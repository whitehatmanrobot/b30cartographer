ee memory if there is no outstanding reference.
        // Note: Length field is not required if the memory 
        // is allocated with NdisAllocateMemoryWithTag.
        //
        NdisFreeMemory(pAdapt, 0, 0);
    }

    DBGPRINT(MUX_LOUD, ("DereferenceAdapter: Adapter %x (%s) new count %d\n", 
                        pAdapt, String, rc));

    return (rc);
}


#if IEEE_VLAN_SUPPORT
NDIS_STATUS
PtHandleRcvTagging(
    IN  PVELAN              pVElan,
    IN  PNDIS_PACKET        Packet,
    IN  OUT PNDIS_PACKET    MyPacket
    )
/*++

Routine Description:

    Parse a received Ethernet frame for 802.1Q tag information.
    If a tag header is present, copy in relevant field values to
    per-packet information to the new packet (MyPacket) used to
    indicate up this frame.

Arguments:

    pVElan   -    Pointer to the VELAN structure.
    Packet   -    Pointer to the indicated packet from the lower miniport
    MyPacket -    Pointer to the new allocated packet
    
Return Value:

    NDIS_STATUS_SUCCESS if the frame was successfully parsed
    and hence should be indicated up this VELAN. NDIS_STATUS_XXX
    otherwise.

--*/
{
    VLAN_TAG_HEADER UNALIGNED * pTagHeader;
    USHORT UNALIGNED *          pTpid;
    PVOID                       pVa;
    ULONG                       BufferLength;
    PNDIS_BUFFER                pNdisBuffer;
    NDIS_PACKET_8021Q_INFO      NdisPacket8021qInfo;
    PVOID                       pDst;
    BOOLEAN                     OnlyOneBuffer = FALSE;
    NDIS_STATUS                 Status;
    
    Status = NDIS_STATUS_SUCCESS;

    do
    {
        pNdisBuffer = Packet->Private.Head;

#ifdef NDIS51_MINIPORT
        NdisQueryBufferSafe(pNdisBuffer, &pVa, &BufferLength, NormalPagePriority );
        if (pVa == NULL)
        {
            Status = NDIS_STATUS_RESOURCES;
            MUX_INCR_STATISTICS(&pVElan->RcvResourceErrors);
            break;
        }
#else
        NdisQueryBuffer(pNdisBuffer, &pVa, &BufferLength);
#endif
    
        //
        // The first NDIS buffer (lookahead) must be longer than
        // ETH_HEADER_SIZE + VLAN_TAG_HEADER_SIZE
        // 
        ASSERT(BufferLength >= ETH_HEADER_SIZE + VLAN_TAG_HEADER_SIZE);

        //
        // Get at the EtherType field.
        //
        pTpid = (USHORT UNALIGNED *)((PUCHAR)pVa + 2 * ETH_LENGTH_OF_ADDRESS);
                    
        //
        // Check if a tag header is present.
        //
        if (*pTpid != TPID)
        {
            //
            // No tag header exists - nothing more to do here.
            // 
            NDIS_PER_PACKET_INFO_FROM_PACKET(MyPacket, Ieee8021QInfo) = 0;                  
            break;
        }

        //
        // We do have a tag header. Parse it further.
        //
        //
        // If E-RIF is present, discard the packet - we don't
        // support this variation.
        //
        pTagHeader = (VLAN_TAG_HEADER UNALIGNED *)(pTpid + 1);
        if (GET_CANONICAL_FORMAT_ID_FROM_TAG(pTagHeader) != 0)
        {
            //
            // Drop the packet
            // 
            Status = NDIS_STATUS_NOT_ACCEPTED;
            MUX_INCR_STATISTICS(&pVElan->RcvFormatErrors);
            break;
        }

        //
        // If there is a VLAN ID in this frame, and we have
        // a configured VLAN ID for this VELAN, check if they
        // are the same - drop if not.
        // 
        if ((GET_VLAN_ID_FROM_TAG(pTagHeader) != 0) &&
             (pVElan->VlanId != 0) &&
             (GET_VLAN_ID_FROM_TAG(pTagHeader) != pVElan->VlanId))
        {
            Status = NDIS_STATUS_NOT_ACCEPTED;
            MUX_INCR_STATISTICS(&pVElan->RcvVlanIdErrors);
            break;
        }

        //
        // Parsed this frame successfully. Copy in relevant
        // parts of the tag header to per-packet information.
        //
        NdisPacket8021qInfo.Value = NULL; // initialize

        COPY_TAG_INFO_FROM_HEADER_TO_PACKET_INFO(NdisPacket8021qInfo, pTagHeader);

        NDIS_PER_PACKET_INFO_FROM_PACKET(MyPacket, Ieee8021QInfo) = 
                                    NdisPacket8021qInfo.Value;

        //
        // Strip off the tag header "in place":
        // 
        pDst = (PVOID)((PUCHAR)pVa + VLAN_TAG_HEADER_SIZE);
        RtlMoveMemory(pDst, pVa, 2 * ETH_LENGTH_OF_ADDRESS);

        //
        // Allocate a new buffer to describe the new first
        // buffer in the packet. This could very well be the
        // only buffer in the packet.
        // 
        NdisAllocateBuffer(&Status,
                            &pNdisBuffer,
                            pVElan->BufferPoolHandle,
                            pDst,
                            BufferLength - VLAN_TAG_HEADER_SIZE);

        if (Status != NDIS_STATUS_SUCCESS)
        {
            //
            // Drop the packet 
            // 
            Status = NDIS_STATUS_RESOURCES;
            MUX_INCR_STATISTICS(&pVElan->RcvResourceErrors);
            break;
        }

        //
        // Prepare the new packet to be indicated up: this consists
        // of the buffer chain starting with the second buffer,
        // appended to the first buffer set up in the previous step.
        //
        MyPacket->Private.Head = NDIS_BUFFER_LINKAGE(Packet->Private.Head);

        //
        // Only one buffer in the packet
        // 
        if (MyPacket->Private.Head == NULL)
        {
            OnlyOneBuffer = TRUE;
        }

        NdisChainBufferAtFront(MyPacket, pNdisBuffer);

        if (OnlyOneBuffer)
        {
            MyPacket->Private.Tail = MyPacket->Private.Head;
        }
        else
        {
            MyPacket->Private.Tail = Packet->Private.Tail;
        }

        break;
    }
    while (FALSE);
                    
    return Status;
}
#endif  // IEEE_VLAN_SUPPORT
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ndis\sys\bus.c ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation

Module Name:

    bus.c

Abstract:

    NDIS wrapper functions to handle specific buses

Author:

    Adam Barr (adamba) 11-Jul-1990

Environment:

    Kernel mode, FSD

Revision History:

    26-Feb-1991  JohnsonA       Added Debugging Code
    10-Jul-1991  JohnsonA       Implement revised Ndis Specs
    01-Jun-1995  JameelH        Re-organization/optimization

--*/


#include <precomp.h>
#pragma hdrstop

#include <stdarg.h>

//
//  Define the module number for debug code.
//
#define MODULE_NUMBER   MODULE_BUS

VOID
NdisReadEisaSlotInformation(
    OUT PNDIS_STATUS            Status,
    IN  NDIS_HANDLE             WrapperConfigurationContext,
    OUT PUINT                   SlotNumber,
    OUT PNDIS_EISA_FUNCTION_INFORMATION EisaData
    )

/*++

Routine Description:

    This routine reads the EISA data from the slot given.

Arguments:

    Status - Status of request to be returned to the user.
    WrapperConfigurationContext - Context passed to MacAddAdapter.
    SlotNumber - the EISA Slot where the card is at.
    EisaData - pointer to a buffer where the EISA configuration is to be returned.

Return Value:

    None.

--*/
{

    DBGPRINT_RAW(DBG_COMP_BUSINFO, DBG_LEVEL_INFO,
            ("==>NdisReadEisaSlotInformation: WrapperConfigurationContext %p\n", WrapperConfigurationContext));
            
    *Status = NDIS_STATUS_NOT_SUPPORTED;

    DBGPRINT_RAW(DBG_COMP_BUSINFO, DBG_LEVEL_INFO,
            ("<==NdisReadEisaSlotInformation: WrapperConfigurationContext %p, Status %lx\n", WrapperConfigurationContext, *Status));
    
    return;
}


VOID
NdisReadEisaSlotInformationEx(
    OUT PNDIS_STATUS            Status,
    IN  NDIS_HANDLE             WrapperConfigurationContext,
    OUT PUINT                   SlotNumber,
    OUT PNDIS_EISA_FUNCTION_INFORMATION *EisaData,
    OUT PUINT                   NumberOfFunctions
    )

/*++

Routine Description:

    This routine reads the EISA data from the slot given.

Arguments:

    Status - Status of request to be returned to the user.
    WrapperConfigurationContext - Context passed to MacAddAdapter.
    SlotNumber - the EISA Slot where the card is at.
    EisaData - pointer to a buffer where the EISA configuration is to be returned.
    NumberOfFunctions - Returns the number of function structures in the EisaData.

Return Value:

    None.

--*/
{
    DBGPRINT_RAW(DBG_COMP_BUSINFO, DBG_LEVEL_INFO,
            ("==>NdisReadEisaSlotInformationEx: WrapperConfigurationContext %p\n", WrapperConfigurationContext));

    *Status = NDIS_STATUS_NOT_SUPPORTED;
    
    DBGPRINT_RAW(DBG_COMP_BUSINFO, DBG_LEVEL_INFO,
            ("<==NdisReadEisaSlotInformationEx: WrapperConfigurationContext %p, Status %lx\n", WrapperConfigurationContext, *Status));

    return;
}


ULONG
NdisImmediateReadPciSlotInformation(
    IN NDIS_HANDLE              WrapperConfigurationContext,
    IN ULONG                    SlotNumber,
    IN ULONG                    Offset,
    IN PVOID                    Buffer,
    IN ULONG                    Length
    )
/*++

Routine Description:

    This routine reads from the PCI configuration space a specified
    length of bytes at a certain offset.

Arguments:

    WrapperConfigurationContext - Context passed to MacAddAdapter.

    SlotNumber - The slot number of the device.

    Offset - Offset to read from

    Buffer - Place to store the bytes

    Length - Number of bytes to read

Return Value:

    Returns the number of bytes read.

--*/
{
    PRTL_QUERY_REGISTRY_TABLE   KeyQueryTable = (PRTL_QUERY_REGISTRY_TABLE)WrapperConfigurationContext;
    PNDIS_MINIPORT_BLOCK        Miniport = (PNDIS_MINIPORT_BLOCK)KeyQueryTable[3].QueryRoutine;
    ULONG                       BytesRead;
    
    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
            ("==>NdisImmediateReadPciSlotInformation: Miniport %p\n", Miniport));

    ASSERT(Miniport != NULL);

    NDIS_WARN(TRUE, Miniport, NDIS_GFLAG_WARN_LEVEL_3,
        ("NdisImmediateReadPciSlotInformation: this API is going away. Use NdisReadPciSlotInformation\n", Miniport));
        
    NDIS_WARN((SlotNumber != 0), Miniport, NDIS_GFLAG_WARN_LEVEL_2,
        ("NdisImmediateReadPciSlotInformation: Miniport %p passes a non-zero SlotNumber to the function\n", Miniport));

    BytesRead = ndisGetSetBusConfigSpace(Miniport,
                                         Offset,
                                         Buffer,
                                         Length,
                                         PCI_WHICHSPACE_CONFIG,
                                         TRUE);             
    DBGPRINT_RAW(DBG_COMP_BUSINFO, DBG_LEVEL_INFO,
            ("<==NdisImmediateReadPciSlotInformation: Miniport %p\n", Miniport));
            
    return BytesRead;
            
}


ULONG
NdisImmediateWritePciSlotInformation(
    IN NDIS_HANDLE              WrapperConfigurationContext,
    IN ULONG                    SlotNumber,
    IN ULONG                    Offset,
    IN PVOID                    Buffer,
    IN ULONG                    Length
    )
/*++

Routine Description:

    This routine writes to the PCI configuration space a specified
    length of bytes at a certain offset.

Arguments:

    WrapperConfigurationContext - Context passed to MacAddAdapter.

    SlotNumber - The slot number of the device.

    Offset - Offset to read from

    Buffer - Place to store the bytes

    Length - Number of bytes to read

Return Value:

    Returns the number of bytes written.

--*/
{
    PRTL_QUERY_REGISTRY_TABLE   KeyQueryTable = (PRTL_QUERY_REGISTRY_TABLE)WrapperConfigurationContext;
    PNDIS_MINIPORT_BLOCK        Miniport = (PNDIS_MINIPORT_BLOCK)KeyQueryTable[3].QueryRoutine;
    ULONG                       BytesWritten;
    
    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
            ("==>NdisImmediateWritePciSlotInformation: Miniport %p\n", Miniport));

    ASSERT(Miniport != NULL);
    
    NDIS_WARN(TRUE, Miniport, NDIS_GFLAG_WARN_LEVEL_3,
        ("NdisImmediateWritePciSlotInformation: this API is going away. Use NdisWritePciSlotInformation\n", Miniport));
        
    NDIS_WARN((SlotNumber != 0), Miniport, NDIS_GFLAG_WARN_LEVEL_2,
        ("NdisImmediateWritePciSlotInformation: Miniport %p passes a non-zero SlotNumber to the function\n", Miniport));
    
    BytesWritten = ndisGetSetBusConfigSpace(Miniport,
                                            Offset,
                                            Buffer,
                                            Length,
                                            PCI_WHICHSPACE_CONFIG,
                                            FALSE);             

    DBGPRINT_RAW(DBG_COMP_BUSINFO, DBG_LEVEL_INFO,
            ("<==NdisImmediateWritePciSlotInformation: Miniport %p\n", Miniport));
            
    return BytesWritten;
}


ULONG
NdisReadPciSlotInformation(
    IN NDIS_HANDLE              NdisAdapterHandle,
    IN ULONG                    SlotNumber,
    IN ULONG                    Offset,
    IN PVOID                    Buffer,
    IN ULONG                    Length
    )
/*++

Routine Description:

    This routine reads from the PCI configuration space a specified
    length of bytes at a certain offset.

Arguments:

    NdisAdapterHandle - Adapter we are talking about.

    SlotNumber - The slot number of the device.

    Offset - Offset to read from

    Buffer - Place to store the bytes

    Length - Number of bytes to read

Return Value:

    Returns the number of bytes read.

--*/
{
    PNDIS_MINIPORT_BLOCK Miniport = (PNDIS_MINIPORT_BLOCK)NdisAdapterHandle;
    ULONG                BytesRead;
    
    DBGPRINT_RAW(DBG_COMP_BUSINFO, DBG_LEVEL_INFO,
            ("==>NdisReadPciSlotInformation: Miniport %p\n", Miniport));

    NDIS_WARN((SlotNumber != 0), Miniport, NDIS_GFLAG_WARN_LEVEL_2,
        ("NdisReadPciSlotInformation: Miniport %p passes a non-zero SlotNumber to the function\n", Miniport));
        
    BytesRead = ndisGetSetBusConfigSpace(Miniport,
                                         Offset,
                                         Buffer,
                                         Length,
                                         PCI_WHICHSPACE_CONFIG,
                                         TRUE);

    DBGPRINT_RAW(DBG_COMP_BUSINFO, DBG_LEVEL_INFO,
            ("<==NdisReadPciSlotInformation: Miniport %p\n", Miniport));
            
    return BytesRead;   
}


ULONG
NdisWritePciSlotInformation(
    IN NDIS_HANDLE              NdisAdapterHandle,
    IN ULONG                    SlotNumber,
    IN ULONG                    Offset,
    IN PVOID                    Buffer,
    IN ULONG                    Length
    )
/*++

Routine Description:

    This routine writes to the PCI configuration space a specified
    length of bytes at a certain offset.

Arguments:

    NdisAdapterHandle - Adapter we are talking about.

    SlotNumber - The slot number of the device.

    Offset - Offset to read from

    Buffer - Place to store the bytes

    Length - Number of bytes to read

Return Value:

    Returns the number of bytes written.

--*/
{
    PNDIS_MINIPORT_BLOCK Miniport = (PNDIS_MINIPORT_BLOCK)NdisAdapterHandle;
    ULONG BytesWritten;
    
    DBGPRINT_RAW(DBG_COMP_BUSINFO, DBG_LEVEL_INFO,
            ("==>NdisWritePciSlotInformation: Miniport %p\n", Miniport));

    NDIS_WARN((SlotNumber != 0), Miniport, NDIS_GFLAG_WARN_LEVEL_2,
        ("NdisWritePciSlotInformation: Miniport %p passes a non-zero SlotNumber to the function\n", Miniport));

    BytesWritten = ndisGetSetBusConfigSpace(Miniport,
                                            Offset,
                                            Buffer,
                                            Length,
                                            PCI_WHICHSPACE_CONFIG,
                                            FALSE);
                            
    DBGPRINT_RAW(DBG_COMP_BUSINFO, DBG_LEVEL_INFO,
            ("<==NdisWritePciSlotInformation: Miniport %p\n", Miniport));
            
    return BytesWritten;
}


NTSTATUS
FASTCALL
ndisQueryBusInterface(
    IN PNDIS_MINIPORT_BLOCK     Miniport
    )
{
    PIRP                    Irp;
    PIO_STACK_LOCATION      IrpSp;
    NTSTATUS                Status;
    PDEVICE_OBJECT          NextDeviceObject;
    BUS_INTERFACE_STANDARD  BusInterfaceStandard = {0};
    
    DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
            ("==>ndisQueryBusInterface: Miniport %p\n", Miniport));

    do {
    
        NextDeviceObject = Miniport->NextDeviceObject; 
        
        //
        //  Allocate an irp to send to PCI bus device driver.
        //
        Irp = IoAllocateIrp((CCHAR)(NextDeviceObject->StackSize + 1),
                            FALSE);
                        
        if (Irp == NULL)
        {
            ASSERT(FALSE);
            Status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }
        
        //
        //  Get the stack location for the next device.
        //
        IrpSp = IoGetNextIrpStackLocation(Irp);
        ASSERT(IrpSp != NULL);
        
        IrpSp->MajorFunction = IRP_MJ_PNP;
        IrpSp->MinorFunction = IRP_MN_QUERY_INTERFACE;
        IrpSp->DeviceObject = NextDeviceObject;
        Irp->IoStatus.Status  = STATUS_NOT_SUPPORTED;
        
        IrpSp->Parameters.QueryInterface.InterfaceType = &GUID_BUS_INTERFACE_STANDARD;
        IrpSp->Parameters.QueryInterface.Size = sizeof (BUS_INTERFACE_STANDARD);
        IrpSp->Parameters.QueryInterface.Version = 1;
        IrpSp->Parameters.QueryInterface.Interface = (PINTERFACE)&BusInterfaceStandard;

        ASSERT(KeGetCurrentIrql() == 0);
        Status = ndisPassIrpDownTheStack(Irp, NextDeviceObject);

        if (NT_SUCCESS(Status))
        {
            Miniport->SetBusData = BusInterfaceStandard.SetBusData;
            Miniport->GetBusData = BusInterfaceStandard.GetBusData;
            Miniport->BusDataContext = BusInterfaceStandard.Context;
            Status = NDIS_STATUS_SUCCESS;
        }

        IoFreeIrp(Irp);
        
    } while (FALSE);

    DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
            ("<==ndisQueryBusInterface: Miniport %p\n", Miniport));

    return Status;
}       

ULONG
ndisGetSetBusConfigSpace(
    IN PNDIS_MINIPORT_BLOCK     Miniport,
    IN ULONG                    Offset,
    IN PVOID                    Buffer,
    IN ULONG                    Length,
    IN ULONG                    WhichSpace,
    IN BOOLEAN                  Read
    )
{
    ULONG   ActualLength = 0;
    
    DBGPRINT_RAW(DBG_COMP_BUSINFO, DBG_LEVEL_INFO,
            ("==>ndisGetSetBusConfigSpace: Miniport %p\n", Miniport));


    if ((Read && MINIPORT_VERIFY_TEST_FLAG(Miniport, fMINIPORT_VERIFY_FAIL_READ_CONFIG_SPACE)) ||
        MINIPORT_VERIFY_TEST_FLAG(Miniport, fMINIPORT_VERIFY_FAIL_WRITE_CONFIG_SPACE))
    {
#if DBG
            DbgPrint("ndisGetSetBusConfigSpace failed to verify miniport %p\n", Miniport);
#endif
            return 0;
    }

    do
    {
        if ((Miniport->SetBusData == NULL) ||  (Miniport->BusDataContext  == NULL))
            break;
            
        ActualLength = (Read ? Miniport->GetBusData : Miniport->SetBusData)(
                                            Miniport->BusDataContext,
                                            WhichSpace,
                                            Buffer,
                                            Offset,
                                            Length);

    } while (FALSE);

    DBGPRINT_RAW(DBG_COMP_BUSINFO, DBG_LEVEL_INFO,
            ("<==ndisGetSetBusConfigSpace: Miniport %p\n", Miniport));
            
    return ActualLength;
}

NDIS_STATUS
ndisTranslateResources(
    IN PNDIS_MINIPORT_BLOCK                 Miniport,
    IN CM_RESOURCE_TYPE                     ResourceType,
    IN PHYSICAL_ADDRESS                     Resource,
    OUT PPHYSICAL_ADDRESS                   pTranslatedResource,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR *   pResourceDescriptor OPTIONAL
    )
{
    UINT                    j;
    PCM_RESOURCE_LIST       AllocatedResources, AllocatedResourcesTranslated;
    PHYSICAL_ADDRESS        Offset;
    PCM_PARTIAL_RESOURCE_LIST pResourceList, pResourceListTranslated;
    NDIS_STATUS             Status = NDIS_STATUS_FAILURE;
    
    DBGPRINT_RAW(DBG_COMP_CONFIG, DBG_LEVEL_INFO,
            ("==>ndisTranslateResources: Miniport %p\n", Miniport));
            
    DBGPRINT_RAW(DBG_COMP_CONFIG, DBG_LEVEL_INFO,
            ("    translating resource  type: %lx, value: %I64x\n", ResourceType, Resource));

    do
    {
        AllocatedResources = Miniport->AllocatedResources;
        AllocatedResourcesTranslated = Miniport->AllocatedResourcesTranslated;

        if ((AllocatedResources == NULL) || (AllocatedResourcesTranslated == NULL))
        {
            Status = NDIS_STATUS_FAILURE;
            break;
        }
        
        pResourceList = &(AllocatedResources->List[0].PartialResourceList);
        pResourceListTranslated = &(AllocatedResourcesTranslated->List[0].PartialResourceList);
        
        for (j = 0; j < pResourceList->Count; j++)
        {
            if (pResourceList->PartialDescriptors[j].Type != ResourceType)
                continue;
                
            switch (ResourceType)
            {
              case CmResourceTypePort:
              case CmResourceTypeMemory:
                Offset.QuadPart = Resource.QuadPart - pResourceList->PartialDescriptors[j].u.Port.Start.QuadPart;
                if ((Offset.QuadPart >= 0) && (Offset.u.HighPart == 0) && 
                    (((ULONG)(Offset.u.LowPart)) < pResourceList->PartialDescriptors[j].u.Port.Length))
                {
                    pTranslatedResource->QuadPart = pResourceListTranslated->PartialDescriptors[j].u.Memory.Start.QuadPart + 
                                                      Offset.QuadPart;
                    Status = NDIS_STATUS_SUCCESS;
                }
                break;
                    
              case CmResourceTypeInterrupt:
                if (Resource.QuadPart == pResourceList->PartialDescriptors[j].u.Interrupt.Level)
                {
                    pTranslatedResource->QuadPart = (LONGLONG)pResourceListTranslated->PartialDescriptors[j].u.Interrupt.Level;
                    Status = NDIS_STATUS_SUCCESS;
                }
                break;
                                    
              case CmResourceTypeDma:
                if (Resource.QuadPart == pResourceList->PartialDescriptors[j].u.Dma.Channel)
                {
                    pTranslatedResource->QuadPart = (LONGLONG)pResourceListTranslated->PartialDescriptors[j].u.Dma.Channel;
                    Status = NDIS_STATUS_SUCCESS;
                }
                break;
            }
            
            if (Status == NDIS_STATUS_SUCCESS)
            {
                DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
                        ("    ndisTranslateResources translated %I64x to %I64x\n", Resource, *pTranslatedResource));
                        
                if (pResourceDescriptor != NULL)
                {
                    *pResourceDescriptor = &pResourceListTranslated->PartialDescriptors[j];
                }
                
                break;
            }
        }
        
    } while (FALSE);
    
    DBGPRINT_RAW(DBG_COMP_CONFIG, DBG_LEVEL_INFO,
            ("<==ndisTranslateResources: Miniport %p, Status %lx\n", Miniport, Status));
            
    return Status;
    
}

ULONG
NdisReadPcmciaAttributeMemory(
    IN NDIS_HANDLE              NdisAdapterHandle,
    IN ULONG                    Offset,
    IN PVOID                    Buffer,
    IN ULONG                    Length
    )
{
    PNDIS_MINIPORT_BLOCK Miniport = (PNDIS_MINIPORT_BLOCK)NdisAdapterHandle;
    PDEVICE_OBJECT       NextDeviceObject;
    ULONG                BytesRead;
    
    DBGPRINT_RAW(DBG_COMP_BUSINFO, DBG_LEVEL_INFO,
            ("==>NdisReadPcmciaAttributeMemory: Miniport %p\n", Miniport));
    
    NextDeviceObject = Miniport->NextDeviceObject;

    ASSERT(NextDeviceObject != NULL);

    //
    // use direct entry points in bus driver to get/set bus data
    //
    BytesRead = ndisGetSetBusConfigSpace(Miniport,
                                         Offset,
                                         Buffer,
                                         Length,
                                         PCCARD_ATTRIBUTE_MEMORY,
                                         TRUE);

    DBGPRINT_RAW(DBG_COMP_BUSINFO, DBG_LEVEL_INFO,
            ("<==NdisReadPcmciaAttributeMemory: Miniport %p, Bytes Read %lx\n", Miniport, BytesRead));

    return BytesRead;
}

ULONG
NdisWritePcmciaAttributeMemory(
    IN NDIS_HANDLE              NdisAdapterHandle,
    IN ULONG                    Offset,
    IN PVOID                    Buffer,
    IN ULONG                    Length
    )
{
    PNDIS_MINIPORT_BLOCK    Miniport = (PNDIS_MINIPORT_BLOCK)NdisAdapterHandle;
    PDEVICE_OBJECT          NextDeviceObject;
    ULONG                   BytesWritten;
    
    DBGPRINT_RAW(DBG_COMP_BUSINFO, DBG_LEVEL_INFO,
            ("==>NdisWritePcmciaAttributeMemory: Miniport %p\n", Miniport));
    
    NextDeviceObject = Miniport->NextDeviceObject;

    ASSERT(NextDeviceObject != NULL);

    BytesWritten = ndisGetSetBusConfigSpace(Miniport,
                                            Offset,
                                            Buffer,
                                            Length,
                                            PCCARD_ATTRIBUTE_MEMORY,
                                            FALSE);             

    DBGPRINT_RAW(DBG_COMP_BUSINFO, DBG_LEVEL_INFO,
            ("<==NdisWritePcmciaAttributeMemory: Miniport %p, Bytes Written %.8x\n", Miniport, BytesWritten));
            
    return BytesWritten;
}


VOID
NdisOverrideBusNumber(
    IN NDIS_HANDLE              WrapperConfigurationContext,
    IN NDIS_HANDLE              MiniportAdapterHandle OPTIONAL,
    IN ULONG                    BusNumber
    )
{
#if DBG
    PRTL_QUERY_REGISTRY_TABLE   KeyQueryTable = (PRTL_QUERY_REGISTRY_TABLE)WrapperConfigurationContext;
    PNDIS_MINIPORT_BLOCK        Miniport = (PNDIS_MINIPORT_BLOCK)KeyQueryTable[3].QueryRoutine;

    NDIS_WARN(TRUE, Miniport, NDIS_GFLAG_WARN_LEVEL_1,
        ("NdisOverrideBusNumber: This API is going away.\n", Miniport));

#endif
}

VOID
NdisReadMcaPosInformation(
    OUT PNDIS_STATUS            Status,
    IN  NDIS_HANDLE             WrapperConfigurationContext,
    OUT PUINT                   ChannelNumber,
    OUT PNDIS_MCA_POS_DATA      McaData
    )
{
    *Status = NDIS_STATUS_NOT_SUPPORTED;
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ndis\sys\common.c ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation

Module Name:

    common.c

Abstract:

    NDIS wrapper functions common to miniports and full mac drivers

Author:

    Adam Barr (adamba) 11-Jul-1990

Environment:

    Kernel mode, FSD

Revision History:

    26-Feb-1991  JohnsonA       Added Debugging Code
    10-Jul-1991  JohnsonA       Implement revised Ndis Specs
    01-Jun-1995  JameelH        Re-organization/optimization
    09-Apr-1996  KyleB          Added resource remove and acquisition routines.

--*/


#include <precomp.h>
#pragma hdrstop

#include <stdarg.h>

//
//  Define the module number for debug code.
//
#define MODULE_NUMBER   MODULE_COMMON

//
// Routines for dealing with making the PKG specific routines pagable
//

VOID FASTCALL
ndisInitializePackage(
    IN  PPKG_REF                pPkg
    )
{
    //
    // Lock and unlock the section to obtain the handle. Subsequent locks will be faster
    //
    pPkg->ImageHandle = MmLockPagableCodeSection(pPkg->Address);
    MmUnlockPagableImageSection(pPkg->ImageHandle);
}


VOID FASTCALL
ndisReferencePackage(
    IN  PPKG_REF                pPkg
    )
{
    ASSERT(CURRENT_IRQL < DISPATCH_LEVEL);
    MmLockPagableSectionByHandle(pPkg->ImageHandle);
    NdisInterlockedIncrement(&pPkg->ReferenceCount);    
}


VOID FASTCALL
ndisDereferencePackage(
    IN  PPKG_REF                pPkg
    )
{
    ASSERT(CURRENT_IRQL < DISPATCH_LEVEL);
    MmUnlockPagableImageSection(pPkg->ImageHandle);
    NdisInterlockedDecrement(&pPkg->ReferenceCount);    
}



NDIS_STATUS
NdisAllocateMemory(
    OUT PVOID *                 VirtualAddress,
    IN  UINT                    Length,
    IN  UINT                    MemoryFlags,
    IN  NDIS_PHYSICAL_ADDRESS   HighestAcceptableAddress
    )
/*++

Routine Description:

    Allocate memory for use by a protocol or a MAC driver

Arguments:

    VirtualAddress - Returns a pointer to the allocated memory.
    Length - Size of requested allocation in bytes.
    MaximumPhysicalAddress - Highest addressable address of the allocated
                            memory.. 0 means highest system memory possible.
    MemoryFlags - Bit mask that allows the caller to specify attributes
                of the allocated memory.  0 means standard memory.

    other options:

        NDIS_MEMORY_CONTIGUOUS
        NDIS_MEMORY_NONCACHED

Return Value:

    NDIS_STATUS_SUCCESS if successful.
    NDIS_STATUS_FAILURE if not successful.  *VirtualAddress will be NULL.


--*/
{
    //
    // Depending on the value of MemoryFlags, we allocate three different
    // types of memory.
    //

    if (MemoryFlags == 0)
    {
        *VirtualAddress = ALLOC_FROM_POOL(Length, NDIS_TAG_ALLOC_MEM);
    }
    else if (MemoryFlags & NDIS_MEMORY_NONCACHED)
    {
        *VirtualAddress = MmAllocateNonCachedMemory(Length);
    }
    else if (MemoryFlags & NDIS_MEMORY_CONTIGUOUS)
    {
        *VirtualAddress = MmAllocateContiguousMemory(Length, HighestAcceptableAddress);
    }
    else
    {
        //
        // invalid flags
        //
        *VirtualAddress = NULL;
    }

    return (*VirtualAddress == NULL) ? NDIS_STATUS_FAILURE : NDIS_STATUS_SUCCESS;
}


NDIS_STATUS
NdisAllocateMemoryWithTag(
    OUT PVOID *                 VirtualAddress,
    IN  UINT                    Length,
    IN  ULONG                   Tag
    )
/*++

Routine Description:

    Allocate memory for use by a protocol or a MAC driver

Arguments:

    VirtualAddress - Returns a pointer to the allocated memory.
    Length - Size of requested allocation in bytes.
    Tag - tag to associate with this memory.

Return Value:

    NDIS_STATUS_SUCCESS if successful.
    NDIS_STATUS_FAILURE if not successful.  *VirtualAddress will be NULL.

--*/
{
    *VirtualAddress = ALLOC_FROM_POOL(Length, Tag);
    return (*VirtualAddress == NULL) ? NDIS_STATUS_FAILURE : NDIS_STATUS_SUCCESS;
}


VOID
NdisFreeMemory(
    IN  PVOID                   VirtualAddress,
    IN  UINT                    Length,
    IN  UINT                    MemoryFlags
    )
/*++

Routine Description:

    Releases memory allocated using NdisAllocateMemory.

Arguments:

    VirtualAddress - Pointer to the memory to be freed.
    Length - Size of allocation in bytes.
    MemoryFlags - Bit mask that allows the caller to specify attributes
                of the allocated memory.  0 means standard memory.

    other options:

        NDIS_MEMORY_CONTIGUOUS
        NDIS_MEMORY_NONCACHED

Return Value:

    None.

--*/
{
    //
    // Depending on the value of MemoryFlags, we allocate three free 3
    // types of memory.
    //

    if (MemoryFlags == 0)
    {
        FREE_POOL(VirtualAddress);
    }
    else if (MemoryFlags & NDIS_MEMORY_NONCACHED)
    {
        MmFreeNonCachedMemory(VirtualAddress, Length);
    }
    else if (MemoryFlags & NDIS_MEMORY_CONTIGUOUS)
    {
        MmFreeContiguousMemory(VirtualAddress);
    }
}


UINT
NdisPacketSize(
    IN  UINT                    ProtocolReservedSize
    )
/*++

Routine Description:

    Returns the size of the packet given the amount of protocolreserved. This lets the caller
    do a better job with # of packets it allocates in a single pool.

Arguments:

    ProtocolReservedSize - Size of protocol reserved in bytes

Return Value:

    None.

--*/
{
    UINT    PacketLength;

    PacketLength = SIZE_PACKET_STACKS + sizeof(NDIS_PACKET_OOB_DATA) + sizeof(NDIS_PACKET_EXTENSION);
    PacketLength += ((FIELD_OFFSET(NDIS_PACKET, ProtocolReserved) + ProtocolReservedSize + sizeof(ULONGLONG) - 1) & ~(sizeof(ULONGLONG) -1));

    //
    // Round the entire length up to a memory allocation alignment.
    //

    PacketLength = (PacketLength + MEMORY_ALLOCATION_ALIGNMENT - 1) & ~(MEMORY_ALLOCATION_ALIGNMENT - 1);

    return(PacketLength);
}


NDIS_HANDLE
NdisGetPoolFromPacket(
    IN  PNDIS_PACKET            Packet
    )
/*++

Routine Description:


Arguments:

    Packet  - Packet in question

Return Value:

    Pool handle corresponding to the packet

--*/
{
    PNDIS_PKT_POOL          Pool = (PNDIS_PKT_POOL)Packet->Private.Pool;

    return(Pool);
}

PNDIS_PACKET_STACK
NdisIMGetCurrentPacketStack(
    IN  PNDIS_PACKET    Packet,
    OUT BOOLEAN *       StacksRemaining
    )
/*++

Routine Description:


Arguments:

    Packet  - Packet in question

Return Value:

    Pointer to the new stack location or NULL if we are out of stacks

--*/
{
    PNDIS_PACKET_STACK  pStack;

    GET_CURRENT_PACKET_STACK_X(Packet, &pStack, StacksRemaining);

    return(pStack);
}


VOID
NdisAllocatePacketPool(
    OUT PNDIS_STATUS            Status,
    OUT PNDIS_HANDLE            PoolHandle,
    IN  UINT                    NumberOfDescriptors,
    IN  UINT                    ProtocolReservedLength
    )
/*++

Routine Description:

    See ndisAllocPacketPool.

Arguments:

    Status - Returns the final status (always NDIS_STATUS_SUCCESS).
    PoolHandle - Returns a pointer to the pool.
    NumberOfDescriptors - Number of packet descriptors needed.
    ProtocolReservedLength - How long the ProtocolReserved field
            should be for packets in this pool.

Return Value:

    None.

--*/
{
    PVOID   Caller, CallersCaller;

    //
    // We save the address of the caller in the pool header, for debugging.
    //
    RtlGetCallersAddress(&Caller, &CallersCaller);

    NdisAllocatePacketPoolEx(Status,
                             PoolHandle,
                             NumberOfDescriptors,
                             0,
                             ProtocolReservedLength);

    if (*Status == NDIS_STATUS_SUCCESS)
    {
        PNDIS_PKT_POOL          Pool = *PoolHandle;

        Pool->Allocator = Caller;
    }
}


VOID
NdisAllocatePacketPoolEx(
    OUT PNDIS_STATUS            Status,
    OUT PNDIS_HANDLE            PoolHandle,
    IN  UINT                    NumberOfDescriptors,
    IN  UINT                    NumberOfOverflowDescriptors,
    IN  UINT                    ProtocolReservedLength
    )
/*++

Routine Description:

    Initializes a packet pool. All packets are the same size for a given pool
    (as determined by ProtocolReservedLength).

    Pool is organized as a pool-header and a number of page-size blocks

Arguments:

    Status - Returns the final status (always NDIS_STATUS_SUCCESS).
    PoolHandle - Returns a pointer to the pool.
    NumberOfDescriptors - Number of packet descriptors needed.
    NumberOfOverflowDescriptors - Number of packet descriptors needed.
    ProtocolReservedLength - How long the ProtocolReserved field should be for packets in this pool.

Return Value:

    None.

--*/
{
    PNDIS_PKT_POOL          Pool;
    PNDIS_PACKET            Packet;
    UINT                    i, NumPkts = (NumberOfDescriptors + NumberOfOverflowDescriptors);
    ULONG                   Tag = NDIS_TAG_PKT_POOL;
    NDIS_HANDLE             tag = *PoolHandle;
    ULONG_PTR               TmpTag;
    PVOID                   Caller, CallersCaller;
    KIRQL                   OldIrql;

    //
    // We save the address of the caller in the pool header, for debugging.
    //
    RtlGetCallersAddress(&Caller, &CallersCaller);

    DBGPRINT_RAW(DBG_COMP_ALL, DBG_LEVEL_INFO,
            ("==>NdisAllocatePacketPoolEx\n"));

    do
    {
        *PoolHandle = NULL;
        TmpTag = (ULONG_PTR)tag & 0xffffff;
        
        if ((TmpTag == '\0PDN') ||
            (TmpTag == '\0pDN'))
        {
            //
            // zero out the high order bit otherwise the verifier gets confused
            //
            Tag = (ULONG)((ULONG_PTR)tag & 0x7fffffff);
        }
    
        Pool = (PNDIS_PKT_POOL)ALLOC_FROM_POOL(sizeof(NDIS_PKT_POOL), Tag);
        if (Pool == NULL)
        {
            *Status = NDIS_STATUS_RESOURCES;
            return;
        }
    
        ZeroMemory(Pool, sizeof(NDIS_PKT_POOL));
    
        Pool->Tag = Tag;
        Pool->PacketLength = (USHORT)NdisPacketSize(ProtocolReservedLength);
        Pool->PktsPerBlock = (USHORT)((PAGE_SIZE - sizeof(NDIS_PKT_POOL_HDR))/Pool->PacketLength);
        if (Pool->PktsPerBlock != 0)
        {
            Pool->MaxBlocks = (NumPkts + Pool->PktsPerBlock - 1)/Pool->PktsPerBlock;
            Pool->BlockSize = PAGE_SIZE;
        }
        
        INITIALIZE_SPIN_LOCK(&Pool->Lock);

        if ((Pool->PktsPerBlock > NumPkts) || (Pool->PktsPerBlock == 0))
        {
            //
            // This is a pool which does not warrant a full-page or packet is too big to fit in
            // one page.
            //
            Pool->BlockSize = (ULONG)(sizeof(NDIS_PKT_POOL_HDR) + (NumPkts*Pool->PacketLength));
            Pool->PktsPerBlock = (USHORT)NumPkts;
            Pool->MaxBlocks = 1;
        }

        Pool->ProtocolId = NDIS_PROTOCOL_ID_DEFAULT;
        InitializeListHead(&Pool->AgingBlocks);
        InitializeListHead(&Pool->FreeBlocks);
        InitializeListHead(&Pool->UsedBlocks);

        ACQUIRE_SPIN_LOCK(&ndisGlobalPacketPoolListLock, &OldIrql);
        InsertHeadList(&ndisGlobalPacketPoolList, &Pool->GlobalPacketPoolList);
        RELEASE_SPIN_LOCK(&ndisGlobalPacketPoolListLock, OldIrql);

            
        //
        // Prime the pool by allocating a packet and freeing it.
        // Aging will ensure it is not immediately freed
        //
        NdisAllocatePacket(Status, &Packet, Pool);
        if (*Status != NDIS_STATUS_SUCCESS)
        {
            ACQUIRE_SPIN_LOCK(&ndisGlobalPacketPoolListLock, &OldIrql);
            RemoveEntryList(&Pool->GlobalPacketPoolList);
            RELEASE_SPIN_LOCK(&ndisGlobalPacketPoolListLock, OldIrql);
            FREE_POOL(Pool);
            break;
        }
        NdisFreePacket(Packet);
        *PoolHandle = Pool;
        Pool->Allocator = Caller;
    } while (FALSE);

    DBGPRINT_RAW(DBG_COMP_ALL, DBG_LEVEL_INFO,
            ("<==NdisAllocatePacketPoolEx, Status %.8x\n", *Status));
}

VOID
NdisFreePacketPool(
    IN  NDIS_HANDLE             PoolHandle
    )
{
    ndisFreePacketPool(PoolHandle, FALSE);
}   

VOID
ndisFreePacketPool(
    IN  NDIS_HANDLE             PoolHandle,
    IN  BOOLEAN                 Verify
    )
{
    PNDIS_PKT_POOL          Pool = (PNDIS_PKT_POOL)PoolHandle;
    PNDIS_PKT_POOL_HDR      Hdr;
    PLIST_ENTRY             List;
    KIRQL                   OldIrql;

    ACQUIRE_SPIN_LOCK(&Pool->Lock, &OldIrql);

    if (Verify)
        ASSERTMSG("NdisFreePacketPool: Freeing non-empty pool\n", IsListEmpty(&Pool->UsedBlocks));
    
    while (!IsListEmpty(&Pool->AgingBlocks))
    {
        List = RemoveHeadList(&Pool->AgingBlocks);
        ASSERT(List != NULL);
        Hdr = CONTAINING_RECORD(List, NDIS_PKT_POOL_HDR, List);
        if (Verify)
            ASSERT(ExQueryDepthSList(&Hdr->FreeList) == Pool->PktsPerBlock);
        Pool->BlocksAllocated --;
        FREE_POOL(Hdr);
    }

    while (!IsListEmpty(&Pool->FreeBlocks))
    {
        List = RemoveHeadList(&Pool->FreeBlocks);
        ASSERT(List != NULL);
        Hdr = CONTAINING_RECORD(List, NDIS_PKT_POOL_HDR, List);
        if (Verify)
            ASSERT(ExQueryDepthSList(&Hdr->FreeList) == Pool->PktsPerBlock);
        Pool->BlocksAllocated --;
        FREE_POOL(Hdr);
    }

    //
    // We should never be executing the code below (see assertmsg() above). This should perhaps
    // be turned into a KeBugCheckEx()
    //
    while (!IsListEmpty(&Pool->UsedBlocks))
    {
        List = RemoveHeadList(&Pool->UsedBlocks);
        ASSERT(List != NULL);
        Hdr = CONTAINING_RECORD(List, NDIS_PKT_POOL_HDR, List);
        FREE_POOL(Hdr);
        Pool->BlocksAllocated --;
    }

    ASSERT(Pool->BlocksAllocated == 0);

    ACQUIRE_SPIN_LOCK_DPC(&ndisGlobalPacketPoolListLock);
    RemoveEntryList(&Pool->GlobalPacketPoolList);
    RELEASE_SPIN_LOCK_DPC(&ndisGlobalPacketPoolListLock);
                                
    RELEASE_SPIN_LOCK(&Pool->Lock, OldIrql);

    FREE_POOL(Pool);
}


#define ndisInitializePacket(_Packet)                                       \
    {                                                                       \
        /*                                                                  \
         * Set the current stack pointer to -1                              \
         */                                                                 \
        CURR_STACK_LOCATION(_Packet) = -1;                                  \
        CURR_XFER_DATA_STACK_LOCATION(_Packet) = -1;                        \
        NDIS_SET_ORIGINAL_PACKET(_Packet, _Packet);                         \
        (_Packet)->Private.Head = NULL;                                     \
        (_Packet)->Private.ValidCounts = FALSE;                             \
        (_Packet)->Private.NdisPacketFlags = fPACKET_ALLOCATED_BY_NDIS;     \
    }

VOID
NdisAllocatePacket(
    OUT PNDIS_STATUS            Status,
    OUT PNDIS_PACKET *          Packet,
    IN  NDIS_HANDLE             PoolHandle
    )
/*++

Routine Description:

    Allocates a packet out of a packet pool.

Arguments:

    Status      -   Returns the final status.
    Packet      -   Return a pointer to the packet.
    PoolHandle  - The packet pool to allocate from.

Return Value:

    NDIS_STATUS_SUCCESS     If we succeeded.
    NDIS_STATUS_RESOURCES   On a failure to allocate or exceeded limit

--*/
{
    PNDIS_PKT_POOL          Pool = (PNDIS_PKT_POOL)PoolHandle;
    PNDIS_PKT_POOL_HDR      Hdr;
    PLIST_ENTRY             List;
    PSINGLE_LIST_ENTRY      SList;
    KIRQL                   OldIrql;

    DBGPRINT(DBG_COMP_ALL, DBG_LEVEL_INFO,
            ("==> NdisAllocatePacket\n"));

    IF_DBG(DBG_COMP_CONFIG, DBG_LEVEL_ERR)
    {
        if (DbgIsNull(Pool))
        {
            DBGPRINT(DBG_COMP_ALL, DBG_LEVEL_ERR,
                    ("NdisAllocatePacket: NULL Pool address\n"));
            DBGBREAK(DBG_COMP_CONFIG, DBG_LEVEL_ERR);
        }

        if (!DbgIsNonPaged(Pool))
        {
            DBGPRINT(DBG_COMP_ALL, DBG_LEVEL_ERR,
                    ("NdisAllocatePacket: Not in NonPaged Memoryn"));
            DBGBREAK(DBG_COMP_CONFIG, DBG_LEVEL_ERR);
        }
    }

    do
    {
        SList = NULL;

        //
        // First check if we have any free packets readily available
        // but get a pointer to Flink before doing the check. this will save us aginst
        // the situations that List can become empty right after the check below.
        //
        List = Pool->FreeBlocks.Flink;
        
        if (List != &Pool->FreeBlocks)
        {
            Hdr = CONTAINING_RECORD(List, NDIS_PKT_POOL_HDR, List);
            SList = InterlockedPopEntrySList(&Hdr->FreeList);

            //
            // Another processor can exhaust the block between the check for non-empty and the pop
            //
            if (SList == NULL)
            {
                goto try_aging_block;
            }

#ifdef NDIS_PKT_POOL_STATISTICS
            InterlockedIncrement(&Pool->cAllocatedFromFreeBlocks);
#endif
            //
            // We got the packet, now see if some book-keeping is in order
            //
            if ((Pool->MaxBlocks > 1) &&
                ExQueryDepthSList(&Hdr->FreeList) == 0)
            {
                //
                // This block is now completely used up. Move it to the UsedBlocks list.
                // The sequence below guarantees that there is no race condition
                //
                ACQUIRE_SPIN_LOCK(&Pool->Lock, &OldIrql);

                RemoveEntryList(&Hdr->List);
                if (ExQueryDepthSList(&Hdr->FreeList) == 0)
                {
                    InsertTailList(&Pool->UsedBlocks, List);
                    Hdr->State = NDIS_PACKET_POOL_BLOCK_USED;

#ifdef NDIS_PKT_POOL_STATISTICS
                    InterlockedIncrement(&Pool->cMovedFreeBlocksToUsed);
#endif
                }
                else
                {
                    InsertHeadList(&Pool->FreeBlocks, &Hdr->List);
                    Hdr->State = NDIS_PACKET_POOL_BLOCK_FREE;
                }

                RELEASE_SPIN_LOCK(&Pool->Lock, OldIrql);
            }
            break;
        }

    try_aging_block:
        //
        // Try taking an aging block and move it into the free block
        //
        ACQUIRE_SPIN_LOCK(&Pool->Lock, &OldIrql);

        if (!IsListEmpty(&Pool->AgingBlocks))
        {
            List = RemoveHeadList(&Pool->AgingBlocks);
            ASSERT (List != NULL);

            Hdr = CONTAINING_RECORD(List, NDIS_PKT_POOL_HDR, List);
            SList = InterlockedPopEntrySList(&Hdr->FreeList);
            ASSERT(SList != NULL);
            InsertHeadList(&Pool->FreeBlocks, List);
            Hdr->State = NDIS_PACKET_POOL_BLOCK_FREE;
            
#ifdef NDIS_PKT_POOL_STATISTICS
            InterlockedIncrement(&Pool->cMovedAgedBlocksToFree);
#endif
            
            if (!IsListEmpty(&Pool->AgingBlocks))
            {
                List = Pool->AgingBlocks.Flink;
                Hdr = CONTAINING_RECORD(List, NDIS_PKT_POOL_HDR, List);
                Pool->NextScavengeTick.QuadPart = Hdr->TimeStamp.QuadPart + PoolAgingTicks.QuadPart;
            }
            else
            {
                Pool->NextScavengeTick.QuadPart = 0;
            }

            RELEASE_SPIN_LOCK(&Pool->Lock, OldIrql);
            break;
        }

        //
        // See if have any head room to allocate more blocks
        //
        if (Pool->BlocksAllocated < Pool->MaxBlocks)
        {
            PUCHAR  pTmp;
            ULONG   i, j;

            Hdr = (PNDIS_PKT_POOL_HDR)ALLOC_FROM_POOL(Pool->BlockSize, Pool->Tag);
            if (Hdr == NULL)
            {
                RELEASE_SPIN_LOCK(&Pool->Lock, OldIrql);
                break;
            }
            NdisZeroMemory(Hdr, Pool->BlockSize);

            Pool->BlocksAllocated ++;
            InitializeListHead(&Hdr->List);
            ExInitializeSListHead(&Hdr->FreeList);
            pTmp = (PUCHAR)Hdr + sizeof(NDIS_PKT_POOL_HDR);
            for (i = Pool->PktsPerBlock; i > 0; i --)
            {
                PNDIS_PACKET    p;
                PNDIS_STACK_RESERVED NSR;

                p = (PNDIS_PACKET)(pTmp + SIZE_PACKET_STACKS);
                p->Private.NdisPacketFlags = 0;
                pTmp += Pool->PacketLength;
#ifdef _WIN64
                InterlockedPushEntrySList(&Hdr->FreeList,
                                            (PSINGLE_LIST_ENTRY)p);
#else

                InterlockedPushEntrySList(&Hdr->FreeList,
                                            (PSINGLE_LIST_ENTRY)(&p->Private.Head));
#endif

                p->Private.Pool = Pool;
                p->Private.Flags = Pool->ProtocolId;
        
                //
                // Set the offset to the out of band data.
                //
                p->Private.NdisPacketOobOffset = (USHORT)(Pool->PacketLength -
                                                            (SIZE_PACKET_STACKS +
                                                             sizeof(NDIS_PACKET_OOB_DATA) +
                                                             sizeof(NDIS_PACKET_EXTENSION)));
                NDIS_SET_ORIGINAL_PACKET(p, p);

                //
                // initialize the spinlocks on packet stack
                //
                for (j = 0; j < ndisPacketStackSize; j++)
                {
                    CURR_STACK_LOCATION(p) = j;
                    NDIS_STACK_RESERVED_FROM_PACKET(p, &NSR);
                    INITIALIZE_SPIN_LOCK(&NSR->Lock);
                }
            }

            SList = InterlockedPopEntrySList(&Hdr->FreeList);

            InsertHeadList(&Pool->FreeBlocks, &Hdr->List);
            Hdr->State = NDIS_PACKET_POOL_BLOCK_FREE;

#ifdef NDIS_PKT_POOL_STATISTICS
            InterlockedIncrement(&Pool->cAllocatedNewBlocks);
#endif

            RELEASE_SPIN_LOCK(&Pool->Lock, OldIrql);
            break;
        }

        RELEASE_SPIN_LOCK(&Pool->Lock, OldIrql);

    } while (FALSE);

    if (SList != NULL)
    {

#ifdef _WIN64
        *Packet = (PNDIS_PACKET)SList;
#else
        *Packet = CONTAINING_RECORD(SList, NDIS_PACKET, Private.Head);
#endif
        *Status = NDIS_STATUS_SUCCESS;
        ndisInitializePacket(*Packet);        
    }
    else
    {
        *Packet = NULL;
        *Status = NDIS_STATUS_RESOURCES;
    }

    DBGPRINT_RAW(DBG_COMP_ALL, DBG_LEVEL_INFO,
            ("<==NdisAllocatePacket, Status %.8x\n", *Status));
}


VOID
NdisFreePacket(
    IN  PNDIS_PACKET    Packet
    )
{
    PNDIS_PKT_POOL_HDR  Hdr;
    PNDIS_PKT_POOL      Pool;
    LARGE_INTEGER       CurrTick;
    KIRQL               OldIrql;
    LARGE_INTEGER       HdrDeadTicks;

    DBGPRINT_RAW(DBG_COMP_ALL, DBG_LEVEL_INFO,
            ("==>NdisFreePacket\n"));

    ASSERT(Packet->Private.NdisPacketFlags & fPACKET_ALLOCATED_BY_NDIS);
    Packet->Private.NdisPacketFlags =0;

    Pool = Packet->Private.Pool;
    Hdr = (PNDIS_PKT_POOL_HDR)((ULONG_PTR)Packet & ~(PAGE_SIZE - 1));
    if (Pool->BlockSize != PAGE_SIZE)
    {
        PLIST_ENTRY List;

        //
        // This pool is not a page-sized pool and so the hdr is not page-aligned.
        // However we know that for such as pool, the Hdr is part of the FreeBlocks
        // list and is never moved to either Used or Aging blocks.
        //
        List = Pool->FreeBlocks.Flink;
        Hdr = CONTAINING_RECORD(List, NDIS_PKT_POOL_HDR, List);
    }

#ifdef _WIN64
    ExInterlockedPushEntrySList(&Hdr->FreeList, (PSINGLE_LIST_ENTRY)Packet, &Pool->Lock);
#else

    ExInterlockedPushEntrySList(&Hdr->FreeList,
                                CONTAINING_RECORD(&Packet->Private.Head, SINGLE_LIST_ENTRY, Next),
                                &Pool->Lock);
#endif

    //
    // If this pool is a pool > 1 block and more than one has been allocated then ...
    //
    // If this hdr is completely free , then move it from the FreeBlocks list to the AgingBlocks and time-stamp it.
    // Add it at the tail since this makes it sorted in time.
    // While we are at it, check the head of the list and age out an entry if it needs to be.
    //
    if (Pool->MaxBlocks > 1)
    {

        if (((Pool->BlocksAllocated > 1) && (ExQueryDepthSList(&Hdr->FreeList) == Pool->PktsPerBlock))||
            (Hdr->State == NDIS_PACKET_POOL_BLOCK_USED))
        {
            ACQUIRE_SPIN_LOCK(&Pool->Lock, &OldIrql);
            if (ExQueryDepthSList(&Hdr->FreeList) == Pool->PktsPerBlock)
            {
                //
                // This block is completely free. Move it to the aged blocks list.
                //
                GET_CURRENT_TICK(&CurrTick);
                Hdr->TimeStamp = CurrTick;
                RemoveEntryList(&Hdr->List);
                InsertTailList(&Pool->AgingBlocks, &Hdr->List);
                Hdr->State = NDIS_PACKET_POOL_BLOCK_AGING;
                
#ifdef NDIS_PKT_POOL_STATISTICS
                InterlockedIncrement(&Pool->cMovedFreeBlocksToAged);
#endif
            }
            else if (Hdr->State == NDIS_PACKET_POOL_BLOCK_USED)
            {
                //
                // This block was completely used up but now has one or more
                // free packet. Move it to the tail of the free blocks list.
                //
                RemoveEntryList(&Hdr->List);
                InsertTailList(&Pool->FreeBlocks, &Hdr->List);
                Hdr->State = NDIS_PACKET_POOL_BLOCK_FREE;
                
#ifdef NDIS_PKT_POOL_STATISTICS
                InterlockedIncrement(&Pool->cMovedUsedBlocksToFree);
#endif
            }
            RELEASE_SPIN_LOCK(&Pool->Lock, OldIrql);
        }

        if (!IsListEmpty(&Pool->AgingBlocks))
        {
            GET_CURRENT_TICK(&CurrTick);
            if (CurrTick.QuadPart > Pool->NextScavengeTick.QuadPart)
            {
                ACQUIRE_SPIN_LOCK(&Pool->Lock, &OldIrql);

                while (!IsListEmpty(&Pool->AgingBlocks))
                {
                    PLIST_ENTRY     List = Pool->AgingBlocks.Flink;

                    Hdr = CONTAINING_RECORD(List, NDIS_PKT_POOL_HDR, List);

                    HdrDeadTicks.QuadPart = Hdr->TimeStamp.QuadPart + PoolAgingTicks.QuadPart;
                    if (CurrTick.QuadPart > HdrDeadTicks.QuadPart)
                    {
                        RemoveHeadList(&Pool->AgingBlocks);
                        
                        if (ExQueryDepthSList(&Hdr->FreeList) != Pool->PktsPerBlock)
                        {
                            //
                            // somehow we ended up allocating a packet from an aged block
                            // put the block back on free list. this can happen if during 
                            // NdisAllocatePacket, right after getting a packet from a free
                            // block list, the block moves to aging list.
                            //
#if DBG
                            DbgPrint("Ndis: pool %p: aged packet pool block at %p contains allocated packets!\n", Pool, Hdr);
#endif
                            InsertHeadList(&Pool->FreeBlocks, &Hdr->List);
                            Hdr->State = NDIS_PACKET_POOL_BLOCK_FREE;
                        }
                        else
                        {
                            FREE_POOL(Hdr);
                            Pool->BlocksAllocated --;
                            
#ifdef NDIS_PKT_POOL_STATISTICS
                            InterlockedIncrement(&Pool->cFreedAgedBlocks);
#endif
                        }
                    } 
                    else
                    {
                        //
                        // Compute the next tick value which represents the earliest time
                        // that we will scavenge this pool again.
                        //
                        Pool->NextScavengeTick.QuadPart = HdrDeadTicks.QuadPart;
                        break;
                    }
                }
                
                RELEASE_SPIN_LOCK(&Pool->Lock, OldIrql);
            }
        }
    }

    DBGPRINT_RAW(DBG_COMP_ALL, DBG_LEVEL_INFO,
            ("<==NdisFreePacket\n"));
}

UINT
NdisPacketPoolUsage(
    IN  PNDIS_HANDLE            PoolHandle
    )
{
    PNDIS_PKT_POOL          Pool = (PNDIS_PKT_POOL)PoolHandle;
    PNDIS_PKT_POOL_HDR      Hdr;
    PLIST_ENTRY             List;
    UINT                    i, NumUsed = 0;

    for (List = Pool->UsedBlocks.Flink; List != &Pool->UsedBlocks; List = List->Flink)
    {
        NumUsed += Pool->PktsPerBlock;
    }

    for (List = Pool->FreeBlocks.Flink; List != &Pool->FreeBlocks; List = List->Flink)
    {
        Hdr = CONTAINING_RECORD(List, NDIS_PKT_POOL_HDR, List);

        NumUsed += (Pool->PktsPerBlock - ExQueryDepthSList(&Hdr->FreeList));
    }

    return NumUsed;
}


VOID
NdisSetPacketPoolProtocolId(
    IN  NDIS_HANDLE             PacketPoolHandle,
    IN  UINT                    ProtocolId
    )
/*++

Routine Description:

    Set the protocol id in the pool and all the packets allocated to the pool. This api has to be called
    prior to any packets that are allocated out of the pool. The code below is linked to the NdisAllocatePacket
    code in that the first empty pool (Pool->BlocksAllocated == 1) is left at the FreeBlocks list and not
    moved to the AgingList.

Arguments:


Return Value:

    None.

--*/
{
    PNDIS_PKT_POOL          Pool = (PNDIS_PKT_POOL)PacketPoolHandle;
    PNDIS_PKT_POOL_HDR      Hdr;
    PLIST_ENTRY             List;
    PNDIS_PACKET            Packet;
    PUCHAR                  p;
    UINT                    j;

    Pool->ProtocolId = ProtocolId;

    ASSERT(IsListEmpty(&Pool->AgingBlocks));
    ASSERT(IsListEmpty(&Pool->UsedBlocks));

    for (List = Pool->FreeBlocks.Flink; List != &Pool->FreeBlocks; List = List->Flink)
    {
        Hdr = CONTAINING_RECORD(List, NDIS_PKT_POOL_HDR, List);
        p = (PUCHAR)Hdr + sizeof(NDIS_PKT_POOL_HDR);

        for (j = Pool->PktsPerBlock; j > 0; j--, p += Pool->PacketLength)
        {
            Packet = (PNDIS_PACKET)(p + SIZE_PACKET_STACKS);
            Packet->Private.Flags |= ProtocolId;
        }
    }
}

VOID
NdisAllocateBufferPool(
    OUT PNDIS_STATUS            Status,
    OUT PNDIS_HANDLE            PoolHandle,
    IN  UINT                    NumberOfDescriptors
    )
/*++

Routine Description:

    Initializes a block of storage so that buffer descriptors can be
    allocated.

Arguments:

    Status - status of the request.
    PoolHandle - handle that is used to specify the pool
    NumberOfDescriptors - Number of buffer descriptors in the pool.

Return Value:

    None.

--*/
{
    *PoolHandle = NULL;
    *Status = NDIS_STATUS_SUCCESS;
}


VOID
NdisFreeBufferPool(
    IN  NDIS_HANDLE             PoolHandle
    )
/*++

Routine Description:

    Terminates usage of a buffer descriptor pool.

Arguments:

    PoolHandle - handle that is used to specify the pool

Return Value:

    None.

--*/
{
    return;
}


VOID
NdisAllocateBuffer(
    OUT PNDIS_STATUS            Status,
    OUT PNDIS_BUFFER *          Buffer,
    IN  NDIS_HANDLE             PoolHandle,
    IN  PVOID                   VirtualAddress,
    IN  UINT                    Length
    )
/*++

Routine Description:

    Creates a buffer descriptor to describe a segment of virtual memory
    allocated via NdisAllocateMemory (which always allocates nonpaged).

Arguments:

    Status - Status of the request.
    Buffer - Pointer to the allocated buffer descriptor.
    PoolHandle - Handle that is used to specify the pool.
    VirtualAddress - The virtual address of the buffer.
    Length - The Length of the buffer.

Return Value:

    None.

--*/
{
    *Status = NDIS_STATUS_FAILURE;
    if ((*Buffer = IoAllocateMdl(VirtualAddress,
                                 Length,
                                 FALSE,
                                 FALSE,
                                 NULL)) != NULL)
    {
        MmBuildMdlForNonPagedPool(*Buffer);
        (*Buffer)->Next = NULL;
        *Status = NDIS_STATUS_SUCCESS;
    }
}


VOID
NdisAdjustBufferLength(
    IN  PNDIS_BUFFER            Buffer,
    IN  UINT                    Length
    )
{
    Buffer->ByteCount = Length;
}


VOID
NdisCopyBuffer(
    OUT PNDIS_STATUS            Status,
    OUT PNDIS_BUFFER *          Buffer,
    IN  NDIS_HANDLE             PoolHandle,
    IN  PVOID                   MemoryDescriptor,
    IN  UINT                    Offset,
    IN  UINT                    Length
    )
/*++

Routine Description:

    Used to create a buffer descriptor given a memory descriptor.

Arguments:

    Status - Status of the request.
    Buffer - Pointer to the allocated buffer descriptor.
    PoolHandle - Handle that is used to specify the pool.
    MemoryDescriptor - Pointer to the descriptor of the source memory.
    Offset - The Offset in the sources memory from which the copy is to begin
    Length - Number of Bytes to copy.

Return Value:

    None.

--*/
{
    PNDIS_BUFFER SourceDescriptor = (PNDIS_BUFFER)MemoryDescriptor;
    PVOID BaseVa = (((PUCHAR)MDL_VA(SourceDescriptor)) + Offset);

    *Status = NDIS_STATUS_FAILURE;
    if ((*Buffer = IoAllocateMdl(BaseVa,
                                 Length,
                                 FALSE,
                                 FALSE,
                                 NULL)) != NULL)
    {
        IoBuildPartialMdl(SourceDescriptor,
                          *Buffer,
                          BaseVa,
                          Length);

        (*Buffer)->Next = NULL;
        *Status = NDIS_STATUS_SUCCESS;
    }
}


VOID
NdisUnchainBufferAtFront(
    IN  OUT PNDIS_PACKET        Packet,
    OUT PNDIS_BUFFER *          Buffer
    )

/*++

Routine Description:

    Takes a buffer off the front of a packet.

Arguments:

    Packet - The packet to be modified.
    Buffer - Returns the packet on the front, or NULL.

Return Value:

    None.

--*/

{
    *Buffer = Packet->Private.Head;

    //
    // If packet is not empty, remove head buffer.
    //

    DBGPRINT_RAW(DBG_COMP_ALL, DBG_LEVEL_INFO,
            ("==>NdisUnchainBufferAtFront\n"));

    IF_DBG(DBG_COMP_CONFIG, DBG_LEVEL_ERR)
    {
        BOOLEAN f = FALSE;
        if (DbgIsNull(Packet))
        {
            DBGPRINT(DBG_COMP_ALL, DBG_LEVEL_ERR,
                    ("UnchainBufferAtFront: Null Packet Pointer\n"));
            f = TRUE;
        }
        if (!DbgIsNonPaged(Packet))
        {
            DBGPRINT(DBG_COMP_ALL, DBG_LEVEL_ERR,
                    ("UnchainBufferAtFront: Packet not in NonPaged Memory\n"));
            f = TRUE;
        }
        if (!DbgIsPacket(Packet))
        {
            DBGPRINT(DBG_COMP_ALL, DBG_LEVEL_ERR,
                    ("UnchainBufferAtFront: Illegal Packet Size\n"));
            f = TRUE;
        }
        if (f)
            DBGBREAK(DBG_COMP_CONFIG, DBG_LEVEL_ERR);
    }

    if (*Buffer != (PNDIS_BUFFER)NULL)
    {
        Packet->Private.Head = (*Buffer)->Next; // may be NULL
        (*Buffer)->Next = (PNDIS_BUFFER)NULL;
        Packet->Private.ValidCounts = FALSE;
    }
    DBGPRINT_RAW(DBG_COMP_ALL, DBG_LEVEL_INFO,
            ("<==NdisUnchainBufferAtFront\n"));
}


VOID
NdisUnchainBufferAtBack(
    IN  OUT PNDIS_PACKET        Packet,
    OUT PNDIS_BUFFER *          Buffer
    )

/*++

Routine Description:

    Takes a buffer off the end of a packet.

Arguments:

    Packet - The packet to be modified.
    Buffer - Returns the packet on the end, or NULL.

Return Value:

    None.

--*/

{
    PNDIS_BUFFER BufP = Packet->Private.Head;
    PNDIS_BUFFER Result;

    DBGPRINT_RAW(DBG_COMP_ALL, DBG_LEVEL_INFO,
            ("==>NdisUnchainBufferAtBack\n"));

    IF_DBG(DBG_COMP_CONFIG, DBG_LEVEL_ERR)
    {
        BOOLEAN f = FALSE;
        if (DbgIsNull(Packet))
        {
            DBGPRINT(DBG_COMP_ALL, DBG_LEVEL_ERR,
                    ("UnchainBufferAtBack: Null Packet Pointer\n"));
            f = TRUE;
        }
        if (!DbgIsNonPaged(Packet))
        {
            DBGPRINT(DBG_COMP_ALL, DBG_LEVEL_ERR,
                    ("UnchainBufferAtBack: Packet not in NonPaged Memory\n"));
            f = TRUE;
        }
        if (!DbgIsPacket(Packet))
        {
            DBGPRINT(DBG_COMP_ALL, DBG_LEVEL_ERR,
                    ("UnchainBufferAtBack: Illegal Packet Size\n"));
            f = TRUE;
        }
        if (f)
            DBGBREAK(DBG_COMP_CONFIG, DBG_LEVEL_ERR);
    }
    if (BufP != (PNDIS_BUFFER)NULL)
    {
        //
        // The packet is not empty, return the tail buffer.
        //

        Result = Packet->Private.Tail;
        if (BufP == Result)
        {
            //
            // There was only one buffer on the queue.
            //

            Packet->Private.Head = (PNDIS_BUFFER)NULL;
        }
        else
        {
            //
            // Determine the new tail buffer.
            //

            while (BufP->Next != Result)
            {
                BufP = BufP->Next;
            }
            Packet->Private.Tail = BufP;
            BufP->Next = NULL;
        }

        Result->Next = (PNDIS_BUFFER)NULL;
        Packet->Private.ValidCounts = FALSE;
    }
    else
    {
        //
        // Packet is empty.
        //

        Result = (PNDIS_BUFFER)NULL;
    }

    *Buffer = Result;
    DBGPRINT_RAW(DBG_COMP_ALL, DBG_LEVEL_INFO,
            ("<==NdisUnchainBufferAtBack\n"));
}



VOID
NdisCopyFromPacketToPacket(
    IN  PNDIS_PACKET            Destination,
    IN  UINT                    DestinationOffset,
    IN  UINT                    BytesToCopy,
    IN  PNDIS_PACKET            Source,
    IN  UINT                    SourceOffset,
    OUT PUINT                   BytesCopied
    )

/*++

Routine Description:

    Copy from an ndis packet to an ndis packet.

Arguments:

    Destination - The packet should be copied in to.

    DestinationOffset - The offset from the beginning of the packet
    into which the data should start being placed.

    BytesToCopy - The number of bytes to copy from the source packet.

    Source - The ndis packet from which to copy data.

    SourceOffset - The offset from the start of the packet from which
    to start copying data.

    BytesCopied - The number of bytes actually copied from the source
    packet.  This can be less than BytesToCopy if the source or destination
    packet is too short.

Return Value:

    None

--*/

{
    //
    // Holds the count of the number of ndis buffers comprising the
    // destination packet.
    //
//    UINT DestinationBufferCount;

    //
    // Holds the count of the number of ndis buffers comprising the
    // source packet.
    //
//    UINT SourceBufferCount;

    //
    // Points to the buffer into which we are putting data.
    //
    PNDIS_BUFFER DestinationCurrentBuffer;

    //
    // Points to the buffer from which we are extracting data.
    //
    PNDIS_BUFFER SourceCurrentBuffer;

    //
    // Holds the virtual address of the current destination buffer.
    //
    PVOID DestinationVirtualAddress;

    //
    // Holds the virtual address of the current source buffer.
    //
    PVOID SourceVirtualAddress;

    //
    // Holds the length of the current destination buffer.
    //
    UINT DestinationCurrentLength;

    //
    // Holds the length of the current source buffer.
    //
    UINT SourceCurrentLength;

    //
    // Keep a local variable of BytesCopied so we aren't referencing
    // through a pointer.
    //
    UINT LocalBytesCopied = 0;

    //
    // Take care of boundary condition of zero length copy.
    //

    *BytesCopied = 0;
    if (!BytesToCopy)
        return;

    //
    // Get the first buffer of the destination.
    //

//    NdisQueryPacket(Destination,
//                    NULL,
//                    &DestinationBufferCount,
//                    &DestinationCurrentBuffer,
//                    NULL);

    DestinationCurrentBuffer = Destination->Private.Head;
    if (DestinationCurrentBuffer == NULL)
        return;

    //
    // Could have a null packet.
    //

//    if (!DestinationBufferCount)
//        return;

//    NdisQueryBuffer(DestinationCurrentBuffer,
//                    &DestinationVirtualAddress,
//                    &DestinationCurrentLength);

    DestinationVirtualAddress = MDL_ADDRESS(DestinationCurrentBuffer);
    DestinationCurrentLength = MDL_SIZE(DestinationCurrentBuffer);


    //
    // Get the first buffer of the source.
    //

//    NdisQueryPacket(Source,
//                    NULL,
//                    &SourceBufferCount,
//                    &SourceCurrentBuffer,
//                    NULL);

    //
    // Could have a null packet.
    //

//    if (!SourceBufferCount)
//        return;


    SourceCurrentBuffer = Source->Private.Head;
    if (SourceCurrentBuffer == NULL)
        return;


//    NdisQueryBuffer(SourceCurrentBuffer,
//                    &SourceVirtualAddress,
//                    &SourceCurrentLength);


    SourceVirtualAddress = MDL_ADDRESS(SourceCurrentBuffer);
    SourceCurrentLength = MDL_SIZE(SourceCurrentBuffer);

    while (LocalBytesCopied < BytesToCopy)
    {
        //
        // Check to see whether we've exhausted the current destination
        // buffer.  If so, move onto the next one.
        //

        if (!DestinationCurrentLength)
        {
//            NdisGetNextBuffer(DestinationCurrentBuffer, &DestinationCurrentBuffer);
            DestinationCurrentBuffer = DestinationCurrentBuffer->Next;

            if (!DestinationCurrentBuffer)
            {
                //
                // We've reached the end of the packet.  We return
                // with what we've done so far. (Which must be shorter
                // than requested.)
                //

                break;

            }

//            NdisQueryBuffer(DestinationCurrentBuffer,
//                            &DestinationVirtualAddress,
//                            &DestinationCurrentLength);

            DestinationVirtualAddress = MDL_ADDRESS(DestinationCurrentBuffer);
            DestinationCurrentLength = MDL_SIZE(DestinationCurrentBuffer);

            continue;
        }


        //
        // Check to see whether we've exhausted the current source
        // buffer.  If so, move onto the next one.
        //

        if (!SourceCurrentLength)
        {
//            NdisGetNextBuffer(SourceCurrentBuffer, &SourceCurrentBuffer);
            SourceCurrentBuffer = SourceCurrentBuffer->Next;

            if (!SourceCurrentBuffer)
            {
                //
                // We've reached the end of the packet.  We return
                // with what we've done so far. (Which must be shorter
                // than requested.)
                //

                break;
            }

//            NdisQueryBuffer(SourceCurrentBuffer,
//                            &SourceVirtualAddress,
//                            &SourceCurrentLength);
            
            SourceVirtualAddress = MDL_ADDRESS(SourceCurrentBuffer);
            SourceCurrentLength = MDL_SIZE(SourceCurrentBuffer);
            
            continue;
        }

        //
        // Try to get us up to the point to start the copy.
        //

        if (DestinationOffset)
        {
            if (DestinationOffset > DestinationCurrentLength)
            {
                //
                // What we want isn't in this buffer.
                //

                DestinationOffset -= DestinationCurrentLength;
                DestinationCurrentLength = 0;
                continue;
            }
            else
            {
                DestinationVirtualAddress = (PCHAR)DestinationVirtualAddress
                                            + DestinationOffset;
                DestinationCurrentLength -= DestinationOffset;
                DestinationOffset = 0;
            }
        }

        //
        // Try to get us up to the point to start the copy.
        //

        if (SourceOffset)
        {
            if (SourceOffset > SourceCurrentLength)
            {
                //
                // What we want isn't in this buffer.
                //

                SourceOffset -= SourceCurrentLength;
                SourceCurrentLength = 0;
                continue;
            }
            else
            {
                SourceVirtualAddress = (PCHAR)SourceVirtualAddress
                                            + SourceOffset;
                SourceCurrentLength -= SourceOffset;
                SourceOffset = 0;
            }
        }

        //
        // Copy the data.
        //

        {
            //
            // Holds the amount of data to move.
            //
            UINT AmountToMove;

            //
            // Holds the amount desired remaining.
            //
            UINT Remaining = BytesToCopy - LocalBytesCopied;

            AmountToMove = ((SourceCurrentLength <= DestinationCurrentLength) ?
                                            (SourceCurrentLength) : (DestinationCurrentLength));

            AmountToMove = ((Remaining < AmountToMove)?
                            (Remaining):(AmountToMove));

            CopyMemory(DestinationVirtualAddress, SourceVirtualAddress, AmountToMove);

            DestinationVirtualAddress =
                (PCHAR)DestinationVirtualAddress + AmountToMove;
            SourceVirtualAddress =
                (PCHAR)SourceVirtualAddress + AmountToMove;

            LocalBytesCopied += AmountToMove;
            SourceCurrentLength -= AmountToMove;
            DestinationCurrentLength -= AmountToMove;
        }
    }

    *BytesCopied = LocalBytesCopied;
}

VOID
NdisUpdateSharedMemory(
    IN  NDIS_HANDLE             NdisAdapterHandle,
    IN  ULONG                   Length,
    IN  PVOID                   VirtualAddress,
    IN  NDIS_PHYSICAL_ADDRESS   PhysicalAddress
    )
/*++

Routine Description:

    Ensures that the data to be read from a shared memory region is
    fully up-to-date.

Arguments:

    NdisAdapterHandle - handle returned by NdisRegisterAdapter.
    Length - The length of the shared memory.
    VirtualAddress - Virtual address returned by NdisAllocateSharedMemory.
    PhysicalAddress - The physical address returned by NdisAllocateSharedMemory.

Return Value:

    None.

--*/

{
    //
    // There is no underlying HAL routine for this anymore,
    // it is not needed.
    //
}


BOOLEAN
ndisCheckPortUsage(
    IN  ULONG                               u32PortNumber,
    IN  PNDIS_MINIPORT_BLOCK                Miniport,
    OUT PULONG                              pTranslatedPort,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR *   pResourceDescriptor
)
/*++

Routine Description:

    This routine checks if a port is currently in use somewhere in the
    system via IoReportUsage -- which fails if there is a conflict.

Arguments:

    BusNumber - Bus number in the system
    PortNumber - Address of the port to access.

Return Value:

    FALSE if there is a conflict, else TRUE

--*/

{
    PHYSICAL_ADDRESS Port;
    PHYSICAL_ADDRESS u64Port;

    Port.QuadPart = u32PortNumber;
    
    if (NDIS_STATUS_SUCCESS == ndisTranslateResources(Miniport,
                                                      CmResourceTypePort,
                                                      Port,
                                                      &u64Port,
                                                      pResourceDescriptor))
    {
        *pTranslatedPort = u64Port.LowPart;
        return TRUE;
    }
    else
    {
        *pTranslatedPort = 0;
        return FALSE;
    }
}


NTSTATUS
ndisStartMapping(
    IN   INTERFACE_TYPE         InterfaceType,
    IN   ULONG                  BusNumber,
    IN   ULONG                  InitialAddress,
    IN   ULONG                  Length,
    IN   ULONG                  AddressSpace,
    OUT PVOID *                 InitialMapping,
    OUT PBOOLEAN                Mapped
    )

/*++

Routine Description:

    This routine initialize the mapping of a address into virtual
    space dependent on the bus number, etc.

Arguments:

    InterfaceType - The bus type (ISA)
    BusNumber - Bus number in the system
    InitialAddress - Address to access.
    Length - Number of bytes from the base address to access.
    InitialMapping - The virtual address space to use when accessing the
     address.
    Mapped - Did an MmMapIoSpace() take place.

Return Value:

    The function value is the status of the operation.

--*/
{
    PHYSICAL_ADDRESS TranslatedAddress;
    PHYSICAL_ADDRESS InitialPhysAddress;

    //
    // Get the system physical address for this card.  The card uses
    // I/O space, except for "internal" Jazz devices which use
    // memory space.
    //

    *Mapped = FALSE;

    InitialPhysAddress.LowPart = InitialAddress;

    InitialPhysAddress.HighPart = 0;

    if (InterfaceType != -1)
    {
        if ((InterfaceType != Isa) &&
            (InterfaceType != PCIBus))
        {
            InterfaceType = Isa;
        }
        
        if (!HalTranslateBusAddress(InterfaceType,              // InterfaceType
                                    BusNumber,                  // BusNumber
                                    InitialPhysAddress,         // Bus Address
                                    &AddressSpace,              // AddressSpace
                                    &TranslatedAddress))        // Translated address
        {
            //
            // It would be nice to return a better status here, but we only get
            // TRUE/FALSE back from HalTranslateBusAddress.
            //

            return NDIS_STATUS_FAILURE;
        }
    }
    else
    {
        TranslatedAddress = InitialPhysAddress;
    }
    
    if (AddressSpace == 0)
    {
        //
        // memory space
        //

        *InitialMapping = MmMapIoSpace(TranslatedAddress, Length, FALSE);

        if (*InitialMapping == NULL)
        {
            return STATUS_INSUFFICIENT_RESOURCES;
        }

        *Mapped = TRUE;
    }
    else
    {
        //
        // I/O space
        //

        *(ULONG_PTR *)InitialMapping = TranslatedAddress.LowPart;
    }

    return STATUS_SUCCESS;
}


NTSTATUS
ndisEndMapping(
    IN  PVOID                   InitialMapping,
    IN  ULONG                   Length,
    IN  BOOLEAN                 Mapped
    )

/*++

Routine Description:

    This routine undoes the mapping of an address into virtual
    space dependent on the bus number, etc.

Arguments:

    InitialMapping - The virtual address space to use when accessing the
     address.
    Length - Number of bytes from the base address to access.
    Mapped - Do we need to call MmUnmapIoSpace.

Return Value:

    The function value is the status of the operation.

--*/
{

    if (Mapped)
    {
        //
        // memory space
        //

        MmUnmapIoSpace(InitialMapping, Length);
    }

    return STATUS_SUCCESS;
}

VOID
ndisImmediateReadWritePort(
    IN  NDIS_HANDLE             WrapperConfigurationContext,
    IN  ULONG                   Port,
    IN  OUT PVOID               Data,
    IN  ULONG                   Size,
    IN  BOOLEAN                 Read
    )
/*++

Routine Description:

    This routine reads from a port a UCHAR.  It does all the mapping,
    etc, to do the read here.

Arguments:

    WrapperConfigurationContext - The handle used to call NdisOpenConfig.

    Port - Port number to read from.

    Data - Pointer to place to store the result.

Return Value:

    None.

--*/

{
    PRTL_QUERY_REGISTRY_TABLE   KeyQueryTable = (PRTL_QUERY_REGISTRY_TABLE)WrapperConfigurationContext;
    PNDIS_MINIPORT_BLOCK        Miniport;
    BOOLEAN                     Mapped = FALSE;
    PVOID                       PortMapping;
    NDIS_INTERFACE_TYPE         BusType;
    ULONG                       BusNumber;
    NTSTATUS                    Status;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR pResourceDescriptor = NULL;

    Miniport = (PNDIS_MINIPORT_BLOCK)KeyQueryTable[3].QueryRoutine;
    BusType = Miniport->BusType;
    BusNumber = Miniport->BusNumber;
    
    ASSERT(Miniport != NULL);
    
    do
    {
        if (Read)
        {
            switch (Size)
            {
                case sizeof (UCHAR):
                    *((PUCHAR)Data) = (UCHAR)0xFF;
                    break;
                    
                case sizeof (USHORT):
                    *((PUSHORT)Data) = (USHORT)0xFFFF;
                    break;
                    
                case sizeof (ULONG):
                    *((PULONG)Data) = (ULONG)0xFFFFFFFF;
                    break;
            }
        }
        
        //
        // Check that the port is available. If so map the space.
        //
        if (ndisCheckPortUsage(Port,
                               Miniport,
                               (PULONG)&PortMapping,
                               &pResourceDescriptor) == FALSE)
        {
            //
            // the resource was not part of already allocated resources,
            // nor could we allocate the resource
            //
            break;
        }

        if (pResourceDescriptor == NULL)
        {
            //
            // the port is not part of allocated resources, try to 
            // temporray allocate the resource
            //
            if (!NT_SUCCESS(Status = ndisStartMapping(BusType,
                                                      BusNumber,
                                                      Port,
                                                      Size,
                                                      (BusType == Internal) ? 0 : 1,
                                                      &PortMapping,
                                                      &Mapped)))
            {
                break;
            }
        }
        else
        {
            Mapped = FALSE;
        }

        if (Read)
        {
            //
            // Read from the port
            //
            switch (Size)
            {
                case sizeof (UCHAR):
                    *((PUCHAR)Data) = READ_PORT_UCHAR((PUCHAR)PortMapping);
                    break;
                    
                case sizeof (USHORT):
                    *((PUSHORT)Data) = READ_PORT_USHORT((PUSHORT)PortMapping);
                    break;
                    
                case sizeof (ULONG):
                    *((PULONG)Data) = READ_PORT_ULONG((PULONG)PortMapping);
                    break;
            }
        }
        else
        {
            //
            // write to the port
            //
            switch (Size)
            {
                case sizeof (UCHAR):
                    WRITE_PORT_UCHAR((PUCHAR)PortMapping, *((PUCHAR)Data));
                    break;
                    
                case sizeof (USHORT):
                    WRITE_PORT_USHORT((PUSHORT)PortMapping, *((PUSHORT)Data));
                    break;
                    
                case sizeof (ULONG):
                    WRITE_PORT_ULONG((PULONG)PortMapping, *((PULONG)Data));
                    break;
            }
        }
        
        if (Mapped)
        {
            //
            // End port mapping
            //

            ndisEndMapping(PortMapping, Size, Mapped);
        }
    } while (FALSE);
}



VOID
NdisImmediateReadPortUchar(
    IN  NDIS_HANDLE             WrapperConfigurationContext,
    IN  ULONG                   Port,
    OUT PUCHAR                  Data
    )
/*++

Routine Description:

    This routine reads from a port a UCHAR.  It does all the mapping,
    etc, to do the read here.

Arguments:

    WrapperConfigurationContext - The handle used to call NdisOpenConfig.

    Port - Port number to read from.

    Data - Pointer to place to store the result.

Return Value:

    None.

--*/

{
#if DBG
    PRTL_QUERY_REGISTRY_TABLE   KeyQueryTable = (PRTL_QUERY_REGISTRY_TABLE)WrapperConfigurationContext;
    PNDIS_MINIPORT_BLOCK        Miniport = (PNDIS_MINIPORT_BLOCK)KeyQueryTable[3].QueryRoutine;

    NDIS_WARN(TRUE, Miniport, NDIS_GFLAG_WARN_LEVEL_1,
        ("NdisImmediateReadPortUchar: this API is going away. use non-Immediate version\n", Miniport));
#endif

    ndisImmediateReadWritePort(WrapperConfigurationContext,
                               Port,
                               (PVOID)Data,
                               sizeof (UCHAR),
                               TRUE);
}

VOID
NdisImmediateReadPortUshort(
    IN  NDIS_HANDLE             WrapperConfigurationContext,
    IN  ULONG                   Port,
    OUT PUSHORT                 Data
    )
/*++

Routine Description:

    This routine reads from a port a USHORT.  It does all the mapping,
    etc, to do the read here.

Arguments:

    WrapperConfigurationContext - The handle used to call NdisOpenConfig.

    Port - Port number to read from.

    Data - Pointer to place to store the result.

Return Value:

    None.

--*/

{
#if DBG
    PRTL_QUERY_REGISTRY_TABLE   KeyQueryTable = (PRTL_QUERY_REGISTRY_TABLE)WrapperConfigurationContext;
    PNDIS_MINIPORT_BLOCK        Miniport = (PNDIS_MINIPORT_BLOCK)KeyQueryTable[3].QueryRoutine;

    NDIS_WARN(TRUE, Miniport, NDIS_GFLAG_WARN_LEVEL_1,
        ("NdisImmediateReadPortUshort: this API is going away. use non-Immediate version\n", Miniport));
#endif

    ndisImmediateReadWritePort(WrapperConfigurationContext,
                               Port,
                               (PVOID)Data,
                               sizeof (USHORT),
                               TRUE);

}

VOID
NdisImmediateReadPortUlong(
    IN  NDIS_HANDLE             WrapperConfigurationContext,
    IN  ULONG                   Port,
    OUT PULONG                  Data
    )
/*++

Routine Description:

    This routine reads from a port a ULONG.  It does all the mapping,
    etc, to do the read here.

Arguments:

    WrapperConfigurationContext - The handle used to call NdisOpenConfig.

    Port - Port number to read from.

    Data - Pointer to place to store the result.

Return Value:

    None.

--*/

{
#if DBG
    PRTL_QUERY_REGISTRY_TABLE   KeyQueryTable = (PRTL_QUERY_REGISTRY_TABLE)WrapperConfigurationContext;
    PNDIS_MINIPORT_BLOCK        Miniport = (PNDIS_MINIPORT_BLOCK)KeyQueryTable[3].QueryRoutine;

    NDIS_WARN(TRUE, Miniport, NDIS_GFLAG_WARN_LEVEL_1,
        ("NdisImmediateReadPortUlong: this API is going away. use non-Immediate version\n", Miniport));
#endif

    ndisImmediateReadWritePort(WrapperConfigurationContext,
                               Port,
                               (PVOID)Data,
                               sizeof (ULONG),
                               TRUE);

}

VOID
NdisImmediateWritePortUchar(
    IN  NDIS_HANDLE             WrapperConfigurationContext,
    IN  ULONG                   Port,
    IN  UCHAR                   Data
    )
/*++

Routine Description:

    This routine writes to a port a UCHAR.  It does all the mapping,
    etc, to do the write here.

Arguments:

    WrapperConfigurationContext - The handle used to call NdisOpenConfig.

    Port - Port number to read from.

    Data - Pointer to place to store the result.

Return Value:

    None.

--*/

{
#if DBG
    PRTL_QUERY_REGISTRY_TABLE   KeyQueryTable = (PRTL_QUERY_REGISTRY_TABLE)WrapperConfigurationContext;
    PNDIS_MINIPORT_BLOCK        Miniport = (PNDIS_MINIPORT_BLOCK)KeyQueryTable[3].QueryRoutine;

    NDIS_WARN(TRUE, Miniport, NDIS_GFLAG_WARN_LEVEL_1,
        ("NdisImmediateWritePortUchar: this API is going away. use non-Immediate version\n", Miniport));
#endif

    ndisImmediateReadWritePort(WrapperConfigurationContext,
                               Port,
                               (PVOID)&Data,
                               sizeof (UCHAR),
                               FALSE);

}

VOID
NdisImmediateWritePortUshort(
    IN  NDIS_HANDLE             WrapperConfigurationContext,
    IN  ULONG                   Port,
    IN  USHORT                  Data
    )
/*++

Routine Description:

    This routine writes to a port a USHORT.  It does all the mapping,
    etc, to do the write here.

Arguments:

    WrapperConfigurationContext - The handle used to call NdisOpenConfig.

    Port - Port number to read from.

    Data - Pointer to place to store the result.

Return Value:

    None.

--*/

{
#if DBG
    PRTL_QUERY_REGISTRY_TABLE   KeyQueryTable = (PRTL_QUERY_REGISTRY_TABLE)WrapperConfigurationContext;
    PNDIS_MINIPORT_BLOCK        Miniport = (PNDIS_MINIPORT_BLOCK)KeyQueryTable[3].QueryRoutine;

    NDIS_WARN(TRUE, Miniport, NDIS_GFLAG_WARN_LEVEL_1,
        ("NdisImmediateWritePortUshort: this API is going away. use non-Immediate version\n", Miniport));
#endif

    ndisImmediateReadWritePort(WrapperConfigurationContext,
                               Port,
                               (PVOID)&Data,
                               sizeof (USHORT),
                               FALSE);

}

VOID
NdisImmediateWritePortUlong(
    IN  NDIS_HANDLE             WrapperConfigurationContext,
    IN  ULONG                   Port,
    IN  ULONG                   Data
    )
/*++

Routine Description:

    This routine writes to a port a ULONG.  It does all the mapping,
    etc, to do the write here.

Arguments:

    WrapperConfigurationContext - The handle used to call NdisOpenConfig.

    Port - Port number to read from.

    Data - Pointer to place to store the result.

Return Value:

    None.

--*/

{
#if DBG
    PRTL_QUERY_REGISTRY_TABLE   KeyQueryTable = (PRTL_QUERY_REGISTRY_TABLE)WrapperConfigurationContext;
    PNDIS_MINIPORT_BLOCK        Miniport = (PNDIS_MINIPORT_BLOCK)KeyQueryTable[3].QueryRoutine;

    NDIS_WARN(TRUE, Miniport, NDIS_GFLAG_WARN_LEVEL_1,
        ("NdisImmediateWritePortUlong: this API is going away. use non-Immediate version\n", Miniport));
#endif

    ndisImmediateReadWritePort(WrapperConfigurationContext,
                               Port,
                               (PVOID)&Data,
                               sizeof (ULONG),
                               FALSE);

}

BOOLEAN
ndisCheckMemoryUsage(
    IN  ULONG                               u32Address,
    IN  PNDIS_MINIPORT_BLOCK                Miniport,
    OUT PULONG                              pTranslatedAddress,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR *   pResourceDescriptor
)
/*++
Routine Description:

    This routine checks if a range of memory is currently in use somewhere
    in the system via IoReportUsage -- which fails if there is a conflict.

Arguments:

    Address - Starting Address of the memory to access.
    Length - Length of memory from the base address to access.

Return Value:

    FALSE if there is a conflict, else TRUE

--*/
{
    PHYSICAL_ADDRESS Address;
    PHYSICAL_ADDRESS u64Address;

    Address.QuadPart = u32Address;

    if (NDIS_STATUS_SUCCESS == ndisTranslateResources(Miniport,
                                                      CmResourceTypeMemory,
                                                      Address,
                                                      &u64Address,
                                                      pResourceDescriptor))
    {
        *pTranslatedAddress = u64Address.LowPart;
        return TRUE;
    }
    else
    {
        *pTranslatedAddress = 0;
        return FALSE;
    }

}

VOID
ndisImmediateReadWriteSharedMemory(
    IN  NDIS_HANDLE             WrapperConfigurationContext,
    IN  ULONG                   SharedMemoryAddress,
    OUT PUCHAR                  Buffer,
    IN  ULONG                   Length,
    IN  BOOLEAN                 Read
    )
/*++

Routine Description:

    This routine read into a buffer from shared ram.  It does all the mapping,
    etc, to do the read here.

Arguments:

    WrapperConfigurationContext - The handle used to call NdisOpenConfig.

    SharedMemoryAddress - The physical address to read from.

    Buffer - The buffer to read into.

    Length - Length of the buffer in bytes.

Return Value:

    None.

--*/

{
    PRTL_QUERY_REGISTRY_TABLE KeyQueryTable = (PRTL_QUERY_REGISTRY_TABLE)WrapperConfigurationContext;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR pResourceDescriptor = NULL;
    NDIS_INTERFACE_TYPE BusType;
    PNDIS_MINIPORT_BLOCK Miniport;
    BOOLEAN             Mapped;
    PVOID               MemoryMapping;
    ULONG               BusNumber;

    Miniport = (PNDIS_MINIPORT_BLOCK)KeyQueryTable[3].QueryRoutine;
    BusType = Miniport->BusType;
    BusNumber = Miniport->BusNumber;

    ASSERT(Miniport != NULL);

    do
    {
        //
        // Check that the memory is available. Map the space
        //

        if (ndisCheckMemoryUsage(SharedMemoryAddress,
                                  Miniport,
                                  (PULONG)&MemoryMapping,
                                  &pResourceDescriptor
                                  ) == FALSE)
        {
            //
            // the resource was not part of already allocated resources,
            // nor could we allocate the resource
            //

            break;
        }
        
        //
        // the port is not part of allocated resources, try to 
        // temporray allocate the resource
        //
        if (!NT_SUCCESS(ndisStartMapping((pResourceDescriptor == NULL) ? BusType : -1,
                                     BusNumber,
                                     SharedMemoryAddress,
                                     Length,
                                     0,
                                     &MemoryMapping,
                                     &Mapped)))
        {
            break;
        }

        if (Read)
        {
            //
            // Read from memory
            //

#ifdef _M_IX86

            memcpy(Buffer, MemoryMapping, Length);

#else

            READ_REGISTER_BUFFER_UCHAR(MemoryMapping,Buffer,Length);

#endif
        }
        else
        {
            //
            // Write to memory
            //

#ifdef _M_IX86

            memcpy(MemoryMapping, Buffer, Length);

#else

            WRITE_REGISTER_BUFFER_UCHAR(MemoryMapping,Buffer,Length);

#endif
        }
        
        //
        // End mapping
        //

        ndisEndMapping(MemoryMapping,
                       Length,
                       Mapped);

    } while (FALSE);
}

VOID
NdisImmediateReadSharedMemory(
    IN  NDIS_HANDLE             WrapperConfigurationContext,
    IN  ULONG                   SharedMemoryAddress,
    OUT PUCHAR                  Buffer,
    IN  ULONG                   Length
    )
/*++

Routine Description:

    This routine read into a buffer from shared ram.  It does all the mapping,
    etc, to do the read here.

Arguments:

    WrapperConfigurationContext - The handle used to call NdisOpenConfig.

    SharedMemoryAddress - The physical address to read from.

    Buffer - The buffer to read into.

    Length - Length of the buffer in bytes.

Return Value:

    None.

--*/

{
#if DBG
    PRTL_QUERY_REGISTRY_TABLE   KeyQueryTable = (PRTL_QUERY_REGISTRY_TABLE)WrapperConfigurationContext;
    PNDIS_MINIPORT_BLOCK        Miniport = (PNDIS_MINIPORT_BLOCK)KeyQueryTable[3].QueryRoutine;

    NDIS_WARN(TRUE, Miniport, NDIS_GFLAG_WARN_LEVEL_1,
        ("NdisImmediateReadSharedMemory: this API is going away. use non-Immediate version\n", Miniport));
#endif

    ndisImmediateReadWriteSharedMemory(
        WrapperConfigurationContext,
        SharedMemoryAddress,
        Buffer,
        Length,
        TRUE
        );
}



VOID
NdisImmediateWriteSharedMemory(
    IN  NDIS_HANDLE             WrapperConfigurationContext,
    IN  ULONG                   SharedMemoryAddress,
    IN  PUCHAR                  Buffer,
    IN  ULONG                   Length
    )
/*++

Routine Description:

    This routine writes a buffer to shared ram.  It does all the mapping,
    etc, to do the write here.

Arguments:

    WrapperConfigurationContext - The handle used to call NdisOpenConfig.

    SharedMemoryAddress - The physical address to write to.

    Buffer - The buffer to write.

    Length - Length of the buffer in bytes.

Return Value:

    None.

--*/

{
#if DBG
    PRTL_QUERY_REGISTRY_TABLE   KeyQueryTable = (PRTL_QUERY_REGISTRY_TABLE)WrapperConfigurationContext;
    PNDIS_MINIPORT_BLOCK        Miniport = (PNDIS_MINIPORT_BLOCK)KeyQueryTable[3].QueryRoutine;

    NDIS_WARN(TRUE, Miniport, NDIS_GFLAG_WARN_LEVEL_1,
        ("NdisImmediateWriteSharedMemory: this API is going away. use non-Immediate version\n", Miniport));
#endif

    ndisImmediateReadWriteSharedMemory(
        WrapperConfigurationContext,
        SharedMemoryAddress,
        Buffer,
        Length,
        FALSE
        );
}


VOID
NdisOpenFile(
    OUT PNDIS_STATUS            Status,
    OUT PNDIS_HANDLE            FileHandle,
    OUT PUINT                   FileLength,
    IN  PNDIS_STRING            FileName,
    IN  NDIS_PHYSICAL_ADDRESS   HighestAcceptableAddress
    )

/*++

Routine Description:

    This routine opens a file for future mapping and reads its contents
    into allocated memory.

Arguments:

    Status - The status of the operation

    FileHandle - A handle to be associated with this open

    FileLength - Returns the length of the file

    FileName - The name of the file

    HighestAcceptableAddress - The highest physical address at which
      the memory for the file can be allocated.

Return Value:

    None.

--*/
{
    NTSTATUS                NtStatus;
    IO_STATUS_BLOCK         IoStatus;
    HANDLE                  NtFileHandle;
    OBJECT_ATTRIBUTES       ObjectAttributes;
    ULONG                   LengthOfFile;
#define PathPrefix      L"\\SystemRoot\\system32\\drivers\\"
    NDIS_STRING             FullFileName;
    PNDIS_FILE_DESCRIPTOR   FileDescriptor;
    PVOID                   FileImage;
    FILE_STANDARD_INFORMATION StandardInfo;

    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
            ("==>NdisOpenFile\n"));

    do
    {
        //
        // Insert the correct path prefix.
        //
        FullFileName.MaximumLength = sizeof(PathPrefix) + FileName->MaximumLength;
        FullFileName.Buffer = ALLOC_FROM_POOL(FullFileName.MaximumLength, NDIS_TAG_FILE_NAME);

        if (FullFileName.Buffer == NULL)
        {
            *Status = NDIS_STATUS_RESOURCES;
            break;
        }
        FullFileName.Length = sizeof (PathPrefix) - sizeof(WCHAR);
        CopyMemory(FullFileName.Buffer, PathPrefix, sizeof(PathPrefix));
        RtlAppendUnicodeStringToString (&FullFileName, FileName);

        DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
                ("  Attempting to open %Z\n", &FullFileName));

        InitializeObjectAttributes(&ObjectAttributes,
                                   &FullFileName,
                                   OBJ_CASE_INSENSITIVE,
                                   NULL,
                                   NULL);

        NtStatus = ZwCreateFile(&NtFileHandle,
                                SYNCHRONIZE | FILE_READ_DATA,
                                &ObjectAttributes,
                                &IoStatus,
                                NULL,
                                0,
                                FILE_SHARE_READ,
                                FILE_OPEN,
                                FILE_SYNCHRONOUS_IO_NONALERT,
                                NULL,
                                0);

        FREE_POOL(FullFileName.Buffer);

        if (!NT_SUCCESS(NtStatus))
        {
            DBGPRINT(DBG_COMP_ALL, DBG_LEVEL_ERR,
                    ("Error opening file %x\n", NtStatus));
            *Status = NDIS_STATUS_FILE_NOT_FOUND;
            break;
        }

        //
        // Query the object to determine its length.
        //

        NtStatus = ZwQueryInformationFile(NtFileHandle,
                                          &IoStatus,
                                          &StandardInfo,
                                          sizeof(FILE_STANDARD_INFORMATION),
                                          FileStandardInformation);

        if (!NT_SUCCESS(NtStatus))
        {
            DBGPRINT(DBG_COMP_ALL, DBG_LEVEL_ERR,
                    ("Error querying info on file %x\n", NtStatus));
            ZwClose(NtFileHandle);
            *Status = NDIS_STATUS_ERROR_READING_FILE;
            break;
        }

        LengthOfFile = StandardInfo.EndOfFile.LowPart;

        DBGPRINT(DBG_COMP_ALL, DBG_LEVEL_INFO,
                ("File length is %d\n", LengthOfFile));

        //
        // Might be corrupted.
        //

        if (LengthOfFile < 1)
        {
            DBGPRINT(DBG_COMP_ALL, DBG_LEVEL_ERR,
                    ("Bad file length %d\n", LengthOfFile));
            ZwClose(NtFileHandle);
            *Status = NDIS_STATUS_ERROR_READING_FILE;
            break;
        }

        //
        // Allocate buffer for this file
        //

        FileImage = ALLOC_FROM_POOL(LengthOfFile, NDIS_TAG_FILE_IMAGE);

        if (FileImage == NULL)
        {
            DBGPRINT(DBG_COMP_ALL, DBG_LEVEL_ERR,
                    ("Could not allocate buffer\n"));
            ZwClose(NtFileHandle);
            *Status = NDIS_STATUS_ERROR_READING_FILE;
            break;
        }

        //
        // Read the file into our buffer.
        //

        NtStatus = ZwReadFile(NtFileHandle,
                              NULL,
                              NULL,
                              NULL,
                              &IoStatus,
                              FileImage,
                              LengthOfFile,
                              NULL,
                              NULL);

        ZwClose(NtFileHandle);

        if ((!NT_SUCCESS(NtStatus)) || (IoStatus.Information != LengthOfFile))
        {
            DBGPRINT(DBG_COMP_ALL, DBG_LEVEL_ERR,
                    ("error reading file %x\n", NtStatus));
            *Status = NDIS_STATUS_ERROR_READING_FILE;
            FREE_POOL(FileImage);
            break;
        }

        //
        // Allocate a structure to describe the file.
        //

        FileDescriptor = ALLOC_FROM_POOL(sizeof(NDIS_FILE_DESCRIPTOR), NDIS_TAG_FILE_DESCRIPTOR);

        if (FileDescriptor == NULL)
        {
            *Status = NDIS_STATUS_RESOURCES;
            FREE_POOL(FileImage);
            break;
        }

        FileDescriptor->Data = FileImage;
        INITIALIZE_SPIN_LOCK (&FileDescriptor->Lock);
        FileDescriptor->Mapped = FALSE;

        *FileHandle = (NDIS_HANDLE)FileDescriptor;
        *FileLength = LengthOfFile;
        *Status = STATUS_SUCCESS;
    } while (FALSE);
    
    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
            ("<==NdisOpenFile, Status %.8x\n", *Status));
}


VOID
NdisCloseFile(
    IN  NDIS_HANDLE             FileHandle
    )

/*++

Routine Description:

    This routine closes a file previously opened with NdisOpenFile.
    The file is unmapped if needed and the memory is freed.

Arguments:

    FileHandle - The handle returned by NdisOpenFile

Return Value:

    None.

--*/
{
    PNDIS_FILE_DESCRIPTOR FileDescriptor = (PNDIS_FILE_DESCRIPTOR)FileHandle;

    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
            ("==>NdisCloseFile\n"));

    FREE_POOL(FileDescriptor->Data);
    FREE_POOL(FileDescriptor);

    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
            ("<==NdisCloseFile\n"));
}


VOID
NdisMapFile(
    OUT PNDIS_STATUS            Status,
    OUT PVOID *                 MappedBuffer,
    IN  NDIS_HANDLE             FileHandle
    )

/*++

Routine Description:

    This routine maps an open file, so that the contents can be accessed.
    Files can only have one active mapping at any time.

Arguments:

    Status - The status of the operation

    MappedBuffer - Returns the virtual address of the mapping.

    FileHandle - The handle returned by NdisOpenFile.

Return Value:

    None.

--*/
{
    PNDIS_FILE_DESCRIPTOR FileDescriptor = (PNDIS_FILE_DESCRIPTOR)FileHandle;

    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
            ("==>NdisMapFile\n"));

    if (FileDescriptor->Mapped == TRUE)
    {
        *Status = NDIS_STATUS_ALREADY_MAPPED;
    }
    else
    {
        FileDescriptor->Mapped = TRUE;
    
        *MappedBuffer = FileDescriptor->Data;
        *Status = STATUS_SUCCESS;
    }

    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
            ("<==NdisMapFile, Status %.8x \n", *Status));
}


VOID
NdisUnmapFile(
    IN  NDIS_HANDLE             FileHandle
    )

/*++

Routine Description:

    This routine unmaps a file previously mapped with NdisOpenFile.
    The file is unmapped if needed and the memory is freed.

Arguments:

    FileHandle - The handle returned by NdisOpenFile

Return Value:

    None.

--*/

{
    PNDIS_FILE_DESCRIPTOR FileDescriptor = (PNDIS_FILE_DESCRIPTOR)FileHandle;

    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
            ("==>NdisUnmapFile\n"));

    FileDescriptor->Mapped = FALSE;

    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
            ("<==NdisUnmapFile\n"));
}


CCHAR
NdisSystemProcessorCount(
    VOID
    )
{
    return KeNumberProcessors;
}


VOID
NdisGetSystemUpTime(
    OUT PULONG                  pSystemUpTime
    )
{
    LARGE_INTEGER TickCount;

    //
    // Get tick count and convert to hundreds of nanoseconds.
    //
    KeQueryTickCount(&TickCount);

    TickCount = RtlExtendedIntegerMultiply(TickCount, (LONG)ndisTimeIncrement);

    TickCount.QuadPart /= 10000;

    ASSERT(TickCount.HighPart == 0);

    *pSystemUpTime = TickCount.LowPart;
}

VOID
NdisGetCurrentProcessorCpuUsage(
    IN  PULONG                  pCpuUsage
    )
{
    ExGetCurrentProcessorCpuUsage(pCpuUsage);
}

VOID
NdisGetCurrentProcessorCounts(
    OUT PULONG          pIdleCount,
    OUT PULONG          pKernelAndUser,
    OUT PULONG          pIndex
    )
{
    ExGetCurrentProcessorCounts(pIdleCount, pKernelAndUser, pIndex);
}

VOID
NdisGetCurrentSystemTime(
    IN  PLARGE_INTEGER          pCurrentTime
    )
{
    KeQuerySystemTime(pCurrentTime);
}

NDIS_STATUS
NdisQueryMapRegisterCount(
    IN  NDIS_INTERFACE_TYPE     BusType,
    OUT PUINT                   MapRegisterCount
    )
{
    *MapRegisterCount = 0;
    return NDIS_STATUS_NOT_SUPPORTED;
}


//
// NDIS Event support
//

VOID
NdisInitializeEvent(
    IN  PNDIS_EVENT             Event
    )
{
    INITIALIZE_EVENT(&Event->Event);
}

VOID
NdisSetEvent(
    IN  PNDIS_EVENT             Event
    )
{
    SET_EVENT(&Event->Event);
}

VOID
NdisResetEvent(
    IN  PNDIS_EVENT             Event
    )
{
    RESET_EVENT(&Event->Event);
}

BOOLEAN
NdisWaitEvent(
    IN  PNDIS_EVENT             Event,
    IN  UINT                    MsToWait
    )
{
    NTSTATUS    Status;
    TIME        Time, *pTime;

    pTime = NULL;
    if (MsToWait != 0)
    {
        ASSERT(CURRENT_IRQL < DISPATCH_LEVEL);
        Time.QuadPart = Int32x32To64(MsToWait, -10000);
        pTime = &Time;
    }

    Status = WAIT_FOR_OBJECT(&Event->Event, pTime);

    return(Status == NDIS_STATUS_SUCCESS);
}

NDIS_STATUS
NdisScheduleWorkItem(
    IN  PNDIS_WORK_ITEM         WorkItem
    )
{
    INITIALIZE_WORK_ITEM((WORK_QUEUE_ITEM *)WorkItem->WrapperReserved,
                         ndisWorkItemHandler,
                         WorkItem);
    XQUEUE_WORK_ITEM((WORK_QUEUE_ITEM *)WorkItem->WrapperReserved, CriticalWorkQueue);

    return NDIS_STATUS_SUCCESS;
}

VOID
ndisWorkItemHandler(
    IN  PNDIS_WORK_ITEM         WorkItem
    )
{
    ASSERT (KeGetCurrentIrql() < DISPATCH_LEVEL);
    (*WorkItem->Routine)(WorkItem, WorkItem->Context);
    ASSERT (KeGetCurrentIrql() < DISPATCH_LEVEL);
}

VOID
NdisInitializeString(
    OUT PNDIS_STRING            Destination,
    IN PUCHAR                   Source
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    WCHAR   *strptr;

    Destination->Length = strlen(Source) * sizeof(WCHAR);
    Destination->MaximumLength = Destination->Length + sizeof(WCHAR);
    Destination->Buffer = ALLOC_FROM_POOL(Destination->MaximumLength, NDIS_TAG_STRING);

    if (Destination->Buffer != NULL)
    {
        strptr = Destination->Buffer;
        while (*Source != '\0')
        {
            *strptr = (WCHAR)*Source;
            Source++;
            strptr++;
        }
        *strptr = UNICODE_NULL;
    }
}

VOID
NdisSetPacketStatus(
    IN          PNDIS_PACKET    Packet,
    IN          NDIS_STATUS     Status,
    IN          NDIS_HANDLE     Handle,
    IN          ULONG           Code
    )
{
#ifdef TRACK_RECEIVED_PACKETS
    NDIS_STATUS     OldStatus =  NDIS_GET_PACKET_STATUS(Packet);

    ndisRcvLogfile[ndisRcvLogfileIndex++] = (ULONG_PTR)Packet;
    ndisRcvLogfile[ndisRcvLogfileIndex++] = (ULONG_PTR)Handle;
    ndisRcvLogfile[ndisRcvLogfileIndex++] = (ULONG_PTR)PsGetCurrentThread();
    ndisRcvLogfile[ndisRcvLogfileIndex++] = (ULONG_PTR)((Status<<24)            |
                                                        ((OldStatus&0xff)<<16)  |
                                                        (Code&0xffff)
                                                        );
#endif
    NDIS_SET_PACKET_STATUS(Packet, Status);
   
}




VOID
NdisCopyFromPacketToPacketSafe(
    IN  PNDIS_PACKET            Destination,
    IN  UINT                    DestinationOffset,
    IN  UINT                    BytesToCopy,
    IN  PNDIS_PACKET            Source,
    IN  UINT                    SourceOffset,
    OUT PUINT                   BytesCopied,
    IN  MM_PAGE_PRIORITY        Priority
    )

/*++

Routine Description:

    Copy from an ndis packet to an ndis packet.

Arguments:

    Destination - The packet should be copied in to.

    DestinationOffset - The offset from the beginning of the packet
    into which the data should start being placed.

    BytesToCopy - The number of bytes to copy from the source packet.

    Source - The ndis packet from which to copy data.

    SourceOffset - The offset from the start of the packet from which
    to start copying data.

    BytesCopied - The number of bytes actually copied from the source
    packet.  This can be less than BytesToCopy if the source or destination
    packet is too short.

Return Value:

    None

--*/

{

    //
    // Points to the buffer into which we are putting data.
    //
    PNDIS_BUFFER DestinationCurrentBuffer;

    //
    // Points to the buffer from which we are extracting data.
    //
    PNDIS_BUFFER SourceCurrentBuffer;

    //
    // Holds the virtual address of the current destination buffer.
    //
    PVOID DestinationVirtualAddress;

    //
    // Holds the virtual address of the current source buffer.
    //
    PVOID SourceVirtualAddress;

    //
    // Holds the length of the current destination buffer.
    //
    UINT DestinationCurrentLength;

    //
    // Holds the length of the current source buffer.
    //
    UINT SourceCurrentLength;

    //
    // Keep a local variable of BytesCopied so we aren't referencing
    // through a pointer.
    //
    UINT LocalBytesCopied = 0;

    //
    // Take care of boundary condition of zero length copy.
    //

    *BytesCopied = 0;
    if (!BytesToCopy)
        return;

    //
    // Get the first buffer of the destination.
    //

//    NdisQueryPacket(Destination,
//                    NULL,
//                    &DestinationBufferCount,
//                    &DestinationCurrentBuffer,
//                    NULL);


    DestinationCurrentBuffer = Destination->Private.Head;
    if (DestinationCurrentBuffer == NULL)
        return;

//    NdisQueryBuffer(DestinationCurrentBuffer,
//                    &DestinationVirtualAddress,
//                    &DestinationCurrentLength);

    DestinationVirtualAddress = MmGetSystemAddressForMdlSafe(DestinationCurrentBuffer, Priority);
    if (DestinationVirtualAddress == NULL)
        return;
    
    DestinationCurrentLength = MmGetMdlByteCount(DestinationCurrentBuffer);

    //
    // Get the first buffer of the source.
    //

//    NdisQueryPacket(Source,
//                    NULL,
//                    &SourceBufferCount,
//                    &SourceCurrentBuffer,
//                    NULL);

    SourceCurrentBuffer = Source->Private.Head;
    if (SourceCurrentBuffer == NULL)
        return;
    


//    NdisQueryBuffer(SourceCurrentBuffer,
//                    &SourceVirtualAddress,
//                    &SourceCurrentLength);
    
    SourceVirtualAddress = MmGetSystemAddressForMdlSafe(SourceCurrentBuffer, Priority);
    if (SourceVirtualAddress == NULL)
        return;

    SourceCurrentLength = MmGetMdlByteCount(SourceCurrentBuffer);

    while (LocalBytesCopied < BytesToCopy)
    {
        //
        // Check to see whether we've exhausted the current destination
        // buffer.  If so, move onto the next one.
        //

        if (!DestinationCurrentLength)
        {
//            NdisGetNextBuffer(DestinationCurrentBuffer, &DestinationCurrentBuffer);

            DestinationCurrentBuffer = DestinationCurrentBuffer->Next;

            if (!DestinationCurrentBuffer)
            {
                //
                // We've reached the end of the packet.  We return
                // with what we've done so far. (Which must be shorter
                // than requested.)
                //

                break;

            }

//            NdisQueryBuffer(DestinationCurrentBuffer,
//                            &DestinationVirtualAddress,
//                            &DestinationCurrentLength);

            DestinationVirtualAddress = MmGetSystemAddressForMdlSafe(DestinationCurrentBuffer, Priority);
            if (DestinationVirtualAddress == NULL)
                break;
            
            DestinationCurrentLength = MmGetMdlByteCount(DestinationCurrentBuffer);
            
            continue;
        }


        //
        // Check to see whether we've exhausted the current source
        // buffer.  If so, move onto the next one.
        //

        if (!SourceCurrentLength)
        {
//            NdisGetNextBuffer(SourceCurrentBuffer, &SourceCurrentBuffer);
            SourceCurrentBuffer = SourceCurrentBuffer->Next;

            if (!SourceCurrentBuffer)
            {
                //
                // We've reached the end of the packet.  We return
                // with what we've done so far. (Which must be shorter
                // than requested.)
                //

                break;
            }

//            NdisQueryBuffer(SourceCurrentBuffer,
//                            &SourceVirtualAddress,
//                            &SourceCurrentLength);
            
            SourceVirtualAddress = MmGetSystemAddressForMdlSafe(SourceCurrentBuffer, Priority);
            if (SourceVirtualAddress == NULL)
                break;

            SourceCurrentLength = MmGetMdlByteCount(SourceCurrentBuffer);
            
            continue;
        }

        //
        // Try to get us up to the point to start the copy.
        //

        if (DestinationOffset)
        {
            if (DestinationOffset > DestinationCurrentLength)
            {
                //
                // What we want isn't in this buffer.
                //

                DestinationOffset -= DestinationCurrentLength;
                DestinationCurrentLength = 0;
                continue;
            }
            else
            {
                DestinationVirtualAddress = (PCHAR)DestinationVirtualAddress
                                            + DestinationOffset;
                DestinationCurrentLength -= DestinationOffset;
                DestinationOffset = 0;
            }
        }

        //
        // Try to get us up to the point to start the copy.
        //

        if (SourceOffset)
        {
            if (SourceOffset > SourceCurrentLength)
            {
                //
                // What we want isn't in this buffer.
                //

                SourceOffset -= SourceCurrentLength;
                SourceCurrentLength = 0;
                continue;
            }
            else
            {
                SourceVirtualAddress = (PCHAR)SourceVirtualAddress
                                            + SourceOffset;
                SourceCurrentLength -= SourceOffset;
                SourceOffset = 0;
            }
        }

        //
        // Copy the data.
        //

        {
            //
            // Holds the amount of data to move.
            //
            UINT AmountToMove;

            //
            // Holds the amount desired remaining.
            //
            UINT Remaining = BytesToCopy - LocalBytesCopied;

            AmountToMove = ((SourceCurrentLength <= DestinationCurrentLength) ?
                                            (SourceCurrentLength) : (DestinationCurrentLength));

            AmountToMove = ((Remaining < AmountToMove)?
                            (Remaining):(AmountToMove));

            CopyMemory(DestinationVirtualAddress, SourceVirtualAddress, AmountToMove);

            DestinationVirtualAddress =
                (PCHAR)DestinationVirtualAddress + AmountToMove;
            SourceVirtualAddress =
                (PCHAR)SourceVirtualAddress + AmountToMove;

            LocalBytesCopied += AmountToMove;
            SourceCurrentLength -= AmountToMove;
            DestinationCurrentLength -= AmountToMove;
        }
    }

    *BytesCopied = LocalBytesCopied;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ndis\sys\config.c ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation

Module Name:

    config.c

Abstract:

    NDIS wrapper functions for full mac drivers configuration/initialization

Author:

    Sean Selitrennikoff (SeanSe) 05-Oct-93
    Jameel Hyder        (JameelH) 01-Jun-95 Re-organization/optimization

Environment:

    Kernel mode, FSD

Revision History:

--*/

#include <precomp.h>

#include <stdarg.h>

//
//  Define the module number for debug code.
//
#define MODULE_NUMBER   MODULE_CONFIG

//
// Requests Used by MAC Drivers
//
//

VOID
NdisInitializeWrapper(
    OUT PNDIS_HANDLE            NdisWrapperHandle,
    IN  PVOID                   SystemSpecific1,
    IN  PVOID                   SystemSpecific2,
    IN  PVOID                   SystemSpecific3
    )
/*++

Routine Description:

    Called at the beginning of every MAC's initialization routine.

Arguments:

    NdisWrapperHandle - A MAC specific handle for the wrapper.

    SystemSpecific1, a pointer to the driver object for the MAC.
    SystemSpecific2, a PUNICODE_STRING containing the location of
                     the registry subtree for this driver.
    SystemSpecific3, unused on NT.

Return Value:

    None.

--*/
{
    NDIS_STATUS             Status;
    PNDIS_WRAPPER_HANDLE    WrapperHandle;
    ULONG                   cbSize;

    UNREFERENCED_PARAMETER (SystemSpecific3);

#if TRACK_UNLOAD
    DbgPrint("NdisInitializeWrapper: DriverObject %p\n",SystemSpecific1);
#endif

    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
            ("==>NdisInitializeWrapper\n"));

    *NdisWrapperHandle = NULL;
    cbSize = sizeof(NDIS_WRAPPER_HANDLE) + ((PUNICODE_STRING)SystemSpecific2)->Length + sizeof(WCHAR);

    WrapperHandle = (PNDIS_WRAPPER_HANDLE)ALLOC_FROM_POOL(cbSize, NDIS_TAG_WRAPPER_HANDLE);

    if (WrapperHandle != NULL)
    {
        *NdisWrapperHandle = WrapperHandle;
        NdisZeroMemory(WrapperHandle, cbSize);
        WrapperHandle->DriverObject = (PDRIVER_OBJECT)SystemSpecific1;
        WrapperHandle->ServiceRegPath.Buffer = (PWSTR)((PUCHAR)WrapperHandle + sizeof(NDIS_WRAPPER_HANDLE));
        WrapperHandle->ServiceRegPath.Length = ((PUNICODE_STRING)SystemSpecific2)->Length;
        WrapperHandle->ServiceRegPath.MaximumLength = WrapperHandle->ServiceRegPath.Length + sizeof(WCHAR);
        NdisMoveMemory(WrapperHandle->ServiceRegPath.Buffer,
                       ((PUNICODE_STRING)SystemSpecific2)->Buffer,
                       WrapperHandle->ServiceRegPath.Length);
    }

    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
            ("<==NdisInitializeWrapper\n"));
}


VOID
NdisTerminateWrapper(
    IN  NDIS_HANDLE             NdisWrapperHandle,
    IN  PVOID                   SystemSpecific
    )
/*++

Routine Description:

    Called at the end of every MAC's termination routine.

Arguments:

    NdisWrapperHandle - The handle returned from NdisInitializeWrapper.

    SystemSpecific - No defined value.

Return Value:

    None.

--*/
{
    PNDIS_WRAPPER_HANDLE    WrapperHandle = (PNDIS_WRAPPER_HANDLE)NdisWrapperHandle;
    PNDIS_M_DRIVER_BLOCK    MiniBlock;


#if TRACK_UNLOAD
    DbgPrint("NdisTerminateWrapper: WrapperHandle %p\n",WrapperHandle);
#endif

    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
            ("==>NdisTerminateWrapper: NdisWrapperHandle %p\n", NdisWrapperHandle));

    UNREFERENCED_PARAMETER(SystemSpecific);

    if ((WrapperHandle != NULL) && (WrapperHandle->DriverObject != NULL))
    {
#if TRACK_UNLOAD
        DbgPrint("NdisTerminateWrapper: DriverObject %p\n",WrapperHandle->DriverObject);
#endif      
        MiniBlock = (PNDIS_M_DRIVER_BLOCK)IoGetDriverObjectExtension(WrapperHandle->DriverObject,
                                                                     (PVOID)NDIS_PNP_MINIPORT_DRIVER_ID);
        if (MiniBlock != NULL)
        {
#if TRACK_UNLOAD
            DbgPrint("NdisTerminateWrapper: MiniBlock %p\n",MiniBlock);
#endif
            MiniBlock->Flags |= fMINIBLOCK_RECEIVED_TERMINATE_WRAPPER;
            //
            //  Miniports should not be terminating the wrapper unless they are failing DriverEntry
            //
            if ((MiniBlock->MiniportQueue != NULL) || (MiniBlock->Flags & fMINIBLOCK_UNLOADING))
            {
                DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
                            ("<==NdisTerminateWrapper\n"));
                return;
            }

            DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
                    ("NdisTerminateWrapper: MiniBlock %p\n", MiniBlock));
            //
            // if the driver is going to fail DriverEntry, we expect it to have enough sense
            // to undo what it is done so far and not to wait for UnloadHandler
            //
            MiniBlock->UnloadHandler = NULL;

            MiniBlock->Flags |= fMINIBLOCK_TERMINATE_WRAPPER_UNLOAD;
            //
            //  call unload entry point since PnP is not going to do it
            //
            ndisMUnload(WrapperHandle->DriverObject);
        }
        else
        {
            FREE_POOL(WrapperHandle);
        }
    }

    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
            ("<==NdisTerminateWrapper\n"));
}


VOID
NdisSetupDmaTransfer(
    OUT PNDIS_STATUS            Status,
    IN  NDIS_HANDLE             NdisDmaHandle,
    IN  PNDIS_BUFFER            Buffer,
    IN  ULONG                   Offset,
    IN  ULONG                   Length,
    IN  BOOLEAN                 WriteToDevice
    )
/*++

Routine Description:

    Sets up the host DMA controller for a DMA transfer. The
    DMA controller is set up to transfer the specified MDL.
    Since we register all DMA channels as non-scatter/gather,
    IoMapTransfer will ensure that the entire MDL is
    in a single logical piece for transfer.

Arguments:

    Status - Returns the status of the request.

    NdisDmaHandle - Handle returned by NdisAllocateDmaChannel.

    Buffer - An NDIS_BUFFER which describes the host memory involved in the
            transfer.

    Offset - An offset within buffer where the transfer should
            start.

    Length - The length of the transfer. VirtualAddress plus Length must not
            extend beyond the end of the buffer.

    WriteToDevice - TRUE for a download operation (host to adapter); FALSE
            for an upload operation (adapter to host).

Return Value:

    None.

--*/
{
    PNDIS_DMA_BLOCK DmaBlock = (PNDIS_DMA_BLOCK)NdisDmaHandle;
    PMAP_TRANSFER mapTransfer = *((PDMA_ADAPTER)DmaBlock->SystemAdapterObject)->DmaOperations->MapTransfer;
    PFLUSH_ADAPTER_BUFFERS flushAdapterBuffers = *((PDMA_ADAPTER)DmaBlock->SystemAdapterObject)->DmaOperations->FlushAdapterBuffers;
    ULONG           LengthMapped;

    //
    // Make sure another request is not in progress.
    //
    if (DmaBlock->InProgress)
    {
        *Status = NDIS_STATUS_RESOURCES;
        return;
    }

    DmaBlock->InProgress = TRUE;

    //
    // Use IoMapTransfer to set up the transfer.
    //
    LengthMapped = Length;

    mapTransfer(DmaBlock->SystemAdapterObject,
                (PMDL)Buffer,
                DmaBlock->MapRegisterBase,
                (PUCHAR)(MDL_VA(Buffer)) + Offset,
                &LengthMapped,
                WriteToDevice);

    if (LengthMapped != Length)
    {
        //
        // Somehow the request could not be mapped competely,
        // this should not happen for a non-scatter/gather adapter.
        //

        flushAdapterBuffers(DmaBlock->SystemAdapterObject,
                            (PMDL)Buffer,
                            DmaBlock->MapRegisterBase,
                            (PUCHAR)(MDL_VA(Buffer)) + Offset,
                            LengthMapped,
                            WriteToDevice);

        DmaBlock->InProgress = FALSE;
        *Status = NDIS_STATUS_RESOURCES;
    }

    else *Status = NDIS_STATUS_SUCCESS;
}


VOID
NdisCompleteDmaTransfer(
    OUT PNDIS_STATUS            Status,
    IN  NDIS_HANDLE             NdisDmaHandle,
    IN  PNDIS_BUFFER            Buffer,
    IN  ULONG                   Offset,
    IN  ULONG                   Length,
    IN  BOOLEAN                 WriteToDevice
    )

/*++

Routine Description:

    Completes a previously started DMA transfer.

Arguments:

    Status - Returns the status of the transfer.

    NdisDmaHandle - Handle returned by NdisAllocateDmaChannel.

    Buffer - An NDIS_BUFFER which was passed to NdisSetupDmaTransfer.

    Offset - the offset passed to NdisSetupDmaTransfer.

    Length - The length passed to NdisSetupDmaTransfer.

    WriteToDevice - TRUE for a download operation (host to adapter); FALSE
            for an upload operation (adapter to host).


Return Value:

    None.

--*/
{
    PNDIS_DMA_BLOCK DmaBlock = (PNDIS_DMA_BLOCK)NdisDmaHandle;
    PFLUSH_ADAPTER_BUFFERS flushAdapterBuffers = *((PDMA_ADAPTER)DmaBlock->SystemAdapterObject)->DmaOperations->FlushAdapterBuffers;
    BOOLEAN         Successful;

    Successful = flushAdapterBuffers(DmaBlock->SystemAdapterObject,
                                     (PMDL)Buffer,
                                     DmaBlock->MapRegisterBase,
                                     (PUCHAR)(MDL_VA(Buffer)) + Offset,
                                     Length,
                                     WriteToDevice);

    *Status = (Successful ? NDIS_STATUS_SUCCESS : NDIS_STATUS_RESOURCES);
    DmaBlock->InProgress = FALSE;
}

#pragma hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ndis\samples\isdnwan\miniport.c ===
/*


    (C) Copyright 1998
        All rights reserved.



  Portions of this software are:

    (C) Copyright 1995, 1999 TriplePoint, Inc. -- http://www.TriplePoint.com
        License to use this software is granted under the terms outlined in
        the TriplePoint Software Services Agreement.

    (C) Copyright 1992 Microsoft Corp. -- http://www.Microsoft.com
        License to use this software is granted under the terms outlined in
        the Microsoft Windows Device Driver Development Kit.



@doc INTERNAL Miniport Miniport_c

@module Miniport.c |

    This module implements the <f DriverEntry> routine, which is the first
    routine called when the driver is loaded into memory.  The Miniport
    initialization and termination routines are also implemented here.

@head3 Contents |
@index class,mfunc,func,msg,mdata,struct,enum | Miniport_c

@end

*/

/* @doc EXTERNAL INTERNAL


@topic 1.0 Miniport Overview |

    The NDIS wrapper provides services to both the Transport drivers, and the
    Miniport drivers.  The NDIS wrapper provides an abstraction layer between
    the two which allows them to interoperate with each other as long as they
    both adhere to the NDIS interfaces defined for Transports and Miniports.

    The NDIS wrapper also provides a set of services which isolate NDIS
    drivers from the specifics of the Operating System (Win 3.11, Win95,
    WinNT), as well as the platform specifics (Processor, Bus, Interrupts).
    The advantage of using the NDIS wrapper is that the Miniport can be
    easily ported to other Windows environments with little or no re-coding.

@iex

    This diagram shows how the NDIS wrapper provides services
    to both the Transport drivers, and the Miniport drivers.

|   +--------+    +-----+    +---------------------------------+
|   |        |    |     |<-->| Windows Transport Drivers (TDI) |
|   |        |    |     |    +---------------------------------+
|   |        |    |     |      | Lower-Edge Functions  ^
|   |        |    |     |      |                       |
|   |        |    |     |      v                       |
|   |        |    |     +--------------------------------------+
|   |        |    |          NDIS Interface Library (Wrapper)  |
|   |        |    |     +--------------------------------------+
|   |Windows |    |     |      |                       ^
|   |   OS   |    |     |      |                       |
|   |Services|    |     |      v Upper-Edge Functions  |
|   |        |    |     |    +---------------------------------+
|   |        |    |     |    | NDIS WAN/TAPI Driver (Miniport) |
|   |        |    |     |    +---------------------------------+
|   |        |    |     |      ^ Lower-Edge Functions
|   |        |    |     |      |
|   |        |    |     |      v
|   |        |    |     +--------------------------------------+
|   |    +---|<-->|------------+                               |
|   +----|---+    +--------------------------------------------+
|        ^
|        |
|        v Hardware Bus
|   +------------------------------+
|   | Network Interface Card (NIC) |
|   +------------------------------+


    An NDISWAN Miniport consists of two, cooperating, drivers contained in
    the same binary.  The NDIS WAN portion of the driver handles packet
    transmits and receives.  While the WAN TAPI portion handles call setup
    and tear down.  Ultimately, it would be better if these two drivers
    were separated, and there was an interface defined between them, but
    history and expedience lead Microsoft to develop this interface model.

    The NDIS WAN side of the Miniport is very similar to an NDIS LAN style
    Miniport, except that some of the NDIS interfaces have been modified to
    support the WAN media type.  The primary difference from the Miniport's
    point of view is the packet structure and different set of NDIS requests,
    and more importantly the line can go up and down.

    The WAN TAPI portion of the Miniport adds significant complexity to the
    Miniport.  The WAN Miniport must provide a pseudo Telephony Service
    Provider Interface (TSPI) which lives under the WAN TSPI.  The NDIS WAN
    TSPI loads under TAPI as the 'real' service provider, and then routes all
    RAS related TAPI events to the Miniport's TSPI.

    The WAN TSPI can have multiple Miniport TSPI's living under its TSPI
    interface.  And since Remote Access Services (RAS) use the TAPI interface
    to place and accept all calls, any Dial Up Networking (DUN) requests
    associated with the Miniport, will end up at the Miniport's TSPI.

@topic 1.1 Call Control Interface |

    FIXME_DESCRIPTION

@topic 1.2 Data Channel Interface |

    FIXME_DESCRIPTION

    Once a call is connected, the data channel associated with the call is
    configured to transmit and receive raw HDLC packets.  Then NDIS is
    notified that the coresponding 'link' is up.  The NDIS documentation
    refers to a data pipe as a link, and the Miniport also uses this
    nomenclature.  In addition, NDIS/RAS wants to see each data channel as a
    separate TAPI line device, so the Miniport also uses this link structure
    to keep track of TAPI calls and lines since they are all mapped 1:1:1.
    Keep this in mind as you read through the code and documentation, because
    I often use line and link interchangeably.

@topic 1.3 Implementation Notes |

    The Miniport is built as a Windows NT Portable Executable (PE) system
    file (.SYS).  The reason for this is that the NDIS WAN interfaces
    routines are currently only defined in the Windows NT version of the NDIS
    library. On Windows 95, the Miniport's binary image file is dynamically
    loaded by the NDIS wrapper during initialization, and runs in Ring-0. A
    Windows 95 version of the NDIS.VXD is available which supports the new
    WAN interrfaces.

@end
*/

/* @doc EXTERNAL INTERNAL


@topic 2.0 Reference Documents |

    The most reliable source of information is provided on the Microsoft
    Developer Network CD.  These documents will provide you with the complete
    NDIS interface requirements and architectural overviews.  In addition,
    there are many addendums and developer notes in the Microsoft Knowledge
    Base.  The most important references are:

@iex
    Product Documentation\DDKs\Windows 95 DDK\Network Drivers\
        Windows 95 Network Drivers
        NDIS 3.0 Netcard Driver
        NDIS Netcard Driver Tester
        Network Driver Installer

    Product Documentation\DDKs\Windows NT DDK\Network Drivers\
        Design Guide\PART2 NDIS 3.0 Driver Design
            Chapters 1-7 discuss all the NDIS interface routines.
            Chapters 8-11,17-18 provide details on WAN/TAPI extensions.

    Product Documentation\SDKs\Win32 SDK\Win32 Telephony\
        This section defines the Windows 95 TAPI implementation.
        Note that this is slightly different than the Windows 3.1 TAPI
        spec.  Pay special attention to lineGetID and line device classes.

@topic 2.1 NDIS Background Information |

    Microsoft is phasing out what they call the NDIS 3.0 Full MAC driver.
    These drivers were written to the NDIS 3.0 specification using the older
    interface routines which have now been augmented by the Miniport
    routines.  The Miniport extensions were added to the NDIS 3.0 interface
    with the goal of making network drivers easier to write.  By using the
    Miniport routines rather than the original NDIS routines, the driver
    writer can make many simplifying assumptions, because the NDIS Wrapper
    will provide most of the queuing, scheduling, and sychronization code.
    The Miniport only has to deal with moving packets on and off the wire.

    The WAN and TAPI extensions were added into the NDIS 3.0 specification
    shortly after the Miniport extensions.  These new WAN interface routines
    are very similar to the LAN interface routines.  The only significant
    difference is the packet format passed between the Miniport and the NDIS
    Wrapper.  The TAPI extensions have no counterpart in the LAN interface,
    so these are all new.  In fact, they turn out to be about half of the
    implementation in a typical WAN/TAPI Miniport.

    It would have been nice if Microsoft would have added these changes and
    bumped the version numbers, but they didn't.  So we are left with a real
    problem trying to identifiy which NDIS 3.0 we are talking about.  The
    thing to remember is that you should avoid the Full MAC interface routines,
    because Microsoft has said that these routines will not be supported in
    future releases.  This is largely due to the Plug-and-Play extensions
    that were introduced in NDIS 3.1 for Windows 95.

    In the near future Microsoft will be adding more features to NDIS 3.5 to
    support advanced routing and some other enhancements.  In addition,
    NDIS 4.0 will be coming out with MANY new features to support ATM and
    other virtual circuit type media.  There are also more TAPI services
    being defined for the NDIS interface.  So don't expect this specification
    to stand still long enough to read it all...

@topic 2.2 Differences between LAN and WAN miniports |

    There are several differences in the way a WAN miniport interfaces
    with NDIS as compared to a LAN miniport driver described in the
    previous chapters. Such differences affect how a WAN driver is
    implemented.

    A WAN miniport must not register a MiniportTransferData handler with
    NdisMRegisterMiniport. Instead, a WAN miniport always passes an entire
    packet to the NdisMWanIndicateReceive function. When
    NdisMWanIndicateReceive returns, the packet has been copied and the
    WAN miniport can reuse the packet resources it allocated.

    WAN miniports provide a MiniportWanSend function instead of a MiniportSend
    function. The MiniportWanSend function accepts an additional parameter that
    specifies a specific data channel on which a packet is to be sent.

    WAN miniports never return NDIS_STATUS_RESOURCES as the status of
    MiniportWanSend or any other MiniportXxx function and cannot call
    NdisMSendResourcesAvailable.

    WAN miniports support a set of WAN-specific OIDs to set and query
    operating characteristics.

    WAN miniports support a set of WAN-specific status indications
    which are passed to NdisMIndicateStatus. These status indications
    report changes in the status of a link.

    WAN miniports call alternative WAN-specific NDIS functions to
    complete the WAN-specific NDIS calls for send and receive. <nl>
    The two completion calls are: <nl>
        NdisMWanIndicateReceiveComplete <nl>
        NdisMWanSendComplete <nl>

    WAN miniport drivers use an NDIS_WAN_PACKET instead of an
    NDIS_PACKET-type descriptor.

    WAN miniport drivers keep a WAN-specific set of statistics.

    WAN miniport drivers never do loopback; it is always
    provided by NDIS.

    WAN miniport drivers cannot be full-duplex miniports.


@end
*/

/* @doc EXTERNAL INTERNAL


@topic 3.0 NDISWAN Miniport Interface |

    The Miniport provides the following functions to the NDIS wrapper.
    The NDIS wrapper calls these functions on behalf of other layers of the
    network software, such as a transport driver bound to a network interface
    card.  The Miniport uses <f NdisMRegisterMiniport> to give NDIS a list of
    entry points for the supported routines, unused routines are set to NULL.

    Some of the Miniport functions are synchronous, while others can
    complete either synchronously or asynchronously. The Miniport must
    indicate to the NDIS library when an asynchronous function has completed
    by calling the appropriate NDIS library completion function. The NDIS
    library can subsequently call completion functions in other layers of the
    network software for postprocessing, if necessary.

    <f DriverEntry> Called by the operating system to activate and
    initialize the Miniport. (Synchronous)

    <f MiniportCheckForHang> Checks the internal state of the network interface
    card. (Synchronous)

    <f MiniportHalt> Halts the network interface card so it is no longer
    functioning. (Synchronous)

    <f MiniportInitialize> Initializes the network interface card. (Synchronous)

    <f MiniportQueryInformation> Queries the capabilities and current status of
    the Miniport. NDISTAPI functions are also passed through this
    interface. (Asynchronous)

    <f MiniportReset> Issues a hardware reset to the network interface card.
    (Asynchronous)

    <f MiniportWanSend> Transmits a packet through the network interface card
    onto the network. (Asynchronous)

    <f MiniportSetInformation> Changes (sets) information about the Miniport
    driver.  NDISTAPI functions are also passed through this interface.
    (Asynchronous)

@iex

    The following routines are defined in the NDIS Miniport interface,
    but they are not used by this implementation.

    MiniportISR                     NOT USED by this Miniport.

    Associated with each Miniport upper-edge driver function that may operate
    asynchronously is a corresponding completion function in the NDIS library.
    When the Miniport function returns a status of NDIS_STATUS_PENDING
    indicating asynchronous operation, this is the completion function that
    must be called when the Miniport has finally completed the request.

@iex

    This table shows how each asynchronous Miniport routine maps to its
    associated NDIS completion routine.

    Miniport Function               Asynchronous Completion Routine
    -----------------               -------------------------------
    MiniportQueryInformation        NdisMQueryInformationComplete
    MiniportReset                   NdisMResetComplete
    MiniportWanSend                 NdisMSendComplete
    MiniportSetInformation          NdisMSetInformationComplete
    MiniportTransferData            NdisMTransferDataComplete (NOT USED)

@end
*/

/* @doc EXTERNAL INTERNAL


@topic 3.1 Initialization and Setup |

    The following diagram shows the typical call sequence used during system
    initialization.  Typically this occurs once when Windows loads.  However,
    NDIS does allow drivers to be unloaded, and then reloaded at any time, so
    you must be prepared to handle this event.

@iex

|   NDIS Wrapper                 |          Miniport
|   -----------------------------+------------------------------------
|   Load NDIS Wrapper            |
|                      >---------+---->+    DriverEntry
|                                |     |
|   NdisMInitializeWrapper  <----+---->+
|                                |     |
|   NdisMRegisterMiniport   <----+---->+
|                                |     |
|                      <---------+----<+
|       ~~~ TIME PASSES
|                      >---------+---->+    MiniportInitialize
|                                |     |
|   NdisOpenConfiguration    <---+---->+
|                                |     |
|   NdisReadConfiguration... <---+---->+
|                                |     |
|   NdisCloseConfiguration   <---+---->+
|                                |     |
|   NdisMSetAttributes       <---+---->+
|                                |     |
|                      <---------+----<+
|       ~~~ TIME PASSES
|                      >---------+---->+    MiniportQueryInformation
|                      <---------+----<+       OID_WAN_CURRENT_ADDRESS
|       ~~~ TIME PASSES
|                      >---------+---->+    MiniportQueryInformation
|                      <---------+----<+       OID_WAN_MEDIUM_SUBTYPE
|       ~~~ TIME PASSES
|                      >---------+---->+    MiniportQueryInformation
|                      <---------+----<+       OID_WAN_GET_INFO

@end
*/

/* @doc EXTERNAL INTERNAL


@topic 3.6 Reset and Shutdown |

    Aside from the initialization and run-time operations, the Miniport must
    support being reset <f MiniportReset> and being shutdown <f MiniportHalt>.

    The reset routine is only called when the NDIS wrapper detects an error
    with the Miniport's operation.  There are two ways in which the wrapper
    determines an error condition.  First, the NDIS wrapper calls
    <f MiniportCheckForHang> once every couple seconds to ask the Miniport
    if it thinks it needs to be reset.  Second, the wrapper may detect a
    timeout condition on an outstanding request to the Miniport.  These are
    both fail-safe conditions which should not happen under normal, run-time
    conditions.

    <f Note>: My feeling is that if you see a reset call, the Miniport is
    broken, and you should find and fix the bug -- not the symptom.

    The shutdown routine is normally only called when Windows is shutting
    down.  However, with the advent of plug and play devices, it is likely to
    become more common to get a shutdown request followed by another load
    request in the same Windows session.  So it is very important to clean up
    properly when <f MiniportHalt> is called. All memory and other resources
    must be released, and all intefaces must be properly closed so they can
    release their resources too.

    NDIS will cleanup any outstanding requests, but the Miniport should
    bring down all calls, and close all TAPI lines using synchronous
    TAPI events.  You can't depend on any NDIS WAN or TAPI events because
    none will be passed through the wrapper as long as the reset is in
    progress.

@end
*/

#define  __FILEID__             MINIPORT_DRIVER_OBJECT_TYPE
// Unique file ID for error logging

#include "Miniport.h"                   // Defines all the miniport objects

#include "TpiParam.h"

#if defined(NDIS_LCODE)
#   pragma NDIS_LCODE   // Windows 95 wants this code locked down!
#   pragma NDIS_LDATA
#endif


DBG_STATIC NDIS_HANDLE          g_NdisWrapperHandle = NULL;
// Receives the context value representing the Miniport wrapper
// as returned from NdisMInitializeWrapper.

NDIS_PHYSICAL_ADDRESS           g_HighestAcceptableAddress =
                                        NDIS_PHYSICAL_ADDRESS_CONST(-1,-1);
// This constant is used for places where NdisAllocateMemory needs to be
// called and the g_HighestAcceptableAddress does not matter.


/* @doc INTERNAL Miniport Miniport_c DriverEntry


@func

    <f DriverEntry> is called by the operating system when a driver is loaded.
    This function creates an association between the miniport NIC driver and
    the NDIS library and registers the miniport's characteristics with NDIS.

    <f DriverEntry> calls NdisMInitializeWrapper and then NdisMRegisterMiniport.
    <f DriverEntry> passes both pointers it received to NdisMInitializeWrapper,
    which returns a wrapper handle.  <f DriverEntry> passes the wrapper handle to
    NdisMRegisterMiniport.

    The registry contains data that is persistent across system boots, as well
    as configuration information generated anew at each system boot.  During
    driver installation, data describing the driver and the NIC is stored in
    the registry. The registry contains adapter characteristics that are read
    by the NIC driver to initialize itself and the NIC. See the Kernel-Mode
    Driver Design Guide for more about the registry and the Programmer's Guide
    for more information about the .inf files that install the driver and
    write to the registry.

@comm

    Every miniport driver must provide a function called DriverEntry.  By
    convention, DriverEntry is the entry point address for a driver.  If a
    driver does not use the name DriverEntry, the driver developer must define
    the name of its entry function to the linker so that the entry point
    address can be known into the OS loader.

    It is interesting to note, that at the time DriverEntry is called, the OS
    doesn't know that the driver is an NDIS driver.  The OS thinks it is just
    another driver being loaded.  So it is possible to do anything any driver
    might do at this point.  Since NDIS is the one who requested this driver
    to be loaded, it would be polite to register with the NDIS wrapper.  But
    you can also hook into other OS functions to use and provide interfaces
    outside the NDIS wrapper.  (Not recommended for the faint of heart).<nl>

    NDIS miniports and intermediate drivers carry out two basic tasks in
    their <f DriverEntry> functions:<nl>

    1)  Call NdisMInitializeWrapper to notify the NDIS library that the
        driver is about to register itself as a miniport.
        NDIS sets up the state it needs to track the driver and
        returns an NdisWrapperHandle, which the driver saves for
        subsequent calls to NdisXxx configuration and initialization
        functions.<nl>

    2)  Fill in an NDISXX_MINIPORT_CHARCTERISTICS structure with the
        appropriate version numbers and the entry points for
        driver-supplied MiniportXxx functions and, then, call
        NdisMRegisterMiniport or NdisIMRegisterLayeredMiniport.
        Usually, NIC drivers call NdisMRegisterMiniport, as do
        intermediate drivers that export only a set of MiniportXxx
        functions. Usually, NDIS intermediate drivers call
        NdisIMRegisterLayeredMiniport, which effectively defers the
        initialization of such a driver's virtual NIC until the driver
        calls NdisIMInitializeDeviceInstance from its
        ProtocolBindAdapter function.<nl>

    <f DriverEntry> can allocate the NDISXX_MINIPORT_CHARACTERISTICS
    structure on the stack since the NDIS library copies the relevant
    information to its own storage. DriverEntry should clear the memory
    for this structure with NdisZeroMemory before setting any driver-supplied
    values in its members. The current MajorNdisVersion is 0x05, and the current
    MinorNdisVersion is 0x00. In each XxxHandler member of the
    characteristics structure, <f DriverEntry> must set the name of a
    driver-supplied MiniportXxx function, or the member must be NULL.

    Calling NdisMRegisterMiniport causes the driver's <f MiniportInitialize>
    function to run in the context of NdisMRegisterMiniport. Calling
    NdisIMRegisterLayeredMiniport defers the call to MiniportInitialize
    until the driver calls NdisIMInitializeDeviceInstance.

    Drivers that call NdisMRegisterMiniport must be prepared for an
    immediate call to their <f MiniportInitialize> functions. Such a driver
    must have sufficient installation and configuration information
    stored in the registry or available from calls to an NdisXxx
    bus-type-specific configuration function to set up any NIC-specific
    resources the driver will need to carry out network I/O operations.

    Drivers that call NdisIMRegisterLayeredMiniport defer the call to
    their <f MiniportInitialize> functions to another driver-supplied
    function that makes a call to NdisIMInitializeDeviceInstance.
    NDIS intermediate drivers usually register a ProtocolBindAdapter
    function and call NdisIMRegisterLayeredMiniport so that NDIS will
    call the ProtocolBindAdapter function after all underlying NIC
    drivers have initialized. This strategy gives such an NDIS
    intermediate driver, which makes the call to
    NdisIMInitializeDeviceInstance from ProtocolBindAdapter,
    the advantage of having its <f MiniportInitialize> function configure
    driver-allocated resources for the intermediate's virtual NIC to
    the features of the underlying NIC driver to which the intermediate
    has already bound itself.

    If NdisMRegisterMiniport or NdisIMRegisterLayeredMiniport does
    not return NDIS_STATUS_SUCCESS, <f DriverEntry> must release any
    resources it allocated, such as memory to hold the NdisWrapperHandle,
    and must call NdisTerminateWrapper before it returns control.
    The driver will not be loaded if this occurs.

    By default, <f DriverEntry> runs at IRQL PASSIVE_LEVEL in a
    system-thread context.

@devnote

    The parameters passed to <f DriverEntry> are OS specific! NT passes in valid
    values, but Windows 3.1 and Windows 95 just pass in zeros.  We don't
    care, because we just pass them to the NDIS wrapper anyway.

@rdesc

    <f DriverEntry> returns zero if it is successful.<nl>
    Otherwise, a non-zero return value indicates an error condition.

@xref

    <f MiniportInitialize>

*/

NTSTATUS DriverEntry(
    IN PDRIVER_OBJECT           DriverObject,               // @parm
    // A pointer to the driver object, which was created by the I/O system.

    IN PUNICODE_STRING          RegistryPath                // @parm
    // A pointer to the registry path, which specifies where driver-specific
    // parameters are stored.
    )
{
    DBG_FUNC("DriverEntry")

    NDIS_STATUS                 Status;
    // Status result returned from an NDIS function call.

    NTSTATUS                    Result;
    // Result code returned by this function.

    NDIS_WAN_MINIPORT_CHARACTERISTICS WanCharacteristics;
    // Characteristics table passed to NdisMWanRegisterMiniport.

    /*
    // Setup default debug flags then breakpoint so we can tweak them
    // when this module is first loaded.  It is also useful to see the
    // build date and time to be sure it's the one you think it is.
    */
#if DBG
    DbgInfo->DbgFlags = DBG_DEFAULTS;
    DbgInfo->DbgID[0] = '0';
    DbgInfo->DbgID[1] = ':';
    if (sizeof(VER_TARGET_STR) < sizeof(DbgInfo->DbgID)-3)
    {
        memcpy(&DbgInfo->DbgID[2], VER_TARGET_STR, sizeof(VER_TARGET_STR));
    }
    else
    {
        memcpy(&DbgInfo->DbgID[2], VER_TARGET_STR, sizeof(DbgInfo->DbgID)-3);
        DbgInfo->DbgID[sizeof(DbgInfo->DbgID)-1] = 0;
    }
#endif // DBG
    DBG_PRINT((VER_TARGET_STR": Build Date:"__DATE__" Time:"__TIME__"\n"));
    DBG_PRINT((VER_TARGET_STR": DbgInfo=0x%X DbgFlags=0x%X\n",
               DbgInfo, DbgInfo->DbgFlags));
    DBG_BREAK(DbgInfo);

    DBG_ENTER(DbgInfo);
    DBG_PARAMS(DbgInfo,
              ("\n"
               "\t|DriverObject=0x%X\n"
               "\t|RegistryPath=0x%X\n",
               DriverObject,
               RegistryPath
              ));

    /*
    // Initialize the Miniport wrapper - THIS MUST BE THE FIRST NDIS CALL.
    */
    NdisMInitializeWrapper(
            &g_NdisWrapperHandle,
            DriverObject,
            RegistryPath,
            NULL
            );
    ASSERT(g_NdisWrapperHandle);

    /*
    // Initialize the characteristics table, exporting the Miniport's entry
    // points to the Miniport wrapper.
    */
    NdisZeroMemory((PVOID)&WanCharacteristics, sizeof(WanCharacteristics));
    WanCharacteristics.MajorNdisVersion        = NDIS_MAJOR_VERSION;
    WanCharacteristics.MinorNdisVersion        = NDIS_MINOR_VERSION;
    WanCharacteristics.Reserved                = NDIS_USE_WAN_WRAPPER;

    WanCharacteristics.InitializeHandler       = MiniportInitialize;
    WanCharacteristics.WanSendHandler          = MiniportWanSend;
    WanCharacteristics.QueryInformationHandler = MiniportQueryInformation;
    WanCharacteristics.SetInformationHandler   = MiniportSetInformation;
    WanCharacteristics.CheckForHangHandler     = MiniportCheckForHang;
    WanCharacteristics.ResetHandler            = MiniportReset;
    WanCharacteristics.HaltHandler             = MiniportHalt;

    /*
    // If the adapter does not generate an interrupt, these entry points
    // are not required.  Otherwise, you can use the have the ISR routine
    // called each time an interupt is generated, or you can use the
    // enable/disable routines.
    */
#if defined(CARD_REQUEST_ISR)
#if (CARD_REQUEST_ISR == FALSE)
    WanCharacteristics.DisableInterruptHandler = MiniportDisableInterrupt;
    WanCharacteristics.EnableInterruptHandler  = MiniportEnableInterrupt;
#endif // CARD_REQUEST_ISR == FALSE
    WanCharacteristics.HandleInterruptHandler  = MiniportHandleInterrupt;
    WanCharacteristics.ISRHandler              = MiniportISR;
#endif // defined(CARD_REQUEST_ISR)

    /*
    // Register the driver with the Miniport wrapper.
    */
    Status = NdisMRegisterMiniport(
                    g_NdisWrapperHandle,
                    (PNDIS_MINIPORT_CHARACTERISTICS) &WanCharacteristics,
                    sizeof(WanCharacteristics)
                    );

    /*
    // The driver will not load if this call fails.
    // The system will log the error for us.
    */
    if (Status != NDIS_STATUS_SUCCESS)
    {
        DBG_ERROR(DbgInfo,("Status=0x%X\n",Status));
        Result = STATUS_UNSUCCESSFUL;
    }
    else
    {
        DBG_NOTICE(DbgInfo,("Status=0x%X\n",Status));
        Result = STATUS_SUCCESS;
    }

    DBG_RETURN(DbgInfo, Result);
    return (Result);
}


/* @doc INTERNAL Miniport Miniport_c MiniportInitialize


@func

    <f MiniportInitialize> is a required function that sets up a NIC (or
    virtual NIC) for network I/O operations, claims all hardware resources
    necessary to the NIC in the registry, and allocates resources the driver
    needs to carry out network I/O operations.

@comm

    NDIS submits no requests to a driver until its initialization
    is completed.

    In NIC and intermediate drivers that call NdisMRegisterMiniport
    from their DriverEntry functions, NDIS calls MiniportInitialize
    in the context of NdisMRegisterMiniport. The underlying device
    driver must initialize before an intermediate driver that depends
    on that device calls NdisMRegisterMiniport.

    For NDIS intermediate drivers that export both ProtocolXxx and
    MiniportXxx functions and that call NdisIMRegisterLayeredMiniport
    from their DriverEntry functions, NDIS calls <f MiniportInitialize>
    in the context of NdisIMInitializeDeviceInstance. Such a driver's
    ProtocolBindAdapter function usually makes the call to
    NdisIMInitializeDeviceInstance.

    For NIC drivers, NDIS must find at least the NIC's I/O bus
    interface type and, if it is not an ISA bus, the bus number
    already installed in the registry by the driver's installation
    script. For more information about installing Windows 2000 drivers,
    see the Driver Writer's Guide.

    The NIC driver obtains configuration information for its
    NIC by calling NdisOpenConfiguration and NdisReadConfiguration.
    The NIC driver obtains bus-specific information by calling the
    appropriate bus-specific function:

    Bus Function for Obtaining Bus-Specific Information:<nl>

    EISA:<nl>
        NdisReadEisaSlotInformation or NdisReadEisaSlotInformationEx

    PCI:<nl>
        NdisReadPciSlotInformation

    PCMCIA:<nl>
         NdisReadPcmciaAttributeMemory

    The NIC driver for an EISA NIC obtains information on the
    hardware resources for its NIC by calling
    NdisReadEisaSlotInformation or NdisReadEisaSlotInformationEx.
    NIC drivers for PCI NICs and PCMCIA NICs obtain such information
    by calling NdisMQueryAdapterResources.

    When it calls <f MiniportInitialize>, the NDIS library supplies an
    array of supported media types, specified as system-defined
    NdisMediumXxx values. <f MiniportInitialize> reads the array
    elements and provides the index of the medium type that NDIS
    should use with this driver for its NIC. If the miniport is
    emulating a medium type, its emulation must be transparent to NDIS.

    The <f MiniportInitialize> function of a NIC driver must call
    NdisMSetAttributes or NdisMSetAttributesEx before it calls
    any NdisXxx function, such as NdisRegisterIoPortRange or NdisMMapIoSpace,
    that claims hardware resources in the registry for the NIC.
    MiniportInitialize must call NdisMSetAttributes(Ex) before it
    attempts to allocate resources for DMA operations as well. If
    the NIC is a busmaster, <f MiniportInitialize> must call
    NdisMAllocateMapRegisters following its call to
    NdisMSetAttributes(Ex) and before it calls NdisMAllocateSharedMemory.
    If the NIC is a slave, MiniportInitialize must call
    NdisMSetAttributes(Ex) before it calls NdisMRegisterDmaChannel.

    Intermediate driver <f MiniportInitialize> functions must call
    NdisMSetAttributesEx with NDIS_ATTRIBUTE_INTERMEDIATE_DRIVER
    set in the AttributeFlags argument. Setting this flag causes
    NDIS to treat every intermediate driver as a full-duplex miniport,
    thereby preventing rare but intermittant deadlocks when concurrent
    send and receive events occur. Consequently, every intermediate
    driver must be written as a full-duplex driver capable of handling
    concurrent sends and indications.

    If the NDIS library's default four-second time-out interval on
    outstanding sends and requests is too short for the driver's NIC,
    <f MiniportInitialize> can call NdisMSetAttributesEx to extend the
    interval. Every intermediate driver also should call
    NdisMSetAttributesEx with NDIS_ATTRIBUTE_IGNORE_PACKET_TIMEOUT
    and NDIS_ATTRIBUTE_IGNORE_REQUEST_TIMEOUT set in the AttributeFlags
    so that NDIS will not attempt to time out sends and requests that
    NDIS holds queued to the intermediate driver.

    The call to NdisMSetAttributes or NdisMSetAttributesEx includes a
    MiniportAdapterContext handle to a driver-allocated context area,
    in which the miniport maintains runtime state information. NDIS
    subsequently passes the supplied <t MiniportAdapterContext> handle as
    an input parameter to other MiniportXxx functions.

    Consequently, the <f MiniportInitialize> function of an intermediate
    driver must call NdisMSetAttributesEx to set up the <t MiniportAdapterContext>
    handle for a driver-allocated per-virtual-NIC context area. Otherwise,
    NDIS would pass a NULL <t MiniportAdapterContext> handle in its subsequent
    calls to the intermediate driver's other MiniportXxx functions.

    After a call to NdisMRegisterIoPortRange, a miniport must call
    the NdisRawXxx functions with the PortOffset value returned by
    NdisMRegisterIoPortRange to communicate with its NIC. The NIC
    driver can no longer call the NdisImmediateRead/WritePortXxx
    functions. Similarly, after a call to NdisMMapIoSpace, a NIC
    driver can no longer call NdisImmediateRead/WriteSharedMemory.

    After it has claimed any bus-relative hardware resources for its
    NIC in the registry, a miniport should no longer call any
    bus-type-specific NdisReadXxx function.

    After <f MiniportInitialize> calls NdisMRegisterInterrupt, the driver's
    <f MiniportISR> function is called if the driver's NIC generates an
    interrupt or if any other device with which the NIC shares an IRQ
    interrupts. NDIS does not call the <f MiniportDisableInterrupt> and
    <f MiniportEnableInterrupt> functions, if the driver supplied them,
    during initialization, so it is such a miniport's responsibility
    to acknowledge and clear any interrupts its NIC generates. If the
    NIC shares an IRQ, the driver must first determine whether its NIC
    generated the interrupt; if not, the miniport must return FALSE as
    soon as possible.

    If the NIC does not generate interrupts, <f MiniportInitialize> should
    call NdisMInitializeTimer with a driver-supplied polling
    MiniportTimer function and a pointer to driver-allocated memory
    for a timer object. Drivers of NICs that generate interrupts and
    intermediate drivers also can set up one or more <f MiniportTimer>
    functions, each with its own timer object. <f MiniportInitialize> usually
    calls NdisMSetPeriodicTimer to enable a polling <f MiniportTimer> function;
    a driver calls NdisMSetTimer subsequently when conditions occur such
    that the driver's nonpolling <f MiniportTimer> function should be run.

    If the driver subsequently indicates receives with
    NdisMIndicateReceivePacket, the MiniportInitialize function
    should call NdisAllocatePacketPool and NdisAllocateBufferPool
    and save the handles returned by these NDIS functions. The packets
    that the driver subsequently indicates with NdisMIndicateReceivePacket
    must reference descriptors that were allocated with NdisAllocatePacket
    and NdisAllocateBuffer.

    If driver functions other than <f MiniportISR> or <f MiniportDisableInterrupt>
    share resources, <f MiniportInitialize> should call NdisAllocateSpinLock
    to set up any spin lock necessary to synchronize access to such a set
    of shared resources, particularly in a full-duplex driver or in a
    driver with a polling <f MiniportTimer> function rather than an ISR.
    Resources shared by other driver functions with <f MiniportISR> or
    <f MiniportDisableInterrupt>, such as NIC registers, are protected
    by the interrupt object set up when <f MiniportInitialize> calls
    NdisMRegisterInterrupt and accessed subsequently by calling
    NdisMSynchronizeWithInterrupt.

    Any NIC driver's <f MiniportInitialize> function should test the
    NIC to be sure the hardware is configured correctly to carry
    out subsequent network I/O operations. If it must wait for
    state changes to occur in the hardware, <f MiniportInitialize>
    either can call NdisWaitEvent with the pointer to a driver-initialized
    event object, or it can call NdisMSleep.

    Unless the <f MiniportInitialize> function of a NIC driver will
    return an error status, it should call
    NdisMRegisterAdapterShutdownHandler with a driver-supplied
    MiniportShutdown function.

    If <f MiniportInitialize> will fail the initialization, it must
    release all resources it has already allocated before it
    returns control.

    If <f MiniportInitialize> returns NDIS_STATUS_OPEN_ERROR, NDIS can
    examine the value returned at OpenErrorStatus to obtain more
    information about the error.

    When <f MiniportInitialize> returns NDIS_STATUS_SUCCESS, the NDIS
    library calls the driver's <f MiniportQueryInformation> function next.

    By default, <f MiniportInitialize> runs at IRQL PASSIVE_LEVEL and in
    the context of a system thread.




@rdesc

    <f MiniportInitialize> can return either of the following:

    @flag NDIS_STATUS_SUCCESS |
        <f MiniportInitialize> configured and set up the NIC, and it allocated
        all the resources the driver needs to carry out network I/O operations.
    @flag NDIS_STATUS_FAILURE |
        <f MiniportInitialize> could not set up the NIC to an
        operational state or could not allocate needed resources.
        <f MiniportInitialize> called NdisWriteErrorLogEntry with parameters
        specifying the configuration or resource allocation failure.<nl>

    As alternatives to NDIS_STATUS_FAILURE, <f MiniportInitialize>
    can return one of the following values, as appropriate,
    when it fails an initialization:

    @flag NDIS_STATUS_UNSUPPORTED_MEDIA |
        The values at MediumArray did not include a medium
        the driver (or its NIC) can support.
    @flag NDIS_STATUS_ADAPTER_NOT_FOUND |
        <f MiniportInitialize> did not recognize the NIC either
        from its description in the registry, using
        NdisOpenConfiguration and NdisReadConfiguration,
        or by probing the NIC on a particular I/O bus, using
        one of the NdisImmediateXxx or bus-type-specific
        NdisXxx configuration functions. This return can be
        propagated from the miniport's call to certain NdisXxx
        functions, such as NdisOpenConfiguration.
    @flag NDIS_STATUS_OPEN_ERROR |
        <f MiniportInitialize> attempted to set up a NIC
        but was unsuccessful.
    @flag NDIS_STATUS_NOT_ACCEPTED |
        <f MiniportInitialize> could not get its NIC to
        accept the configuration parameters that it got from
        the registry or from a bus-type-specific NdisXxx
        configuration function.
    @flag NDIS_STATUS_RESOURCES |
        Either <f MiniportInitialize> could not allocate
        sufficient resources to carry out network I/O
        operations or an attempt to claim bus-relative
        hardware resources in the registry for the NIC
        failed. This return can be propagated from the
        miniport's call to an NdisXxx function.
        If another device has already claimed a
        resource in the registry that its NIC needs,
        <f MiniportInitialize> also should call
        NdisWriteErrorLogEntry to record the
        particular resource conflict (I/O port range,
        interrupt vector, device memory range, as appropriate).
        Supplying an error log record gives the user or system
        administrator information that can be used to reconfigure
        the machine to avoid such hardware resource conflicts.


@xref

    <f DriverEntry>
    <f MiniportDisableInterrupt>
    <f MiniportEnableInterrupt>
    <f MiniportEnableInterrupt>
    <f MiniportISR>
    <f MiniportQueryInformation>
    <f MiniportShutdown>
    <f MiniportTimer>

*/

NDIS_STATUS MiniportInitialize(
    OUT PNDIS_STATUS            OpenErrorStatus,            // @parm
    // Points to a variable that MiniportInitialize sets to an
    // NDIS_STATUS_XXX code specifying additional information about the
    // error if MiniportInitialize will return NDIS_STATUS_OPEN_ERROR.

    OUT PUINT                   SelectedMediumIndex,        // @parm
    // Points to a variable in which MiniportInitialize sets the index of
    // the MediumArray element that specifies the medium type the driver
    // or its NIC uses.

    IN PNDIS_MEDIUM             MediumArray,                // @parm
    // Specifies an array of NdisMediumXxx values from which
    // MiniportInitialize selects one that its NIC supports or that the
    // driver supports as an interface to higher-level drivers.

    IN UINT                     MediumArraySize,            // @parm
    // Specifies the number of elements at MediumArray.

    IN NDIS_HANDLE              MiniportAdapterHandle,      // @parm
    // Specifies a handle identifying the miniport's NIC, which is assigned
    // by the NDIS library. MiniportInitialize should save this handle; it
    // is a required parameter in subsequent calls to NdisXxx functions.

    IN NDIS_HANDLE              WrapperConfigurationContext // @parm
    // Specifies a handle used only during initialization for calls to
    // NdisXxx configuration and initialization functions.  For example,
    // this handle is a required parameter to NdisOpenConfiguration and
    // the NdisImmediateReadXxx and NdisImmediateWriteXxx functions.
    )
{
    DBG_FUNC("MiniportInitialize")

    NDIS_STATUS                 Status;
    // Status result returned from an NDIS function call.

    PMINIPORT_ADAPTER_OBJECT    pAdapter;
    // Pointer to our newly allocated object.

    UINT                        Index;
    // Loop counter.

    DBG_ENTER(DbgInfo);
    DBG_PARAMS(DbgInfo,
              ("\n"
               "\t|OpenErrorStatus=0x%X\n"
               "\t|SelectedMediumIndex=0x%X\n"
               "\t|MediumArray=0x%X\n"
               "\t|MediumArraySize=0x%X\n"
               "\t|MiniportAdapterHandle=0x%X\n"
               "\t|WrapperConfigurationContext=0x%X\n",
               OpenErrorStatus,
               SelectedMediumIndex,
               MediumArray,
               MediumArraySize,
               MiniportAdapterHandle,
               WrapperConfigurationContext
              ));

    /*
    // Search the MediumArray for the NdisMediumWan media type.
    */
    for (Index = 0; Index < MediumArraySize; Index++)
    {
        if (MediumArray[Index] == NdisMediumWan)
        {
            break;
        }
    }

    /*
    // Make sure the protocol has requested the proper media type.
    */
    if (Index < MediumArraySize)
    {
        /*
        // Allocate memory for the adapter information structure.
        */
        Status = AdapterCreate(
                        &pAdapter,
                        MiniportAdapterHandle,
                        WrapperConfigurationContext
                        );

        if (Status == NDIS_STATUS_SUCCESS)
        {
            /*
            // Now it's time to initialize the hardware resources.
            */
            Status = AdapterInitialize(pAdapter);

            if (Status == NDIS_STATUS_SUCCESS)
            {
                /*
                // Save the selected media type.
                */
                *SelectedMediumIndex = Index;
            }
            else
            {
                /*
                // Something went wrong, so let's make sure everything is
                // cleaned up.
                */
                MiniportHalt(pAdapter);
            }
        }
    }
    else
    {
        DBG_ERROR(DbgInfo,("No NdisMediumWan found (Array=0x%X, ArraySize=%d)\n",
                  MediumArray, MediumArraySize));
        /*
        // Log error message and return.
        */
        NdisWriteErrorLogEntry(
                MiniportAdapterHandle,
                NDIS_ERROR_CODE_UNSUPPORTED_CONFIGURATION,
                3,
                Index,
                __FILEID__,
                __LINE__
                );

        Status = NDIS_STATUS_UNSUPPORTED_MEDIA;
    }

    /*
    // If all goes well, register a shutdown handler for this adapter.
    */
    if (Status == NDIS_STATUS_SUCCESS)
    {
        NdisMRegisterAdapterShutdownHandler(MiniportAdapterHandle,
                                            pAdapter, MiniportShutdown);
    }

    DBG_NOTICE(DbgInfo,("Status=0x%X\n",Status));

    DBG_RETURN(DbgInfo, Status);
    return (Status);
}


/* @doc INTERNAL Miniport Miniport_c MiniportHalt


@func

    <f MiniportHalt> request is used to halt the adapter such that it is
    no longer functioning.

@comm

    <f MiniportHalt> should stop the NIC, if it controls a physical
    NIC, and must free all resources that the driver allocated for
    it's NIC before <f MiniportHalt> returns control. In effect,
    <f MiniportHalt> undoes everything that was done by <f MiniportInitialize>
    for a particular NIC.

    If the NIC driver allocated memory, claimed an I/O port range,
    mapped on-board device memory to host memory, initialized timer(s)
    and/or spin lock(s), allocated map registers or claimed a DMA channel,
    and registered an interrupt, that driver must call the reciprocals of the
    NdisXxx functions with which it originally allocated these resources.

    As a general rule, a <f MiniportHalt> function should call reciprocal
    NdisXxx functions in inverse order to the calls the driver made from
    <f MiniportInitialize>. That is, if a NIC driver's <f MiniportInitialize>
    function called NdisMRegisterAdapterShutdownHandler just before
    it returned control, its <f MiniportHalt> function would call
    NdisMDeregisterAdapterShutdownHandler first.

    If its NIC generates interrupts or shares an IRQ, a NIC driver's
    <f MiniportHalt> function can be pre-empted by its <f MiniportISR> or
    <f MiniportDisableInterrupt> function until <f MiniportHalt> calls
    NdisMDeregisterInterrupt. Such a driver's <f MiniportHalt>
    function usually disables interrupts on the NIC, if
    possible, and calls NdisMDeregisterInterrupt as soon
    as it can.

    If the driver has a <f MiniportTimer> function associated
    with any timer object that might be in the system timer
    queue, <f MiniportHalt> should call NdisMCancelTimer.

    Otherwise, it is unnecessary for the miniport to complete
    outstanding requests to its NIC before <f MiniportHalt> begins
    releasing allocated resources. NDIS submits no further
    requests to the miniport for the NIC designated by the
    MiniportAdapterContext handle when NDIS has called <f MiniportHalt>.
    On return from <f MiniportHalt>, NDIS cleans up any state it was
    maintaining about this NIC and about its driver if this
    miniport supports no other NICs in the current machine.

    An NDIS intermediate driver's call to
    NdisIMDeinitializeDeviceInstance causes a
    call to it's <f MiniportHalt> function.

    By default, <f MiniportHalt> runs at IRQL PASSIVE_LEVEL.

    Interrupts are enabled during the call to this routine.

@xref
    <f MiniportInitialize>
    <f MiniportShutdown>

 */

VOID MiniportHalt(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter                    // @parm
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance.
    )
{
    DBG_FUNC("MiniportHalt")

    NDIS_TAPI_PROVIDER_SHUTDOWN TapiShutDown;
    // We use this message to make sure TAPI is cleaned up.

    ULONG                       DummyLong;
    // Don't care about the return value.

    DBG_ENTER(DbgInfo);

    /*
    // Remove our shutdown handler from the system.
    */
    NdisMDeregisterAdapterShutdownHandler(pAdapter->MiniportAdapterHandle);

    /*
    // Make sure all the lines are hungup and indicated.
    // This should already be the case, but let's be sure.
    */
    TapiShutDown.ulRequestID = OID_TAPI_PROVIDER_SHUTDOWN;
    TspiProviderShutdown(pAdapter, &TapiShutDown, &DummyLong, &DummyLong);

    /*
    // Free adapter instance.
    */
    AdapterDestroy(pAdapter);

    DBG_LEAVE(DbgInfo);
}


/* @doc INTERNAL Miniport Miniport_c MiniportShutdown


@func

    <f MiniportShutdown> is an optional function that restores a NIC to its
    initial state when the system is shut down, whether by the user or because
    an unrecoverable system error occurred.

@comm

    Every NIC driver should have a <f MiniportShutdown> function.
    <f MiniportShutdown> does nothing more than restore the NIC
    to its initial state (before the miniport's <f DriverEntry>
    function runs). However, this ensures that the NIC is in a
    known state and ready to be reinitialized when the machine is
    rebooted after a system shutdown occurs for any reason,
    including a crash dump.

    A NIC driver's <f MiniportInitialize> function must call
    NdisMRegisterAdapterShutdownHandler to set up a <f MiniportShutdown>
    function. The driver's <f MiniportHalt> function must make a
    reciprocal call to NdisMDeregisterAdapterShutdownHandler.

    If <f MiniportShutdown> is called due to a user-initiated
    system shutdown, it runs at IRQL PASSIVE_LEVEL in a
    system-thread context. If it is called due to an
    unrecoverable error, <f MiniportShutdown> runs at an
    arbitrary IRQL and in the context of whatever component
    raised the error. For example, <f MiniportShutdown> might be
    run at high DIRQL in the context of an ISR for a device
    essential to continued execution of the system.

    <f MiniportShutdown> should call no NdisXxx functions.

@xref

    <f MiniportHalt>
    <f MiniportInitialize>

*/

VOID MiniportShutdown(
    IN PMINIPORT_ADAPTER_OBJECT pAdapter                    // @parm
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance.
    // This was supplied when the NIC driver's <f MiniportInitialize>
    // function called NdisMRegisterAdapterShutdownHandler. Usually,
    // this input parameter is the NIC-specific <t MINIPORT_ADAPTER_CONTEXT>
    // pointer passed to other MiniportXxx functions
    )
{
    DBG_FUNC("MiniportShutdown")

    DBG_ENTER(pAdapter);

    /*
    // Reset the hardware and bial out - don't release any resources!
    */
    CardReset(pAdapter->pCard);

    DBG_LEAVE(pAdapter);
}


/* @doc INTERNAL Miniport Miniport_c MiniportReset


@func

    <f MiniportReset> request instructs the Miniport to issue a hardware
    reset to the network adapter.  The Miniport also resets its software
    state.

@comm

    <f MiniportReset> can reset the parameters of its NIC. If a reset
    causes a change in the NIC's station address, the miniport
    automatically restores the station address following the reset
    to its prior value. Any multicast or functional addressing masks
    reset by the hardware do not have to be reset in this function.

    If other information, such as multicast or functional addressing
    information or the lookahead size, is changed by a reset,
    <f MiniportReset> must set the variable at AddressingReset to TRUE
    before it returns control. This causes NDIS to call the
    <f MiniportSetInformation> function to restore the information.

    As a general rule, the <f MiniportReset> function of an NDIS
    intermediate driver should always set AddressingReset to TRUE.
    Until the underlying NIC driver resets its NIC, such an intermediate
    driver cannot determine whether it must restore addressing
    information for its virtual NIC. Because an intermediate driver
    disables the NDIS library's timing out of queued sends and requests
    to itself with an initialization-time call to NdisMSetAttributesEx,
    such a driver's <f MiniportReset> function is called only when a reset
    request is directed to the underlying NIC driver.

    Intermediate drivers that layer themselves above other types of
    device drivers also must have a <f MiniportReset> function. Such a
    <f MiniportReset> function must handle reset requests initiated by
    protocol drivers' calls to NdisReset. If the intermediate driver
    also has a <f MiniportCheckForHang> function, its <f MiniportReset> function
    will be called whenever MiniportCheckForHang returns TRUE.

    It is unnecessary for a driver to complete outstanding requests
    before <f MiniportReset> begins resetting the NIC or updating its
    software state. NDIS submits no further requests to the miniport
    for the NIC designated by the <t MINIPORT_ADAPTER_CONTEXT> handle when
    NDIS has called <f MiniportReset> until the reset operation is completed.
    A miniport need not call NdisM(Co)IndicateStatus to signal the start
    and finish of each reset operation because NDIS notifies bound
    protocols when a reset begins and ends.

    If <f MiniportReset> must wait for state changes in the NIC during
    reset operations, it can call NdisStallExecution. However, a
    MiniportReset function should never call NdisStallExecution
    with an interval greater than 50 microseconds.

    If <f MiniportReset> returns NDIS_STATUS_PENDING, the driver must
    complete the original request subsequently with a call to
    NdisMResetComplete.

    <f MiniportReset> can be pre-empted by an interrupt.

    If a NIC driver supplies a <f MiniportCheckForHang> function,
    the NDIS library calls it periodically to determine whether
    to call the driver's <f MiniportReset> function. Otherwise, the
    NDIS library calls a NIC driver's <f MiniportReset> function whenever
    requests NDIS submitted to the <f MiniportQueryInformation>,
    <f MiniportSetInformation>, MiniportSendPackets, MiniportSend,
    or <f MiniportWanSend> function seem to have timed out. (NDIS does
    not call a deserialized NIC driver's <f MiniportReset> function if
    the driver's MiniportSend or MiniportSendPackets function seems
    to have timed out, nor does NDIS call a connection-oriented NIC
    driver's <f MiniportReset> function if the driver's MiniportCoSendPackets
    function seems to have timed out.) By default, the NDIS-determined
    time-out interval for outstanding sends and requests is around
    four seconds. If this default is too short, a NIC driver can make
    an initialization-time call to NdisMSetAttributesEx, rather than
    NdisMSetAttributes, to lengthen the time-out interval to suit its NIC.

    Every NDIS intermediate driver should call NdisMSetAttributesEx
    from <f MiniportInitialize> and disable NDIS's attempts to time out
    requests and sends in the intermediate driver. NDIS runs an
    intermediate driver's <f MiniportCheckForHang> function, if any,
    approximately every two seconds.

    NDIS cannot determine whether a NIC might be hung on receives,
    so supplying a <f MiniportCheckForHang> function allows a driver to
    monitor its NIC for this condition and to force a reset if it occurs.

    By default, MiniportReset runs at IRQL DISPATCH_LEVEL.

@devnote

    I have only seen MiniportReset called when the driver is not working
    properly.  If this gets called, your code is probably broken, so fix
    it.  Don't try to recover here unless there is some hardware/firmware
    problem you must work around.

@rdesc

    <f MiniportReset> allways returns <f NDIS_STATUS_HARD_ERRORS>.

@xref
    <f MiniportCheckForHang>
    <f MiniportInitialize>
    <f MiniportQueryInformation>
    <f MiniportSetInformation>
    <f MiniportWanSend>

*/

NDIS_STATUS MiniportReset(
    OUT PBOOLEAN                AddressingReset,            // @parm
    // The Miniport indicates if the wrapper needs to call
    // <f MiniportSetInformation> to restore the addressing information
    // to the current values by setting this value to TRUE.

    IN PMINIPORT_ADAPTER_OBJECT pAdapter                    // @parm
    // A pointer to the <t MINIPORT_ADAPTER_OBJECT> instance.
    )
{
    DBG_FUNC("MiniportReset")

    NDIS_STATUS                 Result = NDIS_STATUS_SUCCESS;
    // Result code returned by this function.

    DBG_ENTER(pAdapter);
    DBG_ERROR(pAdapter,("##### !!! THIS SHOULD NEVER BE CALLED !!! #####\n"));

    /*
    // If anything goes wrong here, it's very likely an unrecoverable
    // hardware failure.  So we'll just shut this thing down for good.
    */
    Result = NDIS_STATUS_HARD_ERRORS;
    *AddressingReset = TRUE;

    return (Result);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ndis\sys\data.h ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation

Module Name:

    data.h

Abstract:

    NDIS wrapper Data

Author:

    01-Jun-1995 JameelH  Re-organization

Environment:

    Kernel mode, FSD

Revision History:

--*/

#ifndef _DATA_
#define _DATA_

extern UCHAR                    ndisValidProcessors[];
extern UCHAR                    ndisNumberOfProcessors;
extern UCHAR                    ndisMaximumProcessor;
extern UCHAR                    ndisCurrentProcessor;
extern LONG                     ndisFlags;
extern TDI_REGISTER_CALLBACK    ndisTdiRegisterCallback;
extern TDI_PNP_HANDLER          ndisTdiPnPHandler;
extern BOOLEAN                  ndisSkipProcessorAffinity;
extern BOOLEAN                  ndisMediaTypeCl[NdisMediumMax];
extern GUID                     gGuidLanClass;
extern NDIS_STATUS              ndisLastFailedInitErrorCode;
extern NDIS_STRING              ndisDeviceStr;
extern NDIS_STRING              ndisDosDevicesStr;
#if NDIS_NO_REGISTRY
extern PWSTR                    ndisDefaultExportName;
#endif
extern ULONG                    ndisVerifierLevel;
extern ULONG                    ndisVeriferFailedAllocations;
extern PCALLBACK_OBJECT         ndisPowerStateCallbackObject;
extern PVOID                    ndisPowerStateCallbackHandle;
extern ULONG                    ndisAcOnLine;
extern BOOLEAN                  VerifierSystemSufficientlyBooted;
extern BOOLEAN                  ndisGuidsSecured;

extern LARGE_INTEGER            KeBootTime;
extern LONG                     ndisCancelId;

extern KQUEUE                   ndisWorkerQueue;

#if NDIS_UNLOAD        
extern WORK_QUEUE_ITEM          ndisPoisonPill;
#endif

extern KSPIN_LOCK               ndisGlobalLock;

extern PKG_REF                  ndisPkgs[MAX_PKG];

extern PNDIS_PROTOCOL_BLOCK     ndisProtocolList;
extern LIST_ENTRY               ndisGlobalPacketPoolList;

extern PNDIS_OPEN_BLOCK         ndisGlobalOpenList;

//
//  The following are counters used for debugging
//
extern const NDIS_PHYSICAL_ADDRESS HighestAcceptableMax;
extern ULONG                    ndisDmaAlignment;
extern ULONG                    ndisTimeIncrement;

//
// For tracking memory allocated for shared memory
//
extern ERESOURCE SharedMemoryResource;

extern PNDIS_M_DRIVER_BLOCK     ndisMiniDriverList;
extern PNDIS_MINIPORT_BLOCK     ndisMiniportList;
extern NDIS_MEDIUM  *           ndisMediumArray,
                                ndisMediumBuffer[NdisMediumMax + EXPERIMENTAL_SIZE];
extern UINT                     ndisMediumArraySize, ndisMediumArrayMaxSize;
extern WCHAR                    ndisHexLookUp[];
extern ULONG                    ndisInstanceNumber;
extern UINT                     ndisPacketStackSize;

extern NDIS_GUID                ndisCoSupportedGuids[16];
extern NDIS_GUID                ndisSupportedGuids[36];
extern NDIS_GUID                ndisMediaSupportedGuids[75];
extern NDIS_GUID                ndisStatusSupportedGuids[10];

extern OID_SETINFO_HANDLER      ndisMSetInfoHandlers[];

extern HANDLE                   ndisSystemProcess;
extern PDEVICE_OBJECT           ndisDeviceObject;
extern PDRIVER_OBJECT           ndisDriverObject;
extern PETHREAD                 ndisThreadObject;
extern LARGE_INTEGER            PoolAgingTicks;


#if DBG
extern ULONG                    ndisDebugSystems;
extern LONG                     ndisDebugLevel;
extern ULONG                    ndisDebugLogSize;
extern ULONG                    ndisDebugBreakPoint;
#endif  // DBG

#ifdef TRACK_MOPEN_REFCOUNTS
extern ULONG_PTR                ndisLogfile[NDIS_LOGFILE_SIZE];
extern USHORT                   ndisLogfileIndex;
#endif
#ifdef TRACK_MINIPORT_REFCOUNTS
extern USHORT                   ndisMiniportLogfileIndex;
extern UINT                     ndisMiniportLogfile[NDIS_MINIPORT_LOGFILE_SIZE];
#endif

#if TRACK_RECEIVED_PACKETS
extern USHORT                   ndisRcvLogfileIndex;
extern ULONG_PTR                ndisRcvLogfile[NDIS_RCV_LOGFILE_SIZE];
#endif

extern KSPIN_LOCK   ndisProtocolListLock;
extern KSPIN_LOCK   ndisMiniDriverListLock;
extern KSPIN_LOCK   ndisMiniportListLock;
extern KSPIN_LOCK   ndisGlobalPacketPoolListLock;
extern KSPIN_LOCK   ndisGlobalOpenListLock;

extern NDIS_STRING  ndisBuildDate;
extern NDIS_STRING  ndisBuildTime;
extern NDIS_STRING  ndisBuiltBy;

extern KMUTEX       ndisPnPMutex;
extern ULONG        ndisPnPMutexOwner;

extern ULONG        ndisChecked;

extern PNDIS_MINIPORT_BLOCK ndisMiniportTrackAlloc;
extern LIST_ENTRY           ndisMiniportTrackAllocList;
extern PNDIS_M_DRIVER_BLOCK ndisDriverTrackAlloc;
extern LIST_ENTRY           ndisDriverTrackAllocList;
extern KSPIN_LOCK           ndisTrackMemLock;

extern PCALLBACK_OBJECT     ndisBindUnbindCallbackObject;
extern PVOID                ndisBindUnbindCallbackRegisterationHandle;
extern LUID                 SeWmiAccessPrivilege;
extern PSECURITY_DESCRIPTOR ndisSecurityDescriptor;

#endif  // _DATA_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ndis\sys\data.c ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation

Module Name:

    data.c

Abstract:

    NDIS wrapper Data

Author:

    01-Jun-1995 JameelH  Re-organization

Environment:

    Kernel mode, FSD

Revision History:

    10-July-1995    KyleB    Added spinlock logging debug code.

--*/

#include <precomp.h>
#pragma hdrstop


//
//  Define the module number for debug code.
//
#define MODULE_NUMBER   MODULE_DATA

UCHAR                   ndisValidProcessors[32] = { 0 };
UCHAR                   ndisMaximumProcessor = 0;
UCHAR                   ndisCurrentProcessor = 0;
UCHAR                   ndisNumberOfProcessors = 0;
BOOLEAN                 ndisSkipProcessorAffinity = FALSE;
const                   NDIS_PHYSICAL_ADDRESS HighestAcceptableMax = NDIS_PHYSICAL_ADDRESS_CONST(-1,-1);
KSPIN_LOCK              ndisGlobalLock;
PNDIS_M_DRIVER_BLOCK    ndisMiniDriverList = NULL;
PNDIS_PROTOCOL_BLOCK    ndisProtocolList = NULL;
PNDIS_MINIPORT_BLOCK    ndisMiniportList = NULL;
PNDIS_OPEN_BLOCK        ndisGlobalOpenList = NULL;
LIST_ENTRY              ndisGlobalPacketPoolList = {0};
TDI_REGISTER_CALLBACK   ndisTdiRegisterCallback = NULL;
TDI_PNP_HANDLER         ndisTdiPnPHandler = NULL;
ULONG                   ndisDmaAlignment = 0;
ULONG                   ndisTimeIncrement = 0;
ERESOURCE               SharedMemoryResource = {0};
HANDLE                  ndisSystemProcess = {0};
PDEVICE_OBJECT          ndisDeviceObject = NULL;
PDRIVER_OBJECT          ndisDriverObject = NULL;
PETHREAD                ndisThreadObject = NULL;
NDIS_STATUS             ndisLastFailedInitErrorCode = NDIS_STATUS_SUCCESS;
NDIS_STRING             ndisDeviceStr =  NDIS_STRING_CONST("\\DEVICE\\");
// NDIS_STRING             ndisDosDevicesStr = NDIS_STRING_CONST("\\DOSDEVICES\\");
NDIS_STRING             ndisDosDevicesStr = NDIS_STRING_CONST("\\GLOBAL??\\");
#if NDIS_NO_REGISTRY
PWSTR                   ndisDefaultExportName = NDIS_DEFAULT_EXPORT_NAME;
#endif
ULONG                   ndisVerifierLevel = 0;
ULONG                   ndisVeriferFailedAllocations = 0;
PCALLBACK_OBJECT        ndisPowerStateCallbackObject = NULL;
PVOID                   ndisPowerStateCallbackHandle = NULL;
ULONG                   ndisAcOnLine = 1;
LONG                    ndisCancelId = 0;
BOOLEAN                 VerifierSystemSufficientlyBooted = FALSE;
BOOLEAN                 ndisGuidsSecured = FALSE;
    
KQUEUE                  ndisWorkerQueue = {0};

#if NDIS_UNLOAD
WORK_QUEUE_ITEM         ndisPoisonPill = {0};
#endif

LARGE_INTEGER           PoolAgingTicks = {0};

PKG_REF                 ndisPkgs[MAX_PKG] =
    {
        {   0, FALSE, NdisSend,                     NULL},
        {   0, FALSE, ndisMIsr,                     NULL},
        {   0, FALSE, ndisDispatchRequest,          NULL},
        {   0, FALSE, NdisCoSendPackets,            NULL},
        {   0, FALSE, EthFilterDprIndicateReceive,  NULL},
        {   0, FALSE, FddiFilterDprIndicateReceive, NULL},
        {   0, FALSE, TrFilterDprIndicateReceive,   NULL},
#if ARCNET
        {   0, FALSE, ArcFilterDprIndicateReceive,  NULL}
#endif
    };

LONG                    ndisFlags = 0;
LARGE_INTEGER           KeBootTime = {0, 0};

#if DBG
ULONG                   ndisDebugSystems = 0;
LONG                    ndisDebugLevel = DBG_LEVEL_FATAL;
ULONG                   ndisDebugBreakPoint = 0;
ULONG                   MiniportDebug = 0;   // MINIPORT_DEBUG_LOUD;
#endif

#if TRACK_MEMORY

KSPIN_LOCK  ALock = 0;
#define MAX_PTR_COUNT   2048

struct _MemPtr
{
    PVOID   Ptr;
    ULONG   Size;
    ULONG   ModLine;
    ULONG   Tag;
} ndisMemPtrs[MAX_PTR_COUNT] = { 0 };

PVOID
AllocateM(
    IN  UINT    Size,
    IN  ULONG   ModLine,
    IN  ULONG   Tag
    )
{
    PVOID   p;

    p = ExAllocatePoolWithTag(NonPagedPool, Size, Tag);

    if (p != NULL)
    {
        KIRQL   OldIrql;
        UINT    i;

        ACQUIRE_SPIN_LOCK(&ALock, &OldIrql);

        for (i = 0; i < MAX_PTR_COUNT; i++)
        {
            if (ndisMemPtrs[i].Ptr == NULL)
            {
                ndisMemPtrs[i].Ptr = p;
                ndisMemPtrs[i].Size = Size;
                ndisMemPtrs[i].ModLine = ModLine;
                ndisMemPtrs[i].Tag = Tag;
                break;
            }
        }

        RELEASE_SPIN_LOCK(&ALock, OldIrql);
    }

    return(p);
}

VOID
FreeM(
    IN  PVOID   MemPtr
    )
{
    KIRQL   OldIrql;
    UINT    i;

    ACQUIRE_SPIN_LOCK(&ALock, &OldIrql);

    for (i = 0; i < MAX_PTR_COUNT; i++)
    {
        if (ndisMemPtrs[i].Ptr == MemPtr)
        {
            ndisMemPtrs[i].Ptr = NULL;
            ndisMemPtrs[i].Size = 0;
            ndisMemPtrs[i].ModLine = 0;
            ndisMemPtrs[i].Tag = 0;
        }
    }

    RELEASE_SPIN_LOCK(&ALock, OldIrql);

    ExFreePool(MemPtr);
}

#endif

#ifdef TRACK_MOPEN_REFCOUNTS

USHORT ndisLogfileIndex = 0;
ULONG_PTR ndisLogfile[NDIS_LOGFILE_SIZE];

#endif //TRACK_MOPEN_REFCOUNTS

#ifdef TRACK_MINIPORT_REFCOUNTS

USHORT ndisMiniportLogfileIndex = 0;
UINT ndisMiniportLogfile[NDIS_MINIPORT_LOGFILE_SIZE];

#endif //TRACK_MINIPORT_REFCOUNTS

#if TRACK_RECEIVED_PACKETS

USHORT ndisRcvLogfileIndex = 0;
ULONG_PTR ndisRcvLogfile[NDIS_RCV_LOGFILE_SIZE];

#endif

KSPIN_LOCK  ndisProtocolListLock;
KSPIN_LOCK  ndisMiniDriverListLock;
KSPIN_LOCK  ndisMiniportListLock;
KSPIN_LOCK  ndisGlobalPacketPoolListLock;
KSPIN_LOCK  ndisGlobalOpenListLock;

NDIS_STRING ndisBuildDate = {0, 0, NULL}; 
NDIS_STRING ndisBuildTime = {0, 0, NULL};
NDIS_STRING ndisBuiltBy = {0, 0, NULL};

KMUTEX      ndisPnPMutex;
ULONG       ndisPnPMutexOwner = 0;

#if DBG
ULONG   ndisChecked = 1;
#else
ULONG   ndisChecked = 0;
#endif

PNDIS_MINIPORT_BLOCK    ndisMiniportTrackAlloc = NULL;
LIST_ENTRY              ndisMiniportTrackAllocList;
PNDIS_M_DRIVER_BLOCK    ndisDriverTrackAlloc = NULL;
LIST_ENTRY              ndisDriverTrackAllocList;
KSPIN_LOCK              ndisTrackMemLock;

PCALLBACK_OBJECT        ndisBindUnbindCallbackObject = NULL;
PVOID                   ndisBindUnbindCallbackRegisterationHandle = NULL;
LUID                    SeWmiAccessPrivilege = {SE_LOAD_DRIVER_PRIVILEGE, 0};
PSECURITY_DESCRIPTOR    ndisSecurityDescriptor = NULL;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ndis\sys\configm.c ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation

Module Name:

    configm.c

Abstract:

    NDIS wrapper functions for miniport configuration/initialization

Author:

    Sean Selitrennikoff (SeanSe) 05-Oct-93
    Jameel Hyder        (JameelH) 01-Jun-95

Environment:

    Kernel mode, FSD

Revision History:

--*/

#include <precomp.h>
#pragma hdrstop

//
//  Define the module number for debug code.
//
#define MODULE_NUMBER   MODULE_CONFIGM


NDIS_STATUS
NdisMRegisterMiniport(
    IN  NDIS_HANDLE             NdisWrapperHandle,
    IN  PNDIS_MINIPORT_CHARACTERISTICS MiniportCharacteristics,
    IN  UINT                    CharacteristicsLength
    )

/*++

Routine Description:

    Used to register a Miniport driver with the wrapper.

Arguments:

    Status - Status of the operation.

    NdisWrapperHandle - Handle returned by NdisWInitializeWrapper.

    MiniportCharacteritics - The NDIS_MINIPORT_CHARACTERISTICS table.

    CharacteristicsLength - The length of MiniportCharacteristics.

Return Value:

    None.

--*/
{
    NDIS_STATUS             Status;
    PNDIS_M_DRIVER_BLOCK    MiniBlock;

    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
            ("==>NdisMRegisterMiniport: NdisWrapperHandle %p\n", NdisWrapperHandle));


    Status = ndisRegisterMiniportDriver(NdisWrapperHandle,
                                        MiniportCharacteristics,
                                        CharacteristicsLength,
                                        &MiniBlock);

    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
            ("NdisMRegisterMiniport: MiniBlock %p\n", MiniBlock));

    ASSERT (CURRENT_IRQL < DISPATCH_LEVEL);

    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
            ("<==NdisMRegisterMiniport: MiniBlock %p, Status %lx\n", MiniBlock, Status));

    return Status;
}

NDIS_STATUS
NdisIMRegisterLayeredMiniport(
    IN  NDIS_HANDLE             NdisWrapperHandle,
    IN  PNDIS_MINIPORT_CHARACTERISTICS MiniportCharacteristics,
    IN  UINT                    CharacteristicsLength,
    OUT PNDIS_HANDLE            DriverHandle
    )

/*++

Routine Description:

    Used to register a layered Miniport driver with the wrapper.

Arguments:

    Status - Status of the operation.

    NdisWrapperHandle - Handle returned by NdisInitializeWrapper.

    MiniportCharacteritics - The NDIS_MINIPORT_CHARACTERISTICS table.

    CharacteristicsLength - The length of MiniportCharacteristics.

    DriverHandle - Returns a handle which can be used to call NdisMInitializeDeviceInstance.

Return Value:

    None.

--*/
{
    NDIS_STATUS Status;

    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
            ("==>NdisIMRegisterLayeredMiniport: NdisWrapperHandle %p\n", NdisWrapperHandle));

    Status = ndisRegisterMiniportDriver(NdisWrapperHandle,
                                        MiniportCharacteristics,
                                        CharacteristicsLength,
                                        DriverHandle);

    if (Status == NDIS_STATUS_SUCCESS)
    {
        PNDIS_M_DRIVER_BLOCK MiniBlock = (PNDIS_M_DRIVER_BLOCK)(*DriverHandle);

        MiniBlock->Flags |= fMINIBLOCK_INTERMEDIATE_DRIVER;
        
        INITIALIZE_MUTEX(&MiniBlock->IMStartRemoveMutex); 
    }

    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
            ("<==NdisIMRegisterLayeredMiniport: MiniBlock %p, Status %lx\n", *DriverHandle, Status));

    return Status;
}

VOID
NdisIMDeregisterLayeredMiniport(    
    IN  NDIS_HANDLE         DriverHandle
    )
{
    //
    // Do nothing for now
    //
}

VOID
NdisIMAssociateMiniport(    
    IN  NDIS_HANDLE         DriverHandle,
    IN  NDIS_HANDLE         ProtocolHandle
    )
{
    PNDIS_M_DRIVER_BLOCK    MiniDriver = (PNDIS_M_DRIVER_BLOCK)DriverHandle;
    PNDIS_PROTOCOL_BLOCK    Protocol = (PNDIS_PROTOCOL_BLOCK)ProtocolHandle;

    MiniDriver->AssociatedProtocol = Protocol;
    Protocol->AssociatedMiniDriver = MiniDriver;
}

NDIS_STATUS
ndisRegisterMiniportDriver(
    IN  NDIS_HANDLE             NdisWrapperHandle,
    IN  PNDIS_MINIPORT_CHARACTERISTICS MiniportCharacteristics,
    IN  UINT                    CharacteristicsLength,
    OUT PNDIS_HANDLE            DriverHandle
    )

/*++

Routine Description:

    Used to register a layered Miniport driver with the wrapper.

Arguments:

    Status - Status of the operation.

    NdisWrapperHandle - Handle returned by NdisWInitializeWrapper.

    MiniportCharacteritics - The NDIS_MINIPORT_CHARACTERISTICS table.

    CharacteristicsLength - The length of MiniportCharacteristics.

    DriverHandle - Returns a handle which can be used to call NdisMInitializeDeviceInstance.

Return Value:

    None.

--*/

{
    PNDIS_M_DRIVER_BLOCK    MiniBlock;
    PNDIS_WRAPPER_HANDLE    DriverInfo = (PNDIS_WRAPPER_HANDLE)NdisWrapperHandle;
    UNICODE_STRING          Us;
    PWSTR                   pWch;
    USHORT                  i, size;
    NDIS_STATUS             Status;
    KIRQL                   OldIrql;

    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
            ("==>ndisRegisterMiniportDriver: NdisWrapperHandle %p\n", NdisWrapperHandle));


    do
    {
        if (DriverInfo == NULL)
        {
            Status = NDIS_STATUS_FAILURE;
            break;
        }

        //
        // Check version numbers and CharacteristicsLength.
        //
        size = 0;   // Used to indicate bad version below
        if (MiniportCharacteristics->MinorNdisVersion == 0)
        {
            if (MiniportCharacteristics->MajorNdisVersion == 3)
            {
                size = sizeof(NDIS30_MINIPORT_CHARACTERISTICS);
            }

            else if (MiniportCharacteristics->MajorNdisVersion == 4)
            {
                size = sizeof(NDIS40_MINIPORT_CHARACTERISTICS);
            }
            else if (MiniportCharacteristics->MajorNdisVersion == 5)
            {
                size = sizeof(NDIS50_MINIPORT_CHARACTERISTICS);
            }
        }
        else if (MiniportCharacteristics->MinorNdisVersion == 1)
        {
            if (MiniportCharacteristics->MajorNdisVersion == 5)
            {
                size = sizeof(NDIS51_MINIPORT_CHARACTERISTICS);
            }
        }

        //
        // Check that this is an NDIS 3.0/4.0/5.0 miniport.
        //
        if (size == 0)
        {
            Status = NDIS_STATUS_BAD_VERSION;
            break;
        }

        //
        // Check that CharacteristicsLength is enough.
        //
        if (CharacteristicsLength < size)
        {
            Status = NDIS_STATUS_BAD_CHARACTERISTICS;
            break;
        }

        //
        // Validate some stuff for NDIS 5.0
        //
        if (MiniportCharacteristics->MajorNdisVersion == 5)
        {
            if (MiniportCharacteristics->CoSendPacketsHandler != NULL)
            {
                if (MiniportCharacteristics->CoRequestHandler == NULL)
                {
                    Status = NDIS_STATUS_BAD_CHARACTERISTICS;
                    break;
                }
            }
            
            if (MiniportCharacteristics->MinorNdisVersion >= 1)
            {
                //
                // for 5.1 miniports, having an AdapterShutdownHandler is mandatory
                //
                if (MiniportCharacteristics->AdapterShutdownHandler == NULL)
                {
                    Status = NDIS_STATUS_BAD_CHARACTERISTICS;
                    break;
                }
            }
        }

        //
        // Allocate memory for the NDIS MINIPORT block.
        //
        Status = IoAllocateDriverObjectExtension(DriverInfo->DriverObject,          // DriverObject
                                                 (PVOID)NDIS_PNP_MINIPORT_DRIVER_ID,// MiniDriver magic number
                                                 sizeof(NDIS_M_DRIVER_BLOCK),
                                                 (PVOID)&MiniBlock);
        if (!NT_SUCCESS(Status))
        {
            Status = NDIS_STATUS_RESOURCES;
            break;
        }

        ZeroMemory(MiniBlock, sizeof(NDIS_M_DRIVER_BLOCK));

        //
        // Copy over the characteristics table.
        //
        CopyMemory(&MiniBlock->MiniportCharacteristics,
                   MiniportCharacteristics,
                   size);

        //
        // Check if the Driver is verifying
        //
        if (MmIsDriverVerifying(DriverInfo->DriverObject))
        {
            MiniBlock->Flags |= fMINIBLOCK_VERIFYING;
            if (ndisFlags & NDIS_GFLAG_TRACK_MEM_ALLOCATION)
            {
                if (ndisDriverTrackAlloc == NULL)
                {
                    ndisDriverTrackAlloc = MiniBlock;
                }
                else
                {
                    //
                    // tracking memory alocation is allowed
                    // for one driver only. otherwise null out the
                    // global ndisDriverTrackAlloc to avoid confusion
                    // memory allocations will continue to get tracked
                    // but the result will not be very useful
                    //
                    ndisDriverTrackAlloc = NULL;
                }

            }            
        }

        //
        // No adapters yet registered for this Miniport.
        //
        MiniBlock->MiniportQueue = (PNDIS_MINIPORT_BLOCK)NULL;

        //
        // Set up the handlers for this driver. First setup Dummy handlers and then specific ones
        //
        for (i = 0; i < IRP_MJ_MAXIMUM_FUNCTION; i++)
        {
            DriverInfo->DriverObject->MajorFunction[i] = ndisDummyIrpHandler;
        }

        //
        // set up AddDevice handler for this miniport
        //
        DriverInfo->DriverObject->DriverExtension->AddDevice = ndisPnPAddDevice;

        //
        // Set up unload handler
        //
        DriverInfo->DriverObject->DriverUnload = ndisMUnload;

        DriverInfo->DriverObject->MajorFunction[IRP_MJ_CREATE] = ndisCreateIrpHandler;
        DriverInfo->DriverObject->MajorFunction[IRP_MJ_DEVICE_CONTROL] = ndisDeviceControlIrpHandler;
        DriverInfo->DriverObject->MajorFunction[IRP_MJ_CLOSE] = ndisCloseIrpHandler;

        //
        // setup a handler for PnP messages
        //
        DriverInfo->DriverObject->MajorFunction[IRP_MJ_PNP] = ndisPnPDispatch;
        DriverInfo->DriverObject->MajorFunction[IRP_MJ_POWER] = ndisPowerDispatch;
        DriverInfo->DriverObject->MajorFunction[IRP_MJ_SYSTEM_CONTROL] = ndisWMIDispatch;

        //
        // Use this event to tell us when all adapters are removed from the mac
        // during an unload
        //
        INITIALIZE_EVENT(&MiniBlock->MiniportsRemovedEvent);

        // let the initial state stay reset, because the ref count
        // going to zero is going to signal the event
        
        MiniBlock->NdisDriverInfo = DriverInfo;
        InitializeListHead(&MiniBlock->DeviceList);

        ndisInitializeRef(&MiniBlock->Ref);

        //
        // Put Driver on global list.
        //
        PnPReferencePackage();
        ACQUIRE_SPIN_LOCK(&ndisMiniDriverListLock, &OldIrql);

        MiniBlock->NextDriver = ndisMiniDriverList;
        ndisMiniDriverList = MiniBlock;
        
        REF_NDIS_DRIVER_OBJECT();
        
        RELEASE_SPIN_LOCK(&ndisMiniDriverListLock, OldIrql);
        PnPDereferencePackage();

        *DriverHandle = MiniBlock;

        Status = NDIS_STATUS_SUCCESS;
    } while (FALSE);


    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
            ("<==ndisRegisterMiniportDriver: MiniBlock %p\n", MiniBlock));

    return Status;
}


NDIS_STATUS
NdisMRegisterDevice(
    IN  NDIS_HANDLE             NdisWrapperHandle,
    IN  PNDIS_STRING            DeviceName,
    IN  PNDIS_STRING            SymbolicName,
    IN  PDRIVER_DISPATCH    *   MajorFunctions,
    OUT PDEVICE_OBJECT      *   pDeviceObject,
    OUT NDIS_HANDLE         *   NdisDeviceHandle
    )
/*++

Routine Description:

Arguments:


Return Value:


--*/
{
    PNDIS_WRAPPER_HANDLE    DriverInfo = (PNDIS_WRAPPER_HANDLE)NdisWrapperHandle;
    NDIS_STATUS             Status = NDIS_STATUS_SUCCESS;
    PDRIVER_OBJECT          DriverObject;
    PDEVICE_OBJECT          DeviceObject;
    PNDIS_M_DRIVER_BLOCK    MiniBlock;
    PNDIS_MINIPORT_BLOCK    Miniport;
    PNDIS_DEVICE_LIST       DeviceList = NULL;
    KIRQL                   OldIrql;

    *pDeviceObject = NULL;
    *NdisDeviceHandle = NULL;

    //
    // Check if the passed parameter is a NdisWrapperHandle or NdisMiniportHandle
    //
    if (DriverInfo->DriverObject == NULL)
    {
        Miniport = (PNDIS_MINIPORT_BLOCK)NdisWrapperHandle;
        MiniBlock = Miniport->DriverHandle;
    }
    else
    {
        MiniBlock = (PNDIS_M_DRIVER_BLOCK)IoGetDriverObjectExtension(DriverInfo->DriverObject,
                                                                     (PVOID)NDIS_PNP_MINIPORT_DRIVER_ID);
    }

    if (MiniBlock != NULL)
    {
        DriverObject = MiniBlock->NdisDriverInfo->DriverObject;
    
        Status = IoCreateDevice(DriverObject,                           // DriverObject
                                sizeof(NDIS_WRAPPER_CONTEXT) +
                                sizeof(NDIS_DEVICE_LIST) +              // DeviceExtension
                                DeviceName->Length + sizeof(WCHAR) +
                                SymbolicName->Length + sizeof(WCHAR),
                                DeviceName,                             // DeviceName
                                FILE_DEVICE_NETWORK,                    // DeviceType
                                FILE_DEVICE_SECURE_OPEN,                // DeviceCharacteristics
                                FALSE,                                  // Exclusive
                                &DeviceObject);                         // DeviceObject
    
        if (NT_SUCCESS(Status))
        {
            DeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;
            Status = IoCreateSymbolicLink(SymbolicName, DeviceName);

            if (!NT_SUCCESS(Status))
            {
                IoDeleteDevice(DeviceObject);
            }
            else
            {
                DeviceList = (PNDIS_DEVICE_LIST)((PNDIS_WRAPPER_CONTEXT)DeviceObject->DeviceExtension + 1);
                RtlZeroMemory(DeviceList, sizeof(NDIS_DEVICE_LIST) +
                                          DeviceName->Length + sizeof(WCHAR) +
                                          SymbolicName->Length + sizeof(WCHAR));
        
                DeviceList->Signature = (PVOID)CUSTOM_DEVICE_MAGIC_VALUE;
                InitializeListHead(&DeviceList->List);
                DeviceList->MiniBlock = MiniBlock;
                DeviceList->DeviceObject = DeviceObject;
        
                RtlCopyMemory(DeviceList->MajorFunctions,
                              MajorFunctions,
                              (IRP_MJ_MAXIMUM_FUNCTION+1)*sizeof(PDRIVER_DISPATCH));
        
                DeviceList->DeviceName.Buffer = (PWCHAR)(DeviceList + 1);
                DeviceList->DeviceName.Length = DeviceName->Length;
                DeviceList->DeviceName.MaximumLength = DeviceName->Length + sizeof(WCHAR);
                RtlCopyMemory(DeviceList->DeviceName.Buffer,
                              DeviceName->Buffer,
                              DeviceName->Length);
        
                DeviceList->SymbolicLinkName.Buffer = (PWCHAR)((PUCHAR)DeviceList->DeviceName.Buffer + DeviceList->DeviceName.MaximumLength);
                DeviceList->SymbolicLinkName.Length = SymbolicName->Length;
                DeviceList->SymbolicLinkName.MaximumLength = SymbolicName->Length + sizeof(WCHAR);
                RtlCopyMemory(DeviceList->SymbolicLinkName.Buffer,
                              SymbolicName->Buffer,
                              SymbolicName->Length);
        
                PnPReferencePackage();
        
                ACQUIRE_SPIN_LOCK(&MiniBlock->Ref.SpinLock, &OldIrql);
        
                InsertHeadList(&MiniBlock->DeviceList, &DeviceList->List);
        
                RELEASE_SPIN_LOCK(&MiniBlock->Ref.SpinLock, OldIrql);
        
                PnPDereferencePackage();
        
                *pDeviceObject = DeviceObject;
                *NdisDeviceHandle = DeviceList;
            }
        }
    }
    else
    {
        Status = NDIS_STATUS_NOT_SUPPORTED;
    }

    return Status;
}


NDIS_STATUS
NdisMDeregisterDevice(
    IN  NDIS_HANDLE             NdisDeviceHandle
    )
/*++

Routine Description:

Arguments:


Return Value:


--*/
{
    PNDIS_DEVICE_LIST       DeviceList = (PNDIS_DEVICE_LIST)NdisDeviceHandle;
    PNDIS_M_DRIVER_BLOCK    MiniBlock;
    KIRQL                   OldIrql;

    MiniBlock = DeviceList->MiniBlock;

    PnPReferencePackage();

    ACQUIRE_SPIN_LOCK(&MiniBlock->Ref.SpinLock, &OldIrql);

    RemoveEntryList(&DeviceList->List);

    RELEASE_SPIN_LOCK(&MiniBlock->Ref.SpinLock, OldIrql);

    PnPDereferencePackage();
    IoDeleteSymbolicLink(&DeviceList->SymbolicLinkName);
    IoDeleteDevice(DeviceList->DeviceObject);

    return NDIS_STATUS_SUCCESS;
}


VOID
NdisMRegisterUnloadHandler(
    IN  NDIS_HANDLE             NdisWrapperHandle,
    IN  PDRIVER_UNLOAD          UnloadHandler
    )
{
    PNDIS_WRAPPER_HANDLE    DriverInfo = (PNDIS_WRAPPER_HANDLE)NdisWrapperHandle;
    PNDIS_M_DRIVER_BLOCK    MiniBlock;

    if (DriverInfo->DriverObject == NULL)
    {
        MiniBlock = (PNDIS_M_DRIVER_BLOCK)NdisWrapperHandle;
    }
    else
    {
        MiniBlock = (PNDIS_M_DRIVER_BLOCK)IoGetDriverObjectExtension(DriverInfo->DriverObject,
                                                                     (PVOID)NDIS_PNP_MINIPORT_DRIVER_ID);
    }

    if (MiniBlock != NULL)
    {
        MiniBlock->UnloadHandler = UnloadHandler;
    }
}

NDIS_STATUS
NdisIMDeInitializeDeviceInstance(
    IN  NDIS_HANDLE             NdisMiniportHandle
    )
/*++

Routine Description:

Arguments:


Return Value:


--*/
{
    PNDIS_MINIPORT_BLOCK    Miniport;
    PNDIS_M_DRIVER_BLOCK    MiniBlock;
    NDIS_STATUS             Status = NDIS_STATUS_FAILURE;

    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
            ("==>NdisIMDeInitializeDeviceInstance: Miniport %p\n", NdisMiniportHandle));

    ASSERT (KeGetCurrentIrql() < DISPATCH_LEVEL);
    Miniport = (PNDIS_MINIPORT_BLOCK)NdisMiniportHandle;
    MiniBlock = Miniport->DriverHandle;

    if (MINIPORT_INCREMENT_REF(Miniport))
    {
        ndisReferenceDriver(MiniBlock);

        //
        // for all practical purposes we want the same thing happens as in 
        // stopping the device, i.e. device objects remain and some certain fields that
        // get initialized during AddDevice to be preserved.
        //
        Miniport->PnPDeviceState = NdisPnPDeviceStopped;
        ndisPnPRemoveDevice(Miniport->DeviceObject, NULL);
        Miniport->CurrentDevicePowerState = PowerDeviceUnspecified;
        MINIPORT_DECREMENT_REF(Miniport);
        ndisDereferenceDriver(MiniBlock, FALSE);
        Status = NDIS_STATUS_SUCCESS;
    }
    
    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
            ("<==NdisIMDeInitializeDeviceInstance: Miniport %p, Status %lx\n", NdisMiniportHandle, Status));

    return Status;
}

VOID
ndisMFinishQueuedPendingOpen(
    IN  PNDIS_POST_OPEN_PROCESSING      PostOpen
    )
/*++

Routine Description:

    Handles any pending NdisOpenAdapter() calls for miniports.

Arguments:

    PostOpen: a tempoary structure to carry the open information around

Return Value:

    Returns the status code of the open.

--*/
{
    PNDIS_OPEN_BLOCK    Open = PostOpen->Open;
    PNDIS_MINIPORT_BLOCK Miniport = Open->MiniportHandle;
    PNDIS_AF_NOTIFY     AfNotify = NULL;
    NDIS_STATUS         Status;
    UINT                OpenRef;
    KIRQL               OldIrql;

    DBGPRINT_RAW(DBG_COMP_BIND, DBG_LEVEL_INFO,
            ("==>ndisMFinishQueuedPendingOpen: PostOpen %p\n", PostOpen));

    PnPReferencePackage();
    
    NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Miniport, &OldIrql);

    //
    // If this is a binding that involves registration/open of address families, notify
    //
    ASSERT (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_IS_CO) &&
            (Open->ProtocolHandle->ProtocolCharacteristics.CoAfRegisterNotifyHandler != NULL));

    Status = ndisCreateNotifyQueue(Miniport,
                                   Open,
                                   NULL,
                                   &AfNotify);

    NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);


    if (AfNotify != NULL)
    {
        //
        // Notify existing clients of this registration
        //
        ndisNotifyAfRegistration(AfNotify);
    }
    

    FREE_POOL(PostOpen);    

    ndisDereferenceAfNotification(Open);

    NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Miniport, &OldIrql);
    ndisMDereferenceOpen(Open);
    NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);

    PnPDereferencePackage();

    DBGPRINT_RAW(DBG_COMP_BIND, DBG_LEVEL_INFO,
            ("<==ndisMFinishQueuedPendingOpen: Open %p\n", Open));
}


NDIS_STATUS
NdisMRegisterIoPortRange(
    OUT PVOID   *               PortOffset,
    IN  NDIS_HANDLE             MiniportAdapterHandle,
    IN  UINT                    InitialPort,
    IN  UINT                    NumberOfPorts
    )

/*++

Routine Description:

    Sets up an IO port for operations.

Arguments:

    PortOffset - The mapped port address the Miniport uses for NdisRaw functions.

    MiniportAdapterHandle - Handle passed to Miniport Initialize.

    InitialPort - Physical address of the starting port number.

    NumberOfPorts - Number of ports to map.

Return Value:

    None.

--*/
{
    PNDIS_MINIPORT_BLOCK            Miniport = (PNDIS_MINIPORT_BLOCK)(MiniportAdapterHandle);
    PHYSICAL_ADDRESS                PortAddress;
    PHYSICAL_ADDRESS                InitialPortAddress;
    ULONG                           addressSpace;
    NDIS_STATUS                     Status;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR pResourceDescriptor = NULL;

    DBGPRINT_RAW(DBG_COMP_CONFIG, DBG_LEVEL_INFO,
            ("==>NdisMRegisterIoPortRange: Miniport %p\n", Miniport));

    // Miniport->InfoFlags |= NDIS_MINIPORT_USES_IO;

    do
    {
        if (MINIPORT_VERIFY_TEST_FLAG(Miniport, fMINIPORT_VERIFY_FAIL_REGISTER_IO))
        {
#if DBG
            DbgPrint("NdisMRegisterIoPortRange failed to verify miniport %p\n", Miniport);
#endif
            Status = NDIS_STATUS_RESOURCES;
            break;
        }

        InitialPortAddress.QuadPart = InitialPort;
        
#if !defined(_M_IX86)


        Status = ndisTranslateResources(Miniport,
                                        CmResourceTypePort,
                                        InitialPortAddress,
                                        &PortAddress,
                                        &pResourceDescriptor);

        if (Status != NDIS_STATUS_SUCCESS)
        {
            Status = NDIS_STATUS_FAILURE;
            break;
        }

        if (pResourceDescriptor->Type == CmResourceTypeMemory)
            addressSpace = 0;
        else
            addressSpace = -1;

        if (addressSpace == 0)
        {
            //
            // memory space
            //

            *(PortOffset) = (PULONG)MmMapIoSpace(PortAddress,
                                                 NumberOfPorts,
                                                 FALSE);

            if (*(PortOffset) == (PULONG)NULL)
            {
                Status = NDIS_STATUS_RESOURCES;
                break;
            }
        }
        else
        {
            //
            // I/O space
            //
            *(PortOffset) = ULongToPtr(PortAddress.LowPart);
        }
#else   // x86 platform

        //
        // make sure the port belongs to the device
        //
        Status = ndisTranslateResources(Miniport,
                                        CmResourceTypePort,
                                        InitialPortAddress,
                                        &PortAddress,
                                        &pResourceDescriptor);

        if (Status != NDIS_STATUS_SUCCESS)
        {
            Status = NDIS_STATUS_FAILURE;
            break;
        }


        if (pResourceDescriptor->Type == CmResourceTypeMemory)
        {
            //
            // memory space
            //

            *(PortOffset) = (PULONG)MmMapIoSpace(PortAddress,
                                                 NumberOfPorts,
                                                 FALSE);

            if (*(PortOffset) == (PULONG)NULL)
            {
                Status = NDIS_STATUS_RESOURCES;
                break;
            }
        }
        else
        {
            //
            // I/O space
            //
            *(PortOffset) = (PULONG)PortAddress.LowPart;
        }
#endif
        Status = NDIS_STATUS_SUCCESS;
    } while (FALSE);


    DBGPRINT_RAW(DBG_COMP_CONFIG, DBG_LEVEL_INFO,
            ("<==NdisMRegisterIoPortRange: Miniport %p, Status %lx\n", Miniport, Status));

    return Status;
}


VOID
NdisMDeregisterIoPortRange(
    IN  NDIS_HANDLE             MiniportAdapterHandle,
    IN  UINT                    InitialPort,
    IN  UINT                    NumberOfPorts,
    IN  PVOID                   PortOffset
    )

/*++

Routine Description:

    Sets up an IO port for operations.

Arguments:

    MiniportAdapterHandle - Handle passed to Miniport Initialize.

    InitialPort - Physical address of the starting port number.

    NumberOfPorts - Number of ports to map.

    PortOffset - The mapped port address the Miniport uses for NdisRaw functions.

Return Value:

    None.

--*/
{
    PNDIS_MINIPORT_BLOCK Miniport = (PNDIS_MINIPORT_BLOCK)(MiniportAdapterHandle);
    PHYSICAL_ADDRESS PortAddress;
    PHYSICAL_ADDRESS InitialPortAddress;
    ULONG addressSpace;
    CM_PARTIAL_RESOURCE_DESCRIPTOR  Resource;
    NDIS_STATUS Status;

    DBGPRINT_RAW(DBG_COMP_CONFIG, DBG_LEVEL_INFO,
            ("==>NdisMDeregisterIoPortRange: Miniport %p\n", Miniport));

    DBGPRINT_RAW(DBG_COMP_CONFIG, DBG_LEVEL_INFO,
            ("<==NdisMDeregisterIoPortRange: Miniport %p\n", Miniport));

    return;
}


NDIS_STATUS
NdisMMapIoSpace(
    OUT PVOID *                 VirtualAddress,
    IN  NDIS_HANDLE             MiniportAdapterHandle,
    IN  NDIS_PHYSICAL_ADDRESS   PhysicalAddress,
    IN  UINT                    Length
    )
{
    NDIS_STATUS                     Status;
    ULONG                           addressSpace = 0;
    PHYSICAL_ADDRESS                PhysicalTemp;
    PNDIS_MINIPORT_BLOCK            Miniport = (PNDIS_MINIPORT_BLOCK)(MiniportAdapterHandle);
    PCM_PARTIAL_RESOURCE_DESCRIPTOR pResourceDescriptor = NULL;

    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
            ("==>NdisMMapIoSpace\n"));
    
    // Miniport->InfoFlags |= NDIS_MINIPORT_USES_MEMORY;

    if (MINIPORT_VERIFY_TEST_FLAG(Miniport, fMINIPORT_VERIFY_FAIL_MAP_IO_SPACE))
    {
#if DBG
        DbgPrint("NdisMMapIoSpace failed to verify miniport %p\n", Miniport);
#endif
        *VirtualAddress = NULL;
        return NDIS_STATUS_RESOURCES;       
    }
    

    do
    {

#if !defined(_M_IX86)

        PhysicalTemp.HighPart = 0;

        Status = ndisTranslateResources(Miniport,
                                        CmResourceTypeMemory,
                                        PhysicalAddress,
                                        &PhysicalTemp,
                                        &pResourceDescriptor);

        if (Status != NDIS_STATUS_SUCCESS)
        {

            Status = NDIS_STATUS_FAILURE;
            break;
        }

        if (pResourceDescriptor->Type == CmResourceTypeMemory)
            addressSpace = 0;
        else
            addressSpace = -1;
#else
        addressSpace = 0;               // need to do MmMapIoSpace
        
        Status = ndisTranslateResources(Miniport,
                                         CmResourceTypeMemory,
                                         PhysicalAddress,
                                         &PhysicalTemp,
                                         &pResourceDescriptor);

        if (Status != NDIS_STATUS_SUCCESS)
        {

            Status = NDIS_STATUS_FAILURE;
            break;
        }


#endif

        if (addressSpace == 0)
        {
            *VirtualAddress = MmMapIoSpace(PhysicalTemp, (Length), FALSE);
        }
        else
        {
            *VirtualAddress = ULongToPtr(PhysicalTemp.LowPart);
        }
        
        Status = NDIS_STATUS_SUCCESS;
        
        if (*VirtualAddress == NULL)
        {
            Status = NDIS_STATUS_RESOURCES;
        }
    } while (FALSE);
    
    DBGPRINT_RAW(DBG_COMP_CONFIG, DBG_LEVEL_INFO,
            ("<==NdisMMapIoSpace: Miniport %p, Status %lx\n", MiniportAdapterHandle, Status));

    return Status;
}


VOID
NdisMUnmapIoSpace(
    IN  NDIS_HANDLE             MiniportAdapterHandle,
    IN  PVOID                   VirtualAddress,
    IN  UINT                    Length
    )
{
    DBGPRINT_RAW(DBG_COMP_CONFIG, DBG_LEVEL_INFO,
            ("==>NdisMUnmapIoSpace: Miniport %p\n", MiniportAdapterHandle));

#ifndef _ALPHA_
    MmUnmapIoSpace(VirtualAddress, Length);
#endif

    DBGPRINT_RAW(DBG_COMP_CONFIG, DBG_LEVEL_INFO,
            ("<==NdisMUnmapIoSpace: Miniport %p\n", MiniportAdapterHandle));
}


VOID
NdisMAllocateSharedMemory(
    IN  NDIS_HANDLE             MiniportAdapterHandle,
    IN  ULONG                   Length,
    IN  BOOLEAN                 Cached,
    OUT PVOID   *               VirtualAddress,
    OUT PNDIS_PHYSICAL_ADDRESS  PhysicalAddress
    )
{
    PNDIS_MINIPORT_BLOCK    Miniport = (PNDIS_MINIPORT_BLOCK)MiniportAdapterHandle;
    PDMA_ADAPTER            SystemAdapterObject;
    PNDIS_WRAPPER_CONTEXT   WrapperContext;
    PULONG                  Page;
    ULONG                   Type;
    PNDIS_SHARED_MEM_SIGNATURE pSharedMemSignature = NULL; 

    // Miniport->InfoFlags |= NDIS_MINIPORT_USES_SHARED_MEMORY;
    
    SystemAdapterObject = Miniport->SystemAdapterObject;
    WrapperContext = Miniport->WrapperContext;


    DBGPRINT_RAW(DBG_COMP_CONFIG, DBG_LEVEL_INFO,
            ("==>NdisMAllocateSharedMemory: Miniport %p, Length %lx\n", Miniport, Length));
    
    PhysicalAddress->HighPart = PhysicalAddress->LowPart = 0;

    if (MINIPORT_VERIFY_TEST_FLAG(Miniport, fMINIPORT_VERIFY_FAIL_SHARED_MEM_ALLOC))
    {
#if DBG
        DbgPrint("NdisMAllocateSharedMemory failed to verify miniport %p\n", Miniport);
#endif
        *VirtualAddress = NULL;
        DBGPRINT_RAW(DBG_COMP_CONFIG, DBG_LEVEL_INFO,
                ("<==NdisMAllocateSharedMemory: Miniport %p, Length %lx\n", Miniport, Length));
        return;
    }


    if (Miniport->SystemAdapterObject == NULL)
    {
        *VirtualAddress = NULL;
        return;
    }

    if (CURRENT_IRQL >= DISPATCH_LEVEL)
    {
        BAD_MINIPORT(Miniport, "Allocating Shared Memory at raised IRQL");
        KeBugCheckEx(BUGCODE_ID_DRIVER,
                    (ULONG_PTR)Miniport,
                    Length,
                    0,
                    1);
    }

    //
    // Compute allocation size by aligning to the proper boundary.
    //
    ASSERT(Length != 0);

    Length = (Length + ndisDmaAlignment - 1) & ~(ndisDmaAlignment - 1);

    //
    // Check to determine is there is enough room left in the current page
    // to satisfy the allocation.
    //
    Type = Cached ? 1 : 0;
    ExAcquireResourceExclusiveLite(&SharedMemoryResource, TRUE);

    do
    {
        PALLOCATE_COMMON_BUFFER allocateCommonBuffer;
        allocateCommonBuffer = *SystemAdapterObject->DmaOperations->AllocateCommonBuffer;

        if (WrapperContext->SharedMemoryLeft[Type] < Length)
        {
            if ((Length + sizeof(NDIS_SHARED_MEM_SIGNATURE)) >= PAGE_SIZE)
            {
                //
                // The allocation is greater than a page.
                //
                *VirtualAddress = allocateCommonBuffer(SystemAdapterObject,
                                                       Length,
                                                       PhysicalAddress,
                                                       Cached);
                
                break;
            }

            //
            // Allocate a new page for shared alocation.
            //
            WrapperContext->SharedMemoryPage[Type] =
                allocateCommonBuffer(SystemAdapterObject,
                                     PAGE_SIZE,
                                     &WrapperContext->SharedMemoryAddress[Type],
                                     Cached);

            if (WrapperContext->SharedMemoryPage[Type] == NULL)
            {
                WrapperContext->SharedMemoryLeft[Type] = 0;
                *VirtualAddress = NULL;
                break;
            }

            //
            // Initialize the reference count in the last ULONG of the page.
            // Initialize the Tag in the second last ulong of the page
            //
            Page = (PULONG)WrapperContext->SharedMemoryPage[Type];
            pSharedMemSignature = (PNDIS_SHARED_MEM_SIGNATURE) ((PUCHAR)Page+ (PAGE_SIZE - sizeof(NDIS_SHARED_MEM_SIGNATURE)));
            pSharedMemSignature->Tag = NDIS_TAG_SHARED_MEMORY;
            pSharedMemSignature->PageRef = 0;   
            WrapperContext->SharedMemoryLeft[Type] = PAGE_SIZE - sizeof(NDIS_SHARED_MEM_SIGNATURE);
        }

        //
        // Increment the reference count, set the address of the allocation,
        // compute the physical address, and reduce the space remaining.
        //
        Page = (PULONG)WrapperContext->SharedMemoryPage[Type];

        //
        // First check whether Page is pointing to shared memory. Bugcheck to catch the driver
        //
        pSharedMemSignature = (PNDIS_SHARED_MEM_SIGNATURE) ((PUCHAR)Page+ (PAGE_SIZE - sizeof(NDIS_SHARED_MEM_SIGNATURE)));

        if (pSharedMemSignature->Tag  != NDIS_TAG_SHARED_MEMORY)
        {
            ASSERT (pSharedMemSignature->Tag == NDIS_TAG_SHARED_MEMORY);
            BAD_MINIPORT(Miniport, "Overwrote past allocated shared memory");
            KeBugCheckEx(BUGCODE_ID_DRIVER,
                          (ULONG_PTR)Miniport,
                          (ULONG_PTR)Page,
                          (ULONG_PTR)WrapperContext,
                          (ULONG_PTR)pSharedMemSignature);  
        }
        
        pSharedMemSignature->PageRef += 1;

        *VirtualAddress = (PVOID)((PUCHAR)Page +
                            (PAGE_SIZE - sizeof(NDIS_SHARED_MEM_SIGNATURE) - WrapperContext->SharedMemoryLeft[Type]));

        PhysicalAddress->QuadPart = WrapperContext->SharedMemoryAddress[Type].QuadPart +
                                        ((ULONG_PTR)(*VirtualAddress) & (PAGE_SIZE - 1));

        WrapperContext->SharedMemoryLeft[Type] -= Length;
    } while (FALSE);

    if (*VirtualAddress)
    {
        InterlockedIncrement(&Miniport->DmaAdapterRefCount);
    }

    ExReleaseResourceLite(&SharedMemoryResource);

#if DBG
    if (*VirtualAddress == NULL)
    {
         DBGPRINT_RAW(DBG_COMP_ALL, DBG_LEVEL_ERR,
            ("NdisMAllocateSharedMemory: Miniport %p, allocateCommonBuffer failed for %lx bytes\n", Miniport, Length));

    }
#endif                    
        
    if (!MINIPORT_TEST_FLAG(Miniport, fMINIPORT_64BITS_DMA) &&
        (PhysicalAddress->HighPart > 0))
    {
         
#if DBG
        DbgPrint("NdisMAllocateSharedMemory: Miniport %p, allocateCommonBuffer returned a physical address > 4G for a"
                 " non-64bit DMA adapter. PhysAddress->HighPart = %p", Miniport, PhysicalAddress->HighPart);
#endif

        ASSERT(PhysicalAddress->HighPart == 0);
        
    }

    DBGPRINT_RAW(DBG_COMP_CONFIG, DBG_LEVEL_INFO,
            ("<==NdisMAllocateSharedMemory: Miniport %p, Length %lx, Virtual Address %p\n", Miniport, Length, *VirtualAddress));


    
}

NDIS_STATUS
NdisMAllocateSharedMemoryAsync(
    IN  NDIS_HANDLE             MiniportAdapterHandle,
    IN  ULONG                   Length,
    IN  BOOLEAN                 Cached,
    IN  PVOID                   Context
    )
{
    //
    // Convert the handle to our internal structure.
    //
    PNDIS_MINIPORT_BLOCK    Miniport = (PNDIS_MINIPORT_BLOCK) MiniportAdapterHandle;
    PASYNC_WORKITEM         pWorkItem = NULL;

    // Miniport->InfoFlags |= NDIS_MINIPORT_USES_SHARED_MEMORY;

    // Allocate a workitem
    if ((Miniport->SystemAdapterObject != NULL) &&
        (Miniport->DriverHandle->MiniportCharacteristics.AllocateCompleteHandler != NULL))
    {
        pWorkItem = ALLOC_FROM_POOL(sizeof(ASYNC_WORKITEM), NDIS_TAG_ALLOC_SHARED_MEM_ASYNC);
    }

    if ((pWorkItem == NULL) ||
        !MINIPORT_INCREMENT_REF(Miniport))
    {
        if (pWorkItem != NULL)
            FREE_POOL(pWorkItem);
        return NDIS_STATUS_FAILURE;
    }

    InterlockedIncrement(&Miniport->DmaAdapterRefCount);

    // Initialize the workitem and queue it up to a worker thread
    pWorkItem->Miniport = Miniport;
    pWorkItem->Length = Length;
    pWorkItem->Cached = Cached;
    pWorkItem->Context = Context;
    INITIALIZE_WORK_ITEM(&pWorkItem->ExWorkItem, ndisMQueuedAllocateSharedHandler, pWorkItem);
    QUEUE_WORK_ITEM(&pWorkItem->ExWorkItem, CriticalWorkQueue);

    return NDIS_STATUS_PENDING;
}


VOID
ndisMQueuedAllocateSharedHandler(
    IN  PASYNC_WORKITEM         pWorkItem
    )
{
    KIRQL   OldIrql;


    // Allocate the memory
    NdisMAllocateSharedMemory(pWorkItem->Miniport,
                              pWorkItem->Length,
                              pWorkItem->Cached,
                              &pWorkItem->VAddr,
                              &pWorkItem->PhyAddr);

    //
    // we shouldn't need to reference package here
    //
    ASSERT(ndisPkgs[NDSM_PKG].ReferenceCount > 0);

    if (MINIPORT_TEST_FLAG(pWorkItem->Miniport, fMINIPORT_DESERIALIZE))
    {
        KeRaiseIrql(DISPATCH_LEVEL, &OldIrql);
    }
    else
    {
        NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(pWorkItem->Miniport, &OldIrql);
    }

    // Call the miniport back
    (*pWorkItem->Miniport->DriverHandle->MiniportCharacteristics.AllocateCompleteHandler)(
                                pWorkItem->Miniport->MiniportAdapterContext,
                                pWorkItem->VAddr,
                                &pWorkItem->PhyAddr,
                                pWorkItem->Length,
                                pWorkItem->Context);

    if (MINIPORT_TEST_FLAG(pWorkItem->Miniport, fMINIPORT_DESERIALIZE))
    {
        KeLowerIrql(OldIrql);
    }
    else
    {
        NDIS_RELEASE_MINIPORT_SPIN_LOCK(pWorkItem->Miniport, OldIrql);
    }

    ndisDereferenceDmaAdapter(pWorkItem->Miniport);

    // Dereference the miniport
    MINIPORT_DECREMENT_REF(pWorkItem->Miniport);

    // And finally free the work-item
    FREE_POOL(pWorkItem);
}


VOID
ndisFreeSharedMemory(
    IN  NDIS_HANDLE             MiniportAdapterHandle,
    IN  ULONG                   Length,
    IN  BOOLEAN                 Cached,
    IN  PVOID                   VirtualAddress,
    IN  NDIS_PHYSICAL_ADDRESS   PhysicalAddress
    )
{
    PNDIS_MINIPORT_BLOCK    Miniport = (PNDIS_MINIPORT_BLOCK)MiniportAdapterHandle;
    PDMA_ADAPTER            SystemAdapterObject;
    PNDIS_WRAPPER_CONTEXT   WrapperContext;
    PULONG                  Page;
    ULONG                   Type;
    PNDIS_SHARED_MEM_SIGNATURE pSharedMemSignature = NULL; 
    PFREE_COMMON_BUFFER     freeCommonBuffer;
    
    //
    // Get interesting information from the miniport.
    //
    SystemAdapterObject = Miniport->SystemAdapterObject;
    WrapperContext = Miniport->WrapperContext;
    

    if (SystemAdapterObject == NULL)
    {
        if (Miniport->SavedSystemAdapterObject)
            SystemAdapterObject = Miniport->SavedSystemAdapterObject;

        //
        // Non-busmasters shouldn't call this routine.
        //
        ASSERT(SystemAdapterObject != NULL);

#if DBG
        DbgPrint("Ndis: WARNING... Miniport %p freeing shared memory -after- freeing map registers.\n", Miniport);

        if (MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_VERIFYING) && (ndisFlags & NDIS_GFLAG_BREAK_ON_WARNING))
            DbgBreakPoint();

#endif
        Miniport->SystemAdapterObject = Miniport->SavedSystemAdapterObject;

    }


    freeCommonBuffer = *SystemAdapterObject->DmaOperations->FreeCommonBuffer;

    //
    // Compute allocation size by aligning to the proper boundary.
    //
    ASSERT(Length != 0);
    
    Length = (Length + ndisDmaAlignment - 1) & ~(ndisDmaAlignment - 1);
    
    //
    // Free the specified memory.
    //
    ExAcquireResourceExclusiveLite(&SharedMemoryResource, TRUE);
    if ((Length + sizeof(NDIS_SHARED_MEM_SIGNATURE)) >= PAGE_SIZE)
    {
        //
        // The allocation is greater than a page free the page directly.
        //
        freeCommonBuffer(SystemAdapterObject,
                         Length,
                         PhysicalAddress,
                         VirtualAddress,
                         Cached);
    
    }
    else
    {
        //
        // Decrement the reference count and if the result is zero, then free
        // the page.
        //
    
        Page = (PULONG)((ULONG_PTR)VirtualAddress & ~(PAGE_SIZE - 1));
        //
        // First check whether Page is pointing to shared memory. Bugcheck to catch the driver
        //
        pSharedMemSignature = (PNDIS_SHARED_MEM_SIGNATURE) ((PUCHAR)Page + (PAGE_SIZE - sizeof(NDIS_SHARED_MEM_SIGNATURE)));
        
        if (pSharedMemSignature->Tag != NDIS_TAG_SHARED_MEMORY)
        {
            ASSERT (pSharedMemSignature->Tag == NDIS_TAG_SHARED_MEMORY);
            BAD_MINIPORT(Miniport, "Freeing shared memory not allocated");
            KeBugCheckEx(BUGCODE_ID_DRIVER,
                          (ULONG_PTR)Miniport,
                          (ULONG_PTR)Page,
                          (ULONG_PTR)pSharedMemSignature,
                          (ULONG_PTR)VirtualAddress );
        }

        pSharedMemSignature->PageRef -= 1;

        //
        //  If the references on the page have gone to zero then free the page
        //
        
        if (pSharedMemSignature->PageRef == 0)
        {
            //
            // Compute the physical address of the page and free it.
            //

            PhysicalAddress.LowPart &= ~(PAGE_SIZE - 1);
            freeCommonBuffer(SystemAdapterObject,
                             PAGE_SIZE,
                             PhysicalAddress,
                             Page,
                             Cached);

            Type = Cached ? 1 : 0;
            if ((PVOID)Page == WrapperContext->SharedMemoryPage[Type])
            {
                WrapperContext->SharedMemoryLeft[Type] = 0;
                WrapperContext->SharedMemoryPage[Type] = NULL;
            }
        }
    }

    ndisDereferenceDmaAdapter(Miniport);

    ExReleaseResourceLite(&SharedMemoryResource);
}
VOID
NdisMFreeSharedMemory(
    IN  NDIS_HANDLE             MiniportAdapterHandle,
    IN  ULONG                   Length,
    IN  BOOLEAN                 Cached,
    IN  PVOID                   VirtualAddress,
    IN  NDIS_PHYSICAL_ADDRESS   PhysicalAddress
    )
{
    PNDIS_MINIPORT_BLOCK    Miniport = (PNDIS_MINIPORT_BLOCK)MiniportAdapterHandle;

    if (CURRENT_IRQL < DISPATCH_LEVEL)
    {
        ndisFreeSharedMemory(MiniportAdapterHandle,
                             Length,
                             Cached,
                             VirtualAddress,
                             PhysicalAddress);
    }
    else if (MINIPORT_INCREMENT_REF(Miniport))
    {
        PASYNC_WORKITEM pWorkItem = NULL;

        // Allocate a work-item and queue it up to a worker thread
        pWorkItem = ALLOC_FROM_POOL(sizeof(ASYNC_WORKITEM), NDIS_TAG_FREE_SHARED_MEM_ASYNC);
        if (pWorkItem != NULL)
        {
            // Initialize the workitem and queue it up to a worker thread
            pWorkItem->Miniport = Miniport;
            pWorkItem->Length = Length;
            pWorkItem->Cached = Cached;
            pWorkItem->VAddr = VirtualAddress;
            pWorkItem->PhyAddr = PhysicalAddress;
            INITIALIZE_WORK_ITEM(&pWorkItem->ExWorkItem, ndisMQueuedFreeSharedHandler, pWorkItem);
            QUEUE_WORK_ITEM(&pWorkItem->ExWorkItem, CriticalWorkQueue);
        }

        // What do we do now ?
    }
}

VOID
ndisMQueuedFreeSharedHandler(
    IN  PASYNC_WORKITEM         pWorkItem
    )
{
    // Free the memory
    ndisFreeSharedMemory(pWorkItem->Miniport,
                         pWorkItem->Length,
                         pWorkItem->Cached,
                         pWorkItem->VAddr,
                         pWorkItem->PhyAddr);

    // Dereference the miniport
    MINIPORT_DECREMENT_REF(pWorkItem->Miniport);

    // And finally free the work-item
    FREE_POOL(pWorkItem);
}


NDIS_STATUS
NdisMRegisterDmaChannel(
    OUT PNDIS_HANDLE            MiniportDmaHandle,
    IN  NDIS_HANDLE             MiniportAdapterHandle,
    IN  UINT                    DmaChannel,
    IN  BOOLEAN                 Dma32BitAddresses,
    IN  PNDIS_DMA_DESCRIPTION   DmaDescription,
    IN  ULONG                   MaximumLength
    )
{
    PNDIS_MINIPORT_BLOCK            Miniport = (PNDIS_MINIPORT_BLOCK)(MiniportAdapterHandle);
    NDIS_STATUS                     Status;
    NDIS_INTERFACE_TYPE             BusType;
    ULONG                           BusNumber;
    DEVICE_DESCRIPTION              DeviceDescription;
    PDMA_ADAPTER                    AdapterObject;
    ULONG                           MapRegistersNeeded;
    ULONG                           MapRegistersAllowed;
    PNDIS_DMA_BLOCK                 DmaBlock;
    KIRQL                           OldIrql;
    NTSTATUS                        NtStatus;

    
    DBGPRINT_RAW(DBG_COMP_CONFIG, DBG_LEVEL_INFO,
            ("==>NdisMRegisterDmaChannel: Miniport %p\n", Miniport));

    BusType = Miniport->BusType;
    BusNumber = Miniport->BusNumber;

    do
    {
        //
        // Set up the device description; zero it out in case its
        // size changes.
        //
    
        ZeroMemory(&DeviceDescription, sizeof(DEVICE_DESCRIPTION));
    
        DeviceDescription.Version = DEVICE_DESCRIPTION_VERSION;
    
        DeviceDescription.Master = MINIPORT_TEST_FLAG(Miniport, fMINIPORT_BUS_MASTER);
    
        DeviceDescription.ScatterGather = MINIPORT_TEST_FLAG(Miniport, fMINIPORT_BUS_MASTER);
    
        DeviceDescription.DemandMode = DmaDescription->DemandMode;
        DeviceDescription.AutoInitialize = DmaDescription->AutoInitialize;
    
        DeviceDescription.Dma32BitAddresses = Dma32BitAddresses;
    
        DeviceDescription.BusNumber = Miniport->BusNumber;
        DeviceDescription.DmaChannel = DmaChannel;
        DeviceDescription.InterfaceType = BusType;
        DeviceDescription.DmaWidth = DmaDescription->DmaWidth;
        DeviceDescription.DmaSpeed = DmaDescription->DmaSpeed;
        DeviceDescription.MaximumLength = MaximumLength;
        DeviceDescription.DmaPort = DmaDescription->DmaPort;
    
        MapRegistersNeeded = ((MaximumLength - 2) / PAGE_SIZE) + 2;
    
        //
        // Get the adapter object.
        //
        AdapterObject =
                    IoGetDmaAdapter(Miniport->PhysicalDeviceObject,
                                    &DeviceDescription,
                                    &MapRegistersAllowed);
    
        if ((AdapterObject == NULL) || (MapRegistersAllowed < MapRegistersNeeded))
        {
            Status = NDIS_STATUS_RESOURCES;
            break;
        }
    
        //
        // Allocate storage for our DMA block.
        //
        DmaBlock = (PNDIS_DMA_BLOCK)ALLOC_FROM_POOL(sizeof(NDIS_DMA_BLOCK), NDIS_TAG_DMA);
    
        if (DmaBlock == (PNDIS_DMA_BLOCK)NULL)
        {
            Status = NDIS_STATUS_RESOURCES;
            break;
        }
    
        //
        // Use this event to tell us when ndisAllocationExecutionRoutine
        // has been called.
        //
        INITIALIZE_EVENT(&DmaBlock->AllocationEvent);
    
        //
        // We save this to call IoFreeAdapterChannel later.
        //
        (PDMA_ADAPTER)DmaBlock->SystemAdapterObject = AdapterObject;
    
        ASSERT(ndisPkgs[NPNP_PKG].ReferenceCount > 0);
        PnPReferencePackage();
    
        //
        // Now allocate the adapter channel.
        //
        RAISE_IRQL_TO_DISPATCH(&OldIrql);
    
        NtStatus = AdapterObject->DmaOperations->AllocateAdapterChannel(AdapterObject,
                                                                        Miniport->DeviceObject,
                                                                        MapRegistersNeeded,
                                                                        ndisDmaExecutionRoutine,
                                                                        (PVOID)DmaBlock);
    
        LOWER_IRQL(OldIrql, DISPATCH_LEVEL);
        
        PnPDereferencePackage();
    
        if (!NT_SUCCESS(NtStatus))
        {
            DBGPRINT_RAW(DBG_COMP_ALL, DBG_LEVEL_ERR,
                    ("NDIS DMA AllocateAdapterChannel: %lx\n", NtStatus));

            FREE_POOL(DmaBlock);
            Status = NDIS_STATUS_RESOURCES;

            break;
        }
    
    
        //
        // ndisDmaExecutionRoutine will set this event
        // when it has been called.
        //
        NtStatus = WAIT_FOR_OBJECT(&DmaBlock->AllocationEvent, 0);
    
        if (!NT_SUCCESS(NtStatus))
        {
            DBGPRINT_RAW(DBG_COMP_ALL, DBG_LEVEL_ERR,
                    ("NDIS DMA AllocateAdapterChannel: %lx\n", NtStatus));

            FREE_POOL(DmaBlock);
            Status = NDIS_STATUS_RESOURCES;
            break;
        }
    
        RESET_EVENT(&DmaBlock->AllocationEvent);
    
        //
        // We now have the DMA channel allocated, we are done.
        //
        DmaBlock->InProgress = FALSE;
    
        *MiniportDmaHandle = (NDIS_HANDLE)DmaBlock;
        Status = NDIS_STATUS_SUCCESS;
    } while (FALSE);

    
    DBGPRINT_RAW(DBG_COMP_CONFIG, DBG_LEVEL_INFO,
            ("<==NdisMRegisterDmaChannel: Miniport %p, Status %lx\n", Miniport, Status));
    
    return Status;
}



VOID
NdisMDeregisterDmaChannel(
    IN  NDIS_HANDLE             MiniportDmaHandle
    )
{
    KIRQL           OldIrql;
    PNDIS_DMA_BLOCK DmaBlock = (PNDIS_DMA_BLOCK)MiniportDmaHandle;
    PPUT_DMA_ADAPTER    putDmaAdapter;

    DBGPRINT_RAW(DBG_COMP_CONFIG, DBG_LEVEL_INFO,
            ("==>NdisMDeregisterDmaChannel\n"));

    ASSERT(ndisPkgs[NPNP_PKG].ReferenceCount > 0);
    PnPReferencePackage();
    
    RAISE_IRQL_TO_DISPATCH(&OldIrql);
    ((PDMA_ADAPTER)DmaBlock->SystemAdapterObject)->DmaOperations->FreeAdapterChannel(DmaBlock->SystemAdapterObject);
    LOWER_IRQL(OldIrql, DISPATCH_LEVEL);

    putDmaAdapter = ((PDMA_ADAPTER)DmaBlock->SystemAdapterObject)->DmaOperations->PutDmaAdapter;
    putDmaAdapter((PDMA_ADAPTER)DmaBlock->SystemAdapterObject);

    PnPDereferencePackage();

    FREE_POOL(DmaBlock);
    
    DBGPRINT_RAW(DBG_COMP_CONFIG, DBG_LEVEL_INFO,
            ("<==NdisMDeregisterDmaChannel\n"));

}


NDIS_STATUS
NdisMAllocateMapRegisters(
    IN  NDIS_HANDLE             MiniportAdapterHandle,
    IN  UINT                    DmaChannel,
    IN  NDIS_DMA_SIZE           DmaSize,
    IN  ULONG                   BaseMapRegistersNeeded,
    IN  ULONG                   MaximumPhysicalMapping
    )
/*++

Routine Description:

    Allocates map registers for bus mastering devices.

Arguments:

    MiniportAdapterHandle - Handle passed to MiniportInitialize.

    BaseMapRegistersNeeded - The maximum number of base map registers needed
        by the Miniport at any one time.

    MaximumPhysicalMapping - Maximum length of a buffer that will have to be mapped.

Return Value:

    None.

--*/

{
    //
    // Convert the handle to our internal structure.
    //
    PNDIS_MINIPORT_BLOCK Miniport = (PNDIS_MINIPORT_BLOCK) MiniportAdapterHandle;

    //
    // This is needed by HalGetAdapter.
    //
    DEVICE_DESCRIPTION DeviceDescription;

    //
    // Returned by HalGetAdapter.
    //
    ULONG MapRegistersAllowed;

    //
    // Returned by IoGetDmaAdapter.
    //
    PDMA_ADAPTER AdapterObject;

    PALLOCATE_ADAPTER_CHANNEL   allocateAdapterChannel;
    PFREE_MAP_REGISTERS         freeMapRegisters;
    
    //
    // Map registers needed per channel.
    //
    ULONG MapRegistersPerChannel;

    NTSTATUS    NtStatus;
    KIRQL       OldIrql;
    USHORT      i;
    NDIS_STATUS Status = NDIS_STATUS_SUCCESS;
    BOOLEAN     AllocationFailed;
    KEVENT      AllocationEvent;

    DBGPRINT_RAW(DBG_COMP_CONFIG, DBG_LEVEL_INFO,
            ("==>NdisMAllocateMapRegisters: Miniport %p, BaseMapRegistersNeeded %lx\n", Miniport, BaseMapRegistersNeeded));

    ASSERT(ndisPkgs[NPNP_PKG].ReferenceCount > 0);
    PnPReferencePackage();

    // Miniport->InfoFlags |= NDIS_MINIPORT_USES_MAP_REGISTERS;

    do
    {
    
        if (MINIPORT_VERIFY_TEST_FLAG(Miniport, fMINIPORT_VERIFY_FAIL_MAP_REG_ALLOC))
        {
#if DBG
            DbgPrint("NdisMAllocateMapRegisters failed to verify miniport %p\n", Miniport);
#endif
            Status = NDIS_STATUS_RESOURCES;
            break;
        }
    
        //
        // If the device is a busmaster, we get an adapter
        // object for it.
        // If map registers are needed, we loop, allocating an
        // adapter channel for each map register needed.
        //

        if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_BUS_MASTER))
        {

            Miniport->BaseMapRegistersNeeded = (USHORT)BaseMapRegistersNeeded;
            Miniport->MaximumPhysicalMapping = MaximumPhysicalMapping;

            //
            // Allocate storage for holding the appropriate
            // information for each map register.
            //

            Miniport->MapRegisters = NULL;
            if (BaseMapRegistersNeeded > 0)
            {
                Miniport->MapRegisters = (PMAP_REGISTER_ENTRY)
                        ALLOC_FROM_POOL(sizeof(MAP_REGISTER_ENTRY) * BaseMapRegistersNeeded,
                                        NDIS_TAG_MAP_REG);
            
                if (Miniport->MapRegisters == (PMAP_REGISTER_ENTRY)NULL)
                {
                    //
                    // Error out
                    //

                    NdisWriteErrorLogEntry((NDIS_HANDLE)Miniport,
                                           NDIS_ERROR_CODE_OUT_OF_RESOURCES,
                                           1,
                                           0xFFFFFFFF);

                    Status =  NDIS_STATUS_RESOURCES;
                    break;
                }
            }

            //
            // Use this event to tell us when ndisAllocationExecutionRoutine
            // has been called.
            //

            Miniport->AllocationEvent = &AllocationEvent;
            INITIALIZE_EVENT(&AllocationEvent);

            //
            // Set up the device description; zero it out in case its
            // size changes.
            //

            ZeroMemory(&DeviceDescription, sizeof(DEVICE_DESCRIPTION));

            DeviceDescription.Version = DEVICE_DESCRIPTION_VERSION;
            DeviceDescription.Master = TRUE;
            DeviceDescription.ScatterGather = TRUE;

            DeviceDescription.BusNumber = Miniport->BusNumber;
            DeviceDescription.DmaChannel = DmaChannel;
            DeviceDescription.InterfaceType = Miniport->AdapterType;

            if (DeviceDescription.InterfaceType == NdisInterfaceIsa)
            {
                //
                // For ISA devices, the width is based on the DMA channel:
                // 0-3 == 8 bits, 5-7 == 16 bits. Timing is compatibility
                // mode.
                //

                if (DmaChannel > 4)
                {
                    DeviceDescription.DmaWidth = Width16Bits;
                }
                else
                {
                    DeviceDescription.DmaWidth = Width8Bits;
                }
                DeviceDescription.DmaSpeed = Compatible;

            }
            else if (DeviceDescription.InterfaceType == NdisInterfacePci)
            {
                if (DmaSize == NDIS_DMA_32BITS)
                {
                    DeviceDescription.Dma32BitAddresses = TRUE;
                }
                else if (DmaSize == NDIS_DMA_64BITS)
                {
                    DeviceDescription.Dma64BitAddresses = TRUE;
                    MINIPORT_SET_FLAG(Miniport, fMINIPORT_64BITS_DMA);
                }
            }

            DeviceDescription.MaximumLength = MaximumPhysicalMapping;

            //
            // Determine how many map registers we need per channel.
            //
            MapRegistersPerChannel = ((MaximumPhysicalMapping - 2) / PAGE_SIZE) + 2;
            
#if DBG
            if (MapRegistersPerChannel > 16)
            {
                DBGPRINT_RAW(DBG_COMP_CONFIG, DBG_LEVEL_WARN,
                    ("NdisMAllocateMapRegisters: Miniport %p, MaximumPhysicalMapping of 0x%lx\nwould require more than 16 MAP registers per channel, the call may fail\n",
                    Miniport, MaximumPhysicalMapping));
                            
            }           
#endif


            NDIS_WARN((Miniport->BaseMapRegistersNeeded * MapRegistersPerChannel > 0x40),
                      Miniport, 
                      NDIS_GFLAG_WARN_LEVEL_0,
                      ("ndisMInitializeAdapter: Miniport %p is asking for too many %ld > 64 map registers.\n",
                       Miniport, Miniport->BaseMapRegistersNeeded * MapRegistersPerChannel
                      ));


            //
            // Get the adapter object.
            //

            AdapterObject =
                            IoGetDmaAdapter(Miniport->PhysicalDeviceObject, &DeviceDescription, &MapRegistersAllowed);

            if ((AdapterObject == NULL) || (MapRegistersAllowed < MapRegistersPerChannel))
            {
                NdisWriteErrorLogEntry((NDIS_HANDLE)Miniport,
                                       NDIS_ERROR_CODE_OUT_OF_RESOURCES,
                                       1,
                                       0xFFFFFFFF);

                FREE_POOL(Miniport->MapRegisters);
                Miniport->MapRegisters = NULL;
                Status = NDIS_STATUS_RESOURCES;
                
                if (AdapterObject != NULL)
                {
                    RAISE_IRQL_TO_DISPATCH(&OldIrql);
                    ((PDMA_ADAPTER)AdapterObject)->DmaOperations->PutDmaAdapter((PDMA_ADAPTER)AdapterObject);
                    LOWER_IRQL(OldIrql, DISPATCH_LEVEL);
                }
                break;
            }

            //
            // We save this to call IoFreeMapRegisters later.
            //

            Miniport->SystemAdapterObject = AdapterObject;
            Miniport->SavedSystemAdapterObject = NULL;
            ASSERT(Miniport->DmaAdapterRefCount == 0);
            InterlockedIncrement(&Miniport->DmaAdapterRefCount);
            
            allocateAdapterChannel = *AdapterObject->DmaOperations->AllocateAdapterChannel;
            freeMapRegisters = *AdapterObject->DmaOperations->FreeMapRegisters;

            //
            // Now loop, allocating an adapter channel each time, then
            // freeing everything but the map registers.
            //
            AllocationFailed = FALSE;
            for (i=0; i<Miniport->BaseMapRegistersNeeded; i++)
            {
                Miniport->CurrentMapRegister = i;

                RAISE_IRQL_TO_DISPATCH(&OldIrql);

                NtStatus = allocateAdapterChannel(AdapterObject,
                                                  Miniport->DeviceObject,
                                                  MapRegistersPerChannel,
                                                  ndisAllocationExecutionRoutine,
                                                  Miniport);

                if (!NT_SUCCESS(NtStatus))
                {
                    DBGPRINT(DBG_COMP_ALL, DBG_LEVEL_ERR,
                            ("AllocateAdapterChannel: %lx\n", NtStatus));

                    for (; i != 0; i--)
                    {
                        freeMapRegisters(Miniport->SystemAdapterObject,
                                           Miniport->MapRegisters[i-1].MapRegister,
                                           MapRegistersPerChannel);
                    }

                    LOWER_IRQL(OldIrql, DISPATCH_LEVEL);

                    NdisWriteErrorLogEntry((NDIS_HANDLE)Miniport,
                                           NDIS_ERROR_CODE_OUT_OF_RESOURCES,
                                           1,
                                           0xFFFFFFFF);

                    FREE_POOL(Miniport->MapRegisters);
                    Miniport->MapRegisters = NULL;

                    ndisDereferenceDmaAdapter(Miniport);
                    AllocationFailed = TRUE;
                    break;
                }

                LOWER_IRQL(OldIrql, DISPATCH_LEVEL);


                //
                // wait indefinitely for allocation routine to be called
                //
                NtStatus = WAIT_FOR_OBJECT(&AllocationEvent, 0);

                if (!NT_SUCCESS(NtStatus))
                {
                    DBGPRINT(DBG_COMP_ALL, DBG_LEVEL_ERR,
                            ("    NDIS DMA AllocateAdapterChannel: %lx\n", NtStatus));

                    RAISE_IRQL_TO_DISPATCH(&OldIrql);

                    for (; i != 0; i--)
                    {
                        freeMapRegisters(Miniport->SystemAdapterObject,
                                         Miniport->MapRegisters[i-1].MapRegister,
                                         MapRegistersPerChannel);
                    }

                    LOWER_IRQL(OldIrql, DISPATCH_LEVEL);

                    NdisWriteErrorLogEntry((NDIS_HANDLE)Miniport,
                                            NDIS_ERROR_CODE_OUT_OF_RESOURCES,
                                            1,
                                            0xFFFFFFFF);

                    FREE_POOL(Miniport->MapRegisters);
                    Miniport->MapRegisters = NULL;
                    
                    ndisDereferenceDmaAdapter(Miniport);
                    
                    AllocationFailed = TRUE;
                    break;
                }

                RESET_EVENT(&AllocationEvent);
            }

            if (AllocationFailed)
            {
                Status = NDIS_STATUS_RESOURCES;
                break;
            }
        }

    } while (FALSE);

    PnPDereferencePackage();

    DBGPRINT_RAW(DBG_COMP_CONFIG, DBG_LEVEL_INFO,
            ("<==NdisMAllocateMapRegisters: Miniport %p, Status %lx\n", Miniport, Status));

    return Status;
}


VOID
NdisMFreeMapRegisters(
    IN  NDIS_HANDLE             MiniportAdapterHandle
    )

/*++

Routine Description:

    Releases allocated map registers

Arguments:

    MiniportAdapterHandle - Handle passed to MiniportInitialize.

Return Value:

    None.

--*/

{
    //
    // Convert the handle to our internal structure.
    //
    PNDIS_MINIPORT_BLOCK Miniport = (PNDIS_MINIPORT_BLOCK) MiniportAdapterHandle;
    PFREE_MAP_REGISTERS freeMapRegisters;
    KIRQL OldIrql;
    ULONG i;

    DBGPRINT_RAW(DBG_COMP_CONFIG, DBG_LEVEL_INFO,
            ("==>NdisMFreeMapRegisters: Miniport %p\n", Miniport));

    ASSERT(ndisPkgs[NPNP_PKG].ReferenceCount > 0);
    PnPReferencePackage();

    ASSERT(MINIPORT_TEST_FLAG(Miniport, fMINIPORT_BUS_MASTER));
    ASSERT(Miniport->MapRegisters != NULL);
    ASSERT(Miniport->SystemAdapterObject != NULL);

    if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_BUS_MASTER) &&
        (Miniport->MapRegisters != NULL))
    {
        ULONG MapRegistersPerChannel =
            ((Miniport->MaximumPhysicalMapping - 2) / PAGE_SIZE) + 2;

        freeMapRegisters = *Miniport->SystemAdapterObject->DmaOperations->FreeMapRegisters;

        
        RAISE_IRQL_TO_DISPATCH(&OldIrql);
        for (i = 0; i < Miniport->BaseMapRegistersNeeded; i++)
        {

            freeMapRegisters(Miniport->SystemAdapterObject,
                             Miniport->MapRegisters[i].MapRegister,
                             MapRegistersPerChannel);

        }
        LOWER_IRQL(OldIrql, DISPATCH_LEVEL);

        //
        // Map registers are allocated from non-paged pool.
        // So this memory can be freed at DISPATCH
        //
        FREE_POOL(Miniport->MapRegisters);
        Miniport->MapRegisters = NULL;
                
        ndisDereferenceDmaAdapter(Miniport);
    }

    PnPDereferencePackage();

    DBGPRINT_RAW(DBG_COMP_CONFIG, DBG_LEVEL_INFO,
            ("<==NdisMFreeMapRegisters: Miniport %p\n", Miniport));
}


ULONG
NdisMReadDmaCounter(
    IN  NDIS_HANDLE             MiniportDmaHandle
    )
/*++

Routine Description:

    Reads the current value of the dma counter

Arguments:

    MiniportDmaHandle - Handle for the DMA transfer.

Return Value:

    current value of a DMA counter

--*/

{
    return ((PDMA_ADAPTER)((PNDIS_DMA_BLOCK)(MiniportDmaHandle))->SystemAdapterObject)->DmaOperations->ReadDmaCounter(((PNDIS_DMA_BLOCK)(MiniportDmaHandle))->SystemAdapterObject);
}


VOID
ndisBugcheckHandler(
    IN  PNDIS_WRAPPER_CONTEXT   WrapperContext,
    IN  ULONG                   Size
    )
/*++

Routine Description:

    This routine is called when a bugcheck occurs in the system.

Arguments:

    Buffer  -- Ndis wrapper context.

    Size    -- Size of wrapper context

Return Value:

    Void.

--*/
{
    PNDIS_MINIPORT_BLOCK        Miniport;
    
    if (Size == sizeof(NDIS_WRAPPER_CONTEXT))
    {
        Miniport = (PNDIS_MINIPORT_BLOCK)(WrapperContext + 1);
        MINIPORT_PNP_SET_FLAG(Miniport, fMINIPORT_SHUTTING_DOWN);

        if (WrapperContext->ShutdownHandler != NULL)
        {
            WrapperContext->ShutdownHandler(WrapperContext->ShutdownContext);
        }
    }
}


VOID
NdisMRegisterAdapterShutdownHandler(
    IN  NDIS_HANDLE             MiniportHandle,
    IN  PVOID                   ShutdownContext,
    IN  ADAPTER_SHUTDOWN_HANDLER ShutdownHandler
    )
/*++

Routine Description:

    Deregisters an NDIS adapter.

Arguments:

    MiniportHandle - The miniport.

    ShutdownHandler - The Handler for the Adapter, to be called on shutdown.

Return Value:

    none.

--*/
{
    PNDIS_MINIPORT_BLOCK Miniport = (PNDIS_MINIPORT_BLOCK) MiniportHandle;
    PNDIS_WRAPPER_CONTEXT WrapperContext = Miniport->WrapperContext;

    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
            ("==>NdisMRegisterAdapterShutdownHandler: Miniport %p\n", Miniport));

    if (WrapperContext->ShutdownHandler == NULL)
    {
        //
        // Store information
        //

        WrapperContext->ShutdownHandler = ShutdownHandler;
        WrapperContext->ShutdownContext = ShutdownContext;

        //
        // Register our shutdown handler for a bugcheck.  (Note that we are
        // already registered for shutdown notification.)
        //

        KeInitializeCallbackRecord(&WrapperContext->BugcheckCallbackRecord);

        KeRegisterBugCheckCallback(&WrapperContext->BugcheckCallbackRecord, // callback record.
                                   ndisBugcheckHandler,                     // callback routine.
                                   WrapperContext,                          // free form buffer.
                                   sizeof(NDIS_WRAPPER_CONTEXT),            // buffer size.
                                   "Ndis miniport");                        // component id.
    }

    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
            ("<==NdisMRegisterAdapterShutdownHandler: Miniport %p\n", Miniport));
}


VOID
NdisMDeregisterAdapterShutdownHandler(
    IN  NDIS_HANDLE             MiniportHandle
    )
/*++

Routine Description:

Arguments:

    MiniportHandle - The miniport.

Return Value:

    None.

--*/
{
    PNDIS_MINIPORT_BLOCK Miniport = (PNDIS_MINIPORT_BLOCK) MiniportHandle;
    PNDIS_WRAPPER_CONTEXT WrapperContext = Miniport->WrapperContext;

    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
            ("==>NdisMDeregisterAdapterShutdownHandler: Miniport %p\n", Miniport));

    //
    // Clear information
    //

    if (WrapperContext->ShutdownHandler != NULL)
    {
        KeDeregisterBugCheckCallback(&WrapperContext->BugcheckCallbackRecord);
        WrapperContext->ShutdownHandler = NULL;
    }

    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
            ("<==NdisMDeregisterAdapterShutdownHandler: Miniport %p\n", Miniport));
}


NDIS_STATUS
NdisMPciAssignResources(
    IN  NDIS_HANDLE             MiniportHandle,
    IN  ULONG                   SlotNumber,
    OUT PNDIS_RESOURCE_LIST *   AssignedResources
    )
/*++

Routine Description:

    This routine uses the Hal to assign a set of resources to a PCI
    device.

Arguments:

    MiniportHandle - The miniport.

    SlotNumber - Slot number of the device.

    AssignedResources - The returned resources.

Return Value:

    Status of the operation

--*/
{
    PNDIS_MINIPORT_BLOCK Miniport = (PNDIS_MINIPORT_BLOCK) MiniportHandle;

    DBGPRINT_RAW(DBG_COMP_CONFIG, DBG_LEVEL_INFO,
            ("==>NdisMPciAssignResources: Miniport %p\n", Miniport));


    NDIS_WARN(TRUE, Miniport, NDIS_GFLAG_WARN_LEVEL_3,
        ("NdisMPciAssignResources: Miniport %p should use NdisMQueryAdapterResources to get resources.\n", Miniport));

    if ((Miniport->BusType != NdisInterfacePci) || (Miniport->AllocatedResources == NULL))
    {
        *AssignedResources = NULL;
        DBGPRINT(DBG_COMP_CONFIG, DBG_LEVEL_INFO,
                ("<==NdisMPciAssignResources: Miniport %p\n", Miniport));
        return NDIS_STATUS_FAILURE;
    }

    *AssignedResources = &Miniport->AllocatedResources->List[0].PartialResourceList;

    DBGPRINT_RAW(DBG_COMP_CONFIG, DBG_LEVEL_INFO,
            ("<==NdisMPciAssignResources: Miniport %p\n", Miniport));

    return NDIS_STATUS_SUCCESS;
}

VOID
NdisMQueryAdapterResources(
    OUT PNDIS_STATUS            Status,
    IN  NDIS_HANDLE             WrapperConfigurationContext,
    OUT PNDIS_RESOURCE_LIST     ResourceList,
    IN  IN  PUINT               BufferSize
    )
{
    PDEVICE_OBJECT DeviceObject;
    PNDIS_MINIPORT_BLOCK Miniport;
    ULONG               MemNeeded;

    DBGPRINT_RAW(DBG_COMP_CONFIG, DBG_LEVEL_INFO,
        ("==>NdisMQueryAdapterResources: WrapperConfigurationContext %p\n", WrapperConfigurationContext));

    DeviceObject = ((PNDIS_WRAPPER_CONFIGURATION_HANDLE)WrapperConfigurationContext)->DeviceObject;
    Miniport = (PNDIS_MINIPORT_BLOCK)((PNDIS_WRAPPER_CONTEXT)DeviceObject->DeviceExtension + 1);
    
    DBGPRINT_RAW(DBG_COMP_CONFIG, DBG_LEVEL_INFO,
        ("NdisMQueryAdapterResources: Miniport %p\n", Miniport));

    if (Miniport->AllocatedResources == NULL)
    {
        *Status = NDIS_STATUS_FAILURE;
    }
    else
    {
        MemNeeded = sizeof(CM_PARTIAL_RESOURCE_LIST) - sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR)
                        + Miniport->AllocatedResources->List[0].PartialResourceList.Count *
                        sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR);

        if (*BufferSize < MemNeeded)
        {
            *BufferSize = MemNeeded;
            *Status = NDIS_STATUS_RESOURCES;
        }
        else
        {

            NdisMoveMemory(
                        ResourceList,
                        &Miniport->AllocatedResources->List[0].PartialResourceList,
                        MemNeeded
                        );

            *Status = NDIS_STATUS_SUCCESS;
        }
    }

    DBGPRINT_RAW(DBG_COMP_CONFIG, DBG_LEVEL_INFO,
        ("<==NdisMQueryAdapterResources: Miniport %p, Status %lx\n", Miniport, *Status));

    return;

}


NTSTATUS
ndisPnPAddDevice(
    IN  PDRIVER_OBJECT          DriverObject,
    IN  PDEVICE_OBJECT          PhysicalDeviceObject
    )
/*++

Routine Description:

    The AddDevice entry point is called by the Plug & Play manager
    to inform the driver when a new device instance arrives that this
    driver must control.

Arguments:


Return Value:


--*/
{
    NTSTATUS                NtStatus, Status;
    PWSTR                   ExportData = NULL;
    UNICODE_STRING          ExportName, BusStr;
    HANDLE                  Handle = NULL;
    PUINT                   BusTypeData = NULL, CharacteristicsData = NULL;
    ULONG                   ValueType;
    RTL_QUERY_REGISTRY_TABLE LQueryTable[3];

    DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
        ("==>ndisPnPAddDevice: DriverObject %p, PDO %p\n", DriverObject, PhysicalDeviceObject));

    Status = STATUS_UNSUCCESSFUL;

    do
    {
#if NDIS_TEST_REG_FAILURE
        NtStatus = STATUS_UNSUCCESSFUL;
#else
        NtStatus = IoOpenDeviceRegistryKey(PhysicalDeviceObject,
                                           PLUGPLAY_REGKEY_DRIVER,
                                           GENERIC_READ | MAXIMUM_ALLOWED,
                                           &Handle);

#endif

#if !NDIS_NO_REGISTRY

        if (!NT_SUCCESS(NtStatus))
            break;

        //
        // 1.
        // Switch to the Linkage key below this driver instance key
        //
        LQueryTable[0].QueryRoutine = NULL;
        LQueryTable[0].Flags = RTL_QUERY_REGISTRY_SUBKEY;
        LQueryTable[0].Name = L"Linkage";

        //
        // 2.
        // Read the export and rootdevice keywords
        //
        LQueryTable[1].QueryRoutine = ndisReadParameter;
        LQueryTable[1].Flags = RTL_QUERY_REGISTRY_REQUIRED | RTL_QUERY_REGISTRY_NOEXPAND;
        LQueryTable[1].Name = L"Export";
        LQueryTable[1].EntryContext = (PVOID)&ExportData;
        LQueryTable[1].DefaultType = REG_NONE;

        LQueryTable[2].QueryRoutine = NULL;
        LQueryTable[2].Flags = 0;
        LQueryTable[2].Name = NULL;

        NtStatus = RtlQueryRegistryValues(RTL_REGISTRY_HANDLE,
                                          Handle,
                                          LQueryTable,
                                          NULL,
                                          NULL);

        if (!NT_SUCCESS(NtStatus) || (ExportData == NULL))
            break;

        RtlInitUnicodeString(&ExportName, ExportData);

        //
        // 3.
        // Read the bus-type and characteristics keywords
        //
        LQueryTable[0].QueryRoutine = ndisReadParameter;
        LQueryTable[0].Flags = RTL_QUERY_REGISTRY_NOEXPAND;
        LQueryTable[0].Name = L"Characteristics";
        LQueryTable[0].EntryContext = (PVOID)&CharacteristicsData;
        LQueryTable[0].DefaultType = REG_NONE;

        LQueryTable[1].QueryRoutine = NULL;
        LQueryTable[1].Flags = 0;
        LQueryTable[1].Name = NULL;

        NtStatus = RtlQueryRegistryValues(RTL_REGISTRY_HANDLE,
                                          Handle,
                                          LQueryTable,
                                          &ValueType,
                                          NULL);


#else

        if (NT_SUCCESS(NtStatus))
        {
            //
            // 1.
            // Switch to the Linkage key below this driver instance key
            //
            LQueryTable[0].QueryRoutine = NULL;
            LQueryTable[0].Flags = RTL_QUERY_REGISTRY_SUBKEY;
            LQueryTable[0].Name = L"Linkage";

            //
            // 2.
            // Read the export and rootdevice keywords
            //
            LQueryTable[1].QueryRoutine = ndisReadParameter;
            LQueryTable[1].Flags = RTL_QUERY_REGISTRY_REQUIRED | RTL_QUERY_REGISTRY_NOEXPAND;
            LQueryTable[1].Name = L"Export";
            LQueryTable[1].EntryContext = (PVOID)&ExportData;
            LQueryTable[1].DefaultType = REG_NONE;

            LQueryTable[2].QueryRoutine = NULL;
            LQueryTable[2].Flags = 0;
            LQueryTable[2].Name = NULL;

            NtStatus = RtlQueryRegistryValues(RTL_REGISTRY_HANDLE,
                                              Handle,
                                              LQueryTable,
                                              NULL,
                                              NULL);

            if (!NT_SUCCESS(NtStatus) || (ExportData == NULL))
                break;

            RtlInitUnicodeString(&ExportName, ExportData);

            //
            // 3.
            // Read the bus-type and characteristics keywords
            //
            LQueryTable[0].QueryRoutine = ndisReadParameter;
            LQueryTable[0].Flags = RTL_QUERY_REGISTRY_NOEXPAND;
            LQueryTable[0].Name = L"Characteristics";
            LQueryTable[0].EntryContext = (PVOID)&CharacteristicsData;
            LQueryTable[0].DefaultType = REG_NONE;

            LQueryTable[1].QueryRoutine = NULL;
            LQueryTable[1].Flags = 0;
            LQueryTable[1].Name = NULL;

            NtStatus = RtlQueryRegistryValues(RTL_REGISTRY_HANDLE,
                                              Handle,
                                              LQueryTable,
                                              &ValueType,
                                              NULL);

        }
        else
        {
            ExportData = (PWSTR)ALLOC_FROM_POOL(sizeof(NDIS_DEFAULT_EXPORT_NAME),
                                                            NDIS_TAG_NAME_BUF);
            if (ExportData == NULL)
            {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                break;
            }

            RtlCopyMemory(ExportData, ndisDefaultExportName, sizeof(NDIS_DEFAULT_EXPORT_NAME));
            RtlInitUnicodeString(&ExportName, ExportData);
        }

#endif
        DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
            ("ndisPnPAddDevice: Device: "));
        DBGPRINT_UNICODE(DBG_COMP_PNP, DBG_LEVEL_INFO,
                &ExportName);
        DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
                ("\n"));
                
        Status = ndisAddDevice(DriverObject,
                               &ExportName,
                               PhysicalDeviceObject,
                               (CharacteristicsData != NULL) ? *CharacteristicsData : 0);

    } while (FALSE);

    if (Handle)
        ZwClose(Handle);

    if (ExportData != NULL)
        FREE_POOL(ExportData);

    if (CharacteristicsData != NULL)
        FREE_POOL(CharacteristicsData);

    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
        ("    ndisPnPAddDevice returning %lx\n", Status));

    DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
        ("<==ndisPnPAddDevice: PDO %p\n", PhysicalDeviceObject));

    return Status;
}

NDIS_STATUS
FASTCALL
ndisPnPStartDevice(
    IN  PDEVICE_OBJECT          DeviceObject,
    IN  PIRP                    Irp     OPTIONAL
    )
/*+++
Routine Description:

    The handler for IRP_MN_START_DEVICE.

Arguments:

    DeviceObject - The adapter's device object.
    Irp - The IRP.
    Adapter - a pointer to either AdapterBlock or MiniportBlock

Return Value:
    NDIS_STATUS_SUCCESS if intializing the device was successful

Note: This routine can also be called from NdisImInitializeDeviceInstanceEx in which case
        the Irp woud be NULL
---*/
{
    PNDIS_MINIPORT_BLOCK    Miniport;
    PCM_RESOURCE_LIST       AllocatedResources, AllocatedResourcesTranslated, pTempResources = NULL;
    NDIS_STATUS             Status;
    PIO_STACK_LOCATION      IrpSp;
    NTSTATUS                NtStatus;
    ULONG                   MemNeeded = 0;

    DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
        ("==>ndisPnPStartDevice: DeviceObject\n", DeviceObject));

    Miniport = (PNDIS_MINIPORT_BLOCK)((PNDIS_WRAPPER_CONTEXT)DeviceObject->DeviceExtension + 1);
    
    DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
            ("ndisPnPStartDevice: Miniport %p, ", Miniport));
    DBGPRINT_UNICODE(DBG_COMP_PNP, DBG_LEVEL_INFO,  Miniport->pAdapterInstanceName);
    DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO, ("\n"));

    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO, ("\n"));

    if (Miniport->PnPDeviceState == NdisPnPDeviceStopped)
    {
        //
        // re-initialize the miniport block structure without destroying what
        // we set during AddDevice
        //
        ndisReinitializeMiniportBlock(Miniport);
        MINIPORT_PNP_SET_FLAG(Miniport, fMINIPORT_RECEIVED_START);
    }

    do
    {
        if (Irp != NULL)
        {
            IrpSp = IoGetCurrentIrpStackLocation (Irp);

            //
            // save allocated resources with miniport/adapter structure
            //
            AllocatedResources = IrpSp->Parameters.StartDevice.AllocatedResources;
            AllocatedResourcesTranslated = IrpSp->Parameters.StartDevice.AllocatedResourcesTranslated;

            if (AllocatedResources)
            {
                MINIPORT_PNP_SET_FLAG(Miniport, fMINIPORT_HARDWARE_DEVICE);
                MemNeeded = sizeof(CM_RESOURCE_LIST)  - sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR) +
                            AllocatedResources->List[0].PartialResourceList.Count *
                            sizeof(CM_PARTIAL_RESOURCE_DESCRIPTOR);

                pTempResources = (PCM_RESOURCE_LIST)ALLOC_FROM_POOL(2 * MemNeeded, NDIS_TAG_ALLOCATED_RESOURCES);

                if (pTempResources == NULL)
                {
                    Status = NDIS_STATUS_RESOURCES;
                    break;
                }

                NdisMoveMemory(pTempResources, AllocatedResources, MemNeeded);
                NdisMoveMemory((PUCHAR)pTempResources + MemNeeded,
                            IrpSp->Parameters.StartDevice.AllocatedResourcesTranslated, MemNeeded);

#if DBG
                if ((ndisDebugLevel == DBG_LEVEL_INFO) &&
                    (ndisDebugSystems & DBG_COMP_PNP))
                {
                    UINT j;
                    PCM_PARTIAL_RESOURCE_LIST pResourceList;

                    DbgPrint("ndisPnPStartDevice: Miniport %p, Non-Translated allocated resources\n", Miniport);

                    pResourceList = &(AllocatedResources->List[0].PartialResourceList);

                    for (j = 0; j < pResourceList->Count; j++)
                    {
                        switch (pResourceList->PartialDescriptors[j].Type)
                        {
                          case CmResourceTypePort:
                            DbgPrint("IO Port: %p, Length: %lx\n",
                                pResourceList->PartialDescriptors[j].u.Port.Start.LowPart,
                                pResourceList->PartialDescriptors[j].u.Port.Length);
                            break;

                          case CmResourceTypeMemory:
                            DbgPrint("Memory: %p, Length: %lx\n",
                                pResourceList->PartialDescriptors[j].u.Memory.Start.LowPart,
                                pResourceList->PartialDescriptors[j].u.Memory.Length);
                            break;

                          case CmResourceTypeInterrupt:
                            DbgPrint("Interrupt Level: %lx, Vector: %lx\n",
                                pResourceList->PartialDescriptors[j].u.Interrupt.Level,
                                pResourceList->PartialDescriptors[j].u.Interrupt.Vector);
                            break;

                          case CmResourceTypeDma:
                            DbgPrint("DMA Channel: %lx\n", pResourceList->PartialDescriptors[j].u.Dma.Channel);
                            break;
                        }
                    }

                    DbgPrint("ndisPnPStartDevice: Miniport %p, Translated allocated resources\n", Miniport);

                    pResourceList = &(AllocatedResourcesTranslated->List[0].PartialResourceList);

                    for (j = 0; j < pResourceList->Count; j++)
                    {
                        switch (pResourceList->PartialDescriptors[j].Type)
                        {

                            case CmResourceTypePort:
                                DbgPrint("IO Port: %p, Length: %lx\n",
                                    pResourceList->PartialDescriptors[j].u.Port.Start.LowPart,
                                    pResourceList->PartialDescriptors[j].u.Port.Length);
                                break;

                            case CmResourceTypeMemory:
                                DbgPrint("Memory: %p, Length: %lx\n",
                                    pResourceList->PartialDescriptors[j].u.Memory.Start.LowPart,
                                    pResourceList->PartialDescriptors[j].u.Memory.Length);
                                break;

                            case CmResourceTypeInterrupt:
                                DbgPrint("Interrupt Level: %lx, Vector: %lx\n",
                                    pResourceList->PartialDescriptors[j].u.Interrupt.Level,
                                    pResourceList->PartialDescriptors[j].u.Interrupt.Vector);
                                break;

                            case CmResourceTypeDma:
                                DbgPrint("DMA Channel: %lx\n", pResourceList->PartialDescriptors[j].u.Dma.Channel);
                                break;

                        }
                    }
                }
#endif
            } // end of if AllocatedResources != NULL
        }

        Miniport->AllocatedResources = pTempResources;
        Miniport->AllocatedResourcesTranslated = (PCM_RESOURCE_LIST)((PUCHAR)pTempResources + MemNeeded);

        Status = ndisInitializeAdapter(Miniport->DriverHandle,
                                       DeviceObject,
                                       Miniport->pAdapterInstanceName,
                                       Miniport->DeviceContext);

        if (Status == NDIS_STATUS_SUCCESS)
        {
            Miniport->PnPDeviceState = NdisPnPDeviceStarted;
            NdisSetEvent(&Miniport->OpenReadyEvent);
            KeQueryTickCount(&Miniport->NdisStats.StartTicks);            
        }
    } while (FALSE);

    DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
            ("<==ndisPnPStartDevice: Miniport %p\n", Miniport));

    return Status;
}


NTSTATUS
ndisQueryReferenceBusInterface(
    IN  PDEVICE_OBJECT              PnpDeviceObject,
    OUT PBUS_INTERFACE_REFERENCE*   pBusInterface
    )
/*++

Routine Description:

    Queries the bus for the standard information interface.

Arguments:

    PnpDeviceObject -
        Contains the next device object on the Pnp stack.

    PhysicalDeviceObject -
        Contains the physical device object which was passed to the FDO during
        the Add Device.

    BusInterface -
        The place in which to return the pointer to the Reference interface.

Return Value:

    Returns STATUS_SUCCESS if the interface was retrieved, else an error.

--*/
{
    NTSTATUS            Status;
    KEVENT              Event;
    IO_STATUS_BLOCK     IoStatusBlock;
    PIRP                Irp;
    PIO_STACK_LOCATION  IrpStackNext;

    PAGED_CODE();

    *pBusInterface = (PBUS_INTERFACE_REFERENCE)ALLOC_FROM_POOL(sizeof(BUS_INTERFACE_REFERENCE), NDIS_TAG_BUS_INTERFACE);
    if (*pBusInterface == NULL)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    //
    // There is no file object associated with this Irp, so the event may be located
    // on the stack as a non-object manager object.
    //
    INITIALIZE_EVENT(&Event);
    Irp = IoBuildSynchronousFsdRequest(IRP_MJ_PNP,
                                       PnpDeviceObject,
                                       NULL,
                                       0,
                                       NULL,
                                       &Event,
                                       &IoStatusBlock);
    if (Irp != NULL)
    {
        Irp->RequestorMode = KernelMode;
        Irp->IoStatus.Status = STATUS_NOT_SUPPORTED;
        IrpStackNext = IoGetNextIrpStackLocation(Irp);

        //
        // Create an interface query out of the Irp.
        //
        IrpStackNext->MinorFunction = IRP_MN_QUERY_INTERFACE;
        IrpStackNext->Parameters.QueryInterface.InterfaceType = (GUID*)&REFERENCE_BUS_INTERFACE;
        IrpStackNext->Parameters.QueryInterface.Size = sizeof(**pBusInterface);
        IrpStackNext->Parameters.QueryInterface.Version = BUS_INTERFACE_REFERENCE_VERSION;
        IrpStackNext->Parameters.QueryInterface.Interface = (PINTERFACE)*pBusInterface;
        IrpStackNext->Parameters.QueryInterface.InterfaceSpecificData = NULL;
        Status = IoCallDriver(PnpDeviceObject, Irp);
        if (Status == STATUS_PENDING)
        {
            //
            // This waits using KernelMode, so that the stack, and therefore the
            // event on that stack, is not paged out.
            //
            WAIT_FOR_OBJECT(&Event, NULL);
            Status = IoStatusBlock.Status;
        }
    }
    else
    {
        Status = STATUS_INSUFFICIENT_RESOURCES;
    }

    if (!NT_SUCCESS(Status))
    {
        FREE_POOL(*pBusInterface);
        *pBusInterface = NULL;
    }

    return Status;
}


NTSTATUS
ndisAddDevice(
    IN  PDRIVER_OBJECT          DriverObject,
    IN  PUNICODE_STRING         pExportName,
    IN  PDEVICE_OBJECT          PhysicalDeviceObject,
    IN  ULONG                   Characteristics
    )
/*++

Routine Description:

    The AddDevice entry point is called by the Plug & Play manager
    to inform the driver when a new device instance arrives that this
    driver must control.

Arguments:


Return Value:


--*/
{
    PDEVICE_OBJECT          NextDeviceObject = NULL;
    NTSTATUS                NtStatus, Status = STATUS_UNSUCCESSFUL;
    PDEVICE_OBJECT          DevicePtr = NULL;
    PNDIS_MINIPORT_BLOCK    Miniport;
    UNICODE_STRING          us;
    PWCHAR                  pPath;
    PNDIS_M_DRIVER_BLOCK    MiniBlock, TmpMiniBlock;
    UINT                    NumComponents;
    LONG                    Size;
    BOOLEAN                 FreeDevice = FALSE;
    PCM_RESOURCE_LIST       pResourceList;
    KIRQL                   OldIrql;

    DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
        ("==>ndisAddDevice: PDO %p\n", PhysicalDeviceObject));

    PnPReferencePackage();

    do
    {
        MiniBlock = (PNDIS_M_DRIVER_BLOCK)IoGetDriverObjectExtension(DriverObject,
                                                                     (PVOID)NDIS_PNP_MINIPORT_DRIVER_ID);
        {
            //
            // check to make sure the mini block is on our queue
            //
            ACQUIRE_SPIN_LOCK(&ndisMiniDriverListLock, &OldIrql);

            TmpMiniBlock = ndisMiniDriverList;

            while (TmpMiniBlock)
            {
                if (TmpMiniBlock == MiniBlock)
                    break;
                    
                TmpMiniBlock = TmpMiniBlock->NextDriver;
            }
            
            RELEASE_SPIN_LOCK(&ndisMiniDriverListLock, OldIrql);

            ASSERT(TmpMiniBlock == MiniBlock);
            
            if (TmpMiniBlock != MiniBlock)
            {
#if TRACK_UNLOAD
                DbgPrint("ndisAddDevice: AddDevice called with a MiniBlock that is not on ndisMiniDriverList\n");
                KeBugCheckEx(BUGCODE_ID_DRIVER,
                             (ULONG_PTR)MiniBlock,
                             (ULONG_PTR)DriverObject,
                             0,
                             0);
#endif
                break;
            }
        }
        
        //
        // create DeviceObject and Miniport/Adapter structure now,
        // we will set a few field here and the rest will be set during
        // processing IRP_MN_START_DEVICE and InitializeAdapter call.
        //
        // Note: We need the device-name field double null terminated.
        //
        Size = sizeof(NDIS_MINIPORT_BLOCK) +
               sizeof(NDIS_WRAPPER_CONTEXT) +
               pExportName->Length + sizeof(WCHAR) + sizeof(WCHAR);

        NtStatus = IoCreateDevice(DriverObject,
                                  Size,
                                  pExportName,
                                  FILE_DEVICE_PHYSICAL_NETCARD,
                                  FILE_DEVICE_SECURE_OPEN,
                                  FALSE,      // exclusive flag
                                  &DevicePtr);


        if(!NT_SUCCESS(NtStatus))
            break;

        DevicePtr->Flags &= ~DO_DEVICE_INITIALIZING;
        DevicePtr->Flags |= DO_DIRECT_IO;
        PhysicalDeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

        FreeDevice = TRUE;

        //
        //  Mark the device as being pageable.
        //
        DevicePtr->Flags |= DO_POWER_PAGABLE;

        //
        //  Attach our FDO to the PDO. This routine will return the top most
        //  device that is attached to the PDO or the PDO itself if no other
        //  device objects have attached to it.
        //
        NextDeviceObject = IoAttachDeviceToDeviceStack(DevicePtr, PhysicalDeviceObject);
        ZeroMemory(DevicePtr->DeviceExtension, Size);

        Miniport = (PNDIS_MINIPORT_BLOCK)((PNDIS_WRAPPER_CONTEXT)DevicePtr->DeviceExtension + 1);

        Miniport->Signature = (PVOID)MINIPORT_DEVICE_MAGIC_VALUE;
        Miniport->DriverHandle = MiniBlock;
        //
        // initialize OpenReady event in case we get an open request before start IRP
        //
        NdisInitializeEvent(&Miniport->OpenReadyEvent);
        INITIALIZE_SPIN_LOCK(&Miniport->Lock);

#if CHECK_TIMER
        if (Miniport->DriverHandle->Flags & fMINIBLOCK_VERIFYING)
            INITIALIZE_SPIN_LOCK(&Miniport->TimerQueueLock);
#endif

        Miniport->PrimaryMiniport = Miniport;

        Miniport->PnPDeviceState = NdisPnPDeviceAdded;
        
        Miniport->PhysicalDeviceObject = PhysicalDeviceObject;
        Miniport->DeviceObject = DevicePtr;
        Miniport->NextDeviceObject = NextDeviceObject;

        Miniport->WrapperContext = DevicePtr->DeviceExtension;
        InitializeListHead(&Miniport->PacketList);

        //
        // intialize the reference and set it to 0; we will increment it
        // in ndisMinitializeAdapter
        //
        ndisInitializeULongRef(&Miniport->Ref);
        Miniport->Ref.ReferenceCount = 0;
#ifdef TRACK_MINIPORT_REFCOUNTS
        M_LOG_MINIPORT_SET_REF(Miniport, 0);
#endif
        
        //
        // Read the characteristics. This determines if the device is hidden or not (from device-manager)
        //
        if (Characteristics & 0x08)
        {
            //
            // Bit 0x08 is NCF_HIDDEN
            //
            MINIPORT_PNP_SET_FLAG(Miniport, fMINIPORT_HIDDEN);
        }

        if (Characteristics & 0x02)
        {
            //
            // Bit 0x02 is NCF_SOFTWARE_ENUMERATED
            //
            MINIPORT_PNP_SET_FLAG(Miniport, fMINIPORT_SWENUM);
        }

        //
        // MiniportName must follow the MINIPORT_BLOCK.
        //
        ndisSetDeviceNames(pExportName,
                           &Miniport->MiniportName,
                           &Miniport->BaseName,
                           (PUCHAR)Miniport + sizeof(NDIS_MINIPORT_BLOCK));

        NtStatus = ndisCreateAdapterInstanceName(&Miniport->pAdapterInstanceName,
                                                 PhysicalDeviceObject);

        if (!NT_SUCCESS(NtStatus))
        {
            break;
        }

        Miniport->InstanceNumber = (USHORT)InterlockedIncrement(&ndisInstanceNumber);

        DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
                ("ndisAddDevice: Miniport %p, ", Miniport));
        DBGPRINT_UNICODE(DBG_COMP_PNP, DBG_LEVEL_INFO,
                Miniport->pAdapterInstanceName);
        DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO, ("\n"));

        if (Characteristics & 0x02)
        {
            PBUS_INTERFACE_REFERENCE    BusInterface = NULL;

            Status = ndisQueryReferenceBusInterface(PhysicalDeviceObject, &BusInterface);
            if (NT_SUCCESS(Status))
            {
                Miniport->BusInterface = BusInterface;
            }
            else
            {
                ASSERT(BusInterface == NULL);
                break;
            }
        }
        
        //
        // create a security descriptor for the device
        //
        Status = ndisCreateSecurityDescriptor(Miniport->DeviceObject, 
                                              &Miniport->SecurityDescriptor,
                                              TRUE);

        if (!NT_SUCCESS(Status))
        {
            FREE_POOL(Miniport->pAdapterInstanceName);
            Status = STATUS_UNSUCCESSFUL;
            break;
        }

        Status = STATUS_SUCCESS;

        //
        //  Don't want to free up the device object.
        //
        FreeDevice = FALSE;
        
    } while (FALSE);

    if (FreeDevice)
    {
        //
        // if device is created it is also attached
        //
        if (NextDeviceObject)
            IoDetachDevice(NextDeviceObject);

        IoDeleteDevice(DevicePtr);
        DevicePtr = NULL;
    }

    if (DevicePtr && (NT_SUCCESS(Status)))
    {
        //
        // if DevicePtr is not NULL, we do have a valid
        // miniport. queue the miniport on global miniport queue
        //
        ACQUIRE_SPIN_LOCK(&ndisMiniportListLock, &OldIrql);
        Miniport->NextGlobalMiniport = ndisMiniportList;
        ndisMiniportList = Miniport;
        RELEASE_SPIN_LOCK(&ndisMiniportListLock, OldIrql);
    }
    
    PnPDereferencePackage();

    DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
        ("<==ndisAddDevice: Miniport %p\n", Miniport));

    return Status;
}


VOID
ndisSetDeviceNames(
    IN  PNDIS_STRING            ExportName,
    OUT PNDIS_STRING            DeviceName,
    OUT PNDIS_STRING            BaseName,
    IN  PUCHAR                  Buffer
    )
{
    PNDIS_STRING    BindPath;
    PWSTR           pComp, p;
    USHORT          i;
    NDIS_STRING     Str, SubStr;

    DeviceName->Buffer = (PWSTR)Buffer;
    DeviceName->Length = ExportName->Length;
    DeviceName->MaximumLength = DeviceName->Length + sizeof(WCHAR);
    RtlUpcaseUnicodeString(DeviceName,
                           ExportName,
                           FALSE);

    //
    // ExportName is in the form of \Device\<AdapterName>
    // Extract BaseName which is the name w/o the "\Device\"
    //
    BaseName->Buffer = DeviceName->Buffer + (ndisDeviceStr.Length/sizeof(WCHAR));
    BaseName->Length = DeviceName->Length - ndisDeviceStr.Length;
    BaseName->MaximumLength = BaseName->Length + sizeof(WCHAR);
}


NTSTATUS
FASTCALL
ndisPnPQueryStopDevice(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    NTSTATUS             Status;
    PNDIS_MINIPORT_BLOCK Miniport = (PNDIS_MINIPORT_BLOCK)((PNDIS_WRAPPER_CONTEXT)DeviceObject->DeviceExtension + 1);
    KIRQL                OldIrql;

    DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
        ("==>ndisPnPQueryStopDevice: Miniport %p\n", Miniport));

    do
    {
        if (Miniport->PnPCapabilities & NDIS_DEVICE_NOT_STOPPABLE)
        {
            Status = STATUS_UNSUCCESSFUL;
            break;
        }
        
        //
        // query_stop and stop are not reported to the user mode
        // so we have to protect ourselves against cases that apps
        // may have pending IO against the miniport
        //

        NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Miniport, &OldIrql);                    
        if (Miniport->UserModeOpenReferences != 0)
        {
            Status = STATUS_UNSUCCESSFUL;
            NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);
            break;
        }
        NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);

        //
        // for now do the same as query remove
        //
        Status = ndisPnPQueryRemoveDevice(DeviceObject, Irp);
    } while (FALSE);
    
    DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
        ("<==ndisPnPQueryStopDevice: Miniport %p\n", Miniport));

    return Status;
}

NTSTATUS
FASTCALL
ndisPnPCancelStopDevice(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    NTSTATUS    Status;

    DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
        ("==>ndisPnPCancelStopDevice\n"));

    //
    // for now do the same as cancel remove
    //
    Status = ndisPnPCancelRemoveDevice(DeviceObject, Irp);

    DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
        ("<==ndisPnPCancelStopDevice\n"));

    return Status;
}

NTSTATUS
FASTCALL
ndisPnPStopDevice(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    NTSTATUS    Status;

    DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
        ("==>ndisPnPStopDevice\n"));

    //
    // do the same as remove
    //
    Status = ndisPnPRemoveDevice(DeviceObject, Irp);

    DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
        ("<==ndisPnPStopDevice\n"));

    return Status;
}

NTSTATUS
FASTCALL
ndisPnPQueryRemoveDevice(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    PNDIS_MINIPORT_BLOCK    Miniport = (PNDIS_MINIPORT_BLOCK)((PNDIS_WRAPPER_CONTEXT)DeviceObject->DeviceExtension + 1);
    NTSTATUS                Status = STATUS_SUCCESS;

    DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
        ("==>ndisPnPQueryRemoveDevice: Miniport %p, UserModeOpenReferences %lx\n", Miniport, Miniport->UserModeOpenReferences));

    do
    {
        //
        // If this was the network card used in a remote boot, then we
        // can't remove it.
        //
        if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_NETBOOT_CARD))
        {
            Status = STATUS_UNSUCCESSFUL;
            break;
        }

        Status = ndisPnPNotifyAllTransports(Miniport,
                                            NetEventQueryRemoveDevice,
                                            NULL,
                                            0);

    } while (FALSE);

    DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
        ("<==ndisPnPQueryRemoveDevice: Miniport %p, Status 0x%x\n", Miniport, Status));

    return Status;
}

NTSTATUS
FASTCALL
ndisPnPCancelRemoveDevice(
    IN PDEVICE_OBJECT   DeviceObject,
    IN PIRP             Irp
    )
{
    PNDIS_MINIPORT_BLOCK    Miniport = (PNDIS_MINIPORT_BLOCK)((PNDIS_WRAPPER_CONTEXT)DeviceObject->DeviceExtension + 1);
    NTSTATUS                Status = NDIS_STATUS_SUCCESS;

    DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
        ("==>ndisPnPCancelRemoveDevice: Miniport %p\n", Miniport));

    Status = ndisPnPNotifyAllTransports(Miniport,
                                        NetEventCancelRemoveDevice,
                                        NULL,
                                        0);


    DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
        ("<==ndisPnPCancelRemoveDevice: Miniport %p\n", Miniport));

    return STATUS_SUCCESS;
}

NTSTATUS
FASTCALL
ndisPnPRemoveDevice(
    IN  PDEVICE_OBJECT      DeviceObject,
    IN  PIRP                Irp     OPTIONAL
    )
{
    PNDIS_MINIPORT_BLOCK    Miniport = (PNDIS_MINIPORT_BLOCK)((PNDIS_WRAPPER_CONTEXT)DeviceObject->DeviceExtension + 1);
    NTSTATUS                Status = NDIS_STATUS_SUCCESS;
    PNDIS_OPEN_BLOCK        Open, NextOpen;
    NDIS_BIND_CONTEXT       UnbindContext;
    KIRQL                   OldIrql;
    BOOLEAN                 fAcquiredImMutex = FALSE;
    PKMUTEX                 pIMStartRemoveMutex = NULL;

    DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
        ("==>ndisPnPRemoveDevice: Miniport %p\n", Miniport));

    PnPReferencePackage();

    //
    // there are three different cases that we can get a remove request
    // a:   the request is coming from PnP manager in response to a user mode
    //      app. In this case, the remove has been proceeded by a query remove
    //      which we happily failed if there was any legacy protocol bound to
    //      the adapter
    //
    // b.   the request is coming from PnP manager because Starting the device failed
    //      in this case (hopefully) there is no binding at all. in this case it is not
    //      proceeded by query_remove and neet not be. we don't have any protocol bound
    //      to the adapter to worry about
    //
    // c.   or it can come in response to a surprise style removal in which case we are
    //      hosed anyway. sending query_remove to protocols does not do any good
    //

    do
    {
        PNDIS_M_DRIVER_BLOCK    MiniBlock;
        PNDIS_MINIPORT_BLOCK    TmpMiniport;

        //
        // find the miniport on driver queue
        //
        MiniBlock = Miniport->DriverHandle;

        if (MiniBlock == NULL)
            break;

        //
        // Intermediate drivers could be in the middle of initialization through the 
        // NdisIMInitializeDeviceInstance Code path. We need to synchronize
        //
        if (MiniBlock->Flags & fMINIBLOCK_INTERMEDIATE_DRIVER)
        {
            pIMStartRemoveMutex = &MiniBlock->IMStartRemoveMutex;

            WAIT_FOR_OBJECT(pIMStartRemoveMutex, NULL);

            fAcquiredImMutex = TRUE;
        }

        ACQUIRE_SPIN_LOCK(&MiniBlock->Ref.SpinLock, &OldIrql);

        for (TmpMiniport = MiniBlock->MiniportQueue;
             TmpMiniport != NULL;
             TmpMiniport = TmpMiniport->NextMiniport)
        {
            if (TmpMiniport == Miniport)
            {
                break;
            }
        }

        RELEASE_SPIN_LOCK(&MiniBlock->Ref.SpinLock, OldIrql);
        
        if ((TmpMiniport != Miniport) || (Miniport->Ref.Closing == TRUE))
        {
            break;
        }

        ndisReferenceDriver(MiniBlock);

        NdisResetEvent(&Miniport->OpenReadyEvent);

        //
        //  Notify WMI of adapter removal.
        //
        if (Miniport->pAdapterInstanceName != NULL)
        {
            PWNODE_SINGLE_INSTANCE  wnode;
            PUCHAR                  ptmp;
            NTSTATUS                NtStatus;

            ndisSetupWmiNode(Miniport,
                             Miniport->pAdapterInstanceName,
                             Miniport->MiniportName.Length + sizeof(USHORT),
                             (PVOID)&GUID_NDIS_NOTIFY_ADAPTER_REMOVAL,
                             &wnode);

            if (wnode != NULL)
            {
                //
                //  Save the number of elements in the first ULONG.
                //
                ptmp = (PUCHAR)wnode + wnode->DataBlockOffset;
                *((PUSHORT)ptmp) = Miniport->MiniportName.Length;

                //
                //  Copy the data after the number of elements.
                //
                RtlCopyMemory(ptmp + sizeof(USHORT),
                              Miniport->MiniportName.Buffer,
                              Miniport->MiniportName.Length);

                //
                //  Indicate the event to WMI. WMI will take care of freeing
                //  the WMI struct back to pool.
                //
                NtStatus = IoWMIWriteEvent(wnode);
                if (!NT_SUCCESS(NtStatus))
                {
                    DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_ERR,
                        ("ndisPnPRemoveDevice: Failed to indicate adapter removal\n"));

                    FREE_POOL(wnode);
                }
            }
        }

        //
        // this will take care of closing all the bindings
        //
        ndisCloseMiniportBindings(Miniport);

        if (Miniport->pIrpWaitWake)
        {
            if (IoCancelIrp(Miniport->pIrpWaitWake))
            {
                DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
                    ("ndisPnPRemoveDevice: Miniport %p, Successfully canceled wake irp\n", Miniport));

            }
        }

        //
        // get rid of wakeup patterns set on the miniport
        //

        {
            PSINGLE_LIST_ENTRY          Link;
            PNDIS_PACKET_PATTERN_ENTRY  pPatternEntry;
            
            while (Miniport->PatternList.Next != NULL)
            {
                Link = PopEntryList(&Miniport->PatternList);
                pPatternEntry = CONTAINING_RECORD(Link, NDIS_PACKET_PATTERN_ENTRY, Link);
                //
                //  Free the memory taken by the pattern.
                //
                FREE_POOL(pPatternEntry);
            }                               
        }
        

        //
        // and this one will take care of the rest!
        // we call this function even if the device has already been halted by 
        // ndisPMHaltMiniport. because that functions does not clean up everything.
        // ndisMHaltMiniport will check for PM_HALTED flag and avoid re-doing what PMHalt
        // has already done.
        //
        ndisMHaltMiniport(Miniport);

        //
        // Free the media-request structure, if present
        //
        if (Miniport->MediaRequest != NULL)
        {
            FREE_POOL(Miniport->MediaRequest);
            Miniport->MediaRequest = NULL;
        }

        ndisDereferenceDriver(MiniBlock, FALSE);

        {
            UNICODE_STRING  DeviceName, UpcaseDeviceName;
            UNICODE_STRING  SymbolicLink;
            NTSTATUS        NtStatus;
            WCHAR           SymLnkBuf[128];

            SymbolicLink.Buffer = SymLnkBuf;
            SymbolicLink.Length = 0;
            SymbolicLink.MaximumLength = sizeof(SymLnkBuf);
            RtlCopyUnicodeString(&SymbolicLink, &ndisDosDevicesStr);
            RtlAppendUnicodeStringToString(&SymbolicLink,
                                           &Miniport->BaseName);

            NtStatus = IoDeleteSymbolicLink(&SymbolicLink);
            if (!NT_SUCCESS(NtStatus))
            {
#if DBG
                DbgPrint("ndisPnPRemoveDevice: deleting symbolic link name failed for miniport %p, SymbolicLinkName %p, NtStatus %lx\n",
                         Miniport, &SymbolicLink, NtStatus);        
#endif
            }
            
        }
        
    } while (FALSE);

    if(fAcquiredImMutex  == TRUE)
    {
        RELEASE_MUTEX(pIMStartRemoveMutex);
    }

    PnPDereferencePackage();

    DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
        ("<==ndisPnPRemoveDevice: Miniport %p\n", Miniport));

    return Status;
}

VOID
FASTCALL
ndisReinitializeMiniportBlock(
    IN  PNDIS_MINIPORT_BLOCK    Miniport
    )
{
    PDEVICE_OBJECT          PhysicalDeviceObject, DeviceObject, NextDeviceObject;
    PNDIS_M_DRIVER_BLOCK    MiniBlock;
    PNDIS_MINIPORT_BLOCK    NextGlobalMiniport;
    PNDIS_MINIPORT_BLOCK    PrimaryMiniport;
    UNICODE_STRING          BaseName, MiniportName;
    PUNICODE_STRING         InstanceName;
    PNDIS_BIND_PATHS        BindPaths;
    PVOID                   WrapperContext;
    NDIS_HANDLE             DeviceContext;
    ULONG                   PnPCapabilities;
    ULONG                   FlagsToSave = 0;
    ULONG                   PnPFlagsToSave = 0;
    DEVICE_POWER_STATE      CurrentDevicePowerState;
    PVOID                   BusInterface;
    USHORT                  InstanceNumber;
    PSECURITY_DESCRIPTOR    SecurityDescriptor;
        
    DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
            ("==>ndisReinitializeMiniportBlock: Miniport %p\n", Miniport));


    PhysicalDeviceObject = Miniport->PhysicalDeviceObject;
    DeviceObject= Miniport->DeviceObject;
    NextDeviceObject = Miniport->NextDeviceObject;
    MiniBlock = Miniport->DriverHandle;
    WrapperContext = Miniport->WrapperContext;
    BaseName = Miniport->BaseName;
    MiniportName = Miniport->MiniportName;
    InstanceName = Miniport->pAdapterInstanceName;
    DeviceContext = Miniport->DeviceContext;
    BindPaths = Miniport->BindPaths;
    PnPCapabilities = Miniport->PnPCapabilities;
    PnPFlagsToSave = Miniport->PnPFlags & (fMINIPORT_RECEIVED_START | 
                                           fMINIPORT_SWENUM | 
                                           fMINIPORT_HIDDEN |
                                           fMINIPORT_HARDWARE_DEVICE |
                                           fMINIPORT_NDIS_WDM_DRIVER |
                                           fMINIPORT_FILTER_IM
                                           );
                                           
    FlagsToSave = Miniport->Flags & fMINIPORT_REQUIRES_MEDIA_POLLING;
    CurrentDevicePowerState = Miniport->CurrentDevicePowerState;
    NextGlobalMiniport = Miniport->NextGlobalMiniport;
    PrimaryMiniport = Miniport->PrimaryMiniport;
    InstanceNumber = Miniport->InstanceNumber;
    BusInterface = Miniport->BusInterface;
    SecurityDescriptor = Miniport->SecurityDescriptor;
    
        
    ZeroMemory(Miniport, FIELD_OFFSET(NDIS_MINIPORT_BLOCK, OpenReadyEvent));
    ZeroMemory((PUCHAR)Miniport +
                    FIELD_OFFSET(NDIS_MINIPORT_BLOCK, OpenReadyEvent) +
                    sizeof(Miniport->OpenReadyEvent),
                sizeof(NDIS_MINIPORT_BLOCK) -
                    FIELD_OFFSET(NDIS_MINIPORT_BLOCK, OpenReadyEvent) -
                    sizeof(Miniport->OpenReadyEvent));



    //
    // restore what we saved
    //

    Miniport->PnPDeviceState = NdisPnPDeviceAdded;
    Miniport->Signature = (PVOID)MINIPORT_DEVICE_MAGIC_VALUE;
    Miniport->DriverHandle = MiniBlock;
    INITIALIZE_SPIN_LOCK(&Miniport->Lock);
    
#if CHECK_TIMER
    if (Miniport->DriverHandle->Flags & fMINIBLOCK_VERIFYING)
        INITIALIZE_SPIN_LOCK(&Miniport->TimerQueueLock);
#endif

    Miniport->PhysicalDeviceObject = PhysicalDeviceObject;
    Miniport->DeviceObject = DeviceObject;
    Miniport->NextDeviceObject = NextDeviceObject;
    Miniport->WrapperContext = WrapperContext;
    Miniport->BaseName = BaseName;
    Miniport->MiniportName = MiniportName;
    Miniport->pAdapterInstanceName = InstanceName;
    Miniport->DeviceContext = DeviceContext;
    Miniport->BindPaths = BindPaths;
    Miniport->PnPCapabilities = PnPCapabilities;
    Miniport->Flags = FlagsToSave;
    Miniport->PnPFlags = PnPFlagsToSave;
    Miniport->CurrentDevicePowerState = CurrentDevicePowerState;
    Miniport->NextGlobalMiniport = NextGlobalMiniport;
    Miniport->PrimaryMiniport = PrimaryMiniport;
    Miniport->InstanceNumber = InstanceNumber;
    Miniport->BusInterface = BusInterface;

    InitializeListHead(&Miniport->PacketList);
    Miniport->FirstPendingPacket = NULL;
    
    if (MiniBlock->Flags & fMINIBLOCK_INTERMEDIATE_DRIVER)
    {
        MINIPORT_SET_FLAG(Miniport, fMINIPORT_INTERMEDIATE_DRIVER);
    }

    Miniport->SecurityDescriptor = SecurityDescriptor;
    
    DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
        ("<==ndisReinitializeMiniportBlock: Miniport %p\n", Miniport));
}

EXPORT
VOID
NdisMGetDeviceProperty(
    IN NDIS_HANDLE  MiniportAdapterHandle,
    IN OUT PDEVICE_OBJECT * PhysicalDeviceObject    OPTIONAL,
    IN OUT PDEVICE_OBJECT * FunctionalDeviceObject OPTIONAL,
    IN OUT PDEVICE_OBJECT * NextDeviceObject OPTIONAL,
    IN OUT  PCM_RESOURCE_LIST * AllocatedResources OPTIONAL,
    IN OUT  PCM_RESOURCE_LIST * AllocatedResourcesTranslated OPTIONAL
    )
{

    PNDIS_MINIPORT_BLOCK Miniport = (PNDIS_MINIPORT_BLOCK)MiniportAdapterHandle;
    //
    // very likely this is a NDIS_WDM driver.
    //
    if (!MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_HARDWARE_DEVICE))
    {
        MINIPORT_PNP_SET_FLAG(Miniport, fMINIPORT_NDIS_WDM_DRIVER);
    }

    if (ARGUMENT_PRESENT(PhysicalDeviceObject))
    {
        *PhysicalDeviceObject = Miniport->PhysicalDeviceObject;
    }

    if (ARGUMENT_PRESENT(FunctionalDeviceObject))
    {
        *FunctionalDeviceObject = Miniport->DeviceObject;
    }

    if (ARGUMENT_PRESENT(NextDeviceObject))
    {
        *NextDeviceObject = Miniport->NextDeviceObject;
    }

    if (ARGUMENT_PRESENT(AllocatedResources))
    {
        *AllocatedResources = Miniport->AllocatedResources;
    }
    
    if (ARGUMENT_PRESENT(AllocatedResourcesTranslated))
    {
        *AllocatedResourcesTranslated = Miniport->AllocatedResourcesTranslated;
    }

    return;
}

NTSTATUS
ndisWritePnPCapabilities(
    IN PNDIS_MINIPORT_BLOCK Miniport,
    IN ULONG                PnPCapabilities
    )
{
    NTSTATUS            RegistryStatus;
    HANDLE              Handle, RootHandle;
    OBJECT_ATTRIBUTES   ObjAttr;
    UNICODE_STRING      Root={0, 0, NULL};

    do
    {

#if NDIS_TEST_REG_FAILURE
        RegistryStatus = STATUS_UNSUCCESSFUL;
        RootHandle = NULL;
#else
        RegistryStatus = IoOpenDeviceRegistryKey(Miniport->PhysicalDeviceObject,
                                                     PLUGPLAY_REGKEY_DRIVER,
                                                     GENERIC_WRITE | MAXIMUM_ALLOWED,
                                                     &RootHandle);
#endif

        if (!NT_SUCCESS(RegistryStatus))
        {
            break;
        }
        
        InitializeObjectAttributes(&ObjAttr,
                                   &Root,
                                   OBJ_CASE_INSENSITIVE,
                                   RootHandle,
                                   NULL);
                                
        RegistryStatus = ZwOpenKey(&Handle,
                                   GENERIC_READ | MAXIMUM_ALLOWED,
                                   &ObjAttr);
                        
        if (NT_SUCCESS(RegistryStatus))
        {
            RegistryStatus = RtlWriteRegistryValue(RTL_REGISTRY_HANDLE,
                                                   Handle,
                                                   L"PnPCapabilities",
                                                   REG_DWORD,
                                                   &PnPCapabilities,
                                                   sizeof(ULONG));

            ZwClose(Handle);
        }
            
        ZwClose(RootHandle);
        
    } while (FALSE);

    return RegistryStatus;
    
}

NDIS_STATUS
NdisMRemoveMiniport(
    IN  NDIS_HANDLE             MiniportHandle
    )
/*++

Routine Description:
    Miniports call this routine to signal a device failure.
    in response, ndis will ask PnP to send a REMOVE IRP for this device

Arguments:

    MiniportHandle  -   Miniport

Return Value:

    always successful

--*/
{
    PNDIS_MINIPORT_BLOCK    Miniport = (PNDIS_MINIPORT_BLOCK)MiniportHandle;
    
    MINIPORT_PNP_SET_FLAG(Miniport, fMINIPORT_DEVICE_FAILED);
    IoInvalidateDeviceState(Miniport->PhysicalDeviceObject);
    
    return(NDIS_STATUS_SUCCESS);
}


PNDIS_MINIPORT_BLOCK
ndisFindMiniportOnGlobalList(
    IN  PNDIS_STRING                    DeviceName
    )
/*++

Routine Description:

    Find the Miniport with a matching device name on ndisMiniportList.

Arguments:
    
Return Value:
    a pointer to MiniportBlock if found. NULL otherwise
    
--*/
{
    KIRQL                   OldIrql;
    PNDIS_MINIPORT_BLOCK    Miniport;
    NDIS_STRING             UpcaseDevice;
    PWSTR                   pwch;

    DBGPRINT(DBG_COMP_PNP, DBG_LEVEL_INFO,
            ("==>ndisFindMiniportOnGlobalList: DeviceName %p\n", DeviceName));
            
    
    //
    // First we need to upcase the device-name before checking
    //
    UpcaseDevice.Length = DeviceName->Length;
    UpcaseDevice.MaximumLength = DeviceName->Length + sizeof(WCHAR);
    UpcaseDevice.Buffer = ALLOC_FROM_POOL(UpcaseDevice.MaximumLength, NDIS_TAG_STRING);

    if ((pwch = UpcaseDevice.Buffer) == NULL)
    {
        return NULL;
    }

    RtlUpcaseUnicodeString(&UpcaseDevice, DeviceName, FALSE);

    ASSERT(ndisPkgs[NPNP_PKG].ReferenceCount > 0);
    PnPReferencePackage();
    
    ACQUIRE_SPIN_LOCK(&ndisMiniportListLock, &OldIrql);
    for (Miniport = ndisMiniportList;
         Miniport != NULL;
         Miniport = Miniport->NextGlobalMiniport)
    {
        if (NDIS_EQUAL_UNICODE_STRING(&UpcaseDevice, &Miniport->MiniportName))
        {
            break;
        }
    }
    RELEASE_SPIN_LOCK(&ndisMiniportListLock, OldIrql);
    
    PnPDereferencePackage();
    
    FREE_POOL(pwch);

    DBGPRINT(DBG_COMP_PNP, DBG_LEVEL_INFO,
            ("<==ndisFindMiniportOnGlobalList: Miniport %p\n", Miniport));

    return Miniport;
}

ULONG
NdisMGetDmaAlignment(
    IN  NDIS_HANDLE MiniportAdapterHandle
    )
{
    PNDIS_MINIPORT_BLOCK    Miniport = (PNDIS_MINIPORT_BLOCK)MiniportAdapterHandle;
    
    ASSERT(CURRENT_IRQL < DISPATCH_LEVEL);
    ASSERT(Miniport->SystemAdapterObject != NULL);
        
    if (Miniport->SystemAdapterObject)
    {
        return (Miniport->SystemAdapterObject->DmaOperations->GetDmaAlignment(Miniport->SystemAdapterObject));
    }
    else
    {
        return 0;
    }
}


ULONG
NdisGetSharedDataAlignment(
    VOID
    )
{
    return KeGetRecommendedSharedDataAlignment();
}

VOID
ndisDereferenceDmaAdapter(
    IN  PNDIS_MINIPORT_BLOCK    Miniport
    )
{
    PDMA_ADAPTER        DmaAdapter;
    PPUT_DMA_ADAPTER    putDmaAdapter;
    LONG                DmaAdapterRefCount;
    KIRQL               OldIrql;

    NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Miniport, &OldIrql);
    
    DmaAdapterRefCount = InterlockedDecrement(&Miniport->DmaAdapterRefCount);

    ASSERT(DmaAdapterRefCount >= 0);

    if (DmaAdapterRefCount == 0)
    {
        //
        // free the dma adapter
        //
        DmaAdapter = Miniport->SystemAdapterObject;
        ASSERT(DmaAdapter != NULL);
            
        if (DmaAdapter != NULL)
        {
            Miniport->SavedSystemAdapterObject = Miniport->SystemAdapterObject;
            putDmaAdapter = *DmaAdapter->DmaOperations->PutDmaAdapter;
            putDmaAdapter(DmaAdapter);
            Miniport->SystemAdapterObject  = NULL;
        }

        if (Miniport->SGListLookasideList)
        {
            ExDeleteNPagedLookasideList(Miniport->SGListLookasideList);
            FREE_POOL(Miniport->SGListLookasideList);
            Miniport->SGListLookasideList = NULL;
        }
        
        if (Miniport->DmaResourcesReleasedEvent != NULL)
        {
            SET_EVENT(Miniport->DmaResourcesReleasedEvent);
        }
    }
    
    NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ndis\sys\cprotos.h ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation

Module Name:

    cprotos.h

Abstract:

    NDIS wrapper function prototypes for common functions

Author:


Environment:

    Kernel mode, FSD

Revision History:

    Jun-95  Jameel Hyder    Split up from a monolithic file
--*/

NTSTATUS
ndisMIrpCompletion(
    IN  PDEVICE_OBJECT                  DeviceObject,
    IN  PIRP                            Irp,
    IN  PVOID                           Context
    );

#undef NdisMSetAttributes
VOID
NdisMSetAttributes(
    IN  NDIS_HANDLE                     MiniportAdapterHandle,
    IN  NDIS_HANDLE                     MiniportAdapterContext,
    IN  BOOLEAN                         BusMaster,
    IN  NDIS_INTERFACE_TYPE             AdapterType
    );

NDIS_STATUS
ndisPnPNotifyAllTransports(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  NET_PNP_EVENT_CODE              PnpEvent,
    IN  PVOID                           Buffer,
    IN  ULONG                           BufferLength
    );

NDIS_STATUS
FASTCALL
ndisPnPNotifyBinding(
    IN  PNDIS_OPEN_BLOCK                Open,
    IN  PNET_PNP_EVENT                  NetPnpEvent
    );

PNDIS_OPEN_BLOCK
FASTCALL
ndisReferenceNextUnprocessedOpen(
    IN  PNDIS_MINIPORT_BLOCK            Miniport
    );

VOID
ndisUnprocessAllOpens(
    IN  PNDIS_MINIPORT_BLOCK            Miniport
    );

NTSTATUS
ndisCompletionRoutine(
    IN  PDEVICE_OBJECT                  pdo,
    IN  PIRP                            pirp,
    IN  PVOID                           Context
    );
    
NTSTATUS
ndisPnPDispatch(
    IN  PDEVICE_OBJECT                  DeviceObject,
    IN  PIRP                            Irp
    );
    
BOOLEAN
ndisMIsr(
    IN  PKINTERRUPT                     KInterrupt,
    IN  PVOID                           Context
    );

VOID
ndisMDpc(
    IN  PVOID                           SystemSpecific1,
    IN  PVOID                           InterruptContext,
    IN  PVOID                           SystemSpecific2,
    IN  PVOID                           SystemSpecific3
    );

VOID
ndisMWakeUpDpcX(
    IN  PKDPC                           Dpc,
    IN  PVOID                           Context,
    IN  PVOID                           SystemContext1,
    IN  PVOID                           SystemContext2
    );

VOID
ndisMPollMediaState(
    IN  PNDIS_MINIPORT_BLOCK            Miniport
    );

#undef  NdisMSetTimer
VOID
NdisMSetTimer(
    IN  PNDIS_MINIPORT_TIMER            MiniportTimer,
    IN  UINT                            MillisecondsToDelay
    );

VOID
ndisMDpcX(
    IN  PVOID                           SystemSpecific1,
    IN  PVOID                           InterruptContext,
    IN  PVOID                           SystemSpecific2,
    IN  PVOID                           SystemSpecific3
    );

VOID
ndisMTimerDpcX(
    IN  PVOID                           SystemSpecific1,
    IN  PVOID                           InterruptContext,
    IN  PVOID                           SystemSpecific2,
    IN  PVOID                           SystemSpecific3
    );

VOID
ndisMWakeUpDpc(
    IN  PKDPC                           Dpc,
    IN  PVOID                           Context,
    IN  PVOID                           SystemContext1,
    IN  PVOID                           SystemContext2
    );

VOID
ndisMDeferredDpc(
    IN  PKDPC                           Dpc,
    IN  PVOID                           Context,
    IN  PVOID                           SystemContext1,
    IN  PVOID                           SystemContext2
    );
    
NDIS_STATUS
NdisCoAssignInstanceName(
    IN  NDIS_HANDLE                     NdisVcHandle,
    IN  PNDIS_STRING                    BaseInstanceName,
    OUT PNDIS_STRING                    pVcInstanceName     OPTIONAL
    );

NDIS_STATUS
ndisMChangeClass(
    IN  UINT                            OldFilterClasses,
    IN  UINT                            NewFilterClasses,
    IN  NDIS_HANDLE                     BindingHandle,
    IN  PNDIS_REQUEST                   NdisRequest,
    IN  BOOLEAN                         Set
    );

NDIS_STATUS
ndisMReset(
    IN  NDIS_HANDLE                     NdisBindingHandle
    );

NDIS_STATUS
ndisMRequest(
    IN  NDIS_HANDLE                     NdisBindingHandle,
    IN  PNDIS_REQUEST                   NdisRequest
    );

NDIS_STATUS
ndisMRequestX(
    IN  NDIS_HANDLE                     NdisBindingHandle,
    IN  PNDIS_REQUEST                   NdisRequest
    );

VOID
FASTCALL
ndisMAbortRequests(
    IN PNDIS_MINIPORT_BLOCK             Miniport
    );

VOID
FASTCALL
ndisMProcessDeferred(
    IN  PNDIS_MINIPORT_BLOCK            Miniport
    );

NDIS_STATUS
ndisMTransferData(
    IN  NDIS_HANDLE                     NdisBindingHandle,
    IN  NDIS_HANDLE                     MacReceiveContext,
    IN  UINT                            ByteOffset,
    IN  UINT                            BytesToTransfer,
    IN  OUT PNDIS_PACKET                Packet,
    OUT PUINT                           BytesTransferred
    );

#undef NdisMTransferDataComplete
VOID
NdisMTransferDataComplete(
    IN  NDIS_HANDLE                     MiniportAdapterHandle,
    IN  PNDIS_PACKET                    Packet,
    IN  NDIS_STATUS                     Status,
    IN  UINT                            BytesTransferred
    );

VOID
FASTCALL
ndisMDeferredReturnPackets(
    IN  PNDIS_MINIPORT_BLOCK            Miniport
    );

VOID
ndisMIndicatePacket(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  PPNDIS_PACKET                   PacketArray,
    IN  UINT                            NumberOfPackets
    );

VOID
ndisMDummyIndicatePacket(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  PPNDIS_PACKET                   PacketArray,
    IN  UINT                            NumberOfPackets
    );

NTSTATUS
ndisWMIDispatch(
    IN  PDEVICE_OBJECT                  DeviceObject,
    IN  PIRP                            pirp
    );

NTSTATUS
FASTCALL
ndisWmiDisableEvents(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  LPGUID                          Guid
    );

NTSTATUS
FASTCALL
ndisWmiEnableEvents(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  LPGUID                          Guid
    );

NTSTATUS
ndisWmiChangeSingleItem(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  PWNODE_SINGLE_ITEM              wnode,
    IN  ULONG                           BufferSize,
    OUT PULONG                          pReturnSize,
    IN  PIRP                            Irp
    );

NTSTATUS
ndisWmiChangeSingleInstance(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  PWNODE_SINGLE_INSTANCE          wnode,
    IN  ULONG                           BufferSize,
    OUT PULONG                          pReturnSize,
    IN  PIRP                            Irp
    );

NTSTATUS
ndisWmiQuerySingleInstance(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  PWNODE_SINGLE_INSTANCE          wnode,
    IN  ULONG                           BufferSize,
    OUT PULONG                          pReturnSize,
    IN  PIRP                            Irp
    );

NTSTATUS
ndisWmiQueryAllData(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  LPGUID                          guid,
    IN  PWNODE_ALL_DATA                 wnode,
    IN  ULONG                           BufferSize,
    OUT PULONG                          pReturnSize,
    IN  PIRP                            Irp
    );

NTSTATUS
ndisQueryGuidData(
    IN  PUCHAR                          Buffer,
    IN  ULONG                           BufferLength,
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  PNDIS_CO_VC_PTR_BLOCK           pVcBlock,
    IN  LPGUID                          guid,
    IN  PIRP                            Irp
    );

BOOLEAN
ndisWmiCheckAccess(
    IN  PNDIS_GUID  pNdisGuid,
    IN  ULONG       DesiredAccess,
    IN  LONG        RequiredPrivilege,
    IN  PIRP        Irp
    );

NTSTATUS
ndisQueryGuidDataSize(
    OUT PULONG                          pBytesNeeded,
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  PNDIS_CO_VC_PTR_BLOCK           pVcBlock    OPTIONAL,
    IN  LPGUID                          guid
    );

NTSTATUS
ndisWmiGetGuid(
    OUT PNDIS_GUID  *                   ppNdisGuid,
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  LPGUID                          guid,
    IN  NDIS_STATUS                     status
    );

NTSTATUS
ndisWmiRegister(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  ULONG_PTR                       RegistrationType,
    IN  PWMIREGINFO                     wmiRegInfo,
    IN  ULONG                           wmiRegInfoSize,
    IN  PULONG                          pReturnSize
    );

VOID
ndisNotifyWmiBindUnbind(
    PNDIS_MINIPORT_BLOCK                Miniport,
    PNDIS_PROTOCOL_BLOCK                Protocol,
    BOOLEAN                             fBind
    );

VOID
ndisNotifyDevicePowerStateChange(
    PNDIS_MINIPORT_BLOCK                Miniport,
    NDIS_DEVICE_POWER_STATE             PowerState
    );

NDIS_STATUS
ndisQuerySupportedGuidToOidList(
    IN  PNDIS_MINIPORT_BLOCK            Miniport
    );

USHORT
ndisWmiMapOids(
    IN  OUT PNDIS_GUID                  pDst,
    IN  IN  USHORT                      cDst,
    IN      PNDIS_OID                   pOidList,
    IN      USHORT                      cOidList,
    IN      PNDIS_GUID                  ndisSupportedList,
    IN      ULONG                       cSupportedList
    );

NDIS_STATUS
ndisQueryCustomGuids(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  PNDIS_REQUEST                   Request,
    OUT PNDIS_GUID  *                   ppGuidToOid,
    OUT PUSHORT                         pcGuidToOid
    );

NTSTATUS
ndisWmiFindInstanceName(
    IN  PNDIS_CO_VC_PTR_BLOCK   *       ppVcBlock,
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  PWSTR                           pInstanceName,
    IN  USHORT                          cbInstanceName
    );

NDIS_STATUS
ndisQuerySetMiniport(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  PNDIS_CO_VC_PTR_BLOCK           pVcBlock    OPTIONAL,
    IN  BOOLEAN                         fSet,
    IN  PNDIS_REQUEST                   pRequest,
    IN  PLARGE_INTEGER                  TimeOut     OPTIONAL
    );

NDIS_STATUS
ndisMProcessResetRequested(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    OUT PBOOLEAN                        pAddressingReset
    );

#undef NdisMIndicateStatus
VOID
NdisMIndicateStatus(
    IN  NDIS_HANDLE                     MiniportHandle,
    IN  NDIS_STATUS                     GeneralStatus,
    IN  PVOID                           StatusBuffer,
    IN  UINT                            StatusBufferSize
    );

#undef NdisMIndicateStatusComplete
VOID
NdisMIndicateStatusComplete(
    IN  NDIS_HANDLE                     MiniportHandle
    );

#undef NdisMResetComplete
VOID
NdisMResetComplete(
    IN  NDIS_HANDLE                     MiniportAdapterHandle,
    IN  NDIS_STATUS                     Status,
    IN  BOOLEAN                         AddressingReset
    );

VOID
ndisMResetCompleteStage1(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  NDIS_STATUS                     Status,
    IN  BOOLEAN                         AddressingReset
    );

VOID
FASTCALL
ndisMResetCompleteStage2(
    IN  PNDIS_MINIPORT_BLOCK            Miniport
    );

//
// WAN Handlers
//
NDIS_STATUS
ndisMWanSend(
    IN  NDIS_HANDLE                     NdisBindingHandle,
    IN  NDIS_HANDLE                     NdisLinkHandle,
    IN  PNDIS_WAN_PACKET                Packet
    );

#undef NdisMWanIndicateReceive
VOID
NdisMWanIndicateReceive(
    OUT PNDIS_STATUS                    Status,
    IN NDIS_HANDLE                      MiniportAdapterHandle,
    IN NDIS_HANDLE                      NdisLinkContext,
    IN PUCHAR                           Packet,
    IN ULONG                            PacketSize
    );

#undef NdisMWanIndicateReceiveComplete
VOID
NdisMWanIndicateReceiveComplete(
    IN NDIS_HANDLE                      MiniportAdapterHandle,
    IN NDIS_HANDLE                      NdisLinkContext
    );

NDIS_STATUS
ndisMAllocateRequest(
    OUT PNDIS_REQUEST   *               pRequest,
    IN   NDIS_OID                       Oid,
    IN   PVOID                          Buffer      OPTIONAL,
    IN   ULONG                          BufferLength
    );

NDIS_STATUS
ndisMFilterOutStatisticsOids(
    PNDIS_MINIPORT_BLOCK                Miniport,
    PNDIS_REQUEST                       Request
    );

// VOID
// ndisMFreeInternalRequest(
//  IN  PVOID                           PRequest
//  )
#define ndisMFreeInternalRequest(_pRequest) FREE_POOL(_pRequest)

VOID
ndisMTimerDpc(
    IN  PKDPC                           Dpc,
    IN  PVOID                           Context,
    IN  PVOID                           SystemContext1,
    IN  PVOID                           SystemContext2
    );

VOID
FASTCALL
ndisMAbortRequests(
    IN  PNDIS_MINIPORT_BLOCK            Miniport
    );

VOID
FASTCALL
ndisMAbortPackets(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  PNDIS_OPEN_BLOCK                Open OPTIONAL,
    IN  PVOID                           CancelId OPTIONAL
    );

BOOLEAN
FASTCALL
ndisMLoopbackPacketX(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  PNDIS_PACKET                    Packet
    );

BOOLEAN
FASTCALL
ndisMIsLoopbackPacket(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  PNDIS_PACKET                    Packet,
    OUT PNDIS_PACKET    *               LoopbackPacket  OPTIONAL
    );

VOID
ndisMRundownRequests(
    IN  PNDIS_WORK_ITEM                 pWorkItem
    );

VOID
FASTCALL
ndisMDoRequests(
    IN  PNDIS_MINIPORT_BLOCK            Miniport
    );

VOID
ndisMCopyFromPacketToBuffer(
    IN  PNDIS_PACKET                    Packet,
    IN  UINT                            Offset,
    IN  UINT                            BytesToCopy,
    OUT PCHAR                           Buffer,
    OUT PUINT                           BytesCopied
    );

BOOLEAN
FASTCALL
ndisMCreateDummyFilters(
    IN  PNDIS_MINIPORT_BLOCK            Miniport
    );


VOID
FASTCALL
ndisMAdjustFilters(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  PFILTERDBS                      FilterDB
    );

LONG
ndisMDoMiniportOp(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  BOOLEAN                         Query,
    IN  ULONG                           Oid,
    IN  PVOID                           Buf,
    IN  LONG                            BufSize,
    IN  LONG                            ErrorCodesToReturn,
    IN  BOOLEAN                         fMandatory
    );

VOID
ndisMOpenAdapter(
    OUT PNDIS_STATUS                    Status,
    IN  PNDIS_OPEN_BLOCK                NewOpenP,
    IN  BOOLEAN                         UsingEncapsulation
    );

VOID
FASTCALL
ndisMSyncQueryInformationComplete(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  NDIS_STATUS                     Status
    );

#undef NdisMSetInformationComplete
VOID
NdisMSetInformationComplete(
    IN  NDIS_HANDLE                     MiniportAdapterHandle,
    IN  NDIS_STATUS                     Status
    );

#undef NdisMQueryInformationComplete
VOID
NdisMQueryInformationComplete(
    IN  NDIS_HANDLE                     MiniportAdapterHandle,
    IN  NDIS_STATUS                     Status
    );
VOID
FASTCALL
ndisMSyncSetInformationComplete(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  NDIS_STATUS                     Status
    );

VOID
ndisMRequestSetInformationPost(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  PNDIS_REQUEST                   Request,
    IN  NDIS_STATUS                     Status
    );

BOOLEAN
FASTCALL
ndisMQueueRequest(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  PNDIS_REQUEST                   Request
    );

VOID
FASTCALL
ndisMRestoreFilterSettings(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  PNDIS_OPEN_BLOCK                Open OPTIONAL,
    IN  BOOLEAN                         fReset
    );

NDIS_STATUS
FASTCALL
ndisMSetPacketFilter(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  PNDIS_REQUEST                   Request
    );

NDIS_STATUS
FASTCALL
ndisMSetProtocolOptions(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  PNDIS_REQUEST                   Request
    );

NDIS_STATUS
FASTCALL
ndisMSetCurrentLookahead(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  PNDIS_REQUEST                   Request
    );

NDIS_STATUS
FASTCALL
ndisMSetMulticastList(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  PNDIS_REQUEST                   Request
    );

NDIS_STATUS
FASTCALL
ndisMSetFunctionalAddress(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  PNDIS_REQUEST                   Request
    );

NDIS_STATUS
FASTCALL
ndisMSetGroupAddress(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  PNDIS_REQUEST                   Request
    );

NDIS_STATUS
FASTCALL
ndisMSetFddiMulticastList(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  PNDIS_REQUEST                   Request
    );

NDIS_STATUS
FASTCALL
ndisMSetAddWakeUpPattern(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  PNDIS_REQUEST                   Request
    );

NDIS_STATUS
FASTCALL
ndisMSetRemoveWakeUpPattern(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  PNDIS_REQUEST                   Request
    );

NDIS_STATUS
FASTCALL
ndisMSetEnableWakeUp(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  PNDIS_REQUEST                   Request
    );

NDIS_STATUS
ndisMSetInformation(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  PNDIS_REQUEST                   Request
    );

NDIS_STATUS
FASTCALL
ndisMQueryCurrentPacketFilter(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  PNDIS_REQUEST                   Request
    );
    
NDIS_STATUS
FASTCALL
ndisMQueryMediaSupported(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  PNDIS_REQUEST                   Request
    );

NDIS_STATUS
FASTCALL
ndisMQueryEthernetMulticastList(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  PNDIS_REQUEST                   Request
    );

NDIS_STATUS
FASTCALL
ndisMQueryLongMulticastList(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  PNDIS_REQUEST                   Request
    );

NDIS_STATUS
FASTCALL
ndisMQueryShortMulticastList(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  PNDIS_REQUEST                   Request
    );

NDIS_STATUS
FASTCALL
ndisMQueryMaximumFrameSize(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  PNDIS_REQUEST                   Request
    );

NDIS_STATUS
FASTCALL
ndisMQueryMaximumTotalSize(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  PNDIS_REQUEST                   Request
    );

NDIS_STATUS
FASTCALL
ndisMQueryNetworkAddress(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  PNDIS_REQUEST                   Request
    );

NDIS_STATUS
FASTCALL
ndisMQueryWakeUpPatternList(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  PNDIS_REQUEST                   Request
    );

NDIS_STATUS
FASTCALL
ndisMQueryEnableWakeUp(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  PNDIS_REQUEST                   Request
    );

NDIS_STATUS
ndisMQueryInformation(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  PNDIS_REQUEST                   Request
    );

NDIS_STATUS
FASTCALL
ndisMDispatchRequest(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  PNDIS_REQUEST                   Request,
    IN  BOOLEAN                         fQuery
    );

//
// X Filter
//
VOID
FASTCALL
XFilterLockHandler(
    IN  PETH_FILTER                     Filter,
    IN OUT  PLOCK_STATE                 pLockState
    );

VOID
XRemoveAndFreeBinding(
    IN  PX_FILTER                       Filter,
    IN  PX_BINDING_INFO                 Binding
    );

VOID
XRemoveBindingFromLists(
    IN  PX_FILTER                       Filter,
    IN  PX_BINDING_INFO                 Binding
    );

NDIS_STATUS
XFilterAdjust(
    IN  PX_FILTER                       Filter,
    IN  NDIS_HANDLE                     NdisFilterHandle,
    IN  UINT                            FilterClasses,
    IN  BOOLEAN                         Set
    );

VOID
XUndoFilterAdjust(
    IN  PX_FILTER                       Filter,
    IN  PX_BINDING_INFO                 Binding
    );

BOOLEAN
XNoteFilterOpenAdapter(
    IN  PX_FILTER                       Filter,
    IN  NDIS_HANDLE                     NdisBindingHandle,
    OUT PNDIS_HANDLE                    NdisFilterHandle
    );

//
// EthFilterxxx
//
BOOLEAN
EthCreateFilter(
    IN  UINT                            MaximumMulticastAddresses,
    IN  PUCHAR                          AdapterAddress,
    OUT PETH_FILTER *                   Filter
    );

VOID
EthDeleteFilter(
    IN  PETH_FILTER                     Filter
    );

NDIS_STATUS
EthDeleteFilterOpenAdapter(
    IN  PETH_FILTER                     Filter,
    IN  NDIS_HANDLE                     NdisFilterHandle
    );

NDIS_STATUS
EthChangeFilterAddresses(
    IN  PETH_FILTER                     Filter,
    IN  NDIS_HANDLE                     NdisFilterHandle,
    IN  UINT                            AddressCount,
    IN  CHAR                            Addresses[][ETH_LENGTH_OF_ADDRESS],
    IN  BOOLEAN                         Set
    );

BOOLEAN
EthShouldAddressLoopBack(
    IN  PETH_FILTER                     Filter,
    IN  CHAR                            Address[ETH_LENGTH_OF_ADDRESS]
    );

UINT
EthNumberOfOpenFilterAddresses(
    IN  PETH_FILTER                     Filter,
    IN  NDIS_HANDLE                     NdisFilterHandle
    );

VOID
EthQueryGlobalFilterAddresses(
    OUT PNDIS_STATUS                    Status,
    IN  PETH_FILTER                     Filter,
    IN  UINT                            SizeOfArray,
    OUT PUINT                           NumberOfAddresses,
    IN  OUT CHAR                        AddressArray[][ETH_LENGTH_OF_ADDRESS]
    );

VOID
EthQueryOpenFilterAddresses(
    OUT PNDIS_STATUS                    Status,
    IN  PETH_FILTER                     Filter,
    IN  NDIS_HANDLE                     NdisFilterHandle,
    IN  UINT                            SizeOfArray,
    OUT PUINT                           NumberOfAddresses,
    IN  OUT CHAR                        AddressArray[][ETH_LENGTH_OF_ADDRESS]
    );


VOID
EthFilterIndicateReceive(
    IN  PETH_FILTER                     Filter,
    IN  NDIS_HANDLE                     MacReceiveContext,
    IN  PCHAR                           Address,
    IN  PVOID                           HeaderBuffer,
    IN  UINT                            HeaderBufferSize,
    IN  PVOID                           LookaheadBuffer,
    IN  UINT                            LookaheadBufferSize,
    IN  UINT                            PacketSize
    );

VOID
EthFilterIndicateReceiveComplete(
    IN  PETH_FILTER                     Filter
    );

BOOLEAN
FASTCALL
ethFindMulticast(
    IN  UINT                            NumberOfAddresses,
    IN  CHAR                            AddressArray[][ETH_LENGTH_OF_ADDRESS],
    IN  CHAR                            MulticastAddress[ETH_LENGTH_OF_ADDRESS]
    );

VOID
ethCompleteChangeFilterAddresses(
    IN  PETH_FILTER             Filter,
    IN  NDIS_STATUS             Status,
    IN  PETH_BINDING_INFO       LocalBinding OPTIONAL,
    IN  BOOLEAN                 WriteFilterHeld
    );

VOID
ethFilterDprIndicateReceivePacket(
    IN  NDIS_HANDLE                     MiniportHandle,
    IN  PPNDIS_PACKET                   ReceivedPackets,
    IN  UINT                            NumberOfPackets
    );

VOID
EthFilterDprIndicateReceive(
    IN  PETH_FILTER                     Filter,
    IN  NDIS_HANDLE                     MacReceiveContext,
    IN  PCHAR                           Address,
    IN  PVOID                           HeaderBuffer,
    IN  UINT                            HeaderBufferSize,
    IN  PVOID                           LookaheadBuffer,
    IN  UINT                            LookaheadBufferSize,
    IN  UINT                            PacketSize
    );

VOID
EthFilterDprIndicateReceiveComplete(
    IN  PETH_FILTER                     Filter
    );

// UINT
// ethNumberOfGlobalAddresses(
//  IN  PETH_FILTER                     Filter
//  );
#define ethNumberOfGlobalAddresses(_Filter) (_Filter)->NumAddresses

//
// FddiFilterxxxx
//
BOOLEAN
FddiCreateFilter(
    IN  UINT                            MaximumMulticastLongAddresses,
    IN  UINT                            MaximumMulticastShortAddresses,
    IN  PUCHAR                          AdapterLongAddress,
    IN  PUCHAR                          AdapterShortAddress,
    OUT PFDDI_FILTER *                  Filter
    );

VOID
FddiDeleteFilter(
    IN  PFDDI_FILTER                    Filter
    );

NDIS_STATUS
FddiDeleteFilterOpenAdapter(
    IN  PFDDI_FILTER                    Filter,
    IN  NDIS_HANDLE                     NdisFilterHandle
    );

NDIS_STATUS
FddiChangeFilterLongAddresses(
    IN  PFDDI_FILTER                    Filter,
    IN  NDIS_HANDLE                     NdisFilterHandle,
    IN  UINT                            AddressCount,
    IN  CHAR                            Addresses[][FDDI_LENGTH_OF_LONG_ADDRESS],
    IN  BOOLEAN                         Set
    );

NDIS_STATUS
FddiChangeFilterShortAddresses(
    IN  PFDDI_FILTER                    Filter,
    IN  NDIS_HANDLE                     NdisFilterHandle,
    IN  UINT                            AddressCount,
    IN  CHAR                            Addresses[][FDDI_LENGTH_OF_SHORT_ADDRESS],
    IN  BOOLEAN                         Set
    );

BOOLEAN
FddiShouldAddressLoopBack(
    IN  PFDDI_FILTER                    Filter,
    IN  CHAR                            Address[],
    IN  UINT                            LengthOfAddress
    );

UINT
FddiNumberOfOpenFilterLongAddresses(
    IN  PFDDI_FILTER                    Filter,
    IN  NDIS_HANDLE                     NdisFilterHandle
    );

UINT
FddiNumberOfOpenFilterShortAddresses(
    IN  PFDDI_FILTER                    Filter,
    IN  NDIS_HANDLE                     NdisFilterHandle
    );

VOID
FddiQueryGlobalFilterLongAddresses(
    OUT PNDIS_STATUS                    Status,
    IN  PFDDI_FILTER                    Filter,
    IN  UINT                            SizeOfArray,
    OUT PUINT                           NumberOfAddresses,
    IN  OUT CHAR                        AddressArray[][FDDI_LENGTH_OF_LONG_ADDRESS]
    );

VOID
FddiQueryGlobalFilterShortAddresses(
    OUT PNDIS_STATUS                    Status,
    IN  PFDDI_FILTER                    Filter,
    IN  UINT                            SizeOfArray,
    OUT PUINT                           NumberOfAddresses,
    IN  OUT CHAR                        AddressArray[][FDDI_LENGTH_OF_SHORT_ADDRESS]
    );

VOID
FddiQueryOpenFilterLongAddresses(
    OUT PNDIS_STATUS                    Status,
    IN  PFDDI_FILTER                    Filter,
    IN  NDIS_HANDLE                     NdisFilterHandle,
    IN  UINT                            SizeOfArray,
    OUT PUINT                           NumberOfAddresses,
    IN  OUT CHAR                        AddressArray[][FDDI_LENGTH_OF_LONG_ADDRESS]
    );

VOID
FddiQueryOpenFilterShortAddresses(
    OUT PNDIS_STATUS                    Status,
    IN  PFDDI_FILTER                    Filter,
    IN  NDIS_HANDLE                     NdisFilterHandle,
    IN  UINT                            SizeOfArray,
    OUT PUINT                           NumberOfAddresses,
    IN  OUT CHAR                        AddressArray[][FDDI_LENGTH_OF_SHORT_ADDRESS]
    );

VOID
FddiFilterIndicateReceive(
    IN  PFDDI_FILTER                    Filter,
    IN  NDIS_HANDLE                     MacReceiveContext,
    IN  PCHAR                           Address,
    IN  UINT                            AddressLength,
    IN  PVOID                           HeaderBuffer,
    IN  UINT                            HeaderBufferSize,
    IN  PVOID                           LookaheadBuffer,
    IN  UINT                            LookaheadBufferSize,
    IN  UINT                            PacketSize
    );

VOID
FddiFilterIndicateReceiveComplete(
    IN  PFDDI_FILTER                    Filter
    );

BOOLEAN
FASTCALL
fddiFindMulticastLongAddress(
    IN  UINT                            NumberOfAddresses,
    IN  CHAR                            AddressArray[][FDDI_LENGTH_OF_LONG_ADDRESS],
    IN  CHAR                            MulticastAddress[FDDI_LENGTH_OF_LONG_ADDRESS]
    );

BOOLEAN
FASTCALL
fddiFindMulticastShortAddress(
    IN  UINT                            NumberOfAddresses,
    IN  CHAR                            AddressArray[][FDDI_LENGTH_OF_SHORT_ADDRESS],
    IN  CHAR                            MulticastAddress[FDDI_LENGTH_OF_SHORT_ADDRESS]
    );

VOID
fddiCompleteChangeFilterLongAddresses(
    IN  PFDDI_FILTER                    Filter,
    IN  NDIS_STATUS                     Status
    );

VOID
fddiCompleteChangeFilterShortAddresses(
    IN  PFDDI_FILTER                    Filter,
    IN  NDIS_STATUS                     Status
    );

VOID
FddiFilterDprIndicateReceive(
    IN  PFDDI_FILTER                    Filter,
    IN  NDIS_HANDLE                     MacReceiveContext,
    IN  PCHAR                           Address,
    IN  UINT                            AddressLength,
    IN  PVOID                           HeaderBuffer,
    IN  UINT                            HeaderBufferSize,
    IN  PVOID                           LookaheadBuffer,
    IN  UINT                            LookaheadBufferSize,
    IN  UINT                            PacketSize
    );

VOID
FddiFilterDprIndicateReceiveComplete(
    IN  PFDDI_FILTER                    Filter
    );

VOID
fddiFilterDprIndicateReceivePacket(
    IN  NDIS_HANDLE                     MiniportHandle,
    IN  PPNDIS_PACKET                   ReceivedPackets,
    IN  UINT                            NumberOfPackets
    );

// UINT
// fddiNumberOfShortGlobalAddresses(
//  IN  PFDDI_FILTER                    Filter
//  );
#define fddiNumberOfShortGlobalAddresses(_Filter)   (_Filter)->NumShortAddresses

// UINT
// fddiNumberOfLongGlobalAddresses(
//  IN  PFDDI_FILTER                    Filter
//  );
#define fddiNumberOfLongGlobalAddresses(_Filter)    (_Filter)->NumLongAddresses

//
// TrFilterxxx
//
BOOLEAN
TrCreateFilter(
    IN  PUCHAR                          AdapterAddress,
    OUT PTR_FILTER *                    Filter
    );

VOID
TrDeleteFilter(
    IN  PTR_FILTER                      Filter
    );

NDIS_STATUS
TrDeleteFilterOpenAdapter(
    IN  PTR_FILTER                      Filter,
    IN  NDIS_HANDLE                     NdisFilterHandle
    );

NDIS_STATUS
TrChangeFunctionalAddress(
    IN  PTR_FILTER                      Filter,
    IN  NDIS_HANDLE                     NdisFilterHandle,
    IN  CHAR                            FunctionalAddressArray[TR_LENGTH_OF_FUNCTIONAL],
    IN  BOOLEAN                         Set
    );

NDIS_STATUS
TrChangeGroupAddress(
    IN  PTR_FILTER                      Filter,
    IN  NDIS_HANDLE                     NdisFilterHandle,
    IN  CHAR                            GroupAddressArray[TR_LENGTH_OF_FUNCTIONAL],
    IN  BOOLEAN                         Set
    );

BOOLEAN
TrShouldAddressLoopBack(
    IN  PTR_FILTER                      Filter,
    IN  CHAR                            DestinationAddress[TR_LENGTH_OF_ADDRESS],
    IN  CHAR                            SourceAddress[TR_LENGTH_OF_ADDRESS]
    );

VOID
TrFilterIndicateReceive(
    IN  PTR_FILTER                      Filter,
    IN  NDIS_HANDLE                     MacReceiveContext,
    IN  PVOID                           HeaderBuffer,
    IN  UINT                            HeaderBufferSize,
    IN  PVOID                           LookaheadBuffer,
    IN  UINT                            LookaheadBufferSize,
    IN  UINT                            PacketSize
    );

VOID
TrFilterIndicateReceiveComplete(
    IN  PTR_FILTER                      Filter
    );

VOID
trUndoChangeFunctionalAddress(
    IN  OUT PTR_FILTER                  Filter,
    IN      PTR_BINDING_INFO            Binding
    );

VOID
trUndoChangeGroupAddress(
    IN  OUT PTR_FILTER                  Filter,
    IN      PTR_BINDING_INFO            Binding
    );

VOID
trCompleteChangeGroupAddress(
    IN  OUT PTR_FILTER                  Filter,
    IN      PTR_BINDING_INFO            Binding
    );

VOID
TrFilterDprIndicateReceive(
    IN  PTR_FILTER                      Filter,
    IN  NDIS_HANDLE                     MacReceiveContext,
    IN  PVOID                           HeaderBuffer,
    IN  UINT                            HeaderBufferSize,
    IN  PVOID                           LookaheadBuffer,
    IN  UINT                            LookaheadBufferSize,
    IN  UINT                            PacketSize
    );

VOID
TrFilterDprIndicateReceiveComplete(
    IN  PTR_FILTER                      Filter
    );

VOID
trFilterDprIndicateReceivePacket(
    IN  NDIS_HANDLE                     MiniportHandle,
    IN  PPNDIS_PACKET                   ReceivedPackets,
    IN  UINT                            NumberOfPackets
    );

//
// ArcFilterxxx
//
#if ARCNET

VOID
ndisMArcCopyFromBufferToPacket(
    IN  PCHAR                           Buffer,
    IN  UINT                            BytesToCopy,
    IN  PNDIS_PACKET                    Packet,
    IN  UINT                            Offset,
    OUT PUINT                           BytesCopied
    );


BOOLEAN
FASTCALL
ndisMArcnetSendLoopback(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  PNDIS_PACKET                    Packet
    );

NDIS_STATUS
ndisMBuildArcnetHeader(
    PNDIS_MINIPORT_BLOCK                Miniport,
    PNDIS_OPEN_BLOCK                    Open,
    PNDIS_PACKET                        Packet
    );

VOID
ndisMFreeArcnetHeader(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  PNDIS_PACKET                    Packet,
    IN  PNDIS_OPEN_BLOCK                Open    
    );

VOID
ArcDeleteFilter(
    IN  PARC_FILTER                     Filter
    );


NDIS_STATUS
ndisMArcTransferData(
    IN  NDIS_HANDLE                     NdisBindingHandle,
    IN  NDIS_HANDLE                     MacReceiveContext,
    IN  UINT                            ByteOffset,
    IN  UINT                            BytesToTransfer,
    IN  OUT                             PNDIS_PACKET Packet,
    OUT PUINT                           BytesTransferred
    );

VOID
ndisMArcIndicateEthEncapsulatedReceive(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  PVOID                           HeaderBuffer,
    IN  PVOID                           DataBuffer,
    IN  UINT                            Length
    );

VOID
arcUndoFilterAdjust(
    IN  PARC_FILTER                     Filter,
    IN  PARC_BINDING_INFO               Binding
    );

NDIS_STATUS
ArcConvertOidListToEthernet(
    IN  PNDIS_OID                       OidList,
    IN  PULONG                          NumberOfOids
    );

NDIS_STATUS
ArcAllocateBuffers(
    IN  PARC_FILTER                     Filter
    );

NDIS_STATUS
ArcAllocatePackets(
    IN  PARC_FILTER                     Filter
    );

VOID
ArcDiscardPacketBuffers(
    IN  PARC_FILTER                     Filter,
    IN  PARC_PACKET                     Packet
    );

VOID
ArcDestroyPacket(
    IN  PARC_FILTER                     Filter,
    IN  PARC_PACKET                     Packet
    );

BOOLEAN
ArcConvertToNdisPacket(
    IN  PARC_FILTER                     Filter,
    IN  PARC_PACKET                     Packet,
    IN  BOOLEAN                         ConvertWholePacket
    );
#endif

//
//  WORK ITEM ROUTINES.
//
VOID
FASTCALL
ndisMDeQueueWorkItem(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  NDIS_WORK_ITEM_TYPE             WorkItemType,
    OUT PVOID   *                       WorkItemContext OPTIONAL,
    OUT PVOID   *                       WorkItemHandler OPTIONAL
    );

NDIS_STATUS
FASTCALL
ndisMQueueWorkItem(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  NDIS_WORK_ITEM_TYPE             WorkItemType,
    OUT PVOID                           WorkItemContext
    );

NDIS_STATUS
FASTCALL
ndisMQueueNewWorkItem(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  NDIS_WORK_ITEM_TYPE             WorkItemType,
    OUT PVOID                           WorkItemContext,
    IN  PVOID                           WorkItemHandler OPTIONAL
    );

VOID
FASTCALL
ndisIMDeQueueWorkItem(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  NDIS_WORK_ITEM_TYPE             WorkItemType,
    OUT PVOID                           WorkItemContext
    );

//
//  SEND HANDLERS
//
//
BOOLEAN
FASTCALL
ndisMStartSendPackets(
    IN  PNDIS_MINIPORT_BLOCK            Miniport
    );

BOOLEAN
FASTCALL
ndisMStartSends(
    IN  PNDIS_MINIPORT_BLOCK            Miniport
    );

BOOLEAN
FASTCALL
ndisMStartWanSends(
    IN  PNDIS_MINIPORT_BLOCK            Miniport
    );

#undef NdisMSendResourcesAvailable
VOID
NdisMSendResourcesAvailable(
    IN  NDIS_HANDLE                     MiniportAdapterHandle
    );

#undef NdisMSendComplete
VOID
NdisMSendComplete(
    IN  NDIS_HANDLE                     MiniportAdapterHandle,
    IN  PNDIS_PACKET                    Packet,
    IN  NDIS_STATUS                     Status
    );

VOID
ndisMSendCompleteX(
    IN  NDIS_HANDLE                     MiniportAdapterHandle,
    IN  PNDIS_PACKET                    Packet,
    IN  NDIS_STATUS                     Status
    );

#undef NdisMWanSendComplete
VOID
NdisMWanSendComplete(
    IN  NDIS_HANDLE                     MiniportAdapterHandle,
    IN  PNDIS_WAN_PACKET                Packet,
    IN  NDIS_STATUS                     Status
    );

VOID
ndisMSendPackets(
    IN  NDIS_HANDLE                     NdisBindingHandle,
    IN  PPNDIS_PACKET                   PacketArray,
    IN  UINT                            NumberOfPackets
    );

VOID
ndisMSendPacketsX(
    IN  NDIS_HANDLE                     NdisBindingHandle,
    IN  PPNDIS_PACKET                   PacketArray,
    IN  UINT                            NumberOfPackets
    );

NDIS_STATUS
ndisMSend(
    IN  NDIS_HANDLE                     NdisBindingHandle,
    IN  PNDIS_PACKET                    Packet
    );

NDIS_STATUS
ndisMSendX(
    IN  NDIS_HANDLE                     NdisBindingHandle,
    IN  PNDIS_PACKET                    Packet
    );

NDIS_STATUS
ndisMCoSendPackets(
    IN  NDIS_HANDLE                     NdisVcHandle,
    IN  PPNDIS_PACKET                   PacketArray,
    IN  UINT                            NumberOfPackets
    );

NDIS_STATUS
ndisMRejectSend(
    IN  NDIS_HANDLE                     NdisBindingHandle,
    IN  PNDIS_PACKET                    Packet
    );

VOID
ndisMRejectSendPackets(
    IN  NDIS_HANDLE                     NdisBindingHandle,
    IN  PPNDIS_PACKET                   Packets,
    IN  UINT                            NumberOfPackets
    );
    
VOID
FASTCALL
ndisMRestoreOpenHandlers(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  UCHAR                           Flags                   
    );

VOID
FASTCALL
ndisMSwapOpenHandlers(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  NDIS_STATUS                     Status,
    IN  UCHAR                           Flags
    );

NTSTATUS
ndisPassIrpDownTheStack(
    IN  PIRP                            pIrp,
    IN  PDEVICE_OBJECT                  pNextDeviceObject
    );

//
// Co-Ndis prototypes
//
VOID
ndisNotifyAfRegistration(
    IN  struct _NDIS_AF_NOTIFY  *       AfNotify
    );

NDIS_STATUS
ndisCreateNotifyQueue(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  PNDIS_OPEN_BLOCK                Open            OPTIONAL,
    IN  PCO_ADDRESS_FAMILY              AddressFamily   OPTIONAL,
    IN  PNDIS_AF_NOTIFY         *       AfNotify
    );

BOOLEAN
FASTCALL
ndisReferenceAf(
    IN  PNDIS_CO_AF_BLOCK               AfBlock
    );

VOID
FASTCALL
ndisDereferenceAf(
    IN  PNDIS_CO_AF_BLOCK               AfBlock
    );

BOOLEAN
FASTCALL
ndisReferenceSap(
    IN  PNDIS_CO_SAP_BLOCK              SapBlock
    );

VOID
FASTCALL
ndisDereferenceSap(
    IN  PNDIS_CO_SAP_BLOCK              SapBlock
    );

BOOLEAN
FASTCALL
ndisReferenceVcPtr(
    IN  PNDIS_CO_VC_PTR_BLOCK           VcPtr
    );

VOID
FASTCALL
ndisDereferenceVcPtr(
    IN  PNDIS_CO_VC_PTR_BLOCK           VcPtr
    );

VOID
FASTCALL
ndisMCoFreeResources(
    PNDIS_OPEN_BLOCK                    Open
    );

//
//  Fake handlers
//
NDIS_STATUS
ndisMFakeWanSend(
    IN  NDIS_HANDLE                     NdisBindingHandle,
    IN  NDIS_HANDLE                     NdisLinkHandle,
    IN  PVOID                           Packet
    );

NDIS_STATUS
ndisMFakeSend(
    IN  NDIS_HANDLE                     NdisBindingHandle,
    IN  PNDIS_PACKET                    Packet
    );

VOID
ndisMFakeSendPackets(
    IN  NDIS_HANDLE                     NdisBindingHandle,
    IN  PPNDIS_PACKET                   PacketArray,
    IN  UINT                            NumberOfPackets
    );

NDIS_STATUS
ndisMFakeReset(
    IN  NDIS_HANDLE                     NdisBindingHandle
    );

NDIS_STATUS
ndisMFakeRequest(
    IN  NDIS_HANDLE                     NdisBindingHandle,
    IN  PNDIS_REQUEST                   NdisRequest
    );


//
//  POWER MANAGEMENT ROUTINES
//
NTSTATUS
FASTCALL
ndisQueryPowerCapabilities(
    IN  PNDIS_MINIPORT_BLOCK            Miniport
    );

VOID
ndisMediaDisconnectWorker(
    IN  PPOWER_WORK_ITEM                pWorkItem,
    IN  PVOID                           Context
    );

NTSTATUS
ndisMediaDisconnectComplete(
    IN  PDEVICE_OBJECT                  pdo,
    IN  UCHAR                           MinorFunction,
    IN  POWER_STATE                     PowerState,
    IN  PVOID                           Context,
    IN  PIO_STATUS_BLOCK                IoStatus
    );

VOID
ndisMediaDisconnectTimeout(
    IN  PVOID                           SystemSpecific1,
    IN  PVOID                           Context,
    IN  PVOID                           SystemSpecific2,
    IN  PVOID                           SystemSpecific3
    );

NTSTATUS
ndisWaitWakeComplete(
    IN  PDEVICE_OBJECT                  pdo,
    IN  UCHAR                           MinorFunction,
    IN  POWER_STATE                     PowerState,
    IN  PVOID                           Context,
    IN  PIO_STATUS_BLOCK                IoStatus
    );

NTSTATUS
ndisQueryPowerComplete(
    IN PDEVICE_OBJECT                   pdo,
    IN PIRP                             pirp,
    IN PVOID                            Context
    );

NTSTATUS
ndisMPowerPolicy(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  SYSTEM_POWER_STATE              SystemState,
    IN  PDEVICE_POWER_STATE             pDeviceState,
    IN  BOOLEAN                         fIsQuery
    );

NTSTATUS
ndisQueryPower(
    IN  PIRP                            pirp,
    IN  PIO_STACK_LOCATION              pirpSp,
    IN  PNDIS_MINIPORT_BLOCK            Miniport
    );

VOID
FASTCALL
ndisPmHaltMiniport(
    IN PNDIS_MINIPORT_BLOCK             Miniport
    );

NDIS_STATUS
ndisPmInitializeMiniport(
    IN PNDIS_MINIPORT_BLOCK             Miniport
    );

NDIS_STATUS
ndisQuerySetMiniportDeviceState(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  DEVICE_POWER_STATE              DeviceState,
    IN  NDIS_OID                        Oid,
    IN  BOOLEAN                         fSet
    );

NTSTATUS
ndisSetSystemPowerComplete(
    IN  PDEVICE_OBJECT                  pdo,
    IN  UCHAR                           MinorFunction,
    IN  POWER_STATE                     PowerState,
    IN  PVOID                           Context,
    IN  PIO_STATUS_BLOCK                IoStatus
    );

VOID
ndisDevicePowerOn(
    IN  PPOWER_WORK_ITEM                pWorkItem,
    IN  PVOID                           pContext
    );

NTSTATUS
ndisSetDevicePowerOnComplete(
    IN  PDEVICE_OBJECT                  pdo,
    IN  PIRP                            pirp,
    IN  PVOID                           Context
    );

VOID
ndisDevicePowerDown(
    IN  PPOWER_WORK_ITEM                pWorkItem,
    IN  PVOID                           pContext
    );

NTSTATUS
ndisSetDevicePowerDownComplete(
    IN  PDEVICE_OBJECT                  pdo,
    IN  PIRP                            pirp,
    IN  PVOID                           Context
    );

NTSTATUS
ndisSetPower(
    IN  PIRP                            pirp,
    IN  PIO_STACK_LOCATION              pirpSp,
    IN  PNDIS_MINIPORT_BLOCK            Miniport
    );

NTSTATUS
ndisPowerDispatch(
    IN  PDEVICE_OBJECT                  pdo,
    IN  PIRP                            pirp
    );

BOOLEAN
FASTCALL
ndisQueueOpenOnMiniport(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  PNDIS_OPEN_BLOCK                MiniportOpen
    );

NDIS_STATUS
ndisQueueBindWorkitem(
    IN  PNDIS_MINIPORT_BLOCK            Miniport
    );

VOID
ndisQueuedCheckAdapterBindings(
    IN  PNDIS_WORK_ITEM                 pWorkItem,
    IN  PVOID                           Context
    );

BOOLEAN
ndisIsMiniportStarted(
    IN PNDIS_MINIPORT_BLOCK             Miniport
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ndis\sys\debug.c ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation

Module Name:

    debug.c

Abstract:

    NDIS wrapper definitions

Author:


Environment:

    Kernel mode, FSD

Revision History:

    10/22/95        Kyle Brandon    Created.
--*/

#include <precomp.h>
#pragma hdrstop

#if DBG

//
//  Define module number for debug code
//
#define MODULE_NUMBER   MODULE_DEBUG

VOID
ndisDbgPrintUnicodeString(
    IN  PUNICODE_STRING     UnicodeString
        )
{
    UCHAR Buffer[256];


    USHORT i;

    for (i = 0; (i < UnicodeString->Length / 2) && (i < 255); i++)
        Buffer[i] = (UCHAR)UnicodeString->Buffer[i];
        
    Buffer[i] = '\0';
    
    DbgPrint("%s", Buffer);
}

#endif // DBG

#if ASSERT_ON_FREE_BUILDS

VOID
ndisAssert(
    IN  PVOID               exp,
    IN  PUCHAR              File,
    IN  UINT                Line
    )
{
    DbgPrint("Assertion failed: \"%s\", File %s, Line %d\n", exp, File, Line);
    DbgBreakPoint();
    
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ndis\sys\efilter.c ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation

Module Name:

    efilter.c

Abstract:

    This module implements a set of library routines to handle packet
    filtering for NDIS MAC drivers.

Author:

    Anthony V. Ercolano (Tonye) 03-Aug-1990

Environment:

    Kernel Mode - Or whatever is the equivalent on OS/2 and DOS.

Revision History:

    Adam Barr (adamba) 28-Nov-1990

        - Added AddressContexts

    Adam Barr (adamba) 28-May-1991

        - renamed MacXXX to EthXXX, changed filter.c to efilter.c

    10-July-1995        KyleB       Added separate queues for bindings
                                    that receive directed and broadcast
                                    packets.  Also fixed the request code
                                    that requires the filter database.


--*/

#include <precomp.h>
#pragma hdrstop


//
//  Define the module number for debug code.
//
#define MODULE_NUMBER   MODULE_EFILTER

#define ETH_CHECK_FOR_INVALID_BROADCAST_INDICATION(_F)                  \
IF_DBG(DBG_COMP_FILTER, DBG_LEVEL_WARN)                                 \
{                                                                       \
    if (!((_F)->CombinedPacketFilter & NDIS_PACKET_TYPE_BROADCAST))     \
    {                                                                   \
        /*                                                              \
            We should never receive directed packets                    \
            to someone else unless in p-mode.                           \
        */                                                              \
        DBGPRINT(DBG_COMP_FILTER, DBG_LEVEL_ERR,                        \
                ("Bad driver, indicating broadcast when not set to.\n"));\
        DBGBREAK(DBG_COMP_FILTER, DBG_LEVEL_ERR);                       \
    }                                                                   \
}

#define ETH_CHECK_FOR_INVALID_DIRECTED_INDICATION(_F, _A)               \
IF_DBG(DBG_COMP_FILTER, DBG_LEVEL_WARN)                                 \
{                                                                       \
    /*                                                                  \
        The result of comparing an element of the address               \
        array and the multicast address.                                \
                                                                        \
        Result < 0 Implies the adapter address is greater.              \
        Result > 0 Implies the address is greater.                      \
        Result = 0 Implies that the they are equal.                     \
    */                                                                  \
    INT Result;                                                         \
                                                                        \
    ETH_COMPARE_NETWORK_ADDRESSES_EQ((_F)->AdapterAddress,(_A),&Result);\
    if (Result != 0)                                                    \
    {                                                                   \
        /*                                                              \
            We should never receive directed packets                    \
            to someone else unless in p-mode.                           \
        */                                                              \
        DBGPRINT(DBG_COMP_FILTER, DBG_LEVEL_ERR,                        \
                ("Bad driver, indicating packets to another station when not in promiscuous mode.\n"));\
        DBGBREAK(DBG_COMP_FILTER, DBG_LEVEL_ERR);                       \
    }                                                                   \
}


BOOLEAN
EthCreateFilter(
    IN  UINT                    MaximumMulticastAddresses,
    IN  PUCHAR                  AdapterAddress,
    OUT PETH_FILTER *           Filter
    )
/*++

Routine Description:

    This routine is used to create and initialize the filter database.

Arguments:

    MaximumMulticastAddresses - The maximum number of multicast addresses
    that the MAC will support.

    AdapterAddress - the address of the adapter associated with this filter
    database.

    Filter - A pointer to an ETH_FILTER.  This is what is allocated and
    created by this routine.

Return Value:

    If the function returns false then one of the parameters exceeded
    what the filter was willing to support.

--*/
{
    PETH_FILTER LocalFilter;
    BOOLEAN     rc = FALSE;

    do
    {
        *Filter = LocalFilter = ALLOC_FROM_POOL(sizeof(ETH_FILTER), NDIS_TAG_FILTER);
        if (LocalFilter != NULL)
        {
            ZeroMemory(LocalFilter, sizeof(ETH_FILTER));
            EthReferencePackage();
            ETH_COPY_NETWORK_ADDRESS(LocalFilter->AdapterAddress, AdapterAddress);
            LocalFilter->MaxMulticastAddresses = MaximumMulticastAddresses;
            INITIALIZE_SPIN_LOCK(&LocalFilter->BindListLock.SpinLock);
            rc = TRUE;
        }
    } while (FALSE);

    return(rc);
}


//
// NOTE: THIS FUNCTION CANNOT BE PAGEABLE
//
VOID
EthDeleteFilter(
    IN  PETH_FILTER             Filter
    )
/*++

Routine Description:

    This routine is used to delete the memory associated with a filter
    database.  Note that this routines *ASSUMES* that the database
    has been cleared of any active filters.

Arguments:

    Filter - A pointer to an ETH_FILTER to be deleted.

Return Value:

    None.

--*/
{
    ASSERT(Filter->OpenList == NULL);

    //
    //  Free the memory that was allocated for the current multicast
    //  address list.
    //
    if (Filter->MCastAddressBuf)
    {
        FREE_POOL(Filter->MCastAddressBuf);
    }

    ASSERT(Filter->OldMCastAddressBuf == NULL);

    FREE_POOL(Filter);
    EthDereferencePackage();
}


NDIS_STATUS
EthDeleteFilterOpenAdapter(
    IN  PETH_FILTER             Filter,
    IN  NDIS_HANDLE             NdisFilterHandle
    )
/*++

Routine Description:

    When an adapter is being closed this routine should
    be called to delete knowledge of the adapter from
    the filter database.  This routine is likely to call
    action routines associated with clearing filter classes
    and addresses.

    NOTE: THIS ROUTINE SHOULD ****NOT**** BE CALLED IF THE ACTION
    ROUTINES FOR DELETING THE FILTER CLASSES OR THE MULTICAST ADDRESSES
    HAVE ANY POSSIBILITY OF RETURNING A STATUS OTHER THAN NDIS_STATUS_PENDING
    OR NDIS_STATUS_SUCCESS.  WHILE THESE ROUTINES WILL NOT BUGCHECK IF
    SUCH A THING IS DONE, THE CALLER WILL PROBABLY FIND IT DIFFICULT
    TO CODE A CLOSE ROUTINE!

    NOTE: THIS ROUTINE ASSUMES THAT IT IS CALLED WITH THE LOCK HELD.

Arguments:

    Filter - A pointer to the filter database.

    NdisFilterHandle - Pointer to the open.

Return Value:

    If action routines are called by the various address and filtering
    routines the this routine will likely return the status returned
    by those routines.  The exception to this rule is noted below.

    Given that the filter and address deletion routines return a status
    NDIS_STATUS_PENDING or NDIS_STATUS_SUCCESS this routine will then
    try to return the filter index to the freelist.  If the routine
    detects that this binding is currently being indicated to via
    NdisIndicateReceive, this routine will return a status of
    NDIS_STATUS_CLOSING_INDICATING.

--*/
{
    NDIS_STATUS         StatusToReturn;
    PETH_BINDING_INFO   LocalOpen = (PETH_BINDING_INFO)NdisFilterHandle;

    //
    //  Set the packet filter to NONE.
    //
    StatusToReturn = XFilterAdjust(Filter,
                                   NdisFilterHandle,
                                   (UINT)0,
                                   FALSE);
    if ((StatusToReturn == NDIS_STATUS_SUCCESS) ||
        (StatusToReturn == NDIS_STATUS_PENDING))
    {
        NDIS_STATUS StatusToReturn2;

        //
        //  Clear the multicast addresses.
        //
        StatusToReturn2 = EthChangeFilterAddresses(Filter,
                                                   NdisFilterHandle,
                                                   0,
                                                   NULL,
                                                   FALSE);
        if (StatusToReturn2 != NDIS_STATUS_SUCCESS)
        {
            StatusToReturn = StatusToReturn2;
        }
    }

    if ((StatusToReturn == NDIS_STATUS_SUCCESS) ||
        (StatusToReturn == NDIS_STATUS_PENDING) ||
        (StatusToReturn == NDIS_STATUS_RESOURCES))
    {
        //
        // Remove the reference from the original open.
        //
        if (--(LocalOpen->References) == 0)
        {
            //
            //  Remove the binding from the necessary lists.
            //
            XRemoveAndFreeBinding(Filter, LocalOpen);
        }
        else
        {
            //
            // Let the caller know that there is a reference to the open
            // by the receive indication. The close action routine will be
            // called upon return from NdisIndicateReceive.
            //
            StatusToReturn = NDIS_STATUS_CLOSING_INDICATING;
        }
    }

    return(StatusToReturn);
}


NDIS_STATUS
EthChangeFilterAddresses(
    IN  PETH_FILTER             Filter,
    IN  NDIS_HANDLE             NdisFilterHandle,
    IN  UINT                    AddressCount,
    IN  CHAR                    Addresses[][ETH_LENGTH_OF_ADDRESS],
    IN  BOOLEAN                 Set
    )
/*++

Routine Description:

    The ChangeFilterAddress routine will call an action
    routine when the overall multicast address list for the adapter
    has changed.

    If the action routine returns a value other than pending or
    success then this routine has no effect on the multicast address
    list for the open or for the adapter as a whole.

    NOTE: THIS ROUTINE ASSUMES THAT THE LOCK IS HELD.

Arguments:

    Filter - A pointer to the filter database.

    NdisFilterHandle - Pointer to the open.

    AddressCount - The number of elements (addresses,
    not bytes) in MulticastAddressList.

    Addresses - The new multicast address list for this
    binding. This is a sequence of ETH_LENGTH_OF_ADDRESS byte
    addresses, with no padding between them.

    Set - A boolean that determines whether the multicast addresses
    are being adjusted due to a set or because of a close. (The filtering
    routines don't care, the MAC might.)

Return Value:

    If it calls the action routine then it will return the
    status returned by the action routine.  If the status
    returned by the action routine is anything other than
    NDIS_STATUS_SUCCESS or NDIS_STATUS_PENDING the filter database
    will be returned to the state it was in upon entrance to this
    routine.

    If the action routine is not called this routine will return
    the following status:

    NDIS_STATUS_SUCCESS - If the new packet filters doesn't change
    the combined mask of all bindings packet filters.

--*/
{
    PETH_BINDING_INFO   Binding = (PETH_BINDING_INFO)NdisFilterHandle;
    PNDIS_MINIPORT_BLOCK Miniport = Filter->Miniport;
    NDIS_STATUS         Status = NDIS_STATUS_SUCCESS;
    INT                 Result;
    UINT                i, j;
    LOCK_STATE          LockState;
    CHAR                (*OldFilterMCastAddressBuf)[ETH_LENGTH_OF_ADDRESS];
    UINT                OldFilterNumAddresses;
    
    WRITE_LOCK_FILTER(Miniport, Filter, &LockState);

    //
    // Save the old list for this binding and create a new list.
    // The new list needs to be in a sorted order.
    //
    do
    {
        if (Filter->MaxMulticastAddresses == 0)
        {
            break;
        }
        
        //
        // Save the current values - this is used for undoing stuff if something fails
        //
        ASSERT(Binding->OldMCastAddressBuf == NULL);
        Binding->OldMCastAddressBuf = Binding->MCastAddressBuf;
        Binding->OldNumAddresses = Binding->NumAddresses;
        Binding->MCastAddressBuf = NULL;
        Binding->NumAddresses = 0;

        if (!Set)
        {
            //
            // if we are removing a binding from the filter, since we may be
            // here while the driver is processing the request, save and
            // restore the current "Old" values and keep the filter WRITE lock 
            // all the time till we are done.
            //
            OldFilterMCastAddressBuf = Filter->OldMCastAddressBuf;
            OldFilterNumAddresses = Filter->OldNumAddresses;
        }
        else
        {
            ASSERT(Filter->OldMCastAddressBuf == NULL);
            Filter->MCastSet = Binding;
        }
        
        Filter->OldMCastAddressBuf = Filter->MCastAddressBuf;
        Filter->OldNumAddresses = Filter->NumAddresses;        
        Filter->MCastAddressBuf = NULL;
        Filter->NumAddresses = 0;
        

        //
        // fix the multicast list for the binding
        //
        if (AddressCount != 0)
        {
            Binding->MCastAddressBuf = ALLOC_FROM_POOL(ETH_LENGTH_OF_ADDRESS * AddressCount,
                                                       NDIS_TAG_FILTER_ADDR);
            if (Binding->MCastAddressBuf == NULL)
            {
                Status = NDIS_STATUS_RESOURCES;
                break;
            }
        
            for (i = 0; i < AddressCount; i++)
            {
                Result = -1;
                for (j = 0; j < Binding->NumAddresses; j++)
                {
                    ETH_COMPARE_NETWORK_ADDRESSES(Binding->MCastAddressBuf[j],
                                                  Addresses[i],
                                                  &Result);
                    if (Result >= 0)
                        break;
                }
    
                //
                // This address is already present. Caller supplied duplicate. Skip it.
                //
                if (Result == 0)
                    continue;
    
                Binding->NumAddresses ++;
                if (Result > 0)
                {
                    //
                    // We need to move the addresses forward and copy this one here
                    //
                    MoveMemory(Binding->MCastAddressBuf[j+1],
                               Binding->MCastAddressBuf[j],
                               (Binding->NumAddresses-j-1)*ETH_LENGTH_OF_ADDRESS);
                }
            
                MoveMemory(Binding->MCastAddressBuf[j],
                           Addresses[i],
                           ETH_LENGTH_OF_ADDRESS);
            }
        
            ASSERT(Binding->NumAddresses <= AddressCount);
        }

        //
        // Now we need to allocate memory for the global list. The old stuff will be deleted
        // once the operation completes or if we are actually deleting addresses instead of
        // adding them
        //
        Filter->MCastAddressBuf = ALLOC_FROM_POOL(Filter->MaxMulticastAddresses * ETH_LENGTH_OF_ADDRESS,
                                                  NDIS_TAG_FILTER_ADDR);
        if (Filter->MCastAddressBuf == NULL)
        {
            Status = NDIS_STATUS_RESOURCES;
            break;
        }
        
        //
        // Now create the global list from the bindings
        //
        for (Binding = Filter->OpenList;
             (Binding != NULL) && (Status == NDIS_STATUS_SUCCESS);
             Binding = Binding->NextOpen)
        {
            for (i = 0; i < Binding->NumAddresses; i++)
            {
                Result = -1;
                for (j = 0; j < Filter->NumAddresses; j++)
                {
                    ETH_COMPARE_NETWORK_ADDRESSES(Filter->MCastAddressBuf[j],
                                                  Binding->MCastAddressBuf[i],
                                                  &Result);
                    if (Result >= 0)
                    {
                        break;
                    }
                }
    
                if (Result == 0)
                {
                    continue;
                }
    
                Filter->NumAddresses ++;
                if (Filter->NumAddresses > Filter->MaxMulticastAddresses)
                {
                    //
                    // Abort. We exceeded the the # of addresses
                    //
                    Status = NDIS_STATUS_MULTICAST_FULL;
                    break;
                }
    
                if (Result > 0)
                {
                    //
                    // We need to move the addresses forward and copy this one here
                    //
                    MoveMemory(Filter->MCastAddressBuf[j+1],
                               Filter->MCastAddressBuf[j],
                               (Filter->NumAddresses-j-1)*ETH_LENGTH_OF_ADDRESS);
                }
            
                MoveMemory(Filter->MCastAddressBuf[j],
                           Binding->MCastAddressBuf[i],
                           ETH_LENGTH_OF_ADDRESS);
            }
        }
    
        if (Status != NDIS_STATUS_SUCCESS)
            break;


        //
        // After all the hard work, determine if there was indeed a change
        //
        Result = -1;
        
        if (Filter->NumAddresses == Filter->OldNumAddresses)
        {
            for (i = 0; i < Filter->NumAddresses; i++)
            {
                ETH_COMPARE_NETWORK_ADDRESSES_EQ(Filter->MCastAddressBuf[i],
                                                 Filter->OldMCastAddressBuf[i],
                                                 &Result);
                if (Result != 0)
                    break;
            }
        }
    
        if (Result != 0)
        {
            Status = NDIS_STATUS_PENDING;
        }
        else if (Set && (AddressCount == 0))
        {
            //
            // Addresses are being removed (not added). Get rid of the old list right here
            //
            if (Filter->OldMCastAddressBuf != NULL)
            {
                FREE_POOL(Filter->OldMCastAddressBuf);
                Filter->OldMCastAddressBuf = NULL;
                Filter->OldNumAddresses = 0;
            }
        
            Binding = (PETH_BINDING_INFO)NdisFilterHandle;
            if (Binding->OldMCastAddressBuf != NULL)
            {
                FREE_POOL(Binding->OldMCastAddressBuf);
                Binding->OldMCastAddressBuf = NULL;
                Binding->OldNumAddresses = 0;
            }
        }

    } while (FALSE);

#if ARCNET
    //
    // If the address array has changed, we have to call the
    // action array to inform the adapter of this.
    //
    if (Status == NDIS_STATUS_PENDING)
    {
        Binding = (PETH_BINDING_INFO)NdisFilterHandle;

        if ((Miniport->MediaType == NdisMediumArcnet878_2) &&
            MINIPORT_TEST_FLAG((PNDIS_OPEN_BLOCK)Binding->NdisBindingHandle, fMINIPORT_OPEN_USING_ETH_ENCAPSULATION))
        {
            if (Filter->NumAddresses > 0)
            {
                //
                // Turn on broadcast acceptance.
                //
                MINIPORT_SET_FLAG(Miniport, fMINIPORT_ARCNET_BROADCAST_SET);
            }
            else
            {
                //
                // Unset the broadcast filter.
                //
                MINIPORT_CLEAR_FLAG(Miniport, fMINIPORT_ARCNET_BROADCAST_SET);
            }

            //
            //  Need to return success here so that we don't call down to the
            //  ARCnet miniport with an invalid OID, i.e. an ethernet one....
            //
            Status = NDIS_STATUS_SUCCESS;
        }

    }
#endif

    if (Filter->MaxMulticastAddresses != 0)
    {
        if (!Set)
        {
            //
            // if this is a request to adjust the multicast list
            // due to an open closing (called from EthDeleteFilterOpenAdapter)
            // then clean up right here while we still have the filter's
            // WRITE lock and restore the "Old" filter values
            //
            if (Status == NDIS_STATUS_PENDING)
                Status = NDIS_STATUS_SUCCESS;
            
            //
            // Operation completed, do post processing.
            //
            ethCompleteChangeFilterAddresses(Filter, Status, Binding, TRUE);
            Filter->OldMCastAddressBuf = OldFilterMCastAddressBuf;
            Filter->OldNumAddresses = OldFilterNumAddresses;
        }
        else if (Status != NDIS_STATUS_PENDING)
        {    
            //
            // Operation completed, do post processing.
            //
            ethCompleteChangeFilterAddresses(Filter, Status, NULL, TRUE);
        }
    }
    
    WRITE_UNLOCK_FILTER(Miniport, Filter, &LockState);

    return(Status);
}


VOID
ethCompleteChangeFilterAddresses(
    IN  PETH_FILTER             Filter,
    IN  NDIS_STATUS             Status,
    IN  PETH_BINDING_INFO       LocalBinding OPTIONAL,
    IN  BOOLEAN                 WriteFilterHeld
    )
/*++

Routine Description:

    Do post processing for the multicast adddress filter change.

Arguments:

    Filter  -   Pointer to the ethernet filter database.
    Status  -   Status of completion
    LocalBinding    - 
        if not NULL, specifies the binding that attempted the
        Multicast address change, otherwise the binding should 
        be picked up from Filter->McaseSet
    WrtiteFilterHeld   
        if set, the filter WRITE lock is already held and we should not
        attempt to take it again.
        
Return Value:

    None.

    called at DPC with miniport's Spinlock held.

--*/
{
    PETH_BINDING_INFO   Binding;
    LOCK_STATE          LockState;

    if (!WriteFilterHeld)
    {
        WRITE_LOCK_FILTER(Filter->Miniport, Filter, &LockState);
    }
    
    if (LocalBinding)
    {
        Binding = LocalBinding;
    }
    else
    {
        Binding = Filter->MCastSet;
        Filter->MCastSet = NULL;
    }

    if (Status != NDIS_STATUS_SUCCESS)
    {
        //
        // Operation failed. Undo the stuff.
        //

        if (Binding != NULL)
        {
            if (Binding->MCastAddressBuf != NULL)
            {
                FREE_POOL(Binding->MCastAddressBuf);
            }
    
            Binding->MCastAddressBuf = Binding->OldMCastAddressBuf;
            Binding->NumAddresses = Binding->OldNumAddresses;
            Binding->OldMCastAddressBuf = NULL;
            Binding->OldNumAddresses = 0;
        }

        if (Filter->MCastAddressBuf != NULL)
        {
            FREE_POOL(Filter->MCastAddressBuf);
        }

        Filter->MCastAddressBuf = Filter->OldMCastAddressBuf;
        Filter->NumAddresses = Filter->OldNumAddresses;
        Filter->OldMCastAddressBuf = NULL;
        Filter->OldNumAddresses = 0;
    }
    else
    {
        //
        // Operation succeeded, clean-up saved old stuff.
        //
        if (Filter->OldMCastAddressBuf != NULL)
        {
            FREE_POOL(Filter->OldMCastAddressBuf);
            Filter->OldMCastAddressBuf = NULL;
            Filter->OldNumAddresses = 0;
        }
    
        if (Binding != NULL)
        {
            if (Binding->OldMCastAddressBuf != NULL)
            {
                FREE_POOL(Binding->OldMCastAddressBuf);
                Binding->OldMCastAddressBuf = NULL;
                Binding->OldNumAddresses = 0;
            }
        }
    }
    
    if (!WriteFilterHeld)
    {
        WRITE_UNLOCK_FILTER(Filter->Miniport, Filter, &LockState);
    }
}



UINT
EthNumberOfOpenFilterAddresses(
    IN  PETH_FILTER             Filter,
    IN  NDIS_HANDLE             NdisFilterHandle
    )
/*++

Routine Description:

    This routine counts the number of multicast addresses that a specific
    open has.

    NOTE: THIS ROUTINE ASSUMES THAT THE LOCK IS HELD.

Arguments:

    Filter - A pointer to the filter database.

    NdisFilterHandle - Pointer to open block.


Return Value:

    None.

--*/
{
    return(((PETH_BINDING_INFO)NdisFilterHandle)->NumAddresses);
}


VOID
EthQueryOpenFilterAddresses(
    OUT PNDIS_STATUS            Status,
    IN  PETH_FILTER             Filter,
    IN  NDIS_HANDLE             NdisFilterHandle,
    IN  UINT                    SizeOfArray,
    OUT PUINT                   NumberOfAddresses,
    OUT CHAR                    AddressArray[][ETH_LENGTH_OF_ADDRESS]
    )
/*++

Routine Description:

    The routine should be used by the MAC before
    it actually alters the hardware registers to effect a
    filtering hardware.  This is usefull if another binding
    has altered the address list since the action routine
    is called.

Arguments:

    Status - A pointer to the status of the call, NDIS_STATUS_SUCCESS or
    NDIS_STATUS_FAILURE.  Use EthNumberOfOpenAddresses() to get the
    size that is needed.

    Filter - A pointer to the filter database.

    NdisFilterHandle - Pointer to the open block

    SizeOfArray - The byte count of the AddressArray.

    NumberOfAddresses - The number of addresses written to the array.

    AddressArray - Will be filled with the addresses currently in the
    multicast address list.

Return Value:

    None.

--*/
{
    PETH_BINDING_INFO   BindInfo = (PETH_BINDING_INFO)NdisFilterHandle;
    LOCK_STATE          LockState;

    READ_LOCK_FILTER(Filter->Miniport, Filter, &LockState);

    if (SizeOfArray >= (ETH_LENGTH_OF_ADDRESS * BindInfo->NumAddresses))
    {
        MoveMemory(AddressArray[0],
                   BindInfo->MCastAddressBuf,
                   ETH_LENGTH_OF_ADDRESS * BindInfo->NumAddresses);

        *Status = NDIS_STATUS_SUCCESS;
        *NumberOfAddresses = BindInfo->NumAddresses;
    }
    else
    {
        *Status = NDIS_STATUS_FAILURE;
        *NumberOfAddresses = 0;
    }

    READ_UNLOCK_FILTER(Filter->Miniport, Filter, &LockState);
}


VOID
EthQueryGlobalFilterAddresses(
    OUT PNDIS_STATUS            Status,
    IN  PETH_FILTER             Filter,
    IN  UINT                    SizeOfArray,
    OUT PUINT                   NumberOfAddresses,
    IN  OUT CHAR                AddressArray[][ETH_LENGTH_OF_ADDRESS]
    )
/*++

Routine Description:

    The routine should be used by the MAC before
    it actually alters the hardware registers to effect a
    filtering hardware.  This is usefull if another binding
    has altered the address list since the action routine
    is called.

Arguments:

    Status - A pointer to the status of the call, NDIS_STATUS_SUCCESS or
    NDIS_STATUS_FAILURE.  Use ETH_NUMBER_OF_GLOBAL_ADDRESSES() to get the
    size that is needed.

    Filter - A pointer to the filter database.

    SizeOfArray - The byte count of the AddressArray.

    NumberOfAddresses - A pointer to the number of addresses written to the
    array.

    AddressArray - Will be filled with the addresses currently in the
    multicast address list.

Return Value:

    None.

--*/
{
    LOCK_STATE          LockState;

    READ_LOCK_FILTER(Filter->Miniport, Filter, &LockState);

    if (SizeOfArray < (Filter->NumAddresses * ETH_LENGTH_OF_ADDRESS))
    {
        *Status = NDIS_STATUS_FAILURE;
        *NumberOfAddresses = 0;
    }
    else
    {
        *Status = NDIS_STATUS_SUCCESS;
        *NumberOfAddresses = Filter->NumAddresses;

        MoveMemory(AddressArray,
                   Filter->MCastAddressBuf,
                   Filter->NumAddresses*ETH_LENGTH_OF_ADDRESS);
    }

    READ_UNLOCK_FILTER(Filter->Miniport, Filter, &LockState);
}


NDIS_STATUS
FASTCALL
ndisMSetMulticastList(
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  PNDIS_REQUEST           Request
    )
/*++

Routine Description:

Arguments:

Return Value:

Called at DPC with Miniport's lock held.

--*/
{
    UINT                    NumberOfAddresses;
    NDIS_STATUS             Status;
    PNDIS_REQUEST_RESERVED  ReqRsvd = PNDIS_RESERVED_FROM_PNDIS_REQUEST(Request);
    BOOLEAN                 fCleanup = FALSE;

    DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
            ("==>ndisMSetMulticastList\n"));

    do
    {
        //
        //  If the media type is not Ethernet or Ethernet encapsulated ARCnet
        //  then bail.
        //
#if ARCNET
        if ((Miniport->MediaType != NdisMedium802_3) &&
            !((Miniport->MediaType == NdisMediumArcnet878_2) &&
               MINIPORT_TEST_FLAG(ReqRsvd->Open,
                                  fMINIPORT_OPEN_USING_ETH_ENCAPSULATION)))
#else
        if (Miniport->MediaType != NdisMedium802_3)
#endif
        {
            Request->DATA.SET_INFORMATION.BytesRead = 0;
            Request->DATA.SET_INFORMATION.BytesNeeded = 0;
            Status = NDIS_STATUS_NOT_SUPPORTED;
    
            DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
                ("ndisMSetMulticastList: Invalid media\n"));
            break;
        }
    
        //
        //  Verify the information buffer length that was passed in.
        //
        if ((Request->DATA.SET_INFORMATION.InformationBufferLength % ETH_LENGTH_OF_ADDRESS) != 0)
        {
            //
            // The data must be a multiple of the Ethernet
            // address size.
            //
            Request->DATA.SET_INFORMATION.BytesRead = 0;
            Request->DATA.SET_INFORMATION.BytesNeeded = 0;
            Status = NDIS_STATUS_INVALID_LENGTH;
    
            DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
                ("ndisMSetMulticastList: Invalid length\n"));
    
            break;
        }
        
        if (Request->DATA.SET_INFORMATION.InformationBufferLength/ETH_LENGTH_OF_ADDRESS > Miniport->EthDB->MaxMulticastAddresses)
        {
            //
            // too many multicast addresses
            //
            Request->DATA.SET_INFORMATION.BytesRead = 0;
            Request->DATA.SET_INFORMATION.BytesNeeded = 0;
            Status = NDIS_STATUS_MULTICAST_FULL;
    
            DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
                ("ndisMSetMulticastList: too many addresses\n"));
    
            break;
        }
            
        
        //
        //  If this request is because of an open that is closing then we
        //  have already adjusted the settings and we just need to
        //  make sure that the adapter has the new settings.
        //
        if (MINIPORT_TEST_FLAG(ReqRsvd->Open, fMINIPORT_OPEN_CLOSING))
        {
            //
            //  By setting the Status to NDIS_STATUS_PENDING we will call
            //  down to the miniport's SetInformationHandler below.
            //
            Status = NDIS_STATUS_PENDING;
        }
        else
        {
            //
            //  Call the filter library for a normal set operation.
            //
            Status = EthChangeFilterAddresses(Miniport->EthDB,
                                              ReqRsvd->Open->FilterHandle,
                                              Request->DATA.SET_INFORMATION.InformationBufferLength/ETH_LENGTH_OF_ADDRESS,
                                              Request->DATA.SET_INFORMATION.InformationBuffer,
                                              TRUE);
            if (Status == NDIS_STATUS_PENDING)
            {
                fCleanup = TRUE;
            }
        }
    
        //
        //  If the filter library returned pending then we need to
        //  call the miniport driver.
        //
        if (NDIS_STATUS_PENDING == Status)
        {
            //
            //  Get a list of all the multicast address that need to be set.
            //
            ASSERT(Miniport->SetMCastBuffer == NULL);
    
            NumberOfAddresses = ethNumberOfGlobalAddresses(Miniport->EthDB);
            if (NumberOfAddresses != 0)
            {
                Miniport->SetMCastBuffer = ALLOC_FROM_POOL(NumberOfAddresses * ETH_LENGTH_OF_ADDRESS,
                                                           NDIS_TAG_FILTER_ADDR);
                if (Miniport->SetMCastBuffer == NULL)
                {
                    Status = NDIS_STATUS_RESOURCES;
                }
            }
    
            if (Status != NDIS_STATUS_RESOURCES)
            {
                EthQueryGlobalFilterAddresses(&Status,
                                              Miniport->EthDB,
                                              NumberOfAddresses * ETH_LENGTH_OF_ADDRESS,
                                              &NumberOfAddresses,
                                              Miniport->SetMCastBuffer);
            
                //
                //  Call the driver with the new multicast list.
                //
                SAVE_REQUEST_BUF(Miniport,
                                 Request,
                                 Miniport->SetMCastBuffer, NumberOfAddresses * ETH_LENGTH_OF_ADDRESS);
                MINIPORT_SET_INFO(Miniport,
                                  Request,
                                  &Status);
            }
        }
    
        //
        //  If we succeeded then update the request.
        //
        if (Status != NDIS_STATUS_PENDING)
        {
            RESTORE_REQUEST_BUF(Miniport, Request);
            if (NDIS_STATUS_SUCCESS == Status)
            {
                Request->DATA.SET_INFORMATION.BytesRead = Request->DATA.SET_INFORMATION.InformationBufferLength;
            }
            else
            {
                Request->DATA.SET_INFORMATION.BytesRead = 0;
                Request->DATA.SET_INFORMATION.BytesNeeded = 0;
            }
        }
    
        if (Status != NDIS_STATUS_PENDING)
        {
            if (Miniport->SetMCastBuffer != NULL)
            {
                FREE_POOL(Miniport->SetMCastBuffer);
                Miniport->SetMCastBuffer = NULL;
            }
            if (fCleanup)
            {
                ethCompleteChangeFilterAddresses(Miniport->EthDB, Status, NULL, FALSE);
            }
        }
    } while (FALSE);

    DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
            ("<==ndisMSetMulticastList: 0x%x\n", Status));

    return(Status);
}


VOID
EthFilterDprIndicateReceive(
    IN  PETH_FILTER             Filter,
    IN  NDIS_HANDLE             MacReceiveContext,
    IN  PCHAR                   Address,
    IN  PVOID                   HeaderBuffer,
    IN  UINT                    HeaderBufferSize,
    IN  PVOID                   LookaheadBuffer,
    IN  UINT                    LookaheadBufferSize,
    IN  UINT                    PacketSize
    )
/*++

Routine Description:

    This routine is called by the MAC to indicate a packet to
    all bindings.  The packet will be filtered so that only the
    appropriate bindings will receive the packet.  This is the
    code path for ndis 3.0 miniport drivers.

Arguments:

    Filter - Pointer to the filter database.

    MacReceiveContext - A MAC supplied context value that must be
    returned by the protocol if it calls MacTransferData.

    Address - The destination address from the received packet.

    HeaderBuffer - A virtual address of the virtually contiguous
    buffer containing the MAC header of the packet.

    HeaderBufferSize - An unsigned integer indicating the size of
    the header buffer, in bytes.

    LookaheadBuffer - A virtual address of the virtually contiguous
    buffer containing the first LookaheadBufferSize bytes of data
    of the packet.  The packet buffer is valid only within the current
    call to the receive event handler.

    LookaheadBufferSize - An unsigned integer indicating the size of
    the lookahead buffer, in bytes.

    PacketSize - An unsigned integer indicating the size of the received
    packet, in bytes.  This number has nothing to do with the lookahead
    buffer, but indicates how large the arrived packet is so that a
    subsequent MacTransferData request can be made to transfer the entire
    packet as necessary.

Return Value:

    None.

--*/
{
    //
    // Will hold the type of address that we know we've got.
    //
    UINT            AddressType;

    //
    // Will hold the status of indicating the receive packet.
    // ZZZ For now this isn't used.
    //
    NDIS_STATUS     StatusOfReceive;

    LOCK_STATE      LockState;

    //
    // Current Open to indicate to.
    //
    PETH_BINDING_INFO LocalOpen;
    PETH_BINDING_INFO NextOpen;

    //
    // if filter is null, the adapter is indicating too early
    //  
    if (Filter == NULL)
    {
    #if DBG
        DbgPrint("Driver is indicating packets too early\n");
        if (ndisFlags & NDIS_GFLAG_BREAK_ON_WARNING)
        {
            DbgBreakPoint();
        }
    #endif
    
        return;     
    }

    if (!MINIPORT_TEST_FLAG(Filter->Miniport, fMINIPORT_MEDIA_CONNECTED))
    {
        NDIS_WARN(TRUE,
                  Filter->Miniport, 
                  NDIS_GFLAG_WARN_LEVEL_1,
                  ("EthFilterDprIndicateReceive: Miniport %p IndicateReceives wih media disconneted\n",
                  Filter->Miniport));

        return;     
    }

    ASSERT_MINIPORT_LOCKED(Filter->Miniport);

    READ_LOCK_FILTER(Filter->Miniport, Filter, &LockState);

    //
    // Optimize single open case
    //
    if (Filter->SingleActiveOpen)
    {
        if (((HeaderBufferSize >= 14) && (PacketSize != 0)) ||
            (Filter->CombinedPacketFilter & (NDIS_PACKET_TYPE_PROMISCUOUS| NDIS_PACKET_TYPE_ALL_LOCAL)))
        {
            if (!ETH_IS_MULTICAST(Address))
            {
                DIRECTED_PACKETS_IN(Filter->Miniport);
                DIRECTED_BYTES_IN(Filter->Miniport, PacketSize);
            }

            LocalOpen = Filter->SingleActiveOpen;

            ASSERT(LocalOpen != NULL);
            if (LocalOpen == NULL)
            {
                READ_UNLOCK_FILTER(Filter->Miniport, Filter, &LockState);
                return;
            }

            LocalOpen->ReceivedAPacket = TRUE;

            //
            // Indicate the packet to the binding.
            //
            ProtocolFilterIndicateReceive(&StatusOfReceive,
                                          LocalOpen->NdisBindingHandle,
                                          MacReceiveContext,
                                          HeaderBuffer,
                                          HeaderBufferSize,
                                          LookaheadBuffer,
                                          LookaheadBufferSize,
                                          PacketSize,
                                          NdisMedium802_3);
        }

        READ_UNLOCK_FILTER(Filter->Miniport, Filter, &LockState);
        return;
    }

    //
    // If the packet is a runt packet, then only indicate to PROMISCUOUS, ALL_LOCAL
    //
    if ((HeaderBufferSize >= 14) && (PacketSize != 0))
    {
        //
        //  Handle the directed packet case first
        //
        if (!ETH_IS_MULTICAST(Address))
        {
            UINT    IsNotOurs;

            DIRECTED_PACKETS_IN(Filter->Miniport);
            DIRECTED_BYTES_IN(Filter->Miniport, PacketSize);

            //
            // If it is a directed packet, then check if the combined packet
            // filter is PROMISCUOUS, if it is check if it is directed towards
            // us
            //
            IsNotOurs = FALSE;  // Assume it is
            if (Filter->CombinedPacketFilter & (NDIS_PACKET_TYPE_PROMISCUOUS    |
                                                NDIS_PACKET_TYPE_ALL_MULTICAST  |
                                                NDIS_PACKET_TYPE_ALL_LOCAL))
            {
                ETH_COMPARE_NETWORK_ADDRESSES_EQ(Filter->AdapterAddress,
                                                 Address,
                                                 &IsNotOurs);
            }

            //
            //  We definitely have a directed packet so lets indicate it now.
            //
            //  Walk the directed list and indicate up the packets.
            //
            for (LocalOpen = Filter->OpenList;
                 LocalOpen != NULL;
                 LocalOpen = NextOpen)
            {
                //
                //  Get the next open to look at.
                //
                NextOpen = LocalOpen->NextOpen;

                //
                // Ignore if not directed to us and if the binding is not promiscuous
                //
                if (((LocalOpen->PacketFilters & (NDIS_PACKET_TYPE_PROMISCUOUS | NDIS_PACKET_TYPE_ALL_LOCAL)) == 0) &&
                    (IsNotOurs ||
                    ((LocalOpen->PacketFilters & NDIS_PACKET_TYPE_DIRECTED) == 0)))
                {
                        continue;
                }


                //
                // Indicate the packet to the binding.
                //
                ProtocolFilterIndicateReceive(&StatusOfReceive,
                                              LocalOpen->NdisBindingHandle,
                                              MacReceiveContext,
                                              HeaderBuffer,
                                              HeaderBufferSize,
                                              LookaheadBuffer,
                                              LookaheadBufferSize,
                                              PacketSize,
                                              NdisMedium802_3);

                LocalOpen->ReceivedAPacket = TRUE;
            }

            //
            // Done for uni-cast
            //
            READ_UNLOCK_FILTER(Filter->Miniport, Filter, &LockState);
            return;
        }

        //
        // It is at least a multicast address.  Check to see if
        // it is a broadcast address.
        //
        if (ETH_IS_BROADCAST(Address))
        {
            ETH_CHECK_FOR_INVALID_BROADCAST_INDICATION(Filter);

            AddressType = NDIS_PACKET_TYPE_BROADCAST;
        }
        else
        {
            AddressType = NDIS_PACKET_TYPE_MULTICAST;
        }
    }
    else
    {
        // Runt packet
        AddressType = NDIS_PACKET_TYPE_PROMISCUOUS;
    }

    //
    // At this point we know that the packet is either:
    // - Runt packet - indicated by AddressType = NDIS_PACKET_TYPE_PROMISCUOUS    (OR)
    // - Broadcast packet - indicated by AddressType = NDIS_PACKET_TYPE_BROADCAST (OR)
    // - Multicast packet - indicated by AddressType = NDIS_PACKET_TYPE_MULTICAST
    //
    // Walk the broadcast/multicast list and indicate up the packets.
    //
    // The packet is indicated if it meets the following criteria:
    //
    // if ((Binding is promiscuous) OR
    //   ((Packet is broadcast) AND (Binding is Broadcast)) OR
    //   ((Packet is multicast) AND
    //    ((Binding is all-multicast) OR
    //     ((Binding is multicast) AND (address in multicast list)))))
    //
    for (LocalOpen = Filter->OpenList;
         LocalOpen != NULL;
         LocalOpen = NextOpen)
    {
        UINT    LocalFilter = LocalOpen->PacketFilters;

        //
        //  Get the next open to look at.
        //
        NextOpen = LocalOpen->NextOpen;

        if ((LocalFilter & (NDIS_PACKET_TYPE_PROMISCUOUS | NDIS_PACKET_TYPE_ALL_LOCAL))     ||

            ((AddressType == NDIS_PACKET_TYPE_BROADCAST)  &&
             (LocalFilter & NDIS_PACKET_TYPE_BROADCAST))        ||

            ((AddressType == NDIS_PACKET_TYPE_MULTICAST)  &&
             ((LocalFilter & NDIS_PACKET_TYPE_ALL_MULTICAST) ||
              ((LocalFilter & NDIS_PACKET_TYPE_MULTICAST) &&
               ethFindMulticast(LocalOpen->NumAddresses,
                                LocalOpen->MCastAddressBuf,
                                Address)
              )
             )
            )
           )
        {
            //
            // Indicate the packet to the binding.
            //
            ProtocolFilterIndicateReceive(&StatusOfReceive,
                                          LocalOpen->NdisBindingHandle,
                                          MacReceiveContext,
                                          HeaderBuffer,
                                          HeaderBufferSize,
                                          LookaheadBuffer,
                                          LookaheadBufferSize,
                                          PacketSize,
                                          NdisMedium802_3);

            LocalOpen->ReceivedAPacket = TRUE;
        }
    }

    READ_UNLOCK_FILTER(Filter->Miniport, Filter, &LockState);
}



VOID
ethFilterDprIndicateReceivePacket(
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  PPNDIS_PACKET           PacketArray,
    IN  UINT                    NumberOfPackets
    )
/*++

Routine Description:

    This routine is called by the Miniport to indicate packets to
    all bindings.  The packets will be filtered so that only the
    appropriate bindings will receive the individual packets.
    This is the code path for ndis 4.0 miniport drivers.

Arguments:

    Miniport - The Miniport block.

    PacketArray - An array of Packets indicated by the miniport.

    NumberOfPackets - Self-explanatory.

Return Value:

    None.

--*/
{
    //
    // The Filter of interest
    //
    PETH_FILTER         Filter = Miniport->EthDB;

    //
    // Current packet being processed
    //
    PPNDIS_PACKET       pPktArray = PacketArray;
    PNDIS_PACKET        Packet;
    PNDIS_PACKET_OOB_DATA pOob;

    //
    // Pointer to the buffer in the ndispacket
    //
    PNDIS_BUFFER        Buffer;

    //
    // Pointer to the 1st segment of the buffer, points to dest address
    //
    PUCHAR              Address;

    //
    // Total packet length
    //
    UINT                i, LASize, PacketSize, NumIndicates = 0;

    //
    // Will hold the type of address that we know we've got.
    //
    UINT                AddressType;

    //
    // Will hold the status of indicating the receive packet.
    // ZZZ For now this isn't used.
    //
    NDIS_STATUS         StatusOfReceive;

    LOCK_STATE          LockState;

    //
    //  Decides whether we use the protocol's revpkt handler or fall
    //  back to old rcvindicate handler
    //
    BOOLEAN             fFallBack, fPmode;

    //
    // Current Open to indicate to.
    //
    PETH_BINDING_INFO   LocalOpen, NextOpen;
    PNDIS_OPEN_BLOCK    pOpenBlock;

    ULONG               OrgPacketStackLocation;
    
    PNDIS_STACK_RESERVED NSR;

    #ifdef TRACK_RECEIVED_PACKETS
    PETHREAD            CurThread = PsGetCurrentThread();
    // ULONG                   CurThread = KeGetCurrentProcessorNumber();
    #endif

    //
    // if filter is null, the adapter is indicating too early
    //

    ASSERT(Filter != NULL);

    ASSERT_MINIPORT_LOCKED(Miniport);

    READ_LOCK_FILTER(Miniport, Filter, &LockState);
    
    //
    // Walk all the packets
    //
    for (i = 0; i < NumberOfPackets; i++, pPktArray++)
    {
        do
        {
            Packet = *pPktArray;
            ASSERT(Packet != NULL);

            OrgPacketStackLocation = CURR_STACK_LOCATION(Packet);
            
            if ((OrgPacketStackLocation != -1) && 
                !MINIPORT_TEST_FLAG(Miniport, fMINIPORT_INTERMEDIATE_DRIVER))
            {
                BAD_MINIPORT(Miniport, "Indicating packet not owned by it");
                KeBugCheckEx(BUGCODE_ID_DRIVER,
                             (ULONG_PTR)Miniport,
                             (ULONG_PTR)Packet,
                             (ULONG_PTR)PacketArray,
                             NumberOfPackets);
            }

#ifdef TRACK_RECEIVED_PACKETS
            if (OrgPacketStackLocation == -1)
            {
                NDIS_APPEND_RCV_LOGFILE(Packet, Miniport, CurThread,
                                        1, -1, 0, 0, 
                                        NDIS_GET_PACKET_STATUS(Packet));
            }
            else
            {
                NDIS_STACK_RESERVED_FROM_PACKET(Packet, &NSR)
                NDIS_APPEND_RCV_LOGFILE(Packet, Miniport, CurThread, 
                                        2, OrgPacketStackLocation, NSR->RefCount, NSR->XRefCount,
                                        NDIS_GET_PACKET_STATUS(Packet));
            }
#endif            
            
            PUSH_PACKET_STACK(Packet);
            NDIS_STACK_RESERVED_FROM_PACKET(Packet, &NSR)

            ASSERT(NSR->RefCount == 0);
            
#ifdef NDIS_TRACK_RETURNED_PACKETS            
            if (NSR->RefCount != 0)
            {
                BAD_MINIPORT(Miniport, "Indicating packet not owned by it");
                KeBugCheckEx(BUGCODE_ID_DRIVER,
                             (ULONG_PTR)Miniport,
                             (ULONG_PTR)Packet,
                             (ULONG_PTR)PacketArray,
                             NumberOfPackets);
            }
#endif
            pOob = NDIS_OOB_DATA_FROM_PACKET(Packet);
    
            NdisGetFirstBufferFromPacket(Packet,
                                         &Buffer,
                                         &Address,
                                         &LASize,
                                         &PacketSize);
            ASSERT(Buffer != NULL);
    
            ASSERT(pOob->HeaderSize == 14);
            // ASSERT(PacketSize <= 1514);
    
            //
            // Set context in the packet so that NdisReturnPacket can do the right thing
            //
            NDIS_INITIALIZE_RCVD_PACKET(Packet, NSR, Miniport);
    
            //
            // Set the status here that nobody is holding the packet. This will get
            // overwritten by the real status from the protocol. Pay heed to what
            // the miniport is saying.
            //
            if ((pOob->Status != NDIS_STATUS_RESOURCES) &&
                !MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_SYSTEM_SLEEPING))
            {
                //
                // set the packet status to success, but only if the packet is
                // coming from the lowest level driver. we don't want to override
                // the status of a packet that we have already set to pending
                // for lowest level serialized driver
                //
                if (!MINIPORT_TEST_FLAG(Miniport, fMINIPORT_INTERMEDIATE_DRIVER))
                {
                    pOob->Status = NDIS_STATUS_SUCCESS;
                }
                fFallBack = FALSE;
            }
            else
            {
#if DBG
                if ((pOob->Status != NDIS_STATUS_RESOURCES) &&
                    MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_SYSTEM_SLEEPING))
                {
                    DBGPRINT(DBG_COMP_FILTER, DBG_LEVEL_ERR,
                            ("Miniport going into D3, not indicating chained receives\n"));
                }
#endif
                fFallBack = TRUE;
            }

#ifdef TRACK_RECEIVED_PACKETS
            (NDIS_STATUS)NDIS_ORIGINAL_STATUS_FROM_PACKET(Packet) = pOob->Status;
#endif

#if DBG
            //
            // check to see if this is a loopback packet coming from miniport and complain
            // if miniport said it does not do loopback
            //
            
            if (MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_VERIFYING) &&
                ((ndisFlags & NDIS_GFLAG_WARNING_LEVEL_MASK) >= NDIS_GFLAG_WARN_LEVEL_1) &&
                (Miniport->MacOptions & NDIS_MAC_OPTION_NO_LOOPBACK) &&
                !(MINIPORT_TEST_PACKET_FLAG(Packet, fPACKET_IS_LOOPBACK)))
            {   
                UINT fIsFromUs;
                
                ETH_COMPARE_NETWORK_ADDRESSES_EQ(Filter->AdapterAddress,
                                                 (Address + 6),
                                                 &fIsFromUs);
                if (!fIsFromUs)
                {
                    //
                    // miniport has indicated loopback packets while at the same time
                    // it asked ndis to loopback packets
                    //
                    DbgPrint("Miniport %p looping back packet %p and has NDIS_MAC_OPTION_NO_LOOPBACK flag set.\n",
                            Miniport, Packet);
                            
                    if (ndisFlags & NDIS_GFLAG_BREAK_ON_WARNING)
                        DbgBreakPoint();
                }
            }

#endif
    
            //
            // Optimize single open case. Just indicate w/o any validation.
            //
            if (Filter->SingleActiveOpen)
            {
                if ((PacketSize >= 14) ||
                    (Filter->CombinedPacketFilter & (NDIS_PACKET_TYPE_PROMISCUOUS| NDIS_PACKET_TYPE_ALL_LOCAL)))
                {
                    LocalOpen = Filter->SingleActiveOpen;
                    
                    ASSERT(LocalOpen != NULL);
                    if (LocalOpen == NULL)
                    {
                        break;
                    }
                        
                    LocalOpen->ReceivedAPacket = TRUE;
                    NumIndicates ++;
        
                    pOpenBlock = (PNDIS_OPEN_BLOCK)(LocalOpen->NdisBindingHandle);
                    fPmode = (LocalOpen->PacketFilters & (NDIS_PACKET_TYPE_PROMISCUOUS | NDIS_PACKET_TYPE_ALL_LOCAL)) ?
                                                        TRUE : FALSE;
                    if (!ETH_IS_MULTICAST(Address))
                    {
                        DIRECTED_PACKETS_IN(Filter->Miniport);
                        DIRECTED_BYTES_IN(Filter->Miniport, PacketSize);
                    }

                    IndicateToProtocol(Miniport,
                                       Filter,
                                       pOpenBlock,
                                       Packet,
                                       NSR,
                                       Address,
                                       PacketSize,
                                       14,
                                       &fFallBack,
                                       fPmode,
                                       NdisMedium802_3);
                }

                // Done with this packet
                break;  // out of do { } while (FALSE);
            }
    
            //
            // A quick check for Runt packets. These are only indicated to Promiscuous bindings
            //
            if (PacketSize >= 14)
            {
                //
                //  Handle the directed packet case first
                //
                if (!ETH_IS_MULTICAST(Address))
                {
                    UINT    IsNotOurs;
    
                    if (!MINIPORT_TEST_PACKET_FLAG(Packet, fPACKET_IS_LOOPBACK))
                    {
                        DIRECTED_PACKETS_IN(Filter->Miniport);
                        DIRECTED_BYTES_IN(Filter->Miniport, PacketSize);
                    }

                    //
                    // If it is a directed packet, then check if the combined packet
                    // filter is PROMISCUOUS, if it is check if it is directed towards us
                    //
                    IsNotOurs = FALSE;  // Assume it is
                    if (Filter->CombinedPacketFilter & (NDIS_PACKET_TYPE_PROMISCUOUS |
                                                        NDIS_PACKET_TYPE_ALL_LOCAL   |
                                                        NDIS_PACKET_TYPE_ALL_MULTICAST))
                    {
                        ETH_COMPARE_NETWORK_ADDRESSES_EQ(Filter->AdapterAddress,
                                                         Address,
                                                         &IsNotOurs);
                    }
    
                    //
                    //  We definitely have a directed packet so lets indicate it now.
                    //
                    //  Walk the directed list and indicate up the packets.
                    //
                    for (LocalOpen = Filter->OpenList;
                         LocalOpen != NULL;
                         LocalOpen = NextOpen)
                    {
                        //
                        //  Get the next open to look at.
                        //
                        NextOpen = LocalOpen->NextOpen;
    
                        //
                        // Ignore if not directed to us and if the binding is not promiscuous
                        // Or if this is a loopback packet and this protocol specifically asked
                        // us not to loop it back
                        //
                        fPmode = (LocalOpen->PacketFilters & (NDIS_PACKET_TYPE_PROMISCUOUS | NDIS_PACKET_TYPE_ALL_LOCAL)) ?
                                                            TRUE : FALSE;

                        
                        if (!fPmode &&
                            (IsNotOurs || 
                            ((LocalOpen->PacketFilters & NDIS_PACKET_TYPE_DIRECTED) == 0)))
                        {
                                
                            continue;
                        }
    
                        if ((NdisGetPacketFlags(Packet) & NDIS_FLAGS_DONT_LOOPBACK) &&
                            (LOOPBACK_OPEN_IN_PACKET(Packet) == LocalOpen->NdisBindingHandle))
                        {
                            continue;
                        }
    

                        pOpenBlock = (PNDIS_OPEN_BLOCK)(LocalOpen->NdisBindingHandle);
                        LocalOpen->ReceivedAPacket = TRUE;
                        NumIndicates ++;


    
                        IndicateToProtocol(Miniport,
                                           Filter,
                                           pOpenBlock,
                                           Packet,
                                           NSR,
                                           Address,
                                           PacketSize,
                                           14,
                                           &fFallBack,
                                           fPmode,
                                           NdisMedium802_3);

                    }
    
                    // Done with this packet
                    break;  // out of do { } while (FALSE);
                }
    
                //
                // It is at least a multicast address.  Check to see if
                // it is a broadcast address.
                //
                if (ETH_IS_BROADCAST(Address))
                {
                    ETH_CHECK_FOR_INVALID_BROADCAST_INDICATION(Filter);
    
                    AddressType = NDIS_PACKET_TYPE_BROADCAST;
                }
                else
                {
                    AddressType = NDIS_PACKET_TYPE_MULTICAST;
                }
            }
            else
            {
                // Runt packet
                AddressType = NDIS_PACKET_TYPE_PROMISCUOUS;
            }
    
            //
            // At this point we know that the packet is either:
            // - Runt packet - indicated by AddressType = NDIS_PACKET_TYPE_PROMISCUOUS    (OR)
            // - Broadcast packet - indicated by AddressType = NDIS_PACKET_TYPE_BROADCAST (OR)
            // - Multicast packet - indicated by AddressType = NDIS_PACKET_TYPE_MULTICAST
            //
            // Walk the broadcast/multicast list and indicate up the packets.
            //
            // The packet is indicated if it meets the following criteria:
            //
            // if ((Binding is promiscuous) OR
            //   ((Packet is broadcast) AND (Binding is Broadcast)) OR
            //   ((Packet is multicast) AND
            //    ((Binding is all-multicast) OR
            //     ((Binding is multicast) AND (address in multicast list)))))
            //
            for (LocalOpen = Filter->OpenList;
                 LocalOpen != NULL;
                 LocalOpen = NextOpen)
            {
                UINT    LocalFilter;
    
                //
                //  Get the next open to look at.
                //
                NextOpen = LocalOpen->NextOpen;
    
                //
                // Ignore if this is a loopback packet and this protocol specifically asked
                // us not to loop it back
                //
                if ((NdisGetPacketFlags(Packet) & NDIS_FLAGS_DONT_LOOPBACK) &&
                    (LOOPBACK_OPEN_IN_PACKET(Packet) == LocalOpen->NdisBindingHandle))
                {
                    continue;
                }
    
                LocalFilter = LocalOpen->PacketFilters;
                if ((LocalFilter & (NDIS_PACKET_TYPE_PROMISCUOUS | NDIS_PACKET_TYPE_ALL_LOCAL))     ||
    
                    ((AddressType == NDIS_PACKET_TYPE_BROADCAST)  &&
                     (LocalFilter & NDIS_PACKET_TYPE_BROADCAST))        ||
    
                    ((AddressType == NDIS_PACKET_TYPE_MULTICAST)  &&
                     ((LocalFilter & NDIS_PACKET_TYPE_ALL_MULTICAST) ||
                      ((LocalFilter & NDIS_PACKET_TYPE_MULTICAST) &&
                       ethFindMulticast(LocalOpen->NumAddresses,
                                        LocalOpen->MCastAddressBuf,
                                        Address)
                      )
                     )
                    )
                   )
                {
                    pOpenBlock = (PNDIS_OPEN_BLOCK)(LocalOpen->NdisBindingHandle);
                    LocalOpen->ReceivedAPacket = TRUE;
                    NumIndicates ++;
    
                    fPmode = (LocalFilter & (NDIS_PACKET_TYPE_PROMISCUOUS | NDIS_PACKET_TYPE_ALL_LOCAL)) ?
                                TRUE : FALSE;
                    
                    IndicateToProtocol(Miniport,
                                       Filter,
                                       pOpenBlock,
                                       Packet,
                                       NSR,
                                       Address,
                                       PacketSize,
                                       14,
                                       &fFallBack,
                                       fPmode,
                                       NdisMedium802_3);
                }
            }
        } while (FALSE);

        //
        // Tackle refcounts now
        //
        TACKLE_REF_COUNT(Miniport, Packet, NSR, pOob);
    }

    if (NumIndicates > 0)
    {
        for (LocalOpen = Filter->OpenList;
             LocalOpen != NULL;
             LocalOpen = NextOpen)
        {
            NextOpen = LocalOpen->NextOpen;
    
            if (LocalOpen->ReceivedAPacket)
            {
                //
                // Indicate the binding.
                //
                LocalOpen->ReceivedAPacket = FALSE;
    
                FilterIndicateReceiveComplete(LocalOpen->NdisBindingHandle);
            }
        }
    }

    READ_UNLOCK_FILTER(Miniport, Filter, &LockState);
}


VOID
EthFilterDprIndicateReceiveComplete(
    IN  PETH_FILTER             Filter
    )
/*++

Routine Description:

    This routine is called by the MAC to indicate that the receive
    process is complete to all bindings.  Only those bindings which
    have received packets will be notified.

Arguments:

    Filter - Pointer to the filter database.

Return Value:

    None.

--*/
{
    PETH_BINDING_INFO LocalOpen, NextOpen;
    LOCK_STATE        LockState;

    ASSERT(Filter != NULL);
    if (Filter == NULL)
    {
        return;
    }
    
    ASSERT_MINIPORT_LOCKED(Filter->Miniport);

    READ_LOCK_FILTER(Filter->Miniport, Filter, &LockState);

    //
    // We need to aquire the filter exclusively while we're finding
    // bindings to indicate to.
    //
    for (LocalOpen = Filter->OpenList;
         LocalOpen != NULL;
         LocalOpen = NextOpen)
    {
        NextOpen = LocalOpen->NextOpen;

        if (LocalOpen->ReceivedAPacket)
        {
            //
            // Indicate the binding.
            //
            LocalOpen->ReceivedAPacket = FALSE;

            FilterIndicateReceiveComplete(LocalOpen->NdisBindingHandle);
        }
    }

    READ_UNLOCK_FILTER(Filter->Miniport, Filter, &LockState);
}


BOOLEAN
FASTCALL
ethFindMulticast(
    IN  UINT                    NumberOfAddresses,
    IN  CHAR                    AddressArray[][FDDI_LENGTH_OF_LONG_ADDRESS],
    IN  CHAR                    MulticastAddress[FDDI_LENGTH_OF_LONG_ADDRESS]
    )
/*++

Routine Description:

    Check whether the given multicast address is part of the list within a binding
    It is assumed that the address array is already sorted.

    NOTE: This ordering is arbitrary but consistant.

Arguments:

    LocalOpen - The binding in question
    MulticastAddress - The address to search for in the address array.


Return Value:

    If the address is in the sorted list this routine will return
    TRUE, otherwise FALSE.

--*/
{
    //
    // Indices into the address array so that we may do a binary
    // search.
    //
    UINT    Bottom = 0;
    UINT    Middle = NumberOfAddresses / 2;
    UINT    Top;

    if (NumberOfAddresses)
    {
        Top = NumberOfAddresses - 1;

        while ((Middle <= Top) && (Middle >= Bottom))
        {
            //
            // The result of comparing an element of the address
            // array and the multicast address.
            //
            // Result < 0 Implies the multicast address is greater.
            // Result > 0 Implies the address array element is greater.
            // Result = 0 Implies that the array element and the address
            //  are equal.
            //
            INT Result;

            ETH_COMPARE_NETWORK_ADDRESSES(AddressArray[Middle],
                                          MulticastAddress,
                                          &Result);

            if (Result == 0)
            {
                return(TRUE);
            }
            else if (Result > 0)
            {
                if (Middle == 0)
                    break;
                Top = Middle - 1;
            }
            else
            {
                Bottom = Middle+1;
            }

            Middle = Bottom + (((Top+1) - Bottom)/2);
        }
    }

    return(FALSE);
}


BOOLEAN
EthShouldAddressLoopBack(
    IN  PETH_FILTER             Filter,
    IN  CHAR                    Address[ETH_LENGTH_OF_ADDRESS]
    )
/*++

Routine Description:

    Do a quick check to see whether the input address should
    loopback.

    NOTE: THIS ROUTINE ASSUMES THAT THE LOCK IS HELD.

    NOTE: THIS ROUTINE DOES NOT CHECK THE SPECIAL CASE OF SOURCE
    EQUALS DESTINATION.

Arguments:

    Filter - Pointer to the filter database.

    Address - A network address to check for loopback.


Return Value:

    Returns TRUE if the address is *likely* to need loopback.  It
    will return FALSE if there is *no* chance that the address would
    require loopback.

--*/
{
    BOOLEAN fLoopback, fSelfDirected;

    EthShouldAddressLoopBackMacro(Filter, Address, &fLoopback, &fSelfDirected);

    return(fLoopback);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ndis\sys\dma.c ===
/*++
Copyright (c) 1992  Microsoft Corporation

Module Name:

    dma.c

Abstract:

    

Author:

    Jameel Hyder (jameelh) 02-Apr-1998

Environment:

    Kernel mode, FSD

Revision History:

    02-Apr-1998  JameelH Initial version

--*/

#include <precomp.h>
#pragma hdrstop

//
//  Define the module number for debug code.
//
#define MODULE_NUMBER   MODULE_DMA

NDIS_STATUS
NdisMInitializeScatterGatherDma(
    IN  NDIS_HANDLE             MiniportAdapterHandle,
    IN  BOOLEAN                 Dma64BitAddresses,
    IN  ULONG                   MaximumPhysicalMapping
    )
/*++

Routine Description:

    Allocates adapter channel for bus mastering devices.

Arguments:


Return Value:

    None.

--*/
{
    PNDIS_MINIPORT_BLOCK    Miniport = (PNDIS_MINIPORT_BLOCK)MiniportAdapterHandle;
    DEVICE_DESCRIPTION      DeviceDescription;
    ULONG                   MapRegisters, SGMapRegsisters;
    NDIS_STATUS             Status = NDIS_STATUS_NOT_SUPPORTED;
    NTSTATUS                NtStatus;
    ULONG                   ScatterGatherListSize;
    BOOLEAN                 DereferenceDmaAdapter = FALSE;
    BOOLEAN                 FreeSGListLookasideList = FALSE;

    DBGPRINT_RAW(DBG_COMP_CONFIG, DBG_LEVEL_INFO,
            ("==>NdisMInitializeScatterGatherDma: Miniport %lx, Dma64BitAddresses %lx, MaximumPhysicalMapping 0x%lx\n",
                                                Miniport, Dma64BitAddresses, MaximumPhysicalMapping));

    do
    {
        if (!MINIPORT_TEST_FLAGS(Miniport, fMINIPORT_IS_NDIS_5 | fMINIPORT_BUS_MASTER))
        {
            Status = NDIS_STATUS_NOT_SUPPORTED;
            break;
        }
        
        if (MINIPORT_VERIFY_TEST_FLAG(Miniport, fMINIPORT_VERIFY_FAIL_INIT_SG))
        {
            Status = NDIS_STATUS_RESOURCES;
            break;
        }

        NdisZeroMemory(&DeviceDescription, sizeof(DEVICE_DESCRIPTION));
            
        DeviceDescription.Master = TRUE;
        DeviceDescription.ScatterGather = TRUE;

        DeviceDescription.BusNumber = Miniport->BusNumber;
        DeviceDescription.DmaChannel = 0;
        DeviceDescription.InterfaceType = Miniport->AdapterType;

        if (Dma64BitAddresses)
        {
            DeviceDescription.Dma32BitAddresses = FALSE;
            DeviceDescription.Dma64BitAddresses = TRUE;
            MINIPORT_SET_FLAG(Miniport, fMINIPORT_64BITS_DMA);
        }
        else
        {
            DeviceDescription.Dma32BitAddresses = TRUE;
            DeviceDescription.Dma64BitAddresses = FALSE;
        }
        
        if (((MaximumPhysicalMapping * 2 - 2) / PAGE_SIZE) + 2 < Miniport->SGMapRegistersNeeded)
        {
            DeviceDescription.MaximumLength = (Miniport->SGMapRegistersNeeded - 1) << PAGE_SHIFT;
        }
        else
        {
            DeviceDescription.MaximumLength = MaximumPhysicalMapping*2;
        }

        DeviceDescription.Version = DEVICE_DESCRIPTION_VERSION2;

        //
        // Get the adapter object.
        //
        Miniport->SystemAdapterObject = IoGetDmaAdapter(Miniport->PhysicalDeviceObject,
                                        &DeviceDescription,
                                        &MapRegisters);
                                        

        if (Miniport->SystemAdapterObject == NULL)
        {
            NdisWriteErrorLogEntry((NDIS_HANDLE)Miniport,
                                   NDIS_ERROR_CODE_OUT_OF_RESOURCES,
                                   1,
                                   0xFFFFFFFF);
                                   
            DBGPRINT_RAW(DBG_COMP_CONFIG, DBG_LEVEL_ERR, 
                ("NdisMInitializeScatterGatherDma: Miniport %lx, IoGetDmaAdapter failed\n", Miniport));
                
            Status = NDIS_STATUS_RESOURCES;
            break;
        }
        
        DBGPRINT_RAW(DBG_COMP_CONFIG, DBG_LEVEL_INFO,
                ("NdisMInitializeScatterGatherDma: Miniport %lx, MapRegisters 0x%lx\n", Miniport, MapRegisters));
        
        InterlockedIncrement(&Miniport->DmaAdapterRefCount);

        DereferenceDmaAdapter = TRUE;
        
        if (!MINIPORT_TEST_FLAG(Miniport, fMINIPORT_DESERIALIZE))
        {
            Miniport->SendCompleteHandler =  ndisMSendCompleteSG;
        }

        Miniport->SGListLookasideList = (PNPAGED_LOOKASIDE_LIST)ALLOC_FROM_POOL(sizeof(NPAGED_LOOKASIDE_LIST), NDIS_TAG_DMA);
        
        if (Miniport->SGListLookasideList == NULL)
        {
            Status = NDIS_STATUS_RESOURCES;
            break;
        }
        FreeSGListLookasideList = TRUE;
        
        NtStatus = Miniport->SystemAdapterObject->DmaOperations->CalculateScatterGatherList(
                                                                    Miniport->SystemAdapterObject,
                                                                    NULL,
                                                                    0,
                                                                    MapRegisters * PAGE_SIZE,
                                                                    &ScatterGatherListSize,
                                                                    &SGMapRegsisters);

        ASSERT(NT_SUCCESS(NtStatus));
        ASSERT(SGMapRegsisters == MapRegisters);
        
        if (!NT_SUCCESS(NtStatus))
        {
            Status = NDIS_STATUS_RESOURCES;
            break;
        }

        Miniport->ScatterGatherListSize = ScatterGatherListSize;
        
        ExInitializeNPagedLookasideList(Miniport->SGListLookasideList,
                                        NULL,
                                        NULL,
                                        0,
                                        ScatterGatherListSize,
                                        NDIS_TAG_DMA,
                                        0);

        Status = NDIS_STATUS_SUCCESS;
        MINIPORT_SET_FLAG(Miniport, fMINIPORT_SG_LIST);
        Miniport->InfoFlags |= NDIS_MINIPORT_SG_LIST;
        
        DereferenceDmaAdapter = FALSE;
        FreeSGListLookasideList = FALSE;

    }while (FALSE);


    if (DereferenceDmaAdapter)
    {
        ndisDereferenceDmaAdapter(Miniport);
    }
    
    if (FreeSGListLookasideList && Miniport->SGListLookasideList)
    {
        ExDeleteNPagedLookasideList(Miniport->SGListLookasideList);
        FREE_POOL(Miniport->SGListLookasideList);
        Miniport->SGListLookasideList = NULL;
    }
    
    DBGPRINT_RAW(DBG_COMP_CONFIG, DBG_LEVEL_INFO, 
        ("<==NdisMInitializeScatterGatherDma: Miniport %lx, Status %lx\n", Miniport, Status));
    
    return(Status);
}


VOID
FASTCALL
ndisMAllocSGList(
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  PNDIS_PACKET            Packet
    )
/*++

Routine Description:


Arguments:


Return Value:

    None.

--*/
{
    NDIS_STATUS     Status = NDIS_STATUS_SUCCESS;
    PNDIS_BUFFER    Buffer;
    PVOID           pBufferVa;
    ULONG           PacketLength;
    PNDIS_BUFFER    pNdisBuffer = NULL;
    PVOID           SGListBuffer;
    KIRQL           OldIrql;

    NdisQueryPacket(Packet, NULL, NULL, &Buffer, &PacketLength);

    pBufferVa = MmGetMdlVirtualAddress(Buffer);

    SGListBuffer = ExAllocateFromNPagedLookasideList(Miniport->SGListLookasideList);

    //
    //  Callers of GetScatterGatherList must be at dispatch.
    //
    RAISE_IRQL_TO_DISPATCH(&OldIrql);
    
    if (SGListBuffer)
    {
        Packet->Private.Flags = NdisGetPacketFlags(Packet) | NDIS_FLAGS_USES_SG_BUFFER_LIST;
        NDIS_DOUBLE_BUFFER_INFO_FROM_PACKET(Packet) = SGListBuffer;
            
        Status = Miniport->SystemAdapterObject->DmaOperations->BuildScatterGatherList(
                        Miniport->SystemAdapterObject,
                        Miniport->DeviceObject,
                        Buffer,
                        pBufferVa,
                        PacketLength,
                        ndisMProcessSGList,
                        Packet,
                        TRUE,
                        SGListBuffer,
                        Miniport->ScatterGatherListSize);
        
        if (!NT_SUCCESS(Status))
        {
            NDIS_DOUBLE_BUFFER_INFO_FROM_PACKET(Packet) = NULL;
            NdisClearPacketFlags(Packet, NDIS_FLAGS_USES_SG_BUFFER_LIST);
            ExFreeToNPagedLookasideList(Miniport->SGListLookasideList, SGListBuffer);
        }
    }
    else
    {
        Status = NDIS_STATUS_RESOURCES;
    }

    if (!NT_SUCCESS(Status))
    {
    
        Status = Miniport->SystemAdapterObject->DmaOperations->GetScatterGatherList(
                        Miniport->SystemAdapterObject,
                        Miniport->DeviceObject,
                        Buffer,
                        pBufferVa,
                        PacketLength,
                        ndisMProcessSGList,
                        Packet,
                        TRUE);

    }    
    LOWER_IRQL(OldIrql, DISPATCH_LEVEL);

    if (!NT_SUCCESS(Status))
    {
        PCHAR           NewBuffer;
        UINT            BytesCopied;
        
        do
        {
            //
            //  Allocate a buffer for the packet.
            //
            NewBuffer = (PUCHAR)ALLOC_FROM_POOL(PacketLength, NDIS_TAG_DOUBLE_BUFFER_PKT);
            if (NULL == NewBuffer)
            {
                Status = NDIS_STATUS_RESOURCES;
                break;
            }

            //
            //  Allocate an MDL for the buffer
            //
            NdisAllocateBuffer(&Status, &pNdisBuffer, NULL, (PVOID)NewBuffer, PacketLength);
            if (NDIS_STATUS_SUCCESS != Status)
            {    
                break;
            }

            ndisMCopyFromPacketToBuffer(Packet,         // Packet to copy from.
                                        0,              // Offset from beginning of packet.
                                        PacketLength,   // Number of bytes to copy.
                                        NewBuffer,      // The destination buffer.
                                        &BytesCopied);  // The number of bytes copied.
        
            Packet->Private.Flags = NdisGetPacketFlags(Packet) | NDIS_FLAGS_DOUBLE_BUFFERED;
            pBufferVa = MmGetMdlVirtualAddress(pNdisBuffer);

            NDIS_DOUBLE_BUFFER_INFO_FROM_PACKET(Packet) = pNdisBuffer;

            RAISE_IRQL_TO_DISPATCH(&OldIrql);

            Status = Miniport->SystemAdapterObject->DmaOperations->GetScatterGatherList(
                            Miniport->SystemAdapterObject,
                            Miniport->DeviceObject,
                            pNdisBuffer,
                            pBufferVa,
                            PacketLength,
                            ndisMProcessSGList,
                            Packet,
                            TRUE);

            LOWER_IRQL(OldIrql, DISPATCH_LEVEL);

        }while (FALSE);
        
        if (!NT_SUCCESS(Status))
        {
            DBGPRINT(DBG_COMP_SEND, DBG_LEVEL_INFO,
                     ("ndisMAllocSGList: GetScatterGatherList failed %lx\n", Status));

            if (pNdisBuffer)
            {
                NdisFreeBuffer(pNdisBuffer);
            }
            if (NewBuffer)
            {
                FREE_POOL(NewBuffer);
            }

            NDIS_PER_PACKET_INFO_FROM_PACKET(Packet, ScatterGatherListPacketInfo) = NULL;
            NDIS_DOUBLE_BUFFER_INFO_FROM_PACKET(Packet) = NULL;
            NdisClearPacketFlags(Packet, NDIS_FLAGS_DOUBLE_BUFFERED);
            
            if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_IS_CO))
            {
                PNDIS_STACK_RESERVED    NSR;

                NDIS_STACK_RESERVED_FROM_PACKET(Packet, &NSR);
                NdisMCoSendComplete(NDIS_STATUS_FAILURE, NSR->VcPtr, Packet);
            }
            else
            {
                ndisMSendCompleteX(Miniport, Packet, NDIS_STATUS_FAILURE);
            }
        }
    }
}


VOID
FASTCALL
ndisMFreeSGList(
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  PNDIS_PACKET            Packet
    )
/*++

Routine Description:


Arguments:


Return Value:

    None.

--*/
{
    PSCATTER_GATHER_LIST    pSGL;
    PVOID                   SGListBuffer;

    pSGL = NDIS_PER_PACKET_INFO_FROM_PACKET(Packet, ScatterGatherListPacketInfo);
    ASSERT(pSGL != NULL);
    NDIS_PER_PACKET_INFO_FROM_PACKET(Packet, ScatterGatherListPacketInfo) = NULL;

    ASSERT(CURRENT_IRQL == DISPATCH_LEVEL);
    Miniport->SystemAdapterObject->DmaOperations->PutScatterGatherList(Miniport->SystemAdapterObject,
                                                                       pSGL,
                                                                       TRUE);

    if (NdisGetPacketFlags(Packet) & NDIS_FLAGS_USES_SG_BUFFER_LIST)
    {
        NdisClearPacketFlags(Packet, NDIS_FLAGS_USES_SG_BUFFER_LIST);
        SGListBuffer = NDIS_DOUBLE_BUFFER_INFO_FROM_PACKET(Packet);
        NDIS_DOUBLE_BUFFER_INFO_FROM_PACKET(Packet) = NULL;
        ASSERT(SGListBuffer != NULL);
        ExFreeToNPagedLookasideList(Miniport->SGListLookasideList, SGListBuffer);
    }
    else if (NdisGetPacketFlags(Packet) & NDIS_FLAGS_DOUBLE_BUFFERED)
    {
        PNDIS_BUFFER    DoubleBuffer;
        PVOID           Buffer;

        NdisClearPacketFlags(Packet, NDIS_FLAGS_DOUBLE_BUFFERED);
        DoubleBuffer = NDIS_DOUBLE_BUFFER_INFO_FROM_PACKET(Packet);
        NDIS_DOUBLE_BUFFER_INFO_FROM_PACKET(Packet) = NULL;
        ASSERT(DoubleBuffer != NULL);
        Buffer = MmGetMdlVirtualAddress(DoubleBuffer);
        NdisFreeBuffer(DoubleBuffer);
        FREE_POOL(Buffer);        
    }

}

VOID
ndisMProcessSGList(
    IN  PDEVICE_OBJECT          pDO,
    IN  PIRP                    pIrp,
    IN  PSCATTER_GATHER_LIST    pSGL,
    IN  PVOID                   Context
    )
/*++

Routine Description:


Arguments:


Return Value:

    None.

--*/
{
    PNDIS_PACKET            Packet = (PNDIS_PACKET)Context;
    PNDIS_CO_VC_PTR_BLOCK   VcPtr;
    PNDIS_MINIPORT_BLOCK    Miniport;
    PNDIS_OPEN_BLOCK        Open;
    PNDIS_STACK_RESERVED    NSR;

    ASSERT(CURRENT_IRQL == DISPATCH_LEVEL);

    NDIS_PER_PACKET_INFO_FROM_PACKET(Packet, ScatterGatherListPacketInfo) = pSGL;

    NDIS_STACK_RESERVED_FROM_PACKET(Packet, &NSR);

    Open = NSR->Open;
    Miniport = Open->MiniportHandle;

    //
    // Handle Send/SendPacket differently
    //
    MINIPORT_SET_PACKET_FLAG(Packet, fPACKET_PENDING);
    
    
    if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_IS_CO))
    {
        VcPtr = NSR->VcPtr;
        (*VcPtr->WCoSendPacketsHandler)(VcPtr->MiniportContext,
                                        &Packet,
                                        1);
    
    }
    else if (MINIPORT_TEST_SEND_FLAG(Miniport, fMINIPORT_SEND_PACKET_ARRAY))
    {
        //
        //  Pass the packet down to the miniport.
        //
        (Open->WSendPacketsHandler)(Miniport->MiniportAdapterContext,
                                   &Packet,
                                   1);
    }
    else
    {
        ULONG       Flags;
        NDIS_STATUS Status;

        NdisQuerySendFlags(Packet, &Flags);
        Status = (Open->WSendHandler)(Open->MiniportAdapterContext, Packet, Flags);
    
        if (Status != NDIS_STATUS_PENDING)
        {
            ndisMSendCompleteX(Miniport, Packet, Status);
        }
    }
}


VOID
FASTCALL
ndisMAllocSGListS(
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  PNDIS_PACKET            Packet
    )
/*++

Routine Description:
    Allocate SG list for packets sent on a serialized miniport


Arguments:

    Miniport
    Packet
Return Value:

    None.

--*/
{
    NDIS_STATUS     Status = NDIS_STATUS_SUCCESS;
    PNDIS_BUFFER    Buffer;
    PVOID           pBufferVa;
    ULONG           PacketLength;
    PNDIS_BUFFER    pNdisBuffer = NULL;
    PVOID           SGListBuffer;
    KIRQL           OldIrql;

    NdisQueryPacket(Packet, NULL, NULL, &Buffer, &PacketLength);

    pBufferVa = MmGetMdlVirtualAddress(Buffer);

    SGListBuffer = ExAllocateFromNPagedLookasideList(Miniport->SGListLookasideList);

    //
    //  Callers of GetScatterGatherList must be at dispatch.
    //
    RAISE_IRQL_TO_DISPATCH(&OldIrql);


    if (SGListBuffer)
    {
        Packet->Private.Flags = NdisGetPacketFlags(Packet) | NDIS_FLAGS_USES_SG_BUFFER_LIST;
        NDIS_DOUBLE_BUFFER_INFO_FROM_PACKET(Packet) = SGListBuffer;
            
        Status = Miniport->SystemAdapterObject->DmaOperations->BuildScatterGatherList(
                        Miniport->SystemAdapterObject,
                        Miniport->DeviceObject,
                        Buffer,
                        pBufferVa,
                        PacketLength,
                        ndisMProcessSGListS,
                        Packet,
                        TRUE,
                        SGListBuffer,
                        Miniport->ScatterGatherListSize);
        
        if (!NT_SUCCESS(Status))
        {
            NDIS_DOUBLE_BUFFER_INFO_FROM_PACKET(Packet) = NULL;
            NdisClearPacketFlags(Packet, NDIS_FLAGS_USES_SG_BUFFER_LIST);
            ExFreeToNPagedLookasideList(Miniport->SGListLookasideList, SGListBuffer);
        }
    }
    else
    {
        Status = NDIS_STATUS_RESOURCES;
    }

    if (!NT_SUCCESS(Status))
    {
        Status = Miniport->SystemAdapterObject->DmaOperations->GetScatterGatherList(
                        Miniport->SystemAdapterObject,
                        Miniport->DeviceObject,
                        Buffer,
                        pBufferVa,
                        PacketLength,
                        ndisMProcessSGListS,
                        Packet,
                        TRUE);
    }
    LOWER_IRQL(OldIrql, DISPATCH_LEVEL);

    if (!NT_SUCCESS(Status))
    {
        PCHAR           NewBuffer;
        UINT            BytesCopied;
        
        //
        // probably the packet was too fragmented and we couldn't allocate enough
        // map registers. try to double buffer the packet.
        //
        do
        {
            //
            //  Allocate a buffer for the packet.
            //
            NewBuffer = (PUCHAR)ALLOC_FROM_POOL(PacketLength, NDIS_TAG_DOUBLE_BUFFER_PKT);
            if (NULL == NewBuffer)
            {
                Status = NDIS_STATUS_RESOURCES;
                break;
            }

            //
            //  Allocate an MDL for the buffer
            //
            NdisAllocateBuffer(&Status, &pNdisBuffer, NULL, (PVOID)NewBuffer, PacketLength);
            if (NDIS_STATUS_SUCCESS != Status)
            {    
                break;
            }

            ndisMCopyFromPacketToBuffer(Packet,         // Packet to copy from.
                                        0,              // Offset from beginning of packet.
                                        PacketLength,   // Number of bytes to copy.
                                        NewBuffer,      // The destination buffer.
                                        &BytesCopied);  // The number of bytes copied.
        
            Packet->Private.Flags = NdisGetPacketFlags(Packet) | NDIS_FLAGS_DOUBLE_BUFFERED;
            pBufferVa = MmGetMdlVirtualAddress(pNdisBuffer);

            NDIS_DOUBLE_BUFFER_INFO_FROM_PACKET(Packet) = pNdisBuffer;

            RAISE_IRQL_TO_DISPATCH(&OldIrql);

            Status = Miniport->SystemAdapterObject->DmaOperations->GetScatterGatherList(
                            Miniport->SystemAdapterObject,
                            Miniport->DeviceObject,
                            pNdisBuffer,
                            pBufferVa,
                            PacketLength,
                            ndisMProcessSGListS,
                            Packet,
                            TRUE);
            
            LOWER_IRQL(OldIrql, DISPATCH_LEVEL);


        }while (FALSE);
        
        if (!NT_SUCCESS(Status))
        {
            PNDIS_STACK_RESERVED    NSR;
            
            DBGPRINT(DBG_COMP_SEND, DBG_LEVEL_INFO,
                     ("ndisMAllocSGList: GetScatterGatherList failed %lx\n", Status));

            if (pNdisBuffer)
            {
                NdisFreeBuffer(pNdisBuffer);
            }
            if (NewBuffer)
            {
                FREE_POOL(NewBuffer);
            }

            NDIS_PER_PACKET_INFO_FROM_PACKET(Packet, ScatterGatherListPacketInfo) = NULL;
            NDIS_DOUBLE_BUFFER_INFO_FROM_PACKET(Packet) = NULL;
            NdisClearPacketFlags(Packet, NDIS_FLAGS_DOUBLE_BUFFERED);

            NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Miniport, &OldIrql);
            //
            // complete the send, don't unlink the packet since it was never 
            // linked to begin with.
            //
            NDIS_STACK_RESERVED_FROM_PACKET(Packet, &NSR);
            NDISM_COMPLETE_SEND_SG(Miniport, Packet, NSR, Status, TRUE, 0, FALSE);
            NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);
        }
    }
}


VOID
ndisMProcessSGListS(
    IN  PDEVICE_OBJECT          pDO,
    IN  PIRP                    pIrp,
    IN  PSCATTER_GATHER_LIST    pSGL,
    IN  PVOID                   Context
    )
/*++

Routine Description:


Arguments:


Return Value:

    None.

--*/
{
    PNDIS_PACKET            Packet = (PNDIS_PACKET)Context;
    PNDIS_MINIPORT_BLOCK    Miniport;
    PNDIS_OPEN_BLOCK        Open;
    PNDIS_STACK_RESERVED    NSR;
    BOOLEAN                 LocalLock;

    ASSERT(CURRENT_IRQL == DISPATCH_LEVEL);

    NDIS_PER_PACKET_INFO_FROM_PACKET(Packet, ScatterGatherListPacketInfo) = pSGL;

    NDIS_STACK_RESERVED_FROM_PACKET(Packet, &NSR);

    Open = NSR->Open;
    Miniport = Open->MiniportHandle;

    NDIS_ACQUIRE_MINIPORT_SPIN_LOCK_DPC (Miniport);

    //
    // queue the packet
    //
    LINK_PACKET_SG(Miniport, Packet, NSR);

    if (Miniport->FirstPendingPacket == NULL)
    {
        Miniport->FirstPendingPacket = Packet;
    }

    //
    //  If we have the local lock and there is no
    //  packet pending, then fire off a send.
    //
    LOCK_MINIPORT(Miniport, LocalLock);

    NDISM_QUEUE_WORK_ITEM(Miniport, NdisWorkItemSend, NULL);
    if (LocalLock)
    {
        NDISM_PROCESS_DEFERRED(Miniport);
    }
    UNLOCK_MINIPORT(Miniport, LocalLock);

    NDIS_RELEASE_MINIPORT_SPIN_LOCK_DPC(Miniport);
    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ndis\sys\ffilter.c ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation

Module Name:

    ffilter.c

Abstract:

    This module implements a set of library routines to handle packet
    filtering for NDIS MAC drivers.

Author:

    Anthony V. Ercolano (Tonye) 03-Aug-1990

Environment:

    Kernel Mode - Or whatever is the equivalent on OS/2 and DOS.

Revision History:

    Jameel Hyder (JameelH) Re-organization


--*/

#include <precomp.h>
#pragma hdrstop

//
//  Define the module number for debug code.
//
#define MODULE_NUMBER   MODULE_FFILTER


#define FDDI_CHECK_FOR_INVALID_BROADCAST_INDICATION(_F)             \
IF_DBG(DBG_COMP_FILTER, DBG_LEVEL_WARN)                             \
{                                                                   \
    if (!((_F)->CombinedPacketFilter & NDIS_PACKET_TYPE_BROADCAST)) \
    {                                                               \
        /*                                                          \
            We should never receive broadcast packets               \
            to someone else unless in p-mode.                       \
        */                                                          \
        DBGPRINT(DBG_COMP_FILTER, DBG_LEVEL_ERR,                    \
                ("Bad driver, indicating broadcast packets when not set to.\n"));\
        DBGBREAK(DBG_COMP_FILTER, DBG_LEVEL_ERR);                   \
    }                                                               \
}

#define FDDI_CHECK_FOR_INVALID_DIRECTED_INDICATION(_F, _A, _AL)     \
IF_DBG(DBG_COMP_FILTER, DBG_LEVEL_WARN)                             \
{                                                                   \
    /*                                                              \
        The result of comparing an element of the address           \
        array and the multicast address.                            \
                                                                    \
            Result < 0 Implies the adapter address is greater.      \
            Result > 0 Implies the address is greater.              \
            Result = 0 Implies that the they are equal.             \
    */                                                              \
    INT Result = 0;                                                 \
    if (FDDI_LENGTH_OF_LONG_ADDRESS == (_AL))                       \
    {                                                               \
        FDDI_COMPARE_NETWORK_ADDRESSES_EQ(                          \
            (_F)->AdapterLongAddress,                               \
            (_A),                                                   \
            FDDI_LENGTH_OF_LONG_ADDRESS,                            \
            &Result);                                               \
    }                                                               \
    else if (FDDI_LENGTH_OF_SHORT_ADDRESS == (_AL))                 \
    {                                                               \
        FDDI_COMPARE_NETWORK_ADDRESSES_EQ(                          \
            (_F)->AdapterShortAddress,                              \
            (_A),                                                   \
            FDDI_LENGTH_OF_SHORT_ADDRESS,                           \
            &Result);                                               \
    }                                                               \
    if (Result != 0)                                                \
    {                                                               \
        /*                                                          \
            We should never receive directed packets                \
            to someone else unless in p-mode.                       \
        */                                                          \
        DBGPRINT(DBG_COMP_FILTER, DBG_LEVEL_ERR,                    \
                ("Bad driver, indicating packets to another station when not in promiscuous mode.\n"));\
        DBGBREAK(DBG_COMP_FILTER, DBG_LEVEL_ERR);                   \
    }                                                               \
}


BOOLEAN
FddiCreateFilter(
    IN  UINT                    MaximumMulticastLongAddresses,
    IN  UINT                    MaximumMulticastShortAddresses,
    IN  PUCHAR                  AdapterLongAddress,
    IN  PUCHAR                  AdapterShortAddress,
    OUT PFDDI_FILTER *          Filter
    )
/*++

Routine Description:

    This routine is used to create and initialize the filter database.

Arguments:

    MaximumMulticastLongAddresses - The maximum number of Long multicast addresses
    that the MAC will support.

    MaximumMulticastShortAddresses - The maximum number of short multicast addresses
    that the MAC will support.

    AdapterLongAddress - the long address of the adapter associated with this filter
    database.

    AdapterShortAddress - the short address of the adapter associated with this filter
    database.

    Filter - A pointer to an FDDI_FILTER.  This is what is allocated and
    created by this routine.

Return Value:

    If the function returns false then one of the parameters exceeded
    what the filter was willing to support.

--*/
{
    PFDDI_FILTER    LocalFilter;
    BOOLEAN         rc = FALSE;

    do
    {
        //
        // Allocate the database and initialize it.
        //
        *Filter = LocalFilter = ALLOC_FROM_POOL(sizeof(FDDI_FILTER), NDIS_TAG_FILTER);
        if (LocalFilter != NULL)
        {
            ZeroMemory(LocalFilter, sizeof(FDDI_FILTER));
            LocalFilter->NumOpens ++;
            FddiReferencePackage();
        
            FDDI_COPY_NETWORK_ADDRESS(LocalFilter->AdapterLongAddress,
                                      AdapterLongAddress,
                                      FDDI_LENGTH_OF_LONG_ADDRESS);
        
            FDDI_COPY_NETWORK_ADDRESS(LocalFilter->AdapterShortAddress,
                                      AdapterShortAddress,
                                      FDDI_LENGTH_OF_SHORT_ADDRESS);
        
            LocalFilter->MaxMulticastLongAddresses = MaximumMulticastLongAddresses;
            LocalFilter->MaxMulticastShortAddresses = MaximumMulticastShortAddresses;
            INITIALIZE_SPIN_LOCK(&LocalFilter->BindListLock.SpinLock);
            rc = TRUE;
        }
    } while (FALSE);

    return(rc);
}

//
// NOTE: THIS CANNOT BE PAGABLE
//
VOID
FddiDeleteFilter(
    IN  PFDDI_FILTER            Filter
    )
/*++

Routine Description:

    This routine is used to delete the memory associated with a filter
    database.  Note that this routines *ASSUMES* that the database
    has been cleared of any active filters.

Arguments:

    Filter - A pointer to an FDDI_FILTER to be deleted.

Return Value:

    None.

--*/
{

    ASSERT(Filter->OpenList == NULL);

    if (Filter->MCastLongAddressBuf)
    {
        FREE_POOL(Filter->MCastLongAddressBuf);
    }

    ASSERT(Filter->OldMCastLongAddressBuf == NULL);

    if (Filter->MCastShortAddressBuf)
    {
        FREE_POOL(Filter->MCastShortAddressBuf);
    }

    ASSERT(Filter->OldMCastShortAddressBuf == NULL);

    FREE_POOL(Filter);
    FddiDereferencePackage();
}


NDIS_STATUS
FddiDeleteFilterOpenAdapter(
    IN  PFDDI_FILTER            Filter,
    IN  NDIS_HANDLE             NdisFilterHandle
    )
/*++

Routine Description:

    When an adapter is being closed this routine should
    be called to delete knowledge of the adapter from
    the filter database.  This routine is likely to call
    action routines associated with clearing filter classes
    and addresses.

    NOTE: THIS ROUTINE SHOULD ****NOT**** BE CALLED IF THE ACTION
    ROUTINES FOR DELETING THE FILTER CLASSES OR THE MULTICAST ADDRESSES
    HAVE ANY POSSIBILITY OF RETURNING A STATUS OTHER THAN NDIS_STATUS_PENDING
    OR NDIS_STATUS_SUCCESS.  WHILE THESE ROUTINES WILL NOT BUGCHECK IF
    SUCH A THING IS DONE, THE CALLER WILL PROBABLY FIND IT DIFFICULT
    TO CODE A CLOSE ROUTINE!

    NOTE: THIS ROUTINE ASSUMES THAT IT IS CALLED WITH THE LOCK HELD.

Arguments:

    Filter - A pointer to the filter database.

    NdisFilterHandle - Pointer to the open.

Return Value:

    If action routines are called by the various address and filtering
    routines the this routine will likely return the status returned
    by those routines.  The exception to this rule is noted below.

    Given that the filter and address deletion routines return a status
    NDIS_STATUS_PENDING or NDIS_STATUS_SUCCESS this routine will then
    try to return the filter index to the freelist.  If the routine
    detects that this binding is currently being indicated to via
    NdisIndicateReceive, this routine will return a status of
    NDIS_STATUS_CLOSING_INDICATING.

--*/
{

    //
    // Holds the status returned from the packet filter and address
    // deletion routines.  Will be used to return the status to
    // the caller of this routine.
    //
    NDIS_STATUS StatusToReturn;

    //
    // Local variable.
    //
    PFDDI_BINDING_INFO LocalOpen = (PFDDI_BINDING_INFO)NdisFilterHandle;

    //
    //  Set the filter classes to NONE.
    //
    StatusToReturn = XFilterAdjust(Filter,
                                   NdisFilterHandle,
                                   (UINT)0,
                                   FALSE);
    if ((StatusToReturn == NDIS_STATUS_SUCCESS) ||
        (StatusToReturn == NDIS_STATUS_PENDING))
    {
        NDIS_STATUS StatusToReturn2;

        //
        //  Remove the long multicast addresses.
        //
        StatusToReturn2 = FddiChangeFilterLongAddresses(Filter,
                                                        NdisFilterHandle,
                                                        0,
                                                        NULL,
                                                        FALSE);
        if (StatusToReturn2 != NDIS_STATUS_SUCCESS)
        {
            StatusToReturn = StatusToReturn2;
        }

        if (StatusToReturn2 == NDIS_STATUS_PENDING)
        {
            fddiCompleteChangeFilterLongAddresses(Filter, NDIS_STATUS_SUCCESS);
        }

        if ((StatusToReturn == NDIS_STATUS_SUCCESS) ||
            (StatusToReturn == NDIS_STATUS_PENDING))
        {
            StatusToReturn2 = FddiChangeFilterShortAddresses(Filter,
                                                             NdisFilterHandle,
                                                             0,
                                                             NULL,
                                                             FALSE);
            if (StatusToReturn2 != NDIS_STATUS_SUCCESS)
            {
                StatusToReturn = StatusToReturn2;
            }
            
            if (StatusToReturn2 == NDIS_STATUS_PENDING)
            {
                fddiCompleteChangeFilterShortAddresses(Filter, NDIS_STATUS_SUCCESS);
            }

        }
    }

    if ((StatusToReturn == NDIS_STATUS_SUCCESS) ||
        (StatusToReturn == NDIS_STATUS_PENDING) ||
        (StatusToReturn == NDIS_STATUS_RESOURCES))
    {
        //
        // Remove the reference from the original open.
        //
        if (--(LocalOpen->References) == 0)
        {
            //
            // Remove it from the list.
            //
            XRemoveAndFreeBinding(Filter, LocalOpen);
        }
        else
        {
            //
            // Let the caller know that there is a reference to the open
            // by the receive indication. The close action routine will be
            // called upon return from NdisIndicateReceive.
            //
            StatusToReturn = NDIS_STATUS_CLOSING_INDICATING;
        }
    }

    return(StatusToReturn);
}


NDIS_STATUS
FddiChangeFilterLongAddresses(
    IN  PFDDI_FILTER            Filter,
    IN  NDIS_HANDLE             NdisFilterHandle,
    IN  UINT                    AddressCount,
    IN  CHAR                    Addresses[][FDDI_LENGTH_OF_LONG_ADDRESS],
    IN  BOOLEAN                 Set
    )
/*++

Routine Description:

    The ChangeFilterAddress routine will call an action
    routine when the overall multicast address list for the adapter
    has changed.

    If the action routine returns a value other than pending or
    success then this routine has no effect on the multicast address
    list for the open or for the adapter as a whole.

    NOTE: THIS ROUTINE ASSUMES THAT THE LOCK IS HELD.

Arguments:

    Filter - A pointer to the filter database.

    NdisFilterHandle - Pointer to the open.

    AddressCount - The number of elements (addresses,
    not bytes) in MulticastAddressList.

    Addresses - The new multicast address list for this
    binding. This is a sequence of FDDI_LENGTH_OF_LONG_ADDRESS byte
    addresses, with no padding between them.

    Set - A boolean that determines whether the multicast addresses
    are being adjusted due to a set or because of a close. (The filtering
    routines don't care, the MAC might.)

Return Value:

    If it calls the action routine then it will return the
    status returned by the action routine.  If the status
    returned by the action routine is anything other than
    NDIS_STATUS_SUCCESS or NDIS_STATUS_PENDING the filter database
    will be returned to the state it was in upon entrance to this
    routine.

    If the action routine is not called this routine will return
    the following statum:

    NDIS_STATUS_SUCCESS - If the new packet filters doesn't change
    the combined mask of all bindings packet filters.

--*/
{
    PFDDI_BINDING_INFO  Binding = (PFDDI_BINDING_INFO)NdisFilterHandle;
    NDIS_STATUS         Status = NDIS_STATUS_SUCCESS;
    INT                 Result;
    UINT                i, j;
    LOCK_STATE          LockState;

    WRITE_LOCK_FILTER(Filter->Miniport, Filter, &LockState);

    //
    // Save the old list for this binding and create a new list.
    // The new list needs to be in a sorted order.
    //
    do
    {
        //
        // Save the current values - this is used for undoing stuff if something fails
        //
        ASSERT(Binding->OldMCastLongAddressBuf == NULL);
        Binding->OldMCastLongAddressBuf = Binding->MCastLongAddressBuf;
        Binding->OldNumLongAddresses = Binding->NumLongAddresses;
        Binding->MCastLongAddressBuf = NULL;
        Binding->NumLongAddresses = 0;

        ASSERT(Filter->OldMCastLongAddressBuf == NULL);
        Filter->OldMCastLongAddressBuf = Filter->MCastLongAddressBuf;
        Filter->OldNumLongAddresses = Filter->NumLongAddresses;
        Filter->MCastLongAddressBuf = NULL;
        Filter->NumLongAddresses = 0;

        Filter->MCastSet = Binding;

        if (AddressCount != 0)
        {
            Binding->MCastLongAddressBuf = ALLOC_FROM_POOL(FDDI_LENGTH_OF_LONG_ADDRESS * AddressCount,
                                                       NDIS_TAG_FILTER_ADDR);
            if (Binding->MCastLongAddressBuf == NULL)
            {
                Status = NDIS_STATUS_RESOURCES;
                break;
            }
        
            for (i = 0; i < AddressCount; i++)
            {
                for (j = 0, Result = -1; j < Binding->NumLongAddresses; j++)
                {
                    FDDI_COMPARE_NETWORK_ADDRESSES(Binding->MCastLongAddressBuf[j],
                                                  Addresses[i],
                                                  FDDI_LENGTH_OF_LONG_ADDRESS,
                                                  &Result);
                    if (Result >= 0)
                        break;
                }
    
                //
                // This address is already present. Caller supplied duplicate. Skip it.
                //
                if (Result == 0)
                    continue;
    
                Binding->NumLongAddresses ++;
                if (Result > 0)
                {
                    //
                    // We need to move the addresses forward and copy this one here
                    //
                    MoveMemory(Binding->MCastLongAddressBuf[j+1],
                               Binding->MCastLongAddressBuf[j],
                               (Binding->NumLongAddresses-j-1)*FDDI_LENGTH_OF_LONG_ADDRESS);
                }
            
                MoveMemory(Binding->MCastLongAddressBuf[j],
                           Addresses[i],
                           FDDI_LENGTH_OF_LONG_ADDRESS);
            }
        
            ASSERT(Binding->NumLongAddresses <= AddressCount);
        }

        //
        // Now we need to allocate memory for the global list. The old stuff will be deleted
        // once the operation completes
        //
        Filter->MCastLongAddressBuf = ALLOC_FROM_POOL(Filter->MaxMulticastLongAddresses * FDDI_LENGTH_OF_LONG_ADDRESS,
                                                  NDIS_TAG_FILTER_ADDR);
        if (Filter->MCastLongAddressBuf == NULL)
        {
            Status = NDIS_STATUS_RESOURCES;
            break;
        }
        
        //
        // Now create the global list from the bindings
        //
        for (Binding = Filter->OpenList;
             (Binding != NULL) && (Status == NDIS_STATUS_SUCCESS);
             Binding = Binding->NextOpen)
        {
            for (i = 0; i < Binding->NumLongAddresses; i++)
            {
                for (j = 0, Result = -1; j < Filter->NumLongAddresses; j++)
                {
                    FDDI_COMPARE_NETWORK_ADDRESSES(Filter->MCastLongAddressBuf[j],
                                                  Binding->MCastLongAddressBuf[i],
                                                  FDDI_LENGTH_OF_LONG_ADDRESS,
                                                  &Result);
                    if (Result >= 0)
                    {
                        break;
                    }
                }
    
                if (Result == 0)
                {
                    continue;
                }
    
                Filter->NumLongAddresses ++;
                if (Filter->NumLongAddresses > Filter->MaxMulticastLongAddresses)
                {
                    //
                    // Abort. We exceeded the the # of addresses
                    //
                    Status = NDIS_STATUS_MULTICAST_FULL;
                    break;
                }
    
                if (Result > 0)
                {
                    //
                    // We need to move the addresses forward and copy this one here
                    //
                    MoveMemory(Filter->MCastLongAddressBuf[j+1],
                               Filter->MCastLongAddressBuf[j],
                               (Filter->NumLongAddresses-j-1)*FDDI_LENGTH_OF_LONG_ADDRESS);
                }
            
                MoveMemory(Filter->MCastLongAddressBuf[j],
                           Binding->MCastLongAddressBuf[i],
                           FDDI_LENGTH_OF_LONG_ADDRESS);
            }
        }
    
        if (Status != NDIS_STATUS_SUCCESS)
            break;

        //
        // After all the hard work, determine if there was indeed a change
        //
        if (Filter->NumLongAddresses == Filter->OldNumLongAddresses)
        {
            for (i = 0; i < Filter->NumLongAddresses; i++)
            {
                FDDI_COMPARE_NETWORK_ADDRESSES_EQ(Filter->MCastLongAddressBuf[i],
                                                  Filter->OldMCastLongAddressBuf[i],
                                                  FDDI_LENGTH_OF_LONG_ADDRESS,
                                                  &Result);
                if (Result != 0)
                    break;
            }
        }
    
        if (Result != 0)
        {
            Status = NDIS_STATUS_PENDING;
        }
        else if (AddressCount == 0)
        {
            //
            // Addresses are being removed (not added). Get rid of the old list right here
            //
            if (Filter->OldMCastLongAddressBuf != NULL)
            {
                FREE_POOL(Filter->OldMCastLongAddressBuf);
                Filter->OldMCastLongAddressBuf = NULL;
                Filter->OldNumLongAddresses = 0;
            }
        
            Binding = (PFDDI_BINDING_INFO)NdisFilterHandle;
            if (Binding->OldMCastLongAddressBuf != NULL)
            {
                FREE_POOL(Binding->OldMCastLongAddressBuf);
                Binding->OldMCastLongAddressBuf = NULL;
                Binding->OldNumLongAddresses = 0;
            }
        }
    } while (FALSE);
    
    WRITE_UNLOCK_FILTER(Filter->Miniport, Filter, &LockState);
    
    if (Status != NDIS_STATUS_PENDING)
    {
        //
        // Operation completed, do post processing.
        //
        fddiCompleteChangeFilterLongAddresses(Filter, Status);
    }

    return(Status);
}


VOID
fddiCompleteChangeFilterLongAddresses(
    IN  PFDDI_FILTER            Filter,
    IN  NDIS_STATUS             Status
    )
{
    PFDDI_BINDING_INFO  Binding = Filter->MCastSet;
    LOCK_STATE          LockState;

    WRITE_LOCK_FILTER(Filter->Miniport, Filter, &LockState);

    Filter->MCastSet = NULL;
    if (Status != NDIS_STATUS_SUCCESS)
    {
        //
        // Operation failed. Undo the stuff.
        //
        if (Binding != NULL)
        {
            if (Binding->MCastLongAddressBuf != NULL)
            {
                FREE_POOL(Binding->MCastLongAddressBuf);
            }
    
            Binding->MCastLongAddressBuf = Binding->OldMCastLongAddressBuf;
            Binding->NumLongAddresses = Binding->OldNumLongAddresses;
            Binding->OldMCastLongAddressBuf = NULL;
            Binding->OldNumLongAddresses = 0;
        }

        if (Filter->MCastLongAddressBuf != NULL)
        {
            FREE_POOL(Filter->MCastLongAddressBuf);
        }

        Filter->MCastLongAddressBuf = Filter->OldMCastLongAddressBuf;
        Filter->NumLongAddresses = Filter->OldNumLongAddresses;
        Filter->OldMCastLongAddressBuf = NULL;
        Filter->OldNumLongAddresses = 0;
    }
    else
    {
        //
        // Operation succeeded, clean-up saved old stuff.
        //
        if (Filter->OldMCastLongAddressBuf != NULL)
        {
            FREE_POOL(Filter->OldMCastLongAddressBuf);
            Filter->OldMCastLongAddressBuf = NULL;
            Filter->OldNumLongAddresses = 0;
        }
    
        if (Binding != NULL)
        {
            if (Binding->OldMCastLongAddressBuf != NULL)
            {
                FREE_POOL(Binding->OldMCastLongAddressBuf);
                Binding->OldMCastLongAddressBuf = NULL;
                Binding->OldNumLongAddresses = 0;
            }
        }
    }

    WRITE_UNLOCK_FILTER(Filter->Miniport, Filter, &LockState);
}


NDIS_STATUS
FddiChangeFilterShortAddresses(
    IN  PFDDI_FILTER            Filter,
    IN  NDIS_HANDLE             NdisFilterHandle,
    IN  UINT                    AddressCount,
    IN  CHAR                    Addresses[][FDDI_LENGTH_OF_SHORT_ADDRESS],
    IN  BOOLEAN                 Set
    )
/*++

Routine Description:

    The ChangeFilterAddress routine will call an action
    routine when the overall multicast address list for the adapter
    has changed.

    If the action routine returns a value other than pending or
    success then this routine has no effect on the multicast address
    list for the open or for the adapter as a whole.

    NOTE: THIS ROUTINE ASSUMES THAT THE LOCK IS HELD.

Arguments:

    Filter - A pointer to the filter database.

    NdisFilterHandle - Pointer to the open.

    AddressCount - The number of elements (addresses,
    not bytes) in MulticastAddressList.

    Addresses - The new multicast address list for this
    binding. This is a sequence of FDDI_LENGTH_OF_SHORT_ADDRESS byte
    addresses, with no padding between them.

    Set - A boolean that determines whether the multicast addresses
    are being adjusted due to a set or because of a close. (The filtering
    routines don't care, the MAC might.)

Return Value:

    If it calls the action routine then it will return the
    status returned by the action routine.  If the status
    returned by the action routine is anything other than
    NDIS_STATUS_SUCCESS or NDIS_STATUS_PENDING the filter database
    will be returned to the state it was in upon entrance to this
    routine.

    If the action routine is not called this routine will return
    the following statum:

    NDIS_STATUS_SUCCESS - If the new packet filters doesn't change
    the combined mask of all bindings packet filters.

--*/
{
    PFDDI_BINDING_INFO Binding = (PFDDI_BINDING_INFO)NdisFilterHandle;

    NDIS_STATUS         Status = NDIS_STATUS_SUCCESS;
    INT                 Result;
    UINT                i, j;
    LOCK_STATE          LockState;

    WRITE_LOCK_FILTER(Filter->Miniport, Filter, &LockState);

    //
    // Save the old list for this binding and create a new list.
    // The new list needs to be in a sorted order.
    //
    do
    {
        //
        // Save the current values - this is used for undoing stuff if something fails
        //
        ASSERT(Binding->OldMCastShortAddressBuf == NULL);
        Binding->OldMCastShortAddressBuf = Binding->MCastShortAddressBuf;
        Binding->OldNumShortAddresses = Binding->NumShortAddresses;
        Binding->MCastShortAddressBuf = NULL;
        Binding->NumShortAddresses = 0;

        ASSERT(Filter->OldMCastShortAddressBuf == NULL);
        Filter->OldMCastShortAddressBuf = Filter->MCastShortAddressBuf;
        Filter->OldNumShortAddresses = Filter->NumShortAddresses;
        Filter->MCastShortAddressBuf = NULL;
        Filter->NumShortAddresses = 0;

        Filter->MCastSet = Binding;

        if (Filter->MaxMulticastShortAddresses == 0)
        {
            break;
        }
        
        if (AddressCount != 0)
        {
            Binding->MCastShortAddressBuf = ALLOC_FROM_POOL(FDDI_LENGTH_OF_SHORT_ADDRESS * AddressCount,
                                                       NDIS_TAG_FILTER_ADDR);
            if (Binding->MCastShortAddressBuf == NULL)
            {
                Status = NDIS_STATUS_RESOURCES;
                break;
            }
        
            for (i = 0; i < AddressCount; i++)
            {
                for (j = 0, Result = -1; j < Binding->NumShortAddresses; j++)
                {
                    FDDI_COMPARE_NETWORK_ADDRESSES(Binding->MCastShortAddressBuf[j],
                                                  Addresses[i],
                                                  FDDI_LENGTH_OF_SHORT_ADDRESS,
                                                  &Result);
                    if (Result >= 0)
                        break;
                }
    
                if (Result == 0)
                    continue;
    
                Binding->NumShortAddresses ++;
                if (Result > 0)
                {
                    //
                    // We need to move the addresses forward and copy this one here
                    //
                    MoveMemory(Binding->MCastShortAddressBuf[j+1],
                               Binding->MCastShortAddressBuf[j],
                               (Binding->NumShortAddresses-j-1)*FDDI_LENGTH_OF_SHORT_ADDRESS);
                }
            
                MoveMemory(Binding->MCastShortAddressBuf[j],
                           Addresses[i],
                           FDDI_LENGTH_OF_SHORT_ADDRESS);
            }
        
            ASSERT(Binding->NumShortAddresses <= AddressCount);
        }

        //
        // Now we need to allocate memory for the global list. The old stuff will be deleted
        // once the operation completes
        //
        Filter->MCastShortAddressBuf = ALLOC_FROM_POOL(Filter->MaxMulticastShortAddresses * FDDI_LENGTH_OF_SHORT_ADDRESS,
                                                  NDIS_TAG_FILTER_ADDR);
        if (Filter->MCastShortAddressBuf == NULL)
        {
            Status = NDIS_STATUS_RESOURCES;
            break;
        }
        
        //
        // Now create the global list from the bindings
        //
        for (Binding = Filter->OpenList;
             (Binding != NULL) && (Status == NDIS_STATUS_SUCCESS);
             Binding = Binding->NextOpen)
        {
            for (i = 0; i < Binding->NumShortAddresses; i++)
            {
                for (j = 0, Result = -1; j < Filter->NumShortAddresses; j++)
                {
                    FDDI_COMPARE_NETWORK_ADDRESSES(Filter->MCastShortAddressBuf[j],
                                                  Binding->MCastShortAddressBuf[i],
                                                  FDDI_LENGTH_OF_SHORT_ADDRESS,
                                                  &Result);
                    if (Result >= 0)
                    {
                        break;
                    }
                }
    
                if (Result == 0)
                {
                    continue;
                }
    
                Filter->NumShortAddresses ++;
                if (Filter->NumShortAddresses > Filter->MaxMulticastShortAddresses)
                {
                    //
                    // Abort. We exceeded the the # of addresses
                    //
                    Status = NDIS_STATUS_MULTICAST_FULL;
                    break;
                }
    
                if (Result > 0)
                {
                    //
                    // We need to move the addresses forward and copy this one here
                    //
                    MoveMemory(Filter->MCastShortAddressBuf[j+1],
                               Filter->MCastShortAddressBuf[j],
                               (Filter->NumShortAddresses-j-1)*FDDI_LENGTH_OF_SHORT_ADDRESS);
                }
            
                MoveMemory(Filter->MCastShortAddressBuf[j],
                           Binding->MCastShortAddressBuf[i],
                           FDDI_LENGTH_OF_SHORT_ADDRESS);
            }
        }
    
        if (Status != NDIS_STATUS_SUCCESS)
            break;

        //
        // After all the hard work, determine if there was indeed a change
        //
        if (Filter->NumShortAddresses == Filter->OldNumShortAddresses)
        {
            for (i = 0; i < Filter->NumShortAddresses; i++)
            {
                FDDI_COMPARE_NETWORK_ADDRESSES_EQ(Filter->MCastShortAddressBuf[i],
                                                  Filter->OldMCastShortAddressBuf[i],
                                                  FDDI_LENGTH_OF_SHORT_ADDRESS,
                                                  &Result);
                if (Result != 0)
                    break;
            }
        }
    
        if (Result != 0)
        {
            Status = NDIS_STATUS_PENDING;
        }
        else if (AddressCount == 0)
        {
            //
            // Addresses are being removed (not added). Get rid of the old list right here
            //
            if (Filter->OldMCastShortAddressBuf != NULL)
            {
                FREE_POOL(Filter->OldMCastShortAddressBuf);
                Filter->OldMCastShortAddressBuf = NULL;
                Filter->OldNumShortAddresses = 0;
            }
        
            Binding = (PFDDI_BINDING_INFO)NdisFilterHandle;
            if (Binding->OldMCastShortAddressBuf != NULL)
            {
                FREE_POOL(Binding->OldMCastShortAddressBuf);
                Binding->OldMCastShortAddressBuf = NULL;
                Binding->OldNumShortAddresses = 0;
            }
        }
    } while (FALSE);
    
    WRITE_UNLOCK_FILTER(Filter->Miniport, Filter, &LockState);

    //
    // If the address array has changed, we have to call the
    // action array to inform the adapter of this.
    //
    
    if ((Status != NDIS_STATUS_PENDING) && (Filter->MaxMulticastShortAddresses != 0))
    {
        //
        // Operation completed, do post processing.
        //
        fddiCompleteChangeFilterShortAddresses(Filter, Status);
    }

    return(Status);
}


VOID
fddiCompleteChangeFilterShortAddresses(
    IN   PFDDI_FILTER           Filter,
    IN  NDIS_STATUS             Status
    )
{
    PFDDI_BINDING_INFO  Binding = Filter->MCastSet;
    LOCK_STATE          LockState;

    WRITE_LOCK_FILTER(Filter->Miniport, Filter, &LockState);

    if (Status != NDIS_STATUS_SUCCESS)
    {
        //
        // Operation failed. Undo the stuff.
        //
        if (Binding != NULL)
        {
            if (Binding->MCastShortAddressBuf != NULL)
            {
                FREE_POOL(Binding->OldMCastShortAddressBuf);
            }
    
            Binding->MCastShortAddressBuf = Binding->OldMCastShortAddressBuf;
            Binding->NumShortAddresses = Binding->OldNumShortAddresses;
            Binding->OldMCastShortAddressBuf = NULL;
            Binding->OldNumShortAddresses = 0;
        }

        if (Filter->MCastShortAddressBuf != NULL)
        {
            FREE_POOL(Filter->MCastShortAddressBuf);
        }

        Filter->MCastShortAddressBuf = Filter->OldMCastShortAddressBuf;
        Filter->NumShortAddresses = Filter->OldNumShortAddresses;
        Filter->OldMCastShortAddressBuf = NULL;
        Filter->OldNumShortAddresses = 0;
    }
    else
    {
        //
        // Operation succeeded, clean-up saved old stuff. Also mark the fact
        // this miniport supports short addresses
        //
        Filter->SupportsShortAddresses = TRUE;
        if (Filter->OldMCastShortAddressBuf != NULL)
        {
            FREE_POOL(Filter->OldMCastShortAddressBuf);
            Filter->OldMCastShortAddressBuf = NULL;
            Filter->OldNumShortAddresses = 0;
        }
        
        if (Binding != NULL)
        {
            if (Binding->OldMCastShortAddressBuf != NULL)
            {
                FREE_POOL(Binding->OldMCastShortAddressBuf);
                Binding->OldMCastShortAddressBuf = NULL;
                Binding->OldNumShortAddresses = 0;
            }
        }
    }

    WRITE_UNLOCK_FILTER(Filter->Miniport, Filter, &LockState);
}


UINT
FddiNumberOfOpenFilterLongAddresses(
    IN  PFDDI_FILTER            Filter,
    IN  NDIS_HANDLE             NdisFilterHandle
    )
/*++

Routine Description:

    This routine counts the number of multicast addresses that a specific
    open has.

    NOTE: THIS ROUTINE ASSUMES THAT THE LOCK IS HELD.

Arguments:

    Filter - A pointer to the filter database.

    NdisFilterHandle - Pointer to open block.


Return Value:

    None.

--*/
{
    return(((PFDDI_BINDING_INFO)NdisFilterHandle)->NumLongAddresses);
}


UINT
FddiNumberOfOpenFilterShortAddresses(
    IN  PFDDI_FILTER            Filter,
    IN  NDIS_HANDLE             NdisFilterHandle
    )
/*++

Routine Description:

    This routine counts the number of multicast addresses that a specific
    open has.

    NOTE: THIS ROUTINE ASSUMES THAT THE LOCK IS HELD.

Arguments:

    Filter - A pointer to the filter database.

    NdisFilterHandle - Pointer to open block.


Return Value:

    None.

--*/
{
    return(((PFDDI_BINDING_INFO)NdisFilterHandle)->NumShortAddresses);
}


VOID
FddiQueryOpenFilterLongAddresses(
    OUT PNDIS_STATUS            Status,
    IN  PFDDI_FILTER            Filter,
    IN  NDIS_HANDLE             NdisFilterHandle,
    IN  UINT                    SizeOfArray,
    OUT PUINT                   NumberOfAddresses,
    OUT CHAR                    AddressArray[][FDDI_LENGTH_OF_LONG_ADDRESS]
    )
/*++

Routine Description:

    The routine should be used by the MAC before
    it actually alters the hardware registers to effect a
    filtering hardware.  This is usefull if another binding
    has altered the address list since the action routine
    is called.

Arguments:

    Status - A pointer to the status of the call, NDIS_STATUS_SUCCESS or
    NDIS_STATUS_FAILURE.  Use EthNumberOfOpenAddresses() to get the
    size that is needed.

    Filter - A pointer to the filter database.

    NdisFilterHandle - Pointer to the open block

    SizeOfArray - The byte count of the AddressArray.

    NumberOfAddresses - The number of addresses written to the array.

    AddressArray - Will be filled with the addresses currently in the
    multicast address list.

Return Value:

    None.

--*/
{
    PFDDI_BINDING_INFO  BindInfo = (PFDDI_BINDING_INFO)NdisFilterHandle;
    LOCK_STATE          LockState;

    READ_LOCK_FILTER(Filter->Miniport, Filter, &LockState);

    if (SizeOfArray >= (FDDI_LENGTH_OF_LONG_ADDRESS * BindInfo->NumLongAddresses))
    {
        MoveMemory(AddressArray[0],
                   BindInfo->MCastLongAddressBuf,
                   FDDI_LENGTH_OF_LONG_ADDRESS * BindInfo->NumLongAddresses);

        *Status = NDIS_STATUS_SUCCESS;
        *NumberOfAddresses = BindInfo->NumLongAddresses;
    }
    else
    {
        *Status = NDIS_STATUS_FAILURE;
        *NumberOfAddresses = 0;
    }

    READ_UNLOCK_FILTER(Filter->Miniport, Filter, &LockState);
}


VOID
FddiQueryOpenFilterShortAddresses(
    OUT PNDIS_STATUS            Status,
    IN  PFDDI_FILTER            Filter,
    IN  NDIS_HANDLE             NdisFilterHandle,
    IN  UINT                    SizeOfArray,
    OUT PUINT                   NumberOfAddresses,
    OUT CHAR                    AddressArray[][FDDI_LENGTH_OF_SHORT_ADDRESS]
    )
/*++

Routine Description:

    The routine should be used by the MAC before
    it actually alters the hardware registers to effect a
    filtering hardware.  This is usefull if another binding
    has altered the address list since the action routine
    is called.

Arguments:

    Status - A pointer to the status of the call, NDIS_STATUS_SUCCESS or
    NDIS_STATUS_FAILURE.  Use EthNumberOfOpenAddresses() to get the
    size that is needed.

    Filter - A pointer to the filter database.

    NdisFilterHandle - Pointer to the open block

    SizeOfArray - The byte count of the AddressArray.

    NumberOfAddresses - The number of addresses written to the array.

    AddressArray - Will be filled with the addresses currently in the
    multicast address list.

Return Value:

    None.

--*/
{
    PFDDI_BINDING_INFO  BindInfo = (PFDDI_BINDING_INFO)NdisFilterHandle;
    LOCK_STATE          LockState;

    READ_LOCK_FILTER(Filter->Miniport, Filter, &LockState);
    if (SizeOfArray >= (FDDI_LENGTH_OF_LONG_ADDRESS * BindInfo->NumLongAddresses))
    {
        MoveMemory(AddressArray[0],
                   BindInfo->MCastLongAddressBuf,
                   FDDI_LENGTH_OF_SHORT_ADDRESS * BindInfo->NumLongAddresses);

        *Status = NDIS_STATUS_SUCCESS;
        *NumberOfAddresses = BindInfo->NumLongAddresses;
    }
    else
    {
        *Status = NDIS_STATUS_FAILURE;
        *NumberOfAddresses = 0;
    }

    READ_UNLOCK_FILTER(Filter->Miniport, Filter, &LockState);
}


VOID
FddiQueryGlobalFilterLongAddresses(
    OUT PNDIS_STATUS            Status,
    IN  PFDDI_FILTER            Filter,
    IN  UINT                    SizeOfArray,
    OUT PUINT                   NumberOfAddresses,
    IN  OUT CHAR                AddressArray[][FDDI_LENGTH_OF_LONG_ADDRESS]
    )
/*++

Routine Description:

    The routine should be used by the MAC before
    it actually alters the hardware registers to effect a
    filtering hardware.  This is usefull if another binding
    has altered the address list since the action routine
    is called.

Arguments:

    Status - A pointer to the status of the call, NDIS_STATUS_SUCCESS or
    NDIS_STATUS_FAILURE.  Use FDDI_NUMBER_OF_GLOBAL_LONG_ADDRESSES() to get the
    size that is needed.

    Filter - A pointer to the filter database.

    SizeOfArray - The byte count of the AddressArray.

    NumberOfAddresses - A pointer to the number of addresses written to the
    array.

    AddressArray - Will be filled with the addresses currently in the
    multicast address list.

Return Value:

    None.

--*/
{
    LOCK_STATE          LockState;

    READ_LOCK_FILTER(Filter->Miniport, Filter, &LockState);

    if (SizeOfArray < (Filter->NumLongAddresses * FDDI_LENGTH_OF_LONG_ADDRESS))
    {
        *Status = NDIS_STATUS_FAILURE;

        *NumberOfAddresses = 0;
    }
    else
    {
        *Status = NDIS_STATUS_SUCCESS;

        *NumberOfAddresses = Filter->NumLongAddresses;

        MoveMemory(AddressArray[0],
                   Filter->MCastLongAddressBuf[0],
                   Filter->NumLongAddresses*FDDI_LENGTH_OF_LONG_ADDRESS);
    }

    READ_UNLOCK_FILTER(Filter->Miniport, Filter, &LockState);
}


VOID
FddiQueryGlobalFilterShortAddresses(
    OUT PNDIS_STATUS            Status,
    IN  PFDDI_FILTER            Filter,
    IN  UINT                    SizeOfArray,
    OUT PUINT                   NumberOfAddresses,
    IN  OUT CHAR                AddressArray[][FDDI_LENGTH_OF_SHORT_ADDRESS]
    )
/*++

Routine Description:

    The routine should be used by the MAC before
    it actually alters the hardware registers to effect a
    filtering hardware.  This is usefull if another binding
    has altered the address list since the action routine
    is called.

Arguments:

    Status - A pointer to the status of the call, NDIS_STATUS_SUCCESS or
    NDIS_STATUS_FAILURE.  Use FDDI_NUMBER_OF_GLOBAL_SHORT_ADDRESSES() to get the
    size that is needed.

    Filter - A pointer to the filter database.

    SizeOfArray - The byte count of the AddressArray.

    NumberOfAddresses - A pointer to the number of addresses written to the
    array.

    AddressArray - Will be filled with the addresses currently in the
    multicast address list.

Return Value:

    None.

--*/
{
    LOCK_STATE          LockState;

    READ_LOCK_FILTER(Filter->Miniport, Filter, &LockState);

    if (SizeOfArray < (Filter->NumShortAddresses * FDDI_LENGTH_OF_SHORT_ADDRESS))
    {
        *Status = NDIS_STATUS_FAILURE;

        *NumberOfAddresses = 0;
    }
    else
    {
        *Status = NDIS_STATUS_SUCCESS;

        *NumberOfAddresses = Filter->NumShortAddresses;

        MoveMemory(AddressArray[0],
                   Filter->MCastShortAddressBuf[0],
                   Filter->NumShortAddresses*FDDI_LENGTH_OF_SHORT_ADDRESS);
    }

    READ_UNLOCK_FILTER(Filter->Miniport, Filter, &LockState);
}


NDIS_STATUS
FASTCALL
ndisMSetFddiMulticastList(
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  PNDIS_REQUEST           Request
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    NDIS_STATUS Status;
    UINT        NumberOfAddresses, AddrLen;
    BOOLEAN     fCleanup = FALSE;
    BOOLEAN     fShort;

    DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
        ("==>ndisMSetFddiMulticastList\n"));

    fShort = (Request->DATA.SET_INFORMATION.Oid == OID_FDDI_SHORT_MULTICAST_LIST);

    Request->DATA.SET_INFORMATION.BytesRead = 0;
    Request->DATA.SET_INFORMATION.BytesNeeded = 0;

    //
    //  Verify the media type.
    //
    if (Miniport->MediaType != NdisMediumFddi)
    {
        Status = NDIS_STATUS_NOT_SUPPORTED;

        DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
            ("ndisMSetFddiMulticastList: Invalid media type\n"));

        DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
            ("<==ndisMSetFddiMulticastList: 0x%x\n", Status));

        return(Status);
    }

    AddrLen = fShort ? FDDI_LENGTH_OF_SHORT_ADDRESS : FDDI_LENGTH_OF_LONG_ADDRESS;

    //
    //  Verify the information buffer length.
    //
    if ((Request->DATA.SET_INFORMATION.InformationBufferLength % AddrLen) != 0)
    {
        Status = NDIS_STATUS_INVALID_LENGTH;

        DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
            ("<==ndisMSetFddiMulticastList: 0x%x\n", Status));

        //
        // The data must be a multiple of AddrLen
        //
        return(Status);
    }

    //
    //  If this request is because of an open that is closing then we
    //  have already adjusted the settings and we just need to
    //  make sure that the adapter has the new settings.
    //
    if (MINIPORT_TEST_FLAG(PNDIS_RESERVED_FROM_PNDIS_REQUEST(Request)->Open, fMINIPORT_OPEN_CLOSING))
    {
        //
        //  By setting the Status to NDIS_STATUS_PENDING we will call
        //  down to the miniport's SetInformationHandler below.
        //
        Status = NDIS_STATUS_PENDING;
    }
    else
    {
        //
        // Now call the filter package to set up the addresses.
        //
        Status = fShort ?
                    FddiChangeFilterShortAddresses(
                             Miniport->FddiDB,
                             PNDIS_RESERVED_FROM_PNDIS_REQUEST(Request)->Open->FilterHandle,
                             Request->DATA.SET_INFORMATION.InformationBufferLength / AddrLen,
                             Request->DATA.SET_INFORMATION.InformationBuffer,
                             TRUE) :
                    FddiChangeFilterLongAddresses(
                             Miniport->FddiDB,
                             PNDIS_RESERVED_FROM_PNDIS_REQUEST(Request)->Open->FilterHandle,
                             Request->DATA.SET_INFORMATION.InformationBufferLength / AddrLen,
                             Request->DATA.SET_INFORMATION.InformationBuffer,
                             TRUE);
        if (Status == NDIS_STATUS_PENDING)
            fCleanup = TRUE;
    }

    //
    //  If the filter library returned NDIS_STATUS_PENDING then we
    //  need to call down to the miniport driver.
    //
    if (NDIS_STATUS_PENDING == Status)
    {
        //
        //  Get the number of multicast addresses and the list
        //  of multicast addresses to send to the miniport driver.
        //
        NumberOfAddresses = fShort ?
            fddiNumberOfShortGlobalAddresses(Miniport->FddiDB) :
            fddiNumberOfLongGlobalAddresses(Miniport->FddiDB);
        
        ASSERT(Miniport->SetMCastBuffer == NULL);
        if (NumberOfAddresses != 0)
        {
            Miniport->SetMCastBuffer = ALLOC_FROM_POOL(NumberOfAddresses * AddrLen,
                                                       NDIS_TAG_FILTER_ADDR);
            if (Miniport->SetMCastBuffer == NULL)
            {
                Status = NDIS_STATUS_RESOURCES;
            }
        }

        if (Status != NDIS_STATUS_RESOURCES)
        {
            fShort ?
                FddiQueryGlobalFilterShortAddresses(&Status,
                                                    Miniport->FddiDB,
                                                    NumberOfAddresses * AddrLen,
                                                    &NumberOfAddresses,
                                                    Miniport->SetMCastBuffer) :
                FddiQueryGlobalFilterLongAddresses(&Status,
                                                   Miniport->FddiDB,
                                                   NumberOfAddresses * AddrLen,
                                                   &NumberOfAddresses,
                                                   Miniport->SetMCastBuffer);
    
            //
            //  Call the miniport driver.
            //
            SAVE_REQUEST_BUF(Miniport, Request,
                             Miniport->SetMCastBuffer,
                             NumberOfAddresses * AddrLen);
            MINIPORT_SET_INFO(Miniport,
                              Request,
                              &Status);
        }
    }

    if (Status != NDIS_STATUS_PENDING)
    {
        RESTORE_REQUEST_BUF(Miniport, Request);
        if (NDIS_STATUS_SUCCESS == Status)
        {
            Request->DATA.SET_INFORMATION.BytesRead = Request->DATA.SET_INFORMATION.InformationBufferLength;
        }
        else
        {
            Request->DATA.SET_INFORMATION.BytesRead = 0;
            Request->DATA.SET_INFORMATION.BytesNeeded = 0;
        }
    
        if (Miniport->SetMCastBuffer != NULL)
        {
            FREE_POOL(Miniport->SetMCastBuffer);
            Miniport->SetMCastBuffer = NULL;
        }
    
        if (fCleanup)
        {
            fShort ?
                fddiCompleteChangeFilterShortAddresses(Miniport->FddiDB, Status) :
                fddiCompleteChangeFilterLongAddresses(Miniport->FddiDB, Status);
        }
    }

    DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
            ("<==ndisMSetFddiMulticastList: 0x%x\n", Status));

    return(Status);
}

VOID
FddiFilterDprIndicateReceive(
    IN  PFDDI_FILTER            Filter,
    IN  NDIS_HANDLE             MacReceiveContext,
    IN  PCHAR                   Address,
    IN  UINT                    AddressLength,
    IN  PVOID                   HeaderBuffer,
    IN  UINT                    HeaderBufferSize,
    IN  PVOID                   LookaheadBuffer,
    IN  UINT                    LookaheadBufferSize,
    IN  UINT                    PacketSize
    )
/*++

Routine Description:

    This routine is called by the MAC to indicate a packet to
    all bindings.  The packet will be filtered so that only the
    appropriate bindings will receive the packet.

    Called at DPC_LEVEL.

Arguments:

    Filter - Pointer to the filter database.

    MacReceiveContext - A MAC supplied context value that must be
    returned by the protocol if it calls MacTransferData.

    Address - The destination address from the received packet.

    AddressLength - The length of the above address.

    HeaderBuffer - A virtual address of the virtually contiguous
    buffer containing the MAC header of the packet.

    HeaderBufferSize - An unsigned integer indicating the size of
    the header buffer, in bytes.

    LookaheadBuffer - A virtual address of the virtually contiguous
    buffer containing the first LookaheadBufferSize bytes of data
    of the packet.  The packet buffer is valid only within the current
    call to the receive event handler.

    LookaheadBufferSize - An unsigned integer indicating the size of
    the lookahead buffer, in bytes.

    PacketSize - An unsigned integer indicating the size of the received
    packet, in bytes.  This number has nothing to do with the lookahead
    buffer, but indicates how large the arrived packet is so that a
    subsequent MacTransferData request can be made to transfer the entire
    packet as necessary.

Return Value:

    None.

--*/
{
    //
    // Will hold the type of address that we know we've got.
    //
    UINT                AddressType;

    //
    // Will hold the status of indicating the receive packet.
    // ZZZ For now this isn't used.
    //
    NDIS_STATUS         StatusOfReceive;

    LOCK_STATE          LockState;

    //
    // Current Open to indicate to.
    //
    PFDDI_BINDING_INFO  LocalOpen, NextOpen;

    //
    // Holds the result of address determinations.
    //
    INT                 ResultOfAddressCheck;

    //
    // if filter is null, the adapter is indicating too early
    //  
    if (Filter == NULL)
    {
    #if DBG
        DbgPrint("Driver is indicating packets too early\n");
        if (ndisFlags & NDIS_GFLAG_BREAK_ON_WARNING)
        {
            DbgBreakPoint();
        }
    #endif
    
        return;     
    }

    if (!MINIPORT_TEST_FLAG(Filter->Miniport, fMINIPORT_MEDIA_CONNECTED))
    {
        return;     
    }

    ASSERT_MINIPORT_LOCKED(Filter->Miniport);

    READ_LOCK_FILTER(Filter->Miniport, Filter, &LockState);

    //
    // If the packet is a runt packet, then only indicate to PROMISCUOUS
    //
    if ((HeaderBufferSize > (2 * AddressLength)) && (PacketSize != 0))
    {
        BOOLEAN fDirected;

        fDirected = FALSE;
        FDDI_IS_SMT(*((PCHAR)HeaderBuffer), &ResultOfAddressCheck);
        if (!ResultOfAddressCheck)
        {
            fDirected = (((UCHAR)Address[0] & 0x01) == 0);
        }

        //
        //  Handle the directed packet case first
        //
        if (fDirected)
        {
            BOOLEAN IsNotOurs;

            DIRECTED_PACKETS_IN(Filter->Miniport);
            DIRECTED_BYTES_IN(Filter->Miniport, PacketSize);

            //
            // If it is a directed packet, then check if the combined packet
            // filter is PROMISCUOUS, if it is check if it is directed towards
            // us. Eliminate the SMT case.
            //
            IsNotOurs = FALSE;  // Assume it is
            if (Filter->CombinedPacketFilter & (NDIS_PACKET_TYPE_PROMISCUOUS |
                                                NDIS_PACKET_TYPE_ALL_LOCAL   |
                                                NDIS_PACKET_TYPE_ALL_MULTICAST))
            {
                FDDI_COMPARE_NETWORK_ADDRESSES_EQ((AddressLength == FDDI_LENGTH_OF_LONG_ADDRESS) ?
                                                    Filter->AdapterLongAddress :
                                                    Filter->AdapterShortAddress,
                                                  Address,
                                                  AddressLength,
                                                  &IsNotOurs);
            }

            //
            //  Walk the directed list and indicate up the packets.
            //
            for (LocalOpen = Filter->OpenList;
                 LocalOpen != NULL;
                 LocalOpen = NextOpen)
            {
                //
                //  Get the next open to look at.
                //
                NextOpen = LocalOpen->NextOpen;

                //
                // Ignore if not directed to us or if the binding is not promiscuous
                //
                if (((LocalOpen->PacketFilters & NDIS_PACKET_TYPE_PROMISCUOUS) == 0) &&
                    (IsNotOurs ||
                    ((LocalOpen->PacketFilters & NDIS_PACKET_TYPE_DIRECTED) == 0)))
                {
                        continue;
                }

                //
                // Indicate the packet to the binding.
                //
                ProtocolFilterIndicateReceive(&StatusOfReceive,
                                              LocalOpen->NdisBindingHandle,
                                              MacReceiveContext,
                                              HeaderBuffer,
                                              HeaderBufferSize,
                                              LookaheadBuffer,
                                              LookaheadBufferSize,
                                              PacketSize,
                                              NdisMediumFddi);

                LocalOpen->ReceivedAPacket = TRUE;
            }

            //
            // Done for uni-cast
            //
            READ_UNLOCK_FILTER(Filter->Miniport, Filter, &LockState);
            return;
        }

        //
        // Determine whether the input address is a simple direct,
        // a broadcast, a multicast, or an SMT address.
        //
        FDDI_IS_SMT(*((PCHAR)HeaderBuffer), &ResultOfAddressCheck);
        if (ResultOfAddressCheck)
        {
            AddressType = NDIS_PACKET_TYPE_SMT;
        }
        else
        {
            //
            // First check if it *at least* has the multicast address bit.
            //
            FDDI_IS_MULTICAST(Address, AddressLength, &ResultOfAddressCheck);
            if (ResultOfAddressCheck)
            {
                //
                // It is at least a multicast address.  Check to see if
                // it is a broadcast address.
                //

                FDDI_IS_BROADCAST(Address, AddressLength, &ResultOfAddressCheck);
                if (ResultOfAddressCheck)
                {
                    FDDI_CHECK_FOR_INVALID_BROADCAST_INDICATION(Filter);

                    AddressType = NDIS_PACKET_TYPE_BROADCAST;
                }
                else
                {
                    AddressType = NDIS_PACKET_TYPE_MULTICAST;
                }
            }
        }
    }
    else
    {
        // Runt Packet
        AddressType = NDIS_PACKET_TYPE_PROMISCUOUS;
    }

    //
    // At this point we know that the packet is either:
    // - Runt packet - indicated by AddressType = NDIS_PACKET_TYPE_PROMISCUOUS    (OR)
    // - Broadcast packet - indicated by AddressType = NDIS_PACKET_TYPE_BROADCAST (OR)
    // - Multicast packet - indicated by AddressType = NDIS_PACKET_TYPE_MULTICAST
    // - SMT Packet - indicated by AddressType = NDIS_PACKET_TYPE_SMT
    //
    // Walk the broadcast/multicast/SMT list and indicate up the packets.
    //
    // The packet is indicated if it meets the following criteria:
    //
    // if ((Binding is promiscuous) OR
    //   ((Packet is broadcast) AND (Binding is Broadcast)) OR
    //   ((Packet is SMT) AND (Binding is SMT)) OR
    //   ((Packet is multicast) AND
    //    ((Binding is all-multicast) OR
    //      ((Binding is multicast) AND (address in approp. multicast list)))))
    //
    //
    //  Is this a directed packet?
    //
    for (LocalOpen = Filter->OpenList;
         LocalOpen != NULL;
         LocalOpen = NextOpen)
    {
        UINT    LocalFilter = LocalOpen->PacketFilters;

        //
        //  Get the next open to look at.
        //
        NextOpen = LocalOpen->NextOpen;

        if ((LocalFilter & (NDIS_PACKET_TYPE_PROMISCUOUS | NDIS_PACKET_TYPE_ALL_LOCAL))     ||

            ((AddressType == NDIS_PACKET_TYPE_BROADCAST)  &&
             (LocalFilter & NDIS_PACKET_TYPE_BROADCAST))        ||

            ((AddressType == NDIS_PACKET_TYPE_SMT)  &&
             (LocalFilter & NDIS_PACKET_TYPE_SMT))          ||

            ((AddressType == NDIS_PACKET_TYPE_MULTICAST)  &&
             ((LocalFilter & NDIS_PACKET_TYPE_ALL_MULTICAST) ||
              ((LocalFilter & NDIS_PACKET_TYPE_MULTICAST) &&
                (((AddressLength == FDDI_LENGTH_OF_LONG_ADDRESS) &&
                 fddiFindMulticastLongAddress(LocalOpen->NumLongAddresses,
                                              LocalOpen->MCastLongAddressBuf,
                                              Address)
                ) ||
                ((AddressLength == FDDI_LENGTH_OF_SHORT_ADDRESS) &&
                 fddiFindMulticastShortAddress(LocalOpen->NumShortAddresses,
                                               LocalOpen->MCastShortAddressBuf,
                                               Address)
                )
                )
              )
             )
            )
            )
        {
            //
            // Indicate the packet to the binding.
            //
            ProtocolFilterIndicateReceive(&StatusOfReceive,
                                          LocalOpen->NdisBindingHandle,
                                          MacReceiveContext,
                                          HeaderBuffer,
                                          HeaderBufferSize,
                                          LookaheadBuffer,
                                          LookaheadBufferSize,
                                          PacketSize,
                                          NdisMediumFddi);

            LocalOpen->ReceivedAPacket = TRUE;
        }
    }

    READ_UNLOCK_FILTER(Filter->Miniport, Filter, &LockState);
}


VOID
fddiFilterDprIndicateReceivePacket(
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  PPNDIS_PACKET           PacketArray,
    IN  UINT                    NumberOfPackets
    )
/*++

Routine Description:

    This routine is called by the Miniport to indicate packets to
    all bindings.  The packets will be filtered so that only the
    appropriate bindings will receive the individual packets.
    This is the code path for ndis 4.0 miniport drivers.

Arguments:

    Miniport - The Miniport block.

    PacketArray - An array of Packets indicated by the miniport.

    NumberOfPackets - Self-explanatory.

Return Value:

    None.

--*/
{
    //
    // The Filter of interest
    //
    PFDDI_FILTER        Filter = Miniport->FddiDB;

    //
    // Current packet being processed
    //
    PPNDIS_PACKET       pPktArray = PacketArray;
    PNDIS_PACKET        Packet;
    PNDIS_PACKET_OOB_DATA pOob;

    //
    // Pointer to the buffer in the ndispacket
    //
    PNDIS_BUFFER        Buffer;

    //
    // Total packet length
    //
    UINT                i, LASize, PacketSize, NumIndicates = 0;

    //
    // Pointer to the 1st segment of the buffer, points to dest address
    //
    PUCHAR              Address, Hdr;

    UINT                AddressLength;

    //
    // Will hold the type of address that we know we've got.
    //
    UINT                AddressType;

    //
    // Will hold the status of indicating the receive packet.
    // ZZZ For now this isn't used.
    //
    NDIS_STATUS         StatusOfReceive;

    LOCK_STATE          LockState;

    //
    //  Decides whether we use the protocol's revpkt handler or fall
    //  back to old rcvindicate handler
    //
    BOOLEAN             fFallBack, fPmode;

    //
    // Current Open to indicate to.
    //
    PFDDI_BINDING_INFO  LocalOpen, NextOpen;
    PNDIS_OPEN_BLOCK    pOpenBlock;
    PNDIS_STACK_RESERVED NSR;

#ifdef TRACK_RECEIVED_PACKETS
    ULONG               OrgPacketStackLocation;
    PETHREAD            CurThread = PsGetCurrentThread();
#endif

    //
    // Holds the result of address determinations.
    //
    INT                 ResultOfAddressCheck;

    ASSERT_MINIPORT_LOCKED(Miniport);

    READ_LOCK_FILTER(Miniport, Filter, &LockState);

    //
    // Walk all the packets
    //
    for (i = 0; i < NumberOfPackets; i++, pPktArray++)
    {
        do
        {
            Packet = *pPktArray;
            ASSERT(Packet != NULL);
#ifdef TRACK_RECEIVED_PACKETS
            OrgPacketStackLocation = CURR_STACK_LOCATION(Packet);
#endif
            PUSH_PACKET_STACK(Packet);
            NDIS_STACK_RESERVED_FROM_PACKET(Packet, &NSR)

            ASSERT(NSR->RefCount == 0);
            if (NSR->RefCount != 0)
            {
                BAD_MINIPORT(Miniport, "Indicating packet not owned by it");
                KeBugCheckEx(BUGCODE_ID_DRIVER,
                             (ULONG_PTR)Miniport,
                             (ULONG_PTR)Packet,
                             (ULONG_PTR)PacketArray,
                             NumberOfPackets);
            }
    
            pOob = NDIS_OOB_DATA_FROM_PACKET(Packet);
    
            NdisGetFirstBufferFromPacket(Packet,
                                         &Buffer,
                                         &Address,
                                         &LASize,
                                         &PacketSize);
            ASSERT(Buffer != NULL);
    
            Hdr = Address++;
    
            AddressLength = (*Hdr & 0x40) ?
                                    FDDI_LENGTH_OF_LONG_ADDRESS :
                                    FDDI_LENGTH_OF_SHORT_ADDRESS;
            ASSERT(pOob->HeaderSize == (AddressLength * 2 + 1));
    
            //
            // Set context in the packet so that NdisReturnPacket can do the right thing
            //
            NDIS_INITIALIZE_RCVD_PACKET(Packet, NSR, Miniport);
    
            //
            // Set the status here that nobody is holding the packet. This will get
            // overwritten by the real status from the protocol. Pay heed to what
            // the miniport is saying.
            //
            if ((pOob->Status != NDIS_STATUS_RESOURCES) &&
                !MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_SYSTEM_SLEEPING))
            {
                pOob->Status = NDIS_STATUS_SUCCESS;
                fFallBack = FALSE;
            }
            else
            {
#if DBG
                if ((pOob->Status != NDIS_STATUS_RESOURCES) &&
                    MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_SYSTEM_SLEEPING))
                {
                    DBGPRINT(DBG_COMP_FILTER, DBG_LEVEL_ERR,
                            ("Miniport going into D3, not indicating chained receives\n"));
                }
#endif
                fFallBack = TRUE;
            }
    
            //
            // A quick check for Runt packets. These are only indicated to Promiscuous bindings
            //
            if (PacketSize > pOob->HeaderSize)
            {
                BOOLEAN fDirected;
    
                fDirected = FALSE;
                FDDI_IS_SMT(*Address, &ResultOfAddressCheck);
                if (!ResultOfAddressCheck)
                {
                    fDirected = (((UCHAR)Address[0] & 0x01) == 0);
                }
    
                //
                //  Handle the directed packet case first
                //
                if (fDirected)
                {
                    BOOLEAN IsNotOurs;
    
                    if (!MINIPORT_TEST_PACKET_FLAG(Packet, fPACKET_IS_LOOPBACK))
                    {
                        DIRECTED_PACKETS_IN(Filter->Miniport);
                        DIRECTED_BYTES_IN(Filter->Miniport, PacketSize);
                    }

                    //
                    // If it is a directed packet, then check if the combined packet
                    // filter is PROMISCUOUS, if it is check if it is directed towards
                    // us. Eliminate the SMT case.
                    //
                    IsNotOurs = FALSE;  // Assume it is
                    if (Filter->CombinedPacketFilter & (NDIS_PACKET_TYPE_PROMISCUOUS |
                                                        NDIS_PACKET_TYPE_ALL_LOCAL   |
                                                        NDIS_PACKET_TYPE_ALL_MULTICAST))
                    {
                        FDDI_COMPARE_NETWORK_ADDRESSES_EQ((AddressLength == FDDI_LENGTH_OF_LONG_ADDRESS) ?
                                                            Filter->AdapterLongAddress :
                                                            Filter->AdapterShortAddress,
                                                          Address,
                                                          AddressLength,
                                                          &IsNotOurs);
                    }
    
                    //
                    //  We definitely have a directed packet so lets indicate it now.
                    //
                    //  Walk the directed list and indicate up the packets.
                    //
                    for (LocalOpen = Filter->OpenList;
                         LocalOpen != NULL;
                         LocalOpen = NextOpen)
                    {
                        //
                        //  Get the next open to look at.
                        //
                        NextOpen = LocalOpen->NextOpen;
    
                        //
                        // Ignore if not directed to us and if the binding is not promiscuous
                        // Or if this is a loopback packet and this protocol specifically asked
                        // us not to loop it back
                        //
                        fPmode = (LocalOpen->PacketFilters & (NDIS_PACKET_TYPE_PROMISCUOUS | NDIS_PACKET_TYPE_ALL_LOCAL)) ?
                                                            TRUE : FALSE;

                        
                        if (!fPmode &&
                            (IsNotOurs || 
                            ((LocalOpen->PacketFilters & NDIS_PACKET_TYPE_DIRECTED) == 0)))
                        {
                                
                            continue;
                        }
    
                        //
                        // Ignore if this is a loopback packet and this protocol specifically asked
                        // us not to loop it back
                        //
                        if ((NdisGetPacketFlags(Packet) & NDIS_FLAGS_DONT_LOOPBACK) &&
                            (LOOPBACK_OPEN_IN_PACKET(Packet) == LocalOpen->NdisBindingHandle))
                        {
                            continue;
                        }
    
                        pOpenBlock = (PNDIS_OPEN_BLOCK)(LocalOpen->NdisBindingHandle);
                        LocalOpen->ReceivedAPacket = TRUE;
                        NumIndicates ++;
                        
                        IndicateToProtocol(Miniport,
                                           Filter,
                                           pOpenBlock,
                                           Packet,
                                           NSR,
                                           Hdr,
                                           PacketSize,
                                           pOob->HeaderSize,
                                           &fFallBack,
                                           fPmode,
                                           NdisMediumFddi);
                    }
    
                    // Done with this packet
                    break;  // out of do { } while (FALSE);
                }
    
                //
                // Determine whether the input address is a simple direct,
                // a broadcast, a multicast, or an SMT address.
                //
                FDDI_IS_SMT(*Address, &ResultOfAddressCheck);
                if (ResultOfAddressCheck)
                {
                    AddressType = NDIS_PACKET_TYPE_SMT;
                }
                else
                {
                    //
                    // First check if it *at least* has the multicast address bit.
                    //
                    FDDI_IS_MULTICAST(Address, AddressLength, &ResultOfAddressCheck);
                    if (ResultOfAddressCheck)
                    {
                        //
                        // It is at least a multicast address.  Check to see if
                        // it is a broadcast address.
                        //
    
                        FDDI_IS_BROADCAST(Address, AddressLength, &ResultOfAddressCheck);
                        if (ResultOfAddressCheck)
                        {
                            FDDI_CHECK_FOR_INVALID_BROADCAST_INDICATION(Filter);
    
                            AddressType = NDIS_PACKET_TYPE_BROADCAST;
                        }
                        else
                        {
                            AddressType = NDIS_PACKET_TYPE_MULTICAST;
                        }
                    }
                }
            }
            else
            {
                // Runt Packet
                AddressType = NDIS_PACKET_TYPE_PROMISCUOUS;
            }
    
            //
            // At this point we know that the packet is either:
            // - Runt packet - indicated by AddressType = NDIS_PACKET_TYPE_PROMISCUOUS    (OR)
            // - Broadcast packet - indicated by AddressType = NDIS_PACKET_TYPE_BROADCAST (OR)
            // - Multicast packet - indicated by AddressType = NDIS_PACKET_TYPE_MULTICAST
            // - SMT Packet - indicated by AddressType = NDIS_PACKET_TYPE_SMT
            //
            // Walk the broadcast/multicast/SMT list and indicate up the packets.
            //
            // The packet is indicated if it meets the following criteria:
            //
            // if ((Binding is promiscuous) OR
            //   ((Packet is broadcast) AND (Binding is Broadcast)) OR
            //   ((Packet is SMT) AND (Binding is SMT)) OR
            //   ((Packet is multicast) AND
            //    ((Binding is all-multicast) OR
            //      ((Binding is multicast) AND (address in approp. multicast list)))))
            //
            //
            //  Is this a directed packet?
            //
            for (LocalOpen = Filter->OpenList;
                 LocalOpen != NULL;
                 LocalOpen = NextOpen)
            {
                UINT    LocalFilter;
                UINT    IndexOfAddress;
    
                //
                //  Get the next open to look at.
                //
                NextOpen = LocalOpen->NextOpen;
    
                //
                // Ignore if this is a loopback packet and this protocol specifically asked
                // us not to loop it back
                //
                if ((NdisGetPacketFlags(Packet) & NDIS_FLAGS_DONT_LOOPBACK) &&
                    (LOOPBACK_OPEN_IN_PACKET(Packet) == LocalOpen->NdisBindingHandle))
                {
                    continue;
                }
    
                LocalFilter = LocalOpen->PacketFilters;
                if ((LocalFilter & (NDIS_PACKET_TYPE_PROMISCUOUS | NDIS_PACKET_TYPE_ALL_LOCAL))     ||
    
                    ((AddressType == NDIS_PACKET_TYPE_BROADCAST)  &&
                     (LocalFilter & NDIS_PACKET_TYPE_BROADCAST))        ||
    
                    ((AddressType == NDIS_PACKET_TYPE_SMT)  &&
                     (LocalFilter & NDIS_PACKET_TYPE_SMT))          ||
    
                    ((AddressType == NDIS_PACKET_TYPE_MULTICAST)  &&
                     ((LocalFilter & NDIS_PACKET_TYPE_ALL_MULTICAST) ||
                      ((LocalFilter & NDIS_PACKET_TYPE_MULTICAST) &&
                        (((AddressLength == FDDI_LENGTH_OF_LONG_ADDRESS) &&
                         fddiFindMulticastLongAddress(LocalOpen->NumLongAddresses,
                                                      LocalOpen->MCastLongAddressBuf,
                                                      Address)
                        ) ||
                        ((AddressLength == FDDI_LENGTH_OF_SHORT_ADDRESS) &&
                         fddiFindMulticastShortAddress(LocalOpen->NumShortAddresses,
                                                       LocalOpen->MCastShortAddressBuf,
                                                       Address)
                        )
                        )
                      )
                     )
                    )
                    )
                {
                    pOpenBlock = (PNDIS_OPEN_BLOCK)(LocalOpen->NdisBindingHandle);
                    LocalOpen->ReceivedAPacket = TRUE;
                    NumIndicates ++;
    
                    fPmode = (LocalFilter & (NDIS_PACKET_TYPE_PROMISCUOUS | NDIS_PACKET_TYPE_ALL_LOCAL)) ?
                                TRUE : FALSE;
                    
                    IndicateToProtocol(Miniport,
                                       Filter,
                                       pOpenBlock,
                                       Packet,
                                       NSR,
                                       Hdr,
                                       PacketSize,
                                       pOob->HeaderSize,
                                       &fFallBack,
                                       fPmode,
                                       NdisMediumFddi);
                }
            }
        } while (FALSE);

        //
        // Tackle refcounts now
        //
        TACKLE_REF_COUNT(Miniport, Packet, NSR, pOob);
    }

    if (NumIndicates > 0)
    {
        for (LocalOpen = Filter->OpenList;
             LocalOpen != NULL;
             LocalOpen = NextOpen)
        {
            NextOpen = LocalOpen->NextOpen;
    
            if (LocalOpen->ReceivedAPacket)
            {
                //
                // Indicate the binding.
                //
                LocalOpen->ReceivedAPacket = FALSE;
    
                FilterIndicateReceiveComplete(LocalOpen->NdisBindingHandle);
            }
        }
    }

    READ_UNLOCK_FILTER(Miniport, Filter, &LockState);
}


VOID
FddiFilterDprIndicateReceiveComplete(
    IN  PFDDI_FILTER            Filter
    )
/*++

Routine Description:

    This routine is called by the MAC to indicate that the receive
    process is complete to all bindings.  Only those bindings which
    have received packets will be notified.

    Called at DPC_LEVEL.

Arguments:

    Filter - Pointer to the filter database.

Return Value:

    None.

--*/
{
    PFDDI_BINDING_INFO  LocalOpen, NextOpen;
    LOCK_STATE          LockState;

    ASSERT_MINIPORT_LOCKED(Filter->Miniport);

    READ_LOCK_FILTER(Filter->Miniport, Filter, &LockState);

    //
    // We need to aquire the filter exclusively while we're finding
    // bindings to indicate to.
    //
    for (LocalOpen = Filter->OpenList;
         LocalOpen != NULL;
         LocalOpen = NextOpen)
    {
        NextOpen = LocalOpen->NextOpen;

        if (LocalOpen->ReceivedAPacket)
        {
            //
            // Indicate the binding.
            //
            LocalOpen->ReceivedAPacket = FALSE;

            FilterIndicateReceiveComplete(LocalOpen->NdisBindingHandle);
        }
    }

    READ_UNLOCK_FILTER(Filter->Miniport, Filter, &LockState);
}


BOOLEAN
FASTCALL
fddiFindMulticastLongAddress(
    IN  UINT                    NumberOfAddresses,
    IN  CHAR                    AddressArray[][FDDI_LENGTH_OF_LONG_ADDRESS],
    IN  CHAR                    MulticastAddress[FDDI_LENGTH_OF_LONG_ADDRESS]
    )
/*++

Routine Description:

    Given an array of multicast addresses search the array for
    a particular multicast address.  It is assumed that the
    address array is already sorted.

    NOTE: THIS ROUTINE ASSUMES THAT THE LOCK IS HELD.

    NOTE: This ordering is arbitrary but consistant.

Arguments:

    NumberOfAddresses - The number of addresses currently in the
    address array.

    AddressArray - An array of multicast addresses.

    MulticastAddress - The address to search for in the address array.

Return Value:

    If the address is in the sorted list this routine will return
    TRUE, otherwise FALSE.

--*/
{

    //
    // Indices into the address array so that we may do a binary
    // search.
    //
    UINT Bottom = 0;
    UINT Middle = NumberOfAddresses / 2;
    UINT Top;

    if (NumberOfAddresses)
    {
        Top = NumberOfAddresses - 1;

        while ((Middle <= Top) && (Middle >= Bottom))
        {
            //
            // The result of comparing an element of the address
            // array and the multicast address.
            //
            // Result < 0 Implies the multicast address is greater.
            // Result > 0 Implies the address array element is greater.
            // Result = 0 Implies that the array element and the address
            //  are equal.
            //
            INT Result;

            FDDI_COMPARE_NETWORK_ADDRESSES(AddressArray[Middle],
                                           MulticastAddress,
                                           FDDI_LENGTH_OF_LONG_ADDRESS,
                                           &Result);
            if (Result == 0)
            {
                return(TRUE);
            }
            else if (Result > 0)
            {
                if (Middle == 0)
                    break;
                Top = Middle - 1;
            }
            else
            {
                Bottom = Middle+1;
            }

            Middle = Bottom + (((Top+1) - Bottom)/2);
        }
    }

    return(FALSE);
}


BOOLEAN
FASTCALL
fddiFindMulticastShortAddress(
    IN  UINT                    NumberOfAddresses,
    IN  CHAR                    AddressArray[][FDDI_LENGTH_OF_SHORT_ADDRESS],
    IN  CHAR                    MulticastAddress[FDDI_LENGTH_OF_SHORT_ADDRESS]
    )
/*++

Routine Description:

    Given an array of multicast addresses search the array for
    a particular multicast address.  It is assumed that the
    address array is already sorted.

    NOTE: THIS ROUTINE ASSUMES THAT THE LOCK IS HELD.

    NOTE: This ordering is arbitrary but consistant.

Arguments:

    NumberOfAddresses - The number of addresses currently in the
    address array.

    AddressArray - An array of multicast addresses.

    MulticastAddress - The address to search for in the address array.

Return Value:

    If the address is in the sorted list this routine will return
    TRUE, otherwise FALSE.

--*/
{
    //
    // Indices into the address array so that we may do a binary
    // search.
    //
    UINT    Bottom = 0;
    UINT    Middle = NumberOfAddresses / 2;
    UINT    Top;

    if (NumberOfAddresses)
    {
        Top = NumberOfAddresses - 1;

        while ((Middle <= Top) && (Middle >= Bottom))
        {
            //
            // The result of comparing an element of the address
            // array and the multicast address.
            //
            // Result < 0 Implies the multicast address is greater.
            // Result > 0 Implies the address array element is greater.
            // Result = 0 Implies that the array element and the address
            //  are equal.
            //
            INT Result;

            FDDI_COMPARE_NETWORK_ADDRESSES(AddressArray[Middle],
                                           MulticastAddress,
                                           FDDI_LENGTH_OF_SHORT_ADDRESS,
                                           &Result);
            if (Result == 0)
            {
                return(TRUE);
            }
            else if (Result > 0)
            {
                if (Middle == 0)
                    break;
                Top = Middle - 1;
            }
            else
            {
                Bottom = Middle+1;
            }

            Middle = Bottom + (((Top+1) - Bottom)/2);
        }
    }

    return(FALSE);
}


BOOLEAN
FddiShouldAddressLoopBack(
    IN  PFDDI_FILTER            Filter,
    IN  CHAR                    Address[],
    IN  UINT                    AddressLength
    )
/*++

Routine Description:

    Do a quick check to see whether the input address should
    loopback.

    NOTE: THIS ROUTINE ASSUMES THAT THE LOCK IS HELD.

    NOTE: THIS ROUTINE DOES NOT CHECK THE SPECIAL CASE OF SOURCE
    EQUALS DESTINATION.

Arguments:

    Filter - Pointer to the filter database.

    Address - A network address to check for loopback.

    AddressLength - Length of the above address in bytes.

Return Value:

    Returns TRUE if the address needs to be loopback.  It
    will return FALSE if there is *no* chance that the address would
    require loopback.

--*/
{
    BOOLEAN fLoopback, fSelfDirected;

    FddiShouldAddressLoopBackMacro(Filter, Address, AddressLength, &fLoopback, &fSelfDirected);
    return(fLoopback);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ndis\sys\fsbpool.c ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    fsbpool.c

Abstract:

    This file contains the implementation of fixed-size block pool.

Author:

    Shaun Cox (shaunco) 10-Dec-1999

--*/

#include "precomp.h"

#define FSB_SCAVENGE_PERIOD_IN_SECONDS          30
#define FSB_MINIMUM_PAGE_LIFETIME_IN_SECONDS    20

#if defined (_WIN64)
#define APPROX_L2_CACHE_LINE_SIZE   128
#else
#define APPROX_L2_CACHE_LINE_SIZE   64
#endif

// The following structures are used in the single allocation that
// a pool handle points to.
//      PoolHandle ---> [FSB_POOL_HEADER + FSB_CPU_POOL_HEADER for cpu 0 +
//                                         FSB_CPU_POOL_HEADER for cpu 1 + ...
//                                         FSB_CPU_POOL_HEADER for cpu N]
//

// FSB_POOL_HEADER is the data common to all CPUs for a given pool.
//
typedef struct _FSB_POOL_HEADER
{
// cache-line -----
    struct _FSB_POOL_HEADER_BASE
    {
        ULONG                   Tag;
        USHORT                  CallerBlockSize;    // caller's requested block size
        USHORT                  AlignedBlockSize;   // ALIGN_UP(CallerBlockSize, PVOID)
        USHORT                  BlocksPerPage;
        USHORT                  FreeBlockLinkOffset;
        NDIS_BLOCK_INITIALIZER  BuildFunction;
        KSPIN_LOCK              Interlock;
    };
    UCHAR Alignment[APPROX_L2_CACHE_LINE_SIZE
            - (sizeof(struct _FSB_POOL_HEADER_BASE) % APPROX_L2_CACHE_LINE_SIZE)];
} FSB_POOL_HEADER, *PFSB_POOL_HEADER;

C_ASSERT(sizeof(FSB_POOL_HEADER) % APPROX_L2_CACHE_LINE_SIZE == 0);


// FSB_CPU_POOL_HEADER is the data specific to a CPU for a given pool.
//
typedef struct _FSB_CPU_POOL_HEADER
{
// cache-line -----
    struct _FSB_CPU_POOL_HEADER_BASE
    {
        // The doubly-linked list of pages that make up this processor's pool.
        // These pages have one or more free blocks available.
        //
        LIST_ENTRY              PageList;
    
        // The doubly-linked list of pages that are fully in use.  This list
        // is separate from the above list so that we do not spend time walking
        // a very long list during FsbAllocate when many pages are fully used.
        //
        LIST_ENTRY              UsedPageList;
    
        // The next scheduled time (in units of KeQueryTickCount()) for
        // scavenging this pool.  The next scavenge will happen no earlier
        // that this.
        //
        LARGE_INTEGER           NextScavengeTick;
    
        // The number of the processor that owns this pool.
        //
        ULONG                   OwnerCpu;
    
        ULONG                   TotalBlocksAllocated;
        ULONG                   TotalBlocksFreed;
        ULONG                   PeakBlocksInUse;
        ULONG                   TotalPagesAllocated;
        ULONG                   TotalPagesFreed;
        ULONG                   PeakPagesInUse;
    };
    UCHAR Alignment[APPROX_L2_CACHE_LINE_SIZE
            - (sizeof(struct _FSB_CPU_POOL_HEADER_BASE) % APPROX_L2_CACHE_LINE_SIZE)];
} FSB_CPU_POOL_HEADER, *PFSB_CPU_POOL_HEADER;

C_ASSERT(sizeof(FSB_CPU_POOL_HEADER) % APPROX_L2_CACHE_LINE_SIZE == 0);



// FSB_PAGE_HEADER is the data at the beginning of each allocated pool page
// that describes the current state of the blocks on the page.
//
typedef struct _FSB_PAGE_HEADER
{
// cache-line -----
    // Back pointer to the owning cpu pool.
    //
    PFSB_CPU_POOL_HEADER    Pool;

    // Linkage entry for the list of pages managed by the cpu pool.
    //
    LIST_ENTRY              PageLink;

    // Number of blocks built so far on this page.  Blocks are built on
    // demand.  When this number reaches Pool->BlocksPerPage, all blocks on
    // this page have been built.
    //
    USHORT                  BlocksBuilt;

    // Boolean indicator of whether or not this page is on the cpu pool's
    // used-page list.  This is checked during MdpFree to see if the page
    // should be moved back to the normal page list.
    // (it is a USHORT, instead of BOOLEAN, for proper padding)
    //
    USHORT                  OnUsedPageList;

    // List of free blocks on this page.
    //
    SLIST_HEADER            FreeList;

    // The value of KeQueryTickCount (normalized to units of seconds)
    // which represents the time after which this page can be freed back
    // to the system's pool.  This time is only valid if the depth of
    // FreeList is Pool->BlocksPerPage.  (i.e. this time is only valid if
    // the page is completely unused.)
    //
    LARGE_INTEGER           LastUsedTick;

} FSB_PAGE_HEADER, *PFSB_PAGE_HEADER;

// Get a pointer to the overall pool given a pointer to one of
// the per-processor pools within it.
//
__inline
PFSB_POOL_HEADER
PoolFromCpuPool(
    IN PFSB_CPU_POOL_HEADER CpuPool
    )
{
    return (PFSB_POOL_HEADER)(CpuPool - CpuPool->OwnerCpu) - 1;
}


__inline
VOID
ConvertSecondsToTicks(
    IN  ULONG                   Seconds,
    OUT PLARGE_INTEGER          Ticks
    )
{
    // If the following assert fires, you need to cast Seconds below to
    // ULONGLONG so that 64 bit multiplication and division are used.
    // The current code assumes less than 430 seconds so that the
    // 32 multiplication below won't overflow.
    //
    ASSERT(Seconds < 430);

    Ticks->HighPart = 0;
    Ticks->LowPart = (Seconds * 10*1000*1000) / KeQueryTimeIncrement();
}

// Build the next block on the specified pool page.
// This can only be called if not all of the blocks have been built yet.
//
PUCHAR
FsbpBuildNextBlock(
    IN  const FSB_POOL_HEADER*  Pool,
    IN  OUT PFSB_PAGE_HEADER    Page
    )
{
    PUCHAR Block;

    ASSERT(Page->BlocksBuilt < Pool->BlocksPerPage);
    ASSERT((PAGE_SIZE - sizeof(FSB_PAGE_HEADER)) / Pool->AlignedBlockSize
                == Pool->BlocksPerPage);
    ASSERT(Pool->CallerBlockSize <= Pool->AlignedBlockSize);

    Block = (PUCHAR)(Page + 1) + (Page->BlocksBuilt * Pool->AlignedBlockSize);
    ASSERT(PAGE_ALIGN(Block) == Page);

    if (Pool->BuildFunction) {
        Pool->BuildFunction(Block, Pool->CallerBlockSize);
    }

    Page->BlocksBuilt++;

    return Block;
}

// Allocate a new pool page and insert it at the head of the specified
// CPU pool.  Build the first block on the new page and return a pointer
// to it.
//
PUCHAR
FsbpAllocateNewPageAndBuildOneBlock(
    IN const FSB_POOL_HEADER*   Pool,
    IN PFSB_CPU_POOL_HEADER     CpuPool
    )
{
    PFSB_PAGE_HEADER Page;
    PUCHAR Block = NULL;
    ULONG PagesInUse;

    ASSERT(Pool);

    Page = ExAllocatePoolWithTag(NonPagedPool, PAGE_SIZE, Pool->Tag);
    if (Page)
    {
        ASSERT(Page == PAGE_ALIGN(Page));

        RtlZeroMemory(Page, sizeof(FSB_PAGE_HEADER));
        Page->Pool = CpuPool;
        ExInitializeSListHead(&Page->FreeList);

        // Insert the page at the head of the cpu's pool.
        //
        InsertHeadList(&CpuPool->PageList, &Page->PageLink);
        CpuPool->TotalPagesAllocated++;

        // Update the pool's statistics.
        //
        PagesInUse = CpuPool->TotalPagesAllocated - CpuPool->TotalPagesFreed;
        if (PagesInUse > CpuPool->PeakPagesInUse)
        {
            CpuPool->PeakPagesInUse = PagesInUse;
        }

        Block = FsbpBuildNextBlock(Pool, Page);
        ASSERT(Block);
    }

    return Block;
}

// Free the specified pool page back to the system's pool.
//
VOID
FsbpFreePage(
    IN PFSB_CPU_POOL_HEADER CpuPool,
    IN PFSB_PAGE_HEADER Page
    )
{
    ASSERT(Page == PAGE_ALIGN(Page));
    ASSERT(Page->Pool == CpuPool);

    ExFreePool(Page);
    CpuPool->TotalPagesFreed++;

    ASSERT(CpuPool->TotalPagesFreed <= CpuPool->TotalPagesAllocated);
}

// Reclaim the memory consumed by completely unused pool pages belonging
// to the specified per-processor pool.
//
// Caller IRQL: [DISPATCH_LEVEL]
//
VOID
FsbpScavengePool(
    IN OUT PFSB_CPU_POOL_HEADER CpuPool
    )
{
    PFSB_POOL_HEADER    Pool;
    PFSB_PAGE_HEADER    Page;
    PLIST_ENTRY         Scan;
    PLIST_ENTRY         Next;
    LARGE_INTEGER       Ticks;
    LARGE_INTEGER       TicksDelta;

    // We must not only be at DISPATCH_LEVEL (or higher), we must also
    // be called on the processor that owns the specified pool.
    //
    ASSERT(KeGetCurrentIrql() >= DISPATCH_LEVEL);
    ASSERT((ULONG)KeGetCurrentProcessorNumber() == CpuPool->OwnerCpu);

    Pool = PoolFromCpuPool(CpuPool);

    KeQueryTickCount(&Ticks);

    // Compute the next tick value which represents the earliest time
    // that we will scavenge this pool again.
    //
    ConvertSecondsToTicks(FSB_SCAVENGE_PERIOD_IN_SECONDS, &TicksDelta);
    CpuPool->NextScavengeTick.QuadPart = Ticks.QuadPart + TicksDelta.QuadPart;

    // Compute the tick value which represents the last point at which
    // its okay to free a page.
    //
    ConvertSecondsToTicks(FSB_MINIMUM_PAGE_LIFETIME_IN_SECONDS, &TicksDelta);
    Ticks.QuadPart = Ticks.QuadPart - TicksDelta.QuadPart;

    for (Scan = CpuPool->PageList.Flink;
         Scan != &CpuPool->PageList;
         Scan = Next)
    {
        Page = CONTAINING_RECORD(Scan, FSB_PAGE_HEADER, PageLink);
        ASSERT(Page == PAGE_ALIGN(Page));
        ASSERT(CpuPool == Page->Pool);
        ASSERT(!Page->OnUsedPageList);

        // Step to the next link before we possibly unlink this page.
        //
        Next = Scan->Flink;

        if ((Pool->BlocksPerPage == ExQueryDepthSList(&Page->FreeList)) &&
            (Ticks.QuadPart > Page->LastUsedTick.QuadPart))
        {
            RemoveEntryList(Scan);

            FsbpFreePage(CpuPool, Page);
        }
    }

    // Scan the used pages to see if they can be moved back to the normal
    // list.  This can happen if too many frees by non-owning processors
    // are done.  In that case, the pages get orphaned on the used-page
    // list after all of their MDLs have been freed to the page.  Un-orhpan
    // them here.
    //
    for (Scan = CpuPool->UsedPageList.Flink;
         Scan != &CpuPool->UsedPageList;
         Scan = Next)
    {
        Page = CONTAINING_RECORD(Scan, FSB_PAGE_HEADER, PageLink);
        ASSERT(Page == PAGE_ALIGN(Page));
        ASSERT(CpuPool == Page->Pool);
        ASSERT(Page->OnUsedPageList);

        // Step to the next link before we possibly unlink this page.
        Next = Scan->Flink;

        if (0 != ExQueryDepthSList(&Page->FreeList))
        {
            RemoveEntryList(Scan);
            Page->OnUsedPageList = FALSE;
            InsertTailList(&CpuPool->PageList, Scan);
        }
    }
}


// Creates a pool of fixed-size blocks built over non-paged pool.  Each
// block is BlockSize bytes long.  If NULL is not returned,
// FsbDestroyPool should be called at a later time to reclaim the
// resources used by the pool.
//
// Arguments:
//  BlockSize - The size, in bytes, of each block.
//  FreeBlockLinkOffset - The offset, in bytes, from the beginning of a block
//    that represenets a pointer-sized storage location that the pool can
//    use to chain free blocks together.  Most often this will be zero
//    (meaning use the first pointer-size bytes of the block.)
//  Tag - The pool tag to be used internally for calls to
//    ExAllocatePoolWithTag.  This allows callers to track
//    memory consumption for different pools.
//  BuildFunction - An optional pointer to a function which initializes
//    blocks when they are first allocated by the pool.  This allows the
//    caller to perform custom, on-demand initialization of each block.
//
//  Returns the handle used to identify the pool.
//
// Caller IRQL: [PASSIVE_LEVEL, DISPATCH_LEVEL]
//
HANDLE
FsbCreatePool(
    IN  USHORT                  BlockSize,
    IN  USHORT                  FreeBlockLinkOffset,
    IN  ULONG                   Tag,
    IN  NDIS_BLOCK_INITIALIZER  BuildFunction OPTIONAL
    )
{
    SIZE_T              Size;
    PFSB_POOL_HEADER    Pool;
    PFSB_CPU_POOL_HEADER CpuPool;
    CCHAR               NumberCpus = KeNumberProcessors;
    CCHAR               i;

    // We need at least a pointer size worth of space to manage free
    // blocks and we don't impose any per-block overhead, so we borrow it
    // from the block itself.
    //
    ASSERT(BlockSize >= FreeBlockLinkOffset + sizeof(PVOID));

    // This implementation shouldn't be used if we are not going to get more
    // than about 8 blocks per page.  Blocks bigger than this should probably
    // be allocated with multiple pages at a time.
    //
    ASSERT(BlockSize < PAGE_SIZE / 8);

    // Compute the size of our pool header allocation.
    //
    Size = sizeof(FSB_POOL_HEADER) + (sizeof(FSB_CPU_POOL_HEADER) * NumberCpus);

    // Allocate the pool header.
    //
    Pool = ExAllocatePoolWithTag(NonPagedPool, Size, ' bsF');

    if (Pool)
    {
        // Initialize the pool header fields.
        //
        RtlZeroMemory(Pool, Size);
        Pool->Tag = Tag;
        Pool->CallerBlockSize = BlockSize;
        Pool->AlignedBlockSize = (USHORT)ALIGN_UP(BlockSize, PVOID);
        Pool->BlocksPerPage = (PAGE_SIZE - sizeof(FSB_PAGE_HEADER))
                                    / Pool->AlignedBlockSize;
        Pool->FreeBlockLinkOffset = FreeBlockLinkOffset;
        Pool->BuildFunction = BuildFunction;
        KeInitializeSpinLock(&Pool->Interlock);

        // Initialize the per-cpu pool headers.
        //
        CpuPool = (PFSB_CPU_POOL_HEADER)(Pool + 1);

        for (i = 0; i < NumberCpus; i++)
        {
            InitializeListHead(&CpuPool[i].PageList);
            InitializeListHead(&CpuPool[i].UsedPageList);
            CpuPool[i].OwnerCpu = i;
        }
    }

    return Pool;
}

// Destroys a pool of fixed-size blocks previously created by a call to
// FsbCreatePool.
//
// Arguments:
//  PoolHandle - Handle which identifies the pool being destroyed.
//
// Caller IRQL: [PASSIVE_LEVEL, DISPATCH_LEVEL]
//
VOID
FsbDestroyPool(
    IN HANDLE           PoolHandle
    )
{
    PFSB_POOL_HEADER    Pool;
    PFSB_PAGE_HEADER    Page;
    PFSB_CPU_POOL_HEADER CpuPool;
    PLIST_ENTRY         Scan;
    PLIST_ENTRY         Next;
    CCHAR               NumberCpus = KeNumberProcessors;
    CCHAR               i;

    Pool = (PFSB_POOL_HEADER)PoolHandle;
    if (!Pool)
    {
        return;
    }

    for (i = 0, CpuPool = (PFSB_CPU_POOL_HEADER)(Pool + 1);
         i < NumberCpus;
         i++, CpuPool++)
    {
        ASSERT(CpuPool->OwnerCpu == (ULONG)i);

        for (Scan = CpuPool->PageList.Flink;
             Scan != &CpuPool->PageList;
             Scan = Next)
        {
            Page = CONTAINING_RECORD(Scan, FSB_PAGE_HEADER, PageLink);
            ASSERT(Page == PAGE_ALIGN(Page));
            ASSERT(CpuPool == Page->Pool);
            ASSERT(!Page->OnUsedPageList);

            ASSERT(Page->BlocksBuilt <= Pool->BlocksPerPage);
            ASSERT(Page->BlocksBuilt == ExQueryDepthSList(&Page->FreeList));

            // Step to the next link before we free this page.
            //
            Next = Scan->Flink;

            RemoveEntryList(Scan);
            FsbpFreePage(CpuPool, Page);
        }

        ASSERT(IsListEmpty(&CpuPool->UsedPageList));
        ASSERT(CpuPool->TotalPagesAllocated == CpuPool->TotalPagesFreed);
        ASSERT(CpuPool->TotalBlocksAllocated == CpuPool->TotalBlocksFreed);
    }
}

// Returns a pointer to a block allocated from a pool.  NULL is returned if
// the request could not be granted.  The returned pointer is guaranteed to
// have 8 byte alignment.
//
// Arguments:
//  PoolHandle - Handle which identifies the pool being allocated from.
//
// Caller IRQL: [PASSIVE_LEVEL, DISPATCH_LEVEL]
//
PUCHAR
FsbAllocate(
    IN HANDLE           PoolHandle
    )
{
    PFSB_POOL_HEADER    Pool;
    PFSB_CPU_POOL_HEADER CpuPool;
    PFSB_PAGE_HEADER    Page;
    PSINGLE_LIST_ENTRY  BlockLink;
    PUCHAR              Block = NULL;
    KIRQL               OldIrql;
    ULONG               Cpu;
    LARGE_INTEGER       Ticks;

    ASSERT(PoolHandle);

    Pool = (PFSB_POOL_HEADER)PoolHandle;

    // Raise IRQL before saving the processor number since there is chance
    // it could have changed if we saved it while at passive.
    //
    OldIrql = KeRaiseIrqlToDpcLevel();

    Cpu = KeGetCurrentProcessorNumber();
    CpuPool = (PFSB_CPU_POOL_HEADER)(Pool + 1) + Cpu;

    // See if the minimum time has passed since we last scavenged
    // the pool.  If it has, we'll scavenge again.  Normally, scavenging
    // should only be performed when we free.  However, for the case when
    // the caller constantly frees on a non-owning processor, we'll
    // take this chance to do the scavenging.
    //
    KeQueryTickCount(&Ticks);
    if (Ticks.QuadPart > CpuPool->NextScavengeTick.QuadPart)
    {
        FsbpScavengePool(CpuPool);
    }

    if (!IsListEmpty(&CpuPool->PageList))
    {
        Page = CONTAINING_RECORD(CpuPool->PageList.Flink, FSB_PAGE_HEADER, PageLink);
        ASSERT(Page == PAGE_ALIGN(Page));
        ASSERT(CpuPool == Page->Pool);
        ASSERT(!Page->OnUsedPageList);

        BlockLink = ExInterlockedPopEntrySList(&Page->FreeList, &Pool->Interlock);
        if (BlockLink)
        {
            Block = (PUCHAR)BlockLink - Pool->FreeBlockLinkOffset;
        }
        else
        {
            // If there were no blocks on this page's free list, it had better
            // mean we haven't yet built all of the blocks on the page.
            // (Otherwise, what is a fully used page doing on the page list
            // and not on the used-page list?)
            //
            ASSERT(Page->BlocksBuilt < Pool->BlocksPerPage);

            Block = FsbpBuildNextBlock(Pool, Page);
            ASSERT(Block);
        }

        // Got a block.  Now check to see if it was the last one on a fully
        // built page.  If so, move the page to the used-page list.
        //
        if ((0 == ExQueryDepthSList(&Page->FreeList)) &&
            (Page->BlocksBuilt == Pool->BlocksPerPage))
        {
            PLIST_ENTRY PageLink;
            PageLink = RemoveHeadList(&CpuPool->PageList);
            InsertTailList(&CpuPool->UsedPageList, PageLink);
            Page->OnUsedPageList = TRUE;

            ASSERT(Page == CONTAINING_RECORD(PageLink, FSB_PAGE_HEADER, PageLink));
        }

        ASSERT(Block);
        goto GotABlock;
    }
    else
    {
        // The page list is empty so we have to allocate and add a new page.
        //
        Block = FsbpAllocateNewPageAndBuildOneBlock(Pool, CpuPool);
    }

    // If we are returning an block, update the statistics.
    //
    if (Block)
    {
        ULONG BlocksInUse;
GotABlock:

        CpuPool->TotalBlocksAllocated++;

        BlocksInUse = CpuPool->TotalBlocksAllocated - CpuPool->TotalBlocksFreed;
        if (BlocksInUse > CpuPool->PeakBlocksInUse)
        {
            CpuPool->PeakBlocksInUse = BlocksInUse;
        }

        // Don't give anyone ideas about where this might point.  I don't
        // want anyone trashing my pool because they thought this field
        // was valid for some reason.
        //
        ((PSINGLE_LIST_ENTRY)((PUCHAR)Block + Pool->FreeBlockLinkOffset))->Next = NULL;
    }

    KeLowerIrql(OldIrql);

    return Block;
}

// Free a block back to the pool from which it was allocated.
//
// Arguments:
//  Block - A block returned from a prior call to FsbAllocate.
//
// Caller IRQL: [PASSIVE_LEVEL, DISPATCH_LEVEL]
//
VOID
FsbFree(
    IN PUCHAR           Block
    )
{
    PFSB_PAGE_HEADER    Page;
    PFSB_CPU_POOL_HEADER CpuPool;
    PFSB_POOL_HEADER    Pool;
    LARGE_INTEGER       Ticks;
    LOGICAL             PageIsPossiblyUnused;
    LOGICAL             PageIsOnUsedPageList;
    LOGICAL             Scavenge = FALSE;

    ASSERT(Block);

    // Get the address of the page that this block lives on.  This is where
    // our page header is stored.
    //
    Page = PAGE_ALIGN(Block);

    // Follow the back pointer in the page header to locate the owning
    // cpu's pool.
    //
    CpuPool = Page->Pool;

    // Locate the pool header.
    //
    Pool = PoolFromCpuPool(CpuPool);

    // See if the minimum time has passed since we last scavenged
    // the pool.  If it has, we'll scavenge again.
    //
    KeQueryTickCount(&Ticks);
    if (Ticks.QuadPart > CpuPool->NextScavengeTick.QuadPart)
    {
        Scavenge = TRUE;
    }

    // If this is the last block to be returned to this page, the page is
    // now unused.  Note that since there is no synchronization beyond
    // ExInterlockedPush/PopSEntryList between allocate and free, we
    // cannot guarantee that it will remain unused even before the next
    // few instructions are executed.
    //
    PageIsPossiblyUnused = (ExQueryDepthSList(&Page->FreeList)
                                == (Pool->BlocksPerPage - 1));
    if (PageIsPossiblyUnused)
    {
        // Note the tick that this page was last used.  This sets the
        // minimum time that this page will continue to live unless it
        // gets re-used.
        //
        Page->LastUsedTick.QuadPart = Ticks.QuadPart;
    }

    // If this page is on the used-page list, we'll put it back on the normal
    // page list (only after pushing the block back on the page's free list)
    // if, after raising IRQL, we are on the processor that owns this
    // pool.
    //
    PageIsOnUsedPageList = Page->OnUsedPageList;


    InterlockedIncrement(&CpuPool->TotalBlocksFreed);

    // Now return the block to the page's free list.
    //
    ExInterlockedPushEntrySList(
        &Page->FreeList,
        (PSINGLE_LIST_ENTRY)((PUCHAR)Block + Pool->FreeBlockLinkOffset),
        &Pool->Interlock);

    //
    // Warning: Now that the block is back on the page, one cannot reliably
    // dereference anything through 'Page' anymore.  It may have just been
    // scavenged by its owning processor.  This is not the case if the
    // page was on the used-page list (because scavenging doesn't affect
    // the used-page list).  We saved off the value of Page->OnUsedPageList
    // before returning the block so we would not risk touching Page to get
    // this value only to find that it was false.
    //

    // If we need to move the page from the used-page list to the normal
    // page list, or if we need to scavenge, we need to be at DISPATCH_LEVEL
    // and be executing on the processor that owns this pool.
    // Find out if the CPU we are executing on right now owns this pool.
    // Note that if we are running at PASSIVE_LEVEL, the current CPU may
    // change over the duration of this function call, so this value is
    // not absolute over the life of the function.
    //
    if ((PageIsOnUsedPageList || Scavenge) &&
        ((ULONG)KeGetCurrentProcessorNumber() == CpuPool->OwnerCpu))
    {
        KIRQL OldIrql;

        OldIrql = KeRaiseIrqlToDpcLevel();

        // Now that we are at DISPATCH_LEVEL, perform the work if we are still
        // executing on the processor that owns the pool.
        //
        if ((ULONG)KeGetCurrentProcessorNumber() == CpuPool->OwnerCpu)
        {
            // If the page is still on the used-page list (meaning another
            // MdpFree didn't just sneak by), then put the page on the
            // normal list.  Very important to do this after (not before)
            // returning the MDL to the free list because MdpAllocate expects
            // MDL's to be available from pages on the page list.
            //
            if (PageIsOnUsedPageList && Page->OnUsedPageList)
            {
                RemoveEntryList(&Page->PageLink);
                Page->OnUsedPageList = FALSE;
                InsertTailList(&CpuPool->PageList, &Page->PageLink);
            }

            // Perform the scavenge if we previously noted we needed to do so.
            //
            if (Scavenge)
            {
                FsbpScavengePool(CpuPool);
            }
        }

        KeLowerIrql(OldIrql);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ndis\sys\fsbpool.h ===
/*++

Copyright (c) 1999-2000  Microsoft Corporation

Module Name:

    fsbpool.h

Abstract:

    This file contains definitions and function prototypes for manipulating
    fixed-size block pools.

Author:

    Shaun Cox (shaunco) 10-Dec-1999

--*/

#pragma once


// Creates a pool of fixed-size blocks built over non-paged pool.  Each
// block is BlockSize bytes long.  If NULL is not returned,
// FsbDestroyPool should be called at a later time to reclaim the
// resources used by the pool.
//
// Arguments:
//  BlockSize - The size, in bytes, of each block.
//  FreeBlockLinkOffset - The offset, in bytes, from the beginning of a block
//    that represenets a pointer-sized storage location that the pool can
//    use to chain free blocks together.  Most often this will be zero
//    (meaning use the first pointer-size bytes of the block.)
//  Tag - The pool tag to be used internally for calls to
//    ExAllocatePoolWithTag.  This allows callers to track
//    memory consumption for different pools.
//  BuildFunction - An optional pointer to a function which initializes
//    blocks when they are first allocated by the pool.  This allows the
//    caller to perform custom, on-demand initialization of each block.
//
//  Returns the handle used to identify the pool.
//
// Caller IRQL: [PASSIVE_LEVEL, DISPATCH_LEVEL]
//
HANDLE
FsbCreatePool(
    IN  USHORT                      BlockSize,
    IN  USHORT                      FreeBlockLinkOffset,
    IN  ULONG                       Tag,
    IN  NDIS_BLOCK_INITIALIZER      BuildFunction OPTIONAL
    );

// Destroys a pool of fixed-size blocks previously created by a call to
// FsbCreatePool.
//
// Arguments:
//  PoolHandle - Handle which identifies the pool being destroyed.
//
// Caller IRQL: [PASSIVE_LEVEL, DISPATCH_LEVEL]
//
VOID
FsbDestroyPool(
    IN  HANDLE                      PoolHandle
    );

// Returns a pointer to a block allocated from a pool.  NULL is returned if
// the request could not be granted.  The returned pointer is guaranteed to
// have 8 byte alignment.
//
// Arguments:
//  PoolHandle - Handle which identifies the pool being allocated from.
//
// Caller IRQL: [PASSIVE_LEVEL, DISPATCH_LEVEL]
//
PUCHAR
FsbAllocate(
    IN  HANDLE                      PoolHandle
    );

// Free a block back to the pool from which it was allocated.
//
// Arguments:
//  Block - A block returned from a prior call to FsbAllocate.
//
// Caller IRQL: [PASSIVE_LEVEL, DISPATCH_LEVEL]
//
VOID
FsbFree(
    IN  PUCHAR                      Block
    );
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ndis\sys\filter.h ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation

Module Name:

    filter.h

Abstract:

    MACRO for protocol filters.

Author:


Environment:

    Kernel mode, FSD

Revision History:

    Jun-95  Jameel Hyder    New functionality
--*/

#ifndef _FILTER_DEFS_
#define _FILTER_DEFS_

#define INDICATED_PACKET(_Miniport) (_Miniport)->IndicatedPacket[CURRENT_PROCESSOR]

//
// Used by the filter packages for indicating receives
//
#define FilterIndicateReceive(Status,                                                   \
                              NdisBindingHandle,                                        \
                              MacReceiveContext,                                        \
                              HeaderBuffer,                                             \
                              HeaderBufferSize,                                         \
                              LookaheadBuffer,                                          \
                              LookaheadBufferSize,                                      \
                              PacketSize)                                               \
{                                                                                       \
    *(Status) =(((PNDIS_OPEN_BLOCK)(NdisBindingHandle))->ReceiveHandler)(               \
            ((PNDIS_OPEN_BLOCK)(NdisBindingHandle))->ProtocolBindingContext,            \
            (MacReceiveContext),                                                        \
            (HeaderBuffer),                                                             \
            (HeaderBufferSize),                                                         \
            (LookaheadBuffer),                                                          \
            (LookaheadBufferSize),                                                      \
            (PacketSize));                                                              \
}


//
// Used by the filter packages for indicating receive completion
//

#define FilterIndicateReceiveComplete(NdisBindingHandle)                                \
{                                                                                       \
    (((PNDIS_OPEN_BLOCK)(NdisBindingHandle))->ReceiveCompleteHandler)(                  \
        ((PNDIS_OPEN_BLOCK)(NdisBindingHandle))->ProtocolBindingContext);               \
}


#if TRACK_RECEIVED_PACKETS
#define IndicateToProtocol(_Miniport,                                                   \
                           _Filter,                                                     \
                           _pOpenBlock,                                                 \
                           _Packet,                                                     \
                           _NSR,                                                        \
                           _Hdr,                                                        \
                           _PktSize,                                                    \
                           _HdrSize,                                                    \
                           _fFallBack,                                                  \
                           _Pmode,                                                      \
                           _Medium)                                                     \
{                                                                                       \
    UINT                LookaheadBufferSize;                                            \
    PNDIS_PACKET        pPrevIndicatedPacket;                                           \
                                                                                        \
    /*                                                                                  \
     * We indicate this via the IndicatePacketHandler if all of the following           \
     * conditions are met:                                                              \
     * - The binding is not p-mode or all-local                                         \
     * - The binding specifies a ReceivePacketHandler                                   \
     * - The miniport indicates that it is willing to let go of the packet              \
     * - No binding has already claimed the packet                                      \
     */                                                                                 \
                                                                                        \
    pPrevIndicatedPacket = INDICATED_PACKET(_Miniport);                                 \
    INDICATED_PACKET(_Miniport) = (_Packet);                                            \
                                                                                        \
    /*                                                                                  \
     * Indicate the packet to the binding.                                              \
     */                                                                                 \
    if (*(_fFallBack) ||                                                                \
        ((_pOpenBlock)->ReceivePacketHandler == NULL) ||                                \
        ((_Pmode) && ((_Filter)->SingleActiveOpen == NULL)))                            \
    {                                                                                   \
        NDIS_STATUS _StatusOfReceive;                                                   \
        NDIS_STATUS _OldPacketStatus = NDIS_GET_PACKET_STATUS(_Packet);                 \
        NDIS_SET_PACKET_STATUS(_Packet, NDIS_STATUS_RESOURCES);                         \
                                                                                        \
        NDIS_APPEND_RCV_LOGFILE(_Packet, _Miniport, CurThread,                          \
                                3, OrgPacketStackLocation+1, _NSR->RefCount, _NSR->XRefCount, NDIS_GET_PACKET_STATUS(_Packet)); \
                                                                                        \
                                                                                        \
        /*                                                                              \
         * Revert back to old-style indication in this case                             \
         */                                                                             \
        NdisQueryBuffer((_Packet)->Private.Head, NULL, &LookaheadBufferSize);           \
        ProtocolFilterIndicateReceive(&_StatusOfReceive,                                \
                                      (_pOpenBlock),                                    \
                                      (_Packet),                                        \
                                      (_Hdr),                                           \
                                      (_HdrSize),                                       \
                                      (_Hdr) + (_HdrSize),                              \
                                      LookaheadBufferSize - (_HdrSize),                 \
                                      (_PktSize) - (_HdrSize),                          \
                                      Medium);                                          \
                                                                                        \
        NDIS_APPEND_RCV_LOGFILE(_Packet, _Miniport, CurThread,                          \
                                4, OrgPacketStackLocation+1, _NSR->RefCount, _NSR->XRefCount, NDIS_GET_PACKET_STATUS(_Packet)); \
                                                                                        \
        NDIS_SET_PACKET_STATUS(_Packet, _OldPacketStatus);                              \
    }                                                                                   \
    else                                                                                \
    {                                                                                   \
        NDIS_APPEND_RCV_LOGFILE(_Packet, _Miniport, CurThread,                          \
                                5, OrgPacketStackLocation+1, _NSR->RefCount, _NSR->XRefCount, NDIS_GET_PACKET_STATUS(_Packet)); \
                                                                                        \
        (_NSR)->XRefCount += (SHORT)(*(_pOpenBlock)->ReceivePacketHandler)(             \
                            (_pOpenBlock)->ProtocolBindingContext,                      \
                            (_Packet));                                                 \
                                                                                        \
        NDIS_APPEND_RCV_LOGFILE(_Packet, _Miniport, CurThread,                          \
                                6, OrgPacketStackLocation+1, _NSR->RefCount, _NSR->XRefCount, NDIS_GET_PACKET_STATUS(_Packet)); \
                                                                                        \
        ASSERT((_NSR)->XRefCount >= 0);                                                 \
    }                                                                                   \
                                                                                        \
    /*                                                                                  \
     * Manipulate refcount on the packet with miniport lock held                        \
     * Set the reference count on the packet to what the protocol                       \
     * asked for. See NdisReturnPackets for how this is handled                         \
     * when the packets are returned.                                                   \
     */                                                                                 \
    if ((_NSR)->XRefCount > 0)                                                          \
    {                                                                                   \
        /*                                                                              \
         * Now that a binding has claimed it, make sure others do not get a chance      \
         * except if this protocol promises to behave and not use the protocol rsvd     \
         */                                                                             \
                                                                                        \
        if (!MINIPORT_TEST_FLAG(_pOpenBlock, fMINIPORT_OPEN_NO_PROT_RSVD))              \
        {                                                                               \
            *(_fFallBack) = TRUE;                                                       \
        }                                                                               \
    }                                                                                   \
    INDICATED_PACKET(_Miniport) = pPrevIndicatedPacket;                                 \
}

#else

#define IndicateToProtocol(_Miniport,                                                   \
                           _Filter,                                                     \
                           _pOpenBlock,                                                 \
                           _Packet,                                                     \
                           _NSR,                                                        \
                           _Hdr,                                                        \
                           _PktSize,                                                    \
                           _HdrSize,                                                    \
                           _fFallBack,                                                  \
                           _Pmode,                                                      \
                           _Medium)                                                     \
{                                                                                       \
    UINT                LookaheadBufferSize;                                            \
    PNDIS_PACKET        pPrevIndicatedPacket;                                           \
                                                                                        \
    /*                                                                                  \
     * We indicate this via the IndicatePacketHandler if all of the following           \
     * conditions are met:                                                              \
     * - The binding is not p-mode or all-local                                         \
     * - The binding specifies a ReceivePacketHandler                                   \
     * - The miniport indicates that it is willing to let go of the packet              \
     * - No binding has already claimed the packet                                      \
     */                                                                                 \
                                                                                        \
    pPrevIndicatedPacket = INDICATED_PACKET(_Miniport);                                 \
    INDICATED_PACKET(_Miniport) = (_Packet);                                            \
                                                                                        \
    /*                                                                                  \
     * Indicate the packet to the binding.                                              \
     */                                                                                 \
    if (*(_fFallBack) ||                                                                \
        ((_pOpenBlock)->ReceivePacketHandler == NULL) ||                                \
        ((_Pmode) && ((_Filter)->SingleActiveOpen == NULL)))                            \
    {                                                                                   \
        NDIS_STATUS _StatusOfReceive;                                                   \
        NDIS_STATUS _OldPacketStatus = NDIS_GET_PACKET_STATUS(_Packet);                 \
        NDIS_SET_PACKET_STATUS(_Packet, NDIS_STATUS_RESOURCES);                         \
                                                                                        \
        /*                                                                              \
         * Revert back to old-style indication in this case                             \
         */                                                                             \
        NdisQueryBuffer((_Packet)->Private.Head, NULL, &LookaheadBufferSize);           \
        ProtocolFilterIndicateReceive(&_StatusOfReceive,                                \
                                      (_pOpenBlock),                                    \
                                      (_Packet),                                        \
                                      (_Hdr),                                           \
                                      (_HdrSize),                                       \
                                      (_Hdr) + (_HdrSize),                              \
                                      LookaheadBufferSize - (_HdrSize),                 \
                                      (_PktSize) - (_HdrSize),                          \
                                      Medium);                                          \
        NDIS_SET_PACKET_STATUS(_Packet, _OldPacketStatus);                              \
    }                                                                                   \
    else                                                                                \
    {                                                                                   \
        (_NSR)->XRefCount += (SHORT)(*(_pOpenBlock)->ReceivePacketHandler)(             \
                            (_pOpenBlock)->ProtocolBindingContext,                      \
                            (_Packet));                                                 \
        ASSERT((_NSR)->XRefCount >= 0);                                                 \
    }                                                                                   \
                                                                                        \
    /*                                                                                  \
     * Manipulate refcount on the packet with miniport lock held                        \
     * Set the reference count on the packet to what the protocol                       \
     * asked for. See NdisReturnPackets for how this is handled                         \
     * when the packets are returned.                                                   \
     */                                                                                 \
    if ((_NSR)->XRefCount > 0)                                                          \
    {                                                                                   \
        /*                                                                              \
         * Now that a binding has claimed it, make sure others do not get a chance      \
         * except if this protocol promises to behave and not use the protocol rsvd     \
         */                                                                             \
                                                                                        \
        if (!MINIPORT_TEST_FLAG(_pOpenBlock, fMINIPORT_OPEN_NO_PROT_RSVD))              \
        {                                                                               \
            *(_fFallBack) = TRUE;                                                       \
        }                                                                               \
    }                                                                                   \
    INDICATED_PACKET(_Miniport) = pPrevIndicatedPacket;                                 \
}

#endif

#define ProtocolFilterIndicateReceive(_pStatus,                                         \
                                      _OpenB,                                           \
                                      _MacReceiveContext,                               \
                                      _HeaderBuffer,                                    \
                                      _HeaderBufferSize,                                \
                                      _LookaheadBuffer,                                 \
                                      _LookaheadBufferSize,                             \
                                      _PacketSize,                                      \
                                      _Medium)                                          \
    {                                                                                   \
        FilterIndicateReceive(_pStatus,                                                 \
                              (_OpenB),                                                 \
                              _MacReceiveContext,                                       \
                              _HeaderBuffer,                                            \
                              _HeaderBufferSize,                                        \
                              _LookaheadBuffer,                                         \
                              _LookaheadBufferSize,                                     \
                              _PacketSize);                                             \
    }

//
// Loopback macros
//
#define EthShouldAddressLoopBackMacro(_Filter,                                          \
                                      _Address,                                         \
                                      _pfLoopback,                                      \
                                      _pfSelfDirected)                                  \
{                                                                                       \
    UINT CombinedFilters;                                                               \
                                                                                        \
    CombinedFilters = ETH_QUERY_FILTER_CLASSES(_Filter);                                \
                                                                                        \
    *(_pfLoopback) = FALSE;                                                             \
    *(_pfSelfDirected) = FALSE;                                                         \
                                                                                        \
    do                                                                                  \
    {                                                                                   \
                                                                                        \
        /*                                                                              \
         * Check if it *at least* has the multicast address bit.                        \
         */                                                                             \
                                                                                        \
        if (ETH_IS_MULTICAST(_Address))                                                 \
        {                                                                               \
            /*                                                                          \
             * It is at least a multicast address.  Check to see if                     \
             * it is a broadcast address.                                               \
             */                                                                         \
                                                                                        \
            if (ETH_IS_BROADCAST(_Address))                                             \
            {                                                                           \
                if (CombinedFilters & NDIS_PACKET_TYPE_BROADCAST)                       \
                {                                                                       \
                    *(_pfLoopback) = TRUE;                                              \
                    break;                                                              \
                }                                                                       \
            }                                                                           \
            else                                                                        \
            {                                                                           \
                if ((CombinedFilters & NDIS_PACKET_TYPE_ALL_MULTICAST) ||               \
                    ((CombinedFilters & NDIS_PACKET_TYPE_MULTICAST) &&                  \
                     ethFindMulticast((_Filter)->NumAddresses,                          \
                                      (_Filter)->MCastAddressBuf,                       \
                                      _Address)))                                       \
                {                                                                       \
                    *(_pfLoopback) = TRUE;                                              \
                    break;                                                              \
                }                                                                       \
            }                                                                           \
        }                                                                               \
        else                                                                            \
        {                                                                               \
            /*                                                                          \
             * Directed to ourself??                                                    \
             */                                                                         \
                                                                                        \
            if ((*(ULONG UNALIGNED *)&(_Address)[2] ==                                  \
                    *(ULONG UNALIGNED *)&(_Filter)->AdapterAddress[2]) &&               \
                 (*(USHORT UNALIGNED *)&(_Address)[0] ==                                \
                    *(USHORT UNALIGNED *)&(_Filter)->AdapterAddress[0]))                \
            {                                                                           \
                *(_pfLoopback) = TRUE;                                                  \
                *(_pfSelfDirected) = TRUE;                                              \
                break;                                                                  \
            }                                                                           \
        }                                                                               \
    } while (FALSE);                                                                    \
                                                                                        \
    /*                                                                                  \
     * Check if the filter is promiscuous.                                              \
     */                                                                                 \
                                                                                        \
    if (CombinedFilters & (NDIS_PACKET_TYPE_PROMISCUOUS | NDIS_PACKET_TYPE_ALL_LOCAL))  \
    {                                                                                   \
        *(_pfLoopback) = TRUE;                                                          \
    }                                                                                   \
}

#define FddiShouldAddressLoopBackMacro( _Filter,                                        \
                                        _Address,                                       \
                                        _AddressLength,                                 \
                                        _pfLoopBack,                                    \
                                        _pfSelfDirected)                                \
{                                                                                       \
    INT ResultOfAddressCheck;                                                           \
                                                                                        \
    UINT CombinedFilters;                                                               \
                                                                                        \
    CombinedFilters = FDDI_QUERY_FILTER_CLASSES(_Filter);                               \
                                                                                        \
    *(_pfLoopBack) = FALSE;                                                             \
    *(_pfSelfDirected) = FALSE;                                                         \
                                                                                        \
    do                                                                                  \
    {                                                                                   \
        /*                                                                              \
         * Check if it *at least* has the multicast address bit.                        \
         */                                                                             \
                                                                                        \
        FDDI_IS_MULTICAST(_Address,                                                     \
                          (_AddressLength),                                             \
                          &ResultOfAddressCheck);                                       \
                                                                                        \
        if (ResultOfAddressCheck)                                                       \
        {                                                                               \
            /*                                                                          \
             * It is at least a multicast address.  Check to see if                     \
             * it is a broadcast address.                                               \
             */                                                                         \
                                                                                        \
            FDDI_IS_BROADCAST(_Address,                                                 \
                              (_AddressLength),                                         \
                              &ResultOfAddressCheck);                                   \
                                                                                        \
            if (ResultOfAddressCheck)                                                   \
            {                                                                           \
                if (CombinedFilters & NDIS_PACKET_TYPE_BROADCAST)                       \
                {                                                                       \
                    *(_pfLoopBack) = TRUE;                                              \
                    break;                                                              \
                }                                                                       \
            }                                                                           \
            else                                                                        \
            {                                                                           \
                if ((CombinedFilters & NDIS_PACKET_TYPE_ALL_MULTICAST) ||               \
                    ((CombinedFilters & NDIS_PACKET_TYPE_MULTICAST) &&                  \
                     ((((_AddressLength) == FDDI_LENGTH_OF_LONG_ADDRESS) &&             \
                        fddiFindMulticastLongAddress((_Filter)->NumLongAddresses,       \
                                                    (_Filter)->MCastLongAddressBuf,     \
                                                    _Address)) ||                       \
                      (((_AddressLength) == FDDI_LENGTH_OF_SHORT_ADDRESS) &&            \
                        fddiFindMulticastShortAddress((_Filter)->NumShortAddresses,     \
                                                      (_Filter)->MCastShortAddressBuf,  \
                                                      _Address)))))                     \
                {                                                                       \
                    *(_pfLoopBack) = TRUE;                                              \
                    break;                                                              \
                }                                                                       \
            }                                                                           \
        }                                                                               \
        else                                                                            \
        {                                                                               \
            /*                                                                          \
             * Directed to ourself?                                                     \
             */                                                                         \
            if ((_AddressLength) == FDDI_LENGTH_OF_LONG_ADDRESS)                        \
            {                                                                           \
                FDDI_COMPARE_NETWORK_ADDRESSES_EQ((_Filter)->AdapterLongAddress,        \
                                                _Address,                               \
                                                FDDI_LENGTH_OF_LONG_ADDRESS,            \
                                                &ResultOfAddressCheck                   \
                                                );                                      \
            }                                                                           \
            else                                                                        \
            {                                                                           \
                FDDI_COMPARE_NETWORK_ADDRESSES_EQ((_Filter)->AdapterShortAddress,       \
                                                _Address,                               \
                                                FDDI_LENGTH_OF_SHORT_ADDRESS,           \
                                                &ResultOfAddressCheck                   \
                                                );                                      \
            }                                                                           \
                                                                                        \
            if (ResultOfAddressCheck == 0)                                              \
            {                                                                           \
                *(_pfLoopBack) = TRUE;                                                  \
                *(_pfSelfDirected) = TRUE;                                              \
                break;                                                                  \
            }                                                                           \
        }                                                                               \
    } while (FALSE);                                                                    \
                                                                                        \
    /*                                                                                  \
     * First check if the filter is promiscuous.                                        \
     */                                                                                 \
                                                                                        \
    if (CombinedFilters & (NDIS_PACKET_TYPE_PROMISCUOUS | NDIS_PACKET_TYPE_ALL_LOCAL))  \
    {                                                                                   \
        *(_pfLoopBack) = TRUE;                                                          \
    }                                                                                   \
}

#define TrShouldAddressLoopBackMacro(_Filter,                                           \
                                     _DAddress,                                         \
                                     _SAddress,                                         \
                                     _pfLoopback,                                       \
                                     _pfSelfDirected)                                   \
{                                                                                       \
    /* Holds the result of address determinations. */                                   \
    BOOLEAN ResultOfAddressCheck;                                                       \
                                                                                        \
    BOOLEAN IsSourceRouting;                                                            \
                                                                                        \
    UINT CombinedFilters;                                                               \
                                                                                        \
    ULONG GroupAddress;                                                                 \
                                                                                        \
    *(_pfLoopback) = FALSE;                                                             \
    *(_pfSelfDirected) = FALSE;                                                         \
                                                                                        \
    do                                                                                  \
    {                                                                                   \
        CombinedFilters = TR_QUERY_FILTER_CLASSES(_Filter);                             \
                                                                                        \
        /* Convert the 32 bits of the address to a longword. */                         \
        RetrieveUlong(&GroupAddress, ((_DAddress) + 2));                                \
                                                                                        \
        /* Check if the destination is a preexisting group address */                   \
        TR_IS_GROUP((_DAddress), &ResultOfAddressCheck);                                \
                                                                                        \
        if (ResultOfAddressCheck &&                                                     \
            (GroupAddress == (_Filter)->GroupAddress) &&                                \
            ((_Filter)->GroupReferences != 0))                                          \
        {                                                                               \
            *(_pfLoopback) = TRUE;                                                      \
            break;                                                                      \
        }                                                                               \
        else                                                                            \
        {                                                                               \
            TR_IS_SOURCE_ROUTING((_SAddress), &IsSourceRouting);                        \
                                                                                        \
            if (IsSourceRouting && (CombinedFilters & NDIS_PACKET_TYPE_SOURCE_ROUTING)) \
            {                                                                           \
                *(_pfLoopback) = TRUE;                                                  \
                break;                                                                  \
            }                                                                           \
            else                                                                        \
            {                                                                           \
                /* First check if it *at least* has the functional address bit. */      \
                TR_IS_NOT_DIRECTED((_DAddress), &ResultOfAddressCheck);                 \
                                                                                        \
                if (ResultOfAddressCheck)                                               \
                {                                                                       \
                    /* It is at least a functional address.  Check to see if */         \
                    /* it is a broadcast address. */                                    \
                                                                                        \
                    TR_IS_BROADCAST((_DAddress), &ResultOfAddressCheck);                \
                                                                                        \
                    if (ResultOfAddressCheck)                                           \
                    {                                                                   \
                        if (CombinedFilters & NDIS_PACKET_TYPE_BROADCAST)               \
                        {                                                               \
                            *(_pfLoopback) = TRUE;                                      \
                            break;                                                      \
                        }                                                               \
                    }                                                                   \
                    else                                                                \
                    {                                                                   \
                        TR_IS_FUNCTIONAL((_DAddress), &ResultOfAddressCheck);           \
                        if (ResultOfAddressCheck)                                       \
                        {                                                               \
                            if (CombinedFilters &                                       \
                                (NDIS_PACKET_TYPE_ALL_FUNCTIONAL |                      \
                                 NDIS_PACKET_TYPE_FUNCTIONAL))                          \
                            {                                                           \
                                ULONG   FunctionalAddress;                              \
                                                                                        \
                                RetrieveUlong(&FunctionalAddress, ((_DAddress) + 2));   \
                                if ((FunctionalAddress &                                \
                                    (_Filter)->CombinedFunctionalAddress))              \
                                {                                                       \
                                    *(_pfLoopback) = TRUE;                              \
                                    break;                                              \
                                }                                                       \
                            }                                                           \
                        }                                                               \
                    }                                                                   \
                }                                                                       \
                else                                                                    \
                {                                                                       \
                    /* See if it is self-directed. */                                   \
                                                                                        \
                    if ((*(ULONG UNALIGNED  *)(_DAddress + 2) ==                        \
                         *(ULONG UNALIGNED  *)(&(_Filter)->AdapterAddress[2])) &&       \
                        (*(USHORT UNALIGNED *)(_DAddress) ==                            \
                         *(USHORT UNALIGNED *)(&(_Filter)->AdapterAddress[0])))         \
                    {                                                                   \
                        *(_pfLoopback) = TRUE;                                          \
                        *(_pfSelfDirected) = TRUE;                                      \
                        break;                                                          \
                    }                                                                   \
                }                                                                       \
                                                                                        \
            }                                                                           \
        }                                                                               \
    } while (FALSE);                                                                    \
                                                                                        \
    if (CombinedFilters & (NDIS_PACKET_TYPE_PROMISCUOUS | NDIS_PACKET_TYPE_ALL_LOCAL))  \
    {                                                                                   \
        *(_pfLoopback) = TRUE;                                                          \
    }                                                                                   \
}

typedef struct _X_BINDING_INFO  X_BINDING_INFO, *PX_BINDING_INFO;

typedef struct _X_BINDING_INFO
{
    //
    //  The following pointers are used to travers the specific
    //  and total filter lists. They need to be at the first
    //  elements in the structure
    //
    PX_BINDING_INFO             NextOpen;
    PNDIS_OPEN_BLOCK            NdisBindingHandle;
    PVOID                       Reserved;
    UINT                        PacketFilters;
    UINT                        OldPacketFilters;
    ULONG                       References;
    PX_BINDING_INFO             NextInactiveOpen;
    BOOLEAN                     ReceivedAPacket;
    union
    {
        //
        //  Ethernet
        //
        struct
        {
            CHAR                (*MCastAddressBuf)[ETH_LENGTH_OF_ADDRESS];
            UINT                NumAddresses;

            CHAR                (*OldMCastAddressBuf)[ETH_LENGTH_OF_ADDRESS];
            UINT                OldNumAddresses;
        };
        //
        //  Fddi
        //
        struct
        {
            CHAR                (*MCastLongAddressBuf)[FDDI_LENGTH_OF_LONG_ADDRESS];
            UINT                NumLongAddresses;
            CHAR                (*MCastShortAddressBuf)[FDDI_LENGTH_OF_SHORT_ADDRESS];
            UINT                NumShortAddresses;
        
            //
            // Save area while the change is made
            //
            CHAR                (*OldMCastLongAddressBuf)[FDDI_LENGTH_OF_LONG_ADDRESS];
            UINT                OldNumLongAddresses;
            CHAR                (*OldMCastShortAddressBuf)[FDDI_LENGTH_OF_SHORT_ADDRESS];
            UINT                OldNumShortAddresses;
        };
        //
        //  Token-Ring
        //
        struct
        {
            TR_FUNCTIONAL_ADDRESS   FunctionalAddress;
            TR_FUNCTIONAL_ADDRESS   OldFunctionalAddress;
            BOOLEAN                 UsingGroupAddress;
            BOOLEAN                 OldUsingGroupAddress;
        };
    };
} X_BINDING_INFO, *PX_BINDING_INFO;

typedef struct _X_FILTER
{
    //
    // The list of bindings are seperated for directed and broadcast/multicast
    // Promiscuous bindings are on both lists
    //
    PX_BINDING_INFO             OpenList;
    NDIS_RW_LOCK                BindListLock;
    PNDIS_MINIPORT_BLOCK        Miniport;
    UINT                        CombinedPacketFilter;
    UINT                        OldCombinedPacketFilter;
    UINT                        NumOpens;
    PX_BINDING_INFO             MCastSet;
    PX_BINDING_INFO             SingleActiveOpen;
    UCHAR                       AdapterAddress[ETH_LENGTH_OF_ADDRESS];
    union
    {
        //
        // Ethernet
        //
        struct
        {
            CHAR                (*MCastAddressBuf)[ETH_LENGTH_OF_ADDRESS];
            CHAR                (*OldMCastAddressBuf)[ETH_LENGTH_OF_ADDRESS];
            UINT                MaxMulticastAddresses;
            UINT                NumAddresses;
            UINT                OldNumAddresses;
        };
        //
        // Fddi
        //
        struct
        {
#define AdapterLongAddress      AdapterAddress
            UCHAR               AdapterShortAddress[FDDI_LENGTH_OF_SHORT_ADDRESS];
            CHAR                (*MCastLongAddressBuf)[FDDI_LENGTH_OF_LONG_ADDRESS];
            CHAR                (*MCastShortAddressBuf)[FDDI_LENGTH_OF_SHORT_ADDRESS];
            CHAR                (*OldMCastLongAddressBuf)[FDDI_LENGTH_OF_LONG_ADDRESS];
            CHAR                (*OldMCastShortAddressBuf)[FDDI_LENGTH_OF_SHORT_ADDRESS];
            UINT                MaxMulticastLongAddresses;
            UINT                MaxMulticastShortAddresses;
            UINT                NumLongAddresses;
            UINT                NumShortAddresses;
            UINT                OldNumLongAddresses;
            UINT                OldNumShortAddresses;
            BOOLEAN             SupportsShortAddresses;
        };
        struct
        {
            TR_FUNCTIONAL_ADDRESS   CombinedFunctionalAddress;
            TR_FUNCTIONAL_ADDRESS   GroupAddress;
            UINT                    GroupReferences;
            TR_FUNCTIONAL_ADDRESS   OldCombinedFunctionalAddress;
            TR_FUNCTIONAL_ADDRESS   OldGroupAddress;
            UINT                    OldGroupReferences;
        };
    };
} X_FILTER, *PX_FILTER;


//
//UINT
//ETH_QUERY_FILTER_CLASSES(
//  IN  PETH_FILTER             Filter
//  )
//
// This macro returns the currently enabled filter classes.
//
// NOTE: THIS MACRO ASSUMES THAT THE FILTER LOCK IS HELD.
//
#define ETH_QUERY_FILTER_CLASSES(Filter) ((Filter)->CombinedPacketFilter)


//
//UINT
//ETH_QUERY_PACKET_FILTER(
//  IN  PETH_FILTER             Filter,
//  IN  NDIS_HANDLE             NdisFilterHandle
//  )
//
// This macro returns the currently enabled filter classes for a specific
// open instance.
//
// NOTE: THIS MACRO ASSUMES THAT THE FILTER LOCK IS HELD.
//
#define ETH_QUERY_PACKET_FILTER(Filter, NdisFilterHandle) \
        (((PETH_BINDING_INFO)(NdisFilterHandle))->PacketFilters)


//
//UINT
//ETH_NUMBER_OF_GLOBAL_FILTER_ADDRESSES(
//  IN  PETH_FILTER             Filter
//  )
//
// This macro returns the number of multicast addresses in the
// multicast address list.
//
// NOTE: THIS MACRO ASSUMES THAT THE FILTER LOCK IS HELD.
//
#define ETH_NUMBER_OF_GLOBAL_FILTER_ADDRESSES(Filter) ((Filter)->NumAddresses)

typedef X_BINDING_INFO  ETH_BINDING_INFO, *PETH_BINDING_INFO;

typedef X_FILTER        ETH_FILTER, *PETH_FILTER;

//
//UINT
//FDDI_QUERY_FILTER_CLASSES(
//  IN  PFDDI_FILTER            Filter
//  )
//
// This macro returns the currently enabled filter classes.
//
// NOTE: THIS MACRO ASSUMES THAT THE FILTER LOCK IS HELD.
//
#define FDDI_QUERY_FILTER_CLASSES(Filter) ((Filter)->CombinedPacketFilter)


//
//UINT
//FDDI_QUERY_PACKET_FILTER(
//  IN  PFDDI_FILTER            Filter,
//  IN  NDIS_HANDLE             NdisFilterHandle
//  )
//
// This macro returns the currently enabled filter classes for a specific
// open instance.
//
// NOTE: THIS MACRO ASSUMES THAT THE FILTER LOCK IS HELD.
//
#define FDDI_QUERY_PACKET_FILTER(Filter, NdisFilterHandle) \
        (((PFDDI_BINDING_INFO)(NdisFilterHandle))->PacketFilters)


//
//UINT
//FDDI_NUMBER_OF_GLOBAL_FILTER_LONG_ADDRESSES(
//  IN  PFDDI_FILTER            Filter
//  )
//
// This macro returns the number of multicast addresses in the
// multicast address list.
//
// NOTE: THIS MACRO ASSUMES THAT THE FILTER LOCK IS HELD.
//
#define FDDI_NUMBER_OF_GLOBAL_FILTER_LONG_ADDRESSES(Filter) ((Filter)->NumLongAddresses)


//
//UINT
//FDDI_NUMBER_OF_GLOBAL_FILTER_SHORT_ADDRESSES(
//  IN  PFDDI_FILTER            Filter
//  )
//
// This macro returns the number of multicast addresses in the
// multicast address list.
//
// NOTE: THIS MACRO ASSUMES THAT THE FILTER LOCK IS HELD.
//
#define FDDI_NUMBER_OF_GLOBAL_FILTER_SHORT_ADDRESSES(Filter) ((Filter)->NumShortAddresses)

#define FDDI_FILTER_SUPPORTS_SHORT_ADDR(Filter)     (Filter)->SupportsShortAddresses

//
// The binding info is threaded on two lists.  When
// the binding is free it is on a single freelist.
//
// When the binding is being used it is on an index list
// and possibly on seperate broadcast and directed lists.
//
typedef X_BINDING_INFO  FDDI_BINDING_INFO,*PFDDI_BINDING_INFO;

typedef X_FILTER        FDDI_FILTER, *PFDDI_FILTER;

//
//UINT
//TR_QUERY_FILTER_CLASSES(
//  IN PTR_FILTER Filter
//  )
//
// This macro returns the currently enabled filter classes.
//
// NOTE: THIS MACRO ASSUMES THAT THE FILTER LOCK IS HELD.
//
#define TR_QUERY_FILTER_CLASSES(Filter) ((Filter)->CombinedPacketFilter)


//
//UINT
//TR_QUERY_PACKET_FILTER(
//  IN PTR_FILTER Filter,
//  IN NDIS_HANDLE NdisFilterHandle
//  )
//
// This macro returns the currently enabled filter classes for a specific
// open instance.
//
// NOTE: THIS MACRO ASSUMES THAT THE FILTER LOCK IS HELD.
//
#define TR_QUERY_PACKET_FILTER(Filter, NdisFilterHandle) \
        (((PTR_BINDING_INFO)NdisFilterHandle)->PacketFilters)


//
//UINT
//TR_QUERY_FILTER_ADDRESSES(
//  IN PTR_FILTER Filter
//  )
//
// This macro returns the currently enabled functional address.
//
// NOTE: THIS MACRO ASSUMES THAT THE FILTER LOCK IS HELD.
//
#define TR_QUERY_FILTER_ADDRESSES(Filter) ((Filter)->CombinedFunctionalAddress)


//
//UINT
//TR_QUERY_FILTER_GROUP(
//  IN PTR_FILTER Filter
//  )
//
// This macro returns the currently enabled Group address.
//
// NOTE: THIS MACRO ASSUMES THAT THE FILTER LOCK IS HELD.
//
#define TR_QUERY_FILTER_Group(Filter) ((Filter)->GroupAddress)
#define TR_QUERY_FILTER_GROUP(Filter) ((Filter)->GroupAddress)

//
//UINT
//TR_QUERY_FILTER_BINDING_ADDRESS(
//  IN PTR_FILTER Filter
//  IN NDIS_HANDLE NdisFilterHandle,
//  )
//
// This macro returns the currently desired functional addresses
// for the specified binding.
//
// NOTE: THIS MACRO ASSUMES THAT THE FILTER LOCK IS HELD.
//
#define TR_QUERY_FILTER_BINDING_ADDRESS(Filter, NdisFilterHandle) \
                    (((PTR_BINDING_INFO)NdisFilterHandle)->FunctionalAddress)

//
//BOOLEAN
//TR_QUERY_FILTER_BINDING_GROUP(
//  IN PTR_FILTER Filter
//  IN NDIS_HANDLE NdisFilterHandle,
//  )
//
// This macro returns TRUE if the specified binding is using the
// current group address.
//
// NOTE: THIS MACRO ASSUMES THAT THE FILTER LOCK IS HELD.
//
#define TR_QUERY_FILTER_BINDING_GROUP(Filter, NdisFilterHandle) \
                    (((PTR_BINDING_INFO)NdisFilterHandle)->UsingGroupAddress)


typedef X_BINDING_INFO  TR_BINDING_INFO,*PTR_BINDING_INFO;

typedef X_FILTER        TR_FILTER, *PTR_FILTER;

#endif // _FILTER_DEFS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ndis\sys\init.c ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation

Module Name:

    init.c

Abstract:

    NDIS wrapper functions initializing drivers.

Author:

    Adam Barr (adamba) 11-Jul-1990

Environment:

    Kernel mode, FSD

Revision History:

    26-Feb-1991  JohnsonA       Added Debugging Code
    10-Jul-1991  JohnsonA       Implement revised Ndis Specs
    01-Jun-1995  JameelH        Re-organized

--*/

#include <precomp.h>
#include <atm.h>
#pragma hdrstop

#include <stdarg.h>

//
//  Define the module number for debug code.
//
#define MODULE_NUMBER   MODULE_INIT

//
// Configuration Requests
//

VOID
NdisOpenConfiguration(
    OUT PNDIS_STATUS                Status,
    OUT PNDIS_HANDLE                ConfigurationHandle,
    IN  NDIS_HANDLE                 WrapperConfigurationContext
    )
/*++

Routine Description:

    This routine is used to open the parameter subkey of the
    adapter registry tree.

Arguments:

    Status - Returns the status of the request.

    ConfigurationHandle - Returns a handle which is used in calls to
                            NdisReadConfiguration and NdisCloseConfiguration.

    WrapperConfigurationContext - a handle pointing to an RTL_QUERY_REGISTRY_TABLE
                            that is set up for this driver's parameters.

Return Value:

    None.

--*/
{
    //
    // Handle to be returned
    //
    PNDIS_CONFIGURATION_HANDLE HandleToReturn;

    DBGPRINT_RAW(DBG_COMP_REG, DBG_LEVEL_INFO,
        ("==>NdisOpenConfiguration: WrapperConfigurationContext %p\n", WrapperConfigurationContext));
        
    //
    // Allocate the configuration handle
    //
    HandleToReturn = ALLOC_FROM_POOL(sizeof(NDIS_CONFIGURATION_HANDLE), NDIS_TAG_CONFIG_HANLDE);

    *Status = (HandleToReturn != NULL) ? NDIS_STATUS_SUCCESS : NDIS_STATUS_RESOURCES;
    
    if (*Status == NDIS_STATUS_SUCCESS)
    {
        HandleToReturn->KeyQueryTable = ((PNDIS_WRAPPER_CONFIGURATION_HANDLE)WrapperConfigurationContext)->ParametersQueryTable;
        HandleToReturn->ParameterList = NULL;
        *ConfigurationHandle = (NDIS_HANDLE)HandleToReturn;
    }
    
    DBGPRINT_RAW(DBG_COMP_REG, DBG_LEVEL_INFO,
        ("<==NdisOpenConfiguration: WrapperConfigurationContext %p\n", WrapperConfigurationContext));
}


VOID
NdisOpenConfigurationKeyByName(
    OUT PNDIS_STATUS                Status,
    IN  NDIS_HANDLE                 ConfigurationHandle,
    IN  PNDIS_STRING                KeyName,
    OUT PNDIS_HANDLE                KeyHandle
    )
/*++

Routine Description:

    This routine is used to open a subkey relative to the configuration handle.

Arguments:

    Status - Returns the status of the request.

    ConfigurationHandle - Handle to an already open section of the registry

    KeyName - Name of the subkey to open

    KeyHandle - Placeholder for the handle to the sub-key.

Return Value:

    None.

--*/
{
    //
    // Handle to be returned
    //
    PNDIS_CONFIGURATION_HANDLE          SKHandle, ConfigHandle = (PNDIS_CONFIGURATION_HANDLE)ConfigurationHandle;
    PNDIS_WRAPPER_CONFIGURATION_HANDLE  WConfigHandle;
    UNICODE_STRING                      Parent, Child, Sep;
#define PQueryTable                     WConfigHandle->ParametersQueryTable

    DBGPRINT_RAW(DBG_COMP_REG, DBG_LEVEL_INFO,
        ("==>NdisOpenConfigurationKeyByName: ConfigurationHandle\n", ConfigurationHandle));
        
    ASSERT (KeGetCurrentIrql() < DISPATCH_LEVEL);

    do
    {

        if (*ConfigHandle->KeyQueryTable[3].Name)
        {
            RtlInitUnicodeString(&Parent, ConfigHandle->KeyQueryTable[3].Name);
            RtlInitUnicodeString(&Sep, L"\\");
            Child.MaximumLength = KeyName->Length + Parent.Length + Sep.Length + sizeof(WCHAR);
        }
        else
        {
            Child.MaximumLength = KeyName->Length + sizeof(WCHAR);
        }
        
        Child.Length = 0;

        //
        // Allocate the configuration handle
        //

        SKHandle = ALLOC_FROM_POOL(sizeof(NDIS_CONFIGURATION_HANDLE) +
                                    sizeof(NDIS_WRAPPER_CONFIGURATION_HANDLE) +
                                    Child.MaximumLength,
                                    NDIS_TAG_CONFIG_HANLDE);

        *Status = (SKHandle != NULL) ? NDIS_STATUS_SUCCESS : NDIS_STATUS_RESOURCES;

        if (*Status != NDIS_STATUS_SUCCESS)
        {
            *KeyHandle = (NDIS_HANDLE)NULL;
            break;
        }
        
        WConfigHandle = (PNDIS_WRAPPER_CONFIGURATION_HANDLE)((PUCHAR)SKHandle + sizeof(NDIS_CONFIGURATION_HANDLE));
        Child.Buffer = (PWSTR)((PUCHAR)WConfigHandle + sizeof(NDIS_WRAPPER_CONFIGURATION_HANDLE));

        //
        // if there is no parent path, avoid starting the child path with "\\"
        //
        if (*ConfigHandle->KeyQueryTable[3].Name)
        {
            RtlCopyUnicodeString(&Child, &Parent);
            RtlAppendUnicodeStringToString(&Child, &Sep);
        }
        
        RtlAppendUnicodeStringToString(&Child, KeyName);

        SKHandle->KeyQueryTable = WConfigHandle->ParametersQueryTable;


        PQueryTable[0].QueryRoutine = NULL;
        PQueryTable[0].Flags = RTL_QUERY_REGISTRY_SUBKEY;
        PQueryTable[0].Name = L"";

        //
        // 1.
        // Call ndisSaveParameter for a parameter, which will allocate storage for it.
        //
        PQueryTable[1].QueryRoutine = ndisSaveParameters;
        PQueryTable[1].Flags = RTL_QUERY_REGISTRY_REQUIRED | RTL_QUERY_REGISTRY_NOEXPAND;
        PQueryTable[1].DefaultType = REG_NONE;

        //
        // PQueryTable[0].Name and PQueryTable[0].EntryContext
        // are filled in inside ReadConfiguration, in preparation
        // for the callback.
        //
        // PQueryTable[0].Name = KeywordBuffer;
        // PQueryTable[0].EntryContext = ParameterValue;

        //
        // 2.
        // Stop
        //
        PQueryTable[2].QueryRoutine = NULL;
        PQueryTable[2].Flags = 0;
        PQueryTable[2].Name = NULL;

        //
        // NOTE: Some fields in ParametersQueryTable[3] are used to store information for later retrieval.
        //
        PQueryTable[3].QueryRoutine = ConfigHandle->KeyQueryTable[3].QueryRoutine;
        PQueryTable[3].Name = Child.Buffer;
        PQueryTable[3].EntryContext = NULL;
        PQueryTable[3].DefaultData = NULL;
        
        SKHandle->ParameterList = NULL;
        *KeyHandle = (NDIS_HANDLE)SKHandle;
    } while (FALSE);
    
    DBGPRINT_RAW(DBG_COMP_REG, DBG_LEVEL_INFO,
        ("<==NdisOpenConfigurationKeyByName: ConfigurationHandle\n", ConfigurationHandle));

#undef  PQueryTable
}


VOID
NdisOpenConfigurationKeyByIndex(
    OUT PNDIS_STATUS                Status,
    IN  NDIS_HANDLE                 ConfigurationHandle,
    IN  ULONG                       Index,
    OUT PNDIS_STRING                KeyName,
    OUT PNDIS_HANDLE                KeyHandle
    )
/*++

Routine Description:

    This routine is used to open a subkey relative to the configuration handle.

Arguments:

    Status - Returns the status of the request.

    ConfigurationHandle - Handle to an already open section of the registry

    Index - Index of the sub-key to open

    KeyName - Placeholder for the name of subkey being opened

    KeyHandle - Placeholder for the handle to the sub-key.

Return Value:

    None.

--*/
{
    PNDIS_CONFIGURATION_HANDLE          ConfigHandle = (PNDIS_CONFIGURATION_HANDLE)ConfigurationHandle;
    HANDLE                              Handle = NULL, RootHandle = NULL;
    OBJECT_ATTRIBUTES                   ObjAttr;
    UNICODE_STRING                      KeyPath = {0}, Services = {0}, AbsolutePath={0};
    PKEY_BASIC_INFORMATION              InfoBuf = NULL;
    ULONG                               Len;
    PDEVICE_OBJECT                      PhysicalDeviceObject;
    PNDIS_MINIPORT_BLOCK                Miniport;
    
    DBGPRINT_RAW(DBG_COMP_REG, DBG_LEVEL_INFO,
        ("==>NdisOpenConfigurationKeyByIndex: ConfigurationHandle\n", ConfigurationHandle));
        
    ASSERT (KeGetCurrentIrql() < DISPATCH_LEVEL);

    *KeyHandle = NULL;

    do
    {
        if (ConfigHandle->KeyQueryTable[3].Name != NULL)
        {
            RtlInitUnicodeString(&KeyPath, ConfigHandle->KeyQueryTable[3].Name);
        }
        
        if ((Miniport = (PNDIS_MINIPORT_BLOCK)ConfigHandle->KeyQueryTable[3].QueryRoutine) == NULL)
        {
            //
            // protocols
            //
            
            //
            // Open the current key and lookup the Nth subkey. But first conver the service relative
            // path to absolute since this is what ZwOpenKey expects.
            //
            RtlInitUnicodeString(&Services, L"\\Registry\\Machine\\System\\CurrentControlSet\\Services\\");
        }
        else
        {
            //
            // Adapters
            //
            // for adapters, first we have to open the key for PDO
            //
            
            PhysicalDeviceObject = Miniport->PhysicalDeviceObject;

#if NDIS_TEST_REG_FAILURE
            *Status = STATUS_UNSUCCESSFUL;
#else

            *Status = IoOpenDeviceRegistryKey(PhysicalDeviceObject,
                                              PLUGPLAY_REGKEY_DRIVER,
                                              GENERIC_READ | MAXIMUM_ALLOWED,
                                              &RootHandle);
                                              
#endif

            if (!NT_SUCCESS(*Status))
            {
                break;
            }
        }

        if (KeyPath.Length || Services.Length)
        {
            AbsolutePath.MaximumLength = KeyPath.Length + Services.Length + sizeof(WCHAR);
            AbsolutePath.Buffer = (PWSTR)ALLOC_FROM_POOL(AbsolutePath.MaximumLength, NDIS_TAG_DEFAULT);
            if (AbsolutePath.Buffer == NULL)
            {
                *Status = NDIS_STATUS_RESOURCES;
                break;
            }
            NdisMoveMemory(AbsolutePath.Buffer, Services.Buffer, Services.Length);
            AbsolutePath.Length = Services.Length;
            RtlAppendUnicodeStringToString(&AbsolutePath, &KeyPath);
        }
        
        InitializeObjectAttributes(&ObjAttr,
                                   &AbsolutePath,
                                   OBJ_CASE_INSENSITIVE,
                                   RootHandle,
                                   NULL);
                                
        *Status = ZwOpenKey(&Handle,
                            GENERIC_READ | MAXIMUM_ALLOWED,
                            &ObjAttr);
                            
        if (!NT_SUCCESS(*Status))
        {
            Handle = NULL;
            break;
        }
        
        //
        // Allocate memory for the call to ZwEnumerateKey
        //
        Len = sizeof(KEY_BASIC_INFORMATION) + 256;
        InfoBuf = (PKEY_BASIC_INFORMATION)ALLOC_FROM_POOL(Len, NDIS_TAG_DEFAULT);
        if (InfoBuf == NULL)
        {
            *Status = NDIS_STATUS_RESOURCES;
            break;
        }

        //
        // Get the Index(th) key, if it exists
        //
        *Status = ZwEnumerateKey(Handle,
                                 Index,
                                 KeyValueBasicInformation,
                                 InfoBuf,
                                 Len,
                                 &Len);
                                
        if (NT_SUCCESS(*Status))
        {
            //
            // This worked. Now simply pick up the name and do a NdisOpenConfigurationKeyByName on it.
            //
            KeyPath.Length = KeyPath.MaximumLength = (USHORT)InfoBuf->NameLength;
            KeyPath.Buffer = InfoBuf->Name;
            NdisOpenConfigurationKeyByName(Status,
                                           ConfigurationHandle,
                                           &KeyPath,
                                           KeyHandle);
                                        
            if (*Status == NDIS_STATUS_SUCCESS)
            {
                PNDIS_CONFIGURATION_HANDLE      NewHandle = *(PNDIS_CONFIGURATION_HANDLE *)KeyHandle;

                //
                // The path in the new handle has the name of the key. Extract it and return to caller
                //
                RtlInitUnicodeString(KeyName, NewHandle->KeyQueryTable[3].Name);
                KeyName->Buffer = (PWSTR)((PUCHAR)KeyName->Buffer + KeyName->Length - KeyPath.Length);
                KeyName->Length = KeyPath.Length;
                KeyName->MaximumLength = KeyPath.MaximumLength;
            }
        }

    } while (FALSE);

    if (AbsolutePath.Buffer != NULL)
    {
        FREE_POOL(AbsolutePath.Buffer);
    }

    if (InfoBuf != NULL)
    {
        FREE_POOL(InfoBuf);
    }

    if (RootHandle)
        ZwClose (RootHandle);

    if (Handle)
        ZwClose (Handle);


    DBGPRINT_RAW(DBG_COMP_REG, DBG_LEVEL_INFO,
        ("<==NdisOpenConfigurationKeyByIndex: ConfigurationHandle\n", ConfigurationHandle));
}


VOID
NdisReadConfiguration(
    OUT PNDIS_STATUS                    Status,
    OUT PNDIS_CONFIGURATION_PARAMETER * ParameterValue,
    IN NDIS_HANDLE                      ConfigurationHandle,
    IN PNDIS_STRING                     Keyword,
    IN NDIS_PARAMETER_TYPE              ParameterType
    )
/*++

Routine Description:

    This routine is used to read the parameter for a configuration
    keyword from the configuration database.

Arguments:

    Status - Returns the status of the request.

    ParameterValue - Returns the value for this keyword.

    ConfigurationHandle - Handle returned by NdisOpenConfiguration. Points
    to the parameter subkey.

    Keyword - The keyword to search for.

    ParameterType - Ignored on NT, specifies the type of the value.

Return Value:

    None.

--*/
{
    NTSTATUS                    RegistryStatus;
    PWSTR                       KeywordBuffer;
    UINT                        i;
    PNDIS_CONFIGURATION_HANDLE  ConfigHandle = (PNDIS_CONFIGURATION_HANDLE)ConfigurationHandle;
    PDEVICE_OBJECT              PhysicalDeviceObject;
    HANDLE                      Handle = NULL;
    PNDIS_MINIPORT_BLOCK        Miniport = NULL;
    PDEVICE_OBJECT              DeviceObject;
    PCM_PARTIAL_RESOURCE_LIST   pResourceList;
    UINT                        j;
    ULONG                       ValueData;
    
#define PQueryTable             ConfigHandle->KeyQueryTable

    //
    // There are some built-in parameters which can always be
    // read, even if not present in the registry. This is the
    // number of them.
    //
#define BUILT_IN_COUNT 3

    static NDIS_STRING BuiltInStrings[BUILT_IN_COUNT] =
    {
        NDIS_STRING_CONST ("Environment"),
        NDIS_STRING_CONST ("ProcessorType"),
        NDIS_STRING_CONST ("NdisVersion")
    };

    static NDIS_STRING MiniportNameStr = NDIS_STRING_CONST ("MiniportName");

#define STANDARD_RESOURCE_COUNT 9
    //
    // The names of the standard resource types.
    //
    static NDIS_STRING StandardResourceStrings[STANDARD_RESOURCE_COUNT] =
    {
        NDIS_STRING_CONST ("IoBaseAddress"),
        NDIS_STRING_CONST ("InterruptNumber"),
        NDIS_STRING_CONST ("MemoryMappedBaseAddress"),
        NDIS_STRING_CONST ("DmaChannel"),
        //
        // a few drivers use non-standard keywords, so take care of them for now
        //
        NDIS_STRING_CONST ("IoAddress"),
        NDIS_STRING_CONST ("Interrupt"),
        NDIS_STRING_CONST ("IOBase"),
        NDIS_STRING_CONST ("Irq"),
        NDIS_STRING_CONST ("RamAddress")
    };

    UCHAR StandardResourceTypes[STANDARD_RESOURCE_COUNT]=
    {
                        CmResourceTypePort,
                        CmResourceTypeInterrupt,
                        CmResourceTypeMemory,
                        CmResourceTypeDma,
                        CmResourceTypePort,
                        CmResourceTypeInterrupt,
                        CmResourceTypePort,
                        CmResourceTypeInterrupt,
                        CmResourceTypeMemory
    };
    
    static NDIS_CONFIGURATION_PARAMETER BuiltInParameters[BUILT_IN_COUNT] =
        { { NdisParameterInteger, NdisEnvironmentWindowsNt },
          { NdisParameterInteger,
#if defined(_M_IX86)
            NdisProcessorX86
#elif defined(_M_MRX000)
            NdisProcessorMips
#elif defined(_ALPHA_)
            NdisProcessorAlpha
#else
            NdisProcessorPpc
#endif
          },
          { NdisParameterInteger, ((NDIS_MAJOR_VERSION << 16) | NDIS_MINOR_VERSION)}
        };
        
    DBGPRINT_RAW(DBG_COMP_REG, DBG_LEVEL_INFO,
        ("==>NdisReadConfiguration\n"));
    DBGPRINT_RAW(DBG_COMP_REG, DBG_LEVEL_INFO,
        ("    Keyword: "));
    DBGPRINT_UNICODE(DBG_COMP_REG, DBG_LEVEL_INFO,
            Keyword);
    DBGPRINT_RAW(DBG_COMP_REG, DBG_LEVEL_INFO,
        ("\n"));

    ASSERT (KeGetCurrentIrql() < DISPATCH_LEVEL);

    
    do
    {
        KeywordBuffer = Keyword->Buffer;

        //
        // assume failure
        //
        RegistryStatus = STATUS_UNSUCCESSFUL;
        
        //
        // First check if this is one of the built-in parameters.
        //
        for (i = 0; i < BUILT_IN_COUNT; i++)
        {
            if (RtlEqualUnicodeString(Keyword, &BuiltInStrings[i], TRUE))
            {
                RegistryStatus = STATUS_SUCCESS;
                *ParameterValue = &BuiltInParameters[i];
                break;
            }
        }
        
        if (NT_SUCCESS(RegistryStatus))
            break;

        if ((Miniport = (PNDIS_MINIPORT_BLOCK)PQueryTable[3].QueryRoutine) != NULL)
        {
            //
            // check to see if driver is asking for miniport name
            //
            if (RtlEqualUnicodeString(Keyword, &MiniportNameStr, TRUE))
            {
                
                RegistryStatus = ndisSaveParameters(MiniportNameStr.Buffer,
                                                    REG_SZ,
                                                    (PVOID)Miniport->MiniportName.Buffer,
                                                    Miniport->MiniportName.Length,
                                                    (PVOID)ConfigHandle,
                                                    (PVOID)ParameterValue);

                break;  
            }
                
            //
            // check to see if this is a resource keyword
            //
            for (i = 0; i < STANDARD_RESOURCE_COUNT; i++)
            {
                if (RtlEqualUnicodeString(Keyword, &StandardResourceStrings[i], TRUE))
                    break;
            }
            
            if (i < STANDARD_RESOURCE_COUNT)
            {

                NDIS_WARN(TRUE, Miniport, NDIS_GFLAG_WARN_LEVEL_2,
                    ("NdisReadConfiguration: Miniport %p should use NdisMQueryAdapterResources to get the standard resources.\n", Miniport));
            
                do
                {
                    if (Miniport->AllocatedResources == NULL)
                            break;
                            
                    pResourceList = &(Miniport->AllocatedResources->List[0].PartialResourceList);
                                        
                    //
                    // walk through resource list and find the first one that matches
                    //
                    for (j = 0; j < pResourceList->Count; j++)
                    {
                        if (pResourceList->PartialDescriptors[j].Type == StandardResourceTypes[i])
                        {
                            //
                            // could have used  pResourceList->PartialDescriptors[j].Generic.Start.LowPart for all
                            // cases, but in the future, memory value can be 64 bit
                            //
                        
                            switch (StandardResourceTypes[i])
                            {
                            
                                case CmResourceTypePort:
                                    ValueData = pResourceList->PartialDescriptors[j].u.Port.Start.LowPart;
                                    break;
                                    
                                case CmResourceTypeInterrupt:
                                    ValueData = pResourceList->PartialDescriptors[j].u.Interrupt.Level;
                                    break;
                                
                                case CmResourceTypeMemory:
                                    ValueData = pResourceList->PartialDescriptors[j].u.Memory.Start.LowPart;
                                    break;
                                    
                                case CmResourceTypeDma:
                                    ValueData = pResourceList->PartialDescriptors[j].u.Dma.Channel;
                                    break;
                                    
                                default:
                                    ASSERT(FALSE);
                            }
                            
                            //
                            // call SaveParameter ourselves
                            //
                            RegistryStatus = ndisSaveParameters(StandardResourceStrings[i].Buffer,
                                                                REG_DWORD,
                                                                (PVOID)&ValueData,
                                                                sizeof(ULONG),
                                                                (PVOID)ConfigHandle,
                                                                (PVOID)ParameterValue);
                            
                            break;
                        }
                    }
                    
                    if (j >= pResourceList->Count)
                    {
                        RegistryStatus = STATUS_UNSUCCESSFUL;
                    }
                    
                } while (FALSE);
                
                //
                // if keyword was a standard resource keyword, we should break here
                // no matter what the outcome of finding the resource in resource list
                //
                break;
            } // end of if it was a resource keyword
            
        } // end of if NdisReadConfiguration called for a miniport

        //
        // the keyword was not a standard resource or built-in keyword
        // get back to our regular programming...
        //

        //
        // Allocate room for a null-terminated version of the keyword
        //
        if (Keyword->MaximumLength < (Keyword->Length + sizeof(WCHAR)))
        {
            KeywordBuffer = (PWSTR)ALLOC_FROM_POOL(Keyword->Length + sizeof(WCHAR), NDIS_TAG_DEFAULT);
            if (KeywordBuffer == NULL)
            {
                RegistryStatus = STATUS_UNSUCCESSFUL;;
                break;
            }
            CopyMemory(KeywordBuffer, Keyword->Buffer, Keyword->Length);
        }

        if (*(PWCHAR)(((PUCHAR)KeywordBuffer)+Keyword->Length) != (WCHAR)L'\0')
        {
            *(PWCHAR)(((PUCHAR)KeywordBuffer)+Keyword->Length) = (WCHAR)L'\0';
        }

                
        PQueryTable[1].Name = KeywordBuffer;
        PQueryTable[1].EntryContext = ParameterValue;
        
        if (Miniport != NULL)
        {
            PhysicalDeviceObject = Miniport->PhysicalDeviceObject;

            //
            // set the subkey
            //
            PQueryTable[0].Name = PQueryTable[3].Name;
                
#if NDIS_TEST_REG_FAILURE
            RegistryStatus = STATUS_UNSUCCESSFUL;
#else
            RegistryStatus = IoOpenDeviceRegistryKey(PhysicalDeviceObject,
                                                     PLUGPLAY_REGKEY_DRIVER,
                                                     GENERIC_READ | MAXIMUM_ALLOWED,
                                                     &Handle);
                    
#endif

            if(NT_SUCCESS(RegistryStatus))
            {
                RegistryStatus = RtlQueryRegistryValues(RTL_REGISTRY_HANDLE,
                                                        Handle,
                                                        PQueryTable,
                                                        ConfigHandle,                   // context
                                                        NULL);
            }
        }
        else
        {
            //
            // protocols
            //
            RegistryStatus = RtlQueryRegistryValues(RTL_REGISTRY_SERVICES,
                                                    PQueryTable[3].Name,
                                                    PQueryTable,
                                                    ConfigHandle,                   // context
                                                    NULL);
        }

        if (NT_SUCCESS(RegistryStatus))
        {
            //
            // if a value is stored in registry as string but the driver is trying
            // to read it as Integer or HexInteger, do the conversion here
            //
            
            if ((*ParameterValue)->ParameterType == NdisParameterString)
            {
                if (ParameterType == NdisParameterInteger)
                {
                    RtlUnicodeStringToInteger(&(*ParameterValue)->ParameterData.StringData,
                                    10, (PULONG)(&(*ParameterValue)->ParameterData.IntegerData));
                    (*ParameterValue)->ParameterType = NdisParameterInteger;
                }
                else if (ParameterType == NdisParameterHexInteger)
                {
                    RtlUnicodeStringToInteger(&(*ParameterValue)->ParameterData.StringData,
                                    16, (PULONG)(&(*ParameterValue)->ParameterData.IntegerData));
                    (*ParameterValue)->ParameterType = NdisParameterHexInteger;
                }
            }
        }

    } while (FALSE);

    if (KeywordBuffer != Keyword->Buffer)
    {
        FREE_POOL(KeywordBuffer);   // no longer needed
    }

    if (!NT_SUCCESS(RegistryStatus))
    {
        *Status = NDIS_STATUS_FAILURE;
    }
    else
    {
        *Status = NDIS_STATUS_SUCCESS;
    }

    if (Handle)
        ZwClose(Handle);
    
    DBGPRINT_RAW(DBG_COMP_REG, DBG_LEVEL_INFO,
        ("<==NdisReadConfiguration\n"));
    
#undef  PQueryTable
}


VOID
NdisWriteConfiguration(
    OUT PNDIS_STATUS                Status,
    IN NDIS_HANDLE                  ConfigurationHandle,
    IN PNDIS_STRING                 Keyword,
    PNDIS_CONFIGURATION_PARAMETER   ParameterValue
    )
/*++

Routine Description:

    This routine is used to write a parameter to the configuration database.

Arguments:

    Status - Returns the status of the request.

    ConfigurationHandle - Handle passed to the driver

    Keyword - The keyword to set.

    ParameterValue - Specifies the new value for this keyword.

Return Value:

    None.

--*/
{
    PNDIS_CONFIGURATION_HANDLE NdisConfigHandle = (PNDIS_CONFIGURATION_HANDLE)ConfigurationHandle;
    NTSTATUS            RegistryStatus;
    PNDIS_MINIPORT_BLOCK Miniport;
    PWSTR               KeywordBuffer;
    BOOLEAN             FreeKwBuf = FALSE;
    PVOID               ValueData;
    ULONG               ValueLength;
    ULONG               ValueType;
    PDEVICE_OBJECT      PhysicalDeviceObject;
    HANDLE              Handle, RootHandle;
    OBJECT_ATTRIBUTES   ObjAttr;
    UNICODE_STRING      RelativePath;
    
    DBGPRINT_RAW(DBG_COMP_REG, DBG_LEVEL_INFO,
        ("==>NdisWriteConfiguration: ConfigurationHandle %p\n", ConfigurationHandle));
        
    ASSERT (KeGetCurrentIrql() < DISPATCH_LEVEL);

    *Status = NDIS_STATUS_SUCCESS;
    KeywordBuffer = Keyword->Buffer;
    
    do
    {
        //
        // Get the value data.
        //
        switch (ParameterValue->ParameterType)
        {
          case NdisParameterHexInteger:
          case NdisParameterInteger:
            ValueData = &ParameterValue->ParameterData.IntegerData;
            ValueLength = sizeof(ParameterValue->ParameterData.IntegerData);
            ValueType = REG_DWORD;
            break;

          case NdisParameterString:
            ValueData = ParameterValue->ParameterData.StringData.Buffer;
            ValueLength = ParameterValue->ParameterData.StringData.Length;
            ValueType = REG_SZ;
            break;

          case NdisParameterMultiString:
            ValueData = ParameterValue->ParameterData.StringData.Buffer;
            ValueLength = ParameterValue->ParameterData.StringData.Length;
            ValueType = REG_MULTI_SZ;
            break;

          case NdisParameterBinary:
            ValueData = ParameterValue->ParameterData.BinaryData.Buffer;
            ValueLength = ParameterValue->ParameterData.BinaryData.Length;
            ValueType = REG_BINARY;
            break;

          default:
            *Status = NDIS_STATUS_NOT_SUPPORTED;
            break;
        }

        if (*Status != NDIS_STATUS_SUCCESS)
            break;

        if (Keyword->MaximumLength <= (Keyword->Length + sizeof(WCHAR)))
        {
            KeywordBuffer = (PWSTR)ALLOC_FROM_POOL(Keyword->Length + sizeof(WCHAR), NDIS_TAG_DEFAULT);
            if (KeywordBuffer == NULL)
            {
                *Status = NDIS_STATUS_RESOURCES;
                break;
            }
            CopyMemory(KeywordBuffer, Keyword->Buffer, Keyword->Length);
            FreeKwBuf = TRUE;
        }

        if (*(PWCHAR)(((PUCHAR)KeywordBuffer)+Keyword->Length) != (WCHAR)L'\0')
        {
            *(PWCHAR)(((PUCHAR)KeywordBuffer)+Keyword->Length) = (WCHAR)L'\0';
        }
        
        if ((Miniport = (PNDIS_MINIPORT_BLOCK)NdisConfigHandle->KeyQueryTable[3].QueryRoutine) != NULL)
        {
            //
            // Adapters
            //
            PhysicalDeviceObject = Miniport->PhysicalDeviceObject;

#if NDIS_TEST_REG_FAILURE
            RegistryStatus = STATUS_UNSUCCESSFUL;
            RootHandle = NULL;
#else
            RegistryStatus = IoOpenDeviceRegistryKey(PhysicalDeviceObject,
                                                     PLUGPLAY_REGKEY_DRIVER,
                                                     GENERIC_WRITE | MAXIMUM_ALLOWED,
                                                     &RootHandle);
                                    
#endif
            if (!NT_SUCCESS(RegistryStatus))
            {
                *Status = NDIS_STATUS_FAILURE;
                break;
            }

            RtlInitUnicodeString(&RelativePath, NdisConfigHandle->KeyQueryTable[3].Name);
            
            InitializeObjectAttributes(&ObjAttr,
                                       &RelativePath,
                                       OBJ_CASE_INSENSITIVE,
                                       RootHandle,
                                       NULL);
                                    
            RegistryStatus = ZwOpenKey(&Handle,
                                       GENERIC_READ | MAXIMUM_ALLOWED,
                                       &ObjAttr);
                            
            if (NT_SUCCESS(RegistryStatus))
            {
                RegistryStatus = RtlWriteRegistryValue(RTL_REGISTRY_HANDLE,
                                                       Handle,
                                                       KeywordBuffer,
                                                       ValueType,
                                                       ValueData,
                                                       ValueLength);

                ZwClose (Handle);
            }
                
            ZwClose (RootHandle);
        }
        else
        {
            //
            // protocols
            //
            RegistryStatus = RtlWriteRegistryValue(RTL_REGISTRY_SERVICES,
                                                   NdisConfigHandle->KeyQueryTable[3].Name,
                                                   KeywordBuffer,
                                                   ValueType,
                                                   ValueData,
                                                   ValueLength);
        }
        
        if (!NT_SUCCESS(RegistryStatus))
        {
            *Status = NDIS_STATUS_FAILURE;
        }

    } while (FALSE);

    if (FreeKwBuf)
    {
        FREE_POOL(KeywordBuffer);   // no longer needed
    }
    
    DBGPRINT_RAW(DBG_COMP_REG, DBG_LEVEL_INFO,
        ("<==NdisWriteConfiguration: ConfigurationHandle %p\n", ConfigurationHandle));
}


VOID
NdisCloseConfiguration(
    IN NDIS_HANDLE                  ConfigurationHandle
    )
/*++

Routine Description:

    This routine is used to close a configuration database opened by
    NdisOpenConfiguration.

Arguments:

    ConfigurationHandle - Handle returned by NdisOpenConfiguration.

Return Value:

    None.

--*/
{
    //
    // Obtain the actual configuration handle structure
    //
    PNDIS_CONFIGURATION_HANDLE  NdisConfigHandle = (PNDIS_CONFIGURATION_HANDLE)ConfigurationHandle;
    PNDIS_CONFIGURATION_PARAMETER_QUEUE ParameterNode;

    DBGPRINT_RAW(DBG_COMP_REG, DBG_LEVEL_INFO,
        ("==>NdisCloseConfiguration: ConfigurationHandle %p\n", ConfigurationHandle));
        
    ASSERT (KeGetCurrentIrql() < DISPATCH_LEVEL);

    //
    // deallocate the parameter nodes
    //
    ParameterNode = NdisConfigHandle->ParameterList;

    while (ParameterNode != NULL)
    {
        NdisConfigHandle->ParameterList = ParameterNode->Next;

        FREE_POOL(ParameterNode);

        ParameterNode = NdisConfigHandle->ParameterList;
    }

    FREE_POOL(ConfigurationHandle);
                
    DBGPRINT_RAW(DBG_COMP_REG, DBG_LEVEL_INFO,
        ("<==NdisCloseConfiguration: ConfigurationHandle %p\n", ConfigurationHandle));
}


VOID
NdisReadNetworkAddress(
    OUT PNDIS_STATUS                Status,
    OUT PVOID *                     NetworkAddress,
    OUT PUINT                       NetworkAddressLength,
    IN NDIS_HANDLE                  ConfigurationHandle
    )
/*++

Routine Description:

    This routine is used to read the "NetworkAddress" parameter
    from the configuration database. It reads the value as a
    string separated by hyphens, then converts it to a binary
    array and stores the result.

Arguments:

    Status - Returns the status of the request.

    NetworkAddress - Returns a pointer to the address.

    NetworkAddressLength - Returns the length of the address.

    ConfigurationHandle - Handle returned by NdisOpenConfiguration. Points
    to the parameter subkey.

Return Value:

    None.

--*/
{
    NDIS_STRING                     NetAddrStr = NDIS_STRING_CONST("NetworkAddress");
    PNDIS_CONFIGURATION_PARAMETER   ParameterValue;
    NTSTATUS                        NtStatus;
    UCHAR                           ConvertArray[3];
    PWSTR                           CurrentReadLoc;
    PWSTR                           AddressEnd;
    PUCHAR                          CurrentWriteLoc;
    UINT                            TotalBytesRead;
    ULONG                           TempUlong;
    ULONG                           AddressLength;
    PNDIS_MINIPORT_BLOCK            Miniport;

    DBGPRINT_RAW(DBG_COMP_REG, DBG_LEVEL_INFO,
        ("==>NdisReadNetworkAddress: ConfigurationHandle %p\n", ConfigurationHandle));

    ASSERT (KeGetCurrentIrql() < DISPATCH_LEVEL);
    
    Miniport = (PNDIS_MINIPORT_BLOCK)((PNDIS_CONFIGURATION_HANDLE)ConfigurationHandle)->KeyQueryTable[3].QueryRoutine;

    ASSERT(Miniport != NULL);
    ASSERT(Miniport->Signature == (PVOID)MINIPORT_DEVICE_MAGIC_VALUE);

    if (Miniport->Signature == (PVOID)MINIPORT_DEVICE_MAGIC_VALUE)
    {
        Miniport->MacOptions |= NDIS_MAC_OPTION_SUPPORTS_MAC_ADDRESS_OVERWRITE;
        Miniport->InfoFlags |= NDIS_MINIPORT_SUPPORTS_MAC_ADDRESS_OVERWRITE;
    }
        
    do
    {
        //
        // First read the "NetworkAddress" from the registry
        //
        NdisReadConfiguration(Status, &ParameterValue, ConfigurationHandle, &NetAddrStr, NdisParameterString);

        if ((*Status != NDIS_STATUS_SUCCESS) ||
            (ParameterValue->ParameterType != NdisParameterString))
        {
            *Status = NDIS_STATUS_FAILURE;
            break;
        }

        //
        //  If there is not an address specified then exit now.
        //
        if (0 == ParameterValue->ParameterData.StringData.Length)
        {
            *Status = NDIS_STATUS_FAILURE;
            break;
        }

        //
        // Now convert the address to binary (we do this
        // in-place, since this allows us to use the memory
        // already allocated which is automatically freed
        // by NdisCloseConfiguration).
        //

        ConvertArray[2] = '\0';
        CurrentReadLoc = (PWSTR)ParameterValue->ParameterData.StringData.Buffer;
        CurrentWriteLoc = (PUCHAR)CurrentReadLoc;
        TotalBytesRead = ParameterValue->ParameterData.StringData.Length;
        AddressEnd = CurrentReadLoc + (TotalBytesRead / sizeof(WCHAR));
        AddressLength = 0;

        while ((CurrentReadLoc+2) <= AddressEnd)
        {
            //
            // Copy the current two-character value into ConvertArray
            //
            ConvertArray[0] = (UCHAR)(*(CurrentReadLoc++));
            ConvertArray[1] = (UCHAR)(*(CurrentReadLoc++));

            //
            // Convert it to a Ulong and update
            //
            NtStatus = RtlCharToInteger(ConvertArray, 16, &TempUlong);

            if (!NT_SUCCESS(NtStatus))
            {
                *Status = NDIS_STATUS_FAILURE;
                break;
            }

            *(CurrentWriteLoc++) = (UCHAR)TempUlong;
            ++AddressLength;

            //
            // If the next character is a hyphen, skip it.
            //
            if (CurrentReadLoc < AddressEnd)
            {
                if (*CurrentReadLoc == (WCHAR)L'-')
                {
                    ++CurrentReadLoc;
                }
            }
        }

        if (NtStatus != NDIS_STATUS_SUCCESS)
            break;

        *Status = NDIS_STATUS_SUCCESS;
        *NetworkAddress = ParameterValue->ParameterData.StringData.Buffer;
        *NetworkAddressLength = AddressLength;
        if (AddressLength == 0)
        {
            *Status = NDIS_STATUS_FAILURE;
        }
    } while (FALSE);
    
    DBGPRINT_RAW(DBG_COMP_REG, DBG_LEVEL_INFO,
        ("<==NdisReadNetworkAddress: ConfigurationHandle %p\n", ConfigurationHandle));
}


VOID
NdisConvertStringToAtmAddress(
    OUT PNDIS_STATUS            Status,
    IN  PNDIS_STRING            String,
    OUT PATM_ADDRESS            AtmAddress
    )
/*++

Routine Description:


Arguments:

    Status - Returns the status of the request.

    String - String representation of the atm address.

    *   Format defined in Section 5.4,
    *       "Example Master File Format" in ATM95-1532R4 ATM Name System:
    *
    *   AESA format: a string of hexadecimal digits, with '.' characters for punctuation, e.g.
    *
    *       39.246f.00.0e7c9c.0312.0001.0001.000012345678.00
    *
    *   E164 format: A '+' character followed by a string of
    *       decimal digits, with '.' chars for punctuation, e.g.:
    *
    *           +358.400.1234567

    AtmAddress - The converted Atm address is returned here.

Return Value:

    None.

--*/
{
    USHORT          i, j, NumDigits;
    PWSTR           p, q;
    UNICODE_STRING  Us;
    ANSI_STRING     As;
    
    DBGPRINT_RAW(DBG_COMP_REG, DBG_LEVEL_INFO,
        ("==>NdisConvertStringToAtmAddress\n"));

    //
    // Start off by stripping the punctuation characters from the string. We do this in place.
    //
    for (i = NumDigits = 0, j = String->Length/sizeof(WCHAR), p = q = String->Buffer;
         (i < j) && (*p != 0);
         i++, p++)
    {
        if ((*p == ATM_ADDR_BLANK_CHAR) ||
            (*p == ATM_ADDR_PUNCTUATION_CHAR))
        {
            continue;
        }
        *q++ = *p;
        NumDigits ++;
    }

    //
    // Look at the first character to determine if the address is E.164 or NSAP.
    // If the address isn't long enough, we assume that it is native E.164.
    //
    p = String->Buffer;
    if ((*p == ATM_ADDR_E164_START_CHAR) || (NumDigits <= 15))
    {
        if (*p == ATM_ADDR_E164_START_CHAR)
        {
            p ++;
            NumDigits --;
        }
        if ((NumDigits == 0) || (NumDigits > ATM_ADDRESS_LENGTH))
        {
            *Status = NDIS_STATUS_INVALID_LENGTH;
            return;
        }
        AtmAddress->AddressType = ATM_E164;
        AtmAddress->NumberOfDigits = NumDigits;
    }
    else
    {
        if (NumDigits != 2*ATM_ADDRESS_LENGTH)
        {
            *Status = NDIS_STATUS_INVALID_LENGTH;
            return;
        }
        AtmAddress->AddressType = ATM_NSAP;
        AtmAddress->NumberOfDigits = NumDigits/sizeof(WCHAR);
    }

    //
    // Convert the address to Ansi now
    //
    Us.Buffer = p;
    Us.Length = Us.MaximumLength = NumDigits*sizeof(WCHAR);
    As.Buffer = ALLOC_FROM_POOL(NumDigits + 1, NDIS_TAG_CO);
    As.Length = 0;
    As.MaximumLength = NumDigits + 1;
    if (As.Buffer == NULL)
    {
        *Status = NDIS_STATUS_RESOURCES;
        return;
    }

    *Status = NdisUnicodeStringToAnsiString(&As, &Us);
    if (!NT_SUCCESS(*Status))
    {
        FREE_POOL(As.Buffer);
        *Status = NDIS_STATUS_FAILURE;
        return;
    }

    //
    //  Now get the bytes into the destination ATM Address structure.
    //
    if (AtmAddress->AddressType == ATM_E164)
    {
        //
        //  We just need to copy in the digits in ANSI form.
        //
        NdisMoveMemory(AtmAddress->Address, As.Buffer, NumDigits);
    }
    else
    {
        //
        //  This is in NSAP form. We need to pack the hex digits.
        //
        UCHAR           xxString[3];
        ULONG           val;

        xxString[2] = 0;
        for (i = 0; i < ATM_ADDRESS_LENGTH; i++)
        {
            xxString[0] = As.Buffer[i*2];
            xxString[1] = As.Buffer[i*2+1];
            *Status = CHAR_TO_INT(xxString, 16, &val);
            if (!NT_SUCCESS(*Status))
            {
                FREE_POOL(As.Buffer);
                *Status = NDIS_STATUS_FAILURE;
                return;
            }
            AtmAddress->Address[i] = (UCHAR)val;
        }
    }

    FREE_POOL(As.Buffer);
    
    DBGPRINT_RAW(DBG_COMP_REG, DBG_LEVEL_INFO,
        ("<==NdisConvertStringToAtmAddress\n"));

    *Status = NDIS_STATUS_SUCCESS;
}


NTSTATUS
ndisSaveParameters(
    IN PWSTR                        ValueName,
    IN ULONG                        ValueType,
    IN PVOID                        ValueData,
    IN ULONG                        ValueLength,
    IN PVOID                        Context,
    IN PVOID                        EntryContext
    )
/*++

Routine Description:

    This routine is a callback routine for RtlQueryRegistryValues
    It is called with the value for a specified parameter. It allocates
    memory to hold the data and copies it over.

Arguments:

    ValueName - The name of the value (ignored).

    ValueType - The type of the value.

    ValueData - The null-terminated data for the value.

    ValueLength - The length of ValueData.

    Context - Points to the head of the parameter chain.

    EntryContext - A pointer to

Return Value:

    STATUS_SUCCESS

--*/
{
    NDIS_STATUS Status;

    //
    // Obtain the actual configuration handle structure
    //
    PNDIS_CONFIGURATION_HANDLE NdisConfigHandle = (PNDIS_CONFIGURATION_HANDLE)Context;

    //
    // Where the user wants a pointer returned to the data.
    //
    PNDIS_CONFIGURATION_PARAMETER *ParameterValue = (PNDIS_CONFIGURATION_PARAMETER *)EntryContext;

    //
    // Use this to link parameters allocated to this open
    //
    PNDIS_CONFIGURATION_PARAMETER_QUEUE ParameterNode;

    //
    // Size of memory to allocate for parameter node
    //
    UINT    Size;

    //
    // Allocate our parameter node
    //
    Size = sizeof(NDIS_CONFIGURATION_PARAMETER_QUEUE);
    if ((ValueType == REG_SZ) || (ValueType == REG_MULTI_SZ) || (ValueType == REG_BINARY))
    {
        Size += ValueLength;
    }
    
    ParameterNode = ALLOC_FROM_POOL(Size, NDIS_TAG_PARAMETER_NODE);

    Status = (ParameterNode != NULL) ? NDIS_STATUS_SUCCESS : STATUS_INSUFFICIENT_RESOURCES;
    
    if (Status != NDIS_STATUS_SUCCESS)
    {
        return (NTSTATUS)Status;
    }

    *ParameterValue = &ParameterNode->Parameter;

    //
    // Map registry datatypes to ndis data types
    //
    if (ValueType == REG_DWORD)
    {
        //
        // The registry says that the data is in a dword boundary.
        //
        (*ParameterValue)->ParameterType = NdisParameterInteger;
        (*ParameterValue)->ParameterData.IntegerData = *((PULONG) ValueData);
    }
    else if ((ValueType == REG_SZ) || (ValueType == REG_MULTI_SZ))
    {
        (*ParameterValue)->ParameterType =
            (ValueType == REG_SZ) ? NdisParameterString : NdisParameterMultiString;

        (*ParameterValue)->ParameterData.StringData.Buffer = (PWSTR)((PUCHAR)ParameterNode + sizeof(NDIS_CONFIGURATION_PARAMETER_QUEUE));

        CopyMemory((*ParameterValue)->ParameterData.StringData.Buffer,
                   ValueData,
                   ValueLength);
        (*ParameterValue)->ParameterData.StringData.Length = (USHORT)ValueLength;
        (*ParameterValue)->ParameterData.StringData.MaximumLength = (USHORT)ValueLength;

        //
        // Special fix; if a string ends in a NULL and that is included
        // in the length, remove it.
        //
        if (ValueType == REG_SZ)
        {
            if ((((PUCHAR)ValueData)[ValueLength-1] == 0) &&
                (((PUCHAR)ValueData)[ValueLength-2] == 0))
            {
                (*ParameterValue)->ParameterData.StringData.Length -= 2;
            }
        }
    }
    else if (ValueType == REG_BINARY)
    {
        (*ParameterValue)->ParameterType = NdisParameterBinary;
        (*ParameterValue)->ParameterData.BinaryData.Buffer = ValueData;
        (*ParameterValue)->ParameterData.BinaryData.Length = (USHORT)ValueLength;
        (*ParameterValue)->ParameterData.BinaryData.Buffer = (PWSTR)((PUCHAR)ParameterNode + sizeof(NDIS_CONFIGURATION_PARAMETER_QUEUE));
        CopyMemory((*ParameterValue)->ParameterData.BinaryData.Buffer,
                   ValueData,
                   ValueLength);
    }
    else
    {
        FREE_POOL(ParameterNode);
        return STATUS_OBJECT_NAME_NOT_FOUND;
    }

    //
    // Queue this parameter node
    //
    ParameterNode->Next = NdisConfigHandle->ParameterList;
    NdisConfigHandle->ParameterList = ParameterNode;

    return STATUS_SUCCESS;
}


NTSTATUS
ndisReadParameter(
    IN PWSTR                        ValueName,
    IN ULONG                        ValueType,
    IN PVOID                        ValueData,
    IN ULONG                        ValueLength,
    IN PVOID                        Context,
    IN PVOID                        EntryContext
    )
/*++

Routine Description:

    This routine is a callback routine for RtlQueryRegistryValues
    It is called with the values for the "Bind" and "Export" multi-strings
    for a given driver. It allocates memory to hold the data and copies
    it over.

Arguments:

    ValueName - The name of the value ("Bind" or "Export" -- ignored).

    ValueType - The type of the value (REG_MULTI_SZ -- ignored).

    ValueData - The null-terminated data for the value.

    ValueLength - The length of ValueData.

    Context - Unused.

    EntryContext - A pointer to the pointer that holds the copied data.

Return Value:

    STATUS_SUCCESS

--*/
{
    PUCHAR * Data = ((PUCHAR *)EntryContext);

    UNREFERENCED_PARAMETER(ValueName);

    //
    // Allocate one DWORD more and zero is out
    //
    *Data = ALLOC_FROM_POOL(ValueLength + sizeof(ULONG), NDIS_TAG_REG_READ_DATA_BUFFER);

    if (*Data == NULL)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    ZeroMemory(*Data, ValueLength + sizeof(ULONG));
    CopyMemory(*Data, ValueData, ValueLength);

    if (Context)
    {
        *((PULONG)Context) = ValueType;
    }
    
    return STATUS_SUCCESS;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ndis\sys\initpnp.c ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation

Module Name:

    initpnp.c

Abstract:

    NDIS wrapper functions initializing drivers.

Author:

    Jameel Hyder (jameelh) 11-Aug-1995

Environment:

    Kernel mode, FSD

Revision History:

--*/


#include <precomp.h>
#pragma hdrstop

#include <stdarg.h>

//
//  Define the module number for debug code.
//
#define MODULE_NUMBER   MODULE_INITPNP

NDIS_STATUS
ndisInitializeConfiguration(
    OUT PNDIS_WRAPPER_CONFIGURATION_HANDLE  pConfigurationHandle,
    IN  PNDIS_MINIPORT_BLOCK                Miniport,
    OUT PUNICODE_STRING                     pExportName OPTIONAL
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
#define PQueryTable pConfigurationHandle->ParametersQueryTable
#define LQueryTable pConfigurationHandle->ParametersQueryTable

    NDIS_STATUS                     NdisStatus;
    PWSTR                           Export = NULL;
    NTSTATUS                        RegistryStatus;
    PNDIS_CONFIGURATION_PARAMETER   ReturnedValue;
    NDIS_CONFIGURATION_HANDLE       CnfgHandle;
    NDIS_STRING                     BusNumberStr = NDIS_STRING_CONST("BusNumber");
    NDIS_STRING                     SlotNumberStr = NDIS_STRING_CONST("SlotNumber");
    NDIS_STRING                     BusTypeStr = NDIS_STRING_CONST("BusType");
    NDIS_STRING                     PciIdStr = NDIS_STRING_CONST("AdapterCFID");
    NDIS_STRING                     PnPCapsStr = NDIS_STRING_CONST("PnPCapabilities");
    NDIS_STRING                     CharsStr = NDIS_STRING_CONST("Characteristics");
    NDIS_STRING                     RemoteBootStr = NDIS_STRING_CONST("RemoteBootCard");
    NDIS_STRING                     MediaDisconnectTimeOutStr = NDIS_STRING_CONST("MediaDisconnectToSleepTimeOut");
    NDIS_STRING                     PollMediaConnectivityStr = NDIS_STRING_CONST("RequiresMediaStatePoll");
    NDIS_STRING                     NdisDriverVerifyFlagsStr = NDIS_STRING_CONST("NdisDriverVerifyFlags");
    NDIS_STRING                     SGMapRegistersNeededStr = NDIS_STRING_CONST("SGMapRegistersNeeded");
    ULONG                           MediaDisconnectTimeOut;
    HANDLE                          Handle;
    PDEVICE_OBJECT                  PhysicalDeviceObject;
    NDIS_INTERFACE_TYPE             BusType = Isa;
    UINT                            BusNumber = 0;
    ULONG                           ResultLength;
    PNDIS_CONFIGURATION_PARAMETER_QUEUE ParameterNode;
    GUID                            BusTypeGuid;
    
    DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
        ("==>ndisInitializeConfiguration: Miniport %p\n", Miniport));
        
    CnfgHandle.ParameterList = NULL;
    
    do
    {
        PhysicalDeviceObject = Miniport->PhysicalDeviceObject;

        if (Miniport->BindPaths == NULL)
        {
            NdisStatus = ndisReadBindPaths(Miniport, LQueryTable);
            if (NdisStatus != NDIS_STATUS_SUCCESS)
            {
                break;
            }
        }

        if (pExportName != NULL)
        {
            //
            // get a handle to "driver" section for PDO
            //
#if NDIS_TEST_REG_FAILURE
            RegistryStatus = STATUS_UNSUCCESSFUL;
            Handle = NULL;
#else
            RegistryStatus = IoOpenDeviceRegistryKey(PhysicalDeviceObject,
                                                     PLUGPLAY_REGKEY_DRIVER,
                                                     GENERIC_READ | MAXIMUM_ALLOWED,
                                                     &Handle);
#endif

#if !NDIS_NO_REGISTRY
            if (!NT_SUCCESS(RegistryStatus))
            {
                NdisStatus = NDIS_STATUS_FAILURE;
                break;
            }
            
            //
            // Set up LQueryTable to do the following:
            //
        
            //
            // 1. Switch to the Linkage key below this driver instance key
            //
            LQueryTable[0].QueryRoutine = NULL;
            LQueryTable[0].Flags = RTL_QUERY_REGISTRY_SUBKEY;
            LQueryTable[0].Name = L"Linkage";
        
            //
            // 2. Call ndisReadParameter for "Export" (as a single multi-string)
            //    which will allocate storage and save the data in Export.
            //
            LQueryTable[1].QueryRoutine = ndisReadParameter;
            LQueryTable[1].Flags = RTL_QUERY_REGISTRY_REQUIRED | RTL_QUERY_REGISTRY_NOEXPAND;
            LQueryTable[1].Name = L"Export";
            LQueryTable[1].EntryContext = (PVOID)&Export;
            LQueryTable[1].DefaultType = REG_NONE;
        
            //
            // 3. Stop
            //
            LQueryTable[2].QueryRoutine = NULL;
            LQueryTable[2].Flags = 0;
            LQueryTable[2].Name = NULL;
            
            RegistryStatus = RtlQueryRegistryValues(RTL_REGISTRY_HANDLE,
                                                    Handle,
                                                    LQueryTable,
                                                    (PVOID)NULL,      // no context needed
                                                    NULL);

            ZwClose(Handle);
                
            if (!NT_SUCCESS(RegistryStatus))
            {
                DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
                        ("ndisInitializeConfiguration: Could not read Bind/Export for %Z: %lx\n",
                        &Miniport->BaseName,
                        RegistryStatus));

                NdisStatus = NDIS_STATUS_FAILURE;
                break;
            }
#else
            if (NT_SUCCESS(RegistryStatus))
            {
            
                //
                // Set up LQueryTable to do the following:
                //
            
                //
                // 1. Switch to the Linkage key below this driver instance key
                //
                LQueryTable[0].QueryRoutine = NULL;
                LQueryTable[0].Flags = RTL_QUERY_REGISTRY_SUBKEY;
                LQueryTable[0].Name = L"Linkage";
            
                //
                // 2. Call ndisReadParameter for "Export" (as a single multi-string)
                //    which will allocate storage and save the data in Export.
                //
                LQueryTable[1].QueryRoutine = ndisReadParameter;
                LQueryTable[1].Flags = RTL_QUERY_REGISTRY_REQUIRED | RTL_QUERY_REGISTRY_NOEXPAND;
                LQueryTable[1].Name = L"Export";
                LQueryTable[1].EntryContext = (PVOID)&Export;
                LQueryTable[1].DefaultType = REG_NONE;
            
                //
                // 3. Stop
                //
                LQueryTable[2].QueryRoutine = NULL;
                LQueryTable[2].Flags = 0;
                LQueryTable[2].Name = NULL;
                
                RegistryStatus = RtlQueryRegistryValues(RTL_REGISTRY_HANDLE,
                                                        Handle,
                                                        LQueryTable,
                                                        (PVOID)NULL,      // no context needed
                                                        NULL);

                ZwClose(Handle);
                    
                if (!NT_SUCCESS(RegistryStatus))
                {
                    DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
                            ("ndisInitializeConfiguration: Could not read Bind/Export for %Z: %lx\n",
                            &Miniport->BaseName,
                            RegistryStatus));

                    NdisStatus = NDIS_STATUS_FAILURE;
                    break;
                }
            }
            else
            {
                //
                // we have to allocate space for default export name because the
                // caller will attempt to free it
                //

                Export = (PWSTR)ALLOC_FROM_POOL(sizeof(NDIS_DEFAULT_EXPORT_NAME),
                                                                NDIS_TAG_NAME_BUF);
                if (Export == NULL)
                {
                    NdisStatus = STATUS_INSUFFICIENT_RESOURCES;
                    break;
                }

                RtlCopyMemory(Export, ndisDefaultExportName, sizeof(NDIS_DEFAULT_EXPORT_NAME));
                
            
            }
#endif
            RtlInitUnicodeString(pExportName, Export);
        }   
        //
        // NdisReadConfiguration assumes that ParametersQueryTable[3].Name is
        // a key below the services key where the Parameters should be read,
        // for layered drivers we store the last piece of Configuration
        // Path there, leading to the desired effect.
        //
        // I.e, ConfigurationPath == "...\Services\Driver".
        //
        
        //
        // 1) Call ndisSaveParameter for a parameter, which will allocate storage for it.
        //
        PQueryTable[0].QueryRoutine = NULL;
        PQueryTable[0].Flags = RTL_QUERY_REGISTRY_SUBKEY;
        PQueryTable[0].Name = L"";

        //
        // The following fields are filled in during NdisReadConfiguration
        //
        // PQueryTable[1].Name = KeywordBuffer;
        // PQueryTable[1].EntryContext = ParameterValue;
        
        PQueryTable[1].QueryRoutine = ndisSaveParameters;
        PQueryTable[1].Flags = RTL_QUERY_REGISTRY_REQUIRED | RTL_QUERY_REGISTRY_NOEXPAND;
        PQueryTable[1].DefaultType = REG_NONE;
    
        //
        // 2. Stop
        //
        PQueryTable[2].QueryRoutine = NULL;
        PQueryTable[2].Flags = 0;
        PQueryTable[2].Name = NULL;
    
        //
        // NOTE: Some fields in ParametersQueryTable[3 & 4] are used to
        // store information for later retrieval.
        // Save Adapter/Miniport block here. Later on, Adapter's PDO
        // will be used to open the appropiate registry key
        //
        (PVOID)PQueryTable[3].QueryRoutine = (PVOID)Miniport;
        PQueryTable[3].Name = L"";
        PQueryTable[3].EntryContext = NULL;
        PQueryTable[3].DefaultData = NULL;
            
        
        // Now read bustype/busnumber for this adapter and save it
        CnfgHandle.KeyQueryTable = PQueryTable;

        RegistryStatus = IoGetDeviceProperty(PhysicalDeviceObject,
                                             DevicePropertyBusTypeGuid,
                                             sizeof(GUID),
                                             (PVOID)&BusTypeGuid,
                                             &ResultLength);
        
        //
        // try to get the -real- bus type by first querying the bustype guid
        // if we couldn't get the guid, try to get a legacy bustype. because
        // some bus drivers like pcmcia do not report the real bus type, we 
        // have to query the bus type guid first.
        // 

        if (NT_SUCCESS(RegistryStatus))
        {
            if (!memcmp(&BusTypeGuid, &GUID_BUS_TYPE_INTERNAL, sizeof(GUID)))
                BusType = Internal;
            else if (!memcmp(&BusTypeGuid, &GUID_BUS_TYPE_PCMCIA, sizeof(GUID)))
                BusType = PCMCIABus;
            else if (!memcmp(&BusTypeGuid, &GUID_BUS_TYPE_PCI, sizeof(GUID)))
                BusType = PCIBus;
            else if (!memcmp(&BusTypeGuid, &GUID_BUS_TYPE_ISAPNP, sizeof(GUID)))
                BusType = PNPISABus;
            else if (!memcmp(&BusTypeGuid, &GUID_BUS_TYPE_EISA, sizeof(GUID)))
            {
                BusType = Eisa;
                ASSERT(BusType != Eisa);
            }
            else
                BusType = Isa;
        }
        
        if (BusType == Isa)
        {
            //
            // either the call to get BusTypeGuid failed or the returned guid
            // does not match any that we know of
            //
            RegistryStatus = IoGetDeviceProperty(PhysicalDeviceObject,
                                                 DevicePropertyLegacyBusType,
                                                 sizeof(UINT),
                                                 (PVOID)&BusType,
                                                 &ResultLength);
        }

        
        if (!NT_SUCCESS(RegistryStatus) 
            || (BusType == Isa)
            || (BusType == PCMCIABus))
        {

            if (NT_SUCCESS(RegistryStatus))
            {
                ASSERT(BusType != Isa);
            }
            
            //
            // if the call was unsuccessful or BusType is ISA or PCMCIABus
            // read BusType from registry
            //
            NdisReadConfiguration(&NdisStatus,
                                  &ReturnedValue,
                                  &CnfgHandle,
                                  &BusTypeStr,
                                  NdisParameterInteger);
                                  
            if (NdisStatus == NDIS_STATUS_SUCCESS)
            {
                BusType = (NDIS_INTERFACE_TYPE)(ReturnedValue->ParameterData.IntegerData);
            }
        }
        
        if ((BusType == PCIBus) ||
            (BusType == PCMCIABus))
        {               
            ASSERT(CURRENT_IRQL < DISPATCH_LEVEL);
            NdisStatus = ndisQueryBusInterface(Miniport);

            if (NdisStatus != NDIS_STATUS_SUCCESS)
            {
                ASSERT(FALSE);
                break;
            }
        }

        if ((BusType == Eisa) ||
            (BusType == MicroChannel))
        {
            NdisStatus = NDIS_STATUS_NOT_SUPPORTED; 
            break;
        }

        Miniport->BusType = BusType;
        
        //
        // Read PnP capabilities. By default the WOL feature should be disabled
        // 
        //
        NdisReadConfiguration(&NdisStatus,
                              &ReturnedValue,
                              &CnfgHandle,
                              &PnPCapsStr,
                              NdisParameterInteger);
    
        if (NdisStatus == NDIS_STATUS_SUCCESS)
        {
            Miniport->PnPCapabilities = ReturnedValue->ParameterData.IntegerData;
        }
        else
        {
            Miniport->PnPCapabilities =  NDIS_DEVICE_DISABLE_WAKE_UP;
                                                               
        }


        //
        // try to get the bus number from PnP and if it fails
        // try reading it from registry
        //
        RegistryStatus = IoGetDeviceProperty(PhysicalDeviceObject,
                                             DevicePropertyBusNumber,
                                             sizeof(UINT),
                                             (PVOID)&BusNumber,
                                             &ResultLength);
                                
        if (!NT_SUCCESS(RegistryStatus))
        {
            //
            // if the call was unsuccessful
            // Read Bus Number from registry
            //
            NdisReadConfiguration(&NdisStatus,
                                  &ReturnedValue,
                                  &CnfgHandle,
                                  &BusNumberStr,
                                  NdisParameterInteger);
        
            if (NdisStatus == NDIS_STATUS_SUCCESS)
            {
                BusNumber = ReturnedValue->ParameterData.IntegerData;
            }
        }
        
        Miniport->BusNumber = BusNumber;
        
        //
        // Read Slot Number
        //
        NdisReadConfiguration(&NdisStatus,
                              &ReturnedValue,
                              &CnfgHandle,
                              &SlotNumberStr,
                              NdisParameterInteger);
    
        if (NdisStatus == NDIS_STATUS_SUCCESS)
        {
            Miniport->SlotNumber = ReturnedValue->ParameterData.IntegerData;
        }
        else
        {
            Miniport->SlotNumber = -1;
        }

        NdisReadConfiguration(&NdisStatus,
                              &ReturnedValue,
                              &CnfgHandle,
                              &RemoteBootStr,
                              NdisParameterHexInteger);

        if (NdisStatus == NDIS_STATUS_SUCCESS)
        {
            if (ReturnedValue->ParameterData.IntegerData != 0)
            {
                MINIPORT_SET_FLAG(Miniport, fMINIPORT_NETBOOT_CARD);
                Miniport->InfoFlags |= NDIS_MINIPORT_NETBOOT_CARD;
            }
        }
        //
        // read the value for media disconnect timer, set to 20 seconds if not present
        // default=disable pm when cable is disconnected
        //
        MediaDisconnectTimeOut = -1;
        
        NdisReadConfiguration(&NdisStatus,
                              &ReturnedValue,
                              &CnfgHandle,
                              &MediaDisconnectTimeOutStr,
                              NdisParameterHexInteger);

        if (NdisStatus == NDIS_STATUS_SUCCESS)
        {
            MediaDisconnectTimeOut = ReturnedValue->ParameterData.IntegerData;
            if (MediaDisconnectTimeOut == 0)
            {
                MediaDisconnectTimeOut = 1;
            }
        }
        
        Miniport->MediaDisconnectTimeOut = (USHORT)MediaDisconnectTimeOut;
        
        if (MediaDisconnectTimeOut == (ULONG)(-1))
        {
            Miniport->PnPCapabilities |= NDIS_DEVICE_DISABLE_WAKE_ON_RECONNECT;
        }
        
        NdisReadConfiguration(&NdisStatus,
                              &ReturnedValue,
                              &CnfgHandle,
                              &PollMediaConnectivityStr,
                              NdisParameterInteger);
        if (NdisStatus == NDIS_STATUS_SUCCESS)
        {
            //
            // This miniport wants Ndis to poll it regularly for media connectivity. 
            // Default value is FALSE for this flag. This flag will be cleared if miniport
            // can indicate media status or does not support media query
            //
            if (ReturnedValue->ParameterData.IntegerData == 1)
            {
                MINIPORT_SET_FLAG(Miniport, fMINIPORT_REQUIRES_MEDIA_POLLING);
            }
        }

        NdisReadConfiguration(&NdisStatus,
                              &ReturnedValue,
                              &CnfgHandle,
                              &SGMapRegistersNeededStr,
                              NdisParameterInteger);
        if (NdisStatus == NDIS_STATUS_SUCCESS)
        {
            Miniport->SGMapRegistersNeeded = (USHORT)ReturnedValue->ParameterData.IntegerData;
        }
        else
        {
            Miniport->SGMapRegistersNeeded = NDIS_MAXIMUM_SCATTER_GATHER_SEGMENTS;
        }

        NdisReadConfiguration(&NdisStatus,
                              &ReturnedValue,
                              &CnfgHandle,
                              &NdisDriverVerifyFlagsStr,
                              NdisParameterHexInteger);
        if (NdisStatus == NDIS_STATUS_SUCCESS)
        {
            Miniport->DriverVerifyFlags = ReturnedValue->ParameterData.IntegerData;
        }


        PQueryTable[3].DefaultData = NULL;
        PQueryTable[3].Flags = 0;

        NdisStatus = NDIS_STATUS_SUCCESS;
    } while (FALSE);


    //
    // free NDIS_CONFIGURATION_PARAMETER_QUEUE nodes hanging from CnfgHandle
    //
    ParameterNode = CnfgHandle.ParameterList;

    while (ParameterNode != NULL)
    {
        CnfgHandle.ParameterList = ParameterNode->Next;

        FREE_POOL(ParameterNode);

        ParameterNode = CnfgHandle.ParameterList;
    }

#undef  PQueryTable
#undef  LQueryTable

    DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
        ("<==ndisInitializeConfiguration: Miniport %p\n", Miniport));

    return(NdisStatus);
}


NTSTATUS
ndisReadBindPaths(
    IN  PNDIS_MINIPORT_BLOCK        Miniport,
    IN  PRTL_QUERY_REGISTRY_TABLE   LQueryTable
    )
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    NTSTATUS                NtStatus;
    HANDLE                  Handle = NULL;
    PWSTR                   pPath, p, BindPathData = NULL;
    UINT                    i, Len, NumComponents;
    BOOLEAN                 FreeBindPathData = FALSE;

    DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
        ("==>ndisReadBindPaths: Miniport %p\n", Miniport));

    do
    {
#if NDIS_TEST_REG_FAILURE
        NtStatus = STATUS_UNSUCCESSFUL;
#else

        NtStatus = IoOpenDeviceRegistryKey(Miniport->PhysicalDeviceObject,
                                           PLUGPLAY_REGKEY_DRIVER,
                                           GENERIC_READ | MAXIMUM_ALLOWED,
                                           &Handle);
#endif

#if !NDIS_NO_REGISTRY

        if (!NT_SUCCESS(NtStatus))
            break;

        //
        // 1.
        // Switch to the Linkage key below this driver instance key
        //
        LQueryTable[0].QueryRoutine = NULL;
        LQueryTable[0].Flags = RTL_QUERY_REGISTRY_SUBKEY;
        LQueryTable[0].Name = L"Linkage";

        //
        // 2.
        // Read the RootDevice keywords
        //
        LQueryTable[1].QueryRoutine = ndisReadParameter;
        LQueryTable[1].Flags = RTL_QUERY_REGISTRY_NOEXPAND;
        LQueryTable[1].Name = L"RootDevice";
        LQueryTable[1].EntryContext = (PVOID)&BindPathData;
        LQueryTable[1].DefaultType = REG_NONE;

        LQueryTable[2].QueryRoutine = NULL;
        LQueryTable[2].Flags = 0;
        LQueryTable[2].Name = NULL;

        NtStatus = RtlQueryRegistryValues(RTL_REGISTRY_HANDLE,
                                          Handle,
                                          LQueryTable,
                                          NULL,
                                          NULL);
        ZwClose(Handle);

        if (!NT_SUCCESS(NtStatus))
            break;

#else
        if (NT_SUCCESS(NtStatus))
        {
            //
            // 1.
            // Switch to the Linkage key below this driver instance key
            //
            LQueryTable[0].QueryRoutine = NULL;
            LQueryTable[0].Flags = RTL_QUERY_REGISTRY_SUBKEY;
            LQueryTable[0].Name = L"Linkage";

            //
            // 2.
            // Read the RootDevice keywords
            //
            LQueryTable[1].QueryRoutine = ndisReadParameter;
            LQueryTable[1].Flags = RTL_QUERY_REGISTRY_NOEXPAND;
            LQueryTable[1].Name = L"RootDevice";
            LQueryTable[1].EntryContext = (PVOID)&BindPathData;
            LQueryTable[1].DefaultType = REG_NONE;

            LQueryTable[2].QueryRoutine = NULL;
            LQueryTable[2].Flags = 0;
            LQueryTable[2].Name = NULL;

            NtStatus = RtlQueryRegistryValues(RTL_REGISTRY_HANDLE,
                                              Handle,
                                              LQueryTable,
                                              NULL,
                                              NULL);
            ZwClose(Handle);

            if (!NT_SUCCESS(NtStatus))
                break;
        }
        else
        {
            NtStatus = STATUS_SUCCESS;
        }
#endif
        //
        // BindPath is a MULTI-SZ which starts at the top of the filter chain
        // and goes down to the miniport. It is of the form
        //
        // {FN} {FN-1} ... {F1} {Adapter}
        //
        // Where spaces are actually nulls and each of {Fn} is a filter instance.
        //
        if (BindPathData == NULL)
        {
            BindPathData = Miniport->BaseName.Buffer;
        }
        else
        {
            FreeBindPathData = TRUE;
        }

        //
        // Split bindpath into individual components. Start by determining how much
        // space we need.
        //
        Len = sizeof(NDIS_BIND_PATHS);
        for (pPath = BindPathData, NumComponents = 0; *pPath != 0; NOTHING)
        {
            NDIS_STRING us;

            RtlInitUnicodeString(&us, pPath);
            NumComponents++;
            Len += sizeof(NDIS_STRING) + us.Length + ndisDeviceStr.Length + sizeof(WCHAR);
            (PUCHAR)pPath += (us.Length + sizeof(WCHAR));
        }

        //
        // Allocate space for bindpaths. We have NumComponents paths
        // which consume Len bytes of space. We could be re-initialzing
        // so free any previous buffer allcoated for this.
        //
        if (Miniport->BindPaths != NULL)
        {
            FREE_POOL(Miniport->BindPaths);
        }
        Miniport->BindPaths = (PNDIS_BIND_PATHS)ALLOC_FROM_POOL(Len,
                                                                NDIS_TAG_NAME_BUF);
        if (Miniport->BindPaths == NULL)
        {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }

        ZeroMemory(Miniport->BindPaths, Len);
        Miniport->BindPaths->Number = NumComponents;

        if (NumComponents > 1)
        {
            MINIPORT_PNP_SET_FLAG(Miniport, fMINIPORT_FILTER_IM);
        }

        //
        // Create an array in reverse order of device-names in the filter path.
        //
        p = (PWSTR)((PUCHAR)Miniport->BindPaths +
                            sizeof(NDIS_BIND_PATHS) +
                            NumComponents*sizeof(NDIS_STRING));

        for (pPath = BindPathData, i = (NumComponents-1);
             *pPath != 0;
             i --)
        {
            NDIS_STRING Str, SubStr, *Bp;

            RtlInitUnicodeString(&Str, pPath);
            (PUCHAR)pPath += (Str.Length + sizeof(WCHAR));

            Bp = &Miniport->BindPaths->Paths[i];
            Bp->Buffer = p;
            Bp->Length = 0;
            Bp->MaximumLength = Str.Length + ndisDeviceStr.Length + sizeof(WCHAR);

            SubStr.Buffer = (PWSTR)((PUCHAR)p + ndisDeviceStr.Length);
            SubStr.MaximumLength = Str.Length + sizeof(WCHAR);
            SubStr.Length = 0;
            RtlCopyUnicodeString(Bp, &ndisDeviceStr);
            RtlUpcaseUnicodeString(&SubStr,
                                   &Str,
                                   FALSE);
            Bp->Length += SubStr.Length;
            (PUCHAR)p += Bp->MaximumLength;
        }
    } while (FALSE);

    if (FreeBindPathData)
        FREE_POOL(BindPathData);
                        ;
    DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
        ("<==ndisReadBindPaths: Miniport %p\n", Miniport));

    return NtStatus;
}


NTSTATUS
ndisCreateAdapterInstanceName(
    OUT PUNICODE_STRING *       pAdapterInstanceName,
    IN  PDEVICE_OBJECT          PhysicalDeviceObject
    )
{
    NTSTATUS                        NtStatus, SlotQueryStatus;
    DEVICE_REGISTRY_PROPERTY        Property;
    PWCHAR                          pValueInfo = NULL;
    ULONG                           ResultLength = 0;
    PUNICODE_STRING                 AdapterInstanceName = NULL;
    ULONG                           SlotNumber;
    
    DBGPRINT(DBG_COMP_PNP, DBG_LEVEL_INFO,
        ("==>ndisCreateAdapterInstanceName: PDO %p\n", PhysicalDeviceObject));

    do
    {        
        *pAdapterInstanceName = NULL;
        Property = DevicePropertyFriendlyName;
        NtStatus = IoGetDeviceProperty(PhysicalDeviceObject,
                                       Property,
                                       0,
                                       NULL,
                                       &ResultLength);

        if ((NtStatus != STATUS_BUFFER_TOO_SMALL) && !NT_SUCCESS(NtStatus))
        {
            Property = DevicePropertyDeviceDescription;
            NtStatus = IoGetDeviceProperty(PhysicalDeviceObject,
                                           Property,
                                           0,
                                           NULL,
                                           &ResultLength);
            if ((NtStatus != STATUS_BUFFER_TOO_SMALL) && !NT_SUCCESS(NtStatus))
            {
                DBGPRINT(DBG_COMP_PNP, DBG_LEVEL_ERR,
                    ("ndisCreateAdapterInstanceName: PDO %p, Failed to query the adapter description\n", PhysicalDeviceObject));

                break;
            }
        }
        


        //
        //  Allocate space to hold the partial value information.
        //
        pValueInfo = ALLOC_FROM_POOL(ResultLength, NDIS_TAG_DEFAULT);
        if (NULL == pValueInfo)
        {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            DBGPRINT(DBG_COMP_PNP, DBG_LEVEL_ERR,
                ("ndisCreateAdapterInstanceName: PDO %p, Failed to allocate storage for the adapter description\n", PhysicalDeviceObject));

            break;
        }

        RtlZeroMemory(pValueInfo, ResultLength);

        NtStatus = IoGetDeviceProperty(PhysicalDeviceObject,
                                        Property,
                                        ResultLength,
                                        pValueInfo,
                                        &ResultLength);
        if (!NT_SUCCESS(NtStatus))
        {
            DBGPRINT(DBG_COMP_PNP, DBG_LEVEL_ERR,
                ("ndisCreateAdapterInstanceName: PDO %p, Failed to query the adapter description\n", PhysicalDeviceObject));
            break;
        }
        
        //
        //  Determine the size of the instance name buffer. This is a UNICODE_STRING
        //  and it's associated buffer.
        //
        ResultLength += sizeof(UNICODE_STRING);

        //
        //  Allocate the buffer.
        //
        AdapterInstanceName = ALLOC_FROM_POOL(ResultLength, NDIS_TAG_NAME_BUF);
        if (NULL == AdapterInstanceName)
        {
            NtStatus = STATUS_INSUFFICIENT_RESOURCES;
            DBGPRINT(DBG_COMP_PNP, DBG_LEVEL_ERR,
                ("ndisCreateAdapterInstanceName: PDO %p, Failed to allocate storage for the adapter instance name\n", PhysicalDeviceObject));
            break;
        }

        //
        //  Initialize the buffer.
        //
        RtlZeroMemory(AdapterInstanceName, ResultLength);

        //
        //  Initialize the UNICODE_STRING for the instance name.
        //
        AdapterInstanceName->Buffer = (PWSTR)((PUCHAR)AdapterInstanceName + sizeof(UNICODE_STRING));
        AdapterInstanceName->Length = 0;
        AdapterInstanceName->MaximumLength = (USHORT)(ResultLength - sizeof(UNICODE_STRING));

        RtlAppendUnicodeToString(AdapterInstanceName, pValueInfo);
    
        DBGPRINT(DBG_COMP_PNP, DBG_LEVEL_INFO,
            ("ndisCreateAdapterInstanceName: %ws\n", AdapterInstanceName->Buffer));


        //
        //  Return the instance name.
        //
        *pAdapterInstanceName = AdapterInstanceName;


        //
        // get the slot number
        //
        Property = DevicePropertyUINumber;
        SlotQueryStatus = IoGetDeviceProperty(PhysicalDeviceObject,
                                       Property,
                                       sizeof (ULONG),
                                       &SlotNumber,
                                       &ResultLength);
        if (NT_SUCCESS(SlotQueryStatus))
        {
            DBGPRINT(DBG_COMP_PNP, DBG_LEVEL_INFO,
                ("ndisCreateAdapterInstanceName: %ws, Slot Number: %ld\n", 
                  AdapterInstanceName->Buffer, 
                  SlotNumber));
        }
        else
        {
            DBGPRINT(DBG_COMP_PNP, DBG_LEVEL_INFO,
                ("ndisCreateAdapterInstanceName: couldn't get SlotNumber for %ws\n", 
                  AdapterInstanceName->Buffer));
        }


    } while (FALSE);

    if (NULL != pValueInfo)
        FREE_POOL(pValueInfo);

    DBGPRINT(DBG_COMP_PNP, DBG_LEVEL_INFO,
        ("<==ndisCreateAdapterInstanceName: PDO %p, Status 0x%x\n", PhysicalDeviceObject, NtStatus));

    return(NtStatus);
}

NDIS_STATUS
ndisInitializeAdapter(
    IN  PNDIS_M_DRIVER_BLOCK    pMiniBlock,
    IN  PDEVICE_OBJECT          DeviceObject,
    IN  PUNICODE_STRING         InstanceName,
    IN  NDIS_HANDLE             DeviceContext   OPTIONAL
    )
{
    NDIS_WRAPPER_CONFIGURATION_HANDLE   ConfigurationHandle;
    NDIS_STATUS                         NdisStatus;
    UNICODE_STRING                      ExportName;
    NDIS_CONFIGURATION_HANDLE           TmpConfigHandle;
    PNDIS_MINIPORT_BLOCK                Miniport= (PNDIS_MINIPORT_BLOCK)((PNDIS_WRAPPER_CONTEXT)DeviceObject->DeviceExtension + 1);
    TIME                                TS, TE, TD;
    
#define PQueryTable ConfigurationHandle.ParametersQueryTable
#define Db          ConfigurationHandle.Db

    DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
        ("==>ndisInitializeAdapter: Miniport/Adapter %p\n", Miniport));

    do
    {
        ZeroMemory(&ConfigurationHandle, sizeof(NDIS_WRAPPER_CONFIGURATION_HANDLE));

        ExportName.Buffer = NULL;

        //
        //  Build the configuration handle.
        //
        NdisStatus = ndisInitializeConfiguration(&ConfigurationHandle,
                                                 Miniport,
                                                 &ExportName);
                        
        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            break;
        }

        //
        // OK, Now lock down all the filter packages.  If a MAC or
        // Miniport driver uses any of these, then the filter package
        // will reference itself, to keep the image in memory.
        //
#if ARCNET
        ArcReferencePackage();
#endif
        EthReferencePackage();
        FddiReferencePackage();
        TrReferencePackage();
        MiniportReferencePackage();
        CoReferencePackage();

        ConfigurationHandle.DeviceObject = DeviceObject;
        ConfigurationHandle.DriverBaseName = InstanceName;

        KeQuerySystemTime(&TS);

        //
        //  Save the Driver Object with the configuration handle.
        //
        ConfigurationHandle.DriverObject = pMiniBlock->NdisDriverInfo->DriverObject;
        NdisStatus = ndisMInitializeAdapter(pMiniBlock,
                                            &ConfigurationHandle,
                                            &ExportName,
                                            DeviceContext);
                                    
        KeQuerySystemTime(&TE);
        TD.QuadPart = TE.QuadPart - TS.QuadPart;
        TD.QuadPart /= 10000;       // Convert to ms
        Miniport = (PNDIS_MINIPORT_BLOCK)((PNDIS_WRAPPER_CONTEXT)(ConfigurationHandle.DeviceObject->DeviceExtension) + 1);
        Miniport->InitTimeMs = TD.LowPart;

        if (ndisFlags & NDIS_GFLAG_INIT_TIME)
        {
            DbgPrint("NDIS: Init time (%Z) %ld ms\n", Miniport->pAdapterInstanceName, Miniport->InitTimeMs);
        }

        if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            ndisCloseULongRef(&Miniport->Ref);
        }

        //
        // OK, Now dereference all the filter packages.  If a MAC or
        // Miniport driver uses any of these, then the filter package
        // will reference itself, to keep the image in memory.
        //
#if ARCNET
        ArcDereferencePackage();
#endif
        EthDereferencePackage();
        FddiDereferencePackage();
        TrDereferencePackage();
        MiniportDereferencePackage();
        CoDereferencePackage();

    } while (FALSE);

    if (ExportName.Buffer)
        FREE_POOL(ExportName.Buffer);

    //
    // free "Bind" data
    //
    if (PQueryTable[3].EntryContext != NULL)
        FREE_POOL(PQueryTable[3].EntryContext);
    
#undef  PQueryTable
#undef  Db

    DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
        ("<==ndisInitializeAdapter: Miniport/Adapter %p\n", Miniport));

    return(NdisStatus);
}


VOID
FASTCALL
ndisCheckAdapterBindings(
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  PNDIS_PROTOCOL_BLOCK    Protocol    OPTIONAL
    )
/*+++

Routine Description:

    This function, reads the registry to get all the protocols that are supposed 
    to bind to this adapter and for each protocol, calls ndisInitializeBinding

Arguments:

    Adapter     Pointer to ndis Adpater or Miniport block
    Protocol    Optionally if a protocol is specified, initiate binding to only
                that protocol
    
Return Value:
    None

---*/
{
    RTL_QUERY_REGISTRY_TABLE    LinkQueryTable[3];
    NTSTATUS                    RegistryStatus;
    PWSTR                       UpperBind = NULL;
    HANDLE                      Handle;
    PDEVICE_OBJECT              PhysicalDeviceObject;
    UNICODE_STRING              Us;
    PWSTR                       CurProtocolName;
    PNDIS_PROTOCOL_BLOCK        CurProtocol;
    NTSTATUS                    NtStatus;
    KIRQL                       OldIrql;
    
    DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
                ("==>ndisCheckAdapterBindings: Miniport %p, Protocol %p\n", Miniport, Protocol));


    do
    {        
        //
        // get a handle to driver section in registry
        //
        PhysicalDeviceObject = Miniport->PhysicalDeviceObject;
        if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_SECONDARY))
        {
            //
            // Skip bind notifications for a secondary miniport
            //
            break;
        }

#if NDIS_TEST_REG_FAILURE
        RegistryStatus = STATUS_UNSUCCESSFUL;
        Handle = NULL;
#else

        RegistryStatus = IoOpenDeviceRegistryKey(PhysicalDeviceObject,
                                                 PLUGPLAY_REGKEY_DRIVER,
                                                 GENERIC_READ | MAXIMUM_ALLOWED,
                                                 &Handle);
                                                 
#endif

#if NDIS_NO_REGISTRY
        if (!NT_SUCCESS(RegistryStatus))
        {
            if (ARGUMENT_PRESENT(Protocol))
            {
                ndisInitializeBinding(Miniport, Protocol);
                break;
            }
            else
            {
                for (CurProtocol = ndisProtocolList;
                     CurProtocol != NULL;
                     CurProtocol = CurProtocol->NextProtocol)
                {
                    ndisInitializeBinding(Miniport, CurProtocol);
                }               
            }
            
            break;
        }
#else
        if (!NT_SUCCESS(RegistryStatus))
        {
            break;
        }
#endif
        //
        // Set up LinkQueryTable to do the following:
        //

        //
        // 1) Switch to the Linkage key below the xports registry key
        //

        LinkQueryTable[0].QueryRoutine = NULL;
        LinkQueryTable[0].Flags = RTL_QUERY_REGISTRY_SUBKEY;
        LinkQueryTable[0].Name = L"Linkage";

        //
        // 2) Call ndisReadParameter for "UpperBind" (as a single multi-string),
        // which will allocate storage and save the data in UpperBind.
        //

        LinkQueryTable[1].QueryRoutine = ndisReadParameter;
        LinkQueryTable[1].Flags = RTL_QUERY_REGISTRY_REQUIRED | RTL_QUERY_REGISTRY_NOEXPAND;
        LinkQueryTable[1].Name = L"UpperBind";
        LinkQueryTable[1].EntryContext = (PVOID)&UpperBind;
        LinkQueryTable[1].DefaultType = REG_NONE;

        //
        // 3) Stop
        //

        LinkQueryTable[2].QueryRoutine = NULL;
        LinkQueryTable[2].Flags = 0;
        LinkQueryTable[2].Name = NULL;

        RegistryStatus = RtlQueryRegistryValues(RTL_REGISTRY_HANDLE,
                                                Handle,
                                                LinkQueryTable,
                                                (PVOID)NULL,      // no context needed
                                                NULL);
        ZwClose(Handle);
        
        if (NT_SUCCESS(RegistryStatus))
        {
            for (CurProtocolName = UpperBind;
                 *CurProtocolName != 0;
                 CurProtocolName = (PWCHAR)((PUCHAR)CurProtocolName + Us.MaximumLength))
            {
                RtlInitUnicodeString (&Us, CurProtocolName);
    
                if (ARGUMENT_PRESENT(Protocol))
                {
                    if (RtlEqualUnicodeString(&Us, &Protocol->ProtocolCharacteristics.Name, TRUE))
                    {
                        ndisInitializeBinding(Miniport, Protocol);
                        break;
                    }
                }
                else
                {
                    for (CurProtocol = ndisProtocolList;
                         CurProtocol != NULL;
                         CurProtocol = CurProtocol->NextProtocol)
                    {
                        if (RtlEqualUnicodeString(&Us, &CurProtocol->ProtocolCharacteristics.Name, TRUE))
                        {
                            ndisInitializeBinding(Miniport, CurProtocol);
                            break;
                        }
                    }               
                }
            }
        }
        
        //
        // Handle proxy and rca filters.
        //
        if ((Miniport != NULL) &&
            !ndisMediaTypeCl[Miniport->MediaType] &&
            MINIPORT_TEST_FLAG(Miniport, fMINIPORT_IS_CO))
        {
            if (ARGUMENT_PRESENT(Protocol))
            {
                if (Protocol->ProtocolCharacteristics.Flags & NDIS_PROTOCOL_BIND_ALL_CO)
                {
                    ndisInitializeBinding(Miniport, Protocol);
                }
            }
            else
            {
                for (CurProtocol = ndisProtocolList;
                     CurProtocol != NULL;
                     CurProtocol = CurProtocol->NextProtocol)
                {
                    if (CurProtocol->ProtocolCharacteristics.Flags & NDIS_PROTOCOL_BIND_ALL_CO)
                    {
                        ndisInitializeBinding(Miniport, CurProtocol);
                    }
                }
            }
        }
    } while (FALSE);                    

    if (UpperBind != NULL)
        FREE_POOL(UpperBind);
        
    DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
                ("<==ndisCheckAdapterBindings: Miniport %p, Protocol %p\n", Miniport, Protocol));
}

BOOLEAN
FASTCALL
ndisProtocolAlreadyBound(
    IN  PNDIS_PROTOCOL_BLOCK            Protocol,
    IN  PNDIS_MINIPORT_BLOCK            Miniport
    )
{
    PNDIS_OPEN_BLOCK    pOpen;
    BOOLEAN             rc = FALSE;
    KIRQL               OldIrql;

    DBGPRINT_RAW(DBG_COMP_BIND, DBG_LEVEL_INFO,
            ("==>ndisProtocolAlreadyBound: Protocol %p, Miniport %p\n", Protocol, Miniport));
            
    PnPReferencePackage();

    ACQUIRE_SPIN_LOCK(&Protocol->Ref.SpinLock, &OldIrql);

    for (pOpen = Protocol->OpenQueue;
         pOpen != NULL;
         pOpen = pOpen->ProtocolNextOpen)
    {
        if (pOpen->MiniportHandle == Miniport)
        {
            rc = TRUE;
            break;
        }
    }

    RELEASE_SPIN_LOCK(&Protocol->Ref.SpinLock, OldIrql);

    PnPDereferencePackage();
    
    DBGPRINT_RAW(DBG_COMP_BIND, DBG_LEVEL_INFO,
            ("<==ndisProtocolAlreadyBound: Protocol %p, Miniport %p\n", Protocol, Miniport));
            
    return rc;
}


NDIS_STATUS
NdisIMInitializeDeviceInstance(
    IN  NDIS_HANDLE     DriverHandle,
    IN  PNDIS_STRING    DeviceInstance
    )
/*++

Routine Description:

    Initialize an instance of a miniport device.

Arguments:

    DriverHandle -  Handle returned by NdisMRegisterLayeredMiniport.
                    It is a pointer to NDIS_M_DRIVER_BLOCK.
    DeviceInstance -Points to the instance of the driver that must now
                    be initialized.

Return Value:


--*/
{
    NDIS_STATUS Status;
    
    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
            ("==>NdisIMInitializeDeviceInstance: Driver %p, DeviceInstance %p\n", DriverHandle, DeviceInstance));
            
    Status = NdisIMInitializeDeviceInstanceEx(DriverHandle, DeviceInstance, NULL);

    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
            ("<==NdisIMInitializeDeviceInstance: Driver %p, DeviceInstance %p\n", DriverHandle, DeviceInstance));
            
    return Status;
}


NDIS_STATUS
NdisIMInitializeDeviceInstanceEx(
    IN  NDIS_HANDLE     DriverHandle,
    IN  PNDIS_STRING    DeviceInstance,
    IN  NDIS_HANDLE     DeviceContext
    )
/*++

Routine Description:

    Initialize an instance of a miniport device. Incarnation of NdisIMInitializeDeviceInstance.

Arguments:

    DriverHandle    Handle returned by NdisMRegisterLayeredMiniport.
                    It is a pointer to NDIS_M_DRIVER_BLOCK.
    DeviceInstance  Points to the instance of the driver that must now
                    be initialized.
    DeviceContext   Context to associate with the device. Retrieved via NdisIMGetDeviceContext.

Return Value:


--*/
{
    NDIS_STATUS                     Status;
    PNDIS_M_DRIVER_BLOCK            MiniBlock = (PNDIS_M_DRIVER_BLOCK)DriverHandle;
    KIRQL                           OldIrql;
    PNDIS_MINIPORT_BLOCK            Miniport;

    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
            ("==>NdisIMInitializeDeviceInstanceEx: Driver %p, Instance %p, Context %p\n",
                    DriverHandle, DeviceInstance, DeviceContext));

    PnPReferencePackage();
    
    WAIT_FOR_OBJECT(&MiniBlock->IMStartRemoveMutex, NULL);
    
    do
    {
        Miniport = ndisFindMiniportOnGlobalList(DeviceInstance);

        if (Miniport != NULL)
        {
            if (MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_RECEIVED_START) &&
                !MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_REMOVE_IN_PROGRESS | fMINIPORT_PM_HALTED))
            {
                DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
                        ("NdisIMInitializeDeviceInstanceEx: we have already received START_IRP for Miniport %p\n",
                        Miniport));

                //
                // check to make sure the miniport has not been initialized already
                // i.e. we are not getting duplicate NdisIMInitializeDeviceInstance 
                // a device that has already been initialized
                //
                
                if (ndisIsMiniportStarted(Miniport))
                {
                    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_ERR,
                            ("NdisIMInitializeDeviceInstanceEx: we have already initialized this device. Miniport %p\n",
                            Miniport));
                            
                    Status = NDIS_STATUS_NOT_ACCEPTED;
                    break;
                }
                
                Status = ndisIMInitializeDeviceInstance(Miniport,
                                                        DeviceContext,
                                                        FALSE);
                                
                if (Status != NDIS_STATUS_SUCCESS)
                {
                    //
                    // since we have already succeeded the START_IRP, signal PnP to remove this device
                    // by tagging the device as failed and requesting a QUERY_PNP_DEVICE_STATE IRP
                    //
                    MINIPORT_PNP_SET_FLAG(Miniport, fMINIPORT_DEVICE_FAILED);
                    IoInvalidateDeviceState(Miniport->PhysicalDeviceObject);
                }

                break;
            }
        }

        //
        // device is not started or not added yet.
        //
        Status = ndisIMQueueDeviceInstance(DriverHandle,
                                   DeviceInstance,
                                   DeviceContext);

    } while (FALSE);

    RELEASE_MUTEX(&MiniBlock->IMStartRemoveMutex);

    PnPDereferencePackage();
    
    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
                ("<==NdisIMInitializeDeviceInstanceEx: Driver %p, Instance %p, Context %p, Status %lx\n",
                DriverHandle, DeviceInstance, DeviceContext, Status));


    return Status;
}

NDIS_STATUS
ndisIMInitializeDeviceInstance(
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  NDIS_HANDLE             DeviceContext,
    IN  BOOLEAN                 fStartIrp
    )
/*++

Routine Description:

    This routine is called when we have received NdisIMInitializeDeviceInstance
    -AND- START IRP for an IM miniport.
    Initialize an instance of a miniport device.

Arguments:

    Miniport        Handle to NDIS_MINIPORT_BLOCK
    
    DeviceContext   Context to associate with the device. Retrieved via NdisIMGetDeviceContext.

    fStartIrp       flag to signal if we are in the context of handling START IRP
    
Return Value:


--*/
{
    NDIS_STATUS         Status;
    NTSTATUS            NtStatus;

    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
            ("==>ndisIMInitializeDeviceInstance: Miniport %p, Context %p, fStartIrp %lx\n", Miniport, DeviceContext, fStartIrp));
    

    //
    // it is quite possible we are dealing with a miniport block that has been "used"
    // several times. inother words, it has been started and DeviceInitialized, then
    // Device-De-Initialized and then has received a few query_stop and cancel_stop.
    // in this case the miniport block has to be cleaned up. otherwise, ndisPnPStartDevice
    // is not going to detect that miniport block needs re-initalization
    //
    ndisReinitializeMiniportBlock(Miniport);
    

    Miniport->DeviceContext = DeviceContext;
    
    Status = ndisPnPStartDevice(Miniport->DeviceObject, NULL);          // no Irp

    if (Status == NDIS_STATUS_SUCCESS)
    {
        //
        // if we are in the context of start IRP, queue a workitem to initialize
        // the bindings on this adapter to avoid the delay
        //
        if (!fStartIrp)
        {
            //
            //  Now set the device class association so that people can reference this.
            //
            NtStatus = IoSetDeviceInterfaceState(&Miniport->SymbolicLinkName, TRUE);

            if (NT_SUCCESS(NtStatus))
            {
                //
                // Do protocol notifications
                //
                ndisCheckAdapterBindings(Miniport, NULL);
            }
            else
            {
                DBGPRINT(DBG_COMP_PNP, DBG_LEVEL_ERR,
                    ("ndisCheckAdapterBindings: IoSetDeviceInterfaceState failed: Miniport %p, Status %lx\n", Miniport, NtStatus));
                Status = NDIS_STATUS_FAILURE;
                
            }
        }
        else
        {
            Status = ndisQueueBindWorkitem(Miniport);
        }
    }
    else
    {
        //
        // ndisPnPStartDevice can return an internal Error Code if the call 
        // to ndisMInitializeAdapter fails. convert this to NDIS_STATUS
        //
        Status = NDIS_STATUS_FAILURE;
    }

    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
            ("<==ndisIMInitializeDeviceInstance: Miniport %p, Context %p, Status %lx\n", Miniport, DeviceContext, Status));

    return Status;
}

NDIS_STATUS
ndisIMQueueDeviceInstance(
    IN  PNDIS_M_DRIVER_BLOCK    MiniBlock,
    IN  PNDIS_STRING            DeviceInstance,
    IN  NDIS_HANDLE             DeviceContext
    )
{
    NDIS_STATUS                     Status = NDIS_STATUS_SUCCESS;
    PNDIS_PENDING_IM_INSTANCE       NewImInstance, pTemp;
    KIRQL                           OldIrql;
    
    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
                ("==>ndisIMQueueDeviceInstance: Driver %p, Instance %p, Context %p\n",
                MiniBlock, DeviceInstance, DeviceContext));

    do
    {
        //
        // Queue the device name for which we have received an InitializeDeviceInstance
        // from an IM driver. Check for duplicates.
        //
        NewImInstance = (PNDIS_PENDING_IM_INSTANCE)ALLOC_FROM_POOL(sizeof(NDIS_PENDING_IM_INSTANCE) + 
                                                                       DeviceInstance->Length + 
                                                                       sizeof(WCHAR), 
                                                                   NDIS_TAG_IM_DEVICE_INSTANCE);
        if (NULL == NewImInstance)
        {
            Status = NDIS_STATUS_RESOURCES;
            break;
        }

        NewImInstance->Context = DeviceContext;
        NewImInstance->Name.MaximumLength = DeviceInstance->Length + sizeof(WCHAR);
        NewImInstance->Name.Length = 0;
        NewImInstance->Name.Buffer = (PWSTR)((PUCHAR)NewImInstance + sizeof(NDIS_PENDING_IM_INSTANCE));
        RtlUpcaseUnicodeString(&NewImInstance->Name,
                               DeviceInstance,
                               FALSE);
        
        ACQUIRE_SPIN_LOCK(&MiniBlock->Ref.SpinLock, &OldIrql);

        for (pTemp = MiniBlock->PendingDeviceList;
             pTemp != NULL;
             pTemp = pTemp->Next)
        {
            if (NDIS_EQUAL_UNICODE_STRING(&NewImInstance->Name,
                                          &pTemp->Name))
            {
                FREE_POOL(NewImInstance);
                Status = NDIS_STATUS_NOT_ACCEPTED;
                break;
            }
        }

        if (Status == NDIS_STATUS_SUCCESS)
        {
            NewImInstance->Next = MiniBlock->PendingDeviceList;
            MiniBlock->PendingDeviceList = NewImInstance;
        }

        RELEASE_SPIN_LOCK(&MiniBlock->Ref.SpinLock, OldIrql);

    } while (FALSE);
    
    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
                ("<==ndisIMQueueDeviceInstance: Driver %p, Instance %p, Context %p, Status %lx\n",
                MiniBlock, DeviceInstance, DeviceContext, Status));

    return Status;
}


BOOLEAN
ndisIMCheckDeviceInstance(
    IN  PNDIS_M_DRIVER_BLOCK    MiniBlock,
    IN  PUNICODE_STRING         DeviceInstanceName,
    OUT PNDIS_HANDLE            DeviceContext   OPTIONAL
    )
{
    PNDIS_PENDING_IM_INSTANCE       pDI, *ppDI;
    PNDIS_PROTOCOL_BLOCK            Protocol = MiniBlock->AssociatedProtocol;
    KIRQL                           OldIrql;
    BOOLEAN                         rc = FALSE;

    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
                ("==>ndisIMCheckDeviceInstance: Driver %p, DeviceInstanceName %p\n",
                MiniBlock, DeviceInstanceName));

    PnPReferencePackage();
                    
    ACQUIRE_SPIN_LOCK(&MiniBlock->Ref.SpinLock, &OldIrql);

    for (ppDI = &MiniBlock->PendingDeviceList;
         (pDI = *ppDI) != NULL;
         ppDI = &pDI->Next)
    {
        if (NDIS_EQUAL_UNICODE_STRING(&pDI->Name,
                                      DeviceInstanceName))
        {
            if (ARGUMENT_PRESENT(DeviceContext))
            {
                *DeviceContext =  pDI->Context;
            }
            *ppDI = pDI->Next;
            FREE_POOL(pDI);
            rc = TRUE;
            break;
        }
    }

    RELEASE_SPIN_LOCK(&MiniBlock->Ref.SpinLock, OldIrql);

    PnPDereferencePackage();

    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
                ("<==ndisIMCheckDeviceInstance: Driver %p, Name %p, Context %p\n",
                MiniBlock, DeviceInstanceName, DeviceContext));
                    
    if (!rc && ARGUMENT_PRESENT(DeviceContext))
    {
        //
        // Send a reconfig notification to the protocol associated with this IM
        // so it can re-initialize any device(s) it wants to
        //
        if (((Protocol = MiniBlock->AssociatedProtocol) != NULL) &&
            (Protocol->ProtocolCharacteristics.PnPEventHandler != NULL))
        {
            //
            // We got a start device for an IM. Make sure its protocol
            // half has all the requisite bindings. This can happen
            // if an IM is disconnected and reconnected, for example.
            // Also give it a NULL reconfig event. ATMLANE uses that
            //

            NET_PNP_EVENT           NetPnpEvent;
            KEVENT                  Event;
            NDIS_STATUS             Status;

            NdisZeroMemory(&NetPnpEvent, sizeof(NetPnpEvent));
            INITIALIZE_EVENT(&Event);
            NetPnpEvent.NetEvent = NetEventReconfigure;
            PNDIS_PNP_EVENT_RESERVED_FROM_NET_PNP_EVENT(&NetPnpEvent)->pEvent = &Event;

            WAIT_FOR_PROTO_MUTEX(Protocol);

            Status = (Protocol->ProtocolCharacteristics.PnPEventHandler)(NULL, &NetPnpEvent);

            if (NDIS_STATUS_PENDING == Status)
            {
                //
                //  Wait for completion.
                //
                WAIT_FOR_PROTOCOL(Protocol, &Event);
            }
    
            RELEASE_PROT_MUTEX(Protocol);
        }
    }

    return rc;
}

NDIS_STATUS
NdisIMCancelInitializeDeviceInstance(
    IN  NDIS_HANDLE     DriverHandle,
    IN  PNDIS_STRING    DeviceInstance
    )
{
    NDIS_STATUS         Status;
    UNICODE_STRING      UpcaseDevice;
    
    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
            ("==>NdisIMCancelInitializeDeviceInstance: Driver %p, DeviceInstance %p\n", DriverHandle, DeviceInstance));

    //
    // change to upper case
    //

    UpcaseDevice.Length = DeviceInstance->Length;
    UpcaseDevice.MaximumLength = DeviceInstance->Length + sizeof(WCHAR);
    UpcaseDevice.Buffer = ALLOC_FROM_POOL(UpcaseDevice.MaximumLength, NDIS_TAG_STRING);

    if (UpcaseDevice.Buffer == NULL)
    {
        return NDIS_STATUS_RESOURCES;
    }

    Status = RtlUpcaseUnicodeString(&UpcaseDevice, (PUNICODE_STRING)DeviceInstance, FALSE);
    ASSERT (NT_SUCCESS(Status));
            

    Status = (ndisIMCheckDeviceInstance((PNDIS_M_DRIVER_BLOCK)DriverHandle,
                                        &UpcaseDevice,
                                        NULL) == TRUE) ? NDIS_STATUS_SUCCESS : NDIS_STATUS_FAILURE;
    
    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
            ("<==NdisIMCancelInitializeDeviceInstance: Driver %p, DeviceInstance %p, Status %lx\n",
                DriverHandle, DeviceInstance, Status));

    FREE_POOL(UpcaseDevice.Buffer);
    
    return Status;
}

NDIS_HANDLE
NdisIMGetDeviceContext(
    IN  NDIS_HANDLE             MiniportAdapterHandle
    )
{
    PNDIS_MINIPORT_BLOCK    Miniport = (PNDIS_MINIPORT_BLOCK)MiniportAdapterHandle;
    
    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
            ("==>NdisIMGetDeviceContext: Miniport %p\n", Miniport));

    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
            ("<==NdisIMGetDeviceContext: Miniport %p\n", Miniport));
            
    return(Miniport->DeviceContext);
}


NDIS_HANDLE
NdisIMGetBindingContext(
    IN  NDIS_HANDLE             ProtocolBindingContext
    )
{
    PNDIS_OPEN_BLOCK        Open = (PNDIS_OPEN_BLOCK)ProtocolBindingContext;
    PNDIS_MINIPORT_BLOCK    Miniport = Open->MiniportHandle;

    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
            ("==>NdisIMGetBindingContext: Open %p\n", Open));
            
    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
            ("<==NdisIMGetBindingContext: Open %p\n", Open));
            
    return(Miniport->DeviceContext);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ndis\sys\mini.h ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation

Module Name:

    mini.h

Abstract:

    NDIS miniport wrapper definitions

Author:


Environment:

    Kernel mode, FSD

Revision History:

    Jun-95  Jameel Hyder    Split up from a monolithic file
--*/

#ifndef __MINI_H
#define __MINI_H

//
//  Macros for setting, clearing, and testing bits in the Miniport Flags.
//
#define MINIPORT_SET_FLAG(_M, _F)           ((_M)->Flags |= (_F))
#define MINIPORT_CLEAR_FLAG(_M, _F)         ((_M)->Flags &= ~(_F))
#define MINIPORT_TEST_FLAG(_M, _F)          (((_M)->Flags & (_F)) != 0)
#define MINIPORT_TEST_FLAGS(_M, _F)         (((_M)->Flags & (_F)) == (_F))

#define MINIPORT_SET_SEND_FLAG(_M, _F)      ((_M)->SendFlags |= (_F))
#define MINIPORT_CLEAR_SEND_FLAG(_M, _F)    ((_M)->SendFlags &= ~(_F))
#define MINIPORT_TEST_SEND_FLAG(_M, _F)     (((_M)->SendFlags & (_F)) != 0)

#define MINIPORT_PNP_SET_FLAG(_M, _F)       ((_M)->PnPFlags |= (_F))
#define MINIPORT_PNP_CLEAR_FLAG(_M, _F)     ((_M)->PnPFlags &= ~(_F))
#define MINIPORT_PNP_TEST_FLAG(_M, _F)      (((_M)->PnPFlags & (_F)) != 0)
#define MINIPORT_PNP_TEST_FLAGS(_M, _F)     (((_M)->PnPFlags & (_F)) == (_F))

#define MINIPORT_VERIFY_SET_FLAG(_M, _F)    ((_M)->DriverVerifyFlags |= (_F))
#define MINIPORT_VERIFY_CLEAR_FLAG(_M, _F)  ((_M)->DriverVerifyFlags &= ~(_F))
#define MINIPORT_VERIFY_TEST_FLAG(_M, _F)   (((_M)->DriverVerifyFlags & (_F)) != 0)
#define MINIPORT_VERIFY_TEST_FLAGS(_M, _F)  (((_M)->DriverVerifyFlags & (_F)) == (_F))


//
//  Flags for packet information.
//
#define MINIPORT_SET_PACKET_FLAG(_P, _F)    ((_P)->Private.NdisPacketFlags |= (_F))
#define MINIPORT_CLEAR_PACKET_FLAG(_P, _F)  ((_P)->Private.NdisPacketFlags &= ~(_F))
#define MINIPORT_TEST_PACKET_FLAG(_P, _F)   (((_P)->Private.NdisPacketFlags & (_F)) != 0)

//
// Low-bits in the packet flags are reserved by NDIS Wrapper for internal use
//
#if (fPACKET_WRAPPER_RESERVED != 0x3F)
#error (Packet flags overlap)
#endif

#define fPACKET_HAS_TIMED_OUT               0x01
#define fPACKET_IS_LOOPBACK                 0x02
#define fPACKET_SELF_DIRECTED               0x04
#define fPACKET_DONT_COMPLETE               0x08
#define fPACKET_PENDING                     0x10
#define fPACKET_ALREADY_LOOPEDBACK          0x20
#define fPACKET_CLEAR_ITEMS                 0x3F

#define NDIS_STATISTICS_HEADER_SIZE         FIELD_OFFSET(NDIS_STATISTICS_VALUE, Data[0])

//
// Timeout values
//
#define NDIS_MINIPORT_WAKEUP_TIMEOUT        2000    // Wakeup DPC
#define NDIS_MINIPORT_DEFERRED_TIMEOUT      15      // Deferred timer
#define NDIS_MINIPORT_TR_RESET_TIMEOUT      15      // Number of WakeUps per reset attempt
#define NDIS_CFHANG_TIME_SECONDS            2
#define NDISWAN_OPTIONS                     (NDIS_MAC_OPTION_RESERVED | NDIS_MAC_OPTION_NDISWAN)
#define NDIS_MINIPORT_DISCONNECT_TIMEOUT    20      // 20 seconds
#define INTERNAL_INDICATION_SIZE            -2
#define INTERNAL_INDICATION_BUFFER          (PVOID)-1

#define NDIS_M_MAX_MULTI_LIST               32

typedef struct _NDIS_PENDING_IM_INSTANCE    NDIS_PENDING_IM_INSTANCE, *PNDIS_PENDING_IM_INSTANCE;

typedef struct _NDIS_PENDING_IM_INSTANCE
{
    PNDIS_PENDING_IM_INSTANCE   Next;
    NDIS_HANDLE                 Context;
    UNICODE_STRING              Name;
} NDIS_PENDING_IM_INSTANCE, *PNDIS_PENDING_IM_INSTANCE;

typedef struct _NDIS_POST_OPEN_PROCESSING
{
    PNDIS_OPEN_BLOCK            Open;
    WORK_QUEUE_ITEM             WorkItem;
} NDIS_POST_OPEN_PROCESSING, *PNDIS_POST_OPEN_PROCESSING;

//
// one of these per Driver
//
struct _NDIS_M_DRIVER_BLOCK
{
    PNDIS_M_DRIVER_BLOCK        NextDriver;
    PNDIS_MINIPORT_BLOCK        MiniportQueue;      // queue of mini-ports for this driver

    PNDIS_WRAPPER_HANDLE        NdisDriverInfo;     // Driver information.
    PNDIS_PROTOCOL_BLOCK        AssociatedProtocol; // For IM drivers
    LIST_ENTRY                  DeviceList;
    PNDIS_PENDING_IM_INSTANCE   PendingDeviceList;
    PDRIVER_UNLOAD              UnloadHandler;
                                                    //  of this NDIS_DRIVER_BLOCK structure
    NDIS51_MINIPORT_CHARACTERISTICS MiniportCharacteristics; // handler addresses

    KEVENT                      MiniportsRemovedEvent;// used to find when all mini-ports are gone.
    REFERENCE                   Ref;                // contains spinlock for MiniportQueue
    USHORT                      Flags;
    KMUTEX                      IMStartRemoveMutex; // Synchronizes call to IMInitDevInstance and PnpRemove
    ULONG                       DriverVersion;
};

#define fMINIBLOCK_INTERMEDIATE_DRIVER          0x0001
#define fMINIBLOCK_VERIFYING                    0x0002
#define fMINIBLOCK_RECEIVED_TERMINATE_WRAPPER   0x0004
#define fMINIBLOCK_IO_UNLOAD                    0x0008
#define fMINIBLOCK_TERMINATE_WRAPPER_UNLOAD     0x0010
#define fMINIBLOCK_UNLOADING                    0x8000

#define ndisMDereferenceOpen(_Open)                                         \
    {                                                                       \
        UINT    _OpenRef;                                                   \
        DBGPRINT(DBG_COMP_OPENREF, DBG_LEVEL_INFO,                          \
                ("- Open 0x%x Reference 0x%x\n",                            \
                _Open, (_Open)->References));                               \
                                                                            \
        M_OPEN_DECREMENT_REF_INTERLOCKED(_Open, _OpenRef);                  \
                                                                            \
        DBGPRINT(DBG_COMP_OPENREF, DBG_LEVEL_INFO,                          \
                ("==0 Open 0x%x Reference 0x%x\n",                          \
                _Open, _OpenRef));                                          \
                                                                            \
        if (_OpenRef == 0)                                                  \
        {                                                                   \
            ndisMFinishClose(_Open);                                        \
        }                                                                   \
    }

//
// Flags definition for NDIS_OPEN_BLOCK.
//
#define fMINIPORT_OPEN_USING_ETH_ENCAPSULATION  0x00000001
#define fMINIPORT_OPEN_NO_LOOPBACK              0x00000002
#define fMINIPORT_OPEN_PMODE                    0x00000004
#define fMINIPORT_OPEN_NO_PROT_RSVD             0x00000008
#define fMINIPORT_OPEN_PROCESSING               0x00000010
#define fMINIPORT_PACKET_RECEIVED               0x00000080
#define fMINIPORT_STATUS_RECEIVED               0x00000100
#define fMINIPORT_OPEN_CLOSING                  0x00008000
#define fMINIPORT_OPEN_UNBINDING                0x00010000
#define fMINIPORT_OPEN_CALL_MANAGER             0x00020000
#define fMINIPORT_OPEN_CLIENT                   0x00040000
#define fMINIPORT_OPEN_NOTIFY_PROCESSING        0x00080000
#define fMINIPORT_OPEN_CLOSE_COMPLETE           0x00100000
#define fMINIPORT_OPEN_DONT_FREE                0x00200000



//
// Definitions for NDIS_MINIPORT_BLOCK GeneralFlags.
//
#define fMINIPORT_NORMAL_INTERRUPTS             0x00000001
#define fMINIPORT_IN_INITIALIZE                 0x00000002
#define fMINIPORT_ARCNET_BROADCAST_SET          0x00000004
#define fMINIPORT_BUS_MASTER                    0x00000008
#define fMINIPORT_64BITS_DMA                    0x00000010
#define fMINIPORT_DEREGISTERED_INTERRUPT        0x00000020
#define fMINIPORT_SG_LIST                       0x00000040
#define fMINIPORT_REQUEST_TIMEOUT               0x00000100
#define fMINIPORT_PROCESSING_REQUEST            0x00000400
#define fMINIPORT_IGNORE_PACKET_QUEUE           0x00000800
#define fMINIPORT_IGNORE_REQUEST_QUEUE          0x00001000
#define fMINIPORT_IGNORE_TOKEN_RING_ERRORS      0x00002000
#define fMINIPORT_CHECK_FOR_LOOPBACK            0x00004000
#define fMINIPORT_INTERMEDIATE_DRIVER           0x00008000
#define fMINIPORT_IS_NDIS_5                     0x00010000
#define fMINIPORT_IS_CO                         0x00020000
#define fMINIPORT_DESERIALIZE                   0x00040000
#define fMINIPORT_CALLING_RESET                 0x00080000
#define fMINIPORT_RESET_REQUESTED               0x00100000
#define fMINIPORT_RESET_IN_PROGRESS             0x00200000
#define fMINIPORT_RESOURCES_AVAILABLE           0x00400000
#define fMINIPORT_SEND_LOOPBACK_DIRECTED        0x00800000
#define fMINIPORT_RESTORING_FILTERS             0x01000000
#define fMINIPORT_REQUIRES_MEDIA_POLLING        0x02000000
#define fMINIPORT_SUPPORTS_MEDIA_SENSE          0x04000000
#define fMINIPORT_DOES_NOT_DO_LOOPBACK          0x08000000
#define fMINIPORT_SECONDARY                     0x10000000
#define fMINIPORT_MEDIA_CONNECTED               0x20000000
#define fMINIPORT_NETBOOT_CARD                  0x40000000
#define fMINIPORT_PM_HALTING                    0x80000000

#define MINIPORT_LOCK_ACQUIRED(_Miniport)       ((_Miniport)->LockAcquired & 0x01)

#define MINIPORT_AT_DPC_LEVEL (CURRENT_IRQL == DISPATCH_LEVEL)

#define ASSERT_MINIPORT_LOCKED(_Miniport)           \
    if (!MINIPORT_TEST_FLAG(_Miniport, fMINIPORT_DESERIALIZE))  \
    {                                               \
        ASSERT(MINIPORT_LOCK_ACQUIRED(_Miniport));  \
        ASSERT(MINIPORT_AT_DPC_LEVEL);              \
    }

//
//  Send flags
//
#define fMINIPORT_SEND_PACKET_ARRAY             0x01
#define fMINIPORT_SEND_DO_NOT_MAP_MDLS          0x02

//
//  Flags used in PnPFlags
//
#define fMINIPORT_PM_SUPPORTED                  0x00000001
#define fMINIPORT_NO_SHUTDOWN                   0x00000004
#define fMINIPORT_MEDIA_DISCONNECT_WAIT         0x00000008
#define fMINIPORT_REMOVE_IN_PROGRESS            0x00000010
#define fMINIPORT_DEVICE_POWER_ENABLE           0x00000020
#define fMINIPORT_DEVICE_POWER_WAKE_ENABLE      0x00000040
#define fMINIPORT_DEVICE_FAILED                 0x00000100
#define fMINIPORT_MEDIA_DISCONNECT_CANCELLED    0x00000200
#define fMINIPORT_SEND_WAIT_WAKE                0x00000400
#define fMINIPORT_SYSTEM_SLEEPING               0x00000800
#define fMINIPORT_HIDDEN                        0x00001000
#define fMINIPORT_SWENUM                        0x00002000
#define fMINIPORT_PM_HALTED                     0x00004000
#define fMINIPORT_NO_HALT_ON_SUSPEND            0x00008000
#define fMINIPORT_RECEIVED_START                0x00010000
#define fMINIPORT_REJECT_REQUESTS               0x00020000
#define fMINIPORT_PROCESSING                    0x00040000
#define fMINIPORT_HALTING                       0x00080000
#define fMINIPORT_VERIFYING                     0x00100000
#define fMINIPORT_HARDWARE_DEVICE               0x00200000
#define fMINIPORT_NDIS_WDM_DRIVER               0x00400000
#define fMINIPORT_SHUT_DOWN                     0x00800000
#define fMINIPORT_SHUTTING_DOWN                 0x01000000
#define fMINIPORT_ORPHANED                      0x02000000
#define fMINIPORT_QUEUED_BIND_WORKITEM          0x04000000
#define fMINIPORT_FILTER_IM                     0x08000000
#define fMINIPORT_MEDIA_DISCONNECT_INDICATED    0x10000000


//
// flags used in DriverVerifyFlags
//

#define fMINIPORT_VERIFY_FAIL_MAP_REG_ALLOC         0x00000001
#define fMINIPORT_VERIFY_FAIL_INTERRUPT_REGISTER    0x00000002
#define fMINIPORT_VERIFY_FAIL_SHARED_MEM_ALLOC      0x00000004
#define fMINIPORT_VERIFY_FAIL_CANCEL_TIMER          0x00000008
#define fMINIPORT_VERIFY_FAIL_MAP_IO_SPACE          0x00000010
#define fMINIPORT_VERIFY_FAIL_REGISTER_IO           0x00000020
#define fMINIPORT_VERIFY_FAIL_READ_CONFIG_SPACE     0x00000040
#define fMINIPORT_VERIFY_FAIL_WRITE_CONFIG_SPACE    0x00000080
#define fMINIPORT_VERIFY_FAIL_INIT_SG               0x00000100

//
// flags used in XState field to show why we have set handlers to fake ones
//
#define fMINIPORT_STATE_RESETTING                   0x01
#define fMINIPORT_STATE_MEDIA_DISCONNECTED          0x02
#define fMINIPORT_STATE_PM_STOPPED                  0x04



//
// The following defines the NDIS usage of the PacketStack->NdisReserved area. It has different semantics
// for send and receive
//
#define NUM_PACKET_STACKS           2           // Default, registry configurable
typedef struct _NDIS_STACK_RESERVED
{
    union
    {
        struct _SEND_STACK_RESERVED
        {
            PNDIS_OPEN_BLOCK            Open;       // Tracks who the packet owner is - only for de-serialized drivers
            PNDIS_CO_VC_PTR_BLOCK       VcPtr;      // For CO miniports, identifies the VC
        };
        struct _RECV_STACK_RESERVED
        {
            union
            {
                PNDIS_MINIPORT_BLOCK    Miniport;   // Identifies the miniport (IM) that indicated the packet
                PNDIS_PACKET            NextPacket; // In the return-packet queue
            };
            union                                   // Keeps track of ref-counts
            {
                struct
                {
                    LONG                RefCount;
                    LONG                XRefCount;
                };
                ULONG                   RefUlong;
            };
        };
        struct _XFER_DATA_STACK_RESERVED
        {
            PNDIS_OPEN_BLOCK    Opens[3];
        };
    };
    
    KSPIN_LOCK                  Lock;

} NDIS_STACK_RESERVED, *PNDIS_STACK_RESERVED;

#define NDIS_STACK_RESERVED_FROM_PACKET(_P, _NSR)                               \
    {                                                                           \
        PNDIS_PACKET_STACK  _Stack;                                             \
                                                                                \
        GET_CURRENT_PACKET_STACK((_P), &_Stack);                                \
        ASSERT(_Stack != NULL);                                                 \
        *(_NSR) = (PNDIS_STACK_RESERVED)(_Stack->NdisReserved);                 \
    }

#define NDIS_XFER_DATA_STACK_RESERVED_FROM_PACKET(_P, _NSR_OPENS)               \
    {                                                                           \
                                                                                \
        GET_CURRENT_XFER_DATA_PACKET_STACK((_P), &_NSR_OPENS);                  \
        ASSERT(_NSR_OPENS != NULL);                                             \
    }

typedef struct _NDIS_LOOPBACK_REF
{
    PNDIS_OPEN_BLOCK        Open;
    PNDIS_PACKET            NextLoopbackPacket;
} NDIS_LB_REF, *PNDIS_LB_REF;

#define PNDIS_LB_REF_FROM_PNDIS_PACKET(_P)  ((PNDIS_LB_REF)((_P)->MiniportReserved))

#define LOOPBACK_OPEN_IN_PACKET(_P)         PNDIS_LB_REF_FROM_PNDIS_PACKET(_P)->Open
#define SET_LOOPBACK_OPEN_IN_PACKET(_P, _O) LOOPBACK_OPEN_IN_PACKET(_P) = (_O)
#define LOOPBACK_LINKAGE(_P)                PNDIS_LB_REF_FROM_PNDIS_PACKET(_P)->NextLoopbackPacket

//
//  PnP Event reserved information for NDIS.
//
typedef struct _NDIS_PNP_EVENT_RESERVED
{
    PKEVENT             pEvent;
    NDIS_STATUS         Status;
    NDIS_HANDLE         Open;
} NDIS_PNP_EVENT_RESERVED, *PNDIS_PNP_EVENT_RESERVED;

#define PNDIS_PNP_EVENT_RESERVED_FROM_NET_PNP_EVENT(x)  ((PNDIS_PNP_EVENT_RESERVED)(x)->NdisReserved)

#define NDISM_QUEUE_WORK_ITEM(_M, _WT, _WC)             ndisMQueueWorkItem(_M, _WT, _WC)
#define NDISM_QUEUE_NEW_WORK_ITEM(_M, _WT, _WC, _WH)    ndisMQueueNewWorkItem(_M, _WT, _WC, _WH)
#define NDISM_DEQUEUE_WORK_ITEM(_M, _WT, _pWC)          ndisMDeQueueWorkItem(_M, _WT, _pWC, NULL)
#define NDISM_DEQUEUE_WORK_ITEM_WITH_HANDLER(_M, _WT, _pWC, _pWH)   \
                                                        ndisMDeQueueWorkItem(_M, _WT, _pWC, _pWH)

#define NDISM_PROCESS_DEFERRED(_M)                      ndisMProcessDeferred(_M)

#define MINIPORT_ENABLE_INTERRUPT(_M_)                                              \
{                                                                                   \
    if ((_M_)->EnableInterruptHandler != NULL)                                      \
    {                                                                               \
        ((_M_)->EnableInterruptHandler)((_M_)->MiniportAdapterContext);             \
    }                                                                               \
}

#define MINIPORT_SYNC_ENABLE_INTERRUPT(_M_)                                         \
{                                                                                   \
    if (((_M_)->Interrupt != NULL) &&                                               \
        ((_M_)->EnableInterruptHandler != NULL))                                    \
    {                                                                               \
        SYNC_WITH_ISR(((_M_))->Interrupt->InterruptObject,                          \
                      ((_M_)->EnableInterruptHandler),                              \
                      (_M_)->MiniportAdapterContext);                               \
    }                                                                               \
}

#define MINIPORT_DISABLE_INTERRUPT(_M_)                                             \
{                                                                                   \
    ASSERT((_M_)->DisableInterruptHandler != NULL);                                 \
    ((_M_)->DriverHandle->MiniportCharacteristics.DisableInterruptHandler)(         \
                (_M_)->MiniportAdapterContext);                                     \
}

#define MINIPORT_SYNC_DISABLE_INTERRUPT(_M_)                                        \
{                                                                                   \
    if (((_M_)->Interrupt != NULL) &&                                               \
        ((_M_)->DisableInterruptHandler != NULL))                                   \
    {                                                                               \
        SYNC_WITH_ISR(((_M_))->Interrupt->InterruptObject,                          \
                      ((_M_)->DisableInterruptHandler),                             \
                      (_M_)->MiniportAdapterContext);                               \
    }                                                                               \
}

#define MINIPORT_ENABLE_INTERRUPT_EX(_M_, _I_)                                      \
{                                                                                   \
    if ((_M_)->EnableInterruptHandler != NULL)                                      \
    {                                                                               \
        ((_M_)->EnableInterruptHandler)((_I_)->Reserved);                           \
    }                                                                               \
}

#define MINIPORT_SYNC_ENABLE_INTERRUPT_EX(_M_, _I_)                                 \
{                                                                                   \
    if (((_M_)->Interrupt != NULL) &&                                               \
        ((_M_)->EnableInterruptHandler != NULL))                                    \
    {                                                                               \
        SYNC_WITH_ISR(((_I_))->InterruptObject,                                     \
                      ((_M_)->EnableInterruptHandler),                              \
                      (_I_)->Reserved);                                             \
    }                                                                               \
}

#define MINIPORT_DISABLE_INTERRUPT_EX(_M_, _I_)                                     \
{                                                                                   \
    ASSERT((_M_)->DisableInterruptHandler != NULL);                                 \
    ((_M_)->DriverHandle->MiniportCharacteristics.DisableInterruptHandler)(         \
                      (_I_)->Reserved);                                             \
}

#define MINIPORT_SYNC_DISABLE_INTERRUPT_EX(_M_, _I_)                                \
{                                                                                   \
    if (((_M_)->Interrupt != NULL) &&                                               \
        ((_M_)->DisableInterruptHandler != NULL))                                   \
    {                                                                               \
        SYNC_WITH_ISR(((_I_))->InterruptObject,                                     \
                      ((_M_)->DisableInterruptHandler),                             \
                      (_I_)->Reserved);                                             \
    }                                                                               \
}



#define CHECK_FOR_NORMAL_INTERRUPTS(_M_)                                            \
    if (((_M_)->Interrupt != NULL) &&                                               \
        !(_M_)->Interrupt->IsrRequested &&                                          \
        !(_M_)->Interrupt->SharedInterrupt)                                         \
    {                                                                               \
        (_M_)->Flags |= fMINIPORT_NORMAL_INTERRUPTS;                                \
    }                                                                               \
    else                                                                            \
    {                                                                               \
        (_M_)->Flags &= ~fMINIPORT_NORMAL_INTERRUPTS;                               \
    }


#define WMI_BUFFER_TOO_SMALL(_BufferSize, _Wnode, _WnodeSize, _pStatus, _pRSize)    \
{                                                                                   \
    if ((_BufferSize) < sizeof(WNODE_TOO_SMALL))                                    \
    {                                                                               \
        *(_pStatus) = STATUS_BUFFER_TOO_SMALL;                                      \
        *(_pRSize) = sizeof(ULONG);                                                 \
    }                                                                               \
    else                                                                            \
    {                                                                               \
        (_Wnode)->WnodeHeader.BufferSize = sizeof(WNODE_TOO_SMALL);                 \
        (_Wnode)->WnodeHeader.Flags |= WNODE_FLAG_TOO_SMALL;                        \
        ((PWNODE_TOO_SMALL)(_Wnode))->SizeNeeded = (_WnodeSize);                    \
        *(_pRSize) = sizeof(WNODE_TOO_SMALL);                                       \
        *(_pStatus) = STATUS_SUCCESS;                                               \
    }                                                                               \
}


#define MAP_NDIS_STATUS_TO_NT_STATUS(_NdisStatus, _pNtStatus)                       \
{                                                                                   \
    /*                                                                              \
     *  The following NDIS status codes map directly to NT status codes.            \
     */                                                                             \
    if (((NDIS_STATUS_SUCCESS == (_NdisStatus)) ||                                  \
        (NDIS_STATUS_PENDING == (_NdisStatus)) ||                                   \
        (NDIS_STATUS_BUFFER_OVERFLOW == (_NdisStatus)) ||                           \
        (NDIS_STATUS_FAILURE == (_NdisStatus)) ||                                   \
        (NDIS_STATUS_RESOURCES == (_NdisStatus)) ||                                 \
        (NDIS_STATUS_NOT_SUPPORTED == (_NdisStatus))))                              \
    {                                                                               \
        *(_pNtStatus) = (NTSTATUS)(_NdisStatus);                                    \
    }                                                                               \
    else if (NDIS_STATUS_BUFFER_TOO_SHORT == (_NdisStatus))                         \
    {                                                                               \
        /*                                                                          \
         *  The above NDIS status codes require a little special casing.            \
         */                                                                         \
        *(_pNtStatus) = STATUS_BUFFER_TOO_SMALL;                                    \
    }                                                                               \
    else if (NDIS_STATUS_INVALID_LENGTH == (_NdisStatus))                           \
    {                                                                               \
        *(_pNtStatus) = STATUS_INVALID_BUFFER_SIZE;                                 \
    }                                                                               \
    else if (NDIS_STATUS_INVALID_DATA == (_NdisStatus))                             \
    {                                                                               \
        *(_pNtStatus) = STATUS_INVALID_PARAMETER;                                   \
    }                                                                               \
    else                                                                            \
    {                                                                               \
        *(_pNtStatus) = STATUS_UNSUCCESSFUL;                                        \
    }                                                                               \
}



#define EXPERIMENTAL_SIZE               4
#define VC_IDENTIFIER                   L':'
#define VC_IDENTIFIER_STRING            L":"
#define VC_ID_INDEX                     5
#define VC_INSTANCE_ID_SIZE             (sizeof(WCHAR) * 24)    // "XXXX:YYYYYYYYYYYYYYYY "
#define NIBBLE_MASK                     0x0F

#define fNDIS_GUID_EVENT_ENABLED        0x80000000
#define fNDIS_GUID_NOT_SETTABLE         0x40000000
#define fNDIS_GUID_NDIS_ONLY            0x20000000
#define fNDIS_GUID_CO_NDIS              0x10000000

#define NDIS_GUID_SET_FLAG(m, f)        ((m)->Flags |= (f))
#define NDIS_GUID_CLEAR_FLAG(m, f)      ((m)->Flags &= ~(f))
#define NDIS_GUID_TEST_FLAG(m, f)       (((m)->Flags & (f)) != 0)

typedef struct _AsyncWorkItem
{
    WORK_QUEUE_ITEM         ExWorkItem;
    PNDIS_MINIPORT_BLOCK    Miniport;
    ULONG                   Length;
    BOOLEAN                 Cached;
    PVOID                   VAddr;
    PVOID                   Context;
    NDIS_PHYSICAL_ADDRESS   PhyAddr;
} ASYNC_WORKITEM, *PASYNC_WORKITEM;


//
//  Macro for the deferred send handler.
//
#define NDISM_START_SENDS(_M)               (_M)->DeferredSendHandler((_M))

#define NDISM_DEFER_PROCESS_DEFERRED(_M)    QUEUE_DPC(&(_M)->DeferredDpc)

//
// A list of registered address families are maintained here.
//
typedef struct _NDIS_AF_LIST
{
    struct _NDIS_AF_LIST    *   NextAf;     // For this miniport Head at NDIS_MINIPORT_BLOCK

    PNDIS_OPEN_BLOCK            Open;       // Back pointer to the open-block

    CO_ADDRESS_FAMILY           AddressFamily;

    NDIS_CALL_MANAGER_CHARACTERISTICS   CmChars;
} NDIS_AF_LIST, *PNDIS_AF_LIST;

typedef struct  _NDIS_AF_NOTIFY
{
    struct _NDIS_AF_NOTIFY *    Next;
    WORK_QUEUE_ITEM             WorkItem;
    PNDIS_MINIPORT_BLOCK        Miniport;
    PNDIS_OPEN_BLOCK            Open;
    CO_ADDRESS_FAMILY           AddressFamily;
} NDIS_AF_NOTIFY, *PNDIS_AF_NOTIFY;


typedef struct _POWER_WORK_ITEM
{
    //
    // NDIS_WORK_ITEM needs to be the first element here !!!
    //
    NDIS_WORK_ITEM  WorkItem;
    PIRP            pIrp;
} POWER_WORK_ITEM, *PPOWER_WORK_ITEM;


typedef
NDIS_STATUS
(FASTCALL *SET_INFO_HANDLER)(
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  PNDIS_REQUEST           Request
    );

typedef struct _OID_SETINFO_HANDLER
{
    NDIS_OID                    Oid;
    SET_INFO_HANDLER            SetInfoHandler;
} OID_SETINFO_HANDLER, *POID_SETINFO_HANDLER;


#define READ_LOCK                       0
#define WRITE_LOCK_STATE_UNKNOWN        1
#define LOCK_STATE_ALREADY_ACQUIRED     2
#define READ_LOCK_STATE_FREE            3
#define WRITE_LOCK_STATE_FREE           4
#define LOCK_STATE_UNKNOWN              -1

typedef
VOID
(FASTCALL *LOCK_HANDLER)(
    IN  PVOID                   Filter,
    IN OUT  PLOCK_STATE         pLockState
    );

    #define READ_LOCK_FILTER(_Miniport, _Filter, _pLockState)   NDIS_READ_LOCK(&(_Filter)->BindListLock, _pLockState);
    #define READ_UNLOCK_FILTER(_Miniport, _Filter, _pLockState) NDIS_READ_LOCK_STATE_FREE(&(_Filter)->BindListLock, _pLockState)

#define WRITE_LOCK_FILTER(_Miniport, _Filter, _pLockState)  \
    {                                                       \
        LOCK_HANDLER LockHandler =                          \
                (LOCK_HANDLER)((_Miniport)->LockHandler);   \
                                                            \
        (_pLockState)->LockState = WRITE_LOCK_STATE_UNKNOWN;\
        (*LockHandler)(_Filter, _pLockState);               \
    }

#define WRITE_UNLOCK_FILTER(_Miniport, _Filter, _pLockState) UNLOCK_FILTER(_Miniport, _Filter, _pLockState)

#define UNLOCK_FILTER(_Miniport, _Filter, _pLockState)      \
    {                                                       \
        LOCK_HANDLER LockHandler =                          \
                (LOCK_HANDLER)((_Miniport)->LockHandler);   \
                                                            \
        (*LockHandler)(_Filter, _pLockState);               \
    }

#define M_OPEN_INCREMENT_REF(_O)                            \
{                                                           \
    (_O)->References++;                                     \
    NDIS_APPEND_MOPEN_LOGFILE(NDIS_INCREMENT_M_OPEN_REFCOUNT,\
                                   __LINE__,                \
                                   MODULE_NUMBER,           \
                                   (_O),                    \
                                   (_O)->References);       \
}

#define M_OPEN_DECREMENT_REF(_O)                            \
{                                                           \
    (_O)->References--;                                     \
    NDIS_APPEND_MOPEN_LOGFILE(NDIS_DECREMENT_M_OPEN_REFCOUNT,\
                               __LINE__,                    \
                               MODULE_NUMBER,               \
                               (_O),                        \
                               (_O)->References);           \
}



#define M_OPEN_INCREMENT_REF_INTERLOCKED(_O)                \
{                                                           \
    UINT MOpen_RefCount;                                    \
    MOpen_RefCount = NdisInterlockedIncrement(&(_O)->References);\
    NDIS_APPEND_MOPEN_LOGFILE(NDIS_INCREMENT_M_OPEN_REFCOUNT,\
                               __LINE__,                    \
                               MODULE_NUMBER,               \
                               (_O),                        \
                               MOpen_RefCount);             \
}



#define M_OPEN_DECREMENT_REF_INTERLOCKED(_O, _OR)                   \
{                                                                   \
    _OR = NdisInterlockedDecrement(&(_O)->References);              \
    NDIS_APPEND_MOPEN_LOGFILE(NDIS_DECREMENT_M_OPEN_REFCOUNT,       \
                               __LINE__,                            \
                               MODULE_NUMBER,                       \
                               _O,                                  \
                               _OR);                                \
}


#define OPEN_INCREMENT_AF_NOTIFICATION(_O)                                      \
{                                                                               \
    UINT MOpen_AfRefCount;                                                      \
    MOpen_AfRefCount = NdisInterlockedIncrement(&(_O)->PendingAfNotifications); \
    NDIS_APPEND_MOPEN_LOGFILE(NDIS_INCREMENT_OPEN_AF_NOTIFICATION,              \
                               __LINE__,                                        \
                               MODULE_NUMBER,                                   \
                               (_O),                                            \
                               MOpen_AfRefCount);                               \
}

#define OPEN_DECREMENT_AF_NOTIFICATION(_O, _OR)                                 \
{                                                                               \
    _OR = NdisInterlockedDecrement(&(_O)->PendingAfNotifications);              \
    NDIS_APPEND_MOPEN_LOGFILE(NDIS_DECREMENT_OPEN_AF_NOTIFICATION,              \
                               __LINE__,                                        \
                               MODULE_NUMBER,                                   \
                               _O,                                              \
                               _OR);                                            \
}


#ifdef TRACK_MINIPORT_REFCOUNTS
#define MINIPORT_INCREMENT_REF(_M)  ndisReferenceMiniportAndLog(_M, __LINE__, MODULE_NUMBER)
#define MINIPORT_INCREMENT_REF_NO_CHECK(_M)  ndisReferenceMiniportAndLogNoCheck(_M, __LINE__, MODULE_NUMBER)
#define MINIPORT_INCREMENT_REF_CREATE(_M, _IRP) ndisReferenceMiniportAndLogCreate(_M, __LINE__, MODULE_NUMBER, _IRP)
#else
#define MINIPORT_INCREMENT_REF(_M)  ndisReferenceMiniport(_M)
#define MINIPORT_INCREMENT_REF_NO_CHECK(_M)  ndisReferenceMiniportNoCheck(_M)
#define MINIPORT_INCREMENT_REF_CREATE(_M, _IRP) ndisReferenceMiniport(_M)
#endif


#define MINIPORT_DECREMENT_REF(_M)                          \
    {                                                       \
        M_LOG_MINIPORT_DECREMENT_REF(_M, (_M)->Ref.ReferenceCount - 1);\
        ndisDereferenceMiniport(_M);                        \
    }
    
#define MINIPORT_DECREMENT_REF_CLOSE(_M, _IRP)              \
    {                                                       \
        M_LOG_MINIPORT_DECREMENT_REF_CLOSE(_M, (_M)->Ref.ReferenceCount - 1);\
        ndisDereferenceMiniport(_M);                        \
    }

#define MINIPORT_DECREMENT_REF_NO_CLEAN_UP(_M)              \
    {                                                       \
        M_LOG_MINIPORT_DECREMENT_REF(_M, (_M)->Ref.ReferenceCount - 1);\
        ndisDereferenceULongRef(&(_M)->Ref);                     \
    }
    
#ifdef TRACK_MINIPORT_MPMODE_OPENS
#define NDIS_CHECK_PMODE_OPEN_REF(_M)                       \
{                                                           \
    PNDIS_OPEN_BLOCK    _pOpen = (_M)->OpenQueue;           \
    UINT                _NumPmodeOpens = 0;                 \
    while(_pOpen)                                           \
    {                                                       \
        if (_pOpen->Flags & fMINIPORT_OPEN_PMODE)           \
            _NumPmodeOpens++;                               \
        _pOpen = _pOpen->MiniportNextOpen;                  \
    }                                                       \
    ASSERT((_M)->PmodeOpens == _NumPmodeOpens);             \
    (_M)->PmodeOpens = (UCHAR)_NumPmodeOpens;               \
}
#else
#define NDIS_CHECK_PMODE_OPEN_REF(_M)
#endif

//
// if PmodeOpens > 0 and NumOpens > 1, then check to see if we should 
// loop back the packet.
//
// we should also should loopback the packet if the protocol did not
// explicitly asked for the packet not to be looped back and we either have a miniport
// that has indicated that it does not do loopback itself or it is in all_local
// mode.
//


#define NDIS_CHECK_FOR_LOOPBACK(_M, _P)                                     \
    ((MINIPORT_TEST_FLAG(_M, fMINIPORT_CHECK_FOR_LOOPBACK))            ||   \
     (((NdisGetPacketFlags(_P) & NDIS_FLAGS_DONT_LOOPBACK) == 0)  &&        \
      (MINIPORT_TEST_FLAG(_M, fMINIPORT_DOES_NOT_DO_LOOPBACK |              \
                              fMINIPORT_SEND_LOOPBACK_DIRECTED)             \
      )                                                                     \
     )                                                                      \
    )



//
// obselete API. shouldn't show up in ndis.h
//
EXPORT
NDIS_STATUS
NdisQueryMapRegisterCount(
    IN  NDIS_INTERFACE_TYPE     BusType,
    OUT PUINT                   MapRegisterCount
);

EXPORT
VOID
NdisImmediateReadPortUchar(
    IN  NDIS_HANDLE             WrapperConfigurationContext,
    IN  ULONG                   Port,
    OUT PUCHAR                  Data
    );

EXPORT
VOID
NdisImmediateReadPortUshort(
    IN  NDIS_HANDLE             WrapperConfigurationContext,
    IN  ULONG                   Port,
    OUT PUSHORT Data
    );

EXPORT
VOID
NdisImmediateReadPortUlong(
    IN  NDIS_HANDLE             WrapperConfigurationContext,
    IN  ULONG                   Port,
    OUT PULONG Data
    );

EXPORT
VOID
NdisImmediateWritePortUchar(
    IN  NDIS_HANDLE             WrapperConfigurationContext,
    IN  ULONG                   Port,
    IN  UCHAR                   Data
    );

EXPORT
VOID
NdisImmediateWritePortUshort(
    IN  NDIS_HANDLE             WrapperConfigurationContext,
    IN  ULONG                   Port,
    IN  USHORT                  Data
    );

EXPORT
VOID
NdisImmediateWritePortUlong(
    IN  NDIS_HANDLE             WrapperConfigurationContext,
    IN  ULONG                   Port,
    IN  ULONG                   Data
    );

EXPORT
VOID
NdisImmediateReadSharedMemory(
    IN  NDIS_HANDLE             WrapperConfigurationContext,
    IN  ULONG                   SharedMemoryAddress,
    IN  PUCHAR                  Buffer,
    IN  ULONG                   Length
    );

EXPORT
VOID
NdisImmediateWriteSharedMemory(
    IN  NDIS_HANDLE             WrapperConfigurationContext,
    IN  ULONG                   SharedMemoryAddress,
    IN  PUCHAR                  Buffer,
    IN  ULONG                   Length
    );

EXPORT
ULONG
NdisImmediateReadPciSlotInformation(
    IN  NDIS_HANDLE             WrapperConfigurationContext,
    IN  ULONG                   SlotNumber,
    IN  ULONG                   Offset,
    IN  PVOID                   Buffer,
    IN  ULONG                   Length
    );

EXPORT
ULONG
NdisImmediateWritePciSlotInformation(
    IN  NDIS_HANDLE             WrapperConfigurationContext,
    IN  ULONG                   SlotNumber,
    IN  ULONG                   Offset,
    IN  PVOID                   Buffer,
    IN  ULONG                   Length
    );

#define ALIGN_8_LENGTH(_length) (((ULONG)(_length) + 7) & ~7)
#define ALIGN_8_TYPE(_type) ((sizeof(_type) + 7) & ~7)
#endif // __MINI_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ndis\sys\macros.h ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation

Module Name:

    macros.h

Abstract:

    NDIS wrapper definitions

Author:


Environment:

    Kernel mode, FSD

Revision History:

    Jun-95  Jameel Hyder    Split up from a monolithic file
--*/

#ifndef _MACROS_H
#define _MACROS_H

#define NdisMStartBufferPhysicalMappingMacro(                                   \
                _MiniportAdapterHandle,                                         \
                _Buffer,                                                        \
                _PhysicalMapRegister,                                           \
                _Write,                                                         \
                _PhysicalAddressArray,                                          \
                _ArraySize)                                                     \
{                                                                               \
    PNDIS_MINIPORT_BLOCK _Miniport = (PNDIS_MINIPORT_BLOCK)(_MiniportAdapterHandle);\
    PMAP_TRANSFER mapTransfer = *_Miniport->SystemAdapterObject->DmaOperations->MapTransfer;\
    PHYSICAL_ADDRESS _LogicalAddress;                                           \
    PUCHAR _VirtualAddress;                                                     \
    ULONG _LengthRemaining;                                                     \
    ULONG _LengthMapped;                                                        \
    UINT _CurrentArrayLocation;                                                 \
                                                                                \
    _VirtualAddress = (PUCHAR)MmGetMdlVirtualAddress(_Buffer);                  \
    _LengthRemaining = MmGetMdlByteCount(_Buffer);                              \
    _CurrentArrayLocation = 0;                                                  \
                                                                                \
    while (_LengthRemaining > 0)                                                \
    {                                                                           \
        _LengthMapped = _LengthRemaining;                                       \
        _LogicalAddress =                                                       \
            mapTransfer(_Miniport->SystemAdapterObject,                         \
                        (_Buffer),                                              \
                        _Miniport->MapRegisters[_PhysicalMapRegister].MapRegister,\
                        _VirtualAddress,                                        \
                        &_LengthMapped,                                         \
                        (_Write));                                              \
        (_PhysicalAddressArray)[_CurrentArrayLocation].PhysicalAddress = _LogicalAddress;\
        (_PhysicalAddressArray)[_CurrentArrayLocation].Length = _LengthMapped;  \
        _LengthRemaining -= _LengthMapped;                                      \
        _VirtualAddress += _LengthMapped;                                       \
        ++_CurrentArrayLocation;                                                \
    }                                                                           \
    _Miniport->MapRegisters[_PhysicalMapRegister].WriteToDevice = (_Write);     \
    *(_ArraySize) = _CurrentArrayLocation;                                      \
}

#define NdisMCompleteBufferPhysicalMappingMacro(_MiniportAdapterHandle,         \
                                                _Buffer,                        \
                                                _PhysicalMapRegister)           \
{                                                                               \
    PNDIS_MINIPORT_BLOCK _Miniport = (PNDIS_MINIPORT_BLOCK)(_MiniportAdapterHandle);\
    PFLUSH_ADAPTER_BUFFERS flushAdapterBuffers = *_Miniport->SystemAdapterObject->DmaOperations->FlushAdapterBuffers;\
                                                                                \
    flushAdapterBuffers(_Miniport->SystemAdapterObject,                         \
                        _Buffer,                                                \
                        (_Miniport)->MapRegisters[_PhysicalMapRegister].MapRegister,\
                        MmGetMdlVirtualAddress(_Buffer),                        \
                        MmGetMdlByteCount(_Buffer),                             \
                        (_Miniport)->MapRegisters[_PhysicalMapRegister].WriteToDevice);\
}

#endif  //_MACROS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ndis\sys\mac.c ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation

Module Name:

    mac.c

Abstract:

    NDIS wrapper functions for full mac drivers

Author:

    Adam Barr (adamba) 11-Jul-1990

Environment:

    Kernel mode, FSD

Revision History:

    26-Feb-1991  JohnsonA       Added Debugging Code
    10-Jul-1991  JohnsonA       Implement revised Ndis Specs
    01-Jun-1995  JameelH        Re-organized

--*/


#include <precomp.h>
#pragma hdrstop

#include <stdarg.h>

//
//  Define the module number for debug code.
//
#define MODULE_NUMBER   MODULE_MAC

IO_ALLOCATION_ACTION
ndisDmaExecutionRoutine(
    IN  PDEVICE_OBJECT          DeviceObject,
    IN  PIRP                    Irp,
    IN  PVOID                   MapRegisterBase,
    IN  PVOID                   Context
    )

/*++

Routine Description:

    This routine is an execution routine for AllocateAdapterChannel,
    if is called when an adapter channel allocated by
    NdisAllocateDmaChannel is available.

Arguments:

    DeviceObject - The device object of the adapter.

    Irp - ??.

    MapRegisterBase - The address of the first translation table
        assigned to us.

    Context - A pointer to the NDIS_DMA_BLOCK in question.

Return Value:

    None.

--*/
{
    PNDIS_DMA_BLOCK DmaBlock = (PNDIS_DMA_BLOCK)Context;

    UNREFERENCED_PARAMETER (Irp);
    UNREFERENCED_PARAMETER (DeviceObject);


    //
    // Save the map register base.
    //

    DmaBlock->MapRegisterBase = MapRegisterBase;

    //
    // This will free the thread that is waiting for this callback.
    //

    SET_EVENT(&DmaBlock->AllocationEvent);

    return KeepObject;
}

IO_ALLOCATION_ACTION
ndisAllocationExecutionRoutine(
    IN  PDEVICE_OBJECT          DeviceObject,
    IN  PIRP                    Irp,
    IN  PVOID                   MapRegisterBase,
    IN  PVOID                   Context
    )

/*++

Routine Description:

    This routine is the execution routine for AllocateAdapterChannel,
    if is called when the map registers have been assigned.

Arguments:

    DeviceObject - The device object of the adapter.

    Irp - ??.

    MapRegisterBase - The address of the first translation table
        assigned to us.

    Context - A pointer to the Adapter in question.

Return Value:

    None.

--*/
{
    PNDIS_MINIPORT_BLOCK    Miniport = (PNDIS_MINIPORT_BLOCK)Context;

    //
    // Save this translation entry in the correct spot.
    //

    Miniport->MapRegisters[Miniport->CurrentMapRegister].MapRegister = MapRegisterBase;

    //
    // This will free the thread that is waiting for this callback.
    //

    SET_EVENT(Miniport->AllocationEvent);

    return DeallocateObjectKeepRegisters;
}


VOID __cdecl
NdisWriteErrorLogEntry(
    IN  NDIS_HANDLE             NdisAdapterHandle,
    IN  NDIS_ERROR_CODE         ErrorCode,
    IN  ULONG                   NumberOfErrorValues,
    ...
    )
/*++

Routine Description:

    This function allocates an I/O error log record, fills it in and writes it
    to the I/O error log.


Arguments:

    NdisAdapterHandle - points to the adapter block.

    ErrorCode - Ndis code mapped to a string.

    NumberOfErrorValues - number of ULONGS to store for the error.

Return Value:

    None.


--*/
{
    va_list ArgumentPointer;

    PIO_ERROR_LOG_PACKET    errorLogEntry;
    PNDIS_MINIPORT_BLOCK    Miniport = (PNDIS_MINIPORT_BLOCK)NdisAdapterHandle;
    PDEVICE_OBJECT          DeviceObject;
    UINT                    i, StringSize;
    PWCH                    baseFileName;
    ULONG                   ulErrorLogSize = 0;

    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
            ("==>NdisWriteErrorLogEntry\n"));
            
    if (Miniport == NULL)
    {
        return;
    }

    baseFileName = Miniport->pAdapterInstanceName->Buffer;
    StringSize = Miniport->pAdapterInstanceName->MaximumLength;

    ulErrorLogSize = sizeof(IO_ERROR_LOG_PACKET) + NumberOfErrorValues * sizeof(ULONG) + StringSize;

    //
    // If the size is too large , use the MiniportName instead (\Device\{GUID} )
    //
    if (ulErrorLogSize > ERROR_LOG_MAXIMUM_SIZE )
    {
        baseFileName = Miniport->MiniportName.Buffer;
        StringSize = Miniport->MiniportName.MaximumLength;
        
        ulErrorLogSize = sizeof(IO_ERROR_LOG_PACKET) + NumberOfErrorValues * sizeof(ULONG) + StringSize;

    }
    

    errorLogEntry = (PIO_ERROR_LOG_PACKET)IoAllocateErrorLogEntry(Miniport->DeviceObject, (UCHAR)ulErrorLogSize);

    if (errorLogEntry != NULL)
    {
        errorLogEntry->ErrorCode = ErrorCode;

        //
        // store the time
        //

        errorLogEntry->MajorFunctionCode = 0;
        errorLogEntry->RetryCount = 0;
        errorLogEntry->UniqueErrorValue = 0;
        errorLogEntry->FinalStatus = 0;
        errorLogEntry->SequenceNumber = 0;
        errorLogEntry->IoControlCode = 0;

        //
        // Store Data
        //

        errorLogEntry->DumpDataSize = (USHORT)(NumberOfErrorValues * sizeof(ULONG));

        va_start(ArgumentPointer, NumberOfErrorValues);

        for (i = 0; i < NumberOfErrorValues; i++)
        {
            errorLogEntry->DumpData[i] = va_arg(ArgumentPointer, ULONG);
        }

        va_end(ArgumentPointer);


        //
        // Set string information
        //

        if (StringSize != 0)
        {
            errorLogEntry->NumberOfStrings = 1;
            errorLogEntry->StringOffset = (USHORT)(sizeof(IO_ERROR_LOG_PACKET) + NumberOfErrorValues * sizeof(ULONG));


            CopyMemory(((PUCHAR)errorLogEntry) + (sizeof(IO_ERROR_LOG_PACKET) +
                       NumberOfErrorValues * sizeof(ULONG)),
                       baseFileName,
                       StringSize);

        }
        else
        {
            errorLogEntry->NumberOfStrings = 0;
        }

        //
        // write it out
        //

        IoWriteErrorLogEntry(errorLogEntry);
    }

    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
            ("<==NdisWriteErrorLogEntry\n"));
}


VOID
NdisSend(
    OUT PNDIS_STATUS            Status,
    IN  NDIS_HANDLE             NdisBindingHandle,
    IN  PNDIS_PACKET            Packet
    )
{
    *Status = (((PNDIS_OPEN_BLOCK)NdisBindingHandle)->SendHandler)(
                        (PNDIS_OPEN_BLOCK)NdisBindingHandle,
                        Packet);
}

VOID
NdisSendPackets(
    IN  NDIS_HANDLE             NdisBindingHandle,
    IN  PPNDIS_PACKET           PacketArray,
    IN  UINT                    NumberOfPackets
    )
{
    (((PNDIS_OPEN_BLOCK)NdisBindingHandle)->SendPacketsHandler)(
                        (PNDIS_OPEN_BLOCK)NdisBindingHandle,
                        PacketArray,
                        NumberOfPackets);
}

VOID
NdisTransferData(
    OUT PNDIS_STATUS            Status,
    IN  NDIS_HANDLE             NdisBindingHandle,
    IN  NDIS_HANDLE             MacReceiveContext,
    IN  UINT                    ByteOffset,
    IN  UINT                    BytesToTransfer,
    OUT PNDIS_PACKET            Packet,
    OUT PUINT                   BytesTransferred
    )
{
    *Status = (((PNDIS_OPEN_BLOCK)NdisBindingHandle)->TransferDataHandler)(
                        (PNDIS_OPEN_BLOCK)NdisBindingHandle,
                        MacReceiveContext,
                        ByteOffset,
                        BytesToTransfer,
                        Packet,
                        BytesTransferred);
}

VOID
NdisReset(
    OUT PNDIS_STATUS            Status,
    IN  NDIS_HANDLE             NdisBindingHandle
    )
{
    *Status = NDIS_STATUS_NOT_RESETTABLE;
    if (((PNDIS_OPEN_BLOCK)NdisBindingHandle)->ResetHandler != NULL)
    {
        *Status = (((PNDIS_OPEN_BLOCK)NdisBindingHandle)->ResetHandler)(
                        (PNDIS_OPEN_BLOCK)NdisBindingHandle);
    }
}

VOID
NdisRequest(
    OUT PNDIS_STATUS            Status,
    IN  NDIS_HANDLE             NdisBindingHandle,
    IN  PNDIS_REQUEST           NdisRequest
    )
{
    *Status = (((PNDIS_OPEN_BLOCK)NdisBindingHandle)->RequestHandler)(
                        (PNDIS_OPEN_BLOCK)NdisBindingHandle,
                        NdisRequest);
}

BOOLEAN
FASTCALL
ndisReferenceRef(
    IN  PREFERENCE              RefP
    )

/*++

Routine Description:

    Adds a reference to an object.

Arguments:

    RefP - A pointer to the REFERENCE portion of the object.

Return Value:

    TRUE if the reference was added.
    FALSE if the object was closing.

--*/

{
    BOOLEAN rc = TRUE;
    KIRQL   OldIrql;

    DBGPRINT_RAW(DBG_COMP_ALL, DBG_LEVEL_INFO,
            ("==>ndisReferenceRef\n"));

    IF_DBG(DBG_COMP_PROTOCOL, DBG_LEVEL_ERR)
    {
        if (DbgIsNull(RefP))
        {
            DBGPRINT(DBG_COMP_ALL, DBG_LEVEL_ERR,
                    ("ndisReferenceRef: NULL Reference address\n"));
            DBGBREAK(DBG_COMP_ALL, DBG_LEVEL_ERR);
        }
        if (!DbgIsNonPaged(RefP))
        {
            DBGPRINT(DBG_COMP_ALL, DBG_LEVEL_ERR,
                    ("ndisReferenceRef: Reference not in NonPaged Memory\n"));
            DBGBREAK(DBG_COMP_ALL, DBG_LEVEL_ERR);
        }
    }
    ACQUIRE_SPIN_LOCK(&RefP->SpinLock, &OldIrql);

    if (RefP->Closing)
    {
        rc = FALSE;
    }
    else
    {
        ++(RefP->ReferenceCount);
    }

    RELEASE_SPIN_LOCK(&RefP->SpinLock, OldIrql);

    DBGPRINT_RAW(DBG_COMP_ALL, DBG_LEVEL_INFO,
            ("<==ndisReferenceRef\n"));

    return(rc);
}


BOOLEAN
FASTCALL
ndisDereferenceRef(
    IN  PREFERENCE              RefP
    )

/*++

Routine Description:

    Removes a reference to an object.

Arguments:

    RefP - A pointer to the REFERENCE portion of the object.

Return Value:

    TRUE if the reference count is now 0.
    FALSE otherwise.

--*/

{
    BOOLEAN rc = FALSE;
    KIRQL   OldIrql;

    DBGPRINT_RAW(DBG_COMP_ALL, DBG_LEVEL_INFO,
            ("==>ndisDereferenceRef\n"));

    IF_DBG(DBG_COMP_PROTOCOL, DBG_LEVEL_ERR)
    {
        if (DbgIsNull(RefP))
        {
            DBGPRINT(DBG_COMP_ALL, DBG_LEVEL_ERR,
                    ("ndisDereferenceRef: NULL Reference address\n"));
            DBGBREAK(DBG_COMP_ALL, DBG_LEVEL_ERR);
        }
        if (!DbgIsNonPaged(RefP))
        {
            DBGPRINT(DBG_COMP_ALL, DBG_LEVEL_ERR,
                    ("ndisDereferenceRef: Reference not in NonPaged Memory\n"));
            DBGBREAK(DBG_COMP_ALL, DBG_LEVEL_ERR);
        }
    }

    ACQUIRE_SPIN_LOCK(&RefP->SpinLock, &OldIrql);

    --(RefP->ReferenceCount);

    if (RefP->ReferenceCount == 0)
    {
        rc = TRUE;
    }

    RELEASE_SPIN_LOCK(&RefP->SpinLock, OldIrql);

    DBGPRINT_RAW(DBG_COMP_ALL, DBG_LEVEL_INFO,
            ("<==ndisDereferenceRef\n"));
            
    return(rc);
}


VOID
FASTCALL
ndisInitializeRef(
    IN  PREFERENCE              RefP
    )

/*++

Routine Description:

    Initialize a reference count structure.

Arguments:

    RefP - The structure to be initialized.

Return Value:

    None.

--*/

{
    DBGPRINT_RAW(DBG_COMP_ALL, DBG_LEVEL_INFO,
            ("==>ndisInitializeRef\n"));

    IF_DBG(DBG_COMP_PROTOCOL, DBG_LEVEL_ERR)
    {
        if (DbgIsNull(RefP))
        {
            DBGPRINT(DBG_COMP_ALL, DBG_LEVEL_ERR,
                    ("ndisInitializeRef: NULL Reference address\n"));
            DBGBREAK(DBG_COMP_ALL, DBG_LEVEL_ERR);
        }
        if (!DbgIsNonPaged(RefP))
        {
            DBGPRINT(DBG_COMP_ALL, DBG_LEVEL_ERR,
                    ("ndisInitializeRef: Reference not in NonPaged Memory\n"));
            DBGBREAK(DBG_COMP_ALL, DBG_LEVEL_ERR);
        }
    }

    RefP->Closing = FALSE;
    RefP->ReferenceCount = 1;
    INITIALIZE_SPIN_LOCK(&RefP->SpinLock);

    DBGPRINT_RAW(DBG_COMP_ALL, DBG_LEVEL_INFO,
            ("<==ndisInitializeRef\n"));
}


BOOLEAN
FASTCALL
ndisCloseRef(
    IN  PREFERENCE              RefP
    )

/*++

Routine Description:

    Closes a reference count structure.

Arguments:

    RefP - The structure to be closed.

Return Value:

    FALSE if it was already closing.
    TRUE otherwise.

--*/

{
    KIRQL   OldIrql;
    BOOLEAN rc = TRUE;

    DBGPRINT_RAW(DBG_COMP_ALL, DBG_LEVEL_INFO,
            ("==>ndisCloseRef\n"));

    ACQUIRE_SPIN_LOCK(&RefP->SpinLock, &OldIrql);

    if (RefP->Closing)
    {
        rc = FALSE;
    }
    else RefP->Closing = TRUE;

    RELEASE_SPIN_LOCK(&RefP->SpinLock, OldIrql);

    DBGPRINT_RAW(DBG_COMP_ALL, DBG_LEVEL_INFO,
            ("<==ndisCloseRef\n"));
            
    return(rc);
}

BOOLEAN
FASTCALL
ndisReferenceULongRef(
    IN  PULONG_REFERENCE              RefP
    )

/*++

Routine Description:

    Adds a reference to an object.

Arguments:

    RefP - A pointer to the REFERENCE portion of the object.

Return Value:

    TRUE if the reference was added.
    FALSE if the object was closing.

--*/

{
    BOOLEAN rc = TRUE;
    KIRQL   OldIrql;

    DBGPRINT_RAW(DBG_COMP_ALL, DBG_LEVEL_INFO,
            ("==>ndisReferenceULongRef\n"));

    ACQUIRE_SPIN_LOCK(&RefP->SpinLock, &OldIrql);

    if (RefP->Closing)
    {
        rc = FALSE;
    }
    else
    {
        ++(RefP->ReferenceCount);
        
        if (RefP->ReferenceCount == 0)
        {
            --(RefP->ReferenceCount);
            rc = FALSE;        
        }
    }

    RELEASE_SPIN_LOCK(&RefP->SpinLock, OldIrql);

    DBGPRINT_RAW(DBG_COMP_ALL, DBG_LEVEL_INFO,
            ("<==ndisReferenceULongRef\n"));

    return(rc);
}


VOID
FASTCALL
ndisReferenceULongRefNoCheck(
    IN  PULONG_REFERENCE                RefP
    )

/*++

Routine Description:

    Adds a reference to an object.

Arguments:

    RefP - A pointer to the REFERENCE portion of the object.

Return Value:

    None
--*/

{
    KIRQL   OldIrql;

    DBGPRINT_RAW(DBG_COMP_ALL, DBG_LEVEL_INFO,
            ("==>ndisReferenceULongRefNoCheck\n"));

    ACQUIRE_SPIN_LOCK(&RefP->SpinLock, &OldIrql);

    ++(RefP->ReferenceCount);

    RELEASE_SPIN_LOCK(&RefP->SpinLock, OldIrql);

    DBGPRINT_RAW(DBG_COMP_ALL, DBG_LEVEL_INFO,
            ("<==ndisReferenceULongRefNoCheck\n"));

}



BOOLEAN
FASTCALL
ndisDereferenceULongRef(
    IN  PULONG_REFERENCE              RefP
    )

/*++

Routine Description:

    Removes a reference to an object.

Arguments:

    RefP - A pointer to the REFERENCE portion of the object.

Return Value:

    TRUE if the reference count is now 0.
    FALSE otherwise.

--*/

{
    BOOLEAN rc = FALSE;
    KIRQL   OldIrql;

    DBGPRINT_RAW(DBG_COMP_ALL, DBG_LEVEL_INFO,
            ("==>ndisDereferenceULongRef\n"));

    ACQUIRE_SPIN_LOCK(&RefP->SpinLock, &OldIrql);

    --(RefP->ReferenceCount);

    if (RefP->ReferenceCount == 0)
    {
        rc = TRUE;
    }

    RELEASE_SPIN_LOCK(&RefP->SpinLock, OldIrql);

    DBGPRINT_RAW(DBG_COMP_ALL, DBG_LEVEL_INFO,
            ("<==ndisDereferenceULongRef\n"));
            
    return(rc);
}


VOID
FASTCALL
ndisInitializeULongRef(
    IN  PULONG_REFERENCE              RefP
    )

/*++

Routine Description:

    Initialize a reference count structure.

Arguments:

    RefP - The structure to be initialized.

Return Value:

    None.

--*/

{
    DBGPRINT_RAW(DBG_COMP_ALL, DBG_LEVEL_INFO,
            ("==>ndisInitializeULongRef\n"));
    
    RefP->Closing = FALSE;
    RefP->ReferenceCount = 1;
    INITIALIZE_SPIN_LOCK(&RefP->SpinLock);

    DBGPRINT_RAW(DBG_COMP_ALL, DBG_LEVEL_INFO,
            ("<==ndisInitializeULongRef\n"));
}


BOOLEAN
FASTCALL
ndisCloseULongRef(
    IN  PULONG_REFERENCE                RefP
    )

/*++

Routine Description:

    Closes a reference count structure.

Arguments:

    RefP - The structure to be closed.

Return Value:

    FALSE if it was already closing.
    TRUE otherwise.

--*/

{
    KIRQL   OldIrql;
    BOOLEAN rc = TRUE;

    DBGPRINT_RAW(DBG_COMP_ALL, DBG_LEVEL_INFO,
            ("==>ndisCloseULongRef\n"));

    ACQUIRE_SPIN_LOCK(&RefP->SpinLock, &OldIrql);

    if (RefP->Closing)
    {
        rc = FALSE;
    }
    else RefP->Closing = TRUE;

    RELEASE_SPIN_LOCK(&RefP->SpinLock, OldIrql);

    DBGPRINT_RAW(DBG_COMP_ALL, DBG_LEVEL_INFO,
            ("<==ndisCloseULongRef\n"));
            
    return(rc);
}


NTSTATUS
ndisCreateIrpHandler(
    IN  PDEVICE_OBJECT          DeviceObject,
    IN  PIRP                    Irp
    )

/*++

Routine Description:

    The handle for IRP_MJ_CREATE IRPs.

Arguments:

    DeviceObject - The adapter's device object.
    Irp - The IRP.

Return Value:

    STATUS_SUCCESS if it should be.

--*/

{
    PIO_STACK_LOCATION          IrpSp;
    PNDIS_USER_OPEN_CONTEXT     OpenContext = NULL;
    NTSTATUS                    Status = STATUS_SUCCESS, SecurityStatus;
    PNDIS_MINIPORT_BLOCK        Miniport;
    KIRQL                       OldIrql;
    BOOLEAN                     fRef = FALSE;
    BOOLEAN                     fWait;
    BOOLEAN                     fUserModeRef = FALSE;
    BOOLEAN                     AdminAccessAllowed = FALSE;
    BOOLEAN                     DerefAdminOpenCount = FALSE, DerefUserOpenCount = FALSE; 

    DBGPRINT_RAW(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
            ("==>ndisCreateIrpHandler\n"));
    IF_DBG(DBG_COMP_PROTOCOL, DBG_LEVEL_ERR)
    {
        if (DbgIsNull(Irp))
        {
            DBGPRINT(DBG_COMP_ALL, DBG_LEVEL_ERR,
                    (": Null Irp\n"));
            DBGBREAK(DBG_COMP_ALL, DBG_LEVEL_ERR);
        }
        if (!DbgIsNonPaged(Irp))
        {
            DBGPRINT(DBG_COMP_ALL, DBG_LEVEL_ERR,
                    (": Irp not in NonPaged Memory\n"));
            DBGBREAK(DBG_COMP_ALL, DBG_LEVEL_ERR);
        }
    }

    IrpSp = IoGetCurrentIrpStackLocation (Irp);
    if (IrpSp->FileObject == NULL)
    {
        Irp->IoStatus.Status = STATUS_UNSUCCESSFUL;
        IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);
        return(STATUS_UNSUCCESSFUL);
    }

    Miniport = (PNDIS_MINIPORT_BLOCK)((PNDIS_WRAPPER_CONTEXT)DeviceObject->DeviceExtension + 1);

    if (Miniport->Signature != (PVOID)MINIPORT_DEVICE_MAGIC_VALUE)
    {
        return (ndisDummyIrpHandler(DeviceObject, Irp));
    }

    AdminAccessAllowed = ndisCheckAccess(Irp, 
                                         IrpSp, 
                                         &SecurityStatus, 
                                         Miniport->SecurityDescriptor);

    do
    {
        ACQUIRE_SPIN_LOCK(&Miniport->Ref.SpinLock, &OldIrql);

        if ((AdminAccessAllowed && (Miniport->NumAdminOpens >= NDIS_MAX_ADMIN_OPEN_HANDLES)) ||
            ((!AdminAccessAllowed) && (Miniport->NumUserOpens >= NDIS_MAX_USER_OPEN_HANDLES)))
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            RELEASE_SPIN_LOCK(&Miniport->Ref.SpinLock, OldIrql);
            break;
        }
        
        if (AdminAccessAllowed)
        {
            Miniport->NumAdminOpens++;
            DerefAdminOpenCount = TRUE;;
        }
        else
        {
            Miniport->NumUserOpens++;
            DerefUserOpenCount = TRUE;
        }

        RELEASE_SPIN_LOCK(&Miniport->Ref.SpinLock, OldIrql);
        if (MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_DEVICE_FAILED | 
                                             fMINIPORT_REJECT_REQUESTS))
        {
            Status = STATUS_UNSUCCESSFUL;
            break;
        }

        {
            BOOLEAN fWait;

            if (!(fWait = NdisWaitEvent(&Miniport->OpenReadyEvent, 50)) ||
                !(fRef = MINIPORT_INCREMENT_REF_CREATE(Miniport, Irp)))
            {
                if (!fWait && (MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_SYSTEM_SLEEPING) ||
                               !MINIPORT_TEST_FLAG(Miniport, fMINIPORT_MEDIA_CONNECTED)))
                {
                    Status = STATUS_DEVICE_POWERED_OFF;
                }
                else
                {
                    Status = NDIS_STATUS_ADAPTER_NOT_FOUND;
                }
                break;
            }
        }
    
        //
        // Lock down this code since we are about to take a spinlock.
        //
        PnPReferencePackage();

        NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Miniport, &OldIrql);

        if (Miniport->PnPDeviceState == NdisPnPDeviceQueryStopped)
        {
            Status = NDIS_STATUS_ADAPTER_NOT_FOUND;
            NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);

            PnPDereferencePackage();
            break;
        }
        Miniport->UserModeOpenReferences++;
        fUserModeRef = TRUE;

        NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);

        PnPDereferencePackage();
        
        OpenContext = (PNDIS_USER_OPEN_CONTEXT)ALLOC_FROM_POOL(sizeof(NDIS_USER_OPEN_CONTEXT),
                                                               NDIS_TAG_OPEN_CONTEXT);
        if (OpenContext == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
        }
        else
        {
            OpenContext->DeviceObject = DeviceObject;
            OpenContext->Miniport = Miniport;
            OpenContext->OidList = NULL;
            OpenContext->AdminAccessAllowed = AdminAccessAllowed;

            IrpSp->FileObject->FsContext = OpenContext;
    
            //
            // Checked if we already cached OidList, if so just set it here.
            //
            if (Miniport->OidList != NULL)
            {
                OpenContext->OidList = Miniport->OidList;
                Status = NDIS_STATUS_SUCCESS;
            }

            if (OpenContext->OidList == NULL)
            {
                Status = ndisQueryOidList(OpenContext);
            }
    
            if (Status != NDIS_STATUS_SUCCESS)
            {
                if (NT_SUCCESS(Status))
                {
                    //
                    // Some drivers return some bogus non-zero error
                    //
                    Status = STATUS_UNSUCCESSFUL;
                }

            }
        }
    } while (FALSE);

    if (NT_SUCCESS(Status) && MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_SWENUM))
    {
        PBUS_INTERFACE_REFERENCE    BusInterface;

        BusInterface = (PBUS_INTERFACE_REFERENCE)(Miniport->BusInterface);

        ASSERT(BusInterface != NULL);

        if (BusInterface)
        {
            BusInterface->ReferenceDeviceObject(BusInterface->Interface.Context);
        }
        else
        {
            Status = STATUS_UNSUCCESSFUL;
        }
    }

    if (!NT_SUCCESS(Status))
    {
        if (DerefAdminOpenCount)
        {
            ACQUIRE_SPIN_LOCK(&Miniport->Ref.SpinLock, &OldIrql);
            Miniport->NumAdminOpens--;            
            RELEASE_SPIN_LOCK(&Miniport->Ref.SpinLock, OldIrql);
        }
        if (DerefUserOpenCount)
        {
            ACQUIRE_SPIN_LOCK(&Miniport->Ref.SpinLock, &OldIrql);
            Miniport->NumUserOpens--;
            RELEASE_SPIN_LOCK(&Miniport->Ref.SpinLock, OldIrql);
        }
        
        if (fUserModeRef)
        {
            PnPReferencePackage();
            NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Miniport, &OldIrql);
            Miniport->UserModeOpenReferences--;
            NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);
            PnPDereferencePackage();
        }
        
        if (fRef)
        {
            MINIPORT_DECREMENT_REF_CLOSE(Miniport, Irp);
        }

        if (OpenContext)
        {
            FREE_POOL(OpenContext);
        }
    }

    Irp->IoStatus.Status = Status;

    IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);

    DBGPRINT_RAW(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
            ("<==NdisCreateIrplHandler\n"));

    return Status;
}


NDIS_STATUS
FASTCALL
ndisQueryOidList(
    IN  PNDIS_USER_OPEN_CONTEXT OpenContext
    )

/*++

Routine Description:

    This routine will take care of querying the complete OID list for the MAC and filling in
    OpenContext->OidList->OidArray with the ones that are statistics. It blocks when the
    MAC pends and so is synchronous.

    NOTE: We also handle co-ndis miniports here.

Arguments:

    OpenContext - The open context.

Return Value:

    STATUS_SUCCESS if it should be.

--*/
{
    NDIS_REQUEST            Request;
    NDIS_STATUS             Status;
    PNDIS_OID               Buffer;
    ULONG                   BufferLength;

    Status = ndisQueryDeviceOid(OpenContext,
                                &Request,
                                OID_GEN_SUPPORTED_LIST,
                                NULL,
                                0);
    if ((Status != NDIS_STATUS_INVALID_LENGTH) && (Status != NDIS_STATUS_BUFFER_TOO_SHORT))
    {
        return Status;
    }

    //
    // Now we know how much is needed, allocate temp storage...
    //
    BufferLength = Request.DATA.QUERY_INFORMATION.BytesNeeded;
    Buffer = ALLOC_FROM_POOL(BufferLength, NDIS_TAG_DEFAULT);

    if (Buffer == NULL)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    Status = ndisQueryDeviceOid(OpenContext,
                                &Request,
                                OID_GEN_SUPPORTED_LIST,
                                Buffer,
                                BufferLength);

    if (Status == NDIS_STATUS_SUCCESS)
    {
        Status = ndisSplitStatisticsOids(OpenContext,
                                         Buffer,
                                         BufferLength/sizeof(NDIS_OID));
    }
    
    FREE_POOL(Buffer);

    return Status;
}


NDIS_STATUS
FASTCALL
ndisSplitStatisticsOids(
    IN  PNDIS_USER_OPEN_CONTEXT OpenContext,
    IN  PNDIS_OID               OidList,
    IN  ULONG                   NumOids
    )
{
    ULONG   i, j;
    ULONG   StatsOids;

    //
    // Go through the buffer, counting the statistics OIDs.
    // Ignore all the custom oids which match the statistics
    // criteria
    //
    for (i = StatsOids = 0; i < NumOids; i++)
    {
        if (((OidList[i] & 0x00ff0000) == 0x00020000) &&
            ((OidList[i] & 0xff000000) != 0xff000000))
        {
            StatsOids++;
        }
    }

    //
    // Now allocate storage for the stat and non-stat OID arrays.
    //
    OpenContext->OidList = (POID_LIST)ALLOC_FROM_POOL(sizeof(OID_LIST) + ((StatsOids + NumOids)*sizeof(NDIS_OID)),
                                                      NDIS_TAG_OID_ARRAY);
    if (OpenContext->OidList == NULL)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    
    OpenContext->OidList->FullOidCount = NumOids;
    OpenContext->OidList->FullOidArray = (PNDIS_OID)(OpenContext->OidList + 1);
    OpenContext->OidList->StatsOidCount = StatsOids;
    OpenContext->OidList->StatsOidArray = OpenContext->OidList->FullOidArray + NumOids;

    //
    // Now go through the buffer, copying the statistics and non-stat OIDs separately.
    //
    for (i = j = 0; i < NumOids; i++)
    {
        if (((OidList[i] & 0x00ff0000) == 0x00020000) &&
            ((OidList[i] & 0xff000000) != 0xff000000))
        {
            OpenContext->OidList->StatsOidArray[j++] = OidList[i];
        }
        OpenContext->OidList->FullOidArray[i] = OidList[i];
    }

    ASSERT (j == OpenContext->OidList->StatsOidCount);

    //
    // Save it in the miniport
    //
    OpenContext->Miniport->OidList = OpenContext->OidList;

    return NDIS_STATUS_SUCCESS;
}


VOID
ndisCancelLogIrp(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp
    )
/*++

Routine Description:

Arguments:

    DeviceObject - The adapter's device object.
    Irp - The IRP.

Return Value:

    STATUS_SUCCESS if it should be.

--*/
{
    PIO_STACK_LOCATION      IrpSp;
    PNDIS_USER_OPEN_CONTEXT OpenContext;
    PNDIS_MINIPORT_BLOCK    Miniport;
    PNDIS_LOG               Log;
    KIRQL                   OldIrql;

    IrpSp = IoGetCurrentIrpStackLocation (Irp);
    OpenContext = IrpSp->FileObject->FsContext;
    ASSERT(OpenContext != NULL);
    Miniport = OpenContext->Miniport;

    NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Miniport, &OldIrql);

    ASSERT (Miniport->Log != NULL);
    ASSERT (Miniport->Log->Irp == Irp);

    Miniport->Log->Irp = NULL;
    Irp->IoStatus.Status = STATUS_REQUEST_ABORTED;
    Irp->IoStatus.Information = 0;
    NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);

    IoReleaseCancelSpinLock(Irp->CancelIrql);
    IoCompleteRequest (Irp, IO_NETWORK_INCREMENT);
}


NTSTATUS
ndisDeviceControlIrpHandler(
    IN  PDEVICE_OBJECT          DeviceObject,
    IN  PIRP                    Irp
    )
/*++

Routine Description:

    The handle for IRP_MJ_DEVICE_CONTROL IRPs.

Arguments:

    DeviceObject - The adapter's device object.
    Irp - The IRP.

Return Value:

    STATUS_SUCCESS if it should be.

--*/
{
    PIO_STACK_LOCATION      IrpSp;
    PNDIS_USER_OPEN_CONTEXT OpenContext;
    NDIS_REQUEST            Request;
    PNDIS_MINIPORT_BLOCK    Miniport;
    NDIS_STATUS             NdisStatus;
    UINT                    CurrentOid, OidCount;
    PNDIS_OID               OidArray;
    ULONG                   BytesWritten, BytesWrittenThisOid;
    PUCHAR                  Buffer;
    ULONG                   BufferLength;
    ULONG                   DataLength;
    NTSTATUS                Status = STATUS_SUCCESS;
    BOOLEAN                 fWaitComplete = FALSE;

    DBGPRINT_RAW(DBG_COMP_ALL, DBG_LEVEL_INFO,
            ("==>ndisDeviceControlIrpHandler\n"));
    IF_DBG(DBG_COMP_PROTOCOL, DBG_LEVEL_ERR)
    {
        if (DbgIsNull(Irp))
        {
            DBGPRINT(DBG_COMP_ALL, DBG_LEVEL_ERR,
                    (": Null Irp\n"));
            DBGBREAK(DBG_COMP_ALL, DBG_LEVEL_ERR);
        }
        if (!DbgIsNonPaged(Irp))
        {
            DBGPRINT(DBG_COMP_ALL, DBG_LEVEL_ERR,
                    (": Irp not in NonPaged Memory\n"));
            DBGBREAK(DBG_COMP_ALL, DBG_LEVEL_ERR);
        }
    }

    IrpSp = IoGetCurrentIrpStackLocation (Irp);
    if (IrpSp->FileObject == NULL)
    {
        return(STATUS_UNSUCCESSFUL);
    }

    Miniport = (PNDIS_MINIPORT_BLOCK)((PNDIS_WRAPPER_CONTEXT)DeviceObject->DeviceExtension + 1);

    if (Miniport->Signature != (PVOID)MINIPORT_DEVICE_MAGIC_VALUE)
    {
        return (ndisDummyIrpHandler(DeviceObject, Irp));    
    }
    
    if (MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_REMOVE_IN_PROGRESS | fMINIPORT_PM_HALTED))
    {
        Irp->IoStatus.Status = STATUS_UNSUCCESSFUL;
        IoCompleteRequest (Irp, IO_NETWORK_INCREMENT);
        return STATUS_UNSUCCESSFUL;
    }

    IoMarkIrpPending (Irp);
    Irp->IoStatus.Status = STATUS_PENDING;
    Irp->IoStatus.Information = 0;

    OpenContext = IrpSp->FileObject->FsContext;
    switch (IrpSp->Parameters.DeviceIoControl.IoControlCode)
    {
      case IOCTL_NDIS_GET_LOG_DATA:

        if (Irp->MdlAddress == NULL)
        {
            Status = STATUS_INVALID_PARAMETER;
            break;
        }

        NdisStatus = Status = ndisMGetLogData(Miniport, Irp);

        if (Status != STATUS_PENDING)
        {
            fWaitComplete = TRUE;
        }
        break;

      case IOCTL_NDIS_QUERY_GLOBAL_STATS:

        if ((IrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(ULONG)) ||
            !ndisValidOid(OpenContext,
                          *((PULONG)(Irp->AssociatedIrp.SystemBuffer))))
        {
            Status = STATUS_INVALID_PARAMETER;
            break;
        }

        Buffer = (Irp->MdlAddress != NULL) ? MDL_ADDRESS_SAFE(Irp->MdlAddress, LowPagePriority) : NULL;
        if ((Irp->MdlAddress != NULL) && (Buffer == NULL))
        {
            NdisStatus = NDIS_STATUS_RESOURCES;
            break;
        }

        NdisStatus = ndisQueryDeviceOid(OpenContext,
                                        &Request,
                                        *((PULONG)(Irp->AssociatedIrp.SystemBuffer)),
                                        Buffer,
                                        (Irp->MdlAddress != NULL) ? MDL_SIZE(Irp->MdlAddress) : 0);
        BytesWritten = Request.DATA.QUERY_INFORMATION.BytesWritten;
        Irp->IoStatus.Information = BytesWritten;
        fWaitComplete = TRUE;
        break;

      case IOCTL_NDIS_QUERY_ALL_STATS:

        OidCount = OpenContext->OidList->StatsOidCount;
        OidArray = OpenContext->OidList->StatsOidArray;
        goto common;
        break;

      case IOCTL_NDIS_QUERY_SELECTED_STATS:

        //
        // This is essentially a combination of QUERY_ALL_STATS and QUERY_GLOBAL_STATS.
        // Start off by verifying input parameters.
        //
        if ((IrpSp->Parameters.DeviceIoControl.InputBufferLength < sizeof(ULONG)) ||
            ((IrpSp->Parameters.DeviceIoControl.InputBufferLength % sizeof(ULONG)) != 0))
        {
            Status = STATUS_INVALID_PARAMETER;
            break;
        }

        OidCount = IrpSp->Parameters.DeviceIoControl.InputBufferLength / sizeof(NDIS_OID);
        OidArray = (PNDIS_OID)(Irp->AssociatedIrp.SystemBuffer);

      common:
        BufferLength = (Irp->MdlAddress != NULL) ? MDL_SIZE(Irp->MdlAddress) : 0;
        Buffer = (BufferLength != 0) ? (PUCHAR)MDL_ADDRESS_SAFE (Irp->MdlAddress, LowPagePriority) : NULL;
        if (Buffer == NULL)
        {
            NdisStatus = NDIS_STATUS_RESOURCES;
            break;
        }
        BytesWritten = 0;

        NdisStatus = NDIS_STATUS_SUCCESS;
        for (CurrentOid = 0; CurrentOid < OidCount; CurrentOid++)
        {
            NDIS_OID    Oid;
            BOOLEAN     fPrv, fInt;

            NdisZeroMemory(&Request, sizeof(NDIS_REQUEST));
            
            //
            // We need room for an NDIS_STATISTICS_VALUE (OID, Length, Data).
            //
            if (BufferLength < (ULONG)(NDIS_STATISTICS_HEADER_SIZE + sizeof(ULONG)))
            {
                NdisStatus = NDIS_STATUS_INVALID_LENGTH;
                break;
            }

            DataLength = BufferLength - NDIS_STATISTICS_HEADER_SIZE;

            //
            // Check if the OID is part of supported list - if not do not error out but ignore
            //
            Oid = OidArray[CurrentOid];

            fPrv = ((Oid & NDIS_OID_MASK) == NDIS_OID_PRIVATE);

            if (fPrv)
            {
                Oid &= ~NDIS_OID_PRIVATE;
            }

            fInt =  ((Oid == OID_GEN_ELAPSED_TIME) ||
                     (Oid == OID_GEN_INIT_TIME_MS) ||
                     (Oid == OID_GEN_RESET_COUNTS) ||
                     (Oid == OID_GEN_MEDIA_SENSE_COUNTS) ||
                     (Oid == OID_GEN_MINIPORT_INFO));

            if (fInt ||
                !ndisValidOid(OpenContext, Oid))
            {
                if (fPrv || fInt)
                {
                    NdisStatus = NDIS_STATUS_SUCCESS;

                    switch (Oid)
                    {
                      case OID_GEN_DIRECTED_FRAMES_RCV:
                        if (DataLength >= sizeof(ULONG64))
                        {
                            NdisMoveMemory((Buffer + NDIS_STATISTICS_HEADER_SIZE),
                                            &Miniport->NdisStats.DirectedPacketsIn,
                                            sizeof(ULONG64));
                            Request.DATA.QUERY_INFORMATION.BytesWritten = sizeof(ULONG64);
                        }
                        else
                        {
                            *(PULONG)(Buffer + NDIS_STATISTICS_HEADER_SIZE) = (ULONG)Miniport->NdisStats.DirectedPacketsIn;
                            Request.DATA.QUERY_INFORMATION.BytesWritten = sizeof(ULONG);
                        }
                        break;
    
                      case OID_GEN_DIRECTED_FRAMES_XMIT:
                        if (DataLength >= sizeof(ULONG64))
                        {
                            NdisMoveMemory((Buffer + NDIS_STATISTICS_HEADER_SIZE),
                                            &Miniport->NdisStats.DirectedPacketsOut,
                                            sizeof(ULONG64));
                            Request.DATA.QUERY_INFORMATION.BytesWritten = sizeof(ULONG64);
                        }
                        else
                        {
                            *(PULONG)(Buffer + NDIS_STATISTICS_HEADER_SIZE) = (ULONG)Miniport->NdisStats.DirectedPacketsOut;
                            Request.DATA.QUERY_INFORMATION.BytesWritten = sizeof(ULONG);
                        }
                        break;
    
                      case OID_GEN_MEDIA_IN_USE:
                        *(PULONG)(Buffer + NDIS_STATISTICS_HEADER_SIZE) = Miniport->MediaType;
                        Request.DATA.QUERY_INFORMATION.BytesWritten = sizeof(ULONG);
                        break;

                      case OID_GEN_PHYSICAL_MEDIUM:
                        *(PULONG)(Buffer + NDIS_STATISTICS_HEADER_SIZE) = Miniport->PhysicalMediumType;
                        Request.DATA.QUERY_INFORMATION.BytesWritten = sizeof(ULONG);
                        break;

                      case OID_GEN_MEDIA_CONNECT_STATUS:
                        *(PULONG)(Buffer + NDIS_STATISTICS_HEADER_SIZE) = (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_MEDIA_CONNECTED)) ?
                                                                            NdisMediaStateConnected : NdisMediaStateDisconnected;
                        Request.DATA.QUERY_INFORMATION.BytesWritten = sizeof(ULONG);
                        break;
    
#if NDIS_STATISTICS_BYTES
                      case OID_GEN_DIRECTED_BYTES_XMIT:
                        *(PULONGLONG)(Buffer + NDIS_STATISTICS_HEADER_SIZE) = Miniport->NdisStats.DirectedBytesOut.QuadPart;
                        Request.DATA.QUERY_INFORMATION.BytesWritten = sizeof(ULONGLONG);
                        break;

                      case OID_GEN_DIRECTED_BYTES_RCV:
                        *(PULONGLONG)(Buffer + NDIS_STATISTICS_HEADER_SIZE) = Miniport->NdisStats.DirectedBytesIn.QuadPart;
                        Request.DATA.QUERY_INFORMATION.BytesWritten = sizeof(ULONGLONG);
                        break;
#endif                      
                      case OID_GEN_INIT_TIME_MS:
                        *(PULONG)(Buffer + NDIS_STATISTICS_HEADER_SIZE) = Miniport->InitTimeMs;
                        Request.DATA.QUERY_INFORMATION.BytesWritten = sizeof(ULONG);
                        break;

                      case OID_GEN_RESET_COUNTS:
                        *(PULONG)(Buffer + NDIS_STATISTICS_HEADER_SIZE) = (Miniport->InternalResetCount + Miniport->MiniportResetCount);
                        Request.DATA.QUERY_INFORMATION.BytesWritten = sizeof(ULONG);
                        break;

                      case OID_GEN_MEDIA_SENSE_COUNTS:
                        *(PULONG)(Buffer + NDIS_STATISTICS_HEADER_SIZE) = (Miniport->MediaSenseDisconnectCount +
                                                                           (Miniport->MediaSenseConnectCount << 16));
                        Request.DATA.QUERY_INFORMATION.BytesWritten = sizeof(ULONG);
                        break;

                      case OID_GEN_ELAPSED_TIME:
                        {
                            TIME    CurrTicks;

                            KeQueryTickCount(&CurrTicks);
                            CurrTicks.QuadPart -= Miniport->NdisStats.StartTicks.QuadPart;
                            CurrTicks.QuadPart = CurrTicks.QuadPart*KeQueryTimeIncrement()/(10*1000*1000);

                            *(PULONG)(Buffer + NDIS_STATISTICS_HEADER_SIZE) = CurrTicks.LowPart;
                            Request.DATA.QUERY_INFORMATION.BytesWritten = sizeof(ULONG);
                        }
                        break;

                      case OID_GEN_RESET_VERIFY_PARAMETERS:
                        ndisFlags = *(PULONG)(Buffer + NDIS_STATISTICS_HEADER_SIZE);
                        ndisVerifierInitialization();
                        //
                        // when ndisFlags is set by ndis tester vs. reading it from
                        // registry, let it -clear- the verifier flags if necessary
                        // ndisVerifierInit takes care of -setting- them if necessary
                        //
                        if (!(ndisFlags & NDIS_GFLAG_INJECT_ALLOCATION_FAILURE))
                            ndisVerifierLevel &= ~DRIVER_VERIFIER_INJECT_ALLOCATION_FAILURES;
            
                        if (!(ndisFlags & NDIS_GFLAG_SPECIAL_POOL_ALLOCATION))
                            ndisVerifierLevel &= ~DRIVER_VERIFIER_SPECIAL_POOLING;

                        Request.DATA.SET_INFORMATION.BytesRead = sizeof(ULONG);
                        break;

                      case OID_GEN_MINIPORT_INFO:
                        {
                        ULONG   InfoFlags = Miniport->InfoFlags;

                        if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_64BITS_DMA))
                            InfoFlags |= NDIS_MINIPORT_64BITS_DMA;
                        if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_IS_CO))
                            InfoFlags |= NDIS_MINIPORT_IS_CO;
                        if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_REQUIRES_MEDIA_POLLING))
                            InfoFlags |= NDIS_MINIPORT_REQUIRES_MEDIA_POLLING;
                        if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_SUPPORTS_MEDIA_SENSE))
                            InfoFlags |= NDIS_MINIPORT_SUPPORTS_MEDIA_SENSE;
                        if (MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_PM_SUPPORTED))
                            InfoFlags |= NDIS_MINIPORT_PM_SUPPORTED;
                        if (MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_HIDDEN))
                            InfoFlags |= NDIS_MINIPORT_HIDDEN;
                        if (MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_SWENUM))
                            InfoFlags |= NDIS_MINIPORT_SWENUM;
                        if (MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_HARDWARE_DEVICE))
                            InfoFlags |= NDIS_MINIPORT_HARDWARE_DEVICE;
                        if (MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_NDIS_WDM_DRIVER))
                            InfoFlags |= NDIS_MINIPORT_WDM_DRIVER;

                        if (Miniport->DriverHandle->MiniportCharacteristics.CancelSendPacketsHandler)
                        {
                            InfoFlags |= NDIS_MINIPORT_SUPPORTS_CANCEL_SEND_PACKETS;
                        }

                        *(PULONG)(Buffer + NDIS_STATISTICS_HEADER_SIZE) = InfoFlags;
                        Request.DATA.QUERY_INFORMATION.BytesWritten = sizeof(ULONG);
                        break;
                        }
                      
                      default:
                        continue;
                    }
                }
                else continue;
            }
            else
            {
                //
                // Transform OID based on media-type
                //
                if (Oid == OID_802_3_CURRENT_ADDRESS)
                {
                  switch (Miniport->MediaType)
                  {
                    case NdisMedium802_5:
                      Oid = OID_802_5_CURRENT_ADDRESS;
                      break;
                    case NdisMediumFddi:
                      Oid = OID_FDDI_LONG_CURRENT_ADDR;
                      break;
                    case NdisMediumAtm:
                      Oid = OID_ATM_HW_CURRENT_ADDRESS;
                      break;
                    case NdisMediumWan:
                      Oid = OID_WAN_CURRENT_ADDRESS;
                      break;
#if ARCNET
                    case NdisMediumArcnetRaw:
                      Oid = OID_ARCNET_CURRENT_ADDRESS;
                      break;
#endif
                  }
                }
                else if (Oid == OID_802_3_PERMANENT_ADDRESS)
                {
                  switch (Miniport->MediaType)
                  {
                    case NdisMedium802_5:
                      Oid = OID_802_5_PERMANENT_ADDRESS;
                      break;
                    case NdisMediumFddi:
                      Oid = OID_FDDI_LONG_PERMANENT_ADDR;
                      break;
                    case NdisMediumAtm:
                      Oid = OID_ATM_HW_CURRENT_ADDRESS;
                      break;
                    case NdisMediumWan:
                      Oid = OID_WAN_PERMANENT_ADDRESS;
                      break;
                    case NdisMediumArcnetRaw:
                      Oid = OID_ARCNET_PERMANENT_ADDRESS;
                      break;
                  }
                }

                if (!MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_SYSTEM_SLEEPING))
                {
                    NdisStatus = ndisQueryDeviceOid(OpenContext,
                                                    &Request,
                                                    Oid,
                                                    Buffer + NDIS_STATISTICS_HEADER_SIZE,
                                                    BufferLength - NDIS_STATISTICS_HEADER_SIZE);
                }
                else
                {
                    NdisStatus = NDIS_STATUS_ADAPTER_NOT_FOUND;
                }
            }

            if (NdisStatus == NDIS_STATUS_SUCCESS)
            {
                PNDIS_STATISTICS_VALUE StatisticsValue = (PNDIS_STATISTICS_VALUE)Buffer;

                //
                // Create the equivalent of an NDIS_STATISTICS_VALUE element for this OID value
                // (the data itself was already written in the right place.
                //
                StatisticsValue->Oid = OidArray[CurrentOid];    // Not Oid since we map some
                StatisticsValue->DataLength = Request.DATA.QUERY_INFORMATION.BytesWritten;

                //
                // Advance our pointers.
                //

                BytesWrittenThisOid = Request.DATA.QUERY_INFORMATION.BytesWritten + NDIS_STATISTICS_HEADER_SIZE;
                Buffer += BytesWrittenThisOid;
                BufferLength -= BytesWrittenThisOid;
                BytesWritten += BytesWrittenThisOid;
            }
            else
            {
                break;
            }
        }

        Irp->IoStatus.Information = BytesWritten;
        fWaitComplete = TRUE;
        break;
        
      default:
        Status = STATUS_NOT_IMPLEMENTED;
        break;
    }

    if (fWaitComplete)
    {
        if (NdisStatus == NDIS_STATUS_INVALID_LENGTH)
        {
            Status = STATUS_BUFFER_OVERFLOW;
        }
        else if (NdisStatus != NDIS_STATUS_SUCCESS)
        {
            Status = STATUS_UNSUCCESSFUL;
        }
    }

    if (Status != STATUS_PENDING)
    {
        IrpSp->Control &= ~SL_PENDING_RETURNED;
        Irp->IoStatus.Status = Status;
        IoCompleteRequest (Irp, IO_NETWORK_INCREMENT);
    }

    DBGPRINT_RAW(DBG_COMP_ALL, DBG_LEVEL_INFO,
            ("<==ndisDeviceControlIrpHandler\n"));

    return Status;
}


NDIS_STATUS
FASTCALL
ndisQueryDeviceOid(
    IN  PNDIS_USER_OPEN_CONTEXT OpenContext,
    IN  PNDIS_REQUEST           Request,
    IN  NDIS_OID                Oid,
    IN  PVOID                   Buffer,
    IN  UINT                    BufferLength
    )
/*++

Routine Description:


Arguments:


Return Value:

    Status of operation

--*/
{
    NDIS_STATUS             NdisStatus;
    PNDIS_MINIPORT_BLOCK    Miniport;
    PNDIS_COREQ_RESERVED    CoReqRsvd;

    do
    {
        Miniport = OpenContext->Miniport;
    
        Request->RequestType = NdisRequestQueryStatistics;
        Request->DATA.QUERY_INFORMATION.Oid = Oid;
        Request->DATA.QUERY_INFORMATION.InformationBufferLength = BufferLength;
        Request->DATA.QUERY_INFORMATION.InformationBuffer = Buffer;
        Request->DATA.QUERY_INFORMATION.BytesWritten = 0;
        Request->DATA.QUERY_INFORMATION.BytesNeeded = 0;
    
        NdisStatus = ndisQuerySetMiniport(Miniport,
                                          NULL,
                                          FALSE,
                                          Request,
                                          NULL);
    
    } while (FALSE);

    return NdisStatus;
}


BOOLEAN
FASTCALL
ndisValidOid(
    IN  PNDIS_USER_OPEN_CONTEXT OpenContext,
    IN  NDIS_OID                Oid
    )
/*++

Routine Description:


Arguments:


Return Value:

    TRUE if OID is valid, FALSE otherwise

--*/
{
    UINT    i;

    //
    // Always allow this range since it is vendor specific
    //
    if ((Oid & 0xFF000000) != 0)
        return(TRUE);

    for (i = 0; i < OpenContext->OidList->FullOidCount; i++)
    {
        if (OpenContext->OidList->FullOidArray[i] == Oid)
        {
            break;
        }
    }

    return (i < OpenContext->OidList->FullOidCount);
}


NTSTATUS
ndisCloseIrpHandler(
    IN  PDEVICE_OBJECT          DeviceObject,
    IN  PIRP                    Irp
    )

/*++

Routine Description:

    The handle for IRP_MJ_CLOSE IRPs.

Arguments:

    DeviceObject - The adapter's device object.
    Irp - The IRP.

Return Value:

    STATUS_SUCCESS if it should be.

--*/

{
    PNDIS_MINIPORT_BLOCK    Miniport;
    PIO_STACK_LOCATION      IrpSp;
    PNDIS_USER_OPEN_CONTEXT OpenContext;
    KIRQL                   OldIrql;

    DBGPRINT_RAW(DBG_COMP_ALL, DBG_LEVEL_INFO,
            ("==>ndisCloseIrpHandler\n"));
    IF_DBG(DBG_COMP_PROTOCOL, DBG_LEVEL_ERR)
    {
        if (DbgIsNull(Irp))
        {
            DBGPRINT(DBG_COMP_ALL, DBG_LEVEL_ERR,
                    (": Null Irp\n"));
            DBGBREAK(DBG_COMP_ALL, DBG_LEVEL_ERR);
        }
        if (!DbgIsNonPaged(Irp))
        {
            DBGPRINT(DBG_COMP_ALL, DBG_LEVEL_ERR,
                    (": Irp not in NonPaged Memory\n"));
            DBGBREAK(DBG_COMP_ALL, DBG_LEVEL_ERR);
        }
    }

    Miniport = (PNDIS_MINIPORT_BLOCK)((PNDIS_WRAPPER_CONTEXT)DeviceObject->DeviceExtension + 1);

    if (Miniport->Signature != (PVOID)MINIPORT_DEVICE_MAGIC_VALUE)
    {
        return (ndisDummyIrpHandler(DeviceObject, Irp));
    }

    IrpSp = IoGetCurrentIrpStackLocation (Irp);

    OpenContext = IrpSp->FileObject->FsContext;
    IrpSp->FileObject->FsContext = NULL;

    ACQUIRE_SPIN_LOCK(&Miniport->Ref.SpinLock, &OldIrql);
    if (OpenContext->AdminAccessAllowed)
    {
        Miniport->NumAdminOpens--;            
    }
    else
    {
        Miniport->NumUserOpens--;
    }
    RELEASE_SPIN_LOCK(&Miniport->Ref.SpinLock, OldIrql);

    FREE_POOL(OpenContext);

    PnPReferencePackage();

    NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Miniport, &OldIrql);
    Miniport->UserModeOpenReferences--;
    NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);

    PnPDereferencePackage();

    MINIPORT_DECREMENT_REF_CLOSE(Miniport, Irp);

    if (MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_SWENUM))
    {
        PBUS_INTERFACE_REFERENCE    BusInterface;

        BusInterface = (PBUS_INTERFACE_REFERENCE)(Miniport->BusInterface);

        ASSERT(BusInterface != NULL);

        if (BusInterface)
        {
            BusInterface->DereferenceDeviceObject(BusInterface->Interface.Context);
        }
    }

    Irp->IoStatus.Status = STATUS_SUCCESS;
    IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);
    
    DBGPRINT_RAW(DBG_COMP_ALL, DBG_LEVEL_INFO,
            ("<==NdisCloseIrpHandler\n"));

    return STATUS_SUCCESS;
}


NTSTATUS
ndisDummyIrpHandler(
    IN  PDEVICE_OBJECT          DeviceObject,
    IN  PIRP                    Irp
    )

/*++

Routine Description:

    Default handler. If this is a NDIS device, then we simply succeed. If not and we have a
    custom handler, we pass it on. Else we succeed.

Arguments:

    DeviceObject - The adapter's device object.
    Irp - The IRP.

Return Value:

    Always STATUS_SUCCESS.

--*/

{
    PNDIS_DEVICE_LIST       DeviceList;
    PNDIS_MINIPORT_BLOCK    Miniport;
    PIO_STACK_LOCATION      IrpSp;
    NTSTATUS                Status;

    DBGPRINT_RAW(DBG_COMP_ALL, DBG_LEVEL_INFO,
            ("==>ndisDummyIrpHandler\n"));

    IF_DBG(DBG_COMP_PROTOCOL, DBG_LEVEL_ERR)
    {
        if (DbgIsNull(Irp))
        {
            DBGPRINT(DBG_COMP_ALL, DBG_LEVEL_ERR,
                    (": Null Irp\n"));
            DBGBREAK(DBG_COMP_ALL, DBG_LEVEL_ERR);
        }
        if (!DbgIsNonPaged(Irp))
        {
            DBGPRINT(DBG_COMP_ALL, DBG_LEVEL_ERR,
                    (": Irp not in NonPaged Memory\n"));
            DBGBREAK(DBG_COMP_ALL, DBG_LEVEL_ERR);
        }
    }

    IrpSp = IoGetCurrentIrpStackLocation (Irp);
    DeviceList = (PNDIS_DEVICE_LIST)((PNDIS_WRAPPER_CONTEXT)DeviceObject->DeviceExtension + 1);
    Miniport = (PNDIS_MINIPORT_BLOCK)DeviceList;

    do
    {
        //
        // This is a miniport
        //
        if (Miniport->Signature == (PVOID)MINIPORT_DEVICE_MAGIC_VALUE)
        {
            if (IrpSp->MajorFunction == IRP_MJ_CLEANUP)
            {
                Status = STATUS_SUCCESS;
            }
            else
            {
                Status = STATUS_NOT_SUPPORTED;
            }
            break;
        }
        else if (DeviceList->Signature == (PVOID)CUSTOM_DEVICE_MAGIC_VALUE)
        {
            if (DeviceList->MajorFunctions[IrpSp->MajorFunction] == NULL)
            {
                Status = STATUS_NOT_SUPPORTED;
                break;
            }
            else
            {
                return((*DeviceList->MajorFunctions[IrpSp->MajorFunction])(DeviceObject, Irp));
            }
        }
        else
        {
            Status = STATUS_NOT_SUPPORTED;
            break;
        }
    } while (FALSE);

    Irp->IoStatus.Status = Status;
    IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);
    DBGPRINT_RAW(DBG_COMP_ALL, DBG_LEVEL_INFO,
            ("<==ndisDummyIrpHandler\n"));

    return Status;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ndis\sys\miniport.c ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation

Module Name:

    miniport.c

Abstract:

    NDIS miniport wrapper functions

Author:

    Jameel Hyder (JameelH) Re-organization 01-Jun-95

Environment:

    Kernel mode, FSD

Revision History:

--*/

#include <precomp.h>
#pragma hdrstop


//
//  Define the module number for debug code.
//
#define MODULE_NUMBER   MODULE_MINIPORT

NTSTATUS
ndisCompletionRoutine(
    IN  PDEVICE_OBJECT  pdo,
    IN  PIRP            pirp,
    IN  PVOID           Context
    )
/*++

Routine Description:


Arguments:

    pdo     -   Pointer to the device object for the miniport.
    pirp    -   Pointer to the device set power state IRP that was completed.
    Context -   Pointer to an EVENT.

Return Value:

--*/
{
    PPOWER_QUERY    pQuery = Context;

    pQuery->Status = pirp->IoStatus.Status;

    SET_EVENT(&pQuery->Event);

    return(STATUS_MORE_PROCESSING_REQUIRED);
}

NDIS_STATUS
ndisMInitializeAdapter(
    IN  PNDIS_M_DRIVER_BLOCK                pMiniBlock,
    IN  PNDIS_WRAPPER_CONFIGURATION_HANDLE  pConfigurationHandle,
    IN  PUNICODE_STRING                     pExportName,
    IN  NDIS_HANDLE                         DeviceContext   OPTIONAL
    )
{
    FILTERDBS                   FilterDB = {0};
    PDEVICE_OBJECT              pTmpDevice = NULL;
    NTSTATUS                    NtStatus;
    LONG                        ErrorCode = 1;
    PNDIS_MINIPORT_BLOCK        Miniport = NULL;
    UNICODE_STRING              SymbolicLink;
    NDIS_STATUS                 MiniportInitializeStatus = NDIS_STATUS_SUCCESS;
    NDIS_STATUS                 OpenErrorStatus;
    NDIS_STATUS                 NdisStatus;
    NDIS_POWER_PROFILE          PowerProfile;
    ULONG                       GenericUlong = 0;
    PVOID                       DataBuffer;
    PNDIS_MINIPORT_WORK_ITEM    WorkItem;
    GUID                        guidLanClass = GUID_NDIS_LAN_CLASS;
    UINT                        SelectedMediumIndex;
    UINT                        PacketFilter = 0x01;
    WCHAR                       SymLnkBuf[128];
    ULONG                       MaximumShortAddresses;
    ULONG                       MaximumLongAddresses;
    KIRQL                       OldIrql;
    BOOLEAN                     DerefDriver = FALSE, FreeBuffer = FALSE;
    BOOLEAN                     Dequeue = FALSE, ExtendedError = FALSE, HaltMiniport = FALSE;
    BOOLEAN                     ClearDeviceClassAssociation = FALSE, WmiDeregister = FALSE;
    UCHAR                       CurrentLongAddress[6];
    UCHAR                       CurrentShortAddress[2];
    UCHAR                       i;
    BOOLEAN                     fRc;
#if ARCNET
    BOOLEAN                     FreeArcnetLookaheadBuffer = FALSE;
#endif
    BOOLEAN                     DeleteSymbolicLink = FALSE;

    DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
            ("==>ndisMInitializeAdapter\n"));


    do
    {
        ASSERT (CURRENT_IRQL < DISPATCH_LEVEL);

        MiniportReferencePackage();

        //
        // Initialize device.
        //
        if (!ndisReferenceDriver((PNDIS_M_DRIVER_BLOCK)pMiniBlock))
        {
            //
            // The driver is closing.
            //
            break;
        }

        DerefDriver = TRUE;

        pTmpDevice = pConfigurationHandle->DeviceObject;

        //
        // Initialize the Miniport adapter block in the device object extension
        //
        // *** NDIS_WRAPPER_CONTEXT has a higher alignment requirement than
        //   NDIS_MINIPORT_BLOCK, so we put it first in the extension.
        //

        Miniport = (PNDIS_MINIPORT_BLOCK)((PNDIS_WRAPPER_CONTEXT)pTmpDevice->DeviceExtension + 1);

        DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
                ("ndisMInitializeAdapter: Miniport %p, ", Miniport));
        DBGPRINT_UNICODE(DBG_COMP_PNP, DBG_LEVEL_INFO,  Miniport->pAdapterInstanceName);
        DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO, ("\n"));


        //
        // Create symbolic link for the device
        //
        SymbolicLink.Buffer = SymLnkBuf;
        SymbolicLink.Length = 0;
        SymbolicLink.MaximumLength = sizeof(SymLnkBuf);
        RtlCopyUnicodeString(&SymbolicLink, &ndisDosDevicesStr);
        RtlAppendUnicodeStringToString(&SymbolicLink, &Miniport->BaseName);

        NtStatus = IoCreateSymbolicLink(&SymbolicLink, pExportName);

        if (!NT_SUCCESS(NtStatus))
        {
#if DBG
            DbgPrint("ndisMInitializeAdapter: IoCreateSymbolicLink failed for Miniport %p, SymbolicLinkName %p, DeviceName %p, Status %lx\n",
                     Miniport, &SymbolicLink, pExportName, NtStatus);
#endif            
            if (NtStatus == STATUS_OBJECT_NAME_COLLISION)
            {
                DeleteSymbolicLink = TRUE;
            }
            else
            {
                DeleteSymbolicLink = FALSE;
            }
        }
        else
        {
            DeleteSymbolicLink = TRUE;
        }

        Miniport->DeviceContext = DeviceContext;

        Miniport->AssignedProcessor = ndisValidProcessors[ndisCurrentProcessor];
        
        ndisCurrentProcessor --;
        if (ndisCurrentProcessor > ndisMaximumProcessor)
        {
            ndisCurrentProcessor = ndisMaximumProcessor;
        }
        
        MINIPORT_SET_FLAG(Miniport, fMINIPORT_RESOURCES_AVAILABLE);

        //
        //  Initialize the handlers for the simplex case with the RcvPkt handler set to null-filter case
        //
        Miniport->PacketIndicateHandler = ndisMDummyIndicatePacket;
        Miniport->SavedPacketIndicateHandler = ndisMDummyIndicatePacket;

        Miniport->EthRxIndicateHandler = EthFilterDprIndicateReceive;
        Miniport->FddiRxIndicateHandler = FddiFilterDprIndicateReceive;
        Miniport->TrRxIndicateHandler = TrFilterDprIndicateReceive;

        Miniport->EthRxCompleteHandler = EthFilterDprIndicateReceiveComplete;
        Miniport->FddiRxCompleteHandler = FddiFilterDprIndicateReceiveComplete;
        Miniport->TrRxCompleteHandler = TrFilterDprIndicateReceiveComplete;
        Miniport->SendCompleteHandler =  NdisMSendComplete;
        Miniport->TDCompleteHandler = NdisMTransferDataComplete;
        Miniport->ResetCompleteHandler = NdisMResetComplete;
        Miniport->StatusHandler = NdisMIndicateStatus;
        Miniport->StatusCompleteHandler = NdisMIndicateStatusComplete;
        Miniport->SendResourcesHandler = NdisMSendResourcesAvailable;
        Miniport->QueryCompleteHandler = NdisMQueryInformationComplete;
        Miniport->SetCompleteHandler = NdisMSetInformationComplete;

        Miniport->WanSendCompleteHandler = NdisMWanSendComplete;
        Miniport->WanRcvHandler = NdisMWanIndicateReceive;
        Miniport->WanRcvCompleteHandler = NdisMWanIndicateReceiveComplete;

        //
        // And optimize Dpc/Isr stuff
        //
        Miniport->HandleInterruptHandler = Miniport->DriverHandle->MiniportCharacteristics.HandleInterruptHandler;
        Miniport->DisableInterruptHandler = Miniport->DriverHandle->MiniportCharacteristics.DisableInterruptHandler;
        Miniport->EnableInterruptHandler = Miniport->DriverHandle->MiniportCharacteristics.EnableInterruptHandler;
        Miniport->DeferredSendHandler = ndisMStartSends;

        //
        //  Initialize the list for VC instance names
        //
        InitializeListHead(&Miniport->WmiEnabledVcs);

        //
        //  Set some flags describing the miniport.
        //
        if (pMiniBlock->MiniportCharacteristics.MajorNdisVersion >= 4)
        {
            //
            //  Does this miniport indicate packets?
            //
            if (pMiniBlock->MiniportCharacteristics.ReturnPacketHandler)
            {
                Miniport->InfoFlags |= NDIS_MINIPORT_INDICATES_PACKETS;
            }

            //
            //  Can this miniport handle multiple sends?
            //
            if (pMiniBlock->MiniportCharacteristics.SendPacketsHandler)
            {
                MINIPORT_SET_SEND_FLAG(Miniport, fMINIPORT_SEND_PACKET_ARRAY);
                Miniport->DeferredSendHandler = ndisMStartSendPackets;
                Miniport->WSendPacketsHandler = pMiniBlock->MiniportCharacteristics.SendPacketsHandler;
            }

            if (pMiniBlock->MiniportCharacteristics.MajorNdisVersion == 5)
            {
                //
                //  This is an NDIS 5.0 miniport.
                //
                MINIPORT_SET_FLAG(Miniport, fMINIPORT_IS_NDIS_5);
                Miniport->InfoFlags |= NDIS_MINIPORT_IS_NDIS_5;
                
                if (pMiniBlock->MiniportCharacteristics.CoSendPacketsHandler != NULL)
                {
                    //
                    //  This is a connection-oriented miniport.
                    //
                    MINIPORT_SET_FLAG(Miniport, fMINIPORT_IS_CO);
                }
            }
        }

        //
        // the refernce is already initalized, so just increment it here
        // we do reference the miniport instead of intializing it
        // to avoid setting the reference count to 1 if miniport has already
        // been refrenced by receiving some power IRPs
        //
        MINIPORT_INCREMENT_REF(Miniport);

        Miniport->CFHangTicks = 1;  // Default

        //
        //  Allocate a pool of work items to start with.
        //
        for (i = 0; i < NUMBER_OF_SINGLE_WORK_ITEMS; i++)
        {
            WorkItem = &Miniport->WorkItemBuffer[i];
            NdisZeroMemory(WorkItem, sizeof(NDIS_MINIPORT_WORK_ITEM));

            //
            //  Place the work item on the free queue.
            //
            PushEntryList(&Miniport->SingleWorkItems[i], &WorkItem->Link);
        }
 
        //
        //  Enqueue the miniport on the driver block.
        //
        if (!ndisQueueMiniportOnDriver(Miniport, pMiniBlock))
        {
            //
            // The Driver is closing, undo what we have done.
            //
            break;
        }
        Dequeue = TRUE;

        //
        //  Initialize the deferred dpc
        //
        INITIALIZE_DPC(&Miniport->DeferredDpc, ndisMDeferredDpc, Miniport);

        Miniport->LockHandler = XFilterLockHandler;

        //
        //  the miniport's current device state is unspecified.
        //

        if (Miniport->CurrentDevicePowerState == PowerDeviceUnspecified)
        {
            Miniport->CurrentDevicePowerState = PowerDeviceD0;
        }
        ndisQueryPowerCapabilities(Miniport);

        //
        // Call adapter callback. The current value for "Export"
        // is what we tell him to name this device.
        //
        MINIPORT_SET_FLAG(Miniport, fMINIPORT_IN_INITIALIZE);
        MINIPORT_CLEAR_FLAG(Miniport, fMINIPORT_NORMAL_INTERRUPTS);
        if (pMiniBlock->Flags & fMINIBLOCK_VERIFYING)
        {
            MINIPORT_PNP_SET_FLAG(Miniport, fMINIPORT_VERIFYING);
            if ((ndisDriverTrackAlloc != NULL) &&
                (ndisMiniportTrackAlloc == NULL))
            {
                ndisMiniportTrackAlloc = Miniport;
            }
            else
            {
                //
                // tracking memory alocation is allowed
                // for one miniport only. otherwise null out the
                // global ndisDriverTrackAlloc to avoid confusion
                // memory allocations will continue to get tracked
                // but the result will not be as useful
                //
                ndisMiniportTrackAlloc = NULL;
            }
        }

        Miniport->MacOptions = 0;
        MiniportInitializeStatus = (pMiniBlock->MiniportCharacteristics.InitializeHandler)(
                                    &OpenErrorStatus,
                                    &SelectedMediumIndex,
                                    ndisMediumArray,
                                    ndisMediumArraySize/sizeof(NDIS_MEDIUM),
                                    (NDIS_HANDLE)(Miniport),
                                    (NDIS_HANDLE)pConfigurationHandle);

        DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
                ("ndisMInitializeAdapter: Miniport %p, InitializeHandler returned %lx\n", Miniport,
                            MiniportInitializeStatus));

        MINIPORT_CLEAR_FLAG(Miniport, fMINIPORT_IN_INITIALIZE);

        //
        // Free the slot information buffer
        //
        if (pConfigurationHandle->ParametersQueryTable[3].DefaultData != NULL)
        {
            FREE_POOL(pConfigurationHandle->ParametersQueryTable[3].DefaultData);
        }
        
        if (MiniportInitializeStatus == NDIS_STATUS_SUCCESS)
        {
            HaltMiniport = TRUE;

            CHECK_FOR_NORMAL_INTERRUPTS(Miniport);

            //
            // set up the shutdown handlers for 5.1 miniports
            //
            if (pMiniBlock->MiniportCharacteristics.AdapterShutdownHandler != NULL)
            {
                NdisMRegisterAdapterShutdownHandler(
                                        (NDIS_HANDLE)Miniport,
                                        (PVOID)(Miniport->MiniportAdapterContext),
                                        (ADAPTER_SHUTDOWN_HANDLER)(pMiniBlock->MiniportCharacteristics.AdapterShutdownHandler));
            }

#if DBG
            //
            // if the driver verifier is on for the miniport, check to see if it registered an
            // AdapterShutdownHandler and complain if it did not
            //

            NDIS_WARN((((PNDIS_WRAPPER_CONTEXT)Miniport->WrapperContext)->ShutdownHandler == NULL) &&
                      (Miniport->Interrupt != NULL) && 
                      (Miniport->BusType != PNPISABus), 
                      Miniport, NDIS_GFLAG_WARN_LEVEL_0,
                      ("ndisMInitializeAdapter: Miniport %p did not register a Shutdown handler.\n", Miniport));


            //
            // complain if this is a hardware based device and the driver is asking Ndis to ignore
            // stuck send packets or requests
            //
            NDIS_WARN(MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_HARDWARE_DEVICE) &&
                MINIPORT_TEST_FLAG(Miniport, fMINIPORT_IGNORE_REQUEST_QUEUE | fMINIPORT_IGNORE_PACKET_QUEUE),
                Miniport, NDIS_GFLAG_WARN_LEVEL_1,
                ("ndisMInitializeAdapter: -Hardware Based- Miniport %p improperly sets NDIS_ATTRIBUTE_IGNORE_REQUEST_TIMEOUT or NDIS_ATTRIBUTE_IGNORE_PACKET_TIMEOUT attributes.\n", Miniport));

#endif  


            ASSERT(SelectedMediumIndex < (ndisMediumArraySize/sizeof(NDIS_MEDIUM)));

            Miniport->MediaType = ndisMediumArray[SelectedMediumIndex];

            if (Miniport->MediaType != NdisMedium802_5)
            {
                MINIPORT_SET_FLAG(Miniport, fMINIPORT_IGNORE_TOKEN_RING_ERRORS);
            }

            if (NdisMediumWan == Miniport->MediaType)
            {
                if (!MINIPORT_TEST_FLAG(Miniport, (fMINIPORT_IS_CO | fMINIPORT_IS_NDIS_5)))
                {
                    Miniport->DeferredSendHandler = ndisMStartWanSends;
                }
            }

            //
            // get and save the vendor driver version if we don't have t already
            //
            if (pMiniBlock->DriverVersion == 0)
            {
                ndisMDoMiniportOp(Miniport,
                                  TRUE,
                                  OID_GEN_VENDOR_DRIVER_VERSION,
                                  &pMiniBlock->DriverVersion,
                                  sizeof(ULONG),
                                  0x0,
                                  TRUE);
            }

            //
            // Set Maximumlookahead to 0 as default. For lan media query the real
            // stuff.
            //
            if ((Miniport->MediaType >= 0) &&
                (Miniport->MediaType < NdisMediumMax))
            {
                if ((NdisMediumWan != Miniport->MediaType) &&
                    ndisMediaTypeCl[Miniport->MediaType])
                {
                    //
                    // Query maximum lookahead
                    //
                    ErrorCode = ndisMDoMiniportOp(Miniport,
                                                 TRUE,
                                                 OID_GEN_MAXIMUM_LOOKAHEAD,
                                                 &GenericUlong,
                                                 sizeof(GenericUlong),
                                                 0x1,
                                                 TRUE);
                    if (ErrorCode != 0)
                    {
                        DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_WARN,
                                ("ndisMInitializeAdapter: Error querying the OID_GEN_MAXIMUM_LOOKAHEAD\n"));
                        break;
                    }
                }
            }

            //
            // Now adjust based on media type
            //
            switch(Miniport->MediaType)
            {
              case NdisMedium802_3:
                Miniport->MaximumLookahead = ((NDIS_M_MAX_LOOKAHEAD - 14) < GenericUlong) ?
                                              NDIS_M_MAX_LOOKAHEAD - 14 : GenericUlong;
                break;

              case NdisMedium802_5:

                Miniport->MaximumLookahead = ((NDIS_M_MAX_LOOKAHEAD - 32) < GenericUlong) ?
                                              (NDIS_M_MAX_LOOKAHEAD - 32) : GenericUlong;
                break;

              case NdisMediumFddi:
                Miniport->MaximumLookahead = ((NDIS_M_MAX_LOOKAHEAD - 16) < GenericUlong) ?
                                              (NDIS_M_MAX_LOOKAHEAD - 16) : GenericUlong;
                break;

#if ARCNET
              case NdisMediumArcnet878_2:
                Miniport->MaximumLookahead = ((NDIS_M_MAX_LOOKAHEAD - 50) < GenericUlong) ?
                                              NDIS_M_MAX_LOOKAHEAD - 50 : GenericUlong;

                //
                //  Assume we will succeed with the lookahead allocation.
                //
                ExtendedError = FALSE;

                //
                //  allocate a lookahead buffer for arcnet.
                //
                Miniport->ArcBuf = ALLOC_FROM_POOL(sizeof(NDIS_ARC_BUF), NDIS_TAG_LA_BUF);
                if (Miniport->ArcBuf == NULL)
                {
                    DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_WARN,
                            ("    Could not allocate arcnet lookahead buffer\n"));

                    ExtendedError = TRUE;
                }
                NdisZeroMemory(Miniport->ArcBuf, sizeof(NDIS_ARC_BUF));

                Miniport->ArcBuf->ArcnetLookaheadBuffer = ALLOC_FROM_POOL(NDIS_M_MAX_LOOKAHEAD, NDIS_TAG_LA_BUF);

                if (Miniport->ArcBuf->ArcnetLookaheadBuffer == NULL)
                {
                    DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_WARN,
                            ("    Could not allocate arcnet lookahead buffer\n"));

                    ExtendedError = TRUE;
                }
                else
                {
                    FreeArcnetLookaheadBuffer = TRUE;
                    NdisZeroMemory(Miniport->ArcBuf->ArcnetLookaheadBuffer,
                                   Miniport->MaximumLookahead);
                }

                break;
#endif

              case NdisMediumWan:
                Miniport->MaximumLookahead = NDIS_M_MAX_LOOKAHEAD - 14;
                break;

              case NdisMediumIrda:
              case NdisMediumWirelessWan:
              case NdisMediumLocalTalk:
                Miniport->MaximumLookahead = GenericUlong;
                //
                // fall through
                //
              default:
                break;
            }

            //
            //  Was there an error?
            //
            if (ExtendedError)
            {
                DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_WARN,
                        ("    Extended error when processing OID_GEN_MAXIMUM_LOOOKAHEAD\n"));

                ErrorCode = 1;
                break;
            }

            //
            // For lan media query the real
            // stuff.  We also need to call this for wan drivers.
            //
            if (((Miniport->MediaType >= 0) &&
                 (Miniport->MediaType < NdisMediumMax) &&
                 ndisMediaTypeCl[Miniport->MediaType]) ||
                (NdisMediumWan == Miniport->MediaType))
            {
                //
                // Query mac options
                //
                ErrorCode = ndisMDoMiniportOp(Miniport,
                                             TRUE,
                                             OID_GEN_MAC_OPTIONS,
                                             &GenericUlong,
                                             sizeof(GenericUlong),
                                             0x3,
                                             TRUE);

                if (ErrorCode != 0)
                {
                    DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_WARN,
                            ("    Error querying OID_GEN_MAC_OPTIONS\n"));

                    break;
                }

                //
                // NDIS_MAC_OPTION_SUPPORTS_MAC_ADDRESS_OVERWRITE bit in MacOption
                // is set by Ndis when/if the driver calls NdisReadNetworkAddress
                // so make sure we don't override this
                //
                Miniport->MacOptions |= (UINT)GenericUlong;

                if (Miniport->MacOptions & NDIS_MAC_OPTION_NO_LOOPBACK)
                {
                    MINIPORT_SET_FLAG(Miniport, fMINIPORT_DOES_NOT_DO_LOOPBACK);
                }

                //
                // complain if this is a hardware based device and wants to do loopback itself
                //
                NDIS_WARN(MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_HARDWARE_DEVICE) &&
                    !(Miniport->MacOptions & NDIS_MAC_OPTION_NO_LOOPBACK),
                    Miniport, NDIS_GFLAG_WARN_LEVEL_1,
                    ("ndisMInitializeAdapter: -Hardware Based- Miniport %p says it does loopback.\n", Miniport));

                
                if ((Miniport->MacOptions & NDISWAN_OPTIONS) == NDISWAN_OPTIONS)
                {
                    Miniport->MaximumLookahead = NDIS_M_MAX_LOOKAHEAD - 14;
                }
            }

            //
            // Query media-connect state. By default, it is connected. Avoid doing
            // this for NDISWAN miniports which are identified in the following
            // convoluted way
            // only do it for the media that needs to be polled to indicate the correct
            // status. for the rest assume it is connected and let the miniport to
            // indicate otherwise. this way miniports can pend this OID till they find
            // their media connect status (which can take up to a few seconds) without
            // affecting the initialization time
            //
            MINIPORT_SET_FLAG(Miniport, fMINIPORT_MEDIA_CONNECTED);
            
            if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_REQUIRES_MEDIA_POLLING) &&
                (NdisMediumWan != Miniport->MediaType) &&
                ndisMediaTypeCl[Miniport->MediaType] &&
                ((Miniport->MacOptions & NDISWAN_OPTIONS) != NDISWAN_OPTIONS) &&
                (pMiniBlock->AssociatedProtocol == NULL) &&
                ndisMDoMiniportOp(Miniport,
                                  TRUE,
                                  OID_GEN_MEDIA_CONNECT_STATUS,
                                  &GenericUlong,
                                  sizeof(GenericUlong),
                                  0,
                                  TRUE) == 0)
            {
                PNDIS_REQUEST       Request;

                if (GenericUlong == NdisMediaStateConnected)
                {
                    MINIPORT_SET_FLAG(Miniport, fMINIPORT_MEDIA_CONNECTED);
                }
                else
                {
                    MINIPORT_CLEAR_FLAG(Miniport, fMINIPORT_MEDIA_CONNECTED);
                }

                //
                // Allocate a request structure to do media queries
                //
                Request = (PNDIS_REQUEST)ALLOC_FROM_POOL(sizeof(NDIS_REQUEST) + sizeof(ULONG),
                                                                        NDIS_TAG_Q_REQ);

                if (Request == NULL)
                {
                    ErrorCode = 0x01;
                    DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_WARN,
                            ("ndisMInitializeAdapter: Error querying the OID_GEN_MAXIMUM_LOOKAHEAD\n"));
                    break;
                }

                Miniport->MediaRequest = Request;
                ZeroMemory(Request, sizeof(NDIS_REQUEST) + sizeof(ULONG));
                INITIALIZE_EVENT(&(PNDIS_COREQ_RESERVED_FROM_REQUEST(Request)->Event));

                Request->RequestType = NdisRequestQueryInformation;

                //
                //  Copy the buffer that was passed to us into the new buffer.
                //
                Request->DATA.QUERY_INFORMATION.Oid = OID_GEN_MEDIA_CONNECT_STATUS;
                Request->DATA.QUERY_INFORMATION.InformationBuffer = Request + 1;
                Request->DATA.QUERY_INFORMATION.InformationBufferLength = sizeof(ULONG);
                Miniport->InfoFlags |= NDIS_MINIPORT_SUPPORTS_MEDIA_QUERY;
                PNDIS_RESERVED_FROM_PNDIS_REQUEST(Request)->Flags = REQST_COMPLETED;
                Miniport->CheckForHangSeconds = NDIS_CFHANG_TIME_SECONDS;
            }
            else
            {
                //
                // Since we are not polling for media-state, set the tick to 1 and adjust
                // timer value back to what we need. 
                // Clear the Requires Media Polling flag as ndis cannot query the adapter for connectivity
                //
                Miniport->CheckForHangSeconds = Miniport->CFHangTicks*NDIS_CFHANG_TIME_SECONDS;
                Miniport->CFHangTicks = 1;
                MINIPORT_CLEAR_FLAG(Miniport, fMINIPORT_REQUIRES_MEDIA_POLLING);
            }

            Miniport->CFHangCurrentTick = Miniport->CFHangTicks;

            if (MINIPORT_TEST_SEND_FLAG(Miniport, fMINIPORT_SEND_PACKET_ARRAY))
            {
                //
                //  If this miniport supports SendPacketsHandler then we need to query
                //  the maximum number of packets that the miniport supports in a single
                //  call.
                //
                ErrorCode = ndisMDoMiniportOp(Miniport,
                                             TRUE,
                                             OID_GEN_MAXIMUM_SEND_PACKETS,
                                             &GenericUlong,
                                             sizeof(GenericUlong),
                                             0x2,
                                             TRUE);
                if (ErrorCode != 0)
                {
                    DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_WARN,
                            ("Error querying OID_GEN_MAXIMUM_SEND_PACKETS\n"));
                    //
                    // Don't error out. If the miniport did not respond to this, it does
                    // not limit it, so we use what makes sense to us which is SEND_PACKET_ARRAY
                    //
                }
    
                Miniport->MaxSendPackets = SEND_PACKET_ARRAY;
                if (GenericUlong < SEND_PACKET_ARRAY)
                {
                    Miniport->MaxSendPackets = (USHORT)GenericUlong;
                }
            }

            //
            // Query the miniport so we can create the right filter package as appropriate
            //
            switch(Miniport->MediaType)
            {
              case NdisMedium802_3:

                //
                // Query maximum MulticastAddress
                //
                ErrorCode = ndisMDoMiniportOp(Miniport,
                                              TRUE,
                                              OID_802_3_MAXIMUM_LIST_SIZE,
                                              &MaximumLongAddresses,
                                              sizeof(GenericUlong),
                                              0x7,
                                              TRUE);

                if (ErrorCode != 0)
                {
                    ExtendedError = TRUE;
                    DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_WARN,
                            ("    Error querying OID_802_3_MAXIMUM_LIST_SIZE\n"));

                    break;
                }

                Miniport->MaximumLongAddresses = MaximumLongAddresses;

                ErrorCode = ndisMDoMiniportOp(Miniport,
                                              TRUE,
                                              OID_802_3_CURRENT_ADDRESS,
                                              &CurrentLongAddress,
                                              sizeof(CurrentLongAddress),
                                              0x9,
                                              TRUE);

                if (ErrorCode != 0)
                {
                    DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_WARN,
                            ("    Error querying OID_802_3_CURRENT_ADDRESS\n"));

                    ExtendedError = TRUE;
                    break;
                }

                DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
                    ("ndisMInitializeAdapter: Miniport %p, Ethernet Address %02X %02X %02X %02X %02X %02X\n",
                    Miniport,
                    CurrentLongAddress[0],
                    CurrentLongAddress[1],
                    CurrentLongAddress[2],
                    CurrentLongAddress[3],
                    CurrentLongAddress[4],
                    CurrentLongAddress[5]));


                ErrorCode = ndisMDoMiniportOp(Miniport,
                                              TRUE,
                                              OID_GEN_PHYSICAL_MEDIUM,
                                              &GenericUlong,
                                              sizeof(GenericUlong),
                                              0xa,
                                              TRUE);

                if (ErrorCode != 0)
                {
                    //
                    // It is okay for a miniport to not support OID_GEN_PHYSICAL_MEDIUM,
                    // so we let this go.
                    //
                    ErrorCode = 0;
                    break;
                }

                Miniport->PhysicalMediumType = GenericUlong;

                ndisMNotifyMachineName(Miniport, NULL);

                break;

              case NdisMedium802_5:
                ErrorCode = ndisMDoMiniportOp(Miniport,
                                              TRUE,
                                              OID_802_5_CURRENT_ADDRESS,
                                              &CurrentLongAddress,
                                              sizeof(CurrentLongAddress),
                                              0xB,
                                              TRUE);

                if (ErrorCode != 0)
                {
                    DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_WARN,
                            ("    Error querying OID_802_5_CURRENT_ADDRESS\n"));

                    ExtendedError = TRUE;
                }

                break;

              case NdisMediumFddi:
                //
                // Query maximum MulticastAddress
                //
                ErrorCode = ndisMDoMiniportOp(Miniport,
                                              TRUE,
                                              OID_FDDI_LONG_MAX_LIST_SIZE,
                                              &MaximumLongAddresses,
                                              sizeof(GenericUlong),
                                              0xD,
                                              TRUE);
                if (ErrorCode != 0)
                {
                    DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_WARN,
                            ("    Error querying OID_FDDI_LONG_MAX_LIST_SIZE\n"));

                    ExtendedError = TRUE;
                    break;
                }

                Miniport->MaximumLongAddresses = MaximumLongAddresses;

                //
                // Query maximum MulticastAddress
                //
                ErrorCode = ndisMDoMiniportOp(Miniport,
                                              TRUE,
                                              OID_FDDI_SHORT_MAX_LIST_SIZE,
                                              &MaximumShortAddresses,
                                              sizeof(MaximumShortAddresses),
                                              0xF,
                                              TRUE);
                if (ErrorCode != 0)
                {
                    DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_WARN,
                            ("    Error querying OID_FDDI_SHORT_MAX_LIST_SIZE\n"));

                    ExtendedError = TRUE;
                    break;
                }

                Miniport->MaximumShortAddresses = MaximumShortAddresses;

                ErrorCode = ndisMDoMiniportOp(Miniport,
                                              TRUE,
                                              OID_FDDI_LONG_CURRENT_ADDR,
                                              &CurrentLongAddress,
                                              sizeof(CurrentLongAddress),
                                              0x11,
                                              TRUE);
                if (ErrorCode != 0)
                {
                    DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_WARN,
                            ("    Error querying OID_FDDI_LONG_CURRENT_ADDR\n"));

                    ExtendedError = TRUE;
                    break;
                }

                ErrorCode = ndisMDoMiniportOp(Miniport,
                                              TRUE,
                                              OID_FDDI_SHORT_CURRENT_ADDR,
                                              &CurrentShortAddress,
                                              sizeof(CurrentShortAddress),
                                              0x13,
                                              TRUE);
                if (ErrorCode != 0)
                {
                    DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_WARN,
                            ("    Error querying OID_FDDI_SHORT_CURRENT_ADDR\n"));

                    ExtendedError = TRUE;
                    break;
                }
                break;

#if ARCNET
              case NdisMediumArcnet878_2:

                //
                // In case of an encapsulated ethernet binding, we need
                // to return the maximum number of multicast addresses
                // possible.
                //

                Miniport->MaximumLongAddresses = NDIS_M_MAX_MULTI_LIST;

                //
                // Allocate Buffer pools
                //
                NdisAllocateBufferPool(&NdisStatus,
                                       &Miniport->ArcBuf->ArcnetBufferPool,
                                       ARC_SEND_BUFFERS);
                if (NdisStatus != NDIS_STATUS_SUCCESS)
                {
                    DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_WARN,
                            ("    Failed to allocate buffer pool for arcnet\n"));

                    ErrorCode = 0x16;
                    ExtendedError = TRUE;
                    break;
                }

                DataBuffer = ALLOC_FROM_POOL(ARC_HEADER_SIZE * ARC_SEND_BUFFERS, NDIS_TAG_ARC_SEND_BUFFERS);
                if (DataBuffer == NULL)
                {
                    DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_WARN,
                            ("    Failed to allocate memory for arcnet data buffers\n"));

                    NdisFreeBufferPool(Miniport->ArcBuf->ArcnetBufferPool);
                    ErrorCode = 0x18;
                    ExtendedError = TRUE;
                    break;
                }
                ZeroMemory(DataBuffer, ARC_HEADER_SIZE * ARC_SEND_BUFFERS);

                for (i = 0; i < ARC_SEND_BUFFERS; i++)
                {
                    PARC_BUFFER_LIST    Buffer = &Miniport->ArcBuf->ArcnetBuffers[i];

                    Buffer->BytesLeft = Buffer->Size = ARC_HEADER_SIZE;
                    Buffer->Buffer = DataBuffer;
                    Buffer->Next = NULL;    // This implies that it is free

                    DataBuffer = (((PUCHAR)DataBuffer) + ARC_HEADER_SIZE);
                }
                Miniport->ArcBuf->NumFree = ARC_SEND_BUFFERS;

                //
                // Get current address
                //
                ErrorCode = ndisMDoMiniportOp(Miniport,
                                              TRUE,
                                              OID_ARCNET_CURRENT_ADDRESS,
                                              &CurrentLongAddress[5],   // address = 00-00-00-00-00-XX
                                              1,
                                              0x15,
                                              TRUE);
                if (ErrorCode != 0)
                {
                    DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_WARN,
                            ("    Error querying OID_ARCNET_CURRENT_ADDRESS\n"));

                    FREE_POOL(DataBuffer);
                    NdisFreeBufferPool(Miniport->ArcBuf->ArcnetBufferPool);
                    ExtendedError = TRUE;
                    break;
                }

                Miniport->ArcnetAddress = CurrentLongAddress[5];

                break;
#endif

              case NdisMediumWan:
                ErrorCode = ndisMDoMiniportOp(Miniport,
                                              TRUE,
                                              OID_WAN_CURRENT_ADDRESS,
                                              &CurrentLongAddress,
                                              sizeof(CurrentLongAddress),
                                              0x17,
                                              TRUE);
                if (ErrorCode != 0)
                {
                    DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_WARN,
                            ("    Error querying OID_WAN_CURRENT_ADDRESS\n"));

                    ExtendedError = TRUE;
                    break;
                }

              default:
                ErrorCode = 0;
                break;
            }

            if (ErrorCode != 0)
            {
                break;
            }

            //
            // Now create the filter package, as appropriate. Note that CurrentLongAddress etc.
            // are still valid from the abover switch statement
            //
            switch(Miniport->MediaType)
            {
              case NdisMedium802_3:

                fRc = EthCreateFilter(MaximumLongAddresses,
                                      CurrentLongAddress,
                                      &FilterDB.EthDB);

                if (!fRc)
                {
                    DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_WARN,
                            ("    Error creating the Ethernet filter database\n"));

                    ErrorCode = 0x9;
                    ExtendedError = TRUE;
                    break;
                }
                FilterDB.EthDB->Miniport = Miniport;
                break;

              case NdisMedium802_5:
                fRc = TrCreateFilter(CurrentLongAddress,
                                     &FilterDB.TrDB);
                if (!fRc)
                {
                    DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_WARN,
                            ("    Error creating the Token Ring filter database\n"));

                    ErrorCode = 0xC;
                    ExtendedError = TRUE;
                    break;
                }
                FilterDB.TrDB->Miniport = Miniport;
                break;

              case NdisMediumFddi:
                fRc = FddiCreateFilter(MaximumLongAddresses,
                                       MaximumShortAddresses,
                                       CurrentLongAddress,
                                       CurrentShortAddress,
                                       &FilterDB.FddiDB);
                if (!fRc)
                {
                    DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_WARN,
                            ("    Error creating the FDDI filter database\n"));

                    ErrorCode = 0x15;
                    ExtendedError = TRUE;
                    break;
                }
                FilterDB.FddiDB->Miniport = Miniport;
                break;

#if ARCNET
              case NdisMediumArcnet878_2:
                if (!ArcCreateFilter(Miniport,
                                     CurrentLongAddress[5],
                                     &FilterDB.ArcDB))
                {
                    DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_WARN,
                            ("    Error creating the Arcnet filter database\n"));

                    FREE_POOL(DataBuffer);
                    NdisFreeBufferPool(Miniport->ArcBuf->ArcnetBufferPool);
                    ErrorCode = 0x1B;
                    ExtendedError = TRUE;
                    break;
                }
                FilterDB.ArcDB->Miniport = Miniport;

                //
                // Zero all but the last one.
                //
                CurrentLongAddress[0] = 0;
                CurrentLongAddress[1] = 0;
                CurrentLongAddress[2] = 0;
                CurrentLongAddress[3] = 0;
                CurrentLongAddress[4] = 0;

                if (!EthCreateFilter(32,
                                     CurrentLongAddress,
                                     &FilterDB.EthDB))
                {
                    DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_WARN,
                            ("    Error creating the Arcnet filter database for encapsulated ethernet\n"));

                    //
                    //  Delete the arcnet filter.
                    //
                    ArcDeleteFilter(FilterDB.ArcDB);

                    FREE_POOL(DataBuffer);
                    NdisFreeBufferPool(Miniport->ArcBuf->ArcnetBufferPool);
                    ErrorCode = 0x1C;
                    ExtendedError = TRUE;
                    break;
                }
                FilterDB.EthDB->Miniport = Miniport;
                break;
#endif
              default:
                fRc = nullCreateFilter(&FilterDB.NullDB);

                if (!fRc)
                {
                    DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_WARN,
                            ("    Error creating the NULL filter database\n"));

                    ErrorCode = 0x1E;
                    ExtendedError = TRUE;
                    break;
                }

                FilterDB.NullDB->Miniport = Miniport;
                break;
            }

            //
            //  If we successfully create the adapter instance name then we
            //  register with WMI.
            //
            //
            //  let 'em know we can handle WMI requests from IRP_MJ_SYSTEM_CONTROL.
            //
            NtStatus = IoWMIRegistrationControl(Miniport->DeviceObject, WMIREG_ACTION_REGISTER);
            if (!NT_SUCCESS(NtStatus))
            {
                DBGPRINT((DBG_COMP_INIT | DBG_COMP_WMI), DBG_LEVEL_WARN,
                    ("    ndisMInitializeAdapter: Failed to register for WMI support\n"));
                ErrorCode = 0x1F;
                ExtendedError = TRUE;
            }
            else
            {
                WmiDeregister = TRUE;
            }
            
            //
            //  Do we need to log an error?
            //
            if (ExtendedError)
            {
                DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_WARN,
                        ("    Extended error while initializing the miniport\n"));

                NdisWriteErrorLogEntry((NDIS_HANDLE)Miniport,
                                        NDIS_ERROR_CODE_DRIVER_FAILURE,
                                        2,
                                        0xFF00FF00,
                                        ErrorCode);
                break;
            }

            //
            // force a IRP_MN_QUERY_PNP_DEVICE_STATE PnP Irp so we can set the
            // PNP_DEVICE_DONT_DISPLAY_IN_UI bit
            //
            if (MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_HIDDEN))
            {
                IoInvalidateDeviceState(Miniport->PhysicalDeviceObject);
            }

            NtStatus = STATUS_SUCCESS;

            //
            //  Determine PnP/PM capabilities for this adapter.
            //  But only if the bus drive says it supports PM
            //  except when dealing with IM drivers!
            //
            if ((MINIPORT_PNP_TEST_FLAG(Miniport, (fMINIPORT_PM_SUPPORTED | fMINIPORT_NO_HALT_ON_SUSPEND)) ||
                (Miniport->DriverHandle->Flags & fMINIBLOCK_INTERMEDIATE_DRIVER)) &&
                (Miniport->MediaType >= 0)            &&
                (Miniport->MediaType < NdisMediumMax))
            {
                //
                //  Query the miniport for it's pnp capabilities.
                //  If it doesn't support any then it won't handle this
                //  OID.
                //
                ErrorCode = ndisMDoMiniportOp(Miniport,
                                              TRUE,
                                              OID_PNP_CAPABILITIES,
                                              &Miniport->PMCapabilities,
                                              sizeof(Miniport->PMCapabilities),
                                              0x19,
                                              FALSE);

                //
                // reserved flags that miniports are not suposed to write to
                // zero it out just in case they do
                //
                Miniport->PMCapabilities.Flags = 0;

                if (0 == ErrorCode)
                {
                    SYSTEM_POWER_STATE SystemState;
                    DEVICE_POWER_STATE DeviceState;
                    BOOLEAN WakeupCapable = TRUE;

                    MINIPORT_PNP_SET_FLAG(Miniport, fMINIPORT_PM_SUPPORTED);

                    if ((Miniport->PMCapabilities.WakeUpCapabilities.MinLinkChangeWakeUp == NdisDeviceStateUnspecified) &&
                        (Miniport->PMCapabilities.WakeUpCapabilities.MinMagicPacketWakeUp == NdisDeviceStateUnspecified) &&
                        (Miniport->PMCapabilities.WakeUpCapabilities.MinPatternWakeUp == NdisDeviceStateUnspecified))
                    {
                        WakeupCapable = FALSE;
                    }
                    else
                    {
                        if (Miniport->DeviceCaps.SystemWake <= PowerSystemWorking)
                        {
                            WakeupCapable = FALSE;
                        }
                        else
                        {
                            for (SystemState = PowerSystemSleeping1;
                                 SystemState <= Miniport->DeviceCaps.SystemWake;
                                 SystemState++)
                            {
                                DeviceState = Miniport->DeviceCaps.DeviceState[SystemState];

                                if ((DeviceState != PowerDeviceUnspecified) &&
                                    (DeviceState <= Miniport->PMCapabilities.WakeUpCapabilities.MinPatternWakeUp))
                                {
                                    //
                                    // check for device state to make sure the device can go to this state
                                    // any device should be able to go to D0 or D3, so only check for D1 and D2
                                    //

                                    if (((DeviceState == PowerDeviceD1) && !Miniport->DeviceCaps.DeviceD1) ||
                                        ((DeviceState == PowerDeviceD2) && !Miniport->DeviceCaps.DeviceD2))
                                    {
                                        //
                                        // we can't do WOL from this system state. check the next one
                                        //
                                        continue;
                                    }
                                    else
                                    {
                                    
                                        //
                                        // there is at least one system state from which the device can do
                                        // WOL.
                                        //
                                        break;
                                    }
                                }

                            }

                            if (SystemState > Miniport->DeviceCaps.SystemWake)
                            {
                                WakeupCapable = FALSE;
                                DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO, ("ndisMInitializeAdapter: WOL not possible on this miniport: %p \n", Miniport));
                            }
                        }
                    }

                    if (!WakeupCapable)
                    {
                        //
                        // set SystemWake to PowerSystemWorking so everybody knows we can not do 
                        // WOL on this machine but we may be able to put the device to sleep
                        // when it is disconnected for some time.
                        // note that at this point we already know the SystemWake is != PowerSystemUnspecified
                        //
                        Miniport->DeviceCaps.SystemWake = PowerSystemWorking;
                    }

                    if (!(Miniport->PnPCapabilities & NDIS_DEVICE_DISABLE_PM))
                    {
                        MINIPORT_PNP_SET_FLAG(Miniport, fMINIPORT_DEVICE_POWER_ENABLE);

                        if ((Miniport->PMCapabilities.WakeUpCapabilities.MinLinkChangeWakeUp != NdisDeviceStateUnspecified) &&
                            (Miniport->MediaDisconnectTimeOut != (USHORT)(-1)))
                        {

                            //
                            //  If the miniport is capable of wake-up for a link change
                            //  then we need to allocate a timer for timeout.
                            //
                            Miniport->WakeUpEnable |= NDIS_PNP_WAKE_UP_LINK_CHANGE;
                        }

                        if (!(Miniport->PnPCapabilities & NDIS_DEVICE_DISABLE_WAKE_UP) && 
                            WakeupCapable)
                        {
                            if ((Miniport->PMCapabilities.WakeUpCapabilities.MinPatternWakeUp != NdisDeviceStateUnspecified) &&
                                !(Miniport->PnPCapabilities & NDIS_DEVICE_DISABLE_WAKE_ON_PATTERN_MATCH))
                            {
                                MINIPORT_PNP_SET_FLAG(Miniport, fMINIPORT_DEVICE_POWER_WAKE_ENABLE);

                                //
                                // NDIS_DEVICE_WAKE_UP_ENABLE bit is used by tcp/ip to decide whether or not to set a timer
                                // to renew DHCP address. set this flag only if packet matching is enabled
                                //
                                Miniport->PMCapabilities.Flags |= (NDIS_DEVICE_WAKE_UP_ENABLE | NDIS_DEVICE_WAKE_ON_PATTERN_MATCH_ENABLE);
                            }
                            
                            //
                            // no protocol is going to set the magic packet wake up method. so ndis
                            // does it itself (unless specified otherwise in registry)
                            //
                            if ((Miniport->PMCapabilities.WakeUpCapabilities.MinMagicPacketWakeUp != NdisDeviceStateUnspecified) &&
                                !(Miniport->PnPCapabilities & NDIS_DEVICE_DISABLE_WAKE_ON_MAGIC_PACKET))
                            {
                                MINIPORT_PNP_SET_FLAG(Miniport, fMINIPORT_DEVICE_POWER_WAKE_ENABLE);
                                Miniport->PMCapabilities.Flags |= NDIS_DEVICE_WAKE_ON_MAGIC_PACKET_ENABLE;
                                Miniport->WakeUpEnable |= NDIS_PNP_WAKE_UP_MAGIC_PACKET;
                            }
                            
                        }
                    }


                    IF_DBG(DBG_COMP_PM, DBG_LEVEL_INFO)
                    {
                        DbgPrint("ndisMInitializeAdapter: Driver says Miniport %p supports PM\n", Miniport);
                        DbgPrint("\tMinMagicPacketWakeUp: %ld\n", Miniport->PMCapabilities.WakeUpCapabilities.MinMagicPacketWakeUp);
                        DbgPrint("\tMinPatternWakeUp: %ld\n", Miniport->PMCapabilities.WakeUpCapabilities.MinPatternWakeUp);
                        DbgPrint("\tMinLinkChangeWakeUp: %ld\n", Miniport->PMCapabilities.WakeUpCapabilities.MinLinkChangeWakeUp);
                    }
                }
                else
                {
                    MINIPORT_PNP_CLEAR_FLAG(Miniport, fMINIPORT_PM_SUPPORTED);
                }

                ErrorCode = 0;
            }

            //
            // we initialize this timer anyway, just in case user enables "media disconnect sleep" at run-time
            // when -setting- the timer however, we will check to make sure the media disconnect feature is enabled
            //
            NdisInitializeTimer(&Miniport->MediaDisconnectTimer, ndisMediaDisconnectTimeout, Miniport);

            ErrorCode = 1;

            //
            //  Register the device class.
            //
            NtStatus = IoRegisterDeviceInterface(Miniport->PhysicalDeviceObject,
                                                 &guidLanClass,
                                                 &Miniport->BaseName,
                                                 &Miniport->SymbolicLinkName);

            if (!NT_SUCCESS(NtStatus))
            {
                DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_ERR,
                    ("    ndisMInitializeAdapter: IoRegisterDeviceClassAssociation failed\n"));

                break;
            }

            //
            // setting this flag obviously is not necessary because we are going
            // to clear it right away. but leave it here just in case we end up
            // doing something that can fail the initialization -after- this.
            //
            ClearDeviceClassAssociation = TRUE;
            
            //
            // Set to not cleanup
            //

            ErrorCode = 0;
            HaltMiniport = FALSE;
            DerefDriver = FreeBuffer = Dequeue = FALSE;
#if ARCNET
            FreeArcnetLookaheadBuffer = FALSE;
#endif

            ClearDeviceClassAssociation = FALSE;
            DeleteSymbolicLink = FALSE;
            WmiDeregister = FALSE;

            //
            // Finally mark the device as *NOT* initializing. This is to let
            // layered miniports initialize their device instance *OUTSIDE*
            // of their driver entry. If this flag is on, then NdisOpenAdapter
            // to this device will not work. This is also true of subsequent
            // instances of a driver initializing outside of its DriverEntry
            // as a result of a PnP event.
            //
            Miniport->DeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

            //
            // Start wake up timer
            //
            NdisMSetPeriodicTimer((PNDIS_MINIPORT_TIMER)(&Miniport->WakeUpDpcTimer),
                                  Miniport->CheckForHangSeconds*1000);

            //
            //  Notify WMI of adapter arrival.
            //
            {

                PWNODE_SINGLE_INSTANCE  wnode;
                PUCHAR                  ptmp;
                NTSTATUS                NtStatus;
                
                ndisSetupWmiNode(Miniport,
                                 Miniport->pAdapterInstanceName,
                                 Miniport->MiniportName.Length + sizeof(USHORT),
                                 (PVOID)&GUID_NDIS_NOTIFY_ADAPTER_ARRIVAL,
                                 &wnode);

                if (wnode != NULL)
                {
                    //
                    //  Save the number of elements in the first ULONG.
                    //
                    ptmp = (PUCHAR)wnode + wnode->DataBlockOffset;
                    *((PUSHORT)ptmp) = Miniport->MiniportName.Length;

                    //
                    //  Copy the data after the number of elements.
                    //
                    RtlCopyMemory(ptmp + sizeof(USHORT),
                                  Miniport->MiniportName.Buffer,
                                  Miniport->MiniportName.Length);

                    //
                    //  Indicate the event to WMI. WMI will take care of freeing
                    //  the WMI struct back to pool.
                    //
                    NtStatus = IoWMIWriteEvent(wnode);
                    if (!NT_SUCCESS(NtStatus))
                    {
                        DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_ERR,
                            ("ndisMInitializeAdapter: Failed to indicate adapter arrival\n"));

                        FREE_POOL(wnode);
                    }
                }
            }

            //
            // let the adapter know about the current power source
            //
            PowerProfile = ((BOOLEAN)ndisAcOnLine == TRUE) ? 
                            NdisPowerProfileAcOnLine : 
                            NdisPowerProfileBattery;

            ndisNotifyMiniports(Miniport,
                                NdisDevicePnPEventPowerProfileChanged,
                                &PowerProfile,
                                sizeof(NDIS_POWER_PROFILE));

        }
        else
        {
            NdisMDeregisterAdapterShutdownHandler(Miniport);
            
            ndisLastFailedInitErrorCode = ErrorCode = MiniportInitializeStatus;
            ASSERT(Miniport->Interrupt == NULL);
            ASSERT(Miniport->TimerQueue == NULL);
            ASSERT(Miniport->MapRegisters == NULL);

            if ((Miniport->TimerQueue != NULL) || (Miniport->Interrupt != NULL))
            {
                if (Miniport->Interrupt != NULL)
                {
                    BAD_MINIPORT(Miniport, "Unloading without deregistering interrupt");
                }
                else
                {
                    BAD_MINIPORT(Miniport, "Unloading without deregistering timer");
                }
                KeBugCheckEx(BUGCODE_ID_DRIVER,
                            (ULONG_PTR)Miniport,
                            (ULONG_PTR)Miniport->Interrupt,
                            (ULONG_PTR)Miniport->TimerQueue,
                            1);
            }
        }
    } while (FALSE);

    ndisMAdjustFilters(Miniport, &FilterDB);

    if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_DESERIALIZE))
    {
        Miniport->SendPacketsHandler = ndisMSendPacketsX;
    }
    else
    {
        if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_SG_LIST))
        {
            Miniport->SendPacketsHandler = ndisMSendPacketsSG;
            
            if (pMiniBlock->MiniportCharacteristics.SendPacketsHandler)
            {
                Miniport->DeferredSendHandler = ndisMStartSendPacketsSG;
            }
            else
            {
                Miniport->DeferredSendHandler = ndisMStartSendsSG;
            }
        }
        else
        {
            Miniport->SendPacketsHandler = ndisMSendPackets;
        }            
    }

    ndisMSetIndicatePacketHandler(Miniport);
    Miniport->SavedPacketIndicateHandler = Miniport->PacketIndicateHandler;


    //
    //  Perform any necessary cleanup.
    //
    //
    if (WmiDeregister)
    {
        //
        //  Deregister with WMI
        //
        IoWMIRegistrationControl(Miniport->DeviceObject, WMIREG_ACTION_DEREGISTER);
    }

    if (HaltMiniport)
    {
        (Miniport->DriverHandle->MiniportCharacteristics.HaltHandler)(Miniport->MiniportAdapterContext);
        ASSERT(Miniport->TimerQueue == NULL);
        ASSERT (Miniport->Interrupt == NULL);
        ASSERT(Miniport->MapRegisters == NULL);
        if ((Miniport->TimerQueue != NULL) || (Miniport->Interrupt != NULL))
        {
            if (Miniport->Interrupt != NULL)
            {
                BAD_MINIPORT(Miniport, "Unloading without deregistering interrupt");
            }
            else
            {
                BAD_MINIPORT(Miniport, "Unloading without deregistering timer");
            }
            KeBugCheckEx(BUGCODE_ID_DRIVER,
                         (ULONG_PTR)Miniport,
                         (ULONG_PTR)Miniport->TimerQueue,
                         (ULONG_PTR)Miniport->Interrupt,
                         2);
        }
    }

    if (FreeBuffer)
    {
        DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_WARN,
                ("    INIT FAILURE: Freeing the miniport name.\n"));
    }

#if ARCNET
    if (FreeArcnetLookaheadBuffer)
    {
        DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_WARN,
                ("    INIT FAILURE: Freeing the arcnet lookahead buffer.\n"));

        FREE_POOL(Miniport->ArcBuf->ArcnetLookaheadBuffer);
        FREE_POOL(Miniport->ArcBuf);
    }
#endif

    if (Dequeue)
    {
        DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_WARN,
                ("    INIT FAILURE: Dequeueing the miniport from the driver block.\n"));

        ndisDeQueueMiniportOnDriver(Miniport, pMiniBlock);
    }

    if (ClearDeviceClassAssociation)
    {
        IoSetDeviceInterfaceState(&Miniport->SymbolicLinkName, FALSE);
    }

    if (DeleteSymbolicLink)
    {
        NtStatus = IoDeleteSymbolicLink(&SymbolicLink);
        if (!NT_SUCCESS(NtStatus))
        {
#if DBG
            DbgPrint("ndisMInitializeAdapter: deleting symbolic link name failed for miniport %p, SymbolicLinkName %p, NtStatus %lx\n",
                     Miniport, &SymbolicLink, NtStatus);
#endif

        }
    }

    if (DerefDriver)
    {
        DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_WARN,
                ("    INIT FAILURE: Dereferencing the miniport block.\n"));

        ndisDereferenceDriver(pMiniBlock, FALSE);
    }

    if (ErrorCode != 0)
    {
        MiniportDereferencePackage();
    }

    DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
            ("<==ndisMInitializeAdapter: Miniport %p, Status %lx\n", Miniport, ErrorCode));

    return ErrorCode;
}


VOID
ndisMOpenAdapter(
    OUT PNDIS_STATUS            Status,
    IN  PNDIS_OPEN_BLOCK        Open,
    IN  BOOLEAN                 UsingEncapsulation
    )
/*++

Routine Description:

    This routine handles opening a miniport directly from NdisOpenAdapter()

    NOTE: called with Miniport spin lock held.
    NOTE: for serialized drivers called with local lock held

Arguments:

Return Value:

    None.

--*/
{
    PNDIS_MINIPORT_BLOCK    Miniport = Open->MiniportHandle;
    PNDIS_PROTOCOL_BLOCK    Protocol = Open->ProtocolHandle;
    PNDIS_MAC_BLOCK         FakeMac;
    BOOLEAN                 FilterOpen;
    BOOLEAN                 DerefMini = FALSE, DeQueueFromMiniport = FALSE, DeQueueFromProtocol = FALSE;
    BOOLEAN                 FakeMacAllocated = FALSE;

    DBGPRINT_RAW(DBG_COMP_BIND, DBG_LEVEL_INFO,
            ("==>ndisMOpenAdapter: Protocol %p, Miniport %p, Open %p\n",
                        Protocol,
                        Miniport,
                        Open));

    ASSERT_MINIPORT_LOCKED(Miniport);

    do
    {
        if (!MINIPORT_INCREMENT_REF(Miniport))
        {
            //
            // The adapter is closing.
            //
            *Status = NDIS_STATUS_CLOSING;
            break;
        }
        DerefMini = TRUE;

        //
        //  Initialize the open block.
        //
        FakeMac = (PNDIS_MAC_BLOCK)Miniport->FakeMac;
        if (FakeMac == NULL)
        {
            //
            //  Allocate a fake MAC block for the characteristics.
            //
            FakeMac = (PNDIS_MAC_BLOCK)ALLOC_FROM_POOL(sizeof(NDIS_MAC_BLOCK), NDIS_TAG_FAKE_MAC);
            if (FakeMac == NULL)
            {
                *Status = NDIS_STATUS_RESOURCES;
                break;
            }

            //
            //  Initialize the fake mac block.
            //
            ZeroMemory(FakeMac, sizeof(NDIS_MAC_BLOCK));
            Miniport->FakeMac = (PVOID)FakeMac;
            FakeMacAllocated = TRUE;
        }
        
        Open->MacHandle = (PVOID)FakeMac;
        Open->MiniportAdapterContext = Miniport->MiniportAdapterContext;
        Open->CurrentLookahead = (USHORT)Miniport->CurrentLookahead;

        INITIALIZE_SPIN_LOCK(&Open->SpinLock);
 
        DBGPRINT_RAW(DBG_COMP_OPENREF, DBG_LEVEL_INFO, ("    =1 0x%x\n", Open));

        Open->References = 1;

        //
        // Add an extra ref-count for connection-oriented miniports
        // This is removed after the protocol is notified of open-afs
        //
        if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_IS_CO) &&
            (Protocol->ProtocolCharacteristics.CoAfRegisterNotifyHandler != NULL))
        {
            Open->References ++;
        }


        if (UsingEncapsulation)
        {
            MINIPORT_SET_FLAG(Open, fMINIPORT_OPEN_USING_ETH_ENCAPSULATION);
        }

        //
        //  Save the handlers with the open block.
        //
        Open->WSendHandler = Miniport->DriverHandle->MiniportCharacteristics.SendHandler;
        Open->WSendPacketsHandler = Miniport->WSendPacketsHandler;
        Open->WTransferDataHandler = Miniport->DriverHandle->MiniportCharacteristics.TransferDataHandler;
        Open->SendCompleteHandler = Protocol->ProtocolCharacteristics.SendCompleteHandler;
        Open->TransferDataCompleteHandler = Protocol->ProtocolCharacteristics.TransferDataCompleteHandler;
        Open->ReceiveHandler = Protocol->ProtocolCharacteristics.ReceiveHandler;
        Open->ReceiveCompleteHandler = Protocol->ProtocolCharacteristics.ReceiveCompleteHandler;
        Open->StatusHandler = Protocol->ProtocolCharacteristics.StatusHandler;
        Open->StatusCompleteHandler = Protocol->ProtocolCharacteristics.StatusCompleteHandler;
        Open->ResetCompleteHandler = Protocol->ProtocolCharacteristics.ResetCompleteHandler;
        Open->RequestCompleteHandler = Protocol->ProtocolCharacteristics.RequestCompleteHandler;
        Open->ResetHandler = ndisMReset;
        Open->ReceivePacketHandler = Protocol->ProtocolCharacteristics.ReceivePacketHandler;
        Open->RequestHandler = ndisMRequest;
        if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_DESERIALIZE))
        {
            Open->RequestHandler = ndisMRequestX;
        }


        //
        // for backward compatibility with macros that use this field
        //
        Open->BindingHandle = (NDIS_HANDLE)Open;

        //
        //  for even more speed...
        //
#if ARCNET
        if (NdisMediumArcnet878_2 == Miniport->MediaType)
        {
            Open->TransferDataHandler = ndisMArcTransferData;
        }
        else
#endif
        {
            Open->TransferDataHandler = ndisMTransferData;
        }

        //
        //  Set the send handler in the open block.
        //
        switch (Miniport->MediaType)
        {
#if ARCNET
            case NdisMediumArcnet878_2:
                Open->SendHandler = ndisMSend;
                break;
#endif
            case NdisMediumWan:
                if (!MINIPORT_TEST_FLAG(Miniport, (fMINIPORT_IS_CO | fMINIPORT_IS_NDIS_5)))
                {
                    Open->SendHandler = (PVOID)ndisMWanSend;
                }
                break;

            default:
                if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_DESERIALIZE))
                {
                    DBGPRINT_RAW(DBG_COMP_SEND, DBG_LEVEL_INFO,
                            ("    Using ndisMSendX/ndisMSendPacketsX\n"));
                    Open->SendHandler = ndisMSendX;
                }
                else
                {
                    DBGPRINT_RAW(DBG_COMP_SEND, DBG_LEVEL_INFO,
                            ("    Using ndisMSend/ndisMSendPackets\n"));
                    if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_SG_LIST))
                    {
                        Open->SendHandler = ndisMSendSG;
                    }
                    else
                    {
                        Open->SendHandler = ndisMSend;
                    }
                }
                break;
        }

        //
        //  Set up the send packets handler.
        //
        Open->SendPacketsHandler = Miniport->SendPacketsHandler;

        //
        //  For WAN miniports, the send handler is different.
        //
        if ((NdisMediumWan == Miniport->MediaType) &&
            !MINIPORT_TEST_FLAG(Miniport, (fMINIPORT_IS_CO | fMINIPORT_IS_NDIS_5)))
        {
            Open->WanSendHandler = ndisMWanSend;
        }

        if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_IS_CO))
        {
            //
            // NDIS 5.0 miniport extensions
            //
            Open->MiniportCoRequestHandler = Miniport->DriverHandle->MiniportCharacteristics.CoRequestHandler;
            Open->MiniportCoCreateVcHandler = Miniport->DriverHandle->MiniportCharacteristics.CoCreateVcHandler;

            //
            // initialize Lists
            //
            InitializeListHead(&Open->ActiveVcHead);
            InitializeListHead(&Open->InactiveVcHead);

            //
            // the convential send function is not available for CO miniports
            // since this send function does not specify the Vc to send upon
            // However for components which want to use this let them.
            //
            if ((Open->SendHandler == NULL) && (Open->SendPacketsHandler == NULL))
            {
                Open->SendHandler = ndisMRejectSend;
                Open->SendPacketsHandler = ndisMRejectSendPackets;
            }
        }

        Open->CancelSendPacketsHandler = Miniport->DriverHandle->MiniportCharacteristics.CancelSendPacketsHandler;

        Miniport->SavedSendHandler = (PVOID)Open->SendHandler;
        Miniport->SavedSendPacketsHandler = (PVOID)Open->SendPacketsHandler;
        Miniport->SavedCancelSendPacketsHandler = (PVOID)Open->CancelSendPacketsHandler;
        
        //
        // insert the open on miniport and protocol queue
        //
        if (ndisQueueOpenOnMiniport(Miniport, Open))
        {
            DeQueueFromMiniport = TRUE;
        }
        else
        {
            *Status = NDIS_STATUS_OPEN_FAILED;
            break;
        }


        if (ndisQueueOpenOnProtocol(Open, Protocol))
        {
            DeQueueFromProtocol = TRUE;
        }
        else
        {
            *Status = NDIS_STATUS_OPEN_FAILED;
            break;
        }


        //
        // Insert the open into the filter package
        //
        switch (Miniport->MediaType)
        {
#if ARCNET
          case NdisMediumArcnet878_2:
            if (!UsingEncapsulation)
            {
                FilterOpen = ArcNoteFilterOpenAdapter(Miniport->ArcDB,
                                                      Open,
                                                      &Open->FilterHandle);
                break;
            }
#endif
            //
            // If we're using ethernet encapsulation then
            // we simply fall through to the ethernet stuff.
            //
            
          case NdisMedium802_3:
            FilterOpen = XNoteFilterOpenAdapter(Miniport->EthDB,
                                                Open,
                                                &Open->FilterHandle);
            break;
            
          case NdisMedium802_5:
            FilterOpen = XNoteFilterOpenAdapter(Miniport->TrDB,
                                                Open,
                                                &Open->FilterHandle);
            break;
            
          case NdisMediumFddi:
            FilterOpen = XNoteFilterOpenAdapter(Miniport->FddiDB,
                                                Open,
                                                &Open->FilterHandle);
            break;
            
          default:
            FilterOpen = XNoteFilterOpenAdapter(Miniport->NullDB,
                                                Open,
                                                &Open->FilterHandle);
            break;
        }

        //
        //  Check for an open filter failure.
        //
        if (!FilterOpen)
        {
            //
            // Something went wrong, clean up and exit.
            //
            *Status = NDIS_STATUS_OPEN_FAILED;
            break;
        }

        if (FakeMacAllocated)
        {
            FakeMac->MacCharacteristics.TransferDataHandler = ndisMTransferData;
            FakeMac->MacCharacteristics.ResetHandler = ndisMReset;
            FakeMac->MacCharacteristics.RequestHandler = Open->RequestHandler;
            FakeMac->MacCharacteristics.SendHandler = Open->SendHandler;
        }

        *Status = NDIS_STATUS_SUCCESS;

    } while (FALSE);

    //
    //  Cleanup failure case
    //
    if (*Status != NDIS_STATUS_SUCCESS)
    {
        if (DeQueueFromMiniport)
        {
            ndisDeQueueOpenOnMiniport(Open, Miniport);
        }

        if (DeQueueFromProtocol)
        {
            ndisDeQueueOpenOnProtocol(Open, Protocol);
        }
        
        if (DerefMini)
        {
            MINIPORT_DECREMENT_REF(Miniport);
        }
        
    }

    DBGPRINT_RAW(DBG_COMP_BIND, DBG_LEVEL_INFO,
            ("<==ndisMOpenAdapter: Protocol %p, Miniport %p, Open %p, Status %lx\n",
                        Protocol,
                        Miniport,
                        Open,
                        Status));
}

BOOLEAN
NdisIMSwitchToMiniport(
    IN  NDIS_HANDLE             MiniportAdapterHandle,
    OUT PNDIS_HANDLE            SwitchHandle
    )
/*++

Routine Description:

    This routine will attempt to synchronously grab the miniport's (specified
    by MiniportAdapterHandle) spin-lock and local lock.  If it succeeds
    it will return TRUE, otherwise it will return FALSE.

Arguments:

    MiniportAdapterHandle   -   Pointer to the NDIS_MINIPORT_BLOCK whose
                                context we should nail down.
    SwitchHandle            -   Pointer to storage for the current irql.
                                This is returned to the caller as a handle,
                                need-to-know basis baby.

Return Value:

    TRUE if we obtain both locks, FALSE otherwise.

--*/
{
    PNDIS_MINIPORT_BLOCK    Miniport = (PNDIS_MINIPORT_BLOCK)MiniportAdapterHandle;
    BOOLEAN                 LocalLock;
    KIRQL                   OldIrql;

    RAISE_IRQL_TO_DISPATCH(&OldIrql);
    *((PKIRQL)SwitchHandle) = OldIrql;

    //
    //  Did we already acquire the lock with this thread?
    //
    if (CURRENT_THREAD == Miniport->MiniportThread)
    {
        //
        //  We've already acquired the lock...
        //
        ASSERT_MINIPORT_LOCKED(Miniport);

        *SwitchHandle = (NDIS_HANDLE)-1;
        LocalLock = TRUE;
    }
    else
    {
        NDIS_ACQUIRE_MINIPORT_SPIN_LOCK_DPC(Miniport);
    
        LOCK_MINIPORT(Miniport, LocalLock);
    
        NDIS_RELEASE_MINIPORT_SPIN_LOCK_DPC(Miniport);
    }

    return LocalLock;
}

VOID
NdisIMRevertBack(
    IN  NDIS_HANDLE             MiniportAdapterHandle,
    IN  NDIS_HANDLE             SwitchHandle
    )
/*++

Routine Description:

    This routine will undo what NdisMLockMiniport did.  It will release the
    local lock and free the spin lock.

Arguments:

    MiniportAdapterHandle   -   Pointer to the NDIS_MINIPORT_BLOCK whose
                                context we are releasing.
    SwitchHandle            -   This is the original irql from the NdisMLockMiniport
                                call.

Return Value:

--*/
{
    PNDIS_MINIPORT_BLOCK    Miniport = (PNDIS_MINIPORT_BLOCK)MiniportAdapterHandle;

    ASSERT_MINIPORT_LOCKED(Miniport);

    NDIS_ACQUIRE_MINIPORT_SPIN_LOCK_DPC(Miniport);

    //
    //  Before we unlock the miniport's context we need to pick up any
    //  stray workitems for this miniport that may have been generated by
    //  the caller.
    //
    NDISM_PROCESS_DEFERRED(Miniport);

    if ((NDIS_HANDLE)-1 != SwitchHandle)
    {
        UNLOCK_MINIPORT(Miniport, TRUE);
        NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, (KIRQL)SwitchHandle);
    }
    else
    {
        NDIS_RELEASE_MINIPORT_SPIN_LOCK_DPC(Miniport);
    }
}

NDIS_STATUS
NdisIMQueueMiniportCallback(
    IN  NDIS_HANDLE             MiniportAdapterHandle,
    IN  W_MINIPORT_CALLBACK     CallbackRoutine,
    IN  PVOID                   CallbackContext
    )
/*++

Routine Description:

    This routine will attempt to acquire the specified MiniportAdapterHandle's
    miniport lock and local lock and call the callback routine with the context
    information.  If it cannot do so then it will queue a workitem to do it
    later.

Arguments:

    MiniportAdapterHandle   -   PNDIS_MINIPORT_BLOCK of the miniport whose
                                context we are attempting to acquire.
    CallbackRoutine         -   Pointer to the routine that we are to call.
    CallbackContext         -   Context information for the callback routine.

Return Value:

    NDIS_STATUS_SUCCESS -   If we were able to do this synchronously.
    NDIS_STATUS_PENDING -   If it will be called at a later time.
    NDIS_STATUS_RESOURCES - If the work item could not be queue'd.

--*/
{
    PNDIS_MINIPORT_BLOCK    Miniport = (PNDIS_MINIPORT_BLOCK)MiniportAdapterHandle;
    NDIS_STATUS             Status;
    BOOLEAN                 LocalLock;
    KIRQL                   OldIrql;

    RAISE_IRQL_TO_DISPATCH(&OldIrql);

    //
    //  Did we already acuqire the lock with this thread?
    //
    if (CURRENT_THREAD == Miniport->MiniportThread)
    {
        //
        //  We've already acquired the lock...
        //
        ASSERT_MINIPORT_LOCKED(Miniport);

        NDIS_ACQUIRE_MINIPORT_SPIN_LOCK_DPC(Miniport);
        LocalLock = TRUE;
    }
    else
    {
        NDIS_ACQUIRE_MINIPORT_SPIN_LOCK_DPC(Miniport);
        LOCK_MINIPORT(Miniport, LocalLock);
    }

    if (LocalLock)
    {
        //
        //  Call the callback routine.
        //
        NDIS_RELEASE_MINIPORT_SPIN_LOCK_DPC(Miniport);

        (*CallbackRoutine)(Miniport->MiniportAdapterContext, CallbackContext);

        NDIS_ACQUIRE_MINIPORT_SPIN_LOCK_DPC(Miniport);

        NDISM_PROCESS_DEFERRED(Miniport);

        UNLOCK_MINIPORT(Miniport, LocalLock);

        NDIS_RELEASE_MINIPORT_SPIN_LOCK_DPC(Miniport);

        Status = NDIS_STATUS_SUCCESS;
    }
    else
    {
        //
        //  Queue the work item to do this later.
        //
        Status = NDISM_QUEUE_NEW_WORK_ITEM(Miniport,
                                           NdisWorkItemMiniportCallback,
                                           CallbackContext,
                                           CallbackRoutine);

        NDIS_RELEASE_MINIPORT_SPIN_LOCK_DPC(Miniport);


        Status = (NDIS_STATUS_SUCCESS == Status) ? NDIS_STATUS_PENDING : NDIS_STATUS_RESOURCES;
    }

    LOWER_IRQL(OldIrql, DISPATCH_LEVEL);

    return Status;
}

VOID
FASTCALL
ndisMDeQueueWorkItem(
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  NDIS_WORK_ITEM_TYPE     WorkItemType,
    OUT PVOID       *           WorkItemContext OPTIONAL,
    OUT PVOID       *           WorkItemHandler OPTIONAL
    )
/*++

Routine Description:

    This routine will dequeue a workitem of the given type and return any context
    information that is associated with it.


Arguments:

    Miniport            -   Pointer to the miniport block.
    WorkItemType        -   Type of workitem to dequeue.
    WorkItemContext     -   Pointer to storage space for context information.

Return Value:

    None.

--*/
{
    PSINGLE_LIST_ENTRY          Link;
    PNDIS_MINIPORT_WORK_ITEM    WorkItem;

    //
    //  Grab the first workitem of the given type.
    //
    Link = PopEntryList(&Miniport->WorkQueue[WorkItemType]);
    if (Link != NULL)
    {
        //
        //  Get a pointer to the context information.
        //
        WorkItem = CONTAINING_RECORD(Link, NDIS_MINIPORT_WORK_ITEM, Link);

        if (WorkItemContext != NULL)
        {
            *WorkItemContext = WorkItem->WorkItemContext;
        }

        if (ARGUMENT_PRESENT(WorkItemHandler))
        {
            ASSERT(WorkItemType == NdisWorkItemMiniportCallback);
            *WorkItemHandler = *(PVOID *)(WorkItem + 1);
        }

        switch (WorkItemType)
        {
            //
            // Enumerate these if any work-item types are added and they are *not*
            // single work-item types
            //
            case NdisWorkItemMiniportCallback:
                FREE_POOL(WorkItem);
                break;

            case NdisWorkItemResetInProgress:
                PushEntryList(&Miniport->SingleWorkItems[NdisWorkItemResetRequested], Link);
                break;

            case NdisWorkItemResetRequested:
                WorkItem->WorkItemType = NdisWorkItemResetInProgress;
                PushEntryList(&Miniport->WorkQueue[NdisWorkItemResetInProgress], Link);
                break;

            default:
                PushEntryList(&Miniport->SingleWorkItems[WorkItemType], Link);
                break;
        }
    }
}

NDIS_STATUS
FASTCALL
ndisMQueueWorkItem(
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  NDIS_WORK_ITEM_TYPE     WorkItemType,
    IN  PVOID                   WorkItemContext
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    NDIS_STATUS             Status;
    PSINGLE_LIST_ENTRY      Link;
    PNDIS_MINIPORT_WORK_ITEM WorkItem;

    DBGPRINT(DBG_COMP_WORK_ITEM, DBG_LEVEL_INFO,
        ("==>ndisMQueueWorkItem\n"));

    Link = PopEntryList(&Miniport->SingleWorkItems[WorkItemType]);
    if (NULL != Link)
    {
        WorkItem = CONTAINING_RECORD(Link, NDIS_MINIPORT_WORK_ITEM, Link);
        WorkItem->WorkItemType = WorkItemType;
        WorkItem->WorkItemContext = WorkItemContext;
        PushEntryList(&Miniport->WorkQueue[WorkItemType], Link);
        Status = NDIS_STATUS_SUCCESS;
    }
    else
    {
        Status = NDIS_STATUS_NOT_ACCEPTED;
    }

    //
    //  If this is an intermediate driver then we may have to fire a timer
    //  so the work item gets processed.
    //
    if (((Miniport->Flags & (fMINIPORT_INTERMEDIATE_DRIVER | fMINIPORT_DESERIALIZE)) == fMINIPORT_INTERMEDIATE_DRIVER) &&
        (NDIS_STATUS_SUCCESS == Status))
    {
        NDISM_DEFER_PROCESS_DEFERRED(Miniport);
    }
    else if ((MINIPORT_TEST_FLAG(Miniport, fMINIPORT_DESERIALIZE) ||
             MINIPORT_PNP_TEST_FLAG (Miniport, fMINIPORT_PM_HALTED)) &&
             (WorkItemType == NdisWorkItemRequest))
    {
        ndisMDoRequests(Miniport);
    }

    DBGPRINT(DBG_COMP_WORK_ITEM, DBG_LEVEL_INFO,
            ("<==ndisMQueueWorkItem\n"));

    return(Status);
}

NDIS_STATUS
FASTCALL
ndisMQueueNewWorkItem(
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  NDIS_WORK_ITEM_TYPE     WorkItemType,
    IN  PVOID                   WorkItemContext,
    IN  PVOID                   WorkItemHandler OPTIONAL
    )
/*++

Routine Description:

    This routine will queue a workitem in the work queue even if there
    are already work items queue for it.

Arguments:

    Miniport    -   Miniport block to queue the workitem to.
    WorkItem    -   Workitem to place on the queue.

Return Value:

--*/
{
    NDIS_STATUS         Status;
    PNDIS_MINIPORT_WORK_ITEM WorkItem;

    DBGPRINT(DBG_COMP_WORK_ITEM, DBG_LEVEL_INFO,
        ("==>ndisMQueueNewWorkItem\n"));

    ASSERT((WorkItemType < NUMBER_OF_WORK_ITEM_TYPES) &&
           (WorkItemType >= NUMBER_OF_SINGLE_WORK_ITEMS));

    do
    {
        DBGPRINT(DBG_COMP_WORK_ITEM, DBG_LEVEL_INFO,
                ("Allocate a workitem from the pool.\n"));

        WorkItem = ALLOC_FROM_POOL(sizeof(NDIS_MINIPORT_WORK_ITEM) + (ARGUMENT_PRESENT(WorkItemHandler) ? sizeof(PVOID) : 0),
                                    NDIS_TAG_WORK_ITEM);
        if (NULL == WorkItem)
        {
            DBGPRINT(DBG_COMP_WORK_ITEM, DBG_LEVEL_FATAL,
                    ("Failed to allocate a workitem from the pool!\n"));
            DBGBREAK(DBG_COMP_WORK_ITEM, DBG_LEVEL_FATAL);

            Status = NDIS_STATUS_FAILURE;
            break;
        }

        WorkItem->WorkItemType = WorkItemType;
        WorkItem->WorkItemContext = WorkItemContext;
        if (ARGUMENT_PRESENT(WorkItemHandler))
        {
            ASSERT(WorkItemType == NdisWorkItemMiniportCallback);
            *(PVOID *)(WorkItem + 1) = WorkItemHandler;
        }

        DBGPRINT(DBG_COMP_WORK_ITEM, DBG_LEVEL_INFO,
                ("WorkItem 0x%x\n", WorkItem));
        DBGPRINT(DBG_COMP_WORK_ITEM, DBG_LEVEL_INFO,
                ("WorkItem Type 0x%x\n", WorkItemType));
        DBGPRINT(DBG_COMP_WORK_ITEM, DBG_LEVEL_INFO,
                ("WorkItem Context 0x%x\n", WorkItemContext));

        PushEntryList(&Miniport->WorkQueue[WorkItemType], &WorkItem->Link);

        Status = NDIS_STATUS_SUCCESS;

    } while (FALSE);

    //
    //  If this is an intermediate driver (but not a co-ndis or a 
    //  deserialized driver) then we may have to fire a timer
    //  so the work item gets processed.
    //
    if (((Miniport->Flags & (fMINIPORT_INTERMEDIATE_DRIVER | fMINIPORT_DESERIALIZE)) == fMINIPORT_INTERMEDIATE_DRIVER) &&
        (NDIS_STATUS_SUCCESS == Status))
    {
        NDISM_DEFER_PROCESS_DEFERRED(Miniport);
    }

    DBGPRINT(DBG_COMP_WORK_ITEM, DBG_LEVEL_INFO,
        ("<==ndisMQueueNewWorkItem\n"));

    return(Status);
}


VOID
FASTCALL
ndisMProcessDeferred(
    IN  PNDIS_MINIPORT_BLOCK    Miniport
    )

/*++

Routine Description:

    Processes all outstanding operations.

    CALLED WITH THE LOCK HELD!!

Arguments:

    Miniport - Miniport to send to.

Return Value:

    None.

--*/
{
    NDIS_STATUS         Status;
    BOOLEAN             ProcessWorkItems;
    BOOLEAN             AddressingReset = FALSE;
    PKDPC               Dpc;

    ASSERT_MINIPORT_LOCKED(Miniport);

    DBGPRINT_RAW(DBG_COMP_WORK_ITEM, DBG_LEVEL_INFO,
        ("==>ndisMProcessDeferred\n"));

    //
    //  DO NOT CHANGE THE ORDER THAT THE WORKITEMS ARE PROCESSED!!!!!
    //
    do
    {
        ProcessWorkItems = FALSE;

        //
        //  Are there any sends to process?
        //
        if ((Miniport->WorkQueue[NdisWorkItemSend].Next != NULL) &&
            !MINIPORT_TEST_FLAG(Miniport, (fMINIPORT_RESET_REQUESTED | 
                                           fMINIPORT_RESET_IN_PROGRESS | 
                                           fMINIPORT_PM_HALTING)))
        {
            //
            //  Process the sends.
            //
            NDISM_DEQUEUE_WORK_ITEM(Miniport, NdisWorkItemSend, NULL);
            NDISM_START_SENDS(Miniport);
            ProcessWorkItems = TRUE;
        }

        //
        //  Is there a reset currently in progress?
        //
        if (Miniport->WorkQueue[NdisWorkItemResetInProgress].Next != NULL)
        {
            if (Miniport->WorkQueue[NdisWorkItemRequest].Next != NULL)
            {
                //
                //  We have requests to process that set up the packet
                //  filters.
                //
                NDISM_DEQUEUE_WORK_ITEM(Miniport, NdisWorkItemRequest, NULL);
                ndisMDoRequests(Miniport);
            }
            break;
        }

        if (Miniport->WorkQueue[NdisWorkItemReturnPackets].Next != NULL)
        {
            NDISM_DEQUEUE_WORK_ITEM(Miniport, NdisWorkItemReturnPackets, NULL);
            ndisMDeferredReturnPackets(Miniport);
        }

        //
        //  If the adapter is halting then get out of here.
        //
        if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_PM_HALTING))

        {
            DBGPRINT_RAW(DBG_COMP_WORK_ITEM, DBG_LEVEL_INFO,
                ("    Miniport is halting\n"));
            break;
        }

        //
        //  If a miniport wants a call back do it now...
        //
        if (Miniport->WorkQueue[NdisWorkItemMiniportCallback].Next != NULL)
        {
            W_MINIPORT_CALLBACK CallbackRoutine = NULL;
            PVOID               CallbackContext;

            //
            //  Get the callback routine and the context information for it.
            //
            NDISM_DEQUEUE_WORK_ITEM_WITH_HANDLER(Miniport,
                                                 NdisWorkItemMiniportCallback,
                                                 &CallbackContext,
                                                 (PVOID *)&CallbackRoutine);

            if (CallbackRoutine != NULL)
            {
                NDIS_RELEASE_MINIPORT_SPIN_LOCK_DPC(Miniport);

                //
                //  Call the intermediate drivers callback routine.
                //
                (*CallbackRoutine)(Miniport->MiniportAdapterContext, CallbackContext);

                NDIS_ACQUIRE_MINIPORT_SPIN_LOCK_DPC(Miniport);
            }

            ProcessWorkItems = TRUE;
        }

        //
        //  Was there a reset requested?
        //
        if (Miniport->WorkQueue[NdisWorkItemResetRequested].Next != NULL)
        {
            DBGPRINT_RAW(DBG_COMP_WORK_ITEM, DBG_LEVEL_INFO,
                    ("    Reset requested\n"));

            //
            //  We need to release the work item lock to
            //  indicate the status to the bindings
            //  and to call down to the miniport driver.
            //
            Status = ndisMProcessResetRequested(Miniport, &AddressingReset);

            if (NDIS_STATUS_PENDING == Status)
            {
                DBGPRINT_RAW(DBG_COMP_WORK_ITEM, DBG_LEVEL_INFO,
                    ("    Reset is pending\n"));
                //
                //  The reset is still in progress so we need to stop
                //  processing workitems and wait for the completion.
                //
                break;
            }
            else
            {
                //
                //  Do step1 of the reset complete.
                //
                ndisMResetCompleteStage1(Miniport,
                                         Status,
                                         AddressingReset);
                if (Miniport->WorkQueue[NdisWorkItemRequest].Next == NULL)
                {
                    //
                    // somehow we did not queue a workitem due to address reset flag
                    //
                    AddressingReset = FALSE;
                }

                if (!AddressingReset || (Status != NDIS_STATUS_SUCCESS))
                {
                    //
                    //  If there is no addressing reset to be done or
                    //  the reset failed in some way then we tell the
                    //  bindings now.
                    //
                    ndisMResetCompleteStage2(Miniport);
                }
                else
                {
                    //
                    //  We MUST complete the filter requests within
                    //  the reset in progress workitem. Mainly because
                    //  we don't want to do any sends at this time.
                    //
                    ProcessWorkItems = TRUE;
                    continue;
                }
            }
        }

        //
        //  Process any requests?
        //
        if (Miniport->WorkQueue[NdisWorkItemRequest].Next != NULL)
        {
            //
            //  Process the requests.
            //
            NDISM_DEQUEUE_WORK_ITEM(Miniport, NdisWorkItemRequest, NULL);
            ndisMDoRequests(Miniport);
            ProcessWorkItems = TRUE;
        }

        if (Miniport->WorkQueue[NdisWorkItemSend].Next != NULL)
        {
            //
            //  Process the sends.
            //
            NDISM_DEQUEUE_WORK_ITEM(Miniport, NdisWorkItemSend, NULL);
            NDISM_START_SENDS(Miniport);
            ProcessWorkItems = TRUE;
        }
    } while (ProcessWorkItems);

    DBGPRINT_RAW(DBG_COMP_WORK_ITEM, DBG_LEVEL_INFO,
        ("<==ndisMProcessDeferred\n"));
}

VOID
NdisMIndicateStatus(
    IN  NDIS_HANDLE             MiniportAdapterHandle,
    IN  NDIS_STATUS             GeneralStatus,
    IN  PVOID                   StatusBuffer,
    IN  UINT                    StatusBufferSize
    )
/*++

Routine Description:

    This function indicates a new status of the media/mini-port.

Arguments:

    MiniportAdapterHandle - points to the adapter block.

    GeneralStatus - The status to indicate.

    StatusBuffer - Additional information.

    StatusBufferSize - Length of the buffer.

Return Value:

    None.


--*/
{
    PNDIS_MINIPORT_BLOCK    Miniport = (PNDIS_MINIPORT_BLOCK)MiniportAdapterHandle;
    PNDIS_OPEN_BLOCK        Open, NextOpen;
    NDIS_STATUS             Status;
    BOOLEAN                 fTimerCancelled, fSwap = FALSE;
    BOOLEAN                 fInternal = FALSE;
    PNDIS_GUID              pNdisGuid;
    NTSTATUS                NtStatus;
    BOOLEAN                 fMediaConnectStateIndication = FALSE;
    KIRQL                   OldIrql;

    //
    // Internal indications are media-sense indications. These are detected by
    // a StatusBufferSize of -1 and StatusBuffer of NULL.
    //
    if ((GeneralStatus == NDIS_STATUS_MEDIA_CONNECT) || (GeneralStatus == NDIS_STATUS_MEDIA_DISCONNECT))
    {
        fMediaConnectStateIndication = TRUE;
        fInternal = ((StatusBufferSize == INTERNAL_INDICATION_SIZE) && (StatusBuffer == INTERNAL_INDICATION_BUFFER));
    }

    ASSERT_MINIPORT_LOCKED(Miniport);

    NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Miniport, &OldIrql);


    if (MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_FILTER_IM) &&
        fMediaConnectStateIndication)
    {
        //
        // if this is a media conenct/disconnect event from an IM filter
        // driver, skip wmi event
        //
        NtStatus = STATUS_UNSUCCESSFUL;
    }
    else
    {
        //
        //  Check to see if the status is enabled for WMI event indication.
        //
        NtStatus = ndisWmiGetGuid(&pNdisGuid, Miniport, NULL, GeneralStatus);
    }

    if ((NT_SUCCESS(NtStatus)) &&
        NDIS_GUID_TEST_FLAG(pNdisGuid, fNDIS_GUID_EVENT_ENABLED))
    {
        PWNODE_SINGLE_INSTANCE  wnode;
        ULONG                   DataBlockSize = 0;
        PUCHAR                  ptmp;

        //
        //  If the data item is an array then we need to add in the number of
        //  elements.
        //
        if (NDIS_GUID_TEST_FLAG(pNdisGuid, fNDIS_GUID_ARRAY))
        {
            DataBlockSize = StatusBufferSize + sizeof(ULONG);
        }
        else
        {
            DataBlockSize = pNdisGuid->Size;
        }

        //
        // in case of media connect/disconnect status indication, include the
        // NIC's name in the WMI event
        //
        if (fMediaConnectStateIndication)
        {
            DataBlockSize += Miniport->MiniportName.Length + sizeof(WCHAR);
        }
        
        ndisSetupWmiNode(Miniport,
                         Miniport->pAdapterInstanceName,
                         DataBlockSize,
                         (PVOID)&pNdisGuid->Guid,
                         &wnode);

        if (NULL != wnode)
        {   
            //
            //  Increment ptmp to the start of the data block.
            //
            ptmp = (PUCHAR)wnode + wnode->DataBlockOffset;

            if (NDIS_GUID_TEST_FLAG(pNdisGuid, fNDIS_GUID_ARRAY))
            {
                //
                //  If the status is an array but there is no data then complete it with no
                //  data and a 0 length
                //
                if ((NULL == StatusBuffer) || (0 == StatusBufferSize))
                {
                    *((PULONG)ptmp) = 0;
                    ptmp += sizeof(ULONG);
                }
                else
                {
                    //
                    //  Save the number of elements in the first ULONG.
                    //
                    *((PULONG)ptmp) = StatusBufferSize / pNdisGuid->Size;

                    //
                    //  Copy the data after the number of elements.
                    //
                    RtlCopyMemory(ptmp + sizeof(ULONG), StatusBuffer, StatusBufferSize);
                    ptmp += sizeof(ULONG) + StatusBufferSize;
                }
            }
            else
            {
                //
                //  Do we indicate any data up?
                //
                if (0 != pNdisGuid->Size)
                {
                    //
                    //  Copy the data into the buffer.
                    //
                    RtlCopyMemory(ptmp, StatusBuffer, pNdisGuid->Size);
                    ptmp += pNdisGuid->Size;
                }
            }

            if (fMediaConnectStateIndication)
            {
                //
                // for media connect/disconnect status, 
                // add the name of the adapter
                //
                RtlCopyMemory(ptmp,
                              Miniport->MiniportName.Buffer,
                              Miniport->MiniportName.Length);
                    
            }


            //
            //  Indicate the event to WMI. WMI will take care of freeing
            //  the WMI struct back to pool.
            //
            NtStatus = IoWMIWriteEvent(wnode);
            if (!NT_SUCCESS(NtStatus))
            {
                DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_ERR,
                    ("    ndisMIndicateStatus: Unable to indicate the WMI event.\n"));

                FREE_POOL(wnode);
            }
        }
    }

    //
    //  Process the status code that was indicated.
    //
    switch (GeneralStatus)
    {
      case NDIS_STATUS_RING_STATUS:
        if (StatusBufferSize == sizeof(NDIS_STATUS))
        {
            Status = *((PNDIS_STATUS)StatusBuffer);

            if (Status & (NDIS_RING_LOBE_WIRE_FAULT |
                          NDIS_RING_HARD_ERROR |
                          NDIS_RING_SIGNAL_LOSS))
            {
                Miniport->TrResetRing = NDIS_MINIPORT_TR_RESET_TIMEOUT;
            }
            else
            {
                Miniport->TrResetRing = 0;
            }
        }
        break;

      case NDIS_STATUS_MEDIA_DISCONNECT:
        Miniport->MediaSenseDisconnectCount ++;

        DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
            ("NdisMIndicateStatus: NDIS_STATUS_MEDIA_DISCONNECT, Miniport %p, Flags: %lx, PnpFlags %lx, DevicePowerState %lx\n",
                Miniport,
                Miniport->Flags,
                Miniport->PnPFlags,
                Miniport->CurrentDevicePowerState));
        
        if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_MEDIA_CONNECTED))
        {
            fSwap = TRUE;
        }
        MINIPORT_CLEAR_FLAG(Miniport, fMINIPORT_MEDIA_CONNECTED);
        if (!fInternal)
        {
            //
            // miniport can do media sense and indicate status
            //
            MINIPORT_CLEAR_FLAG(Miniport, fMINIPORT_REQUIRES_MEDIA_POLLING);
            MINIPORT_SET_FLAG(Miniport, fMINIPORT_SUPPORTS_MEDIA_SENSE);
    
            //
            //  Is this a PM enabled miniport? And is dynamic power policy
            //  enabled for the miniport?
            //
            if (fSwap &&
                MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_DEVICE_POWER_ENABLE) &&
                (Miniport->WakeUpEnable & NDIS_PNP_WAKE_UP_LINK_CHANGE) &&
                (Miniport->MediaDisconnectTimeOut != (USHORT)(-1)))
            {
                //
                //  Are we already waiting for the disconnect timer to fire?
                //
                if (!MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_MEDIA_DISCONNECT_WAIT))
                {
                    //
                    //  Mark the miniport as disconnecting and fire off the
                    //  timer.
                    //
                    MINIPORT_PNP_CLEAR_FLAG(Miniport, fMINIPORT_MEDIA_DISCONNECT_CANCELLED);
                    MINIPORT_PNP_SET_FLAG(Miniport, fMINIPORT_MEDIA_DISCONNECT_WAIT);

                    NdisSetTimer(&Miniport->MediaDisconnectTimer, Miniport->MediaDisconnectTimeOut * 1000);
                }
            }
        }
        
        break;

      case NDIS_STATUS_MEDIA_CONNECT:
        Miniport->MediaSenseConnectCount ++;
      
        DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
            ("NdisMIndicateStatus: NDIS_STATUS_MEDIA_CONNECT, Miniport %p, Flags: %lx, PnpFlags %lx, DevicePowerState %lx\n",
                Miniport,
                Miniport->Flags,
                Miniport->PnPFlags,
                Miniport->CurrentDevicePowerState));
        
        if (!MINIPORT_TEST_FLAG(Miniport, fMINIPORT_MEDIA_CONNECTED))
        {
            fSwap = TRUE;
        }
        MINIPORT_SET_FLAG(Miniport, fMINIPORT_MEDIA_CONNECTED);
        if (!fInternal)
        {
            //
            // miniport can do media sense and can indicate that status to Ndis. Do not poll
            //
            MINIPORT_CLEAR_FLAG(Miniport, fMINIPORT_REQUIRES_MEDIA_POLLING);
            MINIPORT_SET_FLAG(Miniport, fMINIPORT_SUPPORTS_MEDIA_SENSE);

            //
            // if media disconnect timer was set, cancel the timer
            //
            if (MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_MEDIA_DISCONNECT_WAIT))
            {
                //
                //  Clear the disconnect wait bit and cancel the timer.
                //  IF the timer routine hasn't grabed the lock then we are ok.
                //
                MINIPORT_PNP_CLEAR_FLAG(Miniport, fMINIPORT_MEDIA_DISCONNECT_WAIT);
                MINIPORT_PNP_SET_FLAG(Miniport, fMINIPORT_MEDIA_DISCONNECT_CANCELLED);

                NdisCancelTimer(&Miniport->MediaDisconnectTimer, &fTimerCancelled);
            }
        }

        break;
        
      default:
        break;
    }

    for (Open = Miniport->OpenQueue;
         (Open != NULL);
         Open = NextOpen)
    {
        if (MINIPORT_TEST_FLAG(Open, fMINIPORT_OPEN_CLOSING))
        {
            NextOpen = Open->MiniportNextOpen;
            continue;
        }

        M_OPEN_INCREMENT_REF_INTERLOCKED(Open);
        
        if (Open->StatusHandler != NULL)
        {
            Open->Flags |= fMINIPORT_STATUS_RECEIVED;
            
            if ((NDIS_STATUS_WAN_LINE_UP == GeneralStatus) ||
                (NDIS_STATUS_WAN_LINE_DOWN == GeneralStatus))
            {
                NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);
            }
            else
            {
                NDIS_RELEASE_MINIPORT_SPIN_LOCK_DPC(Miniport);
            }

            //
            // Call Protocol to indicate status
            //
            (Open->StatusHandler)(Open->ProtocolBindingContext,
                                    GeneralStatus,
                                    StatusBuffer,
                                    StatusBufferSize);

            if ((NDIS_STATUS_WAN_LINE_UP == GeneralStatus) ||
                (NDIS_STATUS_WAN_LINE_DOWN == GeneralStatus))
            {
                NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Miniport, &OldIrql);
            }
            else
            {
                NDIS_ACQUIRE_MINIPORT_SPIN_LOCK_DPC(Miniport);
            }
        }
        
        NextOpen = Open->MiniportNextOpen;

        ndisMDereferenceOpen(Open);
    }



    //
    // If we got a connect/disconnect, swap open handlers
    //
    if (fSwap)
    {
        if (NDIS_STATUS_MEDIA_CONNECT == GeneralStatus)
        {
            MINIPORT_PNP_CLEAR_FLAG(Miniport, fMINIPORT_MEDIA_DISCONNECT_INDICATED);
            ndisMRestoreOpenHandlers(Miniport, fMINIPORT_STATE_MEDIA_DISCONNECTED);
            Miniport->PacketIndicateHandler = Miniport->SavedPacketIndicateHandler;
        }
        else
        {
            MINIPORT_PNP_SET_FLAG(Miniport, fMINIPORT_MEDIA_DISCONNECT_INDICATED);
            ndisMSwapOpenHandlers(Miniport, 
                                  NDIS_STATUS_NO_CABLE,
                                  fMINIPORT_STATE_MEDIA_DISCONNECTED);
            Miniport->SavedPacketIndicateHandler = Miniport->PacketIndicateHandler;
            Miniport->PacketIndicateHandler = ndisMDummyIndicatePacket;
        }
        
    }

    NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);
}

VOID
NdisMIndicateStatusComplete(
    IN  NDIS_HANDLE             MiniportAdapterHandle
    )
/*++

Routine Description:

    This function indicates the status is complete.

Arguments:

    MiniportAdapterHandle - points to the adapter block.

Return Value:

    None.


--*/
{
    PNDIS_MINIPORT_BLOCK Miniport = (PNDIS_MINIPORT_BLOCK)MiniportAdapterHandle;
    PNDIS_OPEN_BLOCK     Open, NextOpen;
    KIRQL                OldIrql;

    NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Miniport, &OldIrql);

    ASSERT_MINIPORT_LOCKED(Miniport);

    for (Open = Miniport->OpenQueue;
         Open != NULL;
         Open = NextOpen)
    {
        if (MINIPORT_TEST_FLAG(Open, (fMINIPORT_OPEN_CLOSING | 
                                      fMINIPORT_OPEN_UNBINDING)))
        {
            NextOpen = Open->MiniportNextOpen;
            continue;
        }

        M_OPEN_INCREMENT_REF_INTERLOCKED(Open);
        
        if ((NULL != Open->StatusCompleteHandler) &&
            (Open->Flags & fMINIPORT_STATUS_RECEIVED))
        {
            //
            // Call Protocol to indicate status
            //
            NDIS_RELEASE_MINIPORT_SPIN_LOCK_DPC(Miniport);

            (Open->StatusCompleteHandler)(Open->ProtocolBindingContext);

            NDIS_ACQUIRE_MINIPORT_SPIN_LOCK_DPC(Miniport);
        }
        Open->Flags &= ~fMINIPORT_STATUS_RECEIVED;
        
        NextOpen = Open->MiniportNextOpen;

        ndisMDereferenceOpen(Open);      
    }

    NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);
}


VOID
NdisMWanIndicateReceive(
    OUT PNDIS_STATUS            Status,
    IN  NDIS_HANDLE             MiniportAdapterHandle,
    IN  NDIS_HANDLE             NdisLinkContext,
    IN  PUCHAR                  Packet,
    IN  ULONG                   PacketSize
    )
/*++

Routine Description:

    This function indicates the status is complete.

Arguments:

    MiniportAdapterHandle - points to the adapter block.

Return Value:

    None.


--*/
{
    PNDIS_MINIPORT_BLOCK Miniport = (PNDIS_MINIPORT_BLOCK)MiniportAdapterHandle;
    PNDIS_OPEN_BLOCK     Open;
    KIRQL                OldIrql;

    ASSERT_MINIPORT_LOCKED(Miniport);

    NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Miniport, &OldIrql);

    for (Open = Miniport->OpenQueue;
         Open != NULL;
         Open = Open->MiniportNextOpen)
    {
        //
        // Call Protocol to indicate packet
        //
        NDIS_RELEASE_MINIPORT_SPIN_LOCK_DPC(Miniport);

        *Status = (Open->ProtocolHandle->ProtocolCharacteristics.WanReceiveHandler)(
                                         NdisLinkContext,
                                         Packet,
                                         PacketSize);

        NDIS_ACQUIRE_MINIPORT_SPIN_LOCK_DPC(Miniport);
    }

    NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);
}

VOID
NdisMWanIndicateReceiveComplete(
    IN  NDIS_HANDLE             MiniportAdapterHandle,
    IN  NDIS_HANDLE             NdisLinkContext
    )
/*++

Routine Description:

    This function indicates the status is complete.

Arguments:

    MiniportAdapterHandle - points to the adapter block.

Return Value:

    None.


--*/
{
    PNDIS_MINIPORT_BLOCK Miniport = (PNDIS_MINIPORT_BLOCK)MiniportAdapterHandle;
    PNDIS_OPEN_BLOCK     Open;
    KIRQL                OldIrql;

    ASSERT_MINIPORT_LOCKED(Miniport);

    NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Miniport, &OldIrql);

    for (Open = Miniport->OpenQueue;
         Open != NULL;
         Open = Open->MiniportNextOpen)
    {
        //
        // Call Protocol to indicate status
        //

        NDIS_RELEASE_MINIPORT_SPIN_LOCK_DPC(Miniport);

        (Open->ReceiveCompleteHandler)(NdisLinkContext);

        NDIS_ACQUIRE_MINIPORT_SPIN_LOCK_DPC(Miniport);
    }

    NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);
}

PNDIS_PACKET
NdisGetReceivedPacket(
    IN  NDIS_HANDLE             NdisBindingHandle,
    IN  NDIS_HANDLE             MacContext
    )
{
    PNDIS_OPEN_BLOCK        OpenBlock = ((PNDIS_OPEN_BLOCK)NdisBindingHandle);
    PNDIS_MINIPORT_BLOCK    Miniport;
    PNDIS_PACKET            Packet = NULL;
#ifdef TRACK_RECEIVED_PACKETS
    PETHREAD                CurThread = PsGetCurrentThread();
//    ULONG                   CurThread = KeGetCurrentProcessorNumber();
#endif

    Miniport = OpenBlock->MiniportHandle;

    DBGPRINT_RAW(DBG_COMP_SEND, DBG_LEVEL_INFO,
            ("NdisGetReceivedPacket - Miniort %p, Context %p\n",
            Miniport, MacContext));

    ASSERT_MINIPORT_LOCKED(Miniport);

    //
    // The following tests whether we came here via a IndicatePacket or IndicateRecieve
    //
    if ((INDICATED_PACKET(Miniport) == (PNDIS_PACKET)MacContext) &&
        (MacContext != NULL))
    {
        Packet = NDIS_GET_ORIGINAL_PACKET((PNDIS_PACKET)MacContext);

#ifdef TRACK_RECEIVED_PACKETS
        {
            PNDIS_STACK_RESERVED    NSR;
            NDIS_STACK_RESERVED_FROM_PACKET(Packet, &NSR)

            NDIS_APPEND_RCV_LOGFILE(Packet, Miniport, CurThread,
                                    0xA, CURR_STACK_LOCATION(Packet), NSR->RefCount, NSR->XRefCount, NDIS_GET_PACKET_STATUS(Packet));
        }
#endif
        
    }

    return Packet;
}


VOID
NdisReturnPackets(
    IN  PNDIS_PACKET *          PacketsToReturn,
    IN  UINT                    NumberOfPackets
    )
/*++

Routine Description:

    Decrement the refcount for the packet and return back to the miniport if 0.
    We take the Miniport lock here and hence are protected against other receives.

Arguments:

    PacketsToReturn - Pointer to the set of packets to return to the miniport
    NumberOfPackets - self descriptive

Return Value:

    None.

--*/
{
    UINT                    i;
    KIRQL                   OldIrql;
    
#ifdef TRACK_RECEIVED_PACKETS
    PETHREAD                CurThread = PsGetCurrentThread();
//    ULONG                   CurThread = KeGetCurrentProcessorNumber();
#endif

    RAISE_IRQL_TO_DISPATCH(&OldIrql);

    for (i = 0; i < NumberOfPackets; i++)
    {
        PNDIS_MINIPORT_BLOCK    Miniport;
        PNDIS_STACK_RESERVED    NSR;
        W_RETURN_PACKET_HANDLER Handler;
        PNDIS_PACKET            Packet;
        ULONG                   RefCount;
        BOOLEAN                 LocalLock;

        Packet = PacketsToReturn[i];
        NDIS_STACK_RESERVED_FROM_PACKET(Packet, &NSR)

        ASSERT (Packet != NULL);

        Miniport = NSR->Miniport;
        ASSERT (Miniport != NULL);


        NDIS_APPEND_RCV_LOGFILE(Packet, Miniport, CurThread,
                                0xB, CURR_STACK_LOCATION(Packet), NSR->RefCount, NSR->XRefCount, NDIS_GET_PACKET_STATUS(Packet));
                        
        ADJUST_PACKET_REFCOUNT(NSR, &RefCount);

        if (RefCount == 0)
        {
            NDIS_APPEND_RCV_LOGFILE(Packet, Miniport, CurThread,
                                    0xC, CURR_STACK_LOCATION(Packet), NSR->RefCount, NSR->XRefCount, NDIS_GET_PACKET_STATUS(Packet));

            if (!MINIPORT_TEST_FLAG(Miniport, fMINIPORT_DESERIALIZE))
            {
                NDIS_ACQUIRE_MINIPORT_SPIN_LOCK_DPC(Miniport);
                LOCK_MINIPORT(Miniport, LocalLock);
            }
            
            if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_DESERIALIZE) ||
                LocalLock)
            {

#ifdef NDIS_TRACK_RETURNED_PACKETS
                if (NSR->RefCount != 0)
                {
                    DbgPrint("Packet %p is being returned back to the miniport"
                              "but the ref count is not zero.\n", Packet);
                    DbgBreakPoint();

                }
                    
                if (Packet->Private.Head == NULL)
                {
                    DbgPrint("Packet %p is being returned back to the miniport with NULL Head.\n", Packet);
                    DbgBreakPoint();
                }
        
#endif

            
                //
                //  Return the packet to the miniport
                //
                Handler = Miniport->DriverHandle->MiniportCharacteristics.ReturnPacketHandler;
                NSR->Miniport = NULL;
                POP_PACKET_STACK(Packet);
                
#ifdef NDIS_TRACK_RETURNED_PACKETS
                if (!MINIPORT_TEST_FLAG(Miniport, fMINIPORT_INTERMEDIATE_DRIVER))
                {
                    ULONG    SL;
                    if ((SL = CURR_STACK_LOCATION(Packet)) != -1)
                    {
                        DbgPrint("Packet %p is being returned back to the non-IM miniport"
                                 " with stack location %lx.\n", Packet, SL);
                        DbgBreakPoint();
                    }

                }
#endif

#ifdef TRACK_RECEIVED_PACKETS
                if (!MINIPORT_TEST_FLAG(Miniport, fMINIPORT_DESERIALIZE) &&
                    (NDIS_GET_PACKET_STATUS(Packet) == NDIS_STATUS_RESOURCES))
                {
                    NDIS_STATUS OStatus = (NDIS_STATUS)NDIS_ORIGINAL_STATUS_FROM_PACKET(Packet);

                    if (OStatus != NDIS_STATUS_RESOURCES)
                    {
                        DbgPrint("Packet %p is being returned back to the non-deserialized miniport"
                                 " with packet status changed from %lx to NDIS_STATUS_RESOURCES.\n", Packet, OStatus);
                        DbgBreakPoint();
                    }

                }
#endif
                NDIS_APPEND_RCV_LOGFILE(Packet, Miniport, CurThread,
                                        0xD, CURR_STACK_LOCATION(Packet), NSR->RefCount, NSR->XRefCount, NDIS_GET_PACKET_STATUS(Packet));

                (*Handler)(Miniport->MiniportAdapterContext, Packet);
                if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_INTERMEDIATE_DRIVER))
                {
                    InterlockedDecrement(&Miniport->IndicatedPacketsCount);
                }
             }
            else
            {
                NDIS_APPEND_RCV_LOGFILE(Packet, Miniport, CurThread,
                                        0xE, CURR_STACK_LOCATION(Packet), NSR->RefCount, NSR->XRefCount, NDIS_GET_PACKET_STATUS(Packet));
                //
                //  Miniport is busy so we need to queue this for later.
                //
                NSR->NextPacket = Miniport->ReturnPacketsQueue;
                Miniport->ReturnPacketsQueue = Packet;

                NDISM_QUEUE_WORK_ITEM(Miniport, NdisWorkItemReturnPackets, NULL);
            }

            if (!MINIPORT_TEST_FLAG(Miniport, fMINIPORT_DESERIALIZE))
            {
                UNLOCK_MINIPORT(Miniport, LocalLock);
                NDIS_RELEASE_MINIPORT_SPIN_LOCK_DPC(Miniport);
            }
        }
    }

    LOWER_IRQL(OldIrql, DISPATCH_LEVEL);
}


VOID
FASTCALL
ndisMDeferredReturnPackets(
    IN  PNDIS_MINIPORT_BLOCK    Miniport
    )
{
    PNDIS_PACKET            Packet, NextPacket;
    PNDIS_STACK_RESERVED    NSR;
    W_RETURN_PACKET_HANDLER Handler;
#ifdef TRACK_RECEIVED_PACKETS
    PETHREAD                CurThread = PsGetCurrentThread();
//    ULONG                   CurThread = KeGetCurrentProcessorNumber();
#endif


    ASSERT_MINIPORT_LOCKED(Miniport);
    ASSERT(!MINIPORT_TEST_FLAG(Miniport, fMINIPORT_DESERIALIZE));
        
    Handler = Miniport->DriverHandle->MiniportCharacteristics.ReturnPacketHandler;

    for (Packet = Miniport->ReturnPacketsQueue;
         Packet != NULL;
         Packet = NextPacket)
    {
        NDIS_STACK_RESERVED_FROM_PACKET(Packet, &NSR)
        NextPacket = NSR->NextPacket;
        NSR->Miniport = NULL;

        POP_PACKET_STACK(Packet);


#ifdef NDIS_TRACK_RETURNED_PACKETS
        {
            ULONG    SL;
            if ((SL = CURR_STACK_LOCATION(Packet)) != -1)
            {
                DbgPrint("Packet %p is being returned back to the non-IM miniport"
                         " with stack location %lx.\n", Packet, SL);
                DbgBreakPoint();
            }

        }
#endif

#ifdef TRACK_RECEIVED_PACKETS
        if (NDIS_GET_PACKET_STATUS(Packet) == NDIS_STATUS_RESOURCES)
        {
            NDIS_STATUS OStatus = (NDIS_STATUS)NDIS_ORIGINAL_STATUS_FROM_PACKET(Packet);

            if (OStatus != NDIS_STATUS_RESOURCES)
            {
                DbgPrint("Packet %p is being returned back to the non-deserialized miniport"
                         " with packet status changed from %lx to NDIS_STATUS_RESOURCES.\n", Packet, OStatus);
                DbgBreakPoint();
            }

        }
#endif

        NDIS_APPEND_RCV_LOGFILE(Packet, Miniport, CurThread,
                                0xF, CURR_STACK_LOCATION(Packet), NSR->RefCount, NSR->XRefCount, NDIS_GET_PACKET_STATUS(Packet));


        (*Handler)(Miniport->MiniportAdapterContext, Packet);
        
        if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_INTERMEDIATE_DRIVER))
        {
            InterlockedDecrement(&Miniport->IndicatedPacketsCount);
        }

     }

    Miniport->ReturnPacketsQueue = NULL;
}


VOID
FASTCALL
ndisMAbortRequests(
    IN  PNDIS_MINIPORT_BLOCK    Miniport
    )
/*++

Routine Description:

    this routine will abort any pending requets.

Arguments:

Return Value:

Note:
    called at DPC with Miniport's lock held.

--*/
{
    PNDIS_REQUEST       Request;
    PNDIS_REQUEST       NextRequest;

    DBGPRINT_RAW(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
        ("==>ndisMAbortRequests\n"));

    //
    //  Clear the request timeout flag.
    //
    MINIPORT_CLEAR_FLAG(Miniport, fMINIPORT_REQUEST_TIMEOUT);

    //
    //  Dequeue any request work items that are queued
    //
    NDISM_DEQUEUE_WORK_ITEM(Miniport, NdisWorkItemRequest, NULL);

    Request = Miniport->PendingRequest;
    Miniport->PendingRequest = NULL;

    //
    //  Go through the pending request queue and clear it out.
    //
    for (NOTHING; Request != NULL; Request = NextRequest)
    {
        //
        //  Get a pointer to the next request before we kill the
        //  current one.
        //
        NextRequest = PNDIS_RESERVED_FROM_PNDIS_REQUEST(Request)->Next;
        PNDIS_RESERVED_FROM_PNDIS_REQUEST(Request)->Next = NULL;

        //
        //  Make this request the request in progress.
        //
        MINIPORT_SET_FLAG(Miniport, fMINIPORT_PROCESSING_REQUEST);
        Miniport->PendingRequest = Request;

        if (Request->RequestType == NdisRequestSetInformation)
        {
            ndisMSyncSetInformationComplete(Miniport, NDIS_STATUS_REQUEST_ABORTED);
        }
        else
        {
            ndisMSyncQueryInformationComplete(Miniport, NDIS_STATUS_REQUEST_ABORTED);
        }
    }

    DBGPRINT_RAW(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
            ("<==ndisMAbortRequests\n"));
}

VOID
FASTCALL
ndisMAbortPackets(
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  PNDIS_OPEN_BLOCK        pOpen OPTIONAL,
    IN  PVOID                   CancelId OPTIONAL
    )

/*++

Routine Description:

    Aborts all outstanding packets on a mini-port.

    CALLED WITH THE LOCK HELD!!

Arguments:

    Miniport - Miniport to abort.

Return Value:

    None.

--*/
{
    PNDIS_OPEN_BLOCK    Open;
    PNDIS_PACKET        OldFirstPendingPacket, NewFirstPendingPacket;
    LIST_ENTRY          SubmittedPackets;
    PLIST_ENTRY         List;
    PNDIS_PACKET        Packet;
    BOOLEAN             LookForFirstPendingPacket = FALSE;
    
    DBGPRINT_RAW(DBG_COMP_WORK_ITEM, DBG_LEVEL_INFO,
        ("==>ndisMAbortPackets\n"));

    if (CancelId == NULL)
    {
        ASSERT_MINIPORT_LOCKED(Miniport);
    }

    //
    //  Dequeue any send work items that are queued
    //
    NDISM_DEQUEUE_WORK_ITEM(Miniport, NdisWorkItemSend, NULL);

    OldFirstPendingPacket = Miniport->FirstPendingPacket;
    NewFirstPendingPacket = NULL;
    
    InitializeListHead(&SubmittedPackets);
    if (CancelId)
        LookForFirstPendingPacket = TRUE;
    
    //
    // Clear out the packet queues.
    //
    Miniport->FirstPendingPacket = NULL;

    //
    //  Go through the list of packets and return them to the bindings
    //
    while (!IsListEmpty(&Miniport->PacketList))
    {
        PNDIS_STACK_RESERVED    NSR;

        List = RemoveHeadList(&Miniport->PacketList);
        Packet = CONTAINING_RECORD(List, NDIS_PACKET, WrapperReserved);

        if (LookForFirstPendingPacket)
        {
            if (Packet != OldFirstPendingPacket)
            {
                InsertTailList(&SubmittedPackets, List);
                continue;
            }
            else
            {
                //
                // we passed and saved the packets already submitted 
                // to the miniport
                //
                LookForFirstPendingPacket = FALSE;
            }
        }

        //
        //  Get the open that the packet came from.
        //
        NDIS_STACK_RESERVED_FROM_PACKET(Packet, &NSR)
        Open = NSR->Open;
        ASSERT(VALID_OPEN(Open));

        if (CancelId)
        {
            if ((Open != pOpen) || (CancelId != NDIS_GET_PACKET_CANCEL_ID(Packet)))
            {
                if (NewFirstPendingPacket == NULL)
                {
                    //
                    // we found the first pending packet that we are going
                    // to put back after we are done
                    //
                    NewFirstPendingPacket = Packet;
                }
                //
                // put the packet back on the submitted queue
                //
                InsertTailList(&SubmittedPackets, List);
                continue;
            }
        }

        //
        // get rid of packet
        //

#if ARCNET
        //
        // Now free the arcnet header.
        //
        if ((Miniport->MediaType == NdisMediumArcnet878_2) &&
            MINIPORT_TEST_PACKET_FLAG(Packet, fPACKET_PENDING))

        {
            ndisMFreeArcnetHeader(Miniport, Packet, Open);
        }
#endif
        //
        // Set this to mark that the packet is complete
        //
        NSR->Open = MAGIC_OPEN_I(7);
        POP_PACKET_STACK(Packet);

        NDIS_RELEASE_MINIPORT_SPIN_LOCK_DPC(Miniport);

        if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_SG_LIST) &&
            (NDIS_PER_PACKET_INFO_FROM_PACKET(Packet, ScatterGatherListPacketInfo) != NULL))
        {
                ndisMFreeSGList(Miniport, Packet);
        }

        MINIPORT_CLEAR_PACKET_FLAG(Packet, fPACKET_CLEAR_ITEMS);

        (Open->SendCompleteHandler)(Open->ProtocolBindingContext,
                                    Packet,
                                    NDIS_STATUS_REQUEST_ABORTED);

        NDIS_ACQUIRE_MINIPORT_SPIN_LOCK_DPC(Miniport);

        ndisMDereferenceOpen(Open);
        
    }

    Miniport->FirstPendingPacket = NewFirstPendingPacket;

    if (CancelId)
    {
        //
        // we may have some packets that we should put back on miniport
        //
        while (!IsListEmpty(&SubmittedPackets))
        {
            List = RemoveHeadList(&SubmittedPackets);
            InsertTailList(&Miniport->PacketList, List);
        }
    }
    else
    {
        //
        // only reset this flag if we are aborting -all- the packets
        //
        MINIPORT_SET_FLAG(Miniport, fMINIPORT_RESOURCES_AVAILABLE);
    }

    DBGPRINT_RAW(DBG_COMP_WORK_ITEM, DBG_LEVEL_INFO,
        ("<==ndisMAbortPackets\n"));
}

NDIS_STATUS
ndisMProcessResetRequested(
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    OUT PBOOLEAN                pAddressingReset
    )
/*++

Routine Description:

Arguments:

Return Value:

Note: called at DPC with miniport spinlock held

--*/
{
    NDIS_STATUS         Status;

    do
    {

        //
        //  Dequeue the reset requested work item. this dequeuing will automatically
        //  queue the reset in progress work item.
        //
        NDISM_DEQUEUE_WORK_ITEM(Miniport, NdisWorkItemResetRequested, NULL);

        //
        // if adapter is getting halted, fail the reset request
        //
        if (MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_HALTING))
        {            
            MINIPORT_CLEAR_FLAG(Miniport, fMINIPORT_RESET_REQUESTED);
            Status = NDIS_STATUS_NOT_RESETTABLE;
            break;
        }

        //
        //  Set the reset in progress bit so that the send path can see it.
        //
        MINIPORT_SET_FLAG(Miniport, fMINIPORT_RESET_IN_PROGRESS);
        MINIPORT_CLEAR_FLAG(Miniport, fMINIPORT_RESET_REQUESTED);

        ndisMSwapOpenHandlers(Miniport,
                              NDIS_STATUS_RESET_IN_PROGRESS, 
                              fMINIPORT_STATE_RESETTING);

        NDIS_RELEASE_MINIPORT_SPIN_LOCK_DPC(Miniport);

        NdisMIndicateStatus(Miniport, NDIS_STATUS_RESET_START, NULL, 0);
        NdisMIndicateStatusComplete(Miniport);

        DBGPRINT_RAW(DBG_COMP_WORK_ITEM, DBG_LEVEL_INFO,
            ("    Calling miniport reset\n"));

        //
        //  Call the miniport's reset handler.
        //
        Status = (Miniport->DriverHandle->MiniportCharacteristics.ResetHandler)(pAddressingReset,
                                                                                Miniport->MiniportAdapterContext);
        NDIS_ACQUIRE_MINIPORT_SPIN_LOCK_DPC(Miniport);
    }while (FALSE);
    
    return(Status);
}


NDIS_STATUS
ndisMReset(
    IN  NDIS_HANDLE     NdisBindingHandle
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PNDIS_OPEN_BLOCK        Open = (PNDIS_OPEN_BLOCK)NdisBindingHandle;
    PNDIS_MINIPORT_BLOCK    Miniport = Open->MiniportHandle;
    NDIS_STATUS             Status;
    BOOLEAN                 FreeLock;
    KIRQL                   OldIrql;

    DBGPRINT_RAW(DBG_COMP_RESET, DBG_LEVEL_INFO,
        ("==>ndisMReset\n"));

    do
    {
        NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Miniport, &OldIrql);

        FreeLock = TRUE;

        //
        // if adapter is getting halted, fail the reset request
        //
        if (MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_HALTING))
        {            
            Status = NDIS_STATUS_NOT_RESETTABLE;
            break;
        }


        Status = NDIS_STATUS_RESET_IN_PROGRESS;

        //
        //  Is there already a reset in progress?
        //
        if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_DESERIALIZE))
        {
            if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_RESET_IN_PROGRESS))
            {
                break;
            }
        }
        else
        {
            if (NDISM_QUEUE_WORK_ITEM(Miniport,
                                      NdisWorkItemResetRequested,
                                      NdisBindingHandle) != NDIS_STATUS_SUCCESS)
            {
                break;
            }
        }

        Status = NDIS_STATUS_NOT_RESETTABLE;
        if (Miniport->DriverHandle->MiniportCharacteristics.ResetHandler != NULL)
        {
            //
            //  Update the open's references.
            //
            M_OPEN_INCREMENT_REF_INTERLOCKED(Open);
            Miniport->ResetOpen = Open;

            if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_DESERIALIZE))
            {
                BOOLEAN AddressingReset = FALSE;

                //
                //  Set the reset in progress flag.
                //
                MINIPORT_SET_FLAG(Miniport, fMINIPORT_RESET_IN_PROGRESS | fMINIPORT_CALLING_RESET);
                
                ndisMSwapOpenHandlers(Miniport, 
                                      NDIS_STATUS_RESET_IN_PROGRESS, 
                                      fMINIPORT_STATE_RESETTING);

                //
                // wait for all the requests to come back.
                // note: this is not the same as waiting for all requests to complete
                // we just make sure the original request call has come back
                //
                do
                {
                    if (Miniport->RequestCount == 0)
                    {
                        break;
                    }
                    else
                    {
                        NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);
                        NDIS_INTERNAL_STALL(50);
                        NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Miniport, &OldIrql);
                    }
                } while (TRUE);

                //
                // ok, we got the permission to reset the adapter
                // make sure it was not turned off while we were waiting
                //
                if (Miniport->CurrentDevicePowerState !=  PowerDeviceD0)
                {
                    Miniport->ResetOpen = NULL;
                    //
                    // undo the call to ndisMSwapOpenHandlers, leaving the active handlers 
                    // the fake one.
                    //
                    Miniport->XState &= ~fMINIPORT_STATE_RESETTING;
                    Miniport->FakeStatus = NDIS_STATUS_NOT_SUPPORTED;
                    
                    MINIPORT_CLEAR_FLAG(Miniport, fMINIPORT_RESET_IN_PROGRESS | fMINIPORT_CALLING_RESET);
                    Status = NDIS_STATUS_NOT_SUPPORTED;
                    ndisMDereferenceOpen(Open);
                    break;
                }

                NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);
                FreeLock = FALSE;

                NdisMIndicateStatus(Miniport, NDIS_STATUS_RESET_START, NULL, 0);
                NdisMIndicateStatusComplete(Miniport);

                DBGPRINT_RAW(DBG_COMP_WORK_ITEM, DBG_LEVEL_INFO,
                            ("Calling miniport reset\n"));

                //
                //  Call the miniport's reset handler at DPC
                //
                RAISE_IRQL_TO_DISPATCH(&OldIrql);

                Status = (Miniport->DriverHandle->MiniportCharacteristics.ResetHandler)(
                                          &AddressingReset,
                                          Miniport->MiniportAdapterContext);

                LOWER_IRQL(OldIrql, DISPATCH_LEVEL);
                
                if (NDIS_STATUS_PENDING != Status)
                {
                    NdisMResetComplete(Miniport, Status, AddressingReset);
                    Status = NDIS_STATUS_PENDING;
                }
                
            }
            else
            {
                BOOLEAN LocalLock;

                //
                //  Set the reset requested flag.
                //
                MINIPORT_SET_FLAG(Miniport, fMINIPORT_RESET_REQUESTED);

                //
                //  Grab the local lock.
                //
                LOCK_MINIPORT(Miniport, LocalLock);
                if (LocalLock)
                {
                    //
                    // If we did not lock down the miniport, then some other routine will
                    // do this processing for us.   Otherwise we need to do this processing.
                    //
                    NDISM_PROCESS_DEFERRED(Miniport);
                }

                UNLOCK_MINIPORT(Miniport, LocalLock);
                Status = NDIS_STATUS_PENDING;
            }
        }
    } while (FALSE);

    if (FreeLock)
    {
        NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);
    }

    DBGPRINT_RAW(DBG_COMP_RESET, DBG_LEVEL_INFO,
                ("<==ndisReset\n"));

    return(Status);
}


VOID
NdisMResetComplete(
    IN  NDIS_HANDLE             MiniportAdapterHandle,
    IN  NDIS_STATUS             Status,
    IN  BOOLEAN                 AddressingReset
    )
/*++

Routine Description:

    This function indicates the completion of a reset.

Arguments:

    MiniportAdapterHandle - points to the adapter block.

    Status - Status of the reset.

    AddressingReset - Do we have to submit a request to reload the address
    information.    This includes packet filter, and multicast/functional addresses.

Return Value:

    None.


--*/
{
    PNDIS_MINIPORT_BLOCK    Miniport = (PNDIS_MINIPORT_BLOCK)MiniportAdapterHandle;
    KIRQL                   OldIrql;
    BOOLEAN                 LocalLock;

    DBGPRINT_RAW(DBG_COMP_RESET, DBG_LEVEL_INFO,
        ("==>NdisMResetComplete\n"));

    ASSERT_MINIPORT_LOCKED(Miniport);

    NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Miniport, &OldIrql);


#if 0
    //
    // do not clear the CALLING_RESET flag now. if we do, it will allow
    // ndisMDispatchRequests to send down a request to the miniport that can
    // later on get aborted by Ndis in NdisMResetComplete
    //
    //
    // clear this flag here as well. if reset completed before the original
    // reset call returns, this will allow the RestoreFilter requests to go through
    //
    MINIPORT_CLEAR_FLAG(Miniport, fMINIPORT_CALLING_RESET);
#endif

    if (!MINIPORT_TEST_FLAG(Miniport, fMINIPORT_RESET_IN_PROGRESS))
    {
        BAD_MINIPORT(Miniport, "Completing reset when one is not pending");
        KeBugCheckEx(BUGCODE_ID_DRIVER,
                    (ULONG_PTR)Miniport,
                    (ULONG_PTR)Status,
                    (ULONG_PTR)AddressingReset,
                    0);
    }

    //
    //  Code that is common for synchronous and async resets.
    //
    ndisMResetCompleteStage1(Miniport, Status, AddressingReset);

    if (Miniport->WorkQueue[NdisWorkItemRequest].Next == NULL)
    {
        //
        // somehow we did not queue a workitem due to address reset flag
        //
        AddressingReset = FALSE;
    }

    if (!AddressingReset || (Status != NDIS_STATUS_SUCCESS))
    {
        //
        //  If there is no addressing reset to be done or
        //  the reset failed in some way then we tell the
        //  bindings now.
        //
        ndisMResetCompleteStage2(Miniport);
    }

    NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);

    DBGPRINT_RAW(DBG_COMP_RESET, DBG_LEVEL_INFO,
        ("<==NdisMResetComplete\n"));
}

VOID
ndisMResetCompleteStage1(
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  NDIS_STATUS             Status,
    IN  BOOLEAN                 AddressingReset
    )
/*++

Routine Description:

Arguments:

Return Value:

Note:
    Called at DPC with Miniport's lock held.

--*/
{
    
    if (NDIS_STATUS_NOT_RESETTABLE != Status)
    {
        //
        // Destroy all outstanding packets and requests.
        //
        ndisMAbortPackets(Miniport, NULL, NULL);

        ndisMAbortRequests(Miniport);

        //
        // we can clear this flag now and not any sooner. otherwise we may end up sending
        // a request down on another thread and aborting it ourselves
        //
        MINIPORT_CLEAR_FLAG(Miniport, fMINIPORT_CALLING_RESET);
        
        //
        // Check if we are going to have to reset theadapter again.
        // This happens when we are doing the reset because of a ring failure.
        //
        if (!MINIPORT_TEST_FLAG(Miniport, fMINIPORT_IGNORE_TOKEN_RING_ERRORS))
        {
            if (Miniport->TrResetRing == 1)
            {
                if (Status == NDIS_STATUS_SUCCESS)
                {
                    Miniport->TrResetRing = 0;
                }
                else
                {
                    Miniport->TrResetRing = NDIS_MINIPORT_TR_RESET_TIMEOUT;
                }
            }
        }

        //
        //  If we need to reset the miniports filter settings then
        //  queue the necessary requests & work items.
        //
        if (AddressingReset && (Status == NDIS_STATUS_SUCCESS) &&
            ((Miniport->EthDB != NULL)  ||
             (Miniport->TrDB != NULL)   ||
#if ARCNET
             (Miniport->ArcDB != NULL)  ||
#endif
             (Miniport->FddiDB != NULL)))
        {
            ndisMRestoreFilterSettings(Miniport, NULL, TRUE);
        }
    } 
    else
    {
        MINIPORT_CLEAR_FLAG(Miniport, fMINIPORT_CALLING_RESET);
    }

    //
    //  Save the reset status as it is now.
    //
    Miniport->ResetStatus = Status;
}


VOID
FASTCALL
ndisMResetCompleteStage2(
    IN  PNDIS_MINIPORT_BLOCK    Miniport
    )
/*++

Routine Description:

Arguments:

Return Value:

Note:
    Called at DPC with Miniport's lock held.

--*/
{
    PNDIS_OPEN_BLOCK Open = NULL;

    if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_DESERIALIZE))
    {
        Open = Miniport->ResetOpen;
        Miniport->ResetOpen = NULL;
    }
    else
    {
        ASSERT(Miniport->WorkQueue[NdisWorkItemResetInProgress].Next != NULL);
        NDISM_DEQUEUE_WORK_ITEM(Miniport, NdisWorkItemResetInProgress, &Open);
    }

    MINIPORT_CLEAR_FLAG(Miniport, fMINIPORT_RESET_IN_PROGRESS);

    ndisMRestoreOpenHandlers(Miniport, fMINIPORT_STATE_RESETTING);

    NDIS_RELEASE_MINIPORT_SPIN_LOCK_DPC(Miniport);

    NdisMIndicateStatus(Miniport,
                        NDIS_STATUS_RESET_END,
                        &Miniport->ResetStatus,
                        sizeof(Miniport->ResetStatus));

    NdisMIndicateStatusComplete(Miniport);

    NDIS_ACQUIRE_MINIPORT_SPIN_LOCK_DPC(Miniport);

    //
    //  If a protocol initiated the reset then notify it of the completion.
    //
    if (NULL != Open)
    {
        NDIS_RELEASE_MINIPORT_SPIN_LOCK_DPC(Miniport);

        (Open->ResetCompleteHandler)(Open->ProtocolBindingContext, Miniport->ResetStatus);

        NDIS_ACQUIRE_MINIPORT_SPIN_LOCK_DPC(Miniport);

        ndisMDereferenceOpen(Open);
    }

    //
    // if halt is waiting for this reset to complete, let it know we are done.
    //
    if (Miniport->ResetCompletedEvent)
        SET_EVENT(Miniport->ResetCompletedEvent);

}


//
//  The following routines are called in place of the original send, request,
//
NDIS_STATUS
ndisMFakeWanSend(
    IN  NDIS_HANDLE             NdisBindingHandle,
    IN  NDIS_HANDLE             NdisLinkHandle,
    IN  PVOID                   Packet
    )
{
    PNDIS_MINIPORT_BLOCK    Miniport = ((PNDIS_OPEN_BLOCK)NdisBindingHandle)->MiniportHandle;
    NDIS_STATUS             Status;

    DBGPRINT_RAW(DBG_COMP_SEND, DBG_LEVEL_INFO,
        ("==>ndisMFakeWanSend\n"));

    Status = (Miniport == NULL) ? NDIS_STATUS_FAILURE : Miniport->FakeStatus;

    DBGPRINT_RAW(DBG_COMP_SEND, DBG_LEVEL_INFO,
        ("<==ndisMFakeWanSend\n"));

    return(Status);
}

NDIS_STATUS
ndisMFakeSend(
    IN  NDIS_HANDLE             NdisBindingHandle,
    IN  PNDIS_PACKET            Packet
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PNDIS_MINIPORT_BLOCK    Miniport = ((PNDIS_OPEN_BLOCK)NdisBindingHandle)->MiniportHandle;
    NDIS_STATUS             Status;

    DBGPRINT_RAW(DBG_COMP_SEND, DBG_LEVEL_INFO,
        ("==>ndisMFakeSend\n"));

    Status = (Miniport == NULL) ? NDIS_STATUS_FAILURE : Miniport->FakeStatus;

    DBGPRINT_RAW(DBG_COMP_SEND, DBG_LEVEL_INFO,
        ("<==ndisMFakeSend\n"));

    return(Status);
}

VOID
ndisMFakeSendPackets(
    IN  NDIS_HANDLE             NdisBindingHandle,
    IN  PPNDIS_PACKET           PacketArray,
    IN  UINT                    NumberOfPackets
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PNDIS_OPEN_BLOCK        Open =  (PNDIS_OPEN_BLOCK)NdisBindingHandle;
    PNDIS_MINIPORT_BLOCK    Miniport = Open->MiniportHandle;
    NDIS_STATUS             Status;
    UINT                    c;


    DBGPRINT_RAW(DBG_COMP_SEND, DBG_LEVEL_INFO,
        ("==>ndisMFakeSendPackets\n"));

    Status = (Miniport == NULL) ? NDIS_STATUS_FAILURE : 
                                 ((Miniport->MediaType == NdisMediumArcnet878_2) ? 
                                  NDIS_STATUS_FAILURE : Miniport->FakeStatus);

    for (c = 0; c < NumberOfPackets; c++)
    {
        //
        //  For send packets we need to call the completion handler....
        //
        PNDIS_PACKET pPacket = PacketArray[c];

        MINIPORT_CLEAR_PACKET_FLAG(pPacket, fPACKET_CLEAR_ITEMS);

        (Open->SendCompleteHandler)(Open->ProtocolBindingContext, pPacket, Status);
    }

    DBGPRINT_RAW(DBG_COMP_SEND, DBG_LEVEL_INFO,
        ("<==ndisMFakeSendPackets\n"));
}


NDIS_STATUS
ndisMFakeReset(
    IN  NDIS_HANDLE             NdisBindingHandle
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    NDIS_STATUS Status;

    DBGPRINT_RAW(DBG_COMP_RESET, DBG_LEVEL_INFO,
        ("==>ndisMFakeReset\n"));

    if (((PNDIS_OPEN_BLOCK)NdisBindingHandle)->MiniportHandle == NULL)
    {
        Status = NDIS_STATUS_FAILURE;

    }
    else
    {
        Status = ((PNDIS_OPEN_BLOCK)NdisBindingHandle)->MiniportHandle->FakeStatus;
    }

    DBGPRINT_RAW(DBG_COMP_RESET, DBG_LEVEL_INFO,
        ("<==ndisMFakeReset\n"));

    return(Status);
}

NDIS_STATUS
ndisMFakeRequest(
    IN  NDIS_HANDLE             NdisBindingHandle,
    IN  PNDIS_REQUEST           NdisRequest
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    NDIS_STATUS Status;

    if (((PNDIS_OPEN_BLOCK)NdisBindingHandle)->MiniportHandle == NULL)
    {
        Status = NDIS_STATUS_FAILURE;

    }
    else
    {
        Status = ((PNDIS_OPEN_BLOCK)NdisBindingHandle)->MiniportHandle->FakeStatus;
    }

    return(Status);
}


VOID
FASTCALL
ndisMRestoreOpenHandlers(
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  UCHAR                   Flags                   
    )
/*++

Routine Description:

    This routine will restore the original open handlers to fake handlers so
    that protocol requests will be processed normally. this routine will check to 
    make sure that it can restore the handlers to the original ones because there
    may be more than one reasons to use the fake handlers

Arguments:

    Miniport    -   Pointer to the miniport block.
    Flags           Flags to -clear-

Return Value:
    None

Notes:
    Called with Miniport SpinLock held.

--*/
{
    PNDIS_OPEN_BLOCK    Open;

    DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
            ("==>ndisMRestoreOpenHandlers: Miniport %p, Current fake status %lx, Flags %lx\n",
            Miniport,
            Miniport->FakeStatus,
            (ULONG)Flags));

    ASSERT(CURRENT_IRQL == DISPATCH_LEVEL);
    
    do
    {
        //
        // check to make sure we can restore the handlers
        //
        Miniport->XState &= ~Flags;

        if (Miniport->XState)
        {
            //
            //
            DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
            ("ndisMRestoreOpenHandlers: Keeping the fake handlers on Miniport %p, State flags %lx\n", 
                                    Miniport, Miniport->XState));

            //
            // if the only reason we are here is because media is disconnected 
            // make sure we put back the request handler
            //
            if ((Miniport->XState & fMINIPORT_STATE_MEDIA_DISCONNECTED) == fMINIPORT_STATE_MEDIA_DISCONNECTED)
            {
                for (Open = Miniport->OpenQueue;
                     Open != NULL;
                     Open = Open->MiniportNextOpen)
                {
                    
                    if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_DESERIALIZE))
                    {
                        Open->RequestHandler = ndisMRequestX;
                    }
                    else
                    {
                        Open->RequestHandler = ndisMRequest;
                    }
                }
            }
            break;
        }
                
        for (Open = Miniport->OpenQueue;
             Open != NULL;
             Open = Open->MiniportNextOpen)
        {
            //
            //  Restore the handlers.
            //
            Open->SendHandler = (SEND_HANDLER)Miniport->SavedSendHandler;
            Open->SendPacketsHandler = (SEND_PACKETS_HANDLER)Miniport->SavedSendPacketsHandler;
            Open->CancelSendPacketsHandler = (W_CANCEL_SEND_PACKETS_HANDLER)Miniport->SavedCancelSendPacketsHandler;
            
            if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_DESERIALIZE))
            {
                Open->RequestHandler = ndisMRequestX;
            }
            else
            {
                Open->RequestHandler = ndisMRequest;
            }
            
            Open->ResetHandler = ndisMReset;
        }
    } while (FALSE);
    
    DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
        ("<==ndisMRestoreOpenHandlers: Miniport %p\n", Miniport));
    
    return;

}


VOID
FASTCALL
ndisMSwapOpenHandlers(
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  NDIS_STATUS             Status,
    IN  UCHAR                   Flags
    )
/*++

Routine Description:

    This routine will swap the miniport handlers to fake handlers so that
    protocol requests will be failed cleanly.

Arguments:

    Miniport    -   Pointer to the miniport block.

Return Value:
    None

Notes: Called with miniport SpinLock held

--*/
{
    PNDIS_OPEN_BLOCK    Open;
    
    DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
            ("==>ndisMSwapOpenHandlers: Miniport %p, FakeStatus %lx, Flags %lx\n",
                Miniport,
                Status,
                (ULONG)Flags));

    ASSERT(CURRENT_IRQL == DISPATCH_LEVEL);

    Miniport->XState |= Flags;

    //
    //  Save the status that should be returned whenever someone
    //  calls one of the routines below.
    //
    Miniport->FakeStatus = Status;

    //
    //  Swap the handlers for each open queued to the miniport.
    //
    for (Open = Miniport->OpenQueue;
         Open != NULL;
         Open = Open->MiniportNextOpen)
    {

        //  
        //  Swap the send handler.
        //
        if ((NdisMediumWan == Miniport->MediaType) &&
            !MINIPORT_TEST_FLAG(Miniport, (fMINIPORT_IS_CO | fMINIPORT_IS_NDIS_5)))
        {
            Open->SendHandler   = (PVOID)ndisMFakeWanSend;
        }
        else
        {
            Open->SendHandler   = (PVOID)ndisMFakeSend;
        }

        //
        //  Swap the send packets handler.
        //
        Open->SendPacketsHandler = ndisMFakeSendPackets;

        //
        //  Swap the reset handler.
        //
        Open->ResetHandler = ndisMFakeReset;

        //
        //  Swap the request handler, but not for media-sense case
        //
        if (NDIS_STATUS_NO_CABLE != Status)
        {
            Open->RequestHandler = ndisMFakeRequest;
        }

        //
        // set the cancel send packets ahndler to null
        //
        Open->CancelSendPacketsHandler = NULL;

        //
        // swap the indicate packet handler
        //
        
    }
    
    DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
            ("<==ndisMSwapOpenHandlers: Miniport %p\n", Miniport));
}


VOID
NdisMSetAttributes(
    IN  NDIS_HANDLE             MiniportAdapterHandle,
    IN  NDIS_HANDLE             MiniportAdapterContext,
    IN  BOOLEAN                 BusMaster,
    IN  NDIS_INTERFACE_TYPE     AdapterType
    )
/*++

Routine Description:

    This function sets specific information about an adapter.

Arguments:

    MiniportAdapterHandle - points to the adapter block.

    MiniportAdapterContext - Context to pass to all Miniport driver functions.

    BusMaster - TRUE if a bus mastering adapter.

Return Value:

    None.


--*/
{
    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
            ("==>NdisMSetAttributes: Miniport %p\n", MiniportAdapterHandle));

    NdisMSetAttributesEx(MiniportAdapterHandle,
                         MiniportAdapterContext,
                         0,
                         BusMaster ? NDIS_ATTRIBUTE_BUS_MASTER : 0,
                         AdapterType);

    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
            ("<==NdisMSetAttributes: Miniport %p\n", MiniportAdapterHandle));
}

VOID
NdisMSetAttributesEx(
    IN  NDIS_HANDLE             MiniportAdapterHandle,
    IN  NDIS_HANDLE             MiniportAdapterContext,
    IN  UINT                    CheckForHangTimeInSeconds OPTIONAL,
    IN  ULONG                   AttributeFlags,
    IN  NDIS_INTERFACE_TYPE     AdapterType  OPTIONAL
    )
{
    PNDIS_MINIPORT_BLOCK    Miniport = (PNDIS_MINIPORT_BLOCK)MiniportAdapterHandle;
    PNDIS_OPEN_BLOCK        Open;

    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
            ("==>NdisMSetAttributesEx: Miniport %p\n", Miniport));

    Miniport->MiniportAdapterContext = MiniportAdapterContext;
    Miniport->MiniportAttributes = AttributeFlags;
    
    //
    //  In the case of a first time initialization this will fail out since there
    //  will not be any opens.  In the case of a second time initialization (power up)
    //  we need to fix up the existing open block's adapter contexts.
    //
    for (Open = Miniport->OpenQueue;
         Open != NULL;
         Open = Open->MiniportNextOpen)
    {
        Open->MiniportAdapterContext = MiniportAdapterContext;
    }

    Miniport->AdapterType = AdapterType;

    //
    // Set the new timeout value in ticks. Each tick is NDIS_CFHANG_TIME_SECONDS long.
    //
    if (CheckForHangTimeInSeconds != 0)
    {
        if (CheckForHangTimeInSeconds < NDIS_CFHANG_TIME_SECONDS)
        {
            CheckForHangTimeInSeconds = NDIS_CFHANG_TIME_SECONDS;
        }
        Miniport->CFHangTicks = (USHORT)(CheckForHangTimeInSeconds/NDIS_CFHANG_TIME_SECONDS);
    }


    //
    // Is this a bus master.
    //
    if (AttributeFlags & NDIS_ATTRIBUTE_BUS_MASTER)
    {
        MINIPORT_SET_FLAG(Miniport, fMINIPORT_BUS_MASTER);
        Miniport->InfoFlags |= NDIS_MINIPORT_BUS_MASTER;
    }

    //
    // Should we ignore the packet queues?
    //
    if (AttributeFlags & NDIS_ATTRIBUTE_IGNORE_PACKET_TIMEOUT)
    {
        MINIPORT_SET_FLAG(Miniport, fMINIPORT_IGNORE_PACKET_QUEUE);
        Miniport->InfoFlags |= NDIS_MINIPORT_IGNORE_PACKET_QUEUE;
    }

    //
    // Should we ignore the request queues?
    //
    if (AttributeFlags & NDIS_ATTRIBUTE_IGNORE_REQUEST_TIMEOUT)
    {
        MINIPORT_SET_FLAG(Miniport, fMINIPORT_IGNORE_REQUEST_QUEUE);
        Miniport->InfoFlags |= NDIS_MINIPORT_IGNORE_REQUEST_QUEUE;
    }

    //
    // Should we ignore token ring errors?
    //
    if (AttributeFlags & NDIS_ATTRIBUTE_IGNORE_TOKEN_RING_ERRORS)
    {
        MINIPORT_SET_FLAG(Miniport, fMINIPORT_IGNORE_TOKEN_RING_ERRORS);
        Miniport->InfoFlags |= NDIS_MINIPORT_IGNORE_TOKEN_RING_ERRORS;
    }

    //
    // Is this an intermediate miniport?
    //
    if (AttributeFlags & NDIS_ATTRIBUTE_INTERMEDIATE_DRIVER)
    {
        MINIPORT_SET_FLAG(Miniport, fMINIPORT_INTERMEDIATE_DRIVER);
        Miniport->InfoFlags |= NDIS_MINIPORT_INTERMEDIATE_DRIVER;
    }

    //
    // does the device wants us not to halt it on suspend?
    //
    if (AttributeFlags & NDIS_ATTRIBUTE_NO_HALT_ON_SUSPEND)
    {
        MINIPORT_PNP_SET_FLAG(Miniport, fMINIPORT_NO_HALT_ON_SUSPEND);
        Miniport->InfoFlags |= NDIS_MINIPORT_NO_HALT_ON_SUSPEND;
    }

    //
    // fMINIPORT_IS_CO flag is set on miniports -before- initializing the miniport based
    // on existence of some handlers in driver characteristics
    // allow the driver to override this. do this -before- the test for deserialization.
    // if these drivers are deserialized, they have to make it explicit.
    //
    if (AttributeFlags & NDIS_ATTRIBUTE_NOT_CO_NDIS)
    {
        MINIPORT_CLEAR_FLAG(Miniport, fMINIPORT_IS_CO);
    }
    
    if (((AttributeFlags & NDIS_ATTRIBUTE_DESERIALIZE) ||
         MINIPORT_TEST_FLAG(Miniport, fMINIPORT_IS_CO)))
    {
        MINIPORT_SET_FLAG(Miniport, fMINIPORT_DESERIALIZE);
        Miniport->InfoFlags |= NDIS_MINIPORT_DESERIALIZE;
        
        NdisInitializeTimer(&Miniport->WakeUpDpcTimer,
                            ndisMWakeUpDpcX,
                            Miniport);


        //
        // Reset handlers to the de-serialized ones
        //

        Miniport->SendCompleteHandler = ndisMSendCompleteX;
    }
    else
    {
        NdisInitializeTimer(&Miniport->WakeUpDpcTimer,
                            ndisMWakeUpDpc,
                            Miniport);
    }
    

    if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_IS_CO))
    {
        CoReferencePackage();
    }

    if ((Miniport->DriverHandle->MiniportCharacteristics.MajorNdisVersion > 5) ||
        ((Miniport->DriverHandle->MiniportCharacteristics.MajorNdisVersion == 5) &&
         (Miniport->DriverHandle->MiniportCharacteristics.MinorNdisVersion >= 1)) ||
        (AttributeFlags & NDIS_ATTRIBUTE_USES_SAFE_BUFFER_APIS))
    {
        MINIPORT_SET_SEND_FLAG(Miniport, fMINIPORT_SEND_DO_NOT_MAP_MDLS);
        Miniport->InfoFlags |= NDIS_MINIPORT_USES_SAFE_BUFFER_APIS;
    }

    if (AttributeFlags & NDIS_ATTRIBUTE_SURPRISE_REMOVE_OK)
    {
        Miniport->InfoFlags |= NDIS_MINIPORT_SURPRISE_REMOVE_OK;
    }
    
    DBGPRINT_RAW(DBG_COMP_CONFIG, DBG_LEVEL_INFO,
            ("<==NdisMSetAttributesEx: Miniport %p\n", Miniport));
}

NDIS_STATUS
NdisMSetMiniportSecondary(
    IN  NDIS_HANDLE             MiniportHandle,
    IN  NDIS_HANDLE             PrimaryMiniportHandle
    )
/*++

Routine Description:

    This associates a miniport with another marking current miniport as secondary
    with the link to primary. The secondary has no bindings and opens blocked.

Arguments:

    MiniportHandle        - Miniport block for this miniport
    PrimaryMiniportHandle - Miniport block for the primary miniport

Return Value:

    NDIS_STATUS_SUCCESS or NDIS_STATUS_NOT_SUPPORTED

--*/
{
    PNDIS_MINIPORT_BLOCK    Miniport, PrimaryMiniport;
    PNDIS_OPEN_BLOCK        Open;
    NDIS_STATUS             Status = NDIS_STATUS_SUCCESS;

    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
            ("==>NdisMSetMiniportSecondary: Miniport %p, PrimaryMiniport %p\n",
                MiniportHandle, PrimaryMiniportHandle));

    Miniport = (PNDIS_MINIPORT_BLOCK)MiniportHandle;
    ASSERT(Miniport != NULL);

    PrimaryMiniport = (PNDIS_MINIPORT_BLOCK)PrimaryMiniportHandle;
    ASSERT(PrimaryMiniport != NULL);

    if ((Miniport->DriverHandle != PrimaryMiniport->DriverHandle)   ||
        (Miniport->PrimaryMiniport != Miniport))
    {
        Status = NDIS_STATUS_NOT_SUPPORTED;
    }
    else
    {
        MINIPORT_SET_FLAG(Miniport, fMINIPORT_SECONDARY);
        ndisCloseMiniportBindings(Miniport);

        Miniport->PrimaryMiniport = PrimaryMiniport;
    }

    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
            ("<==NdisMSetMiniportSecondary: Miniport %p, PrimaryMiniport %p\n",
                MiniportHandle, PrimaryMiniportHandle));

    return Status;
}


NDIS_STATUS
NdisMPromoteMiniport(
    IN  NDIS_HANDLE             MiniportHandle
    )
/*++

Routine Description:

    This promotes a secondary miniport to a primary. Fails if there already
    is a primary.

Arguments:

    MiniportHandle        - Miniport block for this miniport

Return Value:

    NDIS_STATUS_SUCCESS or NDIS_STATUS_FAILURE

--*/
{
    PNDIS_MINIPORT_BLOCK    Miniport;
    PNDIS_WORK_ITEM         WorkItem;
    NDIS_STATUS             Status = NDIS_STATUS_SUCCESS;
    PNDIS_MINIPORT_BLOCK    OldPrimaryMiniport;
    PNDIS_M_DRIVER_BLOCK    MiniBlock;
    KIRQL                   OldIrql;


    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
            ("==>NdisMPromoteMiniport: Miniport %p\n", MiniportHandle));

    Miniport = (PNDIS_MINIPORT_BLOCK)MiniportHandle;
    ASSERT(Miniport != NULL);

    do
    {
        NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Miniport, &OldIrql);
        
        if (!MINIPORT_TEST_FLAG(Miniport, fMINIPORT_SECONDARY) ||
            (Miniport->PrimaryMiniport == Miniport) ||
            MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_REJECT_REQUESTS))
        {
            Status = NDIS_STATUS_NOT_SUPPORTED;
            NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);
            break;
        }

        WorkItem = ALLOC_FROM_POOL(sizeof(NDIS_WORK_ITEM), NDIS_TAG_WORK_ITEM);
        if (WorkItem == NULL)
        {
            Status = NDIS_STATUS_RESOURCES;
            NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);
            break;
        }

        OldPrimaryMiniport = Miniport->PrimaryMiniport;
        NdisInitializeWorkItem(WorkItem, ndisQueuedCheckAdapterBindings, Miniport);
        MINIPORT_CLEAR_FLAG(Miniport, fMINIPORT_SECONDARY);
        MINIPORT_PNP_SET_FLAG(Miniport, fMINIPORT_QUEUED_BIND_WORKITEM);
        MINIPORT_INCREMENT_REF(Miniport);
        NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);

        //
        // Make all miniports belonging to this cluster point
        // to this new primary (including this primary itself).
        //
        
        MiniBlock = Miniport->DriverHandle;
        ACQUIRE_SPIN_LOCK(&MiniBlock->Ref.SpinLock, &OldIrql);

        {
            PNDIS_MINIPORT_BLOCK    TmpMiniport = NULL;

            for (TmpMiniport = MiniBlock->MiniportQueue;
                 TmpMiniport != NULL;
                 TmpMiniport = TmpMiniport->NextMiniport)
            {
                if (TmpMiniport->PrimaryMiniport == OldPrimaryMiniport)
                {
                    //
                    // TmpMiniport was a secondary of the old primary
                    // Lets make it point to the new Primary (this miniport)
                    //
                    TmpMiniport->PrimaryMiniport = Miniport;
                }
            }
        }

        RELEASE_SPIN_LOCK(&MiniBlock->Ref.SpinLock, OldIrql);

        //
        // Queue a work-item to notify protocols and make sure the miniport does not go
        // away while we are waiting
        //
        NdisScheduleWorkItem(WorkItem);

    } while (FALSE);

    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
            ("<==NdisMPromoteMiniport: Miniport %p\n", MiniportHandle));

    return Status;
}

NDIS_STATUS
ndisQueueBindWorkitem(
    IN  PNDIS_MINIPORT_BLOCK    Miniport
    )
/*++

Routine Description:
    This routine queues a workitem to handle initiating the bindings
    between a miniport and the protocols.
    
Arguments:
    Miniport
    
Return Value:
    NDIS_STATUS_SUCCESS if the workitem is successfully queued.

--*/

{
    PNDIS_WORK_ITEM WorkItem;
    NDIS_STATUS     Status;
    KIRQL           OldIrql;
    
    DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
        ("==>ndisQueueBindWorkitem: Miniport %p\n", Miniport));

    do
    {
        WorkItem = ALLOC_FROM_POOL(sizeof(NDIS_WORK_ITEM), NDIS_TAG_WORK_ITEM);

        if (WorkItem == NULL)
        {
            Status = NDIS_STATUS_RESOURCES;
            break;
        }

        PnPReferencePackage();
        
        NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Miniport, &OldIrql);
        
        if (MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_REJECT_REQUESTS))
        {
            //
            // miniport is halting or halted. abort
            //
            Status = NDIS_STATUS_ADAPTER_NOT_FOUND;
            NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);
        }
        else
        {
            MINIPORT_PNP_SET_FLAG(Miniport, fMINIPORT_QUEUED_BIND_WORKITEM);

            MINIPORT_INCREMENT_REF(Miniport);
            NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);
            
            WorkItem->Routine = (NDIS_PROC)ndisQueuedCheckAdapterBindings;
            WorkItem->Context = (PVOID)Miniport;

            INITIALIZE_WORK_ITEM((PWORK_QUEUE_ITEM)WorkItem->WrapperReserved,
                                 ndisWorkItemHandler,
                                 WorkItem);

            XQUEUE_WORK_ITEM((PWORK_QUEUE_ITEM)WorkItem->WrapperReserved, 
                              CriticalWorkQueue);                                    
            
            Status = NDIS_STATUS_SUCCESS;
        }
    
        PnPDereferencePackage();
        
    }while (FALSE);

    DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
        ("<==ndisQueueBindWorkitem: Miniport %p, Status %lx\n", Miniport, Status));

    return Status;
}

VOID
ndisQueuedCheckAdapterBindings(
    IN  PNDIS_WORK_ITEM     pWorkItem,
    IN  PVOID               Context
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PNDIS_MINIPORT_BLOCK    Miniport = (PNDIS_MINIPORT_BLOCK)Context;
    NTSTATUS                NtStatus;
    KIRQL                   OldIrql;
    
    DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
        ("==>ndisQueuedCheckAdapterBindings: Miniport %p\n", Miniport));

    PnPReferencePackage();
    
    do
    {
        NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Miniport, &OldIrql);
        
        if (MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_REJECT_REQUESTS) ||
            MINIPORT_TEST_FLAG(Miniport, fMINIPORT_SECONDARY)           ||
            ((Miniport->PnPDeviceState != NdisPnPDeviceStarted) &&
            (Miniport->PnPDeviceState != NdisPnPDeviceQueryStopped) &&
            (Miniport->PnPDeviceState != NdisPnPDeviceQueryRemoved)))
        {
            MINIPORT_PNP_CLEAR_FLAG(Miniport, fMINIPORT_QUEUED_BIND_WORKITEM);
            
            if (Miniport->QueuedBindingCompletedEvent)
            {
                SET_EVENT(Miniport->QueuedBindingCompletedEvent);
            }
            
        }
        else
        {
            NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);


            ndisCheckAdapterBindings(Miniport, NULL);
            
            //
            // Set the device class association so that people can reference this.
            //
            NtStatus = IoSetDeviceInterfaceState(&Miniport->SymbolicLinkName, TRUE);

            if (!NT_SUCCESS(NtStatus))
            {
                DBGPRINT(DBG_COMP_PNP, DBG_LEVEL_ERR,
                    ("ndisQueuedCheckAdapterBindings: IoSetDeviceInterfaceState failed: Miniport %p, Status %lx\n", Miniport, NtStatus));
            }
            
            NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Miniport, &OldIrql);
            
            MINIPORT_PNP_CLEAR_FLAG(Miniport, fMINIPORT_QUEUED_BIND_WORKITEM);

            if (Miniport->QueuedBindingCompletedEvent)
            {
                SET_EVENT(Miniport->QueuedBindingCompletedEvent);
            }
            
        }
    
        NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);
    }while (FALSE);

    PnPDereferencePackage();


    MINIPORT_DECREMENT_REF(Miniport);

    FREE_POOL(pWorkItem);
    
    DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
        ("<==ndisQueuedCheckAdapterBindings: Miniport %p\n", Miniport));
}


BOOLEAN
ndisIsMiniportStarted(
    IN PNDIS_MINIPORT_BLOCK             Miniport
    )
/*++

Routine Description:

    this routine checks to make sure the miniport has been initialized by walking
    the miniport queue on the driver
    returns TRUE is the Miniport has been started, otherwise returns FALSE

Arguments:

    Miniport    -   Miniport

Return Value:

    TRUE if started, FALSE otherwise

--*/
{

    PNDIS_M_DRIVER_BLOCK    MiniBlock;
    PNDIS_MINIPORT_BLOCK    TmpMiniport = NULL;
    KIRQL                   OldIrql;

    DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
        ("==>ndisIsMiniportStarted: Miniport %p\n", Miniport));

    //
    // find the miniport on driver queue
    //
    MiniBlock = Miniport->DriverHandle;

    if (MiniBlock)
    {
        PnPReferencePackage();

        ACQUIRE_SPIN_LOCK(&MiniBlock->Ref.SpinLock, &OldIrql);

        for (TmpMiniport = MiniBlock->MiniportQueue;
             TmpMiniport != NULL;
             TmpMiniport = TmpMiniport->NextMiniport)
        {
            if (TmpMiniport == Miniport)
            {
                break;
            }
        }

        RELEASE_SPIN_LOCK(&MiniBlock->Ref.SpinLock, OldIrql);

        PnPDereferencePackage();
    }


    DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
        ("<==ndisIsMiniportStarted: Miniport %p, Started %lx\n", Miniport, (TmpMiniport == Miniport)));

    return (TmpMiniport == Miniport);
}

BOOLEAN
FASTCALL
ndisQueueOpenOnMiniport(
    IN  PNDIS_MINIPORT_BLOCK        Miniport,
    IN  PNDIS_OPEN_BLOCK            Open
    )

/*++

Routine Description:

    inserts an open block to the list of opens for a Miniport.

Arguments:

    OpenP - The open block to be queued.
    Miniport - The Miniport block to queue it on.

    NOTE: called with miniport lock held. for serialized miniports, the local lock is held as well

Return Value:

    None.

--*/
{
    BOOLEAN rc;

    DBGPRINT_RAW(DBG_COMP_BIND, DBG_LEVEL_INFO,
        ("==>ndisQueueOpenOnMiniport: Miniport %p, Open %p\n", Miniport, Open));

    //
    // we can not reference the package here because this routine can
    // be claled at raised IRQL.
    // make sure the PNP package has been referenced already
    //
    ASSERT(ndisPkgs[NPNP_PKG].ReferenceCount > 0);
    
    if ((Miniport->PnPDeviceState != NdisPnPDeviceStarted) &&
        (Miniport->PnPDeviceState != NdisPnPDeviceQueryStopped) &&
        (Miniport->PnPDeviceState != NdisPnPDeviceQueryRemoved))
    {
        DBGPRINT_RAW(DBG_COMP_BIND, DBG_LEVEL_INFO,
            ("ndisQueueOpenOnMiniport: failing open because the miniport is not started, Miniport %p, Open %p\n", Miniport, Open));
        rc = FALSE;
    }
    else
    {
        Open->MiniportNextOpen = Miniport->OpenQueue;
        Miniport->OpenQueue = Open;
        Miniport->NumOpens++;
        ndisUpdateCheckForLoopbackFlag(Miniport);
        rc = TRUE;
    }
    
    DBGPRINT_RAW(DBG_COMP_BIND, DBG_LEVEL_INFO,
        ("<==ndisQueueOpenOnMiniport: Miniport %p, Open %p, rc %lx\n", Miniport, Open, rc));

    return rc;
}

/*++

VOID
ndisMSetIndicatePacketHandler(
    IN  PNDIS_MINIPORT_BLOCK    Miniport
    )

this function sets the Miniport's indicate packet handler either during 
initial initialization or after a media re-connect status indication
can be called at DPC

--*/

VOID
ndisMSetIndicatePacketHandler(
    IN  PNDIS_MINIPORT_BLOCK    Miniport
    )
{
    KIRQL   OldIrql;
    
    NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Miniport, &OldIrql);
    //
    // set the PacketIndicateHandler and SavedPacketIndicateHandler
    // 
    switch(Miniport->MediaType)
    {
      case NdisMedium802_3:
        Miniport->SavedPacketIndicateHandler =  ethFilterDprIndicateReceivePacket;
        break;

      case NdisMedium802_5:
        Miniport->SavedPacketIndicateHandler =  trFilterDprIndicateReceivePacket;
        break;

      case NdisMediumFddi:
        Miniport->SavedPacketIndicateHandler =  fddiFilterDprIndicateReceivePacket;
        break;

#if ARCNET
      case NdisMediumArcnet878_2:
        Miniport->SavedPacketIndicateHandler =  ethFilterDprIndicateReceivePacket;
        Miniport->SendPacketsHandler = ndisMFakeSendPackets;
        break;
#endif

      case NdisMediumWan:
        break;

      case NdisMediumIrda:
      case NdisMediumWirelessWan:
      case NdisMediumLocalTalk:
        //
        // fall through
        //
      default:
        Miniport->SavedPacketIndicateHandler = ndisMIndicatePacket;
        break;
    }

    if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_MEDIA_CONNECTED))
    {
        Miniport->PacketIndicateHandler = Miniport->SavedPacketIndicateHandler;
    }
    
    NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);
}

BOOLEAN
ndisReferenceOpenByHandle(
    PNDIS_OPEN_BLOCK    Open,
    BOOLEAN             fRef
    )

{
    KIRQL               OldIrql;
    PNDIS_OPEN_BLOCK    *ppOpen;
    BOOLEAN             rc = FALSE;

    
    ACQUIRE_SPIN_LOCK(&ndisGlobalOpenListLock, &OldIrql);

    for (ppOpen = &ndisGlobalOpenList; *ppOpen != NULL; ppOpen = &(*ppOpen)->NextGlobalOpen)
    {
        if (*ppOpen == Open)
        {
            ACQUIRE_SPIN_LOCK_DPC(&Open->SpinLock)

            if (fRef)
            {
                if ((!MINIPORT_TEST_FLAG(Open, fMINIPORT_OPEN_CLOSING)) &&
                    (Open->References != 0))
                {
                    M_OPEN_INCREMENT_REF_INTERLOCKED(Open);
                    rc = TRUE;
                }
            }
            else
            {
                rc = TRUE;
            }
            
            RELEASE_SPIN_LOCK_DPC(&Open->SpinLock);

            break;
        }
    }

    RELEASE_SPIN_LOCK(&ndisGlobalOpenListLock, OldIrql);

    return rc;
}

BOOLEAN
ndisRemoveOpenFromGlobalList(
    IN  PNDIS_OPEN_BLOCK    Open
    )
{
    PNDIS_OPEN_BLOCK    *ppOpen;
    KIRQL               OldIrql;
    BOOLEAN             rc = FALSE;
    
    ACQUIRE_SPIN_LOCK(&ndisGlobalOpenListLock, &OldIrql);
    
    for (ppOpen = &ndisGlobalOpenList; *ppOpen != NULL; ppOpen = &(*ppOpen)->NextGlobalOpen)
    {
        if (*ppOpen == Open)
        {
            *ppOpen = Open->NextGlobalOpen;
            rc = TRUE;
            break;
        }
    }
    
    RELEASE_SPIN_LOCK(&ndisGlobalOpenListLock, OldIrql);

    return rc;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ndis\sys\minint.c ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation

Module Name:

    miniport.c

Abstract:

    NDIS miniport wrapper functions

Author:

    Sean Selitrennikoff (SeanSe) 05-Oct-93
    Jameel Hyder (JameelH) Re-organization 01-Jun-95

Environment:

    Kernel mode, FSD

Revision History:

--*/

#include <precomp.h>
#pragma hdrstop

//
//  Define the module number for debug code.
//
#define MODULE_NUMBER   MODULE_MININT

/////////////////////////////////////////////////////////////////////
//
//  HALT / CLOSE CODE
//
/////////////////////////////////////////////////////////////////////

BOOLEAN
FASTCALL
ndisMKillOpen(
    IN  PNDIS_OPEN_BLOCK        Open
    )

/*++

Routine Description:

    Closes an open. Used when NdisCloseAdapter is called.

Arguments:

    Open - The open to be closed.

Return Value:

    TRUE if the open finished, FALSE if it pended.

Comments:
    called at passive level -without- miniport's lock held.

--*/
{
    PNDIS_MINIPORT_BLOCK    Miniport = Open->MiniportHandle;
    PNDIS_OPEN_BLOCK        tmpOpen;
    ULONG                   newWakeUpEnable;
    BOOLEAN                 rc = TRUE;
    NDIS_STATUS             Status;
    UINT                    OpenRef;
    KIRQL                   OldIrql;
    
    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
        ("==>ndisMKillOpen: Open %p\n", Open));

    ASSERT(ndisPkgs[NPNP_PKG].ReferenceCount > 0);
    PnPReferencePackage();

    KeRaiseIrql(DISPATCH_LEVEL, &OldIrql);
    NDIS_ACQUIRE_MINIPORT_SPIN_LOCK_DPC(Miniport);
    //
    // Find the Miniport open block
    //
    for (tmpOpen = Miniport->OpenQueue;
         tmpOpen != NULL;
         tmpOpen = tmpOpen->MiniportNextOpen)
    {
        if (tmpOpen == Open)
        {
            break;
        }
    }
    NDIS_RELEASE_MINIPORT_SPIN_LOCK_DPC(Miniport);

    do
    {
        ASSERT(tmpOpen != NULL);
        if (tmpOpen == NULL)
            break;
            
        //
        // See if this open is already closing.
        //
        ACQUIRE_SPIN_LOCK_DPC(&Open->SpinLock);
        if (MINIPORT_TEST_FLAG(Open, fMINIPORT_OPEN_CLOSING))
        {
            RELEASE_SPIN_LOCK_DPC(&Open->SpinLock);
            break;
        }

        //
        // Indicate to others that this open is closing.
        //
        MINIPORT_SET_FLAG(Open, fMINIPORT_OPEN_CLOSING);
        RELEASE_SPIN_LOCK_DPC(&Open->SpinLock);

        NDIS_ACQUIRE_MINIPORT_SPIN_LOCK_DPC(Miniport);
        BLOCK_LOCK_MINIPORT_DPC_L(Miniport);


        //
        // Remove us from the filter package
        //
        switch (Miniport->MediaType)
        {
#if ARCNET
            case NdisMediumArcnet878_2:
                if (!MINIPORT_TEST_FLAG(Open,
                                        fMINIPORT_OPEN_USING_ETH_ENCAPSULATION))
                {
                    Status = ArcDeleteFilterOpenAdapter(Miniport->ArcDB,
                                                        Open->FilterHandle,
                                                        NULL);
                    break;
                }

                //
                //  If we're using encapsulation then we
                //  didn't open an arcnet filter but rather
                //  an ethernet filter.                         
                //
#endif
            case NdisMedium802_3:
                Status = EthDeleteFilterOpenAdapter(Miniport->EthDB,
                                                    Open->FilterHandle);
                break;

            case NdisMedium802_5:
                Status = TrDeleteFilterOpenAdapter(Miniport->TrDB,
                                                   Open->FilterHandle);
                break;

            case NdisMediumFddi:
                Status = FddiDeleteFilterOpenAdapter(Miniport->FddiDB,
                                                     Open->FilterHandle);
                break;

            default:
                Status = nullDeleteFilterOpenAdapter(Miniport->NullDB,
                                                     Open->FilterHandle);
                break;
        }

        //
        //  Fix up flags that are dependant on all opens.
        //

        //
        // preserve the state of NDIS_PNP_WAKE_UP_MAGIC_PACKET and NDIS_PNP_WAKE_UP_LINK_CHANGE flag
        //
        newWakeUpEnable = Miniport->WakeUpEnable & (NDIS_PNP_WAKE_UP_MAGIC_PACKET | NDIS_PNP_WAKE_UP_LINK_CHANGE);

        for (tmpOpen = Miniport->OpenQueue;
             tmpOpen != NULL;
             tmpOpen = tmpOpen->MiniportNextOpen)
        {
            //
            //  We don't want to include the open that is closing.
            //
            if (tmpOpen != Open)
            {
                newWakeUpEnable |= tmpOpen->WakeUpEnable;
            }
        }

        //
        //  Reset the filter settings. Just to be sure that we remove the
        //  opens settings at the adapter.
        //
        switch (Miniport->MediaType)
        {
            case NdisMedium802_3:
            case NdisMedium802_5:
            case NdisMediumFddi:
#if ARCNET
            case NdisMediumArcnet878_2:
#endif
                if (!MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_REMOVE_IN_PROGRESS | fMINIPORT_PM_HALTED))
                {
                    ndisMRestoreFilterSettings(Miniport, Open, FALSE);
                }
                
                break;
        }

        DBGPRINT_RAW(DBG_COMP_BIND, DBG_LEVEL_INFO,
                ("!=0 Open 0x%x References 0x%x\n", Open, Open->References));

        if (Status != NDIS_STATUS_CLOSING_INDICATING)
        {
            //
            // Otherwise the close action routine will fix this up.
            //
            DBGPRINT_RAW(DBG_COMP_BIND, DBG_LEVEL_INFO,
                    ("- Open 0x%x Reference 0x%x\n", Open, Open->References));

            M_OPEN_DECREMENT_REF_INTERLOCKED(Open, OpenRef);
        }

        rc = FALSE;
        if (OpenRef != 0)
        {
            ndisMDoRequests(Miniport);
            UNLOCK_MINIPORT_L(Miniport);
        }
        else
        {
            UNLOCK_MINIPORT_L(Miniport);
            ndisMFinishClose(Open);
        }

        NDIS_RELEASE_MINIPORT_SPIN_LOCK_DPC(Miniport);

    } while (FALSE);

    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
        ("<==ndisMKillOpen: Open %p, rc %ld\n", Open, rc));

    KeLowerIrql(OldIrql);
    
    PnPDereferencePackage();

    return rc;
}

VOID
FASTCALL
ndisMFinishClose(
    IN  PNDIS_OPEN_BLOCK        Open
    )
/*++

Routine Description:

    Finishes off a close adapter call. it is called when the ref count on the open
    drops to zero.

    CALLED WITH LOCK HELD!!

Arguments:

    Miniport - The mini-port the open is queued on.

    Open - The open to close

Return Value:

    None.

Comments:
    Called at DPC with Miniport's SpinLock held


--*/
{
    PNDIS_MINIPORT_BLOCK    Miniport = Open->MiniportHandle;
    PKEVENT                 pAllOpensClosedEvent;
    KIRQL                   OldIrql;

    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
        ("==>ndisMFinishClose: MOpen %p\n", Open));

    ASSERT(MINIPORT_TEST_FLAG(Open, fMINIPORT_OPEN_CLOSING));

    MINIPORT_INCREMENT_REF(Miniport);
    

    //
    // free any memory allocated to Vcs
    //
    if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_IS_CO))
    {
        ndisMCoFreeResources(Open);
    }

    ndisDeQueueOpenOnProtocol(Open, Open->ProtocolHandle);

    if (Open->Flags & fMINIPORT_OPEN_PMODE)
    {
        Miniport->PmodeOpens --;
        Open->Flags &= ~fMINIPORT_OPEN_PMODE;
        NDIS_CHECK_PMODE_OPEN_REF(Miniport);
        ndisUpdateCheckForLoopbackFlag(Miniport);            
    }
    
    ndisDeQueueOpenOnMiniport(Open, Miniport);
    
    Open->QC.Status = NDIS_STATUS_SUCCESS;
    
    INITIALIZE_WORK_ITEM(&Open->QC.WorkItem,
                         ndisMQueuedFinishClose,
                         Open);
    QUEUE_WORK_ITEM(&Open->QC.WorkItem, DelayedWorkQueue);
    
    MINIPORT_DECREMENT_REF(Miniport);
    
    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
        ("<==ndisMFinishClose: Mopen %p\n", Open));
}


VOID
ndisMQueuedFinishClose(
    IN  PNDIS_OPEN_BLOCK        Open
    )
/*++

Routine Description:

    Finishes off a close adapter call.

Arguments:

    Miniport - The mini-port the open is queued on.

    Open - The open to close

Return Value:

    None.


--*/
{
    PNDIS_MINIPORT_BLOCK    Miniport = Open->MiniportHandle;
    PKEVENT                 pAllOpensClosedEvent;
    KIRQL                   OldIrql;
    BOOLEAN                 FreeOpen;
    
    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
        ("==>ndisMQueuedFinishClose: Open %p, Miniport %p\n", Open, Miniport));

    ASSERT(ndisPkgs[NPNP_PKG].ReferenceCount > 0);

    MINIPORT_INCREMENT_REF(Miniport);

    (Open->ProtocolHandle->ProtocolCharacteristics.CloseAdapterCompleteHandler) (
            Open->ProtocolBindingContext,
            NDIS_STATUS_SUCCESS);

    MINIPORT_DECREMENT_REF(Miniport);
    ndisDereferenceProtocol(Open->ProtocolHandle);
    if (Open->CloseCompleteEvent != NULL)
    {
        SET_EVENT(Open->CloseCompleteEvent);
    }


    NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Miniport, &OldIrql);

    if ((Miniport->AllOpensClosedEvent != NULL) &&
        (Miniport->OpenQueue == NULL))
    {
        pAllOpensClosedEvent = Miniport->AllOpensClosedEvent;
        Miniport->AllOpensClosedEvent = NULL;
        SET_EVENT(pAllOpensClosedEvent);
    }
    

    ACQUIRE_SPIN_LOCK_DPC(&Open->SpinLock);
    
    if (MINIPORT_TEST_FLAG(Open, fMINIPORT_OPEN_DONT_FREE))
    {
        //
        // there is an unbind attempt in progress
        // do not free the Open block and let unbind know that
        // you've seen its message
        //
        MINIPORT_SET_FLAG(Open, fMINIPORT_OPEN_CLOSE_COMPLETE);
        FreeOpen = FALSE;
    }
    else
    {
        FreeOpen = TRUE;
    }
      
    
    RELEASE_SPIN_LOCK_DPC(&Open->SpinLock);
    
    NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);

    if (FreeOpen)
    {
        ndisRemoveOpenFromGlobalList(Open);
        FREE_POOL(Open);
    }
        
    //
    // finaly decrement the ref count we added for miniport
    //
    MINIPORT_DECREMENT_REF(Miniport);

    //
    // decrement the ref count for PnP package that we added when noticed
    // close is going to pend.
    //
    PnPDereferencePackage();

    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
        ("<==ndisMQueuedFinishClose: Open %p, Miniport %p\n", Open, Miniport));
}


VOID
FASTCALL
ndisDeQueueOpenOnMiniport(
    IN  PNDIS_OPEN_BLOCK            OpenP,
    IN  PNDIS_MINIPORT_BLOCK        Miniport
    )

/*++

Routine Description:


Arguments:


Return Value:

Note: Called with Miniport lock held.


--*/
{
    KIRQL   OldIrql;
    
    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
        ("==>ndisDeQueueOpenOnMiniport: MOpen %p, Miniport %p\n", OpenP, Miniport));

    //
    // we can not reference the package here because this routine can
    // be called at raised IRQL.
    // make sure the PNP package has been referenced already
    //
    ASSERT(ndisPkgs[NPNP_PKG].ReferenceCount > 0);

    //
    // Find the open on the queue, and remove it.
    //

    if (Miniport->OpenQueue == OpenP)
    {
        Miniport->OpenQueue = OpenP->MiniportNextOpen;
        Miniport->NumOpens--;
    }
    else
    {
        PNDIS_OPEN_BLOCK PP = Miniport->OpenQueue;

        while ((PP != NULL) && (PP->MiniportNextOpen != OpenP))
        {
            PP = PP->MiniportNextOpen;
        }
        if (PP == NULL)
        {
#if TRACK_MOPEN_REFCOUNTS
            DbgPrint("Ndis:ndisDeQueueOpenOnMiniport Open %p is -not- on Miniport %p\n", OpenP, Miniport);
            DbgBreakPoint();
#endif
        }
        else
        {
            PP->MiniportNextOpen = PP->MiniportNextOpen->MiniportNextOpen;
            Miniport->NumOpens--;
        }
    }
    ndisUpdateCheckForLoopbackFlag(Miniport);

    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
        ("<==ndisDeQueueOpenOnMiniport: MOpen %p, Miniport %p\n", OpenP, Miniport));
}


BOOLEAN
FASTCALL
ndisQueueMiniportOnDriver(
    IN PNDIS_MINIPORT_BLOCK     Miniport,
    IN PNDIS_M_DRIVER_BLOCK     MiniBlock
    )

/*++

Routine Description:

    Adds an mini-port to a list of mini-port for a driver.

Arguments:

    Miniport - The mini-port block to queue.
    MiniBlock - The driver block to queue it to.

Return Value:

    FALSE if the driver is closing.
    TRUE otherwise.

--*/

{
    KIRQL   OldIrql;
    BOOLEAN rc = TRUE;
    
    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
        ("==>ndisQueueMiniportOnDriver: Miniport %p, MiniBlock %p\n", Miniport, MiniBlock));

    PnPReferencePackage();

    do
    {
        ACQUIRE_SPIN_LOCK(&MiniBlock->Ref.SpinLock, &OldIrql);


        //
        // Make sure the driver is not closing.
        //

        if (MiniBlock->Ref.Closing)
        {
            RELEASE_SPIN_LOCK(&MiniBlock->Ref.SpinLock, OldIrql);
            rc = FALSE;
            break;
        }

        //
        // Add this adapter at the head of the queue
        //
        Miniport->NextMiniport = MiniBlock->MiniportQueue;
        MiniBlock->MiniportQueue = Miniport;
        
        RELEASE_SPIN_LOCK(&MiniBlock->Ref.SpinLock, OldIrql);
        
    } while (FALSE);

    PnPDereferencePackage();
    
    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
        ("<==ndisQueueMiniportOnDriver: Miniport %p, MiniBlock %p, rc %ld\n", Miniport, MiniBlock, rc));
        
    return rc;
}


VOID FASTCALL
FASTCALL
ndisDeQueueMiniportOnDriver(
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  PNDIS_M_DRIVER_BLOCK    MiniBlock
    )

/*++

Routine Description:

    Removes an mini-port from a list of mini-port for a driver.

Arguments:

    Miniport - The mini-port block to dequeue.
    MiniBlock - The driver block to dequeue it from.

Return Value:

    None.

--*/

{
    PNDIS_MINIPORT_BLOCK *ppQ;
    KIRQL   OldIrql;
    
    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
        ("==>ndisDeQueueMiniportOnDriver, Miniport %p, MiniBlock %p\n", Miniport, MiniBlock));

    PnPReferencePackage();

    ACQUIRE_SPIN_LOCK(&MiniBlock->Ref.SpinLock, &OldIrql);

    //
    // Find the driver on the queue, and remove it.
    //
    for (ppQ = &MiniBlock->MiniportQueue;
         *ppQ != NULL;
         ppQ = &(*ppQ)->NextMiniport)
    {
        if (*ppQ == Miniport)
        {
            *ppQ = Miniport->NextMiniport;
            break;
        }
    }

    ASSERT(*ppQ == Miniport->NextMiniport);

    //
    // the same miniport can be queued on the driver again without all the fields
    // getting re-initialized so zero out the linkage
    //
    Miniport->NextMiniport = NULL;

    RELEASE_SPIN_LOCK(&MiniBlock->Ref.SpinLock, OldIrql);

    PnPDereferencePackage();

    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
        ("<==ndisDeQueueMiniportOnDriver: Miniport %p, MiniBlock %p\n", Miniport, MiniBlock));
}


VOID
FASTCALL
ndisDereferenceDriver(
    IN  PNDIS_M_DRIVER_BLOCK    MiniBlock,
    IN  BOOLEAN                 fGlobalLockHeld
    )
/*++

Routine Description:

    Removes a reference from the mini-port driver, deleting it if the count goes to 0.

Arguments:

    Miniport - The mini-port block to dereference.

Return Value:

    None.

--*/
{
    KIRQL   OldIrql;

    DBGPRINT_RAW(DBG_COMP_REF, DBG_LEVEL_INFO,
        ("==>ndisDereferenceDriver: MiniBlock %p\n", MiniBlock));
        
    
    if (ndisDereferenceRef(&(MiniBlock)->Ref))
    {
        PNDIS_M_DRIVER_BLOCK            *ppMB;
        PNDIS_PENDING_IM_INSTANCE       ImInstance, NextImInstance;
    
        //
        // Remove it from the global list.
        //
        ASSERT (IsListEmpty(&MiniBlock->DeviceList));

        if (!fGlobalLockHeld)
        {
            ACQUIRE_SPIN_LOCK(&ndisMiniDriverListLock, &OldIrql);
        }

        for (ppMB = &ndisMiniDriverList; *ppMB != NULL; ppMB = &(*ppMB)->NextDriver)
        {
            if (*ppMB == MiniBlock)
            {
                *ppMB = MiniBlock->NextDriver;
                DEREF_NDIS_DRIVER_OBJECT();
                break;
            }
        }

        if (!fGlobalLockHeld)
        {
            RELEASE_SPIN_LOCK(&ndisMiniDriverListLock, OldIrql);
        }

        //
        // Free the wrapper handle allocated during NdisInitializeWrapper
        //
        if (MiniBlock->NdisDriverInfo != NULL)
        {
            FREE_POOL(MiniBlock->NdisDriverInfo);
            MiniBlock->NdisDriverInfo = NULL;
        }

        //
        // Free any queued device-instance blocks
        //
        for (ImInstance = MiniBlock->PendingDeviceList;
             ImInstance != NULL;
             ImInstance = NextImInstance)
        {
            NextImInstance = ImInstance->Next;
            FREE_POOL(ImInstance);
        }

        //
        // set the event holding unload to go through
        //
        SET_EVENT(&MiniBlock->MiniportsRemovedEvent);
    }

    DBGPRINT_RAW(DBG_COMP_REF, DBG_LEVEL_INFO,
                ("<==ndisDereferenceDriver: MiniBlock %p\n", MiniBlock));
}

#if DBG

BOOLEAN
FASTCALL
ndisReferenceMiniport(
    IN  PNDIS_MINIPORT_BLOCK    Miniport
    )
{
    BOOLEAN rc;

    DBGPRINT(DBG_COMP_REF, DBG_LEVEL_INFO,("==>ndisReferenceMiniport: Miniport %p\n", Miniport));

    rc = ndisReferenceULongRef(&(Miniport->Ref));

    DBGPRINT_RAW(DBG_COMP_REF, DBG_LEVEL_INFO,
        ("    ndisReferenceMiniport: Miniport %p, Ref = %lx\n", Miniport, Miniport->Ref.ReferenceCount));

    DBGPRINT(DBG_COMP_REF, DBG_LEVEL_INFO,("<==ndisReferenceMiniport: Miniport %p\n", Miniport));

    return(rc);
}
#endif

#ifdef TRACK_MINIPORT_REFCOUNTS
BOOLEAN
ndisReferenceMiniportAndLog(
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  UINT                    Line,
    IN  UINT                    Module
    )
{
    BOOLEAN rc;
    rc = ndisReferenceMiniport(Miniport);
    M_LOG_MINIPORT_INCREMENT_REF(Miniport, Line, Module);
    return rc;
}

BOOLEAN
ndisReferenceMiniportAndLogCreate(
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  UINT                    Line,
    IN  UINT                    Module,
    IN  PIRP                    Irp
    )
{
    BOOLEAN rc;
    rc = ndisReferenceMiniport(Miniport);
    M_LOG_MINIPORT_INCREMENT_REF_CREATE(Miniport, Line, Module);
    return rc;
}
#endif

VOID
FASTCALL
ndisDereferenceMiniport(
    IN  PNDIS_MINIPORT_BLOCK    Miniport
    )
/*++

Routine Description:

    Removes a reference from the mini-port driver, deleting it if the count goes to 0.

Arguments:

    Miniport - The mini-port block to dereference.

Return Value:

    None.

--*/
{
    PSINGLE_LIST_ENTRY      Link;
    PNDIS_MINIPORT_WORK_ITEM WorkItem;
    UINT                    c;
    PKEVENT                 RemoveReadyEvent = NULL;
    KEVENT                  RequestsCompletedEvent;
    KIRQL                   OldIrql;
    BOOLEAN                 fTimerCancelled;
    BOOLEAN                 rc;
    
    DBGPRINT_RAW(DBG_COMP_REF, DBG_LEVEL_INFO,
        ("==>ndisDereferenceMiniport: Miniport %p\n", Miniport));
        
    rc = ndisDereferenceULongRef(&(Miniport)->Ref);
    
    DBGPRINT_RAW(DBG_COMP_REF, DBG_LEVEL_INFO,
        ("    ndisDereferenceMiniport:Miniport %p, Ref = %lx\n", Miniport, Miniport->Ref.ReferenceCount));
    
    if (rc)
    {
        DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
            ("    ndisDereferenceMiniport:Miniport %p, Ref = %lx\n", Miniport, Miniport->Ref.ReferenceCount));

        RemoveReadyEvent = Miniport->RemoveReadyEvent;
        
        if (ndisIsMiniportStarted(Miniport) && (Miniport->Ref.ReferenceCount == 0))
        {
            ASSERT (Miniport->Interrupt == NULL);

            if (Miniport->EthDB)
            {
                EthDeleteFilter(Miniport->EthDB);
                Miniport->EthDB = NULL;
            }

            if (Miniport->TrDB)
            {
                TrDeleteFilter(Miniport->TrDB);
                Miniport->TrDB = NULL;
            }

            if (Miniport->FddiDB)
            {
                FddiDeleteFilter(Miniport->FddiDB);
                Miniport->FddiDB = NULL;
            }

#if ARCNET
            if (Miniport->ArcDB)
            {
                ArcDeleteFilter(Miniport->ArcDB);
                Miniport->ArcDB = NULL;
            }
#endif

            if (Miniport->AllocatedResources)
            {
                FREE_POOL(Miniport->AllocatedResources);
            }
            
            //
            //  Free the work items that are currently on the work queue that are
            //  allocated outside of the miniport block
            //
            for (c = NUMBER_OF_SINGLE_WORK_ITEMS; c < NUMBER_OF_WORK_ITEM_TYPES; c++)
            {
                //
                //  Free all work items on the current queue.
                //
                while (Miniport->WorkQueue[c].Next != NULL)
                {
                    Link = PopEntryList(&Miniport->WorkQueue[c]);
                    WorkItem = CONTAINING_RECORD(Link, NDIS_MINIPORT_WORK_ITEM, Link);
                    FREE_POOL(WorkItem);
                }
            }
        
            if (Miniport->OidList != NULL)
            {
                FREE_POOL(Miniport->OidList);
                Miniport->OidList = NULL;
            }

            //
            //  Did we set a timer for the link change power down?
            //

            if (MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_MEDIA_DISCONNECT_WAIT))
            {
                MINIPORT_PNP_CLEAR_FLAG(Miniport, fMINIPORT_MEDIA_DISCONNECT_WAIT);
                MINIPORT_PNP_SET_FLAG(Miniport, fMINIPORT_MEDIA_DISCONNECT_CANCELLED);
                
                NdisCancelTimer(&Miniport->MediaDisconnectTimer, &fTimerCancelled);
                if (!fTimerCancelled)
                {
                    NdisStallExecution(Miniport->MediaDisconnectTimeOut * 1000000);
                }
            }
            
#if ARCNET
            //
            //  Is there an arcnet lookahead buffer allocated?
            //
            if ((Miniport->MediaType == NdisMediumArcnet878_2) &&
                (Miniport->ArcBuf != NULL))
            {
                if (Miniport->ArcBuf->ArcnetLookaheadBuffer != NULL)
                {
                    FREE_POOL(Miniport->ArcBuf->ArcnetLookaheadBuffer);
                }
                FREE_POOL(Miniport->ArcBuf);
                Miniport->ArcBuf = NULL;
            }
#endif
            //
            // if the adapter uses SG DMA, we have to dereference the DMA adapter
            // to get it freed
            //
            if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_SG_LIST))
            {
                ndisDereferenceDmaAdapter(Miniport);
            }

            INITIALIZE_EVENT(&RequestsCompletedEvent);

            NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Miniport, &OldIrql);
            Miniport->DmaResourcesReleasedEvent = &RequestsCompletedEvent;
            
            if (Miniport->SystemAdapterObject != NULL)
            {
                LARGE_INTEGER TimeoutValue;

                TimeoutValue.QuadPart = Int32x32To64(30000, -10000); // Make it 30 second

                NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);
                
                if (!NT_SUCCESS(WAIT_FOR_OBJECT(&RequestsCompletedEvent, &TimeoutValue)))
                {
#if DBG
                    ASSERTMSG("Ndis: Miniport is going away without releasing all resources.\n", (Miniport->DmaAdapterRefCount == 0));
#endif
                }
                
            }
            else
            {
                NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);
            }

            Miniport->DmaResourcesReleasedEvent = NULL;
            
            //
            //  Free the map of custom GUIDs to OIDs.
            //
            if (NULL != Miniport->pNdisGuidMap)
            {
                FREE_POOL(Miniport->pNdisGuidMap);
                Miniport->pNdisGuidMap = NULL;
            }
            
            if (Miniport->FakeMac != NULL)
            {
                FREE_POOL(Miniport->FakeMac);
                Miniport->FakeMac = NULL;
            }

            if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_IS_CO))
            {
                CoDereferencePackage();
            }

            ndisDeQueueMiniportOnDriver(Miniport, Miniport->DriverHandle);
            ndisDereferenceDriver(Miniport->DriverHandle, FALSE);
            NdisMDeregisterAdapterShutdownHandler(Miniport);
            IoUnregisterShutdownNotification(Miniport->DeviceObject);

            if (Miniport->SymbolicLinkName.Buffer != NULL)
            {
                RtlFreeUnicodeString(&Miniport->SymbolicLinkName);
                Miniport->SymbolicLinkName.Buffer = NULL;
            }
            
            MiniportDereferencePackage();
        }
        
        if (RemoveReadyEvent)
        {
            SET_EVENT(RemoveReadyEvent);
        }
    }
    
    DBGPRINT_RAW(DBG_COMP_REF, DBG_LEVEL_INFO,
        ("<==ndisDereferenceMiniport: Miniport %p\n", Miniport));
}


VOID
FASTCALL
ndisMCommonHaltMiniport(
    IN  PNDIS_MINIPORT_BLOCK    Miniport
    )
/*++

Routine Description:

    This is common code for halting a miniport.  There are two different paths
    that will call this routine: 1) from a normal unload. 2) from an adapter
    being transitioned to a low power state.

Arguments:

Return Value:

--*/
{
    KIRQL           OldIrql;
    BOOLEAN         Canceled;
    PNDIS_AF_LIST   MiniportAfList, pNext;
    KEVENT          RequestsCompletedEvent;
    FILTER_PACKET_INDICATION_HANDLER PacketIndicateHandler;

    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
        ("==>ndisMCommonHaltMiniport: Miniport %p\n", Miniport));

    PnPReferencePackage();
    
    //
    // wait for outstanding resets to complete
    //
    BLOCK_LOCK_MINIPORT_LOCKED(Miniport, OldIrql);
    MINIPORT_PNP_SET_FLAG(Miniport, fMINIPORT_HALTING | fMINIPORT_REJECT_REQUESTS);
    
    if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_RESET_IN_PROGRESS))
    {
        INITIALIZE_EVENT(&RequestsCompletedEvent);
        Miniport->ResetCompletedEvent = &RequestsCompletedEvent;
    }
    UNLOCK_MINIPORT_L(Miniport);
    NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);

    if (Miniport->ResetCompletedEvent)
        WAIT_FOR_OBJECT(&RequestsCompletedEvent, NULL);
    
    Miniport->ResetCompletedEvent = NULL;

    //
    // if we have an outstanding queued workitem to initialize the bindings
    // wait for it to fire
    //
    BLOCK_LOCK_MINIPORT_LOCKED(Miniport, OldIrql);
    
    if (MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_QUEUED_BIND_WORKITEM))
    {
        INITIALIZE_EVENT(&RequestsCompletedEvent);
        Miniport->QueuedBindingCompletedEvent = &RequestsCompletedEvent;
    }
    UNLOCK_MINIPORT_L(Miniport);
    NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);

    if (Miniport->QueuedBindingCompletedEvent)
        WAIT_FOR_OBJECT(&RequestsCompletedEvent, NULL);
    
    Miniport->QueuedBindingCompletedEvent = NULL;
    
    IoSetDeviceInterfaceState(&Miniport->SymbolicLinkName, FALSE);
    
    //
    //  Deregister with WMI
    //
    IoWMIRegistrationControl(Miniport->DeviceObject, WMIREG_ACTION_DEREGISTER);

    NdisCancelTimer(&Miniport->WakeUpDpcTimer, &Canceled);
    if (!Canceled)
    {
        NdisStallExecution(NDIS_MINIPORT_WAKEUP_TIMEOUT * 1000);
    }

    BLOCK_LOCK_MINIPORT_LOCKED(Miniport, OldIrql);
    if (Miniport->PendingRequest != NULL)
    {
        INITIALIZE_EVENT(&RequestsCompletedEvent);
        Miniport->AllRequestsCompletedEvent = &RequestsCompletedEvent;
    }
    UNLOCK_MINIPORT_L(Miniport);
    NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);

    if (Miniport->AllRequestsCompletedEvent)
        WAIT_FOR_OBJECT(&RequestsCompletedEvent, NULL);
    
    Miniport->AllRequestsCompletedEvent = NULL;

    if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_INTERMEDIATE_DRIVER))
    {
        PacketIndicateHandler = Miniport->PacketIndicateHandler;
        Miniport->PacketIndicateHandler = ndisMDummyIndicatePacket;
        while (Miniport->IndicatedPacketsCount != 0)
        {
            NdisMSleep(1000);
        }
    }
    
    (Miniport->DriverHandle->MiniportCharacteristics.HaltHandler)(Miniport->MiniportAdapterContext);

    if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_INTERMEDIATE_DRIVER))
    {
        Miniport->PacketIndicateHandler = PacketIndicateHandler;
    }
    
    MINIPORT_PNP_CLEAR_FLAG(Miniport, fMINIPORT_HALTING);
    
    ASSERT(Miniport->TimerQueue == NULL);
    ASSERT (Miniport->Interrupt == NULL);
    ASSERT(Miniport->MapRegisters == NULL);

    //
    // check for memory leak
    //
    if (Miniport == ndisMiniportTrackAlloc)
    {
        ASSERT(IsListEmpty(&ndisMiniportTrackAllocList));
        ndisMiniportTrackAlloc = NULL;
    }

    //
    // zero out statistics
    //
    ZeroMemory(&Miniport->NdisStats, sizeof(Miniport->NdisStats));
    
    if ((Miniport->TimerQueue != NULL) || (Miniport->Interrupt != NULL))
    {
        if (Miniport->Interrupt != NULL)
        {
            BAD_MINIPORT(Miniport, "Unloading without deregistering interrupt");
        }
        else
        {
            BAD_MINIPORT(Miniport, "Unloading without deregistering timer");
        }
        KeBugCheckEx(BUGCODE_ID_DRIVER,
                     (ULONG_PTR)Miniport,
                     (ULONG_PTR)Miniport->TimerQueue,
                     (ULONG_PTR)Miniport->Interrupt,
                     0);
    }

    BLOCK_LOCK_MINIPORT_LOCKED(Miniport, OldIrql);

    ndisMAbortPackets(Miniport, NULL, NULL);

    //
    //  Dequeue any request work items that are queued
    //
    NDISM_DEQUEUE_WORK_ITEM(Miniport, NdisWorkItemRequest, NULL);
    ndisMAbortRequests(Miniport);

    //
    // Free up any AFs registered by this miniport
    //
    for (MiniportAfList = Miniport->CallMgrAfList, Miniport->CallMgrAfList = NULL;
         MiniportAfList != NULL;
         MiniportAfList = pNext)
    {
        pNext = MiniportAfList->NextAf;
        FREE_POOL(MiniportAfList);
    }

    UNLOCK_MINIPORT_L(Miniport);
    NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);
    
    PnPDereferencePackage();

    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
        ("<==ndisMCommonHaltMiniport: Miniport %p\n", Miniport));
}


VOID
FASTCALL
ndisMHaltMiniport(
    IN  PNDIS_MINIPORT_BLOCK    Miniport
    )

/*++

Routine Description:

    Does all the clean up for a mini-port.

Arguments:

    Miniport - pointer to the mini-port to halt

Return Value:

    None.

--*/

{
    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
        ("==>ndisMHaltMiniport: Miniport %p\n", Miniport));

    do
    {
        //
        // If the Miniport is already closing, return.
        //
        if (!ndisCloseULongRef(&Miniport->Ref))
        {
            break;
        }
        
        //
        // if the miniport is not already halted becuase of a PM event
        // halt it here
        //
        if (!MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_PM_HALTED))
        {
            //
            //  Common halt code.
            //
            ndisMCommonHaltMiniport(Miniport);

            //
            // If a shutdown handler was registered then deregister it.
            //
            NdisMDeregisterAdapterShutdownHandler(Miniport);
        }
        
        MINIPORT_DECREMENT_REF(Miniport);
    } while (FALSE);
    
    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
        ("<==ndisMHaltMiniport: Miniport %p\n", Miniport));
}

VOID
ndisMUnload(
    IN  PDRIVER_OBJECT          DriverObject
    )
/*++

Routine Description:

    This routine is called when a driver is supposed to unload.

Arguments:

    DriverObject - the driver object for the mac that is to unload.

Return Value:

    None.

--*/
{
    PNDIS_M_DRIVER_BLOCK MiniBlock, Tmp, IoMiniBlock;
    PNDIS_MINIPORT_BLOCK Miniport, NextMiniport;
    KIRQL                OldIrql;
    
#if TRACK_UNLOAD
    DbgPrint("ndisMUnload: DriverObject %p\n", DriverObject);
#endif

    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
        ("==>ndisMUnload: DriverObject %p\n", DriverObject));

    PnPReferencePackage();
    
    do
    {
        //
        // Search for the driver
        //

        IoMiniBlock = (PNDIS_M_DRIVER_BLOCK)IoGetDriverObjectExtension(DriverObject,
                                                                     (PVOID)NDIS_PNP_MINIPORT_DRIVER_ID);
                                                                     
        if (IoMiniBlock && !(IoMiniBlock->Flags & fMINIBLOCK_TERMINATE_WRAPPER_UNLOAD))
        {
            IoMiniBlock->Flags |= fMINIBLOCK_IO_UNLOAD;
        }

        ACQUIRE_SPIN_LOCK(&ndisMiniDriverListLock, &OldIrql);

        MiniBlock = ndisMiniDriverList;

        while (MiniBlock != (PNDIS_M_DRIVER_BLOCK)NULL)
        {
            if (MiniBlock->NdisDriverInfo->DriverObject == DriverObject)
            {
                break;
            }

            MiniBlock = MiniBlock->NextDriver;
        }

        RELEASE_SPIN_LOCK(&ndisMiniDriverListLock, OldIrql);

#if TRACK_UNLOAD
        DbgPrint("ndisMUnload: MiniBlock %p\n", MiniBlock);
#endif

        if (MiniBlock == (PNDIS_M_DRIVER_BLOCK)NULL)
        {
            //
            // It is already gone.  Just return.
            //
            break;
        }
        
        ASSERT(MiniBlock == IoMiniBlock);
        
        DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
            ("  ndisMUnload: MiniBlock %p\n", MiniBlock));

        MiniBlock->Flags |= fMINIBLOCK_UNLOADING;

        //
        // Now remove the last reference (this will remove it from the list)
        //
        // ASSERT(MiniBlock->Ref.ReferenceCount == 1);

        //
        // If this is an intermediate driver and wants to be called to do unload handling, allow him
        //
        if (MiniBlock->UnloadHandler != NULL)
        {
            (*MiniBlock->UnloadHandler)(DriverObject);
        }

        if (MiniBlock->AssociatedProtocol != NULL)
        {
            MiniBlock->AssociatedProtocol->AssociatedMiniDriver = NULL;
            MiniBlock->AssociatedProtocol = NULL;
        }
        
        ndisDereferenceDriver(MiniBlock, FALSE);

        //
        // Wait for all adapters to be gonzo.
        //
        WAIT_FOR_OBJECT(&MiniBlock->MiniportsRemovedEvent, NULL);
        RESET_EVENT(&MiniBlock->MiniportsRemovedEvent);

#if TRACK_UNLOAD
        ACQUIRE_SPIN_LOCK(&ndisMiniDriverListLock, &OldIrql);

        for (Tmp = ndisMiniDriverList; Tmp != NULL; Tmp = Tmp->NextDriver)
        {
            ASSERT (Tmp != MiniBlock);
            if (Tmp == MiniBlock)
            {
                DbgPrint("NdisMUnload: MiniBlock %p is getting unloaded but it is still on ndisMiniDriverList\n",
                            MiniBlock);
                            
                KeBugCheckEx(BUGCODE_ID_DRIVER,
                     (ULONG_PTR)MiniBlock,
                     (ULONG_PTR)MiniBlock->Ref.ReferenceCount,
                     0,
                     0);

            }
        }

        RELEASE_SPIN_LOCK(&ndisMiniDriverListLock, OldIrql);
#endif

    //
    // check to make sure that the driver has freed all the memory it allocated
    //
    if (MiniBlock == ndisDriverTrackAlloc)
    {
        ASSERT(IsListEmpty(&ndisDriverTrackAllocList));
        ndisDriverTrackAlloc = NULL;
    }

    } while (FALSE);
    
    PnPDereferencePackage();

    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
        ("<==ndisMUnload: DriverObject %p, MiniBlock %p\n", DriverObject, MiniBlock));
}


/////////////////////////////////////////////////////////////////////
//
//  PLUG-N-PLAY CODE
//
/////////////////////////////////////////////////////////////////////


NDIS_STATUS
FASTCALL
ndisCloseMiniportBindings(
    IN  PNDIS_MINIPORT_BLOCK    Miniport
    )
/*++

Routine Description:

    Unbind all protocols from this miniport and finally unload it.

Arguments:

    Miniport - The Miniport to unload.

Return Value:

    None.

--*/
{
    KIRQL                   OldIrql;
    PNDIS_OPEN_BLOCK        Open, TmpOpen;
    NDIS_BIND_CONTEXT       UnbindContext;
    NDIS_STATUS             UnbindStatus;
    KEVENT                  CloseCompleteEvent;
    KEVENT                  AllOpensClosedEvent;
    PKEVENT                 pAllOpensClosedEvent;
    
    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
            ("==>ndisCloseMiniportBindings, Miniport %p\n", Miniport));

    PnPReferencePackage();

    //
    // if we have an outstanding queued workitem to initialize the bindings
    // wait for it to fire
    //
    BLOCK_LOCK_MINIPORT_LOCKED(Miniport, OldIrql);
    
    if (MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_QUEUED_BIND_WORKITEM))
    {
        INITIALIZE_EVENT(&AllOpensClosedEvent);
        Miniport->QueuedBindingCompletedEvent = &AllOpensClosedEvent;
    }
    UNLOCK_MINIPORT_L(Miniport);
    NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);

    if (Miniport->QueuedBindingCompletedEvent)
        WAIT_FOR_OBJECT(&AllOpensClosedEvent, NULL);
    
    Miniport->QueuedBindingCompletedEvent = NULL;
    
    INITIALIZE_EVENT(&AllOpensClosedEvent);
    INITIALIZE_EVENT(&CloseCompleteEvent);

    NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Miniport, &OldIrql);

    if ((Miniport->OpenQueue != NULL) && (Miniport->AllOpensClosedEvent == NULL))
    {
        Miniport->AllOpensClosedEvent = &AllOpensClosedEvent;
    }

    pAllOpensClosedEvent = Miniport->AllOpensClosedEvent;
    
        
    next:

    //
    // Walk the list of open bindings on this miniport and ask the protocols to
    // unbind from them.
    //
    for (Open = Miniport->OpenQueue;
         Open != NULL;
         Open = Open->MiniportNextOpen)
    {
        ACQUIRE_SPIN_LOCK_DPC(&Open->SpinLock);
        if (!MINIPORT_TEST_FLAG(Open, (fMINIPORT_OPEN_CLOSING | fMINIPORT_OPEN_PROCESSING)))
        {
            MINIPORT_SET_FLAG(Open, fMINIPORT_OPEN_PROCESSING);
            if (!MINIPORT_TEST_FLAG(Open, fMINIPORT_OPEN_UNBINDING))
            {
                MINIPORT_SET_FLAG(Open, fMINIPORT_OPEN_UNBINDING | fMINIPORT_OPEN_DONT_FREE);
                Open->CloseCompleteEvent = &CloseCompleteEvent;
                RELEASE_SPIN_LOCK_DPC(&Open->SpinLock);
                break;
            }
#if DBG         
            else
            {
                DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_INFO,
                    ("ndisCloseMiniportBindings: Open %p is already Closing, Flags %lx\n", 
                    Open, Open->Flags));

            }
#endif
        }
        RELEASE_SPIN_LOCK_DPC(&Open->SpinLock);
    }

    
    if (Open != NULL)
    {
        NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);

        ndisUnbindProtocol(Open, FALSE);
        
        NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Miniport, &OldIrql);

        goto next;
    }

    //
    // if we reached the end of the list but there are still some opens
    // that are not marked for closing (can happen if we skip an open only because of
    // processign flag being set) release the spinlocks, give whoever set the
    // processing flag time to release the open. then go back and try again
    // ultimately, all opens should either be marked for Unbinding or be gone
    // by themselves
    //

    for (TmpOpen = Miniport->OpenQueue;
         TmpOpen != NULL;
         TmpOpen = TmpOpen->MiniportNextOpen)
    {
        if (!MINIPORT_TEST_FLAG(TmpOpen, fMINIPORT_OPEN_UNBINDING))
            break;
    }

    if (TmpOpen != NULL)
    {
        NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);
        
        NDIS_INTERNAL_STALL(50);
        
        NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Miniport, &OldIrql);

        goto next;
    }
    
    NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);

    if (pAllOpensClosedEvent)
    {
        WAIT_FOR_OBJECT(pAllOpensClosedEvent, NULL);
    }
    
    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
            ("<==ndisCloseMiniportBindings, Miniport %p\n", Miniport));
            
    PnPDereferencePackage();

    return NDIS_STATUS_SUCCESS;
}

VOID
NdisMSetPeriodicTimer(
    IN PNDIS_MINIPORT_TIMER     Timer,
    IN UINT                     MillisecondsPeriod
    )
/*++

Routine Description:

    Sets up a periodic timer.

Arguments:

    Timer - The timer to Set.

    MillisecondsPeriod - The timer will fire once every so often.

Return Value:

--*/
{
    LARGE_INTEGER FireUpTime;

    FireUpTime.QuadPart = Int32x32To64((LONG)MillisecondsPeriod, -10000);

#if CHECK_TIMER
    if ((Timer->Dpc.DeferredRoutine != ndisMWakeUpDpc) &&
        (Timer->Dpc.DeferredRoutine != ndisMWakeUpDpcX) &&
        (Timer->Miniport->DriverHandle->Flags & fMINIBLOCK_VERIFYING))
    {
        KIRQL   OldIrql;
        PNDIS_MINIPORT_TIMER    pTimer;

        ACQUIRE_SPIN_LOCK(&Timer->Miniport->TimerQueueLock, &OldIrql);
        
        //
        // check to see if the timer is already set
        //
        for (pTimer = Timer->Miniport->TimerQueue;
             pTimer != NULL;
             pTimer = pTimer->NextTimer)
        {
            if (pTimer == Timer)
                break;
        }
        
        if (pTimer == NULL)
        {
            Timer->NextTimer = Timer->Miniport->TimerQueue;
            Timer->Miniport->TimerQueue = Timer;
        }
        
        RELEASE_SPIN_LOCK(&Timer->Miniport->TimerQueueLock, OldIrql);
    }
#endif

    //
    // Set the timer
    //
    SET_PERIODIC_TIMER(&Timer->Timer, FireUpTime, MillisecondsPeriod, &Timer->Dpc);
}


VOID
NdisMSleep(
    IN  ULONG                   MicrosecondsToSleep
    )
/*++

    Routine Description:

    Blocks the caller for specified duration of time. Callable at Irql < DISPATCH_LEVEL.

    Arguments:

    MicrosecondsToSleep - The caller will be blocked for this much time.

    Return Value:

    NONE

--*/
{
    KTIMER          SleepTimer;
    LARGE_INTEGER   TimerValue;

    ASSERT (KeGetCurrentIrql() == LOW_LEVEL);

    INITIALIZE_TIMER_EX(&SleepTimer, SynchronizationTimer);

    TimerValue.QuadPart = Int32x32To64(MicrosecondsToSleep, -10);
    SET_TIMER(&SleepTimer, TimerValue, NULL);

    WAIT_FOR_OBJECT(&SleepTimer, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ndis\sys\minisub.c ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation

Module Name:

    miniport.c

Abstract:

    NDIS wrapper functions

Author:

    Sean Selitrennikoff (SeanSe) 05-Oct-93
    Jameel Hyder (JameelH) Re-organization 01-Jun-95

Environment:

    Kernel mode, FSD

Revision History:

--*/

#include "precomp.h"
#pragma hdrstop

//
//  Define the module number for debug code.
//
#define MODULE_NUMBER   MODULE_MINISUB

VOID
NdisAllocateSpinLock(
    IN  PNDIS_SPIN_LOCK         SpinLock
    )
{
    INITIALIZE_SPIN_LOCK(&SpinLock->SpinLock);
}

VOID
NdisFreeSpinLock(
    IN  PNDIS_SPIN_LOCK         SpinLock
    )
{
    UNREFERENCED_PARAMETER(SpinLock);
}

VOID
NdisAcquireSpinLock(
    IN  PNDIS_SPIN_LOCK         SpinLock
    )
{
    NDIS_ACQUIRE_SPIN_LOCK(SpinLock, &SpinLock->OldIrql);
}

VOID
NdisReleaseSpinLock(
    IN  PNDIS_SPIN_LOCK         SpinLock
    )
{
    NDIS_RELEASE_SPIN_LOCK(SpinLock, SpinLock->OldIrql);
}

VOID
NdisDprAcquireSpinLock(
    IN  PNDIS_SPIN_LOCK         SpinLock
    )
{
    NDIS_ACQUIRE_SPIN_LOCK_DPC(SpinLock);
    SpinLock->OldIrql = DISPATCH_LEVEL;
}

VOID
NdisDprReleaseSpinLock(
    IN  PNDIS_SPIN_LOCK         SpinLock
    )
{
    NDIS_RELEASE_SPIN_LOCK_DPC(SpinLock);
}

#undef NdisFreeBuffer
VOID
NdisFreeBuffer(
    IN  PNDIS_BUFFER            Buffer
    )
{
    IoFreeMdl(Buffer);
}

#undef NdisQueryBuffer
VOID
NdisQueryBuffer(
    IN  PNDIS_BUFFER            Buffer,
    OUT PVOID *                 VirtualAddress OPTIONAL,
    OUT PUINT                   Length
    )
{
    if (ARGUMENT_PRESENT(VirtualAddress))
    {
        *VirtualAddress = MDL_ADDRESS(Buffer);
    }
    *Length = MDL_SIZE(Buffer);
}


VOID
NdisQueryBufferSafe(
    IN  PNDIS_BUFFER            Buffer,
    OUT PVOID *                 VirtualAddress OPTIONAL,
    OUT PUINT                   Length,
    IN  MM_PAGE_PRIORITY        Priority
    )
{
    if (ARGUMENT_PRESENT(VirtualAddress))
    {
        *VirtualAddress = MDL_ADDRESS_SAFE(Buffer, Priority);
    }
    *Length = MDL_SIZE(Buffer);
}

VOID
NdisQueryBufferOffset(
    IN  PNDIS_BUFFER            Buffer,
    OUT PUINT                   Offset,
    OUT PUINT                   Length
    )
{
    *Offset = MDL_OFFSET(Buffer);
    *Length = MDL_SIZE(Buffer);
}

VOID
NdisGetFirstBufferFromPacket(
    IN  PNDIS_PACKET            Packet,
    OUT PNDIS_BUFFER *          FirstBuffer,
    OUT PVOID *                 FirstBufferVA,
    OUT PUINT                   FirstBufferLength,
    OUT PUINT                   TotalBufferLength
    )
{
    PNDIS_BUFFER    pBuf;

    pBuf = Packet->Private.Head;
    *FirstBuffer = pBuf;
    if (pBuf)
    {
        *FirstBufferVA =    MmGetSystemAddressForMdl(pBuf);
        *FirstBufferLength = *TotalBufferLength = MmGetMdlByteCount(pBuf);
        for (pBuf = pBuf->Next;
             pBuf != NULL;
             pBuf = pBuf->Next)
        {
            *TotalBufferLength += MmGetMdlByteCount(pBuf);
        }
    }
    else
    {
        *FirstBufferVA = 0;
        *FirstBufferLength = 0;
        *TotalBufferLength = 0;
    }
}

//
// safe version of NdisGetFirstBufferFromPacket
// if the memory described by the first buffer can not be mapped
// this function will return NULL for FirstBuferVA
//
VOID
NdisGetFirstBufferFromPacketSafe(
    IN  PNDIS_PACKET            Packet,
    OUT PNDIS_BUFFER *          FirstBuffer,
    OUT PVOID *                 FirstBufferVA,
    OUT PUINT                   FirstBufferLength,
    OUT PUINT                   TotalBufferLength,
    IN  MM_PAGE_PRIORITY        Priority
    )
{
    PNDIS_BUFFER    pBuf;

    pBuf = Packet->Private.Head;
    *FirstBuffer = pBuf;
    if (pBuf)
    {
        *FirstBufferVA =    MmGetSystemAddressForMdlSafe(pBuf, Priority);
        *FirstBufferLength = *TotalBufferLength = MmGetMdlByteCount(pBuf);
        for (pBuf = pBuf->Next;
             pBuf != NULL;
             pBuf = pBuf->Next)
        {
            *TotalBufferLength += MmGetMdlByteCount(pBuf);
        }
    }
    else
    {
        *FirstBufferVA = 0;
        *FirstBufferLength = 0;
        *TotalBufferLength = 0;
    }

}

ULONG
NdisBufferLength(
    IN  PNDIS_BUFFER            Buffer
    )
{
    return (MmGetMdlByteCount(Buffer));
}

PVOID
NdisBufferVirtualAddress(
    IN  PNDIS_BUFFER            Buffer
    )
{
    return (MDL_ADDRESS_SAFE(Buffer, HighPagePriority));
}

ULONG
NDIS_BUFFER_TO_SPAN_PAGES(
    IN  PNDIS_BUFFER                Buffer
    )
{
    if (MDL_SIZE(Buffer) == 0)
    {
        return 1;
    }
    return ADDRESS_AND_SIZE_TO_SPAN_PAGES(MDL_VA(Buffer), MDL_SIZE(Buffer));
}

VOID
NdisGetBufferPhysicalArraySize(
    IN  PNDIS_BUFFER            Buffer,
    OUT PUINT                   ArraySize
    )
{
    if (MDL_SIZE(Buffer) == 0)
    {
        *ArraySize = 1;
    }
    else
    {
        *ArraySize = ADDRESS_AND_SIZE_TO_SPAN_PAGES(MDL_VA(Buffer), MDL_SIZE(Buffer));
    }
}

NDIS_STATUS
NdisAnsiStringToUnicodeString(
    IN  OUT PUNICODE_STRING     DestinationString,
    IN      PANSI_STRING        SourceString
    )
{
    NDIS_STATUS Status;

    Status = RtlAnsiStringToUnicodeString(DestinationString,
                                          SourceString,
                                          FALSE);
    return Status;
}

NDIS_STATUS
NdisUnicodeStringToAnsiString(
    IN  OUT PANSI_STRING        DestinationString,
    IN      PUNICODE_STRING     SourceString
    )
{
    NDIS_STATUS Status;

    Status = RtlUnicodeStringToAnsiString(DestinationString,
                                          SourceString,
                                          FALSE);
    return Status;
}


NDIS_STATUS
NdisUpcaseUnicodeString(
    OUT PUNICODE_STRING         DestinationString,
    IN  PUNICODE_STRING         SourceString
    )
{
    return(RtlUpcaseUnicodeString(DestinationString, SourceString, FALSE));
}

VOID
NdisMStartBufferPhysicalMapping(
    IN  NDIS_HANDLE             MiniportAdapterHandle,
    IN  PNDIS_BUFFER            Buffer,
    IN  ULONG                   PhysicalMapRegister,
    IN  BOOLEAN                 WriteToDevice,
    OUT PNDIS_PHYSICAL_ADDRESS_UNIT PhysicalAddressArray,
    OUT PUINT                   ArraySize
    )
{
    NdisMStartBufferPhysicalMappingMacro(MiniportAdapterHandle,
                                         Buffer,
                                         PhysicalMapRegister,
                                         WriteToDevice,
                                         PhysicalAddressArray,
                                         ArraySize);
}

VOID
NdisMCompleteBufferPhysicalMapping(
    IN  NDIS_HANDLE             MiniportAdapterHandle,
    IN  PNDIS_BUFFER            Buffer,
    IN  ULONG                   PhysicalMapRegister
    )
{
    NdisMCompleteBufferPhysicalMappingMacro(MiniportAdapterHandle,
                                            Buffer,
                                            PhysicalMapRegister);
}

#undef NdisInterlockedIncrement
ULONG
NdisInterlockedIncrement(
    IN  PULONG                  Addend
    )
/*++

    Return Value:

        (eax) < 0 (but not necessarily -1) if result of add < 0
        (eax) == 0 if result of add == 0
        (eax) > 0 (but not necessarily +1) if result of add > 0

--*/
{
    return(InterlockedIncrement(Addend));
}

#undef NdisInterlockedDecrement
ULONG
NdisInterlockedDecrement(
    IN  PULONG                  Addend
    )
/*++

    Return Value:

        (eax) < 0 (but not necessarily -1) if result of add < 0
        (eax) == 0 if result of add == 0
        (eax) > 0 (but not necessarily +1) if result of add > 0

--*/
{
    return(InterlockedDecrement(Addend));
}

#undef NdisInterlockedAddUlong
ULONG
NdisInterlockedAddUlong(
    IN  PULONG                  Addend,
    IN  ULONG                   Increment,
    IN  PNDIS_SPIN_LOCK         SpinLock
    )
{
    return(ExInterlockedAddUlong(Addend,Increment, &SpinLock->SpinLock));

}

#undef NdisInterlockedInsertHeadList
PLIST_ENTRY
NdisInterlockedInsertHeadList(
    IN  PLIST_ENTRY             ListHead,
    IN  PLIST_ENTRY             ListEntry,
    IN  PNDIS_SPIN_LOCK         SpinLock
    )
{

    return(ExInterlockedInsertHeadList(ListHead,ListEntry,&SpinLock->SpinLock));

}

#undef NdisInterlockedInsertTailList
PLIST_ENTRY
NdisInterlockedInsertTailList(
    IN  PLIST_ENTRY             ListHead,
    IN  PLIST_ENTRY             ListEntry,
    IN  PNDIS_SPIN_LOCK         SpinLock
    )
{
    return(ExInterlockedInsertTailList(ListHead,ListEntry,&SpinLock->SpinLock));
}

#undef NdisInterlockedRemoveHeadList
PLIST_ENTRY
NdisInterlockedRemoveHeadList(
    IN  PLIST_ENTRY             ListHead,
    IN  PNDIS_SPIN_LOCK         SpinLock
    )
{
    return(ExInterlockedRemoveHeadList(ListHead, &SpinLock->SpinLock));
}

#undef NdisInterlockedPushEntryList
PSINGLE_LIST_ENTRY
NdisInterlockedPushEntryList(
    IN  PSINGLE_LIST_ENTRY      ListHead,
    IN  PSINGLE_LIST_ENTRY      ListEntry,
    IN  PNDIS_SPIN_LOCK         Lock
    )
{
    return(ExInterlockedPushEntryList(ListHead, ListEntry, &Lock->SpinLock));
}

#undef NdisInterlockedPopEntryList
PSINGLE_LIST_ENTRY
NdisInterlockedPopEntryList(
    IN  PSINGLE_LIST_ENTRY      ListHead,
    IN  PNDIS_SPIN_LOCK         Lock
    )
{
    return(ExInterlockedPopEntryList(ListHead, &Lock->SpinLock));
}


//
// Logging support for miniports
//
NDIS_STATUS
NdisMCreateLog(
    IN  NDIS_HANDLE             MiniportAdapterHandle,
    IN  UINT                    Size,
    OUT PNDIS_HANDLE            LogHandle
    )
{
    PNDIS_MINIPORT_BLOCK        Miniport = (PNDIS_MINIPORT_BLOCK)MiniportAdapterHandle;
    PNDIS_LOG                   Log = NULL;
    NDIS_STATUS                 Status;
    KIRQL                       OldIrql;

    NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Miniport, &OldIrql);

    if (Miniport->Log != NULL)
    {
        Status = NDIS_STATUS_FAILURE;
    }
    else
    {
        Log = ALLOC_FROM_POOL(sizeof(NDIS_LOG) + Size, NDIS_TAG_DBG_LOG);
        if (Log != NULL)
        {
            Status = NDIS_STATUS_SUCCESS;
            Miniport->Log = Log;
            INITIALIZE_SPIN_LOCK(&Log->LogLock);
            Log->Miniport = Miniport;
            Log->Irp = NULL;
            Log->TotalSize = Size;
            Log->CurrentSize = 0;
            Log->InPtr = 0;
            Log->OutPtr = 0;
        }
        else
        {
            Status = NDIS_STATUS_RESOURCES;
        }
    }

    *LogHandle = Log;

    NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);

    return Status;
}


VOID
NdisMCloseLog(
    IN   NDIS_HANDLE            LogHandle
    )
{
    PNDIS_LOG                   Log = (PNDIS_LOG)LogHandle;
    PNDIS_MINIPORT_BLOCK        Miniport;
    KIRQL                       OldIrql;

    Miniport = Log->Miniport;

    NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Miniport, &OldIrql);
    Miniport->Log = NULL;
    NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);

    FREE_POOL(Log);
}


NDIS_STATUS
NdisMWriteLogData(
    IN   NDIS_HANDLE            LogHandle,
    IN   PVOID                  LogBuffer,
    IN   UINT                   LogBufferSize
    )
{
    PNDIS_LOG                   Log = (PNDIS_LOG)LogHandle;
    NDIS_STATUS                 Status = NDIS_STATUS_SUCCESS;
    KIRQL                       OldIrql;
    UINT                        AmtToCopy;

    IoAcquireCancelSpinLock(&OldIrql);

    ACQUIRE_SPIN_LOCK_DPC(&Log->LogLock);

    if (LogBufferSize <= Log->TotalSize)
    {
        if (LogBufferSize <= (Log->TotalSize - Log->InPtr))
        {
            //
            // Can copy the entire buffer
            //
            CopyMemory(Log->LogBuf+Log->InPtr, LogBuffer, LogBufferSize);
        }
        else
        {
            //
            // We are going to wrap around. Copy it in two chunks.
            //
            AmtToCopy = Log->TotalSize - Log->InPtr;
            CopyMemory(Log->LogBuf+Log->InPtr,
                       LogBuffer,
                       AmtToCopy);
            CopyMemory(Log->LogBuf + 0,
                       (PUCHAR)LogBuffer+AmtToCopy,
                       LogBufferSize - AmtToCopy);
        }

        //
        // Update the current size
        //
        Log->CurrentSize += LogBufferSize;
        if (Log->CurrentSize > Log->TotalSize)
            Log->CurrentSize = Log->TotalSize;

        //
        // Update the InPtr and possibly the outptr
        //
        Log->InPtr += LogBufferSize;
        if (Log->InPtr >= Log->TotalSize)
        {
            Log->InPtr -= Log->TotalSize;
        }

        if (Log->CurrentSize == Log->TotalSize)
        {
            Log->OutPtr = Log->InPtr;
        }

        //
        // Check if there is a pending Irp to complete
        //
        if (Log->Irp != NULL)
        {
            PIRP    Irp = Log->Irp;
            PUCHAR  Buffer;

            Log->Irp = NULL;

            //
            // If the InPtr is lagging the OutPtr. then we can simply
            // copy the data over in one shot.
            //
            AmtToCopy = MDL_SIZE(Irp->MdlAddress);
            if (AmtToCopy > Log->CurrentSize)
                AmtToCopy = Log->CurrentSize;
            if ((Log->TotalSize - Log->OutPtr) >= AmtToCopy)
            {
                Buffer = MDL_ADDRESS_SAFE(Irp->MdlAddress, LowPagePriority);

                if (Buffer != NULL)
                {
                    CopyMemory(Buffer,
                               Log->LogBuf+Log->OutPtr,
                               AmtToCopy);
                }
                else Status = NDIS_STATUS_RESOURCES;
            }
            else
            {
                Buffer = MDL_ADDRESS_SAFE(Irp->MdlAddress, LowPagePriority);

                if (Buffer != NULL)
                {
                    CopyMemory(Buffer,
                               Log->LogBuf+Log->OutPtr,
                               Log->TotalSize-Log->OutPtr);
                    CopyMemory(Buffer+Log->TotalSize-Log->OutPtr,
                               Log->LogBuf,
                               AmtToCopy - (Log->TotalSize-Log->OutPtr));
                }
                else Status = NDIS_STATUS_RESOURCES;
            }
            Log->CurrentSize -= AmtToCopy;
            Log->OutPtr += AmtToCopy;
            if (Log->OutPtr >= Log->TotalSize)
                Log->OutPtr -= Log->TotalSize;
            Irp->IoStatus.Information = AmtToCopy;
            IoSetCancelRoutine(Irp, NULL);
            Irp->IoStatus.Status = STATUS_SUCCESS;
            IoCompleteRequest(Irp, IO_NETWORK_INCREMENT);
        }
    }
    else
    {
        Status = NDIS_STATUS_BUFFER_OVERFLOW;
    }

    RELEASE_SPIN_LOCK_DPC(&Log->LogLock);

    IoReleaseCancelSpinLock(OldIrql);

    return Status;
}

NDIS_STATUS
FASTCALL
ndisMGetLogData(
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  PIRP                    Irp
    )
{
    NTSTATUS    Status = STATUS_SUCCESS;
    KIRQL       OldIrql;
    PNDIS_LOG   Log;
    UINT        AmtToCopy;

    IoAcquireCancelSpinLock(&OldIrql);

    NDIS_ACQUIRE_MINIPORT_SPIN_LOCK_DPC(Miniport);

    if ((Log = Miniport->Log) != NULL)
    {
        ACQUIRE_SPIN_LOCK_DPC(&Log->LogLock);

        if (Log->CurrentSize != 0)
        {
            PUCHAR  Buffer;

            //
            // If the InPtr is lagging the OutPtr. then we can simply
            // copy the data over in one shot.
            //
            AmtToCopy = MDL_SIZE(Irp->MdlAddress);
            if (AmtToCopy > Log->CurrentSize)
                AmtToCopy = Log->CurrentSize;
            Buffer = MDL_ADDRESS_SAFE(Irp->MdlAddress, LowPagePriority);

            if (Buffer != NULL)
            {
                if ((Log->TotalSize - Log->OutPtr) >= AmtToCopy)
                {
                    CopyMemory(Buffer,
                               Log->LogBuf+Log->OutPtr,
                               AmtToCopy);
                }
                else
                {
                    CopyMemory(Buffer,
                               Log->LogBuf+Log->OutPtr,
                               Log->TotalSize-Log->OutPtr);
                    CopyMemory(Buffer+Log->TotalSize-Log->OutPtr,
                               Log->LogBuf,
                               AmtToCopy - (Log->TotalSize-Log->OutPtr));
                }
                Log->CurrentSize -= AmtToCopy;
                Log->OutPtr += AmtToCopy;
                if (Log->OutPtr >= Log->TotalSize)
                    Log->OutPtr -= Log->TotalSize;
                Irp->IoStatus.Information = AmtToCopy;
                Status = STATUS_SUCCESS;
            }
            else
            {
                Status = STATUS_INSUFFICIENT_RESOURCES;
            }
        }
        else if (Log->Irp != NULL)
        {
            Status = STATUS_UNSUCCESSFUL;
        }
        else
        {
            IoSetCancelRoutine(Irp, ndisCancelLogIrp);
            Log->Irp = Irp;
            Status = STATUS_PENDING;
        }

        RELEASE_SPIN_LOCK_DPC(&Log->LogLock);
    }
    else
    {
        Status = STATUS_UNSUCCESSFUL;
    }

    NDIS_RELEASE_MINIPORT_SPIN_LOCK_DPC(Miniport);
    IoReleaseCancelSpinLock(OldIrql);

    return Status;
}


VOID
NdisMFlushLog(
    IN   NDIS_HANDLE                LogHandle
    )
{
    PNDIS_LOG                   Log = (PNDIS_LOG)LogHandle;
    KIRQL                       OldIrql;

    ACQUIRE_SPIN_LOCK(&Log->LogLock, &OldIrql);
    Log->InPtr = 0;
    Log->OutPtr = 0;
    Log->CurrentSize = 0;
    RELEASE_SPIN_LOCK(&Log->LogLock, OldIrql);
}

NDIS_STATUS
NdisMQueryAdapterInstanceName(
    OUT PNDIS_STRING    pAdapterInstanceName,
    IN  NDIS_HANDLE     NdisAdapterHandle
    )
{
    PNDIS_MINIPORT_BLOCK    Miniport = (PNDIS_MINIPORT_BLOCK)NdisAdapterHandle;
    USHORT                  cbSize;
    PVOID                   ptmp = NULL;
    NDIS_STATUS             Status = NDIS_STATUS_FAILURE;
    NTSTATUS                NtStatus;

    DBGPRINT(DBG_COMP_CONFIG, DBG_LEVEL_INFO,
        ("==>NdisMQueryAdapterInstanceName\n"));

    //
    //  If we failed to create the adapter instance name then fail this call.
    //
    if (NULL != Miniport->pAdapterInstanceName)
    {
        //
        //  Allocate storage for the copy of the adapter instance name.
        //
        cbSize = Miniport->pAdapterInstanceName->MaximumLength;
    
        //
        //  Allocate storage for the new string.
        //
        ptmp = ALLOC_FROM_POOL(cbSize, NDIS_TAG_NAME_BUF);
        if (NULL != ptmp)
        {
            RtlZeroMemory(ptmp, cbSize);
            pAdapterInstanceName->Buffer = ptmp;
            pAdapterInstanceName->Length = 0;
            pAdapterInstanceName->MaximumLength = cbSize;
    
            NtStatus = RtlAppendUnicodeStringToString(
                            pAdapterInstanceName, 
                            Miniport->pAdapterInstanceName);
            if (NT_SUCCESS(NtStatus))
            {
                Status = NDIS_STATUS_SUCCESS;
            }
        }
        else
        {    
            Status = NDIS_STATUS_RESOURCES;
        }
    }

    if (NDIS_STATUS_SUCCESS != Status)
    {
        if (NULL != ptmp)
        {    
            FREE_POOL(ptmp);
        }
    }

    DBGPRINT(DBG_COMP_CONFIG, DBG_LEVEL_INFO,
        ("<==NdisMQueryAdapterInstanceName: 0x%x\n", Status));

    return(Status);
}


EXPORT
VOID
NdisInitializeReadWriteLock(
    IN  PNDIS_RW_LOCK           Lock
    )
{
    NdisZeroMemory(Lock, sizeof(NDIS_RW_LOCK));
}


VOID
NdisAcquireReadWriteLock(
    IN  PNDIS_RW_LOCK           Lock,
    IN  BOOLEAN                 fWrite,
    IN  PLOCK_STATE             LockState
    )
{
    if (fWrite)
    {
        LockState->LockState = WRITE_LOCK_STATE_UNKNOWN;
        {
            UINT    i, refcount;
            ULONG   Prc;

            /*
             * This means we need to attempt to acquire the lock,
             * if we do not already own it.
             * Set the state accordingly.
             */
            if ((Lock)->Context == CURRENT_THREAD)
            {
                (LockState)->LockState = LOCK_STATE_ALREADY_ACQUIRED;
            }
            else
            {
                ACQUIRE_SPIN_LOCK(&(Lock)->SpinLock, &(LockState)->OldIrql);

                Prc = KeGetCurrentProcessorNumber();
                refcount = (Lock)->RefCount[Prc].RefCount;
                (Lock)->RefCount[Prc].RefCount = 0;

                /* wait for all readers to exit */
                for (i=0; i < ndisNumberOfProcessors; i++)
                {
                    volatile UINT   *_p = &(Lock)->RefCount[i].RefCount;

                    while (*_p != 0)
                        NDIS_INTERNAL_STALL(50);
                }

                (Lock)->RefCount[Prc].RefCount = refcount;
                (Lock)->Context = CURRENT_THREAD;
                (LockState)->LockState = WRITE_LOCK_STATE_FREE;
            }
        }
    }
    else
    {
        LockState->LockState = READ_LOCK;
        {                                                                       
            UINT    refcount;                                                   
            ULONG   Prc;                                                        
                                                                                
            RAISE_IRQL_TO_DISPATCH(&(LockState)->OldIrql);                           
                                                                                
            /* go ahead and bump up the ref count IF no writes are underway */  
            Prc = CURRENT_PROCESSOR;                                            
            refcount = InterlockedIncrement(&Lock->RefCount[Prc].RefCount);                          
                                                                                
            /* Test if spin lock is held, i.e., write is underway   */          
            /* if (KeTestSpinLock(&(_L)->SpinLock) == TRUE)         */          
            /* This processor already is holding the lock, just     */          
            /* allow him to take it again or else we run into a     */          
            /* dead-lock situation with the writer                  */          
            if (TEST_SPIN_LOCK((Lock)->SpinLock) &&                               
                (refcount == 1) &&                                              
                ((Lock)->Context != CURRENT_THREAD))                              
            {                                                                   
                (Lock)->RefCount[Prc].RefCount--;                                 
                ACQUIRE_SPIN_LOCK_DPC(&(Lock)->SpinLock);                         
                (Lock)->RefCount[Prc].RefCount++;                                 
                RELEASE_SPIN_LOCK_DPC(&(Lock)->SpinLock);                         
            }                                                                   
            (LockState)->LockState = READ_LOCK_STATE_FREE;                           
        }
    }
//  LockState->LockState = fWrite ? WRITE_LOCK_STATE_UNKNOWN : READ_LOCK;
//  xLockHandler(Lock, LockState);
}


VOID
NdisReleaseReadWriteLock(
    IN  PNDIS_RW_LOCK           Lock,
    IN  PLOCK_STATE             LockState
    )
{
    xLockHandler(Lock, LockState);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ndis\sys\ndis.c ===
/*++
Copyright (c) 1992  Microsoft Corporation

Module Name:

    ndis.c

Abstract:

    NDIS wrapper functions

Author:

    Adam Barr (adamba) 11-Jul-1990

Environment:

    Kernel mode, FSD

Revision History:

    10-Jul-1995  JameelH Make NDIS.SYS a device-driver and add PnP support

--*/

#include <precomp.h>
#pragma hdrstop

//
//  Define the module number for debug code.
//
#define MODULE_NUMBER   MODULE_NDIS

#define NDIS_DEVICE_NAME    L"\\Device\\Ndis"
#define NDIS_SYMBOLIC_NAME  L"\\Global??\\NDIS"

NTSTATUS
DriverEntry(
    IN  PDRIVER_OBJECT      DriverObject,
    IN  PUNICODE_STRING     RegistryPath
    )
/*++

Routine Description:

    NDIS wrapper driver entry point.

Arguments:

    DriverObject - Pointer to the driver object created by the system.
    RegistryPath - Pointer to the registry section where the parameters reside.

Return Value:

    Return value from IoCreateDevice

--*/
{
    NTSTATUS            Status = STATUS_SUCCESS;
    UNICODE_STRING      DeviceName;
    UINT                i;
    OBJECT_ATTRIBUTES   ObjectAttr;
    UNICODE_STRING      CallbackObjectName;
    NTSTATUS            NtStatus;
    SYSTEM_BATTERY_STATE ndisSystemBatteryState;
    HANDLE              ThreadHandle;
    BOOLEAN             fDerefCallbackObject = FALSE, fDeregisterCallback = FALSE;

#define     GET_TEXT_1(_T)      #_T
#define     GET_TEXT(_T)        GET_TEXT_1(_T)

    NdisInitializeString(&ndisBuildDate, __DATE__);
    NdisInitializeString(&ndisBuildTime, __TIME__);
    NdisInitializeString(&ndisBuiltBy, GET_TEXT(BUILT_BY));
        
    ndisDriverObject = DriverObject;
    
    //
    //  Create the device object.
    //
    RtlInitUnicodeString(&DeviceName, NDIS_DEVICE_NAME);
    ndisNumberOfProcessors = KeNumberProcessors;

    Status = IoCreateDevice(DriverObject,               // DriverObject
                            0,                          // DeviceExtension
                            &DeviceName,                // DeviceName
                            FILE_DEVICE_NETWORK,        // DeviceType
                            FILE_DEVICE_SECURE_OPEN,    // DeviceCharacteristics
                            FALSE,                      // Exclusive
                            &ndisDeviceObject);         // DeviceObject
        
    if (NT_SUCCESS(Status))
    {
        UNICODE_STRING  SymbolicLinkName;
    
        // Create a symbolic link to this device
        RtlInitUnicodeString(&SymbolicLinkName, NDIS_SYMBOLIC_NAME);
        Status = IoCreateSymbolicLink(&SymbolicLinkName, &DeviceName);

        ndisDeviceObject->Flags |= DO_DIRECT_IO;
    
        // Initialize the driver object for this file system driver.
        for (i = 0; i <= IRP_MJ_MAXIMUM_FUNCTION; i++)
        {
            DriverObject->MajorFunction[i] = ndisDispatchRequest;
        }
        
        //
        // create a security descriptor for NDIS device object
        //
        Status = ndisCreateSecurityDescriptor(ndisDeviceObject, 
                                              &ndisSecurityDescriptor,
                                              TRUE);

        Status = CreateDeviceDriverSecurityDescriptor(DriverObject);
        Status = CreateDeviceDriverSecurityDescriptor(DriverObject->DeviceObject);
        Status = CreateDeviceDriverSecurityDescriptor(ndisDeviceObject);

        //
        // disable for now
        //
#if NDIS_UNLOAD        
        DriverObject->DriverUnload = ndisUnload;
#else
        DriverObject->DriverUnload = NULL;
#endif

        INITIALIZE_SPIN_LOCK(&ndisGlobalLock);
        INITIALIZE_SPIN_LOCK(&ndisMiniDriverListLock);
        INITIALIZE_SPIN_LOCK(&ndisProtocolListLock);
        INITIALIZE_SPIN_LOCK(&ndisMiniportListLock);
        INITIALIZE_SPIN_LOCK(&ndisGlobalPacketPoolListLock);
        INITIALIZE_SPIN_LOCK(&ndisGlobalOpenListLock);

        ndisDmaAlignment = HalGetDmaAlignmentRequirement();
        if (sizeof(ULONG) > ndisDmaAlignment)
        {
            ndisDmaAlignment = sizeof(ULONG);
        }
        ndisTimeIncrement = KeQueryTimeIncrement();
    
        //
        // Get handles for all conditionally lockable sections
        //
        for (i = 0; i < MAX_PKG; i++)
        {
            ndisInitializePackage(&ndisPkgs[i]);
        }

        ExInitializeResourceLite(&SharedMemoryResource);
    
        ndisReadRegistry();
        //
        // don't let use set this bit through registry
        //
        ndisFlags &= ~NDIS_GFLAG_TRACK_MEM_ALLOCATION;
        
        Status = STATUS_SUCCESS;
        ndisSystemProcess = NtCurrentProcess();

        //
        // Now create a worker thread for use by NDIS
        // This is so that when we queue PnP events upto transports
        // and they need worker threads as well ...
        //
        KeInitializeQueue(&ndisWorkerQueue, 0);
        Status = PsCreateSystemThread(&ThreadHandle,
                                      THREAD_ALL_ACCESS,
                                      NULL,
                                      NtCurrentProcess(),
                                      NULL,
                                      ndisWorkerThread,
                                      NULL);

        
        if (!NT_SUCCESS(Status))
        {
            DBGPRINT(DBG_COMP_ALL, DBG_LEVEL_ERR,
                    ("NDIS DriverEntry: Cannot create worker thread, Status %lx\n", Status));
        }
        else
        {
            NtClose(ThreadHandle);
        }
        
    }
    KeQuerySystemTime(&KeBootTime);

    ConvertSecondsToTicks(POOL_AGING_TIME, &PoolAgingTicks);

    //
    // verifir intialization. in case ndis tester wants to verify
    // the drivers by intercepting ndis entry points, ndis should
    // not verify the calls
    //
    if (!(ndisFlags & NDIS_GFLAG_DONT_VERIFY))
        ndisVerifierInitialization();
    
#if DBG
    if (ndisDebugBreakPoint)
    {
        DbgPrint("Ndis: DriverEntry\n");
        DbgBreakPoint();
    }
#endif

#ifdef TRACK_MOPEN_REFCOUNTS
    NdisZeroMemory (&ndisLogfile, sizeof(UINT) * NDIS_LOGFILE_SIZE);
#endif

#ifdef TRACK_MINIPORT_REFCOUNTS
    NdisZeroMemory (&ndisMiniportLogfile, sizeof(UINT) * NDIS_MINIPORT_LOGFILE_SIZE);
#endif

    //
    // create a callback options for those kernel mode components that like
    // to hear about Bind/Unbind events
    //

    RtlInitUnicodeString(&CallbackObjectName, NDIS_BIND_UNBIND_CALLBACK_NAME);

    InitializeObjectAttributes(&ObjectAttr,
                               &CallbackObjectName,
                               OBJ_CASE_INSENSITIVE | OBJ_PERMANENT,
                               NULL,
                               NULL);
                               
    NtStatus = ExCreateCallback(&ndisBindUnbindCallbackObject,
                              &ObjectAttr,
                              TRUE,             // create
                              TRUE);            // allow multiple callback registeration

    
    if (!NT_SUCCESS(NtStatus))
    {

        DbgPrint("Ndis: failed to create a Callback object. Status %lx\n", NtStatus);
    }
    
#if 0
    else
    {

        //
        // for test purpose
        //
        ndisBindUnbindCallbackRegisterationHandle = ExRegisterCallback(ndisBindUnbindCallbackObject,
                                                             ndisBindUnbindCallback,
                                                             (PVOID)NULL);


        if (ndisBindUnbindCallbackRegisterationHandle == NULL)
        {
            DbgPrint("Ndis: failed to register a BindUnbind callback routine\n");
        }
    }
#endif

    //
    // register a notification callback for power state changes
    //

    RtlInitUnicodeString(&CallbackObjectName, L"\\CallBack\\PowerState");

    InitializeObjectAttributes(&ObjectAttr,
                               &CallbackObjectName,
                               OBJ_CASE_INSENSITIVE | OBJ_PERMANENT,
                               NULL,
                               NULL);
                                   
    NtStatus = ExCreateCallback(&ndisPowerStateCallbackObject,
                                &ObjectAttr,
                                FALSE,
                                TRUE);
                                
    if (!NT_SUCCESS(Status))
    {

        DbgPrint("Ndis: failed to create a Callback object. Status %lx\n", NtStatus);
    }
    else
    {
        fDerefCallbackObject = TRUE;
        ndisPowerStateCallbackHandle = ExRegisterCallback(ndisPowerStateCallbackObject,
                                                          (PCALLBACK_FUNCTION)&ndisPowerStateCallback,
                                                          (PVOID)NULL);

        if (ndisPowerStateCallbackHandle == NULL)
        {
            DbgPrint("Ndis: failed to register a power state Callback routine\n");
        }
        else
        {
            fDeregisterCallback = TRUE;
        }

        RtlZeroMemory(&ndisSystemBatteryState, sizeof(SYSTEM_BATTERY_STATE));
        //
        // get the current power source
        //
        NtStatus = ZwPowerInformation(SystemBatteryState,
                                      NULL,
                                      0,
                                      &ndisSystemBatteryState,
                                      sizeof(SYSTEM_BATTERY_STATE));

        if (NT_SUCCESS(NtStatus))
        {
            ndisAcOnLine = (ndisSystemBatteryState.AcOnLine == TRUE) ? 1 : 0;
        }
           
        fDerefCallbackObject = FALSE;
        fDeregisterCallback = FALSE;    
    }

    InitializeListHead(&ndisGlobalPacketPoolList);
    
    if (fDeregisterCallback)
    {
        ExUnregisterCallback(ndisPowerStateCallbackHandle);
    }

    if (fDerefCallbackObject)
    {
        ObDereferenceObject(ndisPowerStateCallbackObject);

    }

    INITIALIZE_MUTEX(&ndisPnPMutex);

    return Status;
}


#if NDIS_UNLOAD
VOID
ndisUnload(
    IN  PDRIVER_OBJECT      DriverObject
    )
/*++

Routine Description:

    This is the unload routine for the Appletalk driver.

    NOTE: Unload will not be called until all the handles have been
          closed successfully. We just shutdown all the ports, and do
          misc. cleanup.


Arguments:

    DriverObject - Pointer to driver object for this driver.

Return Value:

    None.

--*/
{
    NTSTATUS        Status;
    UNICODE_STRING  SymbolicLinkName;
    UINT            i;

    NdisFreeString(ndisBuildDate);
    NdisFreeString(ndisBuildTime);
    NdisFreeString(ndisBuiltBy);

    if (ndisPowerStateCallbackHandle)
    {
        ExUnregisterCallback(ndisPowerStateCallbackHandle);
    }

    if (ndisPowerStateCallbackObject)
    {
        ObDereferenceObject(ndisPowerStateCallbackObject);
    }

    ExDeleteResourceLite(&SharedMemoryResource);


    //
    // Tell the ndisWorkerThread to quit
    //
    INITIALIZE_WORK_ITEM(&ndisPoisonPill, NULL, &ndisPoisonPill);
    QUEUE_WORK_ITEM(&ndisPoisonPill, CriticalWorkQueue);
    WAIT_FOR_OBJECT(ndisThreadObject, 0);
    ObDereferenceObject(ndisThreadObject);

    RtlInitUnicodeString(&SymbolicLinkName, NDIS_SYMBOLIC_NAME);
    Status = IoDeleteSymbolicLink(&SymbolicLinkName);
    ASSERT(NT_SUCCESS(Status));
    IoDeleteDevice(ndisDeviceObject);

    //
    // ASSERT that all the packages are unlocked
    //
    for (i = 0; i < MAX_PKG; i++)
    {
        ASSERT(ndisPkgs[i].ReferenceCount == 0);
    }
}
#endif

VOID
ndisReadRegistry(
    VOID
    )
{
    RTL_QUERY_REGISTRY_TABLE    QueryTable[8];
    UCHAR                       c;
    ULONG                       DefaultZero = 0;

    //
    //  First we need to initialize the processor information incase
    //  the registry is empty.
    //
    for (c = 0; c < ndisNumberOfProcessors; c++)
    {
        ndisValidProcessors[c] = c;
    }

    ndisCurrentProcessor = ndisMaximumProcessor = c - 1;

    //
    // 1) Switch to the MediaTypes key below the service (NDIS) key
    //
    QueryTable[0].QueryRoutine = NULL;
    QueryTable[0].Flags = RTL_QUERY_REGISTRY_SUBKEY;
    QueryTable[0].Name = L"MediaTypes";

    //
    // Setup to enumerate the values in the registry section (shown above).
    // For each such value, we'll add it to the ndisMediumArray
    //
    QueryTable[1].QueryRoutine = ndisAddMediaTypeToArray;
    QueryTable[1].DefaultType = REG_DWORD;
    QueryTable[1].DefaultData = (PVOID)&DefaultZero;
    QueryTable[1].DefaultLength = 0;
    QueryTable[1].Flags = RTL_QUERY_REGISTRY_REQUIRED | RTL_QUERY_REGISTRY_NOEXPAND;
    QueryTable[1].Name = NULL;

    //
    // Query terminator
    //
    QueryTable[2].QueryRoutine = NULL;
    QueryTable[2].Flags = 0;
    QueryTable[2].Name = NULL;

    //
    // The rest of the work is done in the callback routine ndisAddMediaTypeToArray.
    //
    RtlQueryRegistryValues(RTL_REGISTRY_SERVICES,
                           L"NDIS",
                           QueryTable,
                           (PVOID)NULL,   // no context needed
                           NULL);
    //
    //  Switch to the parameters key below the service (NDIS) key and
    //  read the parameters.
    //
    QueryTable[0].QueryRoutine = NULL;
    QueryTable[0].Flags = RTL_QUERY_REGISTRY_SUBKEY;
    QueryTable[0].Name = L"Parameters";

    //
    //  Read in the processor affinity mask.
    //
    QueryTable[1].QueryRoutine = ndisReadProcessorAffinityMask;
    QueryTable[1].Flags = RTL_QUERY_REGISTRY_REQUIRED | RTL_QUERY_REGISTRY_NOEXPAND;
    QueryTable[1].DefaultData = (PVOID)&DefaultZero;
    QueryTable[1].DefaultLength = 0;
    QueryTable[1].DefaultType = REG_DWORD;
    QueryTable[1].Name = L"ProcessorAffinityMask";

    QueryTable[2].QueryRoutine = ndisReadRegParameters;
    QueryTable[2].Flags = RTL_QUERY_REGISTRY_NOEXPAND;
    QueryTable[2].DefaultData = (PVOID)&ndisFlags;
    QueryTable[2].DefaultLength = 0;
    QueryTable[2].DefaultType = REG_DWORD;
    QueryTable[2].Name = L"Flags";
    QueryTable[2].EntryContext = (PVOID)&ndisFlags;

    QueryTable[3].QueryRoutine = ndisReadRegParameters;
    QueryTable[3].Flags = RTL_QUERY_REGISTRY_NOEXPAND;
    QueryTable[3].DefaultData = (PVOID)&ndisPacketStackSize;
    QueryTable[3].DefaultLength = 0;
    QueryTable[3].DefaultType = REG_DWORD;
    QueryTable[3].Name = L"PacketStackSize";
    QueryTable[3].EntryContext = (PVOID)&ndisPacketStackSize;

    //
    // Query terminator
    //
    QueryTable[4].QueryRoutine = NULL;
    QueryTable[4].Flags = 0;
    QueryTable[4].Name = NULL;

#if DBG
#ifdef NDIS_TRACE
    ndisDebugBreakPoint = 1;
    ndisDebugLevel = 0;
    ndisDebugSystems = 0x3003;
#else
    QueryTable[4].QueryRoutine = ndisReadRegParameters;
    QueryTable[4].Flags = RTL_QUERY_REGISTRY_NOEXPAND;
    QueryTable[4].Name = L"DebugBreakPoint";
    QueryTable[4].DefaultData = (PVOID)&ndisDebugBreakPoint;
    QueryTable[4].DefaultLength = 0;
    QueryTable[4].EntryContext = (PVOID)&ndisDebugBreakPoint;
    QueryTable[4].DefaultType = REG_DWORD;
    
    QueryTable[5].QueryRoutine = ndisReadRegParameters;
    QueryTable[5].Flags = RTL_QUERY_REGISTRY_NOEXPAND;
    QueryTable[5].Name = L"DebugLevel";
    QueryTable[5].DefaultData = (PVOID)&ndisDebugLevel;
    QueryTable[5].DefaultLength = 0;
    QueryTable[5].EntryContext = (PVOID)&ndisDebugLevel;
    QueryTable[5].DefaultType = REG_DWORD;
    
    QueryTable[6].QueryRoutine = ndisReadRegParameters;
    QueryTable[6].Flags = RTL_QUERY_REGISTRY_NOEXPAND;
    QueryTable[6].Name = L"DebugSystems";
    QueryTable[6].DefaultData = (PVOID)&ndisDebugSystems;
    QueryTable[6].DefaultLength = 0;
    QueryTable[6].EntryContext = (PVOID)&ndisDebugSystems;
    QueryTable[6].DefaultType = REG_DWORD;

    //
    // Query terminator
    //
    QueryTable[7].QueryRoutine = NULL;
    QueryTable[7].Flags = 0;
    QueryTable[7].Name = NULL;
#endif
#endif

    //
    // The rest of the work is done in the callback routines
    //
    RtlQueryRegistryValues(RTL_REGISTRY_SERVICES,
                           L"NDIS",
                           QueryTable,
                           (PVOID)NULL,   // no context needed
                           NULL);

    //
    // Make sure ndisPacketStackSize isn't zero
    //
    if (ndisPacketStackSize == 0)
        ndisPacketStackSize = 1;
}

NTSTATUS
ndisReadRegParameters(
    IN PWSTR                        ValueName,
    IN ULONG                        ValueType,
    IN PVOID                        ValueData,
    IN ULONG                        ValueLength,
    IN PVOID                        Context,
    IN PVOID                        EntryContext
    )
/*++


Arguments:

    ValueName - The name of the value

    ValueType - The type of the value (REG_MULTI_SZ -- ignored).

    ValueData - The null-terminated data for the value.

    ValueLength - The length of ValueData.

    Context - Unused.

    EntryContext - A pointer to the pointer that holds the copied data.

Return Value:

    STATUS_SUCCESS

--*/
{
    UNREFERENCED_PARAMETER(ValueName);
    UNREFERENCED_PARAMETER(ValueLength);
    UNREFERENCED_PARAMETER(Context);

    if ((ValueType != REG_DWORD) || (ValueData == NULL))
        return STATUS_UNSUCCESSFUL;

    *((PULONG)EntryContext) = *((PULONG)ValueData);
    
    return STATUS_SUCCESS;
}

NTSTATUS
ndisReadProcessorAffinityMask(
    IN  PWSTR   ValueName,
    IN  ULONG   ValueType,
    IN  PVOID   ValueData,
    IN  ULONG   ValueLength,
    IN  PVOID   Context,
    IN  PVOID   EntryContext
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    //
    //  If we have valid data then build our array of valid processors
    //  to use.... Treat the special case of 0 or default -1 to signify 
    //  that DPC affinity will follow interrupt affinity
    //
    if ((REG_DWORD == ValueType) && (ValueData != NULL))
    {
        if ((*(PULONG)ValueData == 0) ||
            (*(PULONG)ValueData == 0xFFFFFFFF))
        {
            ndisSkipProcessorAffinity = TRUE;
        }
        
        else
        {
            ULONG   ProcessorAffinity;
            UCHAR   c1, c2;
    
            //
            //  Save the processor affinity.
            //
            ProcessorAffinity = *(PULONG)ValueData;
    
            //
            //  Fill in the valid processor array.
            //
            for (c1 = c2 = 0;
                 (c1 <= ndisMaximumProcessor) && (ProcessorAffinity != 0);
                 c1++)
            {
                if (ProcessorAffinity & 1)
                {
                    ndisValidProcessors[c2++] = c1;
                }
                ProcessorAffinity >>= 1;
            }
    
            ndisCurrentProcessor = ndisMaximumProcessor = c2 - 1;
        }
    }

    return STATUS_SUCCESS;
}


NTSTATUS
ndisAddMediaTypeToArray(
    IN PWSTR        ValueName,
    IN ULONG        ValueType,
    IN PVOID        ValueData,
    IN ULONG        ValueLength,
    IN PVOID        Context,
    IN PVOID        EntryContext
    )
{
#if DBG
    NDIS_STRING Str;

    RtlInitUnicodeString(&Str, ValueName);
#endif

    DBGPRINT(DBG_COMP_ALL, DBG_LEVEL_INFO,
            ("ExperimentalMediaType %Z - %x\n", &Str, *(PULONG)ValueData));

    //
    // Ignore all values that we already know about. These should not be in the
    // registry anyway, but just in case somebody is messing with it.
    //
    if ((ValueType == REG_DWORD) && (ValueData != NULL) && (*(PULONG)ValueData > NdisMediumIrda))
    {
        NDIS_MEDIUM *pTemp;
        ULONG       size;

        //
        // See if we have enough space to add this value. If not allocate space for the
        // new array, copy the old one into this (and free the old if not static).
        //
        ASSERT (ndisMediumArraySize <= ndisMediumArrayMaxSize);

        //
        // Check for duplicates. If so drop it
        //
        for (pTemp = ndisMediumArray, size = ndisMediumArraySize;
             size > 0; pTemp ++, size -= sizeof(NDIS_MEDIUM))
        {
            if (*(NDIS_MEDIUM *)ValueData == *pTemp)
            {
                //
                // Duplicate.
                //
                return STATUS_SUCCESS;
            }
        }

        if (ndisMediumArraySize == ndisMediumArrayMaxSize)
        {
            //
            // We do not have any space in the array. Need to re-alloc. Be generous.
            //
            pTemp = (NDIS_MEDIUM *)ALLOC_FROM_POOL(ndisMediumArraySize + EXPERIMENTAL_SIZE*sizeof(NDIS_MEDIUM),
                                                   NDIS_TAG_MEDIA_TYPE_ARRAY);
            if (pTemp != NULL)
            {
                CopyMemory(pTemp, ndisMediumArray, ndisMediumArraySize);
                if (ndisMediumArray != ndisMediumBuffer)
                {
                    FREE_POOL(ndisMediumArray);
                }
                ndisMediumArray = pTemp;
            }
        }
        if (ndisMediumArraySize < ndisMediumArrayMaxSize)
        {
            ndisMediumArray[ndisMediumArraySize/sizeof(NDIS_MEDIUM)] = *(NDIS_MEDIUM *)ValueData;
            ndisMediumArraySize += sizeof(NDIS_MEDIUM);
        }
    }

    return STATUS_SUCCESS;
}

WORK_QUEUE_ITEM LastWorkerThreadWI = {0} ;

VOID
ndisWorkerThread(
    IN  PVOID           Context
    )
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    BOOLEAN             FirstThread = (Context == NULL);
    PLIST_ENTRY         pList;
    HANDLE              ThreadHandle;
    PWORK_QUEUE_ITEM    pWI;
    NTSTATUS            Status;
    
    if (FirstThread)
    {
        ndisThreadObject = PsGetCurrentThread();
        ObReferenceObject(ndisThreadObject);
        
        do
        {
            //
            // Block here waiting for work-items to do
            //
            pList = KeRemoveQueue(&ndisWorkerQueue, KernelMode, NULL);
    
            DBGPRINT_RAW(DBG_COMP_WORK_ITEM, DBG_LEVEL_INFO,
                    ("ndisWorkerThread: WorkItem %p\n", pList));
    
            pWI = CONTAINING_RECORD(pList, WORK_QUEUE_ITEM, List);
    
#if NDIS_UNLOAD        
            //
            // Unload asking us to quit, comply.
            //
            if (pWI == &ndisPoisonPill)
            {
                break;
            }
#endif

            Status = PsCreateSystemThread(&ThreadHandle,
                                          THREAD_ALL_ACCESS,
                                          NULL,
                                          NtCurrentProcess(),
                                          NULL,
                                          ndisWorkerThread,
                                          pWI);
            if (NT_SUCCESS(Status))
            {
                NtClose(ThreadHandle);
            }
            else
            {
                DBGPRINT_RAW(DBG_COMP_WORK_ITEM, DBG_LEVEL_INFO,
                        ("ndisWorkerThread: Failed to create a thread, using EX worker thread\n"));
                XQUEUE_WORK_ITEM(pWI, CriticalWorkQueue);
                ASSERT (KeGetCurrentIrql() == PASSIVE_LEVEL);
            }
        } while (TRUE);
    }
    else
    {
        //
        // Not the main thread, just do the thing and die.
        //
        LastWorkerThreadWI = *((PWORK_QUEUE_ITEM)Context);
        pWI = (PWORK_QUEUE_ITEM)Context;

        (*pWI->WorkerRoutine)(pWI->Parameter);
        ASSERT (KeGetCurrentIrql() == PASSIVE_LEVEL);
    }
}

NTSTATUS
ndisDispatchRequest(
    IN  PDEVICE_OBJECT  pDeviceObject,
    IN  PIRP            pIrp
    )
/*++

Routine Description:

    Dispatcher for Irps intended for the NDIS Device.

Arguments:


Return Value:


--*/
{
    NTSTATUS            Status = STATUS_SUCCESS;
    PIO_STACK_LOCATION  pIrpSp;
    PNDIS_DEVICE_OBJECT_OPEN_CONTEXT OpenContext = NULL;
    NTSTATUS            SecurityStatus;
    static LONG         OpenCount = 0;

    pDeviceObject;      // prevent compiler warnings

    PAGED_CODE( );

    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
    pIrp->IoStatus.Status = STATUS_PENDING;
    pIrp->IoStatus.Information = 0;

    PnPReferencePackage();

    switch (pIrpSp->MajorFunction)
    {
      case IRP_MJ_CREATE:

        OpenContext = (PNDIS_DEVICE_OBJECT_OPEN_CONTEXT)ALLOC_FROM_POOL(sizeof(NDIS_DEVICE_OBJECT_OPEN_CONTEXT),
                                                               NDIS_TAG_OPEN_CONTEXT);

        if (OpenContext == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }
        ZeroMemory(OpenContext, sizeof(NDIS_DEVICE_OBJECT_OPEN_CONTEXT));

        OpenContext->AdminAccessAllowed = ndisCheckAccess(pIrp, 
                                                          pIrpSp, 
                                                          &SecurityStatus, 
                                                          ndisSecurityDescriptor);
        //
        // save the caller's access right
        //
        pIrpSp->FileObject->FsContext = OpenContext;
        Increment(&OpenCount, &Lock);        
        break;

      case IRP_MJ_CLEANUP:
        OpenContext = pIrpSp->FileObject->FsContext;
        ASSERT(OpenContext != NULL);
        pIrpSp->FileObject->FsContext = NULL;
        FREE_POOL(OpenContext);
        Decrement(&OpenCount, &Lock);
        break;

      case IRP_MJ_CLOSE:
        break;

      case IRP_MJ_INTERNAL_DEVICE_CONTROL:
        break;

      case IRP_MJ_DEVICE_CONTROL:
        Status =  ndisHandlePnPRequest(pIrp);
        break;

      default:
        Status = STATUS_NOT_IMPLEMENTED;
        break;
    }

    ASSERT (CURRENT_IRQL < DISPATCH_LEVEL);
    ASSERT (Status != STATUS_PENDING);

    pIrp->IoStatus.Status = Status;
    IoCompleteRequest(pIrp, IO_NETWORK_INCREMENT);

    PnPDereferencePackage();

    return Status;
}

NTSTATUS
ndispConvOffsetToPointer(
    IN     PVOID      MasterBuffer,
    IN     ULONG      MasterLength,
    IN OUT PULONG_PTR Offset,
    IN     ULONG      Length,
    IN     ULONG      Alignment
    )

/*++

Routine Description:

    This function validates a buffer within an IOCTL and converts a buffer
    offset to a pointer.

Argumens:

    MasterBuffer - Pointer to the start of the IOCTL buffer

    MasterLength - Length of the IOCTL buffer

    Offset - Offset of the data buffer within the IOCTL buffer

    Length - Length of the data buffer within the IOCTL buffer

    Alignment - Required alignment of the type within the data buffer

Return Value:

    The function status is the final status of the operation.

--*/

{
    ULONG_PTR masterStart;
    ULONG_PTR masterEnd;
    ULONG_PTR bufStart;
    ULONG_PTR bufEnd;

    if (Length == 0)
    {

        //
        // Nothing to do.
        //

        return STATUS_SUCCESS;
    }

    masterStart = (ULONG_PTR)MasterBuffer;
    masterEnd = masterStart + MasterLength;
    bufStart = masterStart + *Offset;
    bufEnd = bufStart + Length;

    //
    // Ensure that neither of the buffers wrap
    //

    if (masterEnd < masterStart || bufEnd < bufStart)
    {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Ensure that buf is wholly contained within master
    //

    if (bufStart < masterStart || bufEnd > masterEnd)
    {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Make sure that buf is properly aligned
    //

    if ((bufStart & (Alignment - 1)) != 0)
    {
        return STATUS_INVALID_PARAMETER;
    }

    //
    // Everything looks good, perform the conversion
    //

    *Offset += masterStart;
    return STATUS_SUCCESS;
}

NTSTATUS
ndispConvVar(
    IN     PVOID MasterBuffer,
    IN     ULONG MasterLength,
    IN OUT PNDIS_VAR_DATA_DESC Var
    )

/*++

Routine Description:

    This function validates an NDIS_VAR_DATA_DESC buffer within an IOCTL
    and converts its data offset to a pointer.

Argumens:

    MasterBuffer - Pointer to the start of the IOCTL buffer

    MasterLength - Length of the IOCTL buffer

    Var - Pointer to an NDIS_VAR_DATA_DESC structure.

Return Value:

    The function status is the final status of the operation.

--*/

{
    return ndispConvOffsetToPointer( MasterBuffer,
                                     MasterLength,
                                     &Var->Offset,
                                     Var->Length,
                                     sizeof(WCHAR) );
}

NTSTATUS
FASTCALL
ndisHandlePnPRequest(
    IN  PIRP        pIrp
    )
/*++

Routine Description:

    Handler for PnP ioctls.

Arguments:

Return Value:

--*/
{
    NTSTATUS            Status = STATUS_SUCCESS;
    PNDIS_PNP_OPERATION PnPOp;
    PNDIS_ENUM_INTF     EnumIntf;
    PIO_STACK_LOCATION  pIrpSp;
    UNICODE_STRING      Device;
    ULONG               Method;
    PVOID               pBuf;
    UINT                iBufLen, oBufLen;
    UINT                AmtCopied;          
#if defined(_WIN64)
    PUCHAR              pThunkBuf = NULL; // in case we thunk from 32-bit
#endif
    PNDIS_DEVICE_OBJECT_OPEN_CONTEXT OpenContext;
    BOOLEAN             AdminAccessAllowed = FALSE;

    PAGED_CODE( );

    pIrpSp = IoGetCurrentIrpStackLocation(pIrp);
    
    OpenContext = pIrpSp->FileObject->FsContext;
    if (OpenContext == NULL)
    {
        return STATUS_NO_SUCH_FILE;
    }
    AdminAccessAllowed = OpenContext->AdminAccessAllowed;

    Method = pIrpSp->Parameters.DeviceIoControl.IoControlCode & 3;

    // Ensure that the method is buffered - we always use that.
    if (Method == METHOD_BUFFERED)
    {
        // Get the output buffer and its length. Input and Output buffers are
        // both pointed to by the SystemBuffer
        iBufLen = pIrpSp->Parameters.DeviceIoControl.InputBufferLength;
        oBufLen = pIrpSp->Parameters.DeviceIoControl.OutputBufferLength;
        pBuf = pIrp->AssociatedIrp.SystemBuffer;
    }
    else
    {
        return STATUS_INVALID_PARAMETER;
    }

    switch (pIrpSp->Parameters.DeviceIoControl.IoControlCode)
    {
      case IOCTL_NDIS_ADD_TDI_DEVICE:
        if (!AdminAccessAllowed)
        {
            return STATUS_ACCESS_DENIED;
            
        }
        //
        // Validate the DeviceName
        //
        Status = STATUS_INVALID_PARAMETER;
        if ((iBufLen > 0) && ((iBufLen % sizeof(WCHAR)) == 0))
        {
            ((PWCHAR)pBuf)[iBufLen/sizeof(WCHAR) - 1] = 0;
            RtlInitUnicodeString(&Device, pBuf);
            Status = ndisHandleLegacyTransport(&Device);
        }
        break;
    
      case IOCTL_NDIS_DO_PNP_OPERATION:
        if (!AdminAccessAllowed)
        {
            return STATUS_ACCESS_DENIED;
            
        }
        Status = STATUS_BUFFER_TOO_SMALL;
        PnPOp = (PNDIS_PNP_OPERATION)pBuf;
#if defined(_WIN64)
        if (IoIs32bitProcess(pIrp))
        {
            PNDIS_PNP_OPERATION32   PnPOp32;
            PUCHAR                  ThunkPtr;

            PnPOp32 = (PNDIS_PNP_OPERATION32)pBuf;

            //
            // Validate structure based on its 32-bit definition
            //
            if ((iBufLen < sizeof(NDIS_PNP_OPERATION32)) ||
                (iBufLen < sizeof(NDIS_PNP_OPERATION32) +
                            PnPOp32->LowerComponent.MaximumLength +
                            PnPOp32->UpperComponent.MaximumLength))
            {
                break;
            }

            pThunkBuf = ALLOC_FROM_POOL(sizeof(NDIS_PNP_OPERATION) +
                                        PnPOp32->LowerComponent.MaximumLength +
                                        PnPOp32->UpperComponent.MaximumLength, NDIS_TAG_DEFAULT);
            if (pThunkBuf == NULL)
            {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                break;
            }

            PnPOp = (PNDIS_PNP_OPERATION)pThunkBuf;
            PnPOp->Layer = PnPOp32->Layer;
            PnPOp->Operation = PnPOp32->Operation;
            ThunkPtr = (PUCHAR)PnPOp + sizeof(NDIS_PNP_OPERATION);

            //
            // LowerComponent:
            //
            PnPOp->LowerComponent.MaximumLength = PnPOp32->LowerComponent.MaximumLength;
            PnPOp->LowerComponent.Length = PnPOp32->LowerComponent.Length;
            PnPOp->LowerComponent.Offset = ThunkPtr - (PUCHAR)&PnPOp->LowerComponent;
            NdisMoveMemory((PUCHAR)ThunkPtr, (PUCHAR)&PnPOp32->LowerComponent + PnPOp32->LowerComponent.Offset, PnPOp32->LowerComponent.MaximumLength);
            ThunkPtr += PnPOp->LowerComponent.MaximumLength;

            //
            // UpperComponent:
            //
            PnPOp->UpperComponent.MaximumLength = PnPOp32->UpperComponent.MaximumLength;
            PnPOp->UpperComponent.Length = PnPOp32->UpperComponent.Length;
            PnPOp->UpperComponent.Offset = ThunkPtr - (PUCHAR)&PnPOp->UpperComponent;
            NdisMoveMemory((PUCHAR)ThunkPtr, (PUCHAR)&PnPOp32->UpperComponent + PnPOp32->UpperComponent.Offset, PnPOp32->UpperComponent.MaximumLength);
            ThunkPtr += PnPOp->UpperComponent.MaximumLength;

            //
            // BindList:
            //
            PnPOp->BindList.MaximumLength = PnPOp32->BindList.MaximumLength;
            PnPOp->BindList.Length = PnPOp32->BindList.Length;
            PnPOp->BindList.Offset = ThunkPtr - (PUCHAR)&PnPOp->BindList;
            NdisMoveMemory((PUCHAR)ThunkPtr, (PUCHAR)&PnPOp32->BindList + PnPOp32->BindList.Offset, PnPOp32->BindList.MaximumLength);
            ThunkPtr += PnPOp->BindList.MaximumLength;
        }
        else
        {
            //
            // Not a 32-bit process on Win64
            //
            if ((iBufLen < sizeof(NDIS_PNP_OPERATION)) ||
                (iBufLen < (sizeof(NDIS_PNP_OPERATION) +
                            PnPOp->LowerComponent.MaximumLength +
                            PnPOp->UpperComponent.MaximumLength)))
            {
                break;
            }
        }
#else
        if ((iBufLen < sizeof(NDIS_PNP_OPERATION)) ||
            (iBufLen < (sizeof(NDIS_PNP_OPERATION) +
                        PnPOp->LowerComponent.MaximumLength +
                        PnPOp->UpperComponent.MaximumLength)))
        {
            break;
        }
#endif // _WIN64

        //
        // Convert the four buffer offsets within NDIS_PNP_OPERATION
        // to pointers.
        //

        Status = ndispConvVar( PnPOp, iBufLen, &PnPOp->LowerComponent );
        if (!NT_SUCCESS(Status))
        {
            break;
        }

        Status = ndispConvVar( PnPOp, iBufLen, &PnPOp->UpperComponent );
        if (!NT_SUCCESS(Status))
        {
            break;
        }

        Status = ndispConvVar( PnPOp, iBufLen, &PnPOp->BindList );
        if (!NT_SUCCESS(Status))
        {
            break;
        }

        Status = ndispConvOffsetToPointer( PnPOp,
                                        iBufLen,
                                        &PnPOp->ReConfigBufferOff,
                                        PnPOp->ReConfigBufferSize,
                                        sizeof(ULONG_PTR) );
        if (!NT_SUCCESS(Status))
        {
            break;
        }

        Status = ndisHandleUModePnPOp(PnPOp);

        break;

      case IOCTL_NDIS_ENUMERATE_INTERFACES:
#if defined(_WIN64)
        if (IoIs32bitProcess(pIrp))
        {
            if (oBufLen >= sizeof(NDIS_ENUM_INTF32))
            {
                Status = ndisEnumerateInterfaces32(pBuf, oBufLen);
                pIrp->IoStatus.Information = oBufLen;
            }
            else
            {
                Status = STATUS_BUFFER_TOO_SMALL;
            }
            break;
        }
#endif
        if (oBufLen >= sizeof(NDIS_ENUM_INTF))
        {
            EnumIntf = (PNDIS_ENUM_INTF)pBuf;
            Status = ndisEnumerateInterfaces(pBuf, oBufLen);
            pIrp->IoStatus.Information = oBufLen;
        }
        else Status = STATUS_BUFFER_TOO_SMALL;
        break;
        
      case IOCTL_NDIS_GET_VERSION:
        if (oBufLen < sizeof(UINT))
        {
            Status = STATUS_BUFFER_TOO_SMALL;
        }
        else
        {
            *((PUINT)pBuf) = NdisGetVersion();
            if (oBufLen >= 2 * sizeof(UINT))
            {
                *((PUINT)pBuf + 1) = (UINT)ndisChecked;
            }
            Status = STATUS_SUCCESS; 
        }
        break;

      default:
        break;
    }

    ASSERT (CURRENT_IRQL < DISPATCH_LEVEL);

#if defined(_WIN64)
    if (pThunkBuf)
    {
        FREE_POOL(pThunkBuf);
    }
#endif

    return Status;
}


NTSTATUS
FASTCALL
ndisHandleUModePnPOp(
    IN  PNDIS_PNP_OPERATION         PnPOp
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    NTSTATUS        Status;
    PUNICODE_STRING Protocol, Device, BindList;

    WAIT_FOR_OBJECT(&ndisPnPMutex, NULL);
    ndisPnPMutexOwner = MODULE_NUMBER + __LINE__;
    
    //
    // Upcase the protocol and device names
    //
    Protocol = (PUNICODE_STRING)&PnPOp->UpperComponent;
    Device = (PUNICODE_STRING)&PnPOp->LowerComponent;
    BindList = (PUNICODE_STRING)&PnPOp->BindList;

    if (PnPOp->Operation == BIND)
    {
        DBGPRINT(DBG_COMP_ALL, DBG_LEVEL_ERR,
                ("BIND  (%s) %Z to %Z\n",  (PnPOp->Layer == NDIS) ? "NDIS" : "TDI ", Protocol, Device));
    }
    else if (PnPOp->Operation == UNBIND)
    {
        DBGPRINT(DBG_COMP_ALL, DBG_LEVEL_ERR,
                ("UNBIND(%s) %Z to %Z\n",  (PnPOp->Layer == NDIS) ? "NDIS" : "TDI ", Protocol, Device));
    }
    switch (PnPOp->Layer)
    {
      case TDI:
        //
        // Call into the TDI handler to do this
        //
        if (ndisTdiPnPHandler != NULL)
        {
            Status = (*ndisTdiPnPHandler)(Protocol,
                                          Device,
                                          BindList,
                                          PnPOp->ReConfigBufferPtr,
                                          PnPOp->ReConfigBufferSize,
                                          PnPOp->Operation);
        }
        else
        {
            Status = STATUS_UNSUCCESSFUL;
        }
        break;

      case NDIS:
        switch (PnPOp->Operation)
        {
          case BIND:
            Status = ndisHandleProtocolBindNotification(Device, Protocol);
            break;

          case UNBIND:
            Status = ndisHandleProtocolUnbindNotification(Device, Protocol);
            break;

          case RECONFIGURE:
          case BIND_LIST:
            Status = ndisHandleProtocolReconfigNotification(Device,
                                                            Protocol,
                                                            PnPOp->ReConfigBufferPtr,
                                                            PnPOp->ReConfigBufferSize,
                                                            PnPOp->Operation);
            break;

          case UNLOAD:
            Status = ndisHandleProtocolUnloadNotification(Protocol);
            break;

          case REMOVE_DEVICE:
            Status = ndisHandleOrphanDevice(Device);
            break;
            
          default:
            Status = STATUS_INVALID_PARAMETER;
            break;
        }
        break;


      default:
        Status = STATUS_INVALID_PARAMETER;
        break;
    }
    
    ndisPnPMutexOwner = 0;
    RELEASE_MUTEX(&ndisPnPMutex);

    return Status;
}


NTSTATUS
FASTCALL
ndisHandleProtocolBindNotification(
    IN  PUNICODE_STRING                 DeviceName,
    IN  PUNICODE_STRING                 ProtocolName
    )
/*++

Routine Description:
    Given a erotocol's name and an adapter's name, this routine creates a binding between
    a protocol and an adapter (assuming protocol has a BindAdapterHandler)

Arguments:
    DeviceName: Adapter device name i.e. \Device\{GUID}
    ProtocolName Protocols name i.e. TCPIP

Return Value:
    STATUS_SUCCESS if we could call BindAdapterHandler
    STATUS_UNSUCCESSFUL otherwise

Note
    This routine does not return the status of attempted bind, rather if it -could- attempt to bind!    
--*/
{
    NTSTATUS                Status = STATUS_SUCCESS;
    PNDIS_PROTOCOL_BLOCK    Protocol = NULL;
    PNDIS_MINIPORT_BLOCK    Miniport = NULL;

    DBGPRINT_RAW(DBG_COMP_BIND, DBG_LEVEL_INFO,
            ("==>ndisHandleProtocolBindNotification\n"));

    do
    {
        ndisReferenceMiniportByName(DeviceName, &Miniport);

        if (Miniport == NULL)
        {
            Status = STATUS_OBJECT_NAME_NOT_FOUND;
            break;
        }
        
        //
        // Map ProtocolName to the Protocol block
        //
        Status = ndisReferenceProtocolByName(ProtocolName, &Protocol, FALSE);
        if (!NT_SUCCESS(Status))
        {
            Protocol = NULL;
            Status = STATUS_SUCCESS;
            break;
        }

        //
        // Bind this protocols
        //
        ndisCheckAdapterBindings(Miniport, Protocol);
    } while (FALSE);

    if (Protocol != NULL)
    {
        ndisDereferenceProtocol(Protocol);
    }

    if (Miniport != NULL)
    {
        MINIPORT_DECREMENT_REF(Miniport);
    }

    DBGPRINT_RAW(DBG_COMP_BIND, DBG_LEVEL_INFO,
            ("<==ndisHandleProtocolBindNotification\n"));
            
    return Status;
}


NTSTATUS
FASTCALL
ndisHandleProtocolUnbindNotification(
    IN  PUNICODE_STRING                 DeviceName,
    IN  PUNICODE_STRING                 ProtocolName
    )
/*++

Routine Description:


Arguments:


Return Value:

--*/
{
    NTSTATUS                Status;
    PNDIS_OPEN_BLOCK        Open;
    PNDIS_PROTOCOL_BLOCK    Protocol = NULL;
    PNDIS_MINIPORT_BLOCK    Miniport = NULL;
    BOOLEAN                 fPartial = FALSE;
    
    DBGPRINT_RAW(DBG_COMP_BIND, DBG_LEVEL_INFO,
            ("==>ndisHandleProtocolUnbindNotification\n"));

    do
    {
        //
        // Map ProtocolName to the Protocol block
        //
        Status = ndisReferenceProtocolByName(ProtocolName, &Protocol, FALSE);
        if (!NT_SUCCESS(Status))
        {
            DBGPRINT_RAW(DBG_COMP_BIND, DBG_LEVEL_INFO,
                    ("ndisHandleProtocolUnbindNotification: ndisReferenceProtocolByName failed %lx\n", Status));
            Status = STATUS_SUCCESS;
            Protocol = NULL;
            break;
        }
    
        do
        {
            Open = ndisMapOpenByName(DeviceName, Protocol, TRUE, TRUE);

            if (Open == NULL)
            {
                // 
                // There is no -active- binding between this adapter and protocol.
                // This would normally be an error but we need one special case for
                // TCP/IP Arp modules. We can unbind notifications for TCP/IP which
                // are actually destined for the ARP module.
                // We also know that either TCP/IP or ONE and ONLY ONE arp module can be
                // bound to an adapter. Make use of that knowledge.
                //
                ndisDereferenceProtocol(Protocol);
                if (!fPartial)
                {
                    fPartial = TRUE;
                    Protocol = NULL;
                }
                Status = ndisReferenceProtocolByName(ProtocolName, &Protocol, TRUE);
                if (!NT_SUCCESS(Status))
                {
                    break;
                }
            }
        } while (Open == NULL);
        
        DBGPRINT_RAW(DBG_COMP_BIND, DBG_LEVEL_INFO,
            ("ndisHandleProtocolUnbindNotification: Open %p\n", Open));

        if (Open != NULL)
        {
        
            Miniport = Open->MiniportHandle;
            Status = ndisUnbindProtocol(Open, TRUE);
            
            if (Status != NDIS_STATUS_SUCCESS)
            {
                KIRQL               OldIrql;
                PNDIS_OPEN_BLOCK    tmpOpen;
                
                //
                // check to see if the open is still there and if it is
                // clear the UNBIND flag. Note that we were the one
                // setting the flag, so we can clear it ourselves
                //
                ACQUIRE_SPIN_LOCK(&Protocol->Ref.SpinLock, &OldIrql);
                for (tmpOpen = Protocol->OpenQueue;
                     tmpOpen != NULL;
                     tmpOpen = tmpOpen->ProtocolNextOpen)
                {
                    if(tmpOpen == Open)
                    {
                        ACQUIRE_SPIN_LOCK_DPC(&Open->SpinLock);
                        MINIPORT_CLEAR_FLAG(Open, fMINIPORT_OPEN_UNBINDING | 
                                                  fMINIPORT_OPEN_DONT_FREE |
                                                  fMINIPORT_OPEN_PROCESSING);
                        RELEASE_SPIN_LOCK_DPC(&Open->SpinLock);
                        break;
                    }
                }
                RELEASE_SPIN_LOCK(&Protocol->Ref.SpinLock, OldIrql);
            }
        }

    } while (FALSE);

    if (Miniport != NULL)
    {
        MINIPORT_DECREMENT_REF(Miniport);
    }

    if (Protocol != NULL)
    {
        ndisDereferenceProtocol(Protocol);
    }

    DBGPRINT_RAW(DBG_COMP_BIND, DBG_LEVEL_INFO,
            ("<==ndisHandleProtocolUnbindNotification: Protocol %p, Status %lx\n", Protocol, Status));

    return Status;
}


NTSTATUS
ndisHandleProtocolReconfigNotification(
    IN  PUNICODE_STRING                 DeviceName,
    IN  PUNICODE_STRING                 ProtocolName,
    IN  PVOID                           ReConfigBuffer,
    IN  UINT                            ReConfigBufferSize,
    IN  UINT                            Operation
    )
/*++

Routine Description:

    This routine will notify protocols of a cahnge in their configuration -or-
    their bind list

Arguments:
    DeviceName:        Adapter's name (if specified). if NULL, it means the change is global and not bind specific
    ProtocolName:       Protocol's name
    ReConfigBuffer: information buffer
    ReConfigBufferSize: Information buffer size
    Operation:      RECONFIGURE or BIND_LIST

Return Value:

--*/
{
    NTSTATUS                    Status;
    KIRQL                       OldIrql;
    PNDIS_PROTOCOL_BLOCK        Protocol = NULL;
    PNDIS_OPEN_BLOCK            Open = NULL;
    NET_PNP_EVENT               NetPnpEvent;
    PNDIS_PNP_EVENT_RESERVED    EventReserved;
    KEVENT                      Event;
    BOOLEAN                     fPartial = FALSE;

    DBGPRINT_RAW(DBG_COMP_PROTOCOL, DBG_LEVEL_INFO,
            ("==>ndisHandleProtocolReconfigNotification\n"));

    do
    {
        //
        // Map ProtocolName to the Protocol block
        //
        Status = ndisReferenceProtocolByName(ProtocolName, &Protocol, FALSE);
        if (!NT_SUCCESS(Status))
        {
            Protocol = NULL;
            break;
        }

        //
        // We can be passed a NULL device-name which implies global reconfig and we call
        // the protocol's event handler with a NULL BindingContext
        //
        if (DeviceName->Length != 0)
        {
            ASSERT(Operation == RECONFIGURE);
            
            do
            {
                WAIT_FOR_PROTO_MUTEX(Protocol);
                Open = ndisMapOpenByName(DeviceName, Protocol, FALSE, FALSE);
    
                if (Open == NULL)
                {
                    RELEASE_PROT_MUTEX(Protocol);

                    // 
                    // There is no -active- binding between this adapter and protocol.
                    // This would normally be an error but we need one special case for
                    // TCP/IP Arp modules. We can unbind notifications for TCP/IP which
                    // are actually destined for the ARP module.
                    // We also know that either TCP/IP or ONE and ONLY ONE arp module can be
                    // bound to an adapter. Make use of that knowledge.
                    //
                    ndisDereferenceProtocol(Protocol);
                    if (!fPartial)
                    {
                        fPartial = TRUE;
                        Protocol = NULL;
                    }
                    Status = ndisReferenceProtocolByName(ProtocolName, &Protocol, TRUE);
                    if (!NT_SUCCESS(Status))
                    {
                        break;
                    }
                }
            } while (Open == NULL);

            if (Open == NULL)
            {
                //
                // if Open == NULL we are not holding the protocol mutex
                //
                Status = STATUS_OBJECT_NAME_NOT_FOUND;
                break;
            }
            else if (Protocol->ProtocolCharacteristics.PnPEventHandler == NULL)
            {
                //
                // Open is not NULL, we -are- holding the protocol mutex. release
                // it before breaking out
                //
                RELEASE_PROT_MUTEX(Protocol);
                Status = STATUS_UNSUCCESSFUL;
                break;
            }
        }
        else
        {
            //
            // the device is NULL, just grab the protocol mutex
            //
            if (Protocol->ProtocolCharacteristics.PnPEventHandler != NULL)
            {
                WAIT_FOR_PROTO_MUTEX(Protocol);
            }
            else
            {
                Status = STATUS_UNSUCCESSFUL;
                break;
            }
        }


        //
        // Setup the PnPEvent buffer
        //
        NdisZeroMemory(&NetPnpEvent, sizeof(NetPnpEvent));
        switch (Operation)
        {
          case RECONFIGURE:
            NetPnpEvent.NetEvent = NetEventReconfigure;
            break;
            
          case BIND_LIST:
            NetPnpEvent.NetEvent = NetEventBindList;
            break;
            
          default:
            ASSERT(FALSE);
            break;
        }
            
        NetPnpEvent.Buffer = ReConfigBuffer;
        NetPnpEvent.BufferLength = ReConfigBufferSize;

        //
        //  Get a pointer to the NDIS reserved are in the PnP event.
        //
        EventReserved = PNDIS_PNP_EVENT_RESERVED_FROM_NET_PNP_EVENT(&NetPnpEvent);
        INITIALIZE_EVENT(&Event);
        EventReserved->pEvent = &Event;

        //
        // Notify the protocol now
        //
        Status = (Protocol->ProtocolCharacteristics.PnPEventHandler)(
                        (Open != NULL) ? Open->ProtocolBindingContext : NULL,
                        &NetPnpEvent);
    
        if (NDIS_STATUS_PENDING == Status)
        {
            //
            //  Wait for completion.
            //
            WAIT_FOR_PROTOCOL(Protocol, &Event);
    
            //
            //  Get the completion status.
            //
            Status = EventReserved->Status;
        }

        if (Open)
        {
            ACQUIRE_SPIN_LOCK(&Open->SpinLock, &OldIrql);
            MINIPORT_CLEAR_FLAG(Open, fMINIPORT_OPEN_PROCESSING);
            RELEASE_SPIN_LOCK(&Open->SpinLock, OldIrql);
        }

        RELEASE_PROT_MUTEX(Protocol);

    } while (FALSE);

    if (Protocol != NULL)
    {
        ndisDereferenceProtocol(Protocol);
    }
    
    DBGPRINT_RAW(DBG_COMP_PROTOCOL, DBG_LEVEL_INFO,
            ("<==ndisHandleProtocolReconfigNotification\n"));
            
    return Status;
}


NTSTATUS
FASTCALL
ndisHandleProtocolUnloadNotification(
    IN  PUNICODE_STRING                 ProtocolName
    )
/*++

Routine Description:


Arguments:


Return Value:

--*/
{
    NTSTATUS                    Status;
    PNDIS_PROTOCOL_BLOCK        Protocol = NULL;

    DBGPRINT_RAW(DBG_COMP_PROTOCOL, DBG_LEVEL_INFO,
            ("==>ndisHandleProtocolUnloadNotification\n"));

    //
    // Map ProtocolName to the Protocol block
    //
    Status = ndisReferenceProtocolByName(ProtocolName, &Protocol, FALSE);

    if (NT_SUCCESS(Status))
    {
        ndisDereferenceProtocol(Protocol);

        if (Protocol->ProtocolCharacteristics.UnloadHandler != NULL)
        {
            (Protocol->ProtocolCharacteristics.UnloadHandler)();
        }
        else
        {
            Status = STATUS_UNSUCCESSFUL;
        }
    }

    DBGPRINT_RAW(DBG_COMP_PROTOCOL, DBG_LEVEL_INFO,
            ("<==ndisHandleProtocolUnloadNotification\n"));
            
    return Status;
}


NTSTATUS
FASTCALL
ndisHandleOrphanDevice(
    IN  PUNICODE_STRING                 pDevice
    )
/*++

Routine Description:


Arguments:


Return Value:

--*/
{
    NTSTATUS                Status;
    KIRQL                   OldIrql;
    BOOLEAN                 fFound = FALSE;
    PNDIS_M_DRIVER_BLOCK    MiniBlock;
    PNDIS_MINIPORT_BLOCK    Miniport = NULL;
    UNICODE_STRING          UpcaseDevice;

    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
            ("==>ndisHandleOrphanDevice\n"));
            
    UpcaseDevice.Length = pDevice->Length;
    UpcaseDevice.MaximumLength = pDevice->Length + sizeof(WCHAR);
    UpcaseDevice.Buffer = ALLOC_FROM_POOL(UpcaseDevice.MaximumLength, NDIS_TAG_STRING);

    if (UpcaseDevice.Buffer == NULL)
    {
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    Status = RtlUpcaseUnicodeString(&UpcaseDevice, pDevice, FALSE);
    ASSERT (NT_SUCCESS(Status));

    ACQUIRE_SPIN_LOCK(&ndisMiniDriverListLock, &OldIrql);
    
    for (MiniBlock = ndisMiniDriverList;
         (MiniBlock != NULL) && !fFound;
         MiniBlock = MiniBlock->NextDriver)
    {
        ACQUIRE_SPIN_LOCK_DPC(&MiniBlock->Ref.SpinLock);
    
        for (Miniport = MiniBlock->MiniportQueue;
             Miniport != NULL;
             Miniport = Miniport->NextMiniport)
        {
            if (NDIS_EQUAL_UNICODE_STRING(&UpcaseDevice, &Miniport->MiniportName))
            {
                fFound = TRUE;
                NDIS_ACQUIRE_MINIPORT_SPIN_LOCK_DPC(Miniport);
                MINIPORT_PNP_SET_FLAG(Miniport, fMINIPORT_ORPHANED);
                NDIS_RELEASE_MINIPORT_SPIN_LOCK_DPC(Miniport);
                break;
            }
        }
    
        RELEASE_SPIN_LOCK_DPC(&MiniBlock->Ref.SpinLock);
    }

    RELEASE_SPIN_LOCK(&ndisMiniDriverListLock, OldIrql);

    FREE_POOL(UpcaseDevice.Buffer);
    
    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
            ("<==ndisHandleOrphanDevice\n"));

    return STATUS_SUCCESS;
}


NTSTATUS
FASTCALL
ndisEnumerateInterfaces(
    IN  PNDIS_ENUM_INTF                 EnumIntf,
    IN  UINT                            BufferLength
    )
{
    PNDIS_MINIPORT_BLOCK    Miniport;
    PNDIS_M_DRIVER_BLOCK    MiniBlock;
    PNDIS_INTERFACE         Interface;
    UINT                    SpaceLeft = BufferLength - sizeof(NDIS_ENUM_INTF);
    UINT                    SpaceNeeded;
    PUCHAR                  pBuf;
    KIRQL                   OldIrql;
    NTSTATUS                Status = STATUS_SUCCESS;

    NdisZeroMemory(EnumIntf, BufferLength);
    Interface = &EnumIntf->Interface[0];
    pBuf = (PUCHAR)EnumIntf + BufferLength;

    ACQUIRE_SPIN_LOCK(&ndisMiniDriverListLock, &OldIrql);

    for (MiniBlock = ndisMiniDriverList;
         MiniBlock != NULL;
         MiniBlock = MiniBlock->NextDriver)
    {
        ACQUIRE_SPIN_LOCK_DPC(&MiniBlock->Ref.SpinLock);

        for (Miniport = MiniBlock->MiniportQueue;
             Miniport != NULL;
             Miniport = Miniport->NextMiniport)
        {
            if (Miniport->PnPDeviceState != NdisPnPDeviceStarted)
            {
                continue;
            }

            EnumIntf->AvailableInterfaces ++;
            SpaceNeeded = sizeof(NDIS_INTERFACE) +
                            Miniport->MiniportName.Length +
                            Miniport->pAdapterInstanceName->Length;
            EnumIntf->BytesNeeded += SpaceNeeded;
            if (SpaceLeft >= SpaceNeeded)
            {
                EnumIntf->TotalInterfaces ++;
                SpaceLeft -= SpaceNeeded;

                pBuf -= Miniport->MiniportName.Length;
                Interface->DeviceName.Buffer = (PWSTR)pBuf;
                Interface->DeviceName.MaximumLength = 
                Interface->DeviceName.Length = Miniport->MiniportName.Length;
                CopyMemory(pBuf, Miniport->MiniportName.Buffer, Interface->DeviceName.Length);
                POINTER_TO_OFFSET(Interface->DeviceName.Buffer, EnumIntf);

                pBuf -= Miniport->pAdapterInstanceName->Length;
                Interface->DeviceDescription.Buffer = (PWSTR)pBuf;
                Interface->DeviceDescription.MaximumLength = 
                Interface->DeviceDescription.Length = Miniport->pAdapterInstanceName->Length;
                CopyMemory(pBuf, Miniport->pAdapterInstanceName->Buffer, Interface->DeviceDescription.Length);
                
                POINTER_TO_OFFSET(Interface->DeviceDescription.Buffer, EnumIntf);
                Interface ++;
            }
        }

        RELEASE_SPIN_LOCK_DPC(&MiniBlock->Ref.SpinLock);
    }

    RELEASE_SPIN_LOCK(&ndisMiniDriverListLock, OldIrql);

    return Status;
}

#if defined(_WIN64)

//
// Version of ndisEnumerateInterfaces that operates on 32-bit ioctl structures.
// This is to support 32-bit apps running on Win64.
//
NTSTATUS
FASTCALL
ndisEnumerateInterfaces32(
    IN  PNDIS_ENUM_INTF32               EnumIntf,
    IN  UINT                            BufferLength
    )
{
    PNDIS_MINIPORT_BLOCK    Miniport;
    PNDIS_M_DRIVER_BLOCK    MiniBlock;
    PNDIS_INTERFACE32       Interface;
    UINT                    SpaceLeft = BufferLength - sizeof(NDIS_ENUM_INTF32);
    UINT                    SpaceNeeded;
    PUCHAR                  pBuf;
    KIRQL                   OldIrql;
    NTSTATUS                Status = STATUS_SUCCESS;

    NdisZeroMemory(EnumIntf, BufferLength);
    Interface = &EnumIntf->Interface[0];
    pBuf = (PUCHAR)EnumIntf + BufferLength;

    ACQUIRE_SPIN_LOCK(&ndisMiniDriverListLock, &OldIrql);

    for (MiniBlock = ndisMiniDriverList;
         MiniBlock != NULL;
         MiniBlock = MiniBlock->NextDriver)
    {
        ACQUIRE_SPIN_LOCK_DPC(&MiniBlock->Ref.SpinLock);

        for (Miniport = MiniBlock->MiniportQueue;
             Miniport != NULL;
             Miniport = Miniport->NextMiniport)
        {
            if (Miniport->PnPDeviceState != NdisPnPDeviceStarted)
            {
                continue;
            }

            EnumIntf->AvailableInterfaces ++;
            SpaceNeeded = sizeof(NDIS_INTERFACE32) +
                            Miniport->MiniportName.Length +
                            Miniport->pAdapterInstanceName->Length;
            if (SpaceLeft >= SpaceNeeded)
            {
                EnumIntf->TotalInterfaces ++;
                SpaceLeft -= SpaceNeeded;

                pBuf -= Miniport->MiniportName.Length;
                Interface->DeviceName.MaximumLength = 
                Interface->DeviceName.Length = Miniport->MiniportName.Length;
                CopyMemory(pBuf, Miniport->MiniportName.Buffer, Interface->DeviceName.Length);
                Interface->DeviceName.Buffer = (ULONG)((ULONG_PTR)pBuf - (ULONG_PTR)EnumIntf);

                pBuf -= Miniport->pAdapterInstanceName->Length;
                Interface->DeviceDescription.MaximumLength = 
                Interface->DeviceDescription.Length = Miniport->pAdapterInstanceName->Length;
                CopyMemory(pBuf, Miniport->pAdapterInstanceName->Buffer, Interface->DeviceDescription.Length);
                
                Interface->DeviceDescription.Buffer = (ULONG)((ULONG_PTR)pBuf - (ULONG_PTR)EnumIntf);
                Interface ++;
            }
        }

        RELEASE_SPIN_LOCK_DPC(&MiniBlock->Ref.SpinLock);
    }

    RELEASE_SPIN_LOCK(&ndisMiniDriverListLock, OldIrql);

    return Status;
}

#endif // _WIN64

NTSTATUS
ndisUnbindProtocol(
    IN  PNDIS_OPEN_BLOCK        Open,
    IN  BOOLEAN                 Notify
    )
/*+++

Routine Description:

Arguments:
    
Return Value:
    None

---*/
{
    NDIS_STATUS             Status = STATUS_SUCCESS;
    NDIS_BIND_CONTEXT       UnbindContext;
    PKMUTEX                 pMutex;
    PKEVENT                 CloseCompleteEvent = NULL;
    PNDIS_PROTOCOL_BLOCK    Protocol = Open->ProtocolHandle;
    PNDIS_OPEN_BLOCK        TmpOpen;
    PNDIS_MINIPORT_BLOCK    Miniport = Open->MiniportHandle;
    KIRQL                   OldIrql;
    BOOLEAN                 fDerefProtocol = FALSE;
    BOOLEAN                 FreeOpen;
    
    DBGPRINT_RAW(DBG_COMP_BIND, DBG_LEVEL_INFO,
            ("==>ndisUnbindProtocol: Open %p, Notify %d\n", Open, Notify));


    PnPReferencePackage();
    
    //
    // if this is called outside the context of the protocol deregistering, increment 
    // the ref count to make sure the protocol deregisteration does not go through
    // otherwise make note of the fact that we could not increment the ref count and avoid
    // deref at the end
    //
    
    if (ndisReferenceProtocol(Protocol))
    {
        fDerefProtocol = TRUE;
    }

    ASSERT(MINIPORT_TEST_FLAG(Open, fMINIPORT_OPEN_UNBINDING));

    CloseCompleteEvent = Open->CloseCompleteEvent;

    do
    {
        NTSTATUS     WaitStatus;
        pMutex = &Protocol->Mutex;
        WAIT_FOR_PROTO_MUTEX(Protocol);

        //
        // make sure the open didn't go away while we were waiting for
        // protocol mutex.
        //

        ACQUIRE_SPIN_LOCK(&Protocol->Ref.SpinLock, &OldIrql);
        for (TmpOpen = Protocol->OpenQueue; 
             TmpOpen != NULL; 
             TmpOpen = TmpOpen->ProtocolNextOpen)
        {
            if (TmpOpen == Open)
                break;
        }
        RELEASE_SPIN_LOCK(&Protocol->Ref.SpinLock, OldIrql);
        
        if (TmpOpen == NULL)
        {
            //
            // open went away while we were trying to get the protocol mutex
            // return right away
            //

            DBGPRINT_RAW(DBG_COMP_BIND, DBG_LEVEL_INFO,
            ("ndisUnbindProtocol: Open %p, Flags %lx was closed while we were waiting for the protocol mutex.\n", Open, Open->Flags));
            break;
        }
        
        //
        //  wait for all AF notifications to go through
        //
        if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_IS_CO))
        {
            KEVENT      AfNotifyCompleteEvent;

            INITIALIZE_EVENT(&AfNotifyCompleteEvent);
            
            Open->AfNotifyCompleteEvent = &AfNotifyCompleteEvent;
            
            if (Open->PendingAfNotifications != 0)
            {                
                WAIT_FOR_OBJECT(Open->AfNotifyCompleteEvent , 0);
            }
            
            Open->AfNotifyCompleteEvent = NULL;
            
        }

        //
        // Do a query-remove here first
        //
        if (Notify && (Protocol->ProtocolCharacteristics.PnPEventHandler != NULL))
        {
            NET_PNP_EVENT               NetPnpEvent;
            PNDIS_PNP_EVENT_RESERVED    EventReserved;
            KEVENT                      Event;
    
            RtlZeroMemory(&NetPnpEvent, sizeof(NET_PNP_EVENT));
            INITIALIZE_EVENT(&Event);
            EventReserved = PNDIS_PNP_EVENT_RESERVED_FROM_NET_PNP_EVENT(&NetPnpEvent);
            NetPnpEvent.NetEvent = NetEventQueryRemoveDevice;
            NetPnpEvent.Buffer = NULL;
            NetPnpEvent.BufferLength = 0;
            EventReserved->pEvent = &Event;
    
            //
            //  Indicate the event to the protocol.
            //
            Status = (Protocol->ProtocolCharacteristics.PnPEventHandler)(
                                        Open->ProtocolBindingContext,
                                        &NetPnpEvent);

            if (NDIS_STATUS_PENDING == Status)
            {
                //
                //  Wait for completion.
                //
                WAIT_FOR_PROTOCOL(Protocol, &Event);
    
                //
                //  Get the completion status.
                //
                Status = EventReserved->Status;
            }
    
            //
            //  Is the status OK?
            //
            if (Status != NDIS_STATUS_SUCCESS)
            {
                break;
            }
        }

        if (CloseCompleteEvent != NULL)
        {
            INITIALIZE_EVENT(CloseCompleteEvent);
        }

        //
        // Protocol ok with remove so now do it.
        //
        INITIALIZE_EVENT(&UnbindContext.Event);

        Status = NDIS_STATUS_SUCCESS;

        ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);

        (*Protocol->ProtocolCharacteristics.UnbindAdapterHandler)(
                &Status,
                Open->ProtocolBindingContext,
                &UnbindContext);

        ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);

        if (Status == NDIS_STATUS_PENDING)
        {
            WAIT_FOR_PROTOCOL(Protocol, &UnbindContext.Event);
            Status = UnbindContext.BindStatus;
        }

        ASSERT(Status == NDIS_STATUS_SUCCESS);

        ndisNotifyWmiBindUnbind(Miniport, Protocol, FALSE);
           
        ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);
        
        if (CloseCompleteEvent != NULL)
        {
            //
            // make sure the open is gone
            //
            WAIT_FOR_PROTOCOL(Protocol, CloseCompleteEvent);
        }
        
    } while (FALSE);

    RELEASE_MUTEX(pMutex);
    
    ACQUIRE_SPIN_LOCK(&Open->SpinLock, &OldIrql);
    //
    // did the close routine get our message not to free the open structure?
    //
    if (MINIPORT_TEST_FLAG(Open, fMINIPORT_OPEN_CLOSE_COMPLETE))
    {
        //
        // we have to get rid of open ourselves
        // 
        FreeOpen = TRUE;
    }
    else
    {
        //
        // for some reason, unbind did not go through or close is
        // still in progress
        //
        MINIPORT_CLEAR_FLAG(Open, fMINIPORT_OPEN_UNBINDING | 
                                  fMINIPORT_OPEN_DONT_FREE |
                                  fMINIPORT_OPEN_PROCESSING);
        FreeOpen = FALSE;
    }
    RELEASE_SPIN_LOCK(&Open->SpinLock, OldIrql);

    PnPDereferencePackage();

    if (FreeOpen)
    {
        ndisRemoveOpenFromGlobalList(Open);
        FREE_POOL(Open);
    }

    if (fDerefProtocol)
    {
        ndisDereferenceProtocol(Protocol);
    }
    
    DBGPRINT_RAW(DBG_COMP_BIND, DBG_LEVEL_INFO,
            ("<==ndisUnbindProtocol: Open %p, Notify %d, Status %lx\n", Open, Notify, Status));

    return(Status);
}

VOID
ndisReferenceMiniportByName(
    IN  PUNICODE_STRING             DeviceName,
    OUT PNDIS_MINIPORT_BLOCK    *   pMiniport
    )
{
    KIRQL                   OldIrql;
    PNDIS_M_DRIVER_BLOCK    MiniBlock;
    PNDIS_MINIPORT_BLOCK    Miniport = NULL;
    UNICODE_STRING          UpcaseDevice;

    DBGPRINT_RAW(DBG_COMP_REF, DBG_LEVEL_INFO,
            ("==>ndisReferenceMiniportByName\n"));
            
    *pMiniport = NULL;

    UpcaseDevice.Length = DeviceName->Length;
    UpcaseDevice.MaximumLength = DeviceName->Length + sizeof(WCHAR);
    UpcaseDevice.Buffer = ALLOC_FROM_POOL(UpcaseDevice.MaximumLength, NDIS_TAG_STRING);

    if (UpcaseDevice.Buffer == NULL)
    {
        return;
    }

    RtlUpcaseUnicodeString(&UpcaseDevice, DeviceName, FALSE);

    do
    {
        UINT    Depth = 1;

        ACQUIRE_SPIN_LOCK(&ndisMiniDriverListLock, &OldIrql);
    
        for (MiniBlock = ndisMiniDriverList;
             MiniBlock != NULL;
             MiniBlock = MiniBlock->NextDriver)
        {
            ACQUIRE_SPIN_LOCK_DPC(&MiniBlock->Ref.SpinLock);
    
            for (Miniport = MiniBlock->MiniportQueue;
                 Miniport != NULL;
                 Miniport = Miniport->NextMiniport)
            {
                if (!MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_ORPHANED) &&
                    (Miniport->BindPaths != NULL) &&
                    (Miniport->BindPaths->Number >= Depth) &&
                     NDIS_EQUAL_UNICODE_STRING(&UpcaseDevice, &Miniport->BindPaths->Paths[0]))
                {
                    if (*pMiniport != NULL)
                    {
                        MINIPORT_DECREMENT_REF(*pMiniport);
                        *pMiniport = NULL;
                    }
                    Depth = Miniport->BindPaths->Number;
                    if (MINIPORT_INCREMENT_REF(Miniport))
                    {
                        *pMiniport = Miniport;
                    }
                    break;
                }
            }
    
            RELEASE_SPIN_LOCK_DPC(&MiniBlock->Ref.SpinLock);
        }
    
    } while (FALSE);

    RELEASE_SPIN_LOCK(&ndisMiniDriverListLock, OldIrql);

    FREE_POOL(UpcaseDevice.Buffer);
    
    DBGPRINT_RAW(DBG_COMP_REF, DBG_LEVEL_INFO,
            ("<==ndisReferenceMiniportByName\n"));
}

PNDIS_OPEN_BLOCK
FASTCALL
ndisMapOpenByName(
    IN  PUNICODE_STRING                 DeviceName,
    IN  PNDIS_PROTOCOL_BLOCK            Protocol,
    IN  BOOLEAN                         Reference,
    IN  BOOLEAN                         fUnbinding
    )
{
    UNICODE_STRING          UpcaseDevice;
    PNDIS_OPEN_BLOCK        Open, tmpOpen;
    KIRQL                   OldIrql;

    DBGPRINT_RAW(DBG_COMP_BIND, DBG_LEVEL_INFO,
            ("==>ndisReferenceOpenByName, DeviceName %p, Protocol %p, fUnbinding %d\n",
                DeviceName, Protocol, fUnbinding));
            
    Open = NULL;
    
    UpcaseDevice.Length = DeviceName->Length;
    UpcaseDevice.MaximumLength = DeviceName->Length + sizeof(WCHAR);
    UpcaseDevice.Buffer = ALLOC_FROM_POOL(UpcaseDevice.MaximumLength, NDIS_TAG_STRING);
    
    
    if (UpcaseDevice.Buffer == NULL)
    {
        DBGPRINT_RAW(DBG_COMP_ALL, DBG_LEVEL_ERR,
                ("<==ndisReferenceOpenByName: failed to allocate memory.\n"));
        return NULL;
    }

    RtlUpcaseUnicodeString(&UpcaseDevice, DeviceName, FALSE);

    ACQUIRE_SPIN_LOCK(&Protocol->Ref.SpinLock, &OldIrql);

    //
    // Now walk the open list and get to the open representing the DeviceName
    //
    for (Open = Protocol->OpenQueue;
         Open != NULL;
         Open = Open->ProtocolNextOpen)
    {
        if (NDIS_EQUAL_UNICODE_STRING(&UpcaseDevice, Open->RootDeviceName))
        {            
            tmpOpen = Open;
            ACQUIRE_SPIN_LOCK_DPC(&tmpOpen->SpinLock);
            
            if (fUnbinding)
            {
                
                if (MINIPORT_TEST_FLAG(Open, fMINIPORT_OPEN_UNBINDING   | 
                                             fMINIPORT_OPEN_CLOSING     |
                                             fMINIPORT_OPEN_PROCESSING))
                {
                    DBGPRINT_RAW(DBG_COMP_BIND, DBG_LEVEL_INFO,
                            ("ndisReferenceOpenByName: Open %p is already getting unbind\n", Open));
                    Open = NULL;
                }
                else
                {
                    MINIPORT_SET_FLAG(Open, fMINIPORT_OPEN_UNBINDING | 
                                            fMINIPORT_OPEN_DONT_FREE |
                                            fMINIPORT_OPEN_PROCESSING);
                }
            }
            else
            {
                if (MINIPORT_TEST_FLAG(Open, fMINIPORT_OPEN_PROCESSING))
                {
                    Open = NULL;
                }
                else
                {
                    MINIPORT_SET_FLAG(Open, fMINIPORT_OPEN_PROCESSING); 
                }
            }
            RELEASE_SPIN_LOCK_DPC(&tmpOpen->SpinLock);

            break;
        }
    }

    RELEASE_SPIN_LOCK(&Protocol->Ref.SpinLock, OldIrql);

    if ((Open != NULL) && Reference)
    {
        PNDIS_MINIPORT_BLOCK    Miniport;

        Miniport = Open->MiniportHandle;
        if (!MINIPORT_INCREMENT_REF(Miniport))
        {
            if (fUnbinding)
            {
                MINIPORT_CLEAR_FLAG(Open, fMINIPORT_OPEN_UNBINDING  |
                                          fMINIPORT_OPEN_PROCESSING |
                                          fMINIPORT_OPEN_DONT_FREE);
            }
            else
            {
                MINIPORT_CLEAR_FLAG(Open, fMINIPORT_OPEN_PROCESSING); 
            }
            Open = NULL;
        }
    }

    FREE_POOL(UpcaseDevice.Buffer);
    
    DBGPRINT_RAW(DBG_COMP_BIND, DBG_LEVEL_INFO,
            ("<==ndisReferenceOpenByName: Open %p\n", Open ));
            
    return(Open);
}

NTSTATUS
FASTCALL
ndisHandleLegacyTransport(
    IN  PUNICODE_STRING             pDevice
    )
{
    NTSTATUS                    Status = STATUS_SUCCESS;
    RTL_QUERY_REGISTRY_TABLE    LinkQueryTable[3];
    PWSTR                       Export = NULL;
    HANDLE                      TdiHandle;
    
    DBGPRINT_RAW(DBG_COMP_PROTOCOL, DBG_LEVEL_INFO,
            ("==>ndisHandleLegacyTransport\n"));

    if (ndisTdiRegisterCallback == NULL)
    {
        DBGPRINT_RAW(DBG_COMP_CONFIG, DBG_LEVEL_INFO,
                ("<==ndisHandleLegacyTransport\n"));
        return STATUS_UNSUCCESSFUL;
    }

    //
    // Set up LinkQueryTable to do the following:
    //

    //
    // 1) Switch to the Linkage key below the xports registry key
    //

    LinkQueryTable[0].QueryRoutine = NULL;
    LinkQueryTable[0].Flags = RTL_QUERY_REGISTRY_SUBKEY;
    LinkQueryTable[0].Name = L"Linkage";

    //
    // 2) Call ndisReadParameter for "Export" (as a single multi-string),
    // which will allocate storage and save the data in Export.
    //

    LinkQueryTable[1].QueryRoutine = ndisReadParameter;
    LinkQueryTable[1].Flags = RTL_QUERY_REGISTRY_REQUIRED | RTL_QUERY_REGISTRY_NOEXPAND;
    LinkQueryTable[1].Name = L"Export";
    LinkQueryTable[1].EntryContext = (PVOID)&Export;
    LinkQueryTable[1].DefaultType = REG_NONE;

    //
    // 3) Stop
    //

    LinkQueryTable[2].QueryRoutine = NULL;
    LinkQueryTable[2].Flags = 0;
    LinkQueryTable[2].Name = NULL;

    do
    {
        UNICODE_STRING  Us;
        PWSTR           CurExport;

        Status = RtlQueryRegistryValues(RTL_REGISTRY_SERVICES,
                                        pDevice->Buffer,
                                        LinkQueryTable,
                                        (PVOID)NULL,      // no context needed
                                        NULL);


        if (!NT_SUCCESS(Status))
        {
            //
            // Do not complain about TDI drivers which do not
            // have any linkages
            //
            if (Status == STATUS_OBJECT_NAME_NOT_FOUND)
            {
                Status = STATUS_SUCCESS;
            }
            break;
        }

        //
        // Walk the list of exports and call TdiRegisterDevice for each
        //
        for (CurExport = Export;
             *CurExport != 0;
             CurExport = (PWCHAR)((PUCHAR)CurExport + Us.MaximumLength))
        {
            RtlInitUnicodeString (&Us, CurExport);

            Status = (*ndisTdiRegisterCallback)(&Us, &TdiHandle);
            if (!NT_SUCCESS(Status))
            {
                break;
            }
        }
    } while (FALSE);

    if (Export != NULL)
        FREE_POOL(Export);

    DBGPRINT_RAW(DBG_COMP_PROTOCOL, DBG_LEVEL_INFO,
            ("<==ndisHandleLegacyTransport\n"));
            
    return(Status);
}


VOID
FASTCALL
ndisInitializeBinding(
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  PNDIS_PROTOCOL_BLOCK    Protocol
    )
{
    PUNICODE_STRING         ExportName;
    NDIS_BIND_CONTEXT       BindContext;
    PDEVICE_OBJECT          PhysicalDeviceObject;
    NDIS_STATUS             BindStatus;
    UNICODE_STRING          ProtocolSection;
    UNICODE_STRING          DerivedBaseName, Parms;
    
    DBGPRINT_RAW(DBG_COMP_BIND, DBG_LEVEL_INFO,
            ("==>ndisInitializeBinding\n"));

    //
    // Call the protocol to bind to the Miniport
    //
    WAIT_FOR_PROTO_MUTEX(Protocol);

    do
    {
        //
        // once we grabbed the protocol mutex, check again to see if 
        // the adapter is still there
        //
        if (!ndisIsMiniportStarted(Miniport) ||

            ((Miniport->PnPDeviceState != NdisPnPDeviceStarted) &&
             (Miniport->PnPDeviceState != NdisPnPDeviceQueryStopped) &&
             (Miniport->PnPDeviceState != NdisPnPDeviceQueryRemoved)))
        {
            break;
        }

        if (TRUE == ndisProtocolAlreadyBound(Protocol, Miniport))
        {
            //
            // these two are already bound. just return
            //
            break;
        }
        
        ExportName = &Miniport->BindPaths->Paths[0];
        Protocol->BindDeviceName = &Miniport->MiniportName;
        Protocol->RootDeviceName = ExportName;
        PhysicalDeviceObject = Miniport->PhysicalDeviceObject;

        if (ndisReferenceProtocol(Protocol) == FALSE)
        {
            break;
        }

        RtlInitUnicodeString(&Parms, L"\\Parameters\\Adapters\\");

        DerivedBaseName = *ExportName;
        DerivedBaseName.Length -= ndisDeviceStr.Length;
        DerivedBaseName.MaximumLength -= ndisDeviceStr.Length;
        (PUCHAR)(DerivedBaseName.Buffer) += ndisDeviceStr.Length;

        ProtocolSection.MaximumLength = Protocol->ProtocolCharacteristics.Name.Length +         // "tcpip"
                                                 Parms.Length +                                 // "\Parameters\Adapters\"
                                                 ExportName->Length - ndisDeviceStr.Length +    // "{GUID}"
                                                 sizeof(WCHAR);
        ProtocolSection.Length = 0;
        ProtocolSection.Buffer = (PWSTR)ALLOC_FROM_POOL(ProtocolSection.MaximumLength,
                                                        NDIS_TAG_DEFAULT);
        if (ProtocolSection.Buffer != NULL)
        {
            ZeroMemory(ProtocolSection.Buffer, ProtocolSection.MaximumLength);
            RtlCopyUnicodeString(&ProtocolSection,
                                 &Protocol->ProtocolCharacteristics.Name);
            RtlAppendUnicodeStringToString(&ProtocolSection,
                                           &Parms);
            RtlAppendUnicodeStringToString(&ProtocolSection,
                                           &DerivedBaseName);
        }
        else
        {
            ndisDereferenceProtocol(Protocol);
            break;
        }


        BindContext.Next = NULL;
        BindContext.Protocol = Protocol;
        BindContext.Miniport = Miniport;
        BindContext.ProtocolSection = ProtocolSection;
        BindContext.DeviceName = ExportName;
        INITIALIZE_EVENT(&BindContext.Event);

        if (!Protocol->Ref.Closing)
        {
            BindStatus = NDIS_STATUS_SUCCESS;
            Protocol->BindingAdapter = Miniport;
            (*Protocol->ProtocolCharacteristics.BindAdapterHandler)(&BindStatus,
                                                                    &BindContext,
                                                                    ExportName,
                                                                    &ProtocolSection,
                                                                    (PVOID)PhysicalDeviceObject);
                                                                    
            if (BindStatus == NDIS_STATUS_PENDING)
            {
                WAIT_FOR_PROTOCOL(Protocol, &BindContext.Event);
                BindStatus = BindContext.BindStatus;
            }

            Protocol->BindingAdapter = NULL;
            if (BindStatus == NDIS_STATUS_SUCCESS)
            {
                ndisNotifyWmiBindUnbind(Miniport, Protocol, TRUE);
            }

#if DBG
            DBGPRINT_RAW(DBG_COMP_BIND, DBG_LEVEL_INFO,
                    ("  ndisInitializeBinding\n"));
            DBGPRINT_RAW(DBG_COMP_BIND, DBG_LEVEL_INFO,
                    ("    Protocol: "));
            DBGPRINT_UNICODE(DBG_COMP_BIND, DBG_LEVEL_INFO,
                    &Protocol->ProtocolCharacteristics.Name);
            DBGPRINT_RAW(DBG_COMP_BIND, DBG_LEVEL_INFO,
                    ("\n    Adapter: "));

            if (Miniport->pAdapterInstanceName)
            {
                DBGPRINT_UNICODE(DBG_COMP_BIND, DBG_LEVEL_INFO,
                        Miniport->pAdapterInstanceName);
            }
            else
            {
                DBGPRINT_UNICODE(DBG_COMP_INIT, DBG_LEVEL_INFO,
                        &Miniport->BaseName);
            }
            DBGPRINT_RAW(DBG_COMP_BIND, DBG_LEVEL_INFO,
                    ("\n    Result: %lx\n", BindStatus));
#endif
        }

        FREE_POOL(ProtocolSection.Buffer);
        
        Protocol->BindDeviceName = NULL;
        ndisDereferenceProtocol(Protocol);
        
    } while (FALSE);
    
    RELEASE_PROT_MUTEX(Protocol);

    DBGPRINT_RAW(DBG_COMP_BIND, DBG_LEVEL_INFO,
            ("<==ndisInitializeBinding\n"));
}


VOID
NdisCompleteBindAdapter(
    IN  NDIS_HANDLE         BindAdapterContext,
    IN  NDIS_STATUS         Status,
    IN  NDIS_STATUS         OpenStatus
    )
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    PNDIS_BIND_CONTEXT  pContext = (PNDIS_BIND_CONTEXT)BindAdapterContext;
    
    DBGPRINT_RAW(DBG_COMP_BIND, DBG_LEVEL_INFO,
            ("==>NdisCompleteBindAdapter\n"));

    pContext->BindStatus = Status;
    SET_EVENT(&pContext->Event);
    
    DBGPRINT_RAW(DBG_COMP_BIND, DBG_LEVEL_INFO,
            ("<==NdisCompleteBindAdapter\n"));
}

VOID
NdisCompleteUnbindAdapter(
    IN  NDIS_HANDLE         UnbindAdapterContext,
    IN  NDIS_STATUS         Status
    )
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    PNDIS_BIND_CONTEXT  pContext = (PNDIS_BIND_CONTEXT)UnbindAdapterContext;
    
    DBGPRINT_RAW(DBG_COMP_BIND, DBG_LEVEL_INFO,
            ("==>NdisCompleteUnbindAdapter\n"));

    pContext->BindStatus = Status;
    SET_EVENT(&pContext->Event);
    
    DBGPRINT_RAW(DBG_COMP_BIND, DBG_LEVEL_INFO,
            ("<==NdisCompleteUnbindAdapter\n"));
}

VOID
NdisRegisterTdiCallBack(
    IN  TDI_REGISTER_CALLBACK   RegisterCallback,
    IN  TDI_PNP_HANDLER         PnPHandler
    )
/*++

Routine Description:


Arguments:


Return Value:


--*/
{
    DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
            ("==>NdisRegisterTdiCallBack\n"));

    if (ndisTdiRegisterCallback == NULL)
    {
        ndisTdiRegisterCallback = RegisterCallback;
    }

    if (ndisTdiPnPHandler == NULL)
    {
        ndisTdiPnPHandler = PnPHandler;
    }
    
    DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
            ("<==NdisRegisterTdiCallBack\n"));
}

VOID
ndisFindRootDevice(
    IN  PNDIS_STRING                    DeviceName,
    IN  BOOLEAN                         fTester,
    OUT PNDIS_STRING *                  pBindDevice,
    OUT PNDIS_STRING *                  pRootDevice,
    OUT PNDIS_MINIPORT_BLOCK *          pAdapter
    )
/*++

Routine Description:

    Find the Miniport which is the highest level filter given the target root name.
Arguments:
    
Return Value:
    
--*/
{
    KIRQL                   OldIrql;
    PNDIS_M_DRIVER_BLOCK    MiniBlock;
    PNDIS_MINIPORT_BLOCK    Miniport;
    PNDIS_STRING            RootDevice, BindDevice;
    NDIS_STRING             UpcaseDevice;
    PWSTR                   pwch;
    UINT                    Depth = 1;
    BOOLEAN                 Found = FALSE;

    DBGPRINT(DBG_COMP_PNP, DBG_LEVEL_INFO,
            ("==>ndisFindRootDevice\n"));
            
    *pBindDevice = NULL;
    *pRootDevice = NULL;
    *pAdapter = NULL;
    
    //
    // First we need to upcase the device-name before checking
    //
    UpcaseDevice.Length = DeviceName->Length;
    UpcaseDevice.MaximumLength = DeviceName->Length + sizeof(WCHAR);
    UpcaseDevice.Buffer = ALLOC_FROM_POOL(UpcaseDevice.MaximumLength, NDIS_TAG_STRING);

    if ((pwch = UpcaseDevice.Buffer) == NULL)
    {
        return;
    }

    RtlUpcaseUnicodeString(&UpcaseDevice, DeviceName, FALSE);
    BindDevice = &UpcaseDevice;

    ASSERT(ndisPkgs[NPNP_PKG].ReferenceCount > 0);
    PnPReferencePackage();
    
    ACQUIRE_SPIN_LOCK(&ndisMiniDriverListLock, &OldIrql);

    for (MiniBlock = ndisMiniDriverList;
         MiniBlock != NULL;
         MiniBlock = MiniBlock->NextDriver)
    {
        ACQUIRE_SPIN_LOCK_DPC(&MiniBlock->Ref.SpinLock);

        for (Miniport = MiniBlock->MiniportQueue;
             Miniport != NULL;
             Miniport = Miniport->NextMiniport)
        {
            if (fTester)
            {
                if (NDIS_EQUAL_UNICODE_STRING(BindDevice, &Miniport->MiniportName))
                {
                    BindDevice = &Miniport->MiniportName;
                    RootDevice = &Miniport->MiniportName;
                    *pAdapter = Miniport;
                    Found = TRUE;
                    break;
                }
            }
            else if ((Miniport->BindPaths->Number >= Depth) &&
                     NDIS_EQUAL_UNICODE_STRING(BindDevice, &Miniport->BindPaths->Paths[0]))
            {
                RootDevice = &Miniport->BindPaths->Paths[0];
                BindDevice = &Miniport->MiniportName;
                *pAdapter = Miniport;
                Depth = Miniport->BindPaths->Number;
                Found = TRUE;
            }
        }

        RELEASE_SPIN_LOCK_DPC(&MiniBlock->Ref.SpinLock);

        if (fTester && Found)
        {
            break;
        }
    }

    RELEASE_SPIN_LOCK(&ndisMiniDriverListLock, OldIrql);
    PnPDereferencePackage();

    FREE_POOL(pwch);

    if (Found)
    {
        *pBindDevice = BindDevice;
        *pRootDevice = RootDevice;
    }

    DBGPRINT(DBG_COMP_PNP, DBG_LEVEL_INFO,
            ("<==ndisFindRootDevice\n"));
}


VOID
ndisNotifyWmiBindUnbind(
    PNDIS_MINIPORT_BLOCK                Miniport,
    PNDIS_PROTOCOL_BLOCK                Protocol,
    BOOLEAN                             fBind
    )
/*++

Routine Description:

    Notify WMI that either a bind or an unbind has occured.

Arguments:
    
Return Value:
    
--*/
{
    PWNODE_SINGLE_INSTANCE  wnode;
    PUCHAR                  ptmp;
    NTSTATUS                NtStatus;
    
    DBGPRINT(DBG_COMP_PNP, DBG_LEVEL_INFO,
            ("==>ndisNotifyWmiBindUnbind: Miniport %p, Protocol %p, fBind %lx\n", Miniport, Protocol, fBind));

    ndisSetupWmiNode(Miniport,
                     Miniport->pAdapterInstanceName,
                     Miniport->BindPaths->Paths[0].Length + sizeof(WCHAR) +
                     Protocol->ProtocolCharacteristics.Name.Length + sizeof(WCHAR),
                     fBind ? (PVOID)&GUID_NDIS_NOTIFY_BIND : (PVOID)&GUID_NDIS_NOTIFY_UNBIND,
                     &wnode);

    if (wnode != NULL)
    {
        //
        //  Save the number of elements in the first ULONG.
        //
        ptmp = (PUCHAR)wnode + wnode->DataBlockOffset;

        //
        //  Copy the data which is the protocol name + the miniport name in the data field
        //  Protocol<NULL>MiniportName<NULL>
        //
        RtlCopyMemory(ptmp,
                      Protocol->ProtocolCharacteristics.Name.Buffer,
                      Protocol->ProtocolCharacteristics.Name.Length);
    
        RtlCopyMemory(ptmp + Protocol->ProtocolCharacteristics.Name.Length + sizeof(WCHAR),
                      Miniport->BindPaths->Paths[0].Buffer,
                      Miniport->BindPaths->Paths[0].Length);

        //
        // notify kernel mode components who have registered for Ndis BindUnbind event
        //
        if (ndisBindUnbindCallbackObject != NULL)
        {
            ExNotifyCallback(ndisBindUnbindCallbackObject,
                             (PVOID)wnode,
                              NULL);
        }
        
        //
        //  Indicate the event to WMI. WMI will take care of freeing
        //  the WMI struct back to pool.
        //
        NtStatus = IoWMIWriteEvent(wnode);
        if (!NT_SUCCESS(NtStatus))
        {
            DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_ERR,
                ("IoWMIWriteEvent failed %lx\n", NtStatus));
    
            FREE_POOL(wnode);
        }
    }
    
    DBGPRINT(DBG_COMP_PNP, DBG_LEVEL_INFO,
            ("<==ndisNotifyWmiBindUnbind: Miniport %p, Protocol %p, fBind %lx\n", Miniport, Protocol, fBind));

    return;
}


VOID
ndisNotifyDevicePowerStateChange(
    PNDIS_MINIPORT_BLOCK                Miniport,
    NDIS_DEVICE_POWER_STATE             PowerState
    )
/*++

Routine Description:

    Notify WMI that that the power state of a NIC is changed.

Arguments:
    
Return Value:
    
--*/
{
    PWNODE_SINGLE_INSTANCE  wnode;
    PUCHAR                  ptmp;
    NTSTATUS                NtStatus;
    
    DBGPRINT(DBG_COMP_PNP, DBG_LEVEL_INFO,
            ("==>ndisNotifyDevicePowerStateChange: Miniport %p, PowerState %lx\n", Miniport, PowerState));

    ndisSetupWmiNode(Miniport,
                     Miniport->pAdapterInstanceName,
                     Miniport->MiniportName.Length + sizeof(WCHAR),
                     (PowerState == NdisDeviceStateD0) ? (PVOID)&GUID_NDIS_NOTIFY_DEVICE_POWER_ON : (PVOID)&GUID_NDIS_NOTIFY_DEVICE_POWER_OFF,
                     &wnode);

    if (wnode != NULL)
    {
        //
        //  Save the number of elements in the first ULONG.
        //
        ptmp = (PUCHAR)wnode + wnode->DataBlockOffset;
    
        RtlCopyMemory(ptmp,
                      Miniport->MiniportName.Buffer,
                      Miniport->MiniportName.Length);
        
        //
        //  Indicate the event to WMI. WMI will take care of freeing
        //  the WMI struct back to pool.
        //
        NtStatus = IoWMIWriteEvent(wnode);
        if (!NT_SUCCESS(NtStatus))
        {
            DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_ERR,
                ("IoWMIWriteEvent failed %lx\n", NtStatus));
    
            FREE_POOL(wnode);
        }
    }
    
    DBGPRINT(DBG_COMP_PNP, DBG_LEVEL_INFO,
            ("<==ndisNotifyDevicePowerStateChange: Miniport %p, PowerState %lx\n", Miniport, PowerState));

    return;
}

BOOLEAN
NdisMatchPdoWithPacket(
    IN  PNDIS_PACKET        Packet,
    IN  PVOID               Pdo
    )
{
    PNDIS_STACK_RESERVED    NSR;
    PNDIS_MINIPORT_BLOCK    Miniport;

    NDIS_STACK_RESERVED_FROM_PACKET(Packet, &NSR);
    Miniport = NSR->Miniport;

    return (Pdo == Miniport->PhysicalDeviceObject);
}

VOID
ndisPowerStateCallback(
    PVOID   CallBackContext,
    PVOID   Argument1,
    PVOID   Argument2
    )
{
    ULONG   Action = (ULONG)((ULONG_PTR)Argument1);
    ULONG   State = (ULONG)((ULONG_PTR)Argument2);
    NDIS_POWER_PROFILE  PowerProfile;
    
    DBGPRINT(DBG_COMP_PNP, DBG_LEVEL_INFO,
            ("==>ndisPowerStateCallback: Action %lx, State %lx\n", Action, State));

    if (Action == PO_CB_AC_STATUS)
    {
        ndisAcOnLine = State;
        PowerProfile = ((BOOLEAN)ndisAcOnLine == TRUE) ? NdisPowerProfileAcOnLine : NdisPowerProfileBattery;

        ndisNotifyMiniports((PNDIS_MINIPORT_BLOCK)NULL,
                            NdisDevicePnPEventPowerProfileChanged,
                            &PowerProfile,
                            sizeof(NDIS_POWER_PROFILE));
    }
    
    DBGPRINT(DBG_COMP_PNP, DBG_LEVEL_INFO,
            ("<==ndisPowerStateCallback: Action %lx, State %lx\n", Action, State));

}

VOID
ndisNotifyMiniports(
    IN  PNDIS_MINIPORT_BLOCK    Miniport OPTIONAL,
    IN  NDIS_DEVICE_PNP_EVENT   DevicePnPEvent,
    IN  PVOID                   Buffer,
    IN  ULONG                   Length
    )
{
    PNDIS_M_DRIVER_BLOCK    MiniBlock, NextMiniBlock;
    PNDIS_MINIPORT_BLOCK    CurMiniport, NM;
    KIRQL                   OldIrql;
    
    DBGPRINT(DBG_COMP_PNP, DBG_LEVEL_INFO,
            ("==>ndisNotifyMiniportsPowerProfileChange: Miniport %p, Event %lx, Buffer %p\n", 
                                            Miniport,
                                            DevicePnPEvent,
                                            Buffer));
    PnPReferencePackage();
    
    do
    {
        if (Miniport)
        {
            if(Miniport->DriverHandle->MiniportCharacteristics.PnPEventNotifyHandler != NULL)
            {
                //
                // if Miniport has been specified, the caller is responsible to make sure it is valid and appropriate
                // to call the miniport
                //
                Miniport->DriverHandle->MiniportCharacteristics.PnPEventNotifyHandler(Miniport->MiniportAdapterContext,
                                                                                      DevicePnPEvent,
                                                                                      Buffer,
                                                                                      Length);
            }
            
            break;
        }

        //
        // notification is for all the miniports
        //
        
        ACQUIRE_SPIN_LOCK(&ndisMiniDriverListLock, &OldIrql);

        for (MiniBlock = ndisMiniDriverList;
             MiniBlock != NULL;
             MiniBlock = NextMiniBlock)
        {

            if (ndisReferenceDriver(MiniBlock))
            {
                RELEASE_SPIN_LOCK(&ndisMiniDriverListLock, OldIrql);

                while ((CurMiniport = ndisReferenceNextUnprocessedMiniport(MiniBlock)) != NULL)
                {
                    if (CurMiniport->DriverHandle->MiniportCharacteristics.PnPEventNotifyHandler != NULL)
                    {
                        CurMiniport->DriverHandle->MiniportCharacteristics.PnPEventNotifyHandler(CurMiniport->MiniportAdapterContext,
                                                                                                  NdisDevicePnPEventPowerProfileChanged,
                                                                                                  Buffer,
                                                                                                  Length);
                    }
                }

                ndisUnprocessAllMiniports(MiniBlock);
                
                ACQUIRE_SPIN_LOCK(&ndisMiniDriverListLock, &OldIrql);
                NextMiniBlock = MiniBlock->NextDriver;
                ndisDereferenceDriver(MiniBlock, TRUE);
                
            }
        }

        RELEASE_SPIN_LOCK(&ndisMiniDriverListLock, OldIrql);
        
    } while (FALSE);

    PnPDereferencePackage();
    
    DBGPRINT(DBG_COMP_PNP, DBG_LEVEL_INFO,
            ("<==>ndisNotifyMiniportsPowerProfileChange: Miniport %p\n", Miniport));

    return;
}

PNDIS_MINIPORT_BLOCK
ndisReferenceNextUnprocessedMiniport(
    IN  PNDIS_M_DRIVER_BLOCK    MiniBlock
    )
{
    PNDIS_MINIPORT_BLOCK    Miniport;
    KIRQL                   OldIrql;
    
    DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
        ("==>ndisReferenceNextUnprocessedMiniport: MiniBlock %p\n", MiniBlock));

    ACQUIRE_SPIN_LOCK(&MiniBlock->Ref.SpinLock, &OldIrql);

    for (Miniport = MiniBlock->MiniportQueue;
         Miniport != NULL;
         Miniport = Miniport->NextMiniport)
    {
        if (!MINIPORT_TEST_FLAG(Miniport, (fMINIPORT_DEREGISTERED_INTERRUPT | 
                                           fMINIPORT_RESET_IN_PROGRESS | 
                                           fMINIPORT_PM_HALTING)) &&
            !MINIPORT_PNP_TEST_FLAG(Miniport, (fMINIPORT_REMOVE_IN_PROGRESS |
                                               fMINIPORT_DEVICE_FAILED |
                                               fMINIPORT_PM_HALTED |
                                               fMINIPORT_HALTING |
                                               fMINIPORT_SHUTTING_DOWN |
                                               fMINIPORT_PROCESSING)) &&
            (Miniport->PnPDeviceState == NdisPnPDeviceStarted) &&
            (Miniport->CurrentDevicePowerState == PowerDeviceD0) &&
            MINIPORT_INCREMENT_REF(Miniport))
        {
            MINIPORT_PNP_SET_FLAG(Miniport, fMINIPORT_PROCESSING);
            break;
        }
    }

    RELEASE_SPIN_LOCK(&MiniBlock->Ref.SpinLock, OldIrql);

    DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
        ("<==ndisReferenceNextUnprocessedMiniport: MiniBlock %p\n", MiniBlock));
        
    return(Miniport);
}


VOID
ndisUnprocessAllMiniports(
    IN  PNDIS_M_DRIVER_BLOCK        MiniBlock
    )
{
    PNDIS_MINIPORT_BLOCK    Miniport;
    KIRQL                   OldIrql;

    DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
        ("==>ndisUnprocessAllMiniports: MiniBlock %p\n", MiniBlock));

    while (TRUE)
    {
        
        ACQUIRE_SPIN_LOCK(&MiniBlock->Ref.SpinLock, &OldIrql);

        //
        // find the first miniport that is being proccessed. clear the flag, dereference the
        // miniport and go through the whole process again.
        //

        for (Miniport = MiniBlock->MiniportQueue;
             Miniport != NULL;
             Miniport = Miniport->NextMiniport)
        {
            if (MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_PROCESSING))
            {
                MINIPORT_PNP_CLEAR_FLAG(Miniport, fMINIPORT_PROCESSING);
                break;
            }
        }
        
        RELEASE_SPIN_LOCK(&MiniBlock->Ref.SpinLock, OldIrql);

        if (Miniport == NULL)
            break;

        //
        // dereferencing the miniport could make it to go away
        //
        MINIPORT_DECREMENT_REF(Miniport);

    }
    
    DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
        ("<==ndisUnprocessAllMiniports: MiniBlock %p\n", MiniBlock));
}

PVOID
NdisGetRoutineAddress(
    IN PUNICODE_STRING  NdisRoutineName
    )
{
    PVOID       Address;
    ANSI_STRING AnsiString;
    NTSTATUS    Status;


    Status = RtlUnicodeStringToAnsiString(&AnsiString,
                                          NdisRoutineName,
                                          TRUE);

    if (!NT_SUCCESS(Status))
    {
        return NULL;
    }


    Address = FindExportedRoutineByName(ndisDriverObject->DriverStart, &AnsiString);
    
    RtlFreeAnsiString (&AnsiString);

    return Address;
}


PVOID
FindExportedRoutineByName (
    IN PVOID DllBase,
    IN PANSI_STRING AnsiImageRoutineName
    )

/*++

Routine Description:

    This function searches the argument module looking for the requested
    exported function name.

Arguments:

    DllBase - Supplies the base address of the requested module.

    AnsiImageRoutineName - Supplies the ANSI routine name being searched for.

Return Value:

    The virtual address of the requested routine or NULL if not found.

--*/

{
    USHORT OrdinalNumber;
    PULONG NameTableBase;
    PUSHORT NameOrdinalTableBase;
    PULONG Addr;
    ULONG High;
    ULONG Low;
    ULONG Middle;
    LONG Result;
    ULONG ExportSize;
    PVOID FunctionAddress;
    PIMAGE_EXPORT_DIRECTORY ExportDirectory;

    PAGED_CODE();

    FunctionAddress = NULL;

    ExportDirectory = (PIMAGE_EXPORT_DIRECTORY)RtlImageDirectoryEntryToData(
                                DllBase,
                                TRUE,
                                IMAGE_DIRECTORY_ENTRY_EXPORT,
                                &ExportSize
                                );

    if (ExportDirectory == NULL) {
        return NULL;
    }

    //
    // Initialize the pointer to the array of RVA-based ansi export strings.
    //

    NameTableBase = (PULONG)((PCHAR)DllBase + (ULONG)ExportDirectory->AddressOfNames);

    //
    // Initialize the pointer to the array of USHORT ordinal numbers.
    //

    NameOrdinalTableBase = (PUSHORT)((PCHAR)DllBase + (ULONG)ExportDirectory->AddressOfNameOrdinals);

    //
    // Lookup the desired name in the name table using a binary search.
    //

    Low = 0;
    High = ExportDirectory->NumberOfNames - 1;

    //
    // Initializing Middle is not needed for correctness, but without it
    // the compiler cannot compile this code W4 to check for use of
    // uninitialized variables.
    //

    Middle = 0;

    while (High >= Low && (LONG)High >= 0) {

        //
        // Compute the next probe index and compare the import name
        // with the export name entry.
        //

        Middle = (Low + High) >> 1;

        Result = strcmp (AnsiImageRoutineName->Buffer,
                         (PCHAR)DllBase + NameTableBase[Middle]);

        if (Result < 0) {
            High = Middle - 1;
        }
        else if (Result > 0) {
            Low = Middle + 1;
        }
        else {
            break;
        }
    }

    //
    // If the high index is less than the low index, then a matching
    // table entry was not found. Otherwise, get the ordinal number
    // from the ordinal table.
    //

    if ((LONG)High < (LONG)Low) {
        return NULL;
    }

    OrdinalNumber = NameOrdinalTableBase[Middle];

    //
    // If the OrdinalNumber is not within the Export Address Table,
    // then this image does not implement the function.  Return not found.
    //

    if ((ULONG)OrdinalNumber >= ExportDirectory->NumberOfFunctions) {
        return NULL;
    }

    //
    // Index into the array of RVA export addresses by ordinal number.
    //

    Addr = (PULONG)((PCHAR)DllBase + (ULONG)ExportDirectory->AddressOfFunctions);

    FunctionAddress = (PVOID)((PCHAR)DllBase + Addr[OrdinalNumber]);

    //
    // Forwarders are not used by the kernel and HAL to each other.
    //

    if ((ULONG_PTR)FunctionAddress > (ULONG_PTR)ExportDirectory &&
        (ULONG_PTR)FunctionAddress < ((ULONG_PTR)ExportDirectory + ExportSize)) {
        FunctionAddress = NULL;
    }

    return FunctionAddress;
}

UINT
NdisGetVersion(
    VOID
    )
{
    return ((NDIS_MAJOR_VERSION << 16) | NDIS_MINOR_VERSION);
}

#if 0
VOID
ndisBindUnbindCallback(
    PVOID   CallBackContext,
    PVOID   Argument1,
    PVOID   Argument2
    )

{
    PWNODE_SINGLE_INSTANCE  wnode = (PWNODE_SINGLE_INSTANCE)Argument1;
    PUCHAR                  ptmp;
    UNICODE_STRING          ProtocolName, MiniportName;

    DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
        ("==>ndisBindUnbindCallback\n"));

    if (wnode != NULL)
    {
        ptmp = (PUCHAR)wnode + wnode->DataBlockOffset;

        RtlInitUnicodeString(&ProtocolName, (PWCHAR)ptmp);
        ptmp += ProtocolName.Length + sizeof(WCHAR);
        RtlInitUnicodeString(&MiniportName, (PWCHAR)ptmp);
        
        ndisDbgPrintUnicodeString(&ProtocolName);
        DbgPrint("\n");
        ndisDbgPrintUnicodeString(&MiniportName);
        DbgPrint("\n");
    
  
    DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
        ("<==ndisBindUnbindCallback\n"));
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ndis\sys\ndisdbg.h ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation

Module Name:

    ndisdbg.h

Abstract:

    NDIS wrapper definitions

Author:


Environment:

    Kernel mode, FSD

Revision History:

    Jul-14  Kyle Brandon    Added debug supported for conditional breaks.
--*/
#ifndef __DEBUG_H
#define __DEBUG_H

//
//  Define module numbers.
//
#define  MODULE_NDIS            0x00010000
#define  MODULE_DATA            0x00020000
#define  MODULE_INIT            0x00030000
#define  MODULE_INITPNP         0x00040000
#define  MODULE_COMMON          0x00050000
#define  MODULE_CONFIG          0x00060000
#define  MODULE_CONFIGM         0x00070000
#define  MODULE_BUS             0x00080000
#define  MODULE_TIMER           0x00090000
#define  MODULE_TIMERM          0x000A0000
#define  MODULE_MINIPORT        0x000B0000
#define  MODULE_REQUESTM        0x000C0000
#define  MODULE_MINISUB         0x000D0000
#define  MODULE_MAC             0x000E0000
#define  MODULE_PROTOCOL        0x000F0000
#define  MODULE_EFILTER         0x00100000
#define  MODULE_TFILTER         0x00110000
#define  MODULE_FFILTER         0x00120000
#define  MODULE_AFILTER         0x00130000
#define  MODULE_NFILTER         0x00140000
#define  MODULE_DEBUG           0x00150000
#define  MODULE_MININT          0x00160000
#define  MODULE_SENDM           0x00170000
#define  MODULE_NDIS_CO         0x00180000
#define  MODULE_NDIS_PNP        0x00190000
#define  MODULE_POWER           0x001A0000
#define  MODULE_WMI             0x001B0000
#define  MODULE_DMA             0x001C0000
#define  MODULE_CDATA           0x001D0000
#define  MODULE_VERIFY          0x001E0000


#define DBG_LEVEL_INFO          0x00000000
#define DBG_LEVEL_LOG           0x00000800
#define DBG_LEVEL_WARN          0x00001000
#define DBG_LEVEL_ERR           0x00002000
#define DBG_LEVEL_FATAL         0x00003000

#define DBG_COMP_INIT           0x00000001
#define DBG_COMP_CONFIG         0x00000002
#define DBG_COMP_SEND           0x00000004
#define DBG_COMP_RECV           0x00000008
#define DBG_COMP_PROTOCOL       0x00000010
#define DBG_COMP_BIND           0x00000020
#define DBG_COMP_BUSINFO        0x00000040
#define DBG_COMP_REG            0x00000080
#define DBG_COMP_MEMORY         0x00000100
#define DBG_COMP_FILTER         0x00000200
#define DBG_COMP_REQUEST        0x00000400
#define DBG_COMP_WORK_ITEM      0x00000800
#define DBG_COMP_PNP            0x00001000
#define DBG_COMP_PM             0x00002000
#define DBG_COMP_OPENREF        0x00004000
#define DBG_COMP_LOCKS          0x00008000
#define DBG_COMP_RESET          0x00010000
#define DBG_COMP_WMI            0x00020000
#define DBG_COMP_CO             0x00040000
#define DBG_COMP_REF            0x00080000
#define DBG_COMP_ALL            0xFFFFFFFF

#if DBG

#if defined(MEMPRINT)
#include "memprint.h"                           // DavidTr's memprint program at ntos\srv
#endif  // MEMPRINT

VOID
ndisDbgPrintUnicodeString(
    IN PUNICODE_STRING UnicodeString
    );

#define DBGPRINT(Component, Level, Fmt)                                     \
    {                                                                       \
        if ((Level >= ndisDebugLevel) &&                                    \
            ((ndisDebugSystems & Component) == Component))                  \
        {                                                                   \
            DbgPrint("***NDIS*** (%x, %d) ",                                \
                    MODULE_NUMBER >> 16, __LINE__);                         \
            DbgPrint Fmt;                                                   \
        }                                                                   \
    }
        
#define DBGPRINT_RAW(Component, Level, Fmt)                                 \
    {                                                                       \
        if ((Level >= ndisDebugLevel) &&                                    \
            ((ndisDebugSystems & Component) == Component))                  \
        {                                                                   \
            DbgPrint Fmt;                                                   \
        }                                                                   \
    }

#define DBGPRINT_UNICODE(Component, Level, UString)                         \
    {                                                                       \
        if ((Level >= ndisDebugLevel) &&                                    \
            ((ndisDebugSystems & Component) == Component))                  \
        {                                                                   \
            ndisDbgPrintUnicodeString(UString);                             \
        }                                                                   \
    }

#define DBGBREAK(Component, Level)                                          \
    {                                                                       \
        if ((Level >= ndisDebugLevel) && ((ndisDebugSystems & Component) == Component)) \
        {                                                                   \
            DbgPrint("***NDIS*** DbgBreak @ %x, %d\n",                      \
                        MODULE_NUMBER, __LINE__);                           \
            DbgBreakPoint();                                                \
        }                                                                   \
    }

#define IF_DBG(Component, Level)    if ((Level >= ndisDebugLevel) && ((ndisDebugSystems & Component) == Component))

#define DbgIsNonPaged(_Address)     (MmIsNonPagedSystemAddressValid((PVOID)(_Address)))

#define DbgIsPacket(_Packet) \
    ((((PNDIS_PKT_POOL)((_Packet)->Private.Pool))->PacketLength) > sizeof(_Packet))

#define DbgIsNull(_Ptr)  ( ((PVOID)(_Ptr)) == NULL )

#else

#define DBGPRINT(Component, Level, Fmt)
#define DBGPRINT_RAW(Component, Level, Fmt)
#define DBGPRINT_UNICODE(Component, Level, UString)
#define DBGBREAK(Component, Level)

#define DbgIsNonPaged(_Address) TRUE
#define DbgIsPacket(_Packet)    TRUE
#define DbgIsNull(_Ptr)         FALSE

#define IF_DBG(Component, Level)    if (FALSE)

#define ndisDbgPrintUnicodeString(UnicodeString)

#endif  // DBG

#ifdef TRACK_MOPEN_REFCOUNTS
//
// Declarations for ndis' logfile. 
// The purpose of the logfile is to log events 
// relating to the increments and decrements of an mopen's
// refcounts.
//

//
// The Ndis Logfile's size is fixed at 0x10000 and the index
// is of type ushort. This ensures that the logfile always stays 
// within its prescribed limits
//
#define NDIS_LOGFILE_SIZE 0x10000

//
// NdisLogfile Events
//

#define NDIS_INCREMENT_M_OPEN_REFCOUNT              0x0101
#define NDIS_DECREMENT_M_OPEN_REFCOUNT              0x0102

#define NDIS_INCREMENT_OPEN_AF_NOTIFICATION         0xAF01
#define NDIS_DECREMENT_OPEN_AF_NOTIFICATION         0xAF02

/*
VOID 
NDIS_APPEND_MOPEN_LOGFILE(
    IN  USHORT EventCode,
    IN  USHORT LineNumber,
    IN  UINT   ModuleNumber,
    IN  UINT   Arg1,
    IN  UINT   Arg2
    );

*/
#define NDIS_APPEND_MOPEN_LOGFILE( _Ev, _L, _M, _A1, _A2)                       \
        ndisLogfile[ndisLogfileIndex++] = (ULONG_PTR)(_Ev);                     \
        ndisLogfile[ndisLogfileIndex++] = (ULONG_PTR)((_M) | (_L));             \
        ndisLogfile[ndisLogfileIndex++] = (ULONG_PTR)_A1;                       \
        ndisLogfile[ndisLogfileIndex++] = (ULONG_PTR)_A2;


#else  // TRACK_MOPEN_REFCOUNTS
 
#define NDIS_APPEND_MOPEN_LOGFILE( _Ev, _L, _M, _A1, _A2)

#endif // TRACK_MOPEN_REFCOUNTS

#ifdef TRACK_MINIPORT_REFCOUNTS
//
// Declarations for ndis' logfile. 
// The purpose of the logfile is to log events 
// relating to the increments and decrements of a miniport's
// refcounts.
//

//
// The Ndis Logfile's size is fixed at 0x10000 and the index
// is of type ushort. This ensures that the logfile always stays 
// within its prescribed limits
//
#define NDIS_MINIPORT_LOGFILE_SIZE 0x10000

//
// NdisLogfile Events
//
#define NDIS_INCREMENT_MINIPORT_REFCOUNT                0x0101
#define NDIS_DECREMENT_MINIPORT_REFCOUNT                0x0102
#define NDIS_SET_MINIPORT_REFCOUNT                      0x0103

/*
VOID 
NDIS_APPEND_MINIPORT_LOGFILE( USHORT EventCode,
                                USHORT LineNumber,
                                UINT    ModuleNumber,
                                UINT    Arg1,
                                UINT    Arg2 );

*/

#define NDIS_APPEND_MINIPORT_LOGFILE( _Ev, _L, _Mo, _Mi, _R)                \
        ndisMiniportLogfile[ndisMiniportLogfileIndex++] = (UINT)(_Ev);      \
        ndisMiniportLogfile[ndisMiniportLogfileIndex++] = (UINT)((_Mo) | (_L)); \
        ndisMiniportLogfile[ndisMiniportLogfileIndex++] = (UINT)(_Mi);      \
        ndisMiniportLogfile[ndisMiniportLogfileIndex++] = (UINT)(_R);


#define M_LOG_MINIPORT_INCREMENT_REF(_Mi, _L, _Mo)                          \
NDIS_APPEND_MINIPORT_LOGFILE(NDIS_INCREMENT_MINIPORT_REFCOUNT,              \
                               _L,                                          \
                               _Mo,                                         \
                               (_Mi),                                       \
                               (_Mi)->Ref.ReferenceCount);

#define M_LOG_MINIPORT_INCREMENT_REF_CREATE(_Mi, _L, _Mo)                   \
NDIS_APPEND_MINIPORT_LOGFILE(IoGetCurrentProcess(),                         \
                               _L,                                          \
                               _Mo,                                         \
                               (_Mi),                                       \
                               (_Mi)->Ref.ReferenceCount);

#define M_LOG_MINIPORT_DECREMENT_REF(_Mi, _R)                               \
NDIS_APPEND_MINIPORT_LOGFILE(NDIS_DECREMENT_MINIPORT_REFCOUNT,              \
                               __LINE__,                                    \
                               MODULE_NUMBER,                               \
                               (_Mi),                                       \
                               (_R));
                               
#define M_LOG_MINIPORT_DECREMENT_REF_CLOSE(_Mi, _R)                         \
NDIS_APPEND_MINIPORT_LOGFILE(IoGetCurrentProcess(),                         \
                               __LINE__,                                    \
                               MODULE_NUMBER,                               \
                               (_Mi),                                       \
                               (_R));

#define M_LOG_MINIPORT_SET_REF(_Mi, _R)                                     \
NDIS_APPEND_MINIPORT_LOGFILE(NDIS_SET_MINIPORT_REFCOUNT,                    \
                               __LINE__,                                    \
                               MODULE_NUMBER,                               \
                               (_Mi),                                       \
                               (_R));
                               
#else  // TRACK_MINIPORT_REFCOUNTS
 
#define M_LOG_MINIPORT_INCREMENT_REF(_Mi, _L, _Mo)
#define M_LOG_MINIPORT_INCREMENT_REF_CREATE(_Mi, _L, _Mo)
#define M_LOG_MINIPORT_DECREMENT_REF(_M, _R)
#define M_LOG_MINIPORT_DECREMENT_REF_CLOSE(_Mi, _R)
#define M_LOG_MINIPORT_SET_REF(_M, _R)

#endif // TRACK_MINIPORT_REFCOUNTS


#ifdef TRACK_RECEIVED_PACKETS

//
// The Ndis Received Logfile's size is fixed at 0x10000 and the index
// is of type ushort. This ensures that the logfile always stays 
// within its prescribed limits
//
#define NDIS_RCV_LOGFILE_SIZE 0x10000


/*
VOID 
NDIS_APPEND_RCV_LOGFILE(PVOID   Packet,
                        PVOID   Miniport,
                        PVOID   CurrentThread,
                        ULONG   Code,
                        ULONG   StackLocation,
                        ULONG   Ref,
                        ULONG   XRef,
                        ULONG   Status
                        );

*/

#define NDIS_APPEND_RCV_LOGFILE(_PACKET, _MINIPORT, _THREAD, _CODE, _SP, _REF, _XREF, _STATUS)      \
        ndisRcvLogfile[ndisRcvLogfileIndex++] = (UINT)(_PACKET);                                    \
        ndisRcvLogfile[ndisRcvLogfileIndex++] = (UINT)(_MINIPORT);                                  \
        ndisRcvLogfile[ndisRcvLogfileIndex++] = (UINT)(_THREAD);                                    \
        ndisRcvLogfile[ndisRcvLogfileIndex++] = (UINT)((_CODE<<24)|((_SP&0xff)<<16)|((_REF&0xf)<<12)|(_XREF<<8)|(_STATUS&0xff));
        

//        ndisRcvLogfile[ndisRcvLogfileIndex++] = (UINT)((_Mo) | (_L));                                              \
//        ndisRcvLogfile[ndisRcvLogfileIndex++] = (UINT)((_SP<<24)|((_REF&0xff)<<16)|(_XREF<<8)|(_Status&0xff));


#else  // TRACK_MINIPORT_REFCOUNTS

#define NDIS_APPEND_RCV_LOGFILE( _P, _L, _Mo, _SP, _REF, _XREF, _Status, _Arg1)

#endif // TRACK_RECEIVED_PACKETS


#endif  //  __DEBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ndis\sys\ndispnp.c ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation

Module Name:

    Ndispnp.c

Abstract:

Author:

    Kyle Brandon    (KyleB)     
    Alireza Dabagh  (AliD)

Environment:

    Kernel mode

Revision History:

    12/20/96    KyleB           Added support for IRP_MN_QUERY_CAPABILITIES.

--*/

#include <precomp.h>
#pragma hdrstop

//
//  Define the module number for debug code.
//
#define MODULE_NUMBER   MODULE_NDIS_PNP

VOID
NdisCompletePnPEvent(
    IN  NDIS_STATUS     Status,
    IN  NDIS_HANDLE     NdisBindingHandle,
    IN  PNET_PNP_EVENT  NetPnPEvent
    )
/*++

Routine Description:

    This routine is called by a transport when it wants to complete a PnP/PM
    event indication on a given binding.

Arguments:

    Status              -   Status of the PnP/PM event indication.
    NdisBindingHandle   -   Binding that the event was for.
    NetPnPEvent         -   Structure describing the PnP/PM event.

Return Value:

    None.

--*/
{
    PNDIS_PNP_EVENT_RESERVED    EventReserved;
    
    DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
        ("==>NdisCompletePnPEvent: Open %p\n", NdisBindingHandle));
        
    ASSERT(Status != NDIS_STATUS_PENDING);

    //
    //  Get a pointer to the NDIS reserved area in the event.
    //
    EventReserved = PNDIS_PNP_EVENT_RESERVED_FROM_NET_PNP_EVENT(NetPnPEvent);

    //
    //  Save the status with the net event.
    //
    EventReserved->Status = Status;

    //
    //  Signal the event.
    //
    SET_EVENT(EventReserved->pEvent);
    
    DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
        ("<==NdisCompletePnPEvent: Open %p\n", NdisBindingHandle));
}

NTSTATUS
ndisMIrpCompletion(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            Irp,
    IN  PVOID           Context
    )
/*++

Routine Description:

    This routine will get called after the next device object in the stack
    processes the IRP_MN_QUERY_CAPABILITIES IRP this needs to be merged with
    the miniport's capabilites and completed.

Arguments:

    DeviceObject
    Irp
    Context

Return Value:

--*/
{
    SET_EVENT(Context);

    return(STATUS_MORE_PROCESSING_REQUIRED);
}

NTSTATUS
ndisPassIrpDownTheStack(
    IN  PIRP            pIrp,
    IN  PDEVICE_OBJECT  pNextDeviceObject
    )
/*++

Routine Description:

    This routine will simply pass the IRP down to the next device object to
    process.

Arguments:
    pIrp                -   Pointer to the IRP to process.
    pNextDeviceObject   -   Pointer to the next device object that wants
                            the IRP.

Return Value:

--*/
{
    KEVENT              Event;
    NTSTATUS            Status = STATUS_SUCCESS;

    //
    //  Initialize the event structure.
    //
    INITIALIZE_EVENT(&Event);

    //
    //  Set the completion routine so that we can process the IRP when
    //  our PDO is done.
    //
    IoSetCompletionRoutine(pIrp,
                           (PIO_COMPLETION_ROUTINE)ndisMIrpCompletion,
                           &Event,
                           TRUE,
                           TRUE,
                           TRUE);

    //
    //  Pass the IRP down to the PDO.
    //
    Status = IoCallDriver(pNextDeviceObject, pIrp);
    if (Status == STATUS_PENDING)
    {
        //
        //  Wait for completion.
        //
        WAIT_FOR_OBJECT(&Event, NULL);

        Status = pIrp->IoStatus.Status;
    }

    return(Status);
}

NDIS_STATUS
ndisPnPNotifyAllTransports(
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  NET_PNP_EVENT_CODE      PnpEvent,
    IN  PVOID                   Buffer,
    IN  ULONG                   BufferLength
    )
/*++

Routine Description:

    This routine will notify the transports bound to the miniport about
    the PnP event.  When all of the bound transports have completed the
    PnP event it will then call the completion routine.

Arguments:

    Miniport    -   Pointer to the miniport block.
    PnpEvent    -   PnP event to notify the transports of.

Return Value:

--*/
{
    PNDIS_OPEN_BLOCK            Open = NULL;
    NET_PNP_EVENT               NetPnpEvent;
    NDIS_STATUS                 NdisStatus = NDIS_STATUS_SUCCESS;
    BOOLEAN                     fFailure = FALSE;

    DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
        ("==>ndisPnPNotifyAllTransports: Miniport %p\n", Miniport));

    //
    //  Initialize the PnP event structure.
    //
    NdisZeroMemory(&NetPnpEvent, sizeof(NetPnpEvent));

    NetPnpEvent.NetEvent = PnpEvent;
    NetPnpEvent.Buffer = Buffer;
    NetPnpEvent.BufferLength = BufferLength;

    //
    //  Indicate this event to the opens.
    //
    do
    {
        Open = ndisReferenceNextUnprocessedOpen(Miniport);

        if (Open == NULL)
            break;

        NdisStatus = ndisPnPNotifyBinding(Open, &NetPnpEvent);

        //
        //  Is the status OK?
        //
        if (NdisStatus != NDIS_STATUS_SUCCESS) 

        { 

            DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
                ("ndisPnPNotifyAllTransports: Transport "));
            DBGPRINT_UNICODE(DBG_COMP_INIT, DBG_LEVEL_INFO,
                    &Open->ProtocolHandle->ProtocolCharacteristics.Name);
            DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
                    (" failed the pnp event: %lx for Miniport %p with Status %lx\n", PnpEvent, Miniport, NdisStatus));
            
            if ((PnpEvent == NetEventQueryPower) || 
                (PnpEvent == NetEventQueryRemoveDevice) ||
                ((PnpEvent == NetEventSetPower) && (*((PDEVICE_POWER_STATE)Buffer) > PowerDeviceD0)))
            
            {
                break;
            }
            else
            {
                NdisStatus = NDIS_STATUS_SUCCESS;
            }
        }
    } while (TRUE);

    ndisUnprocessAllOpens(Miniport);

    DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
        ("<==ndisPnPNotifyAllTransports: Miniport %p\n", Miniport));

    return(NdisStatus);
}


/*
PNDIS_OPEN_BLOCK
FASTCALL
ndisReferenceNextUnprocessedOpen(
    IN  PNDIS_MINIPORT_BLOCK    Miniport
    )
    
Routine Description:

    This routine is used during PnP notification to protocols. it walks through
    the Open queue on the miniport and finds the first Open that is not being unbound
    and it has not been already notified of the PnP even. it then sets the
    fMINIPORT_OPEN_PROCESSING flag so we do not try to unbind the open and 
    fMINIPORT_OPEN_NOTIFY_PROCESSING flag so we know which opens to "unprocess"
    when we are done

Arguments:

    Miniport: the Miniport block whose open blocks we are going to process.

Return Value:

    the first unprocessed open or null.

*/

PNDIS_OPEN_BLOCK
FASTCALL
ndisReferenceNextUnprocessedOpen(
    IN  PNDIS_MINIPORT_BLOCK    Miniport
    )
{
    PNDIS_OPEN_BLOCK        Open;
    KIRQL                   OldIrql;
    
    DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
        ("==>ndisReferenceNextUnprocessedOpen: Miniport %p\n", Miniport));

    NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Miniport, &OldIrql);
    for (Open = Miniport->OpenQueue;
         Open != NULL;
         Open = Open->MiniportNextOpen)
    {
        ACQUIRE_SPIN_LOCK_DPC(&Open->SpinLock);
        if (!MINIPORT_TEST_FLAG(Open, (fMINIPORT_OPEN_CLOSING | 
                                       fMINIPORT_OPEN_PROCESSING |
                                       fMINIPORT_OPEN_UNBINDING)))
        {
            //
            // this will stop Ndis to Unbind this open for the time being
            //
            MINIPORT_SET_FLAG(Open, fMINIPORT_OPEN_PROCESSING | 
                                    fMINIPORT_OPEN_NOTIFY_PROCESSING);
            
            RELEASE_SPIN_LOCK_DPC(&Open->SpinLock);
            break;
        }
        RELEASE_SPIN_LOCK_DPC(&Open->SpinLock);
    }
    NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);

    DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
        ("<==ndisReferenceNextUnprocessedOpen: Miniport %p\n", Miniport));
        
    return(Open);
}

/*
VOID
ndisUnprocessAllOpens(
    IN  PNDIS_MINIPORT_BLOCK        Miniport
    )
    
Routine Description:

    Clears the fMINIPORT_OPEN_PROCESSING flag on all the open blocks that have been 
    processed during a PnP Notification.

Arguments:
    Miniport: the Miniport block whose open blocks we are going to unprocess.

Return Value:
    None

*/

VOID
ndisUnprocessAllOpens(
    IN  PNDIS_MINIPORT_BLOCK        Miniport
    )
{
    PNDIS_OPEN_BLOCK        Open, NextOpen;
    KIRQL                   OldIrql;

    DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
        ("==>ndisUnprocessAllOpens: Miniport %p\n", Miniport));
        
    NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Miniport, &OldIrql);

    for (Open = Miniport->OpenQueue;
         Open != NULL;
         Open = NextOpen)
    {
        NextOpen = Open->MiniportNextOpen;
        ACQUIRE_SPIN_LOCK_DPC(&Open->SpinLock);

        if (MINIPORT_TEST_FLAGS(Open, fMINIPORT_OPEN_NOTIFY_PROCESSING | 
                                      fMINIPORT_OPEN_PROCESSING))
        {
            MINIPORT_CLEAR_FLAG(Open, fMINIPORT_OPEN_PROCESSING | 
                                      fMINIPORT_OPEN_NOTIFY_PROCESSING);
        }

        RELEASE_SPIN_LOCK_DPC(&Open->SpinLock);
        Open = NextOpen;
    }

    NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);
    
    DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
        ("<==ndisUnprocessAllOpens: Miniport %p\n", Miniport));
}


NDIS_STATUS
FASTCALL
ndisPnPNotifyBinding(
    IN  PNDIS_OPEN_BLOCK    Open,
    IN  PNET_PNP_EVENT      NetPnpEvent
    )
{
    PNDIS_PROTOCOL_BLOCK        Protocol;
    NDIS_HANDLE                 ProtocolBindingContext;
    KEVENT                      Event;
    NDIS_STATUS                 NdisStatus = NDIS_STATUS_NOT_SUPPORTED;
    PNDIS_PNP_EVENT_RESERVED    EventReserved;
    NDIS_BIND_CONTEXT           UnbindContext;
    DEVICE_POWER_STATE          DeviceState;
    NDIS_STATUS                 CloseStatus;
    KIRQL                       OldIrql;
    
    DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
        ("==>ndisPnPNotifyBinding: Open %p\n", Open));
    
    do
    {
        Protocol = Open->ProtocolHandle;
        ProtocolBindingContext = Open->ProtocolBindingContext;

        //
        //  Does the transport have a PnP Event handler?
        //
        if (Protocol->ProtocolCharacteristics.PnPEventHandler != NULL)
        {
            //
            //  Get a pointer to the NDIS reserved in PnP event.
            //
            EventReserved = PNDIS_PNP_EVENT_RESERVED_FROM_NET_PNP_EVENT(NetPnpEvent);
    
            //
            //  Initialize and save the local event with the PnP event.
            //
            INITIALIZE_EVENT(&Event);
            EventReserved->pEvent = &Event;
  
            //
            //  Indicate the event to the protocol.
            //
            NdisStatus = (Protocol->ProtocolCharacteristics.PnPEventHandler)(
                            ProtocolBindingContext,
                            NetPnpEvent);
    
            if (NDIS_STATUS_PENDING == NdisStatus)
            {
                //
                //  Wait for completion.
                //
                WAIT_FOR_PROTOCOL(Protocol, &Event);
    
                //
                //  Get the completion status.
                //
                NdisStatus = EventReserved->Status;
            }
     
            if ((NetPnpEvent->NetEvent == NetEventQueryPower) &&
                (NDIS_STATUS_SUCCESS != NdisStatus) &&
                (NDIS_STATUS_NOT_SUPPORTED != NdisStatus))
            {
                DbgPrint("***NDIS***: Protocol %Z failed QueryPower %lx\n",
                        &Protocol->ProtocolCharacteristics.Name, NdisStatus);
            }
#if DBG
            if ((NetPnpEvent->NetEvent == NetEventSetPower) &&
                (*((PDEVICE_POWER_STATE)NetPnpEvent->Buffer) > PowerDeviceD0) &&
                (MINIPORT_TEST_FLAG(Open->MiniportHandle, fMINIPORT_RESET_IN_PROGRESS)) &&
                (Open->MiniportHandle->ResetOpen == Open))
            {
                DbgPrint("ndisPnPNotifyBinding: Protocol %p returned from SetPower with outstanding Reset.\n", Protocol);
                DbgBreakPoint();
            }
                
#endif
            
        }
        else 
        {
            if ((NetPnpEvent->NetEvent == NetEventQueryRemoveDevice) ||
                (NetPnpEvent->NetEvent == NetEventQueryPower) ||
                (NetPnpEvent->NetEvent == NetEventCancelRemoveDevice)
                )
            {
                //
                // since protocol at least has an UnbindHandler, we can unbind
                // it from the adapter if necessary
                //
                NdisStatus = NDIS_STATUS_SUCCESS;
                break;
            }
        }
        
        //
        // if the protocol does not have a PnPEventHandler or 
        // we tried to suspend a protocol and protocol returned NDIS_STATUS_NOT_SUPPORTED,
        // unbind the protocol
        //
        if ((NdisStatus == NDIS_STATUS_NOT_SUPPORTED) &&
            (NetPnpEvent->NetEvent == NetEventSetPower))
        {
            DeviceState = *((PDEVICE_POWER_STATE)NetPnpEvent->Buffer);
            
            switch (DeviceState)
            {
                case PowerDeviceD1:
                case PowerDeviceD2:
                case PowerDeviceD3:
                    ACQUIRE_SPIN_LOCK(&Open->SpinLock, &OldIrql);
                    if (!MINIPORT_TEST_FLAG(Open, (fMINIPORT_OPEN_UNBINDING | 
                                                   fMINIPORT_OPEN_CLOSING)))
                    {
                        MINIPORT_SET_FLAG(Open, fMINIPORT_OPEN_UNBINDING | 
                                                fMINIPORT_OPEN_DONT_FREE);
                        RELEASE_SPIN_LOCK(&Open->SpinLock, OldIrql);
                        ndisUnbindProtocol(Open, FALSE);
                    }
                    else
                    {
                        RELEASE_SPIN_LOCK(&Open->SpinLock, OldIrql);
                    }
                    
                    NdisStatus = NDIS_STATUS_SUCCESS;
                    break;
                    
                default:
                    break;
            }
        }
    } while (FALSE);

    DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
        ("<==ndisPnPNotifyBinding: Open %p\n", Open));
        
    return NdisStatus;
}



NTSTATUS
ndisPnPDispatch(
    IN  PDEVICE_OBJECT          DeviceObject,
    IN  PIRP                    Irp
    )

/*++

Routine Description:

    The handler for IRP_MJ_PNP_POWER.

Arguments:

    DeviceObject - The adapter's functional device object.
    Irp - The IRP.

Return Value:

--*/
{
    PIO_STACK_LOCATION      IrpSp;
    NTSTATUS                Status = STATUS_SUCCESS;
    PDEVICE_OBJECT          NextDeviceObject;
    PNDIS_MINIPORT_BLOCK    Miniport = NULL;
    KEVENT                  RemoveReadyEvent;
    ULONG                   PnPDeviceState;
    PNDIS_MINIPORT_BLOCK*   ppMB;
    KIRQL                   OldIrql;
    BOOLEAN                 fSendIrpDown = TRUE;
    BOOLEAN                 fCompleteIrp = TRUE;
    
    DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
            ("==>ndisPnPDispatch: DeviceObject %p, Irp %p\n", DeviceObject, Irp));
    
    IF_DBG(DBG_COMP_ALL, DBG_LEVEL_ERR)
    {
        if (DbgIsNull(Irp))
        {
            DBGPRINT(DBG_COMP_PNP, DBG_LEVEL_ERR,
                    ("ndisPnPDispatch: Null Irp\n"));
            DBGBREAK(DBG_COMP_PNP, DBG_LEVEL_ERR);
        }
        if (!DbgIsNonPaged(Irp))
        {
            DBGPRINT(DBG_COMP_PNP, DBG_LEVEL_ERR,
                    ("ndisPnPDispatch: Irp not in NonPaged Memory\n"));
            DBGBREAK(DBG_COMP_PNP, DBG_LEVEL_ERR);
        }
    }
    PnPReferencePackage();

    //
    //  Get a pointer to the miniport block
    //
    Miniport = (PNDIS_MINIPORT_BLOCK)((PNDIS_WRAPPER_CONTEXT)DeviceObject->DeviceExtension + 1);
    
    if (Miniport->Signature != (PVOID)MINIPORT_DEVICE_MAGIC_VALUE)
    {
        DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
                ("ndisPnPDispatch: DeviceObject %p, Irp %p, Device extension is not a miniport.\n", 
                                DeviceObject, Irp));
        Status = STATUS_INVALID_DEVICE_REQUEST;
        fSendIrpDown = FALSE;       
        goto Done;
    }

    //
    //  Get a pointer to the next miniport.
    //
    NextDeviceObject = Miniport->NextDeviceObject;

    IrpSp = IoGetCurrentIrpStackLocation (Irp);
    
    DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
        ("ndisPnPDispatch: Miniport %p, IrpSp->MinorFunction: %lx\n", Miniport, IrpSp->MinorFunction));

    switch(IrpSp->MinorFunction)
    {
        //
        // for Memphis the following IRPs are handled by handling the corresponding
        // Config Manager message:
        //
        // IRP_MN_START_DEVICE                  CONFIG_START
        // IRP_MN_QUERY_REMOVE_DEVICE           CONFIG_TEST/CONFIG_TEST_CAN_REMOVE
        // IRP_MN_CANCEL_REMOVE_DEVICE          CONFIG_TEST_FAILED/CONFIG_TEST_CAN_REMOVE
        // IRP_MN_REMOVE_DEVICE                 CONFIG_REMOVE
        // IRP_MN_QUERY_STOP_DEVICE             CONFIG_TEST/CONFIG_TEST_CAN_STOP
        // IRP_MN_CANCEL_STOP_DEVICE            CONFIG_TEST_FAILED/CONFIG_TEST_CAN_STOP
        // IRP_MN_STOP_DEVICE                   CONFIG_STOP
        // IRP_MN_SURPRISE_REMOVAL
        //
        case IRP_MN_START_DEVICE:

            DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
                ("ndisPnPDispatch: Miniport %p, IRP_MN_START_DEVICE\n", Miniport));

            MINIPORT_PNP_CLEAR_FLAG(Miniport, fMINIPORT_REMOVE_IN_PROGRESS);
            MINIPORT_PNP_SET_FLAG(Miniport, fMINIPORT_RECEIVED_START);
            
            IoCopyCurrentIrpStackLocationToNext(Irp);
            Status = ndisPassIrpDownTheStack(Irp, NextDeviceObject);

            //
            //  If the bus driver succeeded the start irp then proceed.
            //
            if (NT_SUCCESS(Status))
            {
                if (Miniport->DriverHandle->Flags & fMINIBLOCK_INTERMEDIATE_DRIVER)
                {
                    NDIS_HANDLE DeviceContext;

                    //
                    // for layered miniport drivers, have to check to see
                    // if we got InitializeDeviceInstance
                    //
                    MINIPORT_SET_FLAG(Miniport, fMINIPORT_INTERMEDIATE_DRIVER);
                    if (ndisIMCheckDeviceInstance(Miniport->DriverHandle,
                                                  &Miniport->MiniportName,
                                                  &DeviceContext))
                    {
                        WAIT_FOR_OBJECT(&Miniport->DriverHandle->IMStartRemoveMutex, NULL);
                        Status = ndisIMInitializeDeviceInstance(Miniport, DeviceContext, TRUE);
                        RELEASE_MUTEX(&Miniport->DriverHandle->IMStartRemoveMutex);
                        
                    }
                }
                else
                {
                    Status = ndisPnPStartDevice(DeviceObject, Irp);
                    if (Status == NDIS_STATUS_SUCCESS)
                    {
                        if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_IS_CO) &&
                            !ndisMediaTypeCl[Miniport->MediaType] &&
                            (Miniport->MediaType != NdisMediumWan))
                        {
                            UNICODE_STRING  NDProxy;

                            RtlInitUnicodeString(&NDProxy, NDIS_PROXY_SERVICE);
                            ZwLoadDriver(&NDProxy);
                        }
                        if (ndisProtocolList != NULL)
                        {
                            ndisQueueBindWorkitem(Miniport);
                        }
                    }
                    else
                    {
                        Status = STATUS_UNSUCCESSFUL;
                    }
                }                   
            }

            Irp->IoStatus.Status = Status;
            fSendIrpDown = FALSE;   // we already did send the IRP down
            break;
        
        case IRP_MN_QUERY_REMOVE_DEVICE:

            DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
                ("ndisPnPDispatch: Miniport %p, IRP_MN_QUERY_REMOVE_DEVICE\n", Miniport));

            Miniport->OldPnPDeviceState = Miniport->PnPDeviceState;
            Miniport->PnPDeviceState = NdisPnPDeviceQueryRemoved;
            
            Status = ndisPnPQueryRemoveDevice(DeviceObject, Irp);
            Irp->IoStatus.Status = Status;
            //
            // if we failed query_remove, no point sending this irp down
            //
            fSendIrpDown = NT_SUCCESS(Status) ? TRUE : FALSE;
            break;
        
        case IRP_MN_CANCEL_REMOVE_DEVICE:

            DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
                ("ndisPnPDispatch: Miniport %p, IRP_MN_CANCEL_REMOVE_DEVICE\n", Miniport));

            Status = ndisPnPCancelRemoveDevice(DeviceObject,Irp);

            if (NT_SUCCESS(Status))
            {
                Miniport->PnPDeviceState = Miniport->OldPnPDeviceState;
            }
            
            Irp->IoStatus.Status = Status;
            fSendIrpDown = NT_SUCCESS(Status) ? TRUE : FALSE;
            break;
            
        case IRP_MN_REMOVE_DEVICE:

            DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
                ("ndisPnPDispatch: Miniport %p, IRP_MN_REMOVE_DEVICE\n", Miniport));
            ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);

            PnPDeviceState = Miniport->PnPDeviceState;
            
            if (PnPDeviceState != NdisPnPDeviceSurpriseRemoved)
            {
                Miniport->PnPDeviceState = NdisPnPDeviceRemoved;
                MINIPORT_PNP_SET_FLAG(Miniport, fMINIPORT_REMOVE_IN_PROGRESS);
                MINIPORT_PNP_CLEAR_FLAG(Miniport, fMINIPORT_RECEIVED_START);

                //
                // initialize an event and signal when all the wotrkitems have fired.
                //
                if (MINIPORT_INCREMENT_REF(Miniport))
                {
                    INITIALIZE_EVENT(&RemoveReadyEvent);
                    Miniport->RemoveReadyEvent = &RemoveReadyEvent;
                }
                else
                {
                    Miniport->RemoveReadyEvent = NULL;
                }
                
                Status = ndisPnPRemoveDevice(DeviceObject, Irp);

                if (Miniport->RemoveReadyEvent != NULL)
                {
                    MINIPORT_DECREMENT_REF(Miniport);
                    WAIT_FOR_OBJECT(&RemoveReadyEvent, NULL);
                }

                Irp->IoStatus.Status = Status;
            }
            else
            {
                Irp->IoStatus.Status = STATUS_SUCCESS;
            }
            

            //
            // when we are done, send the Irp down here
            // we have some post-processing to do
            //
            IoSkipCurrentIrpStackLocation(Irp);
            Status = IoCallDriver(NextDeviceObject, Irp);

            if (Miniport->pAdapterInstanceName != NULL)
            {
                FREE_POOL(Miniport->pAdapterInstanceName);
            }

            //
            // remove miniport from global miniport list
            //
            ACQUIRE_SPIN_LOCK(&ndisMiniportListLock, &OldIrql);
            for (ppMB = &ndisMiniportList; *ppMB != NULL; ppMB = &(*ppMB)->NextGlobalMiniport)
            {
                if (*ppMB == Miniport)
                {
                    *ppMB = Miniport->NextGlobalMiniport;
                    break;
                }
            }
            RELEASE_SPIN_LOCK(&ndisMiniportListLock, OldIrql);

            if (Miniport->BindPaths != NULL)
            {
                FREE_POOL(Miniport->BindPaths);
            }

            if (Miniport->BusInterface != NULL)
            {
                FREE_POOL(Miniport->BusInterface);
            }

            IoDetachDevice(Miniport->NextDeviceObject);
            IoDeleteDevice(Miniport->DeviceObject);
            
            fSendIrpDown = FALSE;
            fCompleteIrp = FALSE;
            break;
            
        case IRP_MN_SURPRISE_REMOVAL:
            DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
                ("ndisPnPDispatch: Miniport %p, IRP_MN_SURPRISE_REMOVAL\n", Miniport));
                
            ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);

            //
            // let the miniport know the hardware is gone asap
            //
            if (ndisIsMiniportStarted(Miniport) &&
                (Miniport->PnPDeviceState == NdisPnPDeviceStarted) &&
                (!MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_PM_HALTED)) &&
                (Miniport->DriverHandle->MiniportCharacteristics.PnPEventNotifyHandler != NULL))
            {
                Miniport->DriverHandle->MiniportCharacteristics.PnPEventNotifyHandler(Miniport->MiniportAdapterContext,
                                                                                      NdisDevicePnPEventSurpriseRemoved,
                                                                                      NULL,
                                                                                      0);
            }           

            Miniport->PnPDeviceState = NdisPnPDeviceSurpriseRemoved;
            MINIPORT_PNP_SET_FLAG(Miniport, fMINIPORT_REMOVE_IN_PROGRESS);
            MINIPORT_PNP_CLEAR_FLAG(Miniport, fMINIPORT_RECEIVED_START);

            //
            // initialize an event and signal when all the wotrkitems have fired.
            //
            if (MINIPORT_INCREMENT_REF(Miniport))
            {
                INITIALIZE_EVENT(&RemoveReadyEvent);
                Miniport->RemoveReadyEvent = &RemoveReadyEvent;
            }
            else
            {
                Miniport->RemoveReadyEvent = NULL;
            }
            
            Status = ndisPnPRemoveDevice(DeviceObject, Irp);

            if (Miniport->RemoveReadyEvent != NULL)
            {
                MINIPORT_DECREMENT_REF(Miniport);
                WAIT_FOR_OBJECT(&RemoveReadyEvent, NULL);
            }           

            Irp->IoStatus.Status = Status;

            //
            // when we are done, send the Irp down here
            // we have some post-processing to do
            //
            IoSkipCurrentIrpStackLocation(Irp);
            Status = IoCallDriver(NextDeviceObject, Irp);
            fSendIrpDown = FALSE;
            fCompleteIrp = FALSE;
                
            break;
        
        case IRP_MN_QUERY_STOP_DEVICE:

            DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
                ("ndisPnPDispatch: Miniport %p, IRP_MN_QUERY_STOP_DEVICE\n", Miniport));

            Miniport->OldPnPDeviceState = Miniport->PnPDeviceState;
            Miniport->PnPDeviceState = NdisPnPDeviceQueryStopped;
            
            Status = ndisPnPQueryStopDevice(DeviceObject, Irp);
            Irp->IoStatus.Status = Status;
            fSendIrpDown = NT_SUCCESS(Status) ? TRUE : FALSE;
            break;
            
        case IRP_MN_CANCEL_STOP_DEVICE:

            DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
                ("ndisPnPDispatch: Adapter %p, IRP_MN_CANCEL_STOP_DEVICE\n", Miniport));

            Status = ndisPnPCancelStopDevice(DeviceObject,Irp);
            
            if (NT_SUCCESS(Status))
            {
                Miniport->PnPDeviceState = Miniport->OldPnPDeviceState;
            }
            
            Irp->IoStatus.Status = Status;
            fSendIrpDown = NT_SUCCESS(Status) ? TRUE : FALSE;
            break;
            
        case IRP_MN_STOP_DEVICE:

            DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
                    ("ndisPnPDispatch: Miniport %p, IRP_MN_STOP_DEVICE\n", Miniport));

            Miniport->PnPDeviceState = NdisPnPDeviceStopped;
            MINIPORT_PNP_CLEAR_FLAG(Miniport, fMINIPORT_RECEIVED_START);
            //
            // initialize an event and signal when
            // all the wotrkitems have fired.
            //
            if (MINIPORT_INCREMENT_REF(Miniport))
            {
                INITIALIZE_EVENT(&RemoveReadyEvent);
                Miniport->RemoveReadyEvent = &RemoveReadyEvent;
                Miniport->PnPDeviceState = NdisPnPDeviceStopped;
                MINIPORT_PNP_SET_FLAG(Miniport, fMINIPORT_REMOVE_IN_PROGRESS);
            }
            else
            {
                Miniport->RemoveReadyEvent = NULL;
            }
            
            Status = ndisPnPStopDevice(DeviceObject, Irp);
            
            if (Miniport->RemoveReadyEvent != NULL)
            {
                MINIPORT_DECREMENT_REF(Miniport);
                WAIT_FOR_OBJECT(&RemoveReadyEvent, NULL);
            }

            Irp->IoStatus.Status = Status;
            fSendIrpDown = NT_SUCCESS(Status) ? TRUE : FALSE;
            break;


        case IRP_MN_QUERY_CAPABILITIES:
            DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
                ("ndisPnPDispatch: Miniport, IRP_MN_QUERY_CAPABILITIES\n", Miniport));

            if (MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_SWENUM) ||
                (Miniport->MiniportAttributes & NDIS_ATTRIBUTE_SURPRISE_REMOVE_OK))
            {
                IrpSp->Parameters.DeviceCapabilities.Capabilities->SurpriseRemovalOK = 1;
            }
            
            IoCopyCurrentIrpStackLocationToNext(Irp);
            Status = ndisPassIrpDownTheStack(Irp, NextDeviceObject);

            //
            //  If the bus driver succeeded the start irp then proceed.
            //
            if (NT_SUCCESS(Status) && 
                !MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_SWENUM) &&
                !(Miniport->MiniportAttributes & NDIS_ATTRIBUTE_SURPRISE_REMOVE_OK))
            {
                DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
                    ("ndisPnPDispatch: Miniport %p, Clearing the SupriseRemovalOk bit.\n", Miniport));

                //
                //  Modify the capabilities so that the device is not suprise removable.
                //                                                
                IrpSp->Parameters.DeviceCapabilities.Capabilities->SurpriseRemovalOK = 0;
            }

            fSendIrpDown = FALSE;
            break;

        case IRP_MN_QUERY_PNP_DEVICE_STATE:

            if (MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_HIDDEN))
            {
                Irp->IoStatus.Information |= PNP_DEVICE_DONT_DISPLAY_IN_UI;
            }
            
            //
            //  Check to see if a power up failed. 
            //
            if (MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_DEVICE_FAILED))
            {
                DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_ERR,
                    ("ndisPnPDispatch: Miniport %p, IRP_MN_QUERY_PNP_DEVICE_STATE device failed\n", Miniport));

                //
                //  Mark the device as having failed so that pnp will remove it.
                //
                Irp->IoStatus.Information |= PNP_DEVICE_FAILED;
            }
            Irp->IoStatus.Status = Status;
            fSendIrpDown = TRUE ;
            break;

        case IRP_MN_QUERY_DEVICE_RELATIONS:
        case IRP_MN_QUERY_INTERFACE:
        case IRP_MN_QUERY_RESOURCES:
        case IRP_MN_QUERY_RESOURCE_REQUIREMENTS:
        case IRP_MN_READ_CONFIG:
        case IRP_MN_WRITE_CONFIG:
        case IRP_MN_EJECT:
        case IRP_MN_SET_LOCK:
        case IRP_MN_QUERY_ID:
        default:
            DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
                ("ndisPnPDispatch: Miniport %p, MinorFunction 0x%x\n", Miniport, IrpSp->MinorFunction));

            //
            //  We don't handle the irp so pass it down.
            //
            fSendIrpDown = TRUE;
            break;          
    }

Done:
    //
    //  First check to see if we need to send the irp down.
    //  If we don't pass the irp on then check to see if we need to complete it.
    //
    if (fSendIrpDown)
    {
        IoSkipCurrentIrpStackLocation(Irp);
        Status = IoCallDriver(NextDeviceObject, Irp);
    }
    else if (fCompleteIrp)
    {
        Irp->IoStatus.Status = Status;
        IoCompleteRequest(Irp, IO_NO_INCREMENT);
    }

    PnPDereferencePackage();
    
    DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
            ("<==ndisPnPDispatch: Miniport %p\n", Miniport));

    return(Status);
}

NDIS_STATUS
NdisIMNotifyPnPEvent(
    IN  NDIS_HANDLE     MiniportAdapterHandle,
    IN  PNET_PNP_EVENT  NetPnPEvent
    )
{
    PNDIS_MINIPORT_BLOCK    Miniport = (PNDIS_MINIPORT_BLOCK)MiniportAdapterHandle;
    NET_PNP_EVENT_CODE      NetEvent = NetPnPEvent->NetEvent;
    NDIS_STATUS             Status = NDIS_STATUS_SUCCESS;
    
    DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
            ("==>NdisIMNotifyPnPEvent: Miniport %p, NetEvent %lx\n", Miniport, NetEvent));

    switch (NetEvent)
    {
      case NetEventQueryPower:
      case NetEventQueryRemoveDevice:
      case NetEventCancelRemoveDevice:
      case NetEventPnPCapabilities:
        //
        // indicate up to the protocols
        //
        Status = ndisPnPNotifyAllTransports(
                            Miniport,
                            NetPnPEvent->NetEvent,
                            NetPnPEvent->Buffer,
                            NetPnPEvent->BufferLength);
                            
        break;
      
      case NetEventSetPower:
      case NetEventReconfigure:
      case NetEventBindList:
      case NetEventBindsComplete:
      default:
        //
        // ignore
        //
        break;
    }

    DBGPRINT_RAW(DBG_COMP_PNP, DBG_LEVEL_INFO,
            ("<==NdisIMNotifyPnPEvent: Miniport %p, NetEvent %lx, Status %lx\n", Miniport, NetEvent, Status));

    return (Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ndis\sys\ndispwr.c ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation

Module Name:

    ndispwr.c

Abstract:

    This module contains the code to process power managment IRPs that are
    sent under the IRP_MJ_POWER major code.

Author:

    Kyle Brandon    (KyleB)
    Alireza Dabagh  (alid)

Environment:

    Kernel mode

Revision History:

    02/11/97    KyleB           Created

--*/

#include <precomp.h>
#pragma hdrstop

#define MODULE_NUMBER   MODULE_POWER


NTSTATUS
FASTCALL
ndisQueryPowerCapabilities(
    IN  PNDIS_MINIPORT_BLOCK    Miniport
    )
/*++

Routine Description:

    This routine will process the IRP_MN_QUERY_CAPABILITIES by querying the
    next device object and saving information from that request.

Arguments:

    pIrp        -   Pointer to the IRP.
    pIrpSp      -   Pointer to the stack parameters for the IRP.
    pAdapter        -   Pointer to the device.

Return Value:

--*/
{
    PIRP                            pirp;
    PIO_STACK_LOCATION              pirpSpN;
    NTSTATUS                        Status = STATUS_SUCCESS;
    PDEVICE_CAPABILITIES            pDeviceCaps;
    PNDIS_PM_WAKE_UP_CAPABILITIES   pWakeUpCaps;
    DEVICE_CAPABILITIES             deviceCaps;
    POWER_QUERY                     pQuery;

    DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
        ("==>ndisQueryPowerCapabilities: Miniport %p\n", Miniport));

    do
    {
        //
        // default = no PM support
        //
        MINIPORT_PNP_CLEAR_FLAG(Miniport, fMINIPORT_PM_SUPPORTED);

        //
        // if the Next device object is NULL, Don't bother, just flag the Miniport
        // as not supporting PM.
        // this can happen for IM devices under Memphis
        //
        if (Miniport->NextDeviceObject == NULL)
        {
            break;
        }
        
        //
        //  Send the IRP_MN_QUERY_CAPABILITIES to pdo.
        //
        pirp = IoAllocateIrp((CCHAR)(Miniport->NextDeviceObject->StackSize + 1),
                             FALSE);
        if (NULL == pirp)
        {
            DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
                ("ndisQueryPowerCapabilities: Miniport %p, Failed to allocate an irp for IRP_MN_QUERY_CAPABILITIES\n", Miniport));

            NdisWriteErrorLogEntry((NDIS_HANDLE)Miniport,
                                   NDIS_ERROR_CODE_OUT_OF_RESOURCES,
                                   0);
                                   
            Status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }
        
        NdisZeroMemory(&deviceCaps, sizeof(deviceCaps));
        deviceCaps.Size = sizeof(DEVICE_CAPABILITIES);
        deviceCaps.Version = 1;

        //
        // should initalize deviceCaps.Address and deviceCaps.UINumber here as well
        //
        deviceCaps.Address = -1;
        deviceCaps.UINumber= -1;
        
        //
        //  Get the stack pointer.
        //
        pirpSpN = IoGetNextIrpStackLocation(pirp);
        ASSERT(pirpSpN != NULL);
        NdisZeroMemory(pirpSpN, sizeof(IO_STACK_LOCATION ) );
        
        //
        //  Set the default device state to full on.
        //
        pirpSpN->MajorFunction = IRP_MJ_PNP;
        pirpSpN->MinorFunction = IRP_MN_QUERY_CAPABILITIES;
        pirpSpN->Parameters.DeviceCapabilities.Capabilities = &deviceCaps;
        pirp->IoStatus.Status  = STATUS_NOT_SUPPORTED;
        
        //
        //  Setup the I/O completion routine to be called.
        //
        INITIALIZE_EVENT(&pQuery.Event);
        IoSetCompletionRoutine(pirp,
                               ndisCompletionRoutine,
                               &pQuery,
                               TRUE,
                               TRUE,
                               TRUE);


        //
        //  Call the next driver.
        //
        Status = IoCallDriver(Miniport->NextDeviceObject, pirp);
        if (STATUS_PENDING == Status)
        {
            Status = WAIT_FOR_OBJECT(&pQuery.Event, NULL);
            ASSERT(NT_SUCCESS(Status));
        }

        //
        //  If the lower device object successfully completed the request
        //  then we save that information.
        //
        if (NT_SUCCESS(pQuery.Status))
        {
            
            //
            //  Get the pointer to the device capabilities as returned by
            //  the parent PDO.
            //
            pDeviceCaps = &deviceCaps;
        
            //
            // save the entire device caps received from bus driver/ACPI
            //
            NdisMoveMemory(
                &Miniport->DeviceCaps,
                pDeviceCaps,
                sizeof(DEVICE_CAPABILITIES));


            if ((pDeviceCaps->DeviceWake != PowerDeviceUnspecified) &&
                (pDeviceCaps->SystemWake != PowerSystemUnspecified))
            {
                MINIPORT_PNP_SET_FLAG(Miniport, fMINIPORT_PM_SUPPORTED);
            }

            IF_DBG(DBG_COMP_PM, DBG_LEVEL_INFO)
            {
                UINT i;
                DbgPrint("ndisQueryPowerCapabilities: Miniport %p, Bus PM capabilities\n", Miniport);
                DbgPrint("\tDeviceD1:\t\t%ld\n", (pDeviceCaps->DeviceD1 == 0) ? 0 : 1);
                DbgPrint("\tDeviceD2:\t\t%ld\n", (pDeviceCaps->DeviceD2 == 0) ? 0 : 1);
                DbgPrint("\tWakeFromD0:\t\t%ld\n", (pDeviceCaps->WakeFromD0 == 0) ? 0 : 1);
                DbgPrint("\tWakeFromD1:\t\t%ld\n", (pDeviceCaps->WakeFromD1 == 0) ? 0 : 1);
                DbgPrint("\tWakeFromD2:\t\t%ld\n", (pDeviceCaps->WakeFromD2 == 0) ? 0 : 1);
                DbgPrint("\tWakeFromD3:\t\t%ld\n\n", (pDeviceCaps->WakeFromD3 == 0) ? 0 : 1);
                
                DbgPrint("\tSystemState\t\tDeviceState\n");

                if (pDeviceCaps->DeviceState[0] ==  PowerDeviceUnspecified)
                    DbgPrint("\tPowerSystemUnspecified\tPowerDeviceUnspecified\n");
                else
                    DbgPrint("\tPowerSystemUnspecified\t\tD%ld\n", pDeviceCaps->DeviceState[0] - 1);

                for (i = 1; i < PowerSystemMaximum; i++)
                {
                    if (pDeviceCaps->DeviceState[i]==  PowerDeviceUnspecified)
                        DbgPrint("\tS%ld\t\t\tPowerDeviceUnspecified\n",i-1);
                    else
                        DbgPrint("\tS%ld\t\t\tD%ld\n",i-1, pDeviceCaps->DeviceState[i] - 1);

                }

                if (pDeviceCaps->SystemWake == PowerSystemUnspecified)
                    DbgPrint("\t\tSystemWake: PowerSystemUnspecified\n");
                else
                    DbgPrint("\t\tSystemWake: S%ld\n", pDeviceCaps->SystemWake - 1);


                if (pDeviceCaps->DeviceWake == PowerDeviceUnspecified)
                    DbgPrint("\t\tDeviceWake: PowerDeviceUnspecified\n");
                else
                    DbgPrint("\t\tDeviceWake: D%ld\n", pDeviceCaps->DeviceWake - 1);

            }
        }
        else
        {
            DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,("ndisQueryPowerCapabilities: Miniport %p, Bus driver failed IRP_MN_QUERY_CAPABILITIES\n", Miniport));
        }

        //
        //  The irp is no longer needed.
        //
        IoFreeIrp(pirp);
        
    } while (FALSE);
    
    DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
        ("<==ndisQueryPowerCapabilities: Miniport %p, Status 0x%x\n", Miniport, Status));

    return(Status);
}

NTSTATUS
ndisMediaDisconnectComplete(
    IN  PDEVICE_OBJECT      pdo,
    IN  UCHAR               MinorFunction,
    IN  POWER_STATE         PowerState,
    IN  PVOID               Context,
    IN  PIO_STATUS_BLOCK    IoStatus
    )
/*++

Routine Description:


Arguments:

    pdo         -   Pointer to the DEVICE_OBJECT for the miniport.
    pirp        -   Pointer to the device set power state IRP that we created.
    Context     -   Pointer to the miniport block

Return Value:

--*/
{
    PNDIS_MINIPORT_BLOCK    Miniport = (PNDIS_MINIPORT_BLOCK)Context;
    NTSTATUS                Status = STATUS_MORE_PROCESSING_REQUIRED;
    KIRQL                   OldIrql;

    DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
        ("==>ndisMediaDisconnectComplete: Miniport %p\n", Miniport));

    NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Miniport, &OldIrql);

    //
    //  double check that we didn't get a link up while we were doing all this.
    //
    if (!MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_MEDIA_DISCONNECT_CANCELLED))
    {
        DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
            ("ndisMediaDisconnectComplete: Miniport %p, disconnect complete\n", Miniport));

        NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);
    }
    else
    {

        MINIPORT_PNP_CLEAR_FLAG(Miniport, fMINIPORT_MEDIA_DISCONNECT_CANCELLED);

        NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);

        //
        // if system is not going to sleep, wake up the device
        //
        if (!MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_SYSTEM_SLEEPING))
        {
            DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
                ("ndisMediaDisconnectComplete: Miniport %p, disconnect was cancelled. Power back up the miniport\n", Miniport));

            //
            //  Wake it back up
            //
            PowerState.DeviceState = PowerDeviceD0;
            Status = PoRequestPowerIrp(Miniport->PhysicalDeviceObject,
                                       IRP_MN_SET_POWER,
                                       PowerState,
                                       NULL,
                                       NULL,
                                       NULL);
        }
    }
    
    DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
        ("<==ndisMediaDisconnectComplete: Miniport %p\n", Miniport));

    return(STATUS_MORE_PROCESSING_REQUIRED);
}


VOID
ndisMediaDisconnectWorker(
    IN  PPOWER_WORK_ITEM    pWorkItem,
    IN  PVOID               Context
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PNDIS_MINIPORT_BLOCK    Miniport = (PNDIS_MINIPORT_BLOCK)Context;
    POWER_STATE             PowerState;
    NTSTATUS                Status;
    NDIS_STATUS             NdisStatus;
    ULONG                   WakeEnable;

    DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
            ("==>ndisMediaDisconnectWorker: Miniport %p\n", Miniport));

    //
    //  Determine the minimum device state we can go to and still get a link enabled.
    //
    if (Miniport->DeviceCaps.DeviceWake < Miniport->PMCapabilities.WakeUpCapabilities.MinLinkChangeWakeUp)
    {
        PowerState.DeviceState = Miniport->DeviceCaps.DeviceWake;
    }
    else
    {
        PowerState.DeviceState = Miniport->PMCapabilities.WakeUpCapabilities.MinLinkChangeWakeUp;
    }


    
    //
    // enable the appropriate wakeup method. this includes link change,
    // pattern match and/or magic packet.
    // if LINK_CHANGE method is disabled, we should not even get here
    //
    //
    // Miniport->WakeUpEnable is the wakeup methods enabled from protocol (and ndis point of view)
    // with this qfe, when the user turns wol off from UI, the methods going down are not
    // the methods set by protocol/ndis
    //
    
    WakeEnable = Miniport->WakeUpEnable;

    if (Miniport->PnPCapabilities & NDIS_DEVICE_DISABLE_WAKE_ON_PATTERN_MATCH)
    {
        WakeEnable &= ~NDIS_PNP_WAKE_UP_PATTERN_MATCH;
    }

    if (Miniport->PnPCapabilities & NDIS_DEVICE_DISABLE_WAKE_ON_MAGIC_PACKET)
    {
        WakeEnable &= ~NDIS_PNP_WAKE_UP_MAGIC_PACKET;
    }
                 
    NdisStatus = ndisQuerySetMiniportDeviceState(Miniport,
                                                 WakeEnable,
                                                 OID_PNP_ENABLE_WAKE_UP,
                                                 TRUE);

    if (NdisStatus == NDIS_STATUS_SUCCESS)
    {
        
            
        //
        //  We need to request a device state irp.
        //
        Miniport->WaitWakeSystemState = Miniport->DeviceCaps.SystemWake;
        Status = PoRequestPowerIrp(Miniport->PhysicalDeviceObject,
                                   IRP_MN_SET_POWER,
                                   PowerState,
                                   ndisMediaDisconnectComplete,
                                   Miniport,
                                   NULL);

    }
    
    FREE_POOL(pWorkItem);

    DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
            ("<==ndisMediaDisconnectWorker: Miniport %p\n", Miniport));
}


VOID
ndisMediaDisconnectTimeout(
    IN  PVOID   SystemSpecific1,
    IN  PVOID   Context,
    IN  PVOID   SystemSpecific2,
    IN  PVOID   SystemSpecific3
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    //
    //  Fire off a workitem to take care of this at passive level.
    //
    PNDIS_MINIPORT_BLOCK    Miniport = (PNDIS_MINIPORT_BLOCK)Context;
    PNDIS_OPEN_BLOCK        MiniportOpen;
    PPOWER_WORK_ITEM        pWorkItem;

    DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
        ("==>ndisMediaDisconnectTimeout: Miniport %p\n", Miniport));

    
    do
    {
        NDIS_ACQUIRE_MINIPORT_SPIN_LOCK_DPC(Miniport);
        
        if (!MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_MEDIA_DISCONNECT_WAIT))
        {
            NDIS_RELEASE_MINIPORT_SPIN_LOCK_DPC(Miniport);
            DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
                ("ndisMediaDisconnectTimeout: Miniport %p, media disconnect was cancelled\n", Miniport));
            break;
        }
        
        //
        //  Clear the disconnect wait flag.
        //
        MINIPORT_PNP_CLEAR_FLAG(Miniport, fMINIPORT_MEDIA_DISCONNECT_WAIT);
    
        NDIS_RELEASE_MINIPORT_SPIN_LOCK_DPC(Miniport);

        pWorkItem = ALLOC_FROM_POOL(sizeof(POWER_WORK_ITEM), NDIS_TAG_WORK_ITEM);
        if (pWorkItem != NULL)
        {
            //
            //  Initialize the ndis work item to power on.
            //
            NdisInitializeWorkItem(&pWorkItem->WorkItem,
                                   (NDIS_PROC)ndisMediaDisconnectWorker,
                                   Miniport);
        
            MINIPORT_PNP_SET_FLAG(Miniport, fMINIPORT_SEND_WAIT_WAKE);
            
            //
            //  Schedule the workitem to fire.
            //
            NdisScheduleWorkItem(&pWorkItem->WorkItem);
        }
    } while (FALSE);
    
    
    DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
        ("<==ndisMediaDisconnectTimeout: Miniport %p\n", Miniport));
}

NTSTATUS
ndisWaitWakeComplete(
    IN  PDEVICE_OBJECT      pdo,
    IN  UCHAR               MinorFunction,
    IN  POWER_STATE         PowerState,
    IN  PVOID               Context,
    IN  PIO_STATUS_BLOCK    IoStatus
    )
/*++

Routine Description:


Arguments:

    DeviceObject
    Irp
    Context

Return Value:

--*/
{
    PNDIS_MINIPORT_BLOCK    Miniport = (PNDIS_MINIPORT_BLOCK)Context;
    PIRP                    pirp;
    NTSTATUS                Status = IoStatus->Status;
    POWER_STATE             DevicePowerState;
    KIRQL                   OldIrql;
    
    DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
        ("==>ndisWaitWakeComplete: Miniport %p, pIrp %p, Status %lx\n", 
                    Miniport, Miniport->pIrpWaitWake, Status));

    NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Miniport, &OldIrql);
    pirp = Miniport->pIrpWaitWake;
    Miniport->pIrpWaitWake = NULL;
    NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);
    
    if (pirp != NULL)
    {

        //
        //  If this completion routine was called because a wake-up occured at the device level
        //  then we need to initiate a device irp to start up the nic.  If it was completed 
        //  due to a cancellation then we skip this since it was cancelled due to a device irp
        //  being sent to wake-up the device.
        //
        
        if (Status == STATUS_SUCCESS)
        {
            DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
                ("ndisWaitWakeComplete: Miniport %p, Wake irp was complete due to wake event\n", Miniport));

            if (!MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_SYSTEM_SLEEPING))
            {
                DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
                    ("ndisWaitWakeComplete: Miniport %p, Powering up the Miniport\n", Miniport));
                //
                //  We need to request a set power to power up the device.
                //
                DevicePowerState.DeviceState = PowerDeviceD0;
                Status = PoRequestPowerIrp(Miniport->PhysicalDeviceObject,
                                           IRP_MN_SET_POWER,
                                           DevicePowerState,
                                           NULL,
                                           NULL,
                                           NULL);
            }
            else
            {
                //
                // it is also possible that the device woke up the whole system (WOL) in which case we
                // will get a system power IRP eventually and we don't need to request a power IRP.
                //
                DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
                    ("ndisWaitWakeComplete: Miniport %p woke up the system.\n", Miniport));
                
            }
        }
        else
        {
            DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
                ("ndisWaitWakeComplete: Miniport %p, WAIT_WAKE irp failed or cancelled. Status %lx\n",
                    Miniport, Status));

        }

    }
    
    DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
        ("<==ndisWaitWakeComplete: Miniport %p\n", Miniport));
    
    return(STATUS_MORE_PROCESSING_REQUIRED);
}

NTSTATUS
ndisQueryPowerComplete(
    IN  PDEVICE_OBJECT  pdo,
    IN  PIRP            pirp,
    IN  PVOID           Context
    )
/*++

Routine Description:


Arguments:

    pdo     -   Pointer to the device object
    pirp    -   Pointer to the query power irp
    Context -   Pointer to the miniport.

Return Value:

--*/
{
    NTSTATUS    Status = pirp->IoStatus.Status;

    DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
        ("==>ndisQueryPowerComplete: Miniport %p, Bus driver returned %lx for QueryPower\n",
            Context, pirp->IoStatus.Status));
        
#ifdef TRACE_PM_PROBLEMS
    if (!NT_SUCCESS(pirp->IoStatus.Status))
    {
        DbgPrint("ndisQueryPowerComplete: Miniport %p, Bus Driver returned %lx for QueryPower.\n",
            Context, pirp->IoStatus.Status);
    }
#endif

    PoStartNextPowerIrp(pirp);

    DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
        ("<==ndisQueryPowerComplete: Miniport %p\n", Context));

    return(Status);
}

NTSTATUS
ndisQueryPower(
    IN  PIRP                    pirp,
    IN  PIO_STACK_LOCATION      pirpSp,
    IN  PNDIS_MINIPORT_BLOCK    Miniport
    )
/*++

Routine Description:

    This routine will process the IRP_MN_QUERY_POWER for a miniport driver.

Arguments:

    pirp        -   Pointer to the IRP.
    pirpSp      -   Pointer to the IRPs current stack location.
    Adapter     -   Pointer to the adapter.

Return Value:

--*/
{
    NTSTATUS                Status = STATUS_SUCCESS;
    DEVICE_POWER_STATE      DeviceState;
    NDIS_STATUS             NdisStatus;
    PIO_STACK_LOCATION      pirpSpN;

    DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
        ("==>ndisQueryPower: Miniport %p\n", Miniport));

    do
    {
        //
        //  We only handle system power states sent as a query.
        //
        if (pirpSp->Parameters.Power.Type != SystemPowerState)
        {
            DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
                ("ndisQueryPower: Miniport %p, Not a system state! Type: 0x%x. State: 0x%x\n",
                    Miniport, pirpSp->Parameters.Power.Type, pirpSp->Parameters.Power.State));
    
            Status = STATUS_INVALID_DEVICE_REQUEST;

            break;
        }

        //
        //  Determine if the system state is appropriate and what device state we
        //  should go to.
        //
        Status = ndisMPowerPolicy(Miniport,
                                  pirpSp->Parameters.Power.State.SystemState,
                                  &DeviceState,
                                  TRUE);

        

        if (!ndisIsMiniportStarted(Miniport) ||
            (Miniport->PnPDeviceState != NdisPnPDeviceStarted) ||
            (STATUS_DEVICE_POWERED_OFF == Status))
        {       
            pirp->IoStatus.Status = STATUS_SUCCESS;
    
            PoStartNextPowerIrp(pirp);
            IoCompleteRequest(pirp, 0);
            return(STATUS_SUCCESS);
        }

        //
        //  If we didn't succeed then fail the query power.
        //
        if (!NT_SUCCESS(Status))
        {
            DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
                ("ndisQueryPower: Miniport %p, Unable to go to system state 0x%x\n",
                    Miniport, pirpSp->Parameters.Power.State.SystemState));

            break;
        }

        //
        //  Notify the transports with the query power PnP event.
        //
        NdisStatus = ndisPnPNotifyAllTransports(Miniport,
                                                NetEventQueryPower,
                                                &DeviceState,
                                                sizeof(DeviceState));
        if (NDIS_STATUS_SUCCESS != NdisStatus)
        {
            DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_ERR,
                ("ndisQueryPower: Miniport %p, ndisPnPNotifyAllTransports failed\n", Miniport));

            Status = NdisStatus;
            break;
        }

        //
        //  Notify the miniport...
        //
        if (MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_DEVICE_POWER_ENABLE))
        {
            
            NdisStatus = ndisQuerySetMiniportDeviceState(Miniport,
                                                         DeviceState,
                                                         OID_PNP_QUERY_POWER,
                                                         FALSE);

            if (NDIS_STATUS_SUCCESS != NdisStatus)
            {
                DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
                    ("ndisQueryPower: Miniport %p, failed query power\n", Miniport));
                    
                Status = STATUS_UNSUCCESSFUL;
                break;
            }
        }

    } while (FALSE);

    if (!NT_SUCCESS(Status))
    {
        pirp->IoStatus.Status = Status;
        PoStartNextPowerIrp(pirp);
        IoCompleteRequest(pirp, 0);
    }
    else
    {
        //
        //  Pass this irp down the stack.
        //
        pirpSpN = IoGetNextIrpStackLocation(pirp);
        pirpSpN->MajorFunction = IRP_MJ_POWER;
        pirpSpN->MinorFunction = IRP_MN_QUERY_POWER;

        pirpSpN->Parameters.Power.SystemContext = pirpSp->Parameters.Power.SystemContext;
        pirpSpN->Parameters.Power.Type = DevicePowerState;
        pirpSpN->Parameters.Power.State.DeviceState = DeviceState;

        IoSetCompletionRoutine(
            pirp,
            ndisQueryPowerComplete,
            Miniport,
            TRUE,
            TRUE,
            TRUE);

        IoMarkIrpPending(pirp);
        PoStartNextPowerIrp(pirp);
        PoCallDriver(Miniport->NextDeviceObject, pirp);
        Status = STATUS_PENDING;

        DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
                ("ndisQueryPower: Miniport %p, PoCallDriver to NextDeviceObject returned %lx\n", Miniport, Status));

    }

    DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
        ("<==ndisQueryPower: Miniport %p\n", Miniport));

    return(Status);
}

VOID
FASTCALL
ndisPmHaltMiniport(
    IN PNDIS_MINIPORT_BLOCK Miniport
    )
/*++

Routine Description:

    This will stop the miniport from functioning...

Arguments:

    Miniport - pointer to the mini-port to halt

Return Value:

    None.

--*/

{
    KIRQL   OldIrql;

    DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
        ("==>ndisPmHaltMiniport: Miniport \n", Miniport));

    PnPReferencePackage();

    NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Miniport, &OldIrql);

    NdisResetEvent(&Miniport->OpenReadyEvent);

    if (MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_PM_HALTED))
    {
        ASSERT(FALSE);
        NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);
        return;
    }
    //
    //  Mark this miniport as halting.
    //
    MINIPORT_SET_FLAG(Miniport, fMINIPORT_PM_HALTING);
    MINIPORT_PNP_SET_FLAG(Miniport, fMINIPORT_PM_HALTED);

    MINIPORT_CLEAR_FLAG(Miniport, fMINIPORT_NORMAL_INTERRUPTS);
    MINIPORT_PNP_SET_FLAG(Miniport, fMINIPORT_NO_SHUTDOWN);

    NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);

    ndisMCommonHaltMiniport(Miniport);

    NdisMDeregisterAdapterShutdownHandler(Miniport);

    Miniport->MiniportAdapterContext = NULL;

    PnPDereferencePackage();

    DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
        ("<==ndisPmHaltMiniport: Miniport %p\n", Miniport));
}

NDIS_STATUS
ndisPmInitializeMiniport(
    IN  PNDIS_MINIPORT_BLOCK    Miniport
    )
/*++

Routine Description:

    This routine will re-initialize a miniport that has been halted due to
    a PM low power transition.

Arguments:

    Miniport    -   Pointer to the miniport block to re-initialize.

Return Value:

--*/
{
    PNDIS_M_DRIVER_BLOCK                pMiniBlock = Miniport->DriverHandle;
    NDIS_WRAPPER_CONFIGURATION_HANDLE   ConfigurationHandle;
    NDIS_STATUS                         Status;
    NDIS_STATUS                         OpenErrorStatus;
    UINT                                SelectedMediumIndex;
    ULONG                               Flags;
    ULONG                               GenericUlong = 0;
    KIRQL                               OldIrql;
    UCHAR                               SendFlags;

    DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
        ("==>ndisPmInitializeMiniport: Miniport %p\n", Miniport));
    
    do
    {
        MINIPORT_CLEAR_FLAG(Miniport, fMINIPORT_PM_HALTING |
                                      fMINIPORT_DEREGISTERED_INTERRUPT |
                                      fMINIPORT_RESET_REQUESTED |
                                      fMINIPORT_RESET_IN_PROGRESS);
                                      
        MINIPORT_PNP_CLEAR_FLAG(Miniport, fMINIPORT_REMOVE_IN_PROGRESS);

        Flags = Miniport->Flags;
        SendFlags = Miniport->SendFlags;

        //
        //  Clean up any workitems that might have been queue'd
        //
        NDISM_DEQUEUE_WORK_ITEM(Miniport, NdisWorkItemMiniportCallback, NULL);
        NDISM_DEQUEUE_WORK_ITEM(Miniport, NdisWorkItemRequest, NULL);
        NDISM_DEQUEUE_WORK_ITEM(Miniport, NdisWorkItemSend, NULL);
        NDISM_DEQUEUE_WORK_ITEM(Miniport, NdisWorkItemResetRequested, NULL);
        NDISM_DEQUEUE_WORK_ITEM(Miniport, NdisWorkItemResetInProgress, NULL);
        InitializeListHead(&Miniport->PacketList);

        //
        //  Initialize the configuration handle for use during the initialization.
        //
        ConfigurationHandle.DriverObject = Miniport->DriverHandle->NdisDriverInfo->DriverObject;
        ConfigurationHandle.DeviceObject = Miniport->DeviceObject;
        ConfigurationHandle.DriverBaseName = &Miniport->BaseName;

        ASSERT(KeGetCurrentIrql() == 0);
        Status = ndisInitializeConfiguration((PNDIS_WRAPPER_CONFIGURATION_HANDLE)&ConfigurationHandle,
                                             Miniport,
                                             NULL);
        ASSERT(KeGetCurrentIrql() == 0);

        if (NDIS_STATUS_SUCCESS != Status)
        {
            DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_ERR,
                ("ndisPmInitializeMiniport: Miniport %p, ndisInitializeConfiguration failed, Status: 0x%x\n", Miniport, Status));
            break;
        }
    
        //
        // Call adapter callback. The current value for "Export"
        // is what we tell him to name this device.
        //
        MINIPORT_SET_FLAG(Miniport, fMINIPORT_IN_INITIALIZE);
        MINIPORT_CLEAR_FLAG(Miniport, fMINIPORT_NORMAL_INTERRUPTS);
        Miniport->CurrentDevicePowerState = PowerDeviceD0;
    
        Status = (pMiniBlock->MiniportCharacteristics.InitializeHandler)(
                    &OpenErrorStatus,
                    &SelectedMediumIndex,
                    ndisMediumArray,
                    ndisMediumArraySize / sizeof(NDIS_MEDIUM),
                    (NDIS_HANDLE)Miniport,
                    (NDIS_HANDLE)&ConfigurationHandle);
    
        ASSERT(KeGetCurrentIrql() == 0);

        if (NDIS_STATUS_SUCCESS != Status)
        {
            DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_ERR,
                ("ndisPmInitializeMiniport: Miniport %p, MiniportInitialize handler failed, Status 0x%x\n", Miniport, Status));
    
            break;
        }
        
        ASSERT (Miniport->MediaType == ndisMediumArray[SelectedMediumIndex]);
        
        //
        // Restore saved settings
        //
        Miniport->Flags = Flags;
        Miniport->SendFlags = SendFlags;
        
        MINIPORT_PNP_CLEAR_FLAG(Miniport, fMINIPORT_PM_HALTED | fMINIPORT_REJECT_REQUESTS);
        MINIPORT_CLEAR_FLAG(Miniport, fMINIPORT_IN_INITIALIZE);
        CHECK_FOR_NORMAL_INTERRUPTS(Miniport);

        //
        //  Clear the flag preventing the miniport's shutdown handler from being
        //  called if needed.
        //
        MINIPORT_PNP_CLEAR_FLAG(Miniport, fMINIPORT_NO_SHUTDOWN);

        //
        // if device does not need polling for connect status then assume it is connected
        // as we always do when we intialize a miniport. if it does require media polling
        // leave the media status as it was before suspend. it will be updated on the very first
        // wakeup DPC.
        //
        if (!MINIPORT_TEST_FLAG(Miniport, fMINIPORT_REQUIRES_MEDIA_POLLING))
        {
            MINIPORT_SET_FLAG(Miniport, fMINIPORT_MEDIA_CONNECTED);
        }

        if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_MEDIA_CONNECTED))
        {
            //
            // set the ReceivePacket handler
            //
            ndisMSetIndicatePacketHandler(Miniport);
        }

        BLOCK_LOCK_MINIPORT_LOCKED(Miniport, OldIrql);

        //
        //  Restore the filter information.
        //
        ndisMRestoreFilterSettings(Miniport, NULL, FALSE);

        //
        //  Make sure the filter settings get updated.
        //
        if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_DESERIALIZE))
        {
            ndisMDoRequests(Miniport);
        }
        else
        {
            NDISM_PROCESS_DEFERRED(Miniport);
        }

        UNLOCK_MINIPORT_L(Miniport);

        //
        //  Start up the wake up timer.
        //
        DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
            ("ndisPmInitializeMiniport: Miniport %p, startup the wake-up DPC timer\n", Miniport));
    
        NdisMSetPeriodicTimer((PNDIS_MINIPORT_TIMER)(&Miniport->WakeUpDpcTimer),
                              Miniport->CheckForHangSeconds*1000);

        NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);

        ASSERT(KeGetCurrentIrql() == 0);

        if (Miniport->MediaType == NdisMedium802_3)
        {
            ndisMNotifyMachineName(Miniport, NULL);
        }

        //
        // Register with WMI.
        //
        Status = IoWMIRegistrationControl(Miniport->DeviceObject, WMIREG_ACTION_REGISTER);

        if (!NT_SUCCESS(Status))
        {
            //
            //  This should NOT keep the adapter from initializing but we should log the error.
            //
            DBGPRINT_RAW((DBG_COMP_INIT | DBG_COMP_WMI), DBG_LEVEL_WARN,
                ("ndisPmInitializeMiniport: Miniport %p, Failed to register for WMI support\n", Miniport));
        }

        Status = NDIS_STATUS_SUCCESS;
        
        KeQueryTickCount(&Miniport->NdisStats.StartTicks);
        
    } while (FALSE);

    if (NDIS_STATUS_SUCCESS != Status)
    {
        NdisMDeregisterAdapterShutdownHandler(Miniport);
        
        ndisLastFailedInitErrorCode =  Status;
        ASSERT(Miniport->Interrupt == NULL);
        ASSERT(Miniport->TimerQueue == NULL);
        ASSERT(Miniport->MapRegisters == NULL);

        if ((Miniport->TimerQueue != NULL) || (Miniport->Interrupt != NULL))
        {
            if (Miniport->Interrupt != NULL)
            {
                BAD_MINIPORT(Miniport, "Unloading without deregistering interrupt");
            }
            else
            {
                BAD_MINIPORT(Miniport, "Unloading without deregistering timer");
            }
            KeBugCheckEx(BUGCODE_ID_DRIVER,
                        (ULONG_PTR)Miniport,
                        (ULONG_PTR)Miniport->Interrupt,
                        (ULONG_PTR)Miniport->TimerQueue,
                        1);
        }
    
        MINIPORT_SET_FLAG(Miniport, fMINIPORT_PM_HALTING);
        MINIPORT_PNP_SET_FLAG(Miniport, fMINIPORT_PM_HALTED);
        MINIPORT_CLEAR_FLAG(Miniport, fMINIPORT_NORMAL_INTERRUPTS);
        
    }

    DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
        ("<==ndisPmInitializeMiniport: Miniport %p\n", Miniport));

    return(Status);
}

NDIS_STATUS
ndisQuerySetMiniportDeviceState(
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  DEVICE_POWER_STATE      DeviceState,
    IN  NDIS_OID                Oid,
    IN  BOOLEAN                 fSet
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    NDIS_STATUS             NdisStatus;
    NDIS_REQUEST            PowerReq;
    PNDIS_COREQ_RESERVED    CoReqRsvd;
    ULONG                   State;

    DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
            ("==>ndisQuerySetMiniportDeviceState: Miniport %p\n", Miniport));

    //
    //  Setup the miniport's internal request for a set power OID.
    //
    CoReqRsvd = PNDIS_COREQ_RESERVED_FROM_REQUEST(&PowerReq);
    INITIALIZE_EVENT(&CoReqRsvd->Event);

    PowerReq.DATA.SET_INFORMATION.InformationBuffer = &State;
    PowerReq.DATA.SET_INFORMATION.InformationBufferLength = sizeof(State);

    PowerReq.RequestType = fSet ? NdisRequestSetInformation : NdisRequestQueryInformation;

    PowerReq.DATA.SET_INFORMATION.Oid = Oid;
    PowerReq.DATA.SET_INFORMATION.InformationBuffer = &DeviceState;
    PowerReq.DATA.SET_INFORMATION.InformationBufferLength = sizeof(DeviceState);

    NdisStatus = ndisQuerySetMiniport(Miniport,
                                      NULL,
                                      fSet,
                                      &PowerReq,
                                      NULL);

#ifdef TRACE_PM_PROBLEMS
    if (NdisStatus != NDIS_STATUS_SUCCESS)
    {
        DbgPrint("ndisQuerySetMiniportDeviceState: Miniport %p, (Name: %p) failed Oid %lx, Set = %lx with error %lx\n",
                        Miniport,
                        Miniport->pAdapterInstanceName,
                        Oid,
                        fSet,
                        NdisStatus);
    }
#endif

                    
    //
    //  Miniport can't fail the set power request.
    //
    if (fSet)
    {
        ASSERT(NDIS_STATUS_SUCCESS == NdisStatus);
    }
    
    DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
            ("<==ndisQuerySetMiniportDeviceState: Miniport %p, Status %lx\n", Miniport, NdisStatus));

    return(NdisStatus);
}


NTSTATUS
ndisSetSystemPowerComplete(
    IN  PDEVICE_OBJECT      pdo,
    IN  UCHAR               MinorFunction,
    IN  POWER_STATE         PowerState,
    IN  PVOID               Context,
    IN  PIO_STATUS_BLOCK    IoStatus
    )
/*++

Routine Description:


Arguments:

    pdo         -   Pointer to the DEVICE_OBJECT for the miniport.
    pirp        -   Pointer to the device set power state IRP that we created.
    Context     -   Pointer to the system set power state sent by the OS.

Return Value:

--*/
{
    PIRP                    pirpSystem = Context;
    PIO_STACK_LOCATION      pirpSp;
    PNDIS_MINIPORT_BLOCK    Miniport;

    DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
        ("==>ndisSetSystemPowerComplete: DeviceObject %p\n", pdo));

    //
    //  Save the status code with the original IRP.
    //
    pirpSystem->IoStatus = *IoStatus;

    //
    //  did everything go well?
    //
    if (NT_SUCCESS(IoStatus->Status))
    {
        //
        //  Get current stack pointer.
        //
        pirpSp = IoGetCurrentIrpStackLocation(pirpSystem);

        ASSERT(SystemPowerState == pirpSp->Parameters.Power.Type);
        
        DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
            ("ndisSetSystemPowerComplete: DeviceObject %p, Going to system power state %lx\n",
                pdo, pirpSp->Parameters.Power.State));

        //
        //  Notify the system that we are in the appropriate power state.
        //
        PoSetPowerState(pirpSp->DeviceObject,SystemPowerState, pirpSp->Parameters.Power.State);
        
        Miniport = (PNDIS_MINIPORT_BLOCK)((PNDIS_WRAPPER_CONTEXT)pirpSp->DeviceObject->DeviceExtension + 1);

        //
        // now send down the System power IRP
        //
        IoCopyCurrentIrpStackLocationToNext(pirpSystem);
        PoCallDriver(Miniport->NextDeviceObject, pirpSystem);
    }
    else
    {
        DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_ERR,
            ("ndisSetSystemPowerComplete: DeviceObject %p, IRP_MN_SET_POWER failed!\n", pdo));
            
        IoCompleteRequest(pirpSystem, 0);

    }


    DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
        ("<==ndisSetSystemPowerComplete: DeviceObject %p\n", pdo));

    return(STATUS_MORE_PROCESSING_REQUIRED);
}

NTSTATUS
ndisSetSystemPowerOnComplete(
    IN  PDEVICE_OBJECT      pdo,
    IN  PIRP                pirp,
    IN  PVOID               Context
    )
/*++

Routine Description:

    Completion routine for S0 irp completion. This routine requests a D0 irp to be sent down the stack.

Arguments:

    pdo         -   Pointer to the DEVICE_OBJECT for the miniport.
    pirp        -   Pointer to the S0 irp sent by the power manager.
    Context     -   Pointer to the miniport context

Return Value:

--*/
{
    PIO_STACK_LOCATION      pirpSp = IoGetCurrentIrpStackLocation(pirp);
    PNDIS_MINIPORT_BLOCK    Miniport = Context;
    POWER_STATE PowerState;

    DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
        ("==>ndisSetSystemPowerOnComplete: DeviceObject %p\n", pdo));

    //
    //  did everything go well?
    //
    if (NT_SUCCESS(pirp->IoStatus.Status))
    {
        //
        //  Request the D irp now.
        //
        PowerState.DeviceState = PowerDeviceD0;
        PoRequestPowerIrp(Miniport->PhysicalDeviceObject,
                          IRP_MN_SET_POWER,
                          PowerState,
                          NULL,
                          NULL,
                          NULL);
        
        DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
            ("ndisSetSystemPowerOnComplete: DeviceObject %p, Going to system power state %lx\n",
                pdo, PowerState));

        //
        //  Notify the system that we are in the appropriate power state.
        //
        PoSetPowerState(pdo ,SystemPowerState, pirpSp->Parameters.Power.State);
    }
    return(STATUS_SUCCESS);
}

VOID
ndisDevicePowerOn(
    IN  PPOWER_WORK_ITEM    pWorkItem,
    IN  PVOID               pContext
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PNDIS_MINIPORT_BLOCK    Miniport = (PNDIS_MINIPORT_BLOCK)pContext;
    DEVICE_POWER_STATE      DeviceState;
    POWER_STATE             PowerState;
    NDIS_STATUS             NdisStatus;
    PIRP                    pirp;
    PIO_STACK_LOCATION      pirpSp;
    NTSTATUS                NtStatus;
    NDIS_POWER_PROFILE      PowerProfile;
    BOOLEAN                 fNotifyProtocols = FALSE;
    BOOLEAN                 fStartMediaDisconnectTimer = FALSE;
    KIRQL                   OldIrql;

    DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
        ("==>ndisDevicePowerOn: Miniport %p\n", Miniport));
        
    PnPReferencePackage();
    
    pirp = pWorkItem->pIrp;
    pirpSp = IoGetCurrentIrpStackLocation(pirp);
    DeviceState = pirpSp->Parameters.Power.State.DeviceState;

#ifdef TRACE_PM_PROBLEMS
    if (!NT_SUCCESS(pirp->IoStatus.Status))
    {
        DbgPrint("ndisDevicePowerOn: Miniport %p, Bus Driver returned %lx for Powering up the Miniport.\n",
                    Miniport, pirp->IoStatus.Status);
    }
#endif

    if (NT_SUCCESS(pirp->IoStatus.Status))
    {
        DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
            ("ndisDevicePowerOn: Miniport %p, Bus driver succeeded power up\n", Miniport));

        //
        //  If the device is not in D0 then we need to wake up the miniport and
        //  restore the handlers.
        //
        if (Miniport->CurrentDevicePowerState != PowerDeviceD0)
        {
            DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
                ("ndisDevicePowerOn: Miniport %p, Power up the Miniport\n", Miniport));

            //
            //  What type of miniport was this?
            //
            if (MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_DEVICE_POWER_ENABLE))
            {
                //
                //  Set the miniport's device state.
                //
                NdisStatus = ndisQuerySetMiniportDeviceState(Miniport, 
                                                             DeviceState,
                                                             OID_PNP_SET_POWER,
                                                             TRUE);
                ASSERT(KeGetCurrentIrql() == 0);

                if (NdisStatus == NDIS_STATUS_SUCCESS)
                    Miniport->CurrentDevicePowerState = DeviceState;


                //
                // Start wake up timer
                //
                NdisMSetPeriodicTimer((PNDIS_MINIPORT_TIMER)(&Miniport->WakeUpDpcTimer),
                                      Miniport->CheckForHangSeconds*1000);
            }
            else
            {
                ASSERT(KeGetCurrentIrql() == PASSIVE_LEVEL);

                if (((Miniport->DriverHandle->Flags & fMINIBLOCK_INTERMEDIATE_DRIVER) == 0) &&
                    (MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_PM_HALTED)))
                {                    
                    NdisStatus = ndisPmInitializeMiniport(Miniport);
                    ASSERT(KeGetCurrentIrql() == 0);
                }
                else
                {
                    NdisStatus = NDIS_STATUS_SUCCESS;               
                }
            }

            if (NDIS_STATUS_SUCCESS == NdisStatus)
            {
                if (ndisIsMiniportStarted(Miniport))
                {
                    NdisSetEvent(&Miniport->OpenReadyEvent);
                    //
                    //  Restore the handlers.
                    //
                    NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Miniport, &OldIrql);
                    ndisMRestoreOpenHandlers(Miniport, fMINIPORT_STATE_PM_STOPPED);
                    NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);
                    
                    ASSERT(KeGetCurrentIrql() == 0);

                    ASSERT(Miniport->SymbolicLinkName.Buffer != NULL);
                    
                    if (Miniport->SymbolicLinkName.Buffer != NULL)
                    {
                        NtStatus = IoSetDeviceInterfaceState(&Miniport->SymbolicLinkName, TRUE);
                    }
                    
                    if (!NT_SUCCESS(NtStatus))
                    {
                        DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_ERR,
                            ("ndisDevicePowerOn: IoRegisterDeviceClassAssociation failed: Miniport %p, Status %lx\n", Miniport, NtStatus));
                    }

                    fNotifyProtocols = TRUE;
                    fStartMediaDisconnectTimer = TRUE;

                    //
                    // let the adapter know about the current power source
                    //
                    PowerProfile = ((BOOLEAN)ndisAcOnLine == TRUE) ? 
                                    NdisPowerProfileAcOnLine : 
                                    NdisPowerProfileBattery;

                    ndisNotifyMiniports(Miniport,
                                        NdisDevicePnPEventPowerProfileChanged,
                                        &PowerProfile,
                                        sizeof(NDIS_POWER_PROFILE));

                }
                
                //
                //  Save the new power state the device is in.
                //
                Miniport->CurrentDevicePowerState = DeviceState;
            
                DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
                    ("ndisDevicePowerOn: Miniport %p, Going to device state 0x%x\n", Miniport, DeviceState));
            
                //
                //  Notify the system that we are in the new device state.
                //
                PowerState.DeviceState = DeviceState;
                PoSetPowerState(Miniport->DeviceObject, DevicePowerState, PowerState);
            }
            else
            {
                DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_ERR,
                    ("ndisDevicePowerOn: Miniport %p, Power on failed by device driver for the Miniport, Error %lx!\n",
                        Miniport, NdisStatus));
                    
#ifdef TRACE_PM_PROBLEMS
                DbgPrint("ndisDevicePowerOn: Miniport %p, Device Driver failed powering up Miniport with Error %lx.\n",
                        Miniport,
                        NdisStatus);
#endif
                pirp->IoStatus.Status = STATUS_UNSUCCESSFUL;
            }
        }
        else
        {
            //
            // device is already in D0. we are here because of a cancel of QueryPower
            //
            if (ndisIsMiniportStarted(Miniport) && 
                (Miniport->PnPDeviceState == NdisPnPDeviceStarted))
            {
                //
                // even if the current state of the device is D0, we 
                // need to notify the protocol. because we could be getting
                // this IRP as a cancel to a query IRP -or- the device
                // never lost its D0 state, but the sytem went to sleep
                // and woke up!
                //
                NdisSetEvent(&Miniport->OpenReadyEvent);

                //
                //  Restore the handlers.
                //
                NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Miniport, &OldIrql);
                ndisMRestoreOpenHandlers(Miniport, fMINIPORT_STATE_PM_STOPPED);
                NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);

                fNotifyProtocols = TRUE;
                fStartMediaDisconnectTimer = FALSE;

            }
    
        }
    }

    NtStatus = pirp->IoStatus.Status;
    PoStartNextPowerIrp(pirp);
    IoCompleteRequest(pirp, 0);

    //
    // notify the protocols here after completing the power IRP
    // to avoid deadlocks when protocols block on a request that can only
    // complete when the other power IRPs go through
    //
    
    //
    //  Handle the case where the device was not able to power up.
    //
    if (!NT_SUCCESS(NtStatus))
    {
    
#ifdef TRACE_PM_PROBLEMS
        DbgPrint("ndisDevicePowerOn: Miniport %p, Bus or Device failed powering up the Miniport with Error %lx.\n",
                Miniport,
                NtStatus);
#endif

        DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_ERR,
                ("ndisDevicePowerOn: Miniport %p, Power on failed by bus or device driver for Miniport with Error %lx!\n",
                Miniport, NtStatus));

        //
        //  Mark the miniport as having failed so that we remove it correctly.
        //
        MINIPORT_PNP_SET_FLAG(Miniport, fMINIPORT_DEVICE_FAILED);
        
        //
        //  We need to tell pnp that the device state has changed.
        //
        IoInvalidateDeviceState(Miniport->PhysicalDeviceObject);
        ASSERT(KeGetCurrentIrql() == 0);
    }


    if (fNotifyProtocols)
    {
        //
        // for some protocols we may have closed the binding
        //
        ndisCheckAdapterBindings(Miniport, NULL);
        
        //
        //  Notify the transports.
        //
        ndisPnPNotifyAllTransports(Miniport,
                                   NetEventSetPower,
                                   &DeviceState,
                                   sizeof(DeviceState));

        ndisNotifyDevicePowerStateChange(Miniport, DeviceState);
        
        //
        // if media state has changed from disconnect to connect
        // and the last indicated status was disconnect,
        // we should notify the protcols (and Ndis) that the media is
        // connected
        //
        if (MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_MEDIA_DISCONNECT_INDICATED) && 
            MINIPORT_TEST_FLAG(Miniport, fMINIPORT_MEDIA_CONNECTED))
        {
            BLOCK_LOCK_MINIPORT_LOCKED(Miniport, OldIrql);
            NDIS_RELEASE_MINIPORT_SPIN_LOCK_DPC(Miniport);
            MINIPORT_CLEAR_FLAG(Miniport, fMINIPORT_MEDIA_CONNECTED);
        
            NdisMIndicateStatus(Miniport,
                    NDIS_STATUS_MEDIA_CONNECT,
                    INTERNAL_INDICATION_BUFFER,
                    INTERNAL_INDICATION_SIZE);
            NdisMIndicateStatusComplete(Miniport);

            UNLOCK_MINIPORT_L(Miniport);
            LOWER_IRQL(OldIrql, DISPATCH_LEVEL);
        }

        //
        // check the media status and if it is disconnected, start the timer
        //
        if (!MINIPORT_TEST_FLAG(Miniport, fMINIPORT_MEDIA_CONNECTED) &&
            fStartMediaDisconnectTimer)
        {
            if (MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_DEVICE_POWER_ENABLE) &&
                (Miniport->WakeUpEnable & NDIS_PNP_WAKE_UP_LINK_CHANGE) &&
                (Miniport->MediaDisconnectTimeOut != (USHORT)(-1)))
            {
                //
                //  Are we already waiting for the disconnect timer to fire?
                //
                if (!MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_MEDIA_DISCONNECT_WAIT))
                {
                    //
                    //  Mark the miniport as disconnecting and fire off the
                    //  timer.
                    //
                    MINIPORT_PNP_CLEAR_FLAG(Miniport, fMINIPORT_MEDIA_DISCONNECT_CANCELLED);
                    MINIPORT_PNP_SET_FLAG(Miniport, fMINIPORT_MEDIA_DISCONNECT_WAIT);

                    NdisSetTimer(&Miniport->MediaDisconnectTimer, Miniport->MediaDisconnectTimeOut * 1000);
                }
            }
        }
 
    }

    ASSERT(KeGetCurrentIrql() == 0);

    MINIPORT_DECREMENT_REF(Miniport);

    FREE_POOL(pWorkItem);
    
    PnPDereferencePackage();
    
    DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
        ("<==ndisDevicePowerOn: Miniport %p\n", Miniport));
}


NTSTATUS
ndisSetDevicePowerOnComplete(
    IN  PDEVICE_OBJECT  pdo,
    IN  PIRP            pirp,
    IN  PVOID           pContext
    )
/*++

Routine Description:


Arguments:

    pdo     -   Pointer to the device object for the miniport.
    pirp    -   Pointer to the device set power state IRP that was completed.
    Context -   Not used

Return Value:

--*/
{
    PNDIS_MINIPORT_BLOCK    Miniport = (PNDIS_MINIPORT_BLOCK)pContext;
    PPOWER_WORK_ITEM        pWorkItem;
    NDIS_STATUS             NdisStatus;
    DEVICE_POWER_STATE      DeviceState;
    POWER_STATE             PowerState;
    PIO_STACK_LOCATION      pirpSp;

    DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
        ("==>ndisSetDevicePowerOnComplete: Miniport %p, Irp %p, Status %lx\n",
            Miniport, pirp, pirp->IoStatus.Status));

    do
    {
        if (Miniport->PnPDeviceState != NdisPnPDeviceStarted)
        {
            DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
                ("ndisSetDevicePowerOnComplete: Miniport %p is not started yet.\n", Miniport));
                
            pirpSp = IoGetCurrentIrpStackLocation(pirp);
            DeviceState = pirpSp->Parameters.Power.State.DeviceState;
                
            //
            //  Notify the system that we are in the new device state.
            //
            Miniport->CurrentDevicePowerState = DeviceState;
            PowerState.DeviceState = DeviceState;
            PoSetPowerState(Miniport->DeviceObject, DevicePowerState, PowerState);
                
            PoStartNextPowerIrp(pirp);
            IoCompleteRequest(pirp, 0);
            break;
        }
        pWorkItem = ALLOC_FROM_POOL(sizeof(POWER_WORK_ITEM), NDIS_TAG_WORK_ITEM);
        if (pWorkItem == NULL)
        {
            pirp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;

            PoStartNextPowerIrp(pirp);
            IoCompleteRequest(pirp, 0);
            break;
        }

        //
        //  Initialize the ndis work item to power on.
        //
        NdisInitializeWorkItem(&pWorkItem->WorkItem,
                               (NDIS_PROC)ndisDevicePowerOn,
                               Miniport);
        pWorkItem->pIrp = pirp;

        //
        // this reference and corresponding dereference in ndisDevicePowerOn is done
        // to ensure ndis does not return back from REMOVE IRP while we are waiting
        // for ndisDevicePowerOn to fire.
        //
        MINIPORT_INCREMENT_REF(Miniport);

        //
        //  Schedule the workitem to fire.
        //
        INITIALIZE_WORK_ITEM((PWORK_QUEUE_ITEM)(&pWorkItem->WorkItem.WrapperReserved),
                             ndisWorkItemHandler,
                             &pWorkItem->WorkItem);
        XQUEUE_WORK_ITEM((PWORK_QUEUE_ITEM)(&pWorkItem->WorkItem.WrapperReserved), DelayedWorkQueue);
    } while (FALSE);
    
    DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
        ("<==ndisSetDevicePowerOnComplete: Miniport %p\n", Miniport));

    return(STATUS_MORE_PROCESSING_REQUIRED);
}


VOID
ndisDevicePowerDown(
    IN  PPOWER_WORK_ITEM    pWorkItem,
    IN  PVOID               pContext
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PNDIS_MINIPORT_BLOCK    Miniport = (PNDIS_MINIPORT_BLOCK)pContext;
    DEVICE_POWER_STATE      DeviceState;
    POWER_STATE             PowerState;
    NDIS_STATUS             NdisStatus;
    PIRP                    pirp;
    PIO_STACK_LOCATION      pirpSp;
    KIRQL                   OldIrql;

    DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
        ("==>ndisDevicePowerDown: Miniport %p\n", Miniport));

    PnPReferencePackage();

    pirp = pWorkItem->pIrp;
    pirpSp = IoGetCurrentIrpStackLocation(pirp);
    DeviceState = pirpSp->Parameters.Power.State.DeviceState;

    //
    //  If the complete status is successful then we need to continue with
    //  wakeing the stack.
    //
    if (NT_SUCCESS(pirp->IoStatus.Status))
    {
        DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
            ("ndisDevicePowerDown: Miniport %p, going to device state 0x%x\n", Miniport, DeviceState));

        //
        //  Build a power state.
        //
        PowerState.DeviceState = DeviceState;

        //
        //  Save the current device state with the miniport block.
        //
        Miniport->CurrentDevicePowerState = DeviceState;

        //
        //  Let the system know about the devices new power state.
        //
        PoSetPowerState(Miniport->DeviceObject, DevicePowerState, PowerState);
    }
    else if (ndisIsMiniportStarted(Miniport) && 
            (Miniport->PnPDeviceState == NdisPnPDeviceStarted))
    {
        DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_ERR,
            ("ndisDevicePowerDown: Miniport %p, Bus driver failed to power down the Miniport\n", Miniport));
            
#ifdef TRACE_PM_PROBLEMS
            DbgPrint("ndisDevicePowerDown: Miniport %p, Bus Driver returned %lx for Powering Down the Miniport\n",
                Miniport, pirp->IoStatus.Status);
#endif

        //
        //  We need to go back to the current device state.
        //
        PowerState.DeviceState = Miniport->CurrentDevicePowerState;

        DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
            ("ndisDevicePowerDown: Miniport %p, going to device power state 0x%x\n", Miniport, Miniport->CurrentDevicePowerState));

        //
        //  What type of miniport was this?
        //
        if (MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_DEVICE_POWER_ENABLE))
        {
            //
            //  Set the miniport's device state.
            //
            NdisStatus = ndisQuerySetMiniportDeviceState(Miniport,
                                                         PowerState.DeviceState,
                                                         OID_PNP_SET_POWER,
                                                         TRUE);
        }
        else
        {
            NdisStatus = ndisPmInitializeMiniport(Miniport);
        }

        //
        //  Is the miniport initialized?
        //
        if (NDIS_STATUS_SUCCESS != NdisStatus)
        {
            DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
                ("ndisDevicePowerDown: Miniport %p, failed to power down but we are not able to reinitialize it.\n", Miniport));

            //
            //  Mark the miniport as having failed so that we remove it correctly.
            //
            MINIPORT_PNP_SET_FLAG(Miniport, fMINIPORT_DEVICE_FAILED);

            //
            //  The bus driver failed the power off and we can't power the miniport back on.
            //  we invalidate the device state so that it will get removed.
            //
            IoInvalidateDeviceState(Miniport->PhysicalDeviceObject);

            pirp->IoStatus.Status = STATUS_UNSUCCESSFUL;
        }
        else
        {
            //
            //  Restore the handlers.
            //
            NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Miniport, &OldIrql);
            ndisMRestoreOpenHandlers(Miniport, fMINIPORT_STATE_PM_STOPPED);
            NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);

            IoSetDeviceInterfaceState(&Miniport->SymbolicLinkName, TRUE);

            ndisNotifyDevicePowerStateChange(Miniport, PowerState.DeviceState);
            
            //
            //  Notify the transports.
            //
            NdisStatus = ndisPnPNotifyAllTransports(Miniport,
                                                    NetEventSetPower,
                                                    &PowerState.DeviceState,
                                                    sizeof(PowerState.DeviceState));
            ASSERT(NDIS_STATUS_SUCCESS == NdisStatus);
        }
    }

    PoStartNextPowerIrp(pirp);
    IoCompleteRequest(pirp, 0);

    FREE_POOL(pWorkItem);

    ASSERT(KeGetCurrentIrql() == 0);

    PnPDereferencePackage();
    
    DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
        ("<==ndisDevicePowerDown: Miniport %p\n", Miniport));
}

NTSTATUS
ndisSetDevicePowerDownComplete(
    IN  PDEVICE_OBJECT  pdo,
    IN  PIRP            pirp,
    IN  PVOID           pContext
    )
/*++

Routine Description:


Arguments:

    pdo     -   Pointer to the device object for the miniport.
    pirp    -   Pointer to the device set power state IRP that was completed.
    Context -   Not used

Return Value:

--*/
{
    PNDIS_MINIPORT_BLOCK    Miniport = (PNDIS_MINIPORT_BLOCK)pContext;
    NTSTATUS                Status;
    PPOWER_WORK_ITEM        pWorkItem;
    NDIS_STATUS             NdisStatus;
    BOOLEAN                 fTimerCancelled;

    DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
        ("==>ndisSetDevicePowerDownComplete: Miniport %p, Irp %p, Status %lx\n",
            Miniport, pirp, pirp->IoStatus.Status));

    //
    // cancel any pending media disconnect timers
    //
    if (MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_MEDIA_DISCONNECT_WAIT))
    {
        //
        //  Clear the disconnect wait bit and cancel the timer.
        //  IF the timer routine hasn't grabed the lock then we are ok.
        //
        DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
            ("ndisSetDevicePowerDownComplete: Miniport %p, cancelling media disconnect timer\n",Miniport));
        MINIPORT_PNP_CLEAR_FLAG(Miniport, fMINIPORT_MEDIA_DISCONNECT_WAIT);
        MINIPORT_PNP_SET_FLAG(Miniport, fMINIPORT_MEDIA_DISCONNECT_CANCELLED);

        NdisCancelTimer(&Miniport->MediaDisconnectTimer, &fTimerCancelled);
    }

    do
    {
        pWorkItem = ALLOC_FROM_POOL(sizeof(POWER_WORK_ITEM), NDIS_TAG_WORK_ITEM);
        if (pWorkItem == NULL)
        {
            pirp->IoStatus.Status = STATUS_INSUFFICIENT_RESOURCES;

            PoStartNextPowerIrp(pirp);
            IoCompleteRequest(pirp, 0);
            break;
        }

        NdisInitializeWorkItem(&pWorkItem->WorkItem,
                               (NDIS_PROC)ndisDevicePowerDown,
                               Miniport);
        pWorkItem->pIrp = pirp;

        //
        //  Schedule the workitem to fire.
        //
        NdisScheduleWorkItem(&pWorkItem->WorkItem);
    } while (FALSE);
    
    DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
        ("<==ndisSetDevicePowerDownComplete: Miniport %p\n", Miniport));

    return(STATUS_MORE_PROCESSING_REQUIRED);
}

NTSTATUS
ndisSetPower(
    IN  PIRP                    pirp,
    IN  PIO_STACK_LOCATION      pirpSp,
    IN  PNDIS_MINIPORT_BLOCK    Miniport
    )
/*++

Routine Description:

    This routine will process the IRP_MN_SET_POWER for a miniport driver.

Arguments:

    pirp        -   Pointer to the IRP.
    pirpSp      -   Pointer to the IRPs current stack location.
    Miniport    -   Pointer to the Miniport

Return Value:

--*/
{
    POWER_STATE             PowerState;
    DEVICE_POWER_STATE      DeviceState;
    SYSTEM_POWER_STATE      SystemState;
    NDIS_DEVICE_POWER_STATE NdisDeviceState;
    NTSTATUS                Status;
    PIO_STACK_LOCATION      pirpSpN;
    IO_STATUS_BLOCK         IoStatus;
    PIRP                    pirpWake;
    NDIS_STATUS             NdisStatus;
    KEVENT                  Event;
    ULONG                   WakeEnable = 0;
    PIRP                    pIrpWaitWake;
    KIRQL                   OldIrql;

    DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
        ("==>ndisSetPower: Miniport %p, Irp %p\n", Miniport, pirp));

    PnPReferencePackage();
    
    switch (pirpSp->Parameters.Power.Type)
    {
        case SystemPowerState:

            SystemState = pirpSp->Parameters.Power.State.SystemState;
            Miniport->WaitWakeSystemState = SystemState;
            
            //
            // if system is shutting down, call the shutdown handler
            // for miniport and be done with it
            //

            if (SystemState >= PowerSystemShutdown)
            {
                DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
                    ("ndisSetPower: Miniport %p, SystemState %lx\n", Miniport, SystemState));

                if ((Miniport->DriverHandle->Flags & fMINIBLOCK_INTERMEDIATE_DRIVER) == 0)
                {
                    ndisMShutdownMiniport(Miniport);
                }

                pirp->IoStatus.Status = STATUS_SUCCESS;
                PoStartNextPowerIrp(pirp);
                IoSkipCurrentIrpStackLocation(pirp);
                Status = PoCallDriver(Miniport->NextDeviceObject, pirp);
                break;
            }
            else
            {
                //
                // Get the device state for the system state. Note that this will
                // set the fMINIPORT_SYSTEM_SLEEPING flag if we are going to 
                // SystemState > PowerSystemWorking
                //
                Status = ndisMPowerPolicy(Miniport, SystemState, &DeviceState, FALSE);

                //
                //  Is the device already powered off?
                //
                if (STATUS_DEVICE_POWERED_OFF == Status)
                {
                    pirp->IoStatus.Status = STATUS_SUCCESS;
            
                    PoStartNextPowerIrp(pirp);
                    IoCompleteRequest(pirp, 0);
                    Status = STATUS_SUCCESS;
                    break;
                }

                DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
                    ("ndisSetPower: Miniport %p, SystemPowerState[0x%x] DevicePowerState[0x%x]\n", 
                            Miniport, SystemState, DeviceState));

                PowerState.DeviceState = DeviceState;

                if (SystemState > PowerSystemWorking)
                {
                    NdisResetEvent(&Miniport->OpenReadyEvent);

                    //
                    // if system is going to sleep mode, then notify protocols and
                    // request a WAIT_WAKE IRP
                    //
                    
                    //
                    //  Notify the transports of the impending state transition.
                    //  There is nothing we can do if transports fail this
                    //  Note: for all practical purposes there is no need to map
                    //  SytemState to device state here
                    //

                    if (SystemState > PowerSystemSleeping3)
                        NdisDeviceState = PowerSystemSleeping3;
                    else
                        NdisDeviceState = SystemState;

                    ndisNotifyDevicePowerStateChange(Miniport, NdisDeviceState);
                    
                    NdisStatus = ndisPnPNotifyAllTransports(Miniport,
                                                            NetEventSetPower,
                                                            &NdisDeviceState,
                                                            sizeof(SystemState));

                    //
                    // protocols can't fail going to a sleeping state
                    //
                    ASSERT(NDIS_STATUS_SUCCESS == NdisStatus);

                    MiniportReferencePackage();
                    //
                    //  Swap the handlers.
                    //
                    NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Miniport, &OldIrql);
                    
                    ndisMSwapOpenHandlers(Miniport,
                                          NDIS_STATUS_ADAPTER_NOT_READY,
                                          fMINIPORT_STATE_PM_STOPPED);
                    
                    NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);
                    MiniportDereferencePackage();

                    //
                    //  What type of miniport was this?
                    //
                    if (MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_DEVICE_POWER_ENABLE))
                    {

                        NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Miniport, &OldIrql);
                        if (Miniport->pIrpWaitWake != NULL)
                        {
                            MINIPORT_PNP_CLEAR_FLAG(Miniport, fMINIPORT_SEND_WAIT_WAKE);
                        }
                        NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);

                        //
                        //  Is wake-up enabled?
                        //
                        if (MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_SEND_WAIT_WAKE))
                        {
                            MINIPORT_PNP_CLEAR_FLAG(Miniport, fMINIPORT_SEND_WAIT_WAKE);
                        
                            DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
                                ("ndisSetPower: Miniport %p, Creating a wake irp for the device\n", Miniport));

                            //
                            // reuquest a power irp for wake notification
                            //
                            PowerState.SystemState = Miniport->WaitWakeSystemState;
                            Status = PoRequestPowerIrp(Miniport->PhysicalDeviceObject,
                                                       IRP_MN_WAIT_WAKE,
                                                       PowerState,
                                                       ndisWaitWakeComplete,
                                                       Miniport,
                                                       &Miniport->pIrpWaitWake);
                                        
                            DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
                                ("ndisSetPower: Miniport %p, WaiteWakeIrp %p\n",
                                Miniport, Miniport->pIrpWaitWake));
                        }
                    }
                }
                else
                {
                    NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Miniport, &OldIrql);
                    pIrpWaitWake = Miniport->pIrpWaitWake;
                    NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);
                    
                    //
                    // if we are transitioning to PowerSystemWorking or just asserting
                    // it to cancel a query power, we will notify the protocols when
                    // we get the device power IRP
                    //

                    //
                    //  If there is a wait-wake irp outstanding then we need to cancel it.
                    //
                    if (pIrpWaitWake)
                    {
                        if (IoCancelIrp(pIrpWaitWake))
                        {
                            DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
                                ("ndisSetPower: Miniport %p, Successfully canceled wake irp\n", Miniport));
                        }
                    }

                    //
                    // Send the S0 irp down the stack first. When it completes, send the D0 irp. This
                    // allows the power manager to resume faster while the slow network initialization
                    // takes place in the background.
                    //
                    IoCopyCurrentIrpStackLocationToNext(pirp);
                    IoSetCompletionRoutine(pirp,
                                           ndisSetSystemPowerOnComplete,
                                           Miniport,
                                           TRUE,
                                           TRUE,
                                           TRUE);
                    IoMarkIrpPending(pirp);
                    PoStartNextPowerIrp(pirp);
                    PoCallDriver(Miniport->NextDeviceObject, pirp);
                    Status = STATUS_PENDING;
                    break;
                }
            }
            
            //
            // no matter what was the outcome of trying to set a WAIT_WAKE IRP
            // we still have to set the device state appropiately
            // 
            PowerState.DeviceState = DeviceState;
            
            //
            //  Save the device object with the system irp to use in the
            //  completion routine.
            //
            pirpSpN = IoGetNextIrpStackLocation(pirp);
            pirpSpN->DeviceObject = Miniport->DeviceObject;
            IoMarkIrpPending(pirp);
            PoStartNextPowerIrp(pirp);

            //
            //  Let the completion routine take care of everything.
            //
            Status = PoRequestPowerIrp(Miniport->PhysicalDeviceObject,
                                       IRP_MN_SET_POWER,
                                       PowerState,
                                       ndisSetSystemPowerComplete,
                                       pirp,
                                       NULL);
            if (STATUS_PENDING != Status)
            {
                IoStatus.Status = Status;
                IoStatus.Information = 0;

                ndisSetSystemPowerComplete(Miniport->PhysicalDeviceObject,
                                           IRP_MN_SET_POWER,
                                           PowerState,
                                           pirp,
                                           &IoStatus);
            }
            Status = STATUS_PENDING;
            break;

        case DevicePowerState:

            //
            //  Get the device state.
            //
            DeviceState = pirpSp->Parameters.Power.State.DeviceState;

            DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
                ("ndisSetPower: Miniport %p, DeviceState[0x%x]\n", Miniport, DeviceState));

            //
            //  What state is the device going to?
            //
            switch (DeviceState)
            {
                case PowerDeviceD0:
                    //
                    //  We need to pass this IRP down to the pdo so that
                    //  it can power on.
                    //
                    IoCopyCurrentIrpStackLocationToNext(pirp);

                    IoSetCompletionRoutine(pirp,
                                           ndisSetDevicePowerOnComplete,
                                           Miniport,
                                           TRUE,
                                           TRUE,
                                           TRUE);

                    DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
                        ("ndisSetPower: Miniport %p, Power up the bus driver.\n", Miniport));

                    //
                    //  Mark the IRP as pending and send it down the stack.
                    //
                    IoMarkIrpPending(pirp);
                    PoStartNextPowerIrp(pirp);
                    PoCallDriver(Miniport->NextDeviceObject, pirp);
                    Status = STATUS_PENDING;
                    break;

                case PowerDeviceD1:
                case PowerDeviceD2:
                case PowerDeviceD3:

                    if (ndisIsMiniportStarted(Miniport) && 
                        (Miniport->PnPDeviceState == NdisPnPDeviceStarted))
                    {
                        //
                        // if the device state setting is not the result of going to
                        // a sleeping system state, (such as media disconnect case)
                        // then notify protocols, etc.
                        //

                        if (!MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_SYSTEM_SLEEPING))
                        {
                            NdisResetEvent(&Miniport->OpenReadyEvent);
                    
                            ndisNotifyDevicePowerStateChange(Miniport, DeviceState);
                            //
                            //  Notify the transports of the impending state transition.
                            //
                            NdisStatus = ndisPnPNotifyAllTransports(Miniport,
                                                                    NetEventSetPower,
                                                                    &DeviceState,
                                                                    sizeof(DeviceState));
                    
                            ASSERT(NDIS_STATUS_SUCCESS == NdisStatus);

                            //
                            //  Swap the handlers.
                            //
                            NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Miniport, &OldIrql);
                            
                            ndisMSwapOpenHandlers(Miniport,
                                                  NDIS_STATUS_ADAPTER_NOT_READY,
                                                  fMINIPORT_STATE_PM_STOPPED);
                            
                            NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);
                        }
                            
                        //
                        //  What type of miniport was this?
                        //
                        if (MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_DEVICE_POWER_ENABLE))
                        {
                            BOOLEAN Canceled;
                            
                            if (!MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_SYSTEM_SLEEPING))
                            {
                                NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Miniport, &OldIrql);
                                if (Miniport->pIrpWaitWake != NULL)
                                {
                                    MINIPORT_PNP_CLEAR_FLAG(Miniport, fMINIPORT_SEND_WAIT_WAKE);
                                }
                                NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);

                                //
                                //  Is wake-up enabled?
                                //
                                if (MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_SEND_WAIT_WAKE))
                                {
                                    MINIPORT_PNP_CLEAR_FLAG(Miniport, fMINIPORT_SEND_WAIT_WAKE);
                                
                                    DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
                                        ("ndisSetPower: Miniport %p, Creating a wake irp for the device\n", Miniport));

                                    //
                                    // reuquest a power irp for wake notification
                                    //
                                    PowerState.SystemState = Miniport->WaitWakeSystemState;
                                    
                                    Status = PoRequestPowerIrp(Miniport->PhysicalDeviceObject,
                                                               IRP_MN_WAIT_WAKE,
                                                               PowerState,
                                                               ndisWaitWakeComplete,
                                                               Miniport,
                                                               &Miniport->pIrpWaitWake);
                                                
                                    DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
                                        ("ndisSetPower: Miniport %p, WaiteWakeIrp %p\n",
                                            Miniport, Miniport->pIrpWaitWake));
                                }
                            }

                            //
                            // disable the interface
                            //
                            if (Miniport->SymbolicLinkName.Buffer != NULL)
                            {
                                IoSetDeviceInterfaceState(&Miniport->SymbolicLinkName, FALSE);
                            }
                            
                            //
                            //  Set the miniport device state.
                            //
                            NdisStatus = ndisQuerySetMiniportDeviceState(Miniport,
                                                                         DeviceState,
                                                                         OID_PNP_SET_POWER,
                                                                         TRUE);
                            if (NDIS_STATUS_SUCCESS != NdisStatus)
                            {
                                DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_ERR,
                                    ("ndisSetPower: Miniport %p, Failed to power the device down\n", Miniport));
                                
                                if (Miniport->SymbolicLinkName.Buffer != NULL)
                                {
                                    IoSetDeviceInterfaceState(&Miniport->SymbolicLinkName, TRUE);
                                }
                
                                pirp->IoStatus.Status = NdisStatus;
                        
                                PoStartNextPowerIrp(pirp);
                                IoCompleteRequest(pirp, 0);
                                Status = NdisStatus;
                                break;
                            }

                            //
                            //  Cancel the wake-up timer.
                            //
                            NdisCancelTimer(&Miniport->WakeUpDpcTimer, &Canceled);
                            if (!Canceled)
                            {
                                NdisStallExecution(NDIS_MINIPORT_WAKEUP_TIMEOUT * 1000);
                            }
                        }
                        else
                        {
                            if ((Miniport->DriverHandle->Flags & fMINIBLOCK_INTERMEDIATE_DRIVER) == 0)
                            {
                                DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
                                    ("ndisSetPower: Miniport %p, Halt the miniport\n", Miniport));

                                if (!MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_DEVICE_FAILED))
                                {
                                    //
                                    //  Halt the legacy miniport.
                                    //
                                    ndisPmHaltMiniport(Miniport);
                                }
                            }
                        }
                    }
                    
                    DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
                        ("ndisSetPower: Miniport %p, Notify the bus driver of the low power state\n", Miniport));

                    //
                    //  We need to pass this IRP down to the pdo so that
                    //  it can power down.
                    //
                    IoCopyCurrentIrpStackLocationToNext(pirp);

                    IoSetCompletionRoutine(pirp,
                                           ndisSetDevicePowerDownComplete,
                                           Miniport,
                                           TRUE,
                                           TRUE,
                                           TRUE);

                    IoMarkIrpPending(pirp);
                    PoStartNextPowerIrp(pirp);
                    PoCallDriver(Miniport->NextDeviceObject, pirp);
                    Status = STATUS_PENDING;
                    break;
            }

            //
            //  Done with processing the device set power state.
            //
            break;
    }
    
    PnPDereferencePackage();

    DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
        ("<==ndisSetPower: Miniport %p, Status %lx\n", Miniport, Status));

    return(Status);
}


NTSTATUS
ndisPowerDispatch(
    IN  PDEVICE_OBJECT          pDeviceObject,
    IN  PIRP                    pirp
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PIO_STACK_LOCATION      pirpSp;
    NTSTATUS                Status;
    PNDIS_MINIPORT_BLOCK    Miniport;
    PDEVICE_OBJECT          NextDeviceObject;
    PIO_STACK_LOCATION      pirpSpN;

    DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
        ("==>ndisPowerDispatch: DeviceObject %p, Irp %p\n", pDeviceObject, pirp));

    PnPReferencePackage();

    //
    //  Get a pointer to the adapter block and miniport block then determine
    //  which one we should use.
    //
    Miniport = (PNDIS_MINIPORT_BLOCK)((PNDIS_WRAPPER_CONTEXT)pDeviceObject->DeviceExtension + 1);
    
    if (Miniport->Signature != (PVOID)MINIPORT_DEVICE_MAGIC_VALUE)
    {
        DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
            ("ndisPowerDispatch: DeviceObject %p, Irp %p, Device extension is not a miniport.\n", pDeviceObject, pirp));
        //
        //  Fail the invalid request.
        //
        pirp->IoStatus.Status = Status = STATUS_INVALID_DEVICE_REQUEST;
        PoStartNextPowerIrp(pirp);
        IoCompleteRequest(pirp, 0);
        goto Done;
    }
    
    //
    //  Get a pointer to the next DeviceObject.
    //
    NextDeviceObject = Miniport->NextDeviceObject;

    DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
        ("ndisPowerDispatch: Miniport %p\n", Miniport));

    //
    //  Get the stack parameters for this IRP.
    //
    pirpSp = IoGetCurrentIrpStackLocation(pirp);

    switch (pirpSp->MinorFunction)
    {
        //
        // power management stuff
        //
        case IRP_MN_POWER_SEQUENCE:

            DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
                ("ndisPowerDispatch: Miniport %p, Processing IRP_MN_POWER_SEQUENCE\n", Miniport));
                
            PoStartNextPowerIrp(pirp);
            
            //
            //  Generic routine that will pass the IRP to the next device
            //  object in the layer that wants to process it.
            //
            IoCopyCurrentIrpStackLocationToNext(pirp);
            Status = ndisPassIrpDownTheStack(pirp, NextDeviceObject);
            pirp->IoStatus.Status = Status;
            IoCompleteRequest(pirp, 0);
            break;

        case IRP_MN_WAIT_WAKE:

            DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
                ("ndisPowerDispatch: Miniport %p, Processing IRP_MN_WAIT_WAKE\n", Miniport));

            //
            //  Fill in the wake information.
            //
            pirpSp->Parameters.WaitWake.PowerState = Miniport->WaitWakeSystemState;
            IoCopyCurrentIrpStackLocationToNext(pirp);
            PoStartNextPowerIrp(pirp);
            Status = PoCallDriver(NextDeviceObject, pirp);
            break;

        case IRP_MN_QUERY_POWER:

            DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
                ("ndisPowerDispatch: Miniport %p, Processing IRP_MN_QUERY_POWER\n", Miniport));

            Status = ndisQueryPower(pirp, pirpSp, Miniport);
            break;

        case IRP_MN_SET_POWER:

            DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
                ("ndisPowerDispatch: Miniport %p, Processing IRP_MN_SET_POWER\n", Miniport));

            Status = ndisSetPower(pirp, pirpSp, Miniport);
            break;

        default:
            DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
                ("ndisPowerDispatch: Miniport %p, Processing minor function: %lx\n",
                Miniport, pirpSp->MinorFunction));

            //
            // send the IRP down
            //
            PoStartNextPowerIrp(pirp);
            IoSkipCurrentIrpStackLocation(pirp);
            Status = PoCallDriver(NextDeviceObject, pirp);
            break;          
    }

Done:
    PnPDereferencePackage();
    
    DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
        ("<==ndisPowerDispatch: Miniport %p, Status 0x%x\n", Miniport, Status));

    return(Status);
}


NTSTATUS
FASTCALL
ndisMShutdownMiniport(
    IN  PNDIS_MINIPORT_BLOCK    Miniport
    )

/*++

Routine Description:

    The "shutdown handler" for the SHUTDOWN Irp.  Will call the Ndis
    shutdown routine, if one is registered.

Arguments:

    DeviceObject - The adapter's device object.
    Irp - The IRP.

Return Value:

    Always STATUS_SUCCESS.

--*/

{
    PDEVICE_OBJECT          DeviceObject = Miniport->DeviceObject;
    PNDIS_WRAPPER_CONTEXT   WrapperContext =  (PNDIS_WRAPPER_CONTEXT)DeviceObject->DeviceExtension;
    KIRQL                   OldIrql;

    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
            ("==>ndisMShutdownMiniport: Miniport %p\n", Miniport));

    NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Miniport, &OldIrql);

    //
    //  Mark the miniport as halting and NOT using normal interrupts.
    //
    MINIPORT_SET_FLAG(Miniport, fMINIPORT_PM_HALTING);
    MINIPORT_PNP_SET_FLAG(Miniport, fMINIPORT_SHUTTING_DOWN);
    MINIPORT_CLEAR_FLAG(Miniport, fMINIPORT_NORMAL_INTERRUPTS);

    NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);

    if ((WrapperContext->ShutdownHandler != NULL) &&
        (MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_NO_SHUTDOWN) == 0))
    {
        //
        // Call the shutdown routine.
        //
        if (WrapperContext->ShutdownHandler != NULL)
        {
            WrapperContext->ShutdownHandler(WrapperContext->ShutdownContext);
            MINIPORT_PNP_SET_FLAG(Miniport, fMINIPORT_SHUT_DOWN);
        }
    }

    DBGPRINT_RAW(DBG_COMP_INIT, DBG_LEVEL_INFO,
            ("<==ndisMShutdownMiniport: Miniport %p\n", Miniport));

    return STATUS_SUCCESS;
}


NTSTATUS
ndisMPowerPolicy(
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  SYSTEM_POWER_STATE      SystemState,
    IN  PDEVICE_POWER_STATE     pDeviceState,
    IN  BOOLEAN                 fIsQuery
    )
/*++

Routine Description:

    This routine will determine if the miniport should go to the given device state.

Arguments:      

    Miniport    -   Pointer to the miniport block
    SystemState -   State the system wants to go to.

Return Value:

--*/
{
    DEVICE_POWER_STATE              DeviceStateForSystemState, MinDeviceWakeup = PowerDeviceUnspecified;
    NTSTATUS                        Status = STATUS_SUCCESS;
    DEVICE_POWER_STATE              NewDeviceState = PowerDeviceD3;
    PNDIS_PM_WAKE_UP_CAPABILITIES   pWakeCaps;
    NDIS_STATUS                     NdisStatus;
    ULONG                           WakeEnable;
    PIRP                            pIrpWaitWake;
    KIRQL                           OldIrql;

    DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
        ("==>ndisMPowerPolicy: Miniport %p, SystemState %lx\n", Miniport, SystemState));


    if (SystemState >= PowerSystemShutdown)
    {
        //
        // if this is a shutdown request, set device to D3 and return
        //
        DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
            ("ndisMPowerPolicy: Miniport %p, shutting down\n", Miniport));

        *pDeviceState = PowerDeviceD3;
        DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
            ("<==ndisMPowerPolicy: Miniport %p\n", Miniport));
        return(STATUS_SUCCESS);
    }
    
    //
    //  If the system wants to transition to working then we are going to D0. 
    //
    if (SystemState == PowerSystemWorking)
    {
        DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
            ("ndisMPowerPolicy: Miniport %p, Wakeing up the device\n", Miniport));
            
        if (!fIsQuery)
        {
            MINIPORT_PNP_CLEAR_FLAG(Miniport, fMINIPORT_SYSTEM_SLEEPING);
        }

        *pDeviceState = PowerDeviceD0;
        DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
            ("<==ndisMPowerPolicy: Miniport %p\n", Miniport));
        return(STATUS_SUCCESS);
    }
    
    if (!fIsQuery)
    {
        //
        // tag the miniport so when we get the device power IRP, we
        // know we have already been here, taken care of protocols, etc.
        //
        MINIPORT_PNP_SET_FLAG(Miniport, fMINIPORT_SYSTEM_SLEEPING);
    }
    
    //
    //  if this is a legacy miniport or power-disabled miniport then throw it in D3
    //  do the same thing for IM miniports that have not been initialized yet 
    //
    if ((!MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_DEVICE_POWER_ENABLE)) ||
        (!(ndisIsMiniportStarted(Miniport) && (Miniport->PnPDeviceState == NdisPnPDeviceStarted))))
    {
        DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
            ("ndisMPowerPolicy: Miniport %p, Place legacy or PM disabled device in D3\n", Miniport));

        *pDeviceState = PowerDeviceD3;
        DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
            ("<==ndisMPowerPolicy: Miniport %p\n", Miniport));
        return(STATUS_SUCCESS);
    }

    //
    //  First check for the case where the netcard is already asleep due to a 
    //  media disconnect.
    //
    
    NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Miniport, &OldIrql);
    pIrpWaitWake = Miniport->pIrpWaitWake;
    NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);

    if ((Miniport->CurrentDevicePowerState > PowerDeviceD0) &&
        (pIrpWaitWake != NULL))
    {
        ///
        //  Miniport is in a lower power state than D0 and there is a wake irp pending in
        //  the bus driver. This is a pretty good indication that the cable was pulled.
        //  We are not going to enable any wake-up method seeing as the cable has been disconnect.
        //  but if the user does not want to wakeup the machine as a result of a cable
        // reconnect, cancel any pending wait-wake IRP
        ///

        if (!fIsQuery && ((!MINIPORT_PNP_TEST_FLAG (Miniport, fMINIPORT_DEVICE_POWER_WAKE_ENABLE)) ||
                         (Miniport->PnPCapabilities & NDIS_DEVICE_DISABLE_WAKE_ON_RECONNECT)))
        {
            if (IoCancelIrp(pIrpWaitWake))
            {
                DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
                    ("ndisMPowerPolicy: Miniport %p, Successfully canceled media connect wake irp\n", Miniport));
            }
        }
        DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
            ("<==ndisMPowerPolicy: Miniport %p\n", Miniport));
        return(STATUS_DEVICE_POWERED_OFF);
    }

    do
    {
        //
        //  Is system wake-up enabled in the policy?
        //  if wake-up is not enabled then we simply power off.
        //
        if (!MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_DEVICE_POWER_WAKE_ENABLE))
        {
            DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
                ("ndisMPowerPolicy: Miniport %p, Device power wake is not enabled (%u)\n",
                    Miniport, MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_DEVICE_POWER_WAKE_ENABLE)));

            break;
        }


        //
        //  This is the -lightest- state the device can go to for the requested
        //  system state. 
        //
        DeviceStateForSystemState = Miniport->DeviceCaps.DeviceState[SystemState];

        //
        //  Check to see if we are going below SystemSleeping3
        //
        //
        //
        // if we are going to S4 or deeper and device can not wake up the system from that state
        // just do it
        //
        if ((SystemState >= PowerSystemHibernate) && 
            ((SystemState > Miniport->DeviceCaps.SystemWake) || (DeviceStateForSystemState > Miniport->DeviceCaps.DeviceWake)))
        {

            DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
                ("ndisMPowerPolicy: Miniport %p, System is either entering hibernate or shutting down.\n", Miniport));

            //
            //  We succeed this call.
            //
            break;
        } 

        //
        //  Get a nice pointer to the wake-up capabilities.
        //
        pWakeCaps = &Miniport->PMCapabilities.WakeUpCapabilities;

        if ((NDIS_PNP_WAKE_UP_MAGIC_PACKET == (Miniport->WakeUpEnable & NDIS_PNP_WAKE_UP_MAGIC_PACKET)) &&
            (PowerDeviceUnspecified != pWakeCaps->MinMagicPacketWakeUp))
        {
            MinDeviceWakeup = pWakeCaps->MinMagicPacketWakeUp;
        }

        if ((NDIS_PNP_WAKE_UP_PATTERN_MATCH == (Miniport->WakeUpEnable & NDIS_PNP_WAKE_UP_PATTERN_MATCH)) &&
            (PowerDeviceUnspecified != pWakeCaps->MinPatternWakeUp))
        {
            if ((MinDeviceWakeup == PowerDeviceUnspecified) || 
                (MinDeviceWakeup > pWakeCaps->MinPatternWakeUp)) 
            {
                    MinDeviceWakeup = pWakeCaps->MinPatternWakeUp;
            }
        }

        //
        // if both MagicPacket and pattern match are NOT enabled (or the system can't do either)
        // then we may as well go to D3.
        //
        if (MinDeviceWakeup == PowerDeviceUnspecified)
        {
            DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
                ("ndisMPowerPolicy: Miniport %p, MagicPacket and pattern match are not enabled.\n", Miniport));

            break;
        }

        //
        // from this point on, we try to go to power state that we can wake up the system from
        //

        //
        // make sure we don't go too deep
        //

        if (MinDeviceWakeup > Miniport->DeviceCaps.DeviceWake)
        {
            MinDeviceWakeup = Miniport->DeviceCaps.DeviceWake;
        }
        
        //
        //  If the system state requested is lower than the minimum required to wake up the system 
        //  or the corresponding device state is deeper than the lowest device state to wake 
        //  up the system then we
        //  fail this call. Note that we also set the device state to D3. Since
        //  we are not going to be able to support wake-up then we power off.
        //  The query power will look at the failure code and return that to the
        //  system. The set power will ignore the failure code and set the device
        //  into D3.
        //
        if ((SystemState > Miniport->DeviceCaps.SystemWake) ||
            (DeviceStateForSystemState > MinDeviceWakeup) ||
            (DeviceStateForSystemState == PowerDeviceUnspecified))
        {
            DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_ERR,
                ("ndisMPowerPolicy: Miniport %p, Requested system state is lower than the minimum wake-up system state\n", Miniport));

            Status = STATUS_UNSUCCESSFUL;
            break;
        }

        //
        // starting from DeviceWake and up to DeviceState[SystemState], find a
        // suitable device state
        //
        switch (MinDeviceWakeup)
        {
          case PowerDeviceD3:
            if (Miniport->DeviceCaps.WakeFromD3)
            {
                NewDeviceState =  PowerDeviceD3;
                break;
            }
          case PowerDeviceD2:
            if (Miniport->DeviceCaps.DeviceD2 && Miniport->DeviceCaps.WakeFromD2)
            {
              NewDeviceState =  PowerDeviceD2;
              break;
            }
          case PowerDeviceD1:
            if (Miniport->DeviceCaps.DeviceD1 && Miniport->DeviceCaps.WakeFromD1)
            {
              NewDeviceState =  PowerDeviceD1;
              break;
            }
          case PowerDeviceD0:
            if (Miniport->DeviceCaps.WakeFromD0)
            {
              NewDeviceState =  PowerDeviceD0;
              break;
            }
          default:
            Status = STATUS_UNSUCCESSFUL;
            DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_ERR,
                ("ndisMPowerPolicy: Miniport %p, couldn't find any wake-able DeviceState 0x%x\n", Miniport));
            break;

        }


        //
        // ok, we started with deepest state (based on what device said can do)
        // and went up. make sure we didn't go too far up. i.e. the statem state
        // we are going to can maintain the device in desired power state
        //
        if ((Status == NDIS_STATUS_SUCCESS) &&
            (DeviceStateForSystemState > NewDeviceState))
        {
            Status = STATUS_UNSUCCESSFUL;
            DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_ERR,
                ("ndisMPowerPolicy: Miniport %p, couldn't find any wake-able DeviceState 0x%x\n", Miniport));
        
        }

        //
        //  If this is for the set power then we need to enable wake-up on the miniport.
        //
        if (!fIsQuery)
        {
            //
            //  We need to send a request to the miniport to enable the correct wake-up types NOT 
            //  including the link change.
            //
            WakeEnable = Miniport->WakeUpEnable & ~NDIS_PNP_WAKE_UP_LINK_CHANGE;
            
            if (Miniport->PnPCapabilities & NDIS_DEVICE_DISABLE_WAKE_ON_PATTERN_MATCH)
            {
                WakeEnable &= ~NDIS_PNP_WAKE_UP_PATTERN_MATCH;
            }

            if (Miniport->PnPCapabilities & NDIS_DEVICE_DISABLE_WAKE_ON_MAGIC_PACKET)
            {
                WakeEnable &= ~NDIS_PNP_WAKE_UP_MAGIC_PACKET;
            }
    
            NdisStatus = ndisQuerySetMiniportDeviceState(Miniport,
                                                         WakeEnable,
                                                         OID_PNP_ENABLE_WAKE_UP,
                                                         TRUE);

            if (NDIS_STATUS_SUCCESS == NdisStatus)
            {
                MINIPORT_PNP_SET_FLAG(Miniport, fMINIPORT_SEND_WAIT_WAKE);
            }
            else
            {
                DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_ERR,
                    ("ndisMPowerPolicy: Miniport %p, Unable to enable the following wake-up methods 0x%x\n", Miniport, WakeEnable));
    
                //
                //  Since we can't enable the wake methods we may as well go to D3.
                //
                NewDeviceState = PowerDeviceD3;
                break;
            }
        }

        //
        //  Save the device state that we should go to.
        //
        *pDeviceState = NewDeviceState;
    
        DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
            ("ndisMPowerPolicy: Miniport %p, SystemState 0x%x, DeviceState 0x%x\n", Miniport, SystemState, *pDeviceState));
    
        DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
            ("<==ndisMPowerPolicy: Miniport %p\n", Miniport));
    
        return(Status);

    } while (FALSE);


    //
    //  If this is not a query then we need to cancel wake-up on the miniport.
    //
    if (!fIsQuery && MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_DEVICE_POWER_WAKE_ENABLE))
    {
        DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
            ("ndisMPowerPolicy: Miniport %p, Disabling wake-up on the miniport\n", Miniport));

        WakeEnable = 0;
    
        ndisQuerySetMiniportDeviceState(Miniport,
                                        WakeEnable,
                                        OID_PNP_ENABLE_WAKE_UP,
                                        TRUE);
    }

    //
    //  Save the device state that we should go to.
    //
    *pDeviceState = NewDeviceState;

    DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
        ("ndisMPowerPolicy: Miniport %p, SystemState 0x%x, DeviceState 0x%x\n", Miniport, SystemState, *pDeviceState));

    DBGPRINT_RAW(DBG_COMP_PM, DBG_LEVEL_INFO,
        ("<==ndisMPowerPolicy: Miniport %p\n", Miniport));

    return(Status);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ndis\sys\ndisnt.h ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation

Module Name:

    ndisnt.h

Abstract:

    Windows NT Specific macros

Author:


Environment:

    Kernel mode, FSD

Revision History:

    Nov-95  Jameel Hyder    Split up from a monolithic file
--*/

#define Increment(a,b) InterlockedIncrement(a)
#define Decrement(a,b) InterlockedDecrement(a)

#define CURRENT_THREAD                          PsGetCurrentThread()
#define CURRENT_PROCESSOR                       KeGetCurrentProcessorNumber()

#define CopyMemory(Destination,Source,Length)   RtlCopyMemory(Destination,Source,Length)
#define MoveMemory(Destination,Source,Length)   RtlMoveMemory(Destination,Source,Length)
#define ZeroMemory(Destination,Length)          RtlZeroMemory(Destination,Length)

#define INITIALIZE_SPIN_LOCK(_L_)               KeInitializeSpinLock(_L_)
#define ACQUIRE_SPIN_LOCK(_SpinLock, _pOldIrql) ExAcquireSpinLock(_SpinLock, _pOldIrql)
#define RELEASE_SPIN_LOCK(_SpinLock, _OldIrql)  ExReleaseSpinLock(_SpinLock, _OldIrql)

#define ACQUIRE_SPIN_LOCK_DPC(_SpinLock)                                    \
    {                                                                       \
        ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);                       \
        ExAcquireSpinLockAtDpcLevel(_SpinLock);                             \
    }

#define RELEASE_SPIN_LOCK_DPC(_SpinLock)                                    \
    {                                                                       \
        ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);                       \
        ExReleaseSpinLockFromDpcLevel(_SpinLock);                           \
    }


#define NDIS_ACQUIRE_SPIN_LOCK(_SpinLock, _pOldIrql) ExAcquireSpinLock(&(_SpinLock)->SpinLock, _pOldIrql)
#define NDIS_RELEASE_SPIN_LOCK(_SpinLock, _OldIrql)  ExReleaseSpinLock(&(_SpinLock)->SpinLock, _OldIrql)


#define NDIS_ACQUIRE_SPIN_LOCK_DPC(_SpinLock)                               \
    {                                                                       \
        ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);                       \
        ExAcquireSpinLockAtDpcLevel(&(_SpinLock)->SpinLock);                \
    }

#define NDIS_RELEASE_SPIN_LOCK_DPC(_SpinLock)                               \
    {                                                                       \
        ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);                       \
        ExReleaseSpinLockFromDpcLevel(&(_SpinLock)->SpinLock);              \
    }



#define SET_LOCK_DBG(_M)                                                    \
    {                                                                       \
        (_M)->LockDbg = (MODULE_NUMBER + __LINE__);                         \
    }

#define SET_LOCK_DBGX(_M)                                                   \
    {                                                                       \
        (_M)->LockDbgX = (MODULE_NUMBER + __LINE__);                        \
        (_M)->LockThread = CURRENT_THREAD;                                  \
    }

#define CLEAR_LOCK_DBG(_M)                                                  \
    {                                                                       \
        (_M)->LockDbg = 0;                                                  \
    }

#define CLEAR_LOCK_DBGX(_M)                                                 \
    {                                                                       \
        (_M)->LockDbgX = 0;                                                 \
        (_M)->LockThread = NULL;                                            \
    }

#define NDIS_ACQUIRE_COMMON_SPIN_LOCK(_M, _pS, _pIrql, _pT)                 \
{                                                                           \
    ExAcquireSpinLock(_pS, _pIrql);                                         \
    ASSERT((_pT) == NULL);                                                  \
    (_pT) = CURRENT_THREAD;                                                 \
    SET_LOCK_DBG(_M);                                                       \
}

#define NDIS_RELEASE_COMMON_SPIN_LOCK(_M, _pS, _Irql, _pT)                  \
{                                                                           \
    ASSERT(_pT ==  CURRENT_THREAD);                                         \
    _pT =  NULL;                                                            \
    CLEAR_LOCK_DBG(_M);                                                     \
    ExReleaseSpinLock(_pS, _Irql);                                          \
}

#define NDIS_ACQUIRE_COMMON_SPIN_LOCK_DPC(_M, _pS, _pT)                     \
{                                                                           \
    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);                           \
                                                                            \
    ExAcquireSpinLockAtDpcLevel(_pS);                                       \
    ASSERT((_pT) == NULL);                                                  \
    (_pT) = CURRENT_THREAD;                                                 \
    SET_LOCK_DBG(_M);                                                       \
}

#define NDIS_RELEASE_COMMON_SPIN_LOCK_DPC(_M, _pS, _pT)                     \
{                                                                           \
    ASSERT(KeGetCurrentIrql() == DISPATCH_LEVEL);                           \
                                                                            \
    ASSERT(_pT ==  CURRENT_THREAD);                                         \
    _pT =  NULL;                                                            \
    ExReleaseSpinLockFromDpcLevel(_pS);                                     \
    CLEAR_LOCK_DBG(_M);                                                     \
}

#define NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(_M, _pIrql)                         \
    NDIS_ACQUIRE_COMMON_SPIN_LOCK((_M), &(_M)->Lock, (_pIrql), (_M)->MiniportThread)

#define NDIS_RELEASE_MINIPORT_SPIN_LOCK(_M, _Irql)                          \
    NDIS_RELEASE_COMMON_SPIN_LOCK((_M), &(_M)->Lock, (_Irql), (_M)->MiniportThread)

#define NDIS_ACQUIRE_MINIPORT_SPIN_LOCK_DPC(_M)                             \
    NDIS_ACQUIRE_COMMON_SPIN_LOCK_DPC((_M), &(_M)->Lock, (_M)->MiniportThread)

#define NDIS_RELEASE_MINIPORT_SPIN_LOCK_DPC(_M)                             \
    NDIS_RELEASE_COMMON_SPIN_LOCK_DPC(_M, &(_M)->Lock, (_M)->MiniportThread)

//
// Some macros for platform independence
//
#define NDIS_INTERNAL_STALL(_N_)                                            \
    {                                                                       \
        volatile UINT   _cnt;                                               \
        for (_cnt = 0; _cnt < _N_; _cnt++)                                  \
            NOTHING;                                                        \
    }

#define LOCK_MINIPORT(_M, _L)                                               \
    {                                                                       \
        (_L) = 0;                                                           \
        if ((_M)->LockAcquired == 0)                                        \
        {                                                                   \
            (_M)->LockAcquired = 0x01;                                      \
            SET_LOCK_DBGX(_M);                                              \
            (_L) = 0x01;                                                    \
        }                                                                   \
    }

#define BLOCK_LOCK_MINIPORT_DPC_L(_M)                                       \
    {                                                                       \
        do                                                                  \
        {                                                                   \
            if ((_M)->LockAcquired == 0)                                    \
            {                                                               \
                (_M)->LockAcquired = 0x01;                                  \
                SET_LOCK_DBGX(_M);                                          \
                break;                                                      \
            }                                                               \
            else                                                            \
            {                                                               \
                NDIS_RELEASE_MINIPORT_SPIN_LOCK_DPC(_M);                    \
                NDIS_INTERNAL_STALL(50);                                    \
                NDIS_ACQUIRE_MINIPORT_SPIN_LOCK_DPC(_M);                    \
            }                                                               \
        } while (TRUE);                                                     \
    }

#define BLOCK_LOCK_MINIPORT_LOCKED(_M, _I)                                  \
    {                                                                       \
        do                                                                  \
        {                                                                   \
            NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(_M, &(_I));                     \
            if ((_M)->LockAcquired == 0)                                    \
            {                                                               \
                (_M)->LockAcquired = 0x01;                                  \
                SET_LOCK_DBGX(_M);                                          \
                break;                                                      \
            }                                                               \
            NDIS_RELEASE_MINIPORT_SPIN_LOCK(_M, _I);                        \
            NDIS_INTERNAL_STALL(50);                                        \
        } while (TRUE);                                                     \
    }
    
#define UNLOCK_MINIPORT(_M, _L)                                             \
{                                                                           \
    if (_L)                                                                 \
    {                                                                       \
        UNLOCK_MINIPORT_L(_M);                                              \
    }                                                                       \
}


#define UNLOCK_MINIPORT_L(_M)                                               \
{                                                                           \
    ASSERT(MINIPORT_LOCK_ACQUIRED(_M));                                     \
    (_M)->LockAcquired = 0;                                                 \
    CLEAR_LOCK_DBGX(_M);                                                    \
}


#define UNLOCK_MINIPORT_U(_M, _I)                                           \
{                                                                           \
    ASSERT(MINIPORT_LOCK_ACQUIRED(_M));                                     \
    (_M)->LockAcquired = 0;                                                 \
    CLEAR_LOCK_DBGX(_M);                                                    \
                                                                            \
    NDIS_RELEASE_MINIPORT_SPIN_LOCK(_M, _I);                                \
}

#if TRACK_MEMORY

#define ALLOC_FROM_POOL(_Size_, _Tag_)      AllocateM(_Size_,               \
                                                 (MODULE_NUMBER + __LINE__),\
                                                 _Tag_)
#define FREE_POOL(_P_)                      FreeM(_P_)

#else

#define ALLOC_FROM_POOL(_Size_, _Tag_)      ExAllocatePoolWithTag(NonPagedPool, \
                                                                  _Size_,   \
                                                                  _Tag_)
#define FREE_POOL(_P_)                      ExFreePool(_P_)

#endif

#define INITIALIZE_WORK_ITEM(_W, _R, _C)    ExInitializeWorkItem(_W, _R, _C)

#define XQUEUE_WORK_ITEM(_W, _Q)            ExQueueWorkItem(_W, _Q)
#define QUEUE_WORK_ITEM(_W, _Q)             KeInsertQueue(&ndisWorkerQueue, &(_W)->List)

#define CURRENT_IRQL                        KeGetCurrentIrql()
#define RAISE_IRQL_TO_DISPATCH(_pIrql_)     KeRaiseIrql(DISPATCH_LEVEL, _pIrql_)

#define LOWER_IRQL(_OldIrql_, _CurIrql_)                \
{                                                       \
    if (_OldIrql_ != _CurIrql_) KeLowerIrql(_OldIrql_); \
}

#define CURRENT_PROCESSOR                   KeGetCurrentProcessorNumber()

#define INITIALIZE_TIMER(_Timer_)           KeInitializeTimer(_Timer_)
#define INITIALIZE_TIMER_EX(_Timer_,_Type_) KeInitializeTimerEx(_Timer_, _Type_)
#define CANCEL_TIMER(_Timer_)               KeCancelTimer(_Timer_)
#define SET_TIMER(_Timer_, _Time_, _Dpc_)   KeSetTimer(_Timer_, _Time_, _Dpc_)
#define SET_PERIODIC_TIMER(_Timer_, _DueTime_, _PeriodicTime_, _Dpc_)   \
                                            KeSetTimerEx(_Timer_, _DueTime_, _PeriodicTime_, _Dpc_)

#define INITIALIZE_EVENT(_pEvent_)          KeInitializeEvent(_pEvent_, NotificationEvent, FALSE)
#define SET_EVENT(_pEvent_)                 KeSetEvent(_pEvent_, 0, FALSE)
#define RESET_EVENT(_pEvent_)               KeResetEvent(_pEvent_)

#define INITIALIZE_MUTEX(_M_)               KeInitializeMutex(_M_, 0xFFFF)
#define RELEASE_MUTEX(_M_)                  KeReleaseMutex(_M_, FALSE)

#define WAIT_FOR_OBJECT(_O_, _TO_)          KeWaitForSingleObject(_O_,      \
                                                                  Executive,\
                                                                  KernelMode,\
                                                                  FALSE,    \
                                                                  _TO_)     \

#define GET_CURRENT_TICK_IN_SECONDS(_pCurrTick)                             \
    {                                                                       \
        LARGE_INTEGER       _CurrentTick;                                   \
                                                                            \
        KeQueryTickCount(&_CurrentTick);                                    \
        /* Convert to seconds */                                            \
        _CurrentTick.QuadPart = (_CurrentTick.QuadPart*ndisTimeIncrement)/(10*1000*1000);\
        *(_pCurrTick) = _CurrentTick.LowPart;                               \
    }

#define GET_CURRENT_TICK(_pCurrTick)            KeQueryTickCount(_pCurrTick)

#if NOISY_WAIT

#define WAIT_FOR_OBJECT_MSG(_O_, _MSG, _STR)                                \
    {                                                                       \
        NTSTATUS        Status;                                             \
        LARGE_INTEGER   Time;                                               \
                                                                            \
        /* Block 5 seconds */                                               \
        Time.QuadPart = Int32x32To64(5000, -10000);                         \
        do                                                                  \
        {                                                                   \
            Status = KeWaitForSingleObject(_O_,                             \
                                           Executive,                       \
                                           KernelMode,                      \
                                           FALSE,                           \
                                           &Time);                          \
            if (NT_SUCCESS(Status))                                 \
            {                                                               \
                break;                                                      \
            }                                                               \
            DbgPrint(_MSG, _STR);                                           \
        } while (TRUE);                                                     \
    }


#define WAIT_FOR_PROTOCOL(_pProt, _O)                                       \
    {                                                                       \
        WAIT_FOR_OBJECT_MSG(_O,                                             \
                            "NDIS: Waiting for protocol %Z\n",              \
                            &(_pProt)->ProtocolCharacteristics.Name);       \
    }

#define WAIT_FOR_PROTO_MUTEX(_pProt)                                        \
    {                                                                       \
        WAIT_FOR_OBJECT_MSG(&(_pProt)->Mutex,                               \
                            "NDIS: Waiting for protocol %Z\n",              \
                            &(_pProt)->ProtocolCharacteristics.Name);       \
        (_pProt)->MutexOwner = (MODULE_NUMBER + __LINE__);\
    }

#else

#define WAIT_FOR_PROTOCOL(_pProt, _O)                                       \
    {                                                                       \
        WAIT_FOR_OBJECT(_O, NULL);                                          \
    }

#define WAIT_FOR_PROTO_MUTEX(_pProt)                                        \
    {                                                                       \
        WAIT_FOR_OBJECT(&(_pProt)->Mutex, NULL);                            \
        (_pProt)->MutexOwner = (MODULE_NUMBER + __LINE__);                  \
    }

#endif

#define RELEASE_PROT_MUTEX(_pProt)                                          \
    {                                                                       \
            (_pProt)->MutexOwner = 0;                                       \
            RELEASE_MUTEX(&(_pProt)->Mutex);                                \
    }

#define WAIT_FOR_PNP_MUTEX()                                                \
    {                                                                       \
        WAIT_FOR_OBJECT(&ndisPnPMutex, NULL);                               \
        ndisPnPMutexOwner = (MODULE_NUMBER + __LINE__);                     \
    }

#define RELEASE_PNP_MUTEX()                                                 \
    {                                                                       \
        ndisPnPMutexOwner = 0;                                              \
        RELEASE_MUTEX(&ndisPnPMutex);                                       \
    }

#define QUEUE_DPC(_pDpc_)                   KeInsertQueueDpc(_pDpc_, NULL, NULL)
#define INITIALIZE_DPC(_pDpc_, _R_, _C_)    KeInitializeDpc(_pDpc_, _R_, _C_)
#define SET_DPC_IMPORTANCE(_pDpc_)          KeSetImportanceDpc(_pDpc_, LowImportance)
#define SET_PROCESSOR_DPC(_pDpc_, _R_)      if (!ndisSkipProcessorAffinity) \
                                                KeSetTargetProcessorDpc(_pDpc_, _R_)
#define SYNC_WITH_ISR(_O_, _F_, _C_)        KeSynchronizeExecution(_O_,     \
                                            (PKSYNCHRONIZE_ROUTINE)(_F_),   \
                                            _C_)

#define MDL_ADDRESS(_MDL_)                  MmGetSystemAddressForMdl(_MDL_) // Don't use
#define MDL_ADDRESS_SAFE(_MDL_, _PRIORITY_) MmGetSystemAddressForMdlSafe(_MDL_, _PRIORITY_)
#define MDL_SIZE(_MDL_)                     MmGetMdlByteCount(_MDL_)
#define MDL_OFFSET(_MDL_)                   MmGetMdlByteOffset(_MDL_)
#define MDL_VA(_MDL_)                       MmGetMdlVirtualAddress(_MDL_)

#define max(_a, _b)                         (((_a) > (_b)) ? (_a) : (_b))
#define min(_a, _b)                         (((_a) < (_b)) ? (_a) : (_b))
#define NDIS_EQUAL_UNICODE_STRING(s1, s2)   (((s1)->Length == (s2)->Length) &&  \
                                             RtlEqualMemory((s1)->Buffer, (s2)->Buffer, (s1)->Length))

#define NDIS_PARTIAL_MATCH_UNICODE_STRING(s1, s2) \
                                            (((s1)->Length != (s2)->Length) &&  \
                                             RtlEqualMemory((s1)->Buffer, (s2)->Buffer, min((s1)->Length, (s2)->Length)))

#define CHAR_TO_INT(_s, _b, _p)             RtlCharToInteger(_s, _b, _p)


#define BAD_MINIPORT(_M, _S)                DbgPrint(" ***NDIS*** : Miniport %Z - %s\n", (_M)->pAdapterInstanceName, _S)

#define REF_NDIS_DRIVER_OBJECT()            ObfReferenceObject(ndisDriverObject)
#define DEREF_NDIS_DRIVER_OBJECT()          ObfDereferenceObject(ndisDriverObject)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ndis\sys\ndissd.c ===
#include "precomp.h"

typedef ULONG SECURITY_INFORMATION;

NTSTATUS
AddNetConfigOpsAce(IN PACL Dacl,
                  OUT PACL * DeviceAcl
                  )
/*++

Routine Description:

    This routine builds an ACL which gives adds the Network Configuration Operators group
    to the principals allowed to control the driver.

Arguments:

    Dacl - Existing DACL.
    DeviceAcl - Output pointer to the new ACL.

Return Value:

    STATUS_SUCCESS or an appropriate error code.

--*/

{
    PGENERIC_MAPPING GenericMapping;
    PSID AdminsSid = NULL;
    PSID SystemSid = NULL;
    PSID NetConfigOpsSid = NULL;
    PSID NetworkServiceSid = NULL;
    ULONG AclLength;
    NTSTATUS Status;
    ACCESS_MASK AccessMask = GENERIC_ALL;
    PACL NewAcl = NULL;
    ULONG SidSize;
    SID_IDENTIFIER_AUTHORITY sidAuth = SECURITY_NT_AUTHORITY;
    PISID ISid;
    PACCESS_ALLOWED_ACE AceTemp;
    int i;
    //
    // Enable access to all the globally defined SIDs
    //

    GenericMapping = IoGetFileObjectGenericMapping();

    RtlMapGenericMask(&AccessMask, GenericMapping);

    AdminsSid         = SeExports->SeAliasAdminsSid;
    SystemSid         = SeExports->SeLocalSystemSid;
    NetworkServiceSid = SeExports->SeNetworkServiceSid;

    SidSize = RtlLengthRequiredSid(2);
    NetConfigOpsSid = (PSID)(ExAllocatePool(PagedPool,SidSize));

    if (NULL == NetConfigOpsSid) {
        return STATUS_INSUFFICIENT_RESOURCES;
    }
    
    Status = RtlInitializeSid(NetConfigOpsSid, &sidAuth, 2);
    if (Status != STATUS_SUCCESS) {
		goto clean_up;
    }

    ISid = (PISID)(NetConfigOpsSid);
    ISid->SubAuthority[0] = SECURITY_BUILTIN_DOMAIN_RID;
    ISid->SubAuthority[1] = DOMAIN_ALIAS_RID_NETWORK_CONFIGURATION_OPS;

    AclLength = Dacl->AclSize;
    
    AclLength += sizeof(ACL) + sizeof(ACCESS_ALLOWED_ACE) - 2 * sizeof(ULONG);

    AclLength += RtlLengthSid(NetConfigOpsSid);

    NewAcl = ExAllocatePool(
                            PagedPool,
                            AclLength
                            );

    if (NewAcl == NULL) {
        Status = STATUS_INSUFFICIENT_RESOURCES;
        goto clean_up;
    }

    Status = RtlCreateAcl(NewAcl, AclLength, ACL_REVISION2);

    if (!NT_SUCCESS(Status)) {
        goto clean_up;
    }

    for (i = 0; i < Dacl->AceCount; i++) {
        Status = RtlGetAce(Dacl, i, &AceTemp);

        if (NT_SUCCESS(Status)) {

            Status = RtlAddAccessAllowedAce(NewAcl,
                                            ACL_REVISION2,
                                            AceTemp->Mask,
                                            &AceTemp->SidStart);
        }

        if (!NT_SUCCESS(Status)) {
            goto clean_up;
        }
    }

    // Add Net Config Operators Ace
    Status = RtlAddAccessAllowedAce(NewAcl,
                                    ACL_REVISION2,
                                    AccessMask,
                                    NetConfigOpsSid);

    if (!NT_SUCCESS(Status)) {
		goto clean_up;
    }

    if (!NT_SUCCESS(Status)) {
		goto clean_up;
    }

    *DeviceAcl = NewAcl;

clean_up:
	if (NetConfigOpsSid) {
		ExFreePool(NetConfigOpsSid);
	}
	if (!NT_SUCCESS(Status) && NewAcl) {
		ExFreePool(NewAcl);
	}

    return (Status);
}



NTSTATUS
CreateDeviceDriverSecurityDescriptor(PVOID DeviceOrDriverObject)

/*++

Routine Description:

    Creates the SD responsible for giving access to different users.

Arguments:

    None.

Return Value:

    STATUS_SUCCESS or an appropriate error code.

--*/

{
    NTSTATUS status;
    BOOLEAN memoryAllocated = FALSE;
    PSECURITY_DESCRIPTOR sdSecurityDescriptor = NULL;
    ULONG sdSecurityDescriptorLength;
    CHAR buffer[SECURITY_DESCRIPTOR_MIN_LENGTH];
    PSECURITY_DESCRIPTOR localSecurityDescriptor =
    (PSECURITY_DESCRIPTOR) & buffer;
    SECURITY_INFORMATION securityInformation = DACL_SECURITY_INFORMATION;
    PACL paclDacl = NULL;
    BOOLEAN bHasDacl;
    BOOLEAN bDaclDefaulted;
    PACCESS_ALLOWED_ACE pAce = NULL;
    PACL NewAcl = NULL;
    INT i;
    
    //
    // Get a pointer to the security descriptor from the driver/device object.
    //

    status = ObGetObjectSecurity(
                                 DeviceOrDriverObject,
                                 &sdSecurityDescriptor,
                                 &memoryAllocated
                                 );

    if (!NT_SUCCESS(status)) 
    {
        KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,
                 "TCP: Unable to get security descriptor, error: %x\n",
                 status
                ));
        ASSERT(memoryAllocated == FALSE);
        return (status);
    }

    status = RtlGetDaclSecurityDescriptor(sdSecurityDescriptor, &bHasDacl, &paclDacl, &bDaclDefaulted);

    if (bHasDacl)
    {
        status = AddNetConfigOpsAce(paclDacl, &NewAcl);

        if (NT_SUCCESS(status))
        {
            PSECURITY_DESCRIPTOR sdSecDesc = NULL;
            ULONG ulSecDescSize = 0;
            PACL daclAbs = NULL;
            ULONG ulDacl = 0;
            PACL saclAbs = NULL;
            ULONG ulSacl = 0;
            PSID Owner = NULL;
            ULONG ulOwnerSize = 0;
            PSID PrimaryGroup = NULL;
            ULONG ulPrimaryGroupSize = 0;
            BOOLEAN bOwnerDefault;
            BOOLEAN bGroupDefault;
            BOOLEAN HasSacl = FALSE;
            BOOLEAN SaclDefaulted = FALSE;
            SECURITY_INFORMATION secInfo = OWNER_SECURITY_INFORMATION | GROUP_SECURITY_INFORMATION | DACL_SECURITY_INFORMATION;
            HANDLE hIp;
            HANDLE hTcp;

            ulSecDescSize = sizeof(sdSecDesc) + NewAcl->AclSize;
            sdSecDesc = ExAllocatePool(PagedPool, ulSecDescSize);

            if (sdSecDesc)
            {
                ulDacl = NewAcl->AclSize;
                daclAbs = ExAllocatePool(PagedPool, ulDacl);

                if (daclAbs)
                {
                    status = RtlGetOwnerSecurityDescriptor(sdSecurityDescriptor, &Owner, &bOwnerDefault);

                    if (NT_SUCCESS(status))
                    {
                        ulOwnerSize = RtlLengthSid(Owner);

                        status = RtlGetGroupSecurityDescriptor(sdSecurityDescriptor, &PrimaryGroup, &bGroupDefault);

                        if (NT_SUCCESS(status))
                        {
                            status = RtlGetSaclSecurityDescriptor(sdSecurityDescriptor, &HasSacl, &saclAbs, &SaclDefaulted);

                            if (NT_SUCCESS(status))
                            {
                                if (HasSacl) 
                                {
                                    ulSacl = saclAbs->AclSize;
                                    secInfo |= SACL_SECURITY_INFORMATION;
                                }

                                ulPrimaryGroupSize= RtlLengthSid(PrimaryGroup);

                                status = RtlSelfRelativeToAbsoluteSD(sdSecurityDescriptor, sdSecDesc, &ulSecDescSize, daclAbs,
                                                                 &ulDacl, saclAbs, &ulSacl, Owner, &ulOwnerSize, PrimaryGroup, &ulPrimaryGroupSize);

                                if (NT_SUCCESS(status))
                                {
                                    status = RtlSetDaclSecurityDescriptor(sdSecDesc, TRUE, NewAcl, FALSE);

                                    if (NT_SUCCESS(status))
                                    {
                                        status = ObSetSecurityObjectByPointer(DeviceOrDriverObject, secInfo, sdSecDesc);
                                    }
                                }
                            }
                        }
                    }
                }

                if (sdSecDesc)
                {
                    // Since this is a Self-Relative security descriptor, freeing it also frees
                    //  Owner and PrimaryGroup.
                    ExFreePool(sdSecDesc);
                }

                if (daclAbs)
                {
                    ExFreePool(daclAbs);
                }
            }

            if (NewAcl)
            {
                ExFreePool(NewAcl);
            }

        }
    }
    else
    {
        KdPrintEx((DPFLTR_TCPIP_ID, DPFLTR_INFO_LEVEL,"TCP: No Dacl: %x\n", status));
    }

    ObReleaseObjectSecurity(
                            sdSecurityDescriptor,
                            memoryAllocated
                            );

    return (status);
}

NTSTATUS
ndisBuildDeviceAcl(
    OUT PACL        *DeviceAcl,
    IN  BOOLEAN     AddNetConfigOps
    )

/*++

Routine Description:

    This routine builds an ACL which gives Administrators,  LocalSystem,
    and NetworkService principals full access. All other principals have no access.

Arguments:

    DeviceAcl - Output pointer to the new ACL.

Return Value:

    STATUS_SUCCESS or an appropriate error code.

--*/

{
    NTSTATUS            Status;
    PGENERIC_MAPPING    GenericMapping;
    ULONG               AclLength;
    ACCESS_MASK         AccessMask = GENERIC_ALL;
    PACL                NewAcl;
    PSID                NetConfigOpsSid = NULL;
    ULONG               NetConfigOpsSidSize;
    SID_IDENTIFIER_AUTHORITY NetConfigOpsSidAuth = SECURITY_NT_AUTHORITY;
    PISID               ISid;


    do
    {
        //
        // Enable access to all the globally defined SIDs
        //

        GenericMapping = IoGetFileObjectGenericMapping();

        RtlMapGenericMask(&AccessMask, GenericMapping );

        
        AclLength = sizeof(ACL)                                 +
                    FIELD_OFFSET (ACCESS_ALLOWED_ACE, SidStart) +
                    RtlLengthSid(SeExports->SeAliasAdminsSid);


        if (AddNetConfigOps)
        {
            NetConfigOpsSidSize = RtlLengthRequiredSid(2);
            NetConfigOpsSid = (PSID)ALLOC_FROM_POOL(NetConfigOpsSidSize, NDIS_TAG_NET_CFG_OPS_ID);

            if (NULL == NetConfigOpsSid)
            {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                break;
            }
            
            Status = RtlInitializeSid(NetConfigOpsSid, &NetConfigOpsSidAuth, 2);
            if (Status != STATUS_SUCCESS)
            {
                Status = STATUS_INSUFFICIENT_RESOURCES;
                break;
            }

            ISid = (PISID)(NetConfigOpsSid);
            ISid->SubAuthority[0] = SECURITY_BUILTIN_DOMAIN_RID;
            ISid->SubAuthority[1] = DOMAIN_ALIAS_RID_NETWORK_CONFIGURATION_OPS;

            AclLength += RtlLengthSid(NetConfigOpsSid) + FIELD_OFFSET(ACCESS_ALLOWED_ACE, SidStart);
        }        

        NewAcl = ALLOC_FROM_POOL(AclLength, NDIS_TAG_SECURITY);

        if (NewAcl == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }

        ZeroMemory(NewAcl, AclLength);
        
        Status = RtlCreateAcl(NewAcl, AclLength, ACL_REVISION );

        if (!NT_SUCCESS(Status)) 
        {
            FREE_POOL(NewAcl);
            break;
        }

        Status = RtlAddAccessAllowedAce (
                     NewAcl,
                     ACL_REVISION2,
                     AccessMask,
                     SeExports->SeAliasAdminsSid
                     );

        ASSERT(NT_SUCCESS(Status));
        
        if (AddNetConfigOps)
        {
            // Add Net Config Operators Ace
            Status = RtlAddAccessAllowedAce(NewAcl,
                                            ACL_REVISION2,
                                            AccessMask,
                                            NetConfigOpsSid);
            ASSERT(NT_SUCCESS(Status));
        }


        *DeviceAcl = NewAcl;

        Status = STATUS_SUCCESS;
        
    }while (FALSE);

	if (NetConfigOpsSid)
	{
		ExFreePool(NetConfigOpsSid);
	}

    return(Status);

}


NTSTATUS
ndisCreateSecurityDescriptor(
    IN  PDEVICE_OBJECT          DeviceObject,
    OUT PSECURITY_DESCRIPTOR *  pSecurityDescriptor,
    BOOLEAN                     AddNetConfigOps
    )

/*++

Routine Description:

    This routine creates a security descriptor which gives access
    only to certain priviliged accounts. This descriptor is used
    to access check processes that open a handle to miniport device
    objects.

Arguments:

    None.

Return Value:

    STATUS_SUCCESS or an appropriate error code.

--*/

{
    PACL                  devAcl = NULL;
    NTSTATUS              Status;
    BOOLEAN               memoryAllocated = FALSE;
    PSECURITY_DESCRIPTOR  CurSecurityDescriptor;
    PSECURITY_DESCRIPTOR  NewSecurityDescriptor;
    ULONG                 CurSecurityDescriptorLength;
    CHAR                  buffer[SECURITY_DESCRIPTOR_MIN_LENGTH];
    PSECURITY_DESCRIPTOR  localSecurityDescriptor =
                             (PSECURITY_DESCRIPTOR)buffer;
    SECURITY_INFORMATION  securityInformation = DACL_SECURITY_INFORMATION;
    BOOLEAN               bReleaseObjectSecurity = FALSE;


    do
    {

        *pSecurityDescriptor = NULL;
        
        //
        // Get a pointer to the security descriptor from the device object.
        //
        Status = ObGetObjectSecurity(
                     DeviceObject,
                     &CurSecurityDescriptor,
                     &memoryAllocated
                     );

        if (!NT_SUCCESS(Status))
        {
            ASSERT(memoryAllocated == FALSE);
            break;
        }
        bReleaseObjectSecurity = TRUE;

        //
        // Build a local security descriptor with an ACL giving only
        // certain priviliged accounts.
        //
        Status = ndisBuildDeviceAcl(&devAcl, AddNetConfigOps);

        if (!NT_SUCCESS(Status))
        {
            break;
        }
        
        (VOID)RtlCreateSecurityDescriptor(
                    localSecurityDescriptor,
                    SECURITY_DESCRIPTOR_REVISION
                    );

        (VOID)RtlSetDaclSecurityDescriptor(
                    localSecurityDescriptor,
                    TRUE,
                    devAcl,
                    FALSE
                    );

        //
        // Make a copy of the security descriptor. This copy will be the raw descriptor.
        //
        CurSecurityDescriptorLength = RtlLengthSecurityDescriptor(
                                          CurSecurityDescriptor
                                          );

        NewSecurityDescriptor = ALLOC_FROM_POOL(CurSecurityDescriptorLength, NDIS_TAG_SECURITY);

        if (NewSecurityDescriptor == NULL)
        {
            Status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }

        RtlMoveMemory(
            NewSecurityDescriptor,
            CurSecurityDescriptor,
            CurSecurityDescriptorLength
            );

        *pSecurityDescriptor = NewSecurityDescriptor;

        //
        // Now apply the local descriptor to the raw descriptor.
        //
        Status = SeSetSecurityDescriptorInfo(
                     NULL,
                     &securityInformation,
                     localSecurityDescriptor,
                     pSecurityDescriptor,
                     NonPagedPool,
                     IoGetFileObjectGenericMapping()
                     );

        if (!NT_SUCCESS(Status))
        {
            ASSERT(*pSecurityDescriptor == NewSecurityDescriptor);
            FREE_POOL(*pSecurityDescriptor);
            *pSecurityDescriptor = NULL;
            break;
        }

        if (*pSecurityDescriptor != NewSecurityDescriptor)
        {
            ExFreePool(NewSecurityDescriptor);
        }
        
        Status = STATUS_SUCCESS;
    }while (FALSE);


    if (bReleaseObjectSecurity)
    {
        ObReleaseObjectSecurity(
            CurSecurityDescriptor,
            memoryAllocated
            );
    }
    
    if (devAcl!=NULL)
    {
        FREE_POOL(devAcl);
    }

    return(Status);
}

BOOLEAN
ndisCheckAccess (
    PIRP                    Irp,
    PIO_STACK_LOCATION      IrpSp,
    PNTSTATUS               Status,
    PSECURITY_DESCRIPTOR    SecurityDescriptor
    )
/*++

Routine Description:

    Compares security context of the endpoint creator to that
    of the administrator and local system.

Arguments:

    Irp - Pointer to I/O request packet.

    IrpSp - pointer to the IO stack location to use for this request.

    Status - returns status generated by access check on failure.

Return Value:

    TRUE    - the creator has admin or local system privilige
    FALSE    - the creator is just a plain user

--*/

{
    BOOLEAN               accessGranted;
    PACCESS_STATE         accessState;
    PIO_SECURITY_CONTEXT  securityContext;
    PPRIVILEGE_SET        privileges = NULL;
    ACCESS_MASK           grantedAccess;
    PGENERIC_MAPPING GenericMapping;
    ACCESS_MASK AccessMask = GENERIC_ALL;

    //
    // Enable access to all the globally defined SIDs
    //

    GenericMapping = IoGetFileObjectGenericMapping();

    RtlMapGenericMask( &AccessMask, GenericMapping );


    securityContext = IrpSp->Parameters.Create.SecurityContext;
    accessState = securityContext->AccessState;

    SeLockSubjectContext(&accessState->SubjectSecurityContext);

    accessGranted = SeAccessCheck(
                        SecurityDescriptor,
                        &accessState->SubjectSecurityContext,
                        TRUE,
                        AccessMask,
                        0,
                        &privileges,
                        IoGetFileObjectGenericMapping(),
                        (KPROCESSOR_MODE)((IrpSp->Flags & SL_FORCE_ACCESS_CHECK)
                            ? UserMode
                            : Irp->RequestorMode),
                        &grantedAccess,
                        Status
                        );

    if (privileges) {
        (VOID) SeAppendPrivileges(
                   accessState,
                   privileges
                   );
        SeFreePrivileges(privileges);
    }

    if (accessGranted) {
        accessState->PreviouslyGrantedAccess |= grantedAccess;
        accessState->RemainingDesiredAccess &= ~( grantedAccess | MAXIMUM_ALLOWED );
        ASSERT (NT_SUCCESS (*Status));
    }
    else {
        ASSERT (!NT_SUCCESS (*Status));
    }
    SeUnlockSubjectContext(&accessState->SubjectSecurityContext);

    return accessGranted;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ndis\sys\ndiswmi.c ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation

Module Name:

    ndiswmi.c

Abstract:

    This module contains the routines necessary to process IRPs sent under the
    IRP_MJ_SYSTEM_CONTROL major code.

Author:

    Kyle Brandon    (KyleB)     

Environment:

    Kernel mode

Revision History:

--*/

#include <precomp.h>
#pragma hdrstop

#define MODULE_NUMBER MODULE_WMI

#define MOF_RESOURCE_NAME   L"NdisMofResource"

NTSTATUS
ndisWmiFindInstanceName(
    IN  PNDIS_CO_VC_PTR_BLOCK   *ppVcBlock,
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  PWSTR                   pInstanceName,
    IN  USHORT                  cbInstanceName
    )
{
    NTSTATUS                Status = STATUS_SUCCESS;
    PNDIS_OPEN_BLOCK        pOpen;
    PLIST_ENTRY             Link;
    PNDIS_CO_VC_PTR_BLOCK   pVcBlock = NULL;
    UINT                    cListCount;
    PLIST_ENTRY             pListHead;
    UNICODE_STRING          usTemp;

    *ppVcBlock = NULL;
    

    usTemp.Buffer = pInstanceName;
    usTemp.Length = usTemp.MaximumLength = cbInstanceName;

    //
    //  See if this is a VC instance ?
    //
    if (pInstanceName[VC_ID_INDEX] == VC_IDENTIFIER)
    {

        //
        //  The request is for some VC. Go through the Miniport's list of WMI enabled VCs.
        //
        Link = Miniport->WmiEnabledVcs.Flink;
        while (Link != &Miniport->WmiEnabledVcs)
        {
            //
            //  Get a pointer to the VC.
            //
            pVcBlock = CONTAINING_RECORD(Link, NDIS_CO_VC_PTR_BLOCK, WmiLink);

            //
            //  Check the name with the one in the wnode.
            //
            if (RtlEqualUnicodeString(&pVcBlock->VcInstanceName, &usTemp, TRUE))
            {
                //
                //  This is our baby. Slap a reference on it and get out.
                //  
                if (!ndisReferenceVcPtr(pVcBlock))
                {
                    DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_ERR,
                        ("ndisWmiFindInstanceName: Unable to reference the VC\n"));

                    //
                    //  VC is closing, can't query this one.
                    //
                    Status = NDIS_STATUS_FAILURE;
                }

                break;
            }

            //
            //  Initialize this so that we know when we've found the VC in the outer loop.
            //
            pVcBlock = NULL;
            Link = Link->Flink;
        }

        //
        //  If we didn't find the VC then return FAILURE.
        //
        if (Link == &Miniport->WmiEnabledVcs)
        {
            DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_INFO,
                ("ndisWmiFindInstanceName: Could not verify the instance name passed in\n"));

            Status = STATUS_WMI_INSTANCE_NOT_FOUND;
        }

        //
        //  If we found the VC then save it before leaving.
        //  
        if (NT_SUCCESS(Status))
        {
            *ppVcBlock = pVcBlock;
        }
    }
    else
    {

        //
        //  The name belongs to a miniport, check to see if it is for this one.
        //

        if (!RtlEqualUnicodeString(Miniport->pAdapterInstanceName, &usTemp, TRUE))
        {
            DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_ERR,
                ("ndisWmiFindInstanceName: Invalid instance name\n"));

            Status = STATUS_WMI_INSTANCE_NOT_FOUND;
        }
    }

    return(Status);
}

BOOLEAN
ndisWmiGuidIsAdapterSpecific(
    IN  LPGUID  guid
    )
{
    BOOLEAN fAdapterOnly = FALSE;

    if (NdisEqualMemory(guid, (PVOID)&GUID_NDIS_ENUMERATE_ADAPTER, sizeof(GUID)) ||
        NdisEqualMemory(guid, (PVOID)&GUID_POWER_DEVICE_ENABLE, sizeof(GUID)) ||
        NdisEqualMemory(guid, (PVOID)&GUID_POWER_DEVICE_WAKE_ENABLE, sizeof(GUID)) ||
        NdisEqualMemory(guid, (PVOID)&GUID_NDIS_WAKE_ON_MAGIC_PACKET_ONLY, sizeof(GUID)))
    {
        fAdapterOnly = TRUE;
    }

    return(fAdapterOnly);
}

NDIS_STATUS
ndisQuerySetMiniport(
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  PNDIS_CO_VC_PTR_BLOCK   pVcBlock,
    IN  BOOLEAN                 fSet,
    IN  PNDIS_REQUEST           pRequest,
    IN  PLARGE_INTEGER          pTime       OPTIONAL
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    BOOLEAN                 fQuery = !fSet;
    UINT                    Count;
    NDIS_STATUS             NdisStatus;
    PNDIS_COREQ_RESERVED    CoReqRsvd;

    PnPReferencePackage();

#define MAX_WAIT_COUNT  5000
#define WAIT_TIME       1000

    if (MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_DEVICE_FAILED | fMINIPORT_PM_HALTED))
    {
        PnPDereferencePackage();
        return (fQuery ? NDIS_STATUS_FAILURE : NDIS_STATUS_SUCCESS);
    }

    //
    //  Initialize the co-request reserved information.
    //
    CoReqRsvd = PNDIS_COREQ_RESERVED_FROM_REQUEST(pRequest);

    PNDIS_RESERVED_FROM_PNDIS_REQUEST(pRequest)->Open = NULL;

    //
    // preserve the mandatory setting on request
    //
    PNDIS_RESERVED_FROM_PNDIS_REQUEST(pRequest)->Flags &= REQST_MANDATORY;
    
    PNDIS_RESERVED_FROM_PNDIS_REQUEST(pRequest)->Flags |= REQST_SIGNAL_EVENT;
    INITIALIZE_EVENT(&CoReqRsvd->Event);

    //
    // If the miniport is being reset, then wait for the reset to complete before going any further.
    // Make sure we do not wait indefinitely either
    //
    for (Count = 0; Count < MAX_WAIT_COUNT; Count ++)
    {
        if (!MINIPORT_TEST_FLAG(Miniport, (fMINIPORT_RESET_IN_PROGRESS | fMINIPORT_RESET_REQUESTED)))
        {
            break;
        }
        NdisMSleep(WAIT_TIME);  // 1 msec
    }

    if (Count == MAX_WAIT_COUNT)
    {
        PnPDereferencePackage();
        return(NDIS_STATUS_RESET_IN_PROGRESS);
    }

    if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_IS_CO))
    {
        NDIS_HANDLE MiniportVcContext = NULL;

        do
        {
            if (NULL != pVcBlock)
            {
                if (!ndisReferenceVcPtr(pVcBlock))
                {
                    NdisStatus = NDIS_STATUS_CLOSING;
                    break;
                }
                else
                {
                    MiniportVcContext = pVcBlock->MiniportContext;
                }
            }
                        
            NdisStatus = Miniport->DriverHandle->MiniportCharacteristics.CoRequestHandler(
                            Miniport->MiniportAdapterContext,
                            MiniportVcContext,
                            pRequest);
    
            if (NDIS_STATUS_PENDING == NdisStatus)
            {
                WAIT_FOR_OBJECT(&CoReqRsvd->Event, pTime);
    
                //
                //  Get the status that the miniport returned.
                //
                NdisStatus = CoReqRsvd->Status;
            }

            if (NULL != pVcBlock)
            {
                ndisDereferenceVcPtr(pVcBlock);
            }
        } while (FALSE);
    }
    else
    {
        if ((fSet && (Miniport->DriverHandle->MiniportCharacteristics.SetInformationHandler != NULL)) ||
            (fQuery && (Miniport->DriverHandle->MiniportCharacteristics.QueryInformationHandler != NULL)))
        {
            BOOLEAN LocalLock;
            KIRQL   OldIrql;

            NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Miniport, &OldIrql);
    
            ndisMQueueRequest(Miniport, pRequest);
    
            LOCK_MINIPORT(Miniport, LocalLock);

            if (LocalLock || MINIPORT_TEST_FLAG(Miniport, fMINIPORT_DESERIALIZE))
            {
                ndisMDoRequests(Miniport);
            }
            else
            {
                //
                //  Queue the miniport request and wait for it to complete.
                //
                NDISM_QUEUE_WORK_ITEM(Miniport, NdisWorkItemRequest, NULL);
            }
            UNLOCK_MINIPORT(Miniport, LocalLock);
    
            NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);
    
            if (NT_SUCCESS(WAIT_FOR_OBJECT(&CoReqRsvd->Event, pTime)))
            {
                //
                //  Get the status that the miniport returned.
                //
                NdisStatus = CoReqRsvd->Status;
            }
            else
            {
                NdisStatus = -1;    // Special error-code to return time-out
            }
        }
        else
        {
            //
            //  If there isn't a proper handler then this is not a valid request.
            //  
            NdisStatus = STATUS_INVALID_PARAMETER;
        }
    }

    PnPDereferencePackage();

    return(NdisStatus);
}

NDIS_STATUS
ndisQueryCustomGuids(
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  PNDIS_REQUEST           Request,
    OUT PNDIS_GUID      *       ppGuidToOid,
    OUT PUSHORT                 pcGuidToOid
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    USHORT          BytesNeeded;
    NDIS_STATUS     Status;
    USHORT          c, cCustomGuids = 0;
    PNDIS_GUID      pGuidToOid = NULL;

    DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_INFO,
            ("==>ndisQueryCustomGuids\n"));

    *ppGuidToOid = NULL;
    *pcGuidToOid = 0;

    do
    {
        //
        //  Determine the size needed for the custom GUID to OID map.
        //
#if (OID_GEN_CO_SUPPORTED_GUIDS != OID_GEN_SUPPORTED_GUIDS)
#error (OID_GEN_CO_SUPPORTED_GUIDS == OID_GEN_SUPPORTED_GUIDS)
#endif

        INIT_INTERNAL_REQUEST(Request, OID_GEN_SUPPORTED_GUIDS, NdisRequestQueryInformation, NULL, 0);
        Status = ndisQuerySetMiniport(Miniport, NULL, FALSE, Request, NULL);

        BytesNeeded = (USHORT)Request->DATA.QUERY_INFORMATION.BytesNeeded;
    
        //
        //  If the miniport has custom GUIDs then make sure it returned a valid
        //  length for the BytesNeeded.
        //
        if (((NDIS_STATUS_INVALID_LENGTH == Status) ||
             (NDIS_STATUS_BUFFER_TOO_SHORT == Status)) && (0 != BytesNeeded))
        {
            //
            //  Bytes needed should contain the amount of space needed.
            //
            cCustomGuids = (BytesNeeded / sizeof(NDIS_GUID));
        }

        //
        //  If there are no custom GUIDs to support then get out.
        //
        if (cCustomGuids == 0)
        {   
            DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_INFO,
                ("ndisQueryCustomGuids: Miniport does not support custom GUIDS\n"));

            Status = NDIS_STATUS_NOT_SUPPORTED;
            break;
        }


        //
        //  Allocate a buffer to hold the GUID to OID mapping
        //  for the custom GUIDs.
        //
        pGuidToOid = ALLOC_FROM_POOL(BytesNeeded, NDIS_TAG_WMI_GUID_TO_OID);
        if (NULL == pGuidToOid)
        {
            DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_ERR,
                ("ndisQueryCustomGuids: Unable to allocate memory for the GUID to OID map\n"));

            Status = NDIS_STATUS_RESOURCES;
            break;
        }

        //
        //  Query the list of GUIDs
        //
        if (0 != cCustomGuids)
        {
            //
            //  Store the buffer with the request.
            //
            Request->DATA.QUERY_INFORMATION.InformationBuffer = pGuidToOid;
            Request->DATA.QUERY_INFORMATION.InformationBufferLength = BytesNeeded;
    
            //
            //  Query for the list of custom GUIDs and OIDs.
            //
            Status = ndisQuerySetMiniport(Miniport, NULL, FALSE, Request, NULL);
            if (NDIS_STATUS_SUCCESS != Status)
            {
                DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_ERR,
                    ("ndisQueryCustomGuids: Unable to get the list of supported Co GUIDs\n"));
    
                break;
            }

            //
            //  Go through this list and mark the guids as co.
            //
            if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_IS_CO))
            {
                for (c = 0; c < cCustomGuids; c++)
                {
                    NDIS_GUID_SET_FLAG(&pGuidToOid[c], fNDIS_GUID_CO_NDIS);
                }
            }
        }

    } while (FALSE);

    if (NDIS_STATUS_SUCCESS == Status)
    {
        *ppGuidToOid = pGuidToOid;
        *pcGuidToOid = cCustomGuids;
    }
    else
    {
        if (NULL != pGuidToOid)
        {
            FREE_POOL(pGuidToOid);
        }
    }

    DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_INFO,
            ("<==ndisQueryCustomGuids\n"));

    return(Status);
}

USHORT
ndisWmiMapOids(
    IN  OUT PNDIS_GUID  pDst,
    IN  IN  USHORT      cDst,
    IN      PNDIS_OID   pOidList,
    IN      USHORT      cOidList,
    IN      PNDIS_GUID  ndisSupportedList,
    IN      ULONG       cSupportedList
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    USHORT      c1, c2, ctmp = cDst;

    for (c1 = 0; c1 < cSupportedList; c1++)
    {
        for (c2 = 0; c2 < cOidList; c2++)
        {
            if (ndisSupportedList[c1].Oid == pOidList[c2])
            {
                if (NULL != pDst)
                {
                    //
                    //  Copy the guid into the destination buffer.
                    //
                    NdisMoveMemory(&pDst[ctmp], &ndisSupportedList[c1], sizeof(NDIS_GUID));
                }

                ctmp++;
                break;
            }
        }
    }

    return ctmp;
}

NDIS_STATUS
ndisQuerySupportedGuidToOidList(
    IN  PNDIS_MINIPORT_BLOCK    Miniport
    )
/*++

Routine Description:

    This routine will query the miniport and determine the mapping of
    supported GUIDs and their corresponding OIDs. This will include any
    custom OIDs that the driver supports.

Arguments:

Return Value:

--*/
{
    ULONG           BytesNeeded;
    NDIS_STATUS     NdisStatus;
    USHORT          cOidList = 0;
    PNDIS_OID       pOidList = NULL;
    USHORT          cCustomGuids = 0;
    PNDIS_GUID      pCustomGuids = NULL;
    USHORT          cGuidToOidMap = 0;
    PNDIS_GUID      pGuidToOidMap = NULL;
    USHORT          c1, c2;
    NDIS_REQUEST    Request;

    DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_INFO,
        ("==>ndisQuerySupportedGuidToOidList\n"));
    do
    {
#if (OID_GEN_SUPPORTED_LIST != OID_GEN_CO_SUPPORTED_LIST)
#error (OID_GEN_SUPPORTED_LIST != OID_GEN_CO_SUPPORTED_LIST)
#endif

        //
        //  Determine the amount of buffer space needed for the supported list.
        //
        INIT_INTERNAL_REQUEST(&Request, OID_GEN_SUPPORTED_LIST, NdisRequestQueryInformation, NULL, 0);
        NdisStatus = ndisQuerySetMiniport(Miniport, NULL, FALSE, &Request, NULL);
        BytesNeeded = Request.DATA.QUERY_INFORMATION.BytesNeeded;
    
        //
        //  The driver should have returned invalid length and the
        //  length needed in BytesNeeded.
        //
        if (((NDIS_STATUS_INVALID_LENGTH != NdisStatus) && (NDIS_STATUS_BUFFER_TOO_SHORT != NdisStatus)) ||
            (0 == BytesNeeded))
        {
            DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_INFO,
                ("ndisQuerySupportedGuidToOidList: Failed to get the size of the supported OID list.\n"));
    
            NdisStatus = NDIS_STATUS_FAILURE;
            break;
        }
    
        //
        //  Determine the number of Oids supported.
        //
        cOidList = (USHORT)(BytesNeeded/sizeof(NDIS_OID));

        //
        //  Allocate a buffer to hold the supported list of OIDs.
        //
        pOidList = ALLOC_FROM_POOL(BytesNeeded, NDIS_TAG_WMI_OID_SUPPORTED_LIST);
        if (NULL == pOidList)
        {
            DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_INFO,
                ("ndisQuerySupportedGuidToOidList: Failed to allocate memory for the OID list.\n"));

            NdisStatus = NDIS_STATUS_RESOURCES;
            break;
        }

        Request.DATA.QUERY_INFORMATION.InformationBuffer = pOidList;
        Request.DATA.QUERY_INFORMATION.InformationBufferLength = BytesNeeded;

        //
        //  Now query the supported list of OIDs into the buffer.
        //
        NdisStatus = ndisQuerySetMiniport(Miniport, NULL, FALSE, &Request, NULL);
        if (NDIS_STATUS_SUCCESS != NdisStatus)
        {
            DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_INFO,
                    ("ndisQuerySupportedGuidToOidList: Failed to read in the supported OID list.\n"));
            break;
        }
    
        //
        //  Determine the number of [Co]NDIS OIDs that NDIS will handle on behalf of the miniport
        //
        cGuidToOidMap = ndisWmiMapOids(NULL,
                                       cGuidToOidMap,
                                       pOidList,
                                       cOidList,
                                       ndisSupportedGuids,
                                       sizeof(ndisSupportedGuids)/sizeof(NDIS_GUID));
        cGuidToOidMap = ndisWmiMapOids(NULL,
                                       cGuidToOidMap,
                                       pOidList,
                                       cOidList,
                                       ndisCoSupportedGuids,
                                       sizeof(ndisCoSupportedGuids)/sizeof(NDIS_GUID));

        //
        //  Determine the number of media specific OIDs that NDIS will handle on
        //  behalf of the miniport
        //
        cGuidToOidMap = ndisWmiMapOids(NULL,
                                       cGuidToOidMap,
                                       pOidList,
                                       cOidList,
                                       ndisMediaSupportedGuids,
                                       sizeof(ndisMediaSupportedGuids)/sizeof(NDIS_GUID));

        //
        //  Determine the number of custom GUIDs supported.
        //
        NdisStatus = ndisQueryCustomGuids(Miniport, &Request, &pCustomGuids, &cCustomGuids);
        if (NDIS_STATUS_SUCCESS == NdisStatus)
        {
            cGuidToOidMap += cCustomGuids;
        }

        //
        //  Add to the guid count the number of status indications we are
        //  registering.
        //
        cGuidToOidMap += (sizeof(ndisStatusSupportedGuids) / sizeof(NDIS_GUID));

        //
        //  Add the number of GUIDs that ndis will handle.
        //  Add any guids that are not supported with an OID. These will be handled
        //  entirely by ndis.
        //
        for (c1 = 0; c1 < sizeof(ndisSupportedGuids) / sizeof(NDIS_GUID); c1++)
        {
            if (NDIS_GUID_TEST_FLAG(&ndisSupportedGuids[c1], fNDIS_GUID_NDIS_ONLY))
            {
                //
                //  Check to see if the miniport is CoNDIS
                //  
                if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_IS_CO) ||
                    !NDIS_GUID_TEST_FLAG(&ndisSupportedGuids[c1], fNDIS_GUID_CO_NDIS))
                {
                    cGuidToOidMap++;
                }
            }
        }

        //
        //  Allocate space for the GUID to OID map.
        //
        pGuidToOidMap = ALLOC_FROM_POOL(cGuidToOidMap * sizeof(NDIS_GUID), NDIS_TAG_WMI_GUID_TO_OID);
        if (NULL == pGuidToOidMap)
        {
            NdisStatus = NDIS_STATUS_RESOURCES;
            break;
        }

        NdisZeroMemory(pGuidToOidMap, cGuidToOidMap * sizeof(NDIS_GUID));

        //
        //  Add the GUIDs that NDIS will handle
        //
        for (c1 = 0, c2 = 0;
             c1 < sizeof(ndisSupportedGuids) / sizeof(NDIS_GUID);
             c1++)
        {
            if (NDIS_GUID_TEST_FLAG(&ndisSupportedGuids[c1], fNDIS_GUID_NDIS_ONLY))
            {
                //
                //  Check to see if the miniport is CoNDIS
                //  
                if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_IS_CO) ||
                    !NDIS_GUID_TEST_FLAG(&ndisSupportedGuids[c1], fNDIS_GUID_CO_NDIS))
                {
                    NdisMoveMemory(&pGuidToOidMap[c2], &ndisSupportedGuids[c1], sizeof(NDIS_GUID));

                    if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_IS_CO))
                    {
                        //
                        //  we need to mark this for the enumerate guids.
                        //
                        pGuidToOidMap[c2].Flags |= fNDIS_GUID_CO_NDIS;
                    }
                    c2++;
                }
            }
        }

        //
        //  Save the current number of GUIDs in the map in c1
        //
        c1 = c2;

        //
        //  Find the PNDIS_GUIDs that are appropriate for the miniport.
        //
        c1 = ndisWmiMapOids(pGuidToOidMap,
                            c1,
                            pOidList,
                            cOidList,
                            ndisSupportedGuids,
                            sizeof(ndisSupportedGuids)/sizeof(NDIS_GUID));
        c1 = ndisWmiMapOids(pGuidToOidMap,
                            c1,
                            pOidList,
                            cOidList,
                            ndisCoSupportedGuids,
                            sizeof(ndisCoSupportedGuids)/sizeof(NDIS_GUID));

        //
        //  Check for media specific OIDs that ndis can support.
        //
        c1 = ndisWmiMapOids(pGuidToOidMap,
                            c1,
                            pOidList,
                            cOidList,
                            ndisMediaSupportedGuids,
                            sizeof(ndisMediaSupportedGuids)/sizeof(NDIS_GUID));

        //
        //  Add the status indications to the map of supported guids.
        //
        NdisMoveMemory(&pGuidToOidMap[c1], ndisStatusSupportedGuids, sizeof(ndisStatusSupportedGuids));

        c1 += (sizeof(ndisStatusSupportedGuids) / sizeof(NDIS_GUID));

        //
        //  Save the GUID to OID mapping with the miniport.
        //
        Miniport->pNdisGuidMap = pGuidToOidMap;
        Miniport->cNdisGuidMap = cGuidToOidMap;

        //
        //  Now copy over the custom GUID information if any.
        //
        if (NULL != pCustomGuids)
        {
            NdisMoveMemory(&pGuidToOidMap[c1],
                           pCustomGuids,
                           cCustomGuids * sizeof(NDIS_GUID));

            Miniport->pCustomGuidMap = &pGuidToOidMap[c1];
            Miniport->cCustomGuidMap = cCustomGuids;
        }
        else
        {
            //
            //  Make sure these are initialized if they are not supported.
            //
            Miniport->pCustomGuidMap = NULL;
            Miniport->cCustomGuidMap = 0;
        }

        //
        //  We've succeeded.
        //
        NdisStatus = NDIS_STATUS_SUCCESS;

    } while (FALSE);

    //
    //  Free up the buffer that contains the custom GUIDs.
    //
    if (NULL != pCustomGuids)
    {
        FREE_POOL(pCustomGuids);
    }

    //
    //  Free up the list of supported driver OIDs.
    //
    if (NULL != pOidList)
    {
        FREE_POOL(pOidList);
    }

    //
    //  If there was an error and we allocated the GUID to OID map then
    //  free it up also.
    //
    if (NDIS_STATUS_SUCCESS != NdisStatus)
    {
        if (NULL != pGuidToOidMap)
        {
            FREE_POOL(pGuidToOidMap);
        }
    }

    DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_INFO,
        ("<==ndisQuerySupportedGuidToOidList\n"));

    return(NdisStatus);
}


NTSTATUS
ndisWmiRegister(
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  ULONG_PTR               RegistrationType,
    IN  PWMIREGINFO             wmiRegInfo,
    IN  ULONG                   wmiRegInfoSize,
    IN  PULONG                  pReturnSize
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PWMIREGINFO     pwri;
    ULONG           CustomSizeNeeded = 0;
    ULONG           CustomBufferSize;
    ULONG           CommonSizeNeeded;
    ULONG           cCommonGuids;
    PUNICODE_STRING pMiniportRegistryPath;
    PNDIS_GUID      pndisguid;
    PWMIREGGUID     pwrg;
    PUCHAR          ptmp;
    NTSTATUS        Status;
    UINT            c;
    NDIS_STATUS     NdisStatus;

    DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_INFO,
        ("==>ndisWmiRegister\n"));

    //
    //  Initialize the return size.
    //
    *pReturnSize = 0;

    do
    {
        //
        //  Is this a register request?
        //
        if (WMIREGISTER == RegistrationType)
        {
            //
            //  Get the supported list of OIDs
            //
            if (Miniport->pNdisGuidMap == NULL)
            {
                NdisStatus = ndisQuerySupportedGuidToOidList(Miniport);
                
                if (NDIS_STATUS_SUCCESS != NdisStatus)
                {
                    DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_ERR,
                        ("ndisWmiRegister: Unable to get the supported GUID to OID map\n"));

                    Status = STATUS_UNSUCCESSFUL;
                    break;
                }
            }

            //
            //  Determine the amount of space needed for the Custom GUIDs
            //
            if (Miniport->cCustomGuidMap != 0)
            {
                //
                //  Get a pointer to the registry path of the driver.
                //
                pMiniportRegistryPath = &Miniport->DriverHandle->NdisDriverInfo->ServiceRegPath;

                CustomSizeNeeded = sizeof(WMIREGINFO) +
                                    (Miniport->cCustomGuidMap * sizeof(WMIREGGUID)) +
                                    (sizeof(MOF_RESOURCE_NAME) - sizeof(WCHAR) + sizeof(USHORT)) +
                                    (pMiniportRegistryPath->Length + sizeof(USHORT));
            }

            //
            //  Determine how much memory we need to allocate.
            //
            cCommonGuids = Miniport->cNdisGuidMap - Miniport->cCustomGuidMap;

            CommonSizeNeeded = sizeof(WMIREGINFO) + (cCommonGuids * sizeof(WMIREGGUID));
            CustomBufferSize = CustomSizeNeeded;
            CustomSizeNeeded = (CustomSizeNeeded + (sizeof(PVOID) - 1)) & ~(sizeof(PVOID) - 1);

            //
            // CustomBufferSize represents the number of bytes required to store the
            // custom WMI registration info.  CustomSizeNeeded is this value rounded
            // up so that the adjacent WMI registration info is properly aligned.
            //

            //
            //  We need to give this above information back to WMI.
            //

            if (wmiRegInfoSize < (CustomSizeNeeded + CommonSizeNeeded))
            {
                ASSERT(wmiRegInfoSize >= 4);

                *((PULONG)wmiRegInfo) = (CustomSizeNeeded + CommonSizeNeeded);
                *pReturnSize = sizeof(ULONG);
                Status = STATUS_BUFFER_TOO_SMALL;

                DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_INFO,
                    ("ndisWmiRegister: Insufficient buffer space for WMI registration information.\n"));

                break;
            }

            //
            //  Get a pointer to the buffer passed in.
            //
            pwri = wmiRegInfo;

            *pReturnSize = CustomSizeNeeded + CommonSizeNeeded;

            NdisZeroMemory(pwri, CustomSizeNeeded + CommonSizeNeeded);

            //
            //  do we need to initialize a WMIREGINFO struct for custom GUIDs?
            //
            if (0 != CustomSizeNeeded)
            {
                //
                //  Initialize the WMIREGINFO struct for the miniport's
                //  custom GUIDs.
                //
                pwri->BufferSize = CustomBufferSize;
                pwri->NextWmiRegInfo = CustomSizeNeeded;
                pwri->GuidCount = Miniport->cCustomGuidMap;

                for (c = 0, pndisguid = Miniport->pCustomGuidMap, pwrg = pwri->WmiRegGuid;
                     (c < Miniport->cCustomGuidMap);
                     c++, pndisguid++, pwrg++)
                {
                    CopyMemory(&pwrg->Guid, &pndisguid->Guid, sizeof(GUID));
                }

                //
                //  Fill in the registry path.
                //
                ptmp = (PUCHAR)pwrg;
                pwri->RegistryPath = (ULONG)((ULONG_PTR)ptmp - (ULONG_PTR)pwri);
                *((PUSHORT)ptmp) = pMiniportRegistryPath->Length;
                ptmp += sizeof(USHORT);
                CopyMemory(ptmp, pMiniportRegistryPath->Buffer, pMiniportRegistryPath->Length);

                //
                //  Get a pointer to the destination for the MOF name.
                //
                ptmp += pMiniportRegistryPath->Length;

                //
                //  Save the offset to the mof resource.
                //
                pwri->MofResourceName = (ULONG)((ULONG_PTR)ptmp - (ULONG_PTR)pwri);
                *((PUSHORT)ptmp) = sizeof(MOF_RESOURCE_NAME) - sizeof(WCHAR);
                ptmp += sizeof(USHORT);

                //
                //  Copy the mof name into the wri buffer.
                //
                CopyMemory(ptmp, MOF_RESOURCE_NAME, sizeof(MOF_RESOURCE_NAME) - sizeof(WCHAR));

                //
                //  Go on to the next WMIREGINFO struct for the common GUIDs.
                //

                pwri = (PWMIREGINFO)((PCHAR)pwri + pwri->NextWmiRegInfo);
            }

            //
            //  Initialize the pwri struct for the common Oids.
            //
            pwri->BufferSize = CommonSizeNeeded;
            pwri->NextWmiRegInfo = 0;
            pwri->GuidCount = cCommonGuids;

            //
            //  Go through the GUIDs that we support.
            //
            for (c = 0, pndisguid = Miniport->pNdisGuidMap, pwrg = pwri->WmiRegGuid;
                 (c < cCommonGuids);
                 c++, pndisguid++, pwrg++)
            {
                if (NdisEqualMemory(&pndisguid->Guid, (PVOID)&GUID_POWER_DEVICE_ENABLE, sizeof(GUID)) ||
                    NdisEqualMemory(&pndisguid->Guid, (PVOID)&GUID_POWER_DEVICE_WAKE_ENABLE, sizeof(GUID)) ||
                    NdisEqualMemory(&pndisguid->Guid, (PVOID)&GUID_NDIS_WAKE_ON_MAGIC_PACKET_ONLY, sizeof(GUID)))
                {
                    {
                        (ULONG_PTR)pwrg->InstanceInfo = (ULONG_PTR)(Miniport->PhysicalDeviceObject);
                        pwrg->Flags = WMIREG_FLAG_INSTANCE_PDO;
                        pwrg->InstanceCount = 1;
                    }
                    
                }
                CopyMemory(&pwrg->Guid, &pndisguid->Guid, sizeof(GUID));
            }

            pwri->RegistryPath = 0;
            pwri->MofResourceName = 0;
            Status = STATUS_SUCCESS;
        }
        else
        {
            DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_INFO,
                ("ndisWmiRegister: Unsupported registration type\n"));

            Status = STATUS_INVALID_PARAMETER;
            break;
        }
    } while (FALSE);

    DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_INFO,
        ("<==ndisWmiRegister\n"));

    return(Status);
}

NTSTATUS
ndisWmiGetGuid(
    OUT PNDIS_GUID              *ppNdisGuid,
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  LPGUID                  guid,
    IN  NDIS_STATUS             status
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    UINT        c;
    PNDIS_GUID  pNdisGuid;
    NDIS_STATUS RetStatus = NDIS_STATUS_FAILURE;

    //
    //  Search the custom GUIDs
    //
    if (NULL != Miniport->pNdisGuidMap)
    {
        for (c = 0, pNdisGuid = Miniport->pNdisGuidMap;
             (c < Miniport->cNdisGuidMap);
             c++, pNdisGuid++)
        {
            //
            //  Make sure that we have a supported GUID and the GUID maps
            //  to an OID.
            //
            if (NULL != guid)
            {
                //
                //  We are to look for a guid to oid mapping.
                //
                if (NdisEqualMemory(&pNdisGuid->Guid, guid, sizeof(GUID)))
                {
                    //
                    //  We found the GUID, save the OID that we will need to
                    //  send to the miniport.
                    //
                    RetStatus = NDIS_STATUS_SUCCESS;
                    *ppNdisGuid = pNdisGuid;
    
                    break;
                }
            }
            else
            {
                //
                //  We need to find the guid for the status indication
                //
                if (NDIS_GUID_TEST_FLAG(pNdisGuid, fNDIS_GUID_TO_STATUS) &&
                    (pNdisGuid->Status == status))
                {
                    RetStatus = NDIS_STATUS_SUCCESS;
                    *ppNdisGuid = pNdisGuid;

                    break;
                }
            }
        }
    }

    return(RetStatus);
}

NTSTATUS
ndisQueryGuidDataSize(
    OUT PULONG                  pBytesNeeded,
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  PNDIS_CO_VC_PTR_BLOCK   pVcBlock    OPTIONAL,
    IN  LPGUID                  guid
    )
/*++

Routine Description:

    This routine will determine the amount of buffer space needed for
    the GUID's data.

Arguments:

                                    
    pBytesNeeded    -   Pointer to storage for the size needed.
    Miniport        -   Pointer to the miniport block.
    guid            -   GUID to query.

Return Value:

--*/
{
    NTSTATUS        NtStatus;
    NDIS_STATUS     Status;
    PNDIS_GUID      pNdisGuid;
    NDIS_REQUEST    Request;
    ULONG           GuidDataSize;

    DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_INFO,
        ("==>ndisQueryGuidDataSize\n"));

    do
    {
        //
        //  Make sure that we support the guid that was passed, and find
        //  the corresponding OID.
        //
        NtStatus = ndisWmiGetGuid(&pNdisGuid, Miniport, guid, 0);
        if (!NT_SUCCESS(NtStatus))
        {
            DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_ERR,
                ("ndisQueryGuidDataSize: Unsupported GUID\n"));

            NtStatus = STATUS_INVALID_PARAMETER;

            break;
        }

        //
        //  Check for an ndis only guid
        //
        if (NDIS_GUID_TEST_FLAG(pNdisGuid, fNDIS_GUID_NDIS_ONLY))
        {
            NtStatus = STATUS_SUCCESS;

            //
            //  The following GUIDs all return the same data.
            //
            if (NdisEqualMemory(&pNdisGuid->Guid, (PVOID)&GUID_NDIS_ENUMERATE_ADAPTER, sizeof(GUID)))
            {
                //
                //  Length of string and the string data.
                //
                *pBytesNeeded = Miniport->MiniportName.Length + sizeof(USHORT);
            }
            else if (NdisEqualMemory(&pNdisGuid->Guid, (PVOID)&GUID_POWER_DEVICE_ENABLE, sizeof(GUID)))
            {
                *pBytesNeeded = sizeof(BOOLEAN);
            }
            else if (NdisEqualMemory(&pNdisGuid->Guid, (PVOID)&GUID_POWER_DEVICE_WAKE_ENABLE, sizeof(GUID)))
            {
                *pBytesNeeded = sizeof(BOOLEAN);
            }
            else if (NdisEqualMemory(&pNdisGuid->Guid, (PVOID)&GUID_NDIS_WAKE_ON_MAGIC_PACKET_ONLY, sizeof(GUID)))
            {
                *pBytesNeeded = sizeof(BOOLEAN);
            }
            else if ((NULL != pVcBlock) && NdisEqualMemory(&pNdisGuid->Guid, (PVOID)&GUID_NDIS_ENUMERATE_VC, sizeof(GUID)))
            {
                //
                //  There is not data for this VC. It's simply used to enumerate VCs on a miniport.
                //
                *pBytesNeeded = 0;
            }
            else
            {
                //
                //  Unknown guid is being queried...
                //
                NtStatus = STATUS_INVALID_PARAMETER;
            }

            break;
        }

        //
        //  Is this a GUID to OID mapping?
        //
        if (!NDIS_GUID_TEST_FLAG(pNdisGuid, fNDIS_GUID_TO_OID))
        {
            NtStatus = STATUS_INVALID_DEVICE_REQUEST;
            break;
        }

        //
        //  Do we need to query the OID for the size of the data?
        //
        if (NDIS_GUID_TEST_FLAG(pNdisGuid, fNDIS_GUID_ARRAY) ||
            NDIS_GUID_TEST_FLAG(pNdisGuid, fNDIS_GUID_UNICODE_STRING) ||
            NDIS_GUID_TEST_FLAG(pNdisGuid, fNDIS_GUID_ANSI_STRING) ||
            (pNdisGuid->Size == (ULONG)-1))
        {
            //
            //  Query the miniport for the current size of the variable length block.
            //
            INIT_INTERNAL_REQUEST(&Request, pNdisGuid->Oid, NdisRequestQueryStatistics, NULL, 0);
            Status = ndisQuerySetMiniport(Miniport,
                                          pVcBlock,
                                          FALSE,
                                          &Request,
                                          NULL);

            //
            //  Make sure that the miniport failed the above request with
            //  the correct error code and that the BytesNeeded is valid.
            //
            if ((NDIS_STATUS_INVALID_LENGTH != Status) &&
                (NDIS_STATUS_BUFFER_TOO_SHORT != Status) &&
                (NDIS_STATUS_SUCCESS != Status))
            {
                DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_ERR,
                    ("ndisQueryGuidDataSize: Failed to query driver OID: 0x%x\n", Status));

                MAP_NDIS_STATUS_TO_NT_STATUS(Status, &NtStatus);
                break;
            }

            GuidDataSize = Request.DATA.QUERY_INFORMATION.BytesNeeded;
            if (NDIS_GUID_TEST_FLAG(pNdisGuid, fNDIS_GUID_ANSI_STRING))
            {
                //
                //  The size returned is the number of ansi characters. Convert this
                //  to the unicode string size needed
                //
                GuidDataSize = GuidDataSize * sizeof(WCHAR);
                GuidDataSize += sizeof(USHORT);
            }
            else if (NDIS_GUID_TEST_FLAG(pNdisGuid, fNDIS_GUID_UNICODE_STRING))
            {
                //
                //  string data has a USHORT for the size.
                //
                GuidDataSize += sizeof(USHORT);
            }
            else if (NDIS_GUID_TEST_FLAG(pNdisGuid, fNDIS_GUID_ARRAY))
            {
                //
                //  The data is going to have a ULONG of size information at the
                //  start of the buffer.
                //
                GuidDataSize += sizeof(ULONG);
            }
        }
        else
        {
            GuidDataSize = pNdisGuid->Size;
        }

        //
        //  Return the bytes needed.
        //
        *pBytesNeeded = GuidDataSize;

        NtStatus = STATUS_SUCCESS;

    } while (FALSE);

    DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_INFO,
        ("<==ndisQueryGuidDataSize\n"));

    return(NtStatus);
}

NTSTATUS
ndisQueryGuidData(
    IN  PUCHAR                  Buffer,
    IN  ULONG                   BufferLength,
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  PNDIS_CO_VC_PTR_BLOCK   pVcBlock,
    IN  LPGUID                  guid,
    IN  PIRP                    Irp
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    NTSTATUS        NtStatus;
    NDIS_STATUS     Status;
    PNDIS_GUID      pNdisGuid;
    NDIS_REQUEST    Request;
    ANSI_STRING     strAnsi = {0};
    UNICODE_STRING  strUnicode = {0};
    ULONG           QuerySize;
    PUCHAR          QueryBuffer;

    DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_INFO,
        ("==>ndisQueryGuidData\n"));

    do
    {
        //
        //  If the buffer length is equal to 0 then there is no data to query.
        //
        if (0 == BufferLength)
        {
            NtStatus = STATUS_SUCCESS;
            break;
        }

        ZeroMemory(Buffer, BufferLength);

        //
        //  Make sure that we support the guid that was passed, and find
        //  the corresponding OID.
        //
        NtStatus = ndisWmiGetGuid(&pNdisGuid, Miniport, guid, 0);
        if (!NT_SUCCESS(NtStatus))
        {
            DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_ERR,
                ("ndisQueryGuidData: Unsupported GUID\n"));

            NtStatus = STATUS_INVALID_PARAMETER;
            break;
        }

        if (!ndisWmiCheckAccess(pNdisGuid,
                                fNDIS_GUID_ALLOW_READ,
                                SE_LOAD_DRIVER_PRIVILEGE,
                                Irp))
        {
            NtStatus = STATUS_PRIVILEGE_NOT_HELD;
            break;
        }

        //
        //  Is this an NDIS supported GUID?
        //
        if (NDIS_GUID_TEST_FLAG(pNdisGuid, fNDIS_GUID_NDIS_ONLY))
        {
            NtStatus = STATUS_SUCCESS;

            //
            //  The following GUIDs all return the same data.
            //
            if (NdisEqualMemory(&pNdisGuid->Guid, (PVOID)&GUID_NDIS_ENUMERATE_ADAPTER, sizeof(GUID)))
            {
                *(PUSHORT)Buffer = Miniport->MiniportName.Length;

                NdisMoveMemory(Buffer + sizeof(USHORT),
                               Miniport->MiniportName.Buffer,
                               Miniport->MiniportName.Length);
            }
            else if (NdisEqualMemory(&pNdisGuid->Guid, (PVOID)&GUID_POWER_DEVICE_ENABLE, sizeof(GUID)))
            {
                if (MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_PM_SUPPORTED) && 
                    (!MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_NO_HALT_ON_SUSPEND)))
                {
                    *((PBOOLEAN)Buffer) = MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_DEVICE_POWER_ENABLE);
                }
                else
                {
                    NtStatus = STATUS_INVALID_DEVICE_REQUEST;
                }
                
            }
            else if (NdisEqualMemory(&pNdisGuid->Guid, (PVOID)&GUID_POWER_DEVICE_WAKE_ENABLE, sizeof(GUID)))
            {
                if (MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_PM_SUPPORTED) &&
                    (Miniport->DeviceCaps.SystemWake > PowerSystemWorking))
                {
                    *((PBOOLEAN)Buffer) = MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_DEVICE_POWER_WAKE_ENABLE);
                }
                else
                {
                    NtStatus = STATUS_INVALID_DEVICE_REQUEST;
                }
            }
            else if (NdisEqualMemory(&pNdisGuid->Guid, (PVOID)&GUID_NDIS_WAKE_ON_MAGIC_PACKET_ONLY, sizeof(GUID)))
            {
                //
                // let the user see this only if we can do wake on magic packet
                //
                if (MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_PM_SUPPORTED) &&
                    (Miniport->DeviceCaps.SystemWake > PowerSystemWorking) &&
                    (Miniport->PMCapabilities.WakeUpCapabilities.MinMagicPacketWakeUp != NdisDeviceStateUnspecified) &&
                    !(Miniport->PnPCapabilities & NDIS_DEVICE_DISABLE_WAKE_ON_MAGIC_PACKET))
                    
                {
                    *((PBOOLEAN)Buffer) = (Miniport->PnPCapabilities & NDIS_DEVICE_DISABLE_WAKE_ON_PATTERN_MATCH) ? 
                                            TRUE:
                                            FALSE;
                }
                else
                {
                    NtStatus = STATUS_INVALID_DEVICE_REQUEST;
                }
            }
            else if ((NULL != pVcBlock) && NdisEqualMemory(&pNdisGuid->Guid, (PVOID)&GUID_NDIS_ENUMERATE_VC, sizeof(GUID)))
            {
                //
                //  There is no data for this VC.
                //
                break;
            }
            else
            {   
                //
                //  Unknown guid is being queried...
                //
                NtStatus = STATUS_INVALID_PARAMETER;
            }

            break;
        }

        //
        //  Is this a GUID to OID mapping?
        //
        if (!NDIS_GUID_TEST_FLAG(pNdisGuid, fNDIS_GUID_TO_OID))
        {
            NtStatus = STATUS_INVALID_DEVICE_REQUEST;

            break;
        }

        //
        //  Determine the query size. This will depend upon the type of
        //  data.
        //
        if (NDIS_GUID_TEST_FLAG(pNdisGuid, fNDIS_GUID_ARRAY))
        {
            //
            //  The query size is at least the BufferLength minus the ULONG
            //  used for the count. The query buffer will start after the
            //  ULONG of count informaiton in the buffer.
            //
            QuerySize = BufferLength - sizeof(ULONG);
            QueryBuffer = Buffer + sizeof(ULONG);
        }
        else if (NDIS_GUID_TEST_FLAG(pNdisGuid, fNDIS_GUID_ANSI_STRING) ||
                 NDIS_GUID_TEST_FLAG(pNdisGuid, fNDIS_GUID_UNICODE_STRING))
        {
            //
            //  The query size is at least the BufferLength minus the ULONG
            //  used for the count. The query buffer will start after the
            //  ULONG of count informaiton in the buffer.
            //
            QuerySize = BufferLength - sizeof(USHORT);
            QueryBuffer = Buffer + sizeof(USHORT);

            //
            //  Is this a query for an ANSI string?
            //
            if (NDIS_GUID_TEST_FLAG(pNdisGuid, fNDIS_GUID_ANSI_STRING))
            {
                //
                //  The BufferLength is the number of WCHARS not counting a terminating
                //  NULL.
                //
                QuerySize = (QuerySize / sizeof(WCHAR)) + 1;
            }
        }
        else
        {
            QuerySize = BufferLength;
            QueryBuffer = Buffer;
        }

        //
        //  Query the driver for the actual data.
        //
        INIT_INTERNAL_REQUEST(&Request, pNdisGuid->Oid, NdisRequestQueryStatistics, QueryBuffer, QuerySize);
        Status = ndisQuerySetMiniport(Miniport,
                                      pVcBlock,
                                      FALSE,
                                      &Request,
                                      NULL);
        if (NDIS_STATUS_SUCCESS != Status)
        {
            DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_ERR,
                ("ndisQueryGuidData: Failed to query the value for driver OID: 0x%x\n", Status));

            MAP_NDIS_STATUS_TO_NT_STATUS(Status, &NtStatus);
            break;
        }

        //
        //  If this is an array or string we need to fill in the
        //  count/number.
        //
        NtStatus = STATUS_SUCCESS;
        if (NDIS_GUID_TEST_FLAG(pNdisGuid, fNDIS_GUID_ARRAY))
        {
            //
            //  Determine the number of elements.
            //
            *(PULONG)Buffer = QuerySize / pNdisGuid->Size;
        }
        else if (NDIS_GUID_TEST_FLAG(pNdisGuid, fNDIS_GUID_UNICODE_STRING))
        {
            //
            //  The BytesNeeded contains the number of bytes in the string.
            //
            *(PUSHORT)Buffer = (USHORT)QuerySize;
        }
        else if (NDIS_GUID_TEST_FLAG(pNdisGuid, fNDIS_GUID_ANSI_STRING))
        {
            //
            //  The buffer contains the ASCII string, build an
            //  ANSI string from this.
            //
            RtlInitAnsiString(&strAnsi, QueryBuffer);

            //
            //  Convert the ansi string to unicode.
            //
            NtStatus = RtlAnsiStringToUnicodeString(&strUnicode, &strAnsi, TRUE);
            ASSERT(NT_SUCCESS(NtStatus));
            if (NT_SUCCESS(NtStatus))
            {
                //
                //  Save the length with the string.
                //
                *(PUSHORT)Buffer = strUnicode.Length;
    
                //
                //  Copy the string to the wnode buffer.
                //
                NdisMoveMemory(QueryBuffer, strUnicode.Buffer, strUnicode.Length);
    
                //
                //  Free the buffer allocated for the unicode string.
                //
                RtlFreeUnicodeString(&strUnicode);
            }
        }

    } while (FALSE);

    DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_INFO,
        ("<==ndisQueryGuidData\n"));

    return(NtStatus);
}

NTSTATUS
ndisWmiQueryAllData(
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  LPGUID                  guid,
    IN  PWNODE_ALL_DATA         wnode,
    IN  ULONG                   BufferSize,
    OUT PULONG                  pReturnSize,
    IN  PIRP                    Irp
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    NTSTATUS                NtStatus;
    ULONG                   wnodeSize = ALIGN_8_TYPE(WNODE_ALL_DATA);
    ULONG                   InstanceNameOffsetsSize, InstanceNameSize;
    ULONG                   wnodeTotalSize;
    ULONG                   BytesNeeded;

    DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_INFO,
        ("==>ndisWmiQueryAllData\n"));

    do
    {
        *pReturnSize = 0;

        if (BufferSize < sizeof(WNODE_TOO_SMALL))
        {
            WMI_BUFFER_TOO_SMALL(BufferSize, wnode, sizeof(WNODE_TOO_SMALL), &NtStatus, pReturnSize);
            break;
        }

        //
        //  If the guid is only relavent to the adapter then answer it here.
        //  Is this GUID meant for "adapters" only, i.e. not vc's.
        //
        if (ndisWmiGuidIsAdapterSpecific(guid) ||
            !MINIPORT_TEST_FLAG(Miniport, fMINIPORT_IS_CO))
        {
            ULONG   dataSize;
            PUCHAR  pucTmp;

            //
            //  Determine the buffer size needed for the GUID data.
            //
            NtStatus = ndisQueryGuidDataSize(&BytesNeeded, Miniport, NULL, guid);
            if (!NT_SUCCESS(NtStatus))
            {
                DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_ERR,
                    ("ndisWmiQueryAllData: Unable to determine GUID data size\n"));

                break;
            }

            //
            //  Determine the size of the WNODE that is needed.
            //
            dataSize = ALIGN_UP(BytesNeeded, ULONG);
            InstanceNameOffsetsSize = sizeof(ULONG);
            InstanceNameSize = sizeof(USHORT) + Miniport->pAdapterInstanceName->Length; // comes at the end, no need to pad
            
            wnodeTotalSize = wnodeSize + dataSize + InstanceNameOffsetsSize + InstanceNameSize;
            
            if (BufferSize < wnodeTotalSize)
            {
                WMI_BUFFER_TOO_SMALL(BufferSize, wnode, wnodeTotalSize, &NtStatus, pReturnSize);
                break;
            }

            //
            //  Initialize the wnode.
            //
            KeQuerySystemTime(&wnode->WnodeHeader.TimeStamp);
    
            wnode->WnodeHeader.Flags |= WNODE_FLAG_FIXED_INSTANCE_SIZE;
            wnode->WnodeHeader.BufferSize = wnodeTotalSize;

            wnode->InstanceCount = 1;
            wnode->DataBlockOffset = wnodeSize;
            wnode->OffsetInstanceNameOffsets = wnodeSize + dataSize;
            wnode->FixedInstanceSize = BytesNeeded;

            //
            //  Fill in the data block.
            //
            NtStatus = ndisQueryGuidData((PUCHAR)wnode + wnodeSize,
                                          BytesNeeded,
                                          Miniport,
                                          NULL,
                                          guid,
                                          Irp);
            if (!NT_SUCCESS(NtStatus))
            {
                DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_ERR,
                    ("ndisWmiQueryAllData: Failed to get the GUID data.\n"));
                break;
            }

            *(PULONG)((PUCHAR)wnode + wnode->OffsetInstanceNameOffsets) = wnodeSize + dataSize + InstanceNameOffsetsSize;
            
            //
            //  Get the pointer to where we store the instance name.
            //
            pucTmp = (PUCHAR)((PUCHAR)wnode + wnodeSize + dataSize + InstanceNameOffsetsSize);

            *((PUSHORT)pucTmp) = Miniport->pAdapterInstanceName->Length;
            NdisMoveMemory(pucTmp + sizeof(USHORT),
                           Miniport->pAdapterInstanceName->Buffer,
                           Miniport->pAdapterInstanceName->Length);
            
            NtStatus = STATUS_SUCCESS;
            *pReturnSize = wnode->WnodeHeader.BufferSize;
        }
        else
        {
            ULONG                           cRoughInstanceCount = Miniport->VcCount + 1;
            UINT                            cInstanceCount = 0;
            PUCHAR                          pBuffer;
            ULONG                           OffsetToInstanceNames;
            PLIST_ENTRY                     Link;
            PNDIS_CO_VC_PTR_BLOCK           pVcBlock = NULL;
            POFFSETINSTANCEDATAANDLENGTH    poidl;
            PULONG                          pInstanceNameOffsets;
            ULONG                           OffsetToInstanceInfo;
            BOOLEAN                         OutOfSpace = FALSE;

            //
            //  Initialize common wnode information.
            //
            KeQuerySystemTime(&wnode->WnodeHeader.TimeStamp);

            //
            //  Setup the OFFSETINSTANCEDATAANDLENGTH array.
            //
            poidl = wnode->OffsetInstanceDataAndLength;
            wnode->OffsetInstanceNameOffsets = wnodeSize + ALIGN_UP((sizeof(OFFSETINSTANCEDATAANDLENGTH) * cRoughInstanceCount), ULONG);

            //
            //  Get a pointer to the array of offsets to the instance names.
            //
            pInstanceNameOffsets = (PULONG)((PUCHAR)wnode + wnode->OffsetInstanceNameOffsets);

            //
            //  Get the offset from the wnode where will will start copying the instance
            //  data into.
            //
            OffsetToInstanceInfo = ALIGN_8_LENGTH(wnode->OffsetInstanceNameOffsets + sizeof(ULONG) * cRoughInstanceCount);

            //
            //  Get a pointer to start placing the data.
            //
            pBuffer = (PUCHAR)wnode + OffsetToInstanceInfo;

            //
            //  Check to make sure we have at least this much buffer space in the wnode.
            //
            wnodeTotalSize = OffsetToInstanceInfo;

            //
            //  Start with the miniport.
            //
            NtStatus = ndisQueryGuidDataSize(&BytesNeeded, Miniport, NULL, guid);
            if (NT_SUCCESS(NtStatus))
            {
                //
                //  Make sure we have enough buffer space for the instance name and
                //  the data. If not we still continue since we need to find the total
                //  size
                //
                wnodeTotalSize += ALIGN_8_LENGTH(Miniport->pAdapterInstanceName->Length + sizeof(USHORT)) + 
                                  ALIGN_8_LENGTH(BytesNeeded);

                if (BufferSize >= wnodeTotalSize)
                {
                    ///
                    //
                    //  The instance info contains the instance name followed by the
                    //  data for the item.
                    //
                    ///
    
                    //
                    //  Add the offset to the instance name to the table.
                    //
                    pInstanceNameOffsets[cInstanceCount] = OffsetToInstanceInfo;
    
                    //
                    //  Copy the instance name into the wnode buffer.
                    //
                    *((PUSHORT)pBuffer) = Miniport->pAdapterInstanceName->Length;
    
                    NdisMoveMemory(pBuffer + sizeof(USHORT),
                                   Miniport->pAdapterInstanceName->Buffer,
                                   Miniport->pAdapterInstanceName->Length);
    
                    //
                    //  Keep track of true instance counts.
                    //
                    OffsetToInstanceInfo += ALIGN_8_LENGTH(sizeof(USHORT) + Miniport->pAdapterInstanceName->Length);
                    pBuffer = (PUCHAR)wnode + OffsetToInstanceInfo;
    
                    //
                    //  Query the data for the miniport.
                    //
                    NtStatus = ndisQueryGuidData(pBuffer, BytesNeeded, Miniport, NULL, guid, Irp);
                    if (!NT_SUCCESS(NtStatus))
                    {
                        DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_ERR,
                            ("ndisWmiQueryAllData: Failed to get the GUID data.\n"));
                        break;
                    }
    
    
                    //
                    //  Save the length of the data item for this instance.
                    //
                    poidl[cInstanceCount].OffsetInstanceData = OffsetToInstanceInfo;
                    poidl[cInstanceCount].LengthInstanceData = BytesNeeded;
        
                    //
                    //  Keep track of true instance counts.
                    //
                    OffsetToInstanceInfo += ALIGN_8_LENGTH(BytesNeeded);
                    pBuffer = (PUCHAR)wnode + OffsetToInstanceInfo;
                }

                //
                //  Increment the current instance count.
                //
                cInstanceCount++;
            }
            else
            {
                DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_ERR,
                    ("ndisWmiQueryAllData: Unable to determine GUID data size\n"));

                break;
            }


            //
            //  Only the miniport?
            //
            if (cInstanceCount == cRoughInstanceCount)
            {
                if (BufferSize >= wnodeTotalSize)
                {
                    wnode->WnodeHeader.BufferSize = wnodeTotalSize;
                    wnode->InstanceCount = cInstanceCount;
                    *pReturnSize = wnode->WnodeHeader.BufferSize;
                    NtStatus = STATUS_SUCCESS;
                }
                else
                {
                    WMI_BUFFER_TOO_SMALL(BufferSize, wnode, wnodeTotalSize, &NtStatus, pReturnSize);
                }
                break;
            }

            //
            //  First search the inactive vc list.
            //
            Link = Miniport->WmiEnabledVcs.Flink;
            while (Link != &Miniport->WmiEnabledVcs)
            {
                //
                //  We only have room for so many VCs.
                //
                if (cInstanceCount >= cRoughInstanceCount)
                {
                    break;
                }

                //
                //  Get a pointer to the VC.
                //
                pVcBlock = CONTAINING_RECORD(Link, NDIS_CO_VC_PTR_BLOCK, WmiLink);

                if (!ndisReferenceVcPtr(pVcBlock))
                {
                    Link = Link->Flink;

                    //
                    //  This VC is cleaning up.
                    //
                    continue;
                }

                //
                //  If there is an instance name associated with the VC then we need to query it.
                //
                if (NULL != pVcBlock->VcInstanceName.Buffer)
                {
                    //
                    //  Start with the miniport.
                    //
                    NtStatus = ndisQueryGuidDataSize(&BytesNeeded,
                                                     Miniport,
                                                     pVcBlock,
                                                     guid);
                    if (NT_SUCCESS(NtStatus))
                    {
                        //
                        //  Make sure we have enough buffer space for the instance name and
                        //  the data.
                        //
                        wnodeTotalSize += ALIGN_8_LENGTH(pVcBlock->VcInstanceName.Length + sizeof(USHORT)) +
                                          ALIGN_8_LENGTH(BytesNeeded);
                                          
                        if (BufferSize < wnodeTotalSize)
                        {
                            WMI_BUFFER_TOO_SMALL(BufferSize, wnode, wnodeTotalSize, &NtStatus, pReturnSize);
                            OutOfSpace = TRUE;
                            ndisDereferenceVcPtr(pVcBlock);
                            Link = Link->Flink;
                            continue;
                        }

                        //
                        //  The instance info contains the instance name followed by the
                        //  data for the item.
                        //
        
                        //
                        //  Add the offset to the instance name to the table.
                        //
                        pInstanceNameOffsets[cInstanceCount] = OffsetToInstanceInfo;
        
                        //
                        //  Copy the instance name into the wnode buffer.
                        //
                        *((PUSHORT)pBuffer) = pVcBlock->VcInstanceName.Length;
        
                        NdisMoveMemory(pBuffer + sizeof(USHORT),
                                       pVcBlock->VcInstanceName.Buffer,
                                       pVcBlock->VcInstanceName.Length);
        
                        //
                        //  Keep track of true instance counts.
                        //
                        OffsetToInstanceInfo += ALIGN_8_LENGTH(sizeof(USHORT) + pVcBlock->VcInstanceName.Length);
                        pBuffer = (PUCHAR)wnode + OffsetToInstanceInfo;
        
                        //
                        //  Query the data for the miniport.
                        //
                        NtStatus = ndisQueryGuidData(pBuffer,
                                                     BytesNeeded,
                                                     Miniport,
                                                     pVcBlock,
                                                     guid,
                                                     Irp);
                        if (!NT_SUCCESS(NtStatus))
                        {
                            DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_ERR,
                                ("ndisWmiQueryAllData: Failed to query GUID data\n"));
                            ndisDereferenceVcPtr(pVcBlock);
                            break;
                        }
        
                        //
                        //  Save the length of the data item for this instance.
                        //
                        poidl[cInstanceCount].OffsetInstanceData = OffsetToInstanceInfo;
                        poidl[cInstanceCount].LengthInstanceData = BytesNeeded;
            
                        //
                        //  Keep track of true instance counts.
                        //
                        OffsetToInstanceInfo += ALIGN_8_LENGTH(BytesNeeded);
                        pBuffer = (PUCHAR)wnode + OffsetToInstanceInfo;
        
                        //
                        //  Increment the current instance count.
                        //
                        cInstanceCount++;
                    }
                }

                ndisDereferenceVcPtr(pVcBlock);
                Link = Link->Flink;
            }

            if (!OutOfSpace)
            {
                wnode->WnodeHeader.BufferSize = wnodeTotalSize;
                wnode->InstanceCount = cInstanceCount;
    
                //
                //  Set the status to success.
                //
                NtStatus = STATUS_SUCCESS;
                *pReturnSize = wnode->WnodeHeader.BufferSize;
            }
        }
    } while (FALSE);

    DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_INFO,
        ("<==ndisWmiQueryAllData\n"));

    return(NtStatus);
}


NTSTATUS
ndisWmiQuerySingleInstance(
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  PWNODE_SINGLE_INSTANCE  wnode,
    IN  ULONG                   BufferSize,
    OUT PULONG                  pReturnSize,
    IN  PIRP                    Irp
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    NTSTATUS                NtStatus;
    ULONG                   BytesNeeded;
    ULONG                   wnodeSize;
    USHORT                  cbInstanceName;
    PWSTR                   pInstanceName;
    PNDIS_CO_VC_PTR_BLOCK   pVcBlock = NULL;

    DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_INFO,
        ("==>ndisWmiQuerySingleInstance\n"));

    do
    {
        *pReturnSize = 0;

        if (wnode->WnodeHeader.Flags & WNODE_FLAG_STATIC_INSTANCE_NAMES)
        {
            //
            // This is a static instance name
            //
            pVcBlock = NULL;
        }
        else
        {
            //
            //  Determine if this is for a VC or a miniport...
            //
            
            cbInstanceName = *(PUSHORT)((PUCHAR)wnode + wnode->OffsetInstanceName);
            pInstanceName = (PWSTR)((PUCHAR)wnode + wnode->OffsetInstanceName + sizeof(USHORT));
 
            //
            //  This routine will determine if the wnode's instance name is a miniport or VC.
            //  If it's a VC then it will find which one.
            //  
            NtStatus = ndisWmiFindInstanceName(&pVcBlock, Miniport, pInstanceName, cbInstanceName);
            if (!NT_SUCCESS(NtStatus))
            {
                DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_ERR,
                    ("ndisWmiQuerySingleInstance: Unable to find the instance name\n"));

                pVcBlock = NULL;
                break;
            }
        }

        //
        //  Determine the buffer size needed for the GUID data.
        //
        NtStatus = ndisQueryGuidDataSize(&BytesNeeded,
                                         Miniport,
                                         pVcBlock,
                                         &wnode->WnodeHeader.Guid);
        if (!NT_SUCCESS(NtStatus))
        {
            DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_ERR,
                ("ndisWmiQuerySingleInstance: Unable to determine GUID data size\n"));
            break;
        }

        //
        //  Determine the size of the wnode.
        //
        wnodeSize = wnode->DataBlockOffset + BytesNeeded;
        if (BufferSize < wnodeSize)
        {
            WMI_BUFFER_TOO_SMALL(BufferSize, wnode, wnodeSize, &NtStatus, pReturnSize);
            break;
        }

        //
        //  Initialize the wnode.
        //
        KeQuerySystemTime(&wnode->WnodeHeader.TimeStamp);
        wnode->WnodeHeader.BufferSize = wnodeSize;
        wnode->SizeDataBlock = BytesNeeded;

        //
        //  Validate the guid and get the data for it.
        //
        NtStatus = ndisQueryGuidData((PUCHAR)wnode + wnode->DataBlockOffset,
                                     BytesNeeded,
                                     Miniport,
                                     pVcBlock,
                                     &wnode->WnodeHeader.Guid,
                                     Irp);
        if (!NT_SUCCESS(NtStatus))
        {
            DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_ERR,
                ("ndisWmiQuerySingleInstance: Failed to get the GUID data.\n"));
            break;
        }

        *pReturnSize = wnodeSize;
        NtStatus = STATUS_SUCCESS;

    } while (FALSE);

    //
    //  If this was a VC then we need to dereference it.
    //
    if (NULL != pVcBlock)
    {
        ndisDereferenceVcPtr(pVcBlock);
    }

    DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_INFO,
        ("<==ndisWmiQuerySingleInstance\n"));

    return(NtStatus);
}


NTSTATUS
ndisWmiChangeSingleInstance(
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  PWNODE_SINGLE_INSTANCE  wnode,
    IN  ULONG                   BufferSize,
    OUT PULONG                  pReturnSize,
    IN  PIRP                    Irp
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    NTSTATUS                NtStatus;
    NDIS_STATUS             Status;
    PNDIS_GUID              pNdisGuid;
    PUCHAR                  pGuidData;
    ULONG                   GuidDataSize;
    NDIS_REQUEST            Request;
    USHORT                  cbInstanceName;
    PWSTR                   pInstanceName;
    PNDIS_CO_VC_PTR_BLOCK   pVcBlock = NULL;

    DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_INFO,
        ("==>ndisWmiChangeSingleInstance\n"));

    do
    {
        if (wnode->WnodeHeader.Flags & WNODE_FLAG_STATIC_INSTANCE_NAMES)
        {
            //
            // This is a static instance name
            //
            pVcBlock = NULL;
        }
        else
        {
            //
            //  Determine if this is for a VC or a miniport...
            //
            cbInstanceName = *(PUSHORT)((PUCHAR)wnode + wnode->OffsetInstanceName);
            pInstanceName = (PWSTR)((PUCHAR)wnode + wnode->OffsetInstanceName + sizeof(USHORT));

            //
            //  This routine will determine if the wnode's instance name is a miniport or VC.
            //  If it's a VC then it will find which one.
            //  
            NtStatus = ndisWmiFindInstanceName(&pVcBlock, Miniport, pInstanceName, cbInstanceName);
            if (!NT_SUCCESS(NtStatus))
            {
                DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_ERR,
                    ("ndisWmiChangeSingleInstance: Unable to find the instance name\n"));

                pVcBlock = NULL;

                break;
            }
        }

        //
        //  Make sure that we support the guid that was passed, and find
        //  the corresponding OID.
        //
        NtStatus = ndisWmiGetGuid(&pNdisGuid,
                                  Miniport,
                                  &wnode->WnodeHeader.Guid,
                                  0);
        if (!NT_SUCCESS(NtStatus))
        {
            DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_ERR,
                ("ndisWmiChangeSingleInstance: Unsupported GUID\n"));

            NtStatus = STATUS_INVALID_PARAMETER;
            break;
        }
        
        if (!ndisWmiCheckAccess(pNdisGuid,
                                fNDIS_GUID_ALLOW_WRITE,
                                SE_LOAD_DRIVER_PRIVILEGE,
                                Irp))
        {
            NtStatus = STATUS_PRIVILEGE_NOT_HELD;
            break;
        }

        //
        //  Is this guid settable?
        //
        if (NDIS_GUID_TEST_FLAG(pNdisGuid, fNDIS_GUID_NOT_SETTABLE))
        {
            DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_ERR,
                ("ndisWmiChangeSingleInstance: Guid is not settable!\n"));

            NtStatus = STATUS_NOT_SUPPORTED;
            break;
        }

        //
        //  Get a pointer to the GUID data and size.
        //
        GuidDataSize = wnode->SizeDataBlock;
        pGuidData = (PUCHAR)wnode + wnode->DataBlockOffset;

        if (GuidDataSize == 0)
        {
            DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_ERR,
                ("ndisWmiChangeSingleInstance: Guid has not data to set!\n"));

            NtStatus = STATUS_INVALID_PARAMETER;
            break;
        }

        //
        //  Is this an internal ndis guid?  
        //
        if ((NULL == pVcBlock) && NDIS_GUID_TEST_FLAG(pNdisGuid, fNDIS_GUID_NDIS_ONLY))
        {
            PBOOLEAN    pBoolean = (PBOOLEAN)pGuidData;

            NtStatus = STATUS_SUCCESS;

            //
            // for PM set guids, we should update registry for future boots
            //
            //
            if (NdisEqualMemory(&pNdisGuid->Guid, (PVOID)&GUID_POWER_DEVICE_ENABLE, sizeof(GUID)))
            {
                if (MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_PM_SUPPORTED) && 
                    (!MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_NO_HALT_ON_SUSPEND)))

                {
                    if (*pBoolean)
                    {
                        MINIPORT_PNP_SET_FLAG(Miniport, fMINIPORT_DEVICE_POWER_ENABLE);
                        //
                        // enabling power management also enables wake on link change
                        // assuming the adapter supports it
                        //
                        if ((Miniport->PMCapabilities.WakeUpCapabilities.MinLinkChangeWakeUp != NdisDeviceStateUnspecified) &&
                            (Miniport->MediaDisconnectTimeOut != (USHORT)(-1)))
                        {
                            Miniport->WakeUpEnable |= NDIS_PNP_WAKE_UP_LINK_CHANGE;
                        }

                        Miniport->PnPCapabilities &= ~NDIS_DEVICE_DISABLE_PM;
                    }
                    else
                    {
                        //
                        // disabling power management also disables wake on link and magic packet
                        //
                        Miniport->WakeUpEnable &= ~NDIS_PNP_WAKE_UP_LINK_CHANGE;
                    
                        MINIPORT_PNP_CLEAR_FLAG(Miniport, fMINIPORT_DEVICE_POWER_ENABLE);
                        Miniport->PnPCapabilities |= (NDIS_DEVICE_DISABLE_PM | 
                                                      NDIS_DEVICE_DISABLE_WAKE_UP);
                    }
                    
                }
                else
                {
                    NtStatus = STATUS_INVALID_DEVICE_REQUEST;
                }
            }
            else if (NdisEqualMemory(&pNdisGuid->Guid, (PVOID)&GUID_POWER_DEVICE_WAKE_ENABLE, sizeof(GUID)))
            {
                if (MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_PM_SUPPORTED) &&
                    (Miniport->DeviceCaps.SystemWake > PowerSystemWorking))
                {
                    if (*pBoolean)
                    {
                        MINIPORT_PNP_SET_FLAG(Miniport, fMINIPORT_DEVICE_POWER_WAKE_ENABLE);
                        Miniport->PnPCapabilities &= ~NDIS_DEVICE_DISABLE_WAKE_UP;
                        //
                        // enableing Wake on Lan enables wake on Magic Packet method
                        // assuming the miniport supports it and it is not disabled in the registry
                        //
                        if ((Miniport->PMCapabilities.WakeUpCapabilities.MinMagicPacketWakeUp != NdisDeviceStateUnspecified) &&
                            !(Miniport->PnPCapabilities & NDIS_DEVICE_DISABLE_WAKE_ON_MAGIC_PACKET))
                        {
                            Miniport->WakeUpEnable |= NDIS_PNP_WAKE_UP_MAGIC_PACKET;
                        }
                        
                    }
                    else
                    {
                        MINIPORT_PNP_CLEAR_FLAG(Miniport, fMINIPORT_DEVICE_POWER_WAKE_ENABLE);
                        //
                        // disabling Wake On Lan also disables wake on Magic Packet method
                        //
                        Miniport->WakeUpEnable &= ~NDIS_PNP_WAKE_UP_MAGIC_PACKET;
                        Miniport->PnPCapabilities |= NDIS_DEVICE_DISABLE_WAKE_UP;
                    }
                }
                else
                {
                    NtStatus = STATUS_INVALID_DEVICE_REQUEST;
                }
            }
            else if (NdisEqualMemory(&pNdisGuid->Guid, (PVOID)&GUID_NDIS_WAKE_ON_MAGIC_PACKET_ONLY, sizeof(GUID)))
            {
                //
                // let the user set this only if we can do wake on magic packet
                //
                if (MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_PM_SUPPORTED) &&
                    (Miniport->DeviceCaps.SystemWake > PowerSystemWorking) &&
                    (Miniport->PMCapabilities.WakeUpCapabilities.MinMagicPacketWakeUp != NdisDeviceStateUnspecified) &&
                            !(Miniport->PnPCapabilities & NDIS_DEVICE_DISABLE_WAKE_ON_MAGIC_PACKET))
                {
                    if (*pBoolean)
                    {
                        //
                        // user does -not- want to wake on pattern match
                        //
                        Miniport->PnPCapabilities |= NDIS_DEVICE_DISABLE_WAKE_ON_PATTERN_MATCH;
                    }
                    else
                    {
                        Miniport->PnPCapabilities &= ~NDIS_DEVICE_DISABLE_WAKE_ON_PATTERN_MATCH;
                    }
                }
                else
                {
                    NtStatus = STATUS_INVALID_DEVICE_REQUEST;
                }               
            }
            else
            {
                DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_ERR,
                    ("ndisWmiChangeSingleInstance: Invalid NDIS internal GUID!\n"));

                NtStatus = STATUS_INVALID_DEVICE_REQUEST;
            }
            
            if (NT_SUCCESS(NtStatus))
            {
                if (MINIPORT_PNP_TEST_FLAGS(Miniport, fMINIPORT_DEVICE_POWER_ENABLE | 
                                                      fMINIPORT_DEVICE_POWER_WAKE_ENABLE))
                {
                    //
                    // power management and wol has been enabled by the user
                    // check to see what we should tell protocols about the new 
                    // WOL capabilities of the device
                    // NOTE: set NDIS_DEVICE_WAKE_UP_ENABLE only if pattern match is enabled
                    //
                    if (Miniport->PnPCapabilities & NDIS_DEVICE_DISABLE_WAKE_ON_PATTERN_MATCH)
                        Miniport->PMCapabilities.Flags &= ~(NDIS_DEVICE_WAKE_UP_ENABLE | 
                                                            NDIS_DEVICE_WAKE_ON_PATTERN_MATCH_ENABLE);
                    else
                        //
                        // user did not disable wake on pattern match, for protocol's purpose
                        // wol is enabled
                        //
                        Miniport->PMCapabilities.Flags |= NDIS_DEVICE_WAKE_UP_ENABLE | 
                                                          NDIS_DEVICE_WAKE_ON_PATTERN_MATCH_ENABLE;
                        
                    if (Miniport->PnPCapabilities & NDIS_DEVICE_DISABLE_WAKE_ON_MAGIC_PACKET)
                        Miniport->PMCapabilities.Flags &= ~NDIS_DEVICE_WAKE_ON_MAGIC_PACKET_ENABLE;
                    else
                        //
                        // user did not disable wake on magic packet, do -not- set the NDIS_DEVICE_WAKE_UP_ENABLE
                        // bit becasue wake on pattern match may not be enabled
                        //
                        Miniport->PMCapabilities.Flags |= NDIS_DEVICE_WAKE_ON_MAGIC_PACKET_ENABLE;
                }
                else
                    Miniport->PMCapabilities.Flags &= ~(NDIS_DEVICE_WAKE_UP_ENABLE | 
                                                        NDIS_DEVICE_WAKE_ON_PATTERN_MATCH_ENABLE |
                                                        NDIS_DEVICE_WAKE_ON_MAGIC_PACKET_ENABLE);
                    
                ndisWritePnPCapabilities(Miniport, Miniport->PnPCapabilities);
                ndisPnPNotifyAllTransports(Miniport,
                                           NetEventPnPCapabilities,
                                           &Miniport->PMCapabilities.Flags,
                                           sizeof(ULONG));

            }
            
            break;
        }

        //
        //  Make sure it's not a stauts indication.
        //
        if (!NDIS_GUID_TEST_FLAG(pNdisGuid, fNDIS_GUID_TO_OID))
        {
            DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_ERR,
                ("ndisWmiChangeSingleInstance: Guid does not translate to an OID\n"));

            NtStatus = STATUS_INVALID_DEVICE_REQUEST;
            break;
        }

        //
        //  Attempt to set the miniport with the information.
        //
        INIT_INTERNAL_REQUEST(&Request, pNdisGuid->Oid, NdisRequestSetInformation, pGuidData, GuidDataSize);
        Status = ndisQuerySetMiniport(Miniport,
                                      pVcBlock,
                                      TRUE,
                                      &Request,
                                      NULL);

        if (NDIS_STATUS_SUCCESS != Status)
        {
            DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_ERR,
                ("ndisWmiChangeSingleInstance: Failed to set the new information on the miniport\n"));

            MAP_NDIS_STATUS_TO_NT_STATUS(Status, &NtStatus);

            break;
        }

        NtStatus = STATUS_SUCCESS;

    } while (FALSE);

    //
    //  If this was a VC then we need to dereference it.
    //
    if (NULL != pVcBlock)
    {
        ndisDereferenceVcPtr(pVcBlock);
    }

    DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_INFO,
        ("<==ndisWmiChangeSingleInstance\n"));

    return(NtStatus);
}


NTSTATUS
ndisWmiChangeSingleItem(
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  PWNODE_SINGLE_ITEM      wnode,
    IN  ULONG                   BufferSize,
    OUT PULONG                  pReturnSize,
    IN  PIRP                    Irp
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_INFO,
        ("==>ndisWmiChangeSingleItem\n"));

    DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_INFO,
        ("<==ndisWmiChangeSingleItem: Not Supported\n"));

    return(STATUS_NOT_SUPPORTED);
}


NTSTATUS
FASTCALL
ndisWmiEnableEvents(
    IN  PNDIS_MINIPORT_BLOCK        Miniport,
    IN  LPGUID                      Guid
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    NDIS_STATUS Status;
    PNDIS_GUID  pNdisGuid = NULL;

    DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_INFO,
        ("==>ndisWmiEnableEvents\n"));

    do
    {

        //
        //  Get a pointer to the Guid/Status to enable.
        //
        Status = ndisWmiGetGuid(&pNdisGuid, Miniport, Guid, 0);
        
        if (NdisEqualMemory(Guid, (PVOID)&GUID_NDIS_NOTIFY_BIND, sizeof(GUID)) ||
            NdisEqualMemory(Guid, (PVOID)&GUID_NDIS_NOTIFY_UNBIND, sizeof(GUID)) ||
            NdisEqualMemory(Guid, (PVOID)&GUID_NDIS_NOTIFY_DEVICE_POWER_ON, sizeof(GUID)) ||
            NdisEqualMemory(Guid, (PVOID)&GUID_NDIS_NOTIFY_DEVICE_POWER_OFF, sizeof(GUID)) ||
            NdisEqualMemory(Guid, (PVOID)&GUID_NDIS_NOTIFY_ADAPTER_ARRIVAL, sizeof(GUID)) ||
            NdisEqualMemory(Guid, (PVOID)&GUID_NDIS_NOTIFY_ADAPTER_REMOVAL, sizeof(GUID)))
        {
            if (pNdisGuid)
            {
                NDIS_GUID_SET_FLAG(pNdisGuid, fNDIS_GUID_EVENT_ENABLED);
            }
            Status = STATUS_SUCCESS;
            break;
        }

        if (!NT_SUCCESS(Status))
        {
            DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_ERR,
                ("ndisWmiEnableEvents: Cannot find the guid to enable an event\n"));
    
            Status = STATUS_INVALID_PARAMETER;
            break;
        }

        //
        //  Is this GUID an event indication?
        //
        if (!NDIS_GUID_TEST_FLAG(pNdisGuid, fNDIS_GUID_TO_STATUS))
        {
            Status = STATUS_INVALID_DEVICE_REQUEST;
            break;
        }

        //
        //  Mark the guid as enabled
        //
        NDIS_GUID_SET_FLAG(pNdisGuid, fNDIS_GUID_EVENT_ENABLED);
        Status = STATUS_SUCCESS;
    
    } while (FALSE);

    DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_INFO,
        ("<==ndisWmiEnableEvents\n"));

    return(Status);
}

NTSTATUS
FASTCALL
ndisWmiDisableEvents(
    IN  PNDIS_MINIPORT_BLOCK        Miniport,
    IN  LPGUID                      Guid
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    NDIS_STATUS Status;
    PNDIS_GUID  pNdisGuid;

    DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_INFO,
        ("==>ndisWmiDisableEvents\n"));

    do
    {
        //
        //  Get a pointer to the Guid/Status to enable.
        //
        Status = ndisWmiGetGuid(&pNdisGuid, Miniport, Guid, 0);
        if (!NT_SUCCESS(Status))
        {
            DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_ERR,
                ("ndisWmiDisableEvents: Cannot find the guid to enable an event\n"));
    
            Status = STATUS_INVALID_PARAMETER;
            break;
        }

        //
        //  Is this GUID an event indication?
        //
        if (!NDIS_GUID_TEST_FLAG(pNdisGuid, fNDIS_GUID_TO_STATUS))
        {
            Status = STATUS_INVALID_DEVICE_REQUEST;
            break;
        }

        //
        //  Mark the guid as enabled
        //
        NDIS_GUID_CLEAR_FLAG(pNdisGuid, fNDIS_GUID_EVENT_ENABLED);
    
        Status = STATUS_SUCCESS;

    } while (FALSE);

    DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_INFO,
        ("<==ndisWmiDisableEvents\n"));

    return(Status);
}


NTSTATUS
ndisWMIDispatch(
    IN  PDEVICE_OBJECT  DeviceObject,
    IN  PIRP            pirp
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PIO_STACK_LOCATION      pirpSp = IoGetCurrentIrpStackLocation(pirp);
    PVOID                   DataPath = pirpSp->Parameters.WMI.DataPath;
    ULONG                   BufferSize = pirpSp->Parameters.WMI.BufferSize;
    PVOID                   Buffer = pirpSp->Parameters.WMI.Buffer;
    NTSTATUS                Status;
    ULONG                   ReturnSize = 0;
    PNDIS_MINIPORT_BLOCK    Miniport;

    DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_INFO,
        ("==>ndisWMIDispatch\n"));

    //
    //  Get a pointer to miniport block
    //
    Miniport = (PNDIS_MINIPORT_BLOCK)((PNDIS_WRAPPER_CONTEXT)DeviceObject->DeviceExtension + 1);
    try
    {
        if (Miniport->Signature != (PVOID)MINIPORT_DEVICE_MAGIC_VALUE)
        {
            //
            // This is not a miniport. Likely a device created by the driver. Try dispatching to it.
            //
            return(ndisDummyIrpHandler(DeviceObject, pirp));
        }
    }
    except(EXCEPTION_EXECUTE_HANDLER)
    {
        return(STATUS_ACCESS_VIOLATION);
    }

    //
    //  If the provider ID is not us then pass it down the stack.
    //
    if (pirpSp->Parameters.WMI.ProviderId != (ULONG_PTR)DeviceObject)
    {
        IoSkipCurrentIrpStackLocation(pirp);
        Status = IoCallDriver(Miniport->NextDeviceObject, pirp);

        return(Status);
    }

    switch (pirpSp->MinorFunction)
    {
        case IRP_MN_REGINFO:

            DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_INFO,
                ("ndisWMIDispatch: IRP_MN_REGINFO\n"));

            Status = ndisWmiRegister(Miniport,
                                     (ULONG_PTR)DataPath,
                                     Buffer,
                                     BufferSize,
                                     &ReturnSize);
            break;

        case IRP_MN_QUERY_ALL_DATA:

            DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_INFO,
                ("ndisWMIDispatch: IRP_MN_QUERY_ALL_DATA\n"));

            Status = ndisWmiQueryAllData(Miniport,
                                         (LPGUID)DataPath,
                                         (PWNODE_ALL_DATA)Buffer,
                                         BufferSize,
                                         &ReturnSize,
                                         pirp);
            break;

        case IRP_MN_QUERY_SINGLE_INSTANCE:

            DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_INFO,
                ("ndisWMIDispatch: IRP_MN_QUERY_SINGLE_INSTANCE\n"));

            Status = ndisWmiQuerySingleInstance(Miniport,
                                                Buffer,
                                                BufferSize,
                                                &ReturnSize,
                                                pirp);
            break;

        case IRP_MN_CHANGE_SINGLE_INSTANCE:

            DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_INFO,
                ("ndisWMIDispatch: IRP_MN_CHANGE_SINGLE_INSTANCE\n"));

            Status = ndisWmiChangeSingleInstance(Miniport,
                                                 Buffer,
                                                 BufferSize,
                                                 &ReturnSize,
                                                 pirp);
            break;

        case IRP_MN_CHANGE_SINGLE_ITEM:

            DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_INFO,
                ("ndisWMIDispatch: IRP_MN_CHANGE_SINGLE_ITEM\n"));

            Status = ndisWmiChangeSingleItem(Miniport,
                                             Buffer,
                                             BufferSize,
                                             &ReturnSize,
                                             pirp);
            break;

        case IRP_MN_ENABLE_EVENTS:

            DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_INFO,
                ("ndisWMIDispatch: IRP_MN_ENABLE_EVENTS\n"));

            Status = ndisWmiEnableEvents(Miniport, (LPGUID)DataPath);   
            break;

        case IRP_MN_DISABLE_EVENTS:

            DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_INFO,
                ("ndisWMIDispatch: IRP_MN_DISABLE_EVENTS\n"));

            Status = ndisWmiDisableEvents(Miniport, (LPGUID)DataPath);  
            break;

        case IRP_MN_ENABLE_COLLECTION:

            DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_INFO,
                ("ndisWMIDispatch: IRP_MN_ENABLE_COLLECTION\n"));
            Status = STATUS_NOT_SUPPORTED;
            break;

        case IRP_MN_DISABLE_COLLECTION:

            DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_INFO,
                ("ndisWMIDispatch: IRP_MN_DISABLE_COLLECTION\n"));
            Status = STATUS_NOT_SUPPORTED;
            break;

        default:

            DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_INFO,
                ("ndisWMIDispatch: Invalid minor function (0x%x)\n", pirpSp->MinorFunction));

            Status = STATUS_INVALID_DEVICE_REQUEST;
            break;
    }

    pirp->IoStatus.Status = Status;
    ASSERT(ReturnSize <= BufferSize);

    if (Status == STATUS_BUFFER_TOO_SMALL)
    {
        pirp->IoStatus.Information = ReturnSize;
    }
    else
    {
        pirp->IoStatus.Information = NT_SUCCESS(Status) ? ReturnSize : 0;
    }
    
    IoCompleteRequest(pirp, IO_NO_INCREMENT);

    DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_INFO,
        ("<==ndisWMIDispatch\n"));

    return(Status);
}

VOID
ndisSetupWmiNode(
    IN      PNDIS_MINIPORT_BLOCK        Miniport,
    IN      PUNICODE_STRING             InstanceName,
    IN      ULONG                       DataBlockSize,
    IN      PVOID                       pGuid,
    IN OUT  PWNODE_SINGLE_INSTANCE *    pwnode
    )
    
{
/*
    sets up a wmi node
    the caller will fill in the data block after the call returns
*/

    PWNODE_SINGLE_INSTANCE  wnode;
    ULONG                   wnodeSize;
    ULONG                   wnodeInstanceNameSize;
    NTSTATUS                Status;
    PUCHAR                  ptmp;

    //
    //  Determine the amount of wnode information we need.
    //
    wnodeSize = ALIGN_8_TYPE(WNODE_SINGLE_INSTANCE);
    wnodeInstanceNameSize = ALIGN_8_LENGTH(InstanceName->Length + sizeof(USHORT));              

    wnode = ALLOC_FROM_POOL(wnodeSize + wnodeInstanceNameSize + DataBlockSize,
                            NDIS_TAG_WMI_EVENT_ITEM);
    if (NULL != wnode)
    {
        NdisZeroMemory(wnode, wnodeSize + wnodeInstanceNameSize + DataBlockSize);
        wnode->WnodeHeader.BufferSize = wnodeSize + DataBlockSize + wnodeInstanceNameSize;
        wnode->WnodeHeader.ProviderId = IoWMIDeviceObjectToProviderId(Miniport->DeviceObject);
        wnode->WnodeHeader.Version = 1;
        KeQuerySystemTime(&wnode->WnodeHeader.TimeStamp);

        RtlCopyMemory(&wnode->WnodeHeader.Guid, pGuid, sizeof(GUID));
        wnode->WnodeHeader.Flags = WNODE_FLAG_EVENT_ITEM | WNODE_FLAG_SINGLE_INSTANCE;

        wnode->OffsetInstanceName = wnodeSize;
        wnode->DataBlockOffset = wnodeSize + wnodeInstanceNameSize;
        wnode->SizeDataBlock = DataBlockSize;

        //
        //  Get a pointer to the start of the instance name.
        //
        ptmp = (PUCHAR)wnode + wnodeSize;

        //
        //  Copy in the instance name.
        //
        *((PUSHORT)ptmp) = InstanceName->Length;
        RtlCopyMemory(ptmp + sizeof(USHORT),
                      InstanceName->Buffer,
                      InstanceName->Length);

    }
    
    *pwnode = wnode;

}

BOOLEAN
ndisWmiCheckAccess(
    IN  PNDIS_GUID  pNdisGuid,
    IN  ULONG       DesiredAccess,
    IN  LONG        RequiredPrivilege,
    IN  PIRP        Irp
    )
{
    LUID    Privilege;
    BOOLEAN AccessAllowed = FALSE;

    //
    // SE_LOAD_DRIVER_PRIVILEGE
    //
    
    if ((DesiredAccess & fNDIS_GUID_ALLOW_READ) == fNDIS_GUID_ALLOW_READ)
    {
        if (pNdisGuid->Flags & fNDIS_GUID_ALLOW_READ)
        {
            AccessAllowed = TRUE;
        }
        else
        {
            Privilege = RtlConvertLongToLuid(RequiredPrivilege);
            AccessAllowed = SeSinglePrivilegeCheck(Privilege, Irp->RequestorMode);
        }
    }
    else if ((DesiredAccess & fNDIS_GUID_ALLOW_WRITE) == fNDIS_GUID_ALLOW_WRITE)
    {
        if (pNdisGuid->Flags & fNDIS_GUID_ALLOW_WRITE)
        {
            AccessAllowed = TRUE;
        }
        else
        {
            Privilege = RtlConvertLongToLuid(RequiredPrivilege);
            AccessAllowed = SeSinglePrivilegeCheck(Privilege, Irp->RequestorMode);
        }
    }
    else
    {
#if DBG
        DbgPrint("ndisWmiCheckAccess: DesiredAccess can only be READ or WRITE.\n");
#endif
        ASSERT(FALSE);
    }

    return AccessAllowed;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ndis\sys\ndis_co.c ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation

Module Name:

    ndis_co.c

Abstract:

    CO-NDIS miniport wrapper functions

Author:

    Jameel Hyder (JameelH) 01-Feb-96

Environment:

    Kernel mode, FSD

Revision History:

--*/

#include <precomp.h>
#include <atm.h>
#pragma hdrstop


//
//  Define the module number for debug code.
//
#define MODULE_NUMBER   MODULE_NDIS_CO

/*
    Connection-oriented section of NDIS exposes the following objects and apis to
    manipulate these objects.

    AF      Address Family
    SAP     Service Access Point
    VC      Virtual Circuit
    Party   A node in a point-multipoint VC

    There is a notion of a call-manager and a client on a per-binding basis. The
    call manager acts as a helper dll for NDIS wrapper to manage the aforementioned
    objects.

    The concept of AF makes possible the existence of multiple call-managers. An
    example of this is the UNI call-manager and a SPANS call-manager for the ATM
    media.

    SAPs provides a way for incoming calls to be routed to the right entity. A
    protocol can register for more than one SAPs. Its upto the call-manager to
    allow/dis-allow multiple protocol modules to register the same SAP.

    VCs are created either by a protocol module requesting to make an outbound call
    or by the call-manager dispatching an incoming call. VCs can either be point-point
    or point-multi-point. Leaf nodes can be added to VCs at any time provided the first
    leaf was created appropriately.

    References:

    An AF association results in the reference of file-object for the call-manager.

    A SAP registration results in the reference of the AF.

    A send or receive does not reference a VC. This is because miniports are required to
    pend DeactivateVc calls till all I/O completes. So when it calls NdisMCoDeactivateVcComplete
    no other packets will be indicated up and there are no sends outstanding.
*/

NDIS_STATUS
NdisCmRegisterAddressFamily(
    IN  NDIS_HANDLE             NdisBindingHandle,
    IN  PCO_ADDRESS_FAMILY      AddressFamily,
    IN  PNDIS_CALL_MANAGER_CHARACTERISTICS  CmCharacteristics,
    IN  UINT                    SizeOfCmCharacteristics
    )
/*++

Routine Description:
    This is a call from the call-manager to register the address family
    supported by this call-manager.

Arguments:
    NdisBindingHandle       - Pointer to the call-managers NDIS_OPEN_BLOCK.
    AddressFamily           - The address family being registered.
    CmCharacteristics       - Call-Manager characteristics
    SizeOfCmCharacteristics - Size of Call-Manager characteristics

Return Value:
    NDIS_STATUS_SUCCESS if the address family registration is successfully.
    NDIS_STATUS_FAILURE if the caller is not a call-manager or this address
                        family is already registered for this miniport.

--*/
{
    NDIS_STATUS                 Status = NDIS_STATUS_SUCCESS;
    KIRQL                       OldIrql;
    PNDIS_AF_LIST               AfList;
    PNDIS_PROTOCOL_BLOCK        Protocol;
    PNDIS_OPEN_BLOCK            CallMgrOpen;
    PNDIS_MINIPORT_BLOCK        Miniport;
    PNDIS_AF_NOTIFY             AfNotify = NULL;


    CallMgrOpen = (PNDIS_OPEN_BLOCK)NdisBindingHandle;
    Miniport = CallMgrOpen->MiniportHandle;
    Protocol = CallMgrOpen->ProtocolHandle;

    PnPReferencePackage();

    //
    // Make sure that the miniport is a CoNdis miniport and
    // there is no other module registering the same address family.
    //
    NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Miniport, &OldIrql);

    do
    {
        CallMgrOpen->Flags |= fMINIPORT_OPEN_CALL_MANAGER;
        
        //
        // Make sure the binding is not closing down
        //
        if (CallMgrOpen->Flags & fMINIPORT_OPEN_CLOSING)
        {
            Status = NDIS_STATUS_FAILURE;
            break;
        }

        //
        // Make sure that the miniport is a CoNdis miniport and
        // protocol is also a NDIS 5.0 or later protocol.
        //
        if (!MINIPORT_TEST_FLAG(Miniport, fMINIPORT_IS_CO))
        {
            //
            // Not a NDIS 5.0 or later miniport
            //
            Status = NDIS_STATUS_FAILURE;
            break;
        }

        if (Protocol->ProtocolCharacteristics.MajorNdisVersion < 5)
        {
            //
            // Not a NDIS 5.0 or later protocol
            //
            Status = NDIS_STATUS_FAILURE;
            break;
        }

        //
        // Make sure that the call-manager characteristics are 5.0 or later
        //
        if ((CmCharacteristics->MajorVersion < 5) ||
            (SizeOfCmCharacteristics < sizeof(NDIS_CALL_MANAGER_CHARACTERISTICS)))
        {
            //
            // Not a NDIS 5.0 or later protocol
            //
            Status = NDIS_STATUS_FAILURE;
            break;
        }

        //
        // Search registered call-managers for this miniport and make sure there is no
        // clash. A call-manager can only register one address family per-open. This
        // is due to the way we cache handlers. Can be over-come if the handlers are
        // identical for each address-family - but decided not to since it is un-interesting.
        //
        for (AfList = Miniport->CallMgrAfList;
             AfList != NULL;
             AfList = AfList->NextAf)
        {
            if (NdisEqualMemory(&AfList->AddressFamily, AddressFamily, sizeof(CO_ADDRESS_FAMILY)))
            {
                Status = NDIS_STATUS_FAILURE;
                break;
            }
        }

        if (AfList == NULL)
        {
            //
            // No other entity has claimed this address family.
            // Allocate an AfList and a notify structure
            //
            AfList = (PNDIS_AF_LIST)ALLOC_FROM_POOL(sizeof(NDIS_AF_LIST), NDIS_TAG_CO);
            if (AfList == NULL)
            {
                Status = NDIS_STATUS_RESOURCES;
                break;
            }

            Status = ndisCreateNotifyQueue(Miniport, NULL, AddressFamily, &AfNotify);
            if (Status != NDIS_STATUS_SUCCESS)
            {
                FREE_POOL(AfList);
                break;
            }

            AfList->AddressFamily = *AddressFamily;
            CopyMemory(&AfList->CmChars,
                       CmCharacteristics,
                       sizeof(NDIS_CALL_MANAGER_CHARACTERISTICS));

            //
            // link it in the miniport list
            //
            AfList->Open = CallMgrOpen;
            AfList->NextAf = Miniport->CallMgrAfList;
            Miniport->CallMgrAfList = AfList;

            //
            // Finally cache some handlers in the open-block
            //
            CallMgrOpen->CoCreateVcHandler = CmCharacteristics->CmCreateVcHandler;
            CallMgrOpen->CoDeleteVcHandler = CmCharacteristics->CmDeleteVcHandler;
            CallMgrOpen->CmActivateVcCompleteHandler = CmCharacteristics->CmActivateVcCompleteHandler;
            CallMgrOpen->CmDeactivateVcCompleteHandler = CmCharacteristics->CmDeactivateVcCompleteHandler;
            CallMgrOpen->CoRequestCompleteHandler = CmCharacteristics->CmRequestCompleteHandler;

            if (AfNotify != NULL)
            {
                //
                // Notify existing clients of this registration
                //
                QUEUE_WORK_ITEM(&AfNotify->WorkItem, DelayedWorkQueue);
            }
        }
    } while (FALSE);

    NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);

    PnPDereferencePackage();

    return(Status);
}


NDIS_STATUS
NdisMCmRegisterAddressFamily(
    IN  NDIS_HANDLE             MiniportAdapterHandle,
    IN  PCO_ADDRESS_FAMILY      AddressFamily,
    IN  PNDIS_CALL_MANAGER_CHARACTERISTICS CmCharacteristics,
    IN  UINT                    SizeOfCmCharacteristics
    )
/*++

Routine Description:
    This is a call from the miniport supported call-manager to register the address family
    supported by this call-manager.

Arguments:
    MiniportAdapterHandle   - Pointer to the miniports NDIS_MINIPORT_BLOCK.
    AddressFamily           - The address family being registered.
    CmCharacteristics       - Call-Manager characteristics
    SizeOfCmCharacteristics - Size of Call-Manager characteristics

Return Value:
    NDIS_STATUS_SUCCESS if the address family registration is successfully.
    NDIS_STATUS_FAILURE if the caller is not a call-manager or this address
                        family is already registered for this miniport.

--*/
{
    PNDIS_MINIPORT_BLOCK        Miniport;
    NDIS_STATUS                 Status;
    PNDIS_AF_LIST               AfList;
    KIRQL                       OldIrql;

    PnPReferencePackage();

    Miniport = (PNDIS_MINIPORT_BLOCK)MiniportAdapterHandle;

    //
    // Make sure that the miniport is a CoNdis miniport and
    // there is no other module registering the same address family.
    //
    NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Miniport, &OldIrql);

    do
    {
        //
        // Make sure that the miniport is a CoNdis miniport
        //
        if (!MINIPORT_TEST_FLAG(Miniport, fMINIPORT_IS_CO))
        {
            //
            // Not a NDIS 5.0 or later miniport
            //
            Status = NDIS_STATUS_FAILURE;
            break;
        }

        //
        // Make sure that the call-manager characteristics are 5.0 or later
        //
        if ((CmCharacteristics->MajorVersion < 5) ||
            (SizeOfCmCharacteristics < sizeof(NDIS_CALL_MANAGER_CHARACTERISTICS)))
        {
            //
            // Not a NDIS 5.0 or later protocol
            //
            Status = NDIS_STATUS_FAILURE;
            break;
        }

        //
        // Search registered call-managers for this miniport and make sure there is no
        // clash. A call-manager can only register one address family per-open. This
        // is due to the way we cache handlers. Can be over-come if the handlers are
        // identical for each address-family - but decided not to since it is un-interesting.
        //
        for (AfList = Miniport->CallMgrAfList;
             AfList != NULL;
             AfList = AfList->NextAf)
        {
            if (NdisEqualMemory(&AfList->AddressFamily, AddressFamily, sizeof(CO_ADDRESS_FAMILY)))
            {
                Status = NDIS_STATUS_FAILURE;
                break;
            }
        }

        if ((AfList == NULL) && MINIPORT_INCREMENT_REF(Miniport))
        {
            //
            // No other entity has claimed this address family.
            // Allocate an AfList and a notify structure
            //
            AfList = (PNDIS_AF_LIST)ALLOC_FROM_POOL(sizeof(NDIS_AF_LIST), NDIS_TAG_CO);
            if (AfList == NULL)
            {
                Status = NDIS_STATUS_RESOURCES;
                break;
            }

            AfList->AddressFamily = *AddressFamily;
            CopyMemory(&AfList->CmChars,
                       CmCharacteristics,
                       sizeof(NDIS_CALL_MANAGER_CHARACTERISTICS));

            //
            // link it in the miniport list
            //
            AfList->Open = NULL;
            AfList->NextAf = Miniport->CallMgrAfList;
            Miniport->CallMgrAfList = AfList;

            MINIPORT_DECREMENT_REF(Miniport);
            Status = NDIS_STATUS_SUCCESS;
        }
    } while (FALSE);

    NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);

    PnPDereferencePackage();

    return Status;
}


NDIS_STATUS
ndisCreateNotifyQueue(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  PNDIS_OPEN_BLOCK                Open            OPTIONAL,
    IN  PCO_ADDRESS_FAMILY              AddressFamily   OPTIONAL,
    IN  PNDIS_AF_NOTIFY         *       AfNotify
    )
/*++

Routine Description:

    Collect a set of address-family notifications that can then be passed on to ndisNotifyAfRegistration.
    If the Open is NULL, this implies that an AddressFamily is being registered and must be notified to
    all protocols on this miniport. If the AddressFamily is NULL (and the Open is specified) then all
    registered AddressFamilies on this miniport must be indicated to the Open.

Arguments:

    Miniport    -   Miniport of interest
    Open        -   Optional - see comments above
    AddressFamily - Optional - see comments above
    AfNotify    -   Place holder for the list of notifications

Return Value:
    NDIS_STATUS_SUCCESS     - No errors, AfNotify can be NULL
    NDIS_STATUS_RESOURCES   - Failed to allocate memory

Note: Called at DPC with Miniport lock held.

--*/
{
    NDIS_STATUS         Status = NDIS_STATUS_SUCCESS;
    PNDIS_AF_NOTIFY     AfN;
    PNDIS_OPEN_BLOCK    tOpen;
    PNDIS_AF_LIST       AfList;

    ASSERT(ARGUMENT_PRESENT(Open) ^ ARGUMENT_PRESENT(AddressFamily));

    *AfNotify = NULL;
    if (ARGUMENT_PRESENT(Open))
    {
        
        ACQUIRE_SPIN_LOCK_DPC(&Open->SpinLock);
        
        ASSERT(Open->ProtocolHandle->ProtocolCharacteristics.CoAfRegisterNotifyHandler != NULL);

        for (AfList = Miniport->CallMgrAfList;
             AfList != NULL;
             AfList = AfList->NextAf)
        {

            if (MINIPORT_TEST_FLAG(Open, fMINIPORT_OPEN_UNBINDING | fMINIPORT_OPEN_CLOSING))
            {
                //
                // this open is going away. skip it.
                //
                break;

            }
            else
            {
                OPEN_INCREMENT_AF_NOTIFICATION(Open);
    
//                DbgPrint("ndisCreateNotifyQueue: Open %p, AFNotifyRef %lx\n", Open, Open->PendingAfNotifications);
            }
 
            AfN = (PNDIS_AF_NOTIFY)ALLOC_FROM_POOL(sizeof(NDIS_AF_NOTIFY), NDIS_TAG_CO);
            if (AfN == NULL)
            {
                Status = NDIS_STATUS_RESOURCES;
                break;
            }
            
            AfN->Miniport = Miniport;
            AfN->Open = Open;
            M_OPEN_INCREMENT_REF_INTERLOCKED(Open);
            AfN->AddressFamily = AfList->AddressFamily;
            INITIALIZE_WORK_ITEM(&AfN->WorkItem, ndisNotifyAfRegistration, AfN);
            AfN->Next = *AfNotify;
            *AfNotify = AfN;
        }
             
        RELEASE_SPIN_LOCK_DPC(&Open->SpinLock);
    }
    else
    {
        for (tOpen = Miniport->OpenQueue;
             tOpen != NULL;
             tOpen = tOpen->MiniportNextOpen)
        {
            if (tOpen->ProtocolHandle->ProtocolCharacteristics.CoAfRegisterNotifyHandler != NULL)
            {
                ACQUIRE_SPIN_LOCK_DPC(&tOpen->SpinLock);
                if (MINIPORT_TEST_FLAG(tOpen, fMINIPORT_OPEN_UNBINDING | fMINIPORT_OPEN_CLOSING))
                {
                    //
                    // this open is going away. skip it.
                    //
                    RELEASE_SPIN_LOCK_DPC(&tOpen->SpinLock);
                    continue;

                }
                else
                {
                      OPEN_INCREMENT_AF_NOTIFICATION(tOpen);

//                    DbgPrint("ndisCreateNotifyQueue: tOpen %p, AFNotifyRef %lx\n", tOpen, tOpen->PendingAfNotifications);

                    RELEASE_SPIN_LOCK_DPC(&tOpen->SpinLock);
                }
                
                AfN = (PNDIS_AF_NOTIFY)ALLOC_FROM_POOL(sizeof(NDIS_AF_NOTIFY), NDIS_TAG_CO);
                if (AfN == NULL)
                {
                    Status = NDIS_STATUS_RESOURCES;
                    ndisDereferenceAfNotification(tOpen);
                    break;
                }
                
                AfN->Miniport = Miniport;
                AfN->Open = tOpen;
                
                M_OPEN_INCREMENT_REF_INTERLOCKED(tOpen);
                AfN->AddressFamily = *AddressFamily;
                INITIALIZE_WORK_ITEM(&AfN->WorkItem, ndisNotifyAfRegistration, AfN);
                AfN->Next = *AfNotify;
                *AfNotify = AfN;
            }
        }
    }

    return Status;
}


VOID
ndisNotifyAfRegistration(
    IN  PNDIS_AF_NOTIFY         AfNotify
    )
/*++

Routine Description:

    Notify protocols that care that a new address family has been registered.

Arguments:
    AfNotify    - Structure that holds context information.

Return Value:
    None.

--*/
{
    KIRQL                   OldIrql;
    PNDIS_MINIPORT_BLOCK    Miniport;
    PNDIS_PROTOCOL_BLOCK    Protocol;
    PNDIS_OPEN_BLOCK        Open;
    PNDIS_AF_NOTIFY         Af, AfNext;

    Miniport = AfNotify->Miniport;

    PnPReferencePackage();


    for (Af = AfNotify; Af != NULL; Af = AfNext)
    {
        AfNext = Af->Next;
    
        Open = Af->Open;
        Protocol = Open->ProtocolHandle;
        
        if (!MINIPORT_TEST_FLAG(Open, fMINIPORT_OPEN_UNBINDING | fMINIPORT_OPEN_CLOSING))
        {
            (*Protocol->ProtocolCharacteristics.CoAfRegisterNotifyHandler)(
                                Open->ProtocolBindingContext,
                                &Af->AddressFamily);
        }
        
        FREE_POOL(Af);

        ndisDereferenceAfNotification(Open);

        NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Miniport, &OldIrql);
        ndisMDereferenceOpen(Open);
        NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);
    }


    PnPDereferencePackage();
}


NDIS_STATUS
NdisClOpenAddressFamily(
    IN  NDIS_HANDLE             NdisBindingHandle,
    IN  PCO_ADDRESS_FAMILY      AddressFamily,
    IN  NDIS_HANDLE             ClientAfContext,
    IN  PNDIS_CLIENT_CHARACTERISTICS ClCharacteristics,
    IN  UINT                    SizeOfClCharacteristics,
    OUT PNDIS_HANDLE            NdisAfHandle
    )
/*++

Routine Description:
    This is a call from a NDIS 5.0 or later protocol to open a particular
    address familty - in essence getting a handle to the call-manager.

Arguments:
    NdisBindingHandle   - Pointer to the protocol's NDIS_OPEN_BLOCK.
    PCO_ADDRESS_FAMILY  - The address family being registered.
    ClientAfContext     - Protocol context associated with this handle.
    NdisAfHandle        - Handle returned by NDIS for this address family.

Return Value:
    NDIS_STATUS_SUCCESS if the address family open is successfully.
    NDIS_STATUS_PENDING if the call-manager pends this call. The caller will get
                        called at the completion handler when done.
    NDIS_STATUS_FAILURE if the caller is not a NDIS 5.0 prototcol or this address
                        family is not registered for this miniport.

--*/
{
    PNDIS_CO_AF_BLOCK           pAf;
    PNDIS_AF_LIST               AfList;
    PNDIS_OPEN_BLOCK            CallMgrOpen, ClientOpen;
    PNDIS_MINIPORT_BLOCK        Miniport;
    PNDIS_PROTOCOL_BLOCK        Protocol;
    KIRQL                       OldIrql;
    NTSTATUS                    Status;

    *NdisAfHandle = NULL;
    ClientOpen = (PNDIS_OPEN_BLOCK)NdisBindingHandle;
    Miniport = ClientOpen->MiniportHandle;
    Protocol = ClientOpen->ProtocolHandle;

    PnPReferencePackage();

    do
    {
        ClientOpen->Flags |= fMINIPORT_OPEN_CLIENT;

        //
        // Make sure the binding is not closing down
        //
        if (ClientOpen->Flags & fMINIPORT_OPEN_CLOSING)
        {
            Status = NDIS_STATUS_FAILURE;
            break;
        }

        //
        // Make sure that the miniport is a CoNdis miniport and
        // protocol is also a NDIS 5.0 or later protocol.
        //
        if ((Miniport->DriverHandle->MiniportCharacteristics.MajorNdisVersion < 5) ||
            (!MINIPORT_TEST_FLAG(Miniport, fMINIPORT_IS_CO)))
        {
            //
            // Not a NDIS 5.0 or later miniport
            //
            Status = NDIS_STATUS_FAILURE;
            break;
        }

        if (Protocol->ProtocolCharacteristics.MajorNdisVersion < 5)
        {
            //
            // Not a NDIS 5.0 or later protocol
            //
            Status = NDIS_STATUS_FAILURE;
            break;
        }

        //
        // Make sure that the client characteristics are 5.0 or later
        //
        if ((ClCharacteristics->MajorVersion < 5) ||
            (SizeOfClCharacteristics < sizeof(NDIS_CLIENT_CHARACTERISTICS)))
        {
            //
            // Not a NDIS 5.0 or later protocol
            //
            Status = NDIS_STATUS_FAILURE;
            break;
        }

        NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Miniport, &OldIrql);

        //
        // Search the miniport block for a registered call-manager for this address family
        //
        for (AfList = Miniport->CallMgrAfList;
             AfList != NULL;
             AfList = AfList->NextAf)
        {
            if (AfList->AddressFamily.AddressFamily == AddressFamily->AddressFamily)
            {
                CallMgrOpen = AfList->Open;
                break;
            }
        }

        //
        // If we found a matching call manager, make sure that the callmgr
        // is not currently closing.
        //
        if ((AfList == NULL) ||
            ((AfList != NULL) && (AfList->Open != NULL) && (AfList->Open->Flags & fMINIPORT_OPEN_CLOSING)) ||
            (MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_PM_HALTED)))
        {
            NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);

            Status = NDIS_STATUS_FAILURE;
            break;
        }

        //
        // Allocate memory for the AF block.
        //
        pAf = ALLOC_FROM_POOL(sizeof(NDIS_CO_AF_BLOCK), NDIS_TAG_CO);
        if (pAf == NULL)
        {
            NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);
            Status = NDIS_STATUS_RESOURCES;
            break;
        }

        pAf->References = 1;
        pAf->Flags = (AfList->Open == NULL) ? AF_COMBO : 0;
        pAf->Miniport = Miniport;

        pAf->ClientOpen = ClientOpen;
        pAf->CallMgrOpen = CallMgrOpen = AfList->Open;
        pAf->ClientContext = ClientAfContext;

        //
        // Reference the call-manager's file object - we do not want to let it
        // duck from under the client.
        //
        //
        // Reference the client and the call-manager opens
        //
        M_OPEN_INCREMENT_REF_INTERLOCKED(ClientOpen);
        NdisInterlockedIncrement(&ClientOpen->AfReferences);
        if (CallMgrOpen != NULL)
        {
            M_OPEN_INCREMENT_REF_INTERLOCKED(CallMgrOpen);
            NdisInterlockedIncrement(&CallMgrOpen->AfReferences);
        }
        else
        {
            ObReferenceObject(Miniport->DeviceObject);
            Miniport->Ref.ReferenceCount ++;
#ifdef TRACK_MINIPORT_REFCOUNTS
            M_LOG_MINIPORT_INCREMENT_REF(Miniport, __LINE__, MODULE_NUMBER);
#endif
        }

        NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);

        INITIALIZE_SPIN_LOCK(&pAf->Lock);

        //
        // Cache in call-manager entry points
        //
        pAf->CallMgrEntries = &AfList->CmChars;

        //
        // And also Cache in client entry points
        //
        CopyMemory(&pAf->ClientEntries,
                   ClCharacteristics,
                   sizeof(NDIS_CLIENT_CHARACTERISTICS));


        //
        // Cache some handlers in the open-block
        //
        ClientOpen->CoCreateVcHandler = ClCharacteristics->ClCreateVcHandler;
        ClientOpen->CoDeleteVcHandler = ClCharacteristics->ClDeleteVcHandler;
        ClientOpen->CoRequestCompleteHandler = ClCharacteristics->ClRequestCompleteHandler;

        //
        // Now call the CallMgr's OpenAfHandler
        //
        Status = (*AfList->CmChars.CmOpenAfHandler)((CallMgrOpen != NULL) ?
                                                        CallMgrOpen->ProtocolBindingContext :
                                                        Miniport->MiniportAdapterContext,
                                                    AddressFamily,
                                                    pAf,
                                                    &pAf->CallMgrContext);

        if (Status != NDIS_STATUS_PENDING)
        {
            NdisCmOpenAddressFamilyComplete(Status,
                                            pAf,
                                            pAf->CallMgrContext);
            Status = NDIS_STATUS_PENDING;
        }

    } while (FALSE);

    PnPDereferencePackage();

    return Status;
}


VOID
NdisCmOpenAddressFamilyComplete(
    IN  NDIS_STATUS             Status,
    IN  NDIS_HANDLE             NdisAfHandle,
    IN  NDIS_HANDLE             CallMgrAfContext
    )
/*++

Routine Description:

    Completion routine for the OpenAddressFamily call. The call manager had pended this
    call earlier (or will pend). If the call succeeded there is a valid CallMgrContext
    supplied here as well

Arguments:
    Status              -   Completion status
    NdisAfHandle        -   Pointer to the AfBlock
    CallMgrAfContext    -   Call manager's context used in other calls into the call manager.

Return Value:
    NONE. The client's completion handler is called.

--*/
{
    PNDIS_CO_AF_BLOCK           pAf;
    PNDIS_OPEN_BLOCK            ClientOpen;
    PNDIS_MINIPORT_BLOCK        Miniport;
    KIRQL                       OldIrql;

    ASSERT(Status != NDIS_STATUS_PENDING);

    pAf = (PNDIS_CO_AF_BLOCK)NdisAfHandle;
    ClientOpen = pAf->ClientOpen;
    Miniport = pAf->Miniport;

    if (Status != NDIS_STATUS_SUCCESS)
    {
        if (pAf->CallMgrOpen == NULL)
        {
            ObDereferenceObject(Miniport->DeviceObject);
        }
    }

    NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Miniport, &OldIrql);

    pAf->CallMgrContext = CallMgrAfContext;

    if (Status != NDIS_STATUS_SUCCESS)
    {
        //
        // OpenAfHandler failed
        //
        if (pAf->CallMgrOpen != NULL)
        {
            NdisInterlockedDecrement(&pAf->CallMgrOpen->AfReferences);
            ndisMDereferenceOpen(pAf->CallMgrOpen);
        }
        else
        {
            MINIPORT_DECREMENT_REF(Miniport);
        }

        NdisInterlockedDecrement(&ClientOpen->AfReferences);
        ndisMDereferenceOpen(ClientOpen);
    }
    else
    {
        //
        // queue this CallMgr open onto the miniport open
        //
        pAf->NextAf = ClientOpen->NextAf;
        ClientOpen->NextAf = pAf;
    }

    NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);

    //
    // Finally call the client's completion handler
    //
    (*pAf->ClientEntries.ClOpenAfCompleteHandler)(Status,
                                                  pAf->ClientContext,
                                                  (Status == NDIS_STATUS_SUCCESS) ? pAf : NULL);

    if (Status != NDIS_STATUS_SUCCESS)
    {
        FREE_POOL(pAf);
    }

}


NDIS_STATUS
NdisClCloseAddressFamily(
    IN  NDIS_HANDLE             NdisAfHandle
    )
/*++

Routine Description:

    This call closes the Af object which essentially tears down the client-callmanager
    'binding'. Causes all open Vcs to be closed and saps to be de-registered "by the call
    manager".

Arguments:

    NdisAfHandle - Pointer to the Af.

Return Value:

    Status from Call Manager.

--*/
{
    PNDIS_CO_AF_BLOCK           pAf = (PNDIS_CO_AF_BLOCK)NdisAfHandle;
    NDIS_STATUS                 Status = NDIS_STATUS_SUCCESS;
    KIRQL                       OldIrql;

    //
    // Mark the address family as closing and call the call-manager to process.
    //
    ACQUIRE_SPIN_LOCK(&pAf->Lock, &OldIrql);
    if (pAf->Flags & AF_CLOSING)
    {
        Status = NDIS_STATUS_FAILURE;
    }
    pAf->Flags |= AF_CLOSING;
    RELEASE_SPIN_LOCK(&pAf->Lock, OldIrql);

    if (Status == NDIS_STATUS_SUCCESS)
    {
        Status = (*pAf->CallMgrEntries->CmCloseAfHandler)(pAf->CallMgrContext);
        if (Status != NDIS_STATUS_PENDING)
        {
            NdisCmCloseAddressFamilyComplete(Status, pAf);
            Status = NDIS_STATUS_PENDING;
        }
    }

    return Status;
}


VOID
NdisCmCloseAddressFamilyComplete(
    IN  NDIS_STATUS             Status,
    IN  NDIS_HANDLE             NdisAfHandle
    )
/*++

Routine Description:

    Completion routine for the CloseAddressFamily call. The call manager had pended this
    call earlier (or will pend). If the call succeeded there is a valid CallMgrContext
    supplied here as well

Arguments:
    Status              -   Completion status
    NdisAfHandle        -   Pointer to the AfBlock

Return Value:
    NONE. The client's completion handler is called.

--*/
{
    PNDIS_CO_AF_BLOCK           pAf = (PNDIS_CO_AF_BLOCK)NdisAfHandle;
    PNDIS_CO_AF_BLOCK *         ppAf;
    PNDIS_MINIPORT_BLOCK        Miniport;
    KIRQL                       OldIrql;

    Miniport = pAf->Miniport;

    //
    // NOTE: Memphis closes the adapters synchronously. so we have to deref
    // the open -before- calling ClCloseAfCompleteHandler because
    // ClCloseAfCompleteHandler will try to close the adapter and CloseAdapter
    // will pend forever since the ref count never goes to zero
    //
    
    //
    // Complete the call to the client
    //
    (*pAf->ClientEntries.ClCloseAfCompleteHandler)(Status,
                                                   pAf->ClientContext);

    if (Status == NDIS_STATUS_SUCCESS)
    {
        if (pAf->CallMgrOpen == NULL)
        {
            ObDereferenceObject(Miniport->DeviceObject);
        }

        Miniport = pAf->Miniport;

        NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Miniport, &OldIrql);

        if (pAf->CallMgrOpen != NULL)
        {
            NdisInterlockedDecrement(&pAf->CallMgrOpen->AfReferences);
            ndisMDereferenceOpen(pAf->CallMgrOpen);
        }
        else
        {
            MINIPORT_DECREMENT_REF(Miniport);
        }

        //
        //  Unlink from list of open AFs for this client.
        //
        for (ppAf = &pAf->ClientOpen->NextAf;
             *ppAf != NULL;
             ppAf = &((*ppAf)->NextAf))
        {
            if (*ppAf == pAf)
            {
                *ppAf = pAf->NextAf;
                break;
            }
        }

        NdisInterlockedDecrement(&pAf->ClientOpen->AfReferences);
        ndisMDereferenceOpen(pAf->ClientOpen);

        NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);

    }

    //
    // Finally dereference the AF Block, if the call-manager successfully closed it.
    //
    if (Status == NDIS_STATUS_SUCCESS)
    {
        ndisDereferenceAf(pAf);
    }
}


BOOLEAN
FASTCALL
ndisReferenceAf(
    IN  PNDIS_CO_AF_BLOCK   pAf
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    KIRQL   OldIrql;
    BOOLEAN rc = FALSE;

    ACQUIRE_SPIN_LOCK(&pAf->Lock, &OldIrql);

    if ((pAf->Flags & AF_CLOSING) == 0)
    {
        pAf->References ++;
        rc = TRUE;
    }

    RELEASE_SPIN_LOCK(&pAf->Lock, OldIrql);

    return rc;
}


VOID
FASTCALL
ndisDereferenceAf(
    IN  PNDIS_CO_AF_BLOCK   pAf
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    KIRQL   OldIrql;
    BOOLEAN Done = FALSE;

    ACQUIRE_SPIN_LOCK(&pAf->Lock, &OldIrql);

    ASSERT(pAf->References > 0);
    pAf->References --;
    if (pAf->References == 0)
    {
        ASSERT(pAf->Flags & AF_CLOSING);
        Done = TRUE;
    }

    RELEASE_SPIN_LOCK(&pAf->Lock, OldIrql);

    if (Done)
        FREE_POOL(pAf);
}


NDIS_STATUS
NdisClRegisterSap(
    IN  NDIS_HANDLE             NdisAfHandle,
    IN  NDIS_HANDLE             ProtocolSapContext,
    IN  PCO_SAP                 Sap,
    OUT PNDIS_HANDLE            NdisSapHandle
    )
/*++

Routine Description:
    This is a call from a NDIS 5.0 or later protocol to register its SAP
    with the call manager.

Arguments:
    NdisBindingHandle   - Pointer to the protocol's NDIS_OPEN_BLOCK.
    PCO_ADDRESS_FAMILY  - The address family being registered.
    ClientAfContext     - Protocol context associated with this handle.
    NdisAfHandle        - Handle returned by NDIS for this address family.

Return Value:
    NDIS_STATUS_SUCCESS if the address family open is successfully.
    NDIS_STATUS_PENDING if the call-manager pends this call. The caller will get
    NDIS_STATUS_FAILURE if the caller is not a NDIS 5.0 prototcol or this address
                        family is not registered for this miniport.

--*/
{
    NDIS_STATUS                 Status;
    PNDIS_CO_AF_BLOCK           pAf = (PNDIS_CO_AF_BLOCK)NdisAfHandle;
    PNDIS_CO_SAP_BLOCK          pSap;

    *NdisSapHandle = NULL;
    do
    {
        //
        // Reference the Af for this SAP
        //
        if (!ndisReferenceAf(pAf))
        {
            Status = NDIS_STATUS_FAILURE;
            break;
        }

        pSap = (PNDIS_CO_SAP_BLOCK)ALLOC_FROM_POOL(sizeof(NDIS_CO_SAP_BLOCK), NDIS_TAG_CO);
        if (pSap == NULL)
        {
            *NdisSapHandle = NULL;
            Status = NDIS_STATUS_RESOURCES;
            break;
        }

        pSap->Flags = 0;
        pSap->References = 1;
        INITIALIZE_SPIN_LOCK(&pSap->Lock);
        pSap->AfBlock = pAf;
        pSap->Sap = Sap;
        pSap->ClientContext = ProtocolSapContext;
        Status = (*pAf->CallMgrEntries->CmRegisterSapHandler)(pAf->CallMgrContext,
                                                              Sap,
                                                              pSap,
                                                              &pSap->CallMgrContext);

        if (Status != NDIS_STATUS_PENDING)
        {
            NdisCmRegisterSapComplete(Status, pSap, pSap->CallMgrContext);
            Status = NDIS_STATUS_PENDING;
        }

    } while (FALSE);

    return Status;
}


VOID
NdisCmRegisterSapComplete(
    IN  NDIS_STATUS             Status,
    IN  NDIS_HANDLE             NdisSapHandle,
    IN  NDIS_HANDLE             CallMgrSapContext
    )
/*++

Routine Description:
    Completion routine for the registerSap call. The call manager had pended this
    call earlier (or will pend). If the call succeeded there is a valid CallMgrContext
    supplied here as well

Arguments:
    Status              -   Completion status
    NdisAfHandle        -   Pointer to the AfBlock
    CallMgrAfContext    -   Call manager's context used in other calls into the call manager.

Return Value:
    NONE. The client's completion handler is called.

--*/
{
    PNDIS_CO_SAP_BLOCK  pSap = (PNDIS_CO_SAP_BLOCK)NdisSapHandle;
    PNDIS_CO_AF_BLOCK   pAf;

    ASSERT(Status != NDIS_STATUS_PENDING);

    pAf = pSap->AfBlock;
    pSap->CallMgrContext = CallMgrSapContext;

    //
    // Call the clients completion handler
    //
    (*pAf->ClientEntries.ClRegisterSapCompleteHandler)(Status,
                                                       pSap->ClientContext,
                                                       pSap->Sap,
                                                       pSap);

    if (Status != NDIS_STATUS_SUCCESS)
    {
        ndisDereferenceAf(pSap->AfBlock);
        FREE_POOL(pSap);
    }
}


NDIS_STATUS
NdisClDeregisterSap(
    IN  NDIS_HANDLE             NdisSapHandle
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PNDIS_CO_SAP_BLOCK  pSap = (PNDIS_CO_SAP_BLOCK)NdisSapHandle;
    NDIS_STATUS         Status;
    KIRQL               OldIrql;
    BOOLEAN             fAlreadyClosing;

    ACQUIRE_SPIN_LOCK(&pSap->Lock, &OldIrql);

    fAlreadyClosing = FALSE;
    if (pSap->Flags & SAP_CLOSING)
    {
        fAlreadyClosing = TRUE;
    }
    pSap->Flags |= SAP_CLOSING;

    RELEASE_SPIN_LOCK(&pSap->Lock, OldIrql);

    if (fAlreadyClosing)
    {
        return NDIS_STATUS_FAILURE;
    }

    //
    // Notify the call-manager that this sap is being de-registered
    //
    Status = (*pSap->AfBlock->CallMgrEntries->CmDeregisterSapHandler)(pSap->CallMgrContext);

    if (Status != NDIS_STATUS_PENDING)
    {
        NdisCmDeregisterSapComplete(Status, pSap);
        Status = NDIS_STATUS_PENDING;
    }

    return Status;
}


VOID
NdisCmDeregisterSapComplete(
    IN  NDIS_STATUS             Status,
    IN  NDIS_HANDLE             NdisSapHandle
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PNDIS_CO_SAP_BLOCK  pSap = (PNDIS_CO_SAP_BLOCK)NdisSapHandle;

    ASSERT(Status != NDIS_STATUS_PENDING);

    //
    // Complete the call to the client and deref the sap
    //
    (*pSap->AfBlock->ClientEntries.ClDeregisterSapCompleteHandler)(Status,
                                                                   pSap->ClientContext);

    if (Status == NDIS_STATUS_SUCCESS)
    {
        ndisDereferenceAf(pSap->AfBlock);
        ndisDereferenceSap(pSap);
    }
}


BOOLEAN
FASTCALL
ndisReferenceSap(
    IN  PNDIS_CO_SAP_BLOCK  pSap
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    KIRQL   OldIrql;
    BOOLEAN rc = FALSE;

    ACQUIRE_SPIN_LOCK(&pSap->Lock, &OldIrql);

    if ((pSap->Flags & SAP_CLOSING) == 0)
    {
        pSap->References ++;
        rc = TRUE;
    }

    RELEASE_SPIN_LOCK(&pSap->Lock, OldIrql);

    return rc;
}


VOID
FASTCALL
ndisDereferenceSap(
    IN  PNDIS_CO_SAP_BLOCK  pSap
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    KIRQL   OldIrql;
    BOOLEAN Done = FALSE;

    ACQUIRE_SPIN_LOCK(&pSap->Lock, &OldIrql);

    ASSERT(pSap->References > 0);
    pSap->References --;
    if (pSap->References == 0)
    {
        ASSERT(pSap->Flags & SAP_CLOSING);
        Done = TRUE;
    }

    RELEASE_SPIN_LOCK(&pSap->Lock, OldIrql);

    if (Done)
        FREE_POOL(pSap);
}


NDIS_STATUS
NdisCoCreateVc(
    IN  NDIS_HANDLE             NdisBindingHandle,
    IN  NDIS_HANDLE             NdisAfHandle    OPTIONAL,
    IN  NDIS_HANDLE             ProtocolVcContext,
    IN OUT  PNDIS_HANDLE        NdisVcHandle
    )
/*++

Routine Description:
    This is a call from either the call-manager or from the client to create a vc.
    The vc would then be owned by call-manager (signalling vc) or the client.
    This is a synchronous call to all parties and simply creates an end-point over
    which either incoming calls can be dispatched or out-going calls can be made.

    Combined Miniport/Call Manager drivers call NdisMCmCreateVc instead of NdisCoCreateVc.

Arguments:
    NdisBindingHandle   - Pointer to the caller's NDIS_OPEN_BLOCK.
    NdisAfHandle        - Pointer to the AF Block. Not specified for call-manager's private vcs.
    NdisVcHandle        - Where the handle to this Vc will be returned. If this is non-NULL,
                          then we assume a valid Vc and return a new handle to it (this would be
                          a call from the NDIS Proxy to create a second handle to an existing Vc).

Return Value:
    NDIS_STATUS_SUCCESS if all the components succeed.
    ErrorCode           to signify why the call failed.

--*/
{
    NDIS_STATUS             Status;
    PNDIS_OPEN_BLOCK        Open;
    PNDIS_MINIPORT_BLOCK    Miniport;
    PNDIS_CO_AF_BLOCK       pAf;
    PNDIS_CO_VC_PTR_BLOCK   VcPtr;          // VcPtr is returned in NdisVcHandle
    PNDIS_CO_VC_PTR_BLOCK   ExistingVcPtr;  // Passed in optionally by caller
    PNDIS_CO_VC_BLOCK       VcBlock;        // Created if ExistingVcPtr is NULL
    KIRQL                   OldIrql;
    BOOLEAN                 bCallerIsProxy;
    BOOLEAN                 bCallerIsClient;
    BOOLEAN                 bVcToComboMiniport; // VC being created to Integrated MCM

    DBGPRINT(DBG_COMP_CO, DBG_LEVEL_INFO,
            ("=>NdisCoCreateVc\n"));

    //
    //  Get the caller's open for the miniport.
    //
    Open = (PNDIS_OPEN_BLOCK)NdisBindingHandle;
    Miniport = Open->MiniportHandle;

    pAf = (PNDIS_CO_AF_BLOCK)NdisAfHandle;

    //
    //  Is this VC being created to an integrated call manager + miniport driver?
    //
    bVcToComboMiniport = ((pAf) && ((pAf->Flags & AF_COMBO) != 0));

    //
    //  The caller is either a Client or a Call manager.
    //
    bCallerIsClient = ((pAf != NULL) && (Open == pAf->ClientOpen));

    //
    //  The caller could be a Proxy protocol.
    //
    bCallerIsProxy = ((Open->ProtocolHandle->ProtocolCharacteristics.Flags & NDIS_PROTOCOL_PROXY) != 0);

    //
    //  A proxy protocol could pass in its handle to an existing VC, in order
    //  to "duplicate" it to another client.
    //
    ExistingVcPtr = *NdisVcHandle;


    //
    //  Initialize.
    //
    VcPtr = NULL;
    VcBlock = NULL;
    Status = NDIS_STATUS_SUCCESS;

    do
    {
        //
        //  Only a proxy protocol can pass in an existing VC pointer.
        //
        if (ExistingVcPtr && !bCallerIsProxy)
        {
            Status = NDIS_STATUS_FAILURE;
            break;
        }

        //
        //  Allocate context for this VC creation: a VC Pointer Block.
        //  We return a pointer to this as the NdisVcHandle for the caller.
        //
        VcPtr = ALLOC_FROM_POOL(sizeof(NDIS_CO_VC_PTR_BLOCK), NDIS_TAG_CO);
        if (VcPtr == NULL)
        {
            Status = NDIS_STATUS_RESOURCES;
            break;
        }

        //
        // Initialize the VC Ptr
        //
        NdisZeroMemory(VcPtr, sizeof(NDIS_CO_VC_PTR_BLOCK));
        INITIALIZE_SPIN_LOCK(&VcPtr->Lock);
        InitializeListHead(&VcPtr->CallMgrLink);
        InitializeListHead(&VcPtr->ClientLink);
        InitializeListHead(&VcPtr->VcLink);


        if (ExistingVcPtr == NULL)
        {
            //
            //  New VC being created. Allocate and prepare the base VC block.
            //
            DBGPRINT(DBG_COMP_CO, DBG_LEVEL_INFO,
                ("NdisCoCreateVc: passed in ptr == NULL\n"));
            
            VcBlock = ALLOC_FROM_POOL(sizeof(NDIS_CO_VC_BLOCK), NDIS_TAG_CO);
            if (VcBlock == NULL)
            {
                Status = NDIS_STATUS_RESOURCES;
                FREE_POOL(VcPtr);
                VcPtr = NULL;
                break;
            }

            //
            //  Initialize the VC block
            //
            NdisZeroMemory(VcBlock, sizeof(NDIS_CO_VC_BLOCK));
            INITIALIZE_SPIN_LOCK(&VcBlock->Lock);

            //
            //  Stick the Miniport in the VC for use in NdisM functions
            //
            VcBlock->Miniport = Miniport;

            if (!bVcToComboMiniport)
            {
                //
                //  Call the miniport to get its context for this VC.
                //
                Status = (*Open->MiniportCoCreateVcHandler)(Miniport->MiniportAdapterContext,
                                                            VcPtr,
                                                            &VcPtr->MiniportContext);

                if (Status != NDIS_STATUS_SUCCESS)
                {
                    FREE_POOL(VcBlock);
                    break;
                }
            }
        }
        else
        {
            //
            //  A VC Pointer was passed in.
            //

            DBGPRINT(DBG_COMP_CO, DBG_LEVEL_INFO,
                ("NdisCoCreateVc: NdisVcHandle is not NULL!\n"));

            //
            //  Get the Vc from the passed-in VcPtr.
            //
            VcBlock = ExistingVcPtr->VcBlock;

            //
            // Copy the Miniport Context into the new VC ptr.
            //
            VcPtr->MiniportContext = ExistingVcPtr->MiniportContext;
        }

        //
        //  Cache some miniport handlers in the new VC pointer Block
        //
        VcPtr->WCoSendPacketsHandler = Miniport->DriverHandle->MiniportCharacteristics.CoSendPacketsHandler;

        if (!bVcToComboMiniport)
        {
            //
            //  For an MCM driver, CreateVc and DeleteVc go only to the Call Manager
            //  section.
            //
            VcPtr->WCoDeleteVcHandler = Miniport->DriverHandle->MiniportCharacteristics.CoDeleteVcHandler;
        }

        VcPtr->WCoActivateVcHandler = Miniport->DriverHandle->MiniportCharacteristics.CoActivateVcHandler;
        VcPtr->WCoDeactivateVcHandler = Miniport->DriverHandle->MiniportCharacteristics.CoDeactivateVcHandler;

        //
        //  Set up some reverse pointers in the new VC Pointer Block
        //
        VcPtr->Miniport = Miniport;
        VcPtr->VcBlock = VcBlock;
        VcPtr->AfBlock = pAf;

        VcPtr->References = 1;
        VcPtr->pVcFlags = &VcBlock->Flags;

        if (ARGUMENT_PRESENT(NdisAfHandle))
        {
            //
            //  This VC is associated with an AF block, meaning that it is
            //  a normal Client-CM-Miniport VC.
            //
            VcPtr->ClientOpen = pAf->ClientOpen;
            VcPtr->CallMgrOpen = pAf->CallMgrOpen;

            //
            //  Cache non-data path client handlers in new VcPtr.
            //
            VcPtr->ClModifyCallQoSCompleteHandler = pAf->ClientEntries.ClModifyCallQoSCompleteHandler;
            VcPtr->ClIncomingCallQoSChangeHandler = pAf->ClientEntries.ClIncomingCallQoSChangeHandler;
            VcPtr->ClCallConnectedHandler = pAf->ClientEntries.ClCallConnectedHandler;
    
            VcPtr->CmActivateVcCompleteHandler = pAf->CallMgrEntries->CmActivateVcCompleteHandler;
            VcPtr->CmDeactivateVcCompleteHandler = pAf->CallMgrEntries->CmDeactivateVcCompleteHandler;
            VcPtr->CmModifyCallQoSHandler = pAf->CallMgrEntries->CmModifyCallQoSHandler;

            //
            //  Mark this VC if the proxy is handing it off to a proxied client.
            //
            if (ExistingVcPtr != NULL)
            {
                VcBlock->Flags |= VC_HANDOFF_IN_PROGRESS;
            }

            //
            //  Update data path handlers based on who is calling this, and for
            //  what purpose.
            //

            if (!bCallerIsProxy)
            {
                VcBlock->ClientOpen = pAf->ClientOpen;
                VcBlock->CoReceivePacketHandler = pAf->ClientOpen->ProtocolHandle->ProtocolCharacteristics.CoReceivePacketHandler;
                VcBlock->CoSendCompleteHandler = pAf->ClientOpen->ProtocolHandle->ProtocolCharacteristics.CoSendCompleteHandler;

                VcPtr->OwnsVcBlock = TRUE;

                if (bCallerIsClient)
                {
                    //
                    //  Client-created VC, for an outgoing call.
                    //
                    VcBlock->pClientVcPtr = VcPtr;
                }
                else
                {
                    //
                    //  Call Manager-created VC, for an incoming call.
                    //
                    VcBlock->pProxyVcPtr = VcPtr;
                }
            }
            else
            {
                //
                //  The caller is a proxy.
                //
                if (bCallerIsClient)
                {
                    //
                    //  CreateVc from a proxy client to a real Call manager.
                    //
                    if (ExistingVcPtr == NULL)
                    {
                        //
                        //  Proxy client creating a new VC, e.g. for a TAPI outgoing call.
                        //
                        VcBlock->ClientOpen = pAf->ClientOpen;
                        VcBlock->CoReceivePacketHandler = pAf->ClientOpen->ProtocolHandle->ProtocolCharacteristics.CoReceivePacketHandler;
                        VcBlock->CoSendCompleteHandler = pAf->ClientOpen->ProtocolHandle->ProtocolCharacteristics.CoSendCompleteHandler;
                    }
                    else
                    {
                        //
                        //  Proxy client creating a VC on behalf of a CreateVc called
                        //  by a proxied client. The data handlers belong to the
                        //  proxied client, but deletion of this VC does not.
                        //
                        VcBlock->pClientVcPtr = ExistingVcPtr;
                        ExistingVcPtr->OwnsVcBlock = FALSE;  // Real (Proxied) Client doesn't own it
                    }

                    VcBlock->pProxyVcPtr = VcPtr;
                    VcPtr->OwnsVcBlock = TRUE; //  Proxy client owns it
                }
                else
                {
                    //
                    //  CreateVc from a proxy Call manager to a proxied client.
                    //
                    VcBlock->ClientOpen = pAf->ClientOpen;
                    VcBlock->CoReceivePacketHandler = pAf->ClientOpen->ProtocolHandle->ProtocolCharacteristics.CoReceivePacketHandler;
                    VcBlock->CoSendCompleteHandler = pAf->ClientOpen->ProtocolHandle->ProtocolCharacteristics.CoSendCompleteHandler;
                    VcBlock->pClientVcPtr = VcPtr;
    
                    if (ExistingVcPtr != NULL)
                    {
                        //
                        //  Proxy CM forwarding a call to a proxied client.
                        //
                        VcBlock->pProxyVcPtr = ExistingVcPtr;
                        ExistingVcPtr->OwnsVcBlock = TRUE;
                    }
                    else
                    {
                        //
                        //  Proxy CM creating a fresh VC to a proxied client.
                        //  No well-known examples of this case, here for completeness.
                        //
                        VcPtr->OwnsVcBlock = TRUE;
                    }
                }
            }

            //
            // Determine who the caller is and initialize the other. NOTE: As soon as the Proxy Create handler
            // is called, this function can get re-entered. Lock down the VcPtr.
            //
            ACQUIRE_SPIN_LOCK(&VcPtr->Lock, &OldIrql);

            if (Open == pAf->ClientOpen)
            {
                VcPtr->ClientContext = ProtocolVcContext;

                //
                // Call-up to the call-manager now to get its context
                //
                Status = (*pAf->CallMgrEntries->CmCreateVcHandler)(pAf->CallMgrContext,
                                                                   VcPtr,
                                                                   &VcPtr->CallMgrContext);
                if (bVcToComboMiniport)
                {
                    //
                    //  Need the MiniportContext field filled in for NdisCoSendPackets
                    //
                    VcPtr->MiniportContext = VcPtr->CallMgrContext;
                }
            }
            else
            {
                ASSERT(pAf->CallMgrOpen == Open);

                VcPtr->CallMgrContext = ProtocolVcContext;

                //
                // Call-up to the client now to get its context
                //
                Status = (*pAf->ClientOpen->CoCreateVcHandler)(pAf->ClientContext,
                                                               VcPtr,
                                                               &VcPtr->ClientContext);
            }

            //
            // Set up Client Context in VC if non-proxy, so the miniport passes the right client
            // context (client's handle to the VcPtr) when indicating packets. If the passd-in handle
            // is NULL, it's simple -- move the context. If it's not NULL, AND this is a Proxy call mgr,
            // move it so data goes to the new client and not to the Proxy.
            //
            if ((Status == NDIS_STATUS_SUCCESS) &&
                ((ExistingVcPtr == NULL) || (bCallerIsProxy && !bCallerIsClient)))
            {
                VcBlock->ClientContext = VcPtr->ClientContext;
            }

            if (ExistingVcPtr != NULL)
            {
                VcBlock->Flags &= ~VC_HANDOFF_IN_PROGRESS;
            }

            RELEASE_SPIN_LOCK(&VcPtr->Lock, OldIrql);

            if (Status == NDIS_STATUS_SUCCESS)
            {
                //
                //  Link this VC Pointer in the client's and call manager's
                //  Open blocks. Also remember the DeleteVc handler of the
                //  non-creator of this VC pointer, to be called when this
                //  VC pointer is deleted.
                //
                if (bCallerIsClient)
                {
                    //
                    //  Link into Client's Open block.
                    //
                    ExInterlockedInsertHeadList(&Open->InactiveVcHead,
                                                &VcPtr->ClientLink,
                                                &Open->SpinLock);

                    VcPtr->DeleteVcContext = VcPtr->CallMgrContext;
                    VcPtr->CoDeleteVcHandler = pAf->CallMgrEntries->CmDeleteVcHandler;

                    if (!bVcToComboMiniport)
                    {
                        //
                        //  Link into CM's Open block.
                        //
                        ExInterlockedInsertHeadList(&pAf->CallMgrOpen->InactiveVcHead,
                                                    &VcPtr->CallMgrLink,
                                                    &pAf->CallMgrOpen->SpinLock);
                    }
                }
                else
                {
                    //
                    //  Caller is a Call Manager.
                    //
                    VcPtr->DeleteVcContext = VcPtr->ClientContext;
                    VcPtr->CoDeleteVcHandler = pAf->ClientOpen->CoDeleteVcHandler;

                    ExInterlockedInsertHeadList(&Open->InactiveVcHead,
                                                &VcPtr->CallMgrLink,
                                                &Open->SpinLock);
                    ExInterlockedInsertHeadList(&pAf->ClientOpen->InactiveVcHead,
                                                &VcPtr->ClientLink,
                                                &pAf->ClientOpen->SpinLock);
                }
            }
            else
            {
                //
                //  The target protocol (Client or CM) failed CreateVc.
                //  Tell the miniport about it.
                //
                NDIS_STATUS Sts;

                if (!bVcToComboMiniport)
                {
                    Sts = (*VcPtr->WCoDeleteVcHandler)(VcPtr->MiniportContext);
                }

                if (ExistingVcPtr == NULL)
                {
                    FREE_POOL(VcBlock);
                }

                FREE_POOL(VcPtr);
                VcPtr = NULL;
            }
        }
        else
        {
            //
            // No AF handle present. This is a call-manager only VC and so the call-manager
            // is the client and there is no call-manager associated with it. This VC cannot
            // be used with a ClMakeCall or CmDispatchIncomingCall. Set the client values to the
            // call-manager
            //
            DBGPRINT(DBG_COMP_CO, DBG_LEVEL_INFO,
                    ("NdisCoCreateVc: signaling vc\n"));
    
            VcPtr->ClientOpen = Open;
            VcPtr->ClientContext = ProtocolVcContext;
    
            VcBlock->pClientVcPtr = VcPtr;
            VcPtr->OwnsVcBlock = TRUE; // CM owns the VC block
    
            VcBlock->ClientContext = VcPtr->ClientContext;
            VcBlock->ClientOpen = Open;
            VcBlock->CoSendCompleteHandler = Open->ProtocolHandle->ProtocolCharacteristics.CoSendCompleteHandler;
            VcBlock->CoReceivePacketHandler = Open->ProtocolHandle->ProtocolCharacteristics.CoReceivePacketHandler;
    
            //
            // Do set the following call-manager entries since this VC will need to be
            // activated. Also set the call-managers context for the same reasons.
            //
            VcPtr->CmActivateVcCompleteHandler = Open->CmActivateVcCompleteHandler;
            VcPtr->CmDeactivateVcCompleteHandler = Open->CmDeactivateVcCompleteHandler;
            VcPtr->CallMgrContext = ProtocolVcContext;
    
            //
            // Link this in the open_block
            //
            ExInterlockedInsertHeadList(&Open->InactiveVcHead,
                                        &VcPtr->ClientLink,
                                        &Open->SpinLock);
        }
        break;
    }
    while (FALSE);

    if (NDIS_STATUS_SUCCESS == Status)
    {
        LARGE_INTEGER   Increment = {0, 1};

        //
        //  Assign this VC an ID and update the miniports count.
        //
        VcPtr->VcIndex = ExInterlockedAddLargeInteger(&Miniport->VcIndex, Increment, &ndisGlobalLock);
    }

    *NdisVcHandle = VcPtr;
    DBGPRINT(DBG_COMP_CO, DBG_LEVEL_INFO,
            ("<=NdisCoCreateVc: VcPtr %x, Status %x\n", VcPtr, Status));

    return Status;
}


NDIS_STATUS
NdisCoDeleteVc(
    IN  PNDIS_HANDLE            NdisVcHandle
    )
/*++

Routine Description:

    Synchronous call from either the call-manager or the client to delete a VC. Only inactive
    VCs can be deleted. Active Vcs or partially active Vcs cannot be.

Arguments:

    NdisVcHandle    The Vc to delete

Return Value:

    NDIS_STATUS_SUCCESS         If all goes well
    NDIS_STATUS_NOT_ACCEPTED    If Vc is active
    NDIS_STATUS_CLOSING         If Vc de-activation is pending

--*/
{
    PNDIS_CO_VC_PTR_BLOCK       VcPtr = (PNDIS_CO_VC_PTR_BLOCK)NdisVcHandle;
    NDIS_STATUS                 Status;
    KIRQL                       OldIrql;

    DBGPRINT(DBG_COMP_CO, DBG_LEVEL_INFO,
            ("NdisCoDeleteVc VcPtr %x/%x, Ref %d VcBlock %x, Flags %x\n",
             VcPtr, VcPtr->CallFlags, VcPtr->References, VcPtr->VcBlock, *VcPtr->pVcFlags));

    ACQUIRE_SPIN_LOCK(&VcPtr->Lock, &OldIrql);

    if (*VcPtr->pVcFlags & (VC_ACTIVE | VC_ACTIVATE_PENDING))
    {
        Status = NDIS_STATUS_NOT_ACCEPTED;
    }
    else if (*VcPtr->pVcFlags & (VC_DEACTIVATE_PENDING))
    {
        Status = NDIS_STATUS_CLOSING;
    }
    else
    {
        //
        // Take this VcPtr out of the VC's list
        //
        // If the VC isn't already closing mark it as closing.
        //
        // We call the miniport's delete handler if the VC block's Proxy ptr points
        // to this VC ptr. (This indicates that the VC block is owned/created by the
        // CM/Proxy, not the CL).
        //
        // NOTE: We don't delete the VC until all these pointers
        // have gone since the Proxy may wish to redirect the VC to another protocol.
        // However, in general the Proxy would follow a call to DeleteVc for the Client ptr
        // with one for the Proxy.
        // (Note the MP context refers to the VC, not the VcPtr).
        //
        VcPtr->CallFlags |= VC_PTR_BLOCK_CLOSING;

        if (VcPtr->OwnsVcBlock &&
            (VcPtr->WCoDeleteVcHandler != NULL))
        {
            *VcPtr->pVcFlags |= VC_DELETE_PENDING;
        }

        //
        //  If this VC is responding to WMI then get rid of it.
        //
        if (NULL != VcPtr->VcInstanceName.Buffer)
        {
            //
            //  Notify the removal of this VC.
            //
            PWNODE_SINGLE_INSTANCE  wnode;
            PUCHAR                  ptmp;
            NTSTATUS                NtStatus;

            ndisSetupWmiNode(VcPtr->Miniport,
                             &VcPtr->VcInstanceName,
                             0,
                             (PVOID)&GUID_NDIS_NOTIFY_VC_REMOVAL,
                             &wnode);

            if (wnode != NULL)
            {
        
                //
                //  Indicate the event to WMI. WMI will take care of freeing
                //  the WMI struct back to pool.
                //
                NtStatus = IoWMIWriteEvent(wnode);
                if (!NT_SUCCESS(NtStatus))
                {
                    DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_ERR,
                        ("IoWMIWriteEvent failed %lx\n", NtStatus));
            
                    FREE_POOL(wnode);
                }
            }

            ACQUIRE_SPIN_LOCK_DPC(&VcPtr->Miniport->VcCountLock);

            //
            //  Remove the VC from the list of WMI enabled VCs
            //
            RemoveEntryList(&VcPtr->WmiLink);
    
            //
            //  Decrement the number of VC's that have names assigned to them.
            //
            VcPtr->Miniport->VcCount--;

            //
            //  Free the VC's name buffer.
            //
            FREE_POOL(VcPtr->VcInstanceName.Buffer);

            VcPtr->VcInstanceName.Buffer = NULL;
            VcPtr->VcInstanceName.Length = VcPtr->VcInstanceName.MaximumLength = 0;
    
            RELEASE_SPIN_LOCK_DPC(&VcPtr->Miniport->VcCountLock);
        }

        //
        // Next the non-creator's delete handler, if any
        //
        if (VcPtr->CoDeleteVcHandler != NULL)
        {
            Status = (*VcPtr->CoDeleteVcHandler)(VcPtr->DeleteVcContext);
            ASSERT(Status == NDIS_STATUS_SUCCESS);
        }

        //
        // Now de-link the VcPtr from the client and the call-manager
        //
        ACQUIRE_SPIN_LOCK_DPC(&VcPtr->ClientOpen->SpinLock);
        RemoveEntryList(&VcPtr->ClientLink);
        RELEASE_SPIN_LOCK_DPC(&VcPtr->ClientOpen->SpinLock);

        if (VcPtr->CallMgrOpen != NULL)
        {
            ACQUIRE_SPIN_LOCK_DPC(&VcPtr->CallMgrOpen->SpinLock);
            RemoveEntryList(&VcPtr->CallMgrLink);
            RELEASE_SPIN_LOCK_DPC(&VcPtr->CallMgrOpen->SpinLock);
        }

        Status = NDIS_STATUS_SUCCESS;
    }

    RELEASE_SPIN_LOCK(&VcPtr->Lock, OldIrql);

    if (Status == NDIS_STATUS_SUCCESS)
    {
        ndisDereferenceVcPtr(VcPtr);
    }

    return Status;
}


NDIS_STATUS
NdisMCmCreateVc(
    IN  NDIS_HANDLE             MiniportAdapterHandle,
    IN  NDIS_HANDLE             NdisAfHandle,
    IN  NDIS_HANDLE             MiniportVcContext,
    OUT PNDIS_HANDLE            NdisVcHandle
    )
/*++

Routine Description:

    This is a call by the miniport (with a resident CM) to create a Vc for an incoming call.

Arguments:
    MiniportAdapterHandle - Miniport's adapter context
    NdisAfHandle        - Pointer to the AF Block.
    MiniportVcContext   - Miniport's context to associate with this vc.
    NdisVcHandle        - Where the handle to this Vc will be returned.

Return Value:
    NDIS_STATUS_SUCCESS if all the components succeed.
    ErrorCode           to signify why the call failed.

--*/
{
    PNDIS_MINIPORT_BLOCK    Miniport = (PNDIS_MINIPORT_BLOCK)MiniportAdapterHandle;
    PNDIS_CO_VC_BLOCK       VcBlock;
    PNDIS_CO_AF_BLOCK       pAf;
    PNDIS_CO_VC_PTR_BLOCK   VcPtr;
    NDIS_STATUS             Status;

    *NdisVcHandle = NULL;

    //
    // Allocate the memory for NDIS_VC_BLOCK
    //
    VcBlock = ALLOC_FROM_POOL(sizeof(NDIS_CO_VC_BLOCK), NDIS_TAG_CO);
    if (VcBlock == NULL)
        return NDIS_STATUS_RESOURCES;

    //
    // Initialize the VC block
    //
    NdisZeroMemory(VcBlock, sizeof(NDIS_CO_VC_BLOCK));
    INITIALIZE_SPIN_LOCK(&VcBlock->Lock);

    //
    // Allocate the memory for NDIS_VC_PTR_BLOCK
    //
    VcPtr = ALLOC_FROM_POOL(sizeof(NDIS_CO_VC_PTR_BLOCK), NDIS_TAG_CO);
    if (VcPtr == NULL)
    {
        FREE_POOL(VcBlock);
        return NDIS_STATUS_RESOURCES;
    }

    //
    // Initialize the VC Pointer block
    //
    NdisZeroMemory(VcPtr, sizeof(NDIS_CO_VC_PTR_BLOCK));
    INITIALIZE_SPIN_LOCK(&VcPtr->Lock);

    //
    // Cache some miniport handlers
    //
    VcPtr->Miniport = Miniport;
    VcPtr->WCoSendPacketsHandler = Miniport->DriverHandle->MiniportCharacteristics.CoSendPacketsHandler;
    VcPtr->WCoDeleteVcHandler = Miniport->DriverHandle->MiniportCharacteristics.CoDeleteVcHandler;
    VcPtr->WCoActivateVcHandler = Miniport->DriverHandle->MiniportCharacteristics.CoActivateVcHandler;
    VcPtr->WCoDeactivateVcHandler = Miniport->DriverHandle->MiniportCharacteristics.CoDeactivateVcHandler;

    VcBlock->Miniport = Miniport;
    VcBlock->MiniportContext = MiniportVcContext;

    VcPtr->MiniportContext = MiniportVcContext;

    //
    // Set up the VcBlock in the new VcPtr
    //
    VcPtr->VcBlock = VcBlock;

    // VcPtrs to preempt potential for unsynched state when Protocols, Miniports and
    // Miniport-exported Call Managers refer to VCs/VcPtrs as appropriate...similar
    // for References, which is accessed from Vc directly in IndicateReceivePacket.
    //
    VcPtr->pVcFlags = &VcBlock->Flags;

    //
    // We have only one reference for vc on creation.
    //
    pAf = (PNDIS_CO_AF_BLOCK)NdisAfHandle;
    VcPtr->AfBlock = pAf;
    VcPtr->References = 1;

    ASSERT(ARGUMENT_PRESENT(NdisAfHandle));

    VcPtr->ClientOpen = pAf->ClientOpen;
    VcPtr->CallMgrOpen = NULL;
    VcBlock->ClientOpen = pAf->ClientOpen;

    VcBlock->CoSendCompleteHandler = pAf->ClientOpen->ProtocolHandle->ProtocolCharacteristics.CoSendCompleteHandler;
    VcBlock->CoReceivePacketHandler = pAf->ClientOpen->ProtocolHandle->ProtocolCharacteristics.CoReceivePacketHandler;
    VcPtr->ClModifyCallQoSCompleteHandler = pAf->ClientEntries.ClModifyCallQoSCompleteHandler;
    VcPtr->ClIncomingCallQoSChangeHandler = pAf->ClientEntries.ClIncomingCallQoSChangeHandler;
    VcPtr->ClCallConnectedHandler = pAf->ClientEntries.ClCallConnectedHandler;

    VcPtr->CmActivateVcCompleteHandler = pAf->CallMgrEntries->CmActivateVcCompleteHandler;
    VcPtr->CmDeactivateVcCompleteHandler = pAf->CallMgrEntries->CmDeactivateVcCompleteHandler;
    VcPtr->CmModifyCallQoSHandler = pAf->CallMgrEntries->CmModifyCallQoSHandler;

    VcPtr->CallMgrContext = MiniportVcContext;
    VcBlock->CallMgrContext = MiniportVcContext;

    //
    // Call-up to the client now to get its context
    //
    Status = (*pAf->ClientOpen->CoCreateVcHandler)(pAf->ClientContext,
                                                   VcPtr,
                                                   &VcPtr->ClientContext);

    if (Status == NDIS_STATUS_SUCCESS)
    {
        //
        // Setup the client context in the VC block. This may be overwritten by the
        // new client context in a subsequent call to CoCreateVc by the proxy.
        // Link this in the open_block
        //
        VcBlock->ClientContext = VcPtr->ClientContext;
        VcPtr->DeleteVcContext = VcPtr->ClientContext;
        VcPtr->CoDeleteVcHandler = pAf->ClientOpen->CoDeleteVcHandler;
        ExInterlockedInsertHeadList(&pAf->ClientOpen->InactiveVcHead,
                                    &VcPtr->ClientLink,
                                    &pAf->ClientOpen->SpinLock);
        VcBlock->pClientVcPtr = VcPtr;
    }
    else
    {
        FREE_POOL(VcBlock);
        FREE_POOL(VcPtr);
        VcPtr = NULL;
    }

    *NdisVcHandle = VcPtr;
    return Status;
}


NDIS_STATUS
NdisMCmDeleteVc(
    IN  PNDIS_HANDLE            NdisVcHandle
    )
/*++

Routine Description:

    This is a called by the miniport (with a resident CM) to delete a Vc created by it. Identical to
    NdisMCoDeleteVc but a seperate api for completeness.

Arguments:

    NdisVcHandle    The Vc to delete

Return Value:

    NDIS_STATUS_SUCCESS         If all goes well
    NDIS_STATUS_NOT_ACCEPTED    If Vc is active
    NDIS_STATUS_CLOSING         If Vc de-activation is pending

--*/
{
    PNDIS_CO_VC_PTR_BLOCK   VcPtr = (PNDIS_CO_VC_PTR_BLOCK)NdisVcHandle;
    PNDIS_CO_VC_BLOCK       VcBlock = VcPtr->VcBlock;

    if (VcBlock->pProxyVcPtr != NULL)
    {
        return (NdisCoDeleteVc ((PNDIS_HANDLE)VcBlock->pProxyVcPtr));
    }
    else
    {
        ASSERT(VcBlock->pClientVcPtr != NULL);
        return (NdisCoDeleteVc((PNDIS_HANDLE)VcBlock->pClientVcPtr));
    }
}


NDIS_STATUS
NdisCmActivateVc(
    IN  PNDIS_HANDLE            NdisVcHandle,
    IN OUT PCO_CALL_PARAMETERS  CallParameters
    )
/*++

Routine Description:

    Called by the call-manager to set the Vc parameters on the Vc. The wrapper
    saved the media id (e.g. Vpi/Vci for atm) in the Vc so that a p-mode protocol can
    get this info as well on receives.

Arguments:

    NdisVcHandle    The Vc to set parameters on.
    MediaParameters The parameters to set.

Return Value:

    NDIS_STATUS_PENDING         If the miniport pends the call.
    NDIS_STATUS_CLOSING         If Vc de-activation is pending

--*/
{
    PNDIS_CO_VC_PTR_BLOCK   VcPtr = (PNDIS_CO_VC_PTR_BLOCK)NdisVcHandle;
    PNDIS_CO_VC_BLOCK       VcBlock = (PNDIS_CO_VC_BLOCK)VcPtr->VcBlock;
    NDIS_STATUS             Status;
    KIRQL                   OldIrql;

    DBGPRINT(DBG_COMP_CO, DBG_LEVEL_INFO,
            ("NdisCmActivateVC: VcPtr is 0x%x; VC is 0x%x; MiniportContext is 0x%x\n", VcPtr,
            VcPtr->VcBlock, VcPtr->MiniportContext));

    ACQUIRE_SPIN_LOCK(&VcPtr->Lock, &OldIrql);

    //
    // Make sure the Vc does not have an activation/de-activation pending
    // Not that it is ok for the Vc to be already active - then it is a re-activation.
    //
    if (*VcPtr->pVcFlags & VC_ACTIVATE_PENDING)
    {
        Status = NDIS_STATUS_NOT_ACCEPTED;
    }
    else if (*VcPtr->pVcFlags & VC_DEACTIVATE_PENDING)
    {
        Status = NDIS_STATUS_CLOSING;
    }
    else
    {
        *VcPtr->pVcFlags |= VC_ACTIVATE_PENDING;

        //
        // Save the media id for the Vc
        //
        Status = NDIS_STATUS_SUCCESS;
        ASSERT(CallParameters->MediaParameters->MediaSpecific.Length >= sizeof(ULONGLONG));
        VcBlock->VcId = *(UNALIGNED ULONGLONG *)(&CallParameters->MediaParameters->MediaSpecific.Parameters);
    }

    //
    // Set up CM Context and ActivateComplete handler in VC before
    // calling miniports activate func
    //
    VcBlock->CmActivateVcCompleteHandler = VcPtr->CmActivateVcCompleteHandler;
    VcBlock->CallMgrContext = VcPtr->CallMgrContext;

    RELEASE_SPIN_LOCK(&VcPtr->Lock, OldIrql);
    if (Status == NDIS_STATUS_SUCCESS)
    {
        //
        // Now call down to the miniport to activate it. MiniportContext contains
        // Miniport's handle for underlying VC (not VcPtr).
        //
        Status = (*VcPtr->WCoActivateVcHandler)(VcPtr->MiniportContext, CallParameters);
    }

    if (Status != NDIS_STATUS_PENDING)
    {
        NdisMCoActivateVcComplete(Status, VcPtr, CallParameters);
        Status = NDIS_STATUS_PENDING;
    }

    return Status;
}


NDIS_STATUS
NdisMCmActivateVc(
    IN  PNDIS_HANDLE            NdisVcHandle,
    IN  PCO_CALL_PARAMETERS     CallParameters
    )
/*++

Routine Description:
    Called by the miniport resident call-manager to set the Vc parameters on the Vc.

Arguments:

    NdisVcHandle    The Vc to set parameters on.
    MediaParameters The parameters to set.

Return Value:

    NDIS_STATUS_CLOSING         If Vc de-activation is pending

--*/
{
    PNDIS_CO_VC_PTR_BLOCK   VcPtr = (PNDIS_CO_VC_PTR_BLOCK)NdisVcHandle;
    PNDIS_CO_VC_BLOCK       VcBlock = VcPtr->VcBlock;
    NDIS_STATUS             Status;
    KIRQL                   OldIrql;

    ACQUIRE_SPIN_LOCK(&VcBlock->Lock, &OldIrql);

    VcBlock->Flags |= VC_ACTIVE;
    VcBlock->VcId = *(UNALIGNED ULONGLONG *)(&CallParameters->MediaParameters->MediaSpecific.Parameters);

    RELEASE_SPIN_LOCK(&VcBlock->Lock, OldIrql);

    Status = NDIS_STATUS_SUCCESS;
    return Status;
}


VOID
NdisMCoActivateVcComplete(
    IN  NDIS_STATUS             Status,
    IN  PNDIS_HANDLE            NdisVcHandle,
    IN  PCO_CALL_PARAMETERS     CallParameters
    )
/*++

Routine Description:

    Called by the mini-port to complete a pending activation call.
    Also called by CmActivateVc when the miniport doesn't pend the CreateVc call.
    Note that in the second case, we've copied the flags/context/CM function into the
    VC from the VC Ptr.

Arguments:

    Status          Status of activation.
    NdisVcHandle    The Vc in question.

Return Value:

    NONE
    The call-manager's completion routine is called.

--*/
{
    PNDIS_CO_VC_PTR_BLOCK   VcPtr = (PNDIS_CO_VC_PTR_BLOCK)NdisVcHandle;
    PNDIS_CO_VC_BLOCK       VcBlock = VcPtr->VcBlock;
    KIRQL                   OldIrql;

    ACQUIRE_SPIN_LOCK(&VcBlock->Lock, &OldIrql);

    ASSERT(VcBlock->Flags & VC_ACTIVATE_PENDING);

    VcBlock->Flags &= ~VC_ACTIVATE_PENDING;

    if (Status == NDIS_STATUS_SUCCESS)
    {
        VcBlock->Flags |= VC_ACTIVE;
    }

    RELEASE_SPIN_LOCK(&VcBlock->Lock, OldIrql);

    //
    // Complete the call to the call-manager
    //
    (*VcBlock->CmActivateVcCompleteHandler)(Status, VcBlock->CallMgrContext, CallParameters);
}


NDIS_STATUS
NdisCmDeactivateVc(
    IN  PNDIS_HANDLE            NdisVcHandle
    )
/*++

Routine Description:

    Called by the call-manager to de-activate a Vc.

Arguments:

    NdisVcHandle    The Vc to de-activate the Vc.

Return Value:

    NDIS_STATUS_PENDING         If the miniport pends the call.
    NDIS_STATUS_SUCCESS         If all goes well
    NDIS_STATUS_CLOSING         If Vc de-activation is pending

--*/
{
    PNDIS_CO_VC_PTR_BLOCK   VcPtr = (PNDIS_CO_VC_PTR_BLOCK)NdisVcHandle;
    PNDIS_CO_VC_BLOCK       VcBlock = VcPtr->VcBlock;
    NDIS_STATUS             Status;
    KIRQL                   OldIrql;

    ACQUIRE_SPIN_LOCK(&VcPtr->Lock, &OldIrql);

    if ((*VcPtr->pVcFlags & (VC_ACTIVE | VC_ACTIVATE_PENDING)) == 0)
    {
        Status = NDIS_STATUS_NOT_ACCEPTED;
    }
    else if (*VcPtr->pVcFlags & VC_DEACTIVATE_PENDING)
    {
        Status = NDIS_STATUS_CLOSING;
    }
    else
    {
        *VcPtr->pVcFlags |= VC_DEACTIVATE_PENDING;
    }

    RELEASE_SPIN_LOCK(&VcPtr->Lock, OldIrql);

    //
    // Set up flags, CM Context and DeactivateComplete handler in VC before
    // calling mimiports deactivate func
    //
    VcBlock->CmDeactivateVcCompleteHandler = VcPtr->CmDeactivateVcCompleteHandler;
    VcBlock->CallMgrContext = VcPtr->CallMgrContext;

    //
    // Now call down to the miniport to de-activate it
    //
    Status = (*VcPtr->WCoDeactivateVcHandler)(VcPtr->MiniportContext);

    if (Status != NDIS_STATUS_PENDING)
    {
        NdisMCoDeactivateVcComplete(Status, VcPtr);
        Status = NDIS_STATUS_PENDING;
    }

    return Status;
}


NDIS_STATUS
NdisMCmDeactivateVc(
    IN  PNDIS_HANDLE            NdisVcHandle
    )
/*++

Routine Description:

    Called by the miniport resident call-manager to de-activate the Vc. This is a
    synchronous call.

Arguments:

    NdisVcHandle    The Vc to set parameters on.

Return Value:

    NDIS_STATUS_NOT_ACCEPTED    If Vc is not activated
    NDIS_STATUS_SUCCESS         Otherwise

--*/
{
    PNDIS_CO_VC_PTR_BLOCK   VcPtr = (PNDIS_CO_VC_PTR_BLOCK)NdisVcHandle;
    PNDIS_CO_VC_BLOCK       VcBlock = VcPtr->VcBlock;
    NDIS_STATUS             Status;
    KIRQL                   OldIrql;

    ACQUIRE_SPIN_LOCK(&VcBlock->Lock, &OldIrql);

    if ((VcBlock->Flags & VC_ACTIVE) == 0)
    {
        Status = NDIS_STATUS_NOT_ACCEPTED;
    }
    else
    {
        Status = NDIS_STATUS_SUCCESS;
        VcBlock->Flags &= ~VC_ACTIVE;
    }

    RELEASE_SPIN_LOCK(&VcBlock->Lock, OldIrql);

    return Status;
}


VOID
NdisMCoDeactivateVcComplete(
    IN  NDIS_STATUS             Status,
    IN  PNDIS_HANDLE            NdisVcHandle
    )
/*++

Routine Description:

    Called by the mini-port to complete a pending de-activation of a Vc.

Arguments:

    NdisVcHandle    The Vc in question.

Return Value:

    NONE
    The call-manager's completion routine is called.

--*/
{
    PNDIS_CO_VC_PTR_BLOCK   VcPtr = (PNDIS_CO_VC_PTR_BLOCK)NdisVcHandle;
    PNDIS_CO_VC_BLOCK       VcBlock = VcPtr->VcBlock;
    KIRQL                   OldIrql;

    ACQUIRE_SPIN_LOCK(&VcBlock->Lock, &OldIrql);

    ASSERT(VcBlock->Flags & VC_DEACTIVATE_PENDING);

    VcBlock->Flags &= ~VC_DEACTIVATE_PENDING;

    if (Status == NDIS_STATUS_SUCCESS)
    {
        VcBlock->Flags &= ~VC_ACTIVE;
    }

    RELEASE_SPIN_LOCK(&VcBlock->Lock, OldIrql);

    //
    // Complete the call to the call-manager
    //
    (*VcBlock->CmDeactivateVcCompleteHandler)(Status, VcBlock->CallMgrContext);
}


NDIS_STATUS
NdisClMakeCall(
    IN  NDIS_HANDLE             NdisVcHandle,
    IN OUT PCO_CALL_PARAMETERS  CallParameters,
    IN  NDIS_HANDLE             ProtocolPartyContext    OPTIONAL,
    OUT PNDIS_HANDLE            NdisPartyHandle         OPTIONAL
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PNDIS_CO_VC_PTR_BLOCK       VcPtr = (PNDIS_CO_VC_PTR_BLOCK)NdisVcHandle;
    PNDIS_CO_AF_BLOCK           pAf;
    PNDIS_CO_PARTY_BLOCK        pParty = NULL;
    PVOID                       CallMgrPartyContext = NULL;
    NDIS_STATUS                 Status;
    KIRQL                       OldIrql;

    do
    {
        pAf = VcPtr->AfBlock;
        ASSERT(pAf != NULL);
        if (!ndisReferenceAf(pAf))
        {
            Status = NDIS_STATUS_FAILURE;
            break;
        }

        //
        // Ref the VC for the life of the active vc.
        // This is Deref'd is in MakeCallComplete If the call fails and CloseCallComplete
        // when it succeeds
        //
        if (!ndisReferenceVcPtr(VcPtr))
        {
            ndisDereferenceAf(pAf);
            Status = NDIS_STATUS_FAILURE;
            break;
        }

        if (ARGUMENT_PRESENT(NdisPartyHandle))
        {
            *NdisPartyHandle = NULL;
            pParty = (PNDIS_CO_PARTY_BLOCK)ALLOC_FROM_POOL(sizeof(NDIS_CO_PARTY_BLOCK),
                                                           NDIS_TAG_CO);
            if (pParty == NULL)
            {
                ndisDereferenceAf(pAf);
                ndisDereferenceVcPtr(VcPtr);
                Status = NDIS_STATUS_RESOURCES;
                break;
            }
            pParty->VcPtr = VcPtr;
            pParty->ClientContext = ProtocolPartyContext;
            pParty->ClIncomingDropPartyHandler = pAf->ClientEntries.ClIncomingDropPartyHandler;
            pParty->ClDropPartyCompleteHandler = pAf->ClientEntries.ClDropPartyCompleteHandler;
        }

        ACQUIRE_SPIN_LOCK(&VcPtr->Lock, &OldIrql);

        ASSERT((VcPtr->CallFlags & (VC_CALL_ACTIVE  |
                                    VC_CALL_PENDING |
                                    VC_CALL_ABORTED |
                                    VC_CALL_CLOSE_PENDING)) == 0);
        VcPtr->CallFlags |= VC_CALL_PENDING;

        RELEASE_SPIN_LOCK(&VcPtr->Lock, OldIrql);

        //
        // Pass the request off to the call manager
        //
        Status = (*pAf->CallMgrEntries->CmMakeCallHandler)(VcPtr->CallMgrContext,
                                                           CallParameters,
                                                           pParty,
                                                           &CallMgrPartyContext);

        if (Status != NDIS_STATUS_PENDING)
        {
            NdisCmMakeCallComplete(Status,
                                   VcPtr,
                                   pParty,
                                   CallMgrPartyContext,
                                   CallParameters);
            Status = NDIS_STATUS_PENDING;
        }
    } while (FALSE);

    return Status;
}


VOID
NdisCmMakeCallComplete(
    IN  NDIS_STATUS             Status,
    IN  NDIS_HANDLE             NdisVcHandle,
    IN  NDIS_HANDLE             NdisPartyHandle     OPTIONAL,
    IN  NDIS_HANDLE             CallMgrPartyContext OPTIONAL,
    IN  PCO_CALL_PARAMETERS     CallParameters
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PNDIS_CO_AF_BLOCK       pAf;
    PNDIS_CO_VC_PTR_BLOCK   VcPtr = (PNDIS_CO_VC_PTR_BLOCK)NdisVcHandle;
    PNDIS_CO_PARTY_BLOCK    pParty = (PNDIS_CO_PARTY_BLOCK)NdisPartyHandle;
    KIRQL                   OldIrql;
    BOOLEAN                 fAborted;

    DBGPRINT(DBG_COMP_CO, DBG_LEVEL_INFO,
            ("NdisCmMakeCallComplete(%x): VcPtr %x/%x, Ref %d, VCBlock %x/%x\n",
                Status, VcPtr, VcPtr->CallFlags, VcPtr->References,
                VcPtr->VcBlock, VcPtr->VcBlock->Flags));

    pAf = VcPtr->AfBlock;

    ASSERT(Status != NDIS_STATUS_PENDING);

    ACQUIRE_SPIN_LOCK(&VcPtr->Lock, &OldIrql);

    VcPtr->CallFlags &= ~VC_CALL_PENDING;
    if (Status == NDIS_STATUS_SUCCESS)
    {
        VcPtr->CallFlags |= VC_CALL_ACTIVE;
    }
    else
    {
        fAborted = ((VcPtr->CallFlags & VC_CALL_ABORTED) != 0);
    }

    RELEASE_SPIN_LOCK(&VcPtr->Lock, OldIrql);

    if (Status == NDIS_STATUS_SUCCESS)
    {
        //
        // Call completed successfully. Complete it to the client.
        //
        if (ARGUMENT_PRESENT(NdisPartyHandle))
        {
            pParty->CallMgrContext = CallMgrPartyContext;
            ndisReferenceVcPtr(VcPtr);
        }

        ACQUIRE_SPIN_LOCK(&pAf->ClientOpen->SpinLock, &OldIrql);
        RemoveEntryList(&VcPtr->ClientLink);
        InsertHeadList(&pAf->ClientOpen->ActiveVcHead,
                       &VcPtr->ClientLink);
        RELEASE_SPIN_LOCK(&pAf->ClientOpen->SpinLock, OldIrql);
    }
    else
    {
        //
        // Deref the VC and Af (was ref'd in MakeCall) - but only if the call was
        // not aborted. In this case CloseCall will do the right thing.
        //
        if (!fAborted)
        {
            ndisDereferenceVcPtr(VcPtr);
            ndisDereferenceAf(pAf);
            if (pParty)
            {
                FREE_POOL(pParty);
            }
        }

        DBGPRINT(DBG_COMP_CO, DBG_LEVEL_INFO,
                ("NdisCmMakeCallComplete: Failed %lx\n", Status));
    }

    (*pAf->ClientEntries.ClMakeCallCompleteHandler)(Status,
                                                    VcPtr->ClientContext,
                                                    pParty,
                                                    CallParameters);
}


NDIS_STATUS
NdisCmDispatchIncomingCall(
    IN  NDIS_HANDLE             NdisSapHandle,
    IN  NDIS_HANDLE             NdisVcHandle,
    IN OUT PCO_CALL_PARAMETERS  CallParameters
    )
/*++

Routine Description:

    Call from the call-manager to dispatch an incoming vc to the client who registered the Sap.
    The client is identified by the NdisSapHandle.

Arguments:

    NdisBindingHandle   - Identifies the miniport on which the Vc is created
    NdisSapHandle       - Identifies the client
    CallParameters      - Self explanatory
    NdisVcHandle        - Pointer to the NDIS_CO_VC_BLOCK created via NdisCmCreateVc

Return Value:

    Return value from the client or an processing error.

--*/
{
    PNDIS_CO_SAP_BLOCK      Sap;
    PNDIS_CO_VC_PTR_BLOCK   VcPtr;
    PNDIS_CO_AF_BLOCK       pAf;
    NDIS_STATUS             Status;

    Sap = (PNDIS_CO_SAP_BLOCK)NdisSapHandle;
    VcPtr = (PNDIS_CO_VC_PTR_BLOCK)NdisVcHandle;
    pAf = Sap->AfBlock;

    ASSERT(pAf == VcPtr->AfBlock);

    //
    // Make sure the SAP's not closing
    //
    if (!ndisReferenceSap(Sap))
    {
        return(NDIS_STATUS_FAILURE);
    }

    //
    // Make sure the AF is not closing
    //
    if (!ndisReferenceAf(pAf))
    {
        ndisDereferenceSap(Sap);
        return(NDIS_STATUS_FAILURE);
    }

    //
    // Notify the client of this call
    //
    Status = (*pAf->ClientEntries.ClIncomingCallHandler)(Sap->ClientContext,
                                                         VcPtr->ClientContext,
                                                         CallParameters);

    if (Status != NDIS_STATUS_PENDING)
    {
        NdisClIncomingCallComplete(Status, VcPtr, CallParameters);
        Status = NDIS_STATUS_PENDING;
    }

    ndisDereferenceSap(Sap);

    return Status;
}


VOID
NdisClIncomingCallComplete(
    IN  NDIS_STATUS             Status,
    IN  NDIS_HANDLE             NdisVcHandle,
    IN  PCO_CALL_PARAMETERS     CallParameters
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PNDIS_CO_VC_PTR_BLOCK   VcPtr = (PNDIS_CO_VC_PTR_BLOCK)NdisVcHandle;
    KIRQL                   OldIrql;

    ASSERT(Status != NDIS_STATUS_PENDING);

    if (Status == NDIS_STATUS_SUCCESS)
    {
        ACQUIRE_SPIN_LOCK(&VcPtr->ClientOpen->SpinLock, &OldIrql);
        //
        // Reference the VcPtr. This is dereferenced when NdisClCloseCall is called.
        //
        VcPtr->References ++;

        RemoveEntryList(&VcPtr->ClientLink);
        InsertHeadList(&VcPtr->ClientOpen->ActiveVcHead,
                       &VcPtr->ClientLink);

        RELEASE_SPIN_LOCK(&VcPtr->ClientOpen->SpinLock, OldIrql);

        ACQUIRE_SPIN_LOCK(&VcPtr->Lock, &OldIrql);
    
        ASSERT((VcPtr->CallFlags & (VC_CALL_ABORTED | VC_CALL_PENDING)) == 0);
    
        VcPtr->CallFlags |= VC_CALL_ACTIVE;
    
        RELEASE_SPIN_LOCK(&VcPtr->Lock, OldIrql);
    }

    //
    // Call the call-manager handler to notify that client is done with this.
    //
    (*VcPtr->AfBlock->CallMgrEntries->CmIncomingCallCompleteHandler)(
                                            Status,
                                            VcPtr->CallMgrContext,
                                            CallParameters);
}


VOID
NdisCmDispatchCallConnected(
    IN  NDIS_HANDLE             NdisVcHandle
    )
/*++

Routine Description:

    Called by the call-manager to complete the final hand-shake on an incoming call.

Arguments:

    NdisVcHandle    - Pointer to the vc block

Return Value:

    None.

--*/
{
    PNDIS_CO_VC_PTR_BLOCK   VcPtr = (PNDIS_CO_VC_PTR_BLOCK)NdisVcHandle;

    (*VcPtr->ClCallConnectedHandler)(VcPtr->ClientContext);
}


NDIS_STATUS
NdisClModifyCallQoS(
    IN  NDIS_HANDLE             NdisVcHandle,
    IN  PCO_CALL_PARAMETERS     CallParameters
    )
/*++

Routine Description:

    Initiated by the client to modify the QoS associated with the call.

Arguments:

    NdisVcHandle    - Pointer to the vc block
    CallParameters  - New call QoS

Return Value:


--*/
{
    PNDIS_CO_VC_PTR_BLOCK   VcPtr = (PNDIS_CO_VC_PTR_BLOCK)NdisVcHandle;
    NDIS_STATUS             Status;

    //
    // Ask the call-manager to take care of this
    //
    Status = (*VcPtr->CmModifyCallQoSHandler)(VcPtr->CallMgrContext,
                                                  CallParameters);
    return Status;
}

VOID
NdisCmModifyCallQoSComplete(
    IN  NDIS_STATUS             Status,
    IN  NDIS_HANDLE             NdisVcHandle,
    IN  PCO_CALL_PARAMETERS     CallParameters
    )
{
    PNDIS_CO_VC_PTR_BLOCK   VcPtr = (PNDIS_CO_VC_PTR_BLOCK)NdisVcHandle;

    //
    // Simply notify the client
    //
    (*VcPtr->ClModifyCallQoSCompleteHandler)(Status,
                                          VcPtr->ClientContext,
                                          CallParameters);
}


VOID
NdisCmDispatchIncomingCallQoSChange(
    IN  NDIS_HANDLE             NdisVcHandle,
    IN  PCO_CALL_PARAMETERS     CallParameters
    )
/*++

Routine Description:

    Called by the call-manager to indicate a remote requested change in the call-qos. This is
    simply an indication. A client must respond by either accepting it (do nothing) or reject
    it (by either modifying the call qos or by tearing down the call).

Arguments:

    NdisVcHandle    - Pointer to the vc block
    CallParameters  - New call qos

Return Value:

    None.

--*/
{
    PNDIS_CO_VC_PTR_BLOCK   VcPtr = (PNDIS_CO_VC_PTR_BLOCK)NdisVcHandle;

    //
    // Simply notify the client
    //
    (*VcPtr->ClIncomingCallQoSChangeHandler)(VcPtr->ClientContext,
                                          CallParameters);
}


NDIS_STATUS
NdisClCloseCall(
    IN  NDIS_HANDLE             NdisVcHandle,
    IN  NDIS_HANDLE             NdisPartyHandle OPTIONAL,
    IN  PVOID                   Buffer          OPTIONAL,
    IN  UINT                    Size            OPTIONAL
    )
/*++

Routine Description:

    Called by the client to close down a connection established via either NdisClMakeCall
    or accepting an incoming call via NdisClIncomingCallComplete. The optional buffer can
    be specified by the client to send a disconnect message. Upto the call-manager to do
    something reasonable with it.

Arguments:

    NdisVcHandle    - Pointer to the vc block
    Buffer          - Optional disconnect message
    Size            - Size of the disconnect message

Return Value:

--*/
{
    PNDIS_CO_VC_PTR_BLOCK   VcPtr = (PNDIS_CO_VC_PTR_BLOCK)NdisVcHandle;
    PNDIS_CO_PARTY_BLOCK    pParty = (PNDIS_CO_PARTY_BLOCK)NdisPartyHandle;
    NDIS_STATUS             Status;
    KIRQL                   OldIrql;

    DBGPRINT(DBG_COMP_CO, DBG_LEVEL_INFO,
            ("NdisClCloseCall: VcPtr %x/%x, Ref %d, VCBlock %x/%x\n",
                VcPtr, VcPtr->CallFlags, VcPtr->References,
                VcPtr->VcBlock, VcPtr->VcBlock->Flags));
    //
    // Ref the VC. (Gets DeRef'd in CloseCallComplete)
    //
    if (!ndisReferenceVcPtr(VcPtr))
    {
        return (NDIS_STATUS_FAILURE);
    }

    ACQUIRE_SPIN_LOCK(&VcPtr->Lock, &OldIrql);

    VcPtr->CallFlags |= VC_CALL_CLOSE_PENDING;
    if (VcPtr->CallFlags & VC_CALL_PENDING)
        VcPtr->CallFlags |= VC_CALL_ABORTED;

    RELEASE_SPIN_LOCK(&VcPtr->Lock, OldIrql);

    //
    // Simply notify the call-manager
    //
    Status = (*VcPtr->AfBlock->CallMgrEntries->CmCloseCallHandler)(VcPtr->CallMgrContext,
                                                                (pParty != NULL) ?
                                                                    pParty->CallMgrContext :
                                                                    NULL,
                                                                Buffer,
                                                                Size);
    if (Status != NDIS_STATUS_PENDING)
    {
        NdisCmCloseCallComplete(Status, VcPtr, pParty);
        Status = NDIS_STATUS_PENDING;
    }

    return Status;
}


VOID
NdisCmCloseCallComplete(
    IN  NDIS_STATUS             Status,
    IN  NDIS_HANDLE             NdisVcHandle,
    IN  NDIS_HANDLE             NdisPartyHandle OPTIONAL
    )
/*++

Routine Description:



Arguments:

    NdisVcHandle    - Pointer to the vc block

Return Value:

    Nothing. Client handler called

--*/

{
    PNDIS_CO_VC_PTR_BLOCK   VcPtr = (PNDIS_CO_VC_PTR_BLOCK)NdisVcHandle;
    PNDIS_CO_PARTY_BLOCK    pParty = (PNDIS_CO_PARTY_BLOCK)NdisPartyHandle;
    NDIS_HANDLE             ClientVcContext;
    NDIS_HANDLE             ClientPartyContext;
    CL_CLOSE_CALL_COMPLETE_HANDLER  CloseCallCompleteHandler;
    KIRQL                   OldIrql;
    ULONG                   VcFlags;

    DBGPRINT(DBG_COMP_CO, DBG_LEVEL_INFO,
            ("NdisCmCloseCallComplete(%x): VcPtr %x/%x, Ref %d, VCBlock %x/%x\n",
                Status, VcPtr, VcPtr->CallFlags, VcPtr->References,
                VcPtr->VcBlock, VcPtr->VcBlock->Flags));

    ACQUIRE_SPIN_LOCK(&VcPtr->Lock, &OldIrql);

    VcPtr->CallFlags &= ~(VC_CALL_CLOSE_PENDING | VC_CALL_ABORTED);

    ClientVcContext = VcPtr->ClientContext;
    ClientPartyContext = (pParty != NULL)? pParty->ClientContext: NULL;
    CloseCallCompleteHandler = VcPtr->AfBlock->ClientEntries.ClCloseCallCompleteHandler;

    if (Status == NDIS_STATUS_SUCCESS)
    {
        VcFlags = VcPtr->CallFlags;

        VcPtr->CallFlags &= ~(VC_CALL_ACTIVE);

        RELEASE_SPIN_LOCK(&VcPtr->Lock, OldIrql);

        if (pParty != NULL)
        {
            ASSERT(VcPtr == pParty->VcPtr);
            ndisDereferenceVcPtr(pParty->VcPtr);
            FREE_POOL(pParty);
        }

        //
        // Deref the Vc and Af for refs taken in MakeCall/IncomingCallComplete
        //
        ndisDereferenceAf(VcPtr->AfBlock);
        if (VcFlags & VC_CALL_ACTIVE)
        {
            ndisDereferenceVcPtr(VcPtr);
        }
    }
    else
    {
        //
        // Leave the VC and VC Ptr in their original states (before this
        // failed CloseCall happened)
        //
        RELEASE_SPIN_LOCK(&VcPtr->Lock, OldIrql);
    }

    //
    // Deref the VC (Refs were taken in CloseCall)
    //
    ndisDereferenceVcPtr(VcPtr);

    //
    // Now inform the client of CloseCall completion.
    //
    (*CloseCallCompleteHandler)(Status,
                                ClientVcContext,
                                ClientPartyContext);
}


VOID
NdisCmDispatchIncomingCloseCall(
    IN  NDIS_STATUS             CloseStatus,
    IN  NDIS_HANDLE             NdisVcHandle,
    IN  PVOID                   Buffer,
    IN  UINT                    Size
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PNDIS_CO_VC_PTR_BLOCK   VcPtr = (PNDIS_CO_VC_PTR_BLOCK)NdisVcHandle;

    //
    // Notify the client
    //
    (*VcPtr->AfBlock->ClientEntries.ClIncomingCloseCallHandler)(
                                    CloseStatus,
                                    VcPtr->ClientContext,
                                    Buffer,
                                    Size);
}


NDIS_STATUS
NdisClAddParty(
    IN  NDIS_HANDLE             NdisVcHandle,
    IN  NDIS_HANDLE             ProtocolPartyContext,
    IN OUT PCO_CALL_PARAMETERS  CallParameters,
    OUT PNDIS_HANDLE            NdisPartyHandle
    )
/*++

Routine Description:

    Call from the client to the call-manager to add a party to a point-to-multi-point call.

Arguments:

    NdisVcHandle         - The handle client obtained via NdisClMakeCall()
    ProtocolPartyContext - Protocol's context for this leaf
    Flags                - Call flags
    CallParameters       - Call parameters
    NdisPartyHandle      - Place holder for the handle to identify the leaf

Return Value:

    NDIS_STATUS_PENDING The call has pended and will complete via CoAddPartyCompleteHandler.

--*/
{
    PNDIS_CO_VC_PTR_BLOCK       VcPtr = (PNDIS_CO_VC_PTR_BLOCK)NdisVcHandle;
    PNDIS_CO_PARTY_BLOCK    pParty;
    NDIS_STATUS             Status;

    do
    {
        *NdisPartyHandle = NULL;
        if (!ndisReferenceVcPtr(VcPtr))
        {
            Status = NDIS_STATUS_FAILURE;
            break;
        }

        pParty = ALLOC_FROM_POOL(sizeof(NDIS_CO_PARTY_BLOCK), NDIS_TAG_CO);
        if (pParty == NULL)
        {
            Status = NDIS_STATUS_RESOURCES;
            break;
        }

        pParty->ClientContext = ProtocolPartyContext;
        pParty->VcPtr = VcPtr;
        pParty->ClIncomingDropPartyHandler = VcPtr->AfBlock->ClientEntries.ClIncomingDropPartyHandler;
        pParty->ClDropPartyCompleteHandler = VcPtr->AfBlock->ClientEntries.ClDropPartyCompleteHandler;

        //
        // Simply call the call-manager to do its stuff.
        //
        Status = (*VcPtr->AfBlock->CallMgrEntries->CmAddPartyHandler)(
                                            VcPtr->CallMgrContext,
                                            CallParameters,
                                            pParty,
                                            &pParty->CallMgrContext);

        if (Status != NDIS_STATUS_PENDING)
        {
            NdisCmAddPartyComplete(Status,
                                   pParty,
                                   pParty->CallMgrContext,
                                   CallParameters);
            Status = NDIS_STATUS_PENDING;
        }
    } while (FALSE);

    return Status;
}


VOID
NdisCmAddPartyComplete(
    IN  NDIS_STATUS             Status,
    IN  NDIS_HANDLE             NdisPartyHandle,
    IN  NDIS_HANDLE             CallMgrPartyContext OPTIONAL,
    IN  PCO_CALL_PARAMETERS     CallParameters
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PNDIS_CO_PARTY_BLOCK    pParty = (PNDIS_CO_PARTY_BLOCK)NdisPartyHandle;

    ASSERT(Status != NDIS_STATUS_PENDING);

    if (Status == NDIS_STATUS_SUCCESS)
    {
        pParty->CallMgrContext = CallMgrPartyContext;
    }

    //
    // Complete the call to the client
    //
    (*pParty->VcPtr->AfBlock->ClientEntries.ClAddPartyCompleteHandler)(
                                    Status,
                                    pParty->ClientContext,
                                    pParty,
                                    CallParameters);

    if (Status != NDIS_STATUS_SUCCESS)
    {
        ndisDereferenceVcPtr(pParty->VcPtr);
        FREE_POOL(pParty);
    }
}


NDIS_STATUS
NdisClDropParty(
    IN  NDIS_HANDLE             NdisPartyHandle,
    IN  PVOID                   Buffer          OPTIONAL,
    IN  UINT                    Size            OPTIONAL
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PNDIS_CO_PARTY_BLOCK    pParty = (PNDIS_CO_PARTY_BLOCK)NdisPartyHandle;
    NDIS_STATUS             Status;

    //
    // Pass it along to the call-manager to handle this
    //
    Status = (*pParty->VcPtr->AfBlock->CallMgrEntries->CmDropPartyHandler)(
                                        pParty->CallMgrContext,
                                        Buffer,
                                        Size);

    if (Status != NDIS_STATUS_PENDING)
    {
        NdisCmDropPartyComplete(Status, pParty);
        Status = NDIS_STATUS_PENDING;
    }

    return Status;
}


NTSTATUS
ndisUnicodeStringToPointer(
    IN  PUNICODE_STRING         String,
    IN  ULONG                   Base OPTIONAL,
    OUT PVOID *                 Value
    )
/*++

Routine Description:
    Converts an address represented as a unicode string into a pointer.
    (stolen from RtlUnicodeStringToInteger() in ntos\rtl\cnvint.c)
    
Arguments:
    String  -   The Unicode String holding the address
    Base    -   Radix of the address represented in the string (2, 8, 10, or 16)
    Value   -   Address of the pointer in which to store the address.
    
Return Value:
    STATUS_SUCCESS - for successful conversion
    STATUS_INVALID_ARG - if the base supplied is invalid
    Other exception code - if another exception occurs

--*/
{
    PCWSTR  s;
    WCHAR   c, Sign;
    ULONG   nChars, Digit, Shift;

#if defined(_WIN64)
    ULONGLONG Result; 
#else
    ULONG Result;
#endif  

    s = String->Buffer;
    nChars = String->Length / sizeof( WCHAR );

    while (nChars-- && (Sign = *s++) <= ' ')
    {
        if (!nChars)
        {
            Sign = UNICODE_NULL;
            break;
        }
    }

    c = Sign;
    if ((c == L'-') || (c == L'+'))
    {
        if (nChars)
        {
            nChars--;
            c = *s++;
        }
        else
        {
            c = UNICODE_NULL;
        }
    }

    if (Base == 0)
    {
        Base = 10;
        Shift = 0;
        if (c == L'0')
        {
            if (nChars)
            {
                nChars--;
                c = *s++;
                if (c == L'x')
                {
                    Base = 16;
                    Shift = 4;
                }
                else
                if (c == L'o')
                {
                    Base = 8;
                    Shift = 3;
                }
                else
                if (c == L'b')
                {
                    Base = 2;
                    Shift = 1;
                    }
                else
                {
                    nChars++;
                    s--;
                }
            }

            if (nChars)
            {
                nChars--;
                c = *s++;
            }
            else
            {
                c = UNICODE_NULL;
            }
        }
    }
    else
    {
        switch(Base)
        {
          case 16:
            Shift = 4;
            break;
          case  8:
              Shift = 3;
              break;
          case  2:
            Shift = 1;
            break;
          case 10:
            Shift = 0;
            break;
          default:
            return(STATUS_INVALID_PARAMETER);
        }
    }

    Result = 0;
    while (c != UNICODE_NULL)
    {
        if (c >= L'0' && c <= L'9')
        {
            Digit = c - L'0';
        }
        else if (c >= L'A' && c <= L'F')
        {
            Digit = c - L'A' + 10;
        }
        else if (c >= L'a' && c <= L'f')
        {
            Digit = c - L'a' + 10;
        }
        else
        {
            break;
        }

        if (Digit >= Base)
        {
            break;
        }

        if (Shift == 0)
        {
            Result = (Base * Result) + Digit;
        }
        else
        {
            Result = (Result << Shift) | Digit;
        }

        if (!nChars)
        {
            break;
        }
        nChars--;
        c = *s++;
    }

    if (Sign == L'-')
    {
#if defined(_WIN64)
    Result = (ULONGLONG)(-(LONGLONG)Result);
#else   
    Result = (ULONG)(-(LONG)Result);
#endif
    }

    try
    {
        *Value = (PVOID)Result;
    }
    except(EXCEPTION_EXECUTE_HANDLER)
    {
        return (GetExceptionCode());
    }

    return( STATUS_SUCCESS );
}


NDIS_STATUS
NdisClGetProtocolVcContextFromTapiCallId(
    IN  UNICODE_STRING          TapiCallId,
    OUT PNDIS_HANDLE            ProtocolVcContext
    )
/*++

Routine Description:
    Retrieves the protocol VC context for a VC identified by a TAPI Call ID string
    (this string is the UNICODE representation of the identifier returned by
     NdisCoGetTapiCallId).
     
Arguments:
    TapiCallId          - A TAPI Call Id String 
    ProtocolVcContext   - Pointer to a NDIS_HANDLE variable in which to store the 
                          Protocol VC Context 

Return Value:
    NDIS_STATUS_FAILURE if the VC context could not be obtained, NDIS_STATUS_SUCCESS
    otherwise.

--*/
{
    NTSTATUS    Status = ndisUnicodeStringToPointer(&TapiCallId,
                                                    16, 
                                                    (PVOID *)ProtocolVcContext);

    return (NT_SUCCESS(Status) ? NDIS_STATUS_SUCCESS : NDIS_STATUS_FAILURE);
}


VOID
NdisCmDropPartyComplete(
    IN  NDIS_STATUS             Status,
    IN  NDIS_HANDLE             NdisPartyHandle
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PNDIS_CO_PARTY_BLOCK    pParty = (PNDIS_CO_PARTY_BLOCK)NdisPartyHandle;

    ASSERT(Status != NDIS_STATUS_PENDING);

    //
    // Complete the call to the client
    //
    (*pParty->ClDropPartyCompleteHandler)(Status,
                                          pParty->ClientContext);
    if (Status == NDIS_STATUS_SUCCESS)
    {
        ndisDereferenceVcPtr(pParty->VcPtr);
        FREE_POOL(pParty);
    }
}


VOID
NdisCmDispatchIncomingDropParty(
    IN  NDIS_STATUS             DropStatus,
    IN  NDIS_HANDLE             NdisPartyHandle,
    IN  PVOID                   Buffer,
    IN  UINT                    Size
    )
/*++

Routine Description:

    Called by the call-manager to notify the client that this leaf of the multi-party
    call is terminated. The client cannot use the NdisPartyHandle after completing this
    call - synchronously or by calling NdisClIncomingDropPartyComplete.

Arguments:

Return Value:

--*/
{
    PNDIS_CO_PARTY_BLOCK    pParty = (PNDIS_CO_PARTY_BLOCK)NdisPartyHandle;

    //
    // Notify the client
    //
    (*pParty->ClIncomingDropPartyHandler)(DropStatus,
                                          pParty->ClientContext,
                                          Buffer,
                                          Size);
}


BOOLEAN
FASTCALL
ndisReferenceVcPtr(
    IN  PNDIS_CO_VC_PTR_BLOCK   VcPtr
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    KIRQL   OldIrql;
    BOOLEAN rc = FALSE;

    DBGPRINT(DBG_COMP_CO, DBG_LEVEL_INFO,
            ("ndisReferenceVcPtr: VcPtr %x/%x, Flags %x, Ref %d, VcBlock %x\n",
                    VcPtr, VcPtr->CallFlags, *VcPtr->pVcFlags, VcPtr->References, VcPtr->VcBlock));

    ACQUIRE_SPIN_LOCK(&VcPtr->Lock, &OldIrql);

    if ((VcPtr->CallFlags & VC_PTR_BLOCK_CLOSING) == 0)
    {
        VcPtr->References ++;
        rc = TRUE;
    }

    RELEASE_SPIN_LOCK(&VcPtr->Lock, OldIrql);

    return rc;
}


VOID
FASTCALL
ndisDereferenceVcPtr(
    IN  PNDIS_CO_VC_PTR_BLOCK   VcPtr
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    KIRQL               OldIrql;
    BOOLEAN             Done = FALSE;
    BOOLEAN             IsProxyVc;
    PNDIS_CO_VC_BLOCK   VcBlock;

    DBGPRINT(DBG_COMP_CO, DBG_LEVEL_INFO,
            ("ndisDereferenceVcPtr: VcPtr %x/%x, Flags %x, Ref %d, VcBlock %x\n",
                    VcPtr, VcPtr->CallFlags, *VcPtr->pVcFlags, VcPtr->References, VcPtr->VcBlock));

    ACQUIRE_SPIN_LOCK(&VcPtr->Lock, &OldIrql);

    //
    // Take this VcPtr out of the VC's list
    //
    VcBlock = VcPtr->VcBlock;

    ASSERT(VcBlock != NULL);

    ASSERT(VcPtr->References > 0);
    VcPtr->References --;

    if (VcPtr->References == 0)
    {
        ASSERT(VcPtr->CallFlags & VC_PTR_BLOCK_CLOSING);

        if (*VcPtr->pVcFlags & VC_DELETE_PENDING)
        {
            NDIS_STATUS Status;

            DBGPRINT(DBG_COMP_CO, DBG_LEVEL_INFO,
                     ("ndisDereferenceVcPtr: Calling minport\n"));

            *VcPtr->pVcFlags &= ~VC_DELETE_PENDING; // don't call DeleteVc > once

            RELEASE_SPIN_LOCK_DPC(&VcPtr->Lock);
            Status = (*VcPtr->WCoDeleteVcHandler)(VcPtr->MiniportContext);
            ACQUIRE_SPIN_LOCK_DPC(&VcPtr->Lock);

            ASSERT(Status == NDIS_STATUS_SUCCESS);
        }

        if (VcPtr == VcBlock->pClientVcPtr)
        {
            IsProxyVc = FALSE;
        }
        else
        {
            DBGPRINT(DBG_COMP_CO, DBG_LEVEL_INFO,
                     ("ndisDereferenceVcPtr: VC ptr is Proxy\n"));
            ASSERT(VcPtr == VcBlock->pProxyVcPtr);
            IsProxyVc = TRUE;
        }

        RELEASE_SPIN_LOCK(&VcPtr->Lock, OldIrql);

        DBGPRINT(DBG_COMP_CO, DBG_LEVEL_INFO,
                ("ndisDereferenceVcPtr: freeing VcPtr %x (VcBlock %x)\n", VcPtr, VcPtr->VcBlock));
        FREE_POOL(VcPtr);

        Done = TRUE;
    }
    else
    {
        RELEASE_SPIN_LOCK(&VcPtr->Lock, OldIrql);
    }

    if (Done)
    {
        //
        // Any more VC ptrs q'd off this VC? If not,
        // free the VC too. Note both pointers need to be empty, since
        // a VC with no proxy can only ever be a normal
        // non- (or pre-) proxied VC (so we leave it alone).
        //
        // Note that you can have a VC with no Proxy pointer, and a VC
        // with no non-Proxy pointer. [REVIEWERS: Maybe we should assert that a VC
        // that's been proxied should never be left without a proxy pointer when the
        // non-proxy ptr is not null! (This would be a 'dangling' VC with no owner). This
        // would require a 'proxied' flag in the VC].
        //
        ACQUIRE_SPIN_LOCK(&VcBlock->Lock, &OldIrql);

        if (IsProxyVc)
        {
            VcBlock->pProxyVcPtr = NULL;
        }
        else
        {
            VcBlock->pClientVcPtr = NULL;
        }

        if ((VcBlock->pProxyVcPtr == NULL) &&
            (VcBlock->pClientVcPtr == NULL))
        {
            RELEASE_SPIN_LOCK(&VcBlock->Lock, OldIrql);
            DBGPRINT(DBG_COMP_CO, DBG_LEVEL_INFO,
                    ("ndisDereferenceVcPtr: refs are 0; VcPtrs are both NULL; freeing VCBlock %x\n", VcBlock));
            FREE_POOL(VcBlock);
        }
        else
        {
            RELEASE_SPIN_LOCK(&VcBlock->Lock, OldIrql);
        }
    }
}


VOID
FASTCALL
ndisMCoFreeResources(
    PNDIS_OPEN_BLOCK            Open
    )
/*++

Routine Description:

    Cleans-up address family list for call-managers etc.

    CALLED WITH MINIPORT LOCK HELD.

Arguments:

    Open    -   Pointer to the Open block for miniports

Return Value:

    None

--*/
{
    PNDIS_MINIPORT_BLOCK    Miniport;
    PNDIS_AF_LIST           *pAfList, pTmp;

    Miniport = Open->MiniportHandle;

    for (pAfList = &Miniport->CallMgrAfList;
         (pTmp = *pAfList) != NULL;
         NOTHING)
    {
        if (pTmp->Open == Open)
        {
            *pAfList = pTmp->NextAf;
            FREE_POOL(pTmp);
        }
        else
        {
            pAfList = &pTmp->NextAf;
        }
    }

    ASSERT(IsListEmpty(&Open->ActiveVcHead));
}

NDIS_STATUS
NdisCoAssignInstanceName(
    IN  NDIS_HANDLE             NdisVcHandle,
    IN  PNDIS_STRING            BaseInstanceName,
    OUT PNDIS_STRING            pVcInstanceName     OPTIONAL
    )
{
    NDIS_STATUS             Status;
    PNDIS_CO_VC_PTR_BLOCK   VcBlock = (PNDIS_CO_VC_PTR_BLOCK)NdisVcHandle;
    PNDIS_MINIPORT_BLOCK    Miniport = VcBlock->Miniport;
    USHORT                  cbSize;
    PWSTR                   pwBuffer;
    INT                     c;
    UINT                    Value;
    UNICODE_STRING          VcInstance;
    ULONGLONG               VcIndex;
    KIRQL                   OldIrql;

    do
    {
        //
        //  Is there already a name associated with this VC?
        //
        cbSize = VcBlock->VcInstanceName.Length;
        if (NULL == VcBlock->VcInstanceName.Buffer)
        {
            //
            //  The VC instance name will be of the format:
            //      [XXXX:YYYYYYYYYYYYYYYY] Base Name
            //  Where XXXX is the adapter instance number and YY..YY is the zero extended VC index.
            //
            cbSize = VC_INSTANCE_ID_SIZE;

            if (NULL != BaseInstanceName)
            {
                cbSize += BaseInstanceName->Length;
            }

            pwBuffer = ALLOC_FROM_POOL(cbSize, NDIS_TAG_NAME_BUF);
            if (NULL == pwBuffer)
            {
                Status = NDIS_STATUS_RESOURCES;
                break;
            }
            NdisZeroMemory(pwBuffer, cbSize);

            //
            //  Setup the prolog and the seperator and fill in the adapter instance #
            //  
            pwBuffer[0] =  L'[';
            pwBuffer[VC_ID_INDEX] = VC_IDENTIFIER;

            //
            //  Add the adapter instance number.
            //
            Value = Miniport->InstanceNumber;
            for (c = 4; c > 0; c--)
            {
                pwBuffer[c] = ndisHexLookUp[Value & NIBBLE_MASK];
                Value >>= 4;
            }

            //
            //  Add the VC index.
            //
            VcIndex = VcBlock->VcIndex.QuadPart;

            for (c = 15; c >= 0; c--)
            {
                //
                //  Get the nibble to convert.
                //
                Value = (UINT)(VcIndex & NIBBLE_MASK);

                pwBuffer[5+c] = ndisHexLookUp[Value];

                //
                //  Shift the VcIndex by a nibble.
                //
                VcIndex >>= 4;
            }

            //
            //  Add closing bracket and a space
            //
            pwBuffer[21] = L']';;
            pwBuffer[22] = L' ';;

            //
            //  Initialize a temporary UNICODE_STRING to build the name.
            //
            VcInstance.Buffer = pwBuffer;
            VcInstance.Length = VC_INSTANCE_ID_SIZE;
            VcInstance.MaximumLength = cbSize;

            if (NULL != BaseInstanceName)
            {
                //
                //  Append the base instance name passed into us to the end.
                //
                RtlAppendUnicodeStringToString(&VcInstance, BaseInstanceName);
            }

            ACQUIRE_SPIN_LOCK(&Miniport->VcCountLock, &OldIrql);

            Miniport->VcCount++;
            VcBlock->VcInstanceName = VcInstance;

            //
            //  Add the VC to the list of WMI enabled VCs
            //
            InsertTailList(&Miniport->WmiEnabledVcs, &VcBlock->WmiLink);

            RELEASE_SPIN_LOCK(&Miniport->VcCountLock, OldIrql);

            //
            //  Notify the arrival of this VC.
            //
            {
                PWNODE_SINGLE_INSTANCE  wnode;
                PUCHAR                  ptmp;
                NTSTATUS                NtStatus;

                ndisSetupWmiNode(Miniport,
                                 &VcInstance,
                                 0,
                                 (PVOID)&GUID_NDIS_NOTIFY_VC_ARRIVAL,
                                 &wnode);

                if (wnode != NULL)
                {       
                    //
                    //  Indicate the event to WMI. WMI will take care of freeing
                    //  the WMI struct back to pool.
                    //
                    NtStatus = IoWMIWriteEvent(wnode);
                    if (!NT_SUCCESS(NtStatus))
                    {
                        DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_ERR,
                            ("IoWMIWriteEvent failed %lx\n", NtStatus));
            
                        FREE_POOL(wnode);
                    }
                }
            }
        }

        //
        //  Copy the instance name string into callers NDIS_STRING.
        //
        if (ARGUMENT_PRESENT(pVcInstanceName))
        {
            pVcInstanceName->Buffer = ALLOC_FROM_POOL(cbSize, NDIS_TAG_NAME_BUF);
            if (NULL == pVcInstanceName->Buffer)
            {
                Status = NDIS_STATUS_RESOURCES;
                break;
            }
    
            NdisMoveMemory(pVcInstanceName->Buffer, VcBlock->VcInstanceName.Buffer, cbSize);
            pVcInstanceName->Length = VcBlock->VcInstanceName.Length;
            pVcInstanceName->MaximumLength = cbSize;
        }

        Status = NDIS_STATUS_SUCCESS;

    } while (FALSE);

    return(Status);
}

NDIS_STATUS
NdisCoRequest(
    IN  NDIS_HANDLE             NdisBindingHandle,
    IN  NDIS_HANDLE             NdisAfHandle    OPTIONAL,
    IN  NDIS_HANDLE             NdisVcHandle    OPTIONAL,
    IN  NDIS_HANDLE             NdisPartyHandle OPTIONAL,
    IN  PNDIS_REQUEST           NdisRequest
    )
/*++

Routine Description:

    This api is used for two separate paths.
    1. A symmetric call between the client and the call-manager. This mechanism is a
    two-way mechanism for the call-manager and client to communicate with each other in an
    asynchronous manner.
    2. A request down to the miniport.

Arguments:

    NdisBindingHandle   - Specifies the binding and identifies the caller as call-manager/client
    NdisAfHandle        - Pointer to the AF Block and identifies the target. If absent, the
                          request is targeted to the miniport.
    NdisVcHandle        - Pointer to optional VC PTR block. If present the request relates to the
                          VC
    NdisPartyHandle     - Pointer to the optional Party Block. If present the request relates
                          to the party.
    NdisRequest         - The request itself

Return Value:
    NDIS_STATUS_PENDING if the target pends the call.
    NDIS_STATUS_FAILURE if the binding or af is closing.
    Anything else       return code from the other end.

--*/
{
    PNDIS_OPEN_BLOCK        Open;
    PNDIS_CO_AF_BLOCK       pAf;
    NDIS_HANDLE             VcContext;
    PNDIS_COREQ_RESERVED    CoReqRsvd;
    PNDIS_CO_VC_PTR_BLOCK   VcPtr = (PNDIS_CO_VC_PTR_BLOCK)NdisVcHandle;
    NDIS_STATUS             Status;
    KIRQL                   OldIrql;


    CoReqRsvd = PNDIS_COREQ_RESERVED_FROM_REQUEST(NdisRequest);
    Open = (PNDIS_OPEN_BLOCK)NdisBindingHandle;

    do
    {
        if (ARGUMENT_PRESENT(NdisAfHandle))
        {
            CO_REQUEST_HANDLER      CoRequestHandler;
            NDIS_HANDLE             AfContext, PartyContext;

            pAf = (PNDIS_CO_AF_BLOCK)NdisAfHandle;

            //
            // Attempt to reference the AF
            //
            if (!ndisReferenceAf(pAf))
            {
                Status = NDIS_STATUS_FAILURE;
                break;
            }

            VcContext = NULL;
            PartyContext = NULL;
            NdisZeroMemory(CoReqRsvd, sizeof(NDIS_COREQ_RESERVED));
            INITIALIZE_EVENT(&CoReqRsvd->Event);
            PNDIS_RESERVED_FROM_PNDIS_REQUEST(NdisRequest)->Flags = REQST_SIGNAL_EVENT;

            //
            // Figure out who we are and call the peer
            //
            if (pAf->ClientOpen == Open)
            {
                //
                // This is the client, so call the call-manager's CoRequestHandler
                //
                CoRequestHandler = pAf->CallMgrEntries->CmRequestHandler;

                AfContext = pAf->CallMgrContext;
                CoReqRsvd->AfContext = pAf->ClientContext;
                CoReqRsvd->CoRequestCompleteHandler = pAf->ClientEntries.ClRequestCompleteHandler;
                if (ARGUMENT_PRESENT(NdisVcHandle))
                {
                    CoReqRsvd->VcContext = VcPtr->ClientContext;
                    VcContext = VcPtr->CallMgrContext;
                }
                if (ARGUMENT_PRESENT(NdisPartyHandle))
                {
                    CoReqRsvd->PartyContext = ((PNDIS_CO_PARTY_BLOCK)NdisPartyHandle)->ClientContext;
                    PartyContext = ((PNDIS_CO_PARTY_BLOCK)NdisPartyHandle)->CallMgrContext;
                }
            }
            else
            {
                ASSERT(pAf->CallMgrOpen == Open);
                //
                // This is the call-manager, so call the client's CoRequestHandler
                //
                CoRequestHandler = pAf->ClientEntries.ClRequestHandler;
                AfContext = pAf->ClientContext;
                CoReqRsvd->AfContext = pAf->CallMgrContext;
                CoReqRsvd->CoRequestCompleteHandler = pAf->CallMgrEntries->CmRequestCompleteHandler;
                if (ARGUMENT_PRESENT(NdisVcHandle))
                {
                    CoReqRsvd->VcContext = VcPtr->CallMgrContext;
                    VcContext = VcPtr->ClientContext;
                }
                if (ARGUMENT_PRESENT(NdisPartyHandle))
                {
                    CoReqRsvd->PartyContext = ((PNDIS_CO_PARTY_BLOCK)NdisPartyHandle)->CallMgrContext;
                    PartyContext = ((PNDIS_CO_PARTY_BLOCK)NdisPartyHandle)->ClientContext;
                }
            }

            if (CoRequestHandler == NULL)
            {
                Status = NDIS_STATUS_NOT_SUPPORTED;
                break;
            }
            

            if (MINIPORT_PNP_TEST_FLAG(Open->MiniportHandle, fMINIPORT_DEVICE_FAILED))
            {
                Status = (NdisRequest->RequestType == NdisRequestSetInformation) ? 
                                            NDIS_STATUS_SUCCESS : NDIS_STATUS_FAILURE;  

            }
            else
            {
                //
                // Now call the handler
                //
                Status = (*CoRequestHandler)(AfContext, VcContext, PartyContext, NdisRequest);
            }

            
            if (Status != NDIS_STATUS_PENDING)
            {
                NdisCoRequestComplete(Status,
                                      NdisAfHandle,
                                      NdisVcHandle,
                                      NdisPartyHandle,
                                      NdisRequest);

                Status = NDIS_STATUS_PENDING;
            }
        }
        else
        {
            PNDIS_MINIPORT_BLOCK    Miniport;

            Miniport = Open->MiniportHandle;

            //
            // Start off by referencing the open.
            //
            NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Miniport, &OldIrql);

            if (Open->Flags & fMINIPORT_OPEN_CLOSING)
            {
                Status = NDIS_STATUS_CLOSING;
            }
            else if (MINIPORT_TEST_FLAG(Miniport, (fMINIPORT_RESET_IN_PROGRESS | fMINIPORT_RESET_REQUESTED)))
            {
                Status = NDIS_STATUS_RESET_IN_PROGRESS;
            }
            else
            {
                Status = NDIS_STATUS_SUCCESS;
                M_OPEN_INCREMENT_REF_INTERLOCKED(Open);
            }

            NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);

            if (Status == NDIS_STATUS_SUCCESS)
            {
                PNDIS_RESERVED_FROM_PNDIS_REQUEST(NdisRequest)->Open = Open;
                PNDIS_RESERVED_FROM_PNDIS_REQUEST(NdisRequest)->Flags = 0;
                CoReqRsvd->CoRequestCompleteHandler = Open->CoRequestCompleteHandler;
                CoReqRsvd->VcContext = NULL;
                if (ARGUMENT_PRESENT(NdisVcHandle))
                {
                    if (VcPtr->ClientOpen == Open)
                    {
                        CoReqRsvd->VcContext = VcPtr->ClientContext;
                    }
                    else
                    {
                        CoReqRsvd->VcContext = VcPtr->CallMgrContext;
                    }
                }

                if (MINIPORT_PNP_TEST_FLAG(Open->MiniportHandle, fMINIPORT_DEVICE_FAILED))
                {
                    Status = (NdisRequest->RequestType == NdisRequestSetInformation) ? 
                                                NDIS_STATUS_SUCCESS : NDIS_STATUS_FAILURE;  

                }
                else
                {
                    //
                    // Call the miniport's CoRequest Handler
                    //
                    Status = (*Open->MiniportCoRequestHandler)(Open->MiniportAdapterContext,
                                                              (NdisVcHandle != NULL) ?
                                                                    VcPtr->MiniportContext : NULL,
                                                              NdisRequest);
                }
                
                
                if (Status != NDIS_STATUS_PENDING)
                {
                    NdisMCoRequestComplete(Status,
                                           Open->MiniportHandle,
                                           NdisRequest);

                    Status = NDIS_STATUS_PENDING;
                }
            }

        }
    } while (FALSE);

    return Status;
}


NDIS_STATUS
NdisMCmRequest(
    IN  NDIS_HANDLE             NdisAfHandle,
    IN  NDIS_HANDLE             NdisVcHandle    OPTIONAL,
    IN  NDIS_HANDLE             NdisPartyHandle OPTIONAL,
    IN OUT PNDIS_REQUEST        NdisRequest
    )
/*++

Routine Description:

    This api is a symmetric call between the client and an integrated call-manager.
    This mechanism is a two-way mechanism for the call-manager and client to communicate
    with each other in an asynchronous manner.

Arguments:

    NdisAfHandle        - Pointer to the AF Block and identifies the target. If absent, the
                          request is targeted to the miniport.
    NdisVcHandle        - Pointer to optional VC PTR block. If present the request relates to the
                          VC
    NdisPartyHandle     - Pointer to the optional Party Block. If present the request relates
                          to the party.
    NdisRequest         - The request itself

Return Value:
    NDIS_STATUS_PENDING if the target pends the call.
    NDIS_STATUS_FAILURE if the binding or af is closing.
    Anything else       return code from the other end.

--*/
{
    PNDIS_CO_AF_BLOCK       pAf;
    NDIS_HANDLE             VcContext, PartyContext;
    PNDIS_COREQ_RESERVED    CoReqRsvd;
    NDIS_STATUS             Status;

    CoReqRsvd = PNDIS_COREQ_RESERVED_FROM_REQUEST(NdisRequest);
    pAf = (PNDIS_CO_AF_BLOCK)NdisAfHandle;

    do
    {
        //
        // Attempt to reference the AF
        //
        if (!ndisReferenceAf(pAf))
        {
            Status = NDIS_STATUS_FAILURE;
            break;
        }

        VcContext = NULL;
        PartyContext = NULL;
        NdisZeroMemory(CoReqRsvd, sizeof(NDIS_COREQ_RESERVED));
        INITIALIZE_EVENT(&CoReqRsvd->Event);
        PNDIS_RESERVED_FROM_PNDIS_REQUEST(NdisRequest)->Flags = REQST_SIGNAL_EVENT;

        CoReqRsvd->AfContext = pAf->CallMgrContext;
        CoReqRsvd->CoRequestCompleteHandler = pAf->CallMgrEntries->CmRequestCompleteHandler;
        if (ARGUMENT_PRESENT(NdisVcHandle))
        {
            CoReqRsvd->VcContext = pAf->CallMgrContext;
            VcContext = ((PNDIS_CO_VC_PTR_BLOCK)NdisVcHandle)->ClientContext;
        }
        if (ARGUMENT_PRESENT(NdisPartyHandle))
        {
            CoReqRsvd->PartyContext = ((PNDIS_CO_PARTY_BLOCK)NdisPartyHandle)->CallMgrContext;
            PartyContext = ((PNDIS_CO_PARTY_BLOCK)NdisPartyHandle)->ClientContext;
        }

        //
        // Now call the handler
        //
        Status = (*pAf->ClientEntries.ClRequestHandler)(pAf->ClientContext,
                                                        VcContext,
                                                        PartyContext,
                                                        NdisRequest);

        if (Status != NDIS_STATUS_PENDING)
        {
            NdisCoRequestComplete(Status,
                                  NdisAfHandle,
                                  NdisVcHandle,
                                  NdisPartyHandle,
                                  NdisRequest);

            Status = NDIS_STATUS_PENDING;
        }
    } while (FALSE);

    return Status;
}

VOID
NdisCoRequestComplete(
    IN  NDIS_STATUS             Status,
    IN  NDIS_HANDLE             NdisAfHandle,
    IN  NDIS_HANDLE             NdisVcHandle    OPTIONAL,
    IN  NDIS_HANDLE             NdisPartyHandle OPTIONAL,
    IN  PNDIS_REQUEST           NdisRequest
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PNDIS_COREQ_RESERVED    ReqRsvd = PNDIS_COREQ_RESERVED_FROM_REQUEST(NdisRequest);

    //
    // Simply call the request completion handler and deref the Af block
    //
    (*ReqRsvd->CoRequestCompleteHandler)(Status,
                                         ReqRsvd->AfContext,
                                         ReqRsvd->VcContext,
                                         ReqRsvd->PartyContext,
                                         NdisRequest);
    ndisDereferenceAf((PNDIS_CO_AF_BLOCK)NdisAfHandle);
}


NDIS_STATUS
NdisCoGetTapiCallId(
    IN  NDIS_HANDLE             NdisVcHandle,
    IN  OUT PVAR_STRING         TapiCallId
    )
/*++

Routine Description:
    Returns a string that can be used by a TAPI application to identify a particular VC.
    
Arguments:

    NdisVcHandle    - The NDIS handle to the VC to identify
    TapiCallId      - Pointer to a VAR_STRING structure in which to return
                      the identifier

Return Value:
    NDIS_STATUS_BUFFER_TOO_SHORT if the VAR_STRING structure's ulTotalSize field indicates
        that it does not contain enough space to hold the VC's identifier. The ulNeededSize
        field will be set to the size needed.
    
    NDIS_STATUS_INVALID_DATA if the NdisVcHandle passed in is not valid.
    
    NDIS_STATUS_SUCCESS otherwise. 
     
--*/
{
    NDIS_HANDLE ClientContext;

    TapiCallId->ulUsedSize = 0;

    if (NdisVcHandle)
        ClientContext = ((PNDIS_CO_VC_PTR_BLOCK)NdisVcHandle)->ClientContext;
    else
        return NDIS_STATUS_INVALID_DATA;


    //
    // Determine the size we will need.
    //

    TapiCallId->ulNeededSize = sizeof(VAR_STRING) + sizeof(ClientContext);

    //
    // Check that there is enough space to copy the call ID. If not,
    // we bail.
    //

    if (TapiCallId->ulTotalSize < TapiCallId->ulNeededSize) 
        return NDIS_STATUS_BUFFER_TOO_SHORT;

    //
    // Set fields, do the copy.
    // 

    TapiCallId->ulStringFormat = STRINGFORMAT_BINARY;
    TapiCallId->ulStringSize = sizeof(ClientContext);
    TapiCallId->ulStringOffset = sizeof(VAR_STRING); 

    NdisMoveMemory(((PUCHAR)TapiCallId) + TapiCallId->ulStringOffset,
                   &ClientContext,
                   sizeof(ClientContext));

    TapiCallId->ulUsedSize = sizeof(VAR_STRING) + sizeof(ClientContext);

    return NDIS_STATUS_SUCCESS;

}


VOID
NdisMCoRequestComplete(
    IN  NDIS_STATUS             Status,
    IN  NDIS_HANDLE             NdisBindingHandle,
    IN  PNDIS_REQUEST           NdisRequest
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PNDIS_REQUEST_RESERVED  ReqRsvd;
    PNDIS_COREQ_RESERVED    CoReqRsvd;
    PNDIS_MINIPORT_BLOCK    Miniport;
    PNDIS_OPEN_BLOCK        Open;

    ReqRsvd = PNDIS_RESERVED_FROM_PNDIS_REQUEST(NdisRequest);
    CoReqRsvd = PNDIS_COREQ_RESERVED_FROM_REQUEST(NdisRequest);
    Miniport = (PNDIS_MINIPORT_BLOCK)NdisBindingHandle;
    Open = ReqRsvd->Open;

    if ((NdisRequest->RequestType == NdisRequestQueryInformation) &&
        (NdisRequest->DATA.QUERY_INFORMATION.Oid == OID_GEN_CURRENT_PACKET_FILTER) &&
        (NdisRequest->DATA.QUERY_INFORMATION.InformationBufferLength != 0))
    {
        if ((Open != NULL) && (Open->Flags & fMINIPORT_OPEN_PMODE))
        {
            *(PULONG)(NdisRequest->DATA.QUERY_INFORMATION.InformationBuffer) |=
                                NDIS_PACKET_TYPE_PROMISCUOUS | NDIS_PACKET_TYPE_ALL_LOCAL;
        }
    }

    if (Open != NULL)
    {
        KIRQL           OldIrql;

        if (ReqRsvd->Flags & REQST_DOWNLEVEL)
        {
            //
            // Complete the request to the protocol and deref the open
            //
            if (NdisRequest->RequestType == NdisRequestSetInformation)
            {
                NdisMSetInformationComplete(Miniport, Status);
            }
            else
            {
                NdisMQueryInformationComplete(Miniport, Status);
            }
        }
        else
        {
            //
            // Complete the request to the protocol and deref the open
            //
            ReqRsvd->Flags |= REQST_COMPLETED;
            (*CoReqRsvd->CoRequestCompleteHandler)(Status,
                                                   ReqRsvd->Open->ProtocolBindingContext,
                                                   CoReqRsvd->VcContext,
                                                   NULL,
                                                   NdisRequest);

            NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Miniport, &OldIrql);

            ndisMDereferenceOpen(Open);
    
            NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);
        }

    }
    else
    {
        //
        // Just set status and signal
        //
        CoReqRsvd->Status = Status;
        SET_EVENT(&CoReqRsvd->Event);
    }
}



VOID
NdisMCoIndicateReceivePacket(
    IN  NDIS_HANDLE             NdisVcHandle,
    IN  PPNDIS_PACKET           PacketArray,
    IN  UINT                    NumberOfPackets
    )
/*++

Routine Description:

    This routine is called by the Miniport to indicate a set of packets to
    a particular VC.

Arguments:

    NdisVcHandle            - The handle suppplied by Ndis when the VC on which
                              data is received was first reserved.

    PacketArray             - Array of packets.

    NumberOfPackets         - Number of packets being indicated.

Return Value:

    None.
--*/
{
    PNULL_FILTER                Filter;
    UINT                        i, NumPmodeOpens;
    PNDIS_STACK_RESERVED        NSR;
    PNDIS_PACKET_OOB_DATA       pOob;
    PPNDIS_PACKET               pPktArray;
    PNDIS_PACKET                Packet;
    PNDIS_CO_VC_PTR_BLOCK       VcPtr = (PNDIS_CO_VC_PTR_BLOCK)NdisVcHandle;
    PNDIS_CO_VC_BLOCK           VcBlock = VcPtr->VcBlock;
    PNDIS_MINIPORT_BLOCK        Miniport;
    LOCK_STATE                  LockState;
#ifdef TRACK_RECEIVED_PACKETS
    ULONG                       OrgPacketStackLocation;
    PETHREAD                    CurThread = PsGetCurrentThread();
//    ULONG                   CurThread = KeGetCurrentProcessorNumber();
#endif

    Miniport = VcBlock->Miniport;
    Filter = Miniport->NullDB;

    READ_LOCK_FILTER(Miniport, Filter, &LockState);

    VcBlock->ClientOpen->Flags |= fMINIPORT_PACKET_RECEIVED;

    //
    // NOTE that checking Vc Flags for Closing should not be needed since the CallMgr
    // holds onto the protocol's CloseCall request until the ref count goes to zero -
    // which means the miniport has to have completed its RELEASE_VC, which will
    // inturn mandate that we will NOT get any further indications from it.
    // The miniport must not complete a RELEASE_VC until it is no longer indicating data.
    //
    for (i = 0, pPktArray = PacketArray;
         i < NumberOfPackets;
         i++, pPktArray++)
    {
        Packet = *pPktArray;
        ASSERT(Packet != NULL);

#ifdef TRACK_RECEIVED_PACKETS
        OrgPacketStackLocation = CURR_STACK_LOCATION(Packet);
#endif
        pOob = NDIS_OOB_DATA_FROM_PACKET(Packet);
        PUSH_PACKET_STACK(Packet);
        NDIS_STACK_RESERVED_FROM_PACKET(Packet, &NSR)

        DIRECTED_PACKETS_IN(Miniport);
        DIRECTED_BYTES_IN_PACKET(Miniport, Packet);

        //
        // Set context in the packet so that NdisReturnPacket can do the right thing
        //
        NDIS_INITIALIZE_RCVD_PACKET(Packet, NSR, Miniport);

        if (pOob->Status != NDIS_STATUS_RESOURCES)
        {
            pOob->Status = NDIS_STATUS_SUCCESS;
        }

        //
        // Indicate the packet to the binding.
        //
        if ((VcBlock->Flags & VC_HANDOFF_IN_PROGRESS) == 0)
        {
            NSR->XRefCount = (SHORT)(*VcBlock->CoReceivePacketHandler)(VcBlock->ClientOpen->ProtocolBindingContext,
                                                                       VcBlock->ClientContext,
                                                                       Packet);
        }
        else
        {
            //
            // This VC is being transitioned from the NDIS proxy to
            // a proxied client. Since the proxy client may not be fully
            // set up, don't indicate this packet.
            //
            NSR->XRefCount = 0;
        }

        //
        // If there are promiscuous opens on this miniport, indicate it to them as well.
        // The client context will identify the VC.
        //
        if ((NumPmodeOpens = Miniport->PmodeOpens) > 0)
        {
            PNULL_BINDING_INFO  Open, NextOpen;
            PNDIS_OPEN_BLOCK    pPmodeOpen;

            for (Open = Filter->OpenList;
                 Open && (NumPmodeOpens > 0);
                 Open = NextOpen)
            {
                NextOpen = Open->NextOpen;
                pPmodeOpen = (PNDIS_OPEN_BLOCK)(Open->NdisBindingHandle);
                if (pPmodeOpen->Flags & fMINIPORT_OPEN_PMODE)
                {
                    NDIS_STATUS SavedStatus;
                    UINT        Ref;

                    if (pPmodeOpen->ProtocolHandle->ProtocolCharacteristics.CoReceivePacketHandler != NULL)
                    {
                        pPmodeOpen->Flags |= fMINIPORT_PACKET_RECEIVED;
    
                        SavedStatus = NDIS_GET_PACKET_STATUS(Packet);
                        NDIS_SET_PACKET_STATUS(Packet, NDIS_STATUS_RESOURCES);
    
                        //
                        // For Pmode opens, we pass the VcId to the indication routine
                        // since the protocol does not really own the VC.
                        //

                        Ref = (*pPmodeOpen->ProtocolHandle->ProtocolCharacteristics.CoReceivePacketHandler)(
                                                pPmodeOpen->ProtocolBindingContext,
                                                &VcBlock->VcId,
                                                Packet);
    
                        ASSERT(Ref == 0);
    
                        NDIS_SET_PACKET_STATUS(Packet, SavedStatus);
                    }

                    NumPmodeOpens --;
                }
            }
        }

        //
        // Tackle refcounts now
        //
        TACKLE_REF_COUNT(Miniport, Packet, NSR, pOob);
    }

    READ_UNLOCK_FILTER(Miniport, Filter, &LockState);
}

VOID
NdisMCoReceiveComplete(
    IN  NDIS_HANDLE             MiniportAdapterHandle
    )
/*++

Routine Description:

    This routine is called by the Miniport to indicate that the receive
    process is complete to all bindings. Only those bindings which
    have received packets will be notified. The Miniport lock is held
    when this is called.

Arguments:

    MiniportAdapterHandle - The handle supplied by Ndis at initialization
                            time through miniport initialize.

Return Value:

    None.

--*/
{
    PNDIS_MINIPORT_BLOCK Miniport = (PNDIS_MINIPORT_BLOCK)MiniportAdapterHandle;
    PNULL_FILTER        Filter;
    PNDIS_OPEN_BLOCK    Open;
    LOCK_STATE          LockState;

    Filter = Miniport->NullDB;

    READ_LOCK_FILTER(Miniport, Filter, &LockState);

    //
    // check all of the bindings on this adapter
    //
    for (Open = Miniport->OpenQueue;
         Open != NULL;
         Open = Open->MiniportNextOpen)
    {
        if (Open->Flags & fMINIPORT_PACKET_RECEIVED)
        {
            //
            // Indicate the binding.
            //
            Open->Flags &= ~fMINIPORT_PACKET_RECEIVED;

            (*Open->ReceiveCompleteHandler)(Open->ProtocolBindingContext);
        }
    }

    READ_UNLOCK_FILTER(Miniport, Filter, &LockState);
}


VOID
NdisCoSendPackets(
    IN  NDIS_HANDLE         NdisVcHandle,
    IN  PPNDIS_PACKET       PacketArray,
    IN  UINT                NumberOfPackets
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PNDIS_CO_VC_PTR_BLOCK   VcPtr = (PNDIS_CO_VC_PTR_BLOCK)NdisVcHandle;
    PNULL_FILTER            Filter;
    LOCK_STATE              LockState;
    PNDIS_CO_VC_BLOCK       VcBlock = VcPtr->VcBlock;
    PNDIS_STACK_RESERVED    NSR;
    PNDIS_MINIPORT_BLOCK    Miniport = VcPtr->Miniport;
    PNDIS_PACKET            Packet;
    UINT                    PacketCount, Index, NumToSend;
    NDIS_STATUS             Status;
    ULONG                   NumPmodeOpens;

    DBGPRINT(DBG_COMP_SEND, DBG_LEVEL_INFO,
            ("NdisCoSendPackets: VcPtr %x, FirstPkt %x, NumPkts %d\n",
                VcPtr, *PacketArray, NumberOfPackets));

    Filter = Miniport->NullDB;
    READ_LOCK_FILTER(Miniport, Filter, &LockState);

    //
    // If there are promiscuous opens on this miniport, this must be indicated to them.
    // Do this before it is send down to the miniport to preserve packet ordering.
    //
    if ((NumPmodeOpens = Miniport->PmodeOpens) > 0)
    {
        PNDIS_OPEN_BLOCK    pPmodeOpen;

        for (pPmodeOpen = Miniport->OpenQueue;
             pPmodeOpen && (NumPmodeOpens > 0);
             pPmodeOpen = pPmodeOpen->MiniportNextOpen)
        {
            if (pPmodeOpen->Flags & fMINIPORT_OPEN_PMODE)
            {
                ULONG   Ref;

                pPmodeOpen->Flags |= fMINIPORT_PACKET_RECEIVED;

                for (PacketCount = 0; PacketCount < NumberOfPackets; PacketCount++)
                {
                    Packet = PacketArray[PacketCount];

                    //
                    // For Pmode opens, we pass the VcId to the indication routine
                    // since the protocol does not really own the VC. On lookback
                    // the packet cannot be held.
                    //
                    Status = NDIS_GET_PACKET_STATUS(Packet);
                    NDIS_SET_PACKET_STATUS(Packet, NDIS_STATUS_RESOURCES);
                    Packet->Private.Flags |= NDIS_FLAGS_IS_LOOPBACK_PACKET;

                    Ref = (*pPmodeOpen->ProtocolHandle->ProtocolCharacteristics.CoReceivePacketHandler)(
                                            pPmodeOpen->ProtocolBindingContext,
                                            &VcBlock->VcId,
                                            Packet);

                    ASSERT(Ref == 0);
                    NDIS_SET_PACKET_STATUS(Packet, Status);
                    Packet->Private.Flags &= ~NDIS_FLAGS_IS_LOOPBACK_PACKET;
                }

                NumPmodeOpens--;
            }
        }
    }

    Status = NDIS_STATUS_SUCCESS;
    
    for (PacketCount = 0, Index = 0, NumToSend = 0;
         PacketCount < NumberOfPackets;
         PacketCount++)
    {
        Packet = PacketArray[PacketCount];
        PUSH_PACKET_STACK(Packet);
        NDIS_STACK_RESERVED_FROM_PACKET(Packet, &NSR)

        if (MINIPORT_TEST_SEND_FLAG(Miniport, fMINIPORT_SEND_DO_NOT_MAP_MDLS))
        {
            ndisMCheckPacketAndGetStatsOutAlreadyMapped(Miniport, Packet);
        }
        else
        {
            ndisMCheckPacketAndGetStatsOut(Miniport, Packet, &Status);
        }

        if (Status == NDIS_STATUS_SUCCESS)
        {
            if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_SG_LIST))
            {
                NSR->Open = VcPtr->ClientOpen;
                NSR->VcPtr = VcPtr;
                ndisMAllocSGList(Miniport, Packet);
            }
            else
            {
                NumToSend ++;
            }
        }
        else
        {
            NdisMCoSendComplete(NDIS_STATUS_RESOURCES, NdisVcHandle, Packet);
            if (NumToSend != 0)
            {
                ASSERT (!MINIPORT_TEST_FLAG(Miniport, fMINIPORT_SG_LIST));

                //
                // Call down to the miniport to send this batch
                // The miniport must complete the sends for all cases.
                // The send either succeeds/pends or fails.
                //
                (*VcPtr->WCoSendPacketsHandler)(VcPtr->MiniportContext,
                                                &PacketArray[Index],
                                                NumToSend);
                NumToSend = 0;
            }
            Index = PacketCount + 1;
        }
    }

    if (NumToSend != 0)
    {
        //
        // Send down the remaining packets
        //
        (*VcPtr->WCoSendPacketsHandler)(VcPtr->MiniportContext,
                                        &PacketArray[Index],
                                        NumToSend);
    }

    READ_UNLOCK_FILTER(Miniport, Filter, &LockState);
}


VOID
NdisMCoSendComplete(
    IN  NDIS_STATUS         Status,
    IN  NDIS_HANDLE         NdisVcHandle,
    IN  PNDIS_PACKET        Packet
    )
/*++

Routine Description:

    This function is called by the miniport when a send has completed. This
    routine simply calls the protocol to pass along the indication.

Arguments:

    MiniportAdapterHandle - points to the adapter block.
    NdisVcHandle          - the handle supplied to the adapter on the OID_RESERVE_VC
    PacketArray           - a ptr to an array of NDIS_PACKETS
    NumberOfPackets       - the number of packets in  PacketArray
    Status                - the send status that applies to all packets in the array

Return Value:

    None.

--*/
{
    PNDIS_MINIPORT_BLOCK    Miniport;
    PNDIS_OPEN_BLOCK        Open;
    PNDIS_CO_VC_PTR_BLOCK   VcPtr = (PNDIS_CO_VC_PTR_BLOCK)NdisVcHandle;
    PNDIS_CO_VC_BLOCK       VcBlock = VcPtr->VcBlock;
    PNDIS_STACK_RESERVED    NSR;

    DBGPRINT(DBG_COMP_SEND, DBG_LEVEL_INFO,
            ("NdisMCoSendComplete: Status %x, VcPtr %x, Pkt %x\n",
                Status, VcPtr, Packet));


    //
    // There should not be any reason to grab the spin lock and increment the
    // ref count on Open since the open cannot close until the Vc closes and
    // the Vc cannot close in the middle of an indication because the miniport
    // will not complete a RELEASE_VC until is it no longer indicating
    //
    //
    // Indicate to Protocol;
    //

    Open = VcBlock->ClientOpen;
    Miniport = VcBlock->Miniport;

    if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_SG_LIST) &&
        (NDIS_PER_PACKET_INFO_FROM_PACKET(Packet, ScatterGatherListPacketInfo) != NULL))
    {
        ndisMFreeSGList(Miniport, Packet);
    }
    
    NDIS_STACK_RESERVED_FROM_PACKET(Packet, &NSR)

    MINIPORT_CLEAR_PACKET_FLAG(Packet, fPACKET_CLEAR_ITEMS);
    CLEAR_WRAPPER_RESERVED(NSR);
    POP_PACKET_STACK(Packet);
    (VcBlock->CoSendCompleteHandler)(Status,
                                     VcBlock->ClientContext,
                                     Packet);

    //
    // Technically this Vc should not close since there is a send outstanding
    // on it, and the client should not close a Vc with an outstanding send.
    //
    // Took out the VcBlock->References assertion since refs are now kept in VcPtr.
    // NOTE: We could keep the Client ref count (i.e. the VcPtr of the protocol
    // that receives the data indications) in the VC, and use a pointer in the VcPtr,
    // in which case we would assert on *VcPtr->pReferences.
    //
    ASSERT(Open->References > 0);
}


VOID
NdisMCoIndicateStatus(
    IN  NDIS_HANDLE         MiniportAdapterHandle,
    IN  NDIS_HANDLE         NdisVcHandle,
    IN  NDIS_STATUS         GeneralStatus,
    IN  PVOID               StatusBuffer,
    IN  ULONG               StatusBufferSize
    )
/*++

Routine Description:

    This routine handles passing CoStatus to the protocol.  The miniport calls
    this routine when it has status on a VC or a general status for all Vcs - in
    this case the NdisVcHandle is null.

Arguments:

    MiniportAdapterHandle - pointer to the mini-port block;
    NdisVcHandle          - a pointer to the Vc block
    GeneralStatus         - the completion status of the request.
    StatusBuffer          - a buffer containing medium and status specific info
    StatusBufferSize      - the size of the buffer.

Return Value:

    none

--*/
{
    PNDIS_MINIPORT_BLOCK    Miniport = (PNDIS_MINIPORT_BLOCK)MiniportAdapterHandle;
    PNDIS_CO_VC_PTR_BLOCK   VcPtr = (PNDIS_CO_VC_PTR_BLOCK)NdisVcHandle;
    PNDIS_CO_VC_BLOCK       VcBlock;
    PNDIS_OPEN_BLOCK        Open;
    BOOLEAN                 fMediaConnectStateIndication = FALSE;

    DBGPRINT(DBG_COMP_INIT, DBG_LEVEL_INFO,
            ("==>NdisMCoIndicateStatus\n"));
    
    if ((GeneralStatus == NDIS_STATUS_MEDIA_CONNECT) || (GeneralStatus == NDIS_STATUS_MEDIA_DISCONNECT))
    {
        fMediaConnectStateIndication = TRUE;
    }

    do
    {
        NTSTATUS                NtStatus;
        PUNICODE_STRING         InstanceName;
        PWNODE_SINGLE_INSTANCE  wnode;
        ULONG                   DataBlockSize = 0;
        ULONG                   BufSize;
        PUCHAR                  ptmp;
        PNDIS_GUID              pNdisGuid;
    
        //
        //  Get nice pointers to the instance names.
        //
        if (NULL != NdisVcHandle)
        {
            InstanceName = &VcPtr->VcInstanceName;
        }
        else
        {
            InstanceName = Miniport->pAdapterInstanceName;
        }

        //
        //  If there is no instance name then we can't indicate an event.
        //
        if (NULL == InstanceName)
        {
            break;
        }
    
        //
        //  Check to see if the status is enabled for WMI event indication.
        //
        NtStatus = ndisWmiGetGuid(&pNdisGuid, Miniport, NULL, GeneralStatus);
        if ((!NT_SUCCESS(NtStatus)) ||
            !NDIS_GUID_TEST_FLAG(pNdisGuid, fNDIS_GUID_EVENT_ENABLED))
        {
            break;
        }

        //
        //  If the data item is an array then we need to add in the number of
        //  elements.
        //
        if (NDIS_GUID_TEST_FLAG(pNdisGuid, fNDIS_GUID_ARRAY))
        {
            DataBlockSize = StatusBufferSize + sizeof(ULONG);
        }
        else
        {
            DataBlockSize = pNdisGuid->Size;
        }
        
        //
        // in case of media connect/disconnect status indication, include the
        // NIC's name in the WMI event
        //
        if (fMediaConnectStateIndication && (NULL == NdisVcHandle))
        {
            DataBlockSize += Miniport->MiniportName.Length + sizeof(WCHAR);
        }
        
        ndisSetupWmiNode(Miniport,
                         InstanceName,
                         DataBlockSize,
                         (PVOID)&pNdisGuid->Guid,
                         &wnode);

        if (wnode != NULL)
        {
            //
            //  Save the number of elements in the first ULONG.
            //
            ptmp = (PUCHAR)wnode + wnode->DataBlockOffset;

            //
            //  Copy in the data.
            //
            if (NDIS_GUID_TEST_FLAG(pNdisGuid, fNDIS_GUID_ARRAY))
            {
                //
                //  If the status is an array but there is no data then complete it with no
                //  data and a 0 length
                //
                if ((NULL == StatusBuffer) || (0 == StatusBufferSize))
                {
                    *((PULONG)ptmp) = 0;
                    ptmp += sizeof(ULONG);
                }
                else
                {
                    //
                    //  Save the number of elements in the first ULONG.
                    //
                    *((PULONG)ptmp) = StatusBufferSize / pNdisGuid->Size;

                    //
                    //  Copy the data after the number of elements.
                    //
                    NdisMoveMemory(ptmp + sizeof(ULONG), StatusBuffer, StatusBufferSize);
                    ptmp += sizeof(ULONG) + StatusBufferSize;
                }
            }
            else
            {
                //
                //  Do we indicate any data up?
                //
                if (0 != pNdisGuid->Size)
                {
                    //
                    //  Copy the data into the buffer.
                    //
                    NdisMoveMemory(ptmp, StatusBuffer, pNdisGuid->Size);
                    ptmp += pNdisGuid->Size;
                }
            }
            
            if (fMediaConnectStateIndication && (NULL == NdisVcHandle))
            {
                //
                // for media connect/disconnect status, 
                // add the name of the adapter
                //
                RtlCopyMemory(ptmp,
                              Miniport->MiniportName.Buffer,
                              Miniport->MiniportName.Length);
                    
            }

            //
            //  Indicate the event to WMI. WMI will take care of freeing
            //  the WMI struct back to pool.
            //
            NtStatus = IoWMIWriteEvent(wnode);
            if (!NT_SUCCESS(NtStatus))
            {
                DBGPRINT(DBG_COMP_WMI, DBG_LEVEL_ERR,
                    ("    ndisMCoIndicateStatus: Unable to indicate the WMI event.\n"));

                FREE_POOL(wnode);
            }
        }
    } while (FALSE);

    switch (GeneralStatus)
    {
      case NDIS_STATUS_MEDIA_DISCONNECT:
        MINIPORT_CLEAR_FLAG(Miniport, fMINIPORT_MEDIA_CONNECTED);

        //
        // miniport can do media sense and indicate that status to Ndis
        //
        MINIPORT_CLEAR_FLAG(Miniport, fMINIPORT_REQUIRES_MEDIA_POLLING);
        MINIPORT_SET_FLAG(Miniport, fMINIPORT_SUPPORTS_MEDIA_SENSE);

        //
        //  Is this a PM enabled miniport? And is dynamic power policy
        //  enabled for the miniport?
        //
        if (MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_DEVICE_POWER_ENABLE) &&
            (Miniport->WakeUpEnable & NDIS_PNP_WAKE_UP_LINK_CHANGE) &&
            (Miniport->MediaDisconnectTimeOut != (USHORT)(-1)))
        {
            //
            //  Are we already waiting for the disconnect timer to fire?
            //
            if (!MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_MEDIA_DISCONNECT_WAIT))
            {
                //
                //  Mark the miniport as disconnecting and fire off the
                //  timer.
                //
                MINIPORT_PNP_CLEAR_FLAG(Miniport, fMINIPORT_MEDIA_DISCONNECT_CANCELLED);
                MINIPORT_PNP_SET_FLAG(Miniport, fMINIPORT_MEDIA_DISCONNECT_WAIT);
                
                NdisSetTimer(&Miniport->MediaDisconnectTimer, Miniport->MediaDisconnectTimeOut * 1000);
            }
        }
        break;

      case NDIS_STATUS_MEDIA_CONNECT:
        MINIPORT_SET_FLAG(Miniport, fMINIPORT_MEDIA_CONNECTED);
        //
        // miniport can do media sense and can indicate that status to Ndis. Do not poll
        //
        MINIPORT_CLEAR_FLAG(Miniport, fMINIPORT_REQUIRES_MEDIA_POLLING);
        MINIPORT_SET_FLAG(Miniport, fMINIPORT_SUPPORTS_MEDIA_SENSE);

        //
        // if media disconnect timer was set, cancel the timer
        //
        if (MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_MEDIA_DISCONNECT_WAIT))
        {
            BOOLEAN fTimerCancelled;

            //
            //  Clear the disconnect wait bit and cancel the timer.
            //  IF the timer routine hasn't grabed the lock then we are ok.
            //
            MINIPORT_PNP_CLEAR_FLAG(Miniport, fMINIPORT_MEDIA_DISCONNECT_WAIT);
            MINIPORT_PNP_SET_FLAG(Miniport, fMINIPORT_MEDIA_DISCONNECT_CANCELLED);

            NdisCancelTimer(&Miniport->MediaDisconnectTimer, &fTimerCancelled);
        }
        break;
    }

    if (VcPtr != NULL)
    {
        VcBlock = VcPtr->VcBlock;

        //
        // If this is a proxied VC, indicate to the proxy. 
        //

        if (VcBlock->pProxyVcPtr) 
        {
            Open = VcBlock->pProxyVcPtr->ClientOpen;
            (Open->ProtocolHandle->ProtocolCharacteristics.CoStatusHandler)(Open->ProtocolBindingContext,
                                                                            VcPtr->ClientContext,
                                                                            GeneralStatus,
                                                                            StatusBuffer,
                                                                            StatusBufferSize);
        }

        //
        // Indicate to the client.
        //

        if (VcBlock->pClientVcPtr)
        {
            Open = VcBlock->pClientVcPtr->ClientOpen;
            (Open->ProtocolHandle->ProtocolCharacteristics.CoStatusHandler)(Open->ProtocolBindingContext,
                                                                            VcPtr->ClientContext,
                                                                            GeneralStatus,
                                                                            StatusBuffer,
                                                                            StatusBufferSize);
        }
    }
    else if (Miniport->NullDB != NULL)
    {
        LOCK_STATE  LockState;

        //
        // this must be a general status for all clients of this miniport
        // since the Vc handle is null, so indicate this to all protocols.
        //
        READ_LOCK_FILTER(Miniport, Miniport->NullDB, &LockState);

        for (Open = Miniport->OpenQueue;
             Open != NULL;
             Open = Open->MiniportNextOpen)
        {
            if (((Open->Flags & fMINIPORT_OPEN_CLOSING) == 0) &&
                (Open->ProtocolHandle->ProtocolCharacteristics.CoStatusHandler != NULL))
            {
                (Open->ProtocolHandle->ProtocolCharacteristics.CoStatusHandler)(
                        Open->ProtocolBindingContext,
                        NULL,
                        GeneralStatus,
                        StatusBuffer,
                        StatusBufferSize);

            }
        }

        READ_UNLOCK_FILTER(Miniport, Miniport->NullDB, &LockState);
    }

    DBGPRINT(DBG_COMP_CO, DBG_LEVEL_INFO,
            ("<==NdisMCoIndicateStatus\n"));
}

VOID
ndisDereferenceAfNotification(
    IN  PNDIS_OPEN_BLOCK        Open
    )
{    
    ULONG   Ref;
    KIRQL   OldIrql;
    
//    DbgPrint("==>ndisDereferenceAfNotification Open: %p\n", Open);

    ACQUIRE_SPIN_LOCK(&Open->SpinLock, &OldIrql);

    OPEN_DECREMENT_AF_NOTIFICATION(Open, Ref);
    
    if ((Ref == 0) &&
        (Open->AfNotifyCompleteEvent != NULL))
    {
        SET_EVENT(Open->AfNotifyCompleteEvent);
    }
    RELEASE_SPIN_LOCK(&Open->SpinLock, OldIrql);

//    DbgPrint("<==ndisDereferenceAfNotification Open: %p, Ref %lx\n", Open, Ref);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ndis\sys\ndistags.h ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation

Module Name:

    ndistags.h

Abstract:

    List of pool tags used by the NDIS Wraper.

Author:


Environment:

    Kernel mode, FSD

Revision History:

    Mar-96  Jameel Hyder    Initial version
--*/

#ifndef _NDISTAGS_
#define _NDISTAGS_

#define NDIS_TAG_DEFAULT                    '  DN'
#define NDIS_TAG_WORK_ITEM                  'iwDN'
#define NDIS_TAG_NAME_BUF                   'naDN'
#define NDIS_TAG_CO                         'ocDN'
#define NDIS_TAG_DMA                        'bdDN'
#define NDIS_TAG_ALLOC_MEM                  'maDN'
#define NDIS_TAG_ALLOC_MEM_VERIFY_ON        'mvDN'
#define NDIS_TAG_SLOT_INFO                  'isDN'
#define NDIS_TAG_PKT_POOL                   'ppDN'
#define NDIS_TAG_RSRC_LIST                  'lrDN'
#define NDIS_TAG_LOOP_PKT                   'plDN'
#define NDIS_TAG_Q_REQ                      'qrDN'
#define NDIS_TAG_PROT_BLK                   'bpDN'
#define NDIS_TAG_OPEN_BLK                   'boDN'
#define NDIS_TAG_M_OPEN_BLK                 'omDN'
#define NDIS_TAG_DFRD_TMR                   'tdDN'
#define NDIS_TAG_LA_BUF                     'blDN'
#define NDIS_TAG_MAP_REG                    'rmDN'
#define NDIS_TAG_MINI_BLOCK                 'bmDN'
#define NDIS_TAG_DBG                        ' dDN'
#define NDIS_TAG_DBG_S                      'sdDN'
#define NDIS_TAG_DBG_L                      'ldDN'
#define NDIS_TAG_DBG_P                      'pdDN'
#define NDIS_TAG_DBG_LOG                    'lDDN'
#define NDIS_TAG_FILTER                     'fpDN'
#define NDIS_TAG_STRING                     'tsDN'
#define NDIS_TAG_PKT_PATTERN                'kpDN'
#define NDIS_TAG_FILTER_ADDR                'afDN'
#define NDIS_TAG_WMI_REG_INFO               '0wDN'
#define NDIS_TAG_WMI_GUID_TO_OID            '1wDN'
#define NDIS_TAG_WMI_OID_SUPPORTED_LIST     '2wDN'
#define NDIS_TAG_WMI_EVENT_ITEM             '3wDN'
#define NDIS_TAG_REGISTRY_PATH              'prDN'
#define NDIS_TAG_OID_ARRAY                  'aoDN'
#define NDIS_TAG_SHARED_MEMORY              'hsDN'
#define NDIS_TAG_ARC_BUFFER                 'baDN'
#define NDIS_TAG_ARC_DATA                   'daDN'
#define NDIS_TAG_ARC_PACKET                 'paDN'
#define NDIS_TAG_ARC_BINDING_INFO           'iaDN'
#define NDIS_TAG_FILE_NAME                  'nfDN'
#define NDIS_TAG_FILE_IMAGE                 'ifDN'
#define NDIS_TAG_FILE_DESCRIPTOR            'dfDN'
#define NDIS_TAG_WRAPPER_HANDLE             'hwDN'
#define NDIS_TAG_ALLOC_SHARED_MEM_ASYNC     'saDN'
#define NDIS_TAG_FREE_SHARED_MEM_ASYNC      'sfDN'
#define NDIS_TAG_ALLOCATED_RESOURCES        'raDN'
#define NDIS_TAG_BUS_INTERFACE              'ibDN'
#define NDIS_TAG_CONFIG_HANLDE              'hcDN'
#define NDIS_TAG_PARAMETER_NODE             'npDN'
#define NDIS_TAG_REG_READ_DATA_BUFFER       'drDN'
#define NDIS_TAG_IM_DEVICE_INSTANCE         'idDN'
#define NDIS_TAG_CANCEL_DEVICE_NAME         'ncDN'
#define NDIS_TAG_OPEN_CONTEXT               'coDN'
#define NDIS_TAG_ARC_SEND_BUFFERS           'faDN'
#define NDIS_TAG_MEDIA_TYPE_ARRAY           'tmDN'
#define NDIS_TAG_PROTOCOL_CONFIGURATION     'cpDN'
#define NDIS_TAG_DOUBLE_BUFFER_PKT          'gsDN'
#define NDIS_TAG_FAKE_MAC                   'mfDN'
#define NDIS_TAG_NET_CFG_OPS_ID             'scDN'
#define NDIS_TAG_NET_CFG_OPS_ACL            'acDN'
#define NDIS_TAG_NET_CFG_SEC_DESC           'dsDN'
#define NDIS_TAG_NET_CFG_DACL               'adDN'
#define NDIS_TAG_SECURITY                   'esDN'
#define NDIS_TAG_NET_CFG_DACL               'adDN'
#define NDIS_TAG_SECURITY                   'esDN'

#endif  // _NDISTAGS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ndis\sys\ndis_co.h ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation

Module Name:

    ndis_co.h

Abstract:

    NDIS wrapper CO definitions

Author:


Environment:

    Kernel mode, FSD

Revision History:

    Jan-98  Jameel Hyder    Split up from ndisco.h
--*/

#ifndef _NDIS_CO_
#define _NDIS_CO_

//
//  NDIS_CO_AF_BLOCK:
//
//  This structure represents a client's open of an address family on an adapter.
//  An NdisAfHandle points to one of these.
//
//  Creation: NdisClOpenAddressFamily
//  Deletion: Ndis[M]CmCloseAddressFamilyComplete
//
typedef struct _NDIS_CO_AF_BLOCK
{
    struct _NDIS_CO_AF_BLOCK *      NextAf;             // the next open of the call manager per adapter open
    ULONG                           Flags;
    LONG                            References;
    PNDIS_MINIPORT_BLOCK            Miniport;           // pointer to the miniport in question

    //
    // Cached call manager entry points
    //
    PNDIS_CALL_MANAGER_CHARACTERISTICS  CallMgrEntries;
    PNDIS_OPEN_BLOCK                CallMgrOpen;        // pointer to the call manager's open adapter:
                                                        // this is NULL iff combined Miniport+CM

    NDIS_HANDLE                     CallMgrContext;     // context when calling CM's ProtXX funcs

    //
    // Cached client entry points
    //
    NDIS_CLIENT_CHARACTERISTICS     ClientEntries;
    PNDIS_OPEN_BLOCK                ClientOpen;         // pointer to the client's open adapter
    NDIS_HANDLE                     ClientContext;      // context when calling Client's ProtXX funcs

    KSPIN_LOCK                      Lock;
} NDIS_CO_AF_BLOCK, *PNDIS_CO_AF_BLOCK;


//
//  Bit definitions for Flags in NDIS_CO_AF_BLOCK
//
#define AF_COMBO                0x00000001              // Set iff combined Miniport+CM
#define AF_CLOSING              0x80000000


//
//  NDIS_CO_SAP_BLOCK:
//
//  Service Access Point (Sap) structure. The NdisSapHandle points to one of these.
//  A SAP is associated with an open AF block.
//
//  Creation: NdisClRegisterSap
//  Deletion: Ndis[M]CmDeregisterSapComplete
//
typedef struct _NDIS_CO_SAP_BLOCK
{
    NDIS_HANDLE                 CallMgrContext;
    NDIS_HANDLE                 ClientContext;
    PNDIS_CO_AF_BLOCK           AfBlock;
    PCO_SAP                     Sap;
    ULONG                       Flags;
    LONG                        References;
    KSPIN_LOCK                  Lock;
} NDIS_CO_SAP_BLOCK, *PNDIS_CO_SAP_BLOCK;

//
// Definitions for Flags in NDIS_CO_SAP_BLOCK:
//
#define SAP_CLOSING             0x80000000




//
//  NDIS_CO_VC_BLOCK:
//
//  The Virtual Connection structure. The NdisVcHandle points to a NDIS_CO_VC_PTR,
//  which points to one of these.
//
//  Creation: NdisCoCreateVc, NdisMCmCreateVc
//  Deletion: NdisCoDeleteVc, NdisMCmDeleteVc
//
typedef struct _NDIS_CO_VC_BLOCK
{
    ULONG                               References;
    ULONG                               Flags;          // to track closes
    KSPIN_LOCK                          Lock;

    PNDIS_OPEN_BLOCK                    ClientOpen;     // identifies the client for miniport
                                                        // IndicatePacket
    //
    // References for client and call-manager
    //
    NDIS_HANDLE                         ClientContext;  // passed up to the client on indications
    struct _NDIS_CO_VC_PTR_BLOCK    *   pProxyVcPtr;    // Pointer to Proxy's VcPr
    struct _NDIS_CO_VC_PTR_BLOCK    *   pClientVcPtr;   // Pointer to Client's VcPtr
    //
    // Clients cached entry points
    //
    CO_SEND_COMPLETE_HANDLER            CoSendCompleteHandler;
    CO_RECEIVE_PACKET_HANDLER           CoReceivePacketHandler;

    PNDIS_OPEN_BLOCK                    CallMgrOpen;    // identifies the call-manager
    NDIS_HANDLE                         CallMgrContext; // passed up to the call manager on indications

    //
    // Call-manager cached entry points duplicates of VC_PTR_BLOCK
    //
    CM_ACTIVATE_VC_COMPLETE_HANDLER     CmActivateVcCompleteHandler;
    CM_DEACTIVATE_VC_COMPLETE_HANDLER   CmDeactivateVcCompleteHandler;
    CM_MODIFY_CALL_QOS_HANDLER          CmModifyCallQoSHandler;

    //
    // Miniport's context and some cached entry-points
    //
    PNDIS_MINIPORT_BLOCK                Miniport;       // pointer to the miniport in question
    NDIS_HANDLE                         MiniportContext;// passed down to the miniport

    ULONGLONG                           VcId;           // opaque ID for the VC, picked
                                                        // up from MediaParameters when
                                                        // the VC is activated

} NDIS_CO_VC_BLOCK, *PNDIS_CO_VC_BLOCK;


//
//  NDIS_CO_VC_PTR_BLOCK:
//
//  The VC Pointer structure. The NdisVcHandle points to one of these.
//  When a VC is created, one VC Block structure and one VC pointer structure
//  are created.
//
//
typedef struct _NDIS_CO_VC_PTR_BLOCK
{
    LONG                                References;
    ULONG                               CallFlags;      // call state of this VC Ptr
    PLONG                               pVcFlags;
    KSPIN_LOCK                          Lock;

    NDIS_HANDLE                         ClientContext;  // passed up to the client
                                                        // on indications and completes
    LIST_ENTRY                          ClientLink;
    LIST_ENTRY                          VcLink;

    PNDIS_CO_AF_BLOCK                   AfBlock;        // OPTIONAL - NULL for call-mgr owned VCs

    //
    // Miniport VC
    //
    PNDIS_CO_VC_BLOCK                   VcBlock;

    //
    // Identifies the client. This could be the call-manager open if the
    // Vc is call-manager owned, i.e. doesn't have an client association.
    //

    PNDIS_OPEN_BLOCK                    ClientOpen;

    LONG                                OwnsVcBlock;        

    //
    // The non-creator's handler and context
    //
    CO_DELETE_VC_HANDLER                CoDeleteVcHandler;
    NDIS_HANDLE                         DeleteVcContext;

    //
    // Clients cached entry points
    //
    CL_MODIFY_CALL_QOS_COMPLETE_HANDLER ClModifyCallQoSCompleteHandler;
    CL_INCOMING_CALL_QOS_CHANGE_HANDLER ClIncomingCallQoSChangeHandler;
    CL_CALL_CONNECTED_HANDLER           ClCallConnectedHandler;

    PNDIS_OPEN_BLOCK                    CallMgrOpen;    // identifies the call-manager
    NDIS_HANDLE                         CallMgrContext; // passed up to the call manager on indications
    LIST_ENTRY                          CallMgrLink;

    //
    // Call-manager cached entry points duplicates of VC_BLOCK
    //
    CM_ACTIVATE_VC_COMPLETE_HANDLER     CmActivateVcCompleteHandler;
    CM_DEACTIVATE_VC_COMPLETE_HANDLER   CmDeactivateVcCompleteHandler;
    CM_MODIFY_CALL_QOS_HANDLER          CmModifyCallQoSHandler;

    //
    // Miniport's context and some cached entry-points
    //
    PNDIS_MINIPORT_BLOCK                Miniport;       // pointer to the miniport in question
    NDIS_HANDLE                         MiniportContext;// passed down to the miniport
    W_CO_SEND_PACKETS_HANDLER           WCoSendPacketsHandler;
    W_CO_DELETE_VC_HANDLER              WCoDeleteVcHandler;
    W_CO_ACTIVATE_VC_HANDLER            WCoActivateVcHandler;
    W_CO_DEACTIVATE_VC_HANDLER          WCoDeactivateVcHandler;

    UNICODE_STRING                      VcInstanceName;     //  Used to query this specific VC via WMI.
    LARGE_INTEGER                       VcIndex;            //  Used to build the instance name.
    LIST_ENTRY                          WmiLink;            //  List of WMI enabled VCs

} NDIS_CO_VC_PTR_BLOCK, *PNDIS_CO_VC_PTR_BLOCK;



#define VC_ACTIVE               0x00000001
#define VC_ACTIVATE_PENDING     0x00000002
#define VC_DEACTIVATE_PENDING   0x00000004
#define VC_DELETE_PENDING       0x00000008
#define VC_HANDOFF_IN_PROGRESS  0x00000010  // Being handed off to proxied client

//
// VC Call states:
//
#define VC_CALL_ACTIVE          0x00000008
#define VC_CALL_PENDING         0x00000010
#define VC_CALL_CLOSE_PENDING   0x00000020
#define VC_CALL_ABORTED         0x00000040
#define VC_PTR_BLOCK_CLOSING    0x80000000

//
// Structure to represent a handle generated when a multi-party call is generated.
// This handle can ONLY be used for NdisCoDropParty call.
//
typedef struct _NDIS_CO_PARTY_BLOCK
{
    PNDIS_CO_VC_PTR_BLOCK           VcPtr;
    NDIS_HANDLE                     CallMgrContext;
    NDIS_HANDLE                     ClientContext;

    //
    // Cached client Handlers
    //
    CL_INCOMING_DROP_PARTY_HANDLER  ClIncomingDropPartyHandler;
    CL_DROP_PARTY_COMPLETE_HANDLER  ClDropPartyCompleteHandler;
} NDIS_CO_PARTY_BLOCK, *PNDIS_CO_PARTY_BLOCK;


NTSTATUS
ndisUnicodeStringToPointer (
    IN  PUNICODE_STRING             String,
    IN  ULONG                       Base OPTIONAL,
    OUT PVOID                       *Value
    );


#endif  // _NDIS_CO_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ndis\sys\pragma.h ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation

Module Name:

    pragma.h

Abstract:

    Pragma definitions for pageable/init/section-pageable NDIS Wrapper routines.

Author:


Environment:

    Kernel mode, FSD

Revision History:

    Feb-96  Jameel Hyder    Moved from individual source files
--*/

#ifndef _PRAGMA_
#define _PRAGMA_

#ifdef ALLOC_PRAGMA

#pragma alloc_text(INIT, DriverEntry)
#pragma alloc_text(INIT, ndisReadRegistry)
#pragma alloc_text(INIT, ndisAddMediaTypeToArray)
#pragma alloc_text(INIT, ndisReadProcessorAffinityMask)
                                                
//
// These are normally paged out and only get locked down during PnP/Power operations
//
#pragma alloc_text(PAGENPNP, ndisWorkerThread)
#pragma alloc_text(PAGENPNP, ndisDispatchRequest)
#pragma alloc_text(PAGENPNP, ndisHandlePnPRequest)
#pragma alloc_text(PAGENPNP, ndisHandleProtocolBindNotification)
#pragma alloc_text(PAGENPNP, ndisHandleProtocolUnbindNotification)
#pragma alloc_text(PAGENPNP, ndisHandleProtocolReconfigNotification)
#pragma alloc_text(PAGENPNP, ndisHandleProtocolUnloadNotification)
#pragma alloc_text(PAGENPNP, ndisNotifyWmiBindUnbind)
#pragma alloc_text(PAGENPNP, ndisHandleOrphanDevice)
#pragma alloc_text(PAGENPNP, ndisReferenceMiniportByName)
#pragma alloc_text(PAGENPNP, ndisHandleLegacyTransport)
#pragma alloc_text(PAGENPNP, ndisHandleUModePnPOp)
#pragma alloc_text(PAGENPNP, ndisEnumerateInterfaces)
#pragma alloc_text(PAGENPNP, ndisUnbindProtocol)
// #pragma alloc_text(PAGENPNP, NdisCompleteBindAdapter)
#pragma alloc_text(PAGENPNP, NdisCompleteUnbindAdapter)
#pragma alloc_text(PAGENPNP, NdisRegisterTdiCallBack)
#pragma alloc_text(PAGENPNP, ndisInitializePackage)
#pragma alloc_text(PAGENPNP, NdisOpenFile)
#pragma alloc_text(PAGENPNP, NdisCloseFile)
#pragma alloc_text(PAGENPNP, NdisQueryMapRegisterCount)
#pragma alloc_text(PAGENPNP, ndisVerifierQueryMapRegisterCount)
#pragma alloc_text(PAGENPNP, ndisCreateAdapterInstanceName)
#pragma alloc_text(PAGENPNP, ndisPnPCancelStopDevice)
#pragma alloc_text(PAGENPNP, ndisPnPStopDevice)
#pragma alloc_text(PAGENPNP, ndisPnPQueryStopDevice)
#pragma alloc_text(PAGENPNP, ndisPnPCancelRemoveDevice)
#pragma alloc_text(PAGENPNP, ndisPnPQueryRemoveDevice)
#pragma alloc_text(PAGENPNP, ndisPnPRemoveDevice)
#pragma alloc_text(PAGENPNP, ndisQueryReferenceBusInterface)
#pragma alloc_text(PAGENPNP, ndisPnPAddDevice)
#pragma alloc_text(PAGENPNP, ndisPnPStartDevice)
#pragma alloc_text(PAGENPNP, ndisAddDevice)
#pragma alloc_text(PAGENPNP, ndisSetDeviceNames)
#pragma alloc_text(PAGENPNP, ndisPnPDispatch)
#pragma alloc_text(PAGENPNP, ndisReinitializeMiniportBlock)
#pragma alloc_text(PAGENPNP, ndisQueryPowerCapabilities)
#pragma alloc_text(PAGENPNP, ndisQueryPower)
#pragma alloc_text(PAGENPNP, ndisSetPower)
#pragma alloc_text(PAGENPNP, ndisPowerDispatch)
#pragma alloc_text(PAGENPNP, ndisDevicePowerOn)
#pragma alloc_text(PAGENPNP, ndisDevicePowerDown)
#pragma alloc_text(PAGENPNP, ndisWMIDispatch)
#pragma alloc_text(PAGENPNP, ndisWmiChangeSingleItem)
#pragma alloc_text(PAGENPNP, ndisWmiChangeSingleInstance)
#pragma alloc_text(PAGENPNP, ndisWmiQuerySingleInstance)
#pragma alloc_text(PAGENPNP, ndisWmiFindInstanceName)
#pragma alloc_text(PAGENPNP, ndisWmiQueryAllData)
#pragma alloc_text(PAGENPNP, ndisWmiGuidIsAdapterSpecific)
#pragma alloc_text(PAGENPNP, ndisQueryGuidData)
#pragma alloc_text(PAGENPNP, ndisQueryGuidDataSize)
#pragma alloc_text(PAGENPNP, ndisWmiRegister)
#pragma alloc_text(PAGENPNP, ndisQuerySupportedGuidToOidList)
#pragma alloc_text(PAGENPNP, ndisWmiMapOids)
#pragma alloc_text(PAGENPNP, ndisQueryCustomGuids)
#pragma alloc_text(PAGENPNP, ndisPnPNotifyAllTransports)
#pragma alloc_text(PAGENPNP, ndisPnPNotifyBinding)
#pragma alloc_text(PAGENPNP, ndisInitializeRef)
#pragma alloc_text(PAGENPNP, ndisMQueuedFreeSharedHandler)
#pragma alloc_text(PAGENPNP, ndisReferenceProtocolByName)
#pragma alloc_text(PAGENPNP, ndisMPowerPolicy)
#pragma alloc_text(PAGENPNP, ndisQuerySetMiniportDeviceState)
#pragma alloc_text(PAGENPNP, ndisMediaDisconnectWorker)
#pragma alloc_text(PAGENPNP, ndisWmiEnableEvents)
#pragma alloc_text(PAGENPNP, ndisWmiDisableEvents)
#pragma alloc_text(PAGENPNP, ndisDummyIrpHandler)
#pragma alloc_text(PAGENPNP, ndisDeviceControlIrpHandler)
#pragma alloc_text(PAGENPNP, ndisQueryDeviceOid)
#pragma alloc_text(PAGENPNP, ndisValidOid)
#pragma alloc_text(PAGENPNP, ndisSplitStatisticsOids)
//
// These are normally paged out and only get locked down during driver initialization
//
#pragma alloc_text(PAGENPNP, NdisRegisterProtocol)
#pragma alloc_text(PAGENPNP, NdisDeregisterProtocol)
#pragma alloc_text(PAGENPNP, NdisOpenAdapter)
#pragma alloc_text(PAGENPNP, ndisMOpenAdapter)
#pragma alloc_text(PAGENPNP, ndisMFinishQueuedPendingOpen)
#pragma alloc_text(PAGENPNP, ndisQueueOpenOnMiniport)
#pragma alloc_text(PAGENPNP, ndisQueueOpenOnProtocol)
#pragma alloc_text(PAGENPNP, NdisCloseAdapter)
#pragma alloc_text(PAGENPNP, ndisMKillOpen)
#pragma alloc_text(PAGENPNP, ndisMFinishClose)
#pragma alloc_text(PAGENPNP, ndisMQueuedFinishClose)
#pragma alloc_text(PAGENPNP, ndisInitializeBinding)
#pragma alloc_text(PAGENPNP, ndisDeQueueOpenOnMiniport)
#pragma alloc_text(PAGENPNP, ndisDeQueueOpenOnProtocol)
#pragma alloc_text(PAGENPNP, NdisMRegisterMiniport)
#pragma alloc_text(PAGENPNP, ndisRegisterMiniportDriver)
#pragma alloc_text(PAGENPNP, NdisIMAssociateMiniport)
#pragma alloc_text(PAGENPNP, NdisIMRegisterLayeredMiniport)
#pragma alloc_text(PAGENPNP, NdisIMDeregisterLayeredMiniport)
#pragma alloc_text(PAGENPNP, NdisMDeregisterInterrupt)
#pragma alloc_text(PAGENPNP, NdisMDeregisterInterruptEx)
#pragma alloc_text(PAGENPNP, ndisMDeregisterInterruptCommon)
#pragma alloc_text(PAGENPNP, NdisMDeregisterIoPortRange)
#pragma alloc_text(PAGENPNP, NdisMUnmapIoSpace)
#pragma alloc_text(PAGENPNP, NdisMDeregisterDmaChannel)
#pragma alloc_text(PAGENPNP, NdisMFreeMapRegisters)
#pragma alloc_text(PAGENPNP, NdisMDeregisterAdapterShutdownHandler)
#pragma alloc_text(PAGENPNP, ndisInitializeAdapter)
#pragma alloc_text(PAGENPNP, ndisInitializeConfiguration)
#pragma alloc_text(PAGENPNP, ndisMInitializeAdapter)
#pragma alloc_text(PAGENPNP, ndisTranslateResources)
#pragma alloc_text(PAGENPNP, ndisCheckAdapterBindings)
#pragma alloc_text(PAGENPNP, NdisIMDeInitializeDeviceInstance)
#pragma alloc_text(PAGENPNP, ndisIMInitializeDeviceInstance)
#pragma alloc_text(PAGENPNP, ndisProtocolAlreadyBound)
#pragma alloc_text(PAGENPNP, NdisOpenConfiguration)
#pragma alloc_text(PAGENPNP, NdisOpenConfigurationKeyByName)
#pragma alloc_text(PAGENPNP, NdisOpenConfigurationKeyByIndex)
#pragma alloc_text(PAGENPNP, NdisReadConfiguration)
#pragma alloc_text(PAGENPNP, NdisWriteConfiguration)
#pragma alloc_text(PAGENPNP, NdisCloseConfiguration)
#pragma alloc_text(PAGENPNP, NdisReadNetworkAddress)
#pragma alloc_text(PAGENPNP, NdisConvertStringToAtmAddress)
#pragma alloc_text(PAGENPNP, ndisReadParameter)
#pragma alloc_text(PAGENPNP, ndisSaveParameters)
#pragma alloc_text(PAGENPNP, ndisCheckPortUsage)
#pragma alloc_text(PAGENPNP, ndisImmediateReadWritePort)
#pragma alloc_text(PAGENPNP, ndisImmediateReadWriteSharedMemory)
#pragma alloc_text(PAGENPNP, ndisStartMapping)
#pragma alloc_text(PAGENPNP, ndisEndMapping)
#pragma alloc_text(PAGENPNP, NdisImmediateReadPortUchar)
#pragma alloc_text(PAGENPNP, NdisImmediateReadPortUshort)
#pragma alloc_text(PAGENPNP, NdisImmediateReadPortUlong)
#pragma alloc_text(PAGENPNP, NdisImmediateWritePortUchar)
#pragma alloc_text(PAGENPNP, NdisImmediateWritePortUshort)
#pragma alloc_text(PAGENPNP, NdisImmediateWritePortUlong)
#pragma alloc_text(PAGENPNP, ndisCheckMemoryUsage)
#pragma alloc_text(PAGENPNP, NdisImmediateReadSharedMemory)
#pragma alloc_text(PAGENPNP, NdisImmediateWriteSharedMemory)
#pragma alloc_text(PAGENPNP, NdisInitializeWrapper)
#pragma alloc_text(PAGENPNP, NdisTerminateWrapper)
#pragma alloc_text(PAGENPNP, NdisMQueryAdapterResources)
#pragma alloc_text(PAGENPNP, NdisAllocateDmaChannel)
#pragma alloc_text(PAGENPNP, NdisMAllocateMapRegisters)
#pragma alloc_text(PAGENPNP, NdisMInitializeScatterGatherDma)
#pragma alloc_text(PAGENPNP, NdisMQueryAdapterInstanceName)
#pragma alloc_text(PAGENPNP, NdisMSetAttributes)
#pragma alloc_text(PAGENPNP, NdisMSetAttributesEx)
#pragma alloc_text(PAGENPNP, NdisReadEisaSlotInformationEx)
#pragma alloc_text(PAGENPNP, NdisReadEisaSlotInformation)
#pragma alloc_text(PAGENPNP, NdisImmediateReadPciSlotInformation)
#pragma alloc_text(PAGENPNP, NdisImmediateWritePciSlotInformation)
#pragma alloc_text(PAGENPNP, ndisQueryBusInterface)
#pragma alloc_text(PAGENPNP, NdisMRegisterDevice)
#pragma alloc_text(PAGENPNP, NdisMRegisterUnloadHandler)
#pragma alloc_text(PAGENPNP, NdisMAllocateSharedMemory)
#pragma alloc_text(PAGENPNP, NdisMRegisterInterrupt)
#pragma alloc_text(PAGENPNP, NdisMRegisterInterruptEx)
#pragma alloc_text(PAGENPNP, ndisMRegisterInterruptCommon)
#pragma alloc_text(PAGENPNP, NdisMPciAssignResources)
#pragma alloc_text(PAGENPNP, NdisMRegisterAdapterShutdownHandler)
#pragma alloc_text(PAGENPNP, NdisMRegisterIoPortRange)
#pragma alloc_text(PAGENPNP, NdisMMapIoSpace)
#pragma alloc_text(PAGENPNP, NdisMRegisterDmaChannel)
#pragma alloc_text(PAGENPNP, ndisMCreateDummyFilters)
#pragma alloc_text(PAGENPNP, ndisMAdjustFilters)
#pragma alloc_text(PAGENPNP, ndisMDoMiniportOp)
#pragma alloc_text(PAGENPNP, ndisPmInitializeMiniport)
#pragma alloc_text(PAGENPNP, ndisCheckProtocolBindings)
#pragma alloc_text(PAGENPNP, NdisIMGetDeviceContext)
#pragma alloc_text(PAGENPNP, NdisIMGetBindingContext)
#pragma alloc_text(PAGENPNP, NdisMapFile)
#pragma alloc_text(PAGENPNP, NdisUnmapFile)
#pragma alloc_text(PAGENPNP, NdisMSleep)
#pragma alloc_text(PAGENPNP, ndisMUnload)
#pragma alloc_text(PAGENPNP, NdisIMNotifyPnPEvent)
#if ARCNET
#pragma alloc_text(PAGENPNP, ArcCreateFilter)
#pragma alloc_text(PAGENPNP, ArcDeleteFilter)
#endif
#pragma alloc_text(PAGENPNP, EthCreateFilter)
#pragma alloc_text(PAGENPNP, EthDeleteFilter)
#pragma alloc_text(PAGENPNP, TrCreateFilter)
#pragma alloc_text(PAGENPNP, TrDeleteFilter)
#pragma alloc_text(PAGENPNP, FddiCreateFilter)
#pragma alloc_text(PAGENPNP, FddiDeleteFilter)
#pragma alloc_text(PAGENPNP, NdisCmRegisterAddressFamily)
#pragma alloc_text(PAGENPNP, NdisMCmRegisterAddressFamily)
#pragma alloc_text(PAGENPNP, NdisClOpenAddressFamily)
#pragma alloc_text(PAGENPNP, ndisWorkItemHandler)
#pragma alloc_text(PAGENPNP, ndisQuerySetMiniport)
#pragma alloc_text(PAGENPNP, ndisCreateNotifyQueue)
#pragma alloc_text(PAGENPNP, ndisNotifyAfRegistration)
#pragma alloc_text(PAGENPNP, NdisMGetDeviceProperty)
#pragma alloc_text(PAGENPNP, ndisMHaltMiniport)
#pragma alloc_text(PAGENPNP, ndisMCommonHaltMiniport)
#pragma alloc_text(PAGENPNP, ndisMShutdownMiniport)
#pragma alloc_text(PAGENPNP, ndisCloseMiniportBindings)
#pragma alloc_text(PAGENPNP, ndisFindRootDevice)
#pragma alloc_text(PAGENPNP, ndisFindMiniportOnGlobalList)
#pragma alloc_text(PAGENPNP, ndisDeQueueMiniportOnDriver)
#pragma alloc_text(PAGENPNP, ndisQueueMiniportOnDriver)
#pragma alloc_text(PAGENPNP, ndisCloseAllBindingsOnProtocol)
#pragma alloc_text(PAGENPNP, ndisPmHaltMiniport)
#pragma alloc_text(PAGENPNP, NdisIMInitializeDeviceInstance)
#pragma alloc_text(PAGENPNP, NdisIMInitializeDeviceInstanceEx)
#pragma alloc_text(PAGENPNP, NdisIMCancelInitializeDeviceInstance)
#pragma alloc_text(PAGENPNP, ndisIMCheckDeviceInstance)
#pragma alloc_text(PAGENPNP, ndisNotifyMiniports)
#pragma alloc_text(PAGENPNP, ndisReferenceNextUnprocessedMiniport)
#pragma alloc_text(PAGENPNP, ndisUnprocessAllMiniports)
#pragma alloc_text(PAGENPNP, ndisQueueBindWorkitem)
#pragma alloc_text(PAGENPNP, ndisQueuedCheckAdapterBindings)
#pragma alloc_text(PAGENPNP, NdisMGetDmaAlignment)
//
// These are normally paged out and only get locked when a miniport loads
//
#pragma alloc_text(PAGENDSM, NdisMReadDmaCounter)
#pragma alloc_text(PAGENDSM, NdisMSetTimer)
#pragma alloc_text(PAGENDSM, NdisMCancelTimer)
#pragma alloc_text(PAGENDSM, NdisMSynchronizeWithInterrupt)
#pragma alloc_text(PAGENDSM, ndisMIsr)
#pragma alloc_text(PAGENDSM, ndisMDpc)
#pragma alloc_text(PAGENDSM, ndisMDpcX)
#pragma alloc_text(PAGENDSM, ndisMWakeUpDpc)
#pragma alloc_text(PAGENDSM, ndisMWakeUpDpcX)
#pragma alloc_text(PAGENDSM, ndisMPollMediaState)
#pragma alloc_text(PAGENDSM, ndisMTimerDpc)
#pragma alloc_text(PAGENDSM, ndisMTimerDpcX)
#pragma alloc_text(PAGENDSM, ndisMDeferredDpc)
#pragma alloc_text(PAGENDSM, ndisMDeQueueWorkItem)
#pragma alloc_text(PAGENDSM, ndisMQueueWorkItem)
#pragma alloc_text(PAGENDSM, ndisMQueueNewWorkItem)
#pragma alloc_text(PAGENDSM, ndisMProcessDeferred)
#pragma alloc_text(PAGENDSM, ndisMProcessResetRequested)
#pragma alloc_text(PAGENDSM, NdisMIndicateStatus)
#pragma alloc_text(PAGENDSM, NdisMIndicateStatusComplete)
#pragma alloc_text(PAGENDSM, NdisMWanIndicateReceive)
#pragma alloc_text(PAGENDSM, NdisMWanIndicateReceiveComplete)
#pragma alloc_text(PAGENDSM, ndisMIndicatePacket)
#pragma alloc_text(PAGENDSM, ndisMAbortPackets)
#pragma alloc_text(PAGENDSM, ndisMAbortRequests)
#pragma alloc_text(PAGENDSM, NdisMResetComplete)
#pragma alloc_text(PAGENDSM, ndisMResetCompleteStage1)
#pragma alloc_text(PAGENDSM, ndisMResetCompleteStage2)
#pragma alloc_text(PAGENDSM, ndisMediaDisconnectTimeout)
#pragma alloc_text(PAGENDSM, ndisDereferenceMiniport)
#pragma alloc_text(PAGENDSM, NdisMQueryInformationComplete)
#pragma alloc_text(PAGENDSM, ndisMSyncQueryInformationComplete)
#pragma alloc_text(PAGENDSM, ndisMRequestSetInformationPost)
#pragma alloc_text(PAGENDSM, ndisMSyncSetInformationComplete)
#pragma alloc_text(PAGENDSM, NdisMSetInformationComplete)
#pragma alloc_text(PAGENDSM, ndisMSetPacketFilter)
#pragma alloc_text(PAGENDSM, ndisMSetProtocolOptions)
#pragma alloc_text(PAGENDSM, ndisMSetCurrentLookahead)
#pragma alloc_text(PAGENDSM, ndisMSetMulticastList)
#pragma alloc_text(PAGENDSM, ndisMSetAddWakeUpPattern)
#pragma alloc_text(PAGENDSM, ndisMSetRemoveWakeUpPattern)
#pragma alloc_text(PAGENDSM, ndisMSetEnableWakeUp)
#pragma alloc_text(PAGENDSM, ndisMSetInformation)
#pragma alloc_text(PAGENDSM, ndisMQueryCurrentPacketFilter)
#pragma alloc_text(PAGENDSM, ndisMQueryMediaSupported)
#pragma alloc_text(PAGENDSM, ndisMQueryEthernetMulticastList)
#pragma alloc_text(PAGENDSM, ndisMQueryMaximumFrameSize)
#pragma alloc_text(PAGENDSM, ndisMQueryMaximumTotalSize)
#pragma alloc_text(PAGENDSM, ndisMQueryNetworkAddress)
#pragma alloc_text(PAGENDSM, ndisMQueryEnableWakeUp)
#pragma alloc_text(PAGENDSM, ndisMQueryWakeUpPatternList)
#pragma alloc_text(PAGENDSM, ndisMQueryInformation)
#pragma alloc_text(PAGENDSM, ndisMRundownRequests)
#pragma alloc_text(PAGENDSM, ndisMDoRequests)
#pragma alloc_text(PAGENDSM, ndisMAllocateRequest)
#pragma alloc_text(PAGENDSM, ndisMQueueRequest)
#pragma alloc_text(PAGENDSM, ndisMRestoreFilterSettings)
#pragma alloc_text(PAGENDSM, ndisMDispatchRequest)
#pragma alloc_text(PAGENDSM, ndisMFilterOutStatisticsOids)
#pragma alloc_text(PAGENDSM, ndisMChangeClass)
#pragma alloc_text(PAGENDSM, ndisMCopyFromPacketToBuffer)
#pragma alloc_text(PAGENDSM, NdisMSendResourcesAvailable)
#pragma alloc_text(PAGENDSM, NdisMStartBufferPhysicalMapping)
#pragma alloc_text(PAGENDSM, NdisMCompleteBufferPhysicalMapping)
#pragma alloc_text(PAGENDSM, ndisMQueryWakeUpPatternList)
#pragma alloc_text(PAGENDSM, ndisMediaDisconnectComplete)
#pragma alloc_text(PAGENDSM, ndisMAllocSGList)
#pragma alloc_text(PAGENDSM, ndisMFreeSGList)
#pragma alloc_text(PAGENDSM, ndisMProcessSGList)
#pragma alloc_text(PAGENDSM, NdisIMSwitchToMiniport)
#pragma alloc_text(PAGENDSM, NdisIMRevertBack)
#pragma alloc_text(PAGENDSM, NdisIMQueueMiniportCallback)
#pragma alloc_text(PAGENDSM, NdisIMCopySendPerPacketInfo)
#pragma alloc_text(PAGENDSM, NdisIMCopySendCompletePerPacketInfo)
#pragma alloc_text(PAGENDSM, ndisMRestoreOpenHandlers)
#pragma alloc_text(PAGENDSM, ndisMSwapOpenHandlers)
#pragma alloc_text(PAGENDSM, NdisMCreateLog)
#pragma alloc_text(PAGENDSM, NdisMCloseLog)
#pragma alloc_text(PAGENDSM, NdisMWriteLogData)
#pragma alloc_text(PAGENDSM, NdisMFlushLog)
#pragma alloc_text(PAGENDSM, NdisMSetPeriodicTimer)
#pragma alloc_text(PAGENDSM, ndisMQueuedAllocateSharedHandler)
#pragma alloc_text(PAGENDSM, ndisMGetLogData)
#pragma alloc_text(PAGENDSM, NdisMSetMiniportSecondary)
#pragma alloc_text(PAGENDSM, NdisMPromoteMiniport)
#pragma alloc_text(PAGENDSM, NdisMRemoveMiniport)
#pragma alloc_text(PAGENDSM, XRemoveAndFreeBinding)
#pragma alloc_text(PAGENDSM, XRemoveBindingFromLists)
#pragma alloc_text(PAGENDSM, XFilterLockHandler)
#pragma alloc_text(PAGENDSM, XUndoFilterAdjust)
#pragma alloc_text(PAGENDSM, XFilterAdjust)
#pragma alloc_text(PAGENDSM, XNoteFilterOpenAdapter)
#pragma alloc_text(PAGENDSM, ndisMNotifyMachineName)
#pragma alloc_text(PAGENDSM, NdisMFreeSharedMemory)
#pragma alloc_text(PAGENDSM, ndisGetSetBusConfigSpace)
#pragma alloc_text(PAGENDSM, ndisSetupWmiNode)
#pragma alloc_text(PAGENDSM, ndisMSetIndicatePacketHandler)

//
// These are normally paged out and only get locked down when a CO-NDIS miniport loads
//
#pragma alloc_text(PAGENDCO, NdisCmOpenAddressFamilyComplete)
#pragma alloc_text(PAGENDCO, NdisCmCloseAddressFamilyComplete)
#pragma alloc_text(PAGENDCO, NdisClCloseAddressFamily)
#pragma alloc_text(PAGENDCO, NdisClRegisterSap)
#pragma alloc_text(PAGENDCO, NdisCmRegisterSapComplete)
#pragma alloc_text(PAGENDCO, NdisClDeregisterSap)
#pragma alloc_text(PAGENDCO, NdisCmDeregisterSapComplete)
#pragma alloc_text(PAGENDCO, NdisClMakeCall)
#pragma alloc_text(PAGENDCO, NdisCmMakeCallComplete)
#pragma alloc_text(PAGENDCO, NdisCmDispatchIncomingCall)
#pragma alloc_text(PAGENDCO, NdisClIncomingCallComplete)
#pragma alloc_text(PAGENDCO, NdisCmDispatchCallConnected)
#pragma alloc_text(PAGENDCO, NdisClModifyCallQoS)
#pragma alloc_text(PAGENDCO, NdisCmModifyCallQoSComplete)
#pragma alloc_text(PAGENDCO, NdisCmDispatchIncomingCallQoSChange)
#pragma alloc_text(PAGENDCO, NdisClCloseCall)
#pragma alloc_text(PAGENDCO, NdisCmCloseCallComplete)
#pragma alloc_text(PAGENDCO, NdisCmDispatchIncomingCloseCall)
#pragma alloc_text(PAGENDCO, NdisClAddParty)
#pragma alloc_text(PAGENDCO, NdisCmAddPartyComplete)
#pragma alloc_text(PAGENDCO, NdisClDropParty)
#pragma alloc_text(PAGENDCO, NdisCmDropPartyComplete)
#pragma alloc_text(PAGENDCO, NdisCmDispatchIncomingDropParty)
#pragma alloc_text(PAGENDCO, NdisCoCreateVc)
#pragma alloc_text(PAGENDCO, NdisCoDeleteVc)
#pragma alloc_text(PAGENDCO, NdisMCmDeleteVc)
#pragma alloc_text(PAGENDCO, NdisCmActivateVc)
#pragma alloc_text(PAGENDCO, NdisMCoActivateVcComplete)
#pragma alloc_text(PAGENDCO, NdisCmDeactivateVc)
#pragma alloc_text(PAGENDCO, NdisMCoDeactivateVcComplete)
#pragma alloc_text(PAGENDCO, NdisMCmRequest)
#pragma alloc_text(PAGENDCO, NdisCoRequest)
#pragma alloc_text(PAGENDCO, NdisCoRequestComplete)
#pragma alloc_text(PAGENDCO, NdisMCoRequestComplete)
#pragma alloc_text(PAGENDCO, NdisMCoIndicateReceivePacket)
#pragma alloc_text(PAGENDCO, NdisMCoReceiveComplete)
#pragma alloc_text(PAGENDCO, NdisCoSendPackets)
#pragma alloc_text(PAGENDCO, NdisMCoSendComplete)
#pragma alloc_text(PAGENDCO, NdisMCoIndicateStatus)
#pragma alloc_text(PAGENDCO, NdisMCmCreateVc)
#pragma alloc_text(PAGENDCO, NdisMCmActivateVc)
#pragma alloc_text(PAGENDCO, NdisMCmDeactivateVc)
#pragma alloc_text(PAGENDCO, ndisReferenceAf)
#pragma alloc_text(PAGENDCO, ndisDereferenceAf)
#pragma alloc_text(PAGENDCO, ndisReferenceSap)
#pragma alloc_text(PAGENDCO, ndisDereferenceSap)
#pragma alloc_text(PAGENDCO, ndisReferenceVcPtr)
#pragma alloc_text(PAGENDCO, ndisDereferenceVcPtr)
#pragma alloc_text(PAGENDCO, ndisMRejectSend)
#pragma alloc_text(PAGENDCO, ndisMRejectSendPackets)
#pragma alloc_text(PAGENDCO, NdisCoAssignInstanceName)
#pragma alloc_text(PAGENDCO, ndisUnicodeStringToPointer)
#pragma alloc_text(PAGENDCO, NdisClGetProtocolVcContextFromTapiCallId)
#pragma alloc_text(PAGENDCO, NdisCoGetTapiCallId)
#pragma alloc_text(PAGENDCO, ndisMCoFreeResources)


//
// These are normally paged out and only get locked down when a protocol loads
//
#pragma alloc_text(PAGENDSP, NdisSend)
#pragma alloc_text(PAGENDSP, ndisMSend)
#pragma alloc_text(PAGENDSP, NdisSendPackets)
#pragma alloc_text(PAGENDSP, ndisMSendPackets)
#pragma alloc_text(PAGENDSP, ndisMSendPacketsX)
#pragma alloc_text(PAGENDSP, ndisMIsLoopbackPacket)
#pragma alloc_text(PAGENDSP, ndisMLoopbackPacketX)
#pragma alloc_text(PAGENDSP, ndisMWanSend)
#pragma alloc_text(PAGENDSP, ndisMStartSendPackets)
#pragma alloc_text(PAGENDSP, ndisMStartSends)
#pragma alloc_text(PAGENDSP, NdisMSendComplete)
#pragma alloc_text(PAGENDSP, ndisMSendCompleteX)
#pragma alloc_text(PAGENDSP, NdisMWanSendComplete)
#pragma alloc_text(PAGENDSP, NdisRequest)
#pragma alloc_text(PAGENDSP, NdisReset)
#pragma alloc_text(PAGENDSP, ndisMRequest)
#pragma alloc_text(PAGENDSP, ndisMRequestX)
#pragma alloc_text(PAGENDSP, NdisTransferData)
#pragma alloc_text(PAGENDSP, NdisSetProtocolFilter)
#pragma alloc_text(PAGENDSP, NdisGetDriverHandle)
#pragma alloc_text(PAGENDSP, NdisReEnumerateProtocolBindings)
#pragma alloc_text(PAGENDSP, ndisDereferenceProtocol)
#pragma alloc_text(PAGENDSP, NdisOpenProtocolConfiguration)
#pragma alloc_text(PAGENDSP, NdisWriteEventLogEntry)
#pragma alloc_text(PAGENDSP, NdisQueryAdapterInstanceName)
#pragma alloc_text(PAGENDSP, NdisQueryBindInstanceName)
#pragma alloc_text(PAGENDSP, NdisSetPacketPoolProtocolId)
#pragma alloc_text(PAGENDSP, NdisCompletePnPEvent)
#pragma alloc_text(PAGENDSP, NdisReturnPackets)
#pragma alloc_text(PAGENDSP, NdisGetReceivedPacket)
#pragma alloc_text(PAGENDSP, ndisMDeferredReturnPackets)
#pragma alloc_text(PAGENDSP, NdisMTransferDataComplete)
#pragma alloc_text(PAGENDSP, ndisMTransferData)
#pragma alloc_text(PAGENDSP, ndisMReset)
#pragma alloc_text(PAGENDSP, ndisMFakeWanSend)
#pragma alloc_text(PAGENDSP, ndisMFakeSend)
#pragma alloc_text(PAGENDSP, ndisMFakeSendPackets)
#pragma alloc_text(PAGENDSP, ndisMFakeReset)
#pragma alloc_text(PAGENDSP, ndisMFakeRequest)
#pragma alloc_text(PAGENDSP, ndisMSendPacketsSG)
#pragma alloc_text(PAGENDSP, ndisMStartSendPacketsSG)
#pragma alloc_text(PAGENDSP, ndisMStartSendsSG)
#pragma alloc_text(PAGENDSP, ndisMSendSG)
#pragma alloc_text(PAGENDSP, ndisMSendCompleteSG)

//
// These are normally paged out and only get locked down when a ethernet filter is created
//
#pragma alloc_text(PAGENDSE, EthDeleteFilterOpenAdapter)
#pragma alloc_text(PAGENDSE, ethCompleteChangeFilterAddresses)
#pragma alloc_text(PAGENDSE, EthChangeFilterAddresses)
#pragma alloc_text(PAGENDSE, EthNumberOfOpenFilterAddresses)
#pragma alloc_text(PAGENDSE, EthQueryOpenFilterAddresses)
#pragma alloc_text(PAGENDSE, EthQueryGlobalFilterAddresses)
#pragma alloc_text(PAGENDSE, EthFilterDprIndicateReceiveComplete)
#pragma alloc_text(PAGENDSE, EthFilterDprIndicateReceive)
#pragma alloc_text(PAGENDSE, ethFilterDprIndicateReceivePacket)
#pragma alloc_text(PAGENDSE, ethFindMulticast)
#pragma alloc_text(PAGENDSE, EthShouldAddressLoopBack)

//
// These are normally paged out and only get locked down when a token-ring filter is created
//
#pragma alloc_text(PAGENDST, TrDeleteFilterOpenAdapter)
#pragma alloc_text(PAGENDST, trUndoChangeFunctionalAddress)
#pragma alloc_text(PAGENDST, TrChangeFunctionalAddress)
#pragma alloc_text(PAGENDST, trUndoChangeGroupAddress)
#pragma alloc_text(PAGENDST, trCompleteChangeGroupAddress)
#pragma alloc_text(PAGENDST, TrChangeGroupAddress)
#pragma alloc_text(PAGENDST, TrFilterDprIndicateReceive)
#pragma alloc_text(PAGENDST, trFilterDprIndicateReceivePacket)
#pragma alloc_text(PAGENDST, TrFilterDprIndicateReceiveComplete)
#pragma alloc_text(PAGENDST, TrShouldAddressLoopBack)
#pragma alloc_text(PAGENDST, ndisMSetFunctionalAddress)
#pragma alloc_text(PAGENDST, ndisMSetGroupAddress)

//
// These are normally paged out and only get locked down when a fddi filter is created
//
#pragma alloc_text(PAGENDSF, FddiDeleteFilterOpenAdapter)
#pragma alloc_text(PAGENDSF, fddiCompleteChangeFilterLongAddresses)
#pragma alloc_text(PAGENDSF, FddiChangeFilterLongAddresses)
#pragma alloc_text(PAGENDSF, fddiCompleteChangeFilterShortAddresses)
#pragma alloc_text(PAGENDSF, FddiChangeFilterShortAddresses)
#pragma alloc_text(PAGENDSF, FddiNumberOfOpenFilterLongAddresses)
#pragma alloc_text(PAGENDSF, FddiNumberOfOpenFilterShortAddresses)
#pragma alloc_text(PAGENDSF, FddiQueryOpenFilterLongAddresses)
#pragma alloc_text(PAGENDSF, FddiQueryOpenFilterShortAddresses)
#pragma alloc_text(PAGENDSF, FddiQueryGlobalFilterLongAddresses)
#pragma alloc_text(PAGENDSF, FddiQueryGlobalFilterShortAddresses)
#pragma alloc_text(PAGENDSF, FddiFilterDprIndicateReceive)
#pragma alloc_text(PAGENDSF, fddiFilterDprIndicateReceivePacket)
#pragma alloc_text(PAGENDSF, FddiFilterDprIndicateReceiveComplete)
#pragma alloc_text(PAGENDSF, fddiFindMulticastLongAddress)
#pragma alloc_text(PAGENDSF, fddiFindMulticastShortAddress)
#pragma alloc_text(PAGENDSF, FddiShouldAddressLoopBack)
#pragma alloc_text(PAGENDSF, ndisMSetFddiMulticastList)
#pragma alloc_text(PAGENDSF, ndisMQueryLongMulticastList)
#pragma alloc_text(PAGENDSF, ndisMQueryShortMulticastList)

#if ARCNET

//
// These are normally paged out and only get locked down when arcnet filter is created
//
#pragma alloc_text(PAGENDSA, ArcAllocateBuffers)
#pragma alloc_text(PAGENDSA, ArcAllocatePackets)
#pragma alloc_text(PAGENDSA, ArcDiscardPacketBuffers)
#pragma alloc_text(PAGENDSA, ArcDestroyPacket)
#pragma alloc_text(PAGENDSA, ArcConvertToNdisPacket)
#pragma alloc_text(PAGENDSA, ArcFilterDprIndicateReceive)
#pragma alloc_text(PAGENDSA, ArcNoteFilterOpenAdapter)
#pragma alloc_text(PAGENDSA, ArcDeleteFilterOpenAdapter)
#pragma alloc_text(PAGENDSA, ArcFilterAdjust)
#pragma alloc_text(PAGENDSA, ArcFilterDoIndication)
#pragma alloc_text(PAGENDSA, ArcFilterDprIndicateReceiveComplete)
#pragma alloc_text(PAGENDSA, ArcConvertOidListToEthernet)
#pragma alloc_text(PAGENDSA, ndisMArcCopyFromBufferToPacket)
#pragma alloc_text(PAGENDSA, ndisMArcTransferData)
#pragma alloc_text(PAGENDSA, ndisMArcIndicateEthEncapsulatedReceive)
#pragma alloc_text(PAGENDSA, ndisMBuildArcnetHeader)
#pragma alloc_text(PAGENDSA, ndisMFreeArcnetHeader)
#pragma alloc_text(PAGENDSA, ndisMArcnetSendLoopback)
#pragma alloc_text(PAGENDSA, arcUndoFilterAdjust)

#endif

#if 0
//
// These routines belong in the .text object. List here for reference only
//
#pragma alloc_text(text, NDIS_BUFFER_TO_SPAN_PAGES)
#pragma alloc_text(text, NdisQueryBuffer)
#pragma alloc_text(text, NdisQueryBufferSafe)
#pragma alloc_text(text, NdisQueryBufferOffset)
#pragma alloc_text(text, NdisCopyBuffer)
#pragma alloc_text(text, NdisAllocateBuffer)
#pragma alloc_text(text, NdisAdjustBufferLength)
#pragma alloc_text(text, NdisUnchainBufferAtFront)
#pragma alloc_text(text, NdisUnchainBufferAtBack)
#pragma alloc_text(text, NdisCopyFromPacketToPacket)
#pragma alloc_text(text, NdisCopyFromPacketToPacketSafe)
#pragma alloc_text(text, NdisAllocateMemory)
#pragma alloc_text(text, NdisAllocateMemoryWithTag)
#pragma alloc_text(text, NdisAllocatePacketPool)
#pragma alloc_text(text, NdisAllocatePacketPoolEx)
#pragma alloc_text(text, NdisFreeMemory)
#pragma alloc_text(text, ndisAllocationExecutionRoutine)
#pragma alloc_text(text, NdisAllocateBufferPool)
#pragma alloc_text(text, NdisSystemProcessorCount)
#pragma alloc_text(text, NdisSetTimer)
#pragma alloc_text(text, NdisInitializeTimer)
#pragma alloc_text(text, NdisReadPciSlotInformation)
#pragma alloc_text(text, NdisWritePciSlotInformation)
#pragma alloc_text(text, NdisReadPcmciaAttributeMemory)
#pragma alloc_text(text, NdisWritePcmciaAttributeMemory)
#pragma alloc_text(text, ndisReferencePackage)
#pragma alloc_text(text, ndisDereferencePackage)
#pragma alloc_text(text, NdisAllocatePacket)
#pragma alloc_text(text, NdisFreePacketPool)
#pragma alloc_text(text, ndisFreePacketPool)
#pragma alloc_text(text, ndisVerifierFreePacketPool)
#pragma alloc_text(text, NdisFreePacket)
#pragma alloc_text(text, NdisPacketPoolUsage)
#pragma alloc_text(text, NdisUpdateSharedMemory)
#pragma alloc_text(text, NdisGetSystemUpTime)
#pragma alloc_text(text, NdisGetCurrentProcessorCpuUsage)
#pragma alloc_text(text, NdisGetCurrentProcessorCounts)
#pragma alloc_text(text, NdisGetCurrentSystemTime)
#pragma alloc_text(text, NdisInitializeEvent)
#pragma alloc_text(text, NdisSetEvent)
#pragma alloc_text(text, NdisResetEvent)
#pragma alloc_text(text, NdisWaitEvent)
#pragma alloc_text(text, NdisScheduleWorkItem)
#pragma alloc_text(text, NdisInitializeString)
#pragma alloc_text(text, NdisFreeDmaChannel)
#pragma alloc_text(text, NdisSetupDmaTransfer)
#pragma alloc_text(text, NdisCompleteDmaTransfer)
#pragma alloc_text(text, NdisMAllocateSharedMemoryAsync)
#pragma alloc_text(text, ndisBugcheckHandler)
#pragma alloc_text(text, NdisCancelTimer)
#pragma alloc_text(text, ndisCompletionRoutine)
#pragma alloc_text(text, ndisMSendX)
#pragma alloc_text(text, NdisAllocateSpinLock)
#pragma alloc_text(text, NdisFreeSpinLock)
#pragma alloc_text(text, NdisFreeSpinLock)
#pragma alloc_text(text, NdisAcquireSpinLock)
#pragma alloc_text(text, NdisReleaseSpinLock)
#pragma alloc_text(text, NdisDprAcquireSpinLock)
#pragma alloc_text(text, NdisDprReleaseSpinLock)
#pragma alloc_text(text, NdisFreeBuffer)
#pragma alloc_text(text, NdisFreeBufferPool)
#pragma alloc_text(text, NdisGetFirstBufferFromPacket)
#pragma alloc_text(text, NdisBufferLength)
#pragma alloc_text(text, NdisBufferVirtualAddress)
#pragma alloc_text(text, NdisGetBufferPhysicalArraySize)
#pragma alloc_text(text, NdisAnsiStringToUnicodeString)
#pragma alloc_text(text, NdisUnicodeStringToAnsiString)
#pragma alloc_text(text, NdisCompareAnsiString)
#pragma alloc_text(text, NdisCompareUnicodeString)
#pragma alloc_text(text, NdisUpcaseUnicodeString)
#pragma alloc_text(text, ndisDmaExecutionRoutine)
#pragma alloc_text(text, NdisWriteErrorLogEntry)
#pragma alloc_text(text, ndisReferenceRef)
#pragma alloc_text(text, ndisDereferenceRef)
#pragma alloc_text(text, ndisCloseRef)
#pragma alloc_text(text, ndisCancelLogIrp)
#pragma alloc_text(text, ndisMIrpCompletion)
#pragma alloc_text(text, ndisPassIrpDownTheStack)
#pragma alloc_text(text, ndisWaitWakeComplete)
#pragma alloc_text(text, ndisQueryPowerComplete)
#pragma alloc_text(text, ndisSetSystemPowerComplete)
#pragma alloc_text(text, ndisSetDevicePowerOnComplete)
#pragma alloc_text(text, ndisSetDevicePowerDownComplete)
#pragma alloc_text(text, ndisWmiGetGuid)
#pragma alloc_text(text, ndisDereferenceDriver)
#pragma alloc_text(text, NdisGetSharedDataAlignment)
#endif  // if 0

#endif  // ALLOC_PRAGMA

#endif  // _PRAGMA_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ndis\sys\nfilter.c ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation

Module Name:

    nfilter.c

Abstract:

    This module implements a set of library routines to handle packet
    filtering for NDIS MAC drivers.

Author:

    Jameel Hyder (jameelh) July 1998

Environment:

    Kernel Mode - Or whatever is the equivalent on OS/2 and DOS.

Revision History:


--*/

#include <precomp.h>
#pragma hdrstop
#define MODULE_NUMBER   MODULE_NFILTER


BOOLEAN
nullCreateFilter(
    OUT PNULL_FILTER *          Filter
    )
/*++

Routine Description:

    This routine is used to create and initialize the filter database.

Arguments:

    Filter - A pointer to an NULL_FILTER.  This is what is allocated and
    created by this routine.

Return Value:

    If the function returns false then one of the parameters exceeded
    what the filter was willing to support.

--*/
{
    PNULL_FILTER LocalFilter;
    BOOLEAN     rc = FALSE;

    do
    {
        *Filter = LocalFilter = ALLOC_FROM_POOL(sizeof(NULL_FILTER), NDIS_TAG_FILTER);
        if (LocalFilter != NULL)
        {
            ZeroMemory(LocalFilter, sizeof(NULL_FILTER));
            EthReferencePackage();
            INITIALIZE_SPIN_LOCK(&LocalFilter->BindListLock.SpinLock);
            rc = TRUE;
        }
    } while (FALSE);

    return(rc);
}


//
// NOTE: THIS FUNCTION CANNOT BE PAGEABLE
//
VOID
nullDeleteFilter(
    IN  PNULL_FILTER                Filter
    )
/*++

Routine Description:

    This routine is used to delete the memory associated with a filter
    database.  Note that this routines *ASSUMES* that the database
    has been cleared of any active filters.

Arguments:

    Filter - A pointer to an NULL_FILTER to be deleted.

Return Value:

    None.

--*/
{
    ASSERT(Filter->OpenList == NULL);

    FREE_POOL(Filter);
}


NDIS_STATUS
nullDeleteFilterOpenAdapter(
    IN  PNULL_FILTER            Filter,
    IN  NDIS_HANDLE             NdisFilterHandle
    )
/*++

Routine Description:

    When an adapter is being closed this routine should
    be called to delete knowledge of the adapter from
    the filter database.  This routine is likely to call
    action routines associated with clearing filter classes
    and addresses.

    NOTE: THIS ROUTINE SHOULD ****NOT**** BE CALLED IF THE ACTION
    ROUTINES FOR DELETING THE FILTER CLASSES OR THE MULTICAST ADDRESSES
    HAVE ANY POSSIBILITY OF RETURNING A STATUS OTHER THAN NDIS_STATUS_PENDING
    OR NDIS_STATUS_SUCCESS.  WHILE THESE ROUTINES WILL NOT BUGCHECK IF
    SUCH A THING IS DONE, THE CALLER WILL PROBABLY FIND IT DIFFICULT
    TO CODE A CLOSE ROUTINE!

    NOTE: THIS ROUTINE ASSUMES THAT IT IS CALLED WITH THE LOCK HELD.

Arguments:

    Filter - A pointer to the filter database.

    NdisFilterHandle - Pointer to the open.

Return Value:

    If action routines are called by the various address and filtering
    routines the this routine will likely return the status returned
    by those routines.  The exception to this rule is noted below.

    Given that the filter and address deletion routines return a status
    NDIS_STATUS_PENDING or NDIS_STATUS_SUCCESS this routine will then
    try to return the filter index to the freelist.  If the routine
    detects that this binding is currently being indicated to via
    NdisIndicateReceive, this routine will return a status of
    NDIS_STATUS_CLOSING_INDICATING.

--*/
{
    NDIS_STATUS         StatusToReturn = NDIS_STATUS_SUCCESS;
    PNULL_BINDING_INFO  LocalOpen = (PNULL_BINDING_INFO)NdisFilterHandle;

    //
    // Remove the reference from the original open.
    //
    if (--(LocalOpen->References) == 0)
    {
        XRemoveAndFreeBinding(Filter, LocalOpen);
    }
    else
    {
        //
        // Let the caller know that there is a reference to the open
        // by the receive indication. The close action routine will be
        // called upon return from NdisIndicateReceive.
        //
        StatusToReturn = NDIS_STATUS_CLOSING_INDICATING;
    }

    return(StatusToReturn);
}


VOID
ndisMDummyIndicatePacket(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  PPNDIS_PACKET                   PacketArray,
    IN  UINT                            NumberOfPackets
    )
{
    PPNDIS_PACKET           pPktArray = PacketArray;
    PNDIS_STACK_RESERVED    NSR;
    PNDIS_PACKET            Packet;
    PNDIS_PACKET_OOB_DATA   pOob;
    UINT                    i;


    //
    // if we set the dummy handler because we are in process of halting an IM miniport
    // or media is disconnected, do not complain
    //
    if (!(MINIPORT_TEST_FLAG(Miniport, fMINIPORT_INTERMEDIATE_DRIVER) &&
          MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_HALTING)))

    {
        if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_MEDIA_CONNECTED))
        {
            NDIS_WARN(TRUE, Miniport, NDIS_GFLAG_WARN_LEVEL_0,
                ("Miniport %p, Driver is indicating packets before setting any filter\n", Miniport));
        }
        else
        {
            NDIS_WARN(TRUE, Miniport, NDIS_GFLAG_WARN_LEVEL_1,
                ("Miniport %p, Driver is indicating packets in Media disconnect state\n", Miniport));
        }
    }
    
    ASSERT_MINIPORT_LOCKED(Miniport);

    //
    // Walk all the packets and 'complete' them
    //
    for (i = 0; i < NumberOfPackets; i++, pPktArray++)
    {
        Packet = *pPktArray;
        ASSERT(Packet != NULL);

        pOob = NDIS_OOB_DATA_FROM_PACKET(Packet);
        PUSH_PACKET_STACK(Packet);
        NDIS_STACK_RESERVED_FROM_PACKET(Packet, &NSR)

        DIRECTED_PACKETS_IN(Miniport);
        DIRECTED_BYTES_IN(Miniport, PacketSize);

        //
        // Set the status here that nobody is holding the packet.
        //
        if (pOob->Status != NDIS_STATUS_RESOURCES)
        {
            if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_DESERIALIZE))
            {
                W_RETURN_PACKET_HANDLER Handler;

                Handler = Miniport->DriverHandle->MiniportCharacteristics.ReturnPacketHandler;
                pOob->Status = NDIS_STATUS_PENDING;
                NSR->Miniport = NULL;
                POP_PACKET_STACK(Packet);

                (*Handler)(Miniport->MiniportAdapterContext, Packet);

            }
            else
            {
                POP_PACKET_STACK(Packet);
                pOob->Status = NDIS_STATUS_SUCCESS;
            }
        }
        else
        {
            POP_PACKET_STACK(Packet);
        }
    }
}

VOID
ndisMIndicatePacket(
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  PPNDIS_PACKET           PacketArray,
    IN  UINT                    NumberOfPackets
    )
/*++

Routine Description:

    This routine is called by the Miniport to indicate packets to
    all bindings. This is the code path for ndis 4.0 miniport drivers.

Arguments:

    Miniport - The Miniport block.

    PacketArray - An array of Packets indicated by the miniport.

    NumberOfPackets - Self-explanatory.

Return Value:

    None.

--*/
{
    PNULL_FILTER            Filter = Miniport->NullDB;
    PPNDIS_PACKET           pPktArray = PacketArray;
    PNDIS_PACKET            Packet;
    PNDIS_STACK_RESERVED    NSR;
    PNDIS_PACKET_OOB_DATA   pOob;
    PNDIS_BUFFER            Buffer;
    PUCHAR                  Address;
    UINT                    i, LASize,PacketSize, NumIndicates = 0;
    BOOLEAN                 fFallBack;
    PNULL_BINDING_INFO      Open, NextOpen;
    LOCK_STATE              LockState;

#ifdef TRACK_RECEIVED_PACKETS
    ULONG                   OrgPacketStackLocation;
    PETHREAD                CurThread = PsGetCurrentThread();
#endif

    ASSERT_MINIPORT_LOCKED(Miniport);

    READ_LOCK_FILTER(Miniport, Filter, &LockState);

    //
    // Walk all the packets
    //
    for (i = 0; i < NumberOfPackets; i++, pPktArray++)
    {
        Packet = *pPktArray;
        ASSERT(Packet != NULL);

#ifdef TRACK_RECEIVED_PACKETS
       OrgPacketStackLocation = CURR_STACK_LOCATION(Packet);
#endif

        PUSH_PACKET_STACK(Packet);
        NDIS_STACK_RESERVED_FROM_PACKET(Packet, &NSR)

        ASSERT(NSR->RefCount == 0);
        if (NSR->RefCount != 0)
        {
            BAD_MINIPORT(Miniport, "Indicating packet not owned by it");
            KeBugCheckEx(BUGCODE_ID_DRIVER,
                         (ULONG_PTR)Miniport,
                         (ULONG_PTR)Packet,
                         (ULONG_PTR)PacketArray,
                         NumberOfPackets);
        }
    
        pOob = NDIS_OOB_DATA_FROM_PACKET(Packet);
    
        NdisGetFirstBufferFromPacket(Packet,
                                     &Buffer,
                                     &Address,
                                     &LASize,
                                     &PacketSize);
        ASSERT(Buffer != NULL);
    
        DIRECTED_PACKETS_IN(Miniport);
        DIRECTED_BYTES_IN(Miniport, PacketSize);

        //
        // Set the status here that nobody is holding the packet. This will get
        // overwritten by the real status from the protocol. Pay heed to what
        // the miniport is saying.
        //
        NDIS_INITIALIZE_RCVD_PACKET(Packet, NSR, Miniport);
    
        //
        // Set the status here that nobody is holding the packet. This will get
        // overwritten by the real status from the protocol. Pay heed to what
        // the miniport is saying.
        //
        if ((pOob->Status != NDIS_STATUS_RESOURCES) &&
            !MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_SYSTEM_SLEEPING))
        {
            pOob->Status = NDIS_STATUS_SUCCESS;
            fFallBack = FALSE;
        }
        else
        {
#if DBG
            if ((pOob->Status != NDIS_STATUS_RESOURCES) &&
                MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_SYSTEM_SLEEPING))
            {
                DBGPRINT(DBG_COMP_FILTER, DBG_LEVEL_ERR,
                        ("Miniport going into D3, not indicating chained receives\n"));
            }
#endif
            fFallBack = TRUE;
        }
    
        for (Open = Filter->OpenList;
             Open != NULL;
             Open = NextOpen)
        {
            //
            //  Get the next open to look at.
            //
            NextOpen = Open->NextOpen;
            Open->ReceivedAPacket = TRUE;
            NumIndicates ++;
    
            IndicateToProtocol(Miniport,
                               Filter,
                               (PNDIS_OPEN_BLOCK)(Open->NdisBindingHandle),
                               Packet,
                               NSR,
                               Address,
                               PacketSize,
                               pOob->HeaderSize,
                               &fFallBack,
                               FALSE,
                               NdisMediumMax);  // A dummy medium since it is unknown
        }

        //
        // Tackle refcounts now
        //
        TACKLE_REF_COUNT(Miniport, Packet, NSR, pOob);
    }

    if (NumIndicates > 0)
    {
        for (Open = Filter->OpenList;
             Open != NULL;
             Open = NextOpen)
        {
            NextOpen = Open->NextOpen;
    
            if (Open->ReceivedAPacket)
            {
                //
                // Indicate the binding.
                //
                Open->ReceivedAPacket = FALSE;
                FilterIndicateReceiveComplete(Open->NdisBindingHandle);
            }
        }
    }

    READ_UNLOCK_FILTER(Miniport, Filter, &LockState);
}


VOID
FASTCALL
DummyFilterLockHandler(
    IN  PNULL_FILTER            Filter,
    IN OUT  PLOCK_STATE         pLockState
    )
{
    return;
}


VOID
FASTCALL
XFilterLockHandler(
    IN  PETH_FILTER             Filter,
    IN OUT  PLOCK_STATE         pLockState
    )
{
    xLockHandler(&Filter->BindListLock, pLockState);
}

VOID
XRemoveAndFreeBinding(
    IN  PX_FILTER               Filter,
    IN  PX_BINDING_INFO         Binding
    )
/*++

Routine Description:

    This routine will remove a binding from the filter database and
    indicate a receive complete if necessary.  This was made a function
    to remove code redundancey in following routines.  Its not time
    critical so it's cool.

Arguments:

    Filter  -   Pointer to the filter database to remove the binding from.
    Binding -   Pointer to the binding to remove.
--*/
{
    XRemoveBindingFromLists(Filter, Binding);

    switch (Filter->Miniport->MediaType)
    {
      case NdisMedium802_3:
        ASSERT(Binding->MCastAddressBuf == NULL);
        if (Binding->OldMCastAddressBuf)
        {
            FREE_POOL(Binding->OldMCastAddressBuf);
        }
        break;

      case NdisMediumFddi:
        ASSERT(Binding->MCastLongAddressBuf == NULL);
        ASSERT(Binding->MCastShortAddressBuf == NULL);
    
        if (Binding->OldMCastLongAddressBuf)
        {
            FREE_POOL(Binding->OldMCastLongAddressBuf);
        }
    
        if (Binding->OldMCastShortAddressBuf)
        {
            FREE_POOL(Binding->OldMCastShortAddressBuf);
        }
    }

    if (Filter->MCastSet == Binding)
    {
        Filter->MCastSet = NULL;
    }

    FREE_POOL(Binding);
}


VOID
XRemoveBindingFromLists(
    IN  PX_FILTER               Filter,
    IN  PX_BINDING_INFO         Binding
    )
/*++

    This routine will remove a binding from all of the list in a filter database.

Arguments:

    Filter  -   Pointer to the filter database to remove the binding from.
    Binding -   Pointer to the binding to remove.

--*/
{
    PX_BINDING_INFO *   ppBI;
    LOCK_STATE          LockState;

    WRITE_LOCK_FILTER(Filter->Miniport, Filter, &LockState);
    
    if (Filter->SingleActiveOpen == Binding)
    {
        Filter->SingleActiveOpen = NULL;
        ndisUpdateCheckForLoopbackFlag(Filter->Miniport);
    }

    //
    //  Remove the binding from the filters list
    //
    for (ppBI = &Filter->OpenList;
         *ppBI != NULL;
         ppBI = &(*ppBI)->NextOpen)
    {
        if (*ppBI == Binding)
        {
            *ppBI = Binding->NextOpen;
            break;
        }
    }
    ASSERT(*ppBI == Binding->NextOpen);

    Binding->NextOpen = NULL;
    Filter->NumOpens --;

    WRITE_UNLOCK_FILTER(Filter->Miniport, Filter, &LockState);
}

NDIS_STATUS
XFilterAdjust(
    IN  PX_FILTER               Filter,
    IN  NDIS_HANDLE             NdisFilterHandle,
    IN  UINT                    FilterClasses,
    IN  BOOLEAN                 Set
    )
/*++

Routine Description:

    NOTE: THIS ROUTINE ASSUMES THAT THE LOCK IS HELD.

Arguments:

    Filter - A pointer to the filter database.

    NdisFilterHandle - A pointer to the open.

    FilterClasses - The filter classes that are to be added or
    deleted.

    Set - A boolean that determines whether the filter classes
    are being adjusted due to a set or because of a close. (The filtering
    routines don't care, the MAC might.)

Return Value:

    NDIS_STATUS_SUCCESS - If the new packet filters doesn't change
    the combined mask of all bindings packet filters.

--*/
{
    PX_BINDING_INFO LocalOpen = (PETH_BINDING_INFO)NdisFilterHandle;
    PX_BINDING_INFO OpenList;

    //
    // Set the new filter information for the open.
    //
    LocalOpen->OldPacketFilters = LocalOpen->PacketFilters;
    LocalOpen->PacketFilters = FilterClasses;
    Filter->OldCombinedPacketFilter = Filter->CombinedPacketFilter;

    //
    // We always have to reform the combined filter since
    // this filter index may have been the only filter index
    // to use a particular bit.
    //
    for (OpenList = Filter->OpenList, Filter->CombinedPacketFilter = 0;
         OpenList != NULL;
         OpenList = OpenList->NextOpen)
    {
        Filter->CombinedPacketFilter |= OpenList->PacketFilters;
    }

    return (((Filter->OldCombinedPacketFilter & ~NDIS_PACKET_TYPE_ALL_LOCAL) !=
                    (Filter->CombinedPacketFilter & ~NDIS_PACKET_TYPE_ALL_LOCAL)) ?
                                    NDIS_STATUS_PENDING : NDIS_STATUS_SUCCESS);
}


VOID
XUndoFilterAdjust(
    IN  PX_FILTER               Filter,
    IN  PX_BINDING_INFO         Binding
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    Binding->PacketFilters = Binding->OldPacketFilters;
    Filter->CombinedPacketFilter = Filter->OldCombinedPacketFilter;
}

BOOLEAN
XNoteFilterOpenAdapter(
    IN  PX_FILTER               Filter,
    IN  NDIS_HANDLE             NdisBindingHandle,
    OUT PNDIS_HANDLE            NdisFilterHandle
    )
/*++

Routine Description:

    This routine is used to add a new binding to the filter database.

    NOTE: THIS ROUTINE ASSUMES THAT THE DATABASE IS LOCKED WHEN
    IT IS CALLED.

Arguments:

    Filter - A pointer to the previously created and initialized filter
    database.

    NdisBindingHandle - a pointer to Ndis Open block

    NdisFilterHandle - A pointer to Filter open.

Return Value:

    Will return false if creating a new filter index will cause the maximum
    number of filter indexes to be exceeded.

--*/
{
    PX_BINDING_INFO     LocalOpen;
    BOOLEAN             rc = FALSE;
    LOCK_STATE          LockState;

    *NdisFilterHandle = LocalOpen = ALLOC_FROM_POOL(sizeof(X_BINDING_INFO), NDIS_TAG_FILTER);
    if (LocalOpen != NULL)
    {
        ZeroMemory(LocalOpen, sizeof(X_BINDING_INFO));
    
        LocalOpen->References = 1;
        LocalOpen->NdisBindingHandle = NdisBindingHandle;

        WRITE_LOCK_FILTER(Filter->Miniport, Filter, &LockState);

        LocalOpen->NextOpen = Filter->OpenList;
        Filter->OpenList = LocalOpen;
        Filter->NumOpens ++;
    
        WRITE_UNLOCK_FILTER(Filter->Miniport, Filter, &LockState);
        rc = TRUE;
    }

    return rc;
}


VOID
ndisMDummyIndicateReceive(
    IN  PETH_FILTER             Filter,
    IN  NDIS_HANDLE             MacReceiveContext,
    IN  PCHAR                   Address,
    IN  PVOID                   HeaderBuffer,
    IN  UINT                    HeaderBufferSize,
    IN  PVOID                   LookaheadBuffer,
    IN  UINT                    LookaheadBufferSize,
    IN  UINT                    PacketSize
    )
{
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ndis\sys\precomp.h ===
#include "wrapper.h"

#include <windef.h> // needed for ks.h
#include <ks.h>
#include <ndisprv.h>
#include <ndisguid.h>
#include <tdikrnl.h>
#include <wmistr.h>
#include <wdmguid.h>

#include "ndisnt.h"
#include "mini.h"
#include "protos.h"
#include "cprotos.h"
#include "sendm.h"
#include "requestm.h"
#include "nfilter.h"
#include "pragma.h"
#include "data.h"
#include "fsbpool.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ndis\sys\nfilter.h ===
/*++

Copyright (c) 1990  Microsoft Corporation

Module Name:

    nfilter.h

Abstract:

    Header file for the address filtering library for NDIS MAC's.

Author:

    Jameel Hyder (jameelh) July 1998

Environment:


Notes:

--*/

#ifndef _NULL_FILTER_DEFS_
#define _NULL_FILTER_DEFS_

typedef
VOID
(*NULL_DEFERRED_CLOSE)(
    IN  NDIS_HANDLE             BindingHandle
    );

//
// The binding info is threaded on a single list.
//
typedef X_BINDING_INFO  NULL_BINDING_INFO,*PNULL_BINDING_INFO;

typedef X_FILTER        NULL_FILTER,*PNULL_FILTER;

//
// Exported functions
//
EXPORT
BOOLEAN
nullCreateFilter(
    OUT PNULL_FILTER *          Filter
    );

EXPORT
VOID
nullDeleteFilter(
    IN  PNULL_FILTER            Filter
    );


EXPORT
NDIS_STATUS
nullDeleteFilterOpenAdapter(
    IN  PNULL_FILTER            Filter,
    IN  NDIS_HANDLE             NdisFilterHandle
    );

VOID
nullRemoveAndFreeBinding(
    IN  PNULL_FILTER            Filter,
    IN  PNULL_BINDING_INFO      Binding,
    IN  BOOLEAN                 fCallCloseAction
    );

VOID
FASTCALL
nullFilterLockHandler(
    IN  PNULL_FILTER                    Filter,
    IN OUT PLOCK_STATE                  pLockState
    );

VOID
FASTCALL
DummyFilterLockHandler(
    IN  PNULL_FILTER                    Filter,
    IN OUT PLOCK_STATE                  pLockState
    );

/*++
  
Routine Description:

    Multiple-reader-single-writer locking scheme for Filter DB

    Use refCounts to keep track of how many readers are doing reads.
    Use per-processor refCounts to reduce bus traffic.
    Writers are serialized by means of a spin lock. Then they wait for
    readers to finish reading by waiting till refCounts for all processors
    go to zero. Rely on snoopy caches to get the sum right without doing
    interlocked operations

--*/

#define TEST_SPIN_LOCK(_L)  ((_L) != 0)

#define NDIS_READ_LOCK(_L, _pLS)                                        \
{                                                                       \
    UINT    refcount;                                                   \
    ULONG   Prc;                                                        \
                                                                        \
    RAISE_IRQL_TO_DISPATCH(&(_pLS)->OldIrql);                           \
                                                                        \
    /* go ahead and bump up the ref count IF no writes are underway */  \
    Prc = CURRENT_PROCESSOR;                                            \
    refcount = InterlockedIncrement(&(_L)->RefCount[Prc].RefCount);     \
                                                                        \
    /* Test if spin lock is held, i.e., write is underway   */          \
    /* if (KeTestSpinLock(&(_L)->SpinLock) == TRUE)         */          \
    /* This processor already is holding the lock, just     */          \
    /* allow him to take it again or else we run into a     */          \
    /* dead-lock situation with the writer                  */          \
    if (TEST_SPIN_LOCK((_L)->SpinLock) &&                               \
        (refcount == 1) &&                                              \
        ((_L)->Context != CURRENT_THREAD))                              \
    {                                                                   \
        (_L)->RefCount[Prc].RefCount--;                                 \
        ACQUIRE_SPIN_LOCK_DPC(&(_L)->SpinLock);                         \
        (_L)->RefCount[Prc].RefCount++;                                 \
        RELEASE_SPIN_LOCK_DPC(&(_L)->SpinLock);                         \
    }                                                                   \
    (_pLS)->LockState = READ_LOCK_STATE_FREE;                           \
}

#define NDIS_WRITE_LOCK_STATE_UNKNOWN(_L, _pLS)                         \
{                                                                       \
    UINT    i, refcount;                                                \
    ULONG   Prc;                                                        \
                                                                        \
    /*                                                                  \
     * This means we need to attempt to acquire the lock,               \
     * if we do not already own it.                                     \
     * Set the state accordingly.                                       \
     */                                                                 \
    if ((_L)->Context == CURRENT_THREAD)                                \
    {                                                                   \
        (_pLS)->LockState = LOCK_STATE_ALREADY_ACQUIRED;                \
    }                                                                   \
    else                                                                \
    {                                                                   \
        ACQUIRE_SPIN_LOCK(&(_L)->SpinLock, &(_pLS)->OldIrql);           \
                                                                        \
        Prc = KeGetCurrentProcessorNumber();                            \
        refcount = (_L)->RefCount[Prc].RefCount;                        \
        (_L)->RefCount[Prc].RefCount = 0;                               \
                                                                        \
        /* wait for all readers to exit */                              \
        for (i=0; i < ndisNumberOfProcessors; i++)                      \
        {                                                               \
            volatile UINT   *_p = &(_L)->RefCount[i].RefCount;          \
                                                                        \
            while (*_p != 0)                                            \
                NDIS_INTERNAL_STALL(50);                                \
        }                                                               \
                                                                        \
        (_L)->RefCount[Prc].RefCount = refcount;                        \
        (_L)->Context = CURRENT_THREAD;                                 \
        (_pLS)->LockState = WRITE_LOCK_STATE_FREE;                      \
    }                                                                   \
}

#define NDIS_READ_LOCK_STATE_FREE(_L, _pLS)                             \
{                                                                       \
    ULONG   Prc;                                                        \
    ASSERT(CURRENT_IRQL == DISPATCH_LEVEL);                             \
    Prc = CURRENT_PROCESSOR;                                            \
    ASSERT((_L)->RefCount[Prc].RefCount > 0);                           \
    (_L)->RefCount[Prc].RefCount--;                                     \
    (_pLS)->LockState = LOCK_STATE_UNKNOWN;                             \
    if ((_pLS)->OldIrql < DISPATCH_LEVEL)                               \
    {                                                                   \
        KeLowerIrql((_pLS)->OldIrql);                                   \
    }                                                                   \
}

#define NDIS_WRITE_LOCK_STATE_FREE(_L, _pLS)                            \
{                                                                       \
    /* We acquired it. Now we need to free it */                        \
    ASSERT(CURRENT_IRQL == DISPATCH_LEVEL);                             \
    ASSERT((_L)->Context == CURRENT_THREAD);                            \
    (_pLS)->LockState = LOCK_STATE_UNKNOWN;                             \
    (_L)->Context = NULL;                                               \
    RELEASE_SPIN_LOCK(&(_L)->SpinLock, (_pLS)->OldIrql);                \
}

#define NDIS_LOCK_STATE_ALREADY_ACQUIRED(_L, _pLS)                      \
{                                                                       \
    ASSERT((_L)->Context == CURRENT_THREAD);                            \
    /* Nothing to do */                                                 \
}


#define xLockHandler(_L, _pLS)                                                  \
    {                                                                           \
        switch ((_pLS)->LockState)                                              \
        {                                                                       \
          case READ_LOCK:                                                       \
            NDIS_READ_LOCK(_L, _pLS);                                           \
            break;                                                              \
                                                                                \
          case WRITE_LOCK_STATE_UNKNOWN:                                        \
            NDIS_WRITE_LOCK_STATE_UNKNOWN(_L, _pLS);                            \
            break;                                                              \
                                                                                \
          case READ_LOCK_STATE_FREE:                                            \
            NDIS_READ_LOCK_STATE_FREE(_L, _pLS);                                \
            break;                                                              \
                                                                                \
          case WRITE_LOCK_STATE_FREE:                                           \
            NDIS_WRITE_LOCK_STATE_FREE(_L, _pLS);                               \
            break;                                                              \
                                                                                \
          case LOCK_STATE_ALREADY_ACQUIRED:                                     \
            NDIS_LOCK_STATE_ALREADY_ACQUIRED(_L, _pLS);                         \
            /* Nothing to do */                                                 \
            break;                                                              \
                                                                                \
          default:                                                              \
            ASSERT(0);                                                          \
            break;                                                              \
        }                                                                       \
    }

#define NDIS_INITIALIZE_RCVD_PACKET(_P, _NSR, _M)                               \
    {                                                                           \
        _NSR->RefCount = -1;                                                    \
        _NSR->XRefCount = 0;                                                    \
        _NSR->Miniport = _M;                                                    \
        /*                                                                      \
         * Ensure that we force re-calculation.                                 \
         */                                                                     \
        (_P)->Private.ValidCounts = FALSE;                                      \
    }

#define NDIS_ACQUIRE_PACKET_LOCK_DPC(_NSR)  ACQUIRE_SPIN_LOCK_DPC(&(_NSR)->Lock)

#define NDIS_RELEASE_PACKET_LOCK_DPC(_NSR)  RELEASE_SPIN_LOCK_DPC(&(_NSR)->Lock)

#define ADJUST_PACKET_REFCOUNT(_NSR, _pRC)                                      \
    {                                                                           \
        *(_pRC) = InterlockedDecrement(&(_NSR)->RefCount);                      \
    }

#ifdef TRACK_RECEIVED_PACKETS                                            

//
// NSR->XRefCount = Number of times protocol said it will call NdisReturnPacket
// NSR->RefCount = is decremented every time protocol calls NdisReturnPackets
//

#define COALESCE_PACKET_REFCOUNT_DPC(_Packet, _M, _NSR, _pOob, _pRC)            \
    {                                                                           \
        LONG    _LocalXRef = (_NSR)->XRefCount;                                 \
        if (_LocalXRef != 0)                                                    \
        {                                                                       \
            LONG    _LocalRef;                                                  \
            ASSERT((_pOob)->Status != NDIS_STATUS_RESOURCES);                   \
            _LocalRef = InterlockedExchangeAdd(&(_NSR)->RefCount, (_LocalXRef + 1));    \
            *(_pRC) = _LocalRef + _LocalXRef + 1;                               \
            if ((*(_pRC) > 0) && (!MINIPORT_TEST_FLAG((_M), fMINIPORT_DESERIALIZE))) \
            {                                                                   \
                NDIS_SET_PACKET_STATUS(_Packet, NDIS_STATUS_PENDING);           \
            }                                                                   \
            if ((*(_pRC) == 0) && ((_NSR)->RefCount != 0))                      \
            {                                                                   \
                DbgPrint("Packet %p is being returned back to the miniport"     \
                         " but the ref count is not zero.\n", _Packet);         \
                DbgBreakPoint();                                                \
            }                                                                   \
        }                                                                       \
        else                                                                    \
        {                                                                       \
            _NSR->RefCount = *(_pRC) = 0;                                       \
        }                                                                       \
    }

#define TACKLE_REF_COUNT(_M, _P, _S, _O)                                        \
    {                                                                           \
        LONG    RefCount;                                                       \
                                                                                \
        /*                                                                      \
         * We started off with the RefCount set to -1.                          \
         * NdisReturnPackets may have been called which will further reduce it. \
         * Add back the RefCount returned by the protocol                       \
         * and account for the initial -1.                                      \
         */                                                                     \
        COALESCE_PACKET_REFCOUNT_DPC(_P, _M, _S, _O, &RefCount);                \
                                                                                \
        NDIS_APPEND_RCV_LOGFILE(_P, _M, CurThread,                              \
                                7, OrgPacketStackLocation+1, _S->RefCount, _S->XRefCount, NDIS_GET_PACKET_STATUS(_P)); \
                                                                                \
                                                                                \
        if (RefCount == 0)                                                      \
        {                                                                       \
            POP_PACKET_STACK(_P);                                               \
            if ((_O)->Status != NDIS_STATUS_RESOURCES)                          \
            {                                                                   \
                if (MINIPORT_TEST_FLAG((_M), fMINIPORT_DESERIALIZE))            \
                {                                                               \
                    /*                                                          \
                     * Return packets which are truly free,                     \
                     * but only for deserialized drivers                        \
                     */                                                         \
                    W_RETURN_PACKET_HANDLER Handler;                            \
                    if (_S->RefCount != 0)                                      \
                    {                                                           \
                        DbgPrint("Packet %p is being returned back to the "     \
                                 "miniport but the ref count is not zero.\n", _P); \
                        DbgBreakPoint();                                        \
                    }                                                           \
                    if ((_P)->Private.Head == NULL)                             \
                    {                                                           \
                        DbgPrint("Packet %p is being returned back to the miniport with NULL Head.\n", _P); \
                        DbgBreakPoint();                                        \
                    }                                                           \
                                                                                \
                    if (!MINIPORT_TEST_FLAG(_M, fMINIPORT_INTERMEDIATE_DRIVER)) \
                    {                                                           \
                        ULONG    SL;                                            \
                        if ((SL = CURR_STACK_LOCATION(_P)) != -1)               \
                        {                                                       \
                            DbgPrint("Packet %p is being returned back to the non-IM miniport"\
                                     " with stack location %lx.\n", Packet, SL);  \
                            DbgBreakPoint();                                    \
                        }                                                       \
                    }                                                           \
                                                                                \
                    Handler = (_M)->DriverHandle->MiniportCharacteristics.ReturnPacketHandler;\
                    (_S)->Miniport = NULL;                                      \
                    (_O)->Status = NDIS_STATUS_PENDING;                         \
                                                                                \
                    NDIS_APPEND_RCV_LOGFILE(_P, _M, CurThread,                  \
                                            8, OrgPacketStackLocation+1, _S->RefCount, _S->XRefCount, NDIS_GET_PACKET_STATUS(_P)); \
                                                                                \
                                                                                \
                    (*Handler)((_M)->MiniportAdapterContext, _P);               \
                }                                                               \
                else                                                            \
                {                                                               \
                    {                                                           \
                        ULONG    SL;                                            \
                        if ((SL = CURR_STACK_LOCATION(_P)) != -1)               \
                        {                                                       \
                            DbgPrint("Packet %p is being returned back to the non-IM miniport"\
                                     " with stack location %lx.\n", Packet, SL);  \
                            DbgBreakPoint();                                    \
                        }                                                       \
                    }                                                           \
                                                                                \
                    if ((NDIS_GET_PACKET_STATUS(_P) == NDIS_STATUS_RESOURCES))  \
                    {                                                           \
                        NDIS_STATUS _OStatus = (NDIS_STATUS)NDIS_PER_PACKET_INFO_FROM_PACKET(_P, OriginalStatus); \
                                                                                \
                        if (_OStatus != NDIS_STATUS_RESOURCES)                  \
                        {                                                       \
                            DbgPrint("Packet %p is being returned back to the non-deserialized miniport"\
                                     " with packet status changed from %lx to NDIS_STATUS_RESOURCES.\n", _P, _OStatus); \
                            DbgBreakPoint();                                    \
                        }                                                       \
                                                                                \
                    }                                                           \
                                                                                \
                    (_O)->Status = NDIS_STATUS_SUCCESS;                         \
                    NDIS_APPEND_RCV_LOGFILE(_P, _M, CurThread,                  \
                                            9, OrgPacketStackLocation+1, _S->RefCount, _S->XRefCount, NDIS_GET_PACKET_STATUS(_P)); \
                                                                                \
                }                                                               \
            }                                                                   \
        }                                                                       \
        else if (MINIPORT_TEST_FLAG((_M), fMINIPORT_INTERMEDIATE_DRIVER))       \
        {                                                                       \
            InterlockedIncrement(&(_M)->IndicatedPacketsCount);                 \
        }                                                                       \
    }

#else
//
// NSR->XRefCount = Number of times protocol said it will call NdisReturnPacket
// NSR->RefCount = is decremented every time protocol calls NdisReturnPackets
//

#define COALESCE_PACKET_REFCOUNT_DPC(_Packet, _M, _NSR, _pOob, _pRC)            \
    {                                                                           \
        LONG    _LocalXRef = (_NSR)->XRefCount;                                 \
        if (_LocalXRef != 0)                                                    \
        {                                                                       \
            LONG    _LocalRef;                                                  \
            ASSERT((_pOob)->Status != NDIS_STATUS_RESOURCES);                   \
            _LocalRef = InterlockedExchangeAdd(&(_NSR)->RefCount, (_LocalXRef + 1));    \
            *(_pRC) = _LocalRef + _LocalXRef + 1;                               \
            if ((*(_pRC) > 0) && (!MINIPORT_TEST_FLAG((_M), fMINIPORT_DESERIALIZE))) \
            {                                                                   \
                NDIS_SET_PACKET_STATUS(_Packet, NDIS_STATUS_PENDING);           \
            }                                                                   \
        }                                                                       \
        else                                                                    \
        {                                                                       \
            _NSR->RefCount = *(_pRC) = 0;                                       \
        }                                                                       \
    }

#define TACKLE_REF_COUNT(_M, _P, _S, _O)                                        \
    {                                                                           \
        LONG    RefCount;                                                       \
                                                                                \
        /*                                                                      \
         * We started off with the RefCount set to -1.                          \
         * NdisReturnPackets may have been called which will further reduce it. \
         * Add back the RefCount returned by the protocol                       \
         * and account for the initial -1.                                      \
         */                                                                     \
        COALESCE_PACKET_REFCOUNT_DPC(_P, _M, _S, _O, &RefCount);                \
                                                                                \
        if (RefCount == 0)                                                      \
        {                                                                       \
            POP_PACKET_STACK(_P);                                               \
            if ((_O)->Status != NDIS_STATUS_RESOURCES)                          \
            {                                                                   \
                if (MINIPORT_TEST_FLAG((_M), fMINIPORT_DESERIALIZE))            \
                {                                                               \
                    /*                                                          \
                     * Return packets which are truly free,                     \
                     * but only for deserialized drivers                        \
                     */                                                         \
                    W_RETURN_PACKET_HANDLER Handler;                            \
                                                                                \
                    Handler = (_M)->DriverHandle->MiniportCharacteristics.ReturnPacketHandler;\
                    (_S)->Miniport = NULL;                                      \
                    (_O)->Status = NDIS_STATUS_PENDING;                         \
                                                                                \
                    (*Handler)((_M)->MiniportAdapterContext, _P);               \
                }                                                               \
                else                                                            \
                {                                                               \
                    (_O)->Status = NDIS_STATUS_SUCCESS;                         \
                }                                                               \
            }                                                                   \
        }                                                                       \
        else if (MINIPORT_TEST_FLAG((_M), fMINIPORT_INTERMEDIATE_DRIVER))       \
        {                                                                       \
            InterlockedIncrement(&(_M)->IndicatedPacketsCount);                 \
        }                                                                       \
    }


#endif
#endif // _NULL_FILTER_DEFS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ndis\sys\protocol.c ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation

Module Name:

    protocol.c

Abstract:

    NDIS wrapper functions used by protocol modules

Author:

    Adam Barr (adamba) 11-Jul-1990

Environment:

    Kernel mode, FSD

Revision History:

    26-Feb-1991  JohnsonA       Added Debugging Code
    10-Jul-1991  JohnsonA       Implement revised Ndis Specs
    01-Jun-1995  JameelH        Re-organization/optimization

--*/

#define GLOBALS
#include <precomp.h>
#pragma hdrstop

#include <stdarg.h>

//
//  Define the module number for debug code.
//
#define MODULE_NUMBER   MODULE_PROTOCOL

//
// Requests used by protocol modules
//
//

VOID
NdisRegisterProtocol(
    OUT PNDIS_STATUS            pStatus,
    OUT PNDIS_HANDLE            NdisProtocolHandle,
    IN  PNDIS_PROTOCOL_CHARACTERISTICS ProtocolCharacteristics,
    IN  UINT                    CharacteristicsLength
    )
/*++

Routine Description:

    Register an NDIS protocol.

Arguments:

    Status - Returns the final status.
    NdisProtocolHandle - Returns a handle referring to this protocol.
    ProtocolCharacteritics - The NDIS_PROTOCOL_CHARACTERISTICS table.
    CharacteristicsLength - The length of ProtocolCharacteristics.

Return Value:

    None.

Comments:

    Called at passive level

--*/
{
    PNDIS_PROTOCOL_BLOCK Protocol;
    NDIS_STATUS          Status;
    KIRQL                OldIrql;
    USHORT               size;

    DBGPRINT_RAW(DBG_COMP_PROTOCOL, DBG_LEVEL_INFO,
            ("==>NdisRegisterProtocol\n"));
    DBGPRINT_RAW(DBG_COMP_PROTOCOL, DBG_LEVEL_INFO,
            ("    Protocol: "));
    DBGPRINT_UNICODE(DBG_COMP_PROTOCOL, DBG_LEVEL_INFO,
            &ProtocolCharacteristics->Name);
    DBGPRINT_RAW(DBG_COMP_PROTOCOL, DBG_LEVEL_INFO,
            ("\n"));

    PnPReferencePackage();
    ProtocolReferencePackage();

    IF_DBG(DBG_COMP_PROTOCOL, DBG_LEVEL_ERR)
    {
        BOOLEAN f = FALSE;
        if (DbgIsNull(ProtocolCharacteristics->OpenAdapterCompleteHandler))
        {
            DBGPRINT(DBG_COMP_ALL, DBG_LEVEL_ERR,
                ("RegisterProtocol: OpenAdapterCompleteHandler Null\n"));
            f = TRUE;
        }
        if (DbgIsNull(ProtocolCharacteristics->CloseAdapterCompleteHandler))
        {
            DBGPRINT(DBG_COMP_ALL, DBG_LEVEL_ERR,
                ("RegisterProtocol: CloseAdapterCompleteHandler Null\n"));
            f = TRUE;
        }
        if (DbgIsNull(ProtocolCharacteristics->SendCompleteHandler))
        {
            DBGPRINT(DBG_COMP_ALL, DBG_LEVEL_ERR,
                ("RegisterProtocol: SendCompleteHandler Null\n"));
            f = TRUE;
        }
        if (DbgIsNull(ProtocolCharacteristics->TransferDataCompleteHandler))
        {
            DBGPRINT(DBG_COMP_ALL, DBG_LEVEL_ERR,
                ("RegisterProtocol: TransferDataCompleteHandler Null\n"));
            f = TRUE;
        }
        if (DbgIsNull(ProtocolCharacteristics->ResetCompleteHandler))
        {
            DBGPRINT(DBG_COMP_ALL, DBG_LEVEL_ERR,
                ("RegisterProtocol: ResetCompleteHandler Null\n"));
            f = TRUE;
        }
        if (DbgIsNull(ProtocolCharacteristics->RequestCompleteHandler))
        {
            DBGPRINT(DBG_COMP_ALL, DBG_LEVEL_ERR,
                ("RegisterProtocol: RequestCompleteHandler Null\n"));
            f = TRUE;
        }
        if (DbgIsNull(ProtocolCharacteristics->ReceiveHandler))
        {
            DBGPRINT(DBG_COMP_ALL, DBG_LEVEL_ERR,
                ("RegisterProtocol: ReceiveHandler Null\n"));
            f = TRUE;
        }
        if (DbgIsNull(ProtocolCharacteristics->ReceiveCompleteHandler))
        {
            DBGPRINT(DBG_COMP_ALL, DBG_LEVEL_ERR,
                ("RegisterProtocol: ReceiveCompleteHandler Null\n"));
            f = TRUE;
        }
        if (DbgIsNull(ProtocolCharacteristics->StatusHandler))
        {
            DBGPRINT(DBG_COMP_ALL, DBG_LEVEL_ERR,
                ("RegisterProtocol: StatusHandler Null\n"));
            f = TRUE;
        }
        if (DbgIsNull(ProtocolCharacteristics->StatusCompleteHandler))
        {
            DBGPRINT(DBG_COMP_ALL, DBG_LEVEL_ERR,
                ("RegisterProtocol: StatusCompleteHandler Null\n"));
            f = TRUE;
        }
        if (f)
            DBGBREAK(DBG_COMP_ALL, DBG_LEVEL_ERR);
    }

    do
    {
        //
        // Check version numbers and CharacteristicsLength.
        //
        size = 0;   // Used to indicate bad version below
        
        if (ProtocolCharacteristics->MajorNdisVersion < 4)
        {
            DbgPrint("Ndis: NdisRegisterProtocol Ndis 3.0 protocols are not supported.\n");             
        }
        else if ((ProtocolCharacteristics->MajorNdisVersion == 4) &&
                 (ProtocolCharacteristics->MinorNdisVersion == 0))
        {
            size = sizeof(NDIS40_PROTOCOL_CHARACTERISTICS);
        }
        else if ((ProtocolCharacteristics->MajorNdisVersion == 5) &&
                 (ProtocolCharacteristics->MinorNdisVersion <= 1))
        {
            size = sizeof(NDIS50_PROTOCOL_CHARACTERISTICS);
        }
        

        //
        // Check that this is an NDIS 4.0/5.0/5.1 protocol.
        //
        if (size == 0)
        {
            Status = NDIS_STATUS_BAD_VERSION;
            break;
        }
        
        if ((ProtocolCharacteristics->BindAdapterHandler == NULL) ||
            (ProtocolCharacteristics->UnbindAdapterHandler == NULL))
        {
            DbgPrint("Ndis: NdisRegisterProtocol protocol does not have Bind/UnbindAdapterHandler and it is not supported.\n");
            Status = NDIS_STATUS_BAD_VERSION;
            break;
             
        }

        //
        // Check that CharacteristicsLength is enough.
        //
        if (CharacteristicsLength < size)
        {
            Status = NDIS_STATUS_BAD_CHARACTERISTICS;
            break;
        }

        //
        // Allocate memory for the NDIS protocol block.
        //
        Protocol = (PNDIS_PROTOCOL_BLOCK)ALLOC_FROM_POOL(sizeof(NDIS_PROTOCOL_BLOCK) +
                                                          ProtocolCharacteristics->Name.Length + sizeof(WCHAR),
                                                          NDIS_TAG_PROT_BLK);
        if (Protocol == (PNDIS_PROTOCOL_BLOCK)NULL)
        {
            Status = NDIS_STATUS_RESOURCES;
            break;
        }
        ZeroMemory(Protocol, sizeof(NDIS_PROTOCOL_BLOCK) + sizeof(WCHAR) + ProtocolCharacteristics->Name.Length);
        INITIALIZE_MUTEX(&Protocol->Mutex);

        //
        // Copy over the characteristics table.
        //
        CopyMemory(&Protocol->ProtocolCharacteristics,
                  ProtocolCharacteristics,
                  size);

        // Upcase the name in the characteristics table before saving it.
        Protocol->ProtocolCharacteristics.Name.Buffer = (PWCHAR)((PUCHAR)Protocol +
                                                                   sizeof(NDIS_PROTOCOL_BLOCK));
        Protocol->ProtocolCharacteristics.Name.Length = ProtocolCharacteristics->Name.Length;
        Protocol->ProtocolCharacteristics.Name.MaximumLength = ProtocolCharacteristics->Name.Length;
        RtlUpcaseUnicodeString(&Protocol->ProtocolCharacteristics.Name,
                               &ProtocolCharacteristics->Name,
                               FALSE);

        //
        // No opens for this protocol yet.
        //
        Protocol->OpenQueue = (PNDIS_OPEN_BLOCK)NULL;

        ndisInitializeRef(&Protocol->Ref);
        *NdisProtocolHandle = (NDIS_HANDLE)Protocol;
        Status = NDIS_STATUS_SUCCESS;

        //
        // Link the protocol into the list.
        //
        ACQUIRE_SPIN_LOCK(&ndisProtocolListLock, &OldIrql);

        Protocol->NextProtocol = ndisProtocolList;
        ndisProtocolList = Protocol;

        RELEASE_SPIN_LOCK(&ndisProtocolListLock, OldIrql);

        REF_NDIS_DRIVER_OBJECT();
                
        if (ndisReferenceProtocol(Protocol))
        {
            //
            // Start a worker thread to notify the protocol of any existing drivers
            //
            INITIALIZE_WORK_ITEM(&Protocol->WorkItem, ndisCheckProtocolBindings, Protocol);
            QUEUE_WORK_ITEM(&Protocol->WorkItem, CriticalWorkQueue);
        }

    } while (FALSE);

    *pStatus = Status;

    if (Status != NDIS_STATUS_SUCCESS)
    {
        ProtocolDereferencePackage();
    }
    PnPDereferencePackage();
    
    DBGPRINT_RAW(DBG_COMP_PROTOCOL, DBG_LEVEL_INFO,
            ("<==NdisRegisterProtocol\n"));
}


VOID
NdisDeregisterProtocol(
    OUT PNDIS_STATUS            Status,
    IN  NDIS_HANDLE             NdisProtocolHandle
    )
/*++

Routine Description:

    Deregisters an NDIS protocol.

Arguments:

    Status - Returns the final status.
    NdisProtocolHandle - The handle returned by NdisRegisterProtocol.

Return Value:

    None.

Note:

    This will kill all the opens for this protocol.
    Called at PASSIVE level

--*/
{
    PNDIS_PROTOCOL_BLOCK    Protocol = (PNDIS_PROTOCOL_BLOCK)NdisProtocolHandle;
    KEVENT                  DeregEvent;
    PNDIS_PROTOCOL_BLOCK    tProtocol;
    KIRQL                   OldIrql;

    DBGPRINT_RAW(DBG_COMP_PROTOCOL, DBG_LEVEL_INFO,
            ("==>NdisDeregisterProtocol\n"));
    DBGPRINT_RAW(DBG_COMP_PROTOCOL, DBG_LEVEL_INFO,
            ("    Protocol: "));
    DBGPRINT_UNICODE(DBG_COMP_PROTOCOL, DBG_LEVEL_INFO,
            &Protocol->ProtocolCharacteristics.Name);
    DBGPRINT_RAW(DBG_COMP_PROTOCOL, DBG_LEVEL_INFO,
            ("\n"));

    IF_DBG(DBG_COMP_PROTOCOL, DBG_LEVEL_ERR)
    {
        if (DbgIsNull(NdisProtocolHandle))
        {
            DBGPRINT(DBG_COMP_ALL, DBG_LEVEL_ERR,
                    ("DeregisterProtocol: Null Handle\n"));
            DBGBREAK(DBG_COMP_ALL, DBG_LEVEL_ERR);
        }
        if (!DbgIsNonPaged(NdisProtocolHandle))
        {
            DBGPRINT(DBG_COMP_ALL, DBG_LEVEL_ERR,
                    ("DeregisterProtocol: Handle not in NonPaged Memory\n"));
            DBGBREAK(DBG_COMP_ALL, DBG_LEVEL_ERR);
        }
    }

    //
    // first to check if the protcol exist. some buggy drivers deregister
    // even though registeration did not go through
    //

    PnPReferencePackage();
    ACQUIRE_SPIN_LOCK(&ndisProtocolListLock, &OldIrql);

    for (tProtocol = ndisProtocolList;
         tProtocol != NULL;
         tProtocol = tProtocol->NextProtocol)
    {
        if (tProtocol == Protocol)
        {
            break;
        }
    }

    RELEASE_SPIN_LOCK(&ndisProtocolListLock, OldIrql);
    PnPDereferencePackage();

    ASSERT(tProtocol == Protocol);
    
    if (tProtocol == NULL)
    {
        //
        // if a driver is so broken to send a bogus handle to deregister
        // better not bother to fail the call. they can mess up even more
        //
        *Status = NDIS_STATUS_SUCCESS;
        return;
    }
        
    do
    {
        //
        // If the protocol is already closing, return.
        //
        if (!ndisCloseRef(&Protocol->Ref))
        {
            DBGPRINT(DBG_COMP_PROTOCOL, DBG_LEVEL_INFO,
                    ("<==NdisDeregisterProtocol\n"));
            *Status = NDIS_STATUS_FAILURE;
            break;
        }


        if (Protocol->AssociatedMiniDriver)
        {
            Protocol->AssociatedMiniDriver->AssociatedProtocol = NULL;
            Protocol->AssociatedMiniDriver = NULL;
        }
        
        INITIALIZE_EVENT(&DeregEvent);
        Protocol->DeregEvent = &DeregEvent;
        
        ndisCloseAllBindingsOnProtocol(Protocol);

        ndisDereferenceProtocol(Protocol);

        WAIT_FOR_PROTOCOL(Protocol, &DeregEvent);

        *Status = NDIS_STATUS_SUCCESS;
        
    } while (FALSE);    
    
    ProtocolDereferencePackage();

    DBGPRINT_RAW(DBG_COMP_PROTOCOL, DBG_LEVEL_INFO,
            ("<==NdisDeregisterProtocol, Status %lx\n", *Status));
}


VOID
NdisOpenAdapter(
    OUT PNDIS_STATUS            Status,
    OUT PNDIS_STATUS            OpenErrorStatus,
    OUT PNDIS_HANDLE            NdisBindingHandle,
    OUT PUINT                   SelectedMediumIndex,
    IN  PNDIS_MEDIUM            MediumArray,
    IN  UINT                    MediumArraySize,
    IN  NDIS_HANDLE             NdisProtocolHandle,
    IN  NDIS_HANDLE             ProtocolBindingContext,
    IN  PNDIS_STRING            AdapterName,
    IN  UINT                    OpenOptions,
    IN  PSTRING                 AddressingInformation OPTIONAL
    )
/*++

Routine Description:

    Opens a connection between a protocol and an adapter (Miniport).

Arguments:

    Status - Returns the final status.
    NdisBindingHandle - Returns a handle referring to this open.
    SelectedMediumIndex - Index in MediumArray of the medium type that
        the MAC wishes to be viewed as.
    MediumArray - Array of medium types which a protocol supports.
    MediumArraySize - Number of elements in MediumArray.
    NdisProtocolHandle - The handle returned by NdisRegisterProtocol.
    ProtocolBindingContext - A context for indications.
    AdapterName - The name of the adapter to open.
    OpenOptions - bit mask.
    AddressingInformation - Information passed to MacOpenAdapter.

Return Value:

    None.

Note:

    Called at PASSIVE level
    
--*/
{
    PNDIS_OPEN_BLOCK        NewOpenP = NULL;
    PNDIS_PROTOCOL_BLOCK    Protocol;
    PNDIS_MINIPORT_BLOCK    Miniport;
    PWORK_QUEUE_ITEM        pWorkItem;
    PNDIS_POST_OPEN_PROCESSING  PostOpen = NULL;
    PNDIS_STRING            BindDeviceName, RootDeviceName;
    KIRQL                   OldIrql;
    BOOLEAN                 UsingEncapsulation = FALSE;
    BOOLEAN                 DerefProtocol = FALSE;
    BOOLEAN                 DeQueueFromGlobalList = FALSE;
    ULONG                   i, SizeOpen;

    //
    // Allocate memory for the NDIS open block.
    //

    DBGPRINT_RAW(DBG_COMP_BIND, DBG_LEVEL_INFO,
            ("==>NdisOpenAdapter\n"));
    DBGPRINT_RAW(DBG_COMP_BIND, DBG_LEVEL_INFO,
            ("    Protocol: "));
    DBGPRINT_UNICODE(DBG_COMP_BIND, DBG_LEVEL_INFO,
            &((PNDIS_PROTOCOL_BLOCK)NdisProtocolHandle)->ProtocolCharacteristics.Name);
    DBGPRINT_RAW(DBG_COMP_BIND, DBG_LEVEL_INFO,
            (" is opening Adapter: "));
    DBGPRINT_UNICODE(DBG_COMP_BIND, DBG_LEVEL_INFO,
            AdapterName);
    DBGPRINT_RAW(DBG_COMP_BIND, DBG_LEVEL_INFO,
            ("\n"));

    IF_DBG(DBG_COMP_CONFIG, DBG_LEVEL_ERR)
    {
        BOOLEAN f = FALSE;
        if (DbgIsNull(NdisProtocolHandle))
        {
            DBGPRINT(DBG_COMP_ALL, DBG_LEVEL_ERR,
                    ("OpenAdapter: Null ProtocolHandle\n"));
            f = TRUE;
        }
        if (!DbgIsNonPaged(NdisProtocolHandle))
        {
            DBGPRINT(DBG_COMP_ALL, DBG_LEVEL_ERR,
                    ("OpenAdapter: ProtocolHandle not in NonPaged Memory\n"));
            f = TRUE;
        }
        if (DbgIsNull(ProtocolBindingContext))
        {
            DBGPRINT(DBG_COMP_ALL, DBG_LEVEL_ERR,
                    ("OpenAdapter: Null Context\n"));
            f = TRUE;
        }
        if (!DbgIsNonPaged(ProtocolBindingContext))
        {
            DBGPRINT(DBG_COMP_ALL, DBG_LEVEL_ERR,
                    ("OpenAdapter: Context not in NonPaged Memory\n"));
            f = TRUE;
        }
        if (f)
            DBGBREAK(DBG_COMP_CONFIG, DBG_LEVEL_ERR);

    }

    PnPReferencePackage();
    
    do
    {
        *NdisBindingHandle = NULL;
        ASSERT (NdisProtocolHandle != NULL);
        Protocol = (PNDIS_PROTOCOL_BLOCK)NdisProtocolHandle;

        //
        // Increment the protocol's reference count.
        //
        if (!ndisReferenceProtocol(Protocol))
        {
            //
            // The protocol is closing.
            //
            *Status = NDIS_STATUS_CLOSING;
            break;
        }
        DerefProtocol = TRUE;
        
        if ((BindDeviceName = Protocol->BindDeviceName) != NULL)
        {
            //
            // This is a PnP transport. We know what we want.
            //
            RootDeviceName = Protocol->RootDeviceName;
            Miniport = Protocol->BindingAdapter;
            ASSERT(Miniport != NULL);
        }
        else
        {
            BOOLEAN fTester;

            //
            // This is a legacy transport and it has not come via a Bind upto the protocol.
            // Or it can be a IP arp module who wants to defeat this whole scheme.
            // Find the root of the filter chain. Sigh !!!
            //
            fTester = ((Protocol->ProtocolCharacteristics.Flags & NDIS_PROTOCOL_TESTER) != 0);
            ndisFindRootDevice(AdapterName,
                               fTester,
                               &BindDeviceName,
                               &RootDeviceName,
                               &Miniport);
                               
        }

        if (Miniport == NULL)
        {
            *Status = NDIS_STATUS_ADAPTER_NOT_FOUND;
            break;
        }

        SizeOpen = MINIPORT_TEST_FLAG(Miniport, fMINIPORT_IS_CO) ?
                        sizeof(NDIS_OPEN_BLOCK) : (sizeof(NDIS_OPEN_BLOCK) - sizeof(struct _NDIS_OPEN_CO));

        NewOpenP = (PNDIS_OPEN_BLOCK)ALLOC_FROM_POOL(SizeOpen, NDIS_TAG_M_OPEN_BLK);
        if (NewOpenP == (PNDIS_OPEN_BLOCK)NULL)
        {
            *Status = NDIS_STATUS_RESOURCES;
            break;
        }

        ZeroMemory(NewOpenP, SizeOpen);

        //
        // queue the open on the global list
        //
        ACQUIRE_SPIN_LOCK(&ndisGlobalOpenListLock, &OldIrql);
        NewOpenP->NextGlobalOpen = ndisGlobalOpenList;
        ndisGlobalOpenList = NewOpenP;
        DeQueueFromGlobalList = TRUE;
        RELEASE_SPIN_LOCK(&ndisGlobalOpenListLock, OldIrql);


        //
        // Set the name in the Open to the name passed, not the name opened !!!
        //
        NewOpenP->BindDeviceName = BindDeviceName;
        NewOpenP->RootDeviceName = RootDeviceName;
        NewOpenP->MiniportHandle = Miniport;
        NewOpenP->ProtocolHandle = Protocol;
        NewOpenP->ProtocolBindingContext = ProtocolBindingContext;
        
        //
        // set this now just in case we end up calling the protocol for this binding
        // before returning from NdisOpenAdapter
        //
        *NdisBindingHandle = NewOpenP;

        //
        //
        //  Is this the ndiswan miniport wrapper?
        //
        if ((Miniport->MacOptions & NDISWAN_OPTIONS) == NDISWAN_OPTIONS)
        {
            //
            //  Yup.  We want the binding to think that this is an ndiswan link.
            //
            for (i = 0; i < MediumArraySize; i++)
            {
                if (MediumArray[i] == NdisMediumWan)
                {
                    break;
                }
            }
        }
        else
        {
            //
            // Select the medium to use
            //
            for (i = 0; i < MediumArraySize; i++)
            {
                if (MediumArray[i] == Miniport->MediaType)
                {
                    break;
                }
            }
        }

        if (i == MediumArraySize)
        {
            //
            // Check for ethernet encapsulation on Arcnet as
            // a possible combination.
            //
#if ARCNET
            if (Miniport->MediaType == NdisMediumArcnet878_2)
            {
                for (i = 0; i < MediumArraySize; i++)
                {
                    if (MediumArray[i] == NdisMedium802_3)
                    {
                        break;
                    }
                }

                if (i == MediumArraySize)
                {
                    *Status = NDIS_STATUS_UNSUPPORTED_MEDIA;
                    break;
                }

                UsingEncapsulation = TRUE;
            }
            else
#endif
            {
                *Status = NDIS_STATUS_UNSUPPORTED_MEDIA;
                break;
            }
        }

        *SelectedMediumIndex = i;


        NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Miniport, &OldIrql);

        //
        //  Lock the miniport in case it is not serialized
        //
        if (!MINIPORT_TEST_FLAG(Miniport, fMINIPORT_DESERIALIZE))
        {
            BLOCK_LOCK_MINIPORT_DPC_L(Miniport);
        }
        
        ndisMOpenAdapter(Status,
                         NewOpenP,
                         UsingEncapsulation);

        if (*Status == NDIS_STATUS_SUCCESS)
        {        
            //
            // If the media is disconnected, swap handlers
            //
            if (!MINIPORT_TEST_FLAG(Miniport, fMINIPORT_MEDIA_CONNECTED))
            {
                ndisMSwapOpenHandlers(Miniport,
                                      NDIS_STATUS_NO_CABLE,
                                      fMINIPORT_STATE_MEDIA_DISCONNECTED);
            }

            if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_IS_CO) &&
                (NewOpenP->ProtocolHandle->ProtocolCharacteristics.CoAfRegisterNotifyHandler != NULL))
            {

                PostOpen = (PNDIS_POST_OPEN_PROCESSING)ALLOC_FROM_POOL(sizeof(NDIS_POST_OPEN_PROCESSING), NDIS_TAG_WORK_ITEM);
                if (PostOpen != NULL)
                {
                    OPEN_INCREMENT_AF_NOTIFICATION(NewOpenP);
                    
                    PostOpen->Open = NewOpenP;
        
                    //
                    // Prepare a work item to send AF notifications.
                    // Don't queue it yet.
                    //
                    INITIALIZE_WORK_ITEM(&PostOpen->WorkItem,
                                         ndisMFinishQueuedPendingOpen,
                                         PostOpen);
                }
            }
        }

        if (!MINIPORT_TEST_FLAG(Miniport, fMINIPORT_DESERIALIZE))
        {
            //
            // Unlock the miniport.
            //
            UNLOCK_MINIPORT_L(Miniport);
        }

        NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);

        if (*Status != NDIS_STATUS_SUCCESS)
        {
            break;
        }

        //
        // For SWENUM miniports, reference it so it won't go away
        //
        if (MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_SWENUM))
        {
            PBUS_INTERFACE_REFERENCE BusInterface;
    
            BusInterface = (PBUS_INTERFACE_REFERENCE)(Miniport->BusInterface);
            
            ASSERT(BusInterface != NULL);

            if (BusInterface)
            {
                BusInterface->ReferenceDeviceObject(BusInterface->Interface.Context);
            }
        }

        if (PostOpen != NULL)
        {
            //
            // Complete the Open before queueing AF notifications
            //
            (((PNDIS_PROTOCOL_BLOCK)NewOpenP->ProtocolHandle)->ProtocolCharacteristics.OpenAdapterCompleteHandler)(
                                NewOpenP->ProtocolBindingContext,
                                *Status,
                                *Status);

            QUEUE_WORK_ITEM(&PostOpen->WorkItem, DelayedWorkQueue);

            *Status = NDIS_STATUS_PENDING;
        }
        
    } while (FALSE);

    if ((*Status != NDIS_STATUS_SUCCESS) && (*Status != NDIS_STATUS_PENDING))
    {
        if (DerefProtocol)
        {
            ndisDereferenceProtocol(Protocol);
        }

        if (DeQueueFromGlobalList)
        {
            ndisRemoveOpenFromGlobalList(NewOpenP);
        }
    
        if (NewOpenP != NULL)
        {
            FREE_POOL(NewOpenP);
        }
        
        *NdisBindingHandle = NULL;
    }

    PnPDereferencePackage();
    
    DBGPRINT_RAW(DBG_COMP_BIND, DBG_LEVEL_INFO,
            ("<==NdisOpenAdapter\n"));
}

VOID
NdisCloseAdapter(
    OUT PNDIS_STATUS            Status,
    IN  NDIS_HANDLE             NdisBindingHandle
    )
/*++

Routine Description:

    Closes a connection between a protocol and an adapter (MAC).

Arguments:

    Status - Returns the final status.
    NdisBindingHandle - The handle returned by NdisOpenAdapter.

Return Value:

    None.

Note:
    Called at PASSIVE level

--*/
{
    PNDIS_OPEN_BLOCK        Open = ((PNDIS_OPEN_BLOCK)NdisBindingHandle);
    PNDIS_OPEN_BLOCK        tOpen;
    PNDIS_MINIPORT_BLOCK    Miniport;
    KIRQL                   OldIrql;
    
    PnPReferencePackage();

    //
    // find the open on global open list
    //    
    ACQUIRE_SPIN_LOCK(&ndisGlobalOpenListLock, &OldIrql);
    
    for (tOpen = ndisGlobalOpenList; tOpen != NULL; tOpen = tOpen->NextGlobalOpen)
    {
        if (tOpen == Open)
        {
            break;
        }
    }
    
    RELEASE_SPIN_LOCK(&ndisGlobalOpenListLock, OldIrql);



#if DBG
    if (tOpen)
    {
        DBGPRINT_RAW(DBG_COMP_BIND, DBG_LEVEL_INFO,
                ("==>NdisCloseAdapter\n"));
        DBGPRINT_RAW(DBG_COMP_BIND, DBG_LEVEL_INFO,
                ("    Protocol: "));
        DBGPRINT_UNICODE(DBG_COMP_BIND, DBG_LEVEL_INFO,
                &Open->ProtocolHandle->ProtocolCharacteristics.Name);
        DBGPRINT_RAW(DBG_COMP_BIND, DBG_LEVEL_INFO,
                (" is closing Adapter: "));
        DBGPRINT_UNICODE(DBG_COMP_BIND, DBG_LEVEL_INFO,
                &Open->MiniportHandle->MiniportName);
        DBGPRINT_RAW(DBG_COMP_BIND, DBG_LEVEL_INFO,
                ("\n"));
    }
#endif

    IF_DBG(DBG_COMP_CONFIG, DBG_LEVEL_ERR)
    {
        if (DbgIsNull(NdisBindingHandle))
        {
            DBGPRINT(DBG_COMP_ALL, DBG_LEVEL_ERR,
                    ("OpenAdapter: Null BindingHandle\n"));
            DBGBREAK(DBG_COMP_CONFIG, DBG_LEVEL_ERR);
        }
        if (!DbgIsNonPaged(NdisBindingHandle))
        {
            DBGPRINT(DBG_COMP_ALL, DBG_LEVEL_ERR,
                    ("OpenAdapter: BindingHandle not in NonPaged Memory\n"));
            DBGBREAK(DBG_COMP_CONFIG, DBG_LEVEL_ERR);
        }
    }

    do
    {         
        if (tOpen == NULL)
        {
            *Status = NDIS_STATUS_SUCCESS;
            PnPDereferencePackage();
            break;
        }
        
        Miniport = Open->MiniportHandle;

        ASSERT(Miniport != NULL);

        //
        // For SWENUM miniports, dereference it
        //
        if (MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_SWENUM))
        {
            PBUS_INTERFACE_REFERENCE    BusInterface;
        
            BusInterface = (PBUS_INTERFACE_REFERENCE)(Miniport->BusInterface);

            ASSERT(BusInterface != NULL);
            
            if (BusInterface)
            {
                BusInterface->DereferenceDeviceObject(BusInterface->Interface.Context);
            }
        }

        //
        // This returns TRUE if it finished synchronously.
        //
        if (ndisMKillOpen(Open))
        {
            *Status = NDIS_STATUS_SUCCESS;
            PnPDereferencePackage();
        }
        else
        {
            //
            // will complete later.  ndisMQueuedFinishClose routine will dereference
            // the PnP package. we need to have the pnp package referenced because 
            // a couple of routines called during completing the close, run at DPC
            // ex. ndisMFinishClose, ndisDeQueueOpenOnProtocol and ndisDeQueueOpenOnMiniport
            // and they are in pnp package
            //
            *Status = NDIS_STATUS_PENDING;
        }
    } while (FALSE);
    
    DBGPRINT_RAW(DBG_COMP_BIND, DBG_LEVEL_INFO,
            ("<==NdisCloseAdapter\n"));
}


VOID
NdisSetProtocolFilter(
    OUT PNDIS_STATUS            Status,
    IN  NDIS_HANDLE             NdisBindingHandle,
    IN  RECEIVE_HANDLER         ReceiveHandler,
    IN  RECEIVE_PACKET_HANDLER  ReceivePacketHandler,
    IN  NDIS_MEDIUM             Medium,
    IN  UINT                    Offset,
    IN  UINT                    Size,
    IN  PUCHAR                  Pattern
    )
/*++

Routine Description:

    Sets a protocol filter.

Arguments:

    Status               Returns the final status.
    NdisProtocolHandle   The handle returned by NdisRegisterProtocol.
    ReceiveHandler       This will be invoked instead of the default receivehandler
                         when the pattern match happens.
    ReceivePacketHandler This will be invoked instead of the default receivepackethandler
                         when the pattern match happens.
    Size                 Size of pattern
    Pattern              This must match

Return Value:

    None.

Note:

--*/
{
    *Status = NDIS_STATUS_NOT_SUPPORTED;
}


VOID
NdisGetDriverHandle(
    IN  NDIS_HANDLE             NdisBindingHandle,
    OUT PNDIS_HANDLE            NdisDriverHandle
    )
/*++

Routine Description:
    This routine will return the driver handle for the miniport identified by a binding

Arguments:
    NdisBindingHandle
    NdisDriverHandle: on return from this function, this will be set to the driver handle
    
Return Value:

    None.

Note:

--*/
{
    PNDIS_OPEN_BLOCK    OpenBlock = (PNDIS_OPEN_BLOCK)NdisBindingHandle;
    
    DBGPRINT_RAW(DBG_COMP_BIND, DBG_LEVEL_INFO,
            ("==>NdisGetDriverHandle\n"));

    *NdisDriverHandle = OpenBlock->MiniportHandle->DriverHandle;
    
    DBGPRINT_RAW(DBG_COMP_BIND, DBG_LEVEL_INFO,
            ("<==NdisGetDriverHandle\n"));
}


VOID
NdisReEnumerateProtocolBindings(
    IN  NDIS_HANDLE             NdisProtocolHandle
    )
/*++

Routine Description:


Arguments:


Return Value:

    None.

Note:

--*/
{
    if (ndisReferenceProtocol((PNDIS_PROTOCOL_BLOCK)NdisProtocolHandle))
    {
        ndisCheckProtocolBindings((PNDIS_PROTOCOL_BLOCK)NdisProtocolHandle);
    }
    else
    {
        DBGPRINT(DBG_COMP_ALL, DBG_LEVEL_ERR,
                ("NdisReEnumerateProtocolBindings: Reference failed for %Z\n",
                &((PNDIS_PROTOCOL_BLOCK)NdisProtocolHandle)->ProtocolCharacteristics.Name));
    }
}


NTSTATUS
FASTCALL
ndisReferenceProtocolByName(
    IN  PUNICODE_STRING         ProtocolName,
    IN OUT PNDIS_PROTOCOL_BLOCK *Protocol,
    IN  BOOLEAN                 fPartialMatch
    )
/*++

Routine Description:


Arguments:


Return Value:

    None.

Note:

--*/
{
    KIRQL                   OldIrql;
    UNICODE_STRING          UpcaseProtocol;
    PNDIS_PROTOCOL_BLOCK    TmpProtocol;
    NTSTATUS                Status = STATUS_OBJECT_NAME_NOT_FOUND, NtStatus;

    DBGPRINT_RAW(DBG_COMP_PROTOCOL, DBG_LEVEL_INFO,
            ("==>ndisReferenceProtocolByName\n"));
    DBGPRINT_RAW(DBG_COMP_PROTOCOL, DBG_LEVEL_INFO,
            ("    Protocol: "));
    DBGPRINT_UNICODE(DBG_COMP_PROTOCOL, DBG_LEVEL_INFO,
            ProtocolName);
    DBGPRINT_RAW(DBG_COMP_PROTOCOL, DBG_LEVEL_INFO,
            ("\n"));

    
    do
    {
        UpcaseProtocol.Length = ProtocolName->Length;
        UpcaseProtocol.MaximumLength = ProtocolName->Length + sizeof(WCHAR);
        UpcaseProtocol.Buffer = ALLOC_FROM_POOL(UpcaseProtocol.MaximumLength, NDIS_TAG_STRING);
    
        if (UpcaseProtocol.Buffer == NULL)
        {
            //
            // return null if we fail
            //
            *Protocol = NULL;
            Status = STATUS_INSUFFICIENT_RESOURCES;
            break;
        }
    
        NtStatus = RtlUpcaseUnicodeString(&UpcaseProtocol, ProtocolName, FALSE);
        ASSERT (NT_SUCCESS(NtStatus));
        
        ACQUIRE_SPIN_LOCK(&ndisProtocolListLock, &OldIrql);
    
        for (TmpProtocol = (*Protocol == NULL) ? ndisProtocolList : (*Protocol)->NextProtocol;
             TmpProtocol != NULL;
             TmpProtocol = TmpProtocol->NextProtocol)
        {
            if ((fPartialMatch && (TmpProtocol != *Protocol) &&
                 NDIS_PARTIAL_MATCH_UNICODE_STRING(&UpcaseProtocol, &TmpProtocol->ProtocolCharacteristics.Name)) ||
                (!fPartialMatch &&
                 NDIS_EQUAL_UNICODE_STRING(&UpcaseProtocol, &TmpProtocol->ProtocolCharacteristics.Name)))
            {
                if (ndisReferenceProtocol(TmpProtocol))
                {
                    Status = STATUS_SUCCESS;
                }
                else
                {
                    TmpProtocol = NULL;
                }
                break;
            }
        }
    
        RELEASE_SPIN_LOCK(&ndisProtocolListLock, OldIrql);
        *Protocol = TmpProtocol;

        FREE_POOL(UpcaseProtocol.Buffer);

    } while (FALSE);

    DBGPRINT_RAW(DBG_COMP_PROTOCOL, DBG_LEVEL_INFO,
            ("<==ndisReferenceProtocolByName\n"));
            
    return Status;
}

VOID
FASTCALL
ndisDereferenceProtocol(
    IN  PNDIS_PROTOCOL_BLOCK    Protocol
    )
/*++

Routine Description:


Arguments:


Return Value:

    None.

Note:

--*/
{
    BOOLEAN rc;
    
    DBGPRINT_RAW(DBG_COMP_PROTOCOL, DBG_LEVEL_INFO,
            ("==>ndisDereferenceProtocol\n"));

    DBGPRINT_RAW(DBG_COMP_PROTOCOL, DBG_LEVEL_INFO,
            ("    Protocol: "));
    DBGPRINT_UNICODE(DBG_COMP_PROTOCOL, DBG_LEVEL_INFO,
            &Protocol->ProtocolCharacteristics.Name);
    DBGPRINT_RAW(DBG_COMP_PROTOCOL, DBG_LEVEL_INFO,
            (", RefCount: %ld\n", Protocol->Ref.ReferenceCount -1 ));
            
    rc = ndisDereferenceRef(&Protocol->Ref);
    
            
    if (rc)
    {
        KIRQL   OldIrql;
        PNDIS_PROTOCOL_BLOCK *pProtocol;
        
        ACQUIRE_SPIN_LOCK(&ndisProtocolListLock, &OldIrql);

        for (pProtocol = &ndisProtocolList;
             *pProtocol != NULL;
             pProtocol = &(*pProtocol)->NextProtocol)
        {
            if (*pProtocol == Protocol)
            {
                *pProtocol = Protocol->NextProtocol;
                DEREF_NDIS_DRIVER_OBJECT();
                break;
            }
        }

        ASSERT (*pProtocol == Protocol->NextProtocol);

        ASSERT (Protocol->OpenQueue == NULL);

        RELEASE_SPIN_LOCK(&ndisProtocolListLock, OldIrql);

        if (Protocol->DeregEvent != NULL)
            SET_EVENT(Protocol->DeregEvent);
        FREE_POOL(Protocol);

    }
    
    DBGPRINT_RAW(DBG_COMP_PROTOCOL, DBG_LEVEL_INFO,
            ("<==ndisDereferenceProtocol\n"));
}


VOID
ndisCheckProtocolBindings(
    IN  PNDIS_PROTOCOL_BLOCK    Protocol
    )
/*++

Routine Description:


Arguments:


Return Value:

    None.

Note:

--*/
{
    KIRQL                OldIrql;
    PNDIS_M_DRIVER_BLOCK MiniBlock, NextMiniBlock;
    
    DBGPRINT_RAW(DBG_COMP_PROTOCOL, DBG_LEVEL_INFO,
            ("==>ndisCheckProtocolBindings\n"));
    DBGPRINT_RAW(DBG_COMP_PROTOCOL, DBG_LEVEL_INFO,
            ("    Protocol: "));
    DBGPRINT_UNICODE(DBG_COMP_PROTOCOL, DBG_LEVEL_INFO,
            &Protocol->ProtocolCharacteristics.Name);
    DBGPRINT_RAW(DBG_COMP_PROTOCOL, DBG_LEVEL_INFO,
            ("\n"));

    //
    // Check again if reference is allowed i.e. if the protocol called NdisDeregisterProtocol
    // before this thread had a chance to run.
    //
    if (!ndisReferenceProtocol(Protocol))
    {
        ndisDereferenceProtocol(Protocol);
        return;
    }

    PnPReferencePackage();

    ACQUIRE_SPIN_LOCK(&ndisMiniDriverListLock, &OldIrql);

    //
    // First walk the list of miniports
    //
    for (MiniBlock = ndisMiniDriverList;
         MiniBlock != NULL;
         MiniBlock = NextMiniBlock)
    {
        PNDIS_MINIPORT_BLOCK    Miniport, NM;

        NextMiniBlock = MiniBlock->NextDriver;

        if (ndisReferenceDriver(MiniBlock))
        {
            RELEASE_SPIN_LOCK(&ndisMiniDriverListLock, OldIrql);

            ACQUIRE_SPIN_LOCK(&MiniBlock->Ref.SpinLock, &OldIrql);

            for (Miniport = MiniBlock->MiniportQueue;
                 Miniport != NULL;
                 Miniport = NM)
            {
                NM = Miniport->NextMiniport;

                if (!MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_ORPHANED) &&
                    MINIPORT_INCREMENT_REF(Miniport))
                {
                    RELEASE_SPIN_LOCK(&MiniBlock->Ref.SpinLock, OldIrql);
                    ndisCheckAdapterBindings(Miniport, Protocol);
                    NM = Miniport->NextMiniport;
                    MINIPORT_DECREMENT_REF(Miniport);
                    ACQUIRE_SPIN_LOCK(&MiniBlock->Ref.SpinLock, &OldIrql);
                }
            }

            RELEASE_SPIN_LOCK(&MiniBlock->Ref.SpinLock, OldIrql);
            ACQUIRE_SPIN_LOCK(&ndisMiniDriverListLock, &OldIrql);

            NextMiniBlock = MiniBlock->NextDriver;
            ndisDereferenceDriver(MiniBlock, TRUE);
        }
    }

    RELEASE_SPIN_LOCK(&ndisMiniDriverListLock, OldIrql);


    //
    // Now inform this protocol that we are done for now
    //
    if (Protocol->ProtocolCharacteristics.PnPEventHandler != NULL)
    {
        NET_PNP_EVENT   NetPnpEvent;
        KEVENT          Event;
        NDIS_STATUS     Status;

        INITIALIZE_EVENT(&Event);
        NdisZeroMemory(&NetPnpEvent, sizeof(NetPnpEvent));
        NetPnpEvent.NetEvent = NetEventBindsComplete;

        //
        //  Initialize and save the local event with the PnP event.
        //
        PNDIS_PNP_EVENT_RESERVED_FROM_NET_PNP_EVENT(&NetPnpEvent)->pEvent = &Event;
        
        WAIT_FOR_PROTO_MUTEX(Protocol);
        //
        //  Indicate the event to the protocol.
        //
        Status = (Protocol->ProtocolCharacteristics.PnPEventHandler)(NULL, &NetPnpEvent);

        if (NDIS_STATUS_PENDING == Status)
        {
            //
            //  Wait for completion.
            //
            WAIT_FOR_PROTOCOL(Protocol, &Event);
        }
        
        RELEASE_PROT_MUTEX(Protocol);
    }

    //
    // Dereference twice - one for reference by caller and one for reference at the beginning
    // of this routine.
    //
    ndisDereferenceProtocol(Protocol);
    ndisDereferenceProtocol(Protocol);
    
    PnPDereferencePackage();

    DBGPRINT_RAW(DBG_COMP_PROTOCOL, DBG_LEVEL_INFO,
                ("<==ndisCheckProtocolBindings\n"));
}


VOID
NdisOpenProtocolConfiguration(
    OUT PNDIS_STATUS            Status,
    OUT PNDIS_HANDLE            ConfigurationHandle,
    IN   PNDIS_STRING           ProtocolSection
    )
/*++

Routine Description:


Arguments:


Return Value:

    None.

Note:

--*/
{
    PNDIS_CONFIGURATION_HANDLE          HandleToReturn;
    PNDIS_WRAPPER_CONFIGURATION_HANDLE  ConfigHandle;
    UINT                                Size;
#define PQueryTable                     ConfigHandle->ParametersQueryTable

    DBGPRINT_RAW(DBG_COMP_PROTOCOL, DBG_LEVEL_INFO,
            ("==>NdisOpenProtocolConfiguration\n"));

    do
    {
        //
        // Allocate the space for configuration handle
        //
        Size = sizeof(NDIS_CONFIGURATION_HANDLE) +
                sizeof(NDIS_WRAPPER_CONFIGURATION_HANDLE) +
                ProtocolSection->MaximumLength + sizeof(WCHAR);




        HandleToReturn = ALLOC_FROM_POOL(Size, NDIS_TAG_PROTOCOL_CONFIGURATION);
        
        *Status = (HandleToReturn != NULL) ? NDIS_STATUS_SUCCESS : NDIS_STATUS_RESOURCES;
        
        if (*Status != NDIS_STATUS_SUCCESS)
        {
            *ConfigurationHandle = (NDIS_HANDLE)NULL;
            break;
        }

        ZeroMemory(HandleToReturn, Size);
        ConfigHandle = (PNDIS_WRAPPER_CONFIGURATION_HANDLE)((PUCHAR)HandleToReturn + sizeof(NDIS_CONFIGURATION_HANDLE));

        HandleToReturn->KeyQueryTable = ConfigHandle->ParametersQueryTable;
        HandleToReturn->ParameterList = NULL;

        PQueryTable[0].QueryRoutine = NULL;
        PQueryTable[0].Flags = RTL_QUERY_REGISTRY_SUBKEY;
        PQueryTable[0].Name = L"";

        //
        // 1.
        // Call ndisSaveParameter for a parameter, which will allocate storage for it.
        //
        PQueryTable[1].QueryRoutine = ndisSaveParameters;
        PQueryTable[1].Flags = RTL_QUERY_REGISTRY_REQUIRED | RTL_QUERY_REGISTRY_NOEXPAND;
        PQueryTable[1].DefaultType = REG_NONE;
        //
        // PQueryTable[0].Name and PQueryTable[0].EntryContext
        // are filled in inside ReadConfiguration, in preparation
        // for the callback.
        //
        // PQueryTable[0].Name = KeywordBuffer;
        // PQueryTable[0].EntryContext = ParameterValue;

        //
        // 2.
        // Stop
        //

        PQueryTable[2].QueryRoutine = NULL;
        PQueryTable[2].Flags = 0;
        PQueryTable[2].Name = NULL;

        //
        // NOTE: Some fields in ParametersQueryTable[3] are used to store information for later retrieval.
        //
        PQueryTable[3].QueryRoutine = NULL;
        PQueryTable[3].Name = (PWSTR)((PUCHAR)HandleToReturn +
                                        sizeof(NDIS_CONFIGURATION_HANDLE) +
                                        sizeof(NDIS_WRAPPER_CONFIGURATION_HANDLE));

        CopyMemory(PQueryTable[3].Name, ProtocolSection->Buffer, ProtocolSection->Length);

        PQueryTable[3].EntryContext = NULL;
        PQueryTable[3].DefaultData = NULL;

        *ConfigurationHandle = (NDIS_HANDLE)HandleToReturn;
        *Status = NDIS_STATUS_SUCCESS;
        
    } while (FALSE);
    
    DBGPRINT_RAW(DBG_COMP_PROTOCOL, DBG_LEVEL_INFO,
            ("<==NdisOpenProtocolConfiguration\n"));
}


BOOLEAN
FASTCALL
ndisQueueOpenOnProtocol(
    IN  PNDIS_OPEN_BLOCK        OpenP,
    IN  PNDIS_PROTOCOL_BLOCK    Protocol
    )
/*++

Routine Description:

    Attaches an open block to the list of opens for a protocol.

Arguments:

    OpenP - The open block to be queued.
    Protocol - The protocol block to queue it to.

    NOTE: can be called at raised IRQL.

Return Value:

    TRUE if the operation is successful.
    FALSE if the protocol is closing.

--*/
{
    KIRQL   OldIrql;
    BOOLEAN rc;

    DBGPRINT_RAW(DBG_COMP_BIND, DBG_LEVEL_INFO,
            ("==>ndisQueueOpenOnProtocol\n"));
    DBGPRINT_RAW(DBG_COMP_BIND, DBG_LEVEL_INFO,
            ("    Protocol: "));
    DBGPRINT_UNICODE(DBG_COMP_BIND, DBG_LEVEL_INFO,
            &Protocol->ProtocolCharacteristics.Name);
    DBGPRINT_RAW(DBG_COMP_BIND, DBG_LEVEL_INFO,
            ("\n"));

    IF_DBG(DBG_COMP_PROTOCOL, DBG_LEVEL_ERR)
    {
        BOOLEAN f = FALSE;
        if (DbgIsNull(OpenP))
        {
            DBGPRINT(DBG_COMP_ALL, DBG_LEVEL_ERR,
                    ("ndisQueueOpenOnProtocol: Null Open Block\n"));
            f = TRUE;
        }
        if (!DbgIsNonPaged(OpenP))
        {
            DBGPRINT(DBG_COMP_ALL, DBG_LEVEL_ERR,
                    ("ndisQueueOpenOnProtocol: Open Block not in NonPaged Memory\n"));
            f = TRUE;
        }
        if (DbgIsNull(Protocol))
        {
            DBGPRINT(DBG_COMP_ALL, DBG_LEVEL_ERR,
                    ("ndisQueueOpenOnProtocol: Null Protocol Block\n"));
            f = TRUE;
        }
        if (!DbgIsNonPaged(Protocol))
        {
            DBGPRINT(DBG_COMP_ALL, DBG_LEVEL_ERR,
                    ("ndisQueueOpenOnProtocol: Protocol Block not in NonPaged Memory\n"));
            f = TRUE;
        }
        if (f)
            DBGBREAK(DBG_COMP_ALL, DBG_LEVEL_ERR);
    }

    do
    {
        //
        // we can not reference the package here because this routine can
        // be called at raised IRQL.
        // make sure the PNP package has been referenced already
        //
        ASSERT(ndisPkgs[NPNP_PKG].ReferenceCount > 0);

        ACQUIRE_SPIN_LOCK(&Protocol->Ref.SpinLock, &OldIrql);

        //
        // Make sure the protocol is not closing.
        //

        if (Protocol->Ref.Closing)
        {
            rc = FALSE;
            break;
        }

        //
        // Attach this open at the head of the queue.
        //

        OpenP->ProtocolNextOpen = Protocol->OpenQueue;
        Protocol->OpenQueue = OpenP;

        rc = TRUE;
        
    } while (FALSE);

    RELEASE_SPIN_LOCK(&Protocol->Ref.SpinLock, OldIrql);
    
    DBGPRINT_RAW(DBG_COMP_BIND, DBG_LEVEL_INFO,
            ("<==ndisQueueOpenOnProtocol\n"));
            
    return rc;
}


VOID
FASTCALL
ndisDeQueueOpenOnProtocol(
    IN  PNDIS_OPEN_BLOCK        OpenP,
    IN  PNDIS_PROTOCOL_BLOCK    Protocol
    )
/*++

Routine Description:

    Detaches an open block from the list of opens for a protocol.

Arguments:

    OpenP - The open block to be dequeued.
    Protocol - The protocol block to dequeue it from.

    NOTE: can be called at raised IRQL

Return Value:

    None.

--*/
{
    KIRQL   OldIrql;

    DBGPRINT_RAW(DBG_COMP_BIND, DBG_LEVEL_INFO,
            ("==>ndisDeQueueOpenOnProtocol\n"));
    DBGPRINT_RAW(DBG_COMP_BIND, DBG_LEVEL_INFO,
            ("    Protocol: "));
    DBGPRINT_UNICODE(DBG_COMP_BIND, DBG_LEVEL_INFO,
            &Protocol->ProtocolCharacteristics.Name);
    DBGPRINT_RAW(DBG_COMP_BIND, DBG_LEVEL_INFO,
            ("\n"));
            
    IF_DBG(DBG_COMP_PROTOCOL, DBG_LEVEL_ERR)
    {
        BOOLEAN f = FALSE;
        if (DbgIsNull(OpenP))
        {
            DBGPRINT(DBG_COMP_ALL, DBG_LEVEL_ERR,
                    ("ndisDeQueueOpenOnProtocol: Null Open Block\n"));
            f = TRUE;
        }
        if (!DbgIsNonPaged(OpenP))
        {
            DBGPRINT(DBG_COMP_ALL, DBG_LEVEL_ERR,
                    ("ndisDeQueueOpenOnProtocol: Open Block not in NonPaged Memory\n"));
            f = TRUE;
        }
        if (DbgIsNull(Protocol))
        {
            DBGPRINT(DBG_COMP_ALL, DBG_LEVEL_ERR,
                    ("ndisDeQueueOpenOnProtocol: Null Protocol Block\n"));
            f = TRUE;
        }
        if (!DbgIsNonPaged(Protocol))
        {
            DBGPRINT(DBG_COMP_ALL, DBG_LEVEL_ERR,
                    ("ndisDeQueueOpenOnProtocol: Protocol Block not in NonPaged Memory\n"));
            f = TRUE;
        }
        if (f)
            DBGBREAK(DBG_COMP_ALL, DBG_LEVEL_ERR);
    }

    //
    // we can not reference the package here because this routine can
    // be claled at raised IRQL.
    // make sure the PNP package has been referenced already
    //
    ASSERT(ndisPkgs[NPNP_PKG].ReferenceCount > 0);

    ACQUIRE_SPIN_LOCK(&Protocol->Ref.SpinLock, &OldIrql);

    //
    // Find the open on the queue, and remove it.
    //

    if (OpenP == (PNDIS_OPEN_BLOCK)(Protocol->OpenQueue))
    {
        Protocol->OpenQueue = OpenP->ProtocolNextOpen;
    }
    else
    {
        PNDIS_OPEN_BLOCK PP = Protocol->OpenQueue;

        while ((PP != NULL) && (OpenP != (PNDIS_OPEN_BLOCK)(PP->ProtocolNextOpen)))
        {
            PP = PP->ProtocolNextOpen;
        }
        
        if (PP == NULL)
        {
#if TRACK_MOPEN_REFCOUNTS
            DbgPrint("Ndis:ndisDeQueueOpenOnProtocol Open %p is -not- on Protocol %p\n", OpenP, Protocol);
            DbgBreakPoint();
#endif
        }
        else
        {
            PP->ProtocolNextOpen = PP->ProtocolNextOpen->ProtocolNextOpen;
        }
    }

    RELEASE_SPIN_LOCK(&Protocol->Ref.SpinLock, OldIrql);

    DBGPRINT_RAW(DBG_COMP_BIND, DBG_LEVEL_INFO,
            ("<==ndisDeQueueOpenOnProtocol\n"));
}


NDIS_STATUS
NdisWriteEventLogEntry(
    IN  PVOID                   LogHandle,
    IN  NDIS_STATUS             EventCode,
    IN  ULONG                   UniqueEventValue,
    IN  USHORT                  NumStrings,
    IN  PVOID                   StringsList     OPTIONAL,
    IN  ULONG                   DataSize,
    IN  PVOID                   Data            OPTIONAL
    )
/*++

Routine Description:

    This function allocates an I/O error log record, fills it in and writes it
    to the I/O error log on behalf of a NDIS Protocol.


Arguments:

    LogHandle           - Pointer to the driver object logging this event.

    EventCode           - Identifies the error message.

    UniqueEventValue    - Identifies this instance of a given error message.

    NumStrings          - Number of unicode strings in strings list.

    DataSize            - Number of bytes of data.

    Strings             - Array of pointers to unicode strings (PWCHAR).

    Data                - Binary dump data for this message, each piece being
                          aligned on word boundaries.

Return Value:

    NDIS_STATUS_SUCCESS             - The error was successfully logged.
    NDIS_STATUS_BUFFER_TOO_SHORT    - The error data was too large to be logged.
    NDIS_STATUS_RESOURCES           - Unable to allocate memory.

Notes:

    This code is paged and may not be called at raised IRQL.

--*/
{
    PIO_ERROR_LOG_PACKET    ErrorLogEntry;
    ULONG                   PaddedDataSize;
    ULONG                   PacketSize;
    ULONG                   TotalStringsSize = 0;
    USHORT                  i;
    PWCHAR                  *Strings;
    PWCHAR                  Tmp;
    NDIS_STATUS             Status;
    
    DBGPRINT_RAW(DBG_COMP_CONFIG, DBG_LEVEL_INFO,
            ("==>NdisWriteEventLogEntry\n"));

    do
    {
        Strings = (PWCHAR *)StringsList;

        //
        // Sum up the length of the strings
        //
        for (i = 0; i < NumStrings; i++)
        {
            PWCHAR currentString;
            ULONG   stringSize;

            stringSize = sizeof(UNICODE_NULL);
            currentString = Strings[i];

            while (*currentString++ != UNICODE_NULL)
            {
                stringSize += sizeof(WCHAR);
            }

            TotalStringsSize += stringSize;
        }

        if (DataSize % sizeof(ULONG))
        {
            PaddedDataSize = DataSize + (sizeof(ULONG) - (DataSize % sizeof(ULONG)));
        }
        else
        {
            PaddedDataSize = DataSize;
        }

        PacketSize = TotalStringsSize + PaddedDataSize;

        if (PacketSize > NDIS_MAX_EVENT_LOG_DATA_SIZE)
        {
            Status = NDIS_STATUS_BUFFER_TOO_SHORT;       // Too much error data
            break;
        }

        //
        // Now add in the size of the log packet, but subtract 4 from the data
        // since the packet struct contains a ULONG for data.
        //
        if (PacketSize > sizeof(ULONG))
        {
            PacketSize += sizeof(IO_ERROR_LOG_PACKET) - sizeof(ULONG);
        }
        else
        {
            PacketSize += sizeof(IO_ERROR_LOG_PACKET);
        }

        ASSERT(PacketSize <= ERROR_LOG_MAXIMUM_SIZE);

        ErrorLogEntry = (PIO_ERROR_LOG_PACKET) IoAllocateErrorLogEntry((PDRIVER_OBJECT)LogHandle,
                                                                       (UCHAR) PacketSize);

        if (ErrorLogEntry == NULL)
        {
            Status = NDIS_STATUS_RESOURCES;
            break;
        }

        //
        // Fill in the necessary log packet fields.
        //
        ErrorLogEntry->UniqueErrorValue = UniqueEventValue;
        ErrorLogEntry->ErrorCode = EventCode;
        ErrorLogEntry->NumberOfStrings = NumStrings;
        ErrorLogEntry->StringOffset = (USHORT) (sizeof(IO_ERROR_LOG_PACKET) + PaddedDataSize - sizeof(ULONG));
        ErrorLogEntry->DumpDataSize = (USHORT) PaddedDataSize;

        //
        // Copy the Dump Data to the packet
        //
        if (DataSize > 0)
        {
            RtlMoveMemory((PVOID) ErrorLogEntry->DumpData,
                          Data,
                          DataSize);
        }

        //
        // Copy the strings to the packet.
        //
        Tmp =  (PWCHAR)((PUCHAR)ErrorLogEntry + ErrorLogEntry->StringOffset);

        for (i = 0; i < NumStrings; i++)
        {
            PWCHAR wchPtr = Strings[i];

            while( (*Tmp++ = *wchPtr++) != UNICODE_NULL)
                NOTHING;
        }

        IoWriteErrorLogEntry(ErrorLogEntry);
                
        Status = NDIS_STATUS_SUCCESS;
        
    } while (FALSE);
    
    DBGPRINT_RAW(DBG_COMP_CONFIG, DBG_LEVEL_INFO,
            ("<==NdisWriteEventLogEntry\n"));

    return Status;
}

#if DBG
BOOLEAN
ndisReferenceProtocol(
    IN  PNDIS_PROTOCOL_BLOCK            Protocol
    )
{
    BOOLEAN rc;
    
    DBGPRINT_RAW(DBG_COMP_PROTOCOL, DBG_LEVEL_INFO,
            ("==>ndisReferenceProtocol\n"));
            
    rc = ndisReferenceRef(&Protocol->Ref);
                            
    DBGPRINT_RAW(DBG_COMP_PROTOCOL, DBG_LEVEL_INFO,
            ("    Protocol: "));
    DBGPRINT_UNICODE(DBG_COMP_PROTOCOL, DBG_LEVEL_INFO,
            &Protocol->ProtocolCharacteristics.Name);
    DBGPRINT_RAW(DBG_COMP_PROTOCOL, DBG_LEVEL_INFO,
            (", RefCount: %ld\n", Protocol->Ref.ReferenceCount));
            
    DBGPRINT_RAW(DBG_COMP_PROTOCOL, DBG_LEVEL_INFO,
            ("<==ndisReferenceProtocol\n"));
            
    return rc;
}
#endif




NDIS_STATUS
NdisQueryBindInstanceName(
    OUT PNDIS_STRING    pAdapterInstanceName,
    IN  NDIS_HANDLE     BindingContext
    )
{
    PNDIS_BIND_CONTEXT      BindContext = (NDIS_HANDLE)BindingContext;
    PNDIS_MINIPORT_BLOCK    Miniport;
    USHORT                  cbSize;
    PVOID                   ptmp = NULL;
    NDIS_STATUS             Status = NDIS_STATUS_FAILURE;
    NTSTATUS                NtStatus;
    PNDIS_STRING            pAdapterName;

    DBGPRINT(DBG_COMP_BIND, DBG_LEVEL_INFO,
            ("==>NdisQueryBindInstanceName\n"));

    Miniport = BindContext->Miniport;

    pAdapterName = Miniport->pAdapterInstanceName;

    //
    //  If we failed to create the adapter instance name then fail the call.
    //
    if (NULL != pAdapterName)
    {
        //
        //  Allocate storage for the copy of the adapter instance name.
        //
        cbSize = pAdapterName->MaximumLength;
    
        //
        //  Allocate storage for the new string.
        //
        ptmp = ALLOC_FROM_POOL(cbSize, NDIS_TAG_NAME_BUF);
        if (NULL != ptmp)
        {
            RtlZeroMemory(ptmp, cbSize);
            pAdapterInstanceName->Buffer = ptmp;
            pAdapterInstanceName->Length = 0;
            pAdapterInstanceName->MaximumLength = cbSize;

            NtStatus = RtlAppendUnicodeStringToString(pAdapterInstanceName, pAdapterName);
            if (NT_SUCCESS(NtStatus))
            {   
                Status = NDIS_STATUS_SUCCESS;
            }
        }
        else
        {
            Status = NDIS_STATUS_RESOURCES;
        }
    }

    if (NDIS_STATUS_SUCCESS != Status)
    {
        if (NULL != ptmp)
        {   
            FREE_POOL(ptmp);
        }
    }

    DBGPRINT(DBG_COMP_BIND, DBG_LEVEL_INFO,
            ("<==NdisQueryBindInstanceName: 0x%x\n", Status));

    return(Status);
}

NDIS_STATUS
NdisQueryAdapterInstanceName(
    OUT PNDIS_STRING    pAdapterInstanceName,
    IN  NDIS_HANDLE     NdisBindingHandle
    )
{
    PNDIS_OPEN_BLOCK        pOpen = (PNDIS_OPEN_BLOCK)NdisBindingHandle;
    PNDIS_MINIPORT_BLOCK    Miniport= (PNDIS_MINIPORT_BLOCK)pOpen->MiniportHandle;
    USHORT                  cbSize;
    PVOID                   ptmp = NULL;
    NDIS_STATUS             Status = NDIS_STATUS_FAILURE;
    NTSTATUS                NtStatus;
    PNDIS_STRING            pAdapterName;

    DBGPRINT(DBG_COMP_BIND, DBG_LEVEL_INFO,
            ("==>NdisQueryAdapterInstanceName\n"));

    pAdapterName = Miniport->pAdapterInstanceName;

    //
    //  If we failed to create the adapter instance name then fail the call.
    //
    if (NULL != pAdapterName)
    {
        //
        //  Allocate storage for the copy of the adapter instance name.
        //
        cbSize = pAdapterName->MaximumLength;
    
        //
        //  Allocate storage for the new string.
        //
        ptmp = ALLOC_FROM_POOL(cbSize, NDIS_TAG_NAME_BUF);
        if (NULL != ptmp)
        {
            RtlZeroMemory(ptmp, cbSize);
            pAdapterInstanceName->Buffer = ptmp;
            pAdapterInstanceName->Length = 0;
            pAdapterInstanceName->MaximumLength = cbSize;

            NtStatus = RtlAppendUnicodeStringToString(pAdapterInstanceName, pAdapterName);
            if (NT_SUCCESS(NtStatus))
            {   
                Status = NDIS_STATUS_SUCCESS;
            }
        }
        else
        {
            Status = NDIS_STATUS_RESOURCES;
        }
    }

    if (NDIS_STATUS_SUCCESS != Status)
    {
        if (NULL != ptmp)
        {   
            FREE_POOL(ptmp);
        }
    }

    DBGPRINT(DBG_COMP_BIND, DBG_LEVEL_INFO,
            ("<==NdisQueryAdapterInstanceName: 0x%x\n", Status));

    return(Status);
}

NDIS_STATUS
ndisCloseAllBindingsOnProtocol(
    PNDIS_PROTOCOL_BLOCK    Protocol
    )
{
    PNDIS_OPEN_BLOCK    Open, TmpOpen;
    KIRQL               OldIrql;
    NDIS_STATUS         Status = NDIS_STATUS_SUCCESS;
    BOOLEAN             MoreOpen = TRUE;
    
    DBGPRINT_RAW(DBG_COMP_PROTOCOL, DBG_LEVEL_INFO,
        ("==>ndisCloseAllBindingsOnProtocol: Protocol %p\n", Protocol));

    PnPReferencePackage();
    
    //
    // loop through all opens on the protocol and find the first one that is
    // not already tagged as getting unbound
    //
    ACQUIRE_SPIN_LOCK(&Protocol->Ref.SpinLock, &OldIrql);

    next:

    for (Open = Protocol->OpenQueue;
         Open != NULL; 
         Open = Open->ProtocolNextOpen)
    {
        ACQUIRE_SPIN_LOCK_DPC(&Open->SpinLock);
        if (!MINIPORT_TEST_FLAG(Open, (fMINIPORT_OPEN_CLOSING | fMINIPORT_OPEN_PROCESSING)))
        {
            MINIPORT_SET_FLAG(Open, fMINIPORT_OPEN_PROCESSING);
        
            if (!MINIPORT_TEST_FLAG(Open, fMINIPORT_OPEN_UNBINDING))
            {
                MINIPORT_SET_FLAG(Open, fMINIPORT_OPEN_UNBINDING | fMINIPORT_OPEN_DONT_FREE);
                RELEASE_SPIN_LOCK_DPC(&Open->SpinLock);
                break;
            }
#if DBG
            else
            {
                DBGPRINT_RAW(DBG_COMP_PROTOCOL, DBG_LEVEL_INFO,
                    ("ndisCloseAllBindingsOnProtocol: Open %p is already Closing, Flags %lx\n",
                    Open, Open->Flags));
            }
#endif
        }
        RELEASE_SPIN_LOCK_DPC(&Open->SpinLock);
    }

    if (Open)
    {
        //
        // close the adapter
        //                        
        RELEASE_SPIN_LOCK(&Protocol->Ref.SpinLock, OldIrql);
        Status = ndisUnbindProtocol(Open, FALSE);
        ASSERT(Status == NDIS_STATUS_SUCCESS);
        ACQUIRE_SPIN_LOCK(&Protocol->Ref.SpinLock, &OldIrql);
        goto next;
    }


    //
    // if we reached the end of the list but there are still some opens
    // that are not marked for closing (can happen if we skip an open only because of
    // processign flag being set) release the spinlocks, give whoever set the
    // processing flag time to release the open. then go back and try again
    // ultimately, all opens should either be marked for Unbinding or be gone
    // by themselves
    //

    for (TmpOpen = Protocol->OpenQueue;
         TmpOpen != NULL; 
         TmpOpen = TmpOpen->ProtocolNextOpen)
    {
        if (!MINIPORT_TEST_FLAG(TmpOpen, fMINIPORT_OPEN_UNBINDING))
            break;
    }

    if (TmpOpen != NULL)
    {
        RELEASE_SPIN_LOCK(&Protocol->Ref.SpinLock, OldIrql);
        
        NDIS_INTERNAL_STALL(50);
        
        ACQUIRE_SPIN_LOCK(&Protocol->Ref.SpinLock, &OldIrql);

        goto next;
    }
    
    RELEASE_SPIN_LOCK(&Protocol->Ref.SpinLock, OldIrql);

    PnPDereferencePackage();

    DBGPRINT_RAW(DBG_COMP_PROTOCOL, DBG_LEVEL_INFO,
        ("<==ndisCloseAllBindingsOnProtocol: Protocol %p, Status %lx\n", Protocol, Status));
        
    return Status;
    
}

VOID
NdisSetPacketCancelId(
    IN  PNDIS_PACKET    Packet,
    IN  PVOID           CancelId
    )
{
    NDIS_SET_PACKET_CANCEL_ID(Packet, CancelId);
    return;
}


PVOID
NdisGetPacketCancelId(
    IN  PNDIS_PACKET    Packet
    )
{
    return NDIS_GET_PACKET_CANCEL_ID(Packet);
}

VOID
NdisCancelSendPackets(
    IN  NDIS_HANDLE     NdisBindingHandle,
    IN  PVOID           CancelId
    )
{
    PNDIS_OPEN_BLOCK    Open = (PNDIS_OPEN_BLOCK)NdisBindingHandle;
    KIRQL               OldIrql;
    
    ASSERT(CancelId != NULL);
    //
    // call Miniport's CancelSendPackets handler
    //
    if (!MINIPORT_TEST_FLAG(Open->MiniportHandle, fMINIPORT_DESERIALIZE))
    {
        //
        // for serialized miniports, check our send queue and cancel the packets
        //
        NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Open->MiniportHandle, &OldIrql);
        ndisMAbortPackets(Open->MiniportHandle, Open, CancelId);
        NDIS_RELEASE_MINIPORT_SPIN_LOCK(Open->MiniportHandle, OldIrql);
    }
    else if (Open->CancelSendPacketsHandler != NULL)
    {
        Open->CancelSendPacketsHandler(Open->MiniportAdapterContext, CancelId);
    }

    return;
}

NDIS_STATUS
NdisQueryPendingIOCount(
    IN      PVOID       NdisBindingHandle,
    IN OUT  PULONG      IoCount
    )
{
    PNDIS_OPEN_BLOCK        Open = (PNDIS_OPEN_BLOCK)NdisBindingHandle;
    PNDIS_MINIPORT_BLOCK    Miniport = Open->MiniportHandle;
    ULONG                   RefCount;
    NDIS_STATUS             Status;
    KIRQL                   OldIrql;
    
    ACQUIRE_SPIN_LOCK(&Open->SpinLock, &OldIrql);

    if (MINIPORT_TEST_FLAG(Open, fMINIPORT_OPEN_CLOSING))
    {
        RefCount = 0;
        Status = NDIS_STATUS_CLOSING;
    }
    else
    {
        RefCount = Open->References - Open->AfReferences -1;
        Status = NDIS_STATUS_SUCCESS;
    }

    *IoCount = RefCount;
    
    RELEASE_SPIN_LOCK(&Open->SpinLock, OldIrql);

    return Status;
}

UCHAR
NdisGeneratePartialCancelId(
    VOID
    )
{
    return (UCHAR)(InterlockedIncrement(&ndisCancelId) & 0xFF);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ndis\sys\requestm.h ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation

Module Name:

    requestm.h

Abstract:

Author:

    Kyle Brandon    (KyleB)     

Environment:

    Kernel mode

Revision History:

--*/

#ifndef __REQUESTM_H
#define __REQUESTM_H

typedef struct _NDIS_REQUEST_RESERVED
{
    PNDIS_REQUEST               Next;
    PNDIS_OPEN_BLOCK            Open;
    PVOID                       Context;
    ULONG                       Flags;
} NDIS_REQUEST_RESERVED, *PNDIS_REQUEST_RESERVED;

#define PNDIS_RESERVED_FROM_PNDIS_REQUEST(_request) ((PNDIS_REQUEST_RESERVED)((_request)->MacReserved))

//
// Used by the NdisCoRequest api to keep context information in the Request->NdisReserved
//
typedef struct _NDIS_COREQ_RESERVED
{
    union
    {
      struct
      {
        CO_REQUEST_COMPLETE_HANDLER CoRequestCompleteHandler;
        NDIS_HANDLE                 VcContext;
        NDIS_HANDLE                 AfContext;
        NDIS_HANDLE                 PartyContext;
      };
      struct
      {
        NDIS_STATUS                 Status;
        KEVENT                      Event;
      };
    };

} NDIS_COREQ_RESERVED, *PNDIS_COREQ_RESERVED;

#define REQST_DOWNLEVEL             0x00000001
#define REQST_FREE_REQUEST          0x00000002
#define REQST_SIGNAL_EVENT          0x00000004
#define REQST_SAVE_BUF              0x00000008
#define REQST_LAST_RESTORE          0x00000010
#define REQST_MANDATORY             0x00000020
#define REQST_COMPLETED             0x80000000

#define PNDIS_COREQ_RESERVED_FROM_REQUEST(_request) ((PNDIS_COREQ_RESERVED)((_request)->NdisReserved))

//
//  The following structure keeps track of wakeup patterns for open blocks.
//
typedef struct _NDIS_PACKET_PATTERN_ENTRY
{
    SINGLE_LIST_ENTRY       Link;
    PNDIS_OPEN_BLOCK        Open;
    NDIS_PM_PACKET_PATTERN  Pattern;
} NDIS_PACKET_PATTERN_ENTRY, *PNDIS_PACKET_PATTERN_ENTRY;

#define MINIPORT_QUERY_INFO(_M_, _R_, _S_)  *(_S_) = ndisMDispatchRequest(_M_, _R_, TRUE)

#define MINIPORT_SET_INFO(_M_, _R_, _S_)    *(_S_) = ndisMDispatchRequest(_M_, _R_, FALSE)

#define SAVE_REQUEST_BUF(_M_, _R_, _B_, _L_)                                                        \
    {                                                                                               \
        PNDIS_RESERVED_FROM_PNDIS_REQUEST(_R_)->Flags |= REQST_SAVE_BUF;                            \
        (_M_)->SetInfoBuf = (_R_)->DATA.SET_INFORMATION.InformationBuffer;                          \
        (_M_)->SetInfoBufLen = (USHORT)((_R_)->DATA.SET_INFORMATION.InformationBufferLength);       \
        (_R_)->DATA.SET_INFORMATION.InformationBuffer = _B_;                                        \
        (_R_)->DATA.SET_INFORMATION.InformationBufferLength = _L_;                                  \
    }

#define RESTORE_REQUEST_BUF(_M_, _R_)                                                               \
    {                                                                                               \
        if (PNDIS_RESERVED_FROM_PNDIS_REQUEST(_R_)->Flags & REQST_SAVE_BUF)                         \
        {                                                                                           \
            PNDIS_RESERVED_FROM_PNDIS_REQUEST(_R_)->Flags &= ~REQST_SAVE_BUF;                       \
            (_R_)->DATA.SET_INFORMATION.InformationBuffer = (_M_)->SetInfoBuf;                      \
            (_R_)->DATA.SET_INFORMATION.InformationBufferLength = (_M_)->SetInfoBufLen;             \
            (_M_)->SetInfoBuf = NULL;                                                               \
            (_M_)->SetInfoBufLen = 0;                                                               \
        }                                                                                           \
    }

//
//  This macro verifies the query information buffer length.
//
#define VERIFY_QUERY_PARAMETERS(_Request, _SizeNeeded, _Status)                                     \
{                                                                                                   \
    _Status = NDIS_STATUS_SUCCESS;                                                                  \
    if ((_Request)->DATA.QUERY_INFORMATION.InformationBufferLength < (_SizeNeeded))                 \
    {                                                                                               \
        (_Request)->DATA.QUERY_INFORMATION.BytesNeeded = (_SizeNeeded);                             \
        _Status = NDIS_STATUS_INVALID_LENGTH;                                                       \
    }                                                                                               \
}

//
//  This macro verifies the set information buffer length.
//
#define VERIFY_SET_PARAMETERS(_Request, _SizeNeeded, _Status)                                       \
{                                                                                                   \
    _Status = NDIS_STATUS_SUCCESS;                                                                  \
    if ((_Request)->DATA.SET_INFORMATION.InformationBufferLength < (_SizeNeeded))                   \
    {                                                                                               \
        (_Request)->DATA.SET_INFORMATION.BytesNeeded = (_SizeNeeded);                               \
        _Status = NDIS_STATUS_INVALID_LENGTH;                                                       \
    }                                                                                               \
}

#define SET_INTERNAL_REQUEST(_Request, _Open, _Flags)                                               \
{                                                                                                   \
    PNDIS_RESERVED_FROM_PNDIS_REQUEST(_Request)->Open = (_Open);                                    \
    PNDIS_RESERVED_FROM_PNDIS_REQUEST(_Request)->Flags = _Flags;                                    \
                                                                                                    \
    if (NULL != (_Open))                                                                            \
    {                                                                                               \
        M_OPEN_INCREMENT_REF_INTERLOCKED(_Open);                                                    \
                                                                                                    \
        DBGPRINT(DBG_COMP_OPENREF, DBG_LEVEL_INFO,                                                  \
                ("+ Open 0x%x Reference 0x%x\n", _Open, (_Open)->References));                      \
    }                                                                                               \
}

#define SET_INTERNAL_REQUEST_NULL_OPEN(_Request, _Flags)                                            \
{                                                                                                   \
    PNDIS_RESERVED_FROM_PNDIS_REQUEST(_Request)->Open = NULL;                                       \
    PNDIS_RESERVED_FROM_PNDIS_REQUEST(_Request)->Flags = _Flags;                                    \
}

#define INIT_INTERNAL_REQUEST(_Request, _Oid, _Type, _Buf, _Len)                                    \
{                                                                                                   \
    NdisZeroMemory(_Request, sizeof(NDIS_REQUEST));                                                 \
    PNDIS_RESERVED_FROM_PNDIS_REQUEST(_Request)->Flags = REQST_SIGNAL_EVENT;                        \
    (_Request)->DATA.QUERY_INFORMATION.Oid = _Oid;                                                  \
    (_Request)->RequestType = _Type;                                                                \
    (_Request)->DATA.QUERY_INFORMATION.InformationBuffer = _Buf;                                    \
    (_Request)->DATA.QUERY_INFORMATION.InformationBufferLength = _Len;                              \
}

#endif // __REQUESTM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ndis\sys\requestm.c ===
/*++

Copyright (c) 1992  Microsoft Corporation

Module Name:

    requestm.c

Abstract:

    NDIS miniport request routines.

Author:

    Sean Selitrennikoff (SeanSe) 05-Oct-93
    Jameel Hyder (JameelH) Re-organization 01-Jun-95

Environment:

    Kernel mode, FSD

Revision History:

--*/

#include <precomp.h>
#pragma hdrstop

//
//  Define the module number for debug code.
//
#define MODULE_NUMBER   MODULE_REQUESTM

NDIS_STATUS
ndisMRequest(
    IN  NDIS_HANDLE             NdisBindingHandle,
    IN  PNDIS_REQUEST           NdisRequest
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PNDIS_OPEN_BLOCK        Open = (PNDIS_OPEN_BLOCK)NdisBindingHandle;
    PNDIS_MINIPORT_BLOCK    Miniport = Open->MiniportHandle;
    PNDIS_REQUEST_RESERVED  ReqRsvd = PNDIS_RESERVED_FROM_PNDIS_REQUEST(NdisRequest);
    KIRQL                   OldIrql;
    NDIS_STATUS             Status;
    BOOLEAN                 rc;
    
    DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
        ("==>ndisMRequest\n"));

    do
    {
        NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Miniport, &OldIrql);

        SET_INTERNAL_REQUEST(NdisRequest, Open, 0);
        PNDIS_RESERVED_FROM_PNDIS_REQUEST(NdisRequest)->Context = NULL;
    
        //
        // Get protocol-options
        //
        if ((NdisRequest->RequestType == NdisRequestSetInformation) &&
            (NdisRequest->DATA.SET_INFORMATION.Oid == OID_GEN_PROTOCOL_OPTIONS) &&
            (NdisRequest->DATA.SET_INFORMATION.InformationBuffer != NULL))
        {
            PULONG  ProtocolOptions;
    
            ProtocolOptions = (PULONG)(NdisRequest->DATA.SET_INFORMATION.InformationBuffer);
            if (*ProtocolOptions & NDIS_PROT_OPTION_NO_RSVD_ON_RCVPKT)
            {
                *ProtocolOptions &= ~NDIS_PROT_OPTION_NO_RSVD_ON_RCVPKT;
                Open->Flags |= fMINIPORT_OPEN_NO_PROT_RSVD;
            }
            if ((*ProtocolOptions & NDIS_PROT_OPTION_NO_LOOPBACK) &&
                (Miniport->MacOptions & NDIS_MAC_OPTION_NO_LOOPBACK))
            {
                *ProtocolOptions &= ~fMINIPORT_OPEN_NO_LOOPBACK;
                Open->Flags |= fMINIPORT_OPEN_NO_LOOPBACK;
            }
        }
    
        DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
                ("ndisMRequest: Queueing request 0x%x\n", NdisRequest));

        //
        //  Place the new request on the pending queue.
        //
        if (!(rc = ndisMQueueRequest(Miniport, NdisRequest)))
        {
            Status = NDIS_STATUS_INVALID_DEVICE_REQUEST;
            break;
        }

        if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_DESERIALIZE))
        {
            ndisMDoRequests(Miniport);
        }
        else
        {
            BOOLEAN LocalLock;

            LOCK_MINIPORT(Miniport, LocalLock);
            NDISM_QUEUE_WORK_ITEM(Miniport, NdisWorkItemRequest, NULL);
    
            if (LocalLock)
            {
                NDISM_PROCESS_DEFERRED(Miniport);
            }
            UNLOCK_MINIPORT(Miniport, LocalLock);
        }
    
        Status = NDIS_STATUS_PENDING;

        DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
            ("<==ndisMRequest: NDIS_STATUS_PENDING\n"));

    } while (FALSE);

    NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);

    return Status;
}


NDIS_STATUS
ndisMRequestX(
    IN  NDIS_HANDLE             NdisBindingHandle,
    IN  PNDIS_REQUEST           NdisRequest
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    PNDIS_OPEN_BLOCK                    Open = (PNDIS_OPEN_BLOCK)NdisBindingHandle;
    PNDIS_MINIPORT_BLOCK                Miniport;
    PNDIS_DEFERRED_REQUEST_WORKITEM     DeferredRequestWorkItem = NULL;
    NDIS_STATUS                         Status;
    PVOID                               Caller, CallersCaller;

    //
    // We save the address of the caller in the pool header, for debugging.
    //
    RtlGetCallersAddress(&Caller, &CallersCaller);

    do
    {
        DeferredRequestWorkItem = ALLOC_FROM_POOL(sizeof(NDIS_DEFERRED_REQUEST_WORKITEM), NDIS_TAG_WORK_ITEM);
        if (DeferredRequestWorkItem == NULL)
        {
            Status = NDIS_STATUS_RESOURCES;
            break;
        }

        ZeroMemory(DeferredRequestWorkItem, sizeof(NDIS_DEFERRED_REQUEST_WORKITEM));
        
        if (ndisReferenceOpenByHandle(Open, TRUE))
        {
            Miniport = Open->MiniportHandle;
        }
        else
        {
#if DBG
            DbgPrint("ndisMRequestX: Receiving requests %p after closing Open %p.\n", NdisRequest, Open);
            DbgBreakPoint();
#endif
            FREE_POOL(DeferredRequestWorkItem);
            Status = NDIS_STATUS_CLOSING;
            break;
        }
        
        //
        // Queue this to a work-item
        //
        DeferredRequestWorkItem->Caller = Caller;
        DeferredRequestWorkItem->CallersCaller = CallersCaller;
        DeferredRequestWorkItem->Request = NdisRequest;
        DeferredRequestWorkItem->Open = Open;
        DeferredRequestWorkItem->Oid = NdisRequest->DATA.QUERY_INFORMATION.Oid;
        DeferredRequestWorkItem->InformationBuffer = NdisRequest->DATA.QUERY_INFORMATION.InformationBuffer;
        SET_INTERNAL_REQUEST(NdisRequest, Open, 0);
        DeferredRequestWorkItem->WorkItem.Context = (PVOID)DeferredRequestWorkItem;
        DeferredRequestWorkItem->WorkItem.Routine = (NDIS_PROC)ndisMRundownRequests;
        INITIALIZE_WORK_ITEM((WORK_QUEUE_ITEM *)&DeferredRequestWorkItem->WorkItem.WrapperReserved[0],
                             (PWORKER_THREAD_ROUTINE)ndisMRundownRequests, 
                             DeferredRequestWorkItem);
        QUEUE_WORK_ITEM((WORK_QUEUE_ITEM *)&DeferredRequestWorkItem->WorkItem.WrapperReserved[0], CriticalWorkQueue);
        Status = NDIS_STATUS_PENDING;
    } while (FALSE);
    
    return(Status);
}


VOID
ndisMRundownRequests(
    IN  PNDIS_WORK_ITEM         pWorkItem
    )
/*++

Routine Description:

    Call ndisMDoRequests deferred

Arguments:

Return Value:

--*/
{
    PNDIS_DEFERRED_REQUEST_WORKITEM     DeferredRequestWorkItem = (PNDIS_DEFERRED_REQUEST_WORKITEM)pWorkItem->Context;
    PNDIS_REQUEST           Request;
    PNDIS_OPEN_BLOCK        Open = DeferredRequestWorkItem->Open;
    PNDIS_MINIPORT_BLOCK    Miniport;
    NDIS_STATUS             Status;
    UINT                    OpenRef;
    KIRQL                   OldIrql;

    if(ndisReferenceOpenByHandle(Open, FALSE))
    {
        Miniport = Open->MiniportHandle;
    }
    else
    {
        //
        // where did the open go?
        //
        DbgPrint("Ndis: ndisMRundownRequests Open is gone. DeferredRequestWorkItem %p\n", DeferredRequestWorkItem );
        DbgBreakPoint();
        return;
    }

    Request = DeferredRequestWorkItem->Request;
    
    ASSERT(MINIPORT_TEST_FLAG(Miniport, fMINIPORT_DESERIALIZE));

    Status = ndisMRequest(Open, Request);
    
    if (Status != NDIS_STATUS_PENDING)
    {
        PNDIS_RESERVED_FROM_PNDIS_REQUEST(Request)->Flags |= REQST_COMPLETED;

        (Open->RequestCompleteHandler)(Open->ProtocolBindingContext,
                                   Request,
                                   Status);

    }

    NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Miniport, &OldIrql);
    //
    // we have an extra ref because we called both ndisReferenceOpenByHandle
    // and SET_INTERNAL_REQUEST in ndisRequestX
    //
    M_OPEN_DECREMENT_REF_INTERLOCKED(Open, OpenRef);
    ASSERT(OpenRef > 0);
    ndisMDereferenceOpen(Open);
    NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);
    
    FREE_POOL(DeferredRequestWorkItem);
}

LONG
ndisMDoMiniportOp(
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  BOOLEAN                 Query,
    IN  ULONG                   Oid,
    IN  PVOID                   Buf,
    IN  LONG                    BufSize,
    IN  LONG                    ErrorCodesToReturn,
    IN  BOOLEAN                 fMandatory
    )
/*++

Routine Description:

    Query the miniport with the information supplied. If this is not an optional operation
    then the miniport will be halted if a failure occurs and an error code returned.

    THIS IS THE ONLY PLACE CERTAIN QUERIES HAPPEN DOWN TO THE MINIPORT. THESE ARE THEN
    CACHED AND SUBSEQUENT QUERIES ARE TRAPPED AND RESPONDED FROM HERE.

Arguments:

    Miniport            -   Pointer to the Miniport.
    Query               -   TRUE if this is a query. FALSE if this is a set operation.
    Oid                 -   NDIS OID to send to the miniport.
    Buf                 -   Buffer for the operation.
    BufSize             -   Size of the buffer.
    ErrorCodesToReturn  -   If a system call failed the request then return the given error code.
                            If the miniport failed it then return error code plus 1.

Return Value:

    None.

--*/
{
    NDIS_STATUS             NdisStatus = NDIS_STATUS_SUCCESS;
    LONG                    ErrorCode = 0;
    BOOLEAN                 Set = !Query;
    NDIS_REQUEST            Request;
    PNDIS_COREQ_RESERVED    CoReqRsvd;
    PNDIS_REQUEST_RESERVED  ReqRsvd;


    ZeroMemory(&Request, sizeof(NDIS_REQUEST));
    
    CoReqRsvd = PNDIS_COREQ_RESERVED_FROM_REQUEST(&Request);
    ReqRsvd = PNDIS_RESERVED_FROM_PNDIS_REQUEST(&Request);

    if (Query)
    {
        Request.RequestType = NdisRequestQueryInformation;
    }
    else
    {
        Request.RequestType = NdisRequestSetInformation;
    }

    Request.DATA.QUERY_INFORMATION.Oid = Oid;
    Request.DATA.QUERY_INFORMATION.InformationBuffer = Buf;
    Request.DATA.QUERY_INFORMATION.InformationBufferLength = BufSize;
    
    if (fMandatory)
    {
        ReqRsvd->Flags = REQST_MANDATORY;
    }

    NdisStatus = ndisQuerySetMiniport(Miniport,
                                      NULL,
                                      Set,
                                      &Request,
                                      0);

    if (NdisStatus != NDIS_STATUS_SUCCESS)
    {

        //
        //  Return the error code back to the caller.
        //
        ErrorCode = (NdisStatus == -1) ? ErrorCodesToReturn : ErrorCodesToReturn + 1;
    }

    return(ErrorCode);
}


VOID
FASTCALL
ndisMDoRequests(
    IN  PNDIS_MINIPORT_BLOCK    Miniport
    )

/*++

Routine Description:

    Submits a request to the mini-port.

Arguments:

    Miniport - Miniport to send to.

Return Value:

    TRUE if we need to place the work item back on the queue to process later.
    FALSE if we are done with the work item.

Comments:
    Called at DPC level with Miniport's SpinLock held.

--*/
{
    NDIS_STATUS     Status;
    PNDIS_REQUEST   NdisRequest;

    DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
        ("==>ndisMDoRequests\n"));

    ASSERT_MINIPORT_LOCKED(Miniport);

    //
    //  Do we have a request in progress?
    //
    while (((NdisRequest = Miniport->PendingRequest) != NULL) &&
            !MINIPORT_TEST_FLAG(Miniport, fMINIPORT_PROCESSING_REQUEST))
    {
        UINT                    MulticastAddresses;
        ULONG                   PacketFilter;
        BOOLEAN                 DoMove;
        PVOID                   MoveSource;
        UINT                    MoveBytes;
        ULONG                   GenericULong;

        //
        //  Set defaults.
        //
        DoMove = TRUE;
        Status = NDIS_STATUS_SUCCESS;

        //
        // Process first request
        //
        DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
                ("ndisMDoRequests: Processing Request 0x%x, Oid 0x%x\n", NdisRequest, NdisRequest->DATA.QUERY_INFORMATION.Oid));

        //
        //  Clear the timeout flag.
        //
        MINIPORT_CLEAR_FLAG(Miniport, fMINIPORT_REQUEST_TIMEOUT);
        Miniport->CFHangXTicks = 0;

        //
        // Make it known that we are processing a request
        //
        MINIPORT_SET_FLAG(Miniport, fMINIPORT_PROCESSING_REQUEST);

        //
        // Submit to mini-port
        //
        switch (NdisRequest->RequestType)
        {
          case NdisRequestQueryInformation:
            Status = ndisMQueryInformation(Miniport, NdisRequest);
            break;

          case NdisRequestSetInformation:
            Status = ndisMSetInformation(Miniport, NdisRequest);
            break;

          case NdisRequestQueryStatistics:
            MoveSource = &GenericULong;
            MoveBytes = sizeof(GenericULong);

            //
            // We intercept some calls
            //
            switch (NdisRequest->DATA.QUERY_INFORMATION.Oid)
            {
              case OID_GEN_CURRENT_PACKET_FILTER:

                switch (Miniport->MediaType)
                {
                    case NdisMedium802_3:
                        PacketFilter = ETH_QUERY_FILTER_CLASSES(Miniport->EthDB);
                        break;
    
                    case NdisMedium802_5:
                        PacketFilter = TR_QUERY_FILTER_CLASSES(Miniport->TrDB);
                        break;
    
                    case NdisMediumFddi:
                        PacketFilter = FDDI_QUERY_FILTER_CLASSES(Miniport->FddiDB);
                        break;
    
#if ARCNET
                    case NdisMediumArcnet878_2:
                        PacketFilter = ARC_QUERY_FILTER_CLASSES(Miniport->ArcDB);
                        PacketFilter |= ETH_QUERY_FILTER_CLASSES(Miniport->EthDB);
                        break;
#endif
                }
    
                GenericULong = (ULONG)(PacketFilter);
                break;

              case OID_GEN_MEDIA_IN_USE:
              case OID_GEN_MEDIA_SUPPORTED:
                MoveSource = &Miniport->MediaType;
                MoveBytes = sizeof(NDIS_MEDIUM);
                break;

              case OID_GEN_CURRENT_LOOKAHEAD:
                GenericULong = (ULONG)(Miniport->CurrentLookahead);
                break;

              case OID_GEN_MAXIMUM_LOOKAHEAD:
                GenericULong = (ULONG)(Miniport->MaximumLookahead);
                break;

              case OID_PNP_WAKE_UP_PATTERN_LIST:
                DoMove = FALSE;
                MINIPORT_QUERY_INFO(Miniport, NdisRequest, &Status);

                if (Status == NDIS_STATUS_NOT_SUPPORTED)
                {
                    //
                    // get it from ndis
                    //
                    Status = ndisMQueryWakeUpPatternList(Miniport, NdisRequest);
                }
                break;
                
              case OID_PNP_CAPABILITIES:
                DoMove = FALSE;
                MINIPORT_QUERY_INFO(Miniport, NdisRequest, &Status);

                if ((Status == NDIS_STATUS_SUCCESS) &&
                    !(MINIPORT_TEST_FLAG(Miniport, fMINIPORT_INTERMEDIATE_DRIVER)))
                {
                    ((PNDIS_PNP_CAPABILITIES)NdisRequest->DATA.QUERY_INFORMATION.InformationBuffer)->Flags = Miniport->PMCapabilities.Flags;
                }
                break;

              case OID_GEN_MAC_OPTIONS:
                DoMove = FALSE;
                MINIPORT_QUERY_INFO(Miniport, NdisRequest, &Status);

                if (Status == NDIS_STATUS_SUCCESS)
                {
                    *((PULONG)NdisRequest->DATA.QUERY_INFORMATION.InformationBuffer) |= (Miniport->MacOptions & NDIS_MAC_OPTION_SUPPORTS_MAC_ADDRESS_OVERWRITE);
                }
                break;

              case OID_802_3_MULTICAST_LIST:
              case OID_802_3_MAXIMUM_LIST_SIZE:
                if (Miniport->MediaType != NdisMedium802_3)
                {
                    Status = NDIS_STATUS_INVALID_OID;
                    MoveBytes = 0;
                    break;
                }
                switch (NdisRequest->DATA.QUERY_INFORMATION.Oid)
                {
                  case OID_802_3_MULTICAST_LIST:

                    EthQueryGlobalFilterAddresses(&Status,
                                                  Miniport->EthDB,
                                                  NdisRequest->DATA.QUERY_INFORMATION.InformationBufferLength,
                                                  &MulticastAddresses,
                                                  NdisRequest->DATA.QUERY_INFORMATION.InformationBuffer);

                    //
                    //  Did we fail?
                    //
                    if (NDIS_STATUS_SUCCESS != Status)
                    {
                        NdisRequest->DATA.QUERY_INFORMATION.BytesNeeded = ETH_LENGTH_OF_ADDRESS * ETH_NUMBER_OF_GLOBAL_FILTER_ADDRESSES(Miniport->EthDB);
                        Status = NDIS_STATUS_INVALID_LENGTH;
                    }
                    else
                    {
                        NdisRequest->DATA.QUERY_INFORMATION.BytesWritten = MulticastAddresses * ETH_LENGTH_OF_ADDRESS;
                    }
                    DoMove = FALSE;

                    break;

                  case OID_802_3_MAXIMUM_LIST_SIZE:
                    GenericULong = Miniport->MaximumLongAddresses;
                    break;
                }
                break;
                
              case OID_802_5_CURRENT_FUNCTIONAL:
              case OID_802_5_CURRENT_GROUP:
                if (Miniport->MediaType != NdisMedium802_5)
                {
                    Status = NDIS_STATUS_INVALID_OID;
                    MoveBytes = 0;
                    break;
                }
                switch (NdisRequest->DATA.QUERY_INFORMATION.Oid)
                {
                  case OID_802_5_CURRENT_FUNCTIONAL:
                    GenericULong = BYTE_SWAP_ULONG(TR_QUERY_FILTER_ADDRESSES(Miniport->TrDB));
                    break;

                  case OID_802_5_CURRENT_GROUP:
                    GenericULong = BYTE_SWAP_ULONG(TR_QUERY_FILTER_GROUP(Miniport->TrDB));
                    break;
                }
                break;

              case OID_FDDI_LONG_MULTICAST_LIST:
              case OID_FDDI_LONG_MAX_LIST_SIZE:
              case OID_FDDI_SHORT_MULTICAST_LIST:
              case OID_FDDI_SHORT_MAX_LIST_SIZE:
                if (Miniport->MediaType != NdisMediumFddi)
                {
                    Status = NDIS_STATUS_INVALID_OID;
                    MoveBytes = 0;
                    break;
                }

                switch (NdisRequest->DATA.QUERY_INFORMATION.Oid)
                {



                  case OID_FDDI_LONG_MULTICAST_LIST:
                    FddiQueryGlobalFilterLongAddresses(&Status,
                                                       Miniport->FddiDB,
                                                       NdisRequest->DATA.QUERY_INFORMATION.InformationBufferLength,
                                                       &MulticastAddresses,
                                                       NdisRequest->DATA.QUERY_INFORMATION.InformationBuffer);
        
                    //
                    //  Did we fail?
                    //
                    if (NDIS_STATUS_SUCCESS != Status)
                    {
                        NdisRequest->DATA.QUERY_INFORMATION.BytesNeeded =
                            FDDI_LENGTH_OF_LONG_ADDRESS * FDDI_NUMBER_OF_GLOBAL_FILTER_LONG_ADDRESSES(Miniport->FddiDB);
                        Status = NDIS_STATUS_INVALID_LENGTH;
                    }
                    else
                    {
                        NdisRequest->DATA.QUERY_INFORMATION.BytesWritten = FDDI_LENGTH_OF_LONG_ADDRESS * MulticastAddresses;
                    }
                    DoMove = FALSE;
                    break;

                  case OID_FDDI_LONG_MAX_LIST_SIZE:
                    GenericULong = Miniport->MaximumLongAddresses;
                    break;

                  case OID_FDDI_SHORT_MULTICAST_LIST:
                    FddiQueryGlobalFilterShortAddresses(&Status,
                                                        Miniport->FddiDB,
                                                        NdisRequest->DATA.QUERY_INFORMATION.InformationBufferLength,
                                                        &MulticastAddresses,
                                                        NdisRequest->DATA.QUERY_INFORMATION.InformationBuffer);
        
                    //
                    //  Did we fail ?
                    //
                    if (NDIS_STATUS_SUCCESS != Status)
                    {
                        NdisRequest->DATA.QUERY_INFORMATION.BytesNeeded =
                            FDDI_LENGTH_OF_LONG_ADDRESS * FDDI_NUMBER_OF_GLOBAL_FILTER_SHORT_ADDRESSES(Miniport->FddiDB);

                        Status = NDIS_STATUS_INVALID_LENGTH;
                    }
                    else
                    {
                        NdisRequest->DATA.QUERY_INFORMATION.BytesWritten = FDDI_LENGTH_OF_SHORT_ADDRESS * MulticastAddresses;
                    }
                    DoMove = FALSE;
                    break;

                  case OID_FDDI_SHORT_MAX_LIST_SIZE:
                    GenericULong = Miniport->MaximumShortAddresses;
                    break;
                }
                break;

              default:
                DoMove = FALSE;
                MINIPORT_QUERY_INFO(Miniport, NdisRequest, &Status);
                break;
            }

            if (DoMove)
            {
                //
                // This was an intercepted request. Finish it off
                //

                if (Status == NDIS_STATUS_SUCCESS)
                {
                    if (MoveBytes >
                        NdisRequest->DATA.QUERY_INFORMATION.InformationBufferLength)
                    {
                        //
                        // Not enough room in InformationBuffer. Punt
                        //
                        NdisRequest->DATA.QUERY_INFORMATION.BytesNeeded = MoveBytes;

                        Status = NDIS_STATUS_INVALID_LENGTH;
                    }
                    else
                    {
                        //
                        // Copy result into InformationBuffer
                        //

                        NdisRequest->DATA.QUERY_INFORMATION.BytesWritten = MoveBytes;

                        if ((MoveBytes > 0) &&
                            (MoveSource != NdisRequest->DATA.QUERY_INFORMATION.InformationBuffer))
                        {
                            MoveMemory(NdisRequest->DATA.QUERY_INFORMATION.InformationBuffer,
                                       MoveSource,
                                       MoveBytes);
                        }
                    }
                }
                else
                {
                    NdisRequest->DATA.QUERY_INFORMATION.BytesNeeded = MoveBytes;
                }
            }
            break;
        }

        //
        //  Did the request pend?  If so then there is nothing more to do.
        //
        if ((Status == NDIS_STATUS_PENDING) &&
            MINIPORT_TEST_FLAG(Miniport, fMINIPORT_PROCESSING_REQUEST))
        {
            //
            // Still outstanding
            //
            DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
                    ("Request pending, exit do requests\n"));
            break;
        }

        //
        // Complete request
        //
        if (Status != NDIS_STATUS_PENDING)
        {
            switch (NdisRequest->RequestType)
            {
              case NdisRequestQueryStatistics:
              case NdisRequestQueryInformation:
                ndisMSyncQueryInformationComplete(Miniport, Status);
                break;

              case NdisRequestSetInformation:
                ndisMSyncSetInformationComplete(Miniport, Status);
                break;
            }
        }
    }

    DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
        ("<==ndisMDoRequests\n"));
}

NDIS_STATUS
ndisMSetInformation(
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  PNDIS_REQUEST           Request
    )
/*++

Routine Description:

Arguments:

Return Value:

Note: Called at DPC with Miniport's lock held.

--*/
{
    NDIS_STATUS             Status;
    POID_SETINFO_HANDLER    pOidSH;
    BOOLEAN                 Intercept = FALSE;

    DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
        ("==>ndisMSetInformaiton\n"));

    if (PNDIS_RESERVED_FROM_PNDIS_REQUEST(Request)->Open != NULL)
    {
        //
        //  Process the binding's request.
        //
        for (pOidSH = ndisMSetInfoHandlers; pOidSH->Oid != 0; pOidSH++)
        {
            if (pOidSH->Oid == Request->DATA.SET_INFORMATION.Oid)
            {
                Intercept = TRUE;
                Status = (*pOidSH->SetInfoHandler)(Miniport, Request);
                break;
            }
        }
    }

    if (!Intercept)
    {
        //
        //  Either we are not intercepting this request or it is an internal request
        //
        DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
            ("ndisMSetInformaiton: Request not intercepted by NDIS\n"));
    
        MINIPORT_SET_INFO(Miniport,
                          Request,
                          &Status);
    }

    DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
        ("<==ndisMSetInformaiton: 0x%x\n", Status));

    return(Status);
}

VOID
NdisMSetInformationComplete(
    IN  NDIS_HANDLE             MiniportAdapterHandle,
    IN  NDIS_STATUS             Status
    )
/*++

Routine Description:

    This function indicates the completion of a set information operation.

Arguments:

    MiniportAdapterHandle - points to the adapter block.

    Status - Status of the operation

Return Value:

    None.


--*/
{
    PNDIS_MINIPORT_BLOCK    Miniport = (PNDIS_MINIPORT_BLOCK)MiniportAdapterHandle;
    KIRQL                   OldIrql;

    DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
            ("==>NdisMSetInformationComplete\n"));

    ASSERT_MINIPORT_LOCKED(Miniport);

    //
    //  If we don't have a request to complete assume it was
    //  aborted via the reset handler.
    //
    if (!MINIPORT_TEST_FLAG(Miniport, fMINIPORT_PROCESSING_REQUEST))
    {
        DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
            ("NdisMSetInformationComplete: No request to process\n"));

        DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
            ("<==NdisMSetInformationComplete\n"));

        return;
    }

    NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Miniport, &OldIrql);

    DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
            ("Enter set information complete\n"));

    //
    //  Process the actual set information complete.
    //
    ndisMSyncSetInformationComplete(Miniport, Status);

    //
    //  Are there more requests pending?
    //
    if (Miniport->PendingRequest != NULL)
    {
        NDISM_QUEUE_WORK_ITEM(Miniport, NdisWorkItemRequest, NULL);
    }

    NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);

    DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
            ("<==NdisMSetInformationComplete\n"));
}

VOID
FASTCALL
ndisMSyncSetInformationComplete(
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  NDIS_STATUS             Status
    )
/*++

Routine Description:

    This routine will process a set information complete.  This is only
    called from the wrapper.  The difference is that this routine will not
    call ndisMProcessDeferred() after processing the completion of the set.

Arguments:
    Miniport
    Status

Return Value:
    None

Comments:
    Called at DPC with Miniport's SpinLock held.

--*/
{
    PNDIS_REQUEST           Request;
    PNDIS_REQUEST_RESERVED  ReqRsvd;
    PNDIS_OPEN_BLOCK        Open;
    KIRQL                   OldIrql;
    BOOLEAN                 FreeRequest;

    DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
        ("==>ndisMSyncSetInformationComplete\n"));

    //
    //  Clear the timeout flag and the request_in_process flag.
    //
    MINIPORT_CLEAR_FLAG(Miniport, (fMINIPORT_REQUEST_TIMEOUT | fMINIPORT_PROCESSING_REQUEST));
    Miniport->CFHangXTicks = 0;

    //
    //  Get a pointer to the request that we are completeing.
    //  And clear out the request in-progress pointer.
    //
    Request = Miniport->PendingRequest;
    ASSERT(Request != NULL);
    ReqRsvd = PNDIS_RESERVED_FROM_PNDIS_REQUEST(Request);
    Miniport->PendingRequest = ReqRsvd->Next;
    //
    // save the request for debugging purpose
    //
    Miniport->LastRequest = Request;
    FreeRequest =  ((ReqRsvd->Flags & REQST_FREE_REQUEST) == REQST_FREE_REQUEST);
    ReqRsvd->Flags |= REQST_COMPLETED;

    Open = ReqRsvd->Open;

    DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
            ("ndisMSyncSetInformationComplete: Request 0x%x, Oid 0x%x\n",
            Request, Request->DATA.SET_INFORMATION.Oid));

    RESTORE_REQUEST_BUF(Miniport, Request);

    //
    // Free the multicast buffer, if any
    //
    switch (Request->DATA.SET_INFORMATION.Oid)
    {
      case OID_802_3_MULTICAST_LIST:
      case OID_FDDI_LONG_MULTICAST_LIST:
      case OID_FDDI_SHORT_MULTICAST_LIST:
        if (Miniport->SetMCastBuffer != NULL)
        {
            FREE_POOL(Miniport->SetMCastBuffer);
            Miniport->SetMCastBuffer = NULL;
        }
        break;

      case OID_802_3_CURRENT_ADDRESS:
      case OID_802_5_CURRENT_ADDRESS:
      case OID_FDDI_LONG_CURRENT_ADDR:
      case OID_FDDI_SHORT_CURRENT_ADDR:
        if (Status == NDIS_STATUS_SUCCESS)
        {
            //
            // The current layer-2 address has changed. Make the filters understand that
            //

        }
        break;
    }
    
    //
    //  Get a pointer to the open that made the request.
    //  for internal requests this will be NULL.
    //
    //  Do we need to indicate this request to the protocol?
    //  We do if it's not an internal request.
    //
    if (Open != NULL)
    {
        DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
                ("Open 0x%x\n", Open));

        //
        //  Do any necessary post processing for the request.
        //
        ndisMRequestSetInformationPost(Miniport, Request, Status);

        if (ReqRsvd->Flags & REQST_LAST_RESTORE)
        {
            MINIPORT_CLEAR_FLAG(Miniport, fMINIPORT_RESTORING_FILTERS);
        }

        //
        // Don't complete internal requests
        //
        if (!FreeRequest)
        {
            //
            // Indicate to Protocol;
            //
            NDIS_RELEASE_MINIPORT_SPIN_LOCK_DPC(Miniport);
    
            (Open->RequestCompleteHandler)(Open->ProtocolBindingContext,
                                           Request,
                                           Status);
    
            NDIS_ACQUIRE_MINIPORT_SPIN_LOCK_DPC(Miniport);
        }

        //
        //  Dereference the open.
        //
        DBGPRINT(DBG_COMP_OPENREF, DBG_LEVEL_INFO,
                ("- Open 0x%x Reference 0x%x\n", Open, Open->References));

        ndisMDereferenceOpen(Open);

        if (FreeRequest)
        {
            //
            //  Free the request.
            //
            ndisMFreeInternalRequest(Request);
        }
    }
    else
    {
        PNDIS_COREQ_RESERVED    CoReqRsvd;

        //
        //  The CoReqRsvd portion of the request contains ndis only information about the request.
        //
        CoReqRsvd = PNDIS_COREQ_RESERVED_FROM_REQUEST(Request);
        CoReqRsvd->Status = Status;

        //
        //  Internal requests are only used for restoring filter settings
        //  in the set information path.  this means that no post processing
        //  needs to be done.
        //
        DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
                ("Completeing internal request\n"));


        //
        //  Is there a reset in progress?
        //
        if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_RESET_IN_PROGRESS))
        {
            //
            // If this is the last request then complete the reset
            // but only if the request is to restore filter
            // otherwise, this is a request that is getting aborted
            // or completed in the context of a reset
            //
            if ((NULL == Miniport->PendingRequest) &&
                (ReqRsvd->Flags & REQST_LAST_RESTORE))

            {
                ASSERT(NDIS_STATUS_SUCCESS == Status);
                //
                // Now clear out the reset in progress stuff.
                //
                ndisMResetCompleteStage2(Miniport);
            }
        }
        else
        {
            //
            //  What if one of these requests fails???? We should probably halt
            //  the driver sine this is a fatal error as far as the bindings
            //  are concerned.
            //
            if (ReqRsvd->Flags & REQST_MANDATORY)
            {
                ASSERT(NDIS_STATUS_SUCCESS == Status);
            }

        }

        if ((ReqRsvd->Flags & REQST_LAST_RESTORE) == REQST_LAST_RESTORE)
        {
            MINIPORT_CLEAR_FLAG(Miniport, fMINIPORT_RESTORING_FILTERS);
        }

        if ((ReqRsvd->Flags & REQST_SIGNAL_EVENT) == REQST_SIGNAL_EVENT)
        {
            SET_EVENT(&CoReqRsvd->Event);
        }
        else if (FreeRequest)
        {
            //
            //  Free the request.
            //
            ndisMFreeInternalRequest(Request);
        }
    }

    //
    // if we are removing the miniport, we have to signal an event
    // when all requests are completed
    //
    if (Miniport->PendingRequest == NULL)
    {
        if (Miniport->AllRequestsCompletedEvent)
            SET_EVENT(Miniport->AllRequestsCompletedEvent);
    }

    DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
            ("<==ndisMSyncSetInformationComplete\n"));
}


VOID
ndisMRequestSetInformationPost(
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  PNDIS_REQUEST           Request,
    IN  NDIS_STATUS             Status
)
/*++

Routine Description:

    This routine will do any necessary post processing for ndis requests
    of the set information type.

Arguments:

    Miniport    - Pointer to the miniport block.

    Request     - Pointer to the request to process.

Return Value:

    None.

--*/
{
    PNDIS_REQUEST_RESERVED      ReqRsvd;
    PNDIS_OPEN_BLOCK            Open;
    PNDIS_PACKET_PATTERN_ENTRY  pPacketPattern;
    PNDIS_COREQ_RESERVED        CoReqRsvd;

    DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
        ("==>ndisMRequestSetInformationPost\n"));

    //
    //  Get the reserved information for the request.
    //
    ReqRsvd = PNDIS_RESERVED_FROM_PNDIS_REQUEST(Request);
    Open = ReqRsvd->Open;

    switch (Request->DATA.SET_INFORMATION.Oid)
    {
      case OID_GEN_CURRENT_PACKET_FILTER:
        if ((NDIS_STATUS_SUCCESS != Status) && (Open != NULL))
        {
            //
            //  The request was completed with something besides
            //  NDIS_STATUS_SUCCESS (and of course NDIS_STATUS_PENDING).
            //  Return the packete filter to the original state.
            //
            switch (Miniport->MediaType)
            {
              case NdisMedium802_3:
                if (!MINIPORT_TEST_FLAG(Open, fMINIPORT_OPEN_CLOSING))
                {
                    XUndoFilterAdjust(Miniport->EthDB, Open->FilterHandle);
                }
                break;

              case NdisMedium802_5:
                if (!MINIPORT_TEST_FLAG(Open, fMINIPORT_OPEN_CLOSING))
                {
                    XUndoFilterAdjust(Miniport->TrDB, Open->FilterHandle);
                }
                break;

              case NdisMediumFddi:
                if (!MINIPORT_TEST_FLAG(Open, fMINIPORT_OPEN_CLOSING))
                {
                    XUndoFilterAdjust(Miniport->FddiDB, Open->FilterHandle);
                }
                break;

#if ARCNET
              case NdisMediumArcnet878_2:

                if (!MINIPORT_TEST_FLAG(Open, fMINIPORT_OPEN_CLOSING))
                {
                    if (MINIPORT_TEST_FLAG(ReqRsvd->Open, fMINIPORT_OPEN_USING_ETH_ENCAPSULATION))
                    {
                        XUndoFilterAdjust(Miniport->EthDB, ReqRsvd->Open->FilterHandle);
                    }
                    else
                    {
                        arcUndoFilterAdjust(Miniport->ArcDB, ReqRsvd->Open->FilterHandle);
                    }
                }
                break;
#endif
            }
        }
        
        //
        // check to see how many opens have non zero packet filters
        //
        if (Miniport->MediaType == NdisMedium802_3)
        {
            PETH_BINDING_INFO   OpenFilter;
            PETH_BINDING_INFO   ActiveOpenFilter = NULL;
            ULONG               NumActiveOpens = 0;
            
            for (OpenFilter = Miniport->EthDB->OpenList;
                 (OpenFilter != NULL) && (NumActiveOpens <= 1);
                 OpenFilter = OpenFilter->NextOpen)
            {
                if (OpenFilter->PacketFilters != 0)
                {
                    NumActiveOpens++;
                    ActiveOpenFilter = OpenFilter;
                }
            }
            
            if (NumActiveOpens == 1)
            {
                Miniport->EthDB->SingleActiveOpen = ActiveOpenFilter;
            }
            else
            {
                Miniport->EthDB->SingleActiveOpen = NULL;
            }
            
            ndisUpdateCheckForLoopbackFlag(Miniport);
        }
        break;

      case OID_GEN_CURRENT_LOOKAHEAD:
        //
        //  If we succeeded then update the binding information.
        //
        if (NDIS_STATUS_SUCCESS == Status)
        {
            Miniport->CurrentLookahead = *(UNALIGNED ULONG *)(Request->DATA.SET_INFORMATION.InformationBuffer);
            Open->CurrentLookahead = (USHORT)Miniport->CurrentLookahead;

            Request->DATA.SET_INFORMATION.BytesRead = 4;
        }
        break;

      case OID_802_3_MULTICAST_LIST:

        if (Miniport->MediaType == NdisMedium802_3)
        {
            ethCompleteChangeFilterAddresses(Miniport->EthDB, Status, NULL, FALSE);
        }

        if (Status == NDIS_STATUS_SUCCESS)
        {
            Request->DATA.SET_INFORMATION.BytesRead = Request->DATA.SET_INFORMATION.InformationBufferLength;
        }
        break;

      case OID_802_5_CURRENT_FUNCTIONAL:
        if ((Miniport->MediaType == NdisMedium802_5) &&
            (Status != NDIS_STATUS_SUCCESS) &&
            (Open != NULL) &&
            !MINIPORT_TEST_FLAG(Open, fMINIPORT_OPEN_CLOSING))
        {
            trUndoChangeFunctionalAddress(Miniport->TrDB, Open->FilterHandle);
        }
        break;

      case OID_802_5_CURRENT_GROUP:
        if ((Miniport->MediaType == NdisMedium802_5) &&
            (Status != NDIS_STATUS_SUCCESS) &&
            (Open != NULL) &&
            !MINIPORT_TEST_FLAG(Open, fMINIPORT_OPEN_CLOSING))
        {
            trUndoChangeGroupAddress(Miniport->TrDB, Open->FilterHandle);
        }

        break;

      case OID_FDDI_LONG_MULTICAST_LIST:
        if (Miniport->MediaType == NdisMediumFddi)
        {
            fddiCompleteChangeFilterLongAddresses(Miniport->FddiDB, Status);
        }
        if (Status == NDIS_STATUS_SUCCESS)
        {
            Request->DATA.SET_INFORMATION.BytesRead = Request->DATA.SET_INFORMATION.InformationBufferLength;
        }
        break;

      case OID_FDDI_SHORT_MULTICAST_LIST:
        if (Miniport->MediaType == NdisMediumFddi)
        {
            fddiCompleteChangeFilterShortAddresses(Miniport->FddiDB, Status);
        }

        if (Status == NDIS_STATUS_SUCCESS)
        {
            Request->DATA.SET_INFORMATION.BytesRead = Request->DATA.SET_INFORMATION.InformationBufferLength;
        }
        break;

      case OID_PNP_ADD_WAKE_UP_PATTERN:
        //
        //  Get the packet pattern that was completed.
        //
        pPacketPattern = ReqRsvd->Context;
        if (NDIS_STATUS_SUCCESS == Status)
        {
            //
            //  Add the packet pattern to the miniport's list.
            //

            PushEntryList(&Miniport->PatternList, &pPacketPattern->Link);
        }
        else
        {
            //
            //  Free up the packet pattern that NDIS allocated and fail
            //  the request.
            //
            if (pPacketPattern != NULL)
            {
                FREE_POOL(pPacketPattern);
            }
        }
        break;


      case OID_PNP_REMOVE_WAKE_UP_PATTERN:
        //
        //  If the miniport succeeded in removing the pattern then
        //  we need to find it and remove it from our list.
        //  
        if (NDIS_STATUS_SUCCESS == Status)
        {
            PSINGLE_LIST_ENTRY          Link;
            PSINGLE_LIST_ENTRY          PrevLink;
            PNDIS_PACKET_PATTERN_ENTRY  pPatternEntry;
            PNDIS_REQUEST_RESERVED      ReqRsvd = PNDIS_RESERVED_FROM_PNDIS_REQUEST(Request);
            PNDIS_PM_PACKET_PATTERN     pNdisPacketPattern;

            //
            //  Walk the current list of packet patterns.
            //
            for (PrevLink = NULL, Link = Miniport->PatternList.Next;
                 Link != NULL;
                 PrevLink = Link, Link = Link->Next)
            {
                //
                //  Get a pointer to the pattern entry that the Link represents.
                //
                pPatternEntry = CONTAINING_RECORD(Link, NDIS_PACKET_PATTERN_ENTRY, Link);
    
                //
                //  Do the opens match?
                //
                if (pPatternEntry->Open == ReqRsvd->Open)
                {
                    //
                    //  Get a pointer to the packet pattern that the transport
                    //  wants to remove.
                    //
                    pNdisPacketPattern = Request->DATA.SET_INFORMATION.InformationBuffer;
    
                    //
                    //  Make sure that the size of the passed in pattern is the
                    //  same size as the pattern we are going to compare it with.
                    //
                    if ((pNdisPacketPattern->PatternSize != pPatternEntry->Pattern.PatternSize) ||
                        (pNdisPacketPattern->MaskSize != pPatternEntry->Pattern.MaskSize))
                    {
                        //
                        //  Since the sizes don't match the compare below will fail.
                        //
                        continue;
                    }
    
                    //
                    //  Now we need to match the actual pattern that was
                    //  passed to us.
                    //
                    if (NdisEqualMemory(
                            Request->DATA.SET_INFORMATION.InformationBuffer,
                            &pPatternEntry->Pattern,
                            Request->DATA.SET_INFORMATION.InformationBufferLength))
                    {
                        //
                        //  Remove the packet pattern.
                        //
                        if (NULL == PrevLink)
                        {
                            Miniport->PatternList.Next = Link->Next;
                        }
                        else
                        {
                            PrevLink->Next = Link->Next;
                        }

                        //
                        //  Free the memory taken by the pattern.
                        //
                        FREE_POOL(pPatternEntry);
                        break;
                    }
                }
            }
        }
        break;

      case OID_PNP_QUERY_POWER:
        //
        //  The CoReqRsvd portion of the request contains ndis only
        //  information about the request.
        //
        CoReqRsvd = PNDIS_COREQ_RESERVED_FROM_REQUEST(Request);

        //
        //  Save the status that the miniport returned.
        //
        CoReqRsvd->Status = Status;
        break;

    }

    DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
        ("<==ndisMRequestSetInformationPost\n"));
}


NDIS_STATUS
FASTCALL
ndisMSetProtocolOptions(
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  PNDIS_REQUEST           Request
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    NDIS_STATUS             Status;

    VERIFY_SET_PARAMETERS(Request, sizeof(ULONG), Status);
    if (Status == NDIS_STATUS_SUCCESS)
    {
        *(UNALIGNED ULONG *)(&PNDIS_RESERVED_FROM_PNDIS_REQUEST(Request)->Open->ProtocolOptions) =
                        *(UNALIGNED ULONG *)(Request->DATA.SET_INFORMATION.InformationBuffer);
    
        Request->DATA.SET_INFORMATION.BytesRead = sizeof(ULONG);
        Status = NDIS_STATUS_SUCCESS;
    }

    return(Status);
}


NDIS_STATUS
FASTCALL
ndisMSetPacketFilter(
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  PNDIS_REQUEST           Request
    )
/*++

Routine Description:

    This routine will process two types of set packet filter requests.
    The first one is for when a reset happens.  We simply take the
    packet filter setting that is in the request and send it to the adapter.
    The second is when a protocol sets the packet filter, for this we need
    to update the filter library and then send it down to the adapter.

Arguments:

Return Value:

Note:
    Called at DPC with Miniport's lock held.

--*/
{
    NDIS_STATUS             Status;
    ULONG                   PacketFilter;
    PNDIS_OPEN_BLOCK        Open;
    PNDIS_REQUEST_RESERVED  ReqRsvd;
    KIRQL                   OldIrql;
    
    DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
            ("==>ndisMSetPacketFilter\n"));

    //
    //  Verify the information buffer length that was sent in.
    //
    VERIFY_SET_PARAMETERS(Request, sizeof(PacketFilter), Status);
    if (Status != NDIS_STATUS_SUCCESS)
    {
        DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
                ("<==ndisMSetPacketFilter: 0x%x\n", Status));
        return(Status);
    }

    //
    //  Now call the filter package to set the
    //  packet filter.
    //
    PacketFilter = *(UNALIGNED ULONG *)(Request->DATA.SET_INFORMATION.InformationBuffer);

    //
    //  Get a pointer to the reserved information of the request.
    //
    ReqRsvd = PNDIS_RESERVED_FROM_PNDIS_REQUEST(Request);
    Open = ReqRsvd->Open;

    //
    //  If this request is because of an open that is closing then we
    //  have already adjusted the filter settings and we just need to
    //  make sure that the adapter has the new settings.
    //
    if (MINIPORT_TEST_FLAG(Open, fMINIPORT_OPEN_CLOSING))
    {
        //
        //  By setting the Status to NDIS_STATUS_PENDING we will call
        //  down to the miniport's SetInformationHandler below.
        //
        Status = NDIS_STATUS_PENDING;
    }
    else
    {
        switch (Miniport->MediaType)
        {
          case NdisMedium802_3:
            Status = XFilterAdjust(Miniport->EthDB,
                                   Open->FilterHandle,
                                   PacketFilter,
                                   TRUE);
    
            //
            //  Do this here in anticipation that we
            //  need to call down to the miniport
            //  driver.
            //
            PacketFilter = ETH_QUERY_FILTER_CLASSES(Miniport->EthDB);
            break;

          case NdisMedium802_5:
            Status = XFilterAdjust(Miniport->TrDB,
                                   Open->FilterHandle,
                                   PacketFilter,
                                   TRUE);
    
            //
            //  Do this here in anticipation that we
            //  need to call down to the miniport
            //  driver.
            //
            PacketFilter = TR_QUERY_FILTER_CLASSES(Miniport->TrDB);
            break;

          case NdisMediumFddi:
            Status = XFilterAdjust(Miniport->FddiDB,
                                   Open->FilterHandle,
                                   PacketFilter,
                                   TRUE);
    
            //
            //  Do this here in anticipation that we
            //  need to call down to the miniport
            //  driver.
            //
            PacketFilter = FDDI_QUERY_FILTER_CLASSES(Miniport->FddiDB);
            break;

#if ARCNET
          case NdisMediumArcnet878_2:
            if (MINIPORT_TEST_FLAG(Open, fMINIPORT_OPEN_USING_ETH_ENCAPSULATION))
            {
                Status = XFilterAdjust(Miniport->EthDB,
                                       Open->FilterHandle,
                                       PacketFilter,
                                       TRUE);
            }
            else
            {
                Status = ArcFilterAdjust(Miniport->ArcDB,
                                         Open->FilterHandle,
                                         Request,
                                         PacketFilter,
                                         TRUE);
            }
    
            //
            //  Do this here in anticipation that we
            //  need to call down to the miniport
            //  driver.
            //
            PacketFilter = ARC_QUERY_FILTER_CLASSES(Miniport->ArcDB);
            PacketFilter |= ETH_QUERY_FILTER_CLASSES(Miniport->EthDB);
    
            if (MINIPORT_TEST_FLAG(Miniport,
                                   fMINIPORT_ARCNET_BROADCAST_SET) ||
                                   (PacketFilter & NDIS_PACKET_TYPE_MULTICAST))
            {
                PacketFilter &= ~NDIS_PACKET_TYPE_MULTICAST;
                PacketFilter |= NDIS_PACKET_TYPE_BROADCAST;
            }
            break;
#endif

        default:
            break;
        }
    }


    //
    // If this was a request to turn p-mode/l-only on/off then mark things appropriately
    //
    if (Open != NULL)
    {
        PULONG  Filter = (PULONG)(Request->DATA.SET_INFORMATION.InformationBuffer);
    
        if (*Filter & (NDIS_PACKET_TYPE_PROMISCUOUS | NDIS_PACKET_TYPE_ALL_LOCAL))
        {
            if ((Open->Flags & fMINIPORT_OPEN_PMODE) == 0)
            {
                Open->Flags |= fMINIPORT_OPEN_PMODE;
                Miniport->PmodeOpens ++;
                NDIS_CHECK_PMODE_OPEN_REF(Miniport);
                ndisUpdateCheckForLoopbackFlag(Miniport);
            }

            if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_IS_CO))
            {
                *Filter &= ~(NDIS_PACKET_TYPE_PROMISCUOUS | NDIS_PACKET_TYPE_ALL_LOCAL);
            }
        }
        else
        {
            if (Open->Flags & fMINIPORT_OPEN_PMODE)
            {
                Open->Flags &= ~fMINIPORT_OPEN_PMODE;
                Miniport->PmodeOpens --;
                NDIS_CHECK_PMODE_OPEN_REF(Miniport);
                ndisUpdateCheckForLoopbackFlag(Miniport);
            }
        }
    }



    //
    //  If the local-only bit is set and the miniport is doing it's own
    //  loop back then we need to make sure that we loop back non-self
    //  directed packets that are sent out on the pipe.
    //
    if ((PacketFilter & NDIS_PACKET_TYPE_ALL_LOCAL) &&
        (Miniport->MacOptions & NDIS_MAC_OPTION_NO_LOOPBACK) == 0)
    {
        MINIPORT_SET_FLAG(Miniport, fMINIPORT_SEND_LOOPBACK_DIRECTED);
    }
    else
    {
        MINIPORT_CLEAR_FLAG(Miniport, fMINIPORT_SEND_LOOPBACK_DIRECTED);
    }

    //
    //  If the filter library returns NDIS_STATUS_PENDING from
    //  the XxxFitlerAdjust() then we need to call down to the
    //  miniport driver.  Other wise this will have succeeded.
    //
    if (NDIS_STATUS_PENDING == Status)
    {
        //
        //  Save the current global packet filter in a buffer that will stick around.
        //  Remove the ALL_LOCAL bit since miniport does not understand this (and does
        //  not need to).
        //
        Miniport->RequestBuffer = (PacketFilter & ~NDIS_PACKET_TYPE_ALL_LOCAL);

        //
        //  Call the miniport driver. Save the request parms and restore on completion
        //
        SAVE_REQUEST_BUF(Miniport, Request, &Miniport->RequestBuffer, sizeof(PacketFilter));
        MINIPORT_SET_INFO(Miniport,
                          Request,
                          &Status);
    }

    //
    //  If we have success then set the Bytes read in the original request.
    //
    if (Status != NDIS_STATUS_PENDING)
    {
        RESTORE_REQUEST_BUF(Miniport, Request);
        if (NDIS_STATUS_SUCCESS == Status)
        {
            Request->DATA.SET_INFORMATION.BytesRead = 4;
        }
        else
        {
            Request->DATA.SET_INFORMATION.BytesRead = 0;
            Request->DATA.SET_INFORMATION.BytesNeeded = 0;
        }
    }

    DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
            ("<==ndisMSetPacketFilter: 0x%x\n", Status));

    return(Status);
}

NDIS_STATUS
FASTCALL
ndisMSetCurrentLookahead(
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  PNDIS_REQUEST           Request
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    UINT                Lookahead;
    ULONG               CurrentMax;
    PNDIS_OPEN_BLOCK    CurrentOpen;
    NDIS_STATUS         Status;

    DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
            ("==>ndisMSetCurrentLookahead\n"));

    //
    // Verify length of the information buffer.
    //
    VERIFY_SET_PARAMETERS(Request, sizeof(Lookahead), Status);
    if (Status != NDIS_STATUS_SUCCESS)
    {
        DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
                ("<==ndisMSetCurrentLookahead: 0x%x\n", Status));

        return(Status);
    }

    //
    //  Put the lookahead that the binding requests into a
    //  buffer we can use...
    //
    Lookahead = *(UNALIGNED UINT *)(Request->DATA.SET_INFORMATION.InformationBuffer);

    //
    //  Verify that the lookahead is within boundaries...
    //
    if (Lookahead > Miniport->MaximumLookahead)
    {
        Request->DATA.SET_INFORMATION.BytesRead = 0;
        Request->DATA.SET_INFORMATION.BytesNeeded = 0;

        Status = NDIS_STATUS_INVALID_LENGTH;

        DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
                ("<==ndisMSetCurrentLookahead: 0x%x\n", Status));

        return(Status);
    }

    //
    //  Find the maximum lookahead between all opens that
    //  are bound to the miniport driver.
    //
    for (CurrentOpen = Miniport->OpenQueue, CurrentMax = 0;
         CurrentOpen != NULL;
         CurrentOpen = CurrentOpen->MiniportNextOpen)
    {
        if (CurrentOpen->CurrentLookahead > CurrentMax)
        {
            CurrentMax = CurrentOpen->CurrentLookahead;
        }
    }

    //
    //  Figure in the new lookahead.
    //
    if (Lookahead > CurrentMax)
    {
        CurrentMax = Lookahead;
    }

    //
    //  Adjust the current max lookahead if needed.
    //
    if (CurrentMax == 0)
    {
        CurrentMax = Miniport->MaximumLookahead;
    }

    //
    //  Set the default status.
    //
    Status = NDIS_STATUS_SUCCESS;

    //
    //  Do we need to call the miniport driver with the
    //  new max lookahead?
    //
    if (Miniport->CurrentLookahead != CurrentMax)
    {
        //
        //  Save the new lookahead value in a buffer
        //  that will stick around.
        //
        Miniport->RequestBuffer = CurrentMax;

        //
        //  Send it to the driver.
        //
        SAVE_REQUEST_BUF(Miniport, Request, &Miniport->RequestBuffer, sizeof(CurrentMax));
        MINIPORT_SET_INFO(Miniport,
                          Request,
                          &Status);
    }

    //
    //  If we succeeded then update the binding information.
    //
    if (Status != NDIS_STATUS_PENDING)
    {
        RESTORE_REQUEST_BUF(Miniport, Request);
        if (NDIS_STATUS_SUCCESS == Status)
        {
            PNDIS_RESERVED_FROM_PNDIS_REQUEST(Request)->Open->CurrentLookahead = (USHORT)Lookahead;
            Request->DATA.SET_INFORMATION.BytesRead = sizeof(Lookahead);
            Miniport->CurrentLookahead = CurrentMax;
        }
        else
        {
            Request->DATA.SET_INFORMATION.BytesRead = 0;
            Request->DATA.SET_INFORMATION.BytesNeeded = 0;
        }
    }

    DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
            ("<==ndisMSetCurrentLookahead: 0x%x\n", Status));

    return(Status);
}

NDIS_STATUS
FASTCALL
ndisMSetAddWakeUpPattern(
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  PNDIS_REQUEST           Request
    )
/*++

Routine Description:

    This routine will add a packet pattern to a miniports list to be used for
    remote wake-up.

Arguments:

    Miniport    -   Pointer to the adapter's miniport block.
    Request     -   Pointer to the request.

Return Value:

    NDIS_STATUS_SUCCESS if the packet pattern was successfully added.
    NDIS_STATUS_PENDING if the request will complete asynchronously.

--*/
{
    PNDIS_PACKET_PATTERN_ENTRY  pPacketEntry;
    ULONG                       cbSize;
    PNDIS_REQUEST_RESERVED      ReqRsvd = PNDIS_RESERVED_FROM_PNDIS_REQUEST(Request);
    NDIS_STATUS                 Status;

    DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
        ("==>ndisMSetAddWakeUpPattern\n"));

    //
    //  Verify the size of the information buffer.
    //
    VERIFY_SET_PARAMETERS(Request, sizeof(NDIS_PM_PACKET_PATTERN), Status);
    if (NDIS_STATUS_SUCCESS == Status)
    {
        //
        //  Allocate an NDIS_PACKET_PATTERN_ENTRY to store the new pattern.
        //
        cbSize = (sizeof(NDIS_PACKET_PATTERN_ENTRY) -
                  sizeof(NDIS_PM_PACKET_PATTERN)) +
                  Request->DATA.SET_INFORMATION.InformationBufferLength;

        pPacketEntry = ALLOC_FROM_POOL(cbSize, NDIS_TAG_PKT_PATTERN);
        if (NULL != pPacketEntry)
        {
            //
            //  Copy the request information to the pattern entry.
            //
            MoveMemory(&pPacketEntry->Pattern,
                       Request->DATA.SET_INFORMATION.InformationBuffer,
                       Request->DATA.SET_INFORMATION.InformationBufferLength);

            //
            //  Save the open with the pattern entry.
            //
            pPacketEntry->Open = ReqRsvd->Open;

            //
            //  Save the packet entry with the request.
            //
            ReqRsvd->Context = pPacketEntry;

            //
            //  Call the miniport driver.
            //
            MINIPORT_SET_INFO(Miniport,
                              Request,
                              &Status);
        }
        else
        {
            DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_ERR,
                    ("ndisMSetAddWakeUpPattern: Unable to allocate memory for internal data structure\n"));
            ReqRsvd->Context = NULL;
            Status = NDIS_STATUS_RESOURCES;
        }
    }
    else
    {
        DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_ERR,
                ("ndisMSetAddWakeupPattern: Invalid request size\n"));
        
    }

    DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
            ("<==ndisMSetAddWakeUpPattern\n"));

    return(Status);
}

NDIS_STATUS
FASTCALL
ndisMSetRemoveWakeUpPattern(
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  PNDIS_REQUEST           Request
    )
/*++


Routine Description:

    This routine will remove a packet pattern from a miniports list so that the
    adapter will no longer generate wake-up events for it.

Arguments:

    Miniport    -   Pointer to the adapter's miniport block.
    Request     -   Pointer to the request.

Return Value:

    NDIS_STATUS_SUCCESS if the packet pattern was successfully added.
    NDIS_STATUS_PENDING if the request will complete asynchronously.

--*/
{
    NDIS_STATUS                 Status;

    DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
        ("==>ndisMSetRemoveWakeUpPattern\n"));

    //
    //  Verify the size of the information buffer.
    //
    VERIFY_SET_PARAMETERS(Request, sizeof(NDIS_PM_PACKET_PATTERN), Status);
    if (NDIS_STATUS_SUCCESS == Status)
    {
        //
        //  Call the miniport driver.
        //
        MINIPORT_SET_INFO(Miniport,
                          Request,
                          &Status);
    }
    else
    {
        DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_ERR,
            ("ndisMSetRemoveWakeUpPattern: Invalid request size\n"));
        
    }

    DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
        ("<==ndisMSetRemoveWakeUpPattern\n"));

    return(Status);
}

NDIS_STATUS
FASTCALL
ndisMSetEnableWakeUp(
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  PNDIS_REQUEST           Request
    )
/*++

Routine Description:

    This routine will set the wake-up bits for the open and or the with the
    other opens.  If this is different from what is already set on the miniport
    then it will pass the new bits to the miniport.

Arguments:

    Miniport    -   Pointer to the adapter's miniport block.
    Request     -   Pointer to the request.

Return Value:

    
--*/
{
    NDIS_STATUS             Status;
    PNDIS_REQUEST_RESERVED  ReqRsvd = PNDIS_RESERVED_FROM_PNDIS_REQUEST(Request);
    PNDIS_OPEN_BLOCK        tmpOpen;
    PULONG                  pEnableWakeUp;
    ULONG                   newWakeUpEnable;

    DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
        ("==>ndisMSetEnableWakeUp\n"));

    //
    //  Verify the request's information buffer.
    //
    VERIFY_SET_PARAMETERS(Request, sizeof(ULONG), Status);
    if (NDIS_STATUS_SUCCESS == Status)
    {
        //
        //  Get a PULONG to the information buffer.
        //
        pEnableWakeUp = (PULONG)Request->DATA.QUERY_INFORMATION.InformationBuffer;
    
        //
        //  Save the new wake-up enables with the open.
        //
        ReqRsvd->Open->WakeUpEnable = *pEnableWakeUp;

        //
        // preserve the state of NDIS_PNP_WAKE_UP_MAGIC_PACKET and NDIS_PNP_WAKE_UP_LINK_CHANGE flag
        //
        newWakeUpEnable = Miniport->WakeUpEnable & (NDIS_PNP_WAKE_UP_MAGIC_PACKET | NDIS_PNP_WAKE_UP_LINK_CHANGE);
        //
        //  Get the new bitwise or of the wake-up bits.
        //
        for (tmpOpen = Miniport->OpenQueue;
             tmpOpen != NULL;
             tmpOpen = tmpOpen->MiniportNextOpen)
        {
            newWakeUpEnable |= tmpOpen->WakeUpEnable;
        }

        //
        //  Save the combination of all opens options with the miniport.
        //
        Miniport->WakeUpEnable = newWakeUpEnable;

        //
        // if this is an IM driver, give it a chance to send the OID down to the physical device
        //
        if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_INTERMEDIATE_DRIVER))
        {

            MINIPORT_SET_INFO(Miniport,
                          Request,
                          &Status);

    
        }
        
    }

    DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
        ("<==ndisMSetEnableWakeUp\n"));

    return(Status);
}


NDIS_STATUS
ndisMQueryInformation(
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  PNDIS_REQUEST           Request
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    NDIS_STATUS         Status;
    PULONG              pulBuffer;
    PNDIS_OPEN_BLOCK    Open;
    ULONG               Generic;

    //
    //  If there is no open associated with the request then it is an internal request
    //  and we just send it down to the adapter.
    //
    Open = PNDIS_RESERVED_FROM_PNDIS_REQUEST(Request)->Open;
    if (Open == NULL)
    {
        DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
                ("ndisMQueryInformation: Internal request calling to the miniport directly\n"));

        MINIPORT_QUERY_INFO(Miniport, Request, &Status);

        DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
                ("<==ndisMQueryInformaiton: 0x%x\n", Status));

        return(Status);
    }

    //
    //  Copy the request information into temporary storage.
    //
    pulBuffer = Request->DATA.QUERY_INFORMATION.InformationBuffer;

    //
    // increase the request time out for some requests
    //
    if ((Request->DATA.QUERY_INFORMATION.Oid == OID_GEN_MEDIA_CONNECT_STATUS) || 
        (Request->DATA.QUERY_INFORMATION.Oid == OID_GEN_LINK_SPEED))
    {
        Miniport->CFHangXTicks = 2;
    }
    
    //
    //  We intercept some calls.
    //
    switch (Request->DATA.QUERY_INFORMATION.Oid)
    {
      case OID_GEN_CURRENT_PACKET_FILTER:
        Status = ndisMQueryCurrentPacketFilter(Miniport, Request);
        break;
    
      case OID_GEN_MEDIA_IN_USE:
      case OID_GEN_MEDIA_SUPPORTED:
        Status = ndisMQueryMediaSupported(Miniport, Request);
        break;
    
      case OID_GEN_CURRENT_LOOKAHEAD:
        VERIFY_QUERY_PARAMETERS(Request,
                                sizeof(Open->CurrentLookahead),
                                Status);
    
        if (NDIS_STATUS_SUCCESS == Status)
        {
            *pulBuffer = Open->CurrentLookahead;
            Request->DATA.QUERY_INFORMATION.BytesWritten = sizeof(Open->CurrentLookahead);
        }
        break;

      case OID_GEN_MAXIMUM_LOOKAHEAD:
        VERIFY_QUERY_PARAMETERS(Request,
                                sizeof(Miniport->MaximumLookahead),
                                Status);
    
        if (NDIS_STATUS_SUCCESS == Status)
        {
            *pulBuffer = Miniport->MaximumLookahead;
            Request->DATA.QUERY_INFORMATION.BytesWritten = sizeof(Miniport->MaximumLookahead);
        }
        break;

      case OID_802_3_MULTICAST_LIST:
        Status = ndisMQueryEthernetMulticastList(Miniport, Request);
        break;

      case OID_802_3_MAXIMUM_LIST_SIZE:
        VERIFY_QUERY_PARAMETERS(Request,
                                sizeof(Miniport->MaximumLongAddresses),
                                Status);
    
        if (NDIS_STATUS_SUCCESS == Status)
        {
            *pulBuffer = Miniport->MaximumLongAddresses;
            Request->DATA.QUERY_INFORMATION.BytesWritten = sizeof(Miniport->MaximumLongAddresses);
        }
        break;

      case OID_802_5_CURRENT_FUNCTIONAL:
        VERIFY_QUERY_PARAMETERS(Request,
                                sizeof(*pulBuffer),
                                Status);
    
        if (NDIS_STATUS_SUCCESS == Status)
        {
            Generic = TR_QUERY_FILTER_BINDING_ADDRESS(Miniport->TrDB,
                                                      Open->FilterHandle);
    
            *pulBuffer = BYTE_SWAP_ULONG(Generic);
            Request->DATA.QUERY_INFORMATION.BytesWritten = sizeof(*pulBuffer);
        }
        break;

      case OID_802_5_CURRENT_GROUP:
        VERIFY_QUERY_PARAMETERS(Request,
                                sizeof(*pulBuffer),
                                Status);
    
        if (NDIS_STATUS_SUCCESS == Status)
        {
            *pulBuffer = BYTE_SWAP_ULONG(TR_QUERY_FILTER_GROUP(Miniport->TrDB));
            Request->DATA.QUERY_INFORMATION.BytesWritten = sizeof(*pulBuffer);
        }
    
        break;

      case OID_FDDI_LONG_MULTICAST_LIST:
        Status = ndisMQueryLongMulticastList(Miniport, Request);
        break;

      case OID_FDDI_LONG_MAX_LIST_SIZE:
        VERIFY_QUERY_PARAMETERS(Request,
                                sizeof(*pulBuffer),
                                Status);
    
        if (Status == NDIS_STATUS_SUCCESS)
        {
            *pulBuffer = Miniport->MaximumLongAddresses;
            Request->DATA.QUERY_INFORMATION.BytesWritten = sizeof(*pulBuffer);
        }
        break;

      case OID_FDDI_SHORT_MULTICAST_LIST:
        Status = ndisMQueryShortMulticastList(Miniport, Request);
        break;

      case OID_FDDI_SHORT_MAX_LIST_SIZE:
        VERIFY_QUERY_PARAMETERS(Request,
                                sizeof(Miniport->MaximumShortAddresses),
                                Status);
    
        if (NDIS_STATUS_SUCCESS == Status)
        {
            *pulBuffer = Miniport->MaximumShortAddresses;
            Request->DATA.QUERY_INFORMATION.BytesWritten = sizeof(Miniport->MaximumShortAddresses);
        }
        break;

      case OID_GEN_MAXIMUM_FRAME_SIZE:
        Status = ndisMQueryMaximumFrameSize(Miniport, Request);
        break;

      case OID_GEN_MAXIMUM_TOTAL_SIZE:
        Status = ndisMQueryMaximumTotalSize(Miniport, Request);
        break;

      case OID_802_3_PERMANENT_ADDRESS:
      case OID_802_3_CURRENT_ADDRESS:
        Status = ndisMQueryNetworkAddress(Miniport, Request);
        break;

      case OID_PNP_WAKE_UP_PATTERN_LIST:
        Status = ndisMQueryWakeUpPatternList(Miniport, Request);
        break;

      case OID_PNP_ENABLE_WAKE_UP:
        Status = ndisMQueryEnableWakeUp(Miniport, Request);
        break;

      case OID_GEN_FRIENDLY_NAME:
        Status = NDIS_STATUS_BUFFER_TOO_SHORT;
        if (Request->DATA.QUERY_INFORMATION.InformationBufferLength >= (Miniport->pAdapterInstanceName->Length + sizeof(WCHAR)))
        {
            PUCHAR  p = Request->DATA.QUERY_INFORMATION.InformationBuffer;

            NdisMoveMemory(p,
                           Miniport->pAdapterInstanceName->Buffer,
                           Miniport->pAdapterInstanceName->Length);
            *(PWCHAR)(p + Miniport->pAdapterInstanceName->Length) = 0;
            Request->DATA.QUERY_INFORMATION.BytesWritten = 
            Request->DATA.QUERY_INFORMATION.BytesNeeded = Miniport->pAdapterInstanceName->Length + sizeof(WCHAR);
            Status = NDIS_STATUS_SUCCESS;
        }
        break;

      default:
        //
        //  We don't filter this request, just pass it down to the driver.
        //
        MINIPORT_QUERY_INFO(Miniport, Request, &Status);
        break;
    }

    return(Status);
}


VOID
FASTCALL
ndisMSyncQueryInformationComplete(
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  NDIS_STATUS             Status
    )
/*++

Routine Description:

    This routine will process a query information complete. This is only
    called from the wrapper.  The difference is that this routine will not
    call ndisMProcessDeferred() after processing the completion of the query.

Arguments:

Return Value:

--*/
{
    PNDIS_REQUEST           Request;
    PNDIS_OPEN_BLOCK        Open;
    PNDIS_REQUEST_RESERVED  ReqRsvd;

    DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
        ("==>ndisMSyncQueryInformationComplete\n"));

    //
    //  Clear the timeout flag and the request_in_process flag.
    //
    MINIPORT_CLEAR_FLAG(Miniport, (fMINIPORT_REQUEST_TIMEOUT | fMINIPORT_PROCESSING_REQUEST));
    Miniport->CFHangXTicks = 0;

    //
    //  Remove the request.
    //
    Request = Miniport->PendingRequest;
    ASSERT(Request != NULL);
    ReqRsvd = PNDIS_RESERVED_FROM_PNDIS_REQUEST(Request);
    Miniport->PendingRequest = ReqRsvd->Next;
    ReqRsvd->Flags |= REQST_COMPLETED;

    Open = ReqRsvd->Open;
    ASSERT ((ReqRsvd->Flags & REQST_LAST_RESTORE) != REQST_LAST_RESTORE);

    DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
            ("ndisMSyncQueryInformaitonComplete: Request 0x%x, Oid 0x%x\n", Request, Request->DATA.QUERY_INFORMATION.Oid));

    //
    //  Was this an internal request?
    //
    if (Open != NULL)
    {
        //
        //  Do any necessary post-processing on the query.
        //
        if (Request->DATA.QUERY_INFORMATION.Oid == OID_GEN_SUPPORTED_LIST)
        {
            //
            //  Was this a query for the size of the list?
            //
            if (NDIS_STATUS_SUCCESS == Status)
            {
                //
                //  Filter out the statistics oids.
                //
                // ndisMFilterOutStatisticsOids(Miniport, Request);
            }
            else
            {
                if ((NULL == Request->DATA.QUERY_INFORMATION.InformationBuffer) ||
                    (0 == Request->DATA.QUERY_INFORMATION.InformationBufferLength))
                {
#if ARCNET
                    //
                    //  If this is ARCnet running encapsulated ethernet then
                    //  we need to add a couple of OIDs to be safe.
                    //
                    if ((Miniport->MediaType == NdisMediumArcnet878_2) &&
                        MINIPORT_TEST_FLAG(PNDIS_RESERVED_FROM_PNDIS_REQUEST(Request)->Open,
                                           fMINIPORT_OPEN_USING_ETH_ENCAPSULATION))
                    {
                        Request->DATA.QUERY_INFORMATION.BytesNeeded += (ARC_NUMBER_OF_EXTRA_OIDS * sizeof(NDIS_OID));
                    }
#endif
                }
                Request->DATA.QUERY_INFORMATION.BytesWritten = 0;
            }
        }
        else if (Request->DATA.QUERY_INFORMATION.Oid == OID_PNP_CAPABILITIES)
        {
            if ((Status == NDIS_STATUS_SUCCESS) &&
                !(MINIPORT_TEST_FLAG(Miniport, fMINIPORT_INTERMEDIATE_DRIVER)))
            {
                //
                // setup the WOL flag
                //
                ((PNDIS_PNP_CAPABILITIES)Request->DATA.QUERY_INFORMATION.InformationBuffer)->Flags = Miniport->PMCapabilities.Flags;
            }
        }
        else if (Request->DATA.QUERY_INFORMATION.Oid == OID_GEN_MAC_OPTIONS)
        {
            if (Status == NDIS_STATUS_SUCCESS)
            {
                *((PULONG)Request->DATA.QUERY_INFORMATION.InformationBuffer) |= (Miniport->MacOptions & NDIS_MAC_OPTION_SUPPORTS_MAC_ADDRESS_OVERWRITE);
                
            }
        }

        //
        // Indicate to Protocol;
        //
        DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
                ("Open 0x%x\n", Open));

        NDIS_RELEASE_MINIPORT_SPIN_LOCK_DPC(Miniport);

        (Open->RequestCompleteHandler)(Open->ProtocolBindingContext,
                                       Request,
                                       Status);

        NDIS_ACQUIRE_MINIPORT_SPIN_LOCK_DPC(Miniport);

        ndisMDereferenceOpen(Open);
    }
    else
    {
        PNDIS_COREQ_RESERVED    CoReqRsvd;

        DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
                ("Completing Internal Request\n"));

        //
        //  The CoReqRsvd portion of the request contains ndis only
        //  information about the request.
        //
        CoReqRsvd = PNDIS_COREQ_RESERVED_FROM_REQUEST(Request);
        CoReqRsvd->Status = Status;
         
        //
        // Do post processing for media-connect query
        //
        if ((Miniport->MediaRequest == Request) && (Status == NDIS_STATUS_SUCCESS))
        {
            BOOLEAN NowConnected = (*(PULONG)(Request->DATA.QUERY_INFORMATION.InformationBuffer) == NdisMediaStateConnected);
    
            ASSERT (Request->DATA.QUERY_INFORMATION.Oid == OID_GEN_MEDIA_CONNECT_STATUS);
            if (NowConnected ^ MINIPORT_TEST_FLAGS(Miniport, fMINIPORT_MEDIA_CONNECTED))
            {
                NDIS_RELEASE_MINIPORT_SPIN_LOCK_DPC(Miniport);
                NdisMIndicateStatus(Miniport,
                                    NowConnected ?
                                        NDIS_STATUS_MEDIA_CONNECT : NDIS_STATUS_MEDIA_DISCONNECT,
                                    INTERNAL_INDICATION_BUFFER,
                                    INTERNAL_INDICATION_SIZE);
                NdisMIndicateStatusComplete(Miniport);
                NDIS_ACQUIRE_MINIPORT_SPIN_LOCK_DPC(Miniport);
            }
        }

        //
        //  Do we need to signal anyone?
        //
        if ((ReqRsvd->Flags & REQST_SIGNAL_EVENT) == REQST_SIGNAL_EVENT)
        {
            SET_EVENT(&CoReqRsvd->Event);
        }
        else if ((ReqRsvd->Flags & REQST_FREE_REQUEST) == REQST_FREE_REQUEST)
        {
            ndisMFreeInternalRequest(Request);
        }
    }

    //
    // if we are removing the miniport, we have to signal an event
    // when all requests are completed
    //
    if (Miniport->PendingRequest == NULL)
    {
        if (Miniport->AllRequestsCompletedEvent)
            SET_EVENT(Miniport->AllRequestsCompletedEvent);
    }
    
    DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
        ("<==ndisMSyncQueryInformationComplete\n"));
}

VOID
NdisMQueryInformationComplete(
    IN  NDIS_HANDLE             MiniportAdapterHandle,
    IN  NDIS_STATUS             Status
    )
/*++

Routine Description:

    This function indicates the completion of a query information operation.

Arguments:

    MiniportAdapterHandle - points to the adapter block.

    Status - Status of the operation

Return Value:

    None.


--*/
{
    PNDIS_MINIPORT_BLOCK    Miniport = (PNDIS_MINIPORT_BLOCK)MiniportAdapterHandle;
    KIRQL                   OldIrql;

    ASSERT_MINIPORT_LOCKED(Miniport);

    DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
        ("==>ndisMQueryInformationComplete\n"));

    //
    //  If there is no request then we assume this is a complete that was
    //  aborted due to the heart-beat.
    //
    if (!MINIPORT_TEST_FLAG(Miniport, fMINIPORT_PROCESSING_REQUEST))
    {
        DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
            ("ndisMQueryInformationComplete: No request to complete\n"));


        DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
            ("<==ndisMQueryInformationComplete\n"));

        return;
    }

    NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Miniport, &OldIrql);

    DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
            ("Enter query information complete\n"));

    //
    //  Do the actual processing of the query information complete.
    //
    ndisMSyncQueryInformationComplete(Miniport, Status);

    //
    //  Are there more requests pending?
    //
    if (Miniport->PendingRequest != NULL)
    {
        NDISM_QUEUE_WORK_ITEM(Miniport, NdisWorkItemRequest, NULL);
    }

    NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);

    DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
        ("<==ndisMQueryInformationComplete\n"));
}


NDIS_STATUS
FASTCALL
ndisMQueryCurrentPacketFilter(
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  PNDIS_REQUEST           Request
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    ULONG       PacketFilter;
    NDIS_HANDLE FilterHandle;
    NDIS_STATUS Status;

    DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
        ("==>ndisMQueryCurrentPacketFilter\n"));

    //
    //  Verify the buffer that was passed to us.
    //
    VERIFY_QUERY_PARAMETERS(Request, sizeof(PacketFilter), Status);
    if (Status != NDIS_STATUS_SUCCESS)
    {
        DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
            ("<==ndisMQueryCurrentPacketFilter: 0x%x\n", Status));

        return(Status);
    }

    //
    //  Get the filter handle from the open block.
    //
    FilterHandle = PNDIS_RESERVED_FROM_PNDIS_REQUEST(Request)->Open->FilterHandle;

    //
    //  Get the packet filter from the filter library.
    //
    switch (Miniport->MediaType)
    {
        case NdisMedium802_3:
            PacketFilter = ETH_QUERY_PACKET_FILTER(Miniport->EthDB, FilterHandle);
            break;

        case NdisMedium802_5:
            PacketFilter = TR_QUERY_PACKET_FILTER(Miniport->TrDB, FilterHandle);
            break;

        case NdisMediumFddi:
            PacketFilter = FDDI_QUERY_PACKET_FILTER(Miniport->FddiDB, FilterHandle);
            break;

#if ARCNET
        case NdisMediumArcnet878_2:
            if (MINIPORT_TEST_FLAG(
                    PNDIS_RESERVED_FROM_PNDIS_REQUEST(Request)->Open,
                    fMINIPORT_OPEN_USING_ETH_ENCAPSULATION))
            {
                PacketFilter = ETH_QUERY_PACKET_FILTER(Miniport->EthDB, FilterHandle);
            }
            else
            {
                PacketFilter = ARC_QUERY_PACKET_FILTER(Miniport->ArcDB, FilterHandle);
            }
            break;
#endif
    }

    //
    //  Place the packet filter in the buffer that was passed in.
    //
    *(UNALIGNED ULONG *)(Request->DATA.QUERY_INFORMATION.InformationBuffer) = PacketFilter;

    Request->DATA.QUERY_INFORMATION.BytesWritten = sizeof(PacketFilter);
    Status = NDIS_STATUS_SUCCESS;

    DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
        ("<==ndisMQueryCurrentPacketFilter: 0x%x\n", Status));

    return(Status);
}

NDIS_STATUS
FASTCALL
ndisMQueryMediaSupported(
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  PNDIS_REQUEST           Request
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    ULONG       MediaType;
    NDIS_STATUS Status;

    //
    //  Verify the size of the buffer that was passed in by the binding.
    //
    VERIFY_QUERY_PARAMETERS(Request, sizeof(MediaType), Status);
    if (Status != NDIS_STATUS_SUCCESS)
    {
        return(Status);
    }

    //
    //  Default the media type to what the miniport knows it is.
    //
    MediaType = (ULONG)Miniport->MediaType;

#if ARCNET
    //
    //  If we are doing ethernet encapsulation then lie.
    //
    if ((NdisMediumArcnet878_2 == Miniport->MediaType) &&
        MINIPORT_TEST_FLAG(PNDIS_RESERVED_FROM_PNDIS_REQUEST(Request)->Open,
                            fMINIPORT_OPEN_USING_ETH_ENCAPSULATION))
    {
        //
        //  Tell the binding that we are ethernet.
        //
        MediaType = (ULONG)NdisMedium802_3;
    }
#endif
    //
    //  Save it in the request.
    //
    *(UNALIGNED ULONG *)(Request->DATA.QUERY_INFORMATION.InformationBuffer) = MediaType;

    Request->DATA.QUERY_INFORMATION.BytesWritten = sizeof(MediaType);

    return(NDIS_STATUS_SUCCESS);
}

NDIS_STATUS
FASTCALL
ndisMQueryEthernetMulticastList(
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  PNDIS_REQUEST           Request
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    NDIS_STATUS Status;
    UINT        NumberOfAddresses;

    //
    //  call the filter library to get the list of multicast
    //  addresses for this open
    //
    EthQueryOpenFilterAddresses(&Status,
                                Miniport->EthDB,
                                PNDIS_RESERVED_FROM_PNDIS_REQUEST(Request)->Open->FilterHandle,
                                Request->DATA.QUERY_INFORMATION.InformationBufferLength,
                                &NumberOfAddresses,
                                Request->DATA.QUERY_INFORMATION.InformationBuffer);

    //
    //  If the library returned NDIS_STATUS_FAILURE then the buffer
    //  was not big enough.  So call back down to determine how
    //  much buffer space we need.
    //
    if (NDIS_STATUS_FAILURE == Status)
    {
        Request->DATA.QUERY_INFORMATION.BytesNeeded =
                    ETH_LENGTH_OF_ADDRESS *
                    EthNumberOfOpenFilterAddresses(
                        Miniport->EthDB,
                        PNDIS_RESERVED_FROM_PNDIS_REQUEST(Request)->Open->FilterHandle);

        Request->DATA.QUERY_INFORMATION.BytesWritten = 0;

        Status = NDIS_STATUS_INVALID_LENGTH;
    }
    else
    {
        Request->DATA.QUERY_INFORMATION.BytesNeeded = 0;
        Request->DATA.QUERY_INFORMATION.BytesWritten = NumberOfAddresses * ETH_LENGTH_OF_ADDRESS;
    }

    return(Status);
}

NDIS_STATUS
FASTCALL
ndisMQueryLongMulticastList(
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  PNDIS_REQUEST           Request
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    NDIS_STATUS Status;
    UINT        NumberOfAddresses;

    //
    //  Call the filter library to get the list of long
    //  multicast address for this open.
    //
    FddiQueryOpenFilterLongAddresses(&Status,
                                     Miniport->FddiDB,
                                     PNDIS_RESERVED_FROM_PNDIS_REQUEST(Request)->Open->FilterHandle,
                                     Request->DATA.QUERY_INFORMATION.InformationBufferLength,
                                     &NumberOfAddresses,
                                     Request->DATA.QUERY_INFORMATION.InformationBuffer);


    //
    //  If the library returned NDIS_STATUS_FAILURE then the buffer
    //  was not big enough.  So call back down to determine how
    //  much buffer space we need.
    //
    if (NDIS_STATUS_FAILURE == Status)
    {
        Request->DATA.QUERY_INFORMATION.BytesNeeded =
                    FDDI_LENGTH_OF_LONG_ADDRESS *
                    FddiNumberOfOpenFilterLongAddresses(
                        Miniport->FddiDB,
                        PNDIS_RESERVED_FROM_PNDIS_REQUEST(Request)->Open->FilterHandle);


        Request->DATA.QUERY_INFORMATION.BytesWritten = 0;
        Status = NDIS_STATUS_INVALID_LENGTH;
    }
    else
    {
        Request->DATA.QUERY_INFORMATION.BytesNeeded = 0;
        Request->DATA.QUERY_INFORMATION.BytesWritten = NumberOfAddresses * FDDI_LENGTH_OF_LONG_ADDRESS;
    }

    return(Status);
}

NDIS_STATUS
FASTCALL
ndisMQueryShortMulticastList(
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  PNDIS_REQUEST           Request
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    NDIS_STATUS Status;
    UINT        NumberOfAddresses;

    //
    //  Call the filter library to get the list of long
    //  multicast address for this open.
    //
    FddiQueryOpenFilterShortAddresses(&Status,
                                      Miniport->FddiDB,
                                      PNDIS_RESERVED_FROM_PNDIS_REQUEST(Request)->Open->FilterHandle,
                                      Request->DATA.QUERY_INFORMATION.InformationBufferLength,
                                      &NumberOfAddresses,
                                      Request->DATA.QUERY_INFORMATION.InformationBuffer);


    //
    //  If the library returned NDIS_STATUS_FAILURE then the buffer
    //  was not big enough.  So call back down to determine how
    //  much buffer space we need.
    //
    if (NDIS_STATUS_FAILURE == Status)
    {
        Request->DATA.QUERY_INFORMATION.BytesNeeded =
                    FDDI_LENGTH_OF_SHORT_ADDRESS *
                    FddiNumberOfOpenFilterShortAddresses(
                        Miniport->FddiDB,
                        PNDIS_RESERVED_FROM_PNDIS_REQUEST(Request)->Open->FilterHandle);

        Request->DATA.QUERY_INFORMATION.BytesWritten = 0;
        Status = NDIS_STATUS_INVALID_LENGTH;
    }
    else
    {
        Request->DATA.QUERY_INFORMATION.BytesNeeded = 0;
        Request->DATA.QUERY_INFORMATION.BytesWritten = NumberOfAddresses * FDDI_LENGTH_OF_SHORT_ADDRESS;
    }

    return(Status);
}

NDIS_STATUS
FASTCALL
ndisMQueryMaximumFrameSize(
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  PNDIS_REQUEST           Request
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    NDIS_STATUS Status;
    PULONG  pulBuffer = Request->DATA.QUERY_INFORMATION.InformationBuffer;

    VERIFY_QUERY_PARAMETERS(Request, sizeof(*pulBuffer), Status);
    if (Status != NDIS_STATUS_SUCCESS)
    {
        return(Status);
    }

#if ARCNET
    //
    //  Is this ARCnet using encapsulated ethernet?
    //
    if (Miniport->MediaType == NdisMediumArcnet878_2)
    {
        if (MINIPORT_TEST_FLAG(
            PNDIS_RESERVED_FROM_PNDIS_REQUEST(Request)->Open,
            fMINIPORT_OPEN_USING_ETH_ENCAPSULATION))
        {
            //
            // 504 - 14 (ethernet header) == 490.
            //
            *pulBuffer = ARC_MAX_FRAME_SIZE - 14;
            Request->DATA.QUERY_INFORMATION.BytesWritten = sizeof(*pulBuffer);
            return(NDIS_STATUS_SUCCESS);
        }
    }
#endif
    //
    //  Call the miniport for the information.
    //
    MINIPORT_QUERY_INFO(Miniport, Request, &Status);

    return(Status);
}

NDIS_STATUS
FASTCALL
ndisMQueryMaximumTotalSize(
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  PNDIS_REQUEST           Request
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    NDIS_STATUS Status;
    PULONG  pulBuffer = Request->DATA.QUERY_INFORMATION.InformationBuffer;

    VERIFY_QUERY_PARAMETERS(Request, sizeof(*pulBuffer), Status);
    if (Status != NDIS_STATUS_SUCCESS)
    {
        return(Status);
    }

#if ARCNET
    //
    //  Is this ARCnet using encapsulated ethernet?
    //
    if (Miniport->MediaType == NdisMediumArcnet878_2)
    {
        if (MINIPORT_TEST_FLAG(
            PNDIS_RESERVED_FROM_PNDIS_REQUEST(Request)->Open,
            fMINIPORT_OPEN_USING_ETH_ENCAPSULATION))
        {
            *pulBuffer = ARC_MAX_FRAME_SIZE;
            Request->DATA.QUERY_INFORMATION.BytesWritten = sizeof(*pulBuffer);
            return(NDIS_STATUS_SUCCESS);
        }
    }
#endif
    //
    //  Call the miniport for the information.
    //
    MINIPORT_QUERY_INFO(Miniport, Request, &Status);

    return(Status);
}

NDIS_STATUS
FASTCALL
ndisMQueryNetworkAddress(
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  PNDIS_REQUEST           Request
    )
/*++

Routine Description:

Arguments:

Return Value:

--*/
{
    NDIS_STATUS Status;
    UCHAR       Address[ETH_LENGTH_OF_ADDRESS];

    DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
        ("==>ndisMQueryNetworkAddress\n"));

    VERIFY_QUERY_PARAMETERS(Request, ETH_LENGTH_OF_ADDRESS, Status);
    if (Status != NDIS_STATUS_SUCCESS)
    {
        return(Status);
    }

#if ARCNET
    //
    //  Is this ARCnet using encapsulated ethernet?
    //
    if (Miniport->MediaType == NdisMediumArcnet878_2)
    {
        if (MINIPORT_TEST_FLAG(
            PNDIS_RESERVED_FROM_PNDIS_REQUEST(Request)->Open,
            fMINIPORT_OPEN_USING_ETH_ENCAPSULATION))
        {
            //
            //  Arcnet-to-ethernet conversion.
            //
            ZeroMemory(Address, ETH_LENGTH_OF_ADDRESS);

            Address[5] = Miniport->ArcnetAddress;

            ETH_COPY_NETWORK_ADDRESS(Request->DATA.QUERY_INFORMATION.InformationBuffer, Address);

            Request->DATA.QUERY_INFORMATION.BytesWritten = ETH_LENGTH_OF_ADDRESS;

            DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
                ("<==ndisMQueryNetworkAddress\n"));

            return(NDIS_STATUS_SUCCESS);
        }
    }
#endif

    //
    //  Call the miniport for the information.
    //
    MINIPORT_QUERY_INFO(Miniport, Request, &Status);

    DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
        ("<==ndisMQueryNetworkAddress\n"));

    return(Status);
}


NDIS_STATUS
FASTCALL
ndisMQueryWakeUpPatternList(
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  PNDIS_REQUEST           Request
    )
/*++

Routine Description:

    This routinen is executed when a client requests the list of wake-up
    patterns that are set on a given open.

Arguments:

    Miniport    -   Pointer to the miniport block of the adapter.
    Request     -   Pointer to the request.

Return Value:

    NDIS_STATUS_SUCCESS if the request is successful.
    NDIS_STATUS_PENDING if the request will complete asynchronously.
    NDIS_STATUS_FAILURE if we are unable to complete the request.

--*/
{
    PNDIS_REQUEST_RESERVED      ReqRsvd = PNDIS_RESERVED_FROM_PNDIS_REQUEST(Request);
    PNDIS_OPEN_BLOCK            Open = ReqRsvd->Open;
    PSINGLE_LIST_ENTRY          Link;
    PNDIS_PACKET_PATTERN_ENTRY  pPatternEntry;
    ULONG                       SizeNeeded = 0;
    NDIS_STATUS                 Status;
    PUCHAR                      Buffer;
    NDIS_REQUEST_TYPE           RequestType = Request->RequestType;
    ULONG                       BytesWritten = 0;
    
    DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
        ("==>ndisMQueryWakeUpPatternList\n"));

    //
    //  Go through the pattern list and determine the size of the buffer
    //  that is needed for the query.
    //
    for (Link = Miniport->PatternList.Next; Link != NULL; Link = Link->Next)
    {
        //
        //  Get a pointer to the pattern.
        //
        pPatternEntry = CONTAINING_RECORD(
                            Link,
                            NDIS_PACKET_PATTERN_ENTRY,
                            Link);

        //
        //  Is this pattern for the correct open block? or is the request
        //  for global statistics?
        //
        if ((pPatternEntry->Open == Open) ||
            (RequestType == NdisRequestQueryStatistics))
        {
            //
            //  Add the size of the pattern to the total size.
            //
            SizeNeeded += (sizeof(NDIS_PM_PACKET_PATTERN) +
                            pPatternEntry->Pattern.MaskSize +
                            pPatternEntry->Pattern.PatternSize);
        }
    }

    //
    //  Verify the buffer that was passed us.
    //
    VERIFY_QUERY_PARAMETERS(Request, SizeNeeded, Status);
    if (NDIS_STATUS_SUCCESS == Status)
    {
        //
        //  Get a temp pointer to the InformationBuffer.
        //
        Buffer = Request->DATA.QUERY_INFORMATION.InformationBuffer;

        //
        //  Loop through again and copy the patterns into the information
        //  buffer.
        //
        for (Link = Miniport->PatternList.Next; Link != NULL; Link = Link->Next)
        {
            //
            //  Get a pointer to the pattern.
            //
            pPatternEntry = CONTAINING_RECORD(
                                Link,
                                NDIS_PACKET_PATTERN_ENTRY,
                                Link);
    
            //
            //  Is this pattern for the correct open block? or is the request
            //  for global statistics?
            //
            if ((pPatternEntry->Open == Open) ||
                (RequestType == NdisRequestQueryStatistics))
            {
                //
                //  Get the size of the pattern that needs to be copied.
                //
                SizeNeeded = (sizeof(NDIS_PM_PACKET_PATTERN) +
                                pPatternEntry->Pattern.MaskSize +
                                pPatternEntry->Pattern.PatternSize);

                //
                //  Copy the packet pattern to the buffer.
                //
                NdisMoveMemory(Buffer, &pPatternEntry->Pattern, SizeNeeded);

                //
                //  Increment the Buffer to the place to start copying next.
                //
                Buffer += SizeNeeded;
                BytesWritten += SizeNeeded;
            }
        }
    }

    Request->DATA.QUERY_INFORMATION.BytesWritten = BytesWritten;
    
    DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
        ("<==ndisMQueryWakeUpPatternList\n"));
    
    return(Status);
}

NDIS_STATUS
FASTCALL
ndisMQueryEnableWakeUp(
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  PNDIS_REQUEST           Request
    )
/*++

Routine Description:

    This routine will process the query information for the
    OID_PNP_ENABLE_WAKE_UP.  This is a bit mask that defines what will generate
    a wake-up event.  This is set on an open basis but when it's passed down
    to the miniport it is the bit wise or of all opens on the miniport.

Arguments:

    Miniport    -   Pointer to the adapter's miniport block.
    Request     -   Pointer to the request block describing the OID.

Return Value:

    NDIS_STATUS_SUCCESS if the set is successful.

--*/
{
    PNDIS_REQUEST_RESERVED  ReqRsvd = PNDIS_RESERVED_FROM_PNDIS_REQUEST(Request);
    NDIS_STATUS             Status;
    PULONG                  pEnableWakeUp;

    DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
        ("==>ndisMQueryEnableWakeUp\n"));

    //
    //  Verify that we have enough room in the information buffer.
    //
    VERIFY_QUERY_PARAMETERS(Request, sizeof(ULONG), Status);
    if (NDIS_STATUS_SUCCESS == Status)
    {
        //
        //  Get a pointer to the information buffer as a PULONG.
        //
        pEnableWakeUp = (PULONG)Request->DATA.QUERY_INFORMATION.InformationBuffer;

        //
        //  Store the currently enabled wake-up's with the request buffer.
        //
        *pEnableWakeUp = ReqRsvd->Open->WakeUpEnable;

        //
        //  Finish the request.
        //
        Request->DATA.QUERY_INFORMATION.BytesWritten = sizeof(ULONG);
        Request->DATA.QUERY_INFORMATION.BytesNeeded = 0;
    }

    DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_INFO,
        ("<==ndisMQueryEnableWakeUp\n"));

    return(Status);
}


VOID
FASTCALL
ndisMRestoreFilterSettings(
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  PNDIS_OPEN_BLOCK        Open OPTIONAL,
    IN  BOOLEAN                 fReset
    )
/*++

Routine Description:

    This routine will build request's to send down to the driver to
    restore the filter settings.  we have free run of the request queue
    since we just reset it.

Arguments:
    Miniport
    Open: Optional. set when the restore is the result of an adapter getting closed
    fReset: flag to specify if we are restoreing filters as a result of resetting the adapter
    

Return Value:
    None

Comments:
    called with Miniport's Spinlock held.
--*/
{
    PNDIS_REQUEST           LastRequest = NULL, Request = NULL;
    NDIS_STATUS             Status = NDIS_STATUS_SUCCESS;
    ULONG                   PacketFilter;
    UINT                    NumberOfAddresses;
    UINT                    FunctionalAddress;
    UINT                    GroupAddress;
    BOOLEAN                 fSetPacketFilter = TRUE;

    do
    {
        //
        //  Get the packet filter for the media type.
        //
        switch (Miniport->MediaType)
        {
            case NdisMedium802_3:
                PacketFilter = ETH_QUERY_FILTER_CLASSES(Miniport->EthDB);
                break;
    
            case NdisMedium802_5:
                PacketFilter = TR_QUERY_FILTER_CLASSES(Miniport->TrDB);
                break;
    
            case NdisMediumFddi:
                PacketFilter = FDDI_QUERY_FILTER_CLASSES(Miniport->FddiDB);
                break;
#if ARCNET
            case NdisMediumArcnet878_2:
                PacketFilter = ARC_QUERY_FILTER_CLASSES(Miniport->ArcDB);
                PacketFilter |= ETH_QUERY_FILTER_CLASSES(Miniport->EthDB);
        
                if (MINIPORT_TEST_FLAG(
                        Miniport,
                        fMINIPORT_ARCNET_BROADCAST_SET) ||
                    (PacketFilter & NDIS_PACKET_TYPE_MULTICAST))
                {
                    PacketFilter &= ~NDIS_PACKET_TYPE_MULTICAST;
                    PacketFilter |= NDIS_PACKET_TYPE_BROADCAST;
                }
                break;
#endif
            default:
                fSetPacketFilter = FALSE;
                break;
        }
    
        //
        //  If the media in question needs it then set the packet filter.
        //
        if (fSetPacketFilter)
        {
            //
            //  Allocate a request to restore the packet filter.
            //
            Status = ndisMAllocateRequest(&Request,
                                          OID_GEN_CURRENT_PACKET_FILTER,
                                          &PacketFilter,
                                          sizeof(PacketFilter));
            if (Status != NDIS_STATUS_SUCCESS)
            {
                break;
            }
        
            SET_INTERNAL_REQUEST(Request, Open, REQST_FREE_REQUEST);
            LastRequest = Request;
        
            ndisMQueueRequest(Miniport, Request);
        }
    
        //
        //  Now build media dependant requests.
        //
        switch (Miniport->MediaType)
        {
          case NdisMedium802_3:

            ///
            //  For ethernet we need to restore the multicast address list.
            ///
    
            //
            //  Get a list of all the multicast address that need
            //  to be set.
            //
            NumberOfAddresses = ethNumberOfGlobalAddresses(Miniport->EthDB);
    
            //
            //  Allocate a request to restore the multicast address list.
            //
            Status = ndisMAllocateRequest(&Request,
                                          OID_802_3_MULTICAST_LIST,
                                          NULL,
                                          NumberOfAddresses * ETH_LENGTH_OF_ADDRESS);
    
            if (Status != NDIS_STATUS_SUCCESS)
            {
                break;
            }
    
            EthQueryGlobalFilterAddresses(&Status,
                                          Miniport->EthDB,
                                          NumberOfAddresses * ETH_LENGTH_OF_ADDRESS,
                                          &NumberOfAddresses,
                                          (PVOID)(Request + 1));
        
            //
            //  Does the internal request have an open associated with it?
            //
            SET_INTERNAL_REQUEST(Request, Open, REQST_FREE_REQUEST);
            LastRequest = Request;
            
            ndisMQueueRequest(Miniport, Request);
            break;

          case NdisMedium802_5:

            ///
            //  For token ring we need to restore the functional address
            //  and the group address.
            ///
    
            //
            //  Get the current functional address from the filter
            //  library.
            //
            FunctionalAddress = BYTE_SWAP_ULONG(TR_QUERY_FILTER_ADDRESSES(Miniport->TrDB));
    
            //
            //  Allocate a request to restore the functional address.
            //
            Status = ndisMAllocateRequest(&Request,
                                          OID_802_5_CURRENT_FUNCTIONAL,
                                          &FunctionalAddress,
                                          sizeof(FunctionalAddress));
            if (Status != NDIS_STATUS_SUCCESS)
            {
                break;
            }

            //
            //  Does the internal request have an open associated with it?
            //
            SET_INTERNAL_REQUEST(Request, Open, REQST_FREE_REQUEST);
            LastRequest = Request;
        
            ndisMQueueRequest(Miniport, Request);

            //
            //  Get the current group address from the filter library.
            //
            GroupAddress = BYTE_SWAP_ULONG(TR_QUERY_FILTER_GROUP(Miniport->TrDB));
    
            //
            //  Allocate a request to restore the group address.
            //
            Status = ndisMAllocateRequest(&Request,
                                          OID_802_5_CURRENT_GROUP,
                                          &GroupAddress,
                                          sizeof(GroupAddress));
            if (Status != NDIS_STATUS_SUCCESS)
            {
                break;
            }

            //
            //  Does the internal request have an open associated with it?
            //
            SET_INTERNAL_REQUEST(Request, Open, REQST_FREE_REQUEST);
            LastRequest = Request;
        
            ndisMQueueRequest(Miniport, Request);
            break;

          case NdisMediumFddi:

            //
            //  For FDDI we need to restore the long multicast address
            //  list and the short multicast address list.
            //
    
            //
            //  Get the number of multicast addresses and the list
            //  of multicast addresses to send to the miniport driver.
            //
            NumberOfAddresses = fddiNumberOfLongGlobalAddresses(Miniport->FddiDB);
    
            //
            //  Allocate a request to restore the long multicast address list.
            //
            Status = ndisMAllocateRequest(&Request,
                                          OID_FDDI_LONG_MULTICAST_LIST,
                                          NULL,
                                          NumberOfAddresses * FDDI_LENGTH_OF_LONG_ADDRESS);
            if (Status != NDIS_STATUS_SUCCESS)
            {
                break;
            }
    
            FddiQueryGlobalFilterLongAddresses(&Status,
                                               Miniport->FddiDB,
                                               NumberOfAddresses * FDDI_LENGTH_OF_LONG_ADDRESS,
                                               &NumberOfAddresses,
                                               (PVOID)(Request + 1));
    
            //
            //  Does the internal request have an open associated with it?
            //
            SET_INTERNAL_REQUEST(Request, Open, REQST_FREE_REQUEST);
            LastRequest = Request;
            
            ndisMQueueRequest(Miniport, Request);
    
            //
            //  Get the number of multicast addresses and the list
            //  of multicast addresses to send to the miniport driver.
            //
            NumberOfAddresses = fddiNumberOfShortGlobalAddresses(Miniport->FddiDB);

            //
            //  Allocate a request to restore the short multicast address list.
            //
            if (FDDI_FILTER_SUPPORTS_SHORT_ADDR(Miniport->FddiDB))
            {
                Status = ndisMAllocateRequest(&Request,
                                              OID_FDDI_SHORT_MULTICAST_LIST,
                                              NULL,
                                              NumberOfAddresses * FDDI_LENGTH_OF_SHORT_ADDRESS);
                if (Status != NDIS_STATUS_SUCCESS)
                {
                    break;
                }
    
                FddiQueryGlobalFilterShortAddresses(&Status,
                                                    Miniport->FddiDB,
                                                    NumberOfAddresses * FDDI_LENGTH_OF_SHORT_ADDRESS,
                                                    &NumberOfAddresses,
                                                    (PVOID)(Request + 1));
        
                //
                //  Does the internal request have an open associated with it?
                //
                SET_INTERNAL_REQUEST(Request, Open, REQST_FREE_REQUEST);
                LastRequest = Request;
            
                ndisMQueueRequest(Miniport, Request);
            }
            break;

#if ARCNET
          case NdisMediumArcnet878_2:
    
                //
                //  Only the packet filter is restored for arcnet and
                //  that was done above.
                //
                Status = NDIS_STATUS_SUCCESS;
                break;
#endif
        }
    
        if (NDIS_STATUS_SUCCESS != Status)
        {
            break;
        }

        //
        //  Do we need to update the miniports enabled wake-up states?
        //  Or remove any packet patterns?
        //
        {
            PNDIS_OPEN_BLOCK            tmpOpen;
            ULONG                       newWakeUpEnable;
            PSINGLE_LIST_ENTRY          Link;
            PNDIS_PACKET_PATTERN_ENTRY  pPatternEntry;

            //
            // preserve the state of NDIS_PNP_WAKE_UP_MAGIC_PACKET and NDIS_PNP_WAKE_UP_LINK_CHANGE flag
            //
            newWakeUpEnable = Miniport->WakeUpEnable & (NDIS_PNP_WAKE_UP_MAGIC_PACKET | NDIS_PNP_WAKE_UP_LINK_CHANGE);

            //
            //  If we are restoring the filter settings for a NdisCloseAdapter and not a reset
            //  then we need to remove the packet patterns that were added by the open.
            //
            if (!fReset && (Open != NULL))
            {
                //
                //  Find any packet patterns that were added for the open.
                //  Build and queue a request to remove these.
                //
                for (Link = Miniport->PatternList.Next;
                     Link != NULL;
                     Link = Link->Next)
                {
                    //
                    //  Get a pointer to the pattern entry.
                    //
                    pPatternEntry = CONTAINING_RECORD(Link,
                                                      NDIS_PACKET_PATTERN_ENTRY,
                                                      Link);
    
                    //
                    //  Does this pattern belong to the open?
                    //
                    if (pPatternEntry->Open == Open)
                    {
                        //
                        //  Build a request to remove it.
                        //
                        Status = ndisMAllocateRequest(&Request,
                                                      OID_PNP_REMOVE_WAKE_UP_PATTERN,
                                                      &pPatternEntry->Pattern,
                                                      sizeof(NDIS_PM_PACKET_PATTERN) +
                                                            pPatternEntry->Pattern.MaskSize +
                                                            pPatternEntry->Pattern.PatternSize);
    
    
                        if (NDIS_STATUS_SUCCESS != Status)
                        {
                            break;
                        }
    
                        SET_INTERNAL_REQUEST(Request, Open, REQST_FREE_REQUEST);
                    
                        ndisMQueueRequest(Miniport, Request);
                    }
                }
            }
            else
            {
                //
                //  This routine was called for a reset.  Walk the open queue and
                //  re-add the packet patterns.
                //
                //
                //  Find any packet patterns that were added for the open.
                //  Build and queue a request to remove these.
                //
                for (Link = Miniport->PatternList.Next;
                     Link != NULL;
                     Link = Link->Next)
                {
                    //
                    //  Get a pointer to the pattern entry.
                    //
                    pPatternEntry = CONTAINING_RECORD(
                                        Link,
                                        NDIS_PACKET_PATTERN_ENTRY,
                                        Link);
    
                    //
                    //  Build a request to remove it.
                    //
                    Status = ndisMAllocateRequest(&Request,
                                                  OID_PNP_ADD_WAKE_UP_PATTERN,
                                                  &pPatternEntry->Pattern,
                                                  sizeof(NDIS_PM_PACKET_PATTERN) +
                                                    pPatternEntry->Pattern.MaskSize +
                                                    pPatternEntry->Pattern.PatternSize);
    
                    if (NDIS_STATUS_SUCCESS != Status)
                    {
                        break;
                    }
    
                    SET_INTERNAL_REQUEST(Request, Open, REQST_FREE_REQUEST);
                    LastRequest = Request;

                    ndisMQueueRequest(Miniport, Request);
                }
            }

            if (NDIS_STATUS_SUCCESS != Status)
            {
                break;
            }
    
            //
            //  Determine the wake-up enable bits.
            //
            for (tmpOpen = Miniport->OpenQueue;
                 tmpOpen != NULL;
                 tmpOpen = tmpOpen->MiniportNextOpen)
            {
                //
                //  If the Open is being closed then we don't want to include
                //  it's wake-up bits.  If the adapter is being reset then
                //  Open will be NULL and we will get all of the open's wake-up
                //  bits.
                //
                if (Open != tmpOpen)
                {
                    newWakeUpEnable |= tmpOpen->WakeUpEnable;
                }
            }
    
            //
            //  Is this different that what is currently set on the adapter?
            //
            if (newWakeUpEnable != Miniport->WakeUpEnable)
            {
                //
                //  Allocate a request and queue it up!
                //
                Status = ndisMAllocateRequest(&Request,
                                              OID_PNP_ENABLE_WAKE_UP,
                                              &newWakeUpEnable,
                                              sizeof(newWakeUpEnable));
                if (NDIS_STATUS_SUCCESS != Status)
                {
                    break;
                }
    
                //
                //  Does the internal request have an open associated with it?
                //
                SET_INTERNAL_REQUEST(Request, Open, REQST_FREE_REQUEST);
                LastRequest = Request;
            
                ndisMQueueRequest(Miniport, Request);
            }
        }
    } while (FALSE);

    //
    //  Mark the last request that was queued as the last request needed to restore the filter.
    //
    if (fReset && (LastRequest != NULL))
    {
        PNDIS_RESERVED_FROM_PNDIS_REQUEST(LastRequest)->Flags |= REQST_LAST_RESTORE;
        MINIPORT_SET_FLAG(Miniport, fMINIPORT_RESTORING_FILTERS);
    }

    if (NULL != Miniport->PendingRequest)
    {
        NDISM_QUEUE_WORK_ITEM(Miniport, NdisWorkItemRequest, NULL);
    }
}


VOID
ndisMPollMediaState(
    IN  PNDIS_MINIPORT_BLOCK            Miniport
    )
/*++

Routine Description:
    Polls the media connect state for miniports that need to be polled.

Arguments:
    Miniport    Pointer to the miniport block

Return Value:
    None.

Comments: 
    called at DPC with Miniport's SpinLock held.

--*/
{
    PNDIS_REQUEST_RESERVED  ReqRsvd;

    ASSERT(Miniport->MediaRequest != NULL);

    //
    // Make sure the previously queued internal request is complete
    //
    ReqRsvd = PNDIS_RESERVED_FROM_PNDIS_REQUEST(Miniport->MediaRequest);
    if ((ReqRsvd->Flags & REQST_COMPLETED) &&
        (Miniport->PnPDeviceState == NdisPnPDeviceStarted))
    {
        SET_INTERNAL_REQUEST_NULL_OPEN(Miniport->MediaRequest, 0);
        ndisMQueueRequest(Miniport, Miniport->MediaRequest);
    
        if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_DESERIALIZE))
        {
            ndisMDoRequests(Miniport);
        }
        else
        {
            NDISM_QUEUE_WORK_ITEM(Miniport, NdisWorkItemRequest, NULL);
        }
    }
}



BOOLEAN
FASTCALL
ndisMQueueRequest(
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  PNDIS_REQUEST           Request
    )
/*++

Routine Description:
    checks to make sure the request is not already queued on miniport
    and if it is not, it queues the request on miniport's PendingRequest queue.

Arguments:
    Miniport
    Request

Return Value:
    TRUE if the request was successfully queued on the miniport
    FALSE is the request is already queued.
    
Comments:
    called at DPC with Miniport's SpinLock held.

--*/
{
    PNDIS_REQUEST   *ppReq;
    BOOLEAN         rc;
    
    PNDIS_RESERVED_FROM_PNDIS_REQUEST(Request)->Next = NULL;

    for (ppReq = &Miniport->PendingRequest;
         *ppReq != NULL;
         NOTHING)
    {
        ASSERT (*ppReq != Request);
        
        if (*ppReq == Request)
        {
            break;
        }
        ppReq = &(PNDIS_RESERVED_FROM_PNDIS_REQUEST(*ppReq))->Next;
    }

    if (*ppReq != Request)
    {
        *ppReq = Request;

        rc = TRUE;
    }
    else
    {
        rc = FALSE;
    }

    return(rc);
}


NDIS_STATUS
ndisMAllocateRequest(
    OUT PNDIS_REQUEST   *       pRequest,
    IN  NDIS_OID                Oid,
    IN  PVOID                   Buffer      OPTIONAL,
    IN  ULONG                   BufferLength
    )
/*++

Routine Description:

    This routine will allocate a request to be used as an internal request.

Arguments:

    Request     - Will contain a pointer to the new request on exit.
    RequestType - Type of ndis request.
    Oid         - Request identifier.
    Buffer      - Pointer to the buffer for the request.
    BufferLength- Length of the buffer.

Return Value:

    NDIS_STATUS_SUCCESS if the request allocation succeeded.
    NDIS_STATUS_FAILURE otherwise.

--*/
{
    PNDIS_REQUEST   Request;

    //
    //  Allocate the request structure.
    //
    Request = (PNDIS_REQUEST)ALLOC_FROM_POOL(sizeof(NDIS_REQUEST) + BufferLength,
                                             NDIS_TAG_Q_REQ);
    if (NULL == Request)
    {
        *pRequest = NULL;
        return(NDIS_STATUS_RESOURCES);
    }

    //
    //  Zero out the request.
    //
    ZeroMemory(Request, sizeof(NDIS_REQUEST) + BufferLength);
    INITIALIZE_EVENT(&(PNDIS_COREQ_RESERVED_FROM_REQUEST(Request)->Event));

    Request->RequestType = NdisRequestSetInformation;

    //
    //  Copy the buffer that was passed to us into the new buffer.
    //
    Request->DATA.SET_INFORMATION.Oid = Oid;
    Request->DATA.SET_INFORMATION.InformationBuffer = Request + 1;
    Request->DATA.SET_INFORMATION.InformationBufferLength = BufferLength;
    if (Buffer != NULL)
    {
        MoveMemory(Request + 1, Buffer, BufferLength);
    }

    //
    //  Give it back to the caller.
    //
    *pRequest = Request;

    return(NDIS_STATUS_SUCCESS);
}

NDIS_STATUS
FASTCALL
ndisMDispatchRequest(
    IN  PNDIS_MINIPORT_BLOCK        Miniport,
    IN  PNDIS_REQUEST               Request,
    IN  BOOLEAN                     fQuery
    )
/*++

Routine Description:
    all requests directed to drivers go through this function. except those made
    to NdisCoRequest.

Arguments:
    

Return Value:

Note:
    Called at DPC with Miniport's lock held.

--*/
{
    PNDIS_OPEN_BLOCK    Open;
    NDIS_STATUS         Status;
    KIRQL               OldIrql;

    do
    {

        //
        // for deserialized drivers, if the device has been handed a reset and the reset call 
        // has not come back or completed, then abort this request
        //

        if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_DESERIALIZE))
        {
            if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_CALLING_RESET))
            {
                Status = NDIS_STATUS_RESET_IN_PROGRESS;
                break;
            }
        }
        
        //
        // if the device is sleep or about to sleep, block all user mode requests except the power ones
        //
        if ((Request->RequestType == NdisRequestQueryStatistics) &&
            ((MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_SYSTEM_SLEEPING)) ||
             (Miniport->CurrentDevicePowerState > PowerDeviceD0)))
        {
                Status = STATUS_DEVICE_POWERED_OFF;
                break;
        }
        
        if ((MINIPORT_PNP_TEST_FLAG(Miniport, fMINIPORT_DEVICE_FAILED | fMINIPORT_REJECT_REQUESTS)) ||
            ((Miniport->CurrentDevicePowerState > PowerDeviceD0) && (Request->DATA.SET_INFORMATION.Oid != OID_PNP_SET_POWER)))
        {
            Status = fQuery ? NDIS_STATUS_FAILURE : NDIS_STATUS_SUCCESS;
            break;
        }

        //
        // Satisfy this request right away
        //
        if ((Request->RequestType == NdisRequestSetInformation) &&
            (Request->DATA.QUERY_INFORMATION.Oid == OID_GEN_INIT_TIME_MS))
        {
            PULONG  InitTime = (PULONG)(Request->DATA.SET_INFORMATION.InformationBuffer);

            *InitTime = Miniport->InitTimeMs;
            Request->DATA.QUERY_INFORMATION.BytesWritten = sizeof(ULONG);
            Request->DATA.QUERY_INFORMATION.BytesNeeded = sizeof(ULONG);
            Status = NDIS_STATUS_SUCCESS;
            break;
        }

        //
        // If this was a request to turn p-mode/l-only on/off then mark things appropriately
        //  This should be moved to completion handler for this OID
        //
        if ((Request->RequestType == NdisRequestSetInformation) &&
            (Request->DATA.SET_INFORMATION.Oid == OID_GEN_CURRENT_PACKET_FILTER))
        {
            PULONG              Filter = (PULONG)(Request->DATA.SET_INFORMATION.InformationBuffer);

            if ((Open = PNDIS_RESERVED_FROM_PNDIS_REQUEST(Request)->Open) != NULL)
            {
                
                if (*Filter & (NDIS_PACKET_TYPE_PROMISCUOUS | NDIS_PACKET_TYPE_ALL_LOCAL))
                {
                    if ((Open->Flags & fMINIPORT_OPEN_PMODE) == 0)
                    {
                        Open->Flags |= fMINIPORT_OPEN_PMODE;
                        Miniport->PmodeOpens ++;
                        NDIS_CHECK_PMODE_OPEN_REF(Miniport);
                        ndisUpdateCheckForLoopbackFlag(Miniport);
                    }

                }
                else
                {
                    if (Open->Flags & fMINIPORT_OPEN_PMODE)
                    {
                        Open->Flags &= ~fMINIPORT_OPEN_PMODE;
                        Miniport->PmodeOpens --;
                        NDIS_CHECK_PMODE_OPEN_REF(Miniport);
                        ndisUpdateCheckForLoopbackFlag(Miniport);
                    }
                }

            }
            
            //
            //  Remove the ALL_LOCAL bit since miniport does not understand this (and does
            //  not need to).
            //
            *Filter &= ~NDIS_PACKET_TYPE_ALL_LOCAL;

        }

        if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_DESERIALIZE))
        {
            Miniport->RequestCount++;
        }
        
        NDIS_RELEASE_MINIPORT_SPIN_LOCK_DPC(Miniport);

        //
        // check to see if we need the get the protocol mutex
       

        if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_IS_CO))
        {
            PNDIS_RESERVED_FROM_PNDIS_REQUEST(Request)->Flags |= REQST_DOWNLEVEL;
            Status = (Miniport)->DriverHandle->MiniportCharacteristics.CoRequestHandler(
                        (Miniport)->MiniportAdapterContext,
                        NULL,
                        (Request));
        }
        else
        {
            
            if (fQuery)
            {
                Status = (Miniport->DriverHandle->MiniportCharacteristics.QueryInformationHandler)(
                                        Miniport->MiniportAdapterContext,
                                        Request->DATA.QUERY_INFORMATION.Oid,
                                        Request->DATA.QUERY_INFORMATION.InformationBuffer,
                                        Request->DATA.QUERY_INFORMATION.InformationBufferLength,
                                        &Request->DATA.QUERY_INFORMATION.BytesWritten,
                                        &Request->DATA.QUERY_INFORMATION.BytesNeeded);
            }
            else
            {
                Status = (Miniport->DriverHandle->MiniportCharacteristics.SetInformationHandler)(
                                        Miniport->MiniportAdapterContext,
                                        Request->DATA.SET_INFORMATION.Oid,
                                        Request->DATA.SET_INFORMATION.InformationBuffer,
                                        Request->DATA.SET_INFORMATION.InformationBufferLength,
                                        &Request->DATA.SET_INFORMATION.BytesRead,
                                        &Request->DATA.SET_INFORMATION.BytesNeeded);
            }
        }

        NDIS_ACQUIRE_MINIPORT_SPIN_LOCK_DPC(Miniport);
        
        if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_DESERIALIZE))
        {
            Miniport->RequestCount--;
        }


    } while (FALSE);

    return(Status);
}


NDIS_STATUS
ndisMFilterOutStatisticsOids(
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  PNDIS_REQUEST           Request
    )
/*++

Routine Description:

    This routine will filter out any statistics OIDs.

Arguments:

Return Value:

--*/
{
    ULONG c;
    PNDIS_OID OidList;
    ULONG TotalOids;
    ULONG CurrentDestOid;

    //
    //  Initialize some temp variables.
    //
    OidList = Request->DATA.QUERY_INFORMATION.InformationBuffer;
    TotalOids = Request->DATA.QUERY_INFORMATION.BytesWritten / sizeof(NDIS_OID);

    //
    //  Copy the information OIDs to the buffer that
    //  was passed with the original request.
    //
    for (c = 0, CurrentDestOid = 0; c < TotalOids; c++)
    {
        //
        //  Is this a statistic Oid?
        //
        if ((OidList[c] & 0x00FF0000) != 0x00020000)
        {
            OidList[CurrentDestOid++] = OidList[c];
        }
    }

#if ARCNET
    //
    //  If ARCnet then do the filtering.
    //
    if ((Miniport->MediaType == NdisMediumArcnet878_2) &&
        MINIPORT_TEST_FLAG(
            PNDIS_RESERVED_FROM_PNDIS_REQUEST(Request)->Open,
                fMINIPORT_OPEN_USING_ETH_ENCAPSULATION))
    {
        ArcConvertOidListToEthernet(OidList, &CurrentDestOid);
    }
#endif
    //
    //  Save the amount of data that was kept.
    //
    Request->DATA.QUERY_INFORMATION.BytesWritten = CurrentDestOid * sizeof(NDIS_OID);

    return(NDIS_STATUS_SUCCESS);
}


BOOLEAN
FASTCALL
ndisMCreateDummyFilters(
    IN  PNDIS_MINIPORT_BLOCK    Miniport
    )

/*++

Routine Description:

    Creates the bogus filter packages during initialization.

Arguments:

    Miniport - Pointer to the Miniport.

Return Value:

    None.

--*/
{
    UCHAR       Address[6];

    if (!EthCreateFilter(1,
                         Address,
                         &Miniport->EthDB)  ||
        !FddiCreateFilter(1,
                          1,
                          Address,
                          Address,
                          &Miniport->FddiDB)||
#if ARCNET
        !ArcCreateFilter(Miniport,
                         Address[0],
                         &Miniport->ArcDB)  ||
#endif
        !TrCreateFilter(Address,
                        &Miniport->TrDB))
        {
            if (Miniport->EthDB != NULL)
            {
                EthDeleteFilter(Miniport->EthDB);
                Miniport->EthDB = NULL;
            }

            if (Miniport->TrDB != NULL)
            {
                TrDeleteFilter(Miniport->TrDB);
                Miniport->TrDB = NULL;
            }

            if (Miniport->FddiDB != NULL)
            {
                FddiDeleteFilter(Miniport->FddiDB);
                Miniport->FddiDB = NULL;
            }

#if ARCNET
            if (Miniport->ArcDB != NULL)
            {
                ArcDeleteFilter(Miniport->ArcDB);
                Miniport->ArcDB = NULL;
            }
#endif
            return(FALSE);
        }

        Miniport->LockHandler = DummyFilterLockHandler;
        Miniport->EthDB->Miniport = Miniport;
        Miniport->FddiDB->Miniport = Miniport;
        Miniport->TrDB->Miniport = Miniport;
#if ARCNET
        Miniport->ArcDB->Miniport = Miniport;
#endif

        return(TRUE);
}

VOID
FASTCALL
ndisMAdjustFilters(
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  PFILTERDBS              FilterDB
    )

/*++

Routine Description:

    Replace the dummy filters by real ones.

Arguments:

    Miniport - Pointer to the Miniport.
    FilterDB - New valid filters

Return Value:

    None.

--*/
{
    ASSERT(Miniport->EthDB == NULL);
    ASSERT(Miniport->TrDB == NULL);
    ASSERT(Miniport->FddiDB == NULL);
#if ARCNET
    ASSERT(Miniport->ArcDB == NULL);
#endif

    Miniport->EthDB = FilterDB->EthDB;
    Miniport->TrDB = FilterDB->TrDB;
    Miniport->FddiDB = FilterDB->FddiDB;
#if ARCNET
    Miniport->ArcDB = FilterDB->ArcDB;
#endif
}

VOID
ndisMNotifyMachineName(
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  PNDIS_STRING            MachineName OPTIONAL
    )
/*++

Routine Description:

    Send an OID_GEN_MACHINE_NAME to notify the miniport of this machine's name.
    If MachineName is supplied to this routine, use it. Otherwise, read it from
    the registry.

Arguments:

    Miniport - Pointer to the Miniport.
    MachineName - if specified, the name to be sent to the miniport.

Return Value:

    None.
--*/
{
    NDIS_STRING                 RequestMachineName;
    NDIS_STRING                 HostNameKey;
    NTSTATUS                    NtStatus;
    LONG                        ErrorCode;
    RTL_QUERY_REGISTRY_TABLE    QueryTable[2];
    PUCHAR                      HostNameBuffer;

    HostNameKey.Buffer = NULL;
    HostNameBuffer = NULL;

    do
    {
        if (MachineName == NULL)
        {
            ZeroMemory(QueryTable, sizeof(QueryTable));
            ZeroMemory(&HostNameKey, sizeof(HostNameKey));

            QueryTable[0].Flags = RTL_QUERY_REGISTRY_DIRECT|
                                  RTL_QUERY_REGISTRY_REQUIRED;
            QueryTable[0].Name = L"HostName";
            QueryTable[0].EntryContext = &HostNameKey;
            QueryTable[0].DefaultType = REG_NONE;

            QueryTable[1].Name = NULL;

            NtStatus = RtlQueryRegistryValues(
                            RTL_REGISTRY_SERVICES,
                            L"\\Tcpip\\Parameters",
                            &QueryTable[0],
                            NULL,   // Context
                            NULL    // Environment
                            );
    
            if (!NT_SUCCESS(NtStatus))
            {
                DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_ERR,
                    ("ndisMNotifyMachineName: Miniport %p, registry query for %ws failed, Status %x\n",
                        Miniport, QueryTable[0].Name, NtStatus));
                break;
            }

        }
        else
        {
            HostNameKey = *MachineName;
        }

        ASSERT(HostNameKey.MaximumLength >= HostNameKey.Length);

        //
        // Copy the name into non-paged memory since the OID
        // will be sent to the miniport at raised IRQL.
        //
        HostNameBuffer = ALLOC_FROM_POOL(HostNameKey.MaximumLength, NDIS_TAG_NAME_BUF);
        if (HostNameBuffer == NULL)
        {
            DBGPRINT(DBG_COMP_REQUEST, DBG_LEVEL_ERR,
                ("ndisMNotifyMachineName: Miniport %p, failed to alloc %d bytes\n",
                    Miniport, HostNameKey.MaximumLength));
            break;
        }

        ZeroMemory(HostNameBuffer, HostNameKey.MaximumLength);
        NdisMoveMemory(HostNameBuffer, HostNameKey.Buffer, HostNameKey.Length);

        ErrorCode = ndisMDoMiniportOp(Miniport,
                                      FALSE,
                                      OID_GEN_MACHINE_NAME,
                                      HostNameBuffer,
                                      HostNameKey.Length,
                                      0x77,
                                      FALSE);

    }
    while (FALSE);

    if (MachineName == NULL)
    {
        if (HostNameKey.Buffer != NULL)
        {
            ExFreePool(HostNameKey.Buffer);
        }
    }

    if (HostNameBuffer != NULL)
    {
        FREE_POOL(HostNameBuffer);
    }
}

VOID
ndisUpdateCheckForLoopbackFlag(
    IN      PNDIS_MINIPORT_BLOCK    Miniport
    )
{
    if (Miniport->EthDB && Miniport->EthDB->SingleActiveOpen)
    {
        MINIPORT_CLEAR_FLAG(Miniport, fMINIPORT_CHECK_FOR_LOOPBACK);
    }
    else
    {
        if ((Miniport->PmodeOpens > 0) && (Miniport->NumOpens > 1))
        {
            MINIPORT_SET_FLAG(Miniport, fMINIPORT_CHECK_FOR_LOOPBACK);
        }
        else
        {
            MINIPORT_CLEAR_FLAG(Miniport, fMINIPORT_CHECK_FOR_LOOPBACK);
        }
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ndis\sys\sendm.h ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation

Module Name:

    sendm.h

Abstract:

Author:

    Kyle Brandon    (KyleB)     

Environment:

    Kernel mode

Revision History:

--*/

#ifndef __SENDM_H
#define __SENDM_H

#define SEND_PACKET_ARRAY   16

//
// The following definitions apply to serialized drivers only. Packets for the deserialized drivers are not queued
// within NDIS
//
#define PACKET_LIST(_P)     (PLIST_ENTRY)((_P)->WrapperReserved)

#define GET_FIRST_MINIPORT_PACKET(_M, _P)                                       \
    {                                                                           \
        *(_P) = NULL;                                                           \
        if (!IsListEmpty(&(_M)->PacketList))                                    \
        {                                                                       \
            PLIST_ENTRY _L;                                                     \
                                                                                \
            _L = (_M)->PacketList.Flink;                                        \
            *(_P) = CONTAINING_RECORD(_L, NDIS_PACKET, WrapperReserved);        \
        }                                                                       \
    }

//
//  Macros used for getting to OOB data and packet extension.
//
#define PNDIS_PACKET_OOB_DATA_FROM_PNDIS_PACKET(_P)                             \
                (PNDIS_PACKET_OOB_DATA)((PUCHAR)(_P) + (_P)->Private.NdisPacketOobOffset)

#define INIT_PACKET_LIST(_P)            InitializeListHead(PACKET_LIST(_P))

#define LINK_PACKET(_M, _P, _NSR, _O)                                           \
    {                                                                           \
        (_NSR)->Open = _O;                                                      \
        INIT_PACKET_LIST(_P);                                                   \
                                                                                \
        InsertTailList(&(_M)->PacketList,                                       \
                       PACKET_LIST(_P));                                        \
    }

#define LINK_WAN_PACKET(_M, _P)                                                 \
    {                                                                           \
        InitializeListHead(&(_P)->WanPacketQueue);                              \
                                                                                \
        InsertTailList(&(_M)->PacketList,                                       \
                       &(_P)->WanPacketQueue);                                  \
    }

#define UNLINK_PACKET(_M, _P, _NSR)                                             \
    {                                                                           \
        ASSERT(_P != (_M)->FirstPendingPacket);                                 \
        RemoveEntryList(PACKET_LIST(_P));                                       \
        INIT_PACKET_LIST(_P);                                                   \
    }

#define UNLINK_WAN_PACKET(_P)                                                   \
    {                                                                           \
        RemoveEntryList(&(_P)->WanPacketQueue);                                 \
        InitializeListHead(&(_P)->WanPacketQueue);                              \
    }

#if DBG
#define VALIDATE_PACKET_OPEN(_P)                                                \
    {                                                                           \
        PNDIS_STACK_RESERVED    _NSR;                                           \
                                                                                \
        NDIS_STACK_RESERVED_FROM_PACKET(_P, &_NSR);                             \
        ASSERT(VALID_OPEN(_NSR->Open));                                         \
    }
#else
#define VALIDATE_PACKET_OPEN(_P)
#endif

#define NEXT_PACKET_PENDING(_M, _P, _NSR)                                       \
    {                                                                           \
        PLIST_ENTRY             _List;                                          \
                                                                                \
        _List = PACKET_LIST(_P);                                                \
        (_M)->FirstPendingPacket = NULL;                                        \
        if (_List->Flink != &(_M)->PacketList)                                  \
        {                                                                       \
             (_M)->FirstPendingPacket =                                         \
                CONTAINING_RECORD(_List->Flink,                                 \
                                  NDIS_PACKET,                                  \
                                  WrapperReserved);                             \
            VALIDATE_PACKET_OPEN((_M)->FirstPendingPacket);                     \
        }                                                                       \
    }

#if DBG

#define CHECK_FOR_DUPLICATE_PACKET(_M, _P)                                      \
{                                                                               \
    IF_DBG(DBG_COMP_SEND, DBG_LEVEL_FATAL)                                      \
    {                                                                           \
        PLIST_ENTRY     _List;                                                  \
                                                                                \
        if (!IsListEmpty(&(_M)->PacketList))                                    \
        {                                                                       \
            PNDIS_PACKET    _Pkt;                                               \
                                                                                \
            for (_List = (_M)->PacketList.Flink;                                \
                 _List != &(_M)->PacketList;                                    \
                 _List = _List->Flink)                                          \
            {                                                                   \
                _Pkt = CONTAINING_RECORD(_List,                                 \
                                         NDIS_PACKET,                           \
                                         WrapperReserved);                      \
                if (_P == _Pkt)                                                 \
                {                                                               \
                    DBGBREAK(DBG_COMP_SEND, DBG_LEVEL_FATAL);                   \
                }                                                               \
            }                                                                   \
        }                                                                       \
    }                                                                           \
}

#else

#define CHECK_FOR_DUPLICATE_PACKET(_M, _P)

#endif

#define ADD_RESOURCE(_M, C)     MINIPORT_SET_FLAG(_M, fMINIPORT_RESOURCES_AVAILABLE)
#define CLEAR_RESOURCE(_M, C)   MINIPORT_CLEAR_FLAG(_M, fMINIPORT_RESOURCES_AVAILABLE)

#define VALID_OPEN(_O)  (((ULONG_PTR)(_O) & 0xFFFFFF00) != MAGIC_OPEN)

#define MAGIC_OPEN      'MOC\00'
#define MAGIC_OPEN_I(x) (PVOID)((MAGIC_OPEN & 0xFFFFFF00) + 0x00000030 + x)

#define CLEAR_WRAPPER_RESERVED(_NSR)    (_NSR)->RefUlong = 0

#if ARCNET

#define FREE_ARCNET_BUFFER(_M, _P, _O)                                          \
{                                                                               \
    /*                                                                          \
     * If this is arcnet, then free the appended header.                        \
     */                                                                         \
    if ((_M)->MediaType == NdisMediumArcnet878_2)                               \
    {                                                                           \
        ndisMFreeArcnetHeader(_M, _P, _O);                                      \
    }                                                                           \
}

#else

#define FREE_ARCNET_BUFFER(_M, _P, _O)

#endif

#define NDISM_COMPLETE_SEND(_M, _P, _NSR, _S, _L, _I)                           \
{                                                                               \
    PNDIS_OPEN_BLOCK    _O;                                                     \
                                                                                \
    if (!(_L))                                                                  \
        NDIS_ACQUIRE_MINIPORT_SPIN_LOCK_DPC(_M);                                \
                                                                                \
    _O = (_NSR)->Open;                                                          \
                                                                                \
    UNLINK_PACKET(_M, _P, _NSR);                                                \
    POP_PACKET_STACK(_P);                                                       \
                                                                                \
    ADD_RESOURCE((_M), 'F');                                                    \
                                                                                \
    DBGPRINT(DBG_COMP_SEND, DBG_LEVEL_INFO,                                     \
            ("Completed 0x%x\n", (_S)));                                        \
                                                                                \
    FREE_ARCNET_BUFFER(_M, _P, _O);                                             \
                                                                                \
    (_NSR)->Open = MAGIC_OPEN_I(_I);                                            \
    M_OPEN_DECREMENT_REF(_O);                                                   \
                                                                                \
    if (!(_L) && (NULL != (_M)->FirstPendingPacket))                            \
    {                                                                           \
        /*                                                                      \
         *  Do we need to queue another workitem to process more sends ?        \
         */                                                                     \
        NDISM_QUEUE_WORK_ITEM(_M, NdisWorkItemSend, NULL);                      \
    }                                                                           \
                                                                                \
    /*                                                                          \
     *  Indicate the completion to the protocol.                                \
     */                                                                         \
    NDIS_RELEASE_MINIPORT_SPIN_LOCK_DPC((_M));                                  \
                                                                                \
    /*                                                                          \
     * Make sure that an IM which shares send and receive packets on the same   \
     * pool works fine with the check in the receive path.                      \
     */                                                                         \
    (_NSR)->RefCount = 0;                                                       \
    MINIPORT_CLEAR_PACKET_FLAG(_P, fPACKET_CLEAR_ITEMS);                        \
    CLEAR_WRAPPER_RESERVED(_NSR);                                               \
    (_O->SendCompleteHandler)(_O->ProtocolBindingContext,                       \
                              (_P),                                             \
                              (_S));                                            \
                                                                                \
    DBGPRINT(DBG_COMP_OPENREF, DBG_LEVEL_INFO,                                  \
        ("- Open 0x%x Reference 0x%x\n", _O, _O->References));                  \
                                                                                \
    if (_O->References == 0)                                                    \
    {                                                                           \
        NDIS_ACQUIRE_MINIPORT_SPIN_LOCK_DPC(_M);                                \
        ndisMFinishClose(_O);                                                   \
        NDIS_RELEASE_MINIPORT_SPIN_LOCK_DPC((_M));                              \
    }                                                                           \
                                                                                \
    if (_L)                                                                     \
        NDIS_ACQUIRE_MINIPORT_SPIN_LOCK_DPC(_M);                                \
}                                                                               
                                                                                
#define NDISM_COMPLETE_SEND_RESOURCES(_M, _NSR, _P)                             \
{                                                                               \
    DBGPRINT(DBG_COMP_SEND, DBG_LEVEL_INFO,                                     \
            ("Deferring send\n"));                                              \
                                                                                \
    ASSERT(VALID_OPEN((_NSR)->Open));                                           \
    /*                                                                          \
     * Put on pending queue                                                     \
     */                                                                         \
    MINIPORT_CLEAR_PACKET_FLAG(_P, fPACKET_PENDING);                            \
    (_M)->FirstPendingPacket = (_P);                                            \
                                                                                \
    /*                                                                          \
     * Mark the miniport as out of send resources.                              \
     */                                                                         \
    CLEAR_RESOURCE((_M), 'S');                                                  \
}

#define NDISM_SEND_PACKET(_M, _O, _P, _pS)                                      \
{                                                                               \
    UINT    _Flags;                                                             \
    BOOLEAN _SelfDirected;                                                      \
                                                                                \
    /*                                                                          \
     * Indicate the packet loopback if necessary.                               \
    */                                                                          \
                                                                                \
    if (NDIS_CHECK_FOR_LOOPBACK(_M, _P))                                        \
    {                                                                           \
        _SelfDirected = ndisMLoopbackPacketX(_M, _P);                           \
    }                                                                           \
    else                                                                        \
    {                                                                           \
        _SelfDirected = FALSE;                                                  \
    }                                                                           \
                                                                                \
    if (_SelfDirected)                                                          \
    {                                                                           \
        DBGPRINT(DBG_COMP_SEND, DBG_LEVEL_INFO,                                 \
            ("Packet is self-directed.\n"));                                    \
                                                                                \
        /*                                                                      \
         * Self-directed loopback always succeeds.                              \
         */                                                                     \
        *(_pS) = NDIS_STATUS_SUCCESS;                                           \
    }                                                                           \
    else                                                                        \
    {                                                                           \
        DBGPRINT(DBG_COMP_SEND, DBG_LEVEL_INFO,                                 \
            ("Sending packet 0x%p\n", _P));                                     \
                                                                                \
        NdisQuerySendFlags((_P), &_Flags);                                      \
                                                                                \
        /*                                                                      \
         * Call down to the driver.                                             \
         */                                                                     \
        MINIPORT_SET_PACKET_FLAG(_P, fPACKET_PENDING);                          \
        NDIS_RELEASE_MINIPORT_SPIN_LOCK_DPC(_M);                                \
        *(_pS) = ((_O)->WSendHandler)((_O)->MiniportAdapterContext, _P, _Flags);\
        NDIS_ACQUIRE_MINIPORT_SPIN_LOCK_DPC(_M);                                \
    }                                                                           \
}


#define PACKETS_OUT(_M)         (_M)->NdisStats.DirectedPacketsOut ++
#define DIRECTED_PACKETS_IN(_M) (_M)->NdisStats.DirectedPacketsIn ++

#if NDIS_STATISTICS_BYTES
#define BYTES_OUT(_M, _B)           (_M)->NdisStats.DirectedBytesOut.QuadPart += MDL_SIZE(_B)
#define DIRECTED_BYTES_IN(_M, _S)   (_M)->NdisStats.DirectedBytesIn.QuadPart += (_S);
#define DIRECTED_BYTES_IN_PACKET(_M, _P)                                        \
    {                                                                           \
        PNDIS_BUFFER    p;                                                      \
                                                                                \
        for (p = (_P)->Private.Head; p != NULL; p = p->Next)                    \
        {                                                                       \
            DIRECTED_BYTES_IN(_M, MDL_SIZE(p));                                 \
        }                                                                       \
    }

#else   // NDIS_STATISTICS_BYTES

#define BYTES_OUT(_M, _B)
#define DIRECTED_BYTES_IN(_M, _S)
#define DIRECTED_BYTES_IN_PACKET(_M, _P)

#endif  // NDIS_STATISTICS_BYTES


#define ndisMCheckPacketAndGetStatsOut(_M, _P, _S)                              \
    {                                                                           \
        PNDIS_BUFFER    _Buffer;                                                \
                                                                                \
        *(_S) = NDIS_STATUS_SUCCESS;                                            \
        PACKETS_OUT(_M);                                                        \
        _Buffer = (_P)->Private.Head;                                           \
        while (_Buffer != NULL)                                                 \
        {                                                                       \
            if (MDL_ADDRESS_SAFE(_Buffer, HighPagePriority) == NULL)            \
            {                                                                   \
                *(_S) = NDIS_STATUS_RESOURCES;                                  \
                break;                                                          \
            }                                                                   \
            BYTES_OUT(_M, _Buffer);                                             \
            _Buffer = _Buffer->Next;                                            \
        }                                                                       \
    }

#define ndisMCheckPacketAndGetStatsOutAlreadyMapped(_M, _P)                     \
    {                                                                           \
        PNDIS_BUFFER    _Buffer;                                                \
                                                                                \
        PACKETS_OUT(_M);                                                        \
        _Buffer = (_P)->Private.Head;                                           \
        while (_Buffer != NULL)                                                 \
        {                                                                       \
            BYTES_OUT(_M, _Buffer);                                             \
            _Buffer = _Buffer->Next;                                            \
        }                                                                       \
    }


#define NDISM_COMPLETE_SEND_SG(_M, _P, _NSR, _S, _L, _I, _UNLINK)               \
{                                                                               \
    PNDIS_OPEN_BLOCK    _O;                                                     \
                                                                                \
    if (!(_L))                                                                  \
        NDIS_ACQUIRE_MINIPORT_SPIN_LOCK_DPC(_M);                                \
                                                                                \
    _O = (_NSR)->Open;                                                          \
                                                                                \
    if (_UNLINK)                                                                \
    {                                                                           \
        UNLINK_PACKET(_M, _P, _NSR);                                            \
    }                                                                           \
    POP_PACKET_STACK(_P);                                                       \
                                                                                \
    ADD_RESOURCE((_M), 'F');                                                    \
                                                                                \
    DBGPRINT(DBG_COMP_SEND, DBG_LEVEL_INFO,                                     \
            ("Completed 0x%x\n", (_S)));                                        \
                                                                                \
    (_NSR)->Open = MAGIC_OPEN_I(_I);                                            \
    M_OPEN_DECREMENT_REF(_O);                                                   \
                                                                                \
    if (!(_L) && (NULL != (_M)->FirstPendingPacket))                            \
    {                                                                           \
        /*                                                                      \
         *  Do we need to queue another workitem to process more sends ?        \
         */                                                                     \
        NDISM_QUEUE_WORK_ITEM(_M, NdisWorkItemSend, NULL);                      \
    }                                                                           \
                                                                                \
    /*                                                                          \
     *  Indicate the completion to the protocol.                                \
     */                                                                         \
    NDIS_RELEASE_MINIPORT_SPIN_LOCK_DPC((_M));                                  \
                                                                                \
    if (NDIS_PER_PACKET_INFO_FROM_PACKET(_P, ScatterGatherListPacketInfo) != NULL) \
    {                                                                           \
        ndisMFreeSGList(_M, _P);                                                \
    }                                                                           \
    /*                                                                          \
     * Make sure that an IM which shares send and receive packets on the same   \
     * pool works fine with the check in the receive path.                      \
     */                                                                         \
    (_NSR)->RefCount = 0;                                                       \
    MINIPORT_CLEAR_PACKET_FLAG(_P, fPACKET_CLEAR_ITEMS);                        \
    CLEAR_WRAPPER_RESERVED(_NSR);                                               \
    (_O->SendCompleteHandler)(_O->ProtocolBindingContext,                       \
                              (_P),                                             \
                              (_S));                                            \
                                                                                \
    DBGPRINT(DBG_COMP_OPENREF, DBG_LEVEL_INFO,                                  \
        ("- Open 0x%x Reference 0x%x\n", _O, _O->References));                  \
                                                                                \
    if (_O->References == 0)                                                    \
    {                                                                           \
        NDIS_ACQUIRE_MINIPORT_SPIN_LOCK_DPC(_M);                                \
        ndisMFinishClose(_O);                                                   \
        NDIS_RELEASE_MINIPORT_SPIN_LOCK_DPC((_M));                              \
    }                                                                           \
                                                                                \
    if (_L)                                                                     \
        NDIS_ACQUIRE_MINIPORT_SPIN_LOCK_DPC(_M);                                \
}

#define LINK_PACKET_SG(_M, _P, _NSR)                                            \
    {                                                                           \
        INIT_PACKET_LIST(_P);                                                   \
                                                                                \
        InsertTailList(&(_M)->PacketList,                                       \
                       PACKET_LIST(_P));                                        \
    }

#endif // __SENDM_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ndis\sys\sendm.c ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation

Module Name:

    sendm.c

Abstract:

Author:

    Jameel Hyder (JameelH)
    Kyle Brandon (KyleB)

Environment:

    Kernel mode

Revision History:

--*/

#include <precomp.h>
#pragma hdrstop

//
//  Define the module number for debug code.
//
#define MODULE_NUMBER   MODULE_SENDM

///////////////////////////////////////////////////////////////////////////////////////
//
//                      UPPER-EDGE SEND HANDLERS
//
///////////////////////////////////////////////////////////////////////////////////////
VOID
ndisMSendPackets(
    IN  NDIS_HANDLE             NdisBindingHandle,
    IN  PPNDIS_PACKET           PacketArray,
    IN  UINT                    NumberOfPackets
    )
{
    PNDIS_OPEN_BLOCK        Open =  (PNDIS_OPEN_BLOCK)NdisBindingHandle;
    PNDIS_STACK_RESERVED    NSR;
    PNDIS_MINIPORT_BLOCK    Miniport = Open->MiniportHandle;
    BOOLEAN                 LocalLock;
    NDIS_STATUS             Status;
    KIRQL                   OldIrql;
    UINT                    c;
    PPNDIS_PACKET           pPktArray;;

    DBGPRINT(DBG_COMP_SEND, DBG_LEVEL_INFO,
            ("==>ndisMSendPackets\n"));

    NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Miniport, &OldIrql);

    Status = NDIS_STATUS_SUCCESS;
    //
    //  Place the packets on the miniport queue.
    //
    for (c = 0, pPktArray = PacketArray;
         c < NumberOfPackets;
         c++, pPktArray++)
    {
        PNDIS_PACKET    Packet = *pPktArray;
        ASSERT(Packet != NULL);

        ASSERT(Packet->Private.Head != NULL);
        
        PUSH_PACKET_STACK(Packet);
        NDIS_STACK_RESERVED_FROM_PACKET(Packet, &NSR)

        CHECK_FOR_DUPLICATE_PACKET(Miniport, Packet);


        if (MINIPORT_TEST_SEND_FLAG(Miniport, fMINIPORT_SEND_DO_NOT_MAP_MDLS))
        {
            ndisMCheckPacketAndGetStatsOutAlreadyMapped(Miniport, Packet);
        }
        else
        {
            ndisMCheckPacketAndGetStatsOut(Miniport, Packet, &Status);
        }

        NDIS_SET_PACKET_STATUS(Packet, NDIS_STATUS_PENDING);

        MINIPORT_CLEAR_PACKET_FLAG(Packet, fPACKET_SELF_DIRECTED);

        DBGPRINT(DBG_COMP_OPENREF, DBG_LEVEL_INFO,
            ("+ Open 0x%x Reference 0x%x\n", NdisBindingHandle, Open->References));

        M_OPEN_INCREMENT_REF_INTERLOCKED(Open);
        LINK_PACKET(Miniport, Packet, NSR, Open);

        if (Status != NDIS_STATUS_SUCCESS)
        {
            NDISM_COMPLETE_SEND(Miniport, Packet, NSR, Status, TRUE, 0);
        }
        else if (Miniport->FirstPendingPacket == NULL)
        {
            Miniport->FirstPendingPacket = Packet;
        }

    }

    //
    //  Queue a workitem for the new sends.
    //
    NDISM_QUEUE_WORK_ITEM(Miniport, NdisWorkItemSend, NULL);

    LOCK_MINIPORT(Miniport, LocalLock);
    if (LocalLock)
    {
        //
        //  We have the local lock
        //
        NDISM_PROCESS_DEFERRED(Miniport);
        UNLOCK_MINIPORT(Miniport, LocalLock);
    }

    NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);

    DBGPRINT(DBG_COMP_SEND, DBG_LEVEL_INFO,
            ("<==ndisMSendPackets\n"));
}

VOID
ndisMSendPacketsX(
    IN  NDIS_HANDLE             NdisBindingHandle,
    IN  PPNDIS_PACKET           PacketArray,
    IN  UINT                    NumberOfPackets
    )
{
    PNDIS_OPEN_BLOCK        Open = (PNDIS_OPEN_BLOCK)NdisBindingHandle;
    PNDIS_MINIPORT_BLOCK    Miniport = Open->MiniportHandle;
    PNDIS_STACK_RESERVED    NSR;
    PPNDIS_PACKET           pPktArray, pSend;
    NDIS_STATUS             Status;
    UINT                    c, k = 0, Flags;

    DBGPRINT(DBG_COMP_SEND, DBG_LEVEL_INFO,
            ("==>ndisMSendPacketsX\n"));

    DBGPRINT(DBG_COMP_OPENREF, DBG_LEVEL_INFO,
            ("+ Open 0x%x Reference 0x%x\n", NdisBindingHandle, Open->References));

    Status = NDIS_STATUS_SUCCESS ;

    for (c = k =  0, pPktArray = pSend = PacketArray;
         c < NumberOfPackets;
         c++, pPktArray++)
    {
        PNDIS_PACKET    Packet = *pPktArray;

        //
        //  Initialize the packets with the Open
        //
        ASSERT(Packet != NULL);
        ASSERT(Packet->Private.Head != NULL);

        PUSH_PACKET_STACK(Packet);
        NDIS_STACK_RESERVED_FROM_PACKET(Packet, &NSR)

        NSR->Open = Open;
        M_OPEN_INCREMENT_REF_INTERLOCKED(Open);

        MINIPORT_CLEAR_PACKET_FLAG(Packet, fPACKET_SELF_DIRECTED);
        
        NDIS_PER_PACKET_INFO_FROM_PACKET(Packet, ScatterGatherListPacketInfo) = NULL;

        if (MINIPORT_TEST_SEND_FLAG(Miniport, fMINIPORT_SEND_DO_NOT_MAP_MDLS))
        {
            ndisMCheckPacketAndGetStatsOutAlreadyMapped(Miniport, Packet);
        }
        else
        {
            ndisMCheckPacketAndGetStatsOut(Miniport, Packet, &Status);
        }


        if (Status == NDIS_STATUS_SUCCESS)
        {

            //
            // if PmodeOpens > 0 and NumOpens > 1, then check to see if we should 
            // loop back the packet.
            //
            // we should also should loopback the packet if the protocol did not
            // explicitly asked for the packet not to be looped back and we have a miniport
            // that has indicated that it does not do loopback itself or it is in all_local
            // mode
            //
            if (NDIS_CHECK_FOR_LOOPBACK(Miniport, Packet))
            {                
                //
                // Handle loopback
                //
                ndisMLoopbackPacketX(Miniport, Packet);                
                 
            }
            
        }

        //
        // Is this self-directed or if we should drop it due to low-resources?
        //
        if ((Status != NDIS_STATUS_SUCCESS) ||
            MINIPORT_TEST_PACKET_FLAG((Packet), fPACKET_SELF_DIRECTED))
        {
            //
            //  Complete the packet back to the protocol.
            //
            ndisMSendCompleteX(Miniport, Packet, Status);

            if (k > 0)
            {
                ASSERT(MINIPORT_TEST_SEND_FLAG(Miniport, fMINIPORT_SEND_PACKET_ARRAY));

                //
                // Send down the packets so far and skip this one.
                //
                (Open->WSendPacketsHandler)(Miniport->MiniportAdapterContext,
                                           pSend,
                                           k);
    
                pSend = pPktArray + 1;
                k = 0;
            }
        }
        else
        {
            //
            // This needs to go on the wire
            //
            if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_SG_LIST))
            {
                ndisMAllocSGList(Miniport, Packet);
            }
            else if (MINIPORT_TEST_SEND_FLAG(Miniport, fMINIPORT_SEND_PACKET_ARRAY))
            {
                MINIPORT_SET_PACKET_FLAG(Packet, fPACKET_PENDING);
                k++;
            }
            else
            {
                NDIS_STATUS SendStatus;

                //
                //  We need to send this down right away
                //
                NdisQuerySendFlags(Packet, &Flags);
                MINIPORT_SET_PACKET_FLAG(Packet, fPACKET_PENDING);
                SendStatus = (Open->WSendHandler)(Open->MiniportAdapterContext, Packet, Flags);

                //
                //  If the packet is not pending then complete it.
                //
                if (SendStatus != NDIS_STATUS_PENDING)
                {
                    ndisMSendCompleteX(Miniport, Packet, SendStatus);
                }
            }
        }
    }

    //
    //  Pass the remaining packet array down to the miniport.
    //
    if (k > 0)
    {
        ASSERT(MINIPORT_TEST_SEND_FLAG(Miniport, fMINIPORT_SEND_PACKET_ARRAY));
        (Open->WSendPacketsHandler)(Miniport->MiniportAdapterContext,
                                   pSend,
                                   k);
    }

    DBGPRINT(DBG_COMP_SEND, DBG_LEVEL_INFO,
            ("<==ndisMSendPacketsX\n"));
}


NDIS_STATUS
ndisMSend(
    IN  NDIS_HANDLE             NdisBindingHandle,
    IN  PNDIS_PACKET            Packet
    )
{
    PNDIS_OPEN_BLOCK        Open = ((PNDIS_OPEN_BLOCK)NdisBindingHandle);
    PNDIS_MINIPORT_BLOCK    Miniport = Open->MiniportHandle;
    PNDIS_STACK_RESERVED    NSR;
    PNDIS_PACKET_EXTENSION  PktExt;
    NDIS_STATUS             Status;
    BOOLEAN                 LocalLock;
    KIRQL                   OldIrql;

    DBGPRINT(DBG_COMP_SEND, DBG_LEVEL_INFO,
            ("==>ndisMSend\n"));

    NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Miniport, &OldIrql);

    ASSERT(Packet->Private.Head != NULL);

    CHECK_FOR_DUPLICATE_PACKET(Miniport, Packet);

    if (MINIPORT_TEST_SEND_FLAG(Miniport, fMINIPORT_SEND_DO_NOT_MAP_MDLS))
    {
        Status = NDIS_STATUS_SUCCESS;
        ndisMCheckPacketAndGetStatsOutAlreadyMapped(Miniport, Packet);
    }
    else
    {
        ndisMCheckPacketAndGetStatsOut(Miniport, Packet, &Status);
    }
    
    if (Status == NDIS_STATUS_SUCCESS)
    {
        MINIPORT_CLEAR_PACKET_FLAG(Packet, fPACKET_SELF_DIRECTED);
    
        //
        //  Increment the references on this open.
        //
        M_OPEN_INCREMENT_REF(Open);
    
        DBGPRINT(DBG_COMP_OPENREF, DBG_LEVEL_INFO,
            ("+ Open 0x%x Reference 0x%x\n", NdisBindingHandle, ((PNDIS_OPEN_BLOCK)NdisBindingHandle)->References));
    
        PUSH_PACKET_STACK(Packet);
        NDIS_STACK_RESERVED_FROM_PACKET(Packet, &NSR)
        LINK_PACKET(Miniport, Packet, NSR, Open);
    
        if (Miniport->FirstPendingPacket == NULL)
        {
            Miniport->FirstPendingPacket = Packet;
        }
        
        //
        //  If we have the local lock and there is no
        //  packet pending, then fire off a send.
        //
        LOCK_MINIPORT(Miniport, LocalLock);
    
        NDISM_QUEUE_WORK_ITEM(Miniport, NdisWorkItemSend, NULL);
        if (LocalLock)
        {
            NDISM_PROCESS_DEFERRED(Miniport);
        }
        Status = NDIS_STATUS_PENDING;
    
        UNLOCK_MINIPORT(Miniport, LocalLock);
    }

    NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);

    DBGPRINT(DBG_COMP_SEND, DBG_LEVEL_INFO,
            ("<==ndisMSend\n"));

    return Status;
}


NDIS_STATUS
ndisMSendX(
    IN  NDIS_HANDLE             NdisBindingHandle,
    IN  PNDIS_PACKET            Packet
    )
{
    PNDIS_OPEN_BLOCK        Open = (PNDIS_OPEN_BLOCK)NdisBindingHandle;
    PNDIS_MINIPORT_BLOCK    Miniport = Open->MiniportHandle;
    PNDIS_STACK_RESERVED    NSR;
    UINT                    Flags;
    UINT                    OpenRef;
    NDIS_STATUS             Status;

    DBGPRINT(DBG_COMP_SEND, DBG_LEVEL_INFO,
            ("==>ndisMSendX\n"));

    ASSERT(Packet->Private.Head != NULL);

    if (MINIPORT_TEST_SEND_FLAG(Miniport, fMINIPORT_SEND_DO_NOT_MAP_MDLS))
    {
        Status = NDIS_STATUS_SUCCESS;
        ndisMCheckPacketAndGetStatsOutAlreadyMapped(Miniport, Packet);
    }
    else
    {
        ndisMCheckPacketAndGetStatsOut(Miniport, Packet, &Status);
    }

    if (Status != NDIS_STATUS_SUCCESS)
    {
        return NDIS_STATUS_RESOURCES;
    }

    MINIPORT_CLEAR_PACKET_FLAG(Packet, fPACKET_SELF_DIRECTED);
    NDIS_PER_PACKET_INFO_FROM_PACKET(Packet, ScatterGatherListPacketInfo) = NULL;

    //
    //  Initialize the packet info.
    //
    PUSH_PACKET_STACK(Packet);
    NDIS_STACK_RESERVED_FROM_PACKET(Packet, &NSR)
    NSR->Open = Open;

    //
    //  Increment the references on this open.
    //
    DBGPRINT(DBG_COMP_OPENREF, DBG_LEVEL_INFO,
        ("+ Open 0x%x Reference 0x%x\n", Open, Open->References));


    M_OPEN_INCREMENT_REF_INTERLOCKED(Open);

    //
    // HANDLE loopback
    //

    if (NDIS_CHECK_FOR_LOOPBACK(Miniport, Packet))
    {
        ndisMLoopbackPacketX(Miniport, Packet);
    }

    if (!MINIPORT_TEST_PACKET_FLAG(Packet, fPACKET_SELF_DIRECTED))
    {
        //
        // Does the driver support the SG method ?
        //
        if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_SG_LIST))
        {
            ndisMAllocSGList(Miniport, Packet);
        }

        //
        // Handle Send/SendPacket differently
        //
        else if (MINIPORT_TEST_SEND_FLAG(Miniport, fMINIPORT_SEND_PACKET_ARRAY))
        {
            //
            //  Pass the packet down to the miniport.
            //
            (Open->WSendPacketsHandler)(Miniport->MiniportAdapterContext,
                                       &Packet,
                                       1);
        }
        else
        {
            NdisQuerySendFlags(Packet, &Flags);
            MINIPORT_SET_PACKET_FLAG(Packet, fPACKET_PENDING);
            Status = (Open->WSendHandler)(Open->MiniportAdapterContext, Packet, Flags);
    
            if (Status != NDIS_STATUS_PENDING)
            {
                ndisMSendCompleteX(Miniport, Packet, Status);
            }
        }

        Status = NDIS_STATUS_PENDING;
    }
    else
    {
        //
        //  Remove the reference added earlier.
        //
        DBGPRINT(DBG_COMP_OPENREF, DBG_LEVEL_INFO,
            ("- Open 0x%x Reference 0x%x\n", Open, Open->References));
        
        M_OPEN_DECREMENT_REF_INTERLOCKED(Open, OpenRef);

        /*
         * Make sure that an IM which shares send and receive packets on the same
         * pool works fine with the check in the receive path.
         */
        NSR->RefCount = 0;
        POP_PACKET_STACK(Packet);

        MINIPORT_CLEAR_PACKET_FLAG(Packet, fPACKET_CLEAR_ITEMS);
        
        Status = NDIS_STATUS_SUCCESS;
    }

    DBGPRINT(DBG_COMP_SEND, DBG_LEVEL_INFO,
        ("<==ndisMSendX\n"));

    return(Status);
}


VOID
NdisMSendComplete(
    IN  NDIS_HANDLE             MiniportAdapterHandle,
    IN  PNDIS_PACKET            Packet,
    IN  NDIS_STATUS             Status
    )
/*++

Routine Description:

    This function indicates the completion of a send.

Arguments:

    MiniportAdapterHandle - points to the adapter block.

Return Value:

    None.

--*/
{
    PNDIS_MINIPORT_BLOCK    Miniport = (PNDIS_MINIPORT_BLOCK)MiniportAdapterHandle;
    PNDIS_OPEN_BLOCK        Open;
    PNDIS_STACK_RESERVED    NSR;

    ASSERT_MINIPORT_LOCKED(Miniport);

    DBGPRINT(DBG_COMP_SEND, DBG_LEVEL_INFO,
        ("==>ndisMSendComplete\n"));
    DBGPRINT(DBG_COMP_SEND, DBG_LEVEL_INFO,
        ("packet 0x%x\n", Packet));

    ASSERT(Packet->Private.Head != NULL);

    NDIS_STACK_RESERVED_FROM_PACKET(Packet, &NSR)

    ASSERT(VALID_OPEN(NSR->Open));
    ASSERT(MINIPORT_TEST_PACKET_FLAG(Packet, fPACKET_PENDING));

    //
    // Guard against double/bogus completions.
    //
    if (VALID_OPEN(NSR->Open) &&
        MINIPORT_TEST_PACKET_FLAG(Packet, fPACKET_PENDING))
    {
        ASSERT(Packet != Miniport->FirstPendingPacket);
        if (MINIPORT_TEST_PACKET_FLAG(Packet, fPACKET_DONT_COMPLETE))
        {
            //
            // If the packet completed in the context of a SendPackets, then
            // defer completion. It will get completed when we unwind.
            //
            NDIS_SET_PACKET_STATUS(Packet, Status);
            MINIPORT_CLEAR_PACKET_FLAG(Packet, fPACKET_DONT_COMPLETE);
        }
        else
        {
            NDISM_COMPLETE_SEND(Miniport, Packet, NSR, Status, FALSE, 1);
        }
    }

    DBGPRINT(DBG_COMP_SEND, DBG_LEVEL_INFO,
            ("<==ndisMSendComplete\n"));
}


VOID
ndisMSendCompleteX(
    IN  NDIS_HANDLE             MiniportAdapterHandle,
    IN  PNDIS_PACKET            Packet,
    IN  NDIS_STATUS             Status
    )
/*++

Routine Description:

    This function indicates the completion of a send.

Arguments:

    MiniportAdapterHandle - points to the adapter block.

Return Value:

    None.

--*/
{
    PNDIS_MINIPORT_BLOCK    Miniport = (PNDIS_MINIPORT_BLOCK)MiniportAdapterHandle;
    PNDIS_STACK_RESERVED    NSR;
    PNDIS_OPEN_BLOCK        Open;
    UINT                    OpenRef;
    KIRQL                   OldIrql;

    DBGPRINT(DBG_COMP_SEND, DBG_LEVEL_INFO,
        ("==>ndisMSendCompleteX\n"));
    DBGPRINT(DBG_COMP_SEND, DBG_LEVEL_INFO,
        ("packet 0x%x\n", Packet));

    ASSERT(Packet->Private.Head != NULL);

    RAISE_IRQL_TO_DISPATCH(&OldIrql);

    if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_SG_LIST) &&
        (NDIS_PER_PACKET_INFO_FROM_PACKET(Packet, ScatterGatherListPacketInfo) != NULL))
    {
        ndisMFreeSGList(Miniport, Packet);        
    }

    //
    // Indicate to Protocol;
    //
    NDIS_STACK_RESERVED_FROM_PACKET(Packet, &NSR)
    POP_PACKET_STACK(Packet);

    Open = NSR->Open;
    ASSERT(VALID_OPEN(Open));
    NSR->Open = MAGIC_OPEN_I(6);

#if ARCNET
    ASSERT (Miniport->MediaType != NdisMediumArcnet878_2);
#endif

    MINIPORT_CLEAR_PACKET_FLAG(Packet, fPACKET_CLEAR_ITEMS);
    
    /*
     * Make sure that an IM which shares send and receive packets on the same
     * pool works fine with the check in the receive path.
     */
    CLEAR_WRAPPER_RESERVED(NSR);

    (Open->SendCompleteHandler)(Open->ProtocolBindingContext,
                                Packet,
                                Status);

    DBGPRINT(DBG_COMP_OPENREF, DBG_LEVEL_INFO,
            ("- Open 0x%x Reference 0x%x\n", Open, Open->References));

    M_OPEN_DECREMENT_REF_INTERLOCKED(Open, OpenRef);

    DBGPRINT(DBG_COMP_OPENREF, DBG_LEVEL_INFO,
        ("==0 Open 0x%x Reference 0x%x\n", Open, Open->References));

    if (OpenRef == 0)
    {
        NDIS_ACQUIRE_MINIPORT_SPIN_LOCK_DPC(Miniport);

        ndisMFinishClose(Open);

        NDIS_RELEASE_MINIPORT_SPIN_LOCK_DPC(Miniport);
    }

    LOWER_IRQL(OldIrql, DISPATCH_LEVEL);

    DBGPRINT(DBG_COMP_SEND, DBG_LEVEL_INFO,
            ("<==ndisMSendCompleteX\n"));
}

BOOLEAN
FASTCALL
ndisMStartSendPackets(
    IN  PNDIS_MINIPORT_BLOCK    Miniport
    )
{
    PNDIS_PACKET            Packet;
    NDIS_STATUS             Status;
    PNDIS_STACK_RESERVED    NSR;
    PPNDIS_PACKET           pPktArray;
    PNDIS_PACKET            PacketArray[SEND_PACKET_ARRAY];
    UINT                    MaxPkts = Miniport->MaxSendPackets;
    W_SEND_PACKETS_HANDLER  SendPacketsHandler = Miniport->WSendPacketsHandler;
    BOOLEAN                 SelfDirected;

    ASSERT_MINIPORT_LOCKED(Miniport);

    DBGPRINT(DBG_COMP_SEND, DBG_LEVEL_INFO,
            ("==>ndisMStartSendPackets\n"));

    //
    // We could possibly end up with a situation (with intermediate serialized
    // miniports) where there are no packets down with the driver and we the
    // resource window is closed. In such a case open it fully. We are seeing this
    // with wlbs
    //
    if (!MINIPORT_TEST_FLAG(Miniport, fMINIPORT_RESOURCES_AVAILABLE) &&
        (Miniport->FirstPendingPacket == NULL))
    {
        ADD_RESOURCE(Miniport, 'X');
    }

    //
    // Work-around for a scenario we are hitting when PacketList is empty but FirstPendingPacket is NOT
    // Not sure how this can happen - yet.
    //
    if (IsListEmpty(&Miniport->PacketList))
    {
        ASSERT (Miniport->FirstPendingPacket == NULL);
        Miniport->FirstPendingPacket = NULL;
    }

    while ((Miniport->FirstPendingPacket != NULL) &&
            MINIPORT_TEST_FLAG(Miniport, fMINIPORT_RESOURCES_AVAILABLE))
    {
        UINT            Count;
        UINT            NumberOfPackets;

        ASSERT(!IsListEmpty(&Miniport->PacketList));

        //
        //  Initialize the packet array.
        //
        pPktArray = PacketArray;

        //
        //  Place as many packets as we can in the packet array to send
        //  to the miniport.
        //
        for (NumberOfPackets = 0;
             (NumberOfPackets < MaxPkts) && (Miniport->FirstPendingPacket != NULL);
             NOTHING)
        {
            //
            //  Grab the packet off of the pending queue.
            //
            ASSERT(!IsListEmpty(&Miniport->PacketList));

            Packet = Miniport->FirstPendingPacket;
            ASSERT(Packet->Private.Head != NULL);

            NDIS_STACK_RESERVED_FROM_PACKET(Packet, &NSR)
            
            ASSERT(VALID_OPEN(NSR->Open));

            NEXT_PACKET_PENDING(Miniport, Packet, NSR);
        
            //
            // Indicate the packet loopback if necessary.
            //

            if (NDIS_CHECK_FOR_LOOPBACK(Miniport, Packet))
            {
                //
                // make sure the packet does not get looped back at lower levels.
                // we will restore the original flag on send completion
                //

                SelfDirected = ndisMLoopbackPacketX(Miniport, Packet);
            }
            else
            {
                SelfDirected = FALSE;
            }

            if (SelfDirected)
            {
                DBGPRINT(DBG_COMP_SEND, DBG_LEVEL_INFO,
                    ("Packet 0x%x is self-directed.\n", Packet));

                //
                //  Complete the packet back to the binding.
                //
                NDISM_COMPLETE_SEND(Miniport, Packet, NSR, NDIS_STATUS_SUCCESS, TRUE, 2);

                //
                //  No, we don't want to increment the counter for the
                //  miniport's packet array.
                //
            }
            else
            {
                //
                //  We have to re-initialize this.
                //
                *pPktArray = Packet;
                MINIPORT_SET_PACKET_FLAG(Packet, (fPACKET_DONT_COMPLETE | fPACKET_PENDING));
                NDIS_SET_PACKET_STATUS(Packet, NDIS_STATUS_SUCCESS);

                //
                //  Increment the counter for the packet array index.
                //
                NumberOfPackets++;
                pPktArray++;
            }
        }

        //
        //  Are there any packets to send?
        //
        if (NumberOfPackets == 0)
        {
            break;
        }

        pPktArray = PacketArray;

        {

            //
            //  Pass the packet array down to the miniport.
            //
            NDIS_RELEASE_MINIPORT_SPIN_LOCK_DPC(Miniport);
    
            (SendPacketsHandler)(Miniport->MiniportAdapterContext,
                                 pPktArray,
                                 NumberOfPackets);
    
            NDIS_ACQUIRE_MINIPORT_SPIN_LOCK_DPC(Miniport);
        }

        //
        //  Process the packet completion.
        //
        for (Count = 0; Count < NumberOfPackets; Count++, pPktArray++)
        {
            Packet = *pPktArray;
            ASSERT(Packet != NULL);

            Status = NDIS_GET_PACKET_STATUS(*pPktArray);
            MINIPORT_CLEAR_PACKET_FLAG(Packet, fPACKET_DONT_COMPLETE);

            //
            //  Process the packet based on it's return status.
            //
            if (NDIS_STATUS_PENDING == Status)
            {
                DBGPRINT(DBG_COMP_SEND, DBG_LEVEL_INFO,
                    ("Complete is pending\n"));
            }
            else if (Status != NDIS_STATUS_RESOURCES)
            {
                //
                //  Remove from the finish queue.
                //
                DBGPRINT(DBG_COMP_SEND, DBG_LEVEL_INFO,
                        ("Completed packet 0x%x with status 0x%x\n",
                        Packet, Status));

                NDIS_STACK_RESERVED_FROM_PACKET(Packet, &NSR)
                if (VALID_OPEN(NSR->Open))
                {
                    NDISM_COMPLETE_SEND(Miniport, Packet, NSR, Status, TRUE, 3);
                }
            }
            else
            {
                //
                //  Once we hit a return code of NDIS_STATUS_RESOURCES
                //  for a packet then we must break out and re-queue.
                //
                UINT    i;

                Miniport->FirstPendingPacket = Packet;
                CLEAR_RESOURCE(Miniport, 'S');
                for (i = Count; i < NumberOfPackets; i++)
                {
                    PNDIS_PACKET    Packet = PacketArray[i];

                    MINIPORT_CLEAR_PACKET_FLAG(Packet, fPACKET_PENDING);
                    VALIDATE_PACKET_OPEN(Packet);
                }
                break;
            }
        }
    }

    DBGPRINT(DBG_COMP_SEND, DBG_LEVEL_INFO,
            ("<==ndisMStartSendPackets\n"));

    return(FALSE);
}


BOOLEAN
FASTCALL
ndisMStartSends(
    IN  PNDIS_MINIPORT_BLOCK    Miniport
    )
/*++

Routine Description:

    Submits as many sends as possible to the mini-port.

Arguments:

    Miniport - Miniport to send to.

Return Value:

    If there are more packets to send but no resources to do it with
    the this is TRUE to keep a workitem queue'd.

--*/
{
    PNDIS_PACKET            Packet;
    PNDIS_STACK_RESERVED    NSR;
    NDIS_STATUS             Status;
    PNDIS_OPEN_BLOCK        Open;

    ASSERT_MINIPORT_LOCKED(Miniport);

    DBGPRINT(DBG_COMP_SEND, DBG_LEVEL_INFO,
            ("==>ndisMStartSends\n"));

    while ((Miniport->FirstPendingPacket != NULL) &&
           MINIPORT_TEST_FLAG(Miniport, fMINIPORT_RESOURCES_AVAILABLE))
    {
        //
        //  Grab the packet off of the pending queue.
        //
        ASSERT(!IsListEmpty(&Miniport->PacketList));
    
        Packet = Miniport->FirstPendingPacket;

        ASSERT(Packet->Private.Head != NULL);

        NDIS_STACK_RESERVED_FROM_PACKET(Packet, &NSR)
        NEXT_PACKET_PENDING(Miniport, Packet, NSR);

        Open = NSR->Open;
        ASSERT(VALID_OPEN(Open));

#if ARCNET
        //
        //  Is this arcnet using ethernet encapsulation ?
        //
        if (Miniport->MediaType == NdisMediumArcnet878_2)
        {
            //
            //  Build the header for arcnet.
            //
            Status = ndisMBuildArcnetHeader(Miniport, Open, Packet);
            if (NDIS_STATUS_PENDING == Status)
            {
                break;
            }
        }
#endif  
        NDISM_SEND_PACKET(Miniport, Open, Packet, &Status);

        //
        //  Process the packet pending completion status.
        //
        if (NDIS_STATUS_PENDING == Status)
        {
            DBGPRINT(DBG_COMP_SEND, DBG_LEVEL_INFO, ("Complete is pending\n"));
        }
        else
        {
            MINIPORT_CLEAR_PACKET_FLAG(Packet, fPACKET_PENDING);

            //
            //  Handle the completion and resources cases.
            //
            if (Status == NDIS_STATUS_RESOURCES)
            {
                NDISM_COMPLETE_SEND_RESOURCES(Miniport, NSR, Packet);
            }
            else
            {
                NDISM_COMPLETE_SEND(Miniport, Packet, NSR, Status, TRUE, 4);
            }
        }
    }

    DBGPRINT(DBG_COMP_SEND, DBG_LEVEL_INFO,
            ("<==ndisMStartSends\n"));

    return(FALSE);
}


BOOLEAN
FASTCALL
ndisMIsLoopbackPacket(
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  PNDIS_PACKET            Packet,
    OUT PNDIS_PACKET    *       LoopbackPacket  OPTIONAL
    )
/*++

Routine Description:

    This routine will determine if a packet needs to be looped back in
    software.   if the packet is any kind of loopback packet then it
    will get placed on the loopback queue and a workitem will be queued
    to process it later.

Arguments:

    Miniport-   Pointer to the miniport block to send the packet on.
    Packet  -   Packet to check for loopback.

Return Value:

    Returns TRUE if the packet is self-directed.

--*/
{
    PNDIS_BUFFER    FirstBuffer;
    UINT            Length;
    UINT            Offset;
    PUCHAR          BufferAddress;
    BOOLEAN         Loopback;
    BOOLEAN         SelfDirected, NotDirected;
    PNDIS_PACKET    pNewPacket = NULL;
    PUCHAR          Buffer;
    NDIS_STATUS     Status;
    PNDIS_BUFFER    pNdisBuffer;
    UINT            HdrLength;
    LOCK_STATE      LockState;

    //
    //  We should not be here if the driver handles loopback.
    //

    Loopback = FALSE;
    SelfDirected = FALSE;
    FirstBuffer = Packet->Private.Head;
    BufferAddress = MDL_ADDRESS_SAFE(FirstBuffer, HighPagePriority);
    if (BufferAddress == NULL)
    {
        if (ARGUMENT_PRESENT(LoopbackPacket))
            *LoopbackPacket = NULL;
        return(FALSE);
    }

    //
    // If the card does not do loopback, then we check if we need to send it to ourselves,
    // then if that is the case we also check for it being self-directed.
    //
    switch (Miniport->MediaType)
    {
      case NdisMedium802_3:

        if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_SEND_LOOPBACK_DIRECTED))
        {
            if (!ETH_IS_MULTICAST(BufferAddress))
            {
                //
                //  Packet is of type directed, now make sure that it
                //  is not self-directed.
                //
                ETH_COMPARE_NETWORK_ADDRESSES_EQ(BufferAddress,
                                                 Miniport->EthDB->AdapterAddress,
                                                 &NotDirected);

                if (!NotDirected)
                {
                    SelfDirected = Loopback = TRUE;
                    break;
                }
            }
            //
            // since all_local is set we do loopback the packet
            // ourselves
            //
            Loopback = TRUE;
            break;
        }

        READ_LOCK_FILTER(Miniport, Miniport->EthDB, &LockState);

        //
        //  Check for the miniports that don't do loopback.
        //  
        EthShouldAddressLoopBackMacro(Miniport->EthDB,
                                      BufferAddress,
                                      &Loopback,
                                      &SelfDirected);
        READ_UNLOCK_FILTER(Miniport, Miniport->EthDB, &LockState);

        break;

      case NdisMedium802_5:

        if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_SEND_LOOPBACK_DIRECTED))
        {
            TR_IS_NOT_DIRECTED(BufferAddress + 2, &NotDirected);
            if (!NotDirected)
            {
                //
                //  Packet is of type directed, now make sure that it
                //  is not self-directed.
                //
                TR_COMPARE_NETWORK_ADDRESSES_EQ(BufferAddress + 2,
                                                Miniport->TrDB->AdapterAddress,
                                                &NotDirected);
                if (!NotDirected)
                {
                    SelfDirected = Loopback = TRUE;
                    break;
                }
            }
            //
            // since all_local is set we do loopback the packet
            // ourselves
            //
            Loopback = TRUE;
            break;
        }

        READ_LOCK_FILTER(Miniport, Miniport->TrDB, &LockState);
        
        TrShouldAddressLoopBackMacro(Miniport->TrDB,
                                     BufferAddress +2,
                                     BufferAddress +8,
                                     &Loopback,
                                     &SelfDirected);
        
        READ_UNLOCK_FILTER(Miniport, Miniport->TrDB, &LockState);
        break;

      case NdisMediumFddi:

        if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_SEND_LOOPBACK_DIRECTED))
        {
            BOOLEAN IsMulticast;

            FDDI_IS_MULTICAST(BufferAddress + 1,
                              (BufferAddress[0] & 0x40) ?
                                            FDDI_LENGTH_OF_LONG_ADDRESS : FDDI_LENGTH_OF_SHORT_ADDRESS,
                              &IsMulticast);
            if (!IsMulticast)
            {
                //
                //  Packet is of type directed, now make sure that it
                //  is not self-directed.
                //
                FDDI_COMPARE_NETWORK_ADDRESSES_EQ(BufferAddress + 1,
                                                  (BufferAddress[0] & 0x40) ?
                                                    Miniport->FddiDB->AdapterLongAddress : Miniport->FddiDB->AdapterShortAddress,
                                                  (BufferAddress[0] & 0x40) ?
                                                    FDDI_LENGTH_OF_LONG_ADDRESS : FDDI_LENGTH_OF_SHORT_ADDRESS,
                                                  &NotDirected);
                if (!NotDirected)
                {
                    SelfDirected = Loopback = TRUE;
                    break;
                }
            }
            //
            // since all_local is set we do loopback the packet
            // ourselves
            //
            Loopback = TRUE;
            break;
        }

        READ_LOCK_FILTER(Miniport, Miniport->FddiDB, &LockState);

        FddiShouldAddressLoopBackMacro(Miniport->FddiDB,
                                       BufferAddress + 1,  // Skip FC byte to dest address.
                                       (BufferAddress[0] & 0x40) ?
                                            FDDI_LENGTH_OF_LONG_ADDRESS :
                                            FDDI_LENGTH_OF_SHORT_ADDRESS,
                                        &Loopback,
                                        &SelfDirected);

        READ_UNLOCK_FILTER(Miniport, Miniport->FddiDB, &LockState);
        break;
    
#if ARCNET
      case NdisMediumArcnet878_2:

        //
        //  We just handle arcnet packets (encapsulated or not) in
        //   a totally different manner...
        //
        SelfDirected = ndisMArcnetSendLoopback(Miniport, Packet);

        //
        //  Mark the packet as having been looped back.
        //
        return(SelfDirected);
        break;
#endif
    }

    if (Loopback && (NdisGetPacketFlags(Packet) & NDIS_FLAGS_LOOPBACK_ONLY))
    {
        SelfDirected = TRUE;
    }

    //
    // Mark packet with reserved bit to indicate that it is self-directed
    //
    if (SelfDirected)
    {
        MINIPORT_SET_PACKET_FLAG(Packet, fPACKET_SELF_DIRECTED);
    }

    //
    //  If it is not a loopback packet then get out of here.
    //
    if (!Loopback)
    {
        ASSERT(!SelfDirected);
        return (NdisGetPacketFlags(Packet) & NDIS_FLAGS_LOOPBACK_ONLY) ? TRUE : FALSE;
    }

    do
    {
        PNDIS_STACK_RESERVED NSR;
        UINT    PktSize;
        ULONG   j;


        //
        //
        //  Get the buffer length.
        //
        NdisQueryPacketLength(Packet, &Length);
        Offset = 0;

        //
        //  Allocate a buffer for the packet.
        //
        PktSize = NdisPacketSize(PROTOCOL_RESERVED_SIZE_IN_PACKET);
        pNewPacket = (PNDIS_PACKET)ALLOC_FROM_POOL(Length + PktSize, NDIS_TAG_LOOP_PKT);
        if (NULL == pNewPacket)
        {
            Status = NDIS_STATUS_RESOURCES;
            break;
        }
    
        //
        //  Get a pointer to the destination buffer.
        //
        ZeroMemory(pNewPacket, PktSize);
        Buffer = (PUCHAR)pNewPacket + PktSize;
        pNewPacket = (PNDIS_PACKET)((PUCHAR)pNewPacket + SIZE_PACKET_STACKS);

        for (j = 0; j < ndisPacketStackSize; j++)
        {
            CURR_STACK_LOCATION(pNewPacket) = j;
            NDIS_STACK_RESERVED_FROM_PACKET(pNewPacket, &NSR);
            INITIALIZE_SPIN_LOCK(&NSR->Lock);
        }

        CURR_STACK_LOCATION(pNewPacket) = -1;

        //
        //  Allocate an MDL for the packet.
        //
        NdisAllocateBuffer(&Status, &pNdisBuffer, NULL, Buffer, Length);
        if (NDIS_STATUS_SUCCESS != Status)
        {    
            break;
        }
    
        //
        //  NdisChainBufferAtFront()
        //
        pNewPacket->Private.Head = pNdisBuffer;
        pNewPacket->Private.Tail = pNdisBuffer;
        pNewPacket->Private.Pool = (PVOID)'pooL';
        pNewPacket->Private.NdisPacketOobOffset = (USHORT)(PktSize - (SIZE_PACKET_STACKS +
                                                                      sizeof(NDIS_PACKET_OOB_DATA) +
                                                                      sizeof(NDIS_PACKET_EXTENSION)));
        NDIS_SET_ORIGINAL_PACKET(pNewPacket, pNewPacket);

        ndisMCopyFromPacketToBuffer(Packet,     // Packet to copy from.
                                    Offset,     // Offset from beginning of packet.
                                    Length,     // Number of bytes to copy.
                                    Buffer,     // The destination buffer.
                                    &HdrLength);//  The number of bytes copied.
    
        if (ARGUMENT_PRESENT(LoopbackPacket))
        {
            *LoopbackPacket = pNewPacket;
            MINIPORT_SET_PACKET_FLAG(pNewPacket, fPACKET_IS_LOOPBACK);
            pNewPacket->Private.Flags = NdisGetPacketFlags(Packet) & NDIS_FLAGS_DONT_LOOPBACK;
        }
    } while (FALSE);

    if (NDIS_STATUS_SUCCESS != Status)
    {
        if (NULL != pNewPacket)
        {
            pNewPacket = (PNDIS_PACKET)((PUCHAR)pNewPacket - SIZE_PACKET_STACKS);
            FREE_POOL(pNewPacket);
        }

        *LoopbackPacket = NULL;
        SelfDirected = FALSE;
    }
    
    return SelfDirected;
}

BOOLEAN
FASTCALL
ndisMLoopbackPacketX(
    IN  PNDIS_MINIPORT_BLOCK    Miniport,
    IN  PNDIS_PACKET            Packet
    )
{
    PNDIS_PACKET            LoopbackPacket = NULL;
    PNDIS_PACKET_OOB_DATA   pOob;
    PNDIS_STACK_RESERVED    NSR;
    PUCHAR                  BufferAddress;
    KIRQL                   OldIrql;
    BOOLEAN                 fSelfDirected;

    fSelfDirected = !MINIPORT_TEST_PACKET_FLAG(Packet, fPACKET_ALREADY_LOOPEDBACK) &&
                    ndisMIsLoopbackPacket(Miniport, Packet, &LoopbackPacket);

    if ((LoopbackPacket != NULL) && (NdisMediumArcnet878_2 != Miniport->MediaType))
    {
        MINIPORT_SET_PACKET_FLAG(Packet, fPACKET_ALREADY_LOOPEDBACK);
        pOob = NDIS_OOB_DATA_FROM_PACKET(LoopbackPacket);
        NDIS_STACK_RESERVED_FROM_PACKET(Packet, &NSR);
        pOob->Status = NDIS_STATUS_RESOURCES;
        PNDIS_LB_REF_FROM_PNDIS_PACKET(LoopbackPacket)->Open = NSR->Open;

        if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_DESERIALIZE))
        {
            RAISE_IRQL_TO_DISPATCH(&OldIrql);
        }
        
        //
        // For ethernet/token-ring/fddi/encapsulated arc-net, we want to
        // indicate the packet using the receivepacket way.
        //
        if (!MINIPORT_TEST_FLAG(Miniport, fMINIPORT_DESERIALIZE))
        {
            NDIS_RELEASE_MINIPORT_SPIN_LOCK_DPC(Miniport);
        }

        switch (Miniport->MediaType)
        {
          case NdisMedium802_3:
            pOob->HeaderSize = 14;
            ethFilterDprIndicateReceivePacket(Miniport, &LoopbackPacket, 1);
            break;
        
          case NdisMedium802_5:
            pOob->HeaderSize = 14;
            BufferAddress = (PUCHAR)LoopbackPacket + NdisPacketSize(PROTOCOL_RESERVED_SIZE_IN_PACKET) - SIZE_PACKET_STACKS;
            if (BufferAddress[8] & 0x80)
            {
                pOob->HeaderSize += (BufferAddress[14] & 0x1F);
            }
            trFilterDprIndicateReceivePacket(Miniport, &LoopbackPacket, 1);
            break;
        
          case NdisMediumFddi:
            BufferAddress = (PUCHAR)LoopbackPacket + NdisPacketSize(PROTOCOL_RESERVED_SIZE_IN_PACKET) - SIZE_PACKET_STACKS;
            pOob->HeaderSize = (*BufferAddress & 0x40) ?
                                    2 * FDDI_LENGTH_OF_LONG_ADDRESS + 1:
                                    2 * FDDI_LENGTH_OF_SHORT_ADDRESS + 1;

            fddiFilterDprIndicateReceivePacket(Miniport, &LoopbackPacket, 1);
            break;

          default:
            ASSERT(0);
            break;
        }

        if (!MINIPORT_TEST_FLAG(Miniport, fMINIPORT_DESERIALIZE))
        {
            NDIS_ACQUIRE_MINIPORT_SPIN_LOCK_DPC(Miniport);
        }
        else
        {
            LOWER_IRQL(OldIrql, DISPATCH_LEVEL);
        }

        ASSERT(NDIS_GET_PACKET_STATUS(LoopbackPacket) != NDIS_STATUS_PENDING);
        NdisFreeBuffer(LoopbackPacket->Private.Head);
        LoopbackPacket = (PNDIS_PACKET)((PUCHAR)LoopbackPacket - SIZE_PACKET_STACKS);
        FREE_POOL(LoopbackPacket);
    }

    return(fSelfDirected);
}


VOID
NdisMSendResourcesAvailable(
    IN  NDIS_HANDLE             MiniportAdapterHandle
    )
/*++

Routine Description:

    This function indicates that some send resources are available and are free for
    processing more sends.

Arguments:

    MiniportAdapterHandle - points to the adapter block.

Return Value:

    None.


--*/
{
    PNDIS_MINIPORT_BLOCK Miniport = (PNDIS_MINIPORT_BLOCK)MiniportAdapterHandle;

    DBGPRINT(DBG_COMP_SEND, DBG_LEVEL_INFO,
            ("==>ndisMSendResourcesAvailable\n"));

    ASSERT(MINIPORT_AT_DPC_LEVEL);


    ADD_RESOURCE(Miniport, 'V');

    //
    //  Are there more sends to process?
    //
    if (Miniport->FirstPendingPacket != NULL)
    {
        NDIS_ACQUIRE_MINIPORT_SPIN_LOCK_DPC(Miniport);
        ASSERT(!IsListEmpty(&Miniport->PacketList));
        NDISM_QUEUE_WORK_ITEM(Miniport, NdisWorkItemSend, NULL);
        NDIS_RELEASE_MINIPORT_SPIN_LOCK_DPC(Miniport);
    }

    DBGPRINT(DBG_COMP_SEND, DBG_LEVEL_INFO,
        ("<==ndisMSendResourcesAvailable\n"));
}


VOID
NdisMTransferDataComplete(
    IN  NDIS_HANDLE             MiniportAdapterHandle,
    IN  PNDIS_PACKET            Packet,
    IN  NDIS_STATUS             Status,
    IN  UINT                    BytesTransferred
    )
/*++

Routine Description:

    This function indicates the completion of a transfer data request.

Arguments:

    MiniportAdapterHandle - points to the adapter block.

    Packet - The packet the data was copied into.

    Status - Status of the operation.

    BytesTransferred - Total number of bytes transferred.

Return Value:

    None.


--*/
{
    PNDIS_MINIPORT_BLOCK Miniport = (PNDIS_MINIPORT_BLOCK)MiniportAdapterHandle;
    PNDIS_OPEN_BLOCK     Open = NULL;
    KIRQL                OldIrql;

    ASSERT_MINIPORT_LOCKED(Miniport);

//    GET_CURRENT_XFER_DATA_PACKET_STACK(Packet, Open);
    GET_CURRENT_XFER_DATA_PACKET_STACK_AND_ZERO_OUT(Packet, Open);

    if (Open)
    {
        POP_XFER_DATA_PACKET_STACK(Packet);

        if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_DESERIALIZE))
        {
            RAISE_IRQL_TO_DISPATCH(&OldIrql);
        }


        //
        // Indicate to Protocol;
        //

        (Open->TransferDataCompleteHandler)(Open->ProtocolBindingContext,
                                            Packet,
                                            Status,
                                            BytesTransferred);

        if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_DESERIALIZE))
        {
            LOWER_IRQL(OldIrql, DISPATCH_LEVEL);
        }
    }
}


NDIS_STATUS
ndisMTransferData(
    IN  NDIS_HANDLE             NdisBindingHandle,
    IN  NDIS_HANDLE             MacReceiveContext,
    IN  UINT                    ByteOffset,
    IN  UINT                    BytesToTransfer,
    IN  OUT PNDIS_PACKET        Packet,
    OUT PUINT                   BytesTransferred
    )
{
    PNDIS_OPEN_BLOCK        Open = (PNDIS_OPEN_BLOCK)NdisBindingHandle;
    PNDIS_MINIPORT_BLOCK    Miniport = Open->MiniportHandle;
    PNDIS_STACK_RESERVED    NSR;
    NDIS_STATUS             Status;

    ASSERT_MINIPORT_LOCKED(Miniport);

    //
    // Handle non-loopback (non-indicated) as the default case.
    //
    if ((MacReceiveContext == INDICATED_PACKET(Miniport)) &&
        (INDICATED_PACKET(Miniport) != NULL))
    {
        PNDIS_PACKET_OOB_DATA   pOob;

        //
        // This packet is a indicated (or possibly a loopback) packet
        //
        pOob = NDIS_OOB_DATA_FROM_PACKET((PNDIS_PACKET)MacReceiveContext);
        NdisCopyFromPacketToPacketSafe(Packet,
                                       0,
                                       BytesToTransfer,
                                       (PNDIS_PACKET)MacReceiveContext,
                                       ByteOffset + pOob->HeaderSize,
                                       BytesTransferred,
                                       NormalPagePriority);
    
        Status = (*BytesTransferred == BytesToTransfer) ? NDIS_STATUS_SUCCESS : NDIS_STATUS_FAILURE;
    }
    else
    {
        PUSH_XFER_DATA_PACKET_STACK(Packet);
        
        if (CONTAINING_RECORD(Packet, NDIS_PACKET_WRAPPER, Packet)->StackIndex.XferDataIndex >= 3 * ndisPacketStackSize)
        {
            POP_XFER_DATA_PACKET_STACK(Packet);
            Status = NDIS_STATUS_RESOURCES;
        }
        else
        {
            PNDIS_BUFFER    Buffer = Packet->Private.Head;
            
            Status = NDIS_STATUS_SUCCESS;

            if (!MINIPORT_TEST_SEND_FLAG(Miniport, fMINIPORT_SEND_DO_NOT_MAP_MDLS))
            {
                //
                // miniport will not use safe APIs
                // so map the buffers in destination packet
                //
                Buffer = Packet->Private.Head;

                while (Buffer != NULL)
                {
                    if (MDL_ADDRESS_SAFE(Buffer, HighPagePriority) == NULL)
                    {
                        Status = NDIS_STATUS_RESOURCES;
                        break;
                    }
                    Buffer = Buffer->Next;
                }
            }
            
            if (Status == NDIS_STATUS_SUCCESS)
            {
                SET_CURRENT_XFER_DATA_PACKET_STACK(Packet, Open)

                //
                // Call Miniport.
                //
                Status = (Open->WTransferDataHandler)(Packet,
                                                      BytesTransferred,
                                                      Open->MiniportAdapterContext,
                                                      MacReceiveContext,
                                                      ByteOffset,
                                                      BytesToTransfer);
                if (Status != NDIS_STATUS_PENDING)
                {
                    SET_CURRENT_XFER_DATA_PACKET_STACK(Packet, 0);
                    POP_XFER_DATA_PACKET_STACK(Packet);
                }
            }
        }
    }

    return Status;
}


NDIS_STATUS
ndisMWanSend(
    IN  NDIS_HANDLE             NdisBindingHandle,
    IN  NDIS_HANDLE             NdisLinkHandle,
    IN  PNDIS_WAN_PACKET        Packet
    )
{
    PNDIS_OPEN_BLOCK        Open = ((PNDIS_OPEN_BLOCK)NdisBindingHandle);
    PNDIS_MINIPORT_BLOCK    Miniport = Open->MiniportHandle;
    NDIS_STATUS             Status;
    BOOLEAN                 LocalLock;
    KIRQL                   OldIrql;

    DBGPRINT(DBG_COMP_SEND, DBG_LEVEL_INFO,
            ("==>ndisMWanSend\n"));

    if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_PM_HALTING))
    {
        return NDIS_STATUS_FAILURE;
    }

    if (!MINIPORT_TEST_FLAG(Miniport, fMINIPORT_DESERIALIZE))
    {
        NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Miniport, &OldIrql);
        LOCK_MINIPORT(Miniport, LocalLock);
    }

    if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_DESERIALIZE) || LocalLock)
    {
        //
        // Call Miniport to send WAN packet
        //
        if (!MINIPORT_TEST_FLAG(Miniport, fMINIPORT_DESERIALIZE))
        {
            NDIS_RELEASE_MINIPORT_SPIN_LOCK_DPC(Miniport);
        }

        Status = (Miniport->DriverHandle->MiniportCharacteristics.WanSendHandler)(
                            Miniport->MiniportAdapterContext,
                            NdisLinkHandle,
                            Packet);

        if (!MINIPORT_TEST_FLAG(Miniport, fMINIPORT_DESERIALIZE))
        {
            NDIS_ACQUIRE_MINIPORT_SPIN_LOCK_DPC(Miniport);
        }

        //
        //  Process the status of the send.
        //
        if (NDIS_STATUS_PENDING == Status)
        {
            DBGPRINT(DBG_COMP_SEND, DBG_LEVEL_INFO,
                    ("ndisMWanSend: send is pending\n"));
        }
        else
        {
            DBGPRINT(DBG_COMP_SEND, DBG_LEVEL_INFO,
                    ("ndisMWanSend: Completed 0x%x\n", Status));
        }
    }
    else
    {
        LINK_WAN_PACKET(Miniport, Packet);
        Packet->MacReserved1 = NdisLinkHandle;
        NDISM_QUEUE_WORK_ITEM(Miniport, NdisWorkItemSend, NULL);

        if (LocalLock)
        {
            NDISM_PROCESS_DEFERRED(Miniport);
        }
        Status = NDIS_STATUS_PENDING;
    }

    if (!MINIPORT_TEST_FLAG(Miniport, fMINIPORT_DESERIALIZE))
    {
        UNLOCK_MINIPORT(Miniport, LocalLock);
        NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);
    }

    DBGPRINT(DBG_COMP_SEND, DBG_LEVEL_INFO,
            ("<==ndisMWanSend\n"));

    return Status;
}


VOID
NdisMWanSendComplete(
    IN  NDIS_HANDLE             MiniportAdapterHandle,
    IN  PNDIS_WAN_PACKET        Packet,
    IN  NDIS_STATUS             Status
    )
/*++

Routine Description:

    This function indicates the status is complete.

Arguments:

    MiniportAdapterHandle - points to the adapter block.

Return Value:

    None.

--*/
{
    PNDIS_MINIPORT_BLOCK    Miniport = (PNDIS_MINIPORT_BLOCK)MiniportAdapterHandle;
    PNDIS_OPEN_BLOCK        Open;
    KIRQL                   OldIrql;

    ASSERT_MINIPORT_LOCKED(Miniport);

    DBGPRINT(DBG_COMP_SEND, DBG_LEVEL_INFO,
        ("==>ndisMWanSendComplete\n"));
    DBGPRINT(DBG_COMP_SEND, DBG_LEVEL_INFO,
        ("packet 0x%x\n", Packet));

    ASSERT_MINIPORT_LOCKED(Miniport);

    if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_DESERIALIZE))
    {
        RAISE_IRQL_TO_DISPATCH(&OldIrql);
    }

    NDIS_ACQUIRE_MINIPORT_SPIN_LOCK_DPC(Miniport);

    for (Open = Miniport->OpenQueue; Open != NULL; Open = Open->MiniportNextOpen)
    {
        //
        // Call Protocol to complete open
        //
        NDIS_RELEASE_MINIPORT_SPIN_LOCK_DPC(Miniport);
        
        (Open->ProtocolHandle->ProtocolCharacteristics.WanSendCompleteHandler)(
            Open->ProtocolBindingContext,
            Packet,
            Status);

        NDIS_ACQUIRE_MINIPORT_SPIN_LOCK_DPC(Miniport);
    }

    NDIS_RELEASE_MINIPORT_SPIN_LOCK_DPC(Miniport);

    if (MINIPORT_TEST_FLAG(Miniport, fMINIPORT_DESERIALIZE))
    {
        LOWER_IRQL(OldIrql, DISPATCH_LEVEL);
    }

    DBGPRINT(DBG_COMP_SEND, DBG_LEVEL_INFO,
            ("<==ndisMWanSendComplete\n"));
}

BOOLEAN
FASTCALL
ndisMStartWanSends(
    IN  PNDIS_MINIPORT_BLOCK    Miniport
    )
/*++

Routine Description:

    Submits as many sends as possible to the WAN mini-port.

Arguments:

    Miniport - Miniport to send to.

Return Value:

    None

--*/
{
    PNDIS_WAN_PACKET        Packet;
    PLIST_ENTRY             Link;
    NDIS_STATUS             Status;
    PNDIS_M_OPEN_BLOCK      Open;

    ASSERT_MINIPORT_LOCKED(Miniport);

    DBGPRINT(DBG_COMP_SEND, DBG_LEVEL_INFO,
            ("==>ndisMStartSends\n"));

    while (!IsListEmpty(&Miniport->PacketList))
    {
        Link = Miniport->PacketList.Flink;
        Packet = CONTAINING_RECORD(Link, NDIS_WAN_PACKET, WanPacketQueue);
        UNLINK_WAN_PACKET(Packet);

        //
        // Call Miniport to send WAN packet
        //
        NDIS_RELEASE_MINIPORT_SPIN_LOCK_DPC(Miniport);

        Status = (Miniport->DriverHandle->MiniportCharacteristics.WanSendHandler)(
                            Miniport->MiniportAdapterContext,
                            Packet->MacReserved1,
                            Packet);

        //
        //  Process the status of the send.
        //
        if (NDIS_STATUS_PENDING == Status)
        {
            DBGPRINT(DBG_COMP_SEND, DBG_LEVEL_INFO,
                    ("ndisMWanSend: send is pending\n"));
        }
        else
        {
            DBGPRINT(DBG_COMP_SEND, DBG_LEVEL_INFO,
                    ("ndisMWanSend: Completed 0x%x\n", Status));
            NdisMWanSendComplete(Miniport, Packet, Status);
        }

        NDIS_ACQUIRE_MINIPORT_SPIN_LOCK_DPC(Miniport);
    }

    DBGPRINT(DBG_COMP_SEND, DBG_LEVEL_INFO,
            ("<==ndisMStartSends\n"));

    return(FALSE);
}


VOID
ndisMCopyFromPacketToBuffer(
    IN  PNDIS_PACKET            Packet,
    IN  UINT                    Offset,
    IN  UINT                    BytesToCopy,
    OUT PCHAR                   Buffer,
    OUT PUINT                   BytesCopied
    )
/*++

Routine Description:

    Copy from an ndis packet into a buffer.

Arguments:

    Packet - The packet to copy from.

    Offset - The offset from which to start the copy.

    BytesToCopy - The number of bytes to copy from the packet.

    Buffer - The destination of the copy.

    BytesCopied - The number of bytes actually copied.  Can be less then
    BytesToCopy if the packet is shorter than BytesToCopy.

Return Value:

    None

--*/
{
    //
    // Holds the number of ndis buffers comprising the packet.
    //
    UINT NdisBufferCount;

    //
    // Points to the buffer from which we are extracting data.
    //
    PNDIS_BUFFER CurrentBuffer;

    //
    // Holds the virtual address of the current buffer.
    //
    PVOID VirtualAddress;

    //
    // Holds the length of the current buffer of the packet.
    //
    UINT CurrentLength;

    //
    // Keep a local variable of BytesCopied so we aren't referencing
    // through a pointer.
    //
    UINT LocalBytesCopied = 0;

    //
    // Take care of boundary condition of zero length copy.
    //

    *BytesCopied = 0;
    if (!BytesToCopy)
        return;

    //
    // Get the first buffer.
    //

    NdisQueryPacket(Packet,
                    NULL,
                    &NdisBufferCount,
                    &CurrentBuffer,
                    NULL);

    //
    // Could have a null packet.
    //

    if (!NdisBufferCount)
        return;

    VirtualAddress = MDL_ADDRESS_SAFE(CurrentBuffer, NormalPagePriority);
    CurrentLength = MDL_SIZE(CurrentBuffer);
    
    while (LocalBytesCopied < BytesToCopy)
    {
        if (CurrentLength == 0)
        {
            NdisGetNextBuffer(CurrentBuffer, &CurrentBuffer);

            //
            // We've reached the end of the packet. We return
            // with what we've done so far. (Which must be shorter
            // than requested.
            //

            if (!CurrentBuffer)
                break;

            NdisQueryBuffer(CurrentBuffer, &VirtualAddress, &CurrentLength);
            continue;
        }

        //
        // Try to get us up to the point to start the copy.
        //

        if (Offset)
        {
            if (Offset > CurrentLength)
            {
                //
                // What we want isn't in this buffer.
                //

                Offset -= CurrentLength;
                CurrentLength = 0;
                continue;
            }
            else
            {
                VirtualAddress = (PCHAR)VirtualAddress + Offset;
                CurrentLength -= Offset;
                Offset = 0;
            }
        }

        //
        // Copy the data.
        //
        {
            //
            // Holds the amount of data to move.
            //
            UINT AmountToMove;

            AmountToMove = ((CurrentLength <= (BytesToCopy - LocalBytesCopied)) ?
                            (CurrentLength):
                            (BytesToCopy - LocalBytesCopied));

            MoveMemory(Buffer, VirtualAddress, AmountToMove);

            Buffer = (PCHAR)Buffer + AmountToMove;
            VirtualAddress = (PCHAR)VirtualAddress + AmountToMove;

            LocalBytesCopied += AmountToMove;
            CurrentLength -= AmountToMove;
        }
    }

    *BytesCopied = LocalBytesCopied;
}

NDIS_STATUS
ndisMRejectSend(
    IN  NDIS_HANDLE             NdisBindingHandle,
    IN  PNDIS_PACKET            Packet
    )
/*++

Routine Description:

    This routine handles any error cases where a protocol binds to an Atm
    miniport and tries to use the normal NdisSend() call.

Arguments:

    NdisBindingHandle - Handle returned by NdisOpenAdapter.

    Packet - the Ndis packet to send


Return Value:

    NDIS_STATUS - always fails

--*/
{
    return(NDIS_STATUS_NOT_SUPPORTED);
}


VOID
ndisMRejectSendPackets(
    IN  PNDIS_OPEN_BLOCK        OpenBlock,
    IN  PPNDIS_PACKET           Packet,
    IN  UINT                    NumberOfPackets
    )
/*++

Routine Description:

    This routine handles any error cases where a protocol binds to an Atm
    miniport and tries to use the normal NdisSend() call.

Arguments:

    OpenBlock       - Pointer to the NdisOpenBlock

    Packet          - Pointer to the array of packets to send

    NumberOfPackets - self-explanatory


Return Value:

    None - SendCompleteHandler is called for the protocol calling this.

--*/
{
    UINT                i;

    for (i = 0; i < NumberOfPackets; i++)
    {
        MINIPORT_CLEAR_PACKET_FLAG(Packet[i], fPACKET_CLEAR_ITEMS);
        (*OpenBlock->SendCompleteHandler)(OpenBlock->ProtocolBindingContext,
                                          Packet[i],
                                          NDIS_STATUS_NOT_SUPPORTED);
    }
}


VOID
NdisIMCopySendPerPacketInfo(
    IN PNDIS_PACKET DstPacket,
    IN PNDIS_PACKET SrcPacket
    )
/*++

Routine Description:

    This routine is used by IM miniport and copies all relevant per packet info from 
    the SrcPacket to the DstPacket. Used in the Send Code path
    
Arguments:

    DstPacket - Pointer to the destination packet

    SrcPacket - Pointer to the Source Packet

Return Value:


--*/

{
    PVOID *     pDstInfo;                                                        
    PVOID *     pSrcInfo;                                                        
                                                                               
  
    pDstInfo = NDIS_PACKET_EXTENSION_FROM_PACKET(DstPacket)->NdisPacketInfo;    
    pSrcInfo = NDIS_PACKET_EXTENSION_FROM_PACKET(SrcPacket)->NdisPacketInfo;    
                                                                               
  
    pDstInfo[TcpIpChecksumPacketInfo] = pSrcInfo[TcpIpChecksumPacketInfo];       
    pDstInfo[IpSecPacketInfo] = pSrcInfo[IpSecPacketInfo];                       
    pDstInfo[TcpLargeSendPacketInfo] = pSrcInfo[TcpLargeSendPacketInfo];         
    pDstInfo[ClassificationHandlePacketInfo] = pSrcInfo[ClassificationHandlePacketInfo]; 
    pDstInfo[Ieee8021pPriority] = pSrcInfo[Ieee8021pPriority];                   
    pDstInfo[PacketCancelId] = pSrcInfo[PacketCancelId];                   

    DstPacket->Private.NdisPacketFlags &= ~fPACKET_WRAPPER_RESERVED;
    DstPacket->Private.NdisPacketFlags |= SrcPacket->Private.NdisPacketFlags & fPACKET_WRAPPER_RESERVED;
}



EXPORT
VOID
NdisIMCopySendCompletePerPacketInfo(
    IN PNDIS_PACKET DstPacket, 
    IN PNDIS_PACKET SrcPacket
    )
    
/*++

Routine Description:

    This routine is used by IM miniport and copies all relevant per packet info from 
    the SrcPacket to the DstPacket. Used in the SendComplete Code path
    
Arguments:

    DstPacket - Pointer to the destination packet

    SrcPacket - Pointer to the Source Packet

Return Value:


--*/



{
    PVOID *     pDstInfo;                                                        
  
    pDstInfo = NDIS_PACKET_EXTENSION_FROM_PACKET(DstPacket)->NdisPacketInfo;    
  
    pDstInfo[TcpLargeSendPacketInfo] = NDIS_PER_PACKET_INFO_FROM_PACKET(SrcPacket, TcpLargeSendPacketInfo);         

}


VOID
ndisMSendPacketsSG(
    IN  NDIS_HANDLE             NdisBindingHandle,
    IN  PPNDIS_PACKET           PacketArray,
    IN  UINT                    NumberOfPackets
    )
{
    PNDIS_OPEN_BLOCK        Open =  (PNDIS_OPEN_BLOCK)NdisBindingHandle;
    PNDIS_STACK_RESERVED    NSR;
    PNDIS_MINIPORT_BLOCK    Miniport = Open->MiniportHandle;
    BOOLEAN                 LocalLock;
    NDIS_STATUS             Status;
    KIRQL                   OldIrql;
    UINT                    c;
    PPNDIS_PACKET           pPktArray;;

    DBGPRINT(DBG_COMP_SEND, DBG_LEVEL_INFO,
            ("==>ndisMSendPacketsSG\n"));

    ASSERT(MINIPORT_TEST_FLAG(Miniport, fMINIPORT_SG_LIST));
    
    NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Miniport, &OldIrql);

    Status = NDIS_STATUS_SUCCESS;
    
    //
    //  Place the packets on the miniport queue.
    //
    for (c = 0, pPktArray = PacketArray;
         c < NumberOfPackets;
         c++, pPktArray++)
    {
        PNDIS_PACKET    Packet = *pPktArray;
        ASSERT(Packet != NULL);

        PUSH_PACKET_STACK(Packet);
        NDIS_STACK_RESERVED_FROM_PACKET(Packet, &NSR);
        NSR->Open = Open;

        CHECK_FOR_DUPLICATE_PACKET(Miniport, Packet);

        if (MINIPORT_TEST_SEND_FLAG(Miniport, fMINIPORT_SEND_DO_NOT_MAP_MDLS))
        {
            ndisMCheckPacketAndGetStatsOutAlreadyMapped(Miniport, Packet);
        }
        else
        {
            ndisMCheckPacketAndGetStatsOut(Miniport, Packet, &Status);
        }

        NDIS_SET_PACKET_STATUS(Packet, NDIS_STATUS_PENDING);

        MINIPORT_CLEAR_PACKET_FLAG(Packet, fPACKET_SELF_DIRECTED);

        DBGPRINT(DBG_COMP_OPENREF, DBG_LEVEL_INFO,
            ("+ Open 0x%x Reference 0x%x\n", NdisBindingHandle, Open->References));

        M_OPEN_INCREMENT_REF_INTERLOCKED(Open);

        if (Status != NDIS_STATUS_SUCCESS)
        {
            NDISM_COMPLETE_SEND_SG(Miniport, Packet, NSR, Status, TRUE, 0, FALSE);
        }
        else
        {
            NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);
            ndisMAllocSGListS(Miniport, Packet);
            NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Miniport, &OldIrql);
        }

    }

    NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);

    DBGPRINT(DBG_COMP_SEND, DBG_LEVEL_INFO,
            ("<==ndisMSendPacketsSG\n"));
}

NDIS_STATUS
ndisMSendSG(
    IN  NDIS_HANDLE             NdisBindingHandle,
    IN  PNDIS_PACKET            Packet
    )
/*++

Routine Description:
    nsiaMSend for serialized drivers that handle SG lists

Arguments:


Return Value:

    None.

--*/
{
    PNDIS_OPEN_BLOCK        Open = ((PNDIS_OPEN_BLOCK)NdisBindingHandle);
    PNDIS_MINIPORT_BLOCK    Miniport = Open->MiniportHandle;
    PNDIS_STACK_RESERVED    NSR;
    PNDIS_PACKET_EXTENSION  PktExt;
    NDIS_STATUS             Status;
    BOOLEAN                 LocalLock;
    KIRQL                   OldIrql;

    DBGPRINT(DBG_COMP_SEND, DBG_LEVEL_INFO,
            ("==>ndisMSendSG\n"));
    
    ASSERT(MINIPORT_TEST_FLAG(Miniport, fMINIPORT_SG_LIST));

    NDIS_ACQUIRE_MINIPORT_SPIN_LOCK(Miniport, &OldIrql);

    CHECK_FOR_DUPLICATE_PACKET(Miniport, Packet);

    if (MINIPORT_TEST_SEND_FLAG(Miniport, fMINIPORT_SEND_DO_NOT_MAP_MDLS))
    {
        Status = NDIS_STATUS_SUCCESS;
        ndisMCheckPacketAndGetStatsOutAlreadyMapped(Miniport, Packet);
    }
    else
    {
        ndisMCheckPacketAndGetStatsOut(Miniport, Packet, &Status);
    }

    if (Status == NDIS_STATUS_SUCCESS)
    {

        MINIPORT_CLEAR_PACKET_FLAG(Packet, fPACKET_SELF_DIRECTED);
    
        //
        //  Increment the references on this open.
        //
        M_OPEN_INCREMENT_REF(Open);
    
        DBGPRINT(DBG_COMP_OPENREF, DBG_LEVEL_INFO,
            ("+ Open 0x%x Reference 0x%x\n", NdisBindingHandle, ((PNDIS_OPEN_BLOCK)NdisBindingHandle)->References));
    
        PUSH_PACKET_STACK(Packet);
        NDIS_STACK_RESERVED_FROM_PACKET(Packet, &NSR)
        NSR->Open = Open;

        Status = NDIS_STATUS_PENDING;
        
        NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);
        ndisMAllocSGListS(Miniport, Packet);
    }
    else
    {
        NDIS_RELEASE_MINIPORT_SPIN_LOCK(Miniport, OldIrql);
    }
    
    DBGPRINT(DBG_COMP_SEND, DBG_LEVEL_INFO,
            ("<==ndisMSendSG\n"));


    return Status;
}

VOID
ndisMSendCompleteSG(
    IN  NDIS_HANDLE             MiniportAdapterHandle,
    IN  PNDIS_PACKET            Packet,
    IN  NDIS_STATUS             Status
    )
/*++

Routine Description:

    This function indicates the completion of a send.

Arguments:

    MiniportAdapterHandle - points to the adapter block.

Return Value:

    None.

--*/
{
    PNDIS_MINIPORT_BLOCK    Miniport = (PNDIS_MINIPORT_BLOCK)MiniportAdapterHandle;
    PNDIS_OPEN_BLOCK        Open;
    PNDIS_STACK_RESERVED    NSR;

    ASSERT_MINIPORT_LOCKED(Miniport);

    DBGPRINT(DBG_COMP_SEND, DBG_LEVEL_INFO,
        ("==>ndisMSendCompleteSG\n"));
    DBGPRINT(DBG_COMP_SEND, DBG_LEVEL_INFO,
        ("packet 0x%x\n", Packet));
    
    NDIS_STACK_RESERVED_FROM_PACKET(Packet, &NSR)

    ASSERT(VALID_OPEN(NSR->Open));
    ASSERT(MINIPORT_TEST_PACKET_FLAG(Packet, fPACKET_PENDING));
    
    //
    // Guard against double/bogus completions.
    //
    if (VALID_OPEN(NSR->Open) &&
        MINIPORT_TEST_PACKET_FLAG(Packet, fPACKET_PENDING))
    {
        ASSERT(Packet != Miniport->FirstPendingPacket);
        if (MINIPORT_TEST_PACKET_FLAG(Packet, fPACKET_DONT_COMPLETE))
        {
            //
            // If the packet completed in the context of a SendPackets, then
            // defer completion. It will get completed when we unwind.
            //
            NDIS_SET_PACKET_STATUS(Packet, Status);
            MINIPORT_CLEAR_PACKET_FLAG(Packet, fPACKET_DONT_COMPLETE);
        }
        else
        {
            NDISM_COMPLETE_SEND_SG(Miniport, Packet, NSR, Status, FALSE, 1, TRUE);
        }
    }

    DBGPRINT(DBG_COMP_SEND, DBG_LEVEL_INFO,
            ("<==ndisMSendCompleteSG\n"));
}


BOOLEAN
FASTCALL
ndisMStartSendPacketsSG(
    IN  PNDIS_MINIPORT_BLOCK    Miniport
    )
{
    PNDIS_PACKET            Packet;
    NDIS_STATUS             Status;
    PNDIS_STACK_RESERVED    NSR;
    PPNDIS_PACKET           pPktArray;
    PNDIS_PACKET            PacketArray[SEND_PACKET_ARRAY];
    UINT                    MaxPkts = Miniport->MaxSendPackets;
    W_SEND_PACKETS_HANDLER  SendPacketsHandler = Miniport->WSendPacketsHandler;
    BOOLEAN                 SelfDirected;

    ASSERT_MINIPORT_LOCKED(Miniport);

    DBGPRINT(DBG_COMP_SEND, DBG_LEVEL_INFO,
            ("==>ndisMStartSendPacketsSG\n"));

    //
    // We could possibly end up with a situation (with intermediate serialized
    // miniports) where there are no packets down with the driver and we the
    // resource window is closed. In such a case open it fully. We are seeing this
    // with wlbs
    //
    if (!MINIPORT_TEST_FLAG(Miniport, fMINIPORT_RESOURCES_AVAILABLE) &&
        (Miniport->FirstPendingPacket == NULL))
    {
        ADD_RESOURCE(Miniport, 'X');
    }

    //
    // Work-around for a scenario we are hitting when PacketList is empty but FirstPendingPacket is NOT
    // Not sure how this can happen - yet.
    //
    if (IsListEmpty(&Miniport->PacketList))
    {
        ASSERT (Miniport->FirstPendingPacket == NULL);
        Miniport->FirstPendingPacket = NULL;
    }

    while ((Miniport->FirstPendingPacket != NULL) &&
            MINIPORT_TEST_FLAG(Miniport, fMINIPORT_RESOURCES_AVAILABLE))
    {
        UINT            Count;
        UINT            NumberOfPackets;

        ASSERT(!IsListEmpty(&Miniport->PacketList));

        //
        //  Initialize the packet array.
        //
        pPktArray = PacketArray;

        //
        //  Place as many packets as we can in the packet array to send
        //  to the miniport.
        //
        for (NumberOfPackets = 0;
             (NumberOfPackets < MaxPkts) && (Miniport->FirstPendingPacket != NULL);
             NOTHING)
        {
            //
            //  Grab the packet off of the pending queue.
            //
            ASSERT(!IsListEmpty(&Miniport->PacketList));

            Packet = Miniport->FirstPendingPacket;
            NDIS_STACK_RESERVED_FROM_PACKET(Packet, &NSR)
            
            ASSERT(VALID_OPEN(NSR->Open));

            NEXT_PACKET_PENDING(Miniport, Packet, NSR);
        
            //
            // Indicate the packet loopback if necessary.
            //

            if (NDIS_CHECK_FOR_LOOPBACK(Miniport, Packet))
            {
                SelfDirected = ndisMLoopbackPacketX(Miniport, Packet);
            }
            else
            {
                SelfDirected = FALSE;
            }

            if (SelfDirected)
            {
                DBGPRINT(DBG_COMP_SEND, DBG_LEVEL_INFO,
                    ("Packet 0x%x is self-directed.\n", Packet));

                //
                //  Complete the packet back to the binding.
                //
                NDISM_COMPLETE_SEND_SG(Miniport, Packet, NSR, NDIS_STATUS_SUCCESS, TRUE, 2, TRUE);

                //
                //  No, we don't want to increment the counter for the
                //  miniport's packet array.
                //
            }
            else
            {
                //
                //  We have to re-initialize this.
                //
                *pPktArray = Packet;
                MINIPORT_SET_PACKET_FLAG(Packet, (fPACKET_DONT_COMPLETE | fPACKET_PENDING));
                NDIS_SET_PACKET_STATUS(Packet, NDIS_STATUS_SUCCESS);

                //
                //  Increment the counter for the packet array index.
                //
                NumberOfPackets++;
                pPktArray++;
            }
        }

        //
        //  Are there any packets to send?
        //
        if (NumberOfPackets == 0)
        {
            break;
        }

        pPktArray = PacketArray;

        {

            //
            //  Pass the packet array down to the miniport.
            //
            NDIS_RELEASE_MINIPORT_SPIN_LOCK_DPC(Miniport);
    
            (SendPacketsHandler)(Miniport->MiniportAdapterContext,
                                 pPktArray,
                                 NumberOfPackets);
    
            NDIS_ACQUIRE_MINIPORT_SPIN_LOCK_DPC(Miniport);
        }

        //
        //  Process the packet completion.
        //
        for (Count = 0; Count < NumberOfPackets; Count++, pPktArray++)
        {
            Packet = *pPktArray;
            ASSERT(Packet != NULL);

            Status = NDIS_GET_PACKET_STATUS(*pPktArray);
            MINIPORT_CLEAR_PACKET_FLAG(Packet, fPACKET_DONT_COMPLETE);

            //
            //  Process the packet based on it's return status.
            //
            if (NDIS_STATUS_PENDING == Status)
            {
                DBGPRINT(DBG_COMP_SEND, DBG_LEVEL_INFO,
                    ("Complete is pending\n"));
            }
            else if (Status != NDIS_STATUS_RESOURCES)
            {
                //
                //  Remove from the finish queue.
                //
                DBGPRINT(DBG_COMP_SEND, DBG_LEVEL_INFO,
                        ("Completed packet 0x%x with status 0x%x\n",
                        Packet, Status));

                NDIS_STACK_RESERVED_FROM_PACKET(Packet, &NSR)
                if (VALID_OPEN(NSR->Open))
                {
                    NDISM_COMPLETE_SEND_SG(Miniport, Packet, NSR, Status, TRUE, 3, TRUE);
                }
            }
            else
            {
                //
                //  Once we hit a return code of NDIS_STATUS_RESOURCES
                //  for a packet then we must break out and re-queue.
                //
                UINT    i;

                Miniport->FirstPendingPacket = Packet;
                CLEAR_RESOURCE(Miniport, 'S');
                for (i = Count; i < NumberOfPackets; i++)
                {
                    PNDIS_PACKET    Packet = PacketArray[i];

                    MINIPORT_CLEAR_PACKET_FLAG(Packet, fPACKET_PENDING);
                    VALIDATE_PACKET_OPEN(Packet);
                }
                break;
            }
        }
    }

    DBGPRINT(DBG_COMP_SEND, DBG_LEVEL_INFO,
            ("<==ndisMStartSendPacketsSG\n"));

    return(FALSE);
}


BOOLEAN
FASTCALL
ndisMStartSendsSG(
    IN  PNDIS_MINIPORT_BLOCK    Miniport
    )
/*++

Routine Description:

    Submits as many sends as possible to the mini-port.

Arguments:

    Miniport - Miniport to send to.

Return Value:

    If there are more packets to send but no resources to do it with
    the this is TRUE to keep a workitem queue'd.

--*/
{
    PNDIS_PACKET            Packet;
    PNDIS_STACK_RESERVED    NSR;
    NDIS_STATUS             Status;
    PNDIS_OPEN_BLOCK        Open;

    ASSERT_MINIPORT_LOCKED(Miniport);

    DBGPRINT(DBG_COMP_SEND, DBG_LEVEL_INFO,
            ("==>ndisMStartSendsSG\n"));

    while ((Miniport->FirstPendingPacket != NULL) &&
           MINIPORT_TEST_FLAG(Miniport, fMINIPORT_RESOURCES_AVAILABLE))
    {
        //
        //  Grab the packet off of the pending queue.
        //
        ASSERT(!IsListEmpty(&Miniport->PacketList));
    
        Packet = Miniport->FirstPendingPacket;
        NDIS_STACK_RESERVED_FROM_PACKET(Packet, &NSR)
        NEXT_PACKET_PENDING(Miniport, Packet, NSR);

        Open = NSR->Open;
        ASSERT(VALID_OPEN(Open));

        //
        // we can use the same NDISM_SEND_PACKET we do for non SG miniports
        //
        NDISM_SEND_PACKET(Miniport, Open, Packet, &Status);

        //
        //  Process the packet pending completion status.
        //
        if (NDIS_STATUS_PENDING == Status)
        {
            DBGPRINT(DBG_COMP_SEND, DBG_LEVEL_INFO, ("Complete is pending\n"));
        }
        else
        {
            MINIPORT_CLEAR_PACKET_FLAG(Packet, fPACKET_PENDING);

            //
            //  Handle the completion and resources cases.
            //
            if (Status == NDIS_STATUS_RESOURCES)
            {
                NDISM_COMPLETE_SEND_RESOURCES(Miniport, NSR, Packet);
            }
            else
            {
                NDISM_COMPLETE_SEND_SG(Miniport, Packet, NSR, Status, TRUE, 4, TRUE);
            }
        }
    }

    DBGPRINT(DBG_COMP_SEND, DBG_LEVEL_INFO,
            ("<==ndisMStartSendsSG\n"));

    return(FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\net\ndis\sys\protos.h ===
/*++

Copyright (c) 1990-1995  Microsoft Corporation

Module Name:

    protos.h

Abstract:

    NDIS wrapper function prototypes

Author:


Environment:

    Kernel mode, FSD

Revision History:

    Jun-95  Jameel Hyder    Split up from a monolithic file
--*/

NTSTATUS
DriverEntry(
    IN  PDRIVER_OBJECT                  DriverObject,
    IN  PUNICODE_STRING                 RegistryPath
    );

#if NDIS_UNLOAD        
VOID
ndisUnload(
    IN  PDRIVER_OBJECT                  DriverObject
    );
#endif

NTSTATUS
ndisBuildDeviceAcl(
    OUT PACL                    *DeviceAcl,
    IN  BOOLEAN                 AddNetConfigOps
    );

NTSTATUS
ndisCreateSecurityDescriptor(
    IN  PDEVICE_OBJECT          DeviceObject,
    OUT PSECURITY_DESCRIPTOR *  pSecurityDescriptor,
    BOOLEAN                     AddNetConfigOps
    );

BOOLEAN
ndisCheckAccess (
    PIRP                    Irp,
    PIO_STACK_LOCATION      IrpSp,
    PNTSTATUS               Status,
    PSECURITY_DESCRIPTOR    SecurityDescriptor
    );

VOID
ndisReadRegistry(
    VOID
    );
    
VOID
ndisWorkerThread(
    IN  PVOID                           Context
    );
    
NTSTATUS
ndisReadRegParameters(
    IN  PWSTR                           ValueName,
    IN  ULONG                           ValueType,
    IN  PVOID                           ValueData,
    IN  ULONG                           ValueLength,
    IN  PVOID                           Context,
    IN  PVOID                           EntryContext
    );

NTSTATUS
ndisReadProcessorAffinityMask(
    IN  PWSTR                           ValueName,
    IN  ULONG                           ValueType,
    IN  PVOID                           ValueData,
    IN  ULONG                           ValueLength,
    IN  PVOID                           Context,
    IN  PVOID                           EntryContext
    );

NTSTATUS
ndisAddMediaTypeToArray(
    IN  PWSTR                           ValueName,
    IN  ULONG                           ValueType,
    IN  PVOID                           ValueData,
    IN  ULONG                           ValueLength,
    IN  PVOID                           Context,
    IN  PVOID                           EntryContext
    );

NDIS_STATUS
ndisCloseAllBindingsOnProtocol(
    PNDIS_PROTOCOL_BLOCK                Protocol
    );

BOOLEAN
ndisIMCheckDeviceInstance(
    IN  PNDIS_M_DRIVER_BLOCK            MiniBlock,
    IN  PUNICODE_STRING                 DeviceInstance,
    OUT PNDIS_HANDLE                    DeviceContext   OPTIONAL
    );

NDIS_STATUS
ndisIMInitializeDeviceInstance(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  NDIS_HANDLE                     DeviceContext,
    IN  BOOLEAN                         fStartIrp
    );

NDIS_STATUS
ndisIMQueueDeviceInstance(
    IN  PNDIS_M_DRIVER_BLOCK            MiniBlock,
    IN  PNDIS_STRING                    DeviceInstance,
    IN  NDIS_HANDLE                     DeviceContext
    );

NTSTATUS
FASTCALL
ndisPnPQueryRemoveDevice(
    IN  PDEVICE_OBJECT                  DeviceObject,
    IN  PIRP                            Irp
    );

NTSTATUS
FASTCALL
ndisPnPCancelRemoveDevice(
    IN  PDEVICE_OBJECT                  DeviceObject,
    IN  PIRP                            Irp
    );
    
NTSTATUS
FASTCALL
ndisPnPRemoveDevice(
    IN  PDEVICE_OBJECT                  DeviceObject,
    IN  PIRP                            Irp     OPTIONAL
    );
    
VOID
ndisSetDeviceNames(
    IN  PNDIS_STRING                    ExportName,
    OUT PNDIS_STRING                    DeviceName,
    OUT PNDIS_STRING                    BaseName,
    IN  PUCHAR                          Buffer
    );

NTSTATUS
FASTCALL
ndisPnPQueryStopDevice(
    IN  PDEVICE_OBJECT                  DeviceObject,
    IN  PIRP                            Irp
    );

NTSTATUS
FASTCALL
ndisPnPCancelStopDevice(
    IN  PDEVICE_OBJECT                  DeviceObject,
    IN  PIRP                            Irp
    );

NTSTATUS
FASTCALL
ndisPnPStopDevice(
    IN  PDEVICE_OBJECT                  DeviceObject,
    IN  PIRP                            Irp
    );

NDIS_STATUS
ndisTranslateResources(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  CM_RESOURCE_TYPE                ResourceType,
    IN  PHYSICAL_ADDRESS                Resource,
    OUT PPHYSICAL_ADDRESS               pTranslatedResource,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR *pResourceDescriptor OPTIONAL
    );

NTSTATUS
FASTCALL
ndisQueryBusInterface(
    IN  PNDIS_MINIPORT_BLOCK            Miniport
    );

ULONG
ndisGetSetBusConfigSpace(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  ULONG                           Offset,
    IN  PVOID                           Buffer,
    IN  ULONG                           Length,
    IN  ULONG                           WhichSpace,
    IN  BOOLEAN                         Read
    );

VOID
FASTCALL
ndisReinitializeMiniportBlock(
    IN  PNDIS_MINIPORT_BLOCK            Miniport
    );

VOID
FASTCALL
ndisCheckAdapterBindings(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  PNDIS_PROTOCOL_BLOCK            Protocol    OPTIONAL
    );

NDIS_STATUS
FASTCALL
ndisPnPStartDevice(
    IN  PDEVICE_OBJECT                  DeviceObject,
    IN  PIRP                            Irp
    );

NTSTATUS
ndisQueryReferenceBusInterface(
    IN  PDEVICE_OBJECT                  PnpDeviceObject,
    OUT PBUS_INTERFACE_REFERENCE    *   BusInterface
    );

NTSTATUS
ndisPnPAddDevice(
    IN  PDRIVER_OBJECT                  DriverObject,
    IN  PDEVICE_OBJECT                  PhysicalDeviceObject
    );

NTSTATUS
ndisAddDevice(
    IN  PDRIVER_OBJECT                  DriverObject,
    IN  PUNICODE_STRING                 pExportName,
    IN  PDEVICE_OBJECT                  PhysicalDeviceObject,
    IN  ULONG                           Characteristics
    );
    
NTSTATUS
ndisWritePnPCapabilities(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  ULONG                           PnPCapabilities
    );
    
NDIS_STATUS
ndisRegisterMiniportDriver(
    IN  NDIS_HANDLE                     NdisWrapperHandle,
    IN  PNDIS_MINIPORT_CHARACTERISTICS  MiniportCharacteristics,
    IN  UINT                            CharacteristicsLength,
    OUT PNDIS_HANDLE                    DriverHandle
    );

NTSTATUS
ndisDispatchRequest(
    IN  PDEVICE_OBJECT                  pDeviceObject,
    IN  PIRP                            pIrp
    );

NTSTATUS
FASTCALL
ndisHandlePnPRequest(
    IN  PIRP                            pIrp
    );

NTSTATUS
FASTCALL
ndisHandleLegacyTransport(
    IN  PUNICODE_STRING                 pDevice
    );

NTSTATUS
FASTCALL
ndisHandleProtocolBindNotification(
    IN  PUNICODE_STRING                 pDevice,
    IN  PUNICODE_STRING                 Protocol
    );

NTSTATUS
FASTCALL
ndisHandleProtocolUnbindNotification(
    IN  PUNICODE_STRING                 pDevice,
    IN  PUNICODE_STRING                 Protocol
    );

NTSTATUS
ndisHandleProtocolReconfigNotification(
    IN  PUNICODE_STRING                 pDevice,
    IN  PUNICODE_STRING                 Protocol,
    IN  PVOID                           ReConfigBuffer,
    IN  UINT                            ReConfigBufferSize,
    IN  UINT                            Operation
    );

NTSTATUS
FASTCALL
ndisHandleProtocolUnloadNotification(
    IN  PUNICODE_STRING                 Protocol
    );

NTSTATUS
FASTCALL
ndisHandleOrphanDevice(
    IN  PUNICODE_STRING                 pDevice
    );

NTSTATUS
FASTCALL
ndisHandleUModePnPOp(
    IN  PNDIS_PNP_OPERATION             PnPOp
    );

NTSTATUS
FASTCALL
ndisEnumerateInterfaces(
    IN  PNDIS_ENUM_INTF                 EnumIntf,
    IN  UINT                            BufferLength
    );

#if defined(_WIN64)
NTSTATUS
FASTCALL
ndisEnumerateInterfaces32(
    IN  PNDIS_ENUM_INTF32               EnumIntf,
    IN  UINT                            BufferLength
    );
#endif // _WIN64

VOID
ndisFindRootDevice(
    IN  PNDIS_STRING                    DeviceName,
    IN  BOOLEAN                         fTester,
    OUT PNDIS_STRING *                  pBindDeviceName,
    OUT PNDIS_STRING *                  pRootDeviceName,
    OUT PNDIS_MINIPORT_BLOCK *          pMiniport
    );

PNDIS_MINIPORT_BLOCK
ndisFindMiniportOnGlobalList(
    IN  PNDIS_STRING                    DeviceName
    );

NTSTATUS
ndisUnbindProtocol(
    IN  PNDIS_OPEN_BLOCK                Open,
    IN  BOOLEAN                         Notify
    );

VOID
ndisReferenceMiniportByName(
    IN  PUNICODE_STRING                 DeviceName,
    OUT PNDIS_MINIPORT_BLOCK    *       pMiniport
    );

PNDIS_OPEN_BLOCK
FASTCALL
ndisMapOpenByName(
    IN  PUNICODE_STRING                 DeviceName,
    IN  PNDIS_PROTOCOL_BLOCK            Protocol,
    IN  BOOLEAN                         Reference,
    IN  BOOLEAN                         fUnbinding
    );

VOID
NdisMCancelTimer(
    IN  PNDIS_MINIPORT_TIMER            Timer,
    OUT PBOOLEAN                        TimerCancelled
    );

//
// general reference/dereference functions
//

BOOLEAN
FASTCALL
ndisReferenceRef(
    IN  PREFERENCE                      RefP
    );


BOOLEAN
FASTCALL
ndisDereferenceRef(
    IN  PREFERENCE                      RefP
    );


VOID
FASTCALL
ndisInitializeRef(
    IN  PREFERENCE                      RefP
    );


BOOLEAN
FASTCALL
ndisCloseRef(
    IN  PREFERENCE                      RefP
    );

BOOLEAN
FASTCALL
ndisReferenceULongRef(
    IN  PULONG_REFERENCE                RefP
    );

VOID
FASTCALL
ndisReferenceULongRefNoCheck(
    IN  PULONG_REFERENCE                RefP
    );

BOOLEAN
FASTCALL
ndisDereferenceULongRef(
    IN  PULONG_REFERENCE                RefP
    );


VOID
FASTCALL
ndisInitializeULongRef(
    IN  PULONG_REFERENCE                RefP
    );


BOOLEAN
FASTCALL
ndisCloseULongRef(
    IN  PULONG_REFERENCE                RefP
    );

#if DBG
BOOLEAN
FASTCALL
ndisReferenceProtocol(
    IN  PNDIS_PROTOCOL_BLOCK            Protocol
    );
#else
#define ndisReferenceProtocol(ProtP)    ndisReferenceRef(&(ProtP)->Ref)
#endif

NTSTATUS
FASTCALL
ndisReferenceProtocolByName(
    IN  PUNICODE_STRING                 ProtocolName,
    IN OUT  PNDIS_PROTOCOL_BLOCK *      Protocol,
    IN  BOOLEAN                         fPartialMatch
    );


VOID
FASTCALL
ndisDereferenceProtocol(
    IN  PNDIS_PROTOCOL_BLOCK            Protocol
    );


VOID
FASTCALL
ndisDeQueueOpenOnProtocol(
    IN  PNDIS_OPEN_BLOCK                Open,
    IN  PNDIS_PROTOCOL_BLOCK            Protocol
    );

BOOLEAN
ndisCheckPortUsage(
    IN  ULONG                           PortNumber,
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    OUT PULONG                          pTranslatedPort,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR *pResourceDescriptor
    );
    
VOID
ndisImmediateReadWritePort(
    IN  NDIS_HANDLE                     WrapperConfigurationContext,
    IN  ULONG                           Port,
    IN  OUT PVOID                       Data,
    IN  ULONG                           Size,
    IN  BOOLEAN                         Read
    );

BOOLEAN
ndisCheckMemoryUsage(
    IN  ULONG                           Address,
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    OUT PULONG                          pTranslatedAddress,
    OUT PCM_PARTIAL_RESOURCE_DESCRIPTOR *pResourceDescriptor
    );
    
VOID
ndisImmediateReadWriteSharedMemory(
    IN  NDIS_HANDLE                     WrapperConfigurationContext,
    IN  ULONG                           SharedMemoryAddress,
    OUT PUCHAR                          Buffer,
    IN  ULONG                           Length,
    IN  BOOLEAN                         Read
    );
    
NTSTATUS
ndisStartMapping(
    IN   INTERFACE_TYPE                 InterfaceType,
    IN   ULONG                          BusNumber,
    IN   ULONG                          InitialAddress,
    IN   ULONG                          Length,
    IN   ULONG                          AddressSpace,
    OUT PVOID *                         InitialMapping,
    OUT PBOOLEAN                        Mapped
    );

NTSTATUS
ndisEndMapping(
    IN  PVOID                           InitialMapping,
    IN  ULONG                           Length,
    IN  BOOLEAN                         Mapped
    );

NDIS_STATUS
ndisInitializeAdapter(
    IN  PNDIS_M_DRIVER_BLOCK            pMiniBlock,
    IN  PDEVICE_OBJECT                  DeviceObject,
    IN  PUNICODE_STRING                 RegServiceName,
    IN  NDIS_HANDLE                     DeviceContext   OPTIONAL
    );

BOOLEAN
ndisWmiGuidIsAdapterSpecific(
    IN  LPGUID                          guid
    );

NTSTATUS
ndisCreateAdapterInstanceName(
    OUT PUNICODE_STRING *               pAdapterInstanceName,
    IN  PDEVICE_OBJECT                  PhysicalDeviceObject
    );

NDIS_STATUS
ndisInitializeConfiguration(
    OUT PNDIS_WRAPPER_CONFIGURATION_HANDLE  pConfigurationHandle,
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  PUNICODE_STRING                 pExportName
    );

NTSTATUS
ndisReadBindPaths(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  PRTL_QUERY_REGISTRY_TABLE       LQueryTable
    );

NDIS_STATUS
ndisMInitializeAdapter(
    IN  PNDIS_M_DRIVER_BLOCK            pMiniDriver,
    IN  PNDIS_WRAPPER_CONFIGURATION_HANDLE pConfigurationHandle,
    IN  PUNICODE_STRING                 pExportName,
    IN  NDIS_HANDLE                     DeviceContext   OPTIONAL
    );

VOID
FASTCALL
ndisInitializeBinding(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  PNDIS_PROTOCOL_BLOCK            Protocol
    );

BOOLEAN
FASTCALL
ndisProtocolAlreadyBound(
    IN  PNDIS_PROTOCOL_BLOCK            Protocol,
    IN  PNDIS_MINIPORT_BLOCK            Miniport
    );

NTSTATUS
FASTCALL
ndisMShutdownMiniport(
    IN  PNDIS_MINIPORT_BLOCK            Miniport
    );

NDIS_STATUS
FASTCALL
ndisCloseMiniportBindings(
    IN  PNDIS_MINIPORT_BLOCK            Miniport
    );

VOID
ndisCheckProtocolBindings(
    IN  PNDIS_PROTOCOL_BLOCK            Protocol
    );


VOID
ndisMQueuedAllocateSharedHandler(
    IN  PASYNC_WORKITEM                 pWorkItem
    );

VOID
ndisMQueuedFreeSharedHandler(
    IN  PASYNC_WORKITEM                 pWorkItem
    );

/*++
BOOLEAN
ndisReferenceDriver(
    IN  PNDIS_M_DRIVER_BLOCK            DriverP
    );
--*/

#define ndisReferenceDriver(DriverP)    ndisReferenceRef(&(DriverP)->Ref)

VOID
FASTCALL
ndisDereferenceDriver(
    IN  PNDIS_M_DRIVER_BLOCK            DriverP,
    IN  BOOLEAN                         fGlobalLockHeld
    );

BOOLEAN
FASTCALL
ndisQueueMiniportOnDriver(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  PNDIS_M_DRIVER_BLOCK            Driver
    );

VOID
FASTCALL
ndisDeQueueMiniportOnDriver(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  PNDIS_M_DRIVER_BLOCK            Driver
    );


/*++
BOOLEAN
FASTCALL
ndisReferenceMiniport(
    IN  PNDIS_MINIPORT_BLOCK            Miniport
    );
--*/

#if DBG
BOOLEAN 
FASTCALL
ndisReferenceMiniport(
    IN  PNDIS_MINIPORT_BLOCK            Miniport
    );
#else
#define ndisReferenceMiniport(Miniport) ndisReferenceULongRef(&(Miniport)->Ref)
#endif


#ifdef TRACK_MINIPORT_REFCOUNTS
BOOLEAN
ndisReferenceMiniportAndLog(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  UINT                            Line,
    IN  UINT                            Module
    );
    
BOOLEAN
ndisReferenceMiniportAndLogCreate(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  UINT                            Line,
    IN  UINT                            Module,
    IN  PIRP                            Irp
    );
    
#endif

VOID
FASTCALL
ndisDereferenceMiniport(
    IN  PNDIS_MINIPORT_BLOCK            Miniport
    );

VOID
FASTCALL
ndisDeQueueOpenOnMiniport(
    IN  PNDIS_OPEN_BLOCK                MiniportOpen,
    IN  PNDIS_MINIPORT_BLOCK            Miniport
    );

VOID
FASTCALL
ndisInitializePackage(
    IN  PPKG_REF                        pPkg
    );

VOID
FASTCALL
ndisReferencePackage(
    IN  PPKG_REF                        pPkg
    );

VOID
FASTCALL
ndisDereferencePackage(
    IN  PPKG_REF                        pPkg
    );

#define ProtocolReferencePackage()      ndisReferencePackage(&ndisPkgs[NDSP_PKG])
#define MiniportReferencePackage()      ndisReferencePackage(&ndisPkgs[NDSM_PKG])
#define PnPReferencePackage()           ndisReferencePackage(&ndisPkgs[NPNP_PKG])
#define CoReferencePackage()            ndisReferencePackage(&ndisPkgs[NDCO_PKG])
#define EthReferencePackage()           ndisReferencePackage(&ndisPkgs[NDSE_PKG])
#define FddiReferencePackage()          ndisReferencePackage(&ndisPkgs[NDSF_PKG])
#define TrReferencePackage()            ndisReferencePackage(&ndisPkgs[NDST_PKG])
#define ArcReferencePackage()           ndisReferencePackage(&ndisPkgs[NDSA_PKG])

#define ProtocolDereferencePackage()    ndisDereferencePackage(&ndisPkgs[NDSP_PKG])
#define MiniportDereferencePackage()    ndisDereferencePackage(&ndisPkgs[NDSM_PKG])
#define PnPDereferencePackage()         ndisDereferencePackage(&ndisPkgs[NPNP_PKG])
#define CoDereferencePackage()          ndisDereferencePackage(&ndisPkgs[NDCO_PKG])
#define EthDereferencePackage()         ndisDereferencePackage(&ndisPkgs[NDSE_PKG])
#define FddiDereferencePackage()        ndisDereferencePackage(&ndisPkgs[NDSF_PKG])
#define TrDereferencePackage()          ndisDereferencePackage(&ndisPkgs[NDST_PKG])
#define ArcDereferencePackage()         ndisDereferencePackage(&ndisPkgs[NDSA_PKG])


//
// IRP handlers established on behalf of NDIS devices by the wrapper.
//

NTSTATUS
ndisCreateIrpHandler(
    IN  PDEVICE_OBJECT                  DeviceObject,
    IN  PIRP                            Irp
    );

NTSTATUS
ndisDeviceControlIrpHandler(
    IN  PDEVICE_OBJECT                  DeviceObject,
    IN  PIRP                            Irp
    );

NTSTATUS
ndisCloseIrpHandler(
    IN  PDEVICE_OBJECT                  DeviceObject,
    IN  PIRP                            Irp
    );

NTSTATUS
ndisDummyIrpHandler(
    IN  PDEVICE_OBJECT                  DeviceObject,
    IN  PIRP                            Irp
    );

VOID
ndisCancelLogIrp(
    IN  PDEVICE_OBJECT                  DeviceObject,
    IN  PIRP                            Irp
    );

NDIS_STATUS
FASTCALL
ndisMGetLogData(
    IN  PNDIS_MINIPORT_BLOCK            Miniport,
    IN  PIRP                            Irp
    );

BOOLEAN
FASTCALL
ndisQueueOpenOnProtocol(
    IN  PNDIS_OPEN_BLOCK                Open,
    IN  PNDIS_PROTOCOL_BLOCK            Protocol
    );

VOID
NdisCancelTimer(
    IN  PNDIS_TIMER                     Timer,
    OUT PBOOLEAN                        TimerCancelled
    );

//
// Dma operations
//

extern
IO_ALLOCATION_ACTION
ndisDmaExecutionRoutine(
    IN  PDEVICE_OBJECT                  DeviceObject,
    IN  PIRP                            Irp,
    IN  PVOID                           MapRegisterBase,
    IN  PVOID                           Context
    );


//
// Map Registers
//
extern
IO_ALLOCATION_ACTION
ndisAllocationExecutionRoutine(
    IN  PDEVICE_OBJECT                  DeviceObject,
    IN  PIRP                            Irp,
    IN  PVOID                           MapRegisterBase,
    IN  PVOID                           Context
    );

#undef NdisMSendResourcesAvailable
VOID
NdisMSendResourcesAvailable(
    IN  NDIS_HANDLE                     MiniportAdapterHandle
    );

#undef NdisMResetComplete
VOID
NdisMResetComplete(
    IN  NDIS_HANDLE                     MiniportAdapterHandle,
    IN  NDIS_STATUS                     Status,
    IN  BOOLEAN                         AddressingReset
    );

NTSTATUS
ndisSaveParameters(
    IN  PWSTR                           ValueName,
    IN  ULONG                           ValueType,
    IN  PVOID                           ValueData,
    IN  ULONG                           ValueLength,
    IN  PVOID                           Context,
    IN  PVOID                           EntryContext
    );

NTSTATUS
ndisReadParameter(
    IN  PWSTR                           ValueName,
    IN  ULONG                        