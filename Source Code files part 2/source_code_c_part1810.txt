;
                }

                if (pshare->pszRemoteName)
                {
                    LocalFree(pshare->pszRemoteName);
                }

                delete pshare;
                pshare = NULL;
            }
        }
    }

    _csDL.Leave();

    return pshare;
}


HKEY CMtPtRemote::GetRegKey()
{
    TraceMsg(TF_MOUNTPOINT, "CMtPtRemote::GetRegKey: for '%s'", _GetNameDebug());

    return RSDuplicateRootKey();
}

// static
void CMtPtRemote::_NotifyReconnectedNetDrive(LPCWSTR pszMountPoint)
{
    _csDL.Enter();

    CMtPtRemote* pmtptr = CMountPoint::_rgMtPtDriveLetterNet[
        DRIVEID(pszMountPoint)];

    if (pmtptr)
    {
        pmtptr->_pshare->dwGFAGVILastCall = GetTickCount() - 35001;
    }

    // ChangeNotify???

    _csDL.Leave();
}

// static
HRESULT CMtPtRemote::_RemoveShareFromHDPA(CShare* pshare)
{
    _csDL.Enter();

    if (_hdpaShares)
    {
        DWORD c = DPA_GetPtrCount(_hdpaShares);

        for (DWORD dw = 0; dw < c; ++dw)
        {
            CShare* pshare2 = (CShare*)DPA_GetPtr(_hdpaShares, dw);

            if (pshare2 && (pshare2 == pshare))
            {
                DPA_DeletePtr(_hdpaShares, dw);
                break;
            }
        }
    }

    _csDL.Leave();

    return S_OK;
}

DWORD CMtPtRemote::_GetAutorunContentType()
{
    return _GetMTPTContentType();
}

DWORD CMtPtRemote::_GetMTPTDriveType()
{
    return DT_REMOTE;
}

DWORD CMtPtRemote::_GetMTPTContentType()
{
    DWORD dwRet = CT_UNKNOWNCONTENT;

    if (_IsAutorun())
    {
        dwRet |= CT_AUTORUNINF;
    }

    return dwRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\mtptr.h ===
#include "mtpt.h"

class CShare;

class CMtPtRemote : public CMountPoint
{
///////////////////////////////////////////////////////////////////////////////
// Public methods
///////////////////////////////////////////////////////////////////////////////
public:
    CMtPtRemote();
    ~CMtPtRemote();

    // virtual override
    BOOL IsUnavailableNetDrive();
    BOOL IsDisconnectedNetDrive();

    BOOL IsFormatted();

    HRESULT GetLabel(LPTSTR pszLabel, DWORD cchLabel);
    HRESULT GetLabelNoFancy(LPTSTR pszLabel, DWORD cchLabel);
    HRESULT SetLabel(HWND hwnd, LPCTSTR pszLabel);
    HRESULT ChangeNotifyRegisterAlias(void);

    HRESULT GetRemotePath(LPWSTR pszPath, DWORD cchPath);

    UINT GetIcon(LPTSTR pszModule, DWORD cchModule);
    HRESULT GetAssocSystemElement(IAssociationElement **ppae);
    DWORD GetShellDescriptionID();

    int GetDriveFlags();
    void GetTypeString(LPTSTR pszType, DWORD cchType);

    HKEY GetRegKey();

    static void _NotifyReconnectedNetDrive(LPCWSTR pszMountPoint);

///////////////////////////////////////////////////////////////////////////////
// Miscellaneous helpers
///////////////////////////////////////////////////////////////////////////////
private:
    HRESULT _Init(LPCWSTR pszName, LPCWSTR pszShareName, BOOL fUnavailable);
    HRESULT _InitWithoutShareName(LPCWSTR pszName);

    HRESULT _GetDefaultUNCDisplayName(LPTSTR pszLabel, DWORD cchLabel);
    BOOL    _GetComputerDisplayNameFromReg(LPTSTR pszLabel, DWORD cchLabel);

    LPCTSTR _GetUNCName();
    BOOL _IsConnected();
    BOOL _IsUnavailableNetDrive();
    BOOL _IsUnavailableNetDriveFromStateVar();

    BOOL _IsRemote();

    BOOL _IsSlow();
    BOOL _IsAutorun();

    // returns DT_* defined above
    DWORD _GetMTPTDriveType();
    // returns CT_* defined above
    DWORD _GetMTPTContentType();

    DWORD _GetPathSpeed();
    void _CalcPathSpeed();

    BOOL _GetFileAttributes(DWORD* pdwAttrib);
    BOOL _GetFileSystemName(LPTSTR pszFileSysName, DWORD cchFileSysName);
    BOOL _GetGVILabelOrMixedCaseFromReg(LPTSTR pszLabel, DWORD cchLabel);
    BOOL _GetGVILabel(LPTSTR pszLabel, DWORD cchLabel);
    BOOL _GetSerialNumber(DWORD* pdwSerialNumber);
    BOOL _GetFileSystemFlags(DWORD* pdwFlags);
    int _GetGVIDriveFlags();
    int _GetDriveType();
    DWORD _GetAutorunContentType();
    UINT _GetAutorunIcon(LPTSTR pszModule, DWORD cchModule);

    struct GFAGVICALL* _PrepareThreadParam(HANDLE* phEventBegun,
        HANDLE* phEventFinish);
    BOOL _HaveGFAAndGVIExpired(DWORD dwNow);
    BOOL _UpdateGFAAndGVIInfo();
    void _UpdateWNetGCStatus();

    BOOL _IsMountedOnDriveLetter();

    void _InitOnlyOnceStuff();
    void _UpdateLabelFromDesktopINI();
    void _UpdateAutorunInfo();

public:
    static HRESULT _CreateMtPtRemote(LPCWSTR pszMountPoint,
        LPCWSTR pszShareName, BOOL fUnavailable);
    static HRESULT _CreateMtPtRemoteWithoutShareName(LPCWSTR pszMountPoint);

    static CShare* _GetOrCreateShareFromID(LPCWSTR pszShareName);

    static HRESULT _DeleteAllMtPtsAndShares();

    static HRESULT _RemoveShareFromHDPA(CShare* pshare);

///////////////////////////////////////////////////////////////////////////////
// Data
///////////////////////////////////////////////////////////////////////////////
private:
    class CShare*               _pshare;

    DWORD                       _dwWNetGCStatus;
    DWORD                       _dwWNetGC3Status;
    WNGC_CONNECTION_STATE       _wngcs;

    DWORD                       _dwSpeed;

#ifdef DEBUG
private:
    static DWORD                _cMtPtRemote;
#endif
};

class CShare
{
public:
    DWORD                   dwGetFileAttributes;
                  
    WCHAR                   szLabel[MAX_LABEL];
    DWORD                   dwSerialNumber;
    DWORD                   dwMaxFileNameLen;
    DWORD                   dwFileSystemFlags;
    WCHAR                   szFileSysName[MAX_FILESYSNAME];

    BOOL                    fGVIRetValue;
    DWORD                   dwGFAGVILastCall;

    BOOL                    fConnected;

    LPWSTR                  pszRemoteName;
    LPWSTR                  pszKeyName;

    BOOL                    fAutorun;

    BOOL                    fFake;

public:
    ULONG AddRef()
    { return InterlockedIncrement(&_cRef); }

    ULONG Release()
    {
        if (InterlockedDecrement(&_cRef) > 0)
            return _cRef;
    
        delete this;
        return 0;
    }

private:
    LONG            _cRef;

public:
    CShare() : _cRef(1)
    {
#ifdef DEBUG
        ++_cShare;
#endif
    }
    ~CShare()
    {
        CMtPtRemote::_RemoveShareFromHDPA(this);

        if (pszRemoteName)
        {
            LocalFree(pszRemoteName);
        }
        if (pszKeyName)
        {
            LocalFree(pszKeyName);
        }
#ifdef DEBUG
        --_cShare;
#endif
    }
#ifdef DEBUG
private:
    static DWORD                _cShare;
#endif
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\mtptmgmt2.cpp ===
#include "shellprv.h"
#pragma  hdrstop

#include "mtpt.h"
#include "mtptl.h"
#include "mtptr.h"
#include "hwcmmn.h"
#include "clsobj.h"

#include <cfgmgr32.h>

HDPA CMountPoint::_hdpaMountPoints = NULL;
HDPA CMountPoint::_hdpaVolumes = NULL;
HDPA CMountPoint::_hdpaShares = NULL;
CMtPtLocal* CMountPoint::_rgMtPtDriveLetterLocal[26] = {0};
CMtPtRemote* CMountPoint::_rgMtPtDriveLetterNet[26] = {0};

CCriticalSection CMountPoint::_csLocalMtPtHDPA;
CCriticalSection CMountPoint::_csDL;

BOOL CMountPoint::_fShuttingDown = FALSE;

BOOL CMountPoint::_fNetDrivesInited = FALSE;
BOOL CMountPoint::_fLocalDrivesInited = FALSE;
BOOL CMountPoint::_fNoVolLocalDrivesInited = FALSE;
DWORD CMountPoint::_dwTickCountTriedAndFailed = 0;

DWORD CMountPoint::_dwAdviseToken = -1;

BOOL CMountPoint::_fCanRegisterWithShellService = FALSE;

CRegSupport CMountPoint::_rsMtPtsLocalDL;
CRegSupport CMountPoint::_rsMtPtsLocalMOF;
CRegSupport CMountPoint::_rsMtPtsRemote;

DWORD CMountPoint::_dwRemoteDriveAutorun = 0;

static WCHAR g_szCrossProcessCacheMtPtsLocalDLKey[] = TEXT("CPC\\LocalDL");
static WCHAR g_szCrossProcessCacheMtPtsRemoteKey[] = TEXT("CPC\\Remote");
static WCHAR g_szCrossProcessCacheMtPtsLocalMOFKey[] = TEXT("CPC\\LocalMOF");

HANDLE CMountPoint::_hThreadSCN = NULL;

DWORD CMountPoint::_dwRememberedNetDrivesMask = 0;

///////////////////////////////////////////////////////////////////////////////
// Public
///////////////////////////////////////////////////////////////////////////////
//static
CMountPoint* CMountPoint::GetMountPoint(int iDrive, BOOL fCreateNew,
    BOOL fOKToHitNet)
{
    CMountPoint* pMtPt = NULL;

    if (iDrive >= 0 && iDrive < 26)
    {
        _csDL.Enter();

        if (!_fShuttingDown)
        {
            pMtPt = _GetMountPointDL(iDrive, fCreateNew);
        }

        _csDL.Leave();
    }
    else
    {
        TraceMsg(TF_MOUNTPOINT,
            "CMountPoint::GetMountPoint: Requested invalid mtpt '%d'",
            iDrive);
    }

    return pMtPt;
}

//static
CMountPoint* CMountPoint::GetMountPoint(LPCTSTR pszName, BOOL fCreateNew)
{
    CMountPoint* pMtPt = NULL;

    // Sometimes we receive an empty string (go figure)
    // Check '\' for UNC and \\?\VolumeGUID which we do not support
    // (they're not mountpoints)
    if (pszName && *pszName && (TEXT('\\') != *pszName))
    {
        if (InRange(*pszName , TEXT('a'), TEXT('z')) ||
            InRange(*pszName , TEXT('A'), TEXT('Z')))
        {
            _csDL.Enter();

            if (!_fShuttingDown)
            {
                if (!_IsDriveLetter(pszName))
                {
                    BOOL fNetDrive = _IsNetDriveLazyLoadNetDLLs(DRIVEID(pszName));

                    if (!fNetDrive)
                    {
                        TCHAR szClosestMtPt[MAX_PATH];

                        if (_StripToClosestMountPoint(pszName, szClosestMtPt,
                            ARRAYSIZE(szClosestMtPt)))
                        {
                            if (!_IsDriveLetter(szClosestMtPt))
                            {
                                pMtPt = _GetStoredMtPtMOF(szClosestMtPt);
                            }
                            else
                            {
                                pMtPt = _GetMountPointDL(DRIVEID(pszName), fCreateNew);
                            }
                        }
                    }
                    else
                    {
                        // Net drives can only be mounted on drive letter
                        pMtPt = _GetMountPointDL(DRIVEID(pszName), fCreateNew);
                    }
                }
                else
                {
                    pMtPt = _GetMountPointDL(DRIVEID(pszName), fCreateNew);
                }
            }

            _csDL.Leave();
        }
        else
        {
            TraceMsg(TF_MOUNTPOINT,
                "CMountPoint::GetMountPoint: Requested invalid mtpt '%s'",
                pszName);
        }
    }
    else
    {
        TraceMsg(TF_MOUNTPOINT, "CMountPoint::GetMountPoint: Requested invalid mtpt '%s'",
            pszName);
    }

    return pMtPt;
}

//static
CMountPoint* CMountPoint::GetSimulatedMountPointFromVolumeGuid(LPCTSTR pszVolumeGuid)
{
    CMountPoint* pMtPt = NULL;

    static const TCHAR szWackWackVolume[] = TEXT("\\\\?\\Volume");

    // Check for "\\?\Volume"
    if (pszVolumeGuid && 0 == lstrncmp( pszVolumeGuid, szWackWackVolume, ARRAYSIZE(szWackWackVolume) - sizeof("") ) )
    {
        _csDL.Enter();

        CMtPtLocal::_CreateMtPtLocalFromVolumeGuid( pszVolumeGuid, &pMtPt );
        if ( !pMtPt )
        {
            TraceMsg(TF_MOUNTPOINT, "CMountPoint::GetMountPoint: Out of memory" );
        }

        _csDL.Leave();
    }
    else
    {
        TraceMsg(TF_MOUNTPOINT, "CMountPoint::GetSimulatedMountPointFromVolumeGuid: Request is not a volume guid '%ws'",
            pszVolumeGuid);
    }

    return pMtPt;
}


// static
BOOL CMountPoint::_LocalDriveIsCoveredByNetDrive(LPCWSTR pszDriveLetter)
{
    BOOL fCovered = FALSE;

    CMountPoint* pmtpt = GetMountPoint(DRIVEID(pszDriveLetter), FALSE, FALSE);

    if (pmtpt)
    {
        if (pmtpt->_IsRemote())
        {
            fCovered = TRUE;
        }

        pmtpt->Release();
    }

    return fCovered;
}
///////////////////////////////////////////////////////////////////////////////
// Private
///////////////////////////////////////////////////////////////////////////////

// pszSource must be a path including a trailing backslash
// if returns TRUE, then pszDest contains the path to the closest MountPoint

//static
BOOL CMountPoint::_StripToClosestMountPoint(LPCTSTR pszSource, LPTSTR pszDest,
    DWORD cchDest)
{
    BOOL fFound = GetVolumePathName(pszSource, pszDest, cchDest);
    if (fFound)
    {
        PathAddBackslash(pszDest);
    }
    return fFound;
}

///////////////////////////////////////////////////////////////////////////////
// Drive letter: DL
///////////////////////////////////////////////////////////////////////////////
//static
CMountPoint* CMountPoint::_GetMountPointDL(int iDrive, BOOL fCreateNew)
{
    ASSERT(_csDL.IsInside());
    CMountPoint* pmtpt = NULL;

    // Determine if it's a net drive
    BOOL fNetDrive = _IsNetDriveLazyLoadNetDLLs(iDrive);

    if (fNetDrive)
    {
        if (!_fNetDrivesInited)
        {
            _InitNetDrives();
        }

        pmtpt = _rgMtPtDriveLetterNet[iDrive];
    }
    else
    {
        if (!_fLocalDrivesInited)
        {
            _InitLocalDrives();
        }

        pmtpt = _rgMtPtDriveLetterLocal[iDrive];

        if (!_Shell32LoadedInDesktop())
        {
            DWORD dwAllDrives = GetLogicalDrives();
            
            if (pmtpt)
            {
                // make sure it still exist
                if (!(dwAllDrives & (1 << iDrive)))
                {
                    // its' gone!
                    _rgMtPtDriveLetterLocal[iDrive]->Release();
                    _rgMtPtDriveLetterLocal[iDrive] = NULL;
                    pmtpt = NULL;
                }

                if (pmtpt && (pmtpt->_NeedToRefresh()))
                {
                    CVolume* pvol;
                    HRESULT hr;
                    WCHAR szMountPoint[4];

                    _rgMtPtDriveLetterLocal[iDrive]->Release();
                    _rgMtPtDriveLetterLocal[iDrive] = NULL;

                    PathBuildRoot(szMountPoint, iDrive);

                    pvol = CMtPtLocal::_GetVolumeByMtPt(szMountPoint);

                    if (pvol)
                    {
                        hr = CMtPtLocal::_CreateMtPtLocalWithVolume(szMountPoint,
                            pvol);

                        pvol->Release();
                    }
                    else
                    {
                        hr = CMtPtLocal::_CreateMtPtLocal(szMountPoint);
                    }

                    if (SUCCEEDED(hr))
                    {    
                        pmtpt = _rgMtPtDriveLetterLocal[iDrive];
                    }
                    else
                    {
                        pmtpt = NULL;
                    }
                }
            }
            else
            {
                // maybe it arrived after we enumerated
                if (dwAllDrives & (1 << iDrive))
                {
                    WCHAR szMtPt[4];
                    // Is it a non-net drive?
                    UINT uDriveType = GetDriveType(PathBuildRoot(szMtPt, iDrive));

                    if ((DRIVE_FIXED == uDriveType) || (DRIVE_CDROM == uDriveType) || 
                        (DRIVE_REMOVABLE == uDriveType) || (DRIVE_RAMDISK == uDriveType))
                    {
                        // indeed
                        CVolume* pvolNew;

                        HRESULT hrTmp = CMtPtLocal::_CreateVolumeFromReg(szMtPt, &pvolNew);

                        if (SUCCEEDED(hrTmp))
                        {
                            CMtPtLocal::_CreateMtPtLocalWithVolume(szMtPt, pvolNew);

                            pvolNew->Release();
                        }
                        else
                        {
                            CMtPtLocal::_CreateMtPtLocal(szMtPt);
                        }

                        pmtpt = _rgMtPtDriveLetterNet[iDrive];
                    }
                }
            }
        }
    }

    if (pmtpt)
    {
        pmtpt->AddRef();
    }

    return pmtpt;
}

///////////////////////////////////////////////////////////////////////////////
// Mounted On Folder: MOF
///////////////////////////////////////////////////////////////////////////////
//static
CMtPtLocal* CMountPoint::_GetStoredMtPtMOFFromHDPA(LPTSTR pszPathWithBackslash)
{
    CMtPtLocal* pmtptl = NULL;

    if (_hdpaMountPoints)
    {
        int n = DPA_GetPtrCount(_hdpaMountPoints);

        for (int i = 0; i < n; ++i)
        {
            pmtptl = (CMtPtLocal*)DPA_GetPtr(_hdpaMountPoints, i);

            if (pmtptl)
            {
                if (!lstrcmpi(pmtptl->_GetName(), pszPathWithBackslash))
                {
                    break;
                }
                else
                {
                    pmtptl = NULL;
                }
            }
        }
    }

    return pmtptl;
}

//static
CMtPtLocal* CMountPoint::_GetStoredMtPtMOF(LPTSTR pszPathWithBackslash)
{
    ASSERT(_csDL.IsInside());

    _csLocalMtPtHDPA.Enter();

    if (!_fLocalDrivesInited)
    {
        _InitLocalDrives();
    }

    CMtPtLocal* pmtptl = _GetStoredMtPtMOFFromHDPA(pszPathWithBackslash);

    if (!_Shell32LoadedInDesktop())
    {
        BOOL fExist = _CheckLocalMtPtsMOF(pszPathWithBackslash);

        if (pmtptl)
        {
            if (fExist)
            {
                if (pmtptl->_NeedToRefresh())
                {
                    CVolume* pvol = CMtPtLocal::_GetVolumeByMtPt(pszPathWithBackslash);

                    pmtptl = NULL;

                    if (pvol)
                    {
                        HRESULT hr = CMtPtLocal::_CreateMtPtLocalWithVolume(
                            pszPathWithBackslash, pvol);

                        if (SUCCEEDED(hr))
                        {
                            pmtptl = _GetStoredMtPtMOFFromHDPA(pszPathWithBackslash);
                        }

                        pvol->Release();
                    }
                    else
                    {
                        // if we can't get a volume, we don't care about drive mounted on folder
                    }
                }
            }
            else
            {
                // its' gone!
                _RemoveLocalMountPoint(pszPathWithBackslash);
                pmtptl = NULL;
            }
        }
        else
        {
            // maybe it arrived after we enumerated
            if (fExist)
            {
                CVolume* pvolNew;

                HRESULT hrTmp = CMtPtLocal::_CreateVolumeFromReg(pszPathWithBackslash,
                    &pvolNew);

                if (SUCCEEDED(hrTmp))
                {
                    hrTmp = CMtPtLocal::_CreateMtPtLocalWithVolume(pszPathWithBackslash, pvolNew);

                    if (SUCCEEDED(hrTmp))
                    {
                        pmtptl = _GetStoredMtPtMOFFromHDPA(pszPathWithBackslash);
                    }

                    pvolNew->Release();
                }
                else
                {
                    // if we can't get a volume, we don't care about drive mounted on folder
                }
            }
        }
    }

    if (pmtptl)
    {
        pmtptl->AddRef();
    }

    _csLocalMtPtHDPA.Leave();

    return pmtptl;
}

//static
BOOL CMountPoint::_StoreMtPtMOF(CMtPtLocal* pmtptl)
{
    HRESULT hr;

    _csLocalMtPtHDPA.Enter();

    if (!_hdpaMountPoints && !_fShuttingDown)
    {
        _hdpaMountPoints = DPA_Create(2);
    }

    if (_hdpaMountPoints)
    {
        if (-1 == DPA_AppendPtr(_hdpaMountPoints, pmtptl))
        {
            hr = E_OUTOFMEMORY;
        }
        else
        {
            hr = S_OK;
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    _csLocalMtPtHDPA.Leave();

    return hr;
}

//static
BOOL CMountPoint::_IsDriveLetter(LPCTSTR pszName)
{
    // Is this a drive mounted on a drive letter only (e.g. 'a:' or 'a:\')?
    return (!pszName[2] || !pszName[3]);
}

///////////////////////////////////////////////////////////////////////////////
// 
///////////////////////////////////////////////////////////////////////////////

//static
HRESULT CMountPoint::_InitNetDrivesHelper(DWORD dwScope)
{
    HRESULT hr = S_FALSE;
    HANDLE hEnum;
    DWORD dwErr = WNetOpenEnum(dwScope, RESOURCETYPE_DISK, 0, NULL, &hEnum);

    if (WN_SUCCESS == dwErr)
    {
        DWORD cbBuf = 4096 * 4; // Recommended size from docs
        PBYTE pbBuf = (PBYTE)LocalAlloc(LPTR, cbBuf);

        if (pbBuf)
        {
            // return as many entries as possible
            DWORD dwEntries = (DWORD)-1;

            dwErr = WNetEnumResource(hEnum, &dwEntries, pbBuf, &cbBuf);

            if (dwErr == ERROR_MORE_DATA)
            {
                if (pbBuf)
                {
                    LocalFree(pbBuf);
                }

                // cbBuf contains required size
                pbBuf = (PBYTE)LocalAlloc(LPTR, cbBuf);
                if (pbBuf)
                {
                    dwErr = WNetEnumResource(hEnum, &dwEntries, pbBuf, &cbBuf);
                }
                else
                {
                    dwErr = ERROR_NOT_ENOUGH_MEMORY;
                }
            }

            if (dwErr == WN_SUCCESS)
            {
                UINT i;
                NETRESOURCE* pnr = (NETRESOURCE*)pbBuf;
    
                for (i = 0; SUCCEEDED(hr) && (i < dwEntries); ++i)
                {
                    // Is it mapped or just net used
                    if (pnr->lpLocalName)
                    {
                        // Remembered drives and connected drives list overlaps
                        if (!_rgMtPtDriveLetterNet[DRIVEID(pnr->lpLocalName)])
                        {
                            hr = CMtPtRemote::_CreateMtPtRemote(pnr->lpLocalName,
                                                                pnr->lpRemoteName,
                                                                (dwScope == RESOURCE_CONNECTED));

                            if (RESOURCE_REMEMBERED == dwScope)
                            {
                                _dwRememberedNetDrivesMask |= (1 << DRIVEID(pnr->lpLocalName));
                            }
                        }
                    }

                    pnr++;
                }
            }
            //
            // BUGBUG (stephstm) - do we really want to return S_FALSE if WNetEnumResource fails?!?
            //
    
            if (pbBuf)
            {
                LocalFree(pbBuf);
            }
        }

        WNetCloseEnum(hEnum);
    }
    //
    // BUGBUG (stephstm) - do we really want to return S_FALSE if WNetOpenEnum fails?!?
    //
    //  else if (ERROR_NO_NETWORK == dwErr)

    return hr;
}

//static
HRESULT CMountPoint::_ReInitNetDrives()
{
    ASSERT(_csDL.IsInside());

    CMtPtRemote::_DeleteAllMtPtsAndShares();

    _fNetDrivesInited = FALSE;

    CMountPoint::_InitNetDrives();

    return S_OK;
}

//static
HRESULT CMountPoint::_InitNetDrives()
{
    ASSERT(_csDL.IsInside());
    HRESULT hr;

    if (!_fNetDrivesInited)
    {
        if (!_fShuttingDown)
        {
            if (!_hdpaShares)
            {
                _hdpaShares = DPA_Create(3);
            }
        }

        if (_hdpaShares)
        {
            hr = _InitNetDrivesHelper(RESOURCE_CONNECTED);

            if (SUCCEEDED(hr))
            {
                hr = _InitNetDrivesHelper(RESOURCE_REMEMBERED);
            }

            if (SUCCEEDED(hr))
            {
                DWORD dwLogicalDrives = GetLogicalDrives();

                for (DWORD dw = 0; dw < 26; ++dw)
                {
                    if (dwLogicalDrives & (1 << dw))
                    {
                        if (!(_rgMtPtDriveLetterNet[dw]))
                        {
                            WCHAR szDrive[4];

                            PathBuildRoot(szDrive, dw);

                            if (DRIVE_REMOTE == GetDriveType(szDrive))
                            {
                                // This must be a weird System mapped drive
                                // which is not enumerated by the per-user
                                // WNetEnumResource...
                                hr = CMtPtRemote::_CreateMtPtRemoteWithoutShareName(szDrive);
                            }
                        }
                    }
                }

                _fNetDrivesInited = TRUE;
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        hr = S_FALSE;
    }

    if (_Shell32LoadedInDesktop())
    {
        DWORD dwRemoteDrives = 0;

        for (DWORD dw = 0; dw < 26; ++dw)
        {
            if (_rgMtPtDriveLetterNet[dw])
            {
                dwRemoteDrives |= (1 << dw);
            }
        }
    }

    return hr;
}

inline void _CoTaskMemFree(void* pv)
{
    if (pv)
    {
        CoTaskMemFree(pv);
    }
}

const GUID guidVolumeClass =
    {0x53f5630d, 0xb6bf, 0x11d0,
    {0x94, 0xf2, 0x00, 0xa0, 0xc9, 0x1e, 0xfb, 0x8b}};

//static
HRESULT CMountPoint::_EnumVolumes(IHardwareDevices* pihwdevs)
{
    ASSERT(_csDL.IsInside());
    HRESULT hr;

    if (_Shell32LoadedInDesktop())
    {
        // Synchro
        IHardwareDevicesVolumesEnum* penum;

        hr = pihwdevs->EnumVolumes(HWDEV_GETCUSTOMPROPERTIES, &penum);

        ASSERTMSG(NULL != _hdpaVolumes, "_hdpaVolumes should not be NULL at this point, some code found its way here without calling InitLocalDrives");

        if (SUCCEEDED(hr))
        {
            do
            {
                VOLUMEINFO volinfo;

                hr = penum->Next(&volinfo);

                if (SUCCEEDED(hr) && (S_FALSE != hr))
                {
                    CVolume* pvolNew;

                    if (SUCCEEDED(CMtPtLocal::_CreateVolume(&volinfo, &pvolNew)))
                    {
                        CMtPtLocal::_UpdateVolumeRegInfo(&volinfo);

                        pvolNew->Release();
                    }

                    CoTaskMemFree(volinfo.pszDeviceIDVolume);
                    CoTaskMemFree(volinfo.pszVolumeGUID);
                    CoTaskMemFree(volinfo.pszLabel);
                    CoTaskMemFree(volinfo.pszFileSystem);
                    CoTaskMemFree(volinfo.pszAutorunIconLocation);
                    CoTaskMemFree(volinfo.pszAutorunLabel);
                    CoTaskMemFree(volinfo.pszIconLocationFromService);
                    CoTaskMemFree(volinfo.pszNoMediaIconLocationFromService);
                    CoTaskMemFree(volinfo.pszLabelFromService);
                }
            }
            while (SUCCEEDED(hr) && (S_FALSE != hr));

            penum->Release();
        }
    }
    else
    {
        ULONG ulSize;
        ULONG ulFlags = CM_GET_DEVICE_INTERFACE_LIST_PRESENT;

        CONFIGRET cr = CM_Get_Device_Interface_List_Size_Ex(&ulSize,
            (GUID*)&guidVolumeClass, NULL, ulFlags, NULL);

        if ((CR_SUCCESS == cr) && (ulSize > 1))
        {
            LPWSTR pszVolumes = (LPWSTR)LocalAlloc(LPTR, ulSize * sizeof(WCHAR));

            if (pszVolumes)
            {
                cr = CM_Get_Device_Interface_List_Ex((GUID*)&guidVolumeClass,
                    NULL, pszVolumes, ulSize, ulFlags, NULL);

                if (CR_SUCCESS == cr)
                {
                    for (LPWSTR psz = pszVolumes; *psz; psz += lstrlen(psz) + 1)
                    {
                        CVolume* pvolNew;

                        HRESULT hrTmp = CMtPtLocal::_CreateVolumeFromReg(psz,
                            &pvolNew);

                        if (SUCCEEDED(hrTmp))
                        {
                            pvolNew->Release();
                        }
                    }

                    hr = S_OK;
                }
                else
                {
                    hr = S_FALSE;
                }

                LocalFree(pszVolumes);
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
        else
        {
            hr = S_FALSE;
        }
    }

    return hr;
}

//static
HRESULT CMountPoint::_EnumMountPoints(IHardwareDevices* pihwdevs)
{
    ASSERT(_csDL.IsInside());
    HRESULT hr;

    if (_Shell32LoadedInDesktop())
    {
        IHardwareDevicesMountPointsEnum* penum;

        hr = pihwdevs->EnumMountPoints(&penum);

        if (SUCCEEDED(hr))
        {
            LPWSTR pszMountPoint;
            LPWSTR pszDeviceIDVolume;

            while (SUCCEEDED(hr = penum->Next(&pszMountPoint, &pszDeviceIDVolume)) &&
                   (S_FALSE != hr))
            {
                CVolume* pvol = CMtPtLocal::_GetVolumeByID(pszDeviceIDVolume);

                if (pvol)
                {
                    CMtPtLocal::_CreateMtPtLocalWithVolume(pszMountPoint, pvol);

                    pvol->Release();
                }

                if (!_IsDriveLetter(pszMountPoint))
                {
                    _rsMtPtsLocalMOF.RSSetTextValue(NULL, pszMountPoint, TEXT(""));
                }

                CoTaskMemFree(pszMountPoint);
                CoTaskMemFree(pszDeviceIDVolume);
            }

            penum->Release();
        }
    }
    else
    {
        hr = S_OK;

        if (_hdpaVolumes)
        {
            DWORD c = DPA_GetPtrCount(_hdpaVolumes);

            for (int i = c - 1; i >= 0; --i)
            {
                CVolume* pvol = (CVolume*)DPA_GetPtr(_hdpaVolumes, i);

                if (pvol)
                {
                    DWORD cch;

                    if (GetVolumePathNamesForVolumeName(pvol->pszVolumeGUID,
                        NULL, 0, &cch))
                    {
                        // no mountpoint, we're done                        
                    }
                    else
                    {
                        // Expected, even wanted...
                        if (ERROR_MORE_DATA == GetLastError())
                        {
                            LPWSTR pszMtPts = (LPWSTR)LocalAlloc(LPTR,
                                cch * sizeof(WCHAR));

                            if (pszMtPts)
                            {
                                if (GetVolumePathNamesForVolumeName(
                                    pvol->pszVolumeGUID, pszMtPts, cch, &cch))
                                {
                                    for (LPWSTR psz = pszMtPts; *psz;
                                        psz += lstrlen(psz) + 1)
                                    {
                                        CMtPtLocal::_CreateMtPtLocalWithVolume(
                                            psz, pvol);
                                    }
                                }

                                LocalFree(pszMtPts);
                            }
                            else
                            {
                                hr = E_OUTOFMEMORY;
                            }
                        }
                        else
                        {
                            hr = S_FALSE; 
                        }
                    }
                }
            }
        }
    }

    // We don't care about the prev hr.  I'll clean this up when moving the
    // volume information from the Shell Service.  (stephstm, 2001/03/13)

    DWORD dwLogicalDrives = GetLogicalDrives();
    DWORD dwLocalDrives = 0;

    for (DWORD dw = 0; dw < 26; ++dw)
    {
        if (dwLogicalDrives & (1 << dw))
        {
            if (_rgMtPtDriveLetterLocal[dw])
            {
                dwLocalDrives |= (1 << dw);
            }
            else
            {
                WCHAR szDrive[4];

                PathBuildRoot(szDrive, dw);

                if (DRIVE_REMOTE != GetDriveType(szDrive))
                {
                    // This is a "subst" drive or something like this.
                    // It only appears in the per-user drive map, not the
                    // per-machine.  Let's create a mountpoint for it.
                    CMtPtLocal::_CreateMtPtLocal(szDrive);

                    dwLocalDrives |= (1 << dw);
                }
            }
        }
    }

    return hr;
}

//static
HRESULT CMountPoint::_DeleteVolumeInfo()
{
    ASSERT(_csDL.IsInside());

    if (_hdpaVolumes)
    {
        DWORD c = DPA_GetPtrCount(_hdpaVolumes);

        for (int i = c - 1; i >= 0; --i)
        {
            CVolume* pvol = (CVolume*)DPA_GetPtr(_hdpaVolumes, i);

            if (pvol)
            {
                pvol->Release();
            }

            DPA_DeletePtr(_hdpaVolumes, i);
        }

        DPA_Destroy(_hdpaVolumes);
        _hdpaVolumes = NULL;
    }

    return S_OK;
}

//static
HRESULT CMountPoint::_DeleteLocalMtPts()
{
    ASSERT(_csDL.IsInside());
    for (DWORD dw = 0; dw < 26; ++dw)
    {
        CMtPtLocal* pmtptl = (CMtPtLocal*)_rgMtPtDriveLetterLocal[dw];

        if (pmtptl)
        {
            pmtptl->Release();

            _rgMtPtDriveLetterLocal[dw] = 0;
        }
    }

    _csLocalMtPtHDPA.Enter();

    if (_hdpaMountPoints)
    {
        int n = DPA_GetPtrCount(_hdpaMountPoints);

        for (int i = n - 1; i >= 0; --i)
        {
            CMtPtLocal* pmtptl = (CMtPtLocal*)DPA_GetPtr(_hdpaMountPoints, i);

            if (pmtptl)
            {
                pmtptl->Release();

                DPA_DeletePtr(_hdpaMountPoints, i);
            }
        }

        DPA_Destroy(_hdpaMountPoints);
    }

    _csLocalMtPtHDPA.Leave();

    return S_OK;
}

// static
HRESULT CMountPoint::_GetMountPointsForVolume(LPCWSTR pszDeviceIDVolume,
    HDPA hdpaMtPts)
{
    ASSERT(!_csDL.IsInside());

    _csDL.Enter();

    for (DWORD dw = 0; dw < 26; ++dw)
    {
        CMtPtLocal* pmtptl = (CMtPtLocal*)_rgMtPtDriveLetterLocal[dw];

        if (pmtptl && pmtptl->_pvol)
        {
            if (!lstrcmpi(pmtptl->_pvol->pszDeviceIDVolume, pszDeviceIDVolume))
            {
                LPCWSTR pszMtPt = StrDup(pmtptl->_szName);

                if (pszMtPt)
                {
                    if (-1 == DPA_AppendPtr(hdpaMtPts, (void*)pszMtPt))
                    {
                        LocalFree((HLOCAL)pszMtPt);
                    }
                }

                // Volumes can be mounted on only one drive letter
                break;
            }
        }
    }

    _csDL.Leave();

    _csLocalMtPtHDPA.Enter();

    if (_hdpaMountPoints)
    {
        int n = DPA_GetPtrCount(_hdpaMountPoints);

        for (int i = n - 1; i >= 0; --i)
        {
            CMtPtLocal* pmtptl = (CMtPtLocal*)DPA_GetPtr(_hdpaMountPoints, i);

            if (pmtptl && pmtptl->_pvol)
            {
                if (!lstrcmpi(pmtptl->_pvol->pszDeviceIDVolume, pszDeviceIDVolume))
                {
                    LPCWSTR pszMtPt = StrDup(pmtptl->_szName);

                    if (pszMtPt)
                    {
                        if (-1 == DPA_AppendPtr(hdpaMtPts, (void*)pszMtPt))
                        {
                            LocalFree((HLOCAL)pszMtPt);
                        }
                    }
                }
            }
        }
    }

    _csLocalMtPtHDPA.Leave();

    return S_OK;
}

//static
HRESULT CMountPoint::_CleanupLocalMtPtInfo()
{
    _csDL.Enter();

    // We should Unadvise here but there's two problems: the ref counting
    // and we are probably here because CoUninitialize has been called, so
    // creating the IHardwareDevices interface'c component would probably fail

    _DeleteLocalMtPts();
    _DeleteVolumeInfo();

    _csDL.Leave();

    return S_OK;
}

// static
HRESULT CMountPoint::_InitLocalDriveHelper()
{
#ifdef DEBUG
    // We should not try to enter the Drive Letter critical section on this thread.
    // We've already entered it on the thread that launched us, and
    // we should still be in there.  The thread that launched us is waiting for
    // this thread to finish before going on.  Trying to re-enter this critical
    // section from this thread will deadlock.
    DWORD dwThreadID = GetCurrentThreadId();
    _csDL.SetThreadIDToCheckForEntrance(dwThreadID);

    _csDL.FakeEnter();
#endif

    IHardwareDevices* pihwdevs;

    HRESULT hr;
    BOOL fLoadedInDesktop = _Shell32LoadedInDesktop();
    
    if (fLoadedInDesktop)
    {
        hr = _GetHardwareDevices(&pihwdevs);
    }
    else
    {
        hr = S_FALSE;
    }

    if (SUCCEEDED(hr))
    {
        if (!_hdpaVolumes && !_fShuttingDown)
        {
            _hdpaVolumes = DPA_Create(3);
        }

        if (_hdpaVolumes)
        {
            if (SUCCEEDED(hr))
            {
                hr = _EnumVolumes(pihwdevs);

                if (SUCCEEDED(hr))
                {
                    hr = _EnumMountPoints(pihwdevs);

                    if (SUCCEEDED(hr))
                    {
                        _fLocalDrivesInited = TRUE;
                    }
                    else
                    {
                        _DeleteVolumeInfo();
                    }
                }
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }

        if (fLoadedInDesktop)
        {
            pihwdevs->Release();
        }
    }

#ifdef DEBUG
    _csDL.FakeLeave();

    _csDL.SetThreadIDToCheckForEntrance(0);
#endif

    return hr;
}

DWORD WINAPI _FirstHardwareEnumThreadProc(void* pv)
{
    HRESULT hr = CoInitializeEx(NULL, COINIT_MULTITHREADED | COINIT_DISABLE_OLE1DDE);

    if (SUCCEEDED(hr))
    {
        hr = CMountPoint::_InitLocalDriveHelper();

        CoUninitialize();
    }

    return (DWORD)hr;
}

BOOL _InsideLoaderLock()
{
    return (NtCurrentTeb()->ClientId.UniqueThread ==
            ((PRTL_CRITICAL_SECTION)(NtCurrentPeb()->LoaderLock))->OwningThread);
}

//static
BOOL CMountPoint::_CanRegister()
{
    if (!CMountPoint::_fCanRegisterWithShellService)
    {
        HANDLE hCanRegister = OpenEvent(SYNCHRONIZE, FALSE, TEXT("_fCanRegisterWithShellService"));

        if (hCanRegister)
        {
            CloseHandle(hCanRegister);
        }
        else
        {
            CMountPoint::_fCanRegisterWithShellService = TRUE;
        }
    }

    return CMountPoint::_fCanRegisterWithShellService;
}

//static
HRESULT CMountPoint::_InitLocalDrives()
{
    ASSERT(_csDL.IsInside());

    HRESULT hr = E_FAIL;
    BOOL fTryFullInit = FALSE;

    if (CMountPoint::_CanRegister())
    {
        if (!_dwTickCountTriedAndFailed)
        {
            // We didn't try full init yet
            fTryFullInit = TRUE;
        }
        else
        {
            // We already tried and failed doing a full init.  Try again only if
            // it's been more than 5 seconds.
            if ((GetTickCount() - _dwTickCountTriedAndFailed) >
                (5 * 1000))
            {
                fTryFullInit = TRUE;
            }
        }

        if (fTryFullInit)
        {
            if (_Shell32LoadedInDesktop())
            {
                HANDLE hThread = CreateThread(NULL, 0, _FirstHardwareEnumThreadProc, NULL, 0, NULL);

                if (hThread)
                {
                    DWORD dwWait = WaitForSingleObject(hThread, INFINITE);

                    if (WAIT_FAILED != dwWait)
                    {
                        DWORD dwExitCode;

                        if (GetExitCodeThread(hThread, &dwExitCode))
                        {
                            hr = (HRESULT)dwExitCode;
                        }
                    }

                    CloseHandle(hThread);
                }

                if (SUCCEEDED(hr))
                {
                    _dwTickCountTriedAndFailed = 0;
                }
                else
                {
                    _dwTickCountTriedAndFailed = GetTickCount();
                }
            }
            else
            {
                hr = _InitLocalDriveHelper();

                _dwTickCountTriedAndFailed = 0;
            }
        }
    }
   
    if (FAILED(hr))
    {
        if (!_fNoVolLocalDrivesInited)
        {
            DWORD dwLogicalDrives = GetLogicalDrives();

            for (DWORD dw = 0; dw < 26; ++dw)
            {
                if (dwLogicalDrives & (1 << dw))
                {
                    WCHAR szDrive[4];
                    int iDriveType = GetDriveType(PathBuildRoot(szDrive, dw));

                    if ((DRIVE_REMOTE != iDriveType) && (DRIVE_UNKNOWN != iDriveType) &&
                        (DRIVE_NO_ROOT_DIR != iDriveType))
                    {
                        hr = CMtPtLocal::_CreateMtPtLocal(szDrive);
                    }
                }
            }

            _fNoVolLocalDrivesInited = TRUE;
        }
        else
        {
            hr = S_FALSE;
        }
    }

    return hr;
}

//static
DWORD CMountPoint::GetDrivesMask()
{
    HRESULT hr = S_FALSE;
    DWORD dwMask = 0;

    _csDL.Enter();

    if (!_fNetDrivesInited)
    {
        hr = _InitNetDrives();
    }

    if (!_fLocalDrivesInited)
    {
        hr = _InitLocalDrives();
    }

    if (SUCCEEDED(hr))
    {
        if (_Shell32LoadedInDesktop())
        {
            for (DWORD dw = 0; dw < 26; ++dw)
            {
                if (_rgMtPtDriveLetterLocal[dw] || _rgMtPtDriveLetterNet[dw])
                {
                    dwMask |= (1 << dw);
                }
            }
        }
        else
        {
            dwMask = GetLogicalDrives() | _dwRememberedNetDrivesMask;
        }
    }

    _csDL.Leave();

    return dwMask;
}

//static
void CMountPoint::Initialize()
{
    _csLocalMtPtHDPA.Init();
    _csDL.Init();

    _rsMtPtsLocalDL.RSInitRoot(HKEY_CURRENT_USER, REGSTR_MTPT_ROOTKEY2,
        g_szCrossProcessCacheMtPtsLocalDLKey, REG_OPTION_VOLATILE);

    _rsMtPtsRemote.RSInitRoot(HKEY_CURRENT_USER, REGSTR_MTPT_ROOTKEY2,
        g_szCrossProcessCacheMtPtsRemoteKey, REG_OPTION_VOLATILE);

    _rsMtPtsLocalMOF.RSInitRoot(HKEY_CURRENT_USER, REGSTR_MTPT_ROOTKEY2,
        g_szCrossProcessCacheMtPtsLocalMOFKey, REG_OPTION_VOLATILE);
}
///////////////////////////////////////////////////////////////////////////////
// For C caller
///////////////////////////////////////////////////////////////////////////////
STDAPI_(void) CMtPt_FinalCleanUp()
{
    CMountPoint::FinalCleanUp();
    CMtPtLocal::FinalCleanUp();
}

STDAPI_(void) CMtPt_Initialize()
{
    CMountPoint::Initialize();
    CMtPtLocal::Initialize();
}

//static
void CMountPoint::FinalCleanUp()
{
    if (_csDL.IsInitialized() && _csLocalMtPtHDPA.IsInitialized())
    {
        _csDL.Enter();

        _fShuttingDown = TRUE;

        _csLocalMtPtHDPA.Enter();

        _DeleteLocalMtPts();
        _DeleteVolumeInfo();
        CMtPtRemote::_DeleteAllMtPtsAndShares();
        _fNetDrivesInited = FALSE;

        _csLocalMtPtHDPA._fShuttingDown = TRUE;
        _csDL._fShuttingDown = TRUE;

        _csLocalMtPtHDPA.Leave();
        _csDL.Leave();

        _csLocalMtPtHDPA.Delete();
        _csDL.Delete();

        CSniffDrive::CleanUp();

        if (_hThreadSCN)
        {
            CloseHandle(_hThreadSCN);
            _hThreadSCN = NULL;
        }
    }

    if (_Shell32LoadedInDesktop())
    {
        _rsMtPtsLocalDL.RSDeleteKey();
        _rsMtPtsLocalMOF.RSDeleteKey();
        _rsMtPtsRemote.RSDeleteKey();
    }
}

//static
BOOL CMountPoint::_IsNetDriveLazyLoadNetDLLs(int iDrive)
{
    ASSERT(_csDL.IsInside());
    BOOL fNetDrive = FALSE;

    if (!_fNetDrivesInited)
    {
        HRESULT hr = S_FALSE;
        WCHAR szPath[4];

        // Try to avoid loading the net dlls
        UINT uDriveType = GetDriveType(PathBuildRoot(szPath, iDrive));

        if (DRIVE_NO_ROOT_DIR == uDriveType)
        {
            // This happens for Remembered drives
            hr = _InitNetDrives();

            if (SUCCEEDED(hr))
            {
                fNetDrive = BOOLFROMPTR(_rgMtPtDriveLetterNet[iDrive]);
            }
        }
        else
        {
            if (DRIVE_REMOTE == uDriveType)
            {
                fNetDrive = TRUE;
            }
        }
    }
    else
    {
        fNetDrive = BOOLFROMPTR(_rgMtPtDriveLetterNet[iDrive]);

        if (!_Shell32LoadedInDesktop())
        {
            DWORD dwAllDrives = GetLogicalDrives() | _dwRememberedNetDrivesMask;

            if (fNetDrive)
            {
                // make sure it still exist
                if (!(dwAllDrives & (1 << iDrive)))
                {
                    // its' gone!
                    fNetDrive = FALSE;
                }
                else
                {
                    WCHAR szPath[4];

                    // There's still a drive there, make sure it's not a local one
                    if (!(_dwRememberedNetDrivesMask & (1 << iDrive)) &&
                        !(GetDriveType(PathBuildRoot(szPath, iDrive)) == DRIVE_REMOTE))
                    {
                        fNetDrive = FALSE;
                    }
                }

                if (!fNetDrive && (_rgMtPtDriveLetterNet[iDrive]))
                {
                    _rgMtPtDriveLetterNet[iDrive]->Release();
                    _rgMtPtDriveLetterNet[iDrive] = NULL;
                }
            }
            else
            {
                // maybe it arrived after we enumerated
                if (dwAllDrives & (1 << iDrive))
                {
                    WCHAR szPath[4];

                    // Is it a remote drive?
                    if ((_dwRememberedNetDrivesMask & (1 << iDrive)) ||
                        (GetDriveType(PathBuildRoot(szPath, iDrive)) == DRIVE_REMOTE))
                    {
                        // indeed
                        _ReInitNetDrives();

                        fNetDrive = TRUE;
                    }
                }
            }
        }
    }

    return fNetDrive;
}

// static
HRESULT CMountPoint::_RemoveLocalMountPoint(LPCWSTR pszMountPoint)
{
    if (_IsDriveLetter(pszMountPoint))
    {
        _csDL.Enter();
        int iDrive = DRIVEID(pszMountPoint);

        CMtPtLocal* pmtptl = (CMtPtLocal*)_rgMtPtDriveLetterLocal[iDrive];

        if (pmtptl)
        {
            _rgMtPtDriveLetterLocal[iDrive] = 0;

            pmtptl->Release();
        }

        _csDL.Leave();
    }
    else
    {
        _csLocalMtPtHDPA.Enter();

        if (_hdpaMountPoints)
        {
            DWORD c = DPA_GetPtrCount(_hdpaMountPoints);

            for (int i = c - 1; i >= 0; --i)
            {
                CMtPtLocal* pmtptl = (CMtPtLocal*)DPA_GetPtr(_hdpaMountPoints, i);

                if (pmtptl)
                {
                    if (!lstrcmpi(pmtptl->_szName, pszMountPoint))
                    {
                        DPA_DeletePtr(_hdpaMountPoints, i);

                        pmtptl->Release();

                        break;
                    }
                }
            }
        }

        if (_Shell32LoadedInDesktop())
        {
            _rsMtPtsLocalMOF.RSDeleteValue(NULL, pszMountPoint);
        }

        _csLocalMtPtHDPA.Leave();
    }

    return S_OK;
}

// static
HRESULT CMountPoint::_RemoveNetMountPoint(LPCWSTR pszMountPoint)
{
    _csDL.Enter();

    int iDrive = DRIVEID(pszMountPoint);

    if (_rgMtPtDriveLetterNet[iDrive])
    {
        _rgMtPtDriveLetterNet[iDrive]->Release();
        _rgMtPtDriveLetterNet[iDrive] = 0;
    }

    _csDL.Leave();

    return S_OK;
}

// static
BOOL CMountPoint::_CheckLocalMtPtsMOF(LPCWSTR pszMountPoint)
{
    ASSERT(!_Shell32LoadedInDesktop());

    return _rsMtPtsLocalMOF.RSValueExist(NULL, pszMountPoint);
}

//
// This needs to be called from the thread that will be used for APCs callbacks
// (stephstm: 2001/03/31)

// static
DWORD WINAPI CMountPoint::_RegisterThreadProc(void* pv)
{
    ASSERT(_Shell32LoadedInDesktop());
    HANDLE hThread = (HANDLE)pv;
    HRESULT hr = CoInitializeEx(NULL, COINIT_MULTITHREADED | COINIT_DISABLE_OLE1DDE);

    if (SUCCEEDED(hr))
    {
        IHardwareDevices* pihwdevs;

        hr = _GetHardwareDevices(&pihwdevs);

        if (SUCCEEDED(hr))
        {
            hr = pihwdevs->Advise(GetCurrentProcessId(), (ULONG_PTR)hThread,
                (ULONG_PTR)CMountPoint::_EventAPCProc, &_dwAdviseToken);

            pihwdevs->Release();
        }

        CoUninitialize();
    }

    return (DWORD)hr;
}

// static
HRESULT CMountPoint::RegisterForHardwareNotifications()
{
    HRESULT hr;

    if (_Shell32LoadedInDesktop() && (-1 == _dwAdviseToken))
    {
        HANDLE hPseudoProcess = GetCurrentProcess();
        // See comment above!
        HANDLE hPseudoThread = GetCurrentThread();

        hr = E_FAIL;

        if (DuplicateHandle(hPseudoProcess, hPseudoThread, hPseudoProcess,
            &_hThreadSCN, DUPLICATE_SAME_ACCESS, FALSE, 0))
        {
            HANDLE hThread = CreateThread(NULL, 0, _RegisterThreadProc, (void*)_hThreadSCN, 0, NULL);

            CSniffDrive::Init(_hThreadSCN);

            if (hThread)
            {
                DWORD dwWait = WaitForSingleObject(hThread, INFINITE);

                if (WAIT_FAILED != dwWait)
                {
                    DWORD dwExitCode;

                    if (GetExitCodeThread(hThread, &dwExitCode))
                    {
                        hr = (HRESULT)dwExitCode;
                    }
                }

                CloseHandle(hThread);
            }
            else
            {
                // We want to keep the handle around we'll uise it for something else.
            }
        }
    }
    else
    {
        hr = S_FALSE;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\mulprsht.cpp ===
#include "shellprv.h"
#pragma  hdrstop

#include "propsht.h"
#include <winbase.h>
#include <shellids.h>
#include "util.h"       // for GetFileDescription
#include "prshtcpp.h"   // for progress dlg and recursive apply
#include "shlexec.h"    // for SIDKEYNAME
#include "datautil.h"
#include <efsui.h>      // for EfsDetail
#include "ascstr.h"     // for IAssocStore

// drivesx.c
STDAPI_(DWORD) PathGetClusterSize(LPCTSTR pszPath);
STDAPI_(DWORD) DrivesPropertiesThreadProc(void *pv);

// version.c
STDAPI_(void) AddVersionPage(LPCTSTR pszFilePath, LPFNADDPROPSHEETPAGE pfnAddPage, LPARAM lParam);

// link.c
STDAPI_(BOOL) AddLinkPage(LPCTSTR pszFile, LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam);

BOOL _IsBiDiCalendar(void);

const DWORD aFileGeneralHelpIds[] = {
        IDD_LINE_1,             NO_HELP,
        IDD_LINE_2,             NO_HELP,
        IDD_LINE_3,             NO_HELP,
        IDD_ITEMICON,           IDH_FPROP_GEN_ICON,
        IDD_NAMEEDIT,           IDH_FPROP_GEN_NAME,
        IDC_CHANGEFILETYPE,     IDH_FPROP_GEN_CHANGE,
        IDD_FILETYPE_TXT,       IDH_FPROP_GEN_TYPE,
        IDD_FILETYPE,           IDH_FPROP_GEN_TYPE,
        IDD_OPENSWITH_TXT,      IDH_FPROP_GEN_OPENSWITH,
        IDD_OPENSWITH,          IDH_FPROP_GEN_OPENSWITH,
        IDD_LOCATION_TXT,       IDH_FPROP_GEN_LOCATION,
        IDD_LOCATION,           IDH_FPROP_GEN_LOCATION,
        IDD_FILESIZE_TXT,       IDH_FPROP_GEN_SIZE,
        IDD_FILESIZE,           IDH_FPROP_GEN_SIZE,
        IDD_FILESIZE_COMPRESSED,     IDH_FPROP_GEN_COMPRESSED_SIZE,
        IDD_FILESIZE_COMPRESSED_TXT, IDH_FPROP_GEN_COMPRESSED_SIZE,
        IDD_CONTAINS_TXT,       IDH_FPROP_FOLDER_CONTAINS,
        IDD_CONTAINS,           IDH_FPROP_FOLDER_CONTAINS,
        IDD_CREATED_TXT,        IDH_FPROP_GEN_DATE_CREATED,
        IDD_CREATED,            IDH_FPROP_GEN_DATE_CREATED,
        IDD_LASTMODIFIED_TXT,   IDH_FPROP_GEN_LASTCHANGE,
        IDD_LASTMODIFIED,       IDH_FPROP_GEN_LASTCHANGE,
        IDD_LASTACCESSED_TXT,   IDH_FPROP_GEN_LASTACCESS,
        IDD_LASTACCESSED,       IDH_FPROP_GEN_LASTACCESS,
        IDD_ATTR_GROUPBOX,      IDH_COMM_GROUPBOX,
        IDD_READONLY,           IDH_FPROP_GEN_READONLY,
        IDD_HIDDEN,             IDH_FPROP_GEN_HIDDEN,
        IDD_ARCHIVE,            IDH_FPROP_GEN_ARCHIVE,
        IDC_ADVANCED,           IDH_FPROP_GEN_ADVANCED,
        IDC_DRV_PROPERTIES,     IDH_FPROP_GEN_MOUNTEDPROP,
        IDD_FILETYPE_TARGET,    IDH_FPROP_GEN_MOUNTEDTARGET,
        IDC_DRV_TARGET,         IDH_FPROP_GEN_MOUNTEDTARGET,
        0, 0
};

const DWORD aFolderGeneralHelpIds[] = {
        IDD_LINE_1,             NO_HELP,
        IDD_LINE_2,             NO_HELP,
        IDD_LINE_3,             NO_HELP,
        IDD_ITEMICON,           IDH_FPROP_GEN_ICON,
        IDD_NAMEEDIT,           IDH_FPROP_GEN_NAME,
        IDC_CHANGEFILETYPE,     IDH_FPROP_GEN_CHANGE,
        IDD_FILETYPE_TXT,       IDH_FPROP_GEN_TYPE,
        IDD_FILETYPE,           IDH_FPROP_GEN_TYPE,
        IDD_OPENSWITH_TXT,      IDH_FPROP_GEN_OPENSWITH,
        IDD_OPENSWITH,          IDH_FPROP_GEN_OPENSWITH,
        IDD_LOCATION_TXT,       IDH_FPROP_GEN_LOCATION,
        IDD_LOCATION,           IDH_FPROP_GEN_LOCATION,
        IDD_FILESIZE_TXT,       IDH_FPROP_GEN_SIZE,
        IDD_FILESIZE,           IDH_FPROP_GEN_SIZE,
        IDD_FILESIZE_COMPRESSED,     IDH_FPROP_GEN_COMPRESSED_SIZE,
        IDD_FILESIZE_COMPRESSED_TXT, IDH_FPROP_GEN_COMPRESSED_SIZE,
        IDD_CONTAINS_TXT,       IDH_FPROP_FOLDER_CONTAINS,
        IDD_CONTAINS,           IDH_FPROP_FOLDER_CONTAINS,
        IDD_CREATED_TXT,        IDH_FPROP_GEN_DATE_CREATED,
        IDD_CREATED,            IDH_FPROP_GEN_DATE_CREATED,
        IDD_LASTMODIFIED_TXT,   IDH_FPROP_GEN_LASTCHANGE,
        IDD_LASTMODIFIED,       IDH_FPROP_GEN_LASTCHANGE,
        IDD_LASTACCESSED_TXT,   IDH_FPROP_GEN_LASTACCESS,
        IDD_LASTACCESSED,       IDH_FPROP_GEN_LASTACCESS,
        IDD_ATTR_GROUPBOX,      IDH_COMM_GROUPBOX,
        IDD_READONLY,           IDH_FPROP_GEN_FOLDER_READONLY,
        IDD_HIDDEN,             IDH_FPROP_GEN_HIDDEN,
        IDD_ARCHIVE,            IDH_FPROP_GEN_ARCHIVE,
        IDC_ADVANCED,           IDH_FPROP_GEN_ADVANCED,
        IDC_DRV_PROPERTIES,     IDH_FPROP_GEN_MOUNTEDPROP,
        IDD_FILETYPE_TARGET,    IDH_FPROP_GEN_MOUNTEDTARGET,
        IDC_DRV_TARGET,         IDH_FPROP_GEN_MOUNTEDTARGET,
        0, 0
};

const DWORD aMultiPropHelpIds[] = {
        IDD_LINE_1,             NO_HELP,
        IDD_LINE_2,             NO_HELP,
        IDD_ITEMICON,           IDH_FPROP_GEN_ICON,
        IDD_CONTAINS,           IDH_MULTPROP_NAME,
        IDD_FILETYPE_TXT,       IDH_FPROP_GEN_TYPE,
        IDD_FILETYPE,           IDH_FPROP_GEN_TYPE,
        IDD_LOCATION_TXT,       IDH_FPROP_GEN_LOCATION,
        IDD_LOCATION,           IDH_FPROP_GEN_LOCATION,
        IDD_FILESIZE_TXT,       IDH_FPROP_GEN_SIZE,
        IDD_FILESIZE,           IDH_FPROP_GEN_SIZE,
        IDD_FILESIZE_COMPRESSED,     IDH_FPROP_GEN_COMPRESSED_SIZE,
        IDD_FILESIZE_COMPRESSED_TXT, IDH_FPROP_GEN_COMPRESSED_SIZE,
        IDD_ATTR_GROUPBOX,      IDH_COMM_GROUPBOX,
        IDD_READONLY,           IDH_FPROP_GEN_READONLY,
        IDD_HIDDEN,             IDH_FPROP_GEN_HIDDEN,
        IDD_ARCHIVE,            IDH_FPROP_GEN_ARCHIVE,
        IDC_ADVANCED,           IDH_FPROP_GEN_ADVANCED,
        0, 0
};

const DWORD aAdvancedHelpIds[] = {
        IDD_ITEMICON,           NO_HELP,
        IDC_MANAGEFILES_TXT,    NO_HELP,
        IDD_MANAGEFOLDERS_TXT,  NO_HELP,
        IDD_ARCHIVE,            IDH_FPROP_GEN_ARCHIVE,
        IDD_INDEX,              IDH_FPROP_GEN_INDEX,
        IDD_COMPRESS,           IDH_FPROP_GEN_COMPRESSED,
        IDD_ENCRYPT,            IDH_FPROP_GEN_ENCRYPT,
        0, 0
};

FOLDERCONTENTSINFO* Create_FolderContentsInfo()
{
    FOLDERCONTENTSINFO *pfci = (FOLDERCONTENTSINFO*)LocalAlloc(LPTR, sizeof(*pfci));
    if (pfci)
    {
        pfci->_cRef = 1;
    }
    return pfci;
}

void Free_FolderContentsInfoMembers(FOLDERCONTENTSINFO* pfci)
{
    if (pfci->hida)
    {
        GlobalFree(pfci->hida);
        pfci->hida = NULL;
    }
}

LONG AddRef_FolderContentsInfo(FOLDERCONTENTSINFO* pfci)
{
    ASSERTMSG(pfci != NULL, "AddRef_FolderContentsInfo: caller passed a null pfci");
    if (pfci)
    {
        return InterlockedIncrement(&pfci->_cRef);
    }
    return 0;
}

LONG Release_FolderContentsInfo(FOLDERCONTENTSINFO* pfci)
{
    if (pfci)
    {
        if (InterlockedDecrement(&pfci->_cRef))
        {
            return pfci->_cRef;
        }
        Free_FolderContentsInfoMembers(pfci);
        LocalFree(pfci);
    }
    return 0;
}


void UpdateSizeCount(FILEPROPSHEETPAGE * pfpsp)
{
    TCHAR szNum[32], szNum1[64];
    LPTSTR pszFmt = ShellConstructMessageString(HINST_THISDLL,
         MAKEINTRESOURCE(pfpsp->pfci->cbSize ? IDS_SIZEANDBYTES : IDS_SIZE),
         ShortSizeFormat64(pfpsp->pfci->cbSize, szNum, ARRAYSIZE(szNum)),
         AddCommas64(pfpsp->pfci->cbSize, szNum1, ARRAYSIZE(szNum1)));
    if (pszFmt)
    {
        SetDlgItemText(pfpsp->hDlg, IDD_FILESIZE, pszFmt);
        LocalFree(pszFmt);
    }

    pszFmt = ShellConstructMessageString(HINST_THISDLL,
         MAKEINTRESOURCE(pfpsp->pfci->cbActualSize ? IDS_SIZEANDBYTES : IDS_SIZE),
         ShortSizeFormat64(pfpsp->pfci->cbActualSize, szNum, ARRAYSIZE(szNum)),
         AddCommas64(pfpsp->pfci->cbActualSize, szNum1, ARRAYSIZE(szNum1)));

    if (pszFmt)
    {
        SetDlgItemText(pfpsp->hDlg, IDD_FILESIZE_COMPRESSED, pszFmt);
        LocalFree(pszFmt);
    }

    pszFmt = ShellConstructMessageString(HINST_THISDLL,
         MAKEINTRESOURCE(IDS_NUMFILES),
         AddCommas(pfpsp->pfci->cFiles, szNum, ARRAYSIZE(szNum)),
         AddCommas(pfpsp->pfci->cFolders, szNum1, ARRAYSIZE(szNum1)));
    if (pszFmt && !pfpsp->fMountedDrive)
    {
        SetDlgItemText(pfpsp->hDlg, IDD_CONTAINS, pszFmt);
        LocalFree(pszFmt);
    }
}


STDAPI_(BOOL) HIDA_FillFindData(HIDA hida, UINT iItem, LPTSTR pszPath, WIN32_FIND_DATA *pfd, BOOL fReturnCompressedSize)
{
    BOOL fRet = FALSE;      // assume error
    *pszPath = 0;           // assume error

    LPITEMIDLIST pidl = HIDA_ILClone(hida, iItem);
    if (pidl)
    {
        if (SHGetPathFromIDList(pidl, pszPath))
        {
            if (pfd)
            {
                HANDLE h = FindFirstFile(pszPath, pfd);
                if (h == INVALID_HANDLE_VALUE)
                {
                    // error, zero the bits
                    ZeroMemory(pfd, sizeof(*pfd));
                }
                else
                {
                    FindClose(h);
                    // if the user wants the compressed file size, and compression is supported, then go get it
                    if (fReturnCompressedSize && (pfd->dwFileAttributes & (FILE_ATTRIBUTE_COMPRESSED | FILE_ATTRIBUTE_SPARSE_FILE)))
                    {
                        pfd->nFileSizeLow = SHGetCompressedFileSize(pszPath, &pfd->nFileSizeHigh);
                    }
                }
            }
            fRet = TRUE;
        }
        ILFree(pidl);
    }
    return fRet;
}


DWORD CALLBACK SizeThreadProc(void *pv)
{
    FOLDERCONTENTSINFO* pfci = (FOLDERCONTENTSINFO*)pv;

    pfci->cbSize  = 0;
    pfci->cbActualSize = 0;
    pfci->cFiles = 0;
    pfci->cFolders = 0;

    if (pfci->bContinue && pfci->hDlg)
    {
        // update the dialog every 1/4 second
        SetTimer(pfci->hDlg, IDT_SIZE, 250, NULL);
    }

    TCHAR szPath[MAX_PATH];
    for (UINT iItem = 0; HIDA_FillFindData(pfci->hida, iItem, szPath, &pfci->fd, FALSE) && pfci->bContinue; iItem++)
    {
        if (pfci->fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
        {
            FolderSize(szPath, pfci);

            if (pfci->fMultipleFiles)
            {
                // for multiple file/folder properties, count myself
                pfci->cFolders++;
            }
        }
        else
        {   // file selected
            ULARGE_INTEGER ulSize, ulSizeOnDisk;
            DWORD dwClusterSize = PathGetClusterSize(szPath);

            // if compression is supported, we check to see if the file is sparse or compressed
            if (pfci->fIsCompressionAvailable && (pfci->fd.dwFileAttributes & (FILE_ATTRIBUTE_COMPRESSED | FILE_ATTRIBUTE_SPARSE_FILE)))
            {
                ulSizeOnDisk.LowPart = SHGetCompressedFileSize(szPath, &ulSizeOnDisk.HighPart);
            }
            else
            {
                // not compressed or sparse, so just round to the cluster size
                ulSizeOnDisk.LowPart = pfci->fd.nFileSizeLow;
                ulSizeOnDisk.HighPart = pfci->fd.nFileSizeHigh;
                ulSizeOnDisk.QuadPart = ROUND_TO_CLUSTER(ulSizeOnDisk.QuadPart, dwClusterSize);
            }

            // add the size in
            ulSize.LowPart = pfci->fd.nFileSizeLow;
            ulSize.HighPart = pfci->fd.nFileSizeHigh;
            pfci->cbSize += ulSize.QuadPart;

            // add the size on disk in
            pfci->cbActualSize += ulSizeOnDisk.QuadPart;

            // increment the # of files
            pfci->cFiles++;
        }

        // set this so the progress bar knows how much total work there is to do

        // ISSUE RAID BUG - 120446 - Need to Guard access to pfci->ulTotalNumberOfBytes.QuadParts
        pfci->ulTotalNumberOfBytes.QuadPart = pfci->cbActualSize;
    }  // end of For Loop.


    if (pfci->bContinue && pfci->hDlg)
    {
        KillTimer(pfci->hDlg, IDT_SIZE);
        // make sure that there is a WM_TIMER message in the queue so we will get the "final" results
        PostMessage(pfci->hDlg, WM_TIMER, (WPARAM)IDT_SIZE, (LPARAM)NULL);
    }

    pfci->fIsSizeThreadAlive = FALSE;
    Release_FolderContentsInfo(pfci);
    return 0;
}

DWORD CALLBACK SizeThread_AddRefCallBack(void *pv)
{
    FOLDERCONTENTSINFO* pfci = (FOLDERCONTENTSINFO *)pv;
    AddRef_FolderContentsInfo(pfci);
    pfci->fIsSizeThreadAlive = TRUE;
    return 0;
}

void CreateSizeThread(FILEPROPSHEETPAGE * pfpsp)
{
    if (pfpsp->pfci->bContinue)
    {
        if (!pfpsp->pfci->fIsSizeThreadAlive)
        {
            SHCreateThread(SizeThreadProc, pfpsp->pfci, CTF_COINIT, SizeThread_AddRefCallBack);
        }
        else
        {
            // previous size thread still running, so bail
        }
    }
}

void KillSizeThread(FILEPROPSHEETPAGE * pfpsp)
{
    // signal the thread to stop
    pfpsp->pfci->bContinue = FALSE;
}


DWORD GetVolumeFlags(LPCTSTR pszPath, OUT OPTIONAL LPTSTR pszFileSys, int cchFileSys)
{
    TCHAR szRoot[MAX_PATH];

    /* Is this mounted point, e.g. c:\ or c:\hostfolder\ */
    if (!PathGetMountPointFromPath(pszPath, szRoot, ARRAYSIZE(szRoot)))
    {
        //no
        lstrcpyn(szRoot, pszPath, ARRAYSIZE(szRoot));
        PathStripToRoot(szRoot);
    }
    // GetVolumeInformation requires a trailing backslash.  Append one
    PathAddBackslash(szRoot);

    if (pszFileSys)
        *pszFileSys = 0 ;

    DWORD dwVolumeFlags;
    if (GetVolumeInformation(szRoot, NULL, 0, NULL, NULL, &dwVolumeFlags, pszFileSys, cchFileSys))
    {
        return dwVolumeFlags;
    }
    else
    {
        return 0;
    }
}


//
// This function sets the initial file attributes based on the dwFlagsAND / dwFlagsOR
// for the multiple file case
//
void SetInitialFileAttribs(FILEPROPSHEETPAGE* pfpsp, DWORD dwFlagsAND, DWORD dwFlagsOR)
{
    DWORD dwTriState = dwFlagsAND ^ dwFlagsOR; // this dword now has all the bits that are in the BST_INDETERMINATE state
#ifdef DEBUG
    // the pfpsp struct should have been zero inited, make sure that our ATTRIBUTESTATE
    // structs are zero inited
    ATTRIBUTESTATE asTemp = {0};
    ASSERT(memcmp(&pfpsp->asInitial, &asTemp, sizeof(pfpsp->asInitial)) == 0);
#endif // DEBUG

    // set the inital state based on the flags
    if (dwTriState & FILE_ATTRIBUTE_READONLY)
    {
        pfpsp->asInitial.fReadOnly = BST_INDETERMINATE;
    }
    else if (dwFlagsAND & FILE_ATTRIBUTE_READONLY)
    {
        pfpsp->asInitial.fReadOnly = BST_CHECKED;
    }

    if (dwTriState & FILE_ATTRIBUTE_HIDDEN)
    {
        pfpsp->asInitial.fHidden = BST_INDETERMINATE;
    }
    else if (dwFlagsAND & FILE_ATTRIBUTE_HIDDEN)
    {
        pfpsp->asInitial.fHidden = BST_CHECKED;
    }

    if (dwTriState & FILE_ATTRIBUTE_ARCHIVE)
    {
        pfpsp->asInitial.fArchive = BST_INDETERMINATE;
    }
    else if (dwFlagsAND & FILE_ATTRIBUTE_ARCHIVE)
    {
        pfpsp->asInitial.fArchive = BST_CHECKED;
    }

    if (dwTriState & FILE_ATTRIBUTE_NOT_CONTENT_INDEXED)
    {
        pfpsp->asInitial.fIndex = BST_INDETERMINATE;
    }
    else if (!(dwFlagsAND & FILE_ATTRIBUTE_NOT_CONTENT_INDEXED))
    {
        pfpsp->asInitial.fIndex = BST_CHECKED;
    }

    if (dwTriState & FILE_ATTRIBUTE_COMPRESSED)
    {
        pfpsp->asInitial.fCompress = BST_INDETERMINATE;
    }
    else if (dwFlagsAND & FILE_ATTRIBUTE_COMPRESSED)
    {
        pfpsp->asInitial.fCompress = BST_CHECKED;
    }

    if (dwTriState & FILE_ATTRIBUTE_ENCRYPTED)
    {
        pfpsp->asInitial.fEncrypt = BST_INDETERMINATE;
    }
    else if (dwFlagsAND & FILE_ATTRIBUTE_ENCRYPTED)
    {
        pfpsp->asInitial.fEncrypt = BST_CHECKED;
    }
}


//
// Updates the size fields for single and multiple file property sheets.
//
// NOTE: if you have the the WIN32_FIND_DATA already, then pass it for perf
//
STDAPI_(void) UpdateSizeField(FILEPROPSHEETPAGE* pfpsp, WIN32_FIND_DATA* pfd)
{
    WIN32_FIND_DATA wfd;

    if (pfpsp->pfci->fMultipleFiles)
    {
        // multiple selection case
        // create the size and # of files thread
        CreateSizeThread(pfpsp);
    }
    else
    {
        // if the caller didn't pass pfd, then go get the WIN32_FIND_DATA now
        if (!pfd)
        {
            HANDLE hFind = FindFirstFile(pfpsp->szPath, &wfd);

            if (hFind == INVALID_HANDLE_VALUE)
            {
                // if this failed we should clear out all the values as to not show garbage on the screen.
                ZeroMemory(&wfd, sizeof(wfd));
            }
            else
            {
                FindClose(hFind);
            }

            pfd = &wfd;
        }

        if (pfpsp->fMountedDrive)
        {
            // mounted drive case
            SetDateTimeText(pfpsp->hDlg, IDD_CREATED, &pfd->ftCreationTime);
        }
        else if (pfpsp->fIsDirectory)
        {
            // single folder case, in the UI we call this "Modified"
            // but since NTFS updates ftModified when the contents of the
            // folder changes (FAT does not) we use ftCreationTime as the
            // stable end user notiion of "Modified"
            SetDateTimeText(pfpsp->hDlg, IDD_CREATED, &pfd->ftCreationTime);

            // create the size and # of files thread
            CreateSizeThread(pfpsp);
        }
        else
        {
            TCHAR szNum1[MAX_COMMA_AS_K_SIZE];
            TCHAR szNum2[MAX_COMMA_NUMBER_SIZE];
            ULARGE_INTEGER ulSize = { pfd->nFileSizeLow, pfd->nFileSizeHigh };
            DWORD dwClusterSize = PathGetClusterSize(pfpsp->szPath);

            // fill in the "Size:" field
            LPTSTR pszFmt = ShellConstructMessageString(HINST_THISDLL,
                                                 MAKEINTRESOURCE(ulSize.QuadPart ? IDS_SIZEANDBYTES : IDS_SIZE),
                                                 ShortSizeFormat64(ulSize.QuadPart, szNum1, ARRAYSIZE(szNum1)),
                                                 AddCommas64(ulSize.QuadPart, szNum2, ARRAYSIZE(szNum2)));
            if (pszFmt)
            {
                SetDlgItemText(pfpsp->hDlg, IDD_FILESIZE, pszFmt);
                LocalFree(pszFmt);
            }

            //
            // fill in the "Size on disk:" field
            //
            if (pfd->dwFileAttributes & (FILE_ATTRIBUTE_COMPRESSED | FILE_ATTRIBUTE_SPARSE_FILE))
            {
                // the file is compressed or sparse, so for "size on disk" use the compressed size
                ulSize.LowPart = SHGetCompressedFileSize(pfpsp->szPath, &ulSize.HighPart);
            }
            else
            {
                // the file isint comrpessed so just round to the cluster size for the "size on disk"
                ulSize.LowPart = pfd->nFileSizeLow;
                ulSize.HighPart = pfd->nFileSizeHigh;
                ulSize.QuadPart = ROUND_TO_CLUSTER(ulSize.QuadPart, dwClusterSize);
            }

            pszFmt = ShellConstructMessageString(HINST_THISDLL,
                                                 MAKEINTRESOURCE(ulSize.QuadPart ? IDS_SIZEANDBYTES : IDS_SIZE),
                                                 ShortSizeFormat64(ulSize.QuadPart, szNum1, ARRAYSIZE(szNum1)),
                                                 AddCommas64(ulSize.QuadPart, szNum2, ARRAYSIZE(szNum2)));
            if (pszFmt && !pfpsp->fMountedDrive)
            {
                SetDlgItemText(pfpsp->hDlg, IDD_FILESIZE_COMPRESSED, pszFmt);
                LocalFree(pszFmt);
            }

            //
            // we always touch the file in the process of getting its info, so the
            // ftLastAccessTime is always TODAY, which makes this field pretty useless...

            // date and time
            SetDateTimeText(pfpsp->hDlg, IDD_CREATED,      &pfd->ftCreationTime);
            SetDateTimeText(pfpsp->hDlg, IDD_LASTMODIFIED, &pfd->ftLastWriteTime);
            {
                // FAT implementation doesn't support last accessed time (gets the date right, but not the time),
                // so we won't display it
                DWORD dwFlags = FDTF_LONGDATE | FDTF_RELATIVE;

                if (NULL == StrStrI(pfpsp->szFileSys, TEXT("FAT")))
                    dwFlags |= FDTF_LONGTIME;   // for non FAT file systems

                SetDateTimeTextEx(pfpsp->hDlg, IDD_LASTACCESSED, &pfd->ftLastAccessTime, dwFlags);
            }
        }
    }
}


//
// Descriptions:
//   This function fills fields of the multiple object property sheet.
//
BOOL InitMultiplePrsht(FILEPROPSHEETPAGE* pfpsp)
{
    SHFILEINFO sfi;
    TCHAR szBuffer[MAX_PATH+1];
    BOOL fMultipleType = FALSE;
    BOOL fSameLocation = TRUE;
    DWORD dwFlagsOR = 0;                // start all clear
    DWORD dwFlagsAND = (DWORD)-1;       // start all set
    DWORD dwVolumeFlagsAND = (DWORD)-1; // start all set

    TCHAR szType[MAX_PATH];
    TCHAR szDirPath[MAX_PATH];
    szDirPath[0] = 0;
    szType[0] = 0;

    // For all the selected files compare their types and get their attribs
    for (int iItem = 0; HIDA_FillFindData(pfpsp->pfci->hida, iItem, szBuffer, NULL, FALSE); iItem++)
    {
        DWORD dwFileAttributes = GetFileAttributes(szBuffer);

        dwFlagsAND &= dwFileAttributes;
        dwFlagsOR  |= dwFileAttributes;

        // process types only if we haven't already found that there are several types
        if (!fMultipleType)
        {
            SHGetFileInfo((LPTSTR)IDA_GetIDListPtr((LPIDA)GlobalLock(pfpsp->pfci->hida), iItem), 0,
                &sfi, sizeof(sfi), SHGFI_PIDL|SHGFI_TYPENAME);

            if (szType[0] == 0)
                lstrcpyn(szType, sfi.szTypeName, ARRAYSIZE(szType));
            else
                fMultipleType = lstrcmp(szType, sfi.szTypeName) != 0;
        }

        dwVolumeFlagsAND &= GetVolumeFlags(szBuffer, pfpsp->szFileSys, ARRAYSIZE(pfpsp->szFileSys));
        // check to see if the files are in the same location
        if (fSameLocation)
        {
            PathRemoveFileSpec(szBuffer);

            if (szDirPath[0] == 0)
                lstrcpyn(szDirPath, szBuffer, ARRAYSIZE(szDirPath));
            else
                fSameLocation = (lstrcmpi(szDirPath, szBuffer) == 0);
        }
    }

    if ((dwVolumeFlagsAND & FS_FILE_ENCRYPTION) && !SHRestricted(REST_NOENCRYPTION))
    {
        // all the files are on volumes that support encryption (eg NTFS)
        pfpsp->fIsEncryptionAvailable = TRUE;
    }

    if (dwVolumeFlagsAND & FS_FILE_COMPRESSION)
    {
        pfpsp->pfci->fIsCompressionAvailable = TRUE;
    }

    //
    // HACK (reinerf) - we dont have a FS_SUPPORTS_INDEXING so we
    // use the FILE_SUPPORTS_SPARSE_FILES flag, because native index support
    // appeared first on NTFS5 volumes, at the same time sparse file support
    // was implemented.
    //
    if (dwVolumeFlagsAND & FILE_SUPPORTS_SPARSE_FILES)
    {
        // yup, we are on NTFS5 or greater
        pfpsp->fIsIndexAvailable = TRUE;
    }

    // if any of the files was a directory, then we set this flag
    if (dwFlagsOR & FILE_ATTRIBUTE_DIRECTORY)
    {
        pfpsp->fIsDirectory = TRUE;
    }

    // setup all the flags based on what we found out
    SetInitialFileAttribs(pfpsp, dwFlagsAND, dwFlagsOR);

    // set the current attributes to the same as the initial
    pfpsp->asCurrent = pfpsp->asInitial;

    //
    // now setup all the controls on the dialog based on the attribs
    // that we have
    //

    // check for multiple file types
    if (fMultipleType)
    {
        LoadString(HINST_THISDLL, IDS_MULTIPLETYPES, szBuffer, ARRAYSIZE(szBuffer));
    }
    else
    {
        LoadString(HINST_THISDLL, IDS_ALLOFTYPE, szBuffer, ARRAYSIZE(szBuffer));
        StrCatBuff(szBuffer, szType, ARRAYSIZE(szBuffer));
    }
    SetDlgItemText(pfpsp->hDlg, IDD_FILETYPE, szBuffer);

    if (fSameLocation)
    {
        LoadString(HINST_THISDLL, IDS_ALLIN, szBuffer, ARRAYSIZE(szBuffer));
        StrCatBuff(szBuffer, szDirPath, ARRAYSIZE(szBuffer));
        lstrcpyn(pfpsp->szPath, szDirPath, ARRAYSIZE(pfpsp->szPath));
    }
    else
    {
        LoadString(HINST_THISDLL, IDS_VARFOLDERS, szBuffer, ARRAYSIZE(szBuffer));
    }

    //Keep Functionality same as NT4 by avoiding PathCompactPath. 
    SetDlgItemTextWithToolTip(pfpsp->hDlg, IDD_LOCATION, szBuffer, &pfpsp->hwndTip);

    //
    // check the ReadOnly and Hidden checkboxes, they always appear on the general tab
    //
    if (pfpsp->asInitial.fReadOnly == BST_INDETERMINATE)
    {
        SendDlgItemMessage(pfpsp->hDlg, IDD_READONLY, BM_SETSTYLE, BS_AUTO3STATE, 0);
    }
    CheckDlgButton(pfpsp->hDlg, IDD_READONLY, pfpsp->asCurrent.fReadOnly);

    if (pfpsp->asInitial.fHidden == BST_INDETERMINATE)
    {
        SendDlgItemMessage(pfpsp->hDlg, IDD_HIDDEN, BM_SETSTYLE, BS_AUTO3STATE, 0);
    }
    CheckDlgButton(pfpsp->hDlg, IDD_HIDDEN, pfpsp->asCurrent.fHidden);

    // to avoid people making SYSTEM files HIDDEN (SYSTEM HIDDEN files are
    // never show to the user) we don't let people make SYSTEM files HIDDEN
    if (dwFlagsOR & FILE_ATTRIBUTE_SYSTEM)
        EnableWindow(GetDlgItem(pfpsp->hDlg, IDD_HIDDEN), FALSE);

    // Archive is only on the general tab for FAT, otherwise it is under the "Advanced attributes"
    // and FAT volumes dont have the "Advanced attributes" button.
    if (pfpsp->pfci->fIsCompressionAvailable || pfpsp->fIsEncryptionAvailable)
    {
        // if compression is available, then we must be on NTFS
        DestroyWindow(GetDlgItem(pfpsp->hDlg, IDD_ARCHIVE));
    }
    else
    {
        // we are on FAT/FAT32, so get rid of the "Advanced attributes" button, and set the inital Archive state
        DestroyWindow(GetDlgItem(pfpsp->hDlg, IDC_ADVANCED));

        if (pfpsp->asInitial.fArchive == BST_INDETERMINATE)
        {
            SendDlgItemMessage(pfpsp->hDlg, IDD_ARCHIVE, BM_SETSTYLE, BS_AUTO3STATE, 0);
        }
        CheckDlgButton(pfpsp->hDlg, IDD_ARCHIVE, pfpsp->asCurrent.fArchive);
    }

    UpdateSizeField(pfpsp, NULL);

    return TRUE;
}

void Free_DlgDependentFilePropSheetPage(FILEPROPSHEETPAGE* pfpsp)
{
    // this frees the members that are dependent on pfpsp->hDlg still
    // being valid

    if (pfpsp)
    {
        ASSERT(IsWindow(pfpsp->hDlg));  // our window had better still be valid!

        ReplaceDlgIcon(pfpsp->hDlg, IDD_ITEMICON, NULL);

        if (pfpsp->pfci && !pfpsp->pfci->fMultipleFiles)
        {
            // single-file specific members
            if (!pfpsp->fIsDirectory)
            {
                // cleanup the typeicon for non-folders
                ReplaceDlgIcon(pfpsp->hDlg, IDD_TYPEICON, NULL);
            }
        }
    }
}

void Free_DlgIndepFilePropSheetPage(FILEPROPSHEETPAGE *pfpsp)
{
    if (pfpsp)
    {
        IAssocStore* pas = (IAssocStore *)pfpsp->pAssocStore;
        if (pas)
        {
            delete pas;
            pfpsp->pAssocStore = NULL;
        }

        Release_FolderContentsInfo(pfpsp->pfci);
        pfpsp->pfci = NULL;

        ILFree(pfpsp->pidl);
        pfpsp->pidl = NULL;

        ILFree(pfpsp->pidlTarget);
        pfpsp->pidlTarget = NULL;
    }
}

//
// Descriptions:
//   Callback for the property sheet code
//
UINT CALLBACK FilePrshtCallback(HWND hwnd, UINT uMsg, LPPROPSHEETPAGE ppsp)
{
    if (uMsg == PSPCB_RELEASE)
    {
        FILEPROPSHEETPAGE * pfpsp = (FILEPROPSHEETPAGE *)ppsp;

        // Careful!  pfpsp can be NULL in low memory situations
        if (pfpsp)
        {
            KillSizeThread(pfpsp);
            Free_DlgIndepFilePropSheetPage(pfpsp);
        }
    }

    return 1;
}

//
// DESCRIPTION:
//
//   Opens the file for compression.  It handles the case where a READONLY
//   file is trying to be compressed or uncompressed.  Since read only files
//   cannot be opened for WRITE_DATA, it temporarily resets the file to NOT
//   be READONLY in order to open the file, and then sets it back once the
//   file has been compressed.
//
//   Taken from WinFile module wffile.c without change.  Originally from
//   G. Kimura's compact.c. Now taken from shcompui without change.
//
// ARGUMENTS:
//
//   phFile
//      Address of file handle variable for handle of open file if
//      successful.
//
//   szFile
//      Name string of file to be opened.
//
// RETURNS:
//
//    TRUE  = File successfully opened.  Handle in *phFile.
//    FALSE = File couldn't be opened. *phFile == INVALID_HANDLE_VALUE
//
///////////////////////////////////////////////////////////////////////////////
BOOL OpenFileForCompress(HANDLE *phFile, LPCTSTR szFile)
{
    //
    //  Try to open the file - READ_DATA | WRITE_DATA.
    //
    if ((*phFile = CreateFile(szFile,
                               FILE_READ_DATA | FILE_WRITE_DATA,
                               FILE_SHARE_READ | FILE_SHARE_WRITE,
                               NULL,
                               OPEN_EXISTING,
                               FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_SEQUENTIAL_SCAN,
                               NULL)) != INVALID_HANDLE_VALUE)
    {
        //
        //  Successfully opened the file.
        //
        return TRUE;
    }

    if (GetLastError() != ERROR_ACCESS_DENIED)
    {
        return FALSE;
    }

    //
    //  Try to open the file - READ_ATTRIBUTES | WRITE_ATTRIBUTES.
    //
    HANDLE hAttr = CreateFile(szFile,
                              FILE_READ_ATTRIBUTES | FILE_WRITE_ATTRIBUTES,
                              FILE_SHARE_READ | FILE_SHARE_WRITE,
                              NULL,
                              OPEN_EXISTING,
                              FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_SEQUENTIAL_SCAN,
                              NULL);
    
    if (hAttr == INVALID_HANDLE_VALUE)
    {
        return FALSE;
    }

    //
    //  See if the READONLY attribute is set.
    //
    BY_HANDLE_FILE_INFORMATION fi;
    if ((!GetFileInformationByHandle(hAttr, &fi)) ||
         (!(fi.dwFileAttributes & FILE_ATTRIBUTE_READONLY)))
    {
        //
        //  If the file could not be open for some reason other than that
        //  the readonly attribute was set, then fail.
        //
        CloseHandle(hAttr);
        return FALSE;
    }

    //
    //  Turn OFF the READONLY attribute.
    //
    fi.dwFileAttributes &= ~FILE_ATTRIBUTE_READONLY;
    if (!SetFileAttributes(szFile, fi.dwFileAttributes))
    {
        CloseHandle(hAttr);
        return FALSE;
    }

    //
    //  Try again to open the file - READ_DATA | WRITE_DATA.
    //
    *phFile = CreateFile(szFile,
                          FILE_READ_DATA | FILE_WRITE_DATA,
                          FILE_SHARE_READ | FILE_SHARE_WRITE,
                          NULL,
                          OPEN_EXISTING,
                          FILE_FLAG_BACKUP_SEMANTICS | FILE_FLAG_SEQUENTIAL_SCAN,
                          NULL);

    //
    //  Close the file handle opened for READ_ATTRIBUTE | WRITE_ATTRIBUTE.
    //
    CloseHandle(hAttr);

    //
    //  Make sure the open succeeded.  If it still couldn't be opened with
    //  the readonly attribute turned off, then fail.
    //
    if (*phFile == INVALID_HANDLE_VALUE)
    {
        return FALSE;
    }

    //
    //  Turn the READONLY attribute back ON.
    //
    fi.dwFileAttributes |= FILE_ATTRIBUTE_READONLY;
    if (!SetFileAttributes(szFile, fi.dwFileAttributes))
    {
        CloseHandle(*phFile);
        *phFile = INVALID_HANDLE_VALUE;
        return FALSE;
    }

    //
    //  Return success.  A valid file handle is in *phFile.
    //
    return TRUE;
}

// One half second (500 ms = 0.5s)
#define ENCRYPT_RETRY_PERIOD       500
// Retry 4 times (at least 2s)
#define ENCRYPT_MAX_RETRIES         4

//
//  This function encrypts/decrypts a file. If the readonly bit is set, the
//  function will clear it and encrypt/decrypt and then set the RO bit back
//  We will also remove/replace the system bit for known encryptable system
//  files
//
//  szPath      a string that has the full path to the file
//  fCompress   TRUE  - compress the file
//              FALSE - decompress the file
//
//
//  return:     TRUE  - the file was sucessfully encryped/decryped
//              FALSE - the file could not be encryped/decryped
//
STDAPI_(BOOL) SHEncryptFile(LPCTSTR pszPath, BOOL fEncrypt)
{
    BOOL bRet = fEncrypt ? EncryptFile(pszPath) : DecryptFile(pszPath, 0);

    if (!bRet)
    {
        DWORD dwLastError = GetLastError();
        DWORD dwAttribs = GetFileAttributes(pszPath);

        // Check to see if the attributes are blocking the encryption and we can change them
        if (dwAttribs & (FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_READONLY))
        {
            BOOL fStripAttribs = TRUE;
            if (dwAttribs & FILE_ATTRIBUTE_SYSTEM)
            {
                fStripAttribs = FALSE;

                // We can only strip attributes if it is a know encryptable system file
                WCHAR szStream[MAX_PATH + 13];
                StrCpyNW(szStream, pszPath, ARRAYSIZE(szStream));
                StrCatW(szStream, TEXT(":encryptable"));
                
                HANDLE hStream = CreateFile(szStream, GENERIC_READ, NULL, NULL, OPEN_EXISTING, NULL, NULL);
                if (hStream != INVALID_HANDLE_VALUE)
                {
                    CloseHandle(hStream);
                    fStripAttribs = TRUE;
                }
            }

            if (fStripAttribs)
            {
                if (SetFileAttributes(pszPath, dwAttribs & ~FILE_ATTRIBUTE_READONLY & ~FILE_ATTRIBUTE_SYSTEM))
                {
                    int i = 0;
                    while (!bRet && i < ENCRYPT_MAX_RETRIES)
                    {
                        bRet = fEncrypt ? EncryptFile(pszPath) : DecryptFile(pszPath, 0);
                        if (!bRet)
                        {
                            i++;
                            Sleep(ENCRYPT_RETRY_PERIOD);
                        }
                    }
                    SetFileAttributes(pszPath, dwAttribs);
                }
            }
        }

        // If we failed after all this, make sure we return the right error code
        if (!bRet)
        {
            ASSERT(dwLastError != ERROR_SUCCESS);
            SetLastError(dwLastError);
        }
    }

    return bRet;
}

//
//  This function compresses/uncompresses a file.
//
//  szPath      a string that has the full path to the file
//  fCompress   TRUE  - compress the file
//              FALSE - decompress the file
//
//
//  return:     TRUE  - the file was sucessfully compressed/uncompressed
//              FALSE - the file could not be compressed/uncompressed
//
BOOL CompressFile(LPCTSTR pzsPath, BOOL fCompress)
{
    DWORD dwAttribs = GetFileAttributes(pzsPath);

    if (dwAttribs & FILE_ATTRIBUTE_ENCRYPTED)
    {
        // We will fail to compress/decompress the file if is encryped. We don't want
        // to bother the user w/ error messages in this case (since encryption "takes
        // presidence" over compression), so we just return success.
        return TRUE;
    }

    HANDLE hFile;
    if (OpenFileForCompress(&hFile, pzsPath))
    {
        USHORT uState = fCompress ? COMPRESSION_FORMAT_DEFAULT : COMPRESSION_FORMAT_NONE;
        ULONG Length;
        BOOL bRet = DeviceIoControl(hFile,
                               FSCTL_SET_COMPRESSION,
                               &uState,
                               sizeof(USHORT),
                               NULL,
                               0,
                               &Length,
                               FALSE);
        CloseHandle(hFile);
        return bRet;
    }
    else
    {
        // couldnt get a file handle
        return FALSE;
    }
}

BOOL IsValidFileName(LPCTSTR pszFileName)
{
    if (!pszFileName || !pszFileName[0])
    {
        return FALSE;
    }

    LPCTSTR psz = pszFileName;
    do
    {
        // we are only passed the file name, so its ok to use PIVC_LFN_NAME
        if (!PathIsValidChar(*psz, PIVC_LFN_NAME))
        {
            // found a non-legal character
            return FALSE;
        }

        psz = CharNext(psz);
    }
    while (*psz);

    // didn't find any illegal characters
    return TRUE;
}


// renames the file, or checks to see if it could be renamed if fCommit == FALSE
BOOL ApplyRename(FILEPROPSHEETPAGE* pfpsp, BOOL fCommit)
{
    ASSERT(pfpsp->fRename);

    TCHAR szNewName[MAX_PATH];
    Edit_GetText(GetDlgItem(pfpsp->hDlg, IDD_NAMEEDIT), szNewName, ARRAYSIZE(szNewName));

    if (StrCmpC(pfpsp->szInitialName, szNewName) != 0)
    {
        // the name could be changed from C:\foo.txt to C:\FOO.txt, this is
        // technically the same name to PathFileExists, but we should allow it
        // anyway
        BOOL fCaseChange = (lstrcmpi(pfpsp->szInitialName, szNewName) == 0);

        // get the dir where the file lives
        TCHAR szDir[MAX_PATH];
        lstrcpyn(szDir, pfpsp->szPath, ARRAYSIZE(szDir));
        PathRemoveFileSpec(szDir);

        // find out the old name with the extension (we cant use pfpsp->szInitialName here,
        // because it might not have had the extension depending on the users view|options settings)
        LPCTSTR pszOldName = PathFindFileName(pfpsp->szPath);

        if (!pfpsp->fShowExtension)
        {
            // the extension is hidden, so add it to the new path the user typed
            LPCTSTR pszExt = PathFindExtension(pfpsp->szPath);
            if (*pszExt)
            {
                // Note that we can't call PathAddExtension, because it removes the existing extension.
                lstrcatn(szNewName, pszExt, ARRAYSIZE(szNewName));
            }
        }

        // is this a test or is it the real thing? (test needed so we can put up error UI before we get
        // the PSN_LASTCHANCEAPPLY)
        if (fCommit)
        {
            if (SHRenameFileEx(pfpsp->hDlg, NULL, szDir, pszOldName, szNewName) == ERROR_SUCCESS)
            {
                SHChangeNotify(SHCNE_RENAMEITEM, SHCNF_FLUSH | SHCNF_PATH, pszOldName, szNewName);
            }
            else
            {
                return FALSE;   // dont need error ui because SHRenameFile takes care of that for us.
            }
        }
        else
        {
            TCHAR szNewPath[MAX_PATH];
            PathCombine(szNewPath, szDir, szNewName);

            if (!IsValidFileName(szNewName) || (PathFileExists(szNewPath) && !fCaseChange))
            {
                LRESULT lRet = SHRenameFileEx(pfpsp->hDlg, NULL, szDir, pszOldName, szNewName);

                if (lRet == ERROR_SUCCESS)
                {
                    // Whoops, I guess we really CAN rename the file (this case can happen if the user
                    // tries to add a whole bunch of .'s to the end of a folder name).

                    // Rename it back so we can succeed when we call this fn. again with fCommit = TRUE;
                    lRet = SHRenameFileEx(NULL, NULL, szDir, szNewName, pszOldName);
                    ASSERT(lRet == ERROR_SUCCESS);

                    return TRUE;
                }

                // SHRenameFileEx put up the error UI for us, so just return false.
                return FALSE;
            }
        }
        // we dont bother doing anything if the rename succeeded since we only do renames
        // if the dialog is about to close (user hit "ok")
    }
    return TRUE;
}


//
// this is the dlg proc for Attribute Errors
//
//   returns
//
//      IDCANCEL                - user clicked abort
//      IDRETRY                 - user clicked retry
//      IDIGNORE                - user clicked ignore
//      IDIGNOREALL             - user clikced ignore all
//
BOOL_PTR CALLBACK FailedApplyAttribDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        case WM_INITDIALOG:
        {
            ATTRIBUTEERROR* pae = (ATTRIBUTEERROR*)lParam;

            TCHAR szPath[MAX_PATH];
            lstrcpyn(szPath, pae->pszPath, ARRAYSIZE(szPath));

            // Modify very long path names so that they fit into the message box.
            // get the size of the text boxes
            RECT rc;
            GetWindowRect(GetDlgItem(hDlg, IDD_NAME), &rc);
            PathCompactPath(NULL, szPath, rc.right - rc.left);

            SetDlgItemText(hDlg, IDD_NAME, szPath);

            // Default message if FormatMessage doesn't recognize dwLastError
            TCHAR szTemplate[MAX_PATH];
            LoadString(HINST_THISDLL, IDS_UNKNOWNERROR, szTemplate, ARRAYSIZE(szTemplate));
            TCHAR szErrorMsg[MAX_PATH];
            wnsprintf(szErrorMsg, ARRAYSIZE(szErrorMsg), szTemplate, pae->dwLastError);

            // Try the system error message
            FormatMessage(FORMAT_MESSAGE_FROM_SYSTEM, NULL, pae->dwLastError, 0, szErrorMsg, ARRAYSIZE(szErrorMsg), NULL);

            SetDlgItemText(hDlg, IDD_ERROR_TXT, szErrorMsg);
            EnableWindow(hDlg, TRUE);
            break;
        }

        case WM_COMMAND:
        {
            UINT uCtrlID = GET_WM_COMMAND_ID(wParam, lParam);
            switch (uCtrlID)
            {
                case IDIGNOREALL:   // = 10  (this comes from shell32.rc, the rest come from winuser.h)
                case IDCANCEL:      // = 2
                case IDRETRY:       // = 4
                case IDIGNORE:      // = 5
                    EndDialog(hDlg, uCtrlID);
                    return TRUE;
                    break;

                default:
                    return FALSE;
            }
            break;
        }
        default :
            return FALSE;
    }
    return FALSE;
}


//
// This function displays the "and error has occured [abort] [retry] [ignore] [ignore all]" message
// If the user hits abort, then we return FALSE so that our caller knows to abort the operation
//
//  returns the id of the button pressed (one of: IDIGNOREALL, IDIGNORE, IDCANCEL, IDRETRY)
//
int FailedApplyAttribsErrorDlg(HWND hWndParent, ATTRIBUTEERROR* pae)
{
    //  Put up the error message box - ABORT, RETRY, IGNORE, IGNORE ALL.
    int iRet = (int)DialogBoxParam(HINST_THISDLL,
                          MAKEINTRESOURCE(DLG_ATTRIBS_ERROR),
                          hWndParent,
                          FailedApplyAttribDlgProc,
                          (LPARAM)pae);
    //
    // if the user hits the ESC key or the little X thingy, then
    // iRet = 0, so we set iRet = IDCANCEL
    //
    if (!iRet)
    {
        iRet = IDCANCEL;
    }

    return iRet;
}

//
// we check to see if this is a known bad file that we skip applying attribs to
//
BOOL IsBadAttributeFile(LPCTSTR pszFile, FILEPROPSHEETPAGE* pfpsp)
{
    const static LPTSTR s_rgszBadFiles[] = {
        {TEXT("pagefile.sys")},
        {TEXT("hiberfil.sys")},
        {TEXT("ntldr")},
        {TEXT("ntdetect.com")},
        {TEXT("explorer.exe")},
        {TEXT("System Volume Information")},
        {TEXT("cmldr")},
        {TEXT("desktop.ini")},
        {TEXT("ntuser.dat")},
        {TEXT("ntuser.dat.log")},
        {TEXT("ntuser.pol")},
        {TEXT("usrclass.dat")},
        {TEXT("usrclass.dat.log")}};

    LPTSTR pszFileName = PathFindFileName(pszFile);
    for (int i = 0; i < ARRAYSIZE(s_rgszBadFiles); i++)
    {
        if (lstrcmpi(s_rgszBadFiles[i], pszFileName) == 0)
        {
            // this file matched on of the "bad" files that we dont apply attributes to
            return TRUE;
        }
    }

    // ok to muck with this file
    return FALSE;
}

// This is the encryption warning callback dlg proc

BOOL_PTR CALLBACK EncryptionWarningDlgProc(HWND hDlgWarning, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
        case WM_INITDIALOG:
        {
            LPCTSTR pszPath = (LPCTSTR)lParam;

            SetWindowPtr(hDlgWarning, DWLP_USER, (void*) pszPath);

            // set the initial state of the radio buttons
            CheckDlgButton(hDlgWarning, IDC_ENCRYPT_PARENTFOLDER, TRUE);
            break;
        }

        case WM_COMMAND:
        {
            if ((LOWORD(wParam) == IDOK) && (IsDlgButtonChecked(hDlgWarning, IDC_ENCRYPT_PARENTFOLDER) == BST_CHECKED))
            {
                LPTSTR pszPath = (LPTSTR) GetWindowPtr(hDlgWarning, DWLP_USER);

                if (pszPath)
                {
                    LPITEMIDLIST pidl = ILCreateFromPath(pszPath);

                    if (pidl)
                    {
                        SHChangeNotifySuspendResume(TRUE, pidl, TRUE, 0);
                    }

RetryEncryptParentFolder:
                    if (!SHEncryptFile(pszPath, TRUE))
                    {
                        ATTRIBUTEERROR ae = {pszPath, GetLastError()};

                        if (FailedApplyAttribsErrorDlg(hDlgWarning, &ae) == IDRETRY)
                        {
                            goto RetryEncryptParentFolder;
                        }
                    }

                    if (pidl)
                    {
                        SHChangeNotifySuspendResume(FALSE, pidl, TRUE, 0);
                        ILFree(pidl);
                    }
                }
            }
            break;
        }
    }

    // we want the MessageBoxCheckExDlgProc have a crack at everything as well,
    // so return false here
    return FALSE;
}

//
// This function warns the user that they are encrypting a file that is not in and encrypted
// folder. Most editors (MS word included), do a "safe-save" where they rename the file being
// edited, and then save the new modified version out, and then delete the old original. This
// causes an encrypted document that is NOT in an encrypted folder to become decrypted so we
// warn the user here.
//
// returns:
//          TRUE  - the user hit "ok" (either compress just the file, or the parent folder as well)
//          FALSE - the user hit "cancel"
//
int WarnUserAboutDecryptedParentFolder(LPCTSTR pszPath, HWND hWndParent)
{
    // check for the root case (no parent), or the directory case
    if (PathIsRoot(pszPath) || PathIsDirectory(pszPath))
        return TRUE;

    int iRet = IDOK; // assume everything is okidokey

    // first check to see if the parent folder is encrypted
    TCHAR szParentFolder[MAX_PATH];
    lstrcpyn(szParentFolder, pszPath, ARRAYSIZE(szParentFolder));
    PathRemoveFileSpec(szParentFolder);

    DWORD dwAttribs = GetFileAttributes(szParentFolder);
    if ((dwAttribs != (DWORD)-1) && !(dwAttribs & FILE_ATTRIBUTE_ENCRYPTED) && !PathIsRoot(szParentFolder))
    {
        // the parent folder is NOT encrypted and the parent folder isin't the root, so warn the user
        iRet = SHMessageBoxCheckEx(hWndParent, HINST_THISDLL, MAKEINTRESOURCE(DLG_ENCRYPTWARNING), EncryptionWarningDlgProc,
                                  (void *)szParentFolder, IDOK, TEXT("EncryptionWarning"));
    }

    return (iRet == IDOK);
}

//
// Sets attributes of a file based on the info in pfpsp
//
//  szFilename  -  the name of the file to compress
//
//  pfpsp       -  the filepropsheetpage info
//
//  hwndParent  -  Parent hwnd in case we need to put up some ui
//
//  pbSomethingChanged - pointer to a bool that says whether or not something actually was
//                       changed during the operation.
//                       TRUE  - we applied at leaset one attribute
//                       FALSE - we didnt change anything (either an error or all the attribs already matched)
//
//  return value: TRUE  - the operation was sucessful
//                FALSE - there was an error and the user hit cancel to abort the operation
//
//
// NOTE:    the caller of this function must take care of generating the SHChangeNotifies so that
//          we dont end up blindly sending them for every file in a dir (the caller will send
//          one for just that dir). That is why we have the pbSomethingChanged variable.
//
STDAPI_(BOOL) ApplyFileAttributes(LPCTSTR pszPath, FILEPROPSHEETPAGE* pfpsp, HWND hwndParent, BOOL* pbSomethingChanged)
{
    DWORD dwLastError = ERROR_SUCCESS;
    BOOL bCallSetFileAttributes = FALSE;
    LPITEMIDLIST pidl = NULL;
 
    // assume nothing changed to start with
    *pbSomethingChanged = 0;
    
    if ((pfpsp->fRecursive || pfpsp->pfci->fMultipleFiles) && IsBadAttributeFile(pszPath, pfpsp))
    {
        // we are doing a recursive operation or a multiple file operation, so we skip files
        // that we dont want to to mess with because they will ususally give error dialogs
        if (pfpsp->pProgressDlg)
        {
            // since we are skipping this file, we subtract its size from both
            // ulTotal and ulCompleted. This will make sure the progress bar isint
            // messed up by files like pagefile.sys who are huge but get "compressed"
            // in milliseconds.
            ULARGE_INTEGER ulTemp;

            ulTemp.LowPart = pfpsp->fd.nFileSizeLow;
            ulTemp.HighPart = pfpsp->fd.nFileSizeHigh;

            // guard against underflow
            if (pfpsp->ulNumberOfBytesDone.QuadPart < ulTemp.QuadPart)
            {
                pfpsp->ulNumberOfBytesDone.QuadPart = 0;
            }
            else
            {
                pfpsp->ulNumberOfBytesDone.QuadPart -= ulTemp.QuadPart;
            }

            pfpsp->pfci->ulTotalNumberOfBytes.QuadPart -= ulTemp.QuadPart;

            UpdateProgressBar(pfpsp);
        }

        // return telling the user everying is okidokey
        return TRUE;
    }

RetryApplyAttribs:
    DWORD dwInitialAttributes = GetFileAttributes(pszPath);

    if (dwInitialAttributes == -1)
    {
        // we were unable to get the file attribues, doh!
        dwLastError = GetLastError();
        goto RaiseErrorMsg;
    }

    if (pfpsp->pProgressDlg)
    {
        // update the progress dialog file name
        SetProgressDlgPath(pfpsp, pszPath, TRUE);
    }

    //
    // we only allow attribs that SetFileAttributes can handle
    //
    DWORD dwNewAttributes = (dwInitialAttributes & (FILE_ATTRIBUTE_READONLY               | 
                                                    FILE_ATTRIBUTE_HIDDEN                 | 
                                                    FILE_ATTRIBUTE_ARCHIVE                |
                                                    FILE_ATTRIBUTE_OFFLINE                |
                                                    FILE_ATTRIBUTE_SYSTEM                 |
                                                    FILE_ATTRIBUTE_TEMPORARY              |
                                                    FILE_ATTRIBUTE_NOT_CONTENT_INDEXED));

    BOOL bIsSuperHidden = IS_SYSTEM_HIDDEN(dwInitialAttributes);

    if (pfpsp->asInitial.fReadOnly != pfpsp->asCurrent.fReadOnly)
    {
        // don't allow changing of folders read only bit, since this is a trigger
        // for shell special folder stuff like thumbnails, etc.
        if (!(dwInitialAttributes & FILE_ATTRIBUTE_DIRECTORY))
        {
            if (pfpsp->asCurrent.fReadOnly)
            {
                dwNewAttributes |= FILE_ATTRIBUTE_READONLY;
            }
            else
            {
                dwNewAttributes &= ~FILE_ATTRIBUTE_READONLY;
            }

            bCallSetFileAttributes = TRUE;
        }
    }

    //
    // don't allow setting of hidden on system files, as this will make them disappear for good.
    //
    if (pfpsp->asInitial.fHidden != pfpsp->asCurrent.fHidden && !(dwNewAttributes & FILE_ATTRIBUTE_SYSTEM))
    {
        if (pfpsp->asCurrent.fHidden)
        {
            dwNewAttributes |= FILE_ATTRIBUTE_HIDDEN;
        }
        else
        {
            dwNewAttributes &= ~FILE_ATTRIBUTE_HIDDEN;
        }
            
        bCallSetFileAttributes = TRUE;
    }

    if (pfpsp->asInitial.fArchive != pfpsp->asCurrent.fArchive)
    {
        if (pfpsp->asCurrent.fArchive)
        {
            dwNewAttributes |= FILE_ATTRIBUTE_ARCHIVE;
        }
        else
        {
            dwNewAttributes &= ~FILE_ATTRIBUTE_ARCHIVE;
        }
        
        bCallSetFileAttributes = TRUE;
    }

    if (pfpsp->asInitial.fIndex != pfpsp->asCurrent.fIndex)
    {
        if (pfpsp->asCurrent.fIndex)
        {
            dwNewAttributes &= ~FILE_ATTRIBUTE_NOT_CONTENT_INDEXED;
        }
        else
        {
            dwNewAttributes |= FILE_ATTRIBUTE_NOT_CONTENT_INDEXED;
        }
        
        bCallSetFileAttributes = TRUE;
    }

    // did something change that we need to call SetFileAttributes for?
    if (bCallSetFileAttributes)
    {
        if (SetFileAttributes(pszPath, dwNewAttributes))
        {
            // success! set fSomethingChanged so we know to send out
            // a changenotify
            *pbSomethingChanged = TRUE;
        }
        else
        {
            // get the last error value now so we know why it failed
            dwLastError = GetLastError();
            goto RaiseErrorMsg;
        }
    }

    // We need to be careful about the order we compress/encrypt in since these
    // operations are mutually exclusive.
    // We therefore do the uncompressing/decrypting first
    if ((pfpsp->asInitial.fCompress != pfpsp->asCurrent.fCompress) &&
        (pfpsp->asCurrent.fCompress == BST_UNCHECKED))
    {
        if (!CompressFile(pszPath, FALSE))
        {
            // get the last error value now so we know why it failed
            dwLastError = GetLastError();
            goto RaiseErrorMsg;
        }
        else
        {
            // success
            *pbSomethingChanged = TRUE;
        }
    }

    if ((pfpsp->asInitial.fEncrypt != pfpsp->asCurrent.fEncrypt) &&
        (pfpsp->asCurrent.fEncrypt == BST_UNCHECKED))
    {
        BOOL fSucceeded = SHEncryptFile(pszPath, FALSE); // try to decrypt the file

        if (!fSucceeded)
        {
            // get the last error value now so we know why it failed
            dwLastError = GetLastError();

            if (ERROR_SHARING_VIOLATION == dwLastError)
            {
                // Encrypt/Decrypt needs exclusive access to the file, this is a problem if we
                // initiate encrypt for a folder from Explorer, then most probably the folder will
                // be opened.  We don't do "SHChangeNotifySuspendResume" right away for perf reasons,
                // we wait for it to fail and then we try again. (stephstm)

                ASSERT(pidl == NULL);
                pidl = ILCreateFromPath(pszPath);

                if (pidl)
                {
                    SHChangeNotifySuspendResume(TRUE, pidl, TRUE, 0);
                }

                // retry to decrypt after the suspend
                fSucceeded = SHEncryptFile(pszPath, FALSE);

                if (!fSucceeded)
                {
                    // get the last error value now so we know why it failed
                    dwLastError = GetLastError();
                }
            }
        }

        if (fSucceeded)
        {
            // success
            *pbSomethingChanged = TRUE;
            dwLastError = ERROR_SUCCESS;
        }
        else
        {
            ASSERT(dwLastError != ERROR_SUCCESS);
            goto RaiseErrorMsg;
        }
    }

    // now check for encrypt/compress
    if ((pfpsp->asInitial.fCompress != pfpsp->asCurrent.fCompress) &&
        (pfpsp->asCurrent.fCompress == BST_CHECKED))
    {
        if (!CompressFile(pszPath, TRUE))
        {
            // get the last error value now so we know why it failed
            dwLastError = GetLastError();
            goto RaiseErrorMsg;
        }
        else
        {
            // success
            *pbSomethingChanged = TRUE;
        }
    }

    if ((pfpsp->asInitial.fEncrypt != pfpsp->asCurrent.fEncrypt) &&
        (pfpsp->asCurrent.fEncrypt == BST_CHECKED))
    {
        // only prompt for encrypting the parent folder on non-recursive operations
        if (!pfpsp->fRecursive && !WarnUserAboutDecryptedParentFolder(pszPath, hwndParent))
        {
            // user cancled the operation
            return FALSE;
        }

        BOOL fSucceeded = SHEncryptFile(pszPath, TRUE); // try to encrypt the file

        if (!fSucceeded)
        {
            // get the last error value now so we know why it failed
            dwLastError = GetLastError();

            if (ERROR_SHARING_VIOLATION == dwLastError)
            {
                // Encrypt/Decrypt needs exclusive access to the file, this is a problem if we
                // initiate encrypt for a folder from Explorer, then most probably the folder will
                // be opened.  We don't do "SHChangeNotifySuspendResume" right away for perf reasons,
                // we wait for it to fail and then we try again. (stephstm)

                ASSERT(pidl == NULL);
                pidl = ILCreateFromPath(pszPath);

                if (pidl)
                {
                    SHChangeNotifySuspendResume(TRUE, pidl, TRUE, 0);
                }

                // retry to encrypt after the suspend
                fSucceeded = SHEncryptFile(pszPath, TRUE);

                if (!fSucceeded)
                {
                    // get the last error value now so we know why it failed
                    dwLastError = GetLastError();
                }
            }
        }

        if (fSucceeded)
        {
            // success
            *pbSomethingChanged = TRUE;
            dwLastError = ERROR_SUCCESS;
        }
        else
        {
            ASSERT(dwLastError != ERROR_SUCCESS);
            goto RaiseErrorMsg;
        }
    }

RaiseErrorMsg:

    if (pidl)
    {
        SHChangeNotifySuspendResume(FALSE, pidl, TRUE, 0);
        ILFree(pidl);
        pidl = NULL;
    }

    // if we are ignoring all errors or we dont have an hwnd to use as a parent,
    // then dont show any error msgs.
    if (pfpsp->fIgnoreAllErrors || !hwndParent)
    {
        dwLastError = ERROR_SUCCESS;
    }

    // If kernel threw up an error dialog (such as "the disk is write proctected")
    // and the user hit "abort" then return false to avoid a second error dialog
    if (dwLastError == ERROR_REQUEST_ABORTED)
    {
        return FALSE;
    }

    // put up the error dlg if necessary, but not for super hidden files
    if (dwLastError != ERROR_SUCCESS)
    {
        // !PathIsRoot is required, since the root path (eg c:\) is superhidden by default even after formatting a drive,
        // why the filesystem thinks that the root should be +s +r after a format is a mystery to me...
        if (bIsSuperHidden && !ShowSuperHidden() && !PathIsRoot(pszPath))
        {
            dwLastError = ERROR_SUCCESS;
        }
        else
        {
            ATTRIBUTEERROR ae;

            ae.pszPath = pszPath;
            ae.dwLastError = dwLastError;

            int iRet = FailedApplyAttribsErrorDlg(hwndParent, &ae);

            switch (iRet)
            {
                case IDRETRY:
                    // we clear out dwError and try again
                    dwLastError = ERROR_SUCCESS;
                    goto RetryApplyAttribs;
                    break;

                case IDIGNOREALL:
                    pfpsp->fIgnoreAllErrors = TRUE;
                    dwLastError = ERROR_SUCCESS;
                    break;

                case IDIGNORE:
                    dwLastError = ERROR_SUCCESS;
                    break;

                case IDCANCEL:
                default:
                    break;
            }
        }
    }

    // update the progress bar
    if (pfpsp->pProgressDlg)
    {
        ULARGE_INTEGER ulTemp;

        // it is the callers responsibility to make sure that pfpsp->fd is filled with
        // the proper information for the file we are applying attributes to.
        ulTemp.LowPart = pfpsp->fd.nFileSizeLow;
        ulTemp.HighPart = pfpsp->fd.nFileSizeHigh;

        pfpsp->ulNumberOfBytesDone.QuadPart += ulTemp.QuadPart;

        UpdateProgressBar(pfpsp);
    }

    return (dwLastError == ERROR_SUCCESS) ? TRUE : FALSE;
}

//
//  Set the text of a dialog item and attach a tooltip if necessary.
//
STDAPI_(void) SetDlgItemTextWithToolTip(HWND hDlg, UINT id, LPCTSTR pszText, HWND *phwnd)
{
    HWND hwnd = GetDlgItem(hDlg, id);
    if (hwnd)
    {
        SetWindowText(hwnd, pszText);
        RECT rc;
        HDC hDC;
        if (GetClientRect(hwnd, &rc) && (hDC = GetDC(hDlg)) != NULL)
        {
            HFONT hFont = GetWindowFont(hwnd);
            if (hFont)
            {
                // set the dlg font into the DC so we can calc the size
                hFont = (HFONT)SelectObject(hDC, hFont);

                SIZE size = {0};
                GetTextExtentPoint32(hDC, pszText, lstrlen(pszText), &size);
                // restore the prev. hFont
                SelectObject(hDC, hFont);

                if (size.cx > rc.right)
                {
                    // our text size is bigger than the dlg width, so its clipped
                    if (*phwnd == NULL)
                    {
                        *phwnd = CreateWindow(TOOLTIPS_CLASS,
                                              c_szNULL,
                                              WS_POPUP | TTS_NOPREFIX,
                                              CW_USEDEFAULT,
                                              CW_USEDEFAULT,
                                              CW_USEDEFAULT,
                                              CW_USEDEFAULT,
                                              hDlg,
                                              NULL,
                                              HINST_THISDLL,
                                              NULL);
                    }

                    if (*phwnd)
                    {
                        TOOLINFO ti;

                        ti.cbSize = sizeof(ti);
                        ti.uFlags = TTF_IDISHWND | TTF_SUBCLASS;
                        ti.hwnd = hDlg;
                        ti.uId = (UINT_PTR)hwnd;
                        ti.lpszText = (LPTSTR)pszText;  // const -> non const
                        ti.hinst = HINST_THISDLL;
                        SendMessage(*phwnd, TTM_ADDTOOL, 0, (LPARAM)(LPTOOLINFO)&ti);
                    }
                }
            }
            ReleaseDC(hDlg, hDC);
        }
    }
}


void UpdateTriStateCheckboxes(FILEPROPSHEETPAGE* pfpsp)
{
    // we turn off tristate after applying attibs for those things that were tri-state
    // initially but are not anymore since we sucessfully applied the attributes

    if (pfpsp->hDlg)
    {
        if (pfpsp->asInitial.fReadOnly == BST_INDETERMINATE && pfpsp->asCurrent.fReadOnly != BST_INDETERMINATE)
        {
            SendDlgItemMessage(pfpsp->hDlg, IDD_READONLY, BM_SETSTYLE, BS_AUTOCHECKBOX, 0);
        }

        if (pfpsp->asInitial.fHidden == BST_INDETERMINATE && pfpsp->asCurrent.fHidden != BST_INDETERMINATE)
        {
            SendDlgItemMessage(pfpsp->hDlg, IDD_HIDDEN, BM_SETSTYLE, BS_AUTOCHECKBOX, 0);
        }

        // Archive is only on the general tab for files on FAT/FAT32 volumes
        if (!pfpsp->pfci->fIsCompressionAvailable && pfpsp->asInitial.fArchive == BST_INDETERMINATE && pfpsp->asCurrent.fArchive != BST_INDETERMINATE)
        {
            SendDlgItemMessage(pfpsp->hDlg, IDD_ARCHIVE, BM_SETSTYLE, BS_AUTOCHECKBOX, 0);
        }
    }
}

//
// This applies the attributes to the selected files (multiple file case)
//
// return value:
//      TRUE    We sucessfully applied all the attributes
//      FALSE   The user hit cancel, and we stoped
//
STDAPI_(BOOL) ApplyMultipleFileAttributes(FILEPROPSHEETPAGE* pfpsp)
{
    BOOL bRet = FALSE;

    // create the progress dialog.  This may fail if out of memory.  If it does fail, we will
    // abort the operation because it will also probably fail if out of memory.
    if (CreateAttributeProgressDlg(pfpsp))
    {
        BOOL bSomethingChanged = FALSE;

        bRet = TRUE;

        // make sure that HIDA_FillFindDatat returns the compressed size, else our progress est will be way off
        TCHAR szPath[MAX_PATH];
        for (int iItem = 0; HIDA_FillFindData(pfpsp->pfci->hida, iItem, szPath, &pfpsp->fd, TRUE); iItem++)
        {
            if (HasUserCanceledAttributeProgressDlg(pfpsp))
            {
                // the user hit cancel on the progress dlg, so stop
                bRet = FALSE;
                break;
            }

            if (pfpsp->fRecursive && (pfpsp->fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
            {
                // apply attribs to the subfolders
                bRet = ApplyRecursiveFolderAttribs(szPath, pfpsp);

                // send out a notification for the whole dir, regardless if the user hit cancel since
                // something could have changed
                SHChangeNotify(SHCNE_UPDATEDIR, SHCNF_PATH, szPath, NULL);
            }
            else
            {
                HWND hwndParent = NULL;

                // if we have a progress hwnd, try to use it as our parent. This will fail
                // if the progress dialog isn't being displayed yet.
                IUnknown_GetWindow((IUnknown*)pfpsp->pProgressDlg, &hwndParent);

                if (!hwndParent)
                {
                    // the progress dlg isint here yet, so use the property page hwnd
                    hwndParent = GetParent(pfpsp->hDlg);
                }

                // apply the attribs to this item only
                bRet = ApplyFileAttributes(szPath, pfpsp, hwndParent, &bSomethingChanged);

                if (bSomethingChanged)
                {
                    // something changed, so send out a notification for that file
                    DeleteFileThumbnail(szPath);
                    SHChangeNotify(SHCNE_UPDATEITEM, SHCNF_PATH, szPath, NULL);
                }
            }
        }

        // destroy the progress dialog
        DestroyAttributeProgressDlg(pfpsp);

        if (bRet)
        {
            // since we just sucessfully applied attribs, reset any tri-state checkboxes as necessary
            UpdateTriStateCheckboxes(pfpsp);

            // the user did NOT hit cancel, so update the prop sheet to reflect the new attribs
            pfpsp->asInitial = pfpsp->asCurrent;
        }

        // flush any change-notifications we generated
        SHChangeNotifyHandleEvents();
    }

    return bRet;
}


STDAPI_(BOOL) ApplySingleFileAttributes(FILEPROPSHEETPAGE* pfpsp)
{
    BOOL bRet = TRUE;
    BOOL bSomethingChanged = FALSE;

    if (!pfpsp->fRecursive)
    {
        bRet = ApplyFileAttributes(pfpsp->szPath, pfpsp, GetParent(pfpsp->hDlg), &bSomethingChanged);

        if (bSomethingChanged)
        {
            // something changed, so generate a notification for the item
            DeleteFileThumbnail(pfpsp->szPath);
            SHChangeNotify(SHCNE_UPDATEITEM, SHCNF_PATH, pfpsp->szPath, NULL);
        }
    }
    else
    {
        // We only should be doing a recursive operation if we have a directory!
        ASSERT(pfpsp->fIsDirectory);

        // create the progress dialog.  This may fail if out of memory.  If it does fail, we will
        // abort the operation because it will also probably fail if out of memory.
        if (CreateAttributeProgressDlg(pfpsp))
        {
            // apply attribs to this folder & sub files/folders
            bRet = ApplyRecursiveFolderAttribs(pfpsp->szPath, pfpsp);

            // HACKHACK: send out a notification for the item so that defview will refresh properly
            SHChangeNotify(SHCNE_UPDATEITEM, SHCNF_PATH, pfpsp->szPath, NULL);

            // send out a notification for the whole dir, regardless of the return value since
            // something could have changed even if the user hit cancel
            SHChangeNotify(SHCNE_UPDATEDIR, SHCNF_PATH, pfpsp->szPath, NULL);

            DestroyAttributeProgressDlg(pfpsp);
        }
        else
        {
            bRet = FALSE;
        }
    }

    if (bRet)
    {
        // since we just sucessfully applied attribs, reset any tri-state checkboxes as necessary
        UpdateTriStateCheckboxes(pfpsp);

        // the user did NOT hit cancel, so update the prop sheet to reflect the new attribs
        pfpsp->asInitial = pfpsp->asCurrent;

        // (reinerf) need to update the size fields (eg file was just compressed)
    }

    // handle any events we may have generated
    SHChangeNotifyHandleEvents();

    return bRet;
}

//
// this function sets the string that tells the user what attributes they are about to
// apply
//
BOOL SetAttributePromptText(HWND hDlgRecurse, FILEPROPSHEETPAGE* pfpsp)
{
    TCHAR szAttribsToApply[MAX_PATH];
    TCHAR szTemp[MAX_PATH];

    szAttribsToApply[0] = 0;

    if (pfpsp->asInitial.fReadOnly != pfpsp->asCurrent.fReadOnly)
    {
        if (pfpsp->asCurrent.fReadOnly)
            EVAL(LoadString(HINST_THISDLL, IDS_READONLY, szTemp, ARRAYSIZE(szTemp)));
        else
            EVAL(LoadString(HINST_THISDLL, IDS_NOTREADONLY, szTemp, ARRAYSIZE(szTemp)));

        StrCatBuff(szAttribsToApply, szTemp, ARRAYSIZE(szAttribsToApply));
    }

    if (pfpsp->asInitial.fHidden != pfpsp->asCurrent.fHidden)
    {
        if (pfpsp->asCurrent.fHidden)
            EVAL(LoadString(HINST_THISDLL, IDS_HIDE, szTemp, ARRAYSIZE(szTemp)));
        else
            EVAL(LoadString(HINST_THISDLL, IDS_UNHIDE, szTemp, ARRAYSIZE(szTemp)));

        StrCatBuff(szAttribsToApply, szTemp, ARRAYSIZE(szAttribsToApply));
    }

    if (pfpsp->asInitial.fArchive != pfpsp->asCurrent.fArchive)
    {
        if (pfpsp->asCurrent.fArchive)
            EVAL(LoadString(HINST_THISDLL, IDS_ARCHIVE, szTemp, ARRAYSIZE(szTemp)));
        else
            EVAL(LoadString(HINST_THISDLL, IDS_UNARCHIVE, szTemp, ARRAYSIZE(szTemp)));

        StrCatBuff(szAttribsToApply, szTemp, ARRAYSIZE(szAttribsToApply));
    }

    if (pfpsp->asInitial.fIndex != pfpsp->asCurrent.fIndex)
    {
        if (pfpsp->asCurrent.fIndex)
            EVAL(LoadString(HINST_THISDLL, IDS_INDEX, szTemp, ARRAYSIZE(szTemp)));
        else
            EVAL(LoadString(HINST_THISDLL, IDS_DISABLEINDEX, szTemp, ARRAYSIZE(szTemp)));

        StrCatBuff(szAttribsToApply, szTemp, ARRAYSIZE(szAttribsToApply));
    }

    if (pfpsp->asInitial.fCompress != pfpsp->asCurrent.fCompress)
    {
        if (pfpsp->asCurrent.fCompress)
            EVAL(LoadString(HINST_THISDLL, IDS_COMPRESS, szTemp, ARRAYSIZE(szTemp)));
        else
            EVAL(LoadString(HINST_THISDLL, IDS_UNCOMPRESS, szTemp, ARRAYSIZE(szTemp)));

        StrCatBuff(szAttribsToApply, szTemp, ARRAYSIZE(szAttribsToApply));
    }

    if (pfpsp->asInitial.fEncrypt != pfpsp->asCurrent.fEncrypt)
    {
        if (pfpsp->asCurrent.fEncrypt)
            EVAL(LoadString(HINST_THISDLL, IDS_ENCRYPT, szTemp, ARRAYSIZE(szTemp)));
        else
            EVAL(LoadString(HINST_THISDLL, IDS_DECRYPT, szTemp, ARRAYSIZE(szTemp)));

        StrCatBuff(szAttribsToApply, szTemp, ARRAYSIZE(szAttribsToApply));
    }

    if (!*szAttribsToApply)
    {
        // nothing changed bail
        return FALSE;
    }

    // remove the trailing ", "
    int iLength = lstrlen(szAttribsToApply);
    ASSERT(iLength >= 3);
    lstrcpy(&szAttribsToApply[iLength - 2], TEXT("\0"));

    SetDlgItemText(hDlgRecurse, IDD_ATTRIBSTOAPPLY, szAttribsToApply);
    return TRUE;
}


//
// This dlg proc is for the prompt to ask the user if they want to have their changes apply
// to only the directories, or all files/folders within the directories.
//
BOOL_PTR CALLBACK RecursivePromptDlgProc(HWND hDlgRecurse, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
    FILEPROPSHEETPAGE* pfpsp = (FILEPROPSHEETPAGE *)GetWindowLongPtr(hDlgRecurse, DWLP_USER);

    switch (uMessage)
    {
        case WM_INITDIALOG:
        {
            SetWindowLongPtr(hDlgRecurse, DWLP_USER, lParam);
            pfpsp = (FILEPROPSHEETPAGE *)lParam;

            // set the initial state of the radio button
            CheckDlgButton(hDlgRecurse, IDD_RECURSIVE, TRUE);

            // set the IDD_ATTRIBSTOAPPLY based on what attribs we are applying
            if (!SetAttributePromptText(hDlgRecurse, pfpsp))
            {
                // we should not get here because we check for the no attribs
                // to apply earlier
                ASSERT(FALSE);

                EndDialog(hDlgRecurse, TRUE);
            }

            // load either "this folder" or "the selected items"
            TCHAR szFolderText[MAX_PATH];
            LoadString(HINST_THISDLL, pfpsp->pfci->fMultipleFiles ? IDS_THESELECTEDITEMS : IDS_THISFOLDER, szFolderText, ARRAYSIZE(szFolderText));

            // set the IDD_RECURSIVE_TXT text to have "this folder" or "the selected items"
            TCHAR szFormatString[MAX_PATH];
            GetDlgItemText(hDlgRecurse, IDD_RECURSIVE_TXT, szFormatString, ARRAYSIZE(szFormatString));
            TCHAR szDlgText[MAX_PATH];
            wsprintf(szDlgText, szFormatString, szFolderText);
            SetDlgItemText(hDlgRecurse, IDD_RECURSIVE_TXT, szDlgText);

            // set the IDD_NOTRECURSIVE raido button text to have "this folder" or "the selected items"
            GetDlgItemText(hDlgRecurse, IDD_NOTRECURSIVE, szFormatString, ARRAYSIZE(szFormatString));
            wsprintf(szDlgText, szFormatString, szFolderText);
            SetDlgItemText(hDlgRecurse, IDD_NOTRECURSIVE, szDlgText);

            // set the IDD_RECURSIVE raido button text to have "this folder" or "the selected items"
            GetDlgItemText(hDlgRecurse, IDD_RECURSIVE, szFormatString, ARRAYSIZE(szFormatString));
            wsprintf(szDlgText, szFormatString, szFolderText);
            SetDlgItemText(hDlgRecurse, IDD_RECURSIVE, szDlgText);

            return TRUE;
        }

        case WM_COMMAND:
        {
            UINT uCtrlID = GET_WM_COMMAND_ID(wParam, lParam);
            switch (uCtrlID)
            {
                case IDOK:
                    pfpsp->fRecursive = (IsDlgButtonChecked(hDlgRecurse, IDD_RECURSIVE) == BST_CHECKED);
                    // fall through

                case IDCANCEL:
                    EndDialog(hDlgRecurse, (uCtrlID == IDCANCEL) ? FALSE : TRUE);
                    break;
            }
        }

        default:
            return FALSE;
    }
}


//
// This wndproc handles the "Advanced Attributes..." button on the general tab for
//
// return - FALSE:  the user hit cancle
//          TRUE:   the user hit ok
//
BOOL_PTR CALLBACK AdvancedFileAttribsDlgProc(HWND hDlgAttribs, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
    FILEPROPSHEETPAGE* pfpsp = (FILEPROPSHEETPAGE *)GetWindowLongPtr(hDlgAttribs, DWLP_USER);

    switch (uMessage)
    {
        case WM_INITDIALOG:
        {
            SetWindowLongPtr(hDlgAttribs, DWLP_USER, lParam);
            pfpsp = (FILEPROPSHEETPAGE *)lParam;

            // set the initial state of the checkboxes

            if (pfpsp->asInitial.fArchive == BST_INDETERMINATE)
            {
                SendDlgItemMessage(hDlgAttribs, IDD_ARCHIVE, BM_SETSTYLE, BS_AUTO3STATE, 0);
            }
            CheckDlgButton(hDlgAttribs, IDD_ARCHIVE, pfpsp->asCurrent.fArchive);

            if (pfpsp->asInitial.fIndex == BST_INDETERMINATE)
            {
                SendDlgItemMessage(hDlgAttribs, IDD_INDEX, BM_SETSTYLE, BS_AUTO3STATE, 0);
            }
            CheckDlgButton(hDlgAttribs, IDD_INDEX, pfpsp->asCurrent.fIndex);

            if (pfpsp->asInitial.fCompress == BST_INDETERMINATE)
            {
                SendDlgItemMessage(hDlgAttribs, IDD_COMPRESS, BM_SETSTYLE, BS_AUTO3STATE, 0);
            }
            CheckDlgButton(hDlgAttribs, IDD_COMPRESS, pfpsp->asCurrent.fCompress);

            if (pfpsp->asInitial.fEncrypt == BST_INDETERMINATE)
            {
                SendDlgItemMessage(hDlgAttribs, IDD_ENCRYPT, BM_SETSTYLE, BS_AUTO3STATE, 0);
            }
            CheckDlgButton(hDlgAttribs, IDD_ENCRYPT, pfpsp->asCurrent.fEncrypt);

            // assert that compression and encryption are mutually exclusive
            ASSERT(!((pfpsp->asCurrent.fCompress == BST_CHECKED) && (pfpsp->asCurrent.fEncrypt == BST_CHECKED)));

            // gray any checkboxs that are not supported by this filesystem
            EnableWindow(GetDlgItem(hDlgAttribs, IDD_INDEX), pfpsp->fIsIndexAvailable);
            EnableWindow(GetDlgItem(hDlgAttribs, IDD_COMPRESS), pfpsp->pfci->fIsCompressionAvailable);
            EnableWindow(GetDlgItem(hDlgAttribs, IDD_ENCRYPT), pfpsp->fIsEncryptionAvailable);

            if (pfpsp->fIsEncryptionAvailable   &&
                pfpsp->asInitial.fEncrypt       &&
                !pfpsp->fIsDirectory            &&
                !pfpsp->pfci->fMultipleFiles)
            {
                // we only support the Advanced button for the single folder case
                EnableWindow(GetDlgItem(hDlgAttribs, IDC_ADVANCED), TRUE);
            }
            else
            {
                EnableWindow(GetDlgItem(hDlgAttribs, IDC_ADVANCED), FALSE);
            }

            // load either "this folder" or "the selected items"
            TCHAR szFolderText[MAX_PATH];
            LoadString(HINST_THISDLL, pfpsp->pfci->fMultipleFiles ? IDS_THESELECTEDITEMS : IDS_THISFOLDER, szFolderText, ARRAYSIZE(szFolderText));

            // set the IDC_MANAGEFILES_TXT text to have "this folder" or "the selected items"
            TCHAR szFormatString[MAX_PATH];
            GetDlgItemText(hDlgAttribs, IDC_MANAGEFILES_TXT, szFormatString, ARRAYSIZE(szFormatString));
            TCHAR szDlgText[MAX_PATH];
            wsprintf(szDlgText, szFormatString, szFolderText);
            SetDlgItemText(hDlgAttribs, IDC_MANAGEFILES_TXT, szDlgText);
            return TRUE;
        }

        case WM_HELP:
            WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle, NULL, HELP_WM_HELP, (ULONG_PTR)(LPTSTR)aAdvancedHelpIds);
            break;

        case WM_CONTEXTMENU:
            if ((int)SendMessage(hDlgAttribs, WM_NCHITTEST, 0, lParam) != HTCLIENT)
            {
                // not in our client area, so don't process it
                return FALSE;
            }
            WinHelp((HWND)wParam, NULL, HELP_CONTEXTMENU, (ULONG_PTR)(void *)aAdvancedHelpIds);
            break;

        case WM_COMMAND:
        {
            UINT uCtrlID = GET_WM_COMMAND_ID(wParam, lParam);

            switch (uCtrlID) 
            {
            case IDD_COMPRESS:
                // encrypt and compress are mutually exclusive
                if (IsDlgButtonChecked(hDlgAttribs, IDD_COMPRESS) == BST_CHECKED)
                {
                    // the user checked compress so uncheck the encrypt checkbox
                    CheckDlgButton(hDlgAttribs, IDD_ENCRYPT, BST_UNCHECKED);
                }
                break;

            case IDD_ENCRYPT:
                // encrypt and compress are mutually exclusive
                if (IsDlgButtonChecked(hDlgAttribs, IDD_ENCRYPT) == BST_CHECKED)
                {
                    // the user checked encrypt, so uncheck the compression checkbox
                    CheckDlgButton(hDlgAttribs, IDD_COMPRESS, BST_UNCHECKED);

                    if (!pfpsp->pfci->fMultipleFiles && pfpsp->asInitial.fEncrypt)
                    {
                        EnableWindow(GetDlgItem(hDlgAttribs, IDC_ADVANCED), TRUE);
                    }
                }
                else
                {
                    EnableWindow(GetDlgItem(hDlgAttribs, IDC_ADVANCED), FALSE);
                }
                break;

            case IDC_ADVANCED:
                ASSERT(pfpsp->fIsEncryptionAvailable && pfpsp->asInitial.fEncrypt && !pfpsp->pfci->fMultipleFiles);
                // bring up the EfsDetail dialog
                EfsDetail(hDlgAttribs, pfpsp->szPath);
                break;

            case IDOK:
                pfpsp->asCurrent.fArchive = IsDlgButtonChecked(hDlgAttribs, IDD_ARCHIVE);
                if (pfpsp->asCurrent.fArchive == BST_INDETERMINATE)
                {
                    // if its indeterminate, it better had been indeterminate to start with
                    ASSERT(pfpsp->asInitial.fArchive == BST_INDETERMINATE);
                }

                pfpsp->asCurrent.fIndex = IsDlgButtonChecked(hDlgAttribs, IDD_INDEX);
                if (pfpsp->asCurrent.fIndex == BST_INDETERMINATE)
                {
                    // if its indeterminate, it better had been indeterminate to start with
                    ASSERT(pfpsp->asInitial.fIndex == BST_INDETERMINATE);
                }

                pfpsp->asCurrent.fCompress = IsDlgButtonChecked(hDlgAttribs, IDD_COMPRESS);
                if (pfpsp->asCurrent.fCompress == BST_INDETERMINATE)
                {
                    // if its indeterminate, it better had been indeterminate to start with
                    ASSERT(pfpsp->asInitial.fCompress == BST_INDETERMINATE);
                }

                pfpsp->asCurrent.fEncrypt = IsDlgButtonChecked(hDlgAttribs, IDD_ENCRYPT);
                if (pfpsp->asCurrent.fEncrypt == BST_INDETERMINATE)
                {
                    // if its indeterminate, it better had been indeterminate to start with
                    ASSERT(pfpsp->asInitial.fEncrypt == BST_INDETERMINATE);
                }
                // fall through...

            case IDCANCEL:
                ReplaceDlgIcon(hDlgAttribs, IDD_ITEMICON, NULL);
            
                EndDialog(hDlgAttribs, (uCtrlID == IDCANCEL) ? FALSE : TRUE);
                break;
            }
        }

        default:
            return FALSE;
    }

    return TRUE;
}


//
// Descriptions:
//   This is the dialog procedure for multiple object property sheet.
//
BOOL_PTR CALLBACK MultiplePrshtDlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
    FILEPROPSHEETPAGE * pfpsp = (FILEPROPSHEETPAGE *)GetWindowLongPtr(hDlg, DWLP_USER);

    switch (uMessage)
    {
    case WM_INITDIALOG:
        SetWindowLongPtr(hDlg, DWLP_USER, lParam);
        pfpsp = (FILEPROPSHEETPAGE *)lParam;
        pfpsp->hDlg = hDlg;
        pfpsp->pfci->hDlg = hDlg;

        InitMultiplePrsht(pfpsp);
        break;

    case WM_HELP:
        WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle, NULL, HELP_WM_HELP, (ULONG_PTR)(void *)aMultiPropHelpIds);
        break;

    case WM_CONTEXTMENU:
        if ((int)SendMessage(hDlg, WM_NCHITTEST, 0, lParam) != HTCLIENT)
        {
            // not in our client area, so don't process it
            return FALSE;
        }
        WinHelp((HWND)wParam, NULL, HELP_CONTEXTMENU, (ULONG_PTR)(void *)aMultiPropHelpIds);
        break;

    case WM_TIMER:
        UpdateSizeCount(pfpsp);
        break;

    case WM_COMMAND:
        switch (GET_WM_COMMAND_ID(wParam, lParam))
        {
        case IDD_READONLY:
        case IDD_HIDDEN:
        case IDD_ARCHIVE:
            break;

        case IDC_ADVANCED:
            // the dialog box returns fase if the user hit cancel, and true if they hit ok,
            // so if they cancelled, return immediately and don't send the PSM_CHANGED message
            // because nothing actually changed
            if (!DialogBoxParam(HINST_THISDLL,
                                MAKEINTRESOURCE(pfpsp->fIsDirectory ? DLG_FOLDERATTRIBS : DLG_FILEATTRIBS),
                                hDlg,
                                AdvancedFileAttribsDlgProc,
                                (LPARAM)pfpsp))
            {
                // the user has cancled
                return TRUE;
            }
            break;

        default:
            return TRUE;
        }

        // check to see if we need to enable the Apply button
        if (GET_WM_COMMAND_CMD(wParam, lParam) == BN_CLICKED)
        {
            SendMessage(GetParent(hDlg), PSM_CHANGED, (WPARAM)hDlg, 0);
        }
        break;

    case WM_DESTROY:
        Free_DlgDependentFilePropSheetPage(pfpsp);
        break;

    case WM_NOTIFY:
        switch (((NMHDR *)lParam)->code)
        {
            case PSN_APPLY:
            {
                //
                // Get the final state of the checkboxes
                //

                pfpsp->asCurrent.fReadOnly = IsDlgButtonChecked(hDlg, IDD_READONLY);
                if (pfpsp->asCurrent.fReadOnly == BST_INDETERMINATE)
                {
                    // if its indeterminate, it better had been indeterminate to start with
                    ASSERT(pfpsp->asInitial.fReadOnly == BST_INDETERMINATE);
                }

                pfpsp->asCurrent.fHidden = IsDlgButtonChecked(hDlg, IDD_HIDDEN);
                if (pfpsp->asCurrent.fHidden == BST_INDETERMINATE)
                {
                    // if its indeterminate, it better had been indeterminate to start with
                    ASSERT(pfpsp->asInitial.fHidden == BST_INDETERMINATE);
                }

                if (!pfpsp->pfci->fIsCompressionAvailable)
                {
                    // at least one of the files is on FAT, so the Archive checkbox is on the general page
                    pfpsp->asCurrent.fArchive = IsDlgButtonChecked(hDlg, IDD_ARCHIVE);
                    if (pfpsp->asCurrent.fArchive == BST_INDETERMINATE)
                    {
                        // if its indeterminate, it better had been indeterminate to start with
                        ASSERT(pfpsp->asInitial.fArchive == BST_INDETERMINATE);
                    }
                }

                BOOL bRet = TRUE;

                // check to see if the user actually changed something, if they didnt, then
                // we dont have to apply anything
                if (memcmp(&pfpsp->asInitial, &pfpsp->asCurrent, sizeof(pfpsp->asInitial)) != 0)
                {
                    // NOTE: We dont check to see if all the dirs are empty, that would be too expensive.
                    // We only do that in the single file case.
                    if (pfpsp->fIsDirectory)
                    {
                        // check to see if the user wants to apply the attribs recursively or not
                        bRet = (int)DialogBoxParam(HINST_THISDLL,
                                              MAKEINTRESOURCE(DLG_ATTRIBS_RECURSIVE),
                                              hDlg,
                                              RecursivePromptDlgProc,
                                              (LPARAM)pfpsp);
                    }

                    if (bRet)
                        bRet = ApplyMultipleFileAttributes(pfpsp);

                    if (!bRet)
                    {
                        // the user hit cancel, so we return true to prevent the property sheet form closeing
                        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);
                        return TRUE;
                    }
                    else
                    {
                        // update the size / last accessed time
                        UpdateSizeField(pfpsp, NULL);
                    }
                }
                break;
            }
            // fall through

            default:
                return FALSE;
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

// in:
//      hdlg
//      id      text control id
//      pftUTC  UTC time time to be set
//
STDAPI_(void) SetDateTimeText(HWND hdlg, int id, const FILETIME *pftUTC)
{
    SetDateTimeTextEx(hdlg, id, pftUTC, FDTF_LONGDATE | FDTF_LONGTIME | FDTF_RELATIVE) ;
}

STDAPI_(void) SetDateTimeTextEx(HWND hdlg, int id, const FILETIME *pftUTC, DWORD dwFlags)
{
    if (!IsNullTime(pftUTC))
    {
        LCID locale = GetUserDefaultLCID();

        if ((PRIMARYLANGID(LANGIDFROMLCID(locale)) == LANG_ARABIC) ||
            (PRIMARYLANGID(LANGIDFROMLCID(locale)) == LANG_HEBREW))
        {
            HWND hWnd = GetDlgItem(hdlg, id);
            DWORD dwExStyle = GetWindowLong(hdlg, GWL_EXSTYLE);
            if ((BOOLIFY(dwExStyle & WS_EX_RTLREADING)) != (BOOLIFY(dwExStyle & RTL_MIRRORED_WINDOW)))
                dwFlags |= FDTF_RTLDATE;
            else
                dwFlags |= FDTF_LTRDATE;
        }

        TCHAR szBuf[64];
        SHFormatDateTime(pftUTC, &dwFlags, szBuf, SIZECHARS(szBuf));
        SetDlgItemText(hdlg, id, szBuf);
    }
}


//
// Descriptions:
//   Detects BiDi Calender
//
BOOL _IsBiDiCalendar(void)
{
    TCHAR chCalendar[32];
    BOOL fBiDiCalender = FALSE;

    //
    // Let's verify the calendar type whether it's gregorian or not.
    if (GetLocaleInfo(LOCALE_USER_DEFAULT,
                      LOCALE_ICALENDARTYPE,
                      (TCHAR *) &chCalendar[0],
                      ARRAYSIZE(chCalendar)))
    {
        CALTYPE defCalendar = StrToInt((TCHAR *)&chCalendar[0]);
        LCID locale = GetUserDefaultLCID();

        if ((defCalendar == CAL_HIJRI) ||
            (defCalendar == CAL_HEBREW) ||
            ((defCalendar == CAL_GREGORIAN) &&
            ((PRIMARYLANGID(LANGIDFROMLCID(locale)) == LANG_ARABIC) ||
            (PRIMARYLANGID(LANGIDFROMLCID(locale)) == LANG_HEBREW))) ||
            (defCalendar == CAL_GREGORIAN_ARABIC) ||
            (defCalendar == CAL_GREGORIAN_XLIT_ENGLISH) ||
            (defCalendar == CAL_GREGORIAN_XLIT_FRENCH))
        {
            fBiDiCalender = TRUE;
        }
    }

    return fBiDiCalender;
}

// Set the friendly display name into control uId.
BOOL SetPidlToWindow(HWND hwnd, UINT uId, LPITEMIDLIST pidl)
{
    BOOL fRes = FALSE;
    LPCITEMIDLIST pidlItem;
    IShellFolder* psf;
    if (SUCCEEDED(SHBindToParent(pidl, IID_PPV_ARG(IShellFolder, &psf), &pidlItem)))
    {
        TCHAR szPath[MAX_PATH];

        // SHGDN_FORADDRESSBAR | SHGDN_FORPARSING because we want:
        // c:\winnt\.... and http://weird, but not ::{GUID} or Folder.{GUID}
        if (SUCCEEDED(DisplayNameOf(psf, pidlItem, SHGDN_FORADDRESSBAR | SHGDN_FORPARSING, szPath, ARRAYSIZE(szPath))))
        {
            SetDlgItemText(hwnd, IDD_TARGET, szPath);
            fRes = TRUE;
        }
        psf->Release();
    }

    return fRes;
}

//
// Descriptions:
//   This function fills fields of the "general" dialog box (a page of
//  a property sheet) with attributes of the associated file.
//
BOOL InitSingleFilePrsht(FILEPROPSHEETPAGE * pfpsp)
{
    SHFILEINFO sfi;
    // get info about the file.
    SHGetFileInfo(pfpsp->szPath, pfpsp->fd.dwFileAttributes, &sfi, sizeof(sfi),
        SHGFI_ICON|SHGFI_LARGEICON|
        SHGFI_DISPLAYNAME|
        SHGFI_TYPENAME | SHGFI_ADDOVERLAYS);

    // .ani cursor hack!
    if (lstrcmpi(PathFindExtension(pfpsp->szPath), TEXT(".ani")) == 0)
    {
        HICON hIcon = (HICON)LoadImage(NULL, pfpsp->szPath, IMAGE_ICON, 0, 0, LR_LOADFROMFILE);
        if (hIcon)
        {
            if (sfi.hIcon)
                DestroyIcon(sfi.hIcon);

            sfi.hIcon = hIcon;
        }
    }

    // icon
    ReplaceDlgIcon(pfpsp->hDlg, IDD_ITEMICON, sfi.hIcon);

    // set the initial rename state
    pfpsp->fRename = FALSE;

    // set the file type
    if (pfpsp->fMountedDrive)
    {
        //Borrow szVolumeGUID
        TCHAR szVolumeGUID[MAX_PATH];
        LoadString(HINST_THISDLL, IDS_MOUNTEDVOLUME, szVolumeGUID, ARRAYSIZE(szVolumeGUID));

        SetDlgItemText(pfpsp->hDlg, IDD_FILETYPE, szVolumeGUID);

        //use szVolumeLabel temporarily
        TCHAR szVolumeLabel[MAX_PATH];
        lstrcpyn(szVolumeLabel, pfpsp->szPath, ARRAYSIZE(szVolumeLabel));
        PathAddBackslash(szVolumeLabel);
        GetVolumeNameForVolumeMountPoint(szVolumeLabel, szVolumeGUID, ARRAYSIZE(szVolumeGUID));

        if (!GetVolumeInformation(szVolumeGUID, szVolumeLabel, ARRAYSIZE(szVolumeLabel),
            NULL, NULL, NULL, pfpsp->szFileSys, ARRAYSIZE(pfpsp->szFileSys)))
        {
            EnableWindow(GetDlgItem(pfpsp->hDlg, IDC_DRV_PROPERTIES), FALSE);
            *szVolumeLabel = 0;
        }

        if (!(*szVolumeLabel))
            LoadString(HINST_THISDLL, IDS_UNLABELEDVOLUME, szVolumeLabel, ARRAYSIZE(szVolumeLabel));

        SetDlgItemText(pfpsp->hDlg, IDC_DRV_TARGET, szVolumeLabel);
    }
    else
    {
        SetDlgItemText(pfpsp->hDlg, IDD_FILETYPE, sfi.szTypeName);
    }


    // save off the initial short filename, and set the "Name" edit box
    lstrcpyn(pfpsp->szInitialName, sfi.szDisplayName, ARRAYSIZE(pfpsp->szInitialName));
    SetDlgItemText(pfpsp->hDlg, IDD_NAMEEDIT, sfi.szDisplayName);

    // use a strcmp to see if we are showing the extension
    if (lstrcmpi(sfi.szDisplayName, PathFindFileName(pfpsp->szPath)) == 0)
    {
        // since the strings are the same, we must be showing the extension
        pfpsp->fShowExtension = TRUE;
    }

    TCHAR szBuffer[MAX_PATH];
    lstrcpyn(szBuffer, pfpsp->szPath, ARRAYSIZE(szBuffer));
    PathRemoveFileSpec(szBuffer);

    UINT cchMax;
    GetCCHMaxFromPath(pfpsp->szPath, &cchMax, pfpsp->fShowExtension);
    Edit_LimitText(GetDlgItem(pfpsp->hDlg, IDD_NAMEEDIT), cchMax);

    // apply the limit input code for the item
    pfpsp->pidl = ILCreateFromPath(pfpsp->szPath);
    if (pfpsp->pidl)
    {
        IShellFolder *psf;
        if (SUCCEEDED(SHBindToObject(NULL, IID_X_PPV_ARG(IShellFolder, pfpsp->pidl, &psf))))
        {
            SHLimitInputEdit(GetDlgItem(pfpsp->hDlg, IDD_NAMEEDIT), psf);
            psf->Release();
        }
    }

    // Are we a folder shortcut?
    if (pfpsp->fFolderShortcut)
    {
        // Yes; Then we need to populate folder shortcut specific controls.
        if (pfpsp->pidl)
        {
            IShellLink *psl;
            if (SUCCEEDED(SHGetUIObjectFromFullPIDL(pfpsp->pidl, NULL, IID_PPV_ARG(IShellLink, &psl))))
            {
                // Populate the Target
                if (SUCCEEDED(psl->GetIDList(&pfpsp->pidlTarget)))
                {
                    if (SetPidlToWindow(pfpsp->hDlg, IDD_TARGET, pfpsp->pidlTarget))
                    {
                        pfpsp->fValidateEdit = FALSE;     // Set this to false because we already have a pidl
                        // and don't need to validate.
                    }
                }

                // And description
                TCHAR sz[INFOTIPSIZE];
                if (SUCCEEDED(psl->GetDescription(sz, ARRAYSIZE(sz))))
                {
                    SetDlgItemText(pfpsp->hDlg, IDD_COMMENT, sz);
                }

                psl->Release();
            }
        }

        SetDateTimeText(pfpsp->hDlg, IDD_CREATED, &pfpsp->fd.ftCreationTime);
    }
    else
    {
        // set the initial attributes
        SetInitialFileAttribs(pfpsp, pfpsp->fd.dwFileAttributes, pfpsp->fd.dwFileAttributes);
        
        // special case for folders, we don't apply the read only bit to folders
        // and to indicate that in the UI we make the inital state of the check
        // box tri-state. this allows the read only bit to be applied to files in
        // this folder, but not the folders themselves.
        if (pfpsp->fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
        {
            pfpsp->asInitial.fReadOnly = BST_INDETERMINATE;
            SendDlgItemMessage(pfpsp->hDlg, IDD_READONLY, BM_SETSTYLE, BS_AUTO3STATE, 0);
        }

        // set the current attributes to the same as the initial
        pfpsp->asCurrent = pfpsp->asInitial;

        CheckDlgButton(pfpsp->hDlg, IDD_READONLY, pfpsp->asInitial.fReadOnly);
        CheckDlgButton(pfpsp->hDlg, IDD_HIDDEN, pfpsp->asInitial.fHidden);

        // Disable renaming the file if requested
        if (pfpsp->fDisableRename)
        {
            EnableWindow(GetDlgItem(pfpsp->hDlg, IDD_NAMEEDIT), FALSE);
        }

        if (pfpsp->fd.dwFileAttributes & FILE_ATTRIBUTE_SYSTEM)
        {
            // to avoid people making SYSTEM files HIDDEN (superhidden files are
            // not show to the user by default) we don't let people make SYSTEM files HIDDEN
            EnableWindow(GetDlgItem(pfpsp->hDlg, IDD_HIDDEN), FALSE);
        }

        // Archive is only on the general tab for FAT, otherwise it is under the "Advanced attributes"
        // and FAT volumes dont have the "Advanced attributes" button.
        if (pfpsp->pfci->fIsCompressionAvailable || pfpsp->fIsEncryptionAvailable)
        {
            // if compression/encryption is available, then we must be on NTFS
            DestroyWindow(GetDlgItem(pfpsp->hDlg, IDD_ARCHIVE));
        }
        else
        {
            // we are on FAT/FAT32, so get rid of the "Advanced attributes" button, and set the inital Archive state
            DestroyWindow(GetDlgItem(pfpsp->hDlg, IDC_ADVANCED));
            CheckDlgButton(pfpsp->hDlg, IDD_ARCHIVE, pfpsp->asInitial.fArchive);
        }

        UpdateSizeField(pfpsp, &pfpsp->fd);

        if (!(pfpsp->fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY))
        {
            // Check to see if the target file is a lnk, because if it is a lnk then
            // we need to display the type information for the target, not the lnk itself.
            if (PathIsShortcut(pfpsp->szPath, pfpsp->fd.dwFileAttributes))
            {
                pfpsp->fIsLink = TRUE;
            }
            if (!(GetFileAttributes(pfpsp->szPath) & FILE_ATTRIBUTE_OFFLINE))
            {
                 UpdateOpensWithInfo(pfpsp);
            }
            else
            {
                 EnableWindow(GetDlgItem(pfpsp->hDlg, IDC_FT_PROP_CHANGEOPENSWITH), FALSE);
            }
        }

        // get the full path to the folder that contains this file.
        lstrcpyn(szBuffer, pfpsp->szPath, ARRAYSIZE(szBuffer));
        PathRemoveFileSpec(szBuffer);

        // Keep Functionality same as NT4 by avoiding PathCompactPath.
        SetDlgItemTextWithToolTip(pfpsp->hDlg, IDD_LOCATION, szBuffer, &pfpsp->hwndTip);
    }
    return TRUE;
}

STDAPI_(BOOL) ShowMountedVolumeProperties(LPCTSTR pszMountedVolume, HWND hwndParent)
{
    IMountedVolume* pMountedVolume;
    HRESULT hr = SHCoCreateInstance(NULL, &CLSID_MountedVolume, NULL, IID_PPV_ARG(IMountedVolume, &pMountedVolume));
    if (SUCCEEDED(hr))
    {
        TCHAR szPathSlash[MAX_PATH];
        lstrcpyn(szPathSlash, pszMountedVolume, ARRAYSIZE(szPathSlash));
        PathAddBackslash(szPathSlash);

        hr = pMountedVolume->Initialize(szPathSlash);
        if (SUCCEEDED(hr))
        {
            IDataObject* pDataObj;
            hr = pMountedVolume->QueryInterface(IID_PPV_ARG(IDataObject, &pDataObj));
            if (SUCCEEDED(hr))
            {
                PROPSTUFF *pps = (PROPSTUFF *)LocalAlloc(LPTR, sizeof(*pps));
                if (pps)
                {
                    pps->lpStartAddress = DrivesPropertiesThreadProc;
                    pps->pdtobj = pDataObj;

                    EnableWindow(hwndParent, FALSE);

                    DrivesPropertiesThreadProc(pps);

                    EnableWindow(hwndParent, TRUE);

                    LocalFree(pps);
                }

                pDataObj->Release();
            }
            pMountedVolume->Release();
        }
    }

    return SUCCEEDED(hr);
}

#ifdef FOLDERSHORTCUT_EDITABLETARGET
BOOL SetFolderShortcutInfo(HWND hDlg, FILEPROPSHEETPAGE* pfpsp)
{
    ASSERT(pfpsp->pidl);

    BOOL fSuccess = FALSE;

    IShellLink* psl;
    if (SUCCEEDED(SHGetUIObjectFromFullPIDL(pfpsp->pidl, NULL, IID_PPV_ARG(IShellLink, &psl))))
    {
        TCHAR sz[INFOTIPSIZE];
        Edit_GetText(GetDlgItem(pfpsp->hDlg, IDD_COMMENT), sz, ARRAYSIZE(sz));

        psl->SetDescription(sz);

        if (pfpsp->fValidateEdit)
        {
            IShellFolder* psf;
            if (SUCCEEDED(SHGetDesktopFolder(&psf)))
            {
                TCHAR szPath[MAX_PATH];
                Edit_GetText(GetDlgItem(pfpsp->hDlg, IDD_TARGET), sz, ARRAYSIZE(sz));

                if (PathCanonicalize(szPath, sz))
                {
                    LPITEMIDLIST pidlDest;
                    DWORD dwAttrib = SFGAO_FOLDER | SFGAO_VALIDATE;
                    ULONG chEat = 0;
                    if (SUCCEEDED(psf->ParseDisplayName(NULL, NULL, szPath, &chEat, &pidlDest, &dwAttrib)))
                    {
                        if ((dwAttrib & SFGAO_FOLDER) == SFGAO_FOLDER)
                        {
                            ILFree(pfpsp->pidlTarget);
                            pfpsp->pidlTarget = pidlDest;
                            fSuccess = TRUE;
                        }
                        else
                        {
                            ILFree(pidlDest);
                        }
                    }
                }
                psf->Release();
            }
        }
        else
        {
            fSuccess = TRUE;
        }

        if (fSuccess)
        {
            psl->SetIDList(pfpsp->pidlTarget);

            IPersistFile* ppf;
            if (SUCCEEDED(psl->QueryInterface(IID_PPV_ARG(IPersistFile, &ppf))))
            {
                fSuccess = (S_OK == ppf->Save(pfpsp->szPath, TRUE));
                SHChangeNotify(SHCNE_UPDATEITEM, SHCNF_PATH, pfpsp->szPath, NULL);
                ppf->Release();
            }
        }

        psl->Release();
    }

    return fSuccess;
}
#endif

//
// Descriptions:
//   This is the dialog procedure for the "general" page of a property sheet.
//
BOOL_PTR CALLBACK SingleFilePrshtDlgProc(HWND hDlg, UINT uMessage, WPARAM wParam, LPARAM lParam)
{
    FILEPROPSHEETPAGE* pfpsp = (FILEPROPSHEETPAGE *)GetWindowLongPtr(hDlg, DWLP_USER);

    switch (uMessage)
    {
    case WM_INITDIALOG:
        // REVIEW, we should store more state info here, for example
        // the hIcon being displayed and the FILEINFO pointer, not just
        // the file name ptr
        SetWindowLongPtr(hDlg, DWLP_USER, lParam);
        pfpsp = (FILEPROPSHEETPAGE *)lParam;
        pfpsp->hDlg = hDlg;
        pfpsp->pfci->hDlg = hDlg;

        InitSingleFilePrsht(pfpsp);

        // We set this to signal that we are done processing the WM_INITDIALOG.
        // This is needed because we set the text of the "Name" edit box and unless
        // he knows that this is being set for the first time, he thinks that someone is doing a rename.
        pfpsp->fWMInitFinshed = TRUE;
        break;

    case WM_TIMER:
        if (!pfpsp->fMountedDrive)
            UpdateSizeCount(pfpsp);
        break;

    case WM_HELP:
        WinHelp((HWND)((LPHELPINFO)lParam)->hItemHandle, NULL, HELP_WM_HELP, (ULONG_PTR)(void *)(pfpsp->fIsDirectory ? aFolderGeneralHelpIds : aFileGeneralHelpIds));
        break;

    case WM_CONTEXTMENU:
        if ((int)SendMessage(hDlg, WM_NCHITTEST, 0, lParam) != HTCLIENT)
        {
            // not in our client area, so don't process it
            return FALSE;
        }
        WinHelp((HWND)wParam, NULL, HELP_CONTEXTMENU, (ULONG_PTR)(void *)(pfpsp->fIsDirectory ? aFolderGeneralHelpIds : aFileGeneralHelpIds));
        break;


    case WM_COMMAND:
        switch (GET_WM_COMMAND_ID(wParam, lParam))
        {
        case IDD_READONLY:
        case IDD_HIDDEN:
        case IDD_ARCHIVE:
            break;

#ifdef FOLDERSHORTCUT_EDITABLETARGET
        case IDD_TARGET:
            if (GET_WM_COMMAND_CMD(wParam, lParam) == EN_CHANGE)
            {
                // someone typed in the target, enable apply button
                SendMessage(GetParent(hDlg), PSM_CHANGED, (WPARAM)hDlg, 0);

                // Do a verification on apply.
                pfpsp->fValidateEdit = TRUE;
            }
            break;

        case IDD_COMMENT:
            if (GET_WM_COMMAND_CMD(wParam, lParam) == EN_CHANGE)
            {
                // Set the apply.
                SendMessage(GetParent(hDlg), PSM_CHANGED, (WPARAM)hDlg, 0);
            }
            break;
#endif
        case IDD_NAMEEDIT:
            // we need to check the pfpsp->fWMInitFinshed to make sure that we are done processing the WM_INITDIALOG,
            // because during init we set the initial IDD_NAMEEDIT text which generates a EN_CHANGE message.
            if ((GET_WM_COMMAND_CMD(wParam, lParam) == EN_CHANGE) && !pfpsp->fRename && pfpsp->fWMInitFinshed)
            {
                pfpsp->fRename = TRUE;
                //
                // disable "Apply" even though the edit field has changed (reinerf)
                //
                // We only allow "ok" or "cancel" after the name has changed to be sure we
                // don't rename the file out from under other property sheet extensions that
                // cache the original name away
                PropSheet_DisableApply(GetParent(pfpsp->hDlg));
            }
            break;

        case IDC_CHANGEFILETYPE:
            {
                // Bring up the "Open With" dialog
                OPENASINFO oai;

                if (pfpsp->fIsLink && pfpsp->szLinkTarget[0])
                {
                    // if we have a link we want to re-associate the link target, NOT .lnk files!
                    oai.pcszFile = pfpsp->szLinkTarget;
                }
                else
                {
#ifdef DEBUG
                    LPTSTR pszExt = PathFindExtension(pfpsp->szPath);

                    // reality check...
                    ASSERT((lstrcmpi(pszExt, TEXT(".exe")) != 0) &&
                           (lstrcmpi(pszExt, TEXT(".lnk")) != 0));
#endif // DEBUG
                    oai.pcszFile = pfpsp->szPath;
                }

                oai.pcszClass = NULL;
                oai.dwInFlags = (OAIF_REGISTER_EXT | OAIF_FORCE_REGISTRATION); // we want the association to be made

                if (SUCCEEDED(OpenAsDialog(GetParent(hDlg), &oai)))
                {
                    // we changed the association so update the "Opens with:" text. Clear out szLinkTarget to force
                    // the update to happen
                    pfpsp->szLinkTarget[0] = 0;
                    UpdateOpensWithInfo(pfpsp);
                }
            }
            break;

        case IDC_ADVANCED:
            // the dialog box returns fase if the user hit cancel, and true if they hit ok,
            // so if they cancelled, return immediately and don't send the PSM_CHANGED message
            // because nothing actually changed
            if (!DialogBoxParam(HINST_THISDLL,
                                MAKEINTRESOURCE(pfpsp->fIsDirectory ? DLG_FOLDERATTRIBS : DLG_FILEATTRIBS),
                                hDlg,
                                AdvancedFileAttribsDlgProc,
                                (LPARAM)pfpsp))
            {
                // the user has canceled
                return TRUE;
            }
            break;

        case IDC_DRV_PROPERTIES:
            ASSERT(pfpsp->fMountedDrive);
            ShowMountedVolumeProperties(pfpsp->szPath, hDlg);
            break;

#ifdef FOLDERSHORTCUT_EDITABLETARGET
        case IDD_BROWSE:
            {
                // Display the BrowseForFolder dialog.

                // FEATURE(lamadio): Implement a filter to filter things we can create folder
                // shortcuts to. Not enough time for this rev 6.5.99

                TCHAR szTitle[MAX_PATH];
                LoadString(HINST_THISDLL, IDS_BROWSEFORFS, szTitle, ARRAYSIZE(szTitle));
                TCHAR szAltPath[MAX_PATH];

                BROWSEINFO bi = {0};
                bi.hwndOwner    = hDlg;
                bi.pidlRoot     = NULL;
                bi.pszDisplayName = szAltPath;
                bi.lpszTitle    = szTitle;
                bi.ulFlags      =  BIF_USENEWUI | BIF_EDITBOX;
                LPITEMIDLIST pidlFull = SHBrowseForFolder(&bi);
                if (pidlFull)
                {
                    ILFree(pfpsp->pidlTarget);
                    pfpsp->pidlTarget = pidlFull;

                    if (SetPidlToWindow(hDlg, IDD_TARGET, pfpsp->pidlTarget))
                    {
                        SendMessage(GetParent(hDlg), PSM_CHANGED, (WPARAM)hDlg, 0);
                        pfpsp->fValidateEdit = FALSE;
                    }
                }
            }
            break;
#endif

        default:
            return TRUE;
        }

        // check to see if we need to enable the Apply button
        if (GET_WM_COMMAND_CMD(wParam, lParam) == BN_CLICKED)
        {
            SendMessage(GetParent(hDlg), PSM_CHANGED, (WPARAM)hDlg, 0);
        }
        break;

    case WM_DESTROY:
        Free_DlgDependentFilePropSheetPage(pfpsp);
        break;

    case WM_NOTIFY:
        switch (((NMHDR *)lParam)->code)
        {
            case PSN_APPLY:
                // check to see if we could apply the name change.  Note that this
                // does not actually apply the change until PSN_LASTCHANCEAPPLY
                pfpsp->fCanRename = TRUE;
                if (pfpsp->fRename && !ApplyRename(pfpsp, FALSE))
                {
                    // can't change the name so don't let the dialog close
                    pfpsp->fCanRename = FALSE;
                    SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);
                    return TRUE;
                }

                if (pfpsp->fFolderShortcut)
                {
#ifdef FOLDERSHORTCUT_EDITABLETARGET
                    if (!SetFolderShortcutInfo(hDlg, pfpsp))
                    {
                        // Display that we could not create because blah, blah, blah
                        ShellMessageBox(HINST_THISDLL,
                                        hDlg,
                                        MAKEINTRESOURCE(IDS_FOLDERSHORTCUT_ERR),
                                        MAKEINTRESOURCE(IDS_FOLDERSHORTCUT_ERR_TITLE),
                                        MB_OK | MB_ICONSTOP);

                        // Reset the Folder info.
                        SetPidlToWindow(hDlg, IDD_TARGET, pfpsp->pidlTarget);

                        // Don't close the dialog.
                        SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);
                        return TRUE;
                    }
#endif
                }
                else
                {
                    UINT uReadonlyState = IsDlgButtonChecked(hDlg, IDD_READONLY);
                    switch (uReadonlyState)
                    {
                    case BST_CHECKED:
                        pfpsp->asCurrent.fReadOnly = TRUE;
                        break;

                    case BST_UNCHECKED:
                        pfpsp->asCurrent.fReadOnly = FALSE;
                        break;

                    case BST_INDETERMINATE:
                        // read-only checkbox is initaially set to BST_INDETERMINATE for folders
                        ASSERT(pfpsp->fIsDirectory);
                        ASSERT(pfpsp->asInitial.fReadOnly == BST_INDETERMINATE);
                        pfpsp->asCurrent.fReadOnly = BST_INDETERMINATE;
                        break;
                    }

                    pfpsp->asCurrent.fHidden = (IsDlgButtonChecked(hDlg, IDD_HIDDEN) == BST_CHECKED);

                    // Archive is on the general page for FAT volumes
                    if (!pfpsp->pfci->fIsCompressionAvailable)
                    {
                        pfpsp->asCurrent.fArchive = (IsDlgButtonChecked(hDlg, IDD_ARCHIVE) == BST_CHECKED);
                    }

                    // check to see if the user actually changed something, if they didnt, then
                    // we dont have to apply anything
                    if (memcmp(&pfpsp->asInitial, &pfpsp->asCurrent, sizeof(pfpsp->asInitial)) != 0)
                    {
                        BOOL bRet = TRUE;

                        // Check to see if the user wants to apply the attribs recursively or not. If the
                        // directory is empty, dont bother to ask, since there is nothing to recurse into
                        if (pfpsp->fIsDirectory && !PathIsDirectoryEmpty(pfpsp->szPath))
                        {
                            bRet = (int)DialogBoxParam(HINST_THISDLL,
                                                       MAKEINTRESOURCE(DLG_ATTRIBS_RECURSIVE),
                                                       hDlg,
                                                       RecursivePromptDlgProc,
                                                       (LPARAM)pfpsp);
                        }

                        if (bRet)
                        {
                            bRet = ApplySingleFileAttributes(pfpsp);
                        }

                        if (!bRet)
                        {
                            // the user hit cancel, so we return true to prevent the property sheet from closing
                            SetWindowLongPtr(hDlg, DWLP_MSGRESULT, PSNRET_INVALID_NOCHANGEPAGE);
                            return TRUE;
                        }
                        else
                        {
                            // update the size / last accessed time
                            UpdateSizeField(pfpsp, NULL);
                        }
                    }
                }
                break;

            case PSN_SETACTIVE:
                if (pfpsp->fIsLink)
                {
                    // If this is a link, each time we get set active we need to check to see
                    // if the user applied changes on the link tab that would affect the
                    // "Opens With:" info.
                    UpdateOpensWithInfo(pfpsp);
                }
                break;

            case PSN_QUERYINITIALFOCUS:
                // Special hack:  We do not want initial focus on the "Rename" or "Change" controls, since
                // if the user hit something by accident they would start renaming/modifying the assoc. So
                // we set the focus to the "Read-only" control since it is present on all dialogs that use
                // this wndproc (file, folder, and mounted drive)
                SetWindowLongPtr(hDlg, DWLP_MSGRESULT, (LPARAM)GetDlgItem(hDlg, IDD_READONLY));
                return TRUE;

            case PSN_LASTCHANCEAPPLY:
                //
                // HACKHACK (reinerf)
                //
                // I hacked PSN_LASTCHANCEAPPLY into the prsht code so we can get a notification after
                // every other app has applied, then we can go and do the rename.
                //
                // strangely, PSN_LASTCHANCEAPPLY is called even if PSN_APPY returns TRUE.
                //
                // we can now safely rename the file, since all the other tabs have
                // applied their stuff.
                if (pfpsp->fRename && pfpsp->fCanRename)
                {
                    // dont bother to check the return value since this is the last-chance,
                    // so the dialog is ending shortly after this
                    ApplyRename(pfpsp, TRUE);
                }
                break;

            default:
                return FALSE;
        }
        break;

    default:
        return FALSE;
    }

    return TRUE;
}



//
// This function consists of code  that does some
// Initialization for the file property sheet dialog.

STDAPI InitCommonPrsht(FILEPROPSHEETPAGE * pfpsp)
{
    pfpsp->psp.dwSize      = sizeof(FILEPROPSHEETPAGE);        // extra data
    pfpsp->psp.dwFlags     = PSP_USECALLBACK;
    pfpsp->psp.hInstance   = HINST_THISDLL;
    pfpsp->psp.pfnCallback = NULL; //FilePrshtCallback;
    pfpsp->pfci->bContinue   = TRUE;

    // Do basic init for file system props
    if (HIDA_GetCount(pfpsp->pfci->hida) == 1)       // single file?
    {
        // get most of the data we will need (the date/time stuff is not filled in)
        if (HIDA_FillFindData(pfpsp->pfci->hida, 0, pfpsp->szPath, &(pfpsp->pfci->fd), FALSE))
        {
            pfpsp->fd = pfpsp->pfci->fd;
            LPITEMIDLIST pidl = HIDA_ILClone(pfpsp->pfci->hida, 0);
            if (pidl)
            {
                //  disable renaming here.
                DWORD dwAttrs = SFGAO_CANRENAME;
                if (SUCCEEDED(SHGetNameAndFlags(pidl, 0, NULL, 0, &dwAttrs)) && !(dwAttrs & SFGAO_CANRENAME))
                {
                    pfpsp->fDisableRename = TRUE;
                }
                ILFree(pidl);
            }

            if (pfpsp->pfci->fd.dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
            {
                pfpsp->fIsDirectory = TRUE;
                // check for HostFolder folder mounting a volume)
                //GetVolumeNameFromMountPoint Succeeds then the give path is a mount point


                //Make sure the path ends with a backslash. otherwise the following api wont work
                TCHAR szPathSlash[MAX_PATH];
                lstrcpyn(szPathSlash, pfpsp->szPath, ARRAYSIZE(szPathSlash));
                PathAddBackslash(szPathSlash);

                // Is this a mounted volume at this folder?
                // this fct will return FALSE if not on NT5 and higher
                TCHAR szVolumeName[MAX_PATH];
                if (GetVolumeNameForVolumeMountPoint(szPathSlash, szVolumeName, ARRAYSIZE(szVolumeName)))
                {
                    // Yes; show the Mounted Drive Propertysheet instead of normal
                    // folder property sheet
                    // fpsp.fMountedDrive also means NT5 or higher, because this fct will fail otherwise
                    pfpsp->fMountedDrive = TRUE;
                }

                // check to see if it's a folder shortcut
                if (!(pfpsp->fMountedDrive))
                {
                    // Folder and a shortcut? Must be a folder shortcut!
                    if (PathIsShortcut(pfpsp->szPath, pfpsp->pfci->fd.dwFileAttributes))
                    {
                        pfpsp->fFolderShortcut = TRUE;
                    }
                }
            }

            {
                DWORD dwVolumeFlags = GetVolumeFlags(pfpsp->szPath,
                                                     pfpsp->szFileSys,
                                                     ARRAYSIZE(pfpsp->szFileSys));

                // test for file-based compression.
                if (dwVolumeFlags & FS_FILE_COMPRESSION)
                {
                    // filesystem supports compression
                    pfpsp->pfci->fIsCompressionAvailable = TRUE;
                }

                // test for file-based encryption.
                if ((dwVolumeFlags & FS_FILE_ENCRYPTION) && !SHRestricted(REST_NOENCRYPTION))
                {
                    // filesystem supports encryption
                    pfpsp->fIsEncryptionAvailable = TRUE;
                }

                //
                // HACKHACK (reinerf) - we dont have a FS_SUPPORTS_INDEXING so we
                // use the FILE_SUPPORTS_SPARSE_FILES flag, because native index support
                // appeared first on NTFS5 volumes, at the same time sparse file support
                // was implemented.
                //
                if (dwVolumeFlags & FILE_SUPPORTS_SPARSE_FILES)
                {
                    // yup, we are on NTFS5 or greater
                    pfpsp->fIsIndexAvailable = TRUE;
                }

                // check to see if we have a .exe and we need to prompt for user logon
                pfpsp->fIsExe = PathIsBinaryExe(pfpsp->szPath);
            }
        }
    }
    else
    {
        // we have multiple files
        pfpsp->pfci->fMultipleFiles = TRUE;
    }

    return S_OK;
}


//
// Descriptions:
//   This function creates a property sheet object for the "general" page
//  which shows file system attributes.
//
// Arguments:
//  hDrop           -- specifies the file(s)
//  pfnAddPage      -- Specifies the callback function.
//  lParam          -- Specifies the lParam to be passed to the callback.
//
// Returns:
//  TRUE if it added any pages
//
// History:
//  12-31-92 SatoNa Created
//
STDAPI FileSystem_AddPages(IDataObject *pdtobj, LPFNADDPROPSHEETPAGE pfnAddPage, LPARAM lParam)
{
    FILEPROPSHEETPAGE fpsp = {0};
    HRESULT hr = S_OK;

    fpsp.pfci = Create_FolderContentsInfo();
    if (fpsp.pfci)
    {
        hr = DataObj_CopyHIDA(pdtobj, &fpsp.pfci->hida);
        if (SUCCEEDED(hr))
        {
            hr = InitCommonPrsht(&fpsp);
            if (SUCCEEDED(hr))
            {
                fpsp.psp.pfnCallback = FilePrshtCallback;

                UINT uRes;
                if (!fpsp.pfci->fMultipleFiles)
                {
                    fpsp.psp.pfnDlgProc = SingleFilePrshtDlgProc;
                    if (fpsp.fIsDirectory)
                    {
                        if (fpsp.fMountedDrive)
                        {
                            uRes = DLG_MOUNTEDDRV_GENERAL;
                        }
                        else if (fpsp.fFolderShortcut)
                        {
                            uRes = DLG_FOLDERSHORTCUTPROP;
                        }
                        else
                        {
                            uRes = DLG_FOLDERPROP;
                        }
                    }
                    else
                    {
                        //Files
                        uRes = DLG_FILEPROP;
                    }
                }
                else
                {
                    // Multiple Files / Folders.
                    fpsp.psp.pfnDlgProc  = MultiplePrshtDlgProc;
                    uRes = DLG_FILEMULTPROP;
                }
                fpsp.psp.pszTemplate = MAKEINTRESOURCE(uRes);
            }
        }

        if (SUCCEEDED(hr))
        {
            HPROPSHEETPAGE hpage = CreatePropertySheetPage(&fpsp.psp);
            if (hpage)
            {
                if (pfnAddPage(hpage, lParam))
                {
                    hr = S_OK;
                    if (!fpsp.pfci->fMultipleFiles)
                    {
                        if (AddLinkPage(fpsp.szPath, pfnAddPage, lParam))
                        {
                            // set second page default!
                            hr = ResultFromShort(2);
                        }
                        AddVersionPage(fpsp.szPath, pfnAddPage, lParam);
                    }
                }
                else
                {
                    DestroyPropertySheetPage(hpage);
                }
            }
        }
    }
    else
    {
        hr = E_OUTOFMEMORY;
    }

    if (FAILED(hr))
    {
        Free_DlgIndepFilePropSheetPage(&fpsp);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\mydocsfldr.cpp ===
#include "shellprv.h"
#pragma  hdrstop

#include <shguidp.h>    // CLSID_MyDocuments, CLSID_ShellFSFolder
#include <shellp.h>     // SHCoCreateInstance
#include <shlguidp.h>   // IID_IResolveShellLink
#include "util.h"
#include "ids.h"

enum CALLING_APP_TYPE 
{
    APP_IS_UNKNOWN = 0,
    APP_IS_NORMAL,
    APP_IS_OFFICE
};

class CMyDocsFolderLinkResolver : public IResolveShellLink
{
private:
    LONG _cRef;
public:
    CMyDocsFolderLinkResolver() : _cRef(1) { DllAddRef(); };
    ~CMyDocsFolderLinkResolver() { DllRelease(); };

    // IUnknown
    STDMETHOD(QueryInterface)(REFIID riid, void **ppv);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

    // IResolveShellLink
    STDMETHOD(ResolveShellLink)(IUnknown* punk, HWND hwnd, DWORD fFlags);
};

STDMETHODIMP CMyDocsFolderLinkResolver::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENT(CMyDocsFolderLinkResolver, IResolveShellLink),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_ (ULONG) CMyDocsFolderLinkResolver::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_ (ULONG) CMyDocsFolderLinkResolver::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}

STDMETHODIMP CMyDocsFolderLinkResolver::ResolveShellLink(IUnknown* punk, HWND hwnd, DWORD fFlags)
{
    // No action needed to resolve a link to the mydocs folder:
    return S_OK;
}


// shell folder implementation for icon on the desktop. the purpouse of this object is
//      1) to give access to MyDocs high up in the name space 
//         this makes it easier for end users to get to MyDocs
//      2) allow for end user custimization of the real MyDocs folder
//         through the provided property page on this icon

// NOTE: this object agregates the file system folder so we get away with a minimal set of interfaces
// on this object. the real file system folder does stuff like IPersistFolder2 for us

class CMyDocsFolder : public IPersistFolder,
                      public IShellFolder2,
                      public IShellIconOverlay
{
public:
    CMyDocsFolder();
    HRESULT Init();

    // IUnknown
    STDMETHOD(QueryInterface)(REFIID riid, void **ppv);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

    // IShellFolder
    STDMETHOD(ParseDisplayName)(HWND hwnd, LPBC pbc, LPOLESTR pDisplayName,
                                ULONG *pchEaten, LPITEMIDLIST *ppidl, ULONG *pdwAttributes);
    STDMETHOD(EnumObjects)(HWND hwnd, DWORD grfFlags, IEnumIDList **ppEnumIDList);
    STDMETHOD(BindToObject)(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv);
    STDMETHOD(BindToStorage)(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv);
    STDMETHOD(CompareIDs)(LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);
    STDMETHOD(CreateViewObject)(HWND hwnd, REFIID riid, void **ppv);
    STDMETHOD(GetAttributesOf)(UINT cidl, LPCITEMIDLIST * apidl, ULONG * rgfInOut);
    STDMETHOD(GetUIObjectOf)(HWND hwnd, UINT cidl, LPCITEMIDLIST * apidl, REFIID riid, UINT * prgfInOut, void **ppv);
    STDMETHOD(GetDisplayNameOf)(LPCITEMIDLIST pidl, DWORD uFlags, STRRET *pName);
    STDMETHOD(SetNameOf)(HWND hwnd, LPCITEMIDLIST pidl, LPCOLESTR pszName, DWORD uFlags, LPITEMIDLIST* ppidlOut);

    // IShellFolder2
    STDMETHODIMP GetDefaultSearchGUID(LPGUID lpGuid);
    STDMETHODIMP EnumSearches(LPENUMEXTRASEARCH *ppenum);
    STDMETHODIMP GetDefaultColumn(DWORD dwRes, ULONG *pSort, ULONG *pDisplay);
    STDMETHODIMP GetDefaultColumnState(UINT iColumn, DWORD *pbState);
    STDMETHODIMP GetDetailsEx(LPCITEMIDLIST pidl, const SHCOLUMNID *pscid, VARIANT *pv);
    STDMETHODIMP GetDetailsOf(LPCITEMIDLIST pidl, UINT iColumn, SHELLDETAILS *pDetails);
    STDMETHODIMP MapColumnToSCID(UINT iCol, SHCOLUMNID *pscid);

    // IPersist, IPersistFreeThreadedObject
    STDMETHOD(GetClassID)(CLSID *pClassID);

    // IPersistFolder
    STDMETHOD(Initialize)(LPCITEMIDLIST pidl);

    // IPersistFolder2, IPersistFolder3, etc are all implemented by 
    // the folder we agregate

    // IShellIconOverlay
    STDMETHODIMP GetOverlayIndex(LPCITEMIDLIST pidl, int *pIndex);
    STDMETHODIMP GetOverlayIconIndex(LPCITEMIDLIST pidl, int *pIconIndex);

private:
    ~CMyDocsFolder();


    HRESULT _GetFolder();
    HRESULT _GetFolder2();
    HRESULT _GetShellIconOverlay();

    void _FreeFolder();

    HRESULT _PathFromIDList(LPCITEMIDLIST pidl, LPTSTR pszPath);
    HRESULT _PathToIDList(LPCTSTR pszPath, LPITEMIDLIST *ppidl);

    HRESULT _GetFolderOverlayInfo(int *pIndex, BOOL fIconIndex);


    LONG                 _cRef;

    IUnknown *           _punk;         // points to IUnknown for shell folder in use...
    IShellFolder *       _psf;          // points to shell folder in use...
    IShellFolder2 *      _psf2;         // points to shell folder in use...
    IShellIconOverlay*   _psio;         // points to shell folder in use...
    LPITEMIDLIST         _pidl;         // copy of pidl passed to us in Initialize()
    CALLING_APP_TYPE     _host;

    HRESULT RealInitialize(LPCITEMIDLIST pidlRoot, LPCITEMIDLIST pidlBindTo, LPTSTR pRootPath);
    CALLING_APP_TYPE _WhoIsCalling();
};

STDAPI CMyDocsFolder_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv)
{
    HRESULT hr;
    CMyDocsFolder *pmydocs = new CMyDocsFolder();
    if (pmydocs)
    {
        hr = pmydocs->Init();
        if (SUCCEEDED(hr))
            hr = pmydocs->QueryInterface(riid, ppv);
        pmydocs->Release();
    }
    else
    {
        *ppv = NULL;
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

CMyDocsFolder::CMyDocsFolder() : _cRef(1), _host(APP_IS_UNKNOWN),
    _psf(NULL), _psf2(NULL), _psio(NULL), _punk(NULL), _pidl(NULL)
{
    DllAddRef();
}

CMyDocsFolder::~CMyDocsFolder()
{
    _cRef = 1000;  // deal with agregation re-enter

    _FreeFolder();

    ILFree(_pidl);

    DllRelease();
}

HRESULT CMyDocsFolder::Init()
{
    // agregate a file system folder object early so we can
    // delegate QI() to him that we don't implement
    HRESULT hr = SHCoCreateInstance(NULL, &CLSID_ShellFSFolder, SAFECAST(this, IShellFolder *), IID_PPV_ARG(IUnknown, &_punk));
    if (SUCCEEDED(hr))
    {
        IPersistFolder3 *ppf3;
        hr = SHQueryInnerInterface(SAFECAST(this, IShellFolder *), _punk, IID_PPV_ARG(IPersistFolder3, &ppf3));
        if (SUCCEEDED(hr))
        {
            PERSIST_FOLDER_TARGET_INFO pfti = {0};
    
            pfti.dwAttributes = FILE_ATTRIBUTE_DIRECTORY;
            pfti.csidl = CSIDL_PERSONAL | CSIDL_FLAG_PFTI_TRACKTARGET;

            hr = SHGetFolderLocation(NULL, CSIDL_PERSONAL, NULL, 0, &_pidl);
            if (SUCCEEDED(hr))
            {
                hr = ppf3->InitializeEx(NULL, _pidl, &pfti);
            }
            SHReleaseInnerInterface(SAFECAST(this, IShellFolder *), (IUnknown **)&ppf3);
        }
    }
    return hr;
}

STDMETHODIMP CMyDocsFolder::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENTMULTI(CMyDocsFolder, IShellFolder, IShellFolder2),
        QITABENT(CMyDocsFolder, IShellFolder2),
        QITABENTMULTI(CMyDocsFolder, IPersist, IPersistFolder),
        QITABENT(CMyDocsFolder, IPersistFolder),
        QITABENT(CMyDocsFolder, IShellIconOverlay),
        // QITABENTMULTI2(CMyDocsFolder, IID_IPersistFreeThreadedObject, IPersist),           // IID_IPersistFreeThreadedObject
        { 0 },
    };
    HRESULT hr = QISearch(this, qit, riid, ppv);
    if (FAILED(hr) && _punk)
        hr = _punk->QueryInterface(riid, ppv); // agregated guy
    return hr;
}

STDMETHODIMP_ (ULONG) CMyDocsFolder::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_ (ULONG) CMyDocsFolder::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}

// Determine who is calling us so that we can do app specific
// compatibility hacks when needed
CALLING_APP_TYPE CMyDocsFolder::_WhoIsCalling()
{
    // Check to see if we have the value already...
    if (_host == APP_IS_UNKNOWN)
    {
        if (SHGetAppCompatFlags (ACF_APPISOFFICE) & ACF_APPISOFFICE)
            _host = APP_IS_OFFICE;
        else 
            _host = APP_IS_NORMAL;
    }
    return _host;
}

// IPersist methods
STDMETHODIMP CMyDocsFolder::GetClassID(CLSID *pClassID)
{
    *pClassID = CLSID_MyDocuments;
    return S_OK;
}

HRESULT _BindToIDListParent(LPCITEMIDLIST pidl, LPBC pbc, IShellFolder **ppsf, LPITEMIDLIST *ppidlLast)
{
    HRESULT hr;
    LPITEMIDLIST pidlParent = ILCloneParent(pidl);
    if (pidlParent)
    {
        hr = SHBindToObjectEx(NULL, pidlParent, pbc, IID_PPV_ARG(IShellFolder, ppsf));
        ILFree(pidlParent);
    }
    else
        hr = E_OUTOFMEMORY;
    if (ppidlLast)
        *ppidlLast = ILFindLastID(pidl);
    return hr;
}

HRESULT _ConfirmMyDocsPath(HWND hwnd)
{
    TCHAR szPath[MAX_PATH];
    HRESULT hr = SHGetFolderPath(hwnd, CSIDL_PERSONAL | CSIDL_FLAG_CREATE, NULL, SHGFP_TYPE_CURRENT, szPath);
    if (S_OK != hr)
    {
        TCHAR szTitle[MAX_PATH];

        // above failed, get unverified path
        SHGetFolderPath(NULL, CSIDL_PERSONAL | CSIDL_FLAG_DONT_VERIFY, NULL, SHGFP_TYPE_CURRENT, szPath);

        LPCTSTR pszMsg = PathIsNetworkPath(szPath) ? MAKEINTRESOURCE(IDS_CANT_FIND_MYDOCS_NET) :
                                                     MAKEINTRESOURCE(IDS_CANT_FIND_MYDOCS);

        PathCompactPath(NULL, szPath, 400);

        GetMyDocumentsDisplayName(szTitle, ARRAYSIZE(szTitle));

        ShellMessageBox(g_hinst, hwnd, pszMsg, szTitle,
                        MB_OK | MB_ICONSTOP, szPath, szTitle);

        hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);   // user saw the message
    } 
    else if (hr == S_FALSE)
        hr = E_FAIL;
    return hr;
}

// like SHGetPathFromIDList() except this uses the bind context to make sure
// we don't get into loops since there can be cases where there are multiple 
// instances of this folder that can cause binding loops.

HRESULT CMyDocsFolder::_PathFromIDList(LPCITEMIDLIST pidl, LPTSTR pszPath)
{
    *pszPath = 0;

    LPBC pbc;
    HRESULT hr = CreateBindCtx(NULL, &pbc);
    if (SUCCEEDED(hr))
    {
        // this bind context skips extension taged with our CLSID
        hr = pbc->RegisterObjectParam(STR_SKIP_BINDING_CLSID, SAFECAST(this, IShellFolder *));
        if (SUCCEEDED(hr))
        {
            LPITEMIDLIST pidlLast;
            IShellFolder *psf;
            hr = _BindToIDListParent(pidl, pbc, &psf, &pidlLast);
            if (SUCCEEDED(hr))
            {
                hr = DisplayNameOf(psf, pidlLast, SHGDN_FORPARSING, pszPath, MAX_PATH);
                psf->Release();
            }
        }
        pbc->Release();
    }
    return hr;
}

HRESULT CMyDocsFolder::_PathToIDList(LPCTSTR pszPath, LPITEMIDLIST *ppidl)
{
    IShellFolder *psfDesktop;
    HRESULT hr = SHGetDesktopFolder(&psfDesktop);
    if (SUCCEEDED(hr))
    {
        LPBC pbc;
        hr = CreateBindCtx( 0, &pbc );
        if (SUCCEEDED(hr))
        {
            BIND_OPTS bo = {sizeof(bo), 0};
            bo.grfFlags = BIND_JUSTTESTEXISTENCE;   // skip all junctions

            hr = pbc->SetBindOptions( &bo );
            if (SUCCEEDED(hr))
            {
                WCHAR szPath[MAX_PATH];
                SHTCharToUnicode(pszPath, szPath, ARRAYSIZE(szPath));

                hr = psfDesktop->ParseDisplayName(NULL, pbc, szPath, NULL, ppidl, NULL);
            }
            pbc->Release();
        }
        psfDesktop->Release();
    }
    return hr;
}

void CMyDocsFolder::_FreeFolder()
{
    if (_punk)
    {
        SHReleaseInnerInterface(SAFECAST(this, IShellFolder *), (IUnknown **)&_psf);
        SHReleaseInnerInterface(SAFECAST(this, IShellFolder *), (IUnknown **)&_psf2);
        SHReleaseInnerInterface(SAFECAST(this, IShellFolder *), (IUnknown **)&_psio);
        _punk->Release();
        _punk = NULL;
    }
}

// verify that _psf (agregated file system folder) has been inited

HRESULT CMyDocsFolder::_GetFolder()
{
    HRESULT hr;

    if (_psf)
    {
        hr = S_OK;
    }
    else
    {
        hr = SHQueryInnerInterface(SAFECAST(this, IShellFolder *), _punk, IID_PPV_ARG(IShellFolder, &_psf));
    }
    return hr;
}

HRESULT CMyDocsFolder::_GetFolder2()
{
    HRESULT hr;
    if (_psf2)
        hr = S_OK;
    else
    {
        hr = _GetFolder();
        if (SUCCEEDED(hr))
            hr = SHQueryInnerInterface(SAFECAST(this, IShellFolder *), _punk, IID_PPV_ARG(IShellFolder2, &_psf2));
    }
    return hr;
}

HRESULT CMyDocsFolder::_GetShellIconOverlay()
{
    HRESULT hr;
    if (_psio)
    {
        hr = S_OK;
    }
    else
    {
        hr = _GetFolder();
        if (SUCCEEDED(hr))
        {
            hr = SHQueryInnerInterface(SAFECAST(this, IShellFolder *), _punk, IID_PPV_ARG(IShellIconOverlay, &_psio));
        }
    }
    return hr;
}

// returns:
//      S_OK    -- goodness
//      S_FALSE freed the pidl, set to empty
//      E_OUTOFMEMORY

HRESULT _SetIDList(LPITEMIDLIST* ppidl, LPCITEMIDLIST pidl)
{
    if (*ppidl) 
    {
        ILFree(*ppidl);
        *ppidl = NULL;
    }

    return pidl ? SHILClone(pidl, ppidl) : S_FALSE;
}

BOOL IsMyDocsIDList(LPCITEMIDLIST pidl)
{
    BOOL bIsMyDocs = FALSE;
    if (pidl && !ILIsEmpty(pidl) && ILIsEmpty(_ILNext(pidl)))
    {
        LPITEMIDLIST pidlMyDocs;
        if (SUCCEEDED(SHGetFolderLocation(NULL, CSIDL_PERSONAL, NULL, 0, &pidlMyDocs)))
        {
            bIsMyDocs = ILIsEqual(pidl, pidlMyDocs);
            ILFree(pidlMyDocs);
        }
    }
    return bIsMyDocs;
}


// Scans a desktop.ini file for sections to see if all of them are empty...

BOOL IsDesktopIniEmpty(LPCTSTR pIniFile)
{
    TCHAR szSections[1024];  // for section names
    if (GetPrivateProfileSectionNames(szSections, ARRAYSIZE(szSections), pIniFile))
    {
        for (LPTSTR pTmp = szSections; *pTmp; pTmp += lstrlen(pTmp) + 1)
        {
            TCHAR szSection[1024];   // for section key names and values
            GetPrivateProfileSection(pTmp, szSection, ARRAYSIZE(szSection), pIniFile);
            if (szSection[0])
            {
                return FALSE;
            }
        }
    }
    return TRUE;
}

// Remove our entries from the desktop.ini file in this directory, and
// then test the desktop.ini to see if it's empty.  If it is, delete it
// and remove the system/readonly bit from the directory...

void MyDocsUnmakeSystemFolder(LPCTSTR pPath)
{
    TCHAR szIniFile[MAX_PATH];

    PathCombine(szIniFile, pPath, c_szDesktopIni);

    // Remove CLSID2
    WritePrivateProfileString(TEXT(".ShellClassInfo"), TEXT("CLSID2"), NULL, szIniFile);

    // Remove InfoTip
    WritePrivateProfileString(TEXT(".ShellClassInfo"), TEXT("InfoTip"), NULL, szIniFile);

    // Remove Icon
    WritePrivateProfileString(TEXT(".ShellClassInfo"), TEXT("IconFile"), NULL, szIniFile);

    DWORD dwAttrb = GetFileAttributes(szIniFile);
    if (dwAttrb != 0xFFFFFFFF)
    {
        if (IsDesktopIniEmpty(szIniFile))
        {
            dwAttrb &= ~(FILE_ATTRIBUTE_SYSTEM | FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_HIDDEN);
            SetFileAttributes(szIniFile, dwAttrb);
            DeleteFile(szIniFile);
        }
        PathUnmakeSystemFolder(pPath);
    }
}


// IPersistFolder
HRESULT CMyDocsFolder::Initialize(LPCITEMIDLIST pidl)
{
    HRESULT hr;
    if (IsMyDocsIDList(pidl))
    {
        hr = _SetIDList(&_pidl, pidl);
    }
    else
    {
        TCHAR szPathInit[MAX_PATH], szMyDocs[MAX_PATH];

        // we are being inited by some folder other than the one on the
        // desktop (from the old mydocs desktop.ini). if this the current users
        // MyDocs we will untag it now so we don't get called on this anymore

        SHGetFolderPath(NULL, CSIDL_PERSONAL | CSIDL_FLAG_DONT_VERIFY, NULL, SHGFP_TYPE_CURRENT, szMyDocs);

        if (SUCCEEDED(_PathFromIDList(pidl, szPathInit)) &&
            lstrcmpi(szPathInit, szMyDocs) == 0)
        {
            MyDocsUnmakeSystemFolder(szMyDocs);
        }
        hr = E_FAIL;    // don't init on the file system folder anymore
    }
    return hr;
}

STDMETHODIMP CMyDocsFolder::ParseDisplayName(HWND hwnd, LPBC pbc, LPOLESTR pDisplayName, 
                                             ULONG* pchEaten, LPITEMIDLIST* ppidl, ULONG *pdwAttributes)
{
    HRESULT hr = _GetFolder();
    if (SUCCEEDED(hr))
        hr = _psf->ParseDisplayName(hwnd, pbc, pDisplayName, pchEaten, ppidl, pdwAttributes);
    return hr;
}

STDMETHODIMP CMyDocsFolder::EnumObjects(HWND hwnd, DWORD grfFlags, IEnumIDList **ppEnumIdList)
{
    HRESULT hr = _GetFolder();
    if (SUCCEEDED(hr))
        hr = _psf->EnumObjects(hwnd, grfFlags, ppEnumIdList);
    return hr;
}

STDMETHODIMP CMyDocsFolder::BindToObject(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv)
{
    HRESULT hr = _GetFolder();
    if (SUCCEEDED(hr))
        hr = _psf->BindToObject(pidl, pbc, riid, ppv);
    return hr;
}

STDMETHODIMP CMyDocsFolder::BindToStorage(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv)
{
    HRESULT hr = _GetFolder();
    if (SUCCEEDED(hr))
        hr = _psf->BindToStorage(pidl, pbc, riid, ppv);
    return hr;
}

STDMETHODIMP CMyDocsFolder::CompareIDs(LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    HRESULT hr = _GetFolder();
    if (SUCCEEDED(hr))
        hr = _psf->CompareIDs(lParam, pidl1, pidl2);
    return hr;
}

/*
void UpdateSendToFile()
{
    IPersistFile *ppf;
    if (SUCCEEDED(SHCoCreateInstance(NULL, &CLSID_MyDocsDropTarget, NULL, IID_PPV_ARG(IPersistFile, &ppf))))
    {
        ppf->Load(NULL, 0); // hack, get this guy to update his icon
        ppf->Release();
    }
}
*/

STDMETHODIMP CMyDocsFolder::CreateViewObject(HWND hwnd, REFIID riid, void **ppv)
{
    *ppv = NULL;

    HRESULT hr;
    if (riid == IID_IResolveShellLink)
    {
        // No work needed to resolve a link to the mydocs folder, because it is a virtual
        // folder whose location is always tracked by the shell, so return our implementation
        // of IResolveShellLink - which does nothing when Resolve() is called
        CMyDocsFolderLinkResolver* pslr = new CMyDocsFolderLinkResolver;
        if (pslr)
        {
            hr = pslr->QueryInterface(riid, ppv);
            pslr->Release();
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else if (riid == IID_IShellLinkA || 
             riid == IID_IShellLinkW)
    {
        LPITEMIDLIST pidl;
        hr = SHGetFolderLocation(NULL, CSIDL_PERSONAL | CSIDL_FLAG_NO_ALIAS, NULL, 0, &pidl);
        if (SUCCEEDED(hr))
        {
            IShellLink *psl;
            hr = SHCoCreateInstance(NULL, &CLSID_ShellLink, NULL, IID_PPV_ARG(IShellLink, &psl));
            if (SUCCEEDED(hr))
            {
                hr = psl->SetIDList(pidl);
                if (SUCCEEDED(hr))
                {
                    hr = psl->QueryInterface(riid, ppv);
                }
                psl->Release();
            }
            ILFree(pidl);
        }
    }
    else
    {
        hr = _GetFolder();
        if (SUCCEEDED(hr))
        {
            if (hwnd && (IID_IShellView == riid))
                hr = _ConfirmMyDocsPath(hwnd);

            if (SUCCEEDED(hr))
                hr = _psf->CreateViewObject(hwnd, riid, ppv);
        }
    }

    return hr;
}

DWORD _GetRealMyDocsAttributes(DWORD dwAttributes)
{
    DWORD dwRet = SFGAO_HASPROPSHEET;   // default to this in the falure case
                                        // so you can redirect mydocs via the property page
    LPITEMIDLIST pidl;
    HRESULT hr = SHGetFolderLocation(NULL, CSIDL_PERSONAL | CSIDL_FLAG_NO_ALIAS, NULL, 0, &pidl);
    if (SUCCEEDED(hr))
    {
        IShellFolder *psf;
        LPITEMIDLIST pidlLast;
        hr = _BindToIDListParent(pidl, NULL, &psf, &pidlLast);
        if (SUCCEEDED(hr))
        {
            dwRet = SHGetAttributes(psf, pidlLast, dwAttributes);
            psf->Release();
        }
        ILFree(pidl);
    }
    return dwRet;
}

#define MYDOCS_CLSID TEXT("{450d8fba-ad25-11d0-98a8-0800361b1103}") // CLSID_MyDocuments

DWORD MyDocsGetAttributes()
{
    DWORD dwAttributes = SFGAO_CANLINK |            // 00000004
                         SFGAO_CANRENAME |          // 00000010
                         SFGAO_CANDELETE |          // 00000020
                         SFGAO_HASPROPSHEET |       // 00000040
                         SFGAO_DROPTARGET |         // 00000100
                         SFGAO_FILESYSANCESTOR |    // 10000000
                         SFGAO_FOLDER |             // 20000000
                         SFGAO_FILESYSTEM |         // 40000000
                         SFGAO_HASSUBFOLDER |       // 80000000
                         SFGAO_STORAGEANCESTOR |
                         SFGAO_STORAGE;             
                         // SFGAO_NONENUMERATED     // 00100000
                         //                         // F0400174
    HKEY hkey;
    if (ERROR_SUCCESS == RegOpenKey(HKEY_CLASSES_ROOT, TEXT("CLSID\\") MYDOCS_CLSID TEXT("\\ShellFolder"), &hkey))
    {
        DWORD dwSize = sizeof(dwAttributes);
        RegQueryValueEx(hkey, TEXT("Attributes"), NULL, NULL, (BYTE *)&dwAttributes, &dwSize);
        RegCloseKey(hkey);
    }
    return dwAttributes;
}

// these are the attributes from the real mydocs folder that we want to merge
// in with the desktop icons attributes

#define SFGAO_ATTRIBS_MERGE    (SFGAO_SHARE | SFGAO_HASPROPSHEET)

STDMETHODIMP CMyDocsFolder::GetAttributesOf(UINT cidl, LPCITEMIDLIST* apidl, ULONG* rgfInOut)
{
    HRESULT hr;
    if (IsSelf(cidl, apidl))
    {
        DWORD dwRequested = *rgfInOut;

        *rgfInOut = MyDocsGetAttributes();
        
        if (dwRequested & SFGAO_ATTRIBS_MERGE)
            *rgfInOut |= _GetRealMyDocsAttributes(SFGAO_ATTRIBS_MERGE);

        // RegItem "CallForAttributes" gets us here...
        switch(_WhoIsCalling())
        {
        case APP_IS_OFFICE:
            *rgfInOut &= ~(SFGAO_FILESYSANCESTOR | SFGAO_CANMONIKER | 
                           SFGAO_HASPROPSHEET | SFGAO_NONENUMERATED);
            break;
        }
        
        if (SHRestricted(REST_MYDOCSNOPROP))
        {
            (*rgfInOut) &= ~SFGAO_HASPROPSHEET;
        }

        hr = S_OK;
    }
    else
    {
        hr = _GetFolder();
        if (SUCCEEDED(hr))
            hr = _psf->GetAttributesOf(cidl, apidl, rgfInOut);
    }

    return hr;
}

STDMETHODIMP CMyDocsFolder::GetUIObjectOf(HWND hwnd, UINT cidl, LPCITEMIDLIST *aidl, 
                                          REFIID riid, UINT *pRes, void **ppv)
{
    HRESULT hr = _GetFolder();
    if (SUCCEEDED(hr))
        hr = _psf->GetUIObjectOf(hwnd, cidl, aidl, riid, pRes, ppv);
    return hr;
}

STDMETHODIMP CMyDocsFolder::GetDisplayNameOf(LPCITEMIDLIST pidl, DWORD uFlags, STRRET *pName)
{
    HRESULT hr;
    if (IsSelf(1, &pidl))
    {
        TCHAR szMyDocsPath[MAX_PATH];
        hr = SHGetFolderPath(NULL, CSIDL_PERSONAL | CSIDL_FLAG_DONT_VERIFY, NULL, SHGFP_TYPE_CURRENT, szMyDocsPath);
        if (SUCCEEDED(hr))
        {
            // RegItems "WantsFORPARSING" gets us here. allows us to control our parsing name
            LPTSTR psz = ((uFlags & SHGDN_INFOLDER) ? PathFindFileName(szMyDocsPath) : szMyDocsPath);
            hr = StringToStrRet(psz, pName);
        }
    }
    else
    {
        hr = _GetFolder();
        if (SUCCEEDED(hr))
            hr = _psf->GetDisplayNameOf(pidl, uFlags, pName);
    }
    return hr;
}

STDMETHODIMP CMyDocsFolder::SetNameOf(HWND hwnd, LPCITEMIDLIST pidl, LPCOLESTR pName, DWORD uFlags, LPITEMIDLIST *ppidlOut)
{
    HRESULT hr = _GetFolder();
    if (SUCCEEDED(hr))
        hr = _psf->SetNameOf(hwnd, pidl, pName, uFlags, ppidlOut);
    return hr;
}

STDMETHODIMP CMyDocsFolder::GetDefaultSearchGUID(LPGUID lpGuid)
{
    HRESULT hr = _GetFolder2();
    if (SUCCEEDED(hr))
        hr = _psf2->GetDefaultSearchGUID(lpGuid);
    return hr;
}

STDMETHODIMP CMyDocsFolder::EnumSearches(LPENUMEXTRASEARCH *ppenum)
{
    HRESULT hr = _GetFolder2();
    if (SUCCEEDED(hr))
        hr = _psf2->EnumSearches(ppenum);
    return hr;
}

STDMETHODIMP CMyDocsFolder::GetDefaultColumn(DWORD dwRes, ULONG *pSort, ULONG *pDisplay)
{
    HRESULT hr = _GetFolder2();
    if (SUCCEEDED(hr))
        hr = _psf2->GetDefaultColumn(dwRes, pSort, pDisplay);
    return hr;
}

STDMETHODIMP CMyDocsFolder::GetDefaultColumnState(UINT iColumn, DWORD *pbState)
{    
    HRESULT hr = _GetFolder2();
    if (SUCCEEDED(hr))
        hr = _psf2->GetDefaultColumnState(iColumn, pbState);
    return hr;
}

STDMETHODIMP CMyDocsFolder::GetDetailsEx(LPCITEMIDLIST pidl, const SHCOLUMNID *pscid, VARIANT *pv)
{
    HRESULT hr = _GetFolder2();
    if (SUCCEEDED(hr))
        hr = _psf2->GetDetailsEx(pidl, pscid, pv);
    return hr;
}

STDMETHODIMP CMyDocsFolder::GetDetailsOf(LPCITEMIDLIST pidl, UINT iColumn, LPSHELLDETAILS pDetail)
{
    HRESULT hr = _GetFolder2();
    if (SUCCEEDED(hr))
        hr = _psf2->GetDetailsOf(pidl, iColumn, pDetail);
    return hr;
}

STDMETHODIMP CMyDocsFolder::MapColumnToSCID(UINT iCol, SHCOLUMNID *pscid)
{
    HRESULT hr = _GetFolder2();
    if (SUCCEEDED(hr))
        hr = _psf2->MapColumnToSCID(iCol, pscid);
    return hr;
}

HRESULT CMyDocsFolder::_GetFolderOverlayInfo(int *pIndex, BOOL fIconIndex)
{
    HRESULT hr;

    if (pIndex)
    {
        LPITEMIDLIST pidl;
        hr = SHGetFolderLocation(NULL, CSIDL_PERSONAL | CSIDL_FLAG_NO_ALIAS, NULL, 0, &pidl);
        if (SUCCEEDED(hr))
        {
            IShellFolder *psf;
            LPITEMIDLIST pidlLast;
            hr = _BindToIDListParent(pidl, NULL, &psf, &pidlLast);
            if (SUCCEEDED(hr))
            {
                IShellIconOverlay* psio;
                hr = psf->QueryInterface(IID_PPV_ARG(IShellIconOverlay, &psio));
                if (SUCCEEDED(hr))
                {
                    if (fIconIndex)
                        hr = psio->GetOverlayIconIndex(pidlLast, pIndex);
                    else
                        hr = psio->GetOverlayIndex(pidlLast, pIndex);

                    psio->Release();
                }

                psf->Release();
            }

            ILFree(pidl);
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}

STDMETHODIMP CMyDocsFolder::GetOverlayIndex(LPCITEMIDLIST pidl, int *pIndex)
{
    HRESULT hr = E_FAIL;

    if (IsSelf(1, &pidl))
    {
        if (pIndex && *pIndex == OI_ASYNC)
            hr = E_PENDING;
        else
            hr = _GetFolderOverlayInfo(pIndex, FALSE);
    }
    else
    {
        // forward to aggregated dude
        if (SUCCEEDED(_GetShellIconOverlay()))
        {
            hr = _psio->GetOverlayIndex(pidl, pIndex);
        }
    }

    return hr;
}

STDMETHODIMP CMyDocsFolder::GetOverlayIconIndex(LPCITEMIDLIST pidl, int *pIconIndex)
{
    HRESULT hr = E_FAIL;

    if (IsSelf(1, &pidl))
    {
        hr = _GetFolderOverlayInfo(pIconIndex, TRUE);
    }
    else if (SUCCEEDED(_GetShellIconOverlay()))
    {
        // forward to aggregated dude
        hr = _psio->GetOverlayIconIndex(pidl, pIconIndex);
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\nametrans.cpp ===
#include "shellprv.h"
#include "ids.h"
#pragma hdrstop

#include "isproc.h"

// eventually expand this to do rename UI, right now it just picks a default name
// in the destination namespace

HRESULT QIThroughShellItem(IShellItem *psi, REFIID riid, void **ppv)
{
    // todo: put this into shellitem
    *ppv = NULL;

    IShellFolder *psf;
    HRESULT hr = psi->BindToHandler(NULL, BHID_SFObject, IID_PPV_ARG(IShellFolder, &psf));
    if (SUCCEEDED(hr))
    {
        hr = psf->QueryInterface(riid, ppv);
        psf->Release();
    }
    return hr;
}

BOOL IsValidChar(WCHAR chTest, LPWSTR pszValid, LPWSTR pszInvalid)
{
    return (!pszValid || StrChr(pszValid, chTest)) &&
           (!pszInvalid || !StrChr(pszInvalid, chTest));
}

const WCHAR c_rgSubstitutes[] = { '_', ' ', '~' };
WCHAR GetValidSubstitute(LPWSTR pszValid, LPWSTR pszInvalid)
{
    for (int i = 0; i < ARRAYSIZE(c_rgSubstitutes); i++)
    {
        if (IsValidChar(c_rgSubstitutes[i], pszValid, pszInvalid))
        {
            return c_rgSubstitutes[i];
        }
    }
    return 0;
}

HRESULT CheckCharsAndReplaceIfNecessary(IItemNameLimits *pinl, LPWSTR psz)
{
    // returns S_OK if no chars replaced, S_FALSE otherwise
    HRESULT hr = S_OK;
    LPWSTR pszValid, pszInvalid;
    if (SUCCEEDED(pinl->GetValidCharacters(&pszValid, &pszInvalid)))
    {
        WCHAR chSubs = GetValidSubstitute(pszValid, pszInvalid);

        int iSrc = 0, iDest = 0;
        while (psz[iSrc] != 0)
        {
            if (IsValidChar(psz[iSrc], pszValid, pszInvalid))
            {
                // use the char itself if it's valid
                psz[iDest] = psz[iSrc];
                iDest++;
            }
            else
            {
                // mark that we replaced a char
                hr = S_FALSE;
                if (chSubs)
                {
                    // use a substitute if available
                    psz[iDest] = chSubs;
                    iDest++;
                }
                // else no valid char, just skip it
            }
            iSrc++;
        }
        psz[iDest] = 0;

        if (pszValid)
            CoTaskMemFree(pszValid);
        if (pszInvalid)
            CoTaskMemFree(pszInvalid);
    }
    return hr;
}

HRESULT BreakOutString(LPCWSTR psz, LPWSTR *ppszFilespec, LPWSTR *ppszExt)
{
    // todo: detect the (2) in "New Text Document (2).txt" and reduce the filespec
    // accordingly to prevent "(1) (1)" etc. in multiple copies

    *ppszFilespec = NULL;
    *ppszExt = NULL;

    LPWSTR pszExt = PathFindExtension(psz);
    // make an empty string if necessary.  this makes our logic simpler later instead of having to
    // handle the special case all the time.
    HRESULT hr = SHStrDup(pszExt ? pszExt : L"", ppszExt);
    if (SUCCEEDED(hr))
    {
        int iLenExt = lstrlen(*ppszExt);
        int cchBufFilespec = lstrlen(psz) - iLenExt + 1;
        *ppszFilespec = (LPWSTR)CoTaskMemAlloc(cchBufFilespec * sizeof(WCHAR));
        if (*ppszFilespec)
        {
            lstrcpyn(*ppszFilespec, psz, cchBufFilespec);
            hr = S_OK;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    if (FAILED(hr) && *ppszExt)
    {
        CoTaskMemFree(*ppszExt);
        *ppszExt = NULL;
    }
    ASSERT((SUCCEEDED(hr) && *ppszFilespec && *ppszExt) || (FAILED(hr) && !*ppszFilespec && !*ppszExt));
    return hr;
}

BOOL ItemExists(LPCWSTR pszName, IShellItem *psiDest)
{
    BOOL fRet = FALSE;

    IBindCtx *pbc;
    HRESULT hr = BindCtx_CreateWithMode(STGX_MODE_READ, &pbc);
    if (SUCCEEDED(hr))
    {
        ITransferDest *pitd;
        hr = psiDest->BindToHandler(pbc, BHID_SFObject, IID_PPV_ARG(ITransferDest, &pitd));
        if (FAILED(hr))
        {
            hr = CreateStg2StgExWrapper(psiDest, NULL, &pitd);
        }
        if (SUCCEEDED(hr))
        {
            DWORD dwDummy;
            IUnknown *punk;
            hr = pitd->OpenElement(pszName, STGX_MODE_READ, &dwDummy, IID_PPV_ARG(IUnknown, &punk));
            if (SUCCEEDED(hr))
            {
                fRet = TRUE;
                punk->Release();
            }
            pitd->Release();
        }
        pbc->Release();
    }
    return fRet;
}

HRESULT BuildName(LPCWSTR pszFilespec, LPCWSTR pszExt, int iOrd, int iMaxLen, LPWSTR *ppszName)
{
    // some things are hardcoded here like the " (%d)" stuff.  this limitation is equivalent to
    // PathYetAnotherMakeUniqueName so we're okay.

    WCHAR szOrd[10];
    if (iOrd)
    {
        wnsprintf(szOrd, ARRAYSIZE(szOrd), L" (%d)", iOrd);
    }
    else
    {
        szOrd[0] = 0;
    }

    int iLenFilespecToUse = lstrlen(pszFilespec);
    int iLenOrdToUse = lstrlen(szOrd);
    int iLenExtToUse = lstrlen(pszExt);
    int iLenTotal = iLenFilespecToUse + iLenOrdToUse + iLenExtToUse;
    HRESULT hr = S_OK;
    if (iLenTotal > iMaxLen)
    {
        // first reduce the filespec since its less important than the extension
        iLenFilespecToUse = max(1, iLenFilespecToUse - (iLenTotal - iMaxLen));
        iLenTotal = iLenFilespecToUse + iLenOrdToUse + iLenExtToUse;
        if (iLenTotal > iMaxLen)
        {
            // next zap the extension.
            iLenExtToUse = max(0, iLenExtToUse - (iLenTotal - iMaxLen));
            iLenTotal = iLenFilespecToUse + iLenOrdToUse + iLenExtToUse;
            if (iLenTotal > iMaxLen)
            {
                // now it's game over.
                iLenOrdToUse = max(0, iLenOrdToUse - (iLenTotal - iMaxLen));
                iLenTotal = iLenFilespecToUse + iLenOrdToUse + iLenExtToUse;
                if (iLenTotal > iMaxLen)
                {
                    hr = E_FAIL;
                }
            }
        }
    }

    if (SUCCEEDED(hr))
    {
        int cchBuf = iLenTotal + 1;
        *ppszName = (LPWSTR)CoTaskMemAlloc(cchBuf * sizeof(WCHAR));
        if (*ppszName)
        {
            lstrcpyn(*ppszName, pszFilespec, iLenFilespecToUse + 1);
            lstrcpyn(*ppszName + iLenFilespecToUse, szOrd, iLenOrdToUse + 1);
            lstrcpyn(*ppszName + iLenFilespecToUse + iLenOrdToUse, pszExt, iLenExtToUse + 1);
            hr = S_OK;
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    return hr;
}

HRESULT FindUniqueName(LPCWSTR pszFilespec, LPCWSTR pszExt, int iMaxLen, IShellItem *psiDest, LPWSTR *ppszName)
{
    *ppszName = NULL;

    HRESULT hr = E_FAIL;
    BOOL fFound = FALSE;
    for (int i = 0; !fFound && (i < 1000); i++)
    {
        LPWSTR pszBuf;
        if (SUCCEEDED(BuildName(pszFilespec, pszExt, i, iMaxLen, &pszBuf)))
        {
            if (!ItemExists(pszBuf, psiDest))
            {
                fFound = TRUE;
                hr = S_OK;
                *ppszName = pszBuf;
            }
            else
            {
                CoTaskMemFree(pszBuf);
            }
        }
    }

    ASSERT((SUCCEEDED(hr) && *ppszName) || (FAILED(hr) && !*ppszName));
    return hr;
}

HRESULT AutoCreateName(IShellItem *psiDest, IShellItem *psi, LPWSTR *ppszName)
{
    *ppszName = NULL;

    LPWSTR pszOrigName;
    HRESULT hr = psi->GetDisplayName(SIGDN_PARENTRELATIVEFORADDRESSBAR, &pszOrigName);
    if (SUCCEEDED(hr))
    {
        IItemNameLimits *pinl;
        if (SUCCEEDED(QIThroughShellItem(psiDest, IID_PPV_ARG(IItemNameLimits, &pinl))))
        {
            int iMaxLen;
            if (FAILED(pinl->GetMaxLength(pszOrigName, &iMaxLen)))
            {
                // assume this for now in case of failure
                iMaxLen = MAX_PATH;
            }

            if (S_OK != CheckCharsAndReplaceIfNecessary(pinl, pszOrigName) ||
                lstrlen(pszOrigName) > iMaxLen)
            {
                // only if it started as an illegal name do we retry and provide uniqueness.
                // (if its legal then leave it as non-unique so callers can do their confirm overwrite code).
                LPWSTR pszFilespec, pszExt;
                hr = BreakOutString(pszOrigName, &pszFilespec, &pszExt);
                if (SUCCEEDED(hr))
                {
                    hr = FindUniqueName(pszFilespec, pszExt, iMaxLen, psiDest, ppszName);
                    CoTaskMemFree(pszFilespec);
                    CoTaskMemFree(pszExt);
                }
            }
            else
            {
                // the name is okay so let it go through
                hr = S_OK;
                *ppszName = pszOrigName;
                pszOrigName = NULL;
            }
            pinl->Release();
        }
        else
        {
            // if the destination namespace doesn't have an IItemNameLimits then assume the
            // name is all good.  we're not going to probe or anything so this is the best
            // we can do.
            hr = S_OK;
            *ppszName = pszOrigName;
            pszOrigName = NULL;
        }
        if (pszOrigName)
        {
            CoTaskMemFree(pszOrigName);
        }
    }

    if (FAILED(hr) && *ppszName)
    {
        CoTaskMemFree(*ppszName);
        *ppszName = NULL;
    }

    ASSERT((SUCCEEDED(hr) && *ppszName) || (FAILED(hr) && !*ppszName));
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\netapi.cpp ===
#include "shellprv.h"
#include "netview.h"
#include "balmsg.h"
#include "mtpt.h"
#include "ids.h"

#pragma  hdrstop

// from mtptarun.cpp
STDAPI_(void) CMtPt_SetWantUI(int iDrive);

//
// Converts an offset to a string to a string pointer.
//

LPCTSTR _Offset2Ptr(LPTSTR pszBase, UINT_PTR offset, UINT * pcb)
{
    LPTSTR pszRet;
    if (offset == 0) 
    {
        pszRet = NULL;
        *pcb = 0;
    } 
    else 
    {
        pszRet = (LPTSTR)((LPBYTE)pszBase + offset);
        *pcb = (lstrlen(pszRet) + 1) * sizeof(TCHAR);
    }
    return pszRet;
}


//
// exported networking APIs from shell32
//

STDAPI_(UINT) SHGetNetResource(HNRES hnres, UINT iItem, LPNETRESOURCE pnresOut, UINT cbMax)
{
    UINT iRet = 0;        // assume error
    LPNRESARRAY panr = (LPNRESARRAY)GlobalLock(hnres);
    if (panr)
    {
        if (iItem==(UINT)-1)
        {
            iRet = panr->cItems;
        }
        else if (iItem < panr->cItems)
        {
            UINT cbProvider, cbRemoteName;
            LPCTSTR pszProvider = _Offset2Ptr((LPTSTR)panr, (UINT_PTR)panr->nr[iItem].lpProvider, &cbProvider);
            LPCTSTR pszRemoteName = _Offset2Ptr((LPTSTR)panr, (UINT_PTR)panr->nr[iItem].lpRemoteName, &cbRemoteName);
            iRet = sizeof(NETRESOURCE) + cbProvider + cbRemoteName;
            if (iRet <= cbMax)
            {
                LPTSTR psz = (LPTSTR)(pnresOut + 1);
                *pnresOut = panr->nr[iItem];
                if (pnresOut->lpProvider)
                {
                    pnresOut->lpProvider = psz;
                    lstrcpy(psz, pszProvider);
                    psz += cbProvider / sizeof(TCHAR);
                }
                if (pnresOut->lpRemoteName)
                {
                    pnresOut->lpRemoteName = psz;
                    lstrcpy(psz, pszRemoteName);
                }
            }
        }
        GlobalUnlock(hnres);
    }
    return iRet;
}


STDAPI_(DWORD) SHNetConnectionDialog(HWND hwnd, LPTSTR pszRemoteName, DWORD dwType)
{
    CONNECTDLGSTRUCT cds = {0};
    NETRESOURCE nr = {0};

    cds.cbStructure = sizeof(cds);  /* size of this structure in bytes */
    cds.hwndOwner = hwnd;           /* owner window for the dialog */
    cds.lpConnRes = &nr;            /* Requested Resource info    */
    cds.dwFlags = CONNDLG_USE_MRU;  /* flags (see below) */

    nr.dwType = dwType;

    if (pszRemoteName)
    {
        nr.lpRemoteName = pszRemoteName;
        cds.dwFlags = CONNDLG_RO_PATH;
    }
    DWORD mnr = WNetConnectionDialog1(&cds);
    if (mnr == WN_SUCCESS && dwType != RESOURCETYPE_PRINT && cds.dwDevNum != 0)
    {
        TCHAR szPath[4];

        CMountPoint::WantAutorunUI(PathBuildRoot(szPath, cds.dwDevNum - 1 /* 1-based! */));
    }
    return mnr;
}

typedef struct
{
    HWND    hwnd;
    TCHAR   szRemoteName[MAX_PATH];
    DWORD   dwType;
} SHNETCONNECT;

DWORD CALLBACK _NetConnectThreadProc(void *pv)
{
    SHNETCONNECT *pshnc = (SHNETCONNECT *)pv;
    HWND hwndDestroy = NULL;

    if (!pshnc->hwnd)
    {
        RECT rc;
        LPPOINT ppt;
        DWORD pid;

        // Wild multimon guess - Since we don't have a parent window,
        // we will arbitrarily position ourselves in the same location as
        // the foreground window, if the foreground window belongs to our
        // process.
        HWND hwnd = GetForegroundWindow();

        if (hwnd                                    && 
            GetWindowThreadProcessId(hwnd, &pid)    &&
            (pid == GetCurrentProcessId())          && 
            GetWindowRect(hwnd, &rc))
        {
            // Don't use the upper left corner exactly; slide down by
            // some fudge factor.  We definitely want to get past the
            // caption.
            rc.top += GetSystemMetrics(SM_CYCAPTION) * 4;
            rc.left += GetSystemMetrics(SM_CXVSCROLL) * 4;
            ppt = (LPPOINT)&rc;
        }
        else
        {
            ppt = NULL;
        }

        // Create a stub window so the wizard can establish an Alt+Tab icon
        hwndDestroy = _CreateStubWindow(ppt, NULL);
        pshnc->hwnd = hwndDestroy;
    }

    SHNetConnectionDialog(pshnc->hwnd, pshnc->szRemoteName[0] ? pshnc->szRemoteName : NULL, pshnc->dwType);

    if (hwndDestroy)
        DestroyWindow(hwndDestroy);

    LocalFree(pshnc);

    SHChangeNotifyHandleEvents();
    return 0;
}


STDAPI SHStartNetConnectionDialog(HWND hwnd, LPCTSTR pszRemoteName OPTIONAL, DWORD dwType)
{
    SHNETCONNECT *pshnc = (SHNETCONNECT *)LocalAlloc(LPTR, sizeof(SHNETCONNECT));
    if (pshnc)
    {
        pshnc->hwnd = hwnd;
        pshnc->dwType = dwType;
        if (pszRemoteName)
            lstrcpyn(pshnc->szRemoteName, pszRemoteName, ARRAYSIZE(pshnc->szRemoteName));

        if (!SHCreateThread(_NetConnectThreadProc, pshnc, CTF_PROCESS_REF | CTF_COINIT, NULL))
        {
            LocalFree((HLOCAL)pshnc);
        } 
    }
    return S_OK;    // whole thing is async, value here is meaningless
}


#ifdef UNICODE

STDAPI SHStartNetConnectionDialogA(HWND hwnd, LPCSTR pszRemoteName, DWORD dwType)
{
    WCHAR wsz[MAX_PATH];

    if (pszRemoteName)
    {
        SHAnsiToUnicode(pszRemoteName, wsz, SIZECHARS(wsz));
        pszRemoteName = (LPCSTR)wsz;
    }
    return SHStartNetConnectionDialog(hwnd, (LPCTSTR)pszRemoteName, dwType);
}

#else

STDAPI SHStartNetConnectionDialogW(HWND hwnd, LPCWSTR pszRemoteName, DWORD dwType)
{
    char sz[MAX_PATH];

    if (pszRemoteName)
    {
        SHUnicodeToAnsi(pszRemoteName, sz, SIZECHARS(sz));
        pszRemoteName = (LPCWSTR)sz;
    }

    return SHStartNetConnectionDialog(hwnd, (LPCTSTR)pszRemoteName, dwType);
}

#endif


// These are wrappers around the same WNet APIs, but play with the parameters
// to make it easier to call.  They accept full paths rather than just drive letters.
//
DWORD APIENTRY SHWNetDisconnectDialog1 (LPDISCDLGSTRUCT lpConnDlgStruct)
{
    TCHAR szLocalName[3];

    if (lpConnDlgStruct && lpConnDlgStruct->lpLocalName && lstrlen(lpConnDlgStruct->lpLocalName) > 2)
    {
        // Kludge allert, don't pass c:\ to API, instead only pass C:
        szLocalName[0] = lpConnDlgStruct->lpLocalName[0];
        szLocalName[1] = TEXT(':');
        szLocalName[2] = 0;
        lpConnDlgStruct->lpLocalName = szLocalName;
    }

    return WNetDisconnectDialog1 (lpConnDlgStruct);
}


DWORD APIENTRY SHWNetGetConnection (LPCTSTR lpLocalName, LPTSTR lpRemoteName, LPDWORD lpnLength)
{
    TCHAR szLocalName[3];

    if (lpLocalName && lstrlen(lpLocalName) > 2)
    {
        // Kludge allert, don't pass c:\ to API, instead only pass C:
        szLocalName[0] = lpLocalName[0];
        szLocalName[1] = TEXT(':');
        szLocalName[2] = 0;
        lpLocalName = szLocalName;
    }

    return WNetGetConnection (lpLocalName, lpRemoteName, lpnLength);
}


// exported for netfind.cpp to use

STDAPI SHGetDomainWorkgroupIDList(LPITEMIDLIST *ppidl)
{
    *ppidl = NULL;

    IShellFolder *psfDesktop;
    HRESULT hr = SHGetDesktopFolder(&psfDesktop);
    if (SUCCEEDED(hr))
    {
        TCHAR szName[MAX_PATH];

        lstrcpy(szName, TEXT("\\\\"));

        if (RegGetValueString(HKEY_LOCAL_MACHINE, 
                TEXT("SYSTEM\\CurrentControlSet\\Control\\ComputerName\\ComputerName"),
                TEXT("ComputerName"), szName + 2, sizeof(szName) - 2 * sizeof(TCHAR)))
        {
            WCHAR wszName[MAX_PATH];

            SHTCharToUnicode(szName, wszName, ARRAYSIZE(wszName));

            hr = psfDesktop->ParseDisplayName(NULL, NULL, wszName, NULL, ppidl, NULL);
            if (SUCCEEDED(hr))
                ILRemoveLastID(*ppidl);
        }
        else
            hr = E_FAIL;

        psfDesktop->Release();
    }
    return hr;
}


// SHGetComputerDisplayName - formats and returns the computer name for display.

#define REGSTR_PATH_COMPUTERDESCCACHE  REGSTR_PATH_EXPLORER TEXT("\\ComputerDescriptions")

STDAPI_(void) SHCacheComputerDescription(LPCTSTR pszMachineName, LPCTSTR pszDescription)
{
    if (pszDescription)
    {
        DWORD cb = (lstrlen(pszDescription) + 1) * sizeof(*pszDescription);
        SHSetValue(HKEY_CURRENT_USER, REGSTR_PATH_COMPUTERDESCCACHE, SkipServerSlashes(pszMachineName), REG_SZ, pszDescription, cb);
    }
}

STDAPI _GetComputerDescription(LPCTSTR pszMachineName, LPTSTR pszDescription, DWORD cchDescription)
{
    SERVER_INFO_101 *psv101 = NULL;
    HRESULT hr = ResultFromWin32(NetServerGetInfo((LPWSTR)pszMachineName, 101, (BYTE**)&psv101));
    if (SUCCEEDED(hr))
    {
        if (psv101->sv101_comment && psv101->sv101_comment[0])
        {
            lstrcpyn(pszDescription, psv101->sv101_comment, cchDescription);
        }
        else
        {
            hr = E_FAIL;
        }
        NetApiBufferFree(psv101);
    }
    return hr;
}

HRESULT _GetCachedComputerDescription(LPCTSTR pszMachineName, LPTSTR pszDescription, int cchDescription)
{
    ULONG cb = cchDescription*sizeof(*pszDescription);
    return ResultFromWin32(SHGetValue(HKEY_CURRENT_USER, REGSTR_PATH_COMPUTERDESCCACHE, SkipServerSlashes(pszMachineName), NULL, pszDescription, &cb));
}

STDAPI SHGetComputerDisplayNameW(LPCWSTR pszMachineName, DWORD dwFlags, LPWSTR pszDisplay, DWORD cchDisplay)
{
    HRESULT hr = E_FAIL;

    // map the NULL machine name to the local computer name - so we can cache correctly.

    WCHAR szMachineName[CNLEN + 1];
    if (!pszMachineName)
    {
        DWORD cchMachine = ARRAYSIZE(szMachineName);
        if (GetComputerName(szMachineName, &cchMachine))
        {
            pszMachineName = szMachineName;
            dwFlags |= SGCDNF_NOCACHEDENTRY;
        }
    }

    // we must have a machine name, so we can perform the look up.

    if (pszMachineName)
    {
        WCHAR szDescription[256];

        // can we read the name from teh cache, if not/or the user says they don't want
        // the cached name then lets hit the wire and read it.

        if (!(dwFlags & SGCDNF_NOCACHEDENTRY))
            hr = _GetCachedComputerDescription(pszMachineName, szDescription, ARRAYSIZE(szDescription));

        if (FAILED(hr))
        {
            hr = _GetComputerDescription(pszMachineName, szDescription, ARRAYSIZE(szDescription));
            if (FAILED(hr))
            {
                *szDescription = _TEXT('\0');
            }
            if (!(dwFlags & SGCDNF_NOCACHEDENTRY))
            {
                SHCacheComputerDescription(pszMachineName, szDescription);  // write through to cache
            }
        }

        // we have a name, so lets format it, if they request description only / or we failed
        // above lets just return raw string.  otherwise we build a new machine name based
        // on the remote name and the description we fetched.

        if (SUCCEEDED(hr) && *szDescription)
        {
            if (dwFlags & SGCDNF_DESCRIPTIONONLY)
            {
                lstrcpyn(pszDisplay, szDescription, cchDisplay);
                hr = S_OK;
            }
            else
            {
                hr = SHBuildDisplayMachineName(pszMachineName, szDescription, pszDisplay, cchDisplay);
            }
        }
        else if (!(dwFlags & SGCDNF_DESCRIPTIONONLY))
        {
            lstrcpyn(pszDisplay, SkipServerSlashes(pszMachineName), cchDisplay);
            hr = S_OK;
        }
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\netview.h ===
#include "lm.h"

#pragma pack(1)
typedef struct _IDNETRESOURCE   // idn
{
    WORD    cb;
    BYTE    bFlags;         // Display type in low nibble
    BYTE    uType;
    BYTE    uUsage;         // Usage in low nibble, More Flags in high nibble
    CHAR    szNetResName[1];
    // char szProvider[*] - If NET_HASPROVIDER bit is set
    // char szComment[*]  - If NET_HASCOMMENT bit is set.
    // WCHAR szNetResNameWide[*] - If NET_UNICODE bit it set.
    // WCHAR szProviderWide[*]   - If NET_UNICODE and NET_HASPROVIDER
    // WCHAR szCommentWide[*]    - If NET_UNICODE and NET_HASCOMMENT
} IDNETRESOURCE, *LPIDNETRESOURCE;
typedef const IDNETRESOURCE *LPCIDNETRESOURCE;
#pragma pack()

//===========================================================================
// CNetwork: Some private macro - but probably needed in .cpp file.
//===========================================================================
#define NET_DISPLAYNAMEOFFSET           ((UINT)((LPIDNETRESOURCE)0)->szNetResName)
#define NET_GetFlags(pidnRel)           ((pidnRel)->bFlags)
#define NET_GetDisplayType(pidnRel)     ((pidnRel)->bFlags & 0x0f)
#define NET_GetType(pidnRel)            ((pidnRel)->uType)
#define NET_GetUsage(pidnRel)           ((pidnRel)->uUsage & 0x0f)
#define NET_IsReg(pidnRel)              ((pidnRel)->bFlags == SHID_NET_REGITEM)
#define NET_IsJunction(pidnRel)         ((pidnRel)->bFlags & SHID_JUNCTION)
#define NET_IsRootReg(pidnRel)          ((pidnRel)->bFlags == SHID_NET_ROOTREGITEM)
#define NET_IsFake(pidnRel)             ((pidnRel)->szNetResName[0] == '\0')

// Define some Flags that are on high nibble of uUsage byte
#define NET_HASPROVIDER                 0x80    // Has own copy of provider
#define NET_HASCOMMENT                  0x40    // Has comment field in pidl
#define NET_REMOTEFLD                   0x20    // Is remote folder
#define NET_UNICODE                     0x10    // Has unicode names
#define NET_FHasComment(pidnRel)        ((pidnRel)->uUsage & NET_HASCOMMENT)
#define NET_FHasProvider(pidnRel)       ((pidnRel)->uUsage & NET_HASPROVIDER)
#define NET_IsRemoteFld(pidnRel)        ((pidnRel)->uUsage & NET_REMOTEFLD)
#define NET_IsUnicode(pidnRel)          ((pidnRel)->uUsage & NET_UNICODE)

STDAPI_(BOOL) NET_IsRemoteRegItem(LPCITEMIDLIST pidl, REFCLSID rclsid, LPCITEMIDLIST* ppidlRemainder);

// These are exported form netviewx.c they are wrappers around the same WNet
// APIs, but play with the parameters to make it easier to call.  They accept
// full paths rather than just drive letters.

STDAPI_(DWORD) SHWNetDisconnectDialog1 (LPDISCDLGSTRUCT lpConnDlgStruct);
STDAPI_(DWORD) SHWNetGetConnection (LPCTSTR lpLocalName, LPTSTR lpRemoteName, LPDWORD lpnLength);
STDAPI SHGetDomainWorkgroupIDList(LPITEMIDLIST *ppidl);
STDAPI_(void) SHCacheComputerDescription(LPCTSTR pszMachineName, LPCTSTR pszDescription);

typedef struct
{
    LPCTSTR lpName;
    WORD    wNetType;
} NETPROVIDERS;

EXTERN_C const NETPROVIDERS c_rgProviderMap[];
EXTERN_C const int c_cProviders;

STDAPI_(LPTSTR) NET_CopyResName(LPCIDNETRESOURCE pidn, LPTSTR pszBuff, UINT cchBuff);
STDAPI_(LPTSTR) NET_CopyComment(LPCIDNETRESOURCE pidn, LPTSTR pszBuff, UINT cchBuff);
STDAPI_(LPTSTR) NET_CopyProviderName(LPCIDNETRESOURCE pidn, LPTSTR pszBuff, UINT cchBuff);

// netcrawl.cpp
STDAPI_(void) RefreshNetCrawler();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\netcrawl.cpp ===
#include "shellprv.h"
#include "commctrl.h"
#include "comctrlp.h"
#pragma hdrstop

#include "netview.h"
#include "msprintx.h"
#include "setupapi.h"
#include "ras.h"
#include "ids.h"


// a COM object to enumerate shares and printers in the shell, its acts
// as a monitor for all that is going on.

class CWorkgroupCrawler : public INetCrawler, IPersistPropertyBag
{
public:
    CWorkgroupCrawler();
    ~CWorkgroupCrawler();

    // IUnknown
    STDMETHOD(QueryInterface)(REFIID riid, void **ppv);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

    // INetCrawler
    STDMETHOD(Update)(DWORD dwFlags);

    // IPersist
    STDMETHOD(GetClassID)(CLSID *pclsid)
        { *pclsid = CLSID_WorkgroupNetCrawler; return S_OK; }

    // IPersistPropertyBag
    STDMETHOD(InitNew)()
        { return S_OK; }
    STDMETHOD(Load)(IPropertyBag *ppb, IErrorLog *pel)
        { IUnknown_Set((IUnknown**)&_ppb, ppb); return S_OK; }
    STDMETHOD(Save)(IPropertyBag *ppb, BOOL fClearDirty, BOOL fSaveAll)
        { return S_OK; }

private:
    HRESULT _GetMRUs();
    void _AgeOutShares(BOOL fDeleteAll);
    HRESULT _CreateShortcutToShare(LPCTSTR pszRemoteName);
    HRESULT _InstallPrinter(LPCTSTR pszRemoteName);
    BOOL _KeepGoing(int *pcMachines, int *pcShares, int *pcPrinters);
    void _EnumResources(LPNETRESOURCE pnr, int *pcMachines, HDPA hdaShares, HDPA hdaPrinters);
    HANDLE _AddPrinterConnectionNoUI(LPCWSTR pszRemoteName, BOOL *pfInstalled);

    static int CALLBACK _DiscardCB(void *pvItem, void *pv);
    static int CALLBACK _InstallSharesCB(void *pvItem, void *pv);
    static int CALLBACK _InstallPrinterCB(void *pvItem, void *pv);

    LONG _cRef;                 // reference count for the object
    HANDLE _hPrinters;          // MRU for printers 
    HKEY _hShares;              // registry key for the printer shares
    HINSTANCE _hPrintUI;        // instance handle for printui.dll    
    IPropertyBag *_ppb;         // property bag object for state
};


// constants for the MRU's and buffers

#define WORKGROUP_PATH \
            REGSTR_PATH_EXPLORER TEXT("\\WorkgroupCrawler")

#define PRINTER_SUBKEY     \
            (WORKGROUP_PATH TEXT("\\Printers"))
   
#define SHARE_SUBKEY     \
            (WORKGROUP_PATH TEXT("\\Shares"))

#define LAST_VISITED    TEXT("DateLastVisited")
#define SHORTCUT_NAME   TEXT("Filename")

#define MAX_MACHINES    32
#define MAX_PRINTERS    10
#define MAX_SHARES      10

#define CB_WNET_BUFFER  (8*1024)

typedef HANDLE (* ADDPRINTCONNECTIONNOUI)(LPCWSTR, BOOL *);


// construction and IUnknown

CWorkgroupCrawler::CWorkgroupCrawler() :
    _cRef(1)
{
}

CWorkgroupCrawler::~CWorkgroupCrawler()
{
    if (_hPrinters)
        FreeMRUList(_hPrinters);

    if (_hShares)
        RegCloseKey(_hShares);

    if (_hPrintUI)
        FreeLibrary(_hPrintUI);

    if (_ppb)
        _ppb->Release();
}

STDMETHODIMP CWorkgroupCrawler::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = 
    {
        QITABENT(CWorkgroupCrawler, INetCrawler),           // IID_INetCrawler
        QITABENT(CWorkgroupCrawler, IPersist),              // IID_IPersist
        QITABENT(CWorkgroupCrawler, IPersistPropertyBag),   // IID_IPersistPropertyBag
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CWorkgroupCrawler::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CWorkgroupCrawler::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}

STDAPI CWorkgroupCrawler_CreateInstance(IUnknown* punkOuter, REFIID riid, void** ppv)
{
    CWorkgroupCrawler *pwgc = new CWorkgroupCrawler();            
    if (!pwgc)
        return E_OUTOFMEMORY;

    HRESULT hr = pwgc->QueryInterface(riid, ppv);
    pwgc->Release();
    return hr;
}


// lets open the keys for the objects we are about to install

HRESULT CWorkgroupCrawler::_GetMRUs()
{
    // get the printers MRU if we need to allocate one

    if (!_hPrinters)
    {
        MRUINFO mi = { 0 };
        mi.cbSize = sizeof(mi);
        mi.hKey = HKEY_CURRENT_USER;
        mi.uMax = (MAX_PRINTERS * MAX_MACHINES);
        mi.lpszSubKey = PRINTER_SUBKEY;

        _hPrinters = CreateMRUList(&mi);
        if (!_hPrinters)
            return E_OUTOFMEMORY;    
    }

    if (!_hShares) 
    {
        DWORD dwres = RegCreateKeyEx(HKEY_CURRENT_USER, SHARE_SUBKEY, 0, 
                                     TEXT(""), 0, 
                                     MAXIMUM_ALLOWED, 
                                     NULL, 
                                     &_hShares, 
                                     NULL);
        if (WN_SUCCESS != dwres)
        {
            return E_FAIL;
        }
    }

    return S_OK;                // success
}

                                            
// lets create a folder shortcut to the object

HRESULT CWorkgroupCrawler::_CreateShortcutToShare(LPCTSTR pszRemoteName)
{
    HRESULT hr = S_OK;
    TCHAR szTemp[MAX_PATH];
    BOOL fCreateLink = FALSE;
    HKEY hk = NULL;

    // the share information is stored in the registry as follows:
    //
    //  Shares
    //      Remote Name
    //          value: shortcut name
    //          value: last seen
    //
    // as we add each share we update the information stored in this list in 
    // the registry.  for each entry we have the shortcut name (so we can remove it)
    // and the time and date we last visited the share.

    // determine if we need to recreate the object?

    StrCpyN(szTemp, pszRemoteName+2, ARRAYSIZE(szTemp));    
    LPTSTR pszTemp = StrChr(szTemp, TEXT('\\'));
    if (pszTemp)
    {
        *pszTemp = TEXT('/');               // convert the \\...\... to .../...

        DWORD dwres = RegOpenKeyEx(_hShares, szTemp, 0, MAXIMUM_ALLOWED, &hk);
        if (WN_SUCCESS != dwres)
        {
            fCreateLink = TRUE;
            dwres = RegCreateKeyEx(_hShares, szTemp, 0, TEXT(""), 0, MAXIMUM_ALLOWED, NULL, &hk, NULL);
        }

        if (WN_SUCCESS == dwres)
        {
            // if we haven't already seen the link (eg. the key didn't exist in the registry
            // then lets create it now.

            if (fCreateLink)
            {
                // NOTE: we must use SHCoCreateInstance() here because we are being called from a thread
                //       that intentionally did not initialize COM (see comment in Update())

                IShellLink *psl;
                hr = SHCoCreateInstance(NULL, &CLSID_FolderShortcut, NULL, IID_PPV_ARG(IShellLink, &psl));
                if (SUCCEEDED(hr))
                {
                    psl->SetPath(pszRemoteName);                 // sotore the remote name, its kinda important

                    // get a description for the link, this comes either from the desktop.ini or the
                    // is a pretty version of teh remote name.

                    if (GetShellClassInfo(pszRemoteName, TEXT("InfoTip"), szTemp, ARRAYSIZE(szTemp)))
                    {
                        psl->SetDescription(szTemp);
                    }
                    else
                    {
                        StrCpyN(szTemp, pszRemoteName, ARRAYSIZE(szTemp));
                        PathMakePretty(szTemp);
                        psl->SetDescription(szTemp);
                    }

                    // some links (shared documents) can specify a shortcut name, if this is specified
                    // then use it, otherwise get a filename from the nethood folder (eg. foo on bah).
                    //
                    // we musst also record the name we save the shortcut as, this used when we
                    // age out the links from the hood folder.

                    if (!GetShellClassInfo(pszRemoteName, TEXT("NetShareDisplayName"), szTemp, ARRAYSIZE(szTemp)))
                    {
                        LPITEMIDLIST pidl;
                        hr = SHILCreateFromPath(pszRemoteName, &pidl, NULL);
                        if (SUCCEEDED(hr))
                        {
                            hr = SHGetNameAndFlags(pidl, SHGDN_NORMAL, szTemp, ARRAYSIZE(szTemp), NULL); 
                            ILFree(pidl);
                        }
                    }
                    else
                    {
                        hr = S_OK;
                    }

// should we find a unique name (daviddv)

                    if (SUCCEEDED(hr))
                    {
                        if (NO_ERROR == SHSetValue(hk, NULL, SHORTCUT_NAME, REG_SZ, szTemp, lstrlen(szTemp)*sizeof(TCHAR)))
                        {
                            hr = SaveShortcutInFolder(CSIDL_NETHOOD, szTemp, psl);
                        }
                        else
                        {
                            hr = E_FAIL;
                        }
                    }

                    psl->Release();
                }
            }

            // lets update the time we last saw the link into the registry - this is used for the clean up
            // pass we will perform.

            if (SUCCEEDED(hr))
            {
                FILETIME ft;
                GetSystemTimeAsFileTime(&ft);

                dwres = SHSetValue(hk, NULL, LAST_VISITED, REG_BINARY, (void*)&ft, sizeof(ft));
                hr = (NO_ERROR != dwres) ? E_FAIL:S_OK;
            }
        }

        if (hk)
            RegCloseKey(hk);
    }
    else
    {
        hr = E_UNEXPECTED;
    }
    
    return hr;
}


// walk the list of shares stored in the registry to determine which ones should be
// removed from the file system and the list.  all files older than 7 days need to
// be removed.

#define FILETIME_SECOND_OFFSET (LONGLONG)((1 * 10 * 1000 * (LONGLONG)1000))

void CWorkgroupCrawler::_AgeOutShares(BOOL fDeleteAll)
{
    FILETIME ft;
    ULARGE_INTEGER ulTime;
    DWORD index = 0;
    TCHAR szFilesToDelete[1024];
    int cchFilesToDelete = 0;

    GetSystemTimeAsFileTime(&ft);
    ulTime = *((ULARGE_INTEGER*)&ft);
    ulTime.QuadPart -= FILETIME_SECOND_OFFSET*((60*60*24)*2);

    SHQueryInfoKey(_hShares, &index, NULL, NULL, NULL);           // retrieve the count of the keys

    while (((LONG)(--index)) >= 0)
    {
        TCHAR szKey[MAX_PATH];
        DWORD cb = ARRAYSIZE(szKey);
        BOOL fRemoveKey = FALSE;

        if (WN_SUCCESS == SHEnumKeyEx(_hShares, index, szKey, &cb)) 
        {
            // we enumerated a key name, so lets open it so we can look around inside.

            HKEY hk;
            if (WN_SUCCESS == RegOpenKeyEx(_hShares, szKey, 0, MAXIMUM_ALLOWED, &hk))
            {
                ULARGE_INTEGER ulLastSeen;

                // when did we last crawl to this object, if it was less than the time we
                // have for our threshold, then we go through the process of cleaning up the
                // object.

                cb = sizeof(ulLastSeen);
                if (ERROR_SUCCESS == SHGetValue(hk, NULL, LAST_VISITED, NULL, (void*)&ulLastSeen, &cb))
                {
                    if (fDeleteAll || (ulLastSeen.QuadPart <= ulTime.QuadPart))
                    {
                        TCHAR szName[MAX_PATH];
                        cb = ARRAYSIZE(szName)*sizeof(TCHAR);
                        if (ERROR_SUCCESS == SHGetValue(hk, NULL, SHORTCUT_NAME, NULL, &szName, &cb))
                        {
                            TCHAR szPath[MAX_PATH];

                            // compose the path to the object we want to delete.  if the buffer
                            // is full (eg. this item would over run the size) then flush the
                            // buffer.

                            SHGetFolderPath(NULL, CSIDL_NETHOOD|CSIDL_FLAG_CREATE, NULL, 0, szPath);
                            PathAppend(szPath, szName);

                            if ((lstrlen(szPath)+cchFilesToDelete) >= ARRAYSIZE(szFilesToDelete))
                            {
                                SHFILEOPSTRUCT shfo = { NULL, FO_DELETE, szFilesToDelete, NULL, 
                                                        FOF_SILENT|FOF_NOCONFIRMATION|FOF_NOERRORUI, FALSE, NULL, NULL };

                                szFilesToDelete[cchFilesToDelete] = 0;            // double terminate
                                SHFileOperation(&shfo); 

                                cchFilesToDelete = 0;
                            }

                            // add this name to the buffer

                            StrCpyN(&szFilesToDelete[cchFilesToDelete], szPath, ARRAYSIZE(szFilesToDelete) - cchFilesToDelete);
                            cchFilesToDelete += lstrlen(szPath)+1;
                        }

                        fRemoveKey = TRUE;
                    }
                }

                RegCloseKey(hk);

                // we can only close the key once it has been closed

                if (fRemoveKey)
                    SHDeleteKey(_hShares, szKey);
            }                
        }
    }

    // are there any trailing files in the buffer?  if so then lets nuke them also

    if (cchFilesToDelete)
    {
        SHFILEOPSTRUCT shfo = { NULL, FO_DELETE, szFilesToDelete, NULL, 
                                FOF_SILENT|FOF_NOCONFIRMATION|FOF_NOERRORUI, FALSE, NULL, NULL };

        szFilesToDelete[cchFilesToDelete] = 0;            // double terminate
        SHFileOperation(&shfo); 
    }
}


// silently install printers we have discovered.   we have the remote name of the
// printer share, so we then call printui to perform the printer installation
// which it does without UI (hopefully).   

HANDLE CWorkgroupCrawler::_AddPrinterConnectionNoUI(LPCWSTR pszRemoteName, BOOL *pfInstalled)
{
    HANDLE hResult = NULL;

    if (!_hPrintUI)
        _hPrintUI = LoadLibrary(TEXT("printui.dll"));

    if (_hPrintUI)
    {
        ADDPRINTCONNECTIONNOUI apc = (ADDPRINTCONNECTIONNOUI)GetProcAddress(_hPrintUI, (LPCSTR)200);
        if (apc)
        {
            hResult = apc(pszRemoteName, pfInstalled);
        }
    }

    return hResult;
}

HRESULT CWorkgroupCrawler::_InstallPrinter(LPCTSTR pszRemoteName)
{
    if (-1 == FindMRUString(_hPrinters, pszRemoteName, NULL))
    {
        BOOL fInstalled;
        HANDLE hPrinter = _AddPrinterConnectionNoUI(pszRemoteName, &fInstalled);    
        if (hPrinter)
        {
            ClosePrinter(hPrinter);
            hPrinter = NULL;
        }
    }
    AddMRUString(_hPrinters, pszRemoteName);         // promote back to the top of the list
    return S_OK;
}


// check the counters, if we have max'd out then lets stop enumerating

BOOL CWorkgroupCrawler::_KeepGoing(int *pcMachines, int *pcShares, int *pcPrinters)
{
    if (pcMachines && (*pcMachines > MAX_MACHINES))
        return FALSE;
    if (pcShares && (*pcShares > MAX_SHARES))
        return FALSE;
    if (pcPrinters && (*pcPrinters > MAX_PRINTERS))
        return FALSE;

    return TRUE;
}

void CWorkgroupCrawler::_EnumResources(LPNETRESOURCE pnr, int *pcMachines, HDPA hdaShares, HDPA hdaPrinters)
{
    HANDLE hEnum = NULL;
    int cPrinters = 0;
    int cShares = 0;
    DWORD dwScope = RESOURCE_GLOBALNET;
    
    // if no net resource structure passed then lets enumerate the workgroup
    // (this is used for debugging)

    NETRESOURCE nr = { 0 };
    if (!pnr)
    {
        pnr = &nr;
        dwScope = RESOURCE_CONTEXT;
        nr.dwType = RESOURCETYPE_ANY;
        nr.dwUsage = RESOURCEUSAGE_CONTAINER;
    }

    // open the enumerator

    DWORD dwres = WNetOpenEnum(dwScope, RESOURCETYPE_ANY, 0, pnr, &hEnum);
    if (NO_ERROR == dwres)
    {
        NETRESOURCE *pnrBuffer = (NETRESOURCE*)SHAlloc(CB_WNET_BUFFER);        // avoid putting the buffer on the stack
        if (pnrBuffer)
        {
            while ((WN_SUCCESS == dwres) || (dwres == ERROR_MORE_DATA) && _KeepGoing(pcMachines, &cShares, &cPrinters))
            {
                DWORD cbEnumBuffer= CB_WNET_BUFFER;
                DWORD dwCount = -1;

                // enumerate the resources for this enum context and then lets
                // determine the objects which we should see.
            
                dwres = WNetEnumResource(hEnum, &dwCount, pnrBuffer, &cbEnumBuffer);
                if ((WN_SUCCESS == dwres) || (dwres == ERROR_MORE_DATA))
                {
                    DWORD index;
                    for (index = 0 ; (index != dwCount) && _KeepGoing(pcMachines, &cShares, &cPrinters) ; index++)
                    {    
                        LPNETRESOURCE pnr = &pnrBuffer[index];
                        LPTSTR pszRemoteName = pnr->lpRemoteName;

                        switch (pnr->dwDisplayType)
                        {
                            case RESOURCEDISPLAYTYPE_ROOT:      // ignore the entire network object
                            default:
                                break;

                            case RESOURCEDISPLAYTYPE_NETWORK:
                            {
                                // ensure that we only crawl the local network providers (eg. Windows Networking)
                                // crawling DAV, TSCLIENT etc can cause all sorts of random pop ups.                                    
                            
                                DWORD dwType, cbProviderType = sizeof(dwType);
                                if (WN_SUCCESS == WNetGetProviderType(pnr->lpProvider, &dwType))
                                {
                                    if (dwType == WNNC_NET_LANMAN)
                                    {
                                        _EnumResources(pnr, pcMachines, hdaShares, hdaPrinters);
                                    }
                                }
                                break;
                            }                                
                               
                            
                            case RESOURCEDISPLAYTYPE_DOMAIN:
                                _EnumResources(pnr, pcMachines, hdaShares, hdaPrinters);
                                break;
                        
                            case RESOURCEDISPLAYTYPE_SERVER:       
                            {
                                *pcMachines += 1;               // another machine found

                                if (!PathIsSlow(pszRemoteName, -1))
                                {
                                    SHCacheComputerDescription(pszRemoteName, pnr->lpComment);
                                    _EnumResources(pnr, pcMachines, hdaShares, hdaPrinters);
                                }

                                break;
                            }
                        
                            case RESOURCEDISPLAYTYPE_SHARE:                            
                            {
                                HDPA hdpa = NULL;
                                switch (pnr->dwType)
                                {
                                    case RESOURCETYPE_PRINT:
                                        cPrinters++;
                                        hdpa = hdaPrinters;
                                        break;

                                    case RESOURCETYPE_DISK:
                                        cShares++;
                                        hdpa = hdaShares;
                                        break;

                                    default:
                                        break;
                                }

                                if (hdpa)
                                {
                                    LPTSTR pszName = StrDup(pszRemoteName);
                                    if (pszName)
                                    {
                                        if (-1 == DPA_AppendPtr(hdpa, pszName))
                                        {
                                            LocalFree(pszName);
                                        }
                                    }
                                }
                                break;
                            }
                        }
                    } 
                }
            }            
            SHFree(pnrBuffer);
        }    

        WNetCloseEnum(hEnum);        
    }
}


// handle the clean up of the DPA's, either we are installing or 
// we are releasing objects.

int CALLBACK CWorkgroupCrawler::_DiscardCB(void *pvItem, void *pv)
{
    LPTSTR pszRemoteName = (LPTSTR)pvItem;
    LocalFree(pszRemoteName);
    return 1;
}

int CALLBACK CWorkgroupCrawler::_InstallPrinterCB(void *pvItem, void *pv)
{
    CWorkgroupCrawler* pnc = (CWorkgroupCrawler*)pv;
    if (pnc)
    {
        LPTSTR pszRemoteName = (LPTSTR)pvItem;
        pnc->_InstallPrinter(pszRemoteName);
    }
    return _DiscardCB(pvItem, pv);
}

int CALLBACK CWorkgroupCrawler::_InstallSharesCB(void *pvItem, void *pv)
{
    CWorkgroupCrawler* pnc = (CWorkgroupCrawler*)pv;
    if (pnc)
    {
        LPTSTR pszRemoteName = (LPTSTR)pvItem;
        pnc->_CreateShortcutToShare(pszRemoteName);
    }
    return _DiscardCB(pvItem, pv);
}

HRESULT CWorkgroupCrawler::Update(DWORD dwFlags)
{
    // don't crawl if we are logged in on a TS client, this will discover the shares and
    // printers local to the terminal server machine, rather than the ones local to the
    // users login domain - badness.

    if (SHGetMachineInfo(GMI_TSCLIENT))
        return S_OK;

    // by default we will only crawl if there isn't a RAS connection, therefore lets
    // check the status using RasEnumConnections.
    
    RASCONN rc = { 0 };
    DWORD cbConnections = sizeof(rc);
    DWORD cConnections = 0;

    rc.dwSize = sizeof(rc);
    if (!RasEnumConnections(&rc, &cbConnections, &cConnections) && cConnections)
        return S_OK;   

    // check to see if we are in a domain or not, if we are then we shouldn't crawl.  however
    // we do a provide a "WorkgroupOnly" policy which overrides this behaviour.  setting
    // this causes us to skip the check, and perform a CONTEXT ENUM below...

    BOOL fWorkgroupOnly = (_ppb ? SHPropertyBag_ReadBOOLDefRet(_ppb, L"WorkgroupOnly", FALSE):FALSE);
    if (IsOS(OS_DOMAINMEMBER) && !fWorkgroupOnly)
        return S_OK;   

    // populate the DPAs with shares and printer objects we find on the network, to
    // do this enumeration lets fake up a NETRESOURCE structure for entire network

    int cMachines = 0;
    HDPA hdaShares = DPA_Create(MAX_SHARES);
    HDPA hdaPrinters = DPA_Create(MAX_PRINTERS);

    if (hdaShares && hdaPrinters)
    {
        NETRESOURCE nr = { 0 };
        nr.dwDisplayType = RESOURCEDISPLAYTYPE_ROOT;
        nr.dwType = RESOURCETYPE_ANY;
        nr.dwUsage = RESOURCEUSAGE_CONTAINER;

        _EnumResources(fWorkgroupOnly ? NULL:&nr, &cMachines, hdaShares, hdaPrinters);
    }

    // now attempt to make connections to the shares and printers.  to do this
    // we need to look at the number of machines we have visited, if its less
    // than our threshold then we can install.

    if (SUCCEEDED(_GetMRUs()) && (cMachines < MAX_MACHINES))
    {
        DPA_DestroyCallback(hdaShares, _InstallSharesCB, this);
        DPA_DestroyCallback(hdaPrinters, _InstallPrinterCB, this);
        _AgeOutShares(FALSE);
    }
    else
    {
        DPA_DestroyCallback(hdaShares, _DiscardCB, this);
        DPA_DestroyCallback(hdaPrinters, _DiscardCB, this);
    }

    return S_OK;
}



// this is the main crawler object, from this we create the protocol specific
// crawlers which handle enumerating the resources for the various network types.

#define CRAWLER_SUBKEY     \
            TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\NetworkCrawler\\Objects")

class CNetCrawler : public INetCrawler
{
public:
    CNetCrawler();

    // IUnknown
    STDMETHOD(QueryInterface)(REFIID riid, void **ppv);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

    // INetCrawler
    STDMETHOD(Update)(DWORD dwFlags);

private:
    static DWORD CALLBACK s_DoCrawl(void* pv);
    DWORD _DoCrawl();

    LONG _cRef;    
    LONG _cUpdateLock;              // > 0 then we are already spinning

    DWORD _dwFlags;                 // flags from update - passed to each of the crawler sub-objects
};

CNetCrawler* g_pnc = NULL;          // there is a single instance of this object


// construction / IUnknown

CNetCrawler::CNetCrawler() :
    _cRef(1)
{
}

STDMETHODIMP CNetCrawler::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = 
    {
        QITABENT(CNetCrawler, INetCrawler),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CNetCrawler::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CNetCrawler::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    ENTERCRITICAL;
    g_pnc = NULL;
    LEAVECRITICAL;
    
    delete this;
    return 0;
}


// there is a single instance of the object, therefore in a critical section
// lets check to see if the global exists, if so then QI it, otherwise
// create a new one and QI that instead.

STDAPI CNetCrawler_CreateInstance(IUnknown* punkOuter, REFIID riid, void** ppv)
{
    HRESULT hr = E_OUTOFMEMORY;
    ENTERCRITICAL;
    if (g_pnc)
    {
        hr = g_pnc->QueryInterface(riid, ppv);
    }
    else
    {
        g_pnc = new CNetCrawler();            
        if (g_pnc)
        {
            hr = g_pnc->QueryInterface(riid, ppv);
            g_pnc->Release();
        }
    }
    LEAVECRITICAL;
    return hr;
}


// this object has a execution count to inidicate if we are already crawling.  
// only if the count is 0 when the ::Update method is called, will create a thread
// which inturn will create each of the crawler objects and allow them to
// do their enumeration.

DWORD CALLBACK CNetCrawler::s_DoCrawl(void* pv)
{
    CNetCrawler *pnc = (CNetCrawler*)pv;
    return pnc->_DoCrawl();
}

DWORD CNetCrawler::_DoCrawl()
{
    // enumrate all the keys under the crawler sub-key, from that we can then
    // create the individual crawler objects.

    HKEY hk;
    DWORD dwres = RegOpenKeyEx(HKEY_LOCAL_MACHINE, CRAWLER_SUBKEY, 0, KEY_READ, &hk);
    if (WN_SUCCESS == dwres)
    {
        DWORD index = 0;
        SHQueryInfoKey(hk, &index, NULL, NULL, NULL);           // retrieve the count of the keys

        while (((LONG)(--index)) >= 0)
        {
            TCHAR szKey[MAX_PATH];
            DWORD cb = ARRAYSIZE(szKey);
            if (WN_SUCCESS == SHEnumKeyEx(hk, index, szKey, &cb)) 
            {
                // given the keyname, create a property bag so we can access
                
                IPropertyBag *ppb;
                HRESULT hr = SHCreatePropertyBagOnRegKey(hk, szKey, STGM_READ, IID_PPV_ARG(IPropertyBag, &ppb));
                if (SUCCEEDED(hr))
                {
                    // we have a property bag mapped to the registry for the items we need
                    // to read back, so lets get the CLSID and create a crawler from it.

                    CLSID clsid;
                    hr = SHPropertyBag_ReadGUID(ppb, L"CLSID", &clsid);
                    if (SUCCEEDED(hr))
                    {
                        INetCrawler *pnc;
                        hr = SHCoCreateInstance(NULL, &clsid, NULL, IID_PPV_ARG(INetCrawler, &pnc));
                        if (SUCCEEDED(hr))
                        {
                            // if the crawler supports IPersistPropertyBag then lets allow it
                            // to slurp its settings into from the registry.
                            SHLoadFromPropertyBag(pnc, ppb);

                            // allow it to update and load.
    
                            pnc->Update(_dwFlags);          // we don't care about the failure
                            pnc->Release();
                        }
                    }
                    ppb->Release();
                }
            }
        }

        RegCloseKey(hk);
    }

    InterlockedDecrement(&_cUpdateLock);           // release the lock that signifies that we're updating:
    Release();                                       
    return 0;
}

STDMETHODIMP CNetCrawler::Update(DWORD dwFlags)
{
    // we either have policy defined to disable the crawler, or the
    // users has selected that they don't want to be able to auto discover
    // the world. 
    
    SHELLSTATE ss;
    SHGetSetSettings(&ss, SSF_NONETCRAWLING, FALSE);
    if (ss.fNoNetCrawling || SHRestricted(REST_NONETCRAWL))
    {
        return S_OK;
    }

    // increase the lock, if its >0 then we should not bother crawling again
    // as we already have it covered, therefore decrease the lock counter.
    //
    // if the lock is ==0 then create the thread which will do the crawling
    // and inturn create the objects.

    HRESULT hr = S_OK;
    if (InterlockedIncrement(&_cUpdateLock) == 1)
    {
        _dwFlags = dwFlags; // store the flags for use later

        AddRef();
        if (!SHCreateThread(s_DoCrawl, (void*)this, CTF_COINIT, NULL))
        {
            Release();
            hr = E_FAIL;
        }
    }
    else
    {
        InterlockedDecrement(&_cUpdateLock);
    }
    return hr;
}



// helper function that will invoke the net crawler to perform a async refresh,
// to ensure that we don't block we will create a thread which inturn will CoCreate
// the net crawler and then call its refresh method.

DWORD _RefreshCrawlerThreadProc(void *pv)
{
    INetCrawler *pnc;
    if (SUCCEEDED(CoCreateInstance(CLSID_NetCrawler, NULL, CLSCTX_LOCAL_SERVER, IID_PPV_ARG(INetCrawler, &pnc))))
    {
        pnc->Update(SNCF_REFRESHLIST);
        pnc->Release();
    }
    return 0;
}
                
STDAPI_(void) RefreshNetCrawler()
{
    SHCreateThread(_RefreshCrawlerThreadProc, NULL, CTF_COINIT, NULL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\netfldr.cpp ===
#include "shellprv.h"
#include "caggunk.h"
#include "views.h"
#include "ids.h"
#include "shitemid.h"
#include "fstreex.h"
#include "clsobj.h"
#include "datautil.h"
#include "winnetp.h"    // RESOURCE_SHAREABLE
#include "prop.h"
#include "infotip.h"
#include "basefvcb.h"
#include "netview.h"
#include "printer.h"
#include "fsdata.h"
#include "idldrop.h"
#include "enumidlist.h"
#include "util.h"
#include <webvw.h>


#define WNNC_NET_LARGEST WNNC_NET_SYMFONET


HRESULT CNetRootDropTarget_CreateInstance(HWND hwnd, LPCITEMIDLIST pidl, IDropTarget **ppdropt);

class CNetData : public CFSIDLData
{
public:
    CNetData(LPCITEMIDLIST pidlFolder, UINT cidl, LPCITEMIDLIST apidl[]): CFSIDLData(pidlFolder, cidl, apidl, NULL) { };

    // IDataObject methods overwrite
    STDMETHODIMP GetData(FORMATETC *pFmtEtc, STGMEDIUM *pstm);
    STDMETHODIMP QueryGetData(FORMATETC *pFmtEtc);

protected:
    STDMETHODIMP GetHDrop(FORMATETC *pformatetcIn, STGMEDIUM *pmedium);
};


// {22BEB58B-0794-11d2-A4AA-00C04F8EEB3E}
const GUID CLSID_CNetFldr = { 0x22beb58b, 0x794, 0x11d2, 0xa4, 0xaa, 0x0, 0xc0, 0x4f, 0x8e, 0xeb, 0x3e };

// idlist.c
STDAPI_(void) StrRetFormat(STRRET *pStrRet, LPCITEMIDLIST pidlRel, LPCTSTR pszTemplate, LPCTSTR pszAppend);

// in stdenum.cpp
STDAPI_(void *) CStandardEnum_CreateInstance(REFIID riid, BOOL bInterfaces, int cElement, int cbElement, void *rgElements,
                 void (WINAPI * pfnCopyElement)(void *, const void *, DWORD));

// is a \\server\printer object
BOOL _IsPrintShare(LPCIDNETRESOURCE pidn)
{
    return NET_GetDisplayType(pidn) == RESOURCEDISPLAYTYPE_SHARE && 
           NET_GetType(pidn) == RESOURCETYPE_PRINT;
}


// column information

enum
{
    ICOL_NAME = 0,
    ICOL_COMMENT,
    ICOL_COMPUTERNAME,
    ICOL_NETWORKLOCATION
};

const COLUMN_INFO s_net_cols[] = 
{
    DEFINE_COL_STR_ENTRY(SCID_NAME,             30, IDS_NAME_COL),
    DEFINE_COL_STR_ENTRY(SCID_Comment,          30, IDS_EXCOL_COMMENT),
    DEFINE_COL_STR_ENTRY(SCID_COMPUTERNAME,     30, IDS_EXCOL_COMPUTER),
    DEFINE_COL_STR_ENTRY(SCID_NETWORKLOCATION,  30, IDS_NETWORKLOCATION),
};

#define MAX_ICOL_NETFOLDER          (ICOL_COMMENT+1)
#define MAX_ICOL_NETROOT            (ICOL_NETWORKLOCATION+1)

STDAPI CNetwork_DFMCallBackBG(IShellFolder *psf, HWND hwnd, IDataObject *pdtobj, UINT uMsg, WPARAM wParam, LPARAM lParam);

class CNetFolderViewCB;
class CNetFolderEnum;

class CNetFolder : public CAggregatedUnknown, 
                   public IShellFolder2, 
                   public IPersistFolder3,
                   public IShellIconOverlay
{
    friend CNetFolderViewCB;
    friend CNetFolderEnum;

public:
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void ** ppvObj)
                { return CAggregatedUnknown::QueryInterface(riid, ppvObj); };
    STDMETHODIMP_(ULONG) AddRef(void) 
                { return CAggregatedUnknown::AddRef(); };
    STDMETHODIMP_(ULONG) Release(void) 
                { return CAggregatedUnknown::Release(); };

    // IShellFolder
    STDMETHODIMP ParseDisplayName(HWND hwnd, LPBC pbc, LPOLESTR lpszDisplayName,
                                  ULONG* pchEaten, LPITEMIDLIST* ppidl, ULONG* pdwAttributes);
    STDMETHODIMP EnumObjects(HWND hwnd, DWORD grfFlags, IEnumIDList ** ppenumIDList);
    STDMETHODIMP BindToObject(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv);
    STDMETHODIMP BindToStorage(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppvObj);
    STDMETHODIMP CompareIDs(LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);
    STDMETHODIMP CreateViewObject(HWND hwndOwner, REFIID riid, void **ppv);
    STDMETHODIMP GetAttributesOf(UINT cidl, LPCITEMIDLIST* apidl, ULONG* rgfInOut);
    STDMETHODIMP GetUIObjectOf(HWND hwndOwner, UINT cidl, LPCITEMIDLIST* apidl,
                               REFIID riid, UINT* prgfInOut, void **ppv);
    STDMETHODIMP GetDisplayNameOf(LPCITEMIDLIST pidl, DWORD uFlags, LPSTRRET lpName);
    STDMETHODIMP SetNameOf(HWND hwnd, LPCITEMIDLIST pidl, LPCOLESTR lpszName, DWORD uFlags,
                           LPITEMIDLIST* ppidlOut);

    // IShellFolder2
    STDMETHODIMP GetDefaultSearchGUID(GUID *pGuid);
    STDMETHODIMP EnumSearches(IEnumExtraSearch **ppenum);
    STDMETHODIMP GetDefaultColumn(DWORD dwRes, ULONG* pSort, ULONG* pDisplay);
    STDMETHODIMP GetDefaultColumnState(UINT iColumn, DWORD* pbState)
        { return _GetDefaultColumnState(MAX_ICOL_NETFOLDER, iColumn, pbState); }
    STDMETHODIMP GetDetailsEx(LPCITEMIDLIST pidl, const SHCOLUMNID* pscid, VARIANT* pv);
    STDMETHODIMP GetDetailsOf(LPCITEMIDLIST pidl, UINT iColumn, SHELLDETAILS* pDetails)
        { return _GetDetailsOf(MAX_ICOL_NETFOLDER, pidl, iColumn, pDetails); }
    STDMETHODIMP MapColumnToSCID(UINT iColumn, SHCOLUMNID* pscid)
        { return _MapColumnToSCID(MAX_ICOL_NETFOLDER, iColumn, pscid); }

    // IPersist
    STDMETHODIMP GetClassID(CLSID* pClassID);
    // IPersistFolder
    STDMETHODIMP Initialize(LPCITEMIDLIST pidl);
    // IPersistFolder2
    STDMETHODIMP GetCurFolder(LPITEMIDLIST* ppidl);
    // IPersistFolder3
    STDMETHOD(InitializeEx)(IBindCtx *pbc, LPCITEMIDLIST pidlRoot, const PERSIST_FOLDER_TARGET_INFO *ppfai);
    STDMETHOD(GetFolderTargetInfo)(PERSIST_FOLDER_TARGET_INFO *ppfai);

    // *** IShellIconOverlay methods***
    STDMETHOD(GetOverlayIndex)(LPCITEMIDLIST pidl, int * pIndex);
    STDMETHOD(GetOverlayIconIndex)(LPCITEMIDLIST pidl, int * pIconIndex);

protected:
    CNetFolder(IUnknown* punkOuter);
    ~CNetFolder();

    virtual HRESULT v_GetFileFolder(IShellFolder2 **ppsfFiles) 
                { *ppsfFiles = NULL; return E_NOTIMPL; };

    // used by the CAggregatedUnknown stuff
    HRESULT v_InternalQueryInterface(REFIID riid, void **ppvObj);

    HRESULT _OpenKeys(LPCIDNETRESOURCE pidn, HKEY ahkeys[]);
    LPCTSTR _GetProvider(LPCIDNETRESOURCE pidn, IBindCtx *pbc, LPTSTR pszProvider, UINT cchProvider);
    DWORD _OpenEnum(HWND hwnd, DWORD grfFlags, LPNETRESOURCE pnr, HANDLE *phEnum);

    static HRESULT _CreateNetIDList(LPIDNETRESOURCE pidnIn, 
                                    LPCTSTR pszName, LPCTSTR pszProvider, LPCTSTR pszComment,
                                    LPITEMIDLIST *ppidl);

    static HRESULT _NetResToIDList(NETRESOURCE *pnr, 
                                   BOOL fKeepNullRemoteName, 
                                   BOOL fKeepProviderName, 
                                   BOOL fKeepComment, 
                                   LPITEMIDLIST *ppidl);

    static HRESULT _CreateEntireNetwork(LPITEMIDLIST *ppidl);

    static HRESULT _CreateEntireNetworkFullIDList(LPITEMIDLIST *ppidl);

    LPTSTR _GetNameForParsing(LPCWSTR pwszName, LPTSTR pszBuffer, INT cchBuffer, LPTSTR *ppszRegItem);
    HRESULT _ParseRest(LPBC pbc, LPCWSTR pszRest, LPITEMIDLIST* ppidl, DWORD* pdwAttributes);
    HRESULT _AddUnknownIDList(DWORD dwDisplayType, LPITEMIDLIST *ppidl);
    HRESULT _ParseSimple(LPBC pbc, LPWSTR pszName, LPITEMIDLIST* ppidl, DWORD* pdwAttributes);
    HRESULT _NetResToIDLists(NETRESOURCE *pnr, DWORD dwbuf, LPITEMIDLIST *ppidl);

    HRESULT _ParseNetName(HWND hwnd, LPBC pbc, LPCWSTR pwszName, ULONG* pchEaten, 
                              LPITEMIDLIST* ppidl, DWORD* pdwAttributes);
    LONG _GetFilePIDLType(LPCITEMIDLIST pidl);
    LPITEMIDLIST _AddProviderToPidl(LPITEMIDLIST pidl, LPCTSTR lpProvider);
    BOOL _MakeStripToLikeKinds(UINT *pcidl, LPCITEMIDLIST **papidl, BOOL fNetObjects);
    HRESULT _GetDefaultColumnState(UINT cColumns, UINT iColumn, DWORD* pdwState);
    HRESULT _GetDetailsOf(UINT cColumns, LPCITEMIDLIST pidl, UINT iColumn, SHELLDETAILS *pDetails);
    HRESULT _MapColumnToSCID(UINT cColumns, UINT iColumn, SHCOLUMNID* pscid);

    LPFNDFMCALLBACK _GetCallbackType(LPCIDNETRESOURCE pidn)
                        { return _IsPrintShare(pidn) ? &PrinterDFMCallBack : &DFMCallBack; };

    static HRESULT CALLBACK _AttributesCallbackRoot(IShellFolder2* psf, LPCITEMIDLIST pidl, ULONG* prgfInOut);

    LPITEMIDLIST _pidl;
    LPITEMIDLIST _pidlTarget; // pidl of where the folder is in the namespace
    LPCIDNETRESOURCE _pidnForProvider; // optional provider for this container...
    LPTSTR _pszResName;      // optional resource name of this container
    UINT _uDisplayType;      // display type of the folder
    IShellFolder2* _psfFiles;
    IUnknown* _punkReg;
    
private:
    HRESULT _CreateInstance(LPCITEMIDLIST pidlAbs, LPCITEMIDLIST pidlTarget,
                                           UINT uDisplayType,                                            
                                           LPCIDNETRESOURCE pidnForProvider, LPCTSTR pszResName, 
                                           REFIID riid, void **ppv);
    friend HRESULT CNetwork_DFMCallBackBG(IShellFolder *psf, HWND hwnd,
                                          IDataObject *pdtobj, UINT uMsg, 
                                          WPARAM wParam, LPARAM lParam);
    static DWORD CALLBACK _PropertiesThreadProc(void *pv);
    static HRESULT DFMCallBack(IShellFolder* psf, HWND hwnd,
                               IDataObject* pdtobj, UINT uMsg, 
                               WPARAM wParam, LPARAM lParam);
    static HRESULT PrinterDFMCallBack(IShellFolder* psf, HWND hwnd,
                                      IDataObject* pdtobj, UINT uMsg, 
                                      WPARAM wParam, LPARAM lParam);
    static HRESULT CALLBACK _AttributesCallback(IShellFolder2* psf, LPCITEMIDLIST pidl, ULONG* prgfInOut);

    BOOL _GetPathForShare(LPCIDNETRESOURCE pidn, LPTSTR pszPath);
    HRESULT _GetPathForItem(LPCIDNETRESOURCE pidn, LPTSTR pszPath);
    HRESULT _GetPathForItemW(LPCIDNETRESOURCE pidn, LPWSTR pszPath);
    HRESULT _CreateFolderForItem(LPBC pbc, LPCITEMIDLIST pidl, LPCITEMIDLIST pidlTarget, LPCIDNETRESOURCE pidnForProvider, REFIID riid, void **ppv);
    HRESULT _GetFormatName(LPCIDNETRESOURCE pidn, STRRET* pStrRet);
    HRESULT _GetIconOverlayInfo(LPCIDNETRESOURCE pidn, int *pIndex, DWORD dwFlags);
    HKEY _OpenProviderTypeKey(LPCIDNETRESOURCE pidn);
    HKEY _OpenProviderKey(LPCIDNETRESOURCE pidn);
    static void WINAPI _CopyEnumElement(void* pDest, const void* pSource, DWORD dwSize);
    HRESULT _GetNetResource(LPCIDNETRESOURCE pidn, NETRESOURCEW* pnr, int cb);
};  


class CNetRootFolder : public CNetFolder
{
public:
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void ** ppvObj)
                { return CNetFolder::QueryInterface(riid, ppvObj); };
    STDMETHODIMP_(ULONG) AddRef(void)
                { return CNetFolder::AddRef(); };
    STDMETHODIMP_(ULONG) Release(void)
                { return CNetFolder::Release(); };

    // IShellFolder
    STDMETHODIMP ParseDisplayName(HWND hwnd, LPBC pbc, LPOLESTR lpszDisplayName,
                                  ULONG* pchEaten, LPITEMIDLIST* ppidl, ULONG* pdwAttributes);
    STDMETHODIMP EnumObjects(HWND hwnd, DWORD grfFlags, IEnumIDList ** ppenumIDList);
    STDMETHODIMP BindToObject(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv);
    STDMETHODIMP BindToStorage(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppvObj)
        { return CNetFolder::BindToStorage(pidl, pbc, riid, ppvObj); };
    STDMETHODIMP CompareIDs(LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);
    STDMETHODIMP CreateViewObject(HWND hwndOwner, REFIID riid, void **ppv);
    STDMETHODIMP GetAttributesOf(UINT cidl, LPCITEMIDLIST* apidl, ULONG* rgfInOut);
    STDMETHODIMP GetUIObjectOf(HWND hwndOwner, UINT cidl, LPCITEMIDLIST* apidl,
                               REFIID riid, UINT* prgfInOut, void **ppv);
    STDMETHODIMP GetDisplayNameOf(LPCITEMIDLIST pidl, DWORD uFlags, LPSTRRET lpName);
    STDMETHODIMP SetNameOf(HWND hwnd, LPCITEMIDLIST pidl, LPCOLESTR lpszName, DWORD uFlags,
                           LPITEMIDLIST* ppidlOut);

    // IShellFolder2
    STDMETHODIMP GetDefaultSearchGUID(GUID *pGuid)
        { return CNetFolder::GetDefaultSearchGUID(pGuid); };
    STDMETHODIMP EnumSearches(IEnumExtraSearch **ppenum)
        { return CNetFolder::EnumSearches(ppenum); };
    STDMETHODIMP GetDefaultColumn(DWORD dwRes, ULONG* pSort, ULONG* pDisplay)
        { return CNetFolder::GetDefaultColumn(dwRes, pSort, pDisplay); };
    STDMETHODIMP GetDefaultColumnState(UINT iColumn, DWORD* pbState)
        { return _GetDefaultColumnState(MAX_ICOL_NETROOT, iColumn, pbState); }       // +1 for <= check
    STDMETHODIMP GetDetailsEx(LPCITEMIDLIST pidl, const SHCOLUMNID* pscid, VARIANT* pv)
        { return CNetFolder::GetDetailsEx(pidl, pscid, pv); };
    STDMETHODIMP GetDetailsOf(LPCITEMIDLIST pidl, UINT iColumn, SHELLDETAILS* pDetails)
        { return _GetDetailsOf(MAX_ICOL_NETROOT, pidl, iColumn, pDetails); };
    STDMETHODIMP MapColumnToSCID(UINT iColumn, SHCOLUMNID* pscid)
        { return _MapColumnToSCID(MAX_ICOL_NETROOT, iColumn, pscid); }

    // IPersist
    STDMETHODIMP GetClassID(CLSID* pClassID);

    // IPersistFolder
    STDMETHODIMP Initialize(LPCITEMIDLIST pidl);

    // IPersistFolder2
    STDMETHODIMP GetCurFolder(LPITEMIDLIST* ppidl) { return CNetFolder::GetCurFolder(ppidl); };

    // IPersistFolder3
    STDMETHOD(InitializeEx)(IBindCtx *pbc, LPCITEMIDLIST pidlRoot, const PERSIST_FOLDER_TARGET_INFO *ppfai)
        { return CNetFolder::InitializeEx(pbc, pidlRoot, ppfai); };
    STDMETHOD(GetFolderTargetInfo)(PERSIST_FOLDER_TARGET_INFO *ppfai)
        { return CNetFolder::GetFolderTargetInfo(ppfai); };

protected:
    CNetRootFolder(IUnknown* punkOuter) : CNetFolder(punkOuter) { };
    ~CNetRootFolder() { ASSERT(NULL != _spThis); _spThis = NULL; };

    BOOL v_HandleDelete(PLONG pcRef);
    HRESULT v_GetFileFolder(IShellFolder2 **ppsfFiles);

private:
    HRESULT _TryParseEntireNet(HWND hwnd, LPBC pbc, WCHAR *pwszName, LPITEMIDLIST *ppidl, DWORD *pdwAttributes);

    friend HRESULT CNetwork_CreateInstance(IUnknown* punkOuter, REFIID riid, void **ppv);
    static CNetRootFolder* _spThis;
};  

class CNetFolderViewCB : public CBaseShellFolderViewCB
{
public:
    CNetFolderViewCB(CNetFolder *pFolder);

    // IShellFolderViewCB
    STDMETHODIMP RealMessage(UINT uMsg, WPARAM wParam, LPARAM lParam);

private:
    ~CNetFolderViewCB();
    HRESULT OnINVOKECOMMAND(DWORD pv, UINT wP);
    HRESULT OnGETHELPTEXT(DWORD pv, UINT wPl, UINT wPh, LPTSTR lP);
    HRESULT OnREFRESH(DWORD pv, BOOL fPreRefresh);
    HRESULT OnDELAYWINDOWCREATE(DWORD pv, HWND hwnd);
    HRESULT OnGETCOLSAVESTREAM(DWORD pv, WPARAM wP, IStream **pps);
    HRESULT OnDEFITEMCOUNT(DWORD pv, UINT *pnItems);
    HRESULT OnGetZone(DWORD pv, DWORD * pdwZone);
    HRESULT OnEnumeratedItems(DWORD pv, UINT celt, LPCITEMIDLIST *rgpidl);
    HRESULT OnDefViewMode(DWORD pv, FOLDERVIEWMODE* pvm);
    HRESULT OnGetDeferredViewSettings(DWORD pv, SFVM_DEFERRED_VIEW_SETTINGS* pSettings);

    BOOL _GetProviderKeyName(LPTSTR pszName, UINT uNameLen);
    BOOL _EntireNetworkAvailable();

    CNetFolder *_pFolder;
    UINT _cItems;

    // Web View implementation
    HRESULT OnGetWebViewLayout(DWORD pv, UINT uViewMode, SFVM_WEBVIEW_LAYOUT_DATA* pData);
    HRESULT OnGetWebViewContent(DWORD pv, SFVM_WEBVIEW_CONTENT_DATA* pData);
    HRESULT OnGetWebViewTasks(DWORD pv, SFVM_WEBVIEW_TASKSECTION_DATA* pTasks);
public:
    static HRESULT _CanShowHNW(IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState);    
    static HRESULT _CanViewComputersNearMe(IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState);
    static HRESULT _CanSearchActiveDirectory(IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState);

    static HRESULT _DoRunDll32(LPTSTR pszParameters); // helper to do a ShellExecute of RunDll32.

    static HRESULT _OnViewNetConnections(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc);
    static HRESULT _OnAddNetworkPlace(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc)
        { return _DoRunDll32(TEXT("netplwiz.dll,AddNetPlaceRunDll")); }
    static HRESULT _OnHomeNetworkWizard(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc)
        { return _DoRunDll32(TEXT("hnetwiz.dll,HomeNetWizardRunDll")); }
    static HRESULT _OnViewComputersNearMe(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc);
    static HRESULT _OnSearchActiveDirectory(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc)
        { return _DoRunDll32(TEXT("dsquery.dll,OpenQueryWindow")); }
};

#define NETFLDR_EVENTS \
            SHCNE_RENAMEITEM | SHCNE_RENAMEFOLDER | \
            SHCNE_CREATE | SHCNE_DELETE | SHCNE_UPDATEDIR | SHCNE_UPDATEITEM | \
            SHCNE_MKDIR | SHCNE_RMDIR

CNetFolderViewCB::CNetFolderViewCB(CNetFolder *pFolder) : 
    CBaseShellFolderViewCB(pFolder->_pidl, NETFLDR_EVENTS), _pFolder(pFolder)
{
    _pFolder->AddRef();
}

CNetFolderViewCB::~CNetFolderViewCB()
{
    _pFolder->Release();
}

HRESULT CNetFolderViewCB::OnINVOKECOMMAND(DWORD pv, UINT wP)
{
    return CNetwork_DFMCallBackBG(_pFolder, _hwndMain, NULL, DFM_INVOKECOMMAND, wP, 0);
}

HRESULT CNetFolderViewCB::OnGETHELPTEXT(DWORD pv, UINT wPl, UINT wPh, LPTSTR lP)
{
    return CNetwork_DFMCallBackBG(_pFolder, _hwndMain, NULL, DFM_GETHELPTEXTW, MAKEWPARAM(wPl, wPh), (LPARAM)lP);
}

HRESULT CNetFolderViewCB::OnREFRESH(DWORD pv, BOOL fPreRefresh)
{
    if (fPreRefresh)
    {
        RefreshNetCrawler();
    }
    return S_OK;
}

HRESULT CNetFolderViewCB::OnDELAYWINDOWCREATE(DWORD pv, HWND hwnd)
{
    // only do delay window processing in the net root.

    if (RESOURCEDISPLAYTYPE_GENERIC == _pFolder->_uDisplayType) // MyNetPlaces
    {
        RefreshNetCrawler();
    }

    return S_OK;
}

HRESULT CNetFolderViewCB::OnGETCOLSAVESTREAM(DWORD pv, WPARAM wP, IStream **pps)
{
    LPCTSTR pszValName;

    switch (_pFolder->_uDisplayType) 
    {
    case RESOURCEDISPLAYTYPE_DOMAIN:
        pszValName = TEXT("NetDomainColsX");
        break;

    case RESOURCEDISPLAYTYPE_SERVER:
        pszValName = TEXT("NetServerColsX");
        break;

    default:
        return E_FAIL;
    }

    *pps = OpenRegStream(HKEY_CURRENT_USER, REGSTR_PATH_EXPLORER, pszValName, (DWORD) wP);
    return *pps ? S_OK : E_FAIL;
}

// HRESULT CNetFolderViewCB::OnGetZone(DWORD pv, DWORD * pdwZone);

HRESULT CNetFolderViewCB::OnEnumeratedItems(DWORD pv, UINT celt, LPCITEMIDLIST *rgpidl)
{
    _cItems = celt;
    return S_OK;
}

HRESULT CNetFolderViewCB::OnDefViewMode(DWORD pv, FOLDERVIEWMODE* pvm)
{
    if (_cItems < DEFVIEW_FVM_MANY_CUTOFF)
        *pvm = FVM_TILE;
    else
        *pvm = FVM_ICON; // used to pick icon only for My Net Places ((_pFolder->_uDisplayType == RESOURCEDISPLAYTYPE_GENERIC))

    return S_OK;
}

HRESULT CNetFolderViewCB::OnGetDeferredViewSettings(DWORD pv, SFVM_DEFERRED_VIEW_SETTINGS* pSettings)
{
    OnDefViewMode(pv, &pSettings->fvm);

    // if this is the root folder then lets sort accordingly
    if (_pFolder->_uDisplayType == RESOURCEDISPLAYTYPE_GENERIC)
    {
        pSettings->fGroupView = TRUE;
        pSettings->uSortCol = ICOL_NETWORKLOCATION;
        pSettings->iSortDirection = 1;
    }
   
    return S_OK;
}

HRESULT CNetFolderViewCB::OnGetZone(DWORD pv, DWORD * pdwZone)
{
    if (pdwZone)
        *pdwZone = URLZONE_INTRANET; // default is "Local Intranet"
    return S_OK;    
}


HRESULT CNetFolderViewCB::OnGetWebViewLayout(DWORD pv, UINT uViewMode, SFVM_WEBVIEW_LAYOUT_DATA* pData)
{
    ZeroMemory(pData, sizeof(*pData));
    pData->dwLayout = SFVMWVL_NORMAL;
    return S_OK;
}

// HNW is shown on X86 pro or personal workgroup only
HRESULT CNetFolderViewCB::_CanShowHNW(IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState)
{
#ifdef _WIN64
    *puisState = UIS_DISABLED;
    return S_OK;
#else
    if (IsOS(OS_ANYSERVER))
        *puisState = UIS_DISABLED;  // Server-type OS
    else
        *puisState = !IsOS(OS_DOMAINMEMBER) ? UIS_ENABLED : UIS_DISABLED;
    return S_OK;
#endif
}

HRESULT CNetFolderViewCB::_CanViewComputersNearMe(IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState)
{
    if (!SHRestricted(REST_NOCOMPUTERSNEARME))
        *puisState = !IsOS(OS_DOMAINMEMBER) ? UIS_ENABLED : UIS_DISABLED;
    else
        *puisState = UIS_DISABLED;
    return S_OK;
}

HRESULT CNetFolderViewCB::_CanSearchActiveDirectory(IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState)
{
    if (IsOS(OS_DOMAINMEMBER) && (GetEnvironmentVariable(TEXT("USERDNSDOMAIN"), NULL, 0) > 0))
        *puisState = UIS_ENABLED;
    else
        *puisState = UIS_DISABLED;

    return S_OK;
}

HRESULT CNetFolderViewCB::_OnViewNetConnections(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc)
{
    LPITEMIDLIST pidl;
    HRESULT hr = SHGetFolderLocation(NULL, CSIDL_CONNECTIONS, NULL, 0, &pidl); 
    if (SUCCEEDED(hr))
    {
        hr = ((CNetFolderViewCB*)(void*)pv)->_BrowseObject(pidl);
        ILFree(pidl);
    }
    return hr;
}

HRESULT CNetFolderViewCB::_DoRunDll32(LPTSTR pszParameters)
{
    SHELLEXECUTEINFO sei = {0};
    sei.cbSize = sizeof(sei);
    sei.lpFile = TEXT("rundll32.exe");
    sei.lpParameters = pszParameters;
    sei.nShow = SW_SHOWNORMAL;

    return ShellExecuteEx(&sei) ? S_OK : E_FAIL;
}

HRESULT CNetFolderViewCB::_OnViewComputersNearMe(IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc)
{
    LPITEMIDLIST pidl;
    HRESULT hr = SHGetFolderLocation(NULL, CSIDL_COMPUTERSNEARME, NULL, 0, &pidl);
    if (SUCCEEDED(hr))
    {
        hr = ((CNetFolderViewCB*)(void*)pv)->_BrowseObject(pidl);
        ILFree(pidl);
    }
    return hr;
}

const WVTASKITEM c_MyNetPlacesTaskHeader = WVTI_HEADER(L"shell32.dll", IDS_HEADER_MYNETPLACES, IDS_HEADER_MYNETPLACES_TT);
const WVTASKITEM c_MyNetPlacesTaskList[] =
{
    WVTI_ENTRY_ALL(CLSID_NULL, L"shell32.dll", IDS_TASK_ADDNETWORKPLACE,    IDS_TASK_ADDNETWORKPLACE_TT,    IDI_TASK_ADDNETWORKPLACE,    NULL, CNetFolderViewCB::_OnAddNetworkPlace),
    WVTI_ENTRY_ALL(CLSID_NULL, L"shell32.dll", IDS_TASK_VIEWNETCONNECTIONS, IDS_TASK_VIEWNETCONNECTIONS_TT, IDI_TASK_VIEWNETCONNECTIONS, NULL, CNetFolderViewCB::_OnViewNetConnections),
    WVTI_ENTRY_ALL(CLSID_NULL, L"shell32.dll", IDS_TASK_HOMENETWORKWIZARD,  IDS_TASK_HOMENETWORKWIZARD_TT,  IDI_TASK_HOMENETWORKWIZARD,  CNetFolderViewCB::_CanShowHNW, CNetFolderViewCB::_OnHomeNetworkWizard),
    WVTI_ENTRY_ALL(CLSID_NULL, L"shell32.dll", IDS_TASK_COMPUTERSNEARME,    IDS_TASK_COMPUTERSNEARME_TT,    IDI_GROUP,                   CNetFolderViewCB::_CanViewComputersNearMe, CNetFolderViewCB::_OnViewComputersNearMe),
    WVTI_ENTRY_ALL(CLSID_NULL, L"shell32.dll", IDS_TASK_SEARCHDS,           IDS_TASK_SEARCHDS_TT,          IDI_TASK_SEARCHDS,            CNetFolderViewCB::_CanSearchActiveDirectory, CNetFolderViewCB::_OnSearchActiveDirectory),
};

BOOL CNetFolderViewCB::_EntireNetworkAvailable()
{
    BOOL fRet = FALSE;

    // Only enable if we're in a Domain
    if (IsOS(OS_DOMAINMEMBER) && !SHRestricted(REST_NOENTIRENETWORK))
    {
        LPITEMIDLIST pidl;
        if (SUCCEEDED(CNetFolder::_CreateEntireNetworkFullIDList(&pidl)))
        {
            // ... and we're not already in the "Entire Network" folder.
            if (!ILIsEqual(_pidl, pidl))
            {
                fRet = TRUE;
            }
            ILFree(pidl);
        }
    }

    return fRet;
}

HRESULT CNetFolderViewCB::OnGetWebViewContent(DWORD pv, SFVM_WEBVIEW_CONTENT_DATA* pData)
{
    ZeroMemory(pData, sizeof(*pData));

    Create_IUIElement(&c_MyNetPlacesTaskHeader, &(pData->pFolderTaskHeader));

    LPCTSTR rgCsidls[] = { MAKEINTRESOURCE(CSIDL_DRIVES), MAKEINTRESOURCE(CSIDL_PERSONAL), MAKEINTRESOURCE(CSIDL_COMMON_DOCUMENTS), MAKEINTRESOURCE(CSIDL_PRINTERS) };
    
    if (_EntireNetworkAvailable())
    {
        LPITEMIDLIST pidlEntireNetwork = NULL;
        CNetFolder::_CreateEntireNetworkFullIDList(&pidlEntireNetwork);
        CreateIEnumIDListOnCSIDLs2(_pidl, pidlEntireNetwork, rgCsidls, ARRAYSIZE(rgCsidls), &(pData->penumOtherPlaces));
        ILFree(pidlEntireNetwork);
    }
    else
    {
        CreateIEnumIDListOnCSIDLs(_pidl, rgCsidls, ARRAYSIZE(rgCsidls), &(pData->penumOtherPlaces));
    }

    return S_OK;
}

HRESULT CNetFolderViewCB::OnGetWebViewTasks(DWORD pv, SFVM_WEBVIEW_TASKSECTION_DATA* pTasks)
{
    ZeroMemory(pTasks, sizeof(*pTasks));

    Create_IEnumUICommand((IUnknown*)(void*)this, c_MyNetPlacesTaskList, ARRAYSIZE(c_MyNetPlacesTaskList), &pTasks->penumFolderTasks);

    return S_OK;
}

STDMETHODIMP CNetFolderViewCB::RealMessage(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
    HANDLE_MSG(0, SFVM_INVOKECOMMAND, OnINVOKECOMMAND);
    HANDLE_MSG(0, SFVM_GETHELPTEXT, OnGETHELPTEXT);
    HANDLE_MSG(0, SFVM_DELAYWINDOWCREATE, OnDELAYWINDOWCREATE);
    HANDLE_MSG(0, SFVM_GETCOLSAVESTREAM, OnGETCOLSAVESTREAM);
    HANDLE_MSG(0, SFVM_GETZONE, OnGetZone);
    HANDLE_MSG(0, SFVM_ENUMERATEDITEMS, OnEnumeratedItems);
    HANDLE_MSG(0, SFVM_DEFVIEWMODE, OnDefViewMode);
    HANDLE_MSG(0, SFVM_GETDEFERREDVIEWSETTINGS, OnGetDeferredViewSettings);
    HANDLE_MSG(0, SFVM_REFRESH, OnREFRESH);
    HANDLE_MSG(0, SFVM_GETWEBVIEWLAYOUT, OnGetWebViewLayout);
    HANDLE_MSG(0, SFVM_GETWEBVIEWCONTENT, OnGetWebViewContent);
    HANDLE_MSG(0, SFVM_GETWEBVIEWTASKS, OnGetWebViewTasks);

    default:
        return E_FAIL;
    }

    return S_OK;
}


// Replace all the space characters in the provider name with '_'.
void ReplaceSpacesWithUnderscore(LPTSTR psz)
{
    while (psz = StrChr(psz, TEXT(' ')))
    {
        *psz = TEXT('_');
        psz++;              // DBCS safe
    }
}

BOOL CNetFolderViewCB::_GetProviderKeyName(LPTSTR pszName, UINT uNameLen)
{
    if (_pFolder->_GetProvider(NULL, NULL, pszName, uNameLen))
    {
        ReplaceSpacesWithUnderscore(pszName);
    }
    return (BOOL)*pszName;
}


// Define a collate order for the hood object types
#define _HOOD_COL_RON    0
#define _HOOD_COL_REMOTE 1
#define _HOOD_COL_FILE   2
#define _HOOD_COL_NET    3

const static ICONMAP c_aicmpNet[] = {
    { SHID_NET_NETWORK     , II_NETWORK      },
    { SHID_NET_DOMAIN      , II_GROUP        },
    { SHID_NET_SERVER      , II_SERVER       },
    { SHID_NET_SHARE       , (UINT)EIRESID(IDI_SERVERSHARE)  },
    { SHID_NET_DIRECTORY   , II_FOLDER       },
    { SHID_NET_PRINTER     , II_PRINTER      },
    { SHID_NET_RESTOFNET   , II_WORLD        },
    { SHID_NET_SHAREADMIN  , II_DRIVEFIXED   },
    { SHID_NET_TREE        , II_TREE         },
    { SHID_NET_NDSCONTAINER, (UINT)EIRESID(IDI_NDSCONTAINER) },
};

enum
{
    NKID_PROVIDERTYPE = 0,
    NKID_PROVIDER,
    NKID_NETCLASS,
    NKID_NETWORK,
    NKID_DIRECTORY,
    NKID_FOLDER
};

#define NKID_COUNT 6


// This is one-entry cache for remote junctions resolution
TCHAR g_szLastAttemptedJunctionName[MAX_PATH] = {0};
TCHAR g_szLastResolvedJunctionName[MAX_PATH] = {0};

REGITEMSINFO g_riiNetRoot =
{
    REGSTR_PATH_EXPLORER TEXT("\\NetworkNeighborhood\\NameSpace"),
    NULL,
    TEXT(':'),
    SHID_NET_REGITEM,
    1,
    SFGAO_CANLINK,
    0,
    NULL,
    RIISA_ORIGINAL,
    NULL,
    0,
    0,
};

CNetRootFolder* CNetRootFolder::_spThis = NULL;

HRESULT CNetFolder::_CreateInstance(LPCITEMIDLIST pidlAbs, LPCITEMIDLIST pidlTarget, UINT uDisplayType, 
                                LPCIDNETRESOURCE pidnForProvider, LPCTSTR pszResName, 
                                REFIID riid, void **ppv)
{
    HRESULT hr = E_OUTOFMEMORY;

    *ppv = NULL;

    if (!ILIsEmpty(pidlAbs))
    {
        CNetFolder* pNetF = new CNetFolder(NULL);
        if (NULL != pNetF)
        {
            pNetF->_uDisplayType = uDisplayType;

            if (pidnForProvider)
            {
                //Make sure that the pidnProvider has provider information.
                ASSERT(NET_FHasProvider(pidnForProvider))

                //We are interested only in the provider informarion which is contained in the first entry.
                //Its enough if we clone only the first item in the pidl.
                pNetF->_pidnForProvider = (LPCIDNETRESOURCE)ILCloneFirst((LPCITEMIDLIST)pidnForProvider);                
            }

            if (pszResName && *pszResName)
                pNetF->_pszResName = StrDup(pszResName);
           
            pNetF->_pidl = ILClone(pidlAbs);
            pNetF->_pidlTarget = ILClone(pidlTarget);

            if (pNetF->_pidl && (!pidlTarget || (pidlTarget && pNetF->_pidlTarget)))
            {
                if (uDisplayType == RESOURCEDISPLAYTYPE_SERVER)
                {
                    // This is a remote computer. See if there are any remote
                    // computer registry items. If so, aggregate with the registry
                    // class.

                    REGITEMSINFO riiComputer =
                    {
                        REGSTR_PATH_EXPLORER TEXT("\\RemoteComputer\\NameSpace"),
                        NULL,
                        TEXT(':'),
                        SHID_NET_REMOTEREGITEM,
                        -1,
                        SFGAO_FOLDER | SFGAO_CANLINK,
                        0,      // no required reg items
                        NULL,
                        RIISA_ORIGINAL,
                        pszResName,
                        0,
                        0,
                    };

                    CRegFolder_CreateInstance(&riiComputer,
                                              (IUnknown*) (IShellFolder*) pNetF,
                                              IID_PPV_ARG(IUnknown, &pNetF->_punkReg));
                }
                else if (uDisplayType == RESOURCEDISPLAYTYPE_ROOT)
                {
                    //
                    // this is the entire net icon, so lets create an instance of the regitem folder
                    // so we can merge in the items from there.
                    //

                    REGITEMSINFO riiEntireNet =
                    {
                        REGSTR_PATH_EXPLORER TEXT("\\NetworkNeighborhood\\EntireNetwork\\NameSpace"),
                        NULL,
                        TEXT(':'),
                        SHID_NET_REGITEM,
                        -1,
                        SFGAO_CANLINK,
                        0,      // no required reg items
                        NULL,
                        RIISA_ORIGINAL,
                        NULL,
                        0,
                        0,
                    };

                    CRegFolder_CreateInstance(&riiEntireNet,
                                              (IUnknown*) (IShellFolder*) pNetF,
                                              IID_PPV_ARG(IUnknown, &pNetF->_punkReg));
                }
                else
                {
                    ASSERT(hr == E_OUTOFMEMORY);
                }
                hr = pNetF->QueryInterface(riid, ppv);
            }
            pNetF->Release();
        }
        else
        {
            ASSERT(hr == E_OUTOFMEMORY);
        }
    }
    else
    {
        ASSERT(0);
        hr = E_INVALIDARG;
    }

    return hr;
}

HRESULT CNetwork_CreateInstance(IUnknown* punkOuter, REFIID riid, void **ppv)
{
    HRESULT hr = S_OK;
    *ppv = NULL;

    // Must enter critical section to avoid racing against v_HandleDelete
    ENTERCRITICAL;

    if (NULL != CNetRootFolder::_spThis)
    {
        hr = CNetRootFolder::_spThis->QueryInterface(riid, ppv);
    }
    else
    {
        CNetRootFolder* pNetRootF = new CNetRootFolder(punkOuter);
        if (pNetRootF)
        {
            // Initialize it ourselves to ensure that the cached value
            // is the correct one.
            hr = pNetRootF->Initialize((LPCITEMIDLIST)&c_idlNet);
            if (SUCCEEDED(hr))
            {
                pNetRootF->_uDisplayType = RESOURCEDISPLAYTYPE_GENERIC;
                ASSERT(NULL == pNetRootF->_punkReg);

                if (SHRestricted(REST_NOSETFOLDERS))
                    g_riiNetRoot.iReqItems = 0;

                // create the regitems object, he has the NetRoot object as his outer guy.

                hr = CRegFolder_CreateInstance(&g_riiNetRoot,
                                                 SAFECAST(pNetRootF, IShellFolder2*),
                                                 IID_PPV_ARG(IUnknown, &pNetRootF->_punkReg));

                // NOTE: not using SHInterlockedCompareExchange() because we have the critsec
                CNetRootFolder::_spThis = pNetRootF;
                hr = pNetRootF->QueryInterface(riid, ppv);
            }

            // Release the self-reference, but keep the the _spThis pointer intact
            // (it will be reset to NULL in the destructor)
            pNetRootF->Release();
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }

    LEAVECRITICAL;

    return hr;
}


CNetFolder::CNetFolder(IUnknown* punkOuter) : 
    CAggregatedUnknown (punkOuter)
{
    // Assert that we're still using a zero-init flag inside the new operator
    ASSERT(NULL == _pidl);
    ASSERT(NULL == _pidlTarget);
    ASSERT(NULL == _pidnForProvider);
    ASSERT(NULL == _pszResName);
    ASSERT(0 == _uDisplayType);
    ASSERT(NULL == _psfFiles);
    ASSERT(NULL == _punkReg);

    DllAddRef();
}


CNetFolder::~CNetFolder()
{
    ILFree(_pidl);
    ILFree(_pidlTarget);
    ILFree((LPITEMIDLIST)_pidnForProvider);
    
    if (NULL != _pszResName)
    {
        LocalFree(_pszResName);
    }

    if (_psfFiles)
    {
        _psfFiles->Release();
    }

    SHReleaseInnerInterface(SAFECAST(this, IShellFolder *), &_punkReg);
    DllRelease();
}

CNetFolder *FolderToNetFolder(IUnknown *punk)
{
    CNetFolder * pThis = NULL;
    return punk && SUCCEEDED(punk->QueryInterface(CLSID_CNetFldr, (void **)&pThis)) ? pThis : NULL;
}

HRESULT CNetFolder::v_InternalQueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENT(CNetFolder, IShellFolder2),                                    // IID_IShellFolder2
        QITABENTMULTI(CNetFolder, IShellFolder, IShellFolder2),                 // IID_IShellFolder
        QITABENT(CNetFolder, IPersistFolder3),                              // IID_IPersistFolder3
        QITABENT(CNetFolder, IShellIconOverlay),                            // IID_IShellIconOverlay
        QITABENTMULTI(CNetFolder, IPersistFolder2, IPersistFolder3),        // IID_IPersistFolder2
        QITABENTMULTI(CNetFolder, IPersistFolder, IPersistFolder3),         // IID_IPersistFolder
        QITABENTMULTI(CNetFolder, IPersist, IPersistFolder3),               // IID_IPersist
        QITABENTMULTI2(CNetFolder, IID_IPersistFreeThreadedObject, IPersist),   // IID_IPersistFreeThreadedObject
        { 0 },
    };

    if (IsEqualIID(riid, CLSID_CNetFldr))
    {
        *ppv = this;        // get class pointer (unrefed!)
        return S_OK;
    }

    HRESULT hr;
    if (_punkReg && RegGetsFirstShot(riid))
    {
        hr = _punkReg->QueryInterface(riid, ppv);
    }
    else
    {
        hr = QISearch(this, qit, riid, ppv);
        if ((E_NOINTERFACE == hr) && _punkReg)
        {
            hr = _punkReg->QueryInterface(riid, ppv);
        }
    }
    return hr;
}


BOOL CNetRootFolder::v_HandleDelete(PLONG pcRef)
{
    ASSERT(NULL != pcRef);

    ENTERCRITICAL;

    // Once inside the critical section things are slightly more stable.
    // CNetwork_CreateInstance won't be able to rescue the cached reference
    // (and bump the refcount from 0 to 1).  And we don't have to worry
    // about somebody Release()ing us down to zero a second time, since
    // no new references can show up.
    //
    // HOWEVER!  All those scary things could've happened WHILE WE WERE
    // WAITING TO ENTER THE CRITICAL SECTION.
    //
    // While we were waiting, somebody could've called CNetwork_CreateInstance,
    // which bumps the reference count back up.  So don't destroy ourselves
    // if our object got "rescued".
    //
    // What's more, while we were waiting, that somebody could've then
    // Release()d us back down to zero, causing us to be called on that
    // other thread, notice that the refcount is indeed zero, and destroy
    // the object, all on that other thread.  So if we are not the cached
    // instance, then don't destroy ourselves since that other thread did
    // it already.
    //
    // And even more, somebody might call CNetwork_CreateInstance again
    // and create a brand new object, which might COINCIDENTALLY happen
    // to have the same address as the old object we are trying to destroy
    // here.  But in that case, it's okay to destroy the new object because
    // it is indeed the case that the object's reference count is zero and
    // deserves to be destroyed.

    if (this == _spThis && 0 == *pcRef)
    {
        *pcRef = 1000; // protect against cached pointers bumping us up then down
        delete this;
    }
    LEAVECRITICAL;
    // return TRUE to indicate that we've implemented this function
    // (regardless of whether or not this object was actually deleted)
    return TRUE;
}


STDMETHODIMP CNetFolder::ParseDisplayName(HWND hwnd, LPBC pbc, WCHAR* pszName, ULONG* pchEaten,
                                          LPITEMIDLIST* ppidl, DWORD* pdwAttributes)
{
    return E_NOTIMPL;
}


// new for Win2K, this enables enuming the hidden admin shares
#ifndef RESOURCE_SHAREABLE
#define RESOURCE_SHAREABLE      0x00000006
#endif

//
//  in:
//      hwnd        NULL indicates no UI.
//      grfFlags     IShellFolder::EnumObjects() SHCONTF_ flags
//      pnr          in/out params
//
//
DWORD CNetFolder::_OpenEnum(HWND hwnd, DWORD grfFlags, LPNETRESOURCE pnr, HANDLE *phEnum)
{
    DWORD dwType = (grfFlags & SHCONTF_NETPRINTERSRCH) ? RESOURCETYPE_PRINT : RESOURCETYPE_ANY;
    DWORD dwScope = pnr ? RESOURCE_GLOBALNET : RESOURCE_CONTEXT;

    if ((_uDisplayType == RESOURCEDISPLAYTYPE_SERVER) &&
        (grfFlags & SHCONTF_SHAREABLE))
    {
        dwScope = RESOURCE_SHAREABLE;   // hidden admin shares for this server
    }

    DWORD err = WNetOpenEnum(dwScope, dwType, RESOURCEUSAGE_ALL, pnr, phEnum);
    if ((err != WN_SUCCESS) && hwnd)
    {
        // If it failed because you are not authenticated yet,
        // we need to let the user loggin to this network resource.
        //
        // REVIEW: Ask LenS to review this code.
        if (err == WN_NOT_AUTHENTICATED || 
            err == ERROR_LOGON_FAILURE || 
            err == WN_BAD_PASSWORD || 
            err == WN_ACCESS_DENIED)
        {
            // Retry with password dialog box.
            err = WNetAddConnection3(hwnd, pnr, NULL, NULL, CONNECT_TEMPORARY | CONNECT_INTERACTIVE);
            if (err == WN_SUCCESS)
                err = WNetOpenEnum(dwScope, dwType, RESOURCEUSAGE_ALL, pnr, phEnum);
        }

        UINT idTemplate = pnr && pnr->lpRemoteName ? IDS_ENUMERR_NETTEMPLATE2 : IDS_ENUMERR_NETTEMPLATE1;   
        SHEnumErrorMessageBox(hwnd, idTemplate, err, pnr ? pnr->lpRemoteName : NULL, TRUE, MB_OK | MB_ICONHAND);
    }
    return err;
}

// find the share part of a UNC
//  \\server\share
//  return pointer to "share" or pointer to empty string if none

LPCTSTR PathFindShareName(LPCTSTR pszUNC)
{
    LPCTSTR psz = SkipServerSlashes(pszUNC);
    if (*psz)
    {
        psz = StrChr(psz + 1, TEXT('\\'));
        if (psz)
            psz++;
        else
            psz = TEXT("");
    }
    return psz;
}

// Flags for the dwRemote field
#define RMF_CONTEXT         0x00000001  // Entire network is being enumerated
#define RMF_SHOWREMOTE      0x00000002  // Return Remote Services for next enumeration
#define RMF_STOP_ENUM       0x00000004  // Stop enumeration
#define RMF_GETLINKENUM     0x00000008  // Hoodlinks enum needs to be fetched
#define RMF_SHOWLINKS       0x00000010  // Hoodlinks need to be shown
#define RMF_FAKENETROOT     0x00000020  // Don't enumerate the workgroup items

#define RMF_ENTIRENETSHOWN  0x40000000  // Entire network object shown
#define RMF_REMOTESHOWN     0x80000000  // Return Remote Services for next enumeration


class CNetFolderEnum : public CEnumIDListBase
{
public:
    // IEnumIDList
    STDMETHOD(Next)(ULONG celt, LPITEMIDLIST *rgelt, ULONG *pceltFetched);
    
private:
    CNetFolderEnum(CNetFolder *pnf, DWORD grfFlags, DWORD dwRemote, HANDLE hEnum);
    ~CNetFolderEnum();
    friend HRESULT Create_NetFolderEnum(CNetFolder* pnsf, DWORD grfFlags, DWORD dwRemote, HANDLE hEnum, IEnumIDList** ppenum);
    
    CNetFolder *_pnsf;     // CNetFolder object we're enumerating
    HANDLE _hEnum;
    DWORD _grfFlags;
    LONG _cItems;   // Count of items in buffer
    LONG _iItem;    // Current index of the item in the buffer
    DWORD _dwRemote;
    union {
        NETRESOURCE _anr[0];
        BYTE _szBuffer[8192];
    };
    IEnumIDList *_peunk;  // used for enumerating file system items (links)
};

CNetFolderEnum::CNetFolderEnum(CNetFolder *pnsf, DWORD grfFlags, DWORD dwRemote, HANDLE hEnum) : CEnumIDListBase()
{
    _pnsf = pnsf;
    _pnsf->AddRef();

    _grfFlags = grfFlags;
    _dwRemote = dwRemote;

    _hEnum = hEnum;
}

HRESULT Create_NetFolderEnum(CNetFolder* pnf, DWORD grfFlags, DWORD dwRemote, HANDLE hEnum, IEnumIDList** ppenum)
{
    HRESULT hr;
    CNetFolderEnum* p= new CNetFolderEnum(pnf, grfFlags, dwRemote, hEnum);
    if (p)
    {
        hr = p->QueryInterface(IID_PPV_ARG(IEnumIDList, ppenum));
        p->Release();
    }
    else
    {
        hr = E_OUTOFMEMORY;
        *ppenum = NULL;
    }
    return hr;
}

CNetFolderEnum::~CNetFolderEnum()
{
    _pnsf->Release();              // release the "this" ptr we have

    if (_peunk)
        _peunk->Release();

    if (_hEnum)
        WNetCloseEnum(_hEnum);
}

STDMETHODIMP CNetFolderEnum::Next(ULONG celt, LPITEMIDLIST *ppidl, ULONG *pceltFetched)
{
    HRESULT hr;

    *ppidl = NULL;
    if (pceltFetched)
        *pceltFetched = 0;

    // Time to stop enumeration?
    if (_dwRemote & RMF_STOP_ENUM)
        return S_FALSE;       // Yes

    // should we try and get the links enumerator?
    if (_dwRemote & RMF_GETLINKENUM)
    {
        IShellFolder2* psfNetHood;                                                                                             
        if (SUCCEEDED(_pnsf->v_GetFileFolder(&psfNetHood)))
            psfNetHood->EnumObjects(NULL, _grfFlags, &_peunk);

        if (_peunk)
            _dwRemote |= RMF_SHOWLINKS;

        _dwRemote &= ~RMF_GETLINKENUM;
    }

    // should we be showing the links?
    if (_dwRemote & RMF_SHOWLINKS)
    {
        if (_peunk)
        {
            ULONG celtFetched;
            LPITEMIDLIST pidl;

            hr = _peunk->Next(1, &pidl, &celtFetched);
            if (hr == S_OK && celtFetched == 1)
            {
                *ppidl = pidl;
                if (pceltFetched)
                    *pceltFetched = celtFetched;
                return S_OK;       // Added link
            }
        }

        _dwRemote &= ~RMF_SHOWLINKS; // Done enumerating links
    }

    hr = S_OK;

    // Do we add the remote folder?
    // (Note: as a hack to ensure that the remote folder is added
    // to the 'hood despite what MPR says, RMF_SHOWREMOTE can be
    // set without RMF_CONTEXT set.)
    if ((_dwRemote & RMF_SHOWREMOTE) && !(_dwRemote & RMF_REMOTESHOWN))
    {
        // Yes
        // Only try to put the remote entry in once.
        _dwRemote |= RMF_REMOTESHOWN;

        // Is this not the Context container?
        // (See note above as to why we are asking this question.)
        if (!(_dwRemote & RMF_CONTEXT)) 
        {
            // Yes; stop after the next time
            _dwRemote |= RMF_STOP_ENUM;
        }

        // We have fallen thru because the remote services is not
        // installed.

        // Is this not the Context container AND the remote folder
        // is not installed?
        if (!(_dwRemote & RMF_CONTEXT)) 
        {
            // Yes; nothing else to enumerate
            return S_FALSE;
        }
    }

    if (_dwRemote & RMF_FAKENETROOT)
    {
        if ((!(_dwRemote & RMF_ENTIRENETSHOWN)) &&            
            (S_FALSE != SHShouldShowWizards(_punkSite)))
        {                           
            _pnsf->_CreateEntireNetwork(ppidl);         // fake entire net
            _dwRemote |= RMF_ENTIRENETSHOWN;
        }
        else
        {
            return S_FALSE;         // no more to enumerate
        }
    }
    else
    {
        while (TRUE)
        {
            ULONG err = WN_SUCCESS;
            LPNETRESOURCE pnr;

            if (_iItem >= _cItems)
            {
                DWORD dwSize = sizeof(_szBuffer);

                _cItems = -1;           // its signed
                _iItem = 0;

                err = WNetEnumResource(_hEnum, (DWORD*)&_cItems, _szBuffer, &dwSize);
                DebugMsg(DM_TRACE, TEXT("Net EnumCallback: err=%d Count=%d"), err, _cItems);
            }

            pnr = &_anr[_iItem++];

            // Note: the <= below is correct as we already incremented the index...
            if (err == WN_SUCCESS && (_iItem <= _cItems))
            {
                // decide if the thing is a folder or not
                ULONG grfFlagsItem = ((pnr->dwUsage & RESOURCEUSAGE_CONTAINER) || 
                                      (pnr->dwType == RESOURCETYPE_DISK) ||
                                      (pnr->dwType == RESOURCETYPE_ANY)) ?
                                        SHCONTF_FOLDERS : SHCONTF_NONFOLDERS;

                // If this is the context enumeration, we want to insert the
                // Remote Services after the first container.
                //
                // Remember that we need to return the Remote Services in the next iteration.

                if ((pnr->dwUsage & RESOURCEUSAGE_CONTAINER) && 
                     (_dwRemote & RMF_CONTEXT))
                {
                    _dwRemote |= RMF_SHOWREMOTE;
                }

                if ((_pnsf->_uDisplayType == RESOURCEDISPLAYTYPE_SERVER) &&
                    (_grfFlags & SHCONTF_SHAREABLE))
                {
                    // filter out ADMIN$ and IPC$, based on str len
                    if (lstrlen(PathFindShareName(pnr->lpRemoteName)) > 2)
                    {
                        grfFlagsItem = 0;
                    }
                }

                // if this is a network object, work out if we should hide or note, so
                // convert the provider to its type number and open the key under:
                //
                // HKEY_CLASSES_ROOT\Network\Type\<type string>

                if ((pnr->dwDisplayType == RESOURCEDISPLAYTYPE_NETWORK) && 
                          !(_grfFlags & SHCONTF_INCLUDEHIDDEN))
                {
                    DWORD dwType;
                    if (WNetGetProviderType(pnr->lpProvider, &dwType) == WN_SUCCESS)
                    {
                        TCHAR szRegValue[MAX_PATH];
                        wsprintf(szRegValue, TEXT("Network\\Type\\%d"), HIWORD(dwType));

                        BOOL fHide = FALSE;
                        DWORD cb = sizeof(fHide);
                        if ((ERROR_SUCCESS == SHGetValue(HKEY_CLASSES_ROOT, szRegValue, TEXT("HideProvider"), NULL, &fHide, &cb)) && fHide)
                        {
                            grfFlagsItem = 0;
                        }
                    }
                }

                // Check if we found requested type of net resource.
                if (_grfFlags & grfFlagsItem)
                {
                    if (SUCCEEDED(_pnsf->_NetResToIDList(pnr, FALSE, TRUE, (_grfFlags & SHCONTF_NONFOLDERS), ppidl)))
                    {
                        break;
                    }
                }
            }
            else if (err == WN_NO_MORE_ENTRIES) 
            {
                hr = S_FALSE; // no more element
                break;
            }
            else 
            {
                DebugMsg(DM_ERROR, TEXT("sh ER - WNetEnumResource failed (%lx)"), err);
                hr = E_FAIL;
                break;
            }
        }
    }

    if (pceltFetched)
        *pceltFetched = (S_OK == hr) ? 1 : 0;
    
    return hr;
}


STDMETHODIMP CNetFolder::EnumObjects(HWND hwnd, DWORD grfFlags, IEnumIDList** ppenum)
{
    NETRESOURCE nr = {0};
    TCHAR szProvider[MAX_PATH];

    nr.lpProvider = (LPTSTR) _GetProvider(NULL, NULL, szProvider, ARRAYSIZE(szProvider));

    if (_uDisplayType != RESOURCEDISPLAYTYPE_ROOT &&
        _uDisplayType != RESOURCEDISPLAYTYPE_NETWORK)
    {
        nr.lpRemoteName = _pszResName;
    }

    HRESULT hr;
    HANDLE hEnum;
    DWORD err = _OpenEnum(hwnd, grfFlags, &nr,  &hEnum);
    if (err == WN_SUCCESS)
    {
        hr = Create_NetFolderEnum(this, grfFlags, 0, hEnum, ppenum);

        if (FAILED(hr))
        {
            WNetCloseEnum(hEnum);
        }
    }
    else
    {
        hr = HRESULT_FROM_WIN32(err);
    }

    return hr;
}


LPCIDNETRESOURCE NET_IsValidID(LPCITEMIDLIST pidl)
{
    if (pidl && !ILIsEmpty(pidl) && ((pidl->mkid.abID[0] & SHID_GROUPMASK) == SHID_NET))
        return (LPCIDNETRESOURCE)pidl;
    return NULL;
}

STDMETHODIMP CNetFolder::BindToObject(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv)
{
    HRESULT hr;
    LPCIDNETRESOURCE pidn;

    *ppv = NULL;

    pidn = NET_IsValidID(pidl);
    if (pidn)
    {
        IShellFolder *psfJunction;
        LPITEMIDLIST pidlInit = NULL;
        LPITEMIDLIST pidlTarget = NULL;
        LPCITEMIDLIST pidlRight = _ILNext(pidl);
        BOOL fRightIsEmpty = ILIsEmpty(pidlRight);
        LPCIDNETRESOURCE pidnProvider = NET_FHasProvider(pidn) ? pidn :_pidnForProvider;

        hr = S_OK;

        // lets get the IDLISTs we are going to use to initialize the shell folder
        // if we are doing a single level bind then then ILCombine otherwise
        // be more careful.

        pidlInit = ILCombineParentAndFirst(_pidl, pidl, pidlRight);
        if (_pidlTarget)
            pidlTarget = ILCombineParentAndFirst(_pidlTarget, pidl, pidlRight);

        if (!pidlInit || (!pidlTarget && _pidlTarget))
           hr = E_OUTOFMEMORY;

        // now create the folder object we are using, and either return that    
        // object to the caller, or continue the binding down.

        if (SUCCEEDED(hr))
        {
            hr = _CreateFolderForItem(pbc, pidlInit, pidlTarget, pidnProvider, 
                                        fRightIsEmpty ? riid : IID_IShellFolder, 
                                        fRightIsEmpty ? ppv : (void **)&psfJunction);

            if (!fRightIsEmpty && SUCCEEDED(hr))
            {
                hr = psfJunction->BindToObject(pidlRight, pbc, riid, ppv);
                psfJunction->Release();
            }        
        }

        ILFree(pidlInit);
        ILFree(pidlTarget);
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}

STDMETHODIMP CNetFolder::BindToStorage(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv)
{
    return BindToObject(pidl, pbc, riid, ppv);
}

STDMETHODIMP CNetFolder::CompareIDs(LPARAM iCol, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    HRESULT hr = E_INVALIDARG;
    LPCIDNETRESOURCE pidn1 = NET_IsValidID(pidl1);
    LPCIDNETRESOURCE pidn2 = NET_IsValidID(pidl2);

    if (pidn1 && pidn2)
    {
        TCHAR szBuff1[MAX_PATH], szBuff2[MAX_PATH];

        switch (iCol & SHCIDS_COLUMNMASK)
        {
            case ICOL_COMMENT:
            {
                hr = ResultFromShort(StrCmpLogicalRestricted(NET_CopyComment(pidn1, szBuff1, ARRAYSIZE(szBuff1)), 
                                                    NET_CopyComment(pidn2, szBuff2, ARRAYSIZE(szBuff2))));

                if (hr != 0)
                    return hr;

                // drop down into the name comparison
            }

            case ICOL_NAME:
            {
                // Compare by name.  This is the one case where we need to handle
                // simple ids in either place.  We will try to resync the items
                // if we find a case of this before do the compares.
                // Check for relative IDs.  In particular if one item is at
                // a server and the other is at RestOfNet then try to resync
                // the two
                //

                if (NET_IsFake(pidn1) || NET_IsFake(pidn2))
                {
                    // if either pidn1 or pidn2 is fake then we assume they are identical,
                    // this allows us to compare a simple net ID to a real net ID.  we
                    // assume that if this fails later then the world will be happy

                    hr = 0;
                }
                else
                {
                    // otherwise lets look at the names and provider strings accordingly

                    NET_CopyResName(pidn1, szBuff1, ARRAYSIZE(szBuff1));
                    NET_CopyResName(pidn2, szBuff2, ARRAYSIZE(szBuff2));
                    hr = ResultFromShort(StrCmpLogicalRestricted(szBuff1, szBuff2));

                    // If they're still identical, compare provider names.

                    if ((hr == 0) && (iCol & SHCIDS_ALLFIELDS))
                    {
                        LPCTSTR pszProv1 = _GetProvider(pidn1, NULL, szBuff1, ARRAYSIZE(szBuff1));
                        LPCTSTR pszProv2 = _GetProvider(pidn2, NULL, szBuff2, ARRAYSIZE(szBuff2));

                        if (pszProv1 && pszProv2)
                            hr = ResultFromShort(lstrcmp(pszProv1, pszProv2));
                        else
                        {
                            if (pszProv1 || pszProv2)
                                hr = ResultFromShort(pszProv1 ? 1 : -1);
                            else
                                hr = ResultFromShort(0);
                        }
                    }
                }

                // If they identical, compare the rest of IDs.

                if (hr == 0)
                    hr = ILCompareRelIDs((IShellFolder*)this, (LPCITEMIDLIST)pidn1, (LPCITEMIDLIST)pidn2, iCol);
            }
        }
    }

    return hr;
}

STDMETHODIMP CNetFolder::CreateViewObject(HWND hwnd, REFIID riid, void **ppv)
{
    HRESULT hr;

    *ppv = NULL;

    if (IsEqualIID(riid, IID_IShellView))
    {
        SFV_CREATE sSFV;

        sSFV.cbSize   = sizeof(sSFV);
        sSFV.psvOuter = NULL;
        sSFV.psfvcb = new CNetFolderViewCB(this);    // failure is OK, we just get generic support

        QueryInterface(IID_PPV_ARG(IShellFolder, &sSFV.pshf));   // in case we are agregated

        hr = SHCreateShellFolderView(&sSFV, (IShellView**) ppv);

        if (sSFV.pshf)
            sSFV.pshf->Release();

        if (sSFV.psfvcb)
            sSFV.psfvcb->Release();
    }
    else if (IsEqualIID(riid, IID_IContextMenu))
    {
        IShellFolder* psfOuter;
        hr = QueryInterface(IID_PPV_ARG(IShellFolder, &psfOuter));
        if (SUCCEEDED(hr))
        {
            hr = CDefFolderMenu_Create(_pidl, hwnd, 0, NULL, psfOuter, 
                CNetwork_DFMCallBackBG, NULL, NULL, (IContextMenu**) ppv);
            psfOuter->Release();
        }
    }
    else
    {
        hr = E_NOINTERFACE;
    }
    return hr;
}

typedef HRESULT (CALLBACK *PFNGAOCALLBACK)(IShellFolder2 *psf, LPCITEMIDLIST pidl, ULONG* prgfInOut);

STDAPI GetAttributesCallback(IShellFolder2 *psf, UINT cidl, LPCITEMIDLIST* apidl, ULONG *prgfInOut, PFNGAOCALLBACK pfnGAOCallback)
{
    HRESULT hr = S_OK;
    ULONG rgfOut = 0;

    for (UINT i = 0; i < cidl; i++)
    {
        ULONG rgfT = *prgfInOut;
        hr = pfnGAOCallback(psf, apidl[i], &rgfT);
        if (FAILED(hr))
        {
            rgfOut = 0;
            break;
        }
        rgfOut |= rgfT;
    }

    *prgfInOut &= rgfOut;
    return hr;
}
    
STDMETHODIMP CNetFolder::GetAttributesOf(UINT cidl, LPCITEMIDLIST* apidl, ULONG* prgfInOut)
{
    HRESULT hr;
    if (IsSelf(cidl, apidl))
    {
        *prgfInOut &= (SFGAO_CANLINK | SFGAO_HASPROPSHEET | SFGAO_HASSUBFOLDER |
                       SFGAO_FOLDER | SFGAO_FILESYSANCESTOR);
        hr = S_OK;
    }
    else
    {
        hr = GetAttributesCallback(SAFECAST(this, IShellFolder2*), cidl, apidl, prgfInOut, _AttributesCallback);
    }

    return hr;
}

STDMETHODIMP CNetFolder::GetDisplayNameOf(LPCITEMIDLIST pidl, DWORD dwFlags, STRRET* pStrRet)
{
    HRESULT hr;
    LPCIDNETRESOURCE pidn = NET_IsValidID(pidl);
    if (pidn)
    {
        TCHAR szPath[MAX_PATH];
        LPCITEMIDLIST pidlNext = _ILNext(pidl);

        if (dwFlags & SHGDN_FORPARSING)
        {
            if ((dwFlags & SHGDN_INFOLDER) ||
                ((dwFlags & SHGDN_FORADDRESSBAR) && (NET_GetDisplayType(pidn) == RESOURCEDISPLAYTYPE_ROOT))) // the non-infolder name for the root is not good for the address bar
            {
                NET_CopyResName(pidn, szPath, ARRAYSIZE(szPath));
                if (ILIsEmpty(pidlNext))
                {
                    // we just need the last part of the display name (IN FOLDER)
                    LPTSTR pszT = StrRChr(szPath, NULL, TEXT('\\'));

                    if (!pszT)
                        pszT = szPath;
                    else
                        pszT++; // move past '\'
                    hr = StringToStrRet(pszT, pStrRet);
                }
                else
                {
                    hr = ILGetRelDisplayName((IShellFolder*) this, pStrRet, pidl, szPath, MAKEINTRESOURCE(IDS_DSPTEMPLATE_WITH_BACKSLASH), dwFlags);
                }
            }
            else
            {
                LPCITEMIDLIST pidlRight = _ILNext(pidl);

                if (ILIsEmpty(pidlRight))
                {
                    hr = _GetPathForItem(pidn, szPath);
                    if (SUCCEEDED(hr))
                    {
                        hr = StringToStrRet(szPath, pStrRet);
                    }
                }
                else
                {
                    IShellFolder *psfJunction;
                    //Get the pidn which has network provider information.
                    LPCIDNETRESOURCE pidnProvider = NET_FHasProvider(pidn) ? pidn :_pidnForProvider;
                    LPITEMIDLIST pidlInit, pidlTarget = NULL;

                    pidlInit = ILCombineParentAndFirst(_pidl, pidl, pidlRight);                    
                    if (_pidlTarget)
                        pidlTarget = ILCombineParentAndFirst(_pidlTarget, pidl, pidlRight);
    
                    if (!pidlInit || (_pidlTarget && !pidlTarget))
                        return E_OUTOFMEMORY;

                    hr = _CreateFolderForItem(NULL, pidlInit, pidlTarget, pidnProvider, IID_PPV_ARG(IShellFolder, &psfJunction));
                    if (SUCCEEDED(hr))
                    {
                        hr = psfJunction->GetDisplayNameOf(pidlRight, dwFlags, pStrRet);
                        psfJunction->Release();
                    }

                    ILFree(pidlInit);
                    ILFree(pidlTarget);
                }
            }
        }
        else
        {
            hr = _GetFormatName(pidn, pStrRet);
            if (SUCCEEDED(hr) && !(dwFlags & SHGDN_INFOLDER) && (NET_GetFlags(pidn) & SHID_JUNCTION))
            {
                TCHAR szServer[MAX_PATH];
                SHGetNameAndFlags(_pidlTarget ? _pidlTarget:_pidl, SHGDN_FORPARSING, szServer, ARRAYSIZE(szServer), NULL);

                TCHAR szDisplay[MAX_PATH];
                hr = SHGetComputerDisplayName(szServer, 0x0, szDisplay, ARRAYSIZE(szDisplay));
                if (SUCCEEDED(hr))
                {
                    StrRetFormat(pStrRet, pidl, MAKEINTRESOURCE(IDS_DSPTEMPLATE_WITH_ON), szDisplay);
                }
            }
        }
    }
    else
        hr = E_INVALIDARG;

    return hr;
}


STDMETHODIMP CNetFolder::SetNameOf(HWND hwnd, LPCITEMIDLIST pidl, LPCOLESTR lpszName, DWORD dwRes, LPITEMIDLIST* ppidl)
{
    if (ppidl) 
        *ppidl = NULL;

    return E_NOTIMPL;   // not supported
}

STDMETHODIMP CNetFolder::GetUIObjectOf(HWND hwnd, UINT cidl, LPCITEMIDLIST* apidl,
                                       REFIID riid, UINT* prgfInOut, void **ppv)
{
    HRESULT hr = E_INVALIDARG;
    LPCIDNETRESOURCE pidn = cidl ? NET_IsValidID(apidl[0]) : NULL;

    *ppv = NULL;

    if ((IsEqualIID(riid, IID_IExtractIconA) || IsEqualIID(riid, IID_IExtractIconW)) && pidn)
    {
        UINT iIndex;

        if (_IsPrintShare(pidn))
            iIndex = (UINT)EIRESID(IDI_PRINTER_NET);
        else if (NET_IsRemoteFld(pidn))
            iIndex = II_RNA;
        else
            iIndex = SILGetIconIndex(apidl[0], c_aicmpNet, ARRAYSIZE(c_aicmpNet));

        hr = SHCreateDefExtIcon(NULL, iIndex, iIndex, GIL_PERCLASS, II_FOLDER, riid, ppv);
    }
    else if (IsEqualIID(riid, IID_IContextMenu) && pidn)
    {
        HKEY ahkeys[NKID_COUNT];

        hr = _OpenKeys(pidn, ahkeys);
        if (SUCCEEDED(hr))
        {
            IShellFolder* psfOuter;
            hr = QueryInterface(IID_PPV_ARG(IShellFolder, &psfOuter));
            if (SUCCEEDED(hr))
            {
                hr = CDefFolderMenu_Create2(_pidl, hwnd, cidl, apidl, 
                        psfOuter, _GetCallbackType(pidn), 
                        ARRAYSIZE(ahkeys), ahkeys, (IContextMenu**) ppv);
                psfOuter->Release();
            }

            SHRegCloseKeys(ahkeys, ARRAYSIZE(ahkeys));
        }
    }
    else if (cidl && IsEqualIID(riid, IID_IDataObject))
    {
        // Point & Print printer installation assumes that the
        // netresources from CNetData_GetData and the
        // pidls from CIDLData_GetData are in the same order.
        // Keep it this way.

        CNetData *pnd = new CNetData(_pidl, cidl, apidl);
        if (pnd)
        {
            hr = pnd->QueryInterface(riid, ppv);
            pnd->Release();
        }
        else
            hr = E_OUTOFMEMORY;
    }
    else if (pidn && IsEqualIID(riid, IID_IDropTarget))
    {
        // special support because this is an item (not a folder)
        if (_IsPrintShare(pidn))
        {
            LPITEMIDLIST pidl;
            hr = SHILCombine(_pidl, apidl[0], &pidl);
            if (SUCCEEDED(hr))
            {
                hr = CPrinterDropTarget_CreateInstance(hwnd, pidl, (IDropTarget**)ppv);
                ILFree(pidl);
            }
        }
        else
        {
            IShellFolder *psf;

            hr = BindToObject(apidl[0], NULL, IID_PPV_ARG(IShellFolder, &psf));
            if (SUCCEEDED(hr))
            {
                hr = psf->CreateViewObject(hwnd, riid, ppv);
                psf->Release();
            }
        }
    }
    else if (pidn && IsEqualIID(riid, IID_IQueryInfo))
    {
        if (NET_GetDisplayType(pidn) == RESOURCEDISPLAYTYPE_ROOT)
        {
            hr = CreateInfoTipFromText(MAKEINTRESOURCE(IDS_RESTOFNETTIP), riid, ppv);
        }
        else
        {
            // Someday maybe have infotips for other things too
        }
    }

    return hr;
}


STDMETHODIMP CNetFolder::GetDefaultSearchGUID(LPGUID pguid)
{
    *pguid = SRCID_SFindComputer;
    return S_OK;
}


void WINAPI CNetFolder::_CopyEnumElement(void* pDest, const void* pSource, DWORD dwSize)
{
    if (pDest && pSource)
        memcpy(pDest, pSource, dwSize);
}

STDMETHODIMP CNetFolder::EnumSearches(IEnumExtraSearch** ppenum)
{
    HRESULT hr = E_NOTIMPL;
    
    *ppenum = NULL;
    
    // if the restriction is set then this item should be enumerated from the registry
    // so we fail, else enumerate it
    // only enumerate if we actually have a network to search against
    if (!SHRestricted(REST_HASFINDCOMPUTERS) &&
        (GetSystemMetrics(SM_NETWORK) & RNC_NETWORKS))
    {
        EXTRASEARCH *pxs = (EXTRASEARCH *)LocalAlloc(LPTR, sizeof(EXTRASEARCH));
        if (pxs)
        {
            pxs->guidSearch = SRCID_SFindComputer;
            if (LoadStringW(g_hinst, IDS_FC_NAME, pxs->wszFriendlyName, sizeof(pxs->wszFriendlyName)))
            {      
                *ppenum = (IEnumExtraSearch*)CStandardEnum_CreateInstance(IID_IEnumExtraSearch, FALSE,
                            1, sizeof(EXTRASEARCH), pxs, _CopyEnumElement);
                if (*ppenum == NULL)
                {
                    LocalFree(pxs);
                    hr = E_OUTOFMEMORY;
                }
                else
                    hr = S_OK;
            }
        }
        else
            hr = E_OUTOFMEMORY;
    }

    return hr;
}


STDMETHODIMP CNetFolder::GetDefaultColumn(DWORD dwRes, ULONG* pSort, ULONG* pDisplay)
{
    return E_NOTIMPL;
}

HRESULT CNetFolder::_GetDefaultColumnState(UINT cColumns, UINT iColumn, DWORD* pdwState)
{
    *pdwState = 0;
    
    HRESULT hr = S_OK;
    if (iColumn < cColumns)
    {
        *pdwState = s_net_cols[iColumn].csFlags;
        if (iColumn >= 1)
            *pdwState |= SHCOLSTATE_SLOW;   // comment is slow for net root
    }
    else
    {
        hr = E_INVALIDARG;
    }
    return hr;
}

STDMETHODIMP CNetFolder::GetDetailsEx(LPCITEMIDLIST pidl, const SHCOLUMNID* pscid, VARIANT* pv)
{
    HRESULT hr = E_NOTIMPL;
    LPCIDNETRESOURCE pidn = NET_IsValidID(pidl);
    if (pidn)
    {
        if (IsEqualSCID(*pscid, SCID_NETRESOURCE))
        {
            // Office calls SHGetDataFromIDList() with a large buffer to hold all
            // of the strings in the NETRESOURCE structure, so we need to make sure
            // that our variant can hold enough data to pass back to it:
            BYTE rgBuffer[sizeof(NETRESOURCEW) + (4 * MAX_PATH * sizeof(WCHAR))];
            hr = _GetNetResource(pidn, (NETRESOURCEW*) rgBuffer, sizeof(rgBuffer));
            if (SUCCEEDED(hr))
            {
                hr = InitVariantFromBuffer(pv, rgBuffer, sizeof(rgBuffer));
                if (SUCCEEDED(hr))
                {
                    // Fixup pointers in structure to point within the variant
                    // instead of our stack variable (rgBuffer):
                    ASSERT(pv->vt == (VT_ARRAY | VT_UI1));
                    NETRESOURCEW* pnrw = (NETRESOURCEW*) pv->parray->pvData;
                    if (pnrw->lpLocalName)
                    {
                        pnrw->lpLocalName = (LPWSTR) ((BYTE*) pnrw +
                                                      ((BYTE*) pnrw->lpLocalName - rgBuffer));
                    }
                    if (pnrw->lpRemoteName)
                    {
                        pnrw->lpRemoteName = (LPWSTR) ((BYTE*) pnrw +
                                                       ((BYTE*) pnrw->lpRemoteName - rgBuffer));
                    }
                    if (pnrw->lpComment)
                    {
                        pnrw->lpComment = (LPWSTR) ((BYTE*) pnrw +
                                                    ((BYTE*) pnrw->lpComment - rgBuffer));
                    }
                    if (pnrw->lpProvider)
                    {
                        pnrw->lpProvider = (LPWSTR) ((BYTE*) pnrw +
                                                     ((BYTE*) pnrw->lpProvider - rgBuffer));
                    }
                }
            }
        }
        else if (IsEqualSCID(*pscid, SCID_DESCRIPTIONID))
        {
            SHDESCRIPTIONID did;

            switch(SIL_GetType(pidl) & SHID_TYPEMASK)
            {
                case SHID_NET_DOMAIN:
                    did.dwDescriptionId = SHDID_NET_DOMAIN;
                    break;

                case SHID_NET_SERVER:
                    did.dwDescriptionId = SHDID_NET_SERVER;
                    break;

                case SHID_NET_SHARE:
                    did.dwDescriptionId = SHDID_NET_SHARE;
                    break;

                case SHID_NET_RESTOFNET:
                    did.dwDescriptionId = SHDID_NET_RESTOFNET;
                    break;

                default:
                    did.dwDescriptionId = SHDID_NET_OTHER;
                    break;
            }

            did.clsid = CLSID_NULL;
            hr = InitVariantFromBuffer(pv, &did, sizeof(did));
        }
        else if (IsEqualSCID(*pscid, SCID_Comment))
        {
            TCHAR szTemp[MAX_PATH];
            hr = InitVariantFromStr(pv, NET_CopyComment(pidn, szTemp, ARRAYSIZE(szTemp)));
        }
        else if (IsEqualSCID(*pscid, SCID_NAME))
        {
            TCHAR szTemp[MAX_PATH];
            hr = InitVariantFromStr(pv, NET_CopyResName(pidn, szTemp, ARRAYSIZE(szTemp)));
        }
    }
    else
    {
        IShellFolder2* psfFiles;
        hr = v_GetFileFolder(&psfFiles);
        if (SUCCEEDED(hr))
            hr = psfFiles->GetDetailsEx(pidl, pscid, pv);            
    }

    return hr;
}

HRESULT CNetFolder::_GetDetailsOf(UINT cColumns, LPCITEMIDLIST pidl, UINT iColumn, SHELLDETAILS *pDetails)
{
    HRESULT hr = S_OK;

    pDetails->str.uType = STRRET_CSTR;
    pDetails->str.cStr[0] = 0;

    if (NULL == pidl)
    {
        hr = GetDetailsOfInfo(s_net_cols, cColumns, iColumn, pDetails);
    }
    else
    {
        SHCOLUMNID scid;
        hr = MapColumnToSCID(iColumn, &scid);
        if (SUCCEEDED(hr))
        {
            VARIANT var;
            hr = GetDetailsEx(pidl, &scid, &var);
            if (SUCCEEDED(hr))
            {
                TCHAR szTemp[MAX_PATH];
                hr = SHFormatForDisplay(scid.fmtid,
                                        scid.pid,
                                        (PROPVARIANT*)&var,
                                        PUIFFDF_DEFAULT,
                                        szTemp,
                                        ARRAYSIZE(szTemp));
                if (SUCCEEDED(hr))
                {
                    hr = StringToStrRet(szTemp, &pDetails->str);
                }

                VariantClear(&var);
            }
        }
    }

    return hr;
}


HRESULT CNetFolder::_MapColumnToSCID(UINT cColumns, UINT iColumn, SHCOLUMNID* pscid)
{
    return MapColumnToSCIDImpl(s_net_cols, cColumns, iColumn, pscid);
}


// IPersist methods

STDMETHODIMP CNetFolder::GetClassID(CLSID* pCLSID)
{
    switch (_uDisplayType) 
    {
        case RESOURCEDISPLAYTYPE_ROOT:
            *pCLSID = CLSID_NetworkRoot;
            break;

        case RESOURCEDISPLAYTYPE_SERVER:
            *pCLSID = CLSID_NetworkServer;
            break;

        case RESOURCEDISPLAYTYPE_DOMAIN:
            *pCLSID = CLSID_NetworkDomain;
            break;

        case RESOURCEDISPLAYTYPE_SHARE:
            *pCLSID = CLSID_NetworkShare;
            break;

        default:
            *pCLSID = CLSID_NULL;
            break;
    }
    
    return S_OK;
}


// IPersistFolder method

STDMETHODIMP CNetFolder::Initialize(LPCITEMIDLIST pidl)
{
    ILFree(_pidl);
    ILFree(_pidlTarget);
    _pidl = _pidlTarget = NULL;

    return SHILClone(pidl, &_pidl);
}


// IPersistFolder2 method

STDMETHODIMP CNetFolder::GetCurFolder(LPITEMIDLIST* ppidl)
{
    return GetCurFolderImpl(_pidl, ppidl);
}


// IPersistFolder3 methods

STDMETHODIMP CNetFolder::InitializeEx(IBindCtx *pbc, LPCITEMIDLIST pidlRoot, const PERSIST_FOLDER_TARGET_INFO *pfti)
{
    ILFree(_pidl);
    ILFree(_pidlTarget);
    _pidl = _pidlTarget = NULL;

    HRESULT hr = SHILClone(pidlRoot, &_pidl);
    if (SUCCEEDED(hr) && pfti && pfti->pidlTargetFolder)
    {
        hr = SHILClone(pfti->pidlTargetFolder, &_pidlTarget);
    }

    return hr;
}

STDMETHODIMP CNetFolder::GetFolderTargetInfo(PERSIST_FOLDER_TARGET_INFO *pfti)
{
    HRESULT hr = S_OK;

    ZeroMemory(pfti, sizeof(*pfti));

    if (_pidlTarget)
        hr = SHILClone(_pidlTarget, &pfti->pidlTargetFolder);
    
    pfti->dwAttributes = FILE_ATTRIBUTE_DIRECTORY; // maybe add system?
    pfti->csidl = -1;

    return hr;
}


// IShellIconOverlay

HRESULT CNetFolder::_GetIconOverlayInfo(LPCIDNETRESOURCE pidn, int *pIndex, DWORD dwFlags)
{
    HRESULT hr = E_FAIL;

    //
    // For netshare objects we want to get the icon overlay.
    // If the share is "pinned" to be available offline it will
    // have the "Offline Files" overlay.
    //
    if (RESOURCEDISPLAYTYPE_SHARE == NET_GetDisplayType(pidn))
    {
        TCHAR szPath[MAX_PATH];
        hr = _GetPathForItem(pidn, szPath);
        if (SUCCEEDED(hr))
        {
            IShellIconOverlayManager *psiom;
            hr = GetIconOverlayManager(&psiom);
            if (SUCCEEDED(hr))
            {
                WCHAR szPathW[MAX_PATH];
                SHTCharToUnicode(szPath, szPathW, ARRAYSIZE(szPathW));
                hr = psiom->GetFileOverlayInfo(szPathW, 0, pIndex, dwFlags);
                psiom->Release();
            }
        }
    }

    return hr;
}


STDMETHODIMP CNetFolder::GetOverlayIndex(LPCITEMIDLIST pidl, int *pIndex)
{
    HRESULT hr = E_FAIL;
    LPCIDNETRESOURCE pidn = NET_IsValidID(pidl);

    if (NULL != pidn)
    {
        hr = _GetIconOverlayInfo(pidn, pIndex, SIOM_OVERLAYINDEX);
    }
    return hr;
}


STDMETHODIMP CNetFolder::GetOverlayIconIndex(LPCITEMIDLIST pidl, int *pIndex)
{
    HRESULT hr = E_FAIL;
    LPCIDNETRESOURCE pidn = NET_IsValidID(pidl);

    if (NULL != pidn)
    {
        hr = _GetIconOverlayInfo(pidn, pIndex, SIOM_ICONINDEX);
    }
    return hr;
}



//
// Helper function to allow external callers to query information from a
// network pidl...
//
// NOTE NOTE - This function returns a NETRESOURCE structure whose string
// pointers are not valid.  On Win95 they were pointers back into the pidl's
// strings (even though the strings were copied into the supplied pv buffer.)
// Now we make the pointers really point into the buffer.
//
HRESULT CNetFolder::_GetNetResource(LPCIDNETRESOURCE pidn, NETRESOURCEW* pnr, int cb)
{
    TCHAR szStrings[3][MAX_PATH];
    LPWSTR psz, lpsz[3] = {NULL, NULL, NULL};
    int i, cchT;

    if (cb < sizeof(*pnr))
        return DISP_E_BUFFERTOOSMALL;

    ZeroMemory(pnr, cb);

    NET_CopyResName(pidn, szStrings[0], ARRAYSIZE(szStrings[0]));
    NET_CopyComment(pidn, szStrings[1], ARRAYSIZE(szStrings[1]));
    _GetProvider(pidn, NULL, szStrings[2], ARRAYSIZE(szStrings[2]));

    // Fill in some of the stuff first.
    // pnr->dwScope = 0;
    pnr->dwType = NET_GetType(pidn);
    pnr->dwDisplayType = NET_GetDisplayType(pidn);
    pnr->dwUsage = NET_GetUsage(pidn);
    // pnr->lpLocalName = NULL;

    // Now lets copy the strings into the buffer and make the pointers
    // relative to the buffer...
    psz = (LPWSTR)(pnr + 1);
    cb -= sizeof(*pnr);

    for (i = 0; i < ARRAYSIZE(szStrings); i++)
    {
        if (*szStrings[i])
        {
            cchT = (lstrlen(szStrings[i]) + 1) * sizeof(TCHAR);
            if (cchT <= cb)
            {
                SHTCharToUnicode(szStrings[i], psz, cb/sizeof(TCHAR));
                lpsz[i] = psz;
                psz += cchT;
                cb -= cchT * sizeof(TCHAR);
            }
            else
            {
                // A hint that the structure is ok,
                // but the strings are missing
                SetLastError(ERROR_INSUFFICIENT_BUFFER);
            }
        }
    }

    pnr->lpRemoteName = lpsz[0];
    pnr->lpComment    = lpsz[1];
    pnr->lpProvider   = lpsz[2];

    return S_OK;
}

//
// This function opens a reg. database key based on the "network provider".
//
// Returns:        hkey
//
// The caller is responsibe to close the key by calling RegCloseKey().
//
HKEY CNetFolder::_OpenProviderKey(LPCIDNETRESOURCE pidn)
{
    TCHAR szProvider[MAX_PATH];

    if (_GetProvider(pidn, NULL, szProvider, ARRAYSIZE(szProvider)))
    {
        HKEY hkeyProgID = NULL;
        ReplaceSpacesWithUnderscore(szProvider);
        RegOpenKey(HKEY_CLASSES_ROOT, szProvider, &hkeyProgID);
        return hkeyProgID;
    }
    return NULL;
}

//
// This function opens a reg. database key based on the network provider type.
// The type is a number that is not localized, as opposed to the provider name
// which may be localized.
//
// Arguments:
//  pidlAbs -- Absolute IDList to a network resource object.
//
// Returns:        hkey
//
// Notes:
//  The caller is responsible to close the key by calling RegCloseKey().
//

HKEY CNetFolder::_OpenProviderTypeKey(LPCIDNETRESOURCE pidn)
{
    HKEY hkeyProgID = NULL;
    TCHAR szProvider[MAX_PATH];

    if (_GetProvider(pidn, NULL, szProvider, ARRAYSIZE(szProvider)))
    {
        // Now that we've got the provider name, get the provider id.
        DWORD dwType;
        if (WNetGetProviderType(szProvider, &dwType) == WN_SUCCESS)
        {
            // convert nis.wNetType to a string, and then open the key
            // HKEY_CLASSES_ROOT\Network\Type\<type string>

            TCHAR szRegValue[MAX_PATH];
            wsprintf(szRegValue, TEXT("Network\\Type\\%d"), HIWORD(dwType));
            RegOpenKey(HKEY_CLASSES_ROOT, szRegValue, &hkeyProgID);
        }
    }

    return hkeyProgID;
}

HRESULT CNetFolder::_OpenKeys(LPCIDNETRESOURCE pidn, HKEY ahkeys[NKID_COUNT])
{
    // See if there is a key specific to the type of Network object...
    COMPILETIME_ASSERT(6 == NKID_COUNT);
    ahkeys[0] = ahkeys[1] = ahkeys[2] = ahkeys[3] = ahkeys[4] = ahkeys[5] = NULL;
    ahkeys[NKID_PROVIDERTYPE] = _OpenProviderTypeKey(pidn);
    ahkeys[NKID_PROVIDER] = _OpenProviderKey(pidn);

    if (NET_GetDisplayType(pidn) == RESOURCEDISPLAYTYPE_SHARE)
        RegOpenKey(HKEY_CLASSES_ROOT, TEXT("NetShare"), &ahkeys[NKID_NETCLASS]);
    else if (NET_GetDisplayType(pidn) == RESOURCEDISPLAYTYPE_SERVER)
        RegOpenKey(HKEY_CLASSES_ROOT, TEXT("NetServer"), &ahkeys[NKID_NETCLASS]);

    RegOpenKey(HKEY_CLASSES_ROOT, TEXT("Network"), &ahkeys[NKID_NETWORK]);

    // make sure it is not a printer before adding "Folder" or "directory"

    if (!_IsPrintShare(pidn))
    {
        // Shares should also support directory stuff...
        if (NET_GetDisplayType(pidn) == RESOURCEDISPLAYTYPE_SHARE)
            RegOpenKey(HKEY_CLASSES_ROOT, TEXT("Directory"), &ahkeys[NKID_DIRECTORY]);

        RegOpenKey(HKEY_CLASSES_ROOT, c_szFolderClass, &ahkeys[NKID_FOLDER]);
    }

    return S_OK;
}

#define WNFMT_PLATFORM  WNFMT_ABBREVIATED | WNFMT_INENUM

//
//  This function retrieves the formatted (display) name of the specified network object.
//
HRESULT CNetFolder::_GetFormatName(LPCIDNETRESOURCE pidn, STRRET* pStrRet)
{
    HRESULT hr = E_FAIL;
    TCHAR szName[MAX_PATH];

    NET_CopyResName(pidn, szName, ARRAYSIZE(szName));
    
    if (NET_GetDisplayType(pidn) == RESOURCEDISPLAYTYPE_SERVER)
    {
        TCHAR szMachineName[MAX_PATH];
        TCHAR szComment[MAX_PATH];

        NET_CopyResName(pidn, szMachineName, ARRAYSIZE(szMachineName));
        NET_CopyComment(pidn, szComment, ARRAYSIZE(szComment));

        hr = SHBuildDisplayMachineName(szMachineName, szComment, szName, ARRAYSIZE(szName));
    }

    if (FAILED(hr) && 
        (NET_GetDisplayType(pidn) != RESOURCEDISPLAYTYPE_ROOT) && 
        (NET_GetDisplayType(pidn) != RESOURCEDISPLAYTYPE_NETWORK))
    {
        TCHAR szDisplayName[MAX_PATH], szProvider[MAX_PATH];
        DWORD dwSize = ARRAYSIZE(szDisplayName);

        LPCTSTR pszProvider = _GetProvider(pidn, NULL, szProvider, ARRAYSIZE(szProvider));
        if (pszProvider)
        {   
            DWORD dwRes = WNetFormatNetworkName(pszProvider, szName, szDisplayName, &dwSize, WNFMT_PLATFORM, 8 + 1 + 3);
            if (dwRes == WN_SUCCESS)            
                lstrcpy(szName, szDisplayName);
        }
    }

    return StringToStrRet(szName, pStrRet);
}


//
// resolve non-UNC share names (novell) to UNC style names
//
// returns:
//      TRUE    translated the name
//      FALSE   didn't translate (maybe error case)
//
// WARNING: If we use too much stack space then we will cause
//          faults by over flowing the stack.  Millennium #94818
BOOL CNetFolder::_GetPathForShare(LPCIDNETRESOURCE pidn, LPTSTR pszPath)
{
    BOOL fRet = FALSE;

    *pszPath = TEXT('\0');

    LPTSTR pszAccessName = (LPTSTR)LocalAlloc(LPTR, sizeof(TCHAR) * MAX_PATH * 3);
    if (pszAccessName)
    {
        LPTSTR pszRemoteName = pszAccessName + MAX_PATH;
        LPTSTR pszProviderName = pszRemoteName + MAX_PATH;

        NET_CopyResName(pidn, pszRemoteName, MAX_PATH);
        if (NULL != _pszResName)
        {
            //
            // Combine the folder name with the share name
            // to create a UNC path.
            //
            // Borrow the pszProviderName buffer for a bit.
            //
            PathCombine(pszProviderName, _pszResName, pszRemoteName);

            //
            // To be safe: UNC prefix implies that name is available using FS access
            // Theoretically it also should be routed to MPR, but it is late to do this
            //
            if (PathIsUNC(pszProviderName))
            {
                lstrcpy(pszPath, pszProviderName);
                fRet = FALSE;
            }
            else
            {
                pszProviderName[0] = TEXT('\0');
            }
        }

        if (!*pszPath)
        {
            // Check cache
            ENTERCRITICAL;
            if (lstrcmpi(g_szLastAttemptedJunctionName, pszRemoteName) == 0)
            {
                // cache hit
                lstrcpy(pszPath, g_szLastResolvedJunctionName);
                fRet = TRUE;
            }
            LEAVECRITICAL;
        }

        if (!*pszPath)
        {
            NETRESOURCE nr = {0};
            DWORD err, dwRedir, dwResult;
            DWORD cchAccessName;

            nr.lpRemoteName = pszRemoteName;
            nr.lpProvider = (LPTSTR) _GetProvider(pidn, NULL, pszProviderName, MAX_PATH);
            nr.dwType = NET_GetType(pidn);
            nr.dwUsage = NET_GetUsage(pidn);
            nr.dwDisplayType = NET_GetDisplayType(pidn);

            dwRedir = CONNECT_TEMPORARY;

            // Prepare access name buffer and net resource request buffer
            //
            cchAccessName = MAX_PATH;
            pszAccessName[0] = 0;

            err = WNetUseConnection(NULL, &nr, NULL, NULL, dwRedir, pszAccessName, &cchAccessName, &dwResult);
            if ((WN_SUCCESS != err) || !pszAccessName[0])
            {
                // perf idea: might be good to cache the last failed junction bind
                // and early out on the next attempt.  One slight problem this
                // might encounter: what if we cache a failure, the user changes
                // state to fix the problem, but we hit our failure cache...
                //
                lstrcpy(pszPath, pszRemoteName);
                fRet = FALSE;
            }
            else
            {
                // Get the return name
                lstrcpy(pszPath, pszAccessName);
                fRet = TRUE;

                // Update success cache entry
                ENTERCRITICAL;

                lstrcpy(g_szLastAttemptedJunctionName, pszRemoteName);
                lstrcpy(g_szLastResolvedJunctionName, pszAccessName);

                LEAVECRITICAL;
            }
        }

        LocalFree(pszAccessName);
    }
    return fRet;
}

// in:
//      pidn    may be multi-level net resource pidl like
//              [entire net] [provider] [server] [share] [... file sys]
//           or [server] [share] [... file sys]

HRESULT CNetFolder::_GetPathForItem(LPCIDNETRESOURCE pidn, LPTSTR pszPath)
{
    *pszPath = 0;

    // loop down
    for (; !ILIsEmpty((LPCITEMIDLIST)pidn) ; pidn = (LPCIDNETRESOURCE)_ILNext((LPCITEMIDLIST)pidn))
    {
        if (NET_GetFlags(pidn) & SHID_JUNCTION)     // \\server\share or strike/sys
        {
            _GetPathForShare(pidn, pszPath);
            break;  // below this we don't know about any of the PIDLs
        }
        else
        {
            // if this is entire network then return the canonical name for
            // this object.

            if (NET_GetDisplayType(pidn) == RESOURCEDISPLAYTYPE_ROOT)
                StrCpyN(pszPath, TEXT("EntireNetwork"), MAX_PATH);
            else
                NET_CopyResName(pidn, pszPath, MAX_PATH);
        }
    }
    return *pszPath ? S_OK : E_NOTIMPL;
}

HRESULT CNetFolder::_GetPathForItemW(LPCIDNETRESOURCE pidn, LPWSTR pszPath)
{
    return _GetPathForItem(pidn, pszPath);
}


// in:
//  pidl
//
// takes the last items and create a folder for it, assuming the first section is the 
// used to initialze.  the riid and ppv are used to return an object.
//

HRESULT CNetFolder::_CreateFolderForItem(LPBC pbc, LPCITEMIDLIST pidl, LPCITEMIDLIST pidlTarget, LPCIDNETRESOURCE pidnForProvider, REFIID riid, void **ppv)
{
    LPCITEMIDLIST pidlLast = ILFindLastID(pidl);
    LPCIDNETRESOURCE pidn = NET_IsValidID(pidlLast);

    if (!pidn)
        return E_INVALIDARG;

    HRESULT hr;
    if (NET_IsRemoteFld(pidn))
    {
        // note: I think this is dead functionality. it was used in NT4 but we can't find
        // the impl of this CLSID_Remote anymore...
        IPersistFolder * ppf;
        hr = SHCoCreateInstance(NULL, &CLSID_Remote, NULL, IID_PPV_ARG(IPersistFolder, &ppf));
        if (SUCCEEDED(hr))
        {
            hr= ppf->Initialize(pidl);
            if (SUCCEEDED(hr))
                hr = ppf->QueryInterface(riid, ppv);
            ppf->Release();
        }
    }
    else if (NET_GetFlags(pidn) & SHID_JUNCTION)     // \\server\share or strike/sys
    {
        PERSIST_FOLDER_TARGET_INFO * ppfti = (PERSIST_FOLDER_TARGET_INFO *) LocalAlloc(LPTR, sizeof(PERSIST_FOLDER_TARGET_INFO));
        if (ppfti)
        {
            ppfti->pidlTargetFolder = (LPITEMIDLIST)pidlTarget;    
            _GetPathForItemW(pidn, ppfti->szTargetParsingName);
            ppfti->csidl = -1;
            ppfti->dwAttributes = FILE_ATTRIBUTE_DIRECTORY; // maybe add system?

            hr = CFSFolder_CreateFolder(NULL, pbc, pidl, ppfti, riid, ppv);
            LocalFree(ppfti);
        }
        else
            hr = E_OUTOFMEMORY;
    }
    else
    {
        TCHAR szPath[MAX_PATH];
        NET_CopyResName(pidn, szPath, ARRAYSIZE(szPath));

        hr = _CreateInstance(pidl, pidlTarget, NET_GetDisplayType(pidn), pidnForProvider, szPath, riid, ppv);
    }
    return hr;
}


// get the provider for an item or the folder itself. since some items don't have the
// provider stored we fall back to the folder to get the provider in that case
//
//  in:
//      pidn    item to get provider for. if NULL get provider for the folder
//      pbc     IBindCtx to get provider for.  if NULL get provider from pidn or folder.
//
// returns:
//      NULL        no provider in the item or the folder
//      non NULL    address of passed in buffer

LPCTSTR CNetFolder::_GetProvider(LPCIDNETRESOURCE pidn, IBindCtx *pbc, LPTSTR pszProvider, UINT cchProvider)
{
    // attempt to get the provider from the property bag
    IPropertyBag *ppb;
    if (pbc && SUCCEEDED(pbc->GetObjectParam(STR_PARSE_NETFOLDER_INFO, (IUnknown**)&ppb)))
    {
        HRESULT hr = SHPropertyBag_ReadStr(ppb, STR_PARSE_NETFOLDER_PROVIDERNAME, pszProvider, cchProvider);
        ppb->Release();
        if (SUCCEEDED(hr) && *pszProvider)
        {
            return pszProvider;
        }
    }

    // from the IDLIST
    if (pidn && NET_CopyProviderName(pidn, pszProvider, cchProvider))
        return pszProvider;

    // from our state
    if (_pidnForProvider)
    {
        NET_CopyProviderName(_pidnForProvider, pszProvider, cchProvider);
        return pszProvider;
    }

    *pszProvider = 0;
    return NULL;
}


const NETPROVIDERS c_rgProviderMap[] = 
{
    { TEXT("Microsoft Network"), HIWORD(WNNC_NET_LANMAN) },
    { TEXT("NetWare"),           HIWORD(WNNC_NET_NETWARE) }
};


// construct a net idlist either copying the existing data from a pidl or 
// from a NETRESOURCE structure

HRESULT CNetFolder::_CreateNetIDList(LPIDNETRESOURCE pidnIn, 
                                     LPCTSTR pszName, LPCTSTR pszProvider, LPCTSTR pszComment, 
                                     LPITEMIDLIST *ppidl)
{
    LPBYTE pb;
    UINT cbmkid = sizeof(IDNETRESOURCE) - sizeof(CHAR);
    UINT cchName, cchProvider, cchComment, cbProviderType = 0;
    LPIDNETRESOURCE pidn;
    WORD wNetType = 0;
    BOOL fUnicode = FALSE;
    UINT cchAnsiName, cchAnsiProvider, cchAnsiComment;
    CHAR szAnsiName[MAX_PATH], szAnsiProvider[MAX_PATH], szAnsiComment[MAX_PATH];

    ASSERT(ppidl != NULL);
    *ppidl = NULL;

    if (!pszName)
        pszName = c_szNULL;     // For now put in an empty string...

    if (pszProvider)
        cbProviderType += sizeof(WORD);
    
    // Win9x shipped with one set of provider name which are 
    // different on NT.  Therefore lets convert the NT one to
    // something that Win9x can understand.

    if (pszProvider)
    {
        cbProviderType = sizeof(WORD);
        DWORD dwType, dwRes = WNetGetProviderType(pszProvider, &dwType);
        if (dwRes == WN_SUCCESS)
        {
            wNetType = HIWORD(dwType);
            for (int i = 0; i < ARRAYSIZE(c_rgProviderMap); i++)
            {
                if (c_rgProviderMap[i].wNetType == wNetType)
                {
                    pszProvider = c_rgProviderMap[i].lpName;
                    break;
                }
            }
        }
    }

    // compute the string lengths ready to build an IDLIST

    cchName = lstrlen(pszName)+1;
    cchProvider = pszProvider ? lstrlen(pszProvider)+1 : 0;
    cchComment = pszComment ? lstrlen(pszComment)+1 : 0;

    cchAnsiName = 0;
    cchAnsiProvider = 0;
    cchAnsiComment = 0;

    fUnicode  = !DoesStringRoundTrip(pszName, szAnsiName, ARRAYSIZE(szAnsiProvider));
    cchAnsiName = lstrlenA(szAnsiName)+1;

    if (pszProvider)
    {
        fUnicode |= !DoesStringRoundTrip(pszProvider, szAnsiProvider, ARRAYSIZE(szAnsiProvider));
        cchAnsiProvider = lstrlenA(szAnsiProvider)+1;
    }

    if (pszComment)
    {
        fUnicode |= !DoesStringRoundTrip(pszComment, szAnsiComment, ARRAYSIZE(szAnsiComment));
        cchAnsiComment = lstrlenA(szAnsiComment)+1;
    }

    // allocate and fill the IDLIST header

    cbmkid += cbProviderType+cchAnsiName + cchAnsiProvider + cchAnsiComment;

    if (fUnicode)
        cbmkid += (sizeof(WCHAR)*(cchName+cchProvider+cchComment));

    pidn = (LPIDNETRESOURCE)_ILCreate(cbmkid + sizeof(USHORT));
    if (!pidn)
        return E_OUTOFMEMORY;

    pidn->cb = (WORD)cbmkid;
    pidn->bFlags = pidnIn->bFlags;
    pidn->uType = pidnIn->uType;
    pidn->uUsage = pidnIn->uUsage;

    if (pszProvider)
        pidn->uUsage |= NET_HASPROVIDER;

    if (pszComment)
        pidn->uUsage |= NET_HASCOMMENT;

    pb = (LPBYTE) pidn->szNetResName;

    //
    // write the ANSI strings into the IDLIST
    //

    StrCpyA((PSTR) pb, szAnsiName);
    pb += cchAnsiName;

    if (pszProvider)
    {
        StrCpyA((PSTR) pb, szAnsiProvider);
        pb += cchAnsiProvider;
    }

    if (pszComment)
    {
        StrCpyA((PSTR) pb, szAnsiComment);
        pb += cchAnsiComment;
    }

    // if we are going to be UNICODE then lets write those strings also.
    // Note that we must use unaligned string copies since the is no
    // promse that the ANSI strings will have an even number of characters
    // in them.
    if (fUnicode)
    {
        pidn->uUsage |= NET_UNICODE;
      
        ualstrcpyW((UNALIGNED WCHAR *)pb, pszName);
        pb += cchName*sizeof(WCHAR);

        if (pszProvider)
        {
            ualstrcpyW((UNALIGNED WCHAR *)pb, pszProvider);
            pb += cchProvider*sizeof(WCHAR);
        }

        if (pszComment)
        {
            ualstrcpyW((UNALIGNED WCHAR *)pb, pszComment);
            pb += cchComment*sizeof(WCHAR);
        }
    }

    //
    // and the trailing provider type
    //

    if (cbProviderType)
    {
        // Store the provider type
        pb = (LPBYTE)pidn + pidn->cb - sizeof(WORD);
        *((UNALIGNED WORD *)pb) = wNetType;
    }

    *ppidl = (LPITEMIDLIST)pidn;
    return S_OK;
}


// wrapper for converting a NETRESOURCE into an IDLIST via _CreateNetPidl

HRESULT CNetFolder::_NetResToIDList(NETRESOURCE *pnr, 
                                    BOOL fKeepNullRemoteName, 
                                    BOOL fKeepProviderName, 
                                    BOOL fKeepComment, 
                                    LPITEMIDLIST *ppidl)
{
    NETRESOURCE nr = *pnr;
    LPITEMIDLIST pidl;
    LPTSTR pszName, pszProvider, pszComment;
    IDNETRESOURCE idn;
    LPTSTR psz;

    if (ppidl)
        *ppidl = NULL;

    switch (pnr->dwDisplayType) 
    {
    case RESOURCEDISPLAYTYPE_NETWORK:
        pszName = pnr->lpProvider;
        break;

    case RESOURCEDISPLAYTYPE_ROOT:
        pszName =pnr->lpComment;
        break;

    default:
        {
            pszName = pnr->lpRemoteName;

            if (!fKeepNullRemoteName && (!pszName || !*pszName))
                return E_FAIL;

            if (pszName && *pszName)
            {
                psz = (LPTSTR)SkipServerSlashes(pnr->lpRemoteName);
                if ( *psz )
                    PathMakePretty(psz);
            }
        }
        break;
    }

    pszProvider = fKeepProviderName ? nr.lpProvider:NULL;
    pszComment = fKeepComment ? nr.lpComment:NULL;
       
    idn.bFlags = (BYTE)(SHID_NET | (pnr->dwDisplayType & 0x0f));
    idn.uType  = (BYTE)(pnr->dwType & 0x0f);
    idn.uUsage = (BYTE)(pnr->dwUsage & 0x0f);

    // Is the current resource a share of some kind and not a container
    if ((pnr->dwDisplayType == RESOURCEDISPLAYTYPE_SHARE || pnr->dwDisplayType == RESOURCEDISPLAYTYPE_SHAREADMIN) &&
        !(pnr->dwUsage & RESOURCEUSAGE_CONTAINER))
    {
        // If so, remember to delegate children of this folder to FSFolder
        idn.bFlags |= (BYTE)SHID_JUNCTION;    // \\server\share type thing
    }

    HRESULT hr = _CreateNetIDList(&idn, pszName, pszProvider, pszComment, &pidl);
    if (SUCCEEDED(hr))
    {
        if (ppidl)
            *ppidl = pidl;
    }

    return hr;
}

HRESULT CNetFolder::_CreateEntireNetwork(LPITEMIDLIST *ppidl)
{
    TCHAR szPath[MAX_PATH];
    NETRESOURCE nr = {0};

    // We need to add the Rest of network entry.  This is psuedo
    // bogus, as we should either always do it ourself or have
    // MPR always do it, but here it goes...
    LoadString(HINST_THISDLL, IDS_RESTOFNET, szPath, ARRAYSIZE(szPath));
    nr.dwDisplayType = RESOURCEDISPLAYTYPE_ROOT;
    nr.dwType = RESOURCETYPE_ANY;
    nr.dwUsage = RESOURCEUSAGE_CONTAINER;
    nr.lpComment = szPath;

    return _NetResToIDList(&nr, FALSE, FALSE, FALSE, ppidl);
}

HRESULT CNetFolder::_CreateEntireNetworkFullIDList(LPITEMIDLIST *ppidl)
{
    // CLSID_NetworkPlaces\EntireNetwork
    return SHILCreateFromPath(TEXT("::{208D2C60-3AEA-1069-A2D7-08002B30309D}\\EntireNetwork"), ppidl, NULL);
}

//
// To be called back from within CDefFolderMenu
//
STDAPI CNetwork_DFMCallBackBG(IShellFolder *psf, HWND hwnd,
                              IDataObject *pdtobj, UINT uMsg, 
                              WPARAM wParam, LPARAM lParam)
{
    HRESULT hr = S_OK;
    CNetFolder *pThis = FolderToNetFolder(psf);

    if (NULL == pThis)
        return E_UNEXPECTED;

    switch(uMsg)
    {
    case DFM_MERGECONTEXTMENU_BOTTOM:
        if (!(wParam & (CMF_VERBSONLY | CMF_DVFILE)))
        {
            CDefFolderMenu_MergeMenu(HINST_THISDLL, POPUP_PROPERTIES_BG, 0, (LPQCMINFO)lParam);
        }
        break;

    case DFM_GETHELPTEXT:
        LoadStringA(HINST_THISDLL, LOWORD(wParam) + IDS_MH_FSIDM_FIRST, (LPSTR)lParam, HIWORD(wParam));
        break;

    case DFM_GETHELPTEXTW:
        LoadStringW(HINST_THISDLL, LOWORD(wParam) + IDS_MH_FSIDM_FIRST, (LPWSTR)lParam, HIWORD(wParam));
        break;

    case DFM_INVOKECOMMAND:
        switch (wParam)
        {
        case FSIDM_PROPERTIESBG:
            hr = SHPropertiesForPidl(hwnd, pThis->_pidl, (LPCTSTR)lParam);
            break;

        default:
            // This is one of view menu items, use the default code.
            hr = S_FALSE;
            break;
        }
        break;

    default:
        hr = E_NOTIMPL;
        break;
    }

    return hr;
}


//
// To be called back from within CDefFolderMenu
//
STDAPI CNetFolder::DFMCallBack(IShellFolder* psf, HWND hwnd,
                                  IDataObject* pdtobj, UINT uMsg, 
                                  WPARAM wParam, LPARAM lParam)
{
    HRESULT hr = S_OK;

    switch(uMsg)
    {
    case DFM_MERGECONTEXTMENU:
        if (pdtobj)
        {
            STGMEDIUM medium;
            LPIDA pida;
            LPQCMINFO pqcm = (LPQCMINFO)lParam;
            UINT idCmdBase = pqcm->idCmdFirst; // must be called before merge
            CDefFolderMenu_MergeMenu(HINST_THISDLL, POPUP_NETWORK_ITEM, 0, pqcm);

            pida = DataObj_GetHIDA(pdtobj, &medium);
            if (pida)
            {
                if (pida->cidl > 0)
                {
                    LPIDNETRESOURCE pidn = (LPIDNETRESOURCE)IDA_GetIDListPtr(pida, 0);

                    // Only enable "connect" command if the first one is a share.
                    if (pidn)
                    {
                        ULONG rgf = 0;
                        if(NET_GetFlags(pidn) & SHID_JUNCTION &&
                            !SHRestricted(REST_NONETCONNECTDISCONNECT))
                        {
                            EnableMenuItem(pqcm->hmenu, idCmdBase + FSIDM_CONNECT,
                                MF_CHECKED | MF_BYCOMMAND);
                        }
                    }
                }
                HIDA_ReleaseStgMedium(pida, &medium);
            }
        }
        break;

    case DFM_GETHELPTEXT:
        LoadStringA(HINST_THISDLL, LOWORD(wParam) + IDS_MH_FSIDM_FIRST, (LPSTR)lParam, HIWORD(wParam));
        break;

    case DFM_GETHELPTEXTW:
        LoadStringW(HINST_THISDLL, LOWORD(wParam) + IDS_MH_FSIDM_FIRST, (LPWSTR)lParam, HIWORD(wParam));
        break;

    case DFM_INVOKECOMMAND:
        switch(wParam)
        {
        case DFM_CMD_PROPERTIES:
            hr = SHLaunchPropSheet(_PropertiesThreadProc, pdtobj, (LPCTSTR)lParam, psf, NULL);
            break;

        case DFM_CMD_LINK:
            {
                hr = S_FALSE; // do the default shortcut stuff
                CNetFolder *pThis = FolderToNetFolder(psf);
                if (pThis)
                {
                    // net hood special case.  in this case we want to create the shortuct
                    // in the net hood, not offer to put this on the desktop
                    IShellFolder2* psfFiles;
                    if (SUCCEEDED(pThis->v_GetFileFolder(&psfFiles)))
                    {
                        CFSFolder_CreateLinks(hwnd, psfFiles, pdtobj, (LPCTSTR)lParam, CMIC_MASK_FLAG_NO_UI);
                        hr = S_OK;    // we created the links
                    }
                }
            }
            break;

        case FSIDM_CONNECT:
            if (pdtobj)
            {
                STGMEDIUM medium;
                LPIDA pida = DataObj_GetHIDA(pdtobj, &medium);
                if (pida)
                {
                    for (UINT i = 0; i < pida->cidl; i++)
                    {
                        LPIDNETRESOURCE pidn = (LPIDNETRESOURCE)IDA_GetIDListPtr(pida, i);

                        // Only execute "connect" on shares.
                        if (NET_GetFlags(pidn) & SHID_JUNCTION)
                        {
                            TCHAR szName[MAX_PATH];
                            LPTSTR pszName = NET_CopyResName(pidn, szName, ARRAYSIZE(szName));
                            DWORD err = SHStartNetConnectionDialog(hwnd, pszName, RESOURCETYPE_DISK);
                            DebugMsg(DM_TRACE, TEXT("CNet FSIDM_CONNECT (%s, %x)"), szName, err);

                            // events will get generated automatically
                        }
                    }
                    HIDA_ReleaseStgMedium(pida, &medium);
                }
            }
            break;

        default:
            // This is one of view menu items, use the default code.
            hr = S_FALSE;
            break;
        }
        break;

    default:
        hr = E_NOTIMPL;
        break;
    }
    return hr;
}

STDAPI CNetFolder::PrinterDFMCallBack(IShellFolder* psf, HWND hwnd,
                                      IDataObject* pdtobj, UINT uMsg, 
                                      WPARAM wParam, LPARAM lParam)
{
    HRESULT hr = S_OK;

    switch(uMsg)
    {
    case DFM_MERGECONTEXTMENU:
        //
        //  Returning S_FALSE indicates no need to get verbs from
        // extensions.
        //
        hr = S_FALSE;
        break;

    // if anyone hooks our context menu, we want to be on top (Open)
    case DFM_MERGECONTEXTMENU_TOP:
        if (pdtobj)
        {
            LPQCMINFO pqcm = (LPQCMINFO)lParam;

            // insert verbs
            CDefFolderMenu_MergeMenu(HINST_THISDLL, POPUP_NETWORK_PRINTER, 0, pqcm);
            SetMenuDefaultItem(pqcm->hmenu, 0, MF_BYPOSITION);
        }
        break;

    case DFM_GETHELPTEXT:
        LoadStringA(HINST_THISDLL, LOWORD(wParam) + IDS_MH_FSIDM_FIRST, (LPSTR)lParam, HIWORD(wParam));
        break;

    case DFM_GETHELPTEXTW:
        LoadStringW(HINST_THISDLL, LOWORD(wParam) + IDS_MH_FSIDM_FIRST, (LPWSTR)lParam, HIWORD(wParam));
        break;

    case DFM_INVOKECOMMAND:
        switch (wParam)
        {
        case DFM_CMD_PROPERTIES:
            hr = SHLaunchPropSheet(_PropertiesThreadProc, pdtobj, (LPCTSTR)lParam, psf, NULL);
            break;

        case DFM_CMD_LINK:
            // do the default create shortcut crap
            return S_FALSE;

        case FSIDM_OPENPRN:
        case FSIDM_NETPRN_INSTALL:
        {
            STGMEDIUM medium;
            LPIDA pida = DataObj_GetHIDA(pdtobj, &medium);
            if (pida)
            {
                UINT action;

                // set up the operation we are going to perform
                switch (wParam) 
                {
                case FSIDM_OPENPRN:
                    action = PRINTACTION_OPENNETPRN;
                    break;
                case FSIDM_NETPRN_INSTALL:
                    action = PRINTACTION_NETINSTALL;
                    break;
                default: // FSIDM_CONNECT_PRN
                    action = (UINT)-1;
                    break;
                }

                for (UINT i = 0; i < pida->cidl; i++)
                {
                    LPIDNETRESOURCE pidn = (LPIDNETRESOURCE)IDA_GetIDListPtr(pida, i);

                    // Only execute command for a net print share
                    if (_IsPrintShare(pidn))
                    {
                        TCHAR szName[MAX_PATH];
                        NET_CopyResName(pidn,szName,ARRAYSIZE(szName));

                        SHInvokePrinterCommand(hwnd, action, szName, NULL, FALSE);
                    }
                } // for (i...
                HIDA_ReleaseStgMedium(pida, &medium);
            } // if (medium.hGlobal)
            break;
        } // case ID_NETWORK_PRINTER_INSTALL, FSIDM_CONNECT_PRN

        default:
            hr = E_FAIL;
            break;

        } // switch(wparam)
        break;

    default:
        hr = E_NOTIMPL;
        break;
    }
    return hr;
}


//
// REVIEW: Almost identical code in fstreex.c
//
DWORD CALLBACK CNetFolder::_PropertiesThreadProc(void *pv)
{
    PROPSTUFF* pps = (PROPSTUFF *)pv;
    ULONG_PTR dwCookie = 0;
    ActivateActCtx(NULL, &dwCookie);
    CNetFolder *pThis = FolderToNetFolder(pps->psf);
    if (pThis)
    {
        STGMEDIUM medium;
        LPIDA pida = DataObj_GetHIDA(pps->pdtobj, &medium);
        if (pida)
        {
            // Yes, do context menu.
            HKEY ahkeys[NKID_COUNT];
            LPCIDNETRESOURCE pnid = (LPCIDNETRESOURCE)IDA_GetIDListPtr(pida, 0);
            if (pnid)
            {
                HRESULT hr = pThis->_OpenKeys(pnid, ahkeys);
                if (SUCCEEDED(hr))
                {
                    LPTSTR pszCaption = SHGetCaption(medium.hGlobal);
                    SHOpenPropSheet(pszCaption, ahkeys, ARRAYSIZE(ahkeys),
                                    &CLSID_ShellNetDefExt,
                                    pps->pdtobj, NULL, pps->pStartPage);
                    if (pszCaption)
                        SHFree(pszCaption);

                    SHRegCloseKeys(ahkeys, ARRAYSIZE(ahkeys));
                }
            }

            HIDA_ReleaseStgMedium(pida, &medium);
        }
    }
    return S_OK;
}

STDAPI CNetFolder::_AttributesCallback(IShellFolder2* psf, LPCITEMIDLIST pidl, ULONG* prgfInOut)
{
    LPCIDNETRESOURCE pidn = (LPCIDNETRESOURCE)pidl;
    ULONG rgfOut = SFGAO_CANLINK | SFGAO_HASPROPSHEET | SFGAO_HASSUBFOLDER |
                   SFGAO_FOLDER | SFGAO_FILESYSANCESTOR | SFGAO_STORAGEANCESTOR;

    if (NET_GetFlags(pidn) & SHID_JUNCTION)
    {
        if ((NET_GetType(pidn) == RESOURCETYPE_DISK) || 
            (NET_GetType(pidn) == RESOURCETYPE_ANY))
            rgfOut |= SFGAO_FILESYSTEM | SFGAO_DROPTARGET | SFGAO_CANCOPY | SFGAO_CANMOVE | SFGAO_STORAGE;
        else
            rgfOut &= ~(SFGAO_FILESYSANCESTOR | SFGAO_STORAGEANCESTOR);
    }

    if (_IsPrintShare(pidn))
    {
        rgfOut |= SFGAO_DROPTARGET; // for drag and drop printing
        rgfOut &= ~(SFGAO_FILESYSANCESTOR | SFGAO_STORAGEANCESTOR | SFGAO_FILESYSTEM | SFGAO_FOLDER | SFGAO_HASSUBFOLDER);
    }

    if (NET_IsRemoteFld(pidn))
    {
        rgfOut &= ~(SFGAO_FILESYSANCESTOR | SFGAO_STORAGEANCESTOR | SFGAO_FILESYSTEM);
    }

    *prgfInOut = rgfOut;
    return S_OK;

}

// This is only used by the CNetRootFolder subclass, but because we can only QI for
// CLSID_NetFldr, and we can't access protected members of any CNetFolder instance 
// from a member function of CNetRootFolder, we'll make it belong to CNetFolder

HRESULT CALLBACK CNetFolder::_AttributesCallbackRoot(IShellFolder2* psf, LPCITEMIDLIST pidl, ULONG* prgfInOut)
{
    HRESULT hr;
    CNetFolder* pNetF = FolderToNetFolder(psf);
    if (pNetF)
    {
        if (NET_IsValidID(pidl))
        {
            hr = pNetF->CNetFolder::GetAttributesOf(1, &pidl, prgfInOut);
        }
        else 
        {
            IShellFolder2* psfFiles;
            hr = pNetF->v_GetFileFolder(&psfFiles);
            if (SUCCEEDED(hr))
                hr = psfFiles->GetAttributesOf(1, &pidl, prgfInOut);
        }
    }
    else
        hr = E_FAIL;
    return hr;
}

// this is called by netfind.c

STDAPI CNetwork_EnumSearches(IShellFolder2* psf2, IEnumExtraSearch **ppenum)
{
    *ppenum = NULL;

    CNetFolder* pNetF = FolderToNetFolder(psf2);
    return pNetF ? pNetF->EnumSearches(ppenum) : E_INVALIDARG;
}


// given the resulting ppidl and a pszRest continue to parse through and add in the remainder
// of the file system path.

HRESULT CNetFolder::_ParseRest(LPBC pbc, LPCWSTR pszRest, LPITEMIDLIST* ppidl, DWORD* pdwAttributes)
{
    HRESULT hr = S_OK;

    // skip leading \ if there is one present
    if (pszRest && pszRest[0] == L'\\')
        pszRest++;

    if (pszRest && pszRest[0])
    {
        // need to QI to get the agregated case
        IShellFolder* psfBind;
        hr = QueryInterface(IID_PPV_ARG(IShellFolder, &psfBind));
        if (SUCCEEDED(hr))
        {
            // pass down to pick off stuff below including regitems and file names
            IShellFolder* psfSub;
            hr = psfBind->BindToObject(*ppidl, NULL, IID_PPV_ARG(IShellFolder, &psfSub));
            if (SUCCEEDED(hr))
            {
                LPITEMIDLIST pidlSubDir;
                hr = psfSub->ParseDisplayName(NULL, pbc, (LPWSTR)pszRest, NULL, &pidlSubDir, pdwAttributes);
                if (SUCCEEDED(hr))
                {
                    hr = SHILAppend(pidlSubDir, ppidl);
                }
                psfSub->Release();
            }
            psfBind->Release();
        }
    }
    else
    {
        if (pdwAttributes)
        {
            LPCITEMIDLIST apidlLast[1] = { ILFindLastID(*ppidl) };
            hr = GetAttributesOf(1, apidlLast, pdwAttributes);
        }
    }

    return hr;
}


// generate an IDLIST from the NETRESOURCESTRUCTURE we have by
// walking up its parents trying to determine where we
// are in the namespace

BOOL _GetParentResource(NETRESOURCE *pnr, DWORD *pdwbuf)
{
    if ((pnr->dwDisplayType == RESOURCEDISPLAYTYPE_ROOT) || 
           (WN_SUCCESS != WNetGetResourceParent(pnr, pnr, pdwbuf)))
    {
        return FALSE;
    }

    return TRUE;
}

HRESULT CNetFolder::_NetResToIDLists(NETRESOURCE *pnr, DWORD dwbuf, LPITEMIDLIST *ppidl)
{
    HRESULT hr = S_OK;

    do
    {
        LPITEMIDLIST pidlT;
        hr = _NetResToIDList(pnr, TRUE, TRUE, TRUE, &pidlT);
        if (SUCCEEDED(hr))
        {
            hr = SHILPrepend(pidlT, ppidl); // NOTE: SHILPrepend frees on failure
        }
    }
    while (SUCCEEDED(hr) && _GetParentResource(pnr, &dwbuf));

    return hr;
}


// get the parsable network name from the object

LPTSTR CNetFolder::_GetNameForParsing(LPCWSTR pwszName, LPTSTR pszBuffer, INT cchBuffer, LPTSTR *ppszRegItem)
{
    LPTSTR pszRegItem = NULL;
    INT cSlashes = 0;

    *ppszRegItem = NULL;
 
    SHUnicodeToTChar(pwszName, pszBuffer, cchBuffer);    

    // remove the trailing \ if there is one, NTLanMan barfs if we pass a string containing it

    INT cchPath = lstrlen(pszBuffer)-1;
    if (cchPath > 2)
    {
        // We don't need to call CharPrev if cchPath <= 2.
        // Calling CharPrev is expensive.
        LPTSTR lpTmp = CharPrev(pszBuffer, pszBuffer + cchPath + 1);
        if (*lpTmp == TEXT('\\'))
            *lpTmp = TEXT('\0');
    }

    // lets walk the name, look for \:: squence to signify the start of a regitem name,
    // and if the number of slashes is > 2 then we should bail
    
    LPTSTR pszUNC = pszBuffer+2;    
    while (pszUNC && *pszUNC && (cSlashes < 2))
    {
        if ((pszUNC[0] == TEXT('\\')) && 
                (pszUNC[1] == TEXT(':')) && (pszUNC[2] == TEXT(':')))
        {
            *ppszRegItem = pszUNC;
            break;
        }

        pszUNC = StrChr(pszUNC+1, TEXT('\\'));
        cSlashes++;
    }

    return pszUNC;
}


HRESULT CNetFolder::_ParseNetName(HWND hwnd, LPBC pbc, 
                                  LPCWSTR pwszName, ULONG* pchEaten,
                                  LPITEMIDLIST *ppidl, DWORD *pdwAttrib)
{
    HRESULT hr;
    struct _NRTEMP 
    {
        NETRESOURCE nr;
        TCHAR szBuffer[1024];
    } nrOut = { 0 };
    TCHAR szPath[MAX_PATH];
    DWORD dwres, dwbuf = sizeof(nrOut.szBuffer);
    LPTSTR pszServerShare = NULL;
    LPTSTR pszRestOfName = NULL;
    LPTSTR pszFakeRestOfName = NULL;
    LPTSTR pszRegItem = NULL;

    // validate the name before we start cracking it...

    pszFakeRestOfName = _GetNameForParsing(pwszName, szPath, ARRAYSIZE(szPath), &pszRegItem);

    NETRESOURCE nr = { 0 };
    nr.lpRemoteName = szPath;
    nr.dwType = RESOURCETYPE_ANY;

    TCHAR szProviderTemp[256];
    nr.lpProvider = (LPTSTR)_GetProvider(NULL, pbc, szProviderTemp, ARRAYSIZE(szProviderTemp));

    dwres = WNetGetResourceInformation(&nr, &nrOut.nr, &dwbuf, &pszRestOfName);    
    if (WN_SUCCESS != dwres)
    {
        TCHAR cT;
        LPTSTR pszTemp;

        // truncate the string at the \\server\share to try and parse the name,
        // note at this point if MPR resolves the alias on a Novel server this could
        // get very confusing (eg. \\strike\foo\bah may resolve to \\string\bla,
        // yet our concept of what pszRestOfName will be wrong!
    
        if (pszFakeRestOfName)
        {
            cT = *pszFakeRestOfName;
            *pszFakeRestOfName = TEXT('\0');
        }

        dwres = WNetGetResourceInformation(&nr, &nrOut.nr, &dwbuf, &pszTemp);    
        if (dwres != WN_SUCCESS)
        {
            // we failed to get  a net connection using the truncated string,
            // so lets try and use a new connect (eg. prompt for creds)

// NOTE: shouldn't we only be doing this if its an access denied type error?

            dwres = WNetUseConnection(hwnd, &nr, NULL, NULL, hwnd ? CONNECT_INTERACTIVE:0, NULL, NULL, NULL);
            if (dwres == WN_SUCCESS)
            {
                dwres = WNetGetResourceInformation(&nr, &nrOut, &dwbuf, &pszTemp);
            }
        }

        if (pszFakeRestOfName)
            *pszFakeRestOfName = cT;

        pszRestOfName = pszFakeRestOfName;
    }

    if (WN_SUCCESS == dwres)
    {
        WCHAR wszRestOfName[MAX_PATH] = { 0 };

        if (pszRestOfName)
            SHTCharToUnicode(pszRestOfName, wszRestOfName, ARRAYSIZE(wszRestOfName));

        // assume we are truncating at the regitem and parsing through

        if (pszRegItem)
            pszRestOfName = pszRegItem;

        // attempt to convert the NETRESOURCE to a string to IDLISTS by walking the
        // parents, then add in Entire Network

        hr = _NetResToIDLists(&nrOut.nr, dwbuf, ppidl);
        if (SUCCEEDED(hr))
        {
            LPITEMIDLIST pidlT;
            hr = _CreateEntireNetwork(&pidlT);
            if (SUCCEEDED(hr))
            {
                hr = SHILPrepend(pidlT, ppidl); // NOTE: SHILPrepend frees on failure
            }
        }

        // if we have a local string then lets continue to parse it by binding to 
        // its parent folder, otherwise we just want to return the attributes

        if (SUCCEEDED(hr))
        {
            if (SUCCEEDED(DisplayNameOf(this, *ppidl, SHGDN_FORPARSING, szPath, ARRAYSIZE(szPath))))
            {
                NPTRegisterNameToPidlTranslation(szPath, *ppidl); // no _ILNext b/c this is relative to the Net Places folder
            }
            hr = _ParseRest(pbc, wszRestOfName, ppidl, pdwAttrib);
        }
    }
    else
    {
        hr = HRESULT_FROM_WIN32(dwres);
    }

    return hr;
}


//
// simple name parsing for the network paths.  this makes big assumptions about the
// \\server\share format we are given, and the type of IDLISTs to return.
//

HRESULT CNetFolder::_AddUnknownIDList(DWORD dwDisplayType, LPITEMIDLIST *ppidl)
{
    NETRESOURCE nr = { 0 };

    nr.dwScope = RESOURCE_GLOBALNET;
    nr.dwDisplayType = dwDisplayType;
    nr.dwUsage = RESOURCEUSAGE_CONTAINER;
    nr.lpRemoteName = TEXT("\0");               // null name means fake item

    LPITEMIDLIST pidlT;
    HRESULT hr = _NetResToIDList(&nr, TRUE, FALSE, FALSE, &pidlT);
    if (SUCCEEDED(hr))
    {
        hr = SHILAppend(pidlT, ppidl);
        if (FAILED(hr))
            ILFree(pidlT);
    }

    return hr;
}

HRESULT CNetFolder::_ParseSimple(LPBC pbc, LPWSTR pszName, LPITEMIDLIST* ppidl, DWORD* pdwAttributes)
{
    HRESULT hr = S_OK;
    NETRESOURCE nr = {0};
    LPWSTR pszSlash;
    LPITEMIDLIST pidlT;
    USES_CONVERSION;

    *ppidl = NULL;

    // create the entire network IDLIST, provider and domain elements

    hr = _CreateEntireNetwork(ppidl);

    if (SUCCEEDED(hr))
        hr = _AddUnknownIDList(RESOURCEDISPLAYTYPE_NETWORK, ppidl);

    if (SUCCEEDED(hr))
        hr = _AddUnknownIDList(RESOURCEDISPLAYTYPE_DOMAIN, ppidl);

    // create the server IDLIST

    if (SUCCEEDED(hr))
    {
        pszSlash = StrChrW(pszName+2, L'\\');

        if (pszSlash)
            *pszSlash = L'\0';

        nr.dwScope = RESOURCE_GLOBALNET;
        nr.dwDisplayType = RESOURCEDISPLAYTYPE_SERVER;
        nr.dwType = RESOURCETYPE_DISK;
        nr.dwUsage = RESOURCEUSAGE_CONTAINER;
        nr.lpRemoteName = W2T(pszName);

        hr = _NetResToIDList(&nr, FALSE, FALSE, FALSE, &pidlT);
        if (SUCCEEDED(hr))
            hr = SHILAppend(pidlT, ppidl);

        if (pszSlash)
            *pszSlash = L'\\';

        // if we have a trailing \ then lets add in the share part of the IDLIST

        if (SUCCEEDED(hr) && pszSlash)
        {
            pszSlash = StrChrW(pszSlash+1, L'\\');
            if (pszSlash)
                *pszSlash = L'\0';

            nr.dwDisplayType = RESOURCEDISPLAYTYPE_SHARE;
            nr.dwUsage = RESOURCEUSAGE_CONNECTABLE;
            nr.lpRemoteName = W2T(pszName);

            hr = _NetResToIDList(&nr, FALSE, FALSE, FALSE, &pidlT);
            if (SUCCEEDED(hr))
                hr = SHILAppend(pidlT, ppidl);

            if (pszSlash)
                *pszSlash = L'\\';
        }
    }

    if (SUCCEEDED(hr))
    {
        hr = _ParseRest(pbc, pszSlash, ppidl, pdwAttributes);
    }
    
    return hr;
}


// try parsing out the EntireNet or localised version.  if we find that object then try and
// parse through that to the regitems or other objects which live below.   this inturn
// will cause an instance of CNetFolder to be created to generate the other parsing names.
//
// returns:
//      S_FALSE         - not rest of net, try something else
//      S_OK            - was rest of net, use this
//      FAILED(hr)    - error result, return

HRESULT CNetRootFolder::_TryParseEntireNet(HWND hwnd, LPBC pbc, WCHAR *pwszName, LPITEMIDLIST *ppidl, DWORD *pdwAttributes)
{
    HRESULT hr = S_FALSE; // skip, not rest of net
 
    *ppidl = NULL;

    if (!PathIsUNCW(pwszName))
    {
        const WCHAR szEntireNetwork[] = L"EntireNetwork";
        WCHAR szRestOfNet[128];
        INT cchRestOfNet = LoadStringW(HINST_THISDLL, IDS_RESTOFNET, szRestOfNet, ARRAYSIZE(szRestOfNet));
       
        BOOL fRestOfNet = !StrCmpNIW(szRestOfNet, pwszName, cchRestOfNet);
        if (!fRestOfNet && !StrCmpNIW(szEntireNetwork, pwszName, ARRAYSIZE(szEntireNetwork)-1)) 
        {
            fRestOfNet = TRUE;
            cchRestOfNet = ARRAYSIZE(szEntireNetwork)-1;
        }
        
        if (fRestOfNet)
        {
            hr = _CreateEntireNetwork(ppidl);
            if (SUCCEEDED(hr))
            {
                if (pdwAttributes)
                {
                    GetAttributesOf(1, (LPCITEMIDLIST *)ppidl, pdwAttributes);
                }
                hr = S_OK;
            }

            // 
            // if we find extra stuff after the name then lets bind and continue the parsing
            // from there on.  this is needed so the we can access regitems burried inside
            // entire net.
            //
            // eg:  EntireNetwork\\::{clsid}
            //

            if (SUCCEEDED(hr) && 
                    (pwszName[cchRestOfNet] == L'\\') && pwszName[cchRestOfNet+1])
            {
                IShellFolder *psfRestOfNet;
                hr = BindToObject(*ppidl, NULL, IID_PPV_ARG(IShellFolder, &psfRestOfNet));
                if (SUCCEEDED(hr))
                {
                    LPITEMIDLIST pidl;
                    hr = psfRestOfNet->ParseDisplayName(hwnd, pbc, pwszName+cchRestOfNet+1, NULL, &pidl, pdwAttributes);
                    if  (SUCCEEDED(hr))
                    {
                        hr = SHILAppend(pidl, ppidl);                        
                    }
                    psfRestOfNet->Release();
                }
            }
        }
    }

    return hr;
}


// CNetRootFolder::ParseDisplayname
//  - swtich based on the file system context to see if we need to do a simple parse or not,
//  - check for "EntireNet" and delegate parsing as required.

STDMETHODIMP CNetRootFolder::ParseDisplayName(HWND hwnd, LPBC pbc, WCHAR* pszName, ULONG* pchEaten, LPITEMIDLIST* ppidl, DWORD* pdwAttributes)
{
    if (!ppidl)
        return E_INVALIDARG;

    *ppidl = NULL;

    if (!pszName)
        return E_INVALIDARG;

    HRESULT hr = _TryParseEntireNet(hwnd, pbc, pszName, ppidl, pdwAttributes);
    if (hr == S_FALSE)
    {
        if (PathIsUNCW(pszName))
        {
            LPCITEMIDLIST pidlMapped;
            LPTSTR pszRest = NPTMapNameToPidl(pszName, &pidlMapped);
            if (pidlMapped)
            {
                hr = SHILClone(pidlMapped, ppidl);
                if (SUCCEEDED(hr))
                {
                    hr = _ParseRest(pbc, pszRest, ppidl, pdwAttributes);
                }
            }
            else
            {
                if (S_OK == SHIsFileSysBindCtx(pbc, NULL))
                {
                    hr = _ParseSimple(pbc, pszName, ppidl, pdwAttributes);
                }
                else
                {
                    hr = _ParseNetName(hwnd, pbc, pszName, pchEaten, ppidl, pdwAttributes);
                }
            }
        }
        else
        {
            hr = HRESULT_FROM_WIN32(ERROR_BAD_NET_NAME);
        }

        if ((HRESULT_FROM_WIN32(ERROR_BAD_NET_NAME) == hr))
        {
            IShellFolder2 *psfFiles;
            if (SUCCEEDED(v_GetFileFolder(&psfFiles)))
            {
                hr = psfFiles->ParseDisplayName(hwnd, pbc, pszName, pchEaten, ppidl, pdwAttributes);
            }
        }
    }

    if (FAILED(hr))
    {
        ILFree(*ppidl);
        *ppidl = NULL;
    }
    
    return hr;
}



STDMETHODIMP CNetRootFolder::EnumObjects(HWND hwnd, DWORD grfFlags, IEnumIDList** ppenum)
{
    DWORD dwRemote = RMF_GETLINKENUM;
    HANDLE hEnum = NULL;

    // Do we enumerate the workgroup?
    if (!SHRestricted(REST_ENUMWORKGROUP))
    {
        // Don't enumerate the workgroup, if the restriction says so
        dwRemote |= RMF_FAKENETROOT;

        // Check the WNet policy to see if we should be showing the
        // entire net object.  If not, mark it as shown so that the
        // enumerator doesn't return it.
        if (SHRestricted(REST_NOENTIRENETWORK))
            dwRemote |= RMF_ENTIRENETSHOWN;
    }

    // if we are not faking the net root then lets call _OpenEnum, otherwise lets ignore

    if (!(dwRemote & RMF_FAKENETROOT))
    {
        DWORD err = _OpenEnum(hwnd, grfFlags, NULL, &hEnum);

        // Always add the remote folder to the 'hood
        if (WN_SUCCESS != err)
        {
            // Yes; still show remote anyway (only)
            dwRemote |= RMF_SHOWREMOTE;
        }
        else
        {
            // No; allow everything to be enumerated in the 'hood.
            dwRemote |= RMF_CONTEXT;
        }
    }

    HRESULT hr = Create_NetFolderEnum(this, grfFlags, dwRemote, hEnum, ppenum);

    if (FAILED(hr) && hEnum)
    {
        WNetCloseEnum(hEnum);
    }

    return hr;
}

STDMETHODIMP CNetRootFolder::BindToObject(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv)
{
    HRESULT hr;
    if (NET_IsValidID(pidl))
        hr = CNetFolder::BindToObject(pidl, pbc, riid, ppv);
    else
    {
        IShellFolder2* psfFiles;
        hr = v_GetFileFolder(&psfFiles);
        if (SUCCEEDED(hr))
            hr = psfFiles->BindToObject(pidl, pbc, riid, ppv);
    }
    return hr;
}

STDMETHODIMP CNetRootFolder::CompareIDs(LPARAM iCol, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    HRESULT hr = E_INVALIDARG;

    // First obtain the collate type of the pidls and their respective
    // collate order.

    LONG iColateType1 = _GetFilePIDLType(pidl1);
    LONG iColateType2 = _GetFilePIDLType(pidl2);

    if (iColateType1 == iColateType2) 
    {
        // pidls are of same type.
        if (iColateType1 == _HOOD_COL_FILE)  // two file system pidls
        {
            IShellFolder2* psfFiles;
            if (SUCCEEDED(v_GetFileFolder(&psfFiles)))
            {
                if (0 == (iCol & SHCIDS_COLUMNMASK))
                {
                    // special case this for perf, this is the name compare
                    hr = psfFiles->CompareIDs(iCol, pidl1, pidl2);
                }
                else
                {
                    SHCOLUMNID scid;
                    MapColumnToSCID((UINT)iCol & SHCIDS_COLUMNMASK, &scid);
                    int iRet = CompareBySCID(psfFiles, &scid, pidl1, pidl2);
                    hr = ResultFromShort(iRet);
                }
            }
        }
        else 
        {
            // pidls same and are not of type file,
            // so both must be a type understood
            // by the CNetwork class - pass on to compare.

            hr = CNetFolder::CompareIDs(iCol, pidl1, pidl2);
        }
    }
    else 
    {
        // ensure that entire network ends up at the head of the list

        LPCIDNETRESOURCE pidn1 = NET_IsValidID(pidl1);
        LPCIDNETRESOURCE pidn2 = NET_IsValidID(pidl2);

        if ((pidn1 && (NET_GetDisplayType(pidn1) == RESOURCEDISPLAYTYPE_ROOT)) ||
             (pidn2 && (NET_GetDisplayType(pidn2) == RESOURCEDISPLAYTYPE_ROOT)))
        {
            if (iColateType1 == _HOOD_COL_FILE)
                return ResultFromShort(1);
            else
                return ResultFromShort(-1);
        }

        // pidls are not of same type, so have already been correctly
        // collated (consequently, sorting is first by type and
        // then by subfield).

        hr = ResultFromShort(((iColateType2 - iColateType1) > 0) ? 1 : -1);
    }
    return hr;
}

STDMETHODIMP CNetRootFolder::CreateViewObject(HWND hwnd, REFIID riid, void **ppv)
{
    ASSERT(ILIsEqual(_pidl, (LPCITEMIDLIST)&c_idlNet));

    if (IsEqualIID(riid, IID_IDropTarget))
    {
        return CNetRootDropTarget_CreateInstance(hwnd, _pidl, (IDropTarget**) ppv);
    }
    return CNetFolder::CreateViewObject(hwnd, riid, ppv);
}

STDMETHODIMP CNetRootFolder::GetAttributesOf(UINT cidl, LPCITEMIDLIST *apidl, ULONG* prgfInOut)
{
    HRESULT hr;

    if (IsSelf(cidl, apidl))
    {
        // The user can rename links in the hood.
        hr = CNetFolder::GetAttributesOf(cidl, apidl, prgfInOut);
        *prgfInOut |= SFGAO_CANRENAME;
    }
    else
    {
        hr = GetAttributesCallback(SAFECAST(this, IShellFolder2*), cidl, apidl, prgfInOut, _AttributesCallbackRoot);
    }
    return hr;
}

STDMETHODIMP CNetRootFolder::GetDisplayNameOf(LPCITEMIDLIST pidl, DWORD dwFlags, STRRET* pStrRet)
{
    HRESULT hr;
    if (NET_IsValidID(pidl) || IsSelf(1, &pidl))
    {
        hr = CNetFolder::GetDisplayNameOf(pidl, dwFlags, pStrRet);
    }
    else
    {
        IShellFolder2* psfFiles;
        hr = v_GetFileFolder(&psfFiles);
        if (SUCCEEDED(hr))
            hr = psfFiles->GetDisplayNameOf(pidl, dwFlags, pStrRet);
    }
    return hr;
}

STDMETHODIMP CNetRootFolder::SetNameOf(HWND hwnd, LPCITEMIDLIST pidl, LPCOLESTR lpszName,
                                       DWORD dwRes, LPITEMIDLIST* ppidl)
{
    HRESULT hr;
    if (NET_IsValidID(pidl))
    {
        hr = CNetFolder::SetNameOf(hwnd, pidl, lpszName, dwRes, ppidl);
    }
    else
    {
        IShellFolder2* psfFiles;
        hr = v_GetFileFolder(&psfFiles);
        if (SUCCEEDED(hr))
            hr = psfFiles->SetNameOf(hwnd, pidl, lpszName, dwRes, ppidl);
    }
    return hr;
}

STDMETHODIMP CNetRootFolder::GetUIObjectOf(HWND hwnd, UINT cidl, LPCITEMIDLIST* apidl,
                                           REFIID riid, UINT* prgfInOut, void **ppv)
{
    HRESULT hr = E_INVALIDARG;
    LPCIDNETRESOURCE pidn = cidl ? NET_IsValidID(apidl[0]) : NULL;
    BOOL fStriped = FALSE;

    *ppv = NULL;

    if (pidn)
    {
        fStriped = _MakeStripToLikeKinds(&cidl, &apidl, TRUE);

        if (IsEqualIID(riid, IID_IContextMenu))
        {
            HKEY ahkeys[NKID_COUNT];

            hr = _OpenKeys(pidn, ahkeys);
            if (SUCCEEDED(hr))
            {
                IShellFolder* psfOuter;
                hr = QueryInterface(IID_PPV_ARG(IShellFolder, &psfOuter));
                if (SUCCEEDED(hr))
                {
                    hr = CDefFolderMenu_Create2(_pidl, hwnd, cidl, apidl, 
                                                  psfOuter, _GetCallbackType(pidn),
                                                  ARRAYSIZE(ahkeys), ahkeys, (IContextMenu**) ppv);
                    psfOuter->Release();
                }
                SHRegCloseKeys(ahkeys, ARRAYSIZE(ahkeys));
            }
        }
        else
            hr = CNetFolder::GetUIObjectOf(hwnd, cidl, apidl, riid, prgfInOut, ppv);
    }
    else
    {
        fStriped = _MakeStripToLikeKinds(&cidl, &apidl, FALSE);

        IShellFolder2* psfFiles;
        hr = v_GetFileFolder(&psfFiles);
        if (SUCCEEDED(hr))
            hr = psfFiles->GetUIObjectOf(hwnd, cidl, apidl, riid, prgfInOut, ppv);
    }

    if (fStriped)
        LocalFree((HLOCAL)apidl);
    return hr;
}

STDMETHODIMP CNetRootFolder::GetClassID(CLSID* pCLSID)
{
    *pCLSID = CLSID_NetworkPlaces;
    return S_OK;
}

STDMETHODIMP CNetRootFolder::Initialize(LPCITEMIDLIST pidl)
{
    ASSERT(ILIsEqual(pidl, (LPCITEMIDLIST)&c_idlNet));
    ASSERT(AssertIsIDListInNameSpace(pidl, &CLSID_NetworkPlaces) && ILIsEmpty(_ILNext(pidl)));
    // Only allow the Net root on the desktop

    // Don't initialize more than once; we are a singleton object.
    // This is theoretically redundant with the InterlockedCompareExchange
    // below, but redundant reinitialization is by far the common case
    // so we'll optimize it.
    if (_pidl)
        return S_OK;

    LPITEMIDLIST pidlNew;
    HRESULT hr = SHILClone(pidl, &pidlNew);
    if (SUCCEEDED(hr))
    {
        if (SHInterlockedCompareExchange((void**)&_pidl, pidlNew, 0))
        {
            // Some other thread raced with us, throw away our copy
            ILFree(pidlNew);
        }
    }
    return hr;
}

LONG CNetFolder::_GetFilePIDLType(LPCITEMIDLIST pidl)
{
    if (NET_IsValidID(pidl)) 
    {
        if (NET_IsRemoteFld((LPIDNETRESOURCE)pidl)) 
        {
            return _HOOD_COL_REMOTE;
        }
        if (NET_GetDisplayType((LPIDNETRESOURCE)pidl) == RESOURCEDISPLAYTYPE_ROOT) 
        {
            return _HOOD_COL_RON;
        }
        return _HOOD_COL_NET;
    }
    return _HOOD_COL_FILE;
}


/* This function adds a provider name to an IDLIST that doesn't already have one. */
/* A new IDLIST pointer is returned; the old pointer is no longer valid. */

LPITEMIDLIST CNetFolder::_AddProviderToPidl(LPITEMIDLIST pidl, LPCTSTR lpProvider)
{
    LPIDNETRESOURCE pidn = (LPIDNETRESOURCE)pidl;

    if (!NET_FHasProvider(pidn))
    {
        LPITEMIDLIST pidlres;
        TCHAR szName[MAX_PATH], szComment[MAX_PATH];

        // construct a new IDLIST preserving the name, comment and other information

        NET_CopyResName(pidn, szName, ARRAYSIZE(szName));
        NET_CopyComment(pidn, szComment, ARRAYSIZE(szComment));

        HRESULT hr = _CreateNetIDList(pidn, szName, lpProvider, szComment[0] ? szComment:NULL, &pidlres);
        if (SUCCEEDED(hr) && !ILIsEmpty(_ILNext(pidl)))
        {
            LPITEMIDLIST pidlT;
            hr = SHILCombine(pidlres, _ILNext(pidl), &pidlT);
            if (SUCCEEDED(hr))
            {
                ILFree(pidlres);
                pidlres = pidlT;
            }
        }

        // if we have a result, free the old PIDL and return the new

        if (SUCCEEDED(hr))
        {
            ILFree(pidl);
            pidl = pidlres;
        }
    }

    return pidl;
}

BOOL CNetFolder::_MakeStripToLikeKinds(UINT *pcidl, LPCITEMIDLIST **papidl, BOOL fNetObjects)
{
    BOOL bRet = FALSE;
    LPITEMIDLIST *apidl = (LPITEMIDLIST*)*papidl;
    int cidl = *pcidl;

    for (int i = 0; i < cidl; i++)
    {
        if ((NET_IsValidID(apidl[i]) != NULL) != fNetObjects)
        {
            LPCITEMIDLIST *apidlHomo = (LPCITEMIDLIST *)LocalAlloc(LPTR, sizeof(*apidlHomo) * cidl);
            if (!apidlHomo)
                return FALSE;

            int cpidlHomo = 0;
            for (i = 0; i < cidl; i++)
            {
                if ((NET_IsValidID(apidl[i]) != NULL) == fNetObjects)
                    apidlHomo[cpidlHomo++] = apidl[i];
            }

            // Setup to use the stripped version of the pidl array...
            *pcidl = cpidlHomo;
            *papidl = apidlHomo;
            bRet = TRUE;
        }
    }
    return bRet;
}

HRESULT CNetRootFolder::v_GetFileFolder(IShellFolder2 **psf)
{
    HRESULT hr = SHCacheTrackingFolder((LPCITEMIDLIST)&c_idlNet, CSIDL_NETHOOD, &_psfFiles);
    *psf = _psfFiles;
    return hr;
}


//
// pmedium and pformatetcIn == NULL if we are handling QueryGetData
//
HRESULT CNetData::GetHDrop(FORMATETC *pformatetcIn, STGMEDIUM *pmedium)
{
    HRESULT hr = E_INVALIDARG;        // assume error
    STGMEDIUM medium;
    LPIDA pida = DataObj_GetHIDA(this, &medium);
    if (pida)
    {
        // Get the first one to see the type.
        LPCIDNETRESOURCE pidn = (LPCIDNETRESOURCE)IDA_GetIDListPtr(pida, 0);

        if (NULL == pidn)
            hr = E_FAIL;
            
        if (pidn && (NET_GetFlags(pidn) & SHID_JUNCTION) && 
            (NET_GetType(pidn) == RESOURCETYPE_DISK))
        {
            // Get HDrop only if we are handling IDataObject::GetData (pmedium != NULL)
            if (pmedium) 
            {
                // We have non-null FORMATETC and STGMEDIUM - get the HDrop
                hr = CFSIDLData::GetHDrop(pformatetcIn, pmedium);
            }
            else
            {
                hr = S_OK;  // We were handling QueryGetData
            }
        }
        HIDA_ReleaseStgMedium(pida, &medium);
    }
    return hr;
}

LPTSTR NET_GetProviderFromRes(LPCIDNETRESOURCE pidn, LPTSTR pszBuff, UINT cchBuff);

// By the way...Win95 shipped with the below provider
// names.  Since the name can be changed and be localized,
// we have to try and map these correctly for net pidl
// interop.

//
// get the network resource name from an item. this is not a file system path!
//
// example:
//      server      \\server or strike/sys
//      share       \\server\share or strike/sys
//      printer     \\server\printer
//      provider    "provider name"
//      entire net  "Entire Network"
//
// in:
//   pidn       the item
//   cchBuff    size of buffer in chars.
//
// out:
//   pszBuff    return buffer
//
// returns:
//   address of the input buffer (pszBuff)
//
LPTSTR NET_CopyResName(LPCIDNETRESOURCE pidn, LPTSTR pszBuff, UINT cchBuff)
{
    if (NET_IsUnicode(pidn))
    {
        LPBYTE pb = (LPBYTE)pidn->szNetResName;
        pb += lstrlenA((LPSTR)pb) + 1;      // Skip over ansi net name
        if (NET_FHasProvider(pidn))
            pb += lstrlenA((LPSTR)pb) + 1;  // Skip over ansi provider
        if (NET_FHasComment(pidn))
            pb += lstrlenA((LPSTR)pb) + 1;  // Skip over comment
        ualstrcpyn(pszBuff, (LPNWSTR)pb, cchBuff);
    }
    else
    {
        SHAnsiToTChar(pidn->szNetResName, pszBuff, cchBuff);
    }
    return pszBuff;
}

//
// get the provider name from an item. some items do not have providers stored
// in them. for example the "*" indicates where the provider is stored in the
// two different forms of network pidls.
//      [entire net] [provider *] [server] [share] [... file system]
//      [server *] [share] [... file system]
// in:
//   pidn       item (single item PIDL) to try to get the provider name from
//   cchBuff    size in chars.
// out:
//   pszBuff    output
//
LPTSTR NET_CopyProviderName(LPCIDNETRESOURCE pidn, LPTSTR pszBuff, UINT cchBuff)
{
    *pszBuff = 0;

    if (!NET_FHasProvider(pidn))
        return NULL;

    // try the wNetType at the end of the pidl

    const BYTE *pb = (LPBYTE)pidn + pidn->cb - sizeof(WORD);
    DWORD dwNetType = *((UNALIGNED WORD *)pb) << 16;

    if (dwNetType && (dwNetType <= WNNC_NET_LARGEST) &&
        (WNetGetProviderName(dwNetType, pszBuff, (ULONG*)&cchBuff) == WN_SUCCESS))
    {
        return pszBuff;
    }

    // Try the old way...

    pb = (LPBYTE)pidn->szNetResName + lstrlenA(pidn->szNetResName) + 1;      // Skip over ansi net name

    if (NET_IsUnicode(pidn))
    {
        pb += lstrlenA((LPSTR)pb) + 1;      // Skip over ansi provider
        if (NET_FHasComment(pidn))
            pb += lstrlenA((LPSTR)pb) + 1;  // Skip over comment
        pb += (ualstrlen((LPNWSTR)pb) + 1) * sizeof(WCHAR); // skip over unicode net name
        ualstrcpyn(pszBuff, (LPNWSTR)pb, cchBuff);
    }
    else
    {
        SHAnsiToTChar((LPSTR)pb, pszBuff, cchBuff);
    }

    // Map from Win95 net provider name if possible...
    for (int i = 0; i < ARRAYSIZE(c_rgProviderMap); i++)
    {
        if (lstrcmp(pszBuff, c_rgProviderMap[i].lpName) == 0)
        {
            DWORD dwNetType = c_rgProviderMap[i].wNetType << 16;
            if (dwNetType && (dwNetType <= WNNC_NET_LARGEST))
            {
                *pszBuff = 0;
                WNetGetProviderName(dwNetType, pszBuff, (LPDWORD)&cchBuff);
            }
            break;
        }
    }
    return pszBuff;
}

//
// get the comment if there is one from the net item
//
LPTSTR NET_CopyComment(LPCIDNETRESOURCE pidn, LPTSTR pszBuff, UINT cchBuff)
{
    *pszBuff = 0;

    LPCSTR pszT = pidn->szNetResName + lstrlenA(pidn->szNetResName) + 1;
    if (NET_FHasComment(pidn))
    {
        if (NET_FHasProvider(pidn))
            pszT += lstrlenA(pszT) + 1;
        if (NET_IsUnicode(pidn))
        {
            pszT += lstrlenA(pszT) + 1;      // Skip Ansi comment

            LPNCWSTR pszW = (LPNCWSTR)pszT;  // We're at the unicode portion of the pidl
            pszW += ualstrlen(pszW) + 1;     // Skip Unicode Name
            if (NET_FHasProvider(pidn))
                pszW += ualstrlen(pszW) + 1; // Skip Unicode Provider
            ualstrcpyn(pszBuff, pszW, cchBuff);
        }
        else
        {
            SHAnsiToUnicode(pszT, pszBuff, cchBuff);
        }
    }
    return pszBuff;
}

//  pidlRemainder will be filled in (only in the TRUE return case) with a
//  pointer to the part of the IDL (if any) past the remote regitem.
//  This value may be used, for example, to differentiate between a remote
//  printer folder and a printer under a remote printer folder

BOOL NET_IsRemoteRegItem(LPCITEMIDLIST pidl, REFCLSID rclsid, LPCITEMIDLIST* ppidlRemainder)
{
    BOOL bRet = FALSE;
    // in "My Network Places"
    if (pidl && IsIDListInNameSpace(pidl, &CLSID_NetworkPlaces))
    {
        LPCITEMIDLIST pidlStart = pidl; // save this

        // Now, search for a server item. HACKHACK: this assume everything from
        // the NetHood to the server item is a shell pidl with a bFlags field!!

        for (pidl = _ILNext(pidl); !ILIsEmpty(pidl); pidl = _ILNext(pidl))
        {
            if ((SIL_GetType(pidl) & SHID_TYPEMASK) == SHID_NET_SERVER)
            {
                LPITEMIDLIST pidlToTest;

                // Found a server. Is the thing after it a remote registry item?
                pidl = _ILNext(pidl);

                *ppidlRemainder = _ILNext(pidl);

                pidlToTest = ILCloneUpTo(pidlStart, *ppidlRemainder);
                if (pidlToTest)
                {
                    CLSID clsid;
                    bRet = SUCCEEDED(GetCLSIDFromIDList(pidlToTest, &clsid)) && IsEqualCLSID(rclsid, clsid);
                    ILFree(pidlToTest);
                }
                break;  // done
            }
        }
    }
    return bRet;
}




//
// Get the provider name from an absolute IDLIST.
// Parameters:
//  pidlAbs -- Specifies the Absolute IDList to the file system object
//
LPTSTR NET_GetProviderFromIDList(LPCITEMIDLIST pidlAbs, LPTSTR pszBuff, UINT cchBuff)
{
    return NET_GetProviderFromRes((LPCIDNETRESOURCE)_ILNext(pidlAbs), pszBuff, cchBuff);
}

//
// Get the provider name from a relative IDLIST.
// in:
//  pidn    potentially multi level item to try to get the resource from
//
LPTSTR NET_GetProviderFromRes(LPCIDNETRESOURCE pidn, LPTSTR pszBuffer, UINT cchBuffer)
{
    // If this guy is the REST of network item, we increment to the
    // next IDLIST - If at root return NULL
    if (pidn->cb == 0)
        return NULL;

    //
    // If the IDLIST starts with a ROOT_REGITEM, then skip to the
    // next item in the list...
    if (pidn->bFlags == SHID_ROOT_REGITEM)
    {
        pidn = (LPIDNETRESOURCE)_ILNext((LPITEMIDLIST)pidn);
        if (pidn->cb == 0)
            return NULL;
    }

    // If the IDLIST includes Entire Network, the provider will be
    // part of the next component.
    if (NET_GetDisplayType(pidn) == RESOURCEDISPLAYTYPE_ROOT)
    {
        pidn = (LPIDNETRESOURCE)_ILNext((LPITEMIDLIST)pidn);
        if (pidn->cb == 0)
            return NULL;
    }

    // If the next component after the 'hood or Entire Network is
    // a network object, its name is the provider name, else the
    // provider name comes after the remote name.
    if (NET_GetDisplayType(pidn) == RESOURCEDISPLAYTYPE_NETWORK)
    {
        // Simply return the name field back for the item.
        return NET_CopyResName(pidn, pszBuffer, cchBuffer);
    }
    else
    {
        // Nope one of the items in the neighborhood view was selected
        // The Provider name is stored after ther resource name
        return NET_CopyProviderName(pidn, pszBuffer, cchBuffer);
    }
}

#define PTROFFSET(pBase, p)     ((int) ((LPBYTE)(p) - (LPBYTE)(pBase)))


//
// fill in pmedium with a NRESARRAY
//
// pmedium == NULL if we are handling QueryGetData
//
STDAPI CNetData_GetNetResource(IDataObject *pdtobj, STGMEDIUM *pmedium)
{
    HRESULT hr = E_OUTOFMEMORY;
    LPITEMIDLIST pidl;
    STGMEDIUM medium;
    LPIDA pida = DataObj_GetHIDA(pdtobj, &medium);

    ASSERT(pida && pida->cidl);

    // First, get the provider name from the first one (assuming they are common).
    pidl = IDA_ILClone(pida, 0);
    if (pidl)
    {
        TCHAR szProvider[MAX_PATH];
        LPCTSTR pszProvider = NET_GetProviderFromIDList(pidl, szProvider, ARRAYSIZE(szProvider));
        if (pmedium)
        {
            TCHAR szName[MAX_PATH];
            UINT cbHeader = sizeof(NRESARRAY) + (sizeof(NETRESOURCE) * (pida->cidl - 1));
            UINT cbRequired, iItem;

            // Calculate required size
            cbRequired = cbHeader;
            if (pszProvider)
                cbRequired += (lstrlen(pszProvider) + 1) * sizeof(TCHAR);

            for (iItem = 0; iItem < pida->cidl; iItem++)
            {
                LPCIDNETRESOURCE pidn = (LPCIDNETRESOURCE)IDA_GetIDListPtr(pida, iItem);
                NET_CopyResName(pidn, szName, ARRAYSIZE(szName));
                cbRequired += (lstrlen(szName) + 1) * sizeof(TCHAR);
            }

            //
            // Indicate that the caller should release hmem.
            //
            pmedium->pUnkForRelease = NULL;
            pmedium->tymed = TYMED_HGLOBAL;
            pmedium->hGlobal = GlobalAlloc(GPTR, cbRequired);
            if (pmedium->hGlobal)
            {
                LPNRESARRAY panr = (LPNRESARRAY)pmedium->hGlobal;
                LPTSTR pszT = (LPTSTR)((LPBYTE)panr + cbHeader);
                LPTSTR pszEnd = (LPTSTR)((LPBYTE)panr + cbRequired);
                UINT offProvider = 0;

                panr->cItems = pida->cidl;

                // Copy the provider name. This is not necessary,
                // if we are dragging providers.
                if (pszProvider)
                {
                    lstrcpy(pszT, pszProvider);
                    offProvider = PTROFFSET(panr, pszT);
                    pszT += lstrlen(pszT) + 1;
                }

                //
                // For each item, fill each NETRESOURCE and append resource
                // name at the end. Note that we should put offsets in
                // lpProvider and lpRemoteName.
                //
                for (iItem = 0; iItem < pida->cidl; iItem++)
                {
                    LPNETRESOURCE pnr = &panr->nr[iItem];
                    LPCIDNETRESOURCE pidn = (LPCIDNETRESOURCE)IDA_GetIDListPtr(pida, iItem);

                    ASSERT(pnr->dwScope == 0);
                    ASSERT(pnr->lpLocalName==NULL);
                    ASSERT(pnr->lpComment==NULL);

                    pnr->dwType = NET_GetType(pidn);
                    pnr->dwDisplayType = NET_GetDisplayType(pidn);
                    pnr->dwUsage = NET_GetUsage(pidn);
                    NET_CopyResName(pidn, pszT, (UINT)(pszEnd-pszT));

                    if (pnr->dwDisplayType == RESOURCEDISPLAYTYPE_ROOT)
                    {
                        pnr->lpProvider = NULL;
                        pnr->lpRemoteName = NULL;
                    }
                    else if (pnr->dwDisplayType == RESOURCEDISPLAYTYPE_NETWORK)
                    {
                        *((UINT *) &pnr->lpProvider) = PTROFFSET(panr, pszT);
                        ASSERT(pnr->lpRemoteName == NULL);
                    }
                    else
                    {
                        *((UINT *) &pnr->lpProvider) = offProvider;
                        *((UINT *) &pnr->lpRemoteName) = PTROFFSET(panr, pszT);
                    }
                    pszT += lstrlen(pszT) + 1;
                }

                ASSERT(pszEnd == pszT);
                hr = S_OK;
            }
        }
        else
        {
            hr = S_OK;    // handing QueryGetData, yes, we have it
        }
        ILFree(pidl);
    }

    HIDA_ReleaseStgMedium(pida, &medium);

    return hr;
}


// fill in pmedium with an HGLOBAL version of a NRESARRAY

STDAPI CNetData_GetNetResourceForFS(IDataObject *pdtobj, STGMEDIUM *pmedium)
{
    HRESULT hr = E_OUTOFMEMORY;
    LPITEMIDLIST pidlAbs;
    STGMEDIUM medium;
    LPIDA pida = DataObj_GetHIDA(pdtobj, &medium);

    ASSERT(pida && medium.hGlobal);     // we created this...

    //
    // NOTES: Even though we may have multiple FS objects in this HIDA,
    //  we know that they share the root. Therefore, getting the pidl for
    //  the first item is always sufficient.
    //

    pidlAbs = IDA_ILClone(pida, 0);
    if (pidlAbs)
    {
        LPITEMIDLIST pidl;

        ASSERT(AssertIsIDListInNameSpace(pidlAbs, &CLSID_NetworkPlaces));

        //
        // Look for the JUNCTION point (starting from the second ID)
        //
        for (pidl = _ILNext(pidlAbs); !ILIsEmpty(pidl); pidl = _ILNext(pidl))
        {
            LPIDNETRESOURCE pidn = (LPIDNETRESOURCE)pidl;
            if (NET_GetFlags(pidn) & SHID_JUNCTION)
            {
                //
                // We found the JUNCTION point (which is s share).
                // Return the HNRES to it.
                //
                TCHAR szProvider[MAX_PATH];
                TCHAR szRemote[MAX_PATH];
                UINT cbRequired;
                LPCTSTR pszProvider = NET_GetProviderFromIDList(pidlAbs, szProvider, ARRAYSIZE(szProvider));
                LPCTSTR pszRemoteName = NET_CopyResName(pidn, szRemote, ARRAYSIZE(szRemote));
                UINT   cbProvider = lstrlen(pszProvider) * sizeof(TCHAR) + sizeof(TCHAR);

                //
                // This should not be a provider node.
                // This should not be the last ID in pidlAbs.
                //
                ASSERT(pszProvider != pszRemoteName);
                ASSERT(!ILIsEmpty(_ILNext(pidl)));

                cbRequired = sizeof(NRESARRAY) + cbProvider + lstrlen(pszRemoteName) * sizeof(TCHAR) + sizeof(TCHAR);

                pmedium->pUnkForRelease = NULL;
                pmedium->tymed = TYMED_HGLOBAL;
                pmedium->hGlobal = GlobalAlloc(GPTR, cbRequired);
                if (pmedium->hGlobal)
                {
                    LPNRESARRAY panr = (LPNRESARRAY)pmedium->hGlobal;
                    LPNETRESOURCE pnr = &panr->nr[0];
                    LPTSTR pszT = (LPTSTR)(panr + 1);

                    ASSERT(pnr->dwScope == 0);
                    ASSERT(pnr->lpLocalName == NULL);
                    ASSERT(pnr->lpComment == NULL);

                    panr->cItems = 1;

                    pnr->dwType = NET_GetType(pidn);
                    pnr->dwDisplayType = NET_GetDisplayType(pidn);
                    pnr->dwUsage = NET_GetUsage(pidn);

                    *((UINT *) &pnr->lpProvider) = sizeof(NRESARRAY);
                    lstrcpy(pszT, pszProvider);
                    ASSERT(PTROFFSET(panr, pszT) == sizeof(NRESARRAY));
                    pszT += cbProvider / sizeof(TCHAR);

                    *((UINT *) &pnr->lpRemoteName) = sizeof(NRESARRAY) + cbProvider;
                    ASSERT(PTROFFSET(panr, pszT) == (int)sizeof(NRESARRAY) + (int)cbProvider);
                    lstrcpy(pszT, pszRemoteName);

                    ASSERT(((LPBYTE)panr) + cbRequired == (LPBYTE)pszT + (lstrlen(pszT) + 1) * sizeof(TCHAR));
                    hr = S_OK;
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
                break;
            }
        }
        ASSERT(!ILIsEmpty(pidl));   // We should have found the junction point.
        ILFree(pidlAbs);
    }
    HIDA_ReleaseStgMedium(pida, &medium);
    return hr;
}

STDMETHODIMP CNetData::QueryGetData(FORMATETC *pformatetc)
{
    if (pformatetc->tymed & TYMED_HGLOBAL)
    {
        if (pformatetc->cfFormat == g_cfNetResource)
            return CNetData_GetNetResource(this, NULL);

        if (pformatetc->cfFormat == CF_HDROP)
            return GetHDrop(NULL, NULL);
    }

    return CFSIDLData::QueryGetData(pformatetc);
}

STDMETHODIMP CNetData::GetData(FORMATETC *pformatetc, STGMEDIUM *pmedium)
{
    if (pformatetc->tymed & TYMED_HGLOBAL)
    {
        if (pformatetc->cfFormat == g_cfNetResource)
            return CNetData_GetNetResource(this, pmedium);

        if (pformatetc->cfFormat == CF_HDROP)
            return GetHDrop(pformatetc, pmedium);
    }

    return CFSIDLData::GetData(pformatetc, pmedium);
}

BOOL GetPathFromDataObject(IDataObject *pdtobj, DWORD dwData, LPTSTR pszFileName)
{
    BOOL bRet = FALSE;
    BOOL fUnicode = FALSE;
    HRESULT hr;

    if (dwData & (DTID_FDESCW | DTID_FDESCA))
    {
        FORMATETC fmteW = {g_cfFileGroupDescriptorW, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
        STGMEDIUM medium = {0};

        hr = pdtobj->GetData(&fmteW, &medium);

        if (SUCCEEDED(hr))
        {
            fUnicode = TRUE;
        }
        else
        {
            FORMATETC fmteA = {g_cfFileGroupDescriptorA, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
            hr = pdtobj->GetData(&fmteA, &medium);
        }

        if (SUCCEEDED(hr))
        {
            if (fUnicode)
            {
                FILEGROUPDESCRIPTORW *pfgdW = (FILEGROUPDESCRIPTORW *)GlobalLock(medium.hGlobal);
                if (pfgdW)
                {
                    if (pfgdW->cItems == 1)
                    {
                        SHUnicodeToTChar(pfgdW->fgd[0].cFileName, pszFileName, MAX_PATH);
                    }
                    bRet = TRUE;
                    GlobalUnlock(medium.hGlobal);
                }
            }
            else
            {
                FILEGROUPDESCRIPTORA *pfgdA = (FILEGROUPDESCRIPTORA*)GlobalLock(medium.hGlobal);
                if (pfgdA)
                {
                    if (pfgdA->cItems == 1)
                    {
                        SHAnsiToTChar(pfgdA->fgd[0].cFileName, pszFileName, MAX_PATH);
                    }
                    bRet = TRUE;
                    GlobalUnlock(medium.hGlobal);
                }
            }
            ReleaseStgMedium(&medium);
        }
    }

    return bRet;
}

class CNetRootDropTarget : public CIDLDropTarget
{
    friend HRESULT CNetRootDropTarget_CreateInstance(HWND hwnd, LPCITEMIDLIST pidl, IDropTarget **ppdropt);
public:
    CNetRootDropTarget(HWND hwnd) : CIDLDropTarget(hwnd) { };

    // IDropTarget methods overwirte
    STDMETHODIMP DragEnter(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    STDMETHODIMP Drop(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);

private:
    ~CNetRootDropTarget();
    IDropTarget *_pdtgHood;              // file system drop target
};

CNetRootDropTarget::~CNetRootDropTarget()
{
    if (_pdtgHood)
        _pdtgHood->Release();
}

STDMETHODIMP CNetRootDropTarget::DragEnter(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    CIDLDropTarget::DragEnter(pdtobj, grfKeyState, pt, pdwEffect);

    if ((m_dwData & (DTID_NETRES | DTID_HIDA)) == (DTID_NETRES | DTID_HIDA))
    {
        // NETRESOURCE (DTID_NETRES) allow link
        *pdwEffect &= DROPEFFECT_LINK;
    }
    else if (((m_dwData & (DTID_FDESCW | DTID_CONTENTS)) == (DTID_FDESCW | DTID_CONTENTS)) ||
             ((m_dwData & (DTID_FDESCA | DTID_CONTENTS)) == (DTID_FDESCA | DTID_CONTENTS)) )
    {
        // dragging an URL from the web browser gives a FILECONTENTS version
        // of a .URL file. accept that here for Internet Shortcut (.url)
        TCHAR szFileName[MAX_PATH];
        if (GetPathFromDataObject(pdtobj, m_dwData, szFileName) &&
            (0 == lstrcmpi(PathFindExtension(szFileName), TEXT(".url"))))
        {
            *pdwEffect &= DROPEFFECT_LINK;
        }
        else
        {
            *pdwEffect = DROPEFFECT_NONE;
        }
    }
    else
    {
        *pdwEffect = DROPEFFECT_NONE;
    }

    m_dwEffectLastReturned = *pdwEffect;
    return S_OK;
}

STDMETHODIMP CNetRootDropTarget::Drop(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    *pdwEffect &= DROPEFFECT_LINK;

    HRESULT hr = CIDLDropTarget::DragDropMenu(DROPEFFECT_LINK, pdtobj,
                            pt, pdwEffect, NULL, NULL, POPUP_NONDEFAULTDD, grfKeyState);
    if (*pdwEffect)
    {
        if (!_pdtgHood)
        {
            LPITEMIDLIST pidl = SHCloneSpecialIDList(NULL, CSIDL_NETHOOD, FALSE);
            if (pidl)
            {
                IShellFolder *psf;
                if (SUCCEEDED(SHBindToObject(NULL, IID_X_PPV_ARG(IShellFolder, pidl, &psf))))
                {
                    psf->CreateViewObject(_GetWindow(), IID_PPV_ARG(IDropTarget, &_pdtgHood));
                    psf->Release();
                }
                ILFree(pidl);
            }
        }
        
        if (_pdtgHood)
        {
            // force link through the dwEffect and keyboard
            *pdwEffect &= DROPEFFECT_LINK;
            grfKeyState = MK_LBUTTON | MK_CONTROL | MK_SHIFT | MK_FAKEDROP;
            hr = SHSimulateDrop(_pdtgHood, pdtobj, grfKeyState, NULL, pdwEffect);
        }
        else 
            *pdwEffect = 0;
    }

    CIDLDropTarget::DragLeave();
    return hr;
}

HRESULT CNetRootDropTarget_CreateInstance(HWND hwnd, LPCITEMIDLIST pidl, IDropTarget **ppdropt)
{
    *ppdropt = NULL;

    HRESULT hr;
    CNetRootDropTarget *pnrdt = new CNetRootDropTarget(hwnd);
    if (pnrdt)
    {
        hr = pnrdt->_Init(pidl);
        if (SUCCEEDED(hr))
            pnrdt->QueryInterface(IID_PPV_ARG(IDropTarget, ppdropt));
        pnrdt->Release();
    }
    else
        hr = E_OUTOFMEMORY;
    return hr;
}

// This part is psuedo bogus.  Basically we have problems at times doing a
// translation from things like \\pyrex\user to the appropriate PIDL,
// especially if you want to avoid the overhead of hitting the network and
// also problems of knowing if the server is in the "HOOD"
//
// We must maintain the mapping table in UNICODE internally, because
// IShellFolder::ParseDisplayName uses UNICODE, and we don't want to have
// to deal with lstrlen(dbcs) != lstrlen(sbcs) problems.
//

typedef struct _NPT_ITEM
{
    struct _NPT_ITEM *pnptNext;     // Pointer to next item;
    LPCITEMIDLIST   pidl;           // The pidl
    USHORT          cchName;        // size of the name in characters.
    WCHAR           szName[1];      // The name to translate from
} NPT_ITEM;

// Each process will maintain their own list.
NPT_ITEM *g_pnptHead = NULL;

//
//  Function to register translations from Path to IDList translations.
//
void NPTRegisterNameToPidlTranslation(LPCTSTR pszPath, LPCITEMIDLIST pidl)
{
    NPT_ITEM *pnpt;
    int cItemsRemoved = 0;
    WCHAR szPath[MAX_PATH];

    // We currently are only interested in UNC Roots
    // If the table becomes large we can reduce this to only servers...

    if (!PathIsUNC(pszPath))
        return;     // Not interested.

    //
    // If this item is not a root we need to count how many items to remove
    //
    SHTCharToUnicode(pszPath, szPath, ARRAYSIZE(szPath));
    while (!PathIsUNCServerShare(szPath))
    {
        cItemsRemoved++;
        if (!PathRemoveFileSpecW(szPath))
            return;     // Did not get back to a valid root
    }

    ENTERCRITICAL;

    // We don't want to add duplicates
    for (pnpt = g_pnptHead; pnpt != NULL ; pnpt = pnpt->pnptNext)
    {
        if (StrCmpIW(szPath, pnpt->szName) == 0)
            break;
    }

    if (pnpt == NULL)
    {
        UINT cch = lstrlenW(szPath);
        pnpt = (NPT_ITEM *)LocalAlloc(LPTR, sizeof(NPT_ITEM) + cch * sizeof(WCHAR));
        if (pnpt)
        {
            pnpt->pidl = ILClone(pidl);
            if (pnpt->pidl)
            {
                while (cItemsRemoved--)
                {
                    ILRemoveLastID((LPITEMIDLIST)pnpt->pidl);
                }
                pnpt->pnptNext = g_pnptHead;
                g_pnptHead = pnpt;
                pnpt->cchName = (USHORT) cch;
                lstrcpyW(pnpt->szName, szPath);
            }
            else
            {
                LocalFree((HLOCAL)pnpt);
            }
        }
    }
    LEAVECRITICAL;
}

// The main function to attemp to map a portion of the name into an idlist
// Right now limit it to UNC roots
//
LPWSTR NPTMapNameToPidl(LPCWSTR pszPath, LPCITEMIDLIST *ppidl)
{
    NPT_ITEM *pnpt;

    *ppidl = NULL;

    ENTERCRITICAL;

    // See if we can find the item in the list.
    for (pnpt = g_pnptHead; pnpt != NULL ; pnpt = pnpt->pnptNext)
    {
        if (IntlStrEqNIW(pszPath, pnpt->szName, pnpt->cchName) &&
            ((pszPath[pnpt->cchName] == TEXT('\\')) || (pszPath[pnpt->cchName] == TEXT('\0'))))
        {             
            break;
        }
    }
    LEAVECRITICAL;

    // See if we found a match
    if (pnpt == NULL)
        return NULL;

    // Found a match
    *ppidl = pnpt->pidl;
    return (LPWSTR)pszPath + pnpt->cchName;     // points to slash
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\newres.h ===
/**
**      Header for the New version of RC.EXE. This contains the structures
**      for new format of BITMAP files.
**/

/*  The width of the name field in the Data for the group resources */
#ifndef RC_INVOKED       // RC can't handle #pragmas
#pragma pack(2)

typedef struct tagBITMAPHEADER
  {
    DWORD   Size;
    WORD    Width;
    WORD    Height;
    WORD    Planes;
    WORD    BitCount;
  } BITMAPHEADER;

// WHY WASN'T THIS DEFINED TO BE SAME AS RESOURCE FORMAT?
// Image File header
typedef struct tagIMAGEFILEHEADER
{
    BYTE    cx;
    BYTE    cy;
    BYTE    nColors;
    BYTE    iUnused;
    WORD    xHotSpot;
    WORD    yHotSpot;
    DWORD   cbDIB;
    DWORD   offsetDIB;
} IMAGEFILEHEADER;

// File header
#define FT_ICON     1
#define FT_CURSOR   2

typedef struct tagICONFILEHEADER
{
        WORD iReserved;
        WORD iResourceType;
        WORD cresIcons;
        IMAGEFILEHEADER imh[1];
} ICONFILEHEADER;

typedef struct tagNEWHEADER {
    WORD    Reserved;
    WORD    ResType;
    WORD    ResCount;
} NEWHEADER, *LPNEWHEADER;

typedef struct tagICONDIR
{
        BYTE  Width;            /* 16, 32, 64 */
        BYTE  Height;           /* 16, 32, 64 */
        BYTE  ColorCount;       /* 2, 8, 16 */
        BYTE  reserved;
} ICONDIR;

// Format of resource directory (array of resources)

typedef struct tagRESDIR
{
        ICONDIR Icon;
        WORD    Planes;
        WORD    BitCount;
        DWORD   BytesInRes;
        WORD    idIcon;
} RESDIR, *LPRESDIR;

typedef struct tagRESDIRDISK
{
        struct  tagICONDIR  Icon;

        WORD   Reserved[2];
        DWORD  BytesInRes;
        DWORD  Offset;
} RESDIRDISK, *LPRESDIRDISK;

#pragma pack()
#endif // !RC_INVOKED
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\netfind.cpp ===
#include "shellprv.h"
#pragma  hdrstop
#include "shellids.h" // new help ids are stored here
#include "findfilter.h"
#include "netview.h"
#include "prop.h"
#include "ids.h"

STDAPI CNetwork_EnumSearches(IShellFolder2 *psf2, IEnumExtraSearch **ppenum);

class CNetFindEnum;

class CNetFindFilter : public IFindFilter
{
    friend CNetFindEnum;

public:
    CNetFindFilter();

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IFindFilter
    STDMETHODIMP GetStatusMessageIndex(UINT uContext, UINT *puMsgIndex);
    STDMETHODIMP GetFolderMergeMenuIndex(UINT *puBGMainMergeMenu, UINT *puBGPopupMergeMenu);
    STDMETHODIMP FFilterChanged();
    STDMETHODIMP GenerateTitle(LPTSTR *ppszTile, BOOL fFileName);
    STDMETHODIMP PrepareToEnumObjects(HWND hwnd, DWORD * pdwFlags);
    STDMETHODIMP ClearSearchCriteria();
    STDMETHODIMP EnumObjects(IShellFolder *psf, LPCITEMIDLIST pidlStart, DWORD grfFlags, int iColSort, 
                              LPTSTR pszProgressText, IRowsetWatchNotify *prwn, IFindEnum **ppfindenum);
    STDMETHODIMP GetColumnsFolder(IShellFolder2 **ppsf);
    STDMETHODIMP_(BOOL) MatchFilter(IShellFolder *psf, LPCITEMIDLIST pidl);
    STDMETHODIMP SaveCriteria(IStream * pstm, WORD fCharType);   
    STDMETHODIMP RestoreCriteria(IStream * pstm, int cCriteria, WORD fCharType);
    STDMETHODIMP DeclareFSNotifyInterest(HWND hwndDlg, UINT uMsg);
    STDMETHODIMP GetColSaveStream(WPARAM wParam, IStream **ppstm);
    STDMETHODIMP GenerateQueryRestrictions(LPWSTR *ppwszQuery, DWORD *pdwGQRFlags);
    STDMETHODIMP ReleaseQuery();
    STDMETHODIMP UpdateField(LPCWSTR pszField, VARIANT vValue);
    STDMETHODIMP ResetFieldsToDefaults();
    STDMETHODIMP GetItemContextMenu(HWND hwndOwner, IFindFolder* pff, IContextMenu** ppcm);
    STDMETHODIMP GetDefaultSearchGUID(IShellFolder2 *psf2, LPGUID lpGuid);
    STDMETHODIMP EnumSearches(IShellFolder2 *psf2, LPENUMEXTRASEARCH *ppenum);
    STDMETHODIMP GetSearchFolderClassId(LPGUID lpGuid);
    STDMETHODIMP GetNextConstraint(VARIANT_BOOL fReset, BSTR *pName, VARIANT *pValue, VARIANT_BOOL *pfFound);
    STDMETHODIMP GetQueryLanguageDialect(ULONG * pulDialect);
    STDMETHODIMP GetWarningFlags(DWORD *pdwWarningFlags) { return E_NOTIMPL; }

protected:

    LPTSTR _pszCompName;   // the one we do compares with
    TCHAR _szUserInputCompName[MAX_PATH];  // User input

private:
    ~CNetFindFilter();
    LONG _cRef;

    LPITEMIDLIST _pidlStart;      // Where to start the search from.

    // Data associated with the file name.
};

CNetFindFilter::CNetFindFilter() : _cRef(1)
{
}

CNetFindFilter::~CNetFindFilter()
{
    ILFree(_pidlStart);
    Str_SetPtr(&_pszCompName, NULL);
}


STDMETHODIMP CNetFindFilter::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENT(CNetFindFilter, IFindFilter),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CNetFindFilter::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CNetFindFilter::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;
    
    delete this;
    return 0;
}

STDMETHODIMP CNetFindFilter::GetStatusMessageIndex(UINT uContext, UINT *puMsgIndex)
{
    // Currently context is not used
    *puMsgIndex = IDS_COMPUTERSFOUND;
    return S_OK;
}

STDMETHODIMP CNetFindFilter::GetFolderMergeMenuIndex(UINT *puBGMainMergeMenu, UINT *puBGPopupMergeMenu)
{
    *puBGPopupMergeMenu = 0;
    return S_OK;
}

STDMETHODIMP CNetFindFilter::GetItemContextMenu(HWND hwndOwner, IFindFolder* pff, IContextMenu **ppcm)
{
    return CFindItem_Create(hwndOwner, pff, ppcm);
}

STDMETHODIMP CNetFindFilter::GetDefaultSearchGUID(IShellFolder2 *psf2, GUID *pGuid)
{
    *pGuid = SRCID_SFindComputer;
    return S_OK;
}

STDMETHODIMP CNetFindFilter::EnumSearches(IShellFolder2 *psf2, IEnumExtraSearch **ppenum)
{
    return CNetwork_EnumSearches(psf2, ppenum);
}

STDMETHODIMP CNetFindFilter::GetSearchFolderClassId(LPGUID lpGuid)
{
    *lpGuid = CLSID_ComputerFindFolder;
    return S_OK;
}

STDMETHODIMP CNetFindFilter::GetNextConstraint(VARIANT_BOOL fReset, BSTR *pName, VARIANT *pValue, VARIANT_BOOL *pfFound)
{
    *pName = NULL;
    *pfFound = FALSE;
    VariantClear(pValue);                            
    return E_NOTIMPL;
}

STDMETHODIMP CNetFindFilter::GetQueryLanguageDialect(ULONG * pulDialect)
{
    if (pulDialect)
        *pulDialect = 0;
    return E_NOTIMPL;
}

STDMETHODIMP CNetFindFilter::FFilterChanged()
{
    // Currently not saving so who cares?
    return S_FALSE;
}

STDMETHODIMP CNetFindFilter::GenerateTitle(LPTSTR *ppszTitle, BOOL fFileName)
{
    // Now lets construct the message from the resource
    *ppszTitle = ShellConstructMessageString(HINST_THISDLL,
            MAKEINTRESOURCE(IDS_FIND_TITLE_COMPUTER), fFileName ? TEXT(" #") : TEXT(":"));

    return *ppszTitle ? S_OK : E_OUTOFMEMORY;
}

STDMETHODIMP CNetFindFilter::ClearSearchCriteria()
{
    return S_OK;
}


STDAPI CreateDefaultComputerFindFilter(IFindFilter **ppff)
{
    *ppff = new CNetFindFilter;
    return *ppff ? S_OK : E_OUTOFMEMORY;
}


class CNetFindEnum : public IFindEnum
{
public:
    CNetFindEnum(CNetFindFilter *pnff, IShellFolder *psf, LPTSTR pszDisplayText, DWORD grfFlags, LPITEMIDLIST pidlStart);

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IFindEnum
    STDMETHODIMP Next(LPITEMIDLIST *ppidl, int *pcObjectSearched, int *pcFoldersSearched, BOOL *pfContinue, int *pState);
    STDMETHODIMP Skip(int celt) { return E_NOTIMPL; }
    STDMETHODIMP Reset() { return E_NOTIMPL; }
    STDMETHODIMP StopSearch() { return E_NOTIMPL; }
    STDMETHODIMP_(BOOL) FQueryIsAsync();
    STDMETHODIMP GetAsyncCount(DBCOUNTITEM *pdwTotalAsync, int *pnPercentComplete, BOOL *pfQueryDone);
    STDMETHODIMP GetItemIDList(UINT iItem, LPITEMIDLIST *ppidl);
    STDMETHODIMP GetItemID(UINT iItem, DWORD *puWorkID);
    STDMETHODIMP SortOnColumn(UINT iCol, BOOL fAscending);

private:
    ~CNetFindEnum();
    HRESULT _FindCompByUNCName(LPITEMIDLIST *ppidl, int *piState);

    LONG _cRef;
    IFindFolder  *_pff;                 // find folder

    // Stuff to use in the search
    DWORD _grfFlags;                    // Flags that control things like recursion

    // filter info...
    LPTSTR _pszDisplayText;             // Place to write feadback text into
    CNetFindFilter *_pnetf;             // Pointer to the net filter...

    // enumeration state

    IShellFolder *_psfEnum;             // Pointer to shell folder for the object.
    IEnumIDList  *_penum;               // Enumerator in use.
    LPITEMIDLIST  _pidlFolder;                // The idlist of the currently processing
    LPITEMIDLIST  _pidlStart;           // Pointer to the starting point.
    int           _iFolder;             // Which folder are we adding items for?
    BOOL          _fFindUNC;            // Find UNC special case
    int           _iPassCnt;            // Used to control when to reiterat...
};


CNetFindEnum::CNetFindEnum(CNetFindFilter *pnff, IShellFolder *psf, LPTSTR pszDisplayText, DWORD grfFlags, LPITEMIDLIST pidlStart) :
    _cRef(1), _pnetf(pnff), _pszDisplayText(pszDisplayText), _grfFlags(grfFlags), _iFolder(-1)
{
    ASSERT(0 == _iPassCnt);

    _pnetf->AddRef();

    psf->QueryInterface(IID_PPV_ARG(IFindFolder, &_pff));
    ASSERT(_pff);

    if (pidlStart)
        SHILClone(pidlStart, &_pidlStart);
    else
        SHGetDomainWorkgroupIDList(&_pidlStart);

    // special case to force us to search for specific UNC
    _fFindUNC = _pnetf->_pszCompName && (_pnetf->_pszCompName[0] == TEXT('\\'));
}

CNetFindEnum::~CNetFindEnum()
{
    // Release any open enumerator and open IShell folder we may have.
    if (_psfEnum)
        _psfEnum->Release();
    if (_penum)
        _penum->Release();

    _pff->Release();
    _pnetf->Release();

    ILFree(_pidlStart);
    ILFree(_pidlFolder);
}

STDMETHODIMP CNetFindEnum::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
//        QITABENT(CNetFindEnum, IFindEnum),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CNetFindEnum::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CNetFindEnum::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;
    delete this;
    return 0;
}

STDMETHODIMP CNetFindFilter::EnumObjects(IShellFolder *psf, LPCITEMIDLIST pidlStart, 
                                    DWORD grfFlags, int iColSort, LPTSTR pszDisplayText, 
                                    IRowsetWatchNotify *prsn, IFindEnum **ppfindenum)
{
    // We need to construct the iterator
    *ppfindenum = new CNetFindEnum(this, psf, pszDisplayText, grfFlags, _pidlStart);
    return *ppfindenum ? S_OK : E_OUTOFMEMORY;
}

STDMETHODIMP CNetFindFilter::PrepareToEnumObjects(HWND hwnd, DWORD *pdwFlags)
{
    *pdwFlags = 0;

    // Also lets convert the Computer name  pattern into the strings
    // will do the compares against.
    if ((_szUserInputCompName[0] == TEXT('\\')) &&
        (_szUserInputCompName[1] == TEXT('\\')))
    {
        Str_SetPtr(&_pszCompName, _szUserInputCompName);
    }
    else
    {
        SetupWildCardingOnFileSpec(_szUserInputCompName, &_pszCompName);
    }

    return S_OK;
}

STDMETHODIMP CNetFindFilter::GetColumnsFolder(IShellFolder2 **ppsf)
{
    LPITEMIDLIST pidl;
    HRESULT hr = SHGetDomainWorkgroupIDList(&pidl);
    if (SUCCEEDED(hr))
    {
        hr = SHBindToObject(NULL, IID_X_PPV_ARG(IShellFolder2, pidl, ppsf));
        ILFree(pidl);
    }
    else
        *ppsf = NULL;
    return hr;
}

STDMETHODIMP_(BOOL) CNetFindFilter::MatchFilter(IShellFolder *psf, LPCITEMIDLIST pidl)
{
    if (this->_pszCompName && this->_pszCompName[0])
    {
        // Although for now not much...
        TCHAR szPath[MAX_PATH];

        return SUCCEEDED(DisplayNameOf(psf, pidl, SHGDN_NORMAL, szPath, ARRAYSIZE(szPath))) &&
               PathMatchSpec(szPath, _pszCompName);
    }

    return TRUE;    // emtpy search, return TRUE (yes)
}

STDMETHODIMP CNetFindFilter::SaveCriteria(IStream *pstm, WORD fCharType)
{
    return S_OK;
}

STDMETHODIMP CNetFindFilter::RestoreCriteria(IStream *pstm, int cCriteria, WORD fCharType)
{
    return S_OK;
}

STDMETHODIMP CNetFindFilter::GetColSaveStream(WPARAM wparam, IStream **ppstm)
{
    *ppstm = NULL;
    return E_NOTIMPL;
}

STDMETHODIMP CNetFindFilter::GenerateQueryRestrictions(LPWSTR *ppszQuery, DWORD *pdwFlags)
{
    if (ppszQuery)
        *ppszQuery = NULL;
    *pdwFlags = 0;
    return E_NOTIMPL;
}

STDMETHODIMP CNetFindFilter::ReleaseQuery()
{
    return S_OK;
}

HRESULT CNetFindFilter::UpdateField(LPCWSTR pszField, VARIANT vValue)
{
    HRESULT hr = E_FAIL;

    if (0 == StrCmpIW(pszField, L"LookIn"))
    {
        hr = S_OK;  // ignored
    }
    else if (0 == StrCmpIW(pszField, L"SearchFor"))
    {
        // Careful!  VariantToStr returns a pointer, not an HRESULT
        if (VariantToStr(&vValue, _szUserInputCompName, ARRAYSIZE(_szUserInputCompName)))
        {
            hr = S_OK;
        }
    }

    return hr;
}

HRESULT CNetFindFilter::ResetFieldsToDefaults()
{
    _szUserInputCompName[0] = 0;
    return S_OK;
}

STDMETHODIMP CNetFindFilter::DeclareFSNotifyInterest(HWND hwndDlg, UINT uMsg)
{
    SHChangeNotifyEntry fsne;

    fsne.fRecursive = TRUE;
    fsne.pidl = _pidlStart;
    if (fsne.pidl) 
    {
        SHChangeNotifyRegister(hwndDlg, SHCNRF_NewDelivery | SHCNRF_ShellLevel, SHCNE_DISKEVENTS, uMsg, 1, &fsne);
    }

    return S_OK;
}

// chop off all of an UNC path except the \\server portion

void _StripToServer(LPTSTR pszUNC)
{
    for (pszUNC += 2; *pszUNC; pszUNC = CharNext(pszUNC))
    {
        if (*pszUNC == TEXT('\\'))
        {
            // found something after server name, so get rid of it
            *pszUNC = 0;
            break;
        }
    }
}

// Helper function to the next function to help process find computer
// on returning computers by UNC names...

HRESULT CNetFindEnum::_FindCompByUNCName(LPITEMIDLIST *ppidl, int *piState)
{
    *piState = GNF_DONE;    // assume we are done

    // Two cases, There is a UNC name entered.  If so we need to process
    // this by extracting everythign off after the server name...
    if (_pnetf->_pszCompName && _pnetf->_pszCompName[0])
    {
        if (PathIsUNC(_pnetf->_pszCompName))
        {
            _StripToServer(_pnetf->_pszCompName);
        }
        else
        {
            // no unc name, but lets try to convert to unc name
            TCHAR szTemp[MAX_PATH];
            szTemp[0] = TEXT('\\');
            szTemp[1] = TEXT('\\');
            szTemp[2] = 0;

            StrCatBuff(szTemp, _pnetf->_szUserInputCompName, ARRAYSIZE(szTemp)); 
            _StripToServer(szTemp);

            Str_SetPtr(&_pnetf->_pszCompName, szTemp);
        }
    }

    if (_pnetf->_pszCompName && _pnetf->_pszCompName[0])
    {
        // see if we can parse this guy... if so we have a match
        LPITEMIDLIST pidl;
        if (SUCCEEDED(SHParseDisplayName(_pnetf->_pszCompName, NULL, &pidl, 0, NULL)))
        {
            LPITEMIDLIST pidlFolder;
            LPCITEMIDLIST pidlChild;
            if (SUCCEEDED(SplitIDList(pidl, &pidlFolder, &pidlChild)))
            {
                if (SUCCEEDED(_pff->AddFolder(pidlFolder, FALSE, &_iFolder)))
                {
                    if (SUCCEEDED(_pff->AddDataToIDList(pidlChild, _iFolder, pidlFolder, DFDF_NONE, 0, 0, 0, ppidl)))
                        *piState = GNF_MATCH;
                }
                ILFree(pidlFolder);
            }
            ILFree(pidl);
        }
    }
    return S_OK;
}

STDMETHODIMP CNetFindEnum::Next(LPITEMIDLIST *ppidl, int *pcObjectSearched, 
                                int *pcFoldersSearched, BOOL *pfContinue, int *piState)
{
    HRESULT hr;
    // Special case to find UNC Names quickly
    if (_fFindUNC)
    {
        // If not the first time through return that we are done!
        if (_iPassCnt)
        {
            *piState = GNF_DONE;
            return S_OK;
        }

        _iPassCnt = 1;

        hr = _FindCompByUNCName(ppidl, piState);
    }
    else
    {
        BOOL fContinue = TRUE;

        do
        {
            if (_penum)
            {
                LPITEMIDLIST pidl;
                if (S_OK == _penum->Next(1, &pidl, NULL))
                {
                    // Now see if this is someone we might want to return.
                    // Our Match function take esither find data or idlist...
                    // for networks we work off of the idlist,
                    fContinue = FALSE;  // We can exit the loop;
                    (*pcObjectSearched)++;
                
                    if (_pnetf->MatchFilter(_psfEnum, pidl))
                    {
                        *piState = GNF_MATCH;

                        // see if we have to add this folder to our list.
                        if (-1 == _iFolder)
                            _pff->AddFolder(_pidlFolder, FALSE, &_iFolder);

                        if (SUCCEEDED(_pff->AddDataToIDList(pidl, _iFolder, _pidlFolder, DFDF_NONE, 0, 0, 0, ppidl)))
                        {
                            if ((_iPassCnt == 1) && _pnetf->_pszCompName && _pnetf->_pszCompName[0])
                            {
                                // See if this is an exact match of the name
                                // we are looking for.  If it is we set pass=2
                                // as to not add the item twice.
                                TCHAR szName[MAX_PATH];

                                if (SUCCEEDED(DisplayNameOf(_psfEnum, pidl, SHGDN_NORMAL, szName, ARRAYSIZE(szName))) &&
                                    (0 == lstrcmpi(szName, _pnetf->_szUserInputCompName)))
                                {
                                    _iPassCnt = 2;
                                }
                            }
                            ILFree(pidl);
                            pidl = NULL;
                            break;
                        }
                    }
                    else
                    {
                        *piState = GNF_NOMATCH;
                    }
                    ILFree(pidl);
                }
                else
                {
                    ATOMICRELEASE(_penum);      // release and zero
                    ATOMICRELEASE(_psfEnum);
                }
            }

            if (!_penum)
            {
                switch (_iPassCnt)
                {
                case 1:
                    // We went through all of the items see if there is
                    // an exact match...
                    _iPassCnt = 2;

                    return _FindCompByUNCName(ppidl, piState);

                case 2:
                    // We looped through everything so return done!
                    *piState = GNF_DONE;
                    return S_OK;

                case 0:
                    // This is the main pass through here...
                    // Need to clone the idlist
                    hr = SHILClone(_pidlStart, &_pidlFolder);
                    if (SUCCEEDED(hr))
                    {
                        _iPassCnt = 1;

                        // We will do the first on in our own thread.
                        if (SUCCEEDED(SHBindToObject(NULL, IID_X_PPV_ARG(IShellFolder, _pidlFolder, &_psfEnum))))
                        {
                            if (S_OK != _psfEnum->EnumObjects(NULL, SHCONTF_FOLDERS | SHCONTF_NONFOLDERS, &_penum))
                            {
                                // Failed to get iterator so release folder.
                                ATOMICRELEASE(_psfEnum);
                                ASSERT(NULL == _penum);
                            }
                        }
                        break;
                    }
                    else
                    {
                       *piState = GNF_ERROR;
                       return hr;
                    }
                }

                (*pcFoldersSearched)++;

                // update progress text
                SHGetNameAndFlags(_pidlFolder, SHGDN_NORMAL, _pszDisplayText, MAX_PATH, NULL);
            }
        } while (fContinue && *pfContinue);

        hr = S_OK;
    }
    return hr;
}

STDMETHODIMP_(BOOL) CNetFindEnum::FQueryIsAsync()
{
    return FALSE;
}

STDMETHODIMP CNetFindEnum::GetAsyncCount(DBCOUNTITEM *pdwTotalAsync, int *pnPercentComplete, BOOL *pfQueryDone)
{
    return E_NOTIMPL;
}

STDMETHODIMP CNetFindEnum::GetItemIDList(UINT iItem, LPITEMIDLIST *ppidl)
{
    return E_NOTIMPL;
}

STDMETHODIMP CNetFindEnum::GetItemID(UINT iItem, DWORD *puWorkID)
{
    *puWorkID = (UINT)-1;
    return E_NOTIMPL;
}

STDMETHODIMP CNetFindEnum::SortOnColumn(UINT iCOl, BOOL fAscending)
{
    return E_NOTIMPL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\ole2def.c ===
// stubs for OLE routines that we used to delay load or implement ourselves

#include "shellprv.h"
#pragma  hdrstop

STDAPI SHFlushClipboard(void)
{
    return OleFlushClipboard();
}

// we should not use these anymore, just call the OLE32 versions

STDAPI SHRegisterDragDrop(HWND hwnd, IDropTarget *pDropTarget)
{
    return RegisterDragDrop(hwnd, pDropTarget);
}

STDAPI SHRevokeDragDrop(HWND hwnd)
{
    return RevokeDragDrop(hwnd);
}

STDAPI_(void) SHFreeUnusedLibraries()
{
    CoFreeUnusedLibraries();
}

STDAPI SHLoadOLE(LPARAM lParam)
{
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\nothunk.c ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    nothunk.c

Abstract:

    Code to handle routines which are being thunked down to 16 bits or
    exported from the Windows 95 kernel.  On NT these do nothing.

--*/


#include "shellprv.h"
#pragma  hdrstop

LRESULT WINAPI CallCPLEntry16(
    HINSTANCE hinst,
    FARPROC16 lpfnEntry,
    HWND hwndCPL,
    UINT msg,
    LPARAM lParam1,
    LPARAM lParam2
) {
    return 0L;
}

void RunDll_CallEntry16(
    RUNDLLPROC pfn,
    HWND hwndStub,
    HINSTANCE hinst,
    LPSTR pszParam,
    int nCmdShow)
{
    return;
}

void SHGlobalDefect(DWORD lpVoid)
{
    return;
}


VOID WINAPI CallAddPropSheetPages16(
    LPFNADDPROPSHEETPAGES lpfn16,
    LPVOID hdrop,
    LPPAGEARRAY papg
) {
    return;
}


UINT WINAPI SHAddPages16(HGLOBAL hGlobal, LPCTSTR pszDllEntry, LPFNADDPROPSHEETPAGE pfnAddPage, LPARAM lParam)
{
    return 0;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\obexerr.h ===
/*****************************************************************************
*
* Copyright (c) 2000 - 2001  Microsoft Corporation
*
* Module Name:
*
*    obexerr.h
*
* Abstract:
*
*    Error codes for OBEX
*
*****************************************************************************/

#if _MSC_VER >= 1000
#pragma once
#endif // _MSC_VER >= 1000

#ifndef __OBEXERR_H__
#define __OBEXERR_H__

//--------------------------------------------------------------------------
//     Core OBEX Error messages
//--------------------------------------------------------------------------

//
//  Values are 32 bit values layed out as follows:
//
//   3 3 2 2 2 2 2 2 2 2 2 2 1 1 1 1 1 1 1 1 1 1
//   1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0
//  +---+-+-+-----------------------+-------------------------------+
//  |Sev|C|R|     Facility          |               Code            |
//  +---+-+-+-----------------------+-------------------------------+
//
//  where
//
//      Sev - is the severity code
//
//          00 - Success
//          01 - Informational
//          10 - Warning
//          11 - Error
//
//      C - is the Customer code flag
//
//      R - is a reserved bit
//
//      Facility - is the facility code
//
//      Code - is the facility's status code
//
//
// Define the facility codes
//


//
// OBEX error codes from the spec mapped into HRESULTS
//
#define E_OBEX_BASE             MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0300)
#define HRESULT_FROM_OBEX(x)    ( (x == 0x20) ? S_OK : E_OBEX_BASE | x )
#define OBEX_FROM_HRESULT       ( (x == S_OK) ? OBEX_REPLY_SUCCESS : x & 0x000000FF )
#define IS_OBEX_ERR(x)          ( (x & 0x00000F00) == 0x0300 )

//
// Windows specific error codes
//

//
// MessageId: OBEX_E_DISCONNECTED
//
// MessageText:
//
//  The connection has been disconnected.
//
#define OBEX_E_DISCONNECTED             MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0200)

//
// MessageId: OBEX_E_ABORTED
//
// MessageText:
//
//  The request has been aborted.
//
#define OBEX_E_ABORTED                  MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0201)

//
// MessageId: OBEX_E_NOT_INITIALIZED
//
// MessageText:
//
//  OBEX has not been initialized.
//
#define OBEX_E_NOT_INITIALIZED          MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0202)

//
// MessageId: OBEX_E_TRANSPORT_NOT_AVAILABLE
//
// MessageText:
//
//  The requested transport is not available.
//
#define OBEX_E_TRANSPORT_NOT_AVAILABLE  MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0203)

// MessageId: OBEX_E_TRANSPORT_INIT
//
// MessageText:
//
//  An error occurred while initializing the transports.
//
#define OBEX_E_TRANSPORT_INIT           MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0204)

// MessageId: OBEX_E_ALREADY_CONNECTED
//
// MessageText:
//
//  A connection to the device has already been established.
//
#define OBEX_E_ALREADY_CONNECTED        MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0205)

// MessageId: OBEX_E_NOT_CONNECTED
//
// MessageText:
//
//  A connection to the device has not been established.
//
#define OBEX_E_NOT_CONNECTED            MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0206)

// MessageId: OBEX_E_CANT_CONNECT
//
// MessageText:
//
//  A connection to the OBEX service on the remote device could not be established.
//
#define OBEX_E_CANT_CONNECT             MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0207)

// MessageId: OBEX_E_TIMEOUT
//
// MessageText:
//
//  A timeout occurred while communicating on the network.
//
#define OBEX_E_TIMEOUT                  MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0208)

// MessageId: OBEX_E_NETWORK_ERROR
//
// MessageText:
//
//  An unspecified network error occurred.
//
#define OBEX_E_NETWORK_ERROR            MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x0209)

// MessageId: OBEX_E_DEVICE_NOT_FOUND
//
// MessageText:
//
//  The specified device could not be located.
//
#define OBEX_E_DEVICE_NOT_FOUND         MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x020A)

// MessageId: OBEX_E_SERIVCE_ALREADY_REGISTERED
//
// MessageText:
//
//  The specified service has already been registered.
//
#define OBEX_E_SERIVCE_ALREADY_REGISTERED MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x020B)

// MessageId: OBEX_E_UNEXPECTED
//
// MessageText:
//
//  The unexpected error occurred.
//
#define OBEX_E_UNEXPECTED               MAKE_HRESULT(SEVERITY_ERROR, FACILITY_ITF, 0x020C)


#endif // #ifndef __OBEXERR_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\ole2dup.h ===
#include <shellp.h>

// undoced OLE32 export (so we have to have this thunk)
STDAPI SHStgOpenStorageOnHandle(HANDLE h, DWORD grfMode, void *res1, void *res2, REFIID riid, void **ppv);

STDAPI SHCoCreateInstance(LPCTSTR pszCLSID, const CLSID *pclsid, IUnknown* pUnkOuter, REFIID riid, void **ppv);
STDAPI SHExtCoCreateInstance(LPCTSTR pszCLSID, const CLSID *pclsid, IUnknown* pUnkOuter, REFIID riid, void **ppv);
STDAPI SHExtCoCreateInstance2(LPCTSTR pszCLSID, const CLSID *pclsid, IUnknown *punkOuter, DWORD dwClsCtx, REFIID riid, void **ppv);
STDAPI SHCLSIDFromString(LPCTSTR lpsz, LPCLSID pclsid);
STDAPI_(HINSTANCE) SHPinDllOfCLSIDStr(LPCTSTR pszCLSID);

#define CH_GUIDFIRST TEXT('{') // '}'
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\ole2dup.c ===
#include "shellprv.h"
#pragma  hdrstop

// this makes sure the DLL for the given clsid stays in memory
// this is needed because we violate COM rules and hold apparment objects
// across the lifetime of appartment threads. these objects really need
// to be free threaded (we have always treated them as such)

STDAPI_(HINSTANCE) SHPinDllOfCLSIDStr(LPCTSTR pszCLSID)
{
    CLSID clsid;

    SHCLSIDFromString(pszCLSID, &clsid);
    return SHPinDllOfCLSID(&clsid);
}

// translate string form of CLSID into binary form

STDAPI SHCLSIDFromString(LPCTSTR psz, CLSID *pclsid)
{
    *pclsid = CLSID_NULL;
    if (psz == NULL) 
        return NOERROR;
    return GUIDFromString(psz, pclsid) ? NOERROR : CO_E_CLASSSTRING;
}

BOOL _IsShellDll(LPCTSTR pszDllPath)
{
    LPCTSTR pszDllName = PathFindFileName(pszDllPath);
    return lstrcmpi(pszDllName, TEXT("shell32.dll")) == 0;
}

HKEY g_hklmApprovedExt = (HKEY)-1;    // not tested yet

// On NT, we must check to ensure that this CLSID exists in
// the list of approved CLSIDs that can be used in-process.
// If not, we fail the creation with ERROR_ACCESS_DENIED.
// We explicitly allow anything serviced by this DLL

BOOL _IsShellExtApproved(LPCTSTR pszClass, LPCTSTR pszDllPath)
{
    BOOL fIsApproved = TRUE;

    ASSERT(!_IsShellDll(pszDllPath));

#ifdef FULL_DEBUG
    if (TRUE)
#else
    if (SHRestricted(REST_ENFORCESHELLEXTSECURITY))
#endif
    {
        if (g_hklmApprovedExt == (HKEY)-1)
        {
            g_hklmApprovedExt = NULL;
            RegOpenKey(HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Shell Extensions\\Approved"), &g_hklmApprovedExt);
        }

        if (g_hklmApprovedExt)
        {
            fIsApproved = SHQueryValueEx(g_hklmApprovedExt, pszClass, 0, NULL, NULL, NULL) == ERROR_SUCCESS;
            if (!fIsApproved)
            {
                HKEY hk;
                if (RegOpenKey(HKEY_CURRENT_USER, TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Shell Extensions\\Approved"), &hk) == ERROR_SUCCESS)
                {
                    fIsApproved = SHQueryValueEx(hk, pszClass, 0, NULL, NULL, NULL) == ERROR_SUCCESS;
                    RegCloseKey(hk);
                }
            }
        }
    }

#ifdef FULL_DEBUG
    if (!SHRestricted(REST_ENFORCESHELLEXTSECURITY) && !fIsApproved)
    {
        TraceMsg(TF_WARNING, "%s not approved; fortunately, shell security is disabled", pszClass);
        fIsApproved = TRUE;
    }
#endif
    return fIsApproved;
}

STDAPI_(BOOL) IsGuimodeSetupRunning()
{
    DWORD dwSystemSetupInProgress;
    DWORD dwMiniSetupInProgress;
    DWORD dwType;
    DWORD dwSize;
    
    dwSize = sizeof(dwSystemSetupInProgress);
    if ((SHGetValueW(HKEY_LOCAL_MACHINE, L"SYSTEM\\Setup", L"SystemSetupInProgress", &dwType, (LPVOID)&dwSystemSetupInProgress, &dwSize) == ERROR_SUCCESS) &&
        (dwType == REG_DWORD) &&
        (dwSystemSetupInProgress != 0))
    {

        // starting w/ whistler on a syspreped machine the SystemSetupInProgress will be set EVEN AFTER guimode setup
        // has finished (needed for OOBE on the boot after guimode finishes). So, to distinguish the "first-boot" case
        // from the "guimode-setup" case we check the MiniSetupInProgress value as well.

        dwSize = sizeof(dwMiniSetupInProgress);
        if ((SHGetValueW(HKEY_LOCAL_MACHINE, L"SYSTEM\\Setup", L"MiniSetupInProgress", &dwType, (LPVOID)&dwMiniSetupInProgress, &dwSize) != ERROR_SUCCESS) ||
            (dwType != REG_DWORD) ||
            (dwMiniSetupInProgress == 0))
        {
            return TRUE;
        }
    }

    return FALSE;
}

typedef HRESULT (__stdcall *PFNDLLGETCLASSOBJECT)(REFCLSID rclsid, REFIID riid, void **ppv);

HRESULT _CreateFromDllGetClassObject(PFNDLLGETCLASSOBJECT pfn, const CLSID *pclsid, IUnknown *punkOuter, REFIID riid, void **ppv)
{
    IClassFactory *pcf;
    HRESULT hr = pfn(pclsid, &IID_IClassFactory, &pcf);
    if (SUCCEEDED(hr))
    {
        hr = pcf->lpVtbl->CreateInstance(pcf, punkOuter, riid, ppv);
#ifdef DEBUG
        if (SUCCEEDED(hr))
        {
            // confirm that OLE can create this object to
            // make sure our objects are really CoCreateable
            IUnknown *punk;
            HRESULT hrTemp = CoCreateInstance(pclsid, punkOuter, CLSCTX_INPROC_SERVER, riid, &punk);
            if (SUCCEEDED(hrTemp))
                punk->lpVtbl->Release(punk);
            else
            {
                if (hrTemp == CO_E_NOTINITIALIZED)
                {
                    // shell32.dll works without com being inited
                    TraceMsg(TF_WARNING, "shell32 or friend object used without COM being initalized");
                }
// the RIPMSG below was hitting too often in out-of-memory cases where lame class factories return E_FAIL, E_NOTIMPL, and a bunch of
// other meaningless error codes. I have therefore relegaed this ripmsg to FULL_DEBUG only status.
#ifdef FULL_DEBUG
                else if ((hrTemp != E_OUTOFMEMORY) &&   // stress can hit the E_OUTOFMEMORY case
                         (hrTemp != E_NOINTERFACE) &&   // stress can hit the E_NOINTERFACE case
                         (hrTemp != HRESULT_FROM_WIN32(ERROR_COMMITMENT_LIMIT)) &&      // stress can hit the ERROR_COMMITMENT_LIMIT case
                         (hrTemp != HRESULT_FROM_WIN32(ERROR_NO_SYSTEM_RESOURCES)) &&   // stress can hit the ERROR_NO_SYSTEM_RESOURCES case
                         !IsGuimodeSetupRunning())      // and we don't want to fire the assert during guimode (shell32 might not be registered yet)
                {
                    // others failures are bad
                    RIPMSG(FALSE, "CoCreate failed with %x", hrTemp);
                }
#endif // FULL_DEBUG
            }
        }
#endif
        pcf->lpVtbl->Release(pcf);
    }
    return hr;
}


HRESULT _CreateFromShell(const CLSID *pclsid, IUnknown *punkOuter, REFIID riid, void **ppv)
{
    return _CreateFromDllGetClassObject(DllGetClassObject, pclsid, punkOuter, riid, ppv);
}

HRESULT _CreateFromDll(LPCTSTR pszDllPath, const CLSID *pclsid, IUnknown *punkOuter, REFIID riid, void **ppv)
{
    HMODULE hmod = LoadLibraryEx(pszDllPath,NULL,LOAD_WITH_ALTERED_SEARCH_PATH);
    if (hmod)
    {
        HRESULT hr;
        PFNDLLGETCLASSOBJECT pfn = (PFNDLLGETCLASSOBJECT)GetProcAddress(hmod, "DllGetClassObject");
        if (pfn)
            hr = _CreateFromDllGetClassObject(pfn, pclsid, punkOuter, riid, ppv);
        else
            hr = E_FAIL;

        if (FAILED(hr))
            FreeLibrary(hmod);
        return hr;
    }
    return HRESULT_FROM_WIN32(GetLastError());
}

STDAPI SHGetInProcServerForClass(const CLSID *pclsid, LPTSTR pszDllPath, LPTSTR pszClass, BOOL *pbLoadWithoutCOM)
{
    TCHAR szKeyToOpen[GUIDSTR_MAX + 128], szInProcServer[GUIDSTR_MAX];
    HKEY hkeyInProcServer;
    DWORD dwSize = MAX_PATH * sizeof(TCHAR);  // convert to count of bytes
    DWORD dwError;

    SHStringFromGUID(pclsid, szInProcServer, ARRAYSIZE(szInProcServer));

    lstrcpy(pszClass, szInProcServer);

    *pszDllPath = 0;

    lstrcpy(szKeyToOpen, TEXT("CLSID\\"));
    lstrcat(szKeyToOpen, szInProcServer);
    lstrcat(szKeyToOpen, TEXT("\\InProcServer32"));

    dwError = RegOpenKeyEx(HKEY_CLASSES_ROOT, szKeyToOpen, 0, KEY_QUERY_VALUE, &hkeyInProcServer);
    if (dwError == ERROR_SUCCESS)
    {
        SHQueryValueEx(hkeyInProcServer, NULL, 0, NULL, (BYTE *)pszDllPath, &dwSize);

        *pbLoadWithoutCOM = SHQueryValueEx(hkeyInProcServer, TEXT("LoadWithoutCOM"), NULL, NULL, NULL, NULL) == ERROR_SUCCESS;
        RegCloseKey(hkeyInProcServer);
    }

    //
    //  Return a more accurate error code so we don't
    //  fire a bogus assertion.
    //
    if (*pszDllPath)
    {
        return S_OK;
    }
    else
    {
        // If error was "key not found", then the class is not registered.
        // If no error, then class is not registered properly (e.g., null
        // string for InProcServer32).
        if (dwError == ERROR_FILE_NOT_FOUND || dwError == ERROR_SUCCESS)
        {
            return REGDB_E_CLASSNOTREG;
        }
        else
        {
            // Any other error is worth reporting as-is (out of memory,
            // access denied, etc.)
            return HRESULT_FROM_WIN32(dwError);
        }
    }
}

STDAPI _SHCoCreateInstance(const CLSID * pclsid, IUnknown *punkOuter, DWORD dwCoCreateFlags, 
                           BOOL bMustBeApproved, REFIID riid, void **ppv)
{
    HRESULT hr = E_FAIL;
    TCHAR szClass[GUIDSTR_MAX + 64], szDllPath[MAX_PATH];
    BOOL bLoadWithoutCOM = FALSE;
    *ppv = NULL;
    *szDllPath = 0;

    // save us some registry accesses and try the shell first
    // but only if its INPROC
    if (dwCoCreateFlags & CLSCTX_INPROC_SERVER)
        hr = _CreateFromShell(pclsid, punkOuter, riid, ppv);

#ifdef DEBUG
    if (SUCCEEDED(hr))
    {
        HRESULT hrRegistered = THR(SHGetInProcServerForClass(pclsid, szDllPath, szClass, &bLoadWithoutCOM));

        //
        // check to see if we're the explorer process before complaining (to
        // avoid ripping during setup before all objects have been registered)
        //
        if (IsProcessAnExplorer() && !IsGuimodeSetupRunning() && hrRegistered == REGDB_E_CLASSNOTREG)
        {
            ASSERTMSG(FAILED(hr), "object not registered (add to selfreg.inx) pclsid = %x", pclsid);
        }
    }
#endif

    if (FAILED(hr))
    {
        BOOL fNeedsInProc = ((dwCoCreateFlags & CLSCTX_ALL) == CLSCTX_INPROC_SERVER);
        hr = fNeedsInProc ? THR(SHGetInProcServerForClass(pclsid, szDllPath, szClass, &bLoadWithoutCOM)) : S_FALSE;
        if (SUCCEEDED(hr))
        {
            if (hr == S_OK && _IsShellDll(szDllPath))
            {
                // Object likely moved out of the shell DLL.
                hr = CLASS_E_CLASSNOTAVAILABLE;
            }
            else if (bMustBeApproved &&
                     SHStringFromGUID(pclsid, szClass, ARRAYSIZE(szClass)) &&
                     !_IsShellExtApproved(szClass, szDllPath))
            {
                TraceMsg(TF_ERROR, "SHCoCreateInstance() %s needs to be registered under HKLM or HKCU"
                    ",Software\\Microsoft\\Windows\\CurrentVersion\\Shell Extensions\\Approved", szClass);
                hr = HRESULT_FROM_WIN32(ERROR_ACCESS_DENIED);
            }
            else
            {
                hr = THR(SHCoCreateInstanceAC(pclsid, punkOuter, dwCoCreateFlags, riid, ppv));

                if (FAILED(hr) && fNeedsInProc && bLoadWithoutCOM)
                {
                    if ((hr == REGDB_E_IIDNOTREG) || (hr == CO_E_NOTINITIALIZED))
                    {
                        hr = THR(_CreateFromDll(szDllPath, pclsid, punkOuter, riid, ppv));
                    }
                }

                // only RIP if this is not a secondary explorer process since secondary explorers dont init com or ole since
                // they are going to delegate to an existing process and we don't want to have to load ole for perf in that case.
                if (!IsSecondaryExplorerProcess())
                {
                    RIPMSG((hr != CO_E_NOTINITIALIZED), "COM not inited for dll %s", szDllPath);
                }

                //  sometimes we need to permanently pin these objects.
                if (SUCCEEDED(hr) && fNeedsInProc && (OBJCOMPATF_PINDLL & SHGetObjectCompatFlags(NULL, pclsid)))
                {
                    SHPinDllOfCLSID(pclsid);
                }
            }
        }
    }

#ifdef DEBUG
    if (FAILED(hr) && (hr != E_NOINTERFACE))    // E_NOINTERFACE means riid not accepted
    {
        ULONGLONG dwTF = IsFlagSet(g_dwBreakFlags, BF_COCREATEINSTANCE) ? TF_ALWAYS : TF_WARNING;
        TraceMsg(dwTF, "CoCreateInstance: failed (%s,%x)", szClass, hr);
    }
#endif
    return hr;
}

STDAPI SHCoCreateInstance(LPCTSTR pszCLSID, const CLSID * pclsid, IUnknown *punkOuter, REFIID riid, void **ppv)
{
    CLSID clsid;
    if (pszCLSID)
    {
        SHCLSIDFromString(pszCLSID, &clsid);
        pclsid = &clsid;
    }
    return _SHCoCreateInstance(pclsid, punkOuter, CLSCTX_INPROC_SERVER, FALSE, riid, ppv);
}

//
// create a shell extension object, ensures that object is in the approved list
//
STDAPI SHExtCoCreateInstance2(LPCTSTR pszCLSID, const CLSID *pclsid, IUnknown *punkOuter, DWORD dwClsCtx, REFIID riid, void **ppv)
{
    CLSID clsid;
    
    if (pszCLSID)
    {
        SHCLSIDFromString(pszCLSID, &clsid);
        pclsid = &clsid;
    }

    return _SHCoCreateInstance(pclsid, punkOuter, dwClsCtx, TRUE, riid, ppv);
}

STDAPI SHExtCoCreateInstance(LPCTSTR pszCLSID, const CLSID *pclsid, IUnknown *punkOuter, REFIID riid, void **ppv)
{
    return SHExtCoCreateInstance2(pszCLSID, pclsid, punkOuter, CLSCTX_NO_CODE_DOWNLOAD | CLSCTX_INPROC_SERVER, riid, ppv);
}

STDAPI_(BOOL) SHIsBadInterfacePtr(const void *pv, UINT cbVtbl)
{
    IUnknown const * punk = pv;
    return IsBadReadPtr(punk, sizeof(punk->lpVtbl)) || 
           IsBadReadPtr(punk->lpVtbl, cbVtbl) || 
           IsBadCodePtr((FARPROC)punk->lpVtbl->Release);
}

// private API that loads COM inproc objects out of band of COM. this 
// should be used very carefully, only in special legacy cases where 
// we knowingly need to break COM rules. right now this is only for AVIFile
// as it depended on the Win95 behavior of SHCoCreateInstance() loading objects
// without COM being inited and without them being marshalled

STDAPI SHCreateInstance(REFCLSID clsid, REFIID riid, void **ppv)
{
    TCHAR szClass[GUIDSTR_MAX + 64], szDllPath[MAX_PATH];
    BOOL bLoadWithoutCOM;

    HRESULT hr = SHGetInProcServerForClass(clsid, szDllPath, szClass, &bLoadWithoutCOM);
    if (SUCCEEDED(hr))
    {
        hr = THR(_CreateFromDll(szDllPath, clsid, NULL, riid, ppv));
    }
    else
    {
        *ppv = NULL;
    }
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\ole2dup2.c ===
#include "shellprv.h"
#pragma  hdrstop


// NOTE: the STRRET_WSTR pOleStr gets freed, so don't try to use it later

STDAPI_(BOOL) StrRetToStrN(LPTSTR pszOut, UINT cchOut, STRRET *pStrRet, LPCITEMIDLIST pidl)
{
    return SUCCEEDED(StrRetToBuf(pStrRet, pidl, pszOut, cchOut));
}

STDAPI_(int) OleStrToStrN(LPTSTR pszOut, int cchOut, LPCWSTR pwsz, int cchWideChar)
{
    int cchOutput;
#ifdef UNICODE
    VDATEINPUTBUF(pszOut, WCHAR, cchOut);

    if (cchOut > cchWideChar && -1 != cchWideChar)
        cchOut = cchWideChar;

    cchOutput = cchOut;

    while (cchOut)
    {
        if ((*pszOut++ = *pwsz++) == 0)
            return cchOutput - cchOut + 1;
        cchOut--;
    }

    if (-1 == cchWideChar)
        pszOut--;              // Make room for the null 

    *pszOut = 0;
    return cchOutput;
#else
    VDATEINPUTBUF(pszOut, CHAR, cchOut);
    cchOutput = WideCharToMultiByte(CP_ACP, 0, pwsz, cchWideChar, pszOut, cchOut, NULL, NULL);
    if (cchOutput && (cchOutput == cchOut))
        cchOutput--;
    pszOut[cchOutput] = 0;
    return cchOutput;
#endif // UNICODE
}


STDAPI_(int) StrToOleStrN(LPWSTR pwszOut, int cchOut, LPCTSTR psz, int cchIn)
{
    int cchOutput;
#ifdef UNICODE
    VDATEINPUTBUF(pwszOut, WCHAR, cchOut);

    if (cchOut > cchIn)
        cchOut = cchIn;

    cchOutput = cchOut;

    while (--cchOut)
    {
        if ((*pwszOut++ = *psz++) == 0)
            return cchOutput - cchOut + 1;
    }

    *pwszOut = 0;
    return cchOutput;
#else
    VDATEINPUTBUF(pwszOut, WCHAR, cchOut);
    cchOutput = MultiByteToWideChar(CP_ACP, 0, psz, cchIn, pwszOut, cchOut);
    if (cchOutput && (cchOutput == cchOut))
        cchOutput--;
    pwszOut[cchOutput] = 0;
    return cchOutput;
#endif
}

// bogus export, too scared to remove it
STDAPI_(int) StrToOleStr(LPWSTR pwszOut, LPCTSTR psz)
{
    VDATEINPUTBUF(pwszOut, WCHAR, MAX_PATH);
    return SHTCharToUnicode(psz, pwszOut, MAX_PATH);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\obex.h ===
#pragma warning( disable: 4049 )  /* more than 64k source lines */

/* this ALWAYS GENERATED file contains the definitions for the interfaces */


 /* File created by MIDL compiler version 6.00.0340 */
/* Compiler settings for obex.idl:
    Oicf, W1, Zp8, env=Win32 (32b run)
    protocol : dce , ms_ext, c_ext, robust
    error checks: allocation ref bounds_check enum stub_data 
    VC __declspec() decoration level: 
         __declspec(uuid()), __declspec(selectany), __declspec(novtable)
         DECLSPEC_UUID(), MIDL_INTERFACE()
*/
//@@MIDL_FILE_HEADING(  )


/* verify that the <rpcndr.h> version is high enough to compile this file*/
#ifndef __REQUIRED_RPCNDR_H_VERSION__
#define __REQUIRED_RPCNDR_H_VERSION__ 475
#endif

#include "rpc.h"
#include "rpcndr.h"

#ifndef __RPCNDR_H_VERSION__
#error this stub requires an updated version of <rpcndr.h>
#endif // __RPCNDR_H_VERSION__

#ifndef COM_NO_WINDOWS_H
#include "windows.h"
#include "ole2.h"
#endif /*COM_NO_WINDOWS_H*/

#ifndef __obex_h__
#define __obex_h__

#if defined(_MSC_VER) && (_MSC_VER >= 1020)
#pragma once
#endif

/* Forward Declarations */ 

#ifndef __IObex_FWD_DEFINED__
#define __IObex_FWD_DEFINED__
typedef interface IObex IObex;
#endif 	/* __IObex_FWD_DEFINED__ */


#ifndef __IObexDevice_FWD_DEFINED__
#define __IObexDevice_FWD_DEFINED__
typedef interface IObexDevice IObexDevice;
#endif 	/* __IObexDevice_FWD_DEFINED__ */


#ifndef __IHeaderCollection_FWD_DEFINED__
#define __IHeaderCollection_FWD_DEFINED__
typedef interface IHeaderCollection IHeaderCollection;
#endif 	/* __IHeaderCollection_FWD_DEFINED__ */


#ifndef __IObexSink_FWD_DEFINED__
#define __IObexSink_FWD_DEFINED__
typedef interface IObexSink IObexSink;
#endif 	/* __IObexSink_FWD_DEFINED__ */


#ifndef __IObexService_FWD_DEFINED__
#define __IObexService_FWD_DEFINED__
typedef interface IObexService IObexService;
#endif 	/* __IObexService_FWD_DEFINED__ */


#ifndef __IObexServiceConnection_FWD_DEFINED__
#define __IObexServiceConnection_FWD_DEFINED__
typedef interface IObexServiceConnection IObexServiceConnection;
#endif 	/* __IObexServiceConnection_FWD_DEFINED__ */


#ifndef __IInboxSink_FWD_DEFINED__
#define __IInboxSink_FWD_DEFINED__
typedef interface IInboxSink IInboxSink;
#endif 	/* __IInboxSink_FWD_DEFINED__ */


#ifndef __IHeaderEnum_FWD_DEFINED__
#define __IHeaderEnum_FWD_DEFINED__
typedef interface IHeaderEnum IHeaderEnum;
#endif 	/* __IHeaderEnum_FWD_DEFINED__ */


#ifndef __IPropertyBagEnum_FWD_DEFINED__
#define __IPropertyBagEnum_FWD_DEFINED__
typedef interface IPropertyBagEnum IPropertyBagEnum;
#endif 	/* __IPropertyBagEnum_FWD_DEFINED__ */


#ifndef __IDeviceEnum_FWD_DEFINED__
#define __IDeviceEnum_FWD_DEFINED__
typedef interface IDeviceEnum IDeviceEnum;
#endif 	/* __IDeviceEnum_FWD_DEFINED__ */


#ifndef __Obex_FWD_DEFINED__
#define __Obex_FWD_DEFINED__

#ifdef __cplusplus
typedef class Obex Obex;
#else
typedef struct Obex Obex;
#endif /* __cplusplus */

#endif 	/* __Obex_FWD_DEFINED__ */


#ifndef __HeaderCollection_FWD_DEFINED__
#define __HeaderCollection_FWD_DEFINED__

#ifdef __cplusplus
typedef class HeaderCollection HeaderCollection;
#else
typedef struct HeaderCollection HeaderCollection;
#endif /* __cplusplus */

#endif 	/* __HeaderCollection_FWD_DEFINED__ */


#ifndef __PropertyBag_FWD_DEFINED__
#define __PropertyBag_FWD_DEFINED__

#ifdef __cplusplus
typedef class PropertyBag PropertyBag;
#else
typedef struct PropertyBag PropertyBag;
#endif /* __cplusplus */

#endif 	/* __PropertyBag_FWD_DEFINED__ */


#ifndef __IrdaTransport_FWD_DEFINED__
#define __IrdaTransport_FWD_DEFINED__

#ifdef __cplusplus
typedef class IrdaTransport IrdaTransport;
#else
typedef struct IrdaTransport IrdaTransport;
#endif /* __cplusplus */

#endif 	/* __IrdaTransport_FWD_DEFINED__ */


#ifndef __BthTransport_FWD_DEFINED__
#define __BthTransport_FWD_DEFINED__

#ifdef __cplusplus
typedef class BthTransport BthTransport;
#else
typedef struct BthTransport BthTransport;
#endif /* __cplusplus */

#endif 	/* __BthTransport_FWD_DEFINED__ */


#ifndef __IpTransport_FWD_DEFINED__
#define __IpTransport_FWD_DEFINED__

#ifdef __cplusplus
typedef class IpTransport IpTransport;
#else
typedef struct IpTransport IpTransport;
#endif /* __cplusplus */

#endif 	/* __IpTransport_FWD_DEFINED__ */


/* header files for imported files */
#include "oaidl.h"
#include "ocidl.h"

#ifdef __cplusplus
extern "C"{
#endif 

void * __RPC_USER MIDL_user_allocate(size_t);
void __RPC_USER MIDL_user_free( void * ); 

/* interface __MIDL_itf_obex_0000 */
/* [local] */ 

#include <obexerr.h>







#define	OBEX_VERSION_10	( 0x10 )

#define	OBEX_VERSION_12	( 0x12 )

#define	OBEX_VERSION	( OBEX_VERSION_12 )

#define	INVALID_CONN_ID	( 0xffffffff )

typedef 
enum _OBEX_EVENT
    {	OE_NEW_DEVICE	= 0,
	OE_QUERY_PASSWORD	= OE_NEW_DEVICE + 1,
	OE_NEW_CONNECTION	= OE_QUERY_PASSWORD + 1,
	OE_NEW_COMMAND	= OE_NEW_CONNECTION + 1,
	OE_ABORT	= OE_NEW_COMMAND + 1,
	OE_DISCONNECT	= OE_ABORT + 1
    } 	OBEX_EVENT;

typedef enum _OBEX_EVENT *LPOBEX_EVENT;

typedef 
enum _INBOX_EVENT
    {	IE_GET	= 0,
	IE_PUT	= IE_GET + 1
    } 	INBOX_EVENT;

typedef enum _INBOX_EVENT *LPINBOX_EVENT;

#define	SETPATH_FLAG_BACKUP	( 0x1 )

#define	SETPATH_FLAG_DONT_CREATE	( 0x2 )

#define	OBEX_HEADER_UNICODE	( 0 )

#define	OBEX_HEADER_STREAM	( 0x40 )

#define	OBEX_HEADER_1BYTE	( 0x80 )

#define	OBEX_HEADER_4BYTE	( 0xc0 )

#define	OBEX_HEADER_COUNT	( 0 | OBEX_HEADER_4BYTE )

#define	OBEX_HEADER_NAME	( 0x1 | OBEX_HEADER_UNICODE )

#define	OBEX_HEADER_TYPE	( 0x2 | OBEX_HEADER_STREAM )

#define	OBEX_HEADER_LENGTH	( 0x3 | OBEX_HEADER_4BYTE )

#define	OBEX_HEADER_TIME_ISO	( 0x4 | OBEX_HEADER_STREAM )

#define	OBEX_HEADER_TIME_COMPAT	( 0x4 | OBEX_HEADER_4BYTE )

#define	OBEX_HEADER_DESCRIPTION	( 0x5 | OBEX_HEADER_UNICODE )

#define	OBEX_HEADER_TARGET	( 0x6 | OBEX_HEADER_STREAM )

#define	OBEX_HEADER_HTTP	( 0x7 | OBEX_HEADER_STREAM )

#define	OBEX_HEADER_BODY	( 0x8 | OBEX_HEADER_STREAM )

#define	OBEX_HEADER_END_OF_BODY	( 0x9 | OBEX_HEADER_STREAM )

#define	OBEX_HEADER_WHO	( 0xa | OBEX_HEADER_STREAM )

#define	OBEX_HEADER_CONNECTION_ID	( 0xb | OBEX_HEADER_4BYTE )

#define	OBEX_HEADER_APP_PARAMS	( 0xc | OBEX_HEADER_STREAM )

#define	OBEX_HEADER_AUTH_CHALLENGE	( 0xd | OBEX_HEADER_STREAM )

#define	OBEX_HEADER_AUTH_RESPONSE	( 0xe | OBEX_HEADER_STREAM )

#define	OBEX_HEADER_OBJECT_CLASS	( 0xf | OBEX_HEADER_STREAM )

typedef struct _OBEX_HEADER
    {
    byte bId;
    /* [switch_is] */ /* [switch_type] */ union 
        {
        /* [case()][string] */ LPWSTR pszData;
        /* [case()] */ DWORD dwData;
        /* [case()] */ byte bData;
        /* [case()] */ struct 
            {
            DWORD dwSize;
            /* [size_is] */ byte *pbaData;
            } 	ba;
        } 	value;
    } 	OBEX_HEADER;

typedef struct _OBEX_REQUEST
    {
    DWORD dwRequest;
    DWORD dwFlags;
    IHeaderCollection *pHeaderCol;
    BOOL fStream;
    IStream *pStream;
    } 	OBEX_REQUEST;

typedef struct _OBEX_REQUEST *POBEX_REQUEST;

#define	OBEX_OPCODE_FINALBIT	( 0x80 )

#define	OBEX_OPCODE_CONNECT	( 0 | OBEX_OPCODE_FINALBIT )

#define	OBEX_OPCODE_DISCONNECT	( 0x1 | OBEX_OPCODE_FINALBIT )

#define	OBEX_OPCODE_PUT	( 0x2 )

#define	OBEX_OPCODE_GET	( 0x3 )

#define	OBEX_OPCODE_SET_PATH	( 0x5 | OBEX_OPCODE_FINALBIT )

#define	OBEX_OPCODE_ABORT	( 0x7f | OBEX_OPCODE_FINALBIT )

#define	OBEX_REPLY_CONTINUE	( 0x10 )

#define	OBEX_REPLY_SUCCESS	( 0x20 )

#define	OBEX_REPLY_CREATED	( 0x21 )

#define	OBEX_REPLY_ACCEPTED	( 0x22 )

#define	OBEX_REPLY_NON_AUTHORITATIVE_INFO	( 0x23 )

#define	OBEX_REPLY_NO_CONTENT	( 0x24 )

#define	OBEX_REPLY_RESET_CONTENT	( 0x25 )

#define	OBEX_REPLY_PARTIAL_CONTENT	( 0x26 )

#define	OBEX_REPLY_MULIPLE_CHOICES	( 0x30 )

#define	OBEX_REPLY_MOVED_PERMANENTLY	( 0x31 )

#define	OBEX_REPLY_MOVED_TEMPORARILY	( 0x32 )

#define	OBEX_REPLY_SEE_OTHER	( 0x33 )

#define	OBEX_REPLY_NOT_NODIFIED	( 0x34 )

#define	OBEX_REPLY_USE_PROXY	( 0x35 )

#define	OBEX_REPLY_FAIL_BAD_REQUEST	( 0x40 )

#define	OBEX_REPLY_FAIL_UNAUTHORIZED	( 0x41 )

#define	OBEX_REPLY_FAIL_PAYMENT_REQUIRED	( 0x42 )

#define	OBEX_REPLY_FAIL_FORBIDDEN	( 0x43 )

#define	OBEX_REPLY_FAIL_NOT_FOUND	( 0x44 )

#define	OBEX_REPLY_FAIL_METHOD_NOT_ALLOWED	( 0x45 )

#define	OBEX_REPLY_FAIL_NOT_ACCEPTABLE	( 0x46 )

#define	OBEX_REPLY_FAIL_PROXY_AUTHORIZATION_REQUIRED	( 0x47 )

#define	OBEX_REPLY_FAIL_REQUEST_TIME_OUT	( 0x48 )

#define	OBEX_REPLY_FAIL_CONFLICT	( 0x49 )

#define	OBEX_REPLY_FAIL_GONE	( 0x4a )

#define	OBEX_REPLY_FAIL_LENGTH_REQUIRED	( 0x4b )

#define	OBEX_REPLY_FAIL_PRECONDITION_FAILED	( 0x4c )

#define	OBEX_REPLY_FAIL_REQUESTED_ENTITY_TOO_LARGE	( 0x4d )

#define	OBEX_REPLY_FAIL_REQUEST_URL_TOO_LARGE	( 0x4e )

#define	OBEX_REPLY_FAIL_UNSUPPORTED_MEDIA_TYPE	( 0x4f )

#define	OBEX_REPLY_FAIL_INTERNAL_SERVER_ERROR	( 0x50 )

#define	OBEX_REPLY_FAIL_NOT_IMPLEMENTED	( 0x51 )

#define	OBEX_REPLY_FAIL_BAD_GATEWAY	( 0x52 )

#define	OBEX_REPLY_FAIL_SERVICE_UNAVAILABLE	( 0x53 )

#define	OBEX_REPLY_FAIL_GATEWAY_TIMEOUT	( 0x54 )

#define	OBEX_REPLY_FAIL_HTTP_VERSION_NOT_SUPPORTED	( 0x55 )

#define	OBEX_REPLY_FAIL_DATABASE_FULL	( 0x60 )

#define	OBEX_REPLY_FAIL_DATABASE_LOCKED	( 0x61 )

#define	OBEX_DEVICE_CAP_UNKNOWN	( 0 )

#define	OBEX_DEVICE_CAP_PUSH	( 0x1 )

#define	OBEX_DEVICE_CAP_FILE_BROWSE	( 0x2 )

#define	OBEX_DEVICE_CAP_SYNC	( 0x4 )



extern RPC_IF_HANDLE __MIDL_itf_obex_0000_v0_0_c_ifspec;
extern RPC_IF_HANDLE __MIDL_itf_obex_0000_v0_0_s_ifspec;

#ifndef __IObex_INTERFACE_DEFINED__
#define __IObex_INTERFACE_DEFINED__

/* interface IObex */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IObex;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("0C5A5B12-2979-42D1-9E15-A63E34383B58")
    IObex : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Initialize( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Shutdown( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE EnumDevices( 
            /* [out] */ IDeviceEnum **ppDeviceEnum,
            /* [in] */ REFCLSID uuidTransport) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE EnumTransports( 
            /* [out] */ IPropertyBagEnum **ppTransportEnum) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE RegisterService( 
            /* [in] */ IPropertyBag *pPropertyBag,
            /* [out] */ IObexService **ppService) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE BindToDevice( 
            /* [in] */ IPropertyBag *pPropertyBag,
            /* [out] */ IObexDevice **ppDevice) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IObexVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IObex * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IObex * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IObex * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Initialize )( 
            IObex * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Shutdown )( 
            IObex * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *EnumDevices )( 
            IObex * This,
            /* [out] */ IDeviceEnum **ppDeviceEnum,
            /* [in] */ REFCLSID uuidTransport);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *EnumTransports )( 
            IObex * This,
            /* [out] */ IPropertyBagEnum **ppTransportEnum);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *RegisterService )( 
            IObex * This,
            /* [in] */ IPropertyBag *pPropertyBag,
            /* [out] */ IObexService **ppService);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *BindToDevice )( 
            IObex * This,
            /* [in] */ IPropertyBag *pPropertyBag,
            /* [out] */ IObexDevice **ppDevice);
        
        END_INTERFACE
    } IObexVtbl;

    interface IObex
    {
        CONST_VTBL struct IObexVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IObex_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IObex_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IObex_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IObex_Initialize(This)	\
    (This)->lpVtbl -> Initialize(This)

#define IObex_Shutdown(This)	\
    (This)->lpVtbl -> Shutdown(This)

#define IObex_EnumDevices(This,ppDeviceEnum,uuidTransport)	\
    (This)->lpVtbl -> EnumDevices(This,ppDeviceEnum,uuidTransport)

#define IObex_EnumTransports(This,ppTransportEnum)	\
    (This)->lpVtbl -> EnumTransports(This,ppTransportEnum)

#define IObex_RegisterService(This,pPropertyBag,ppService)	\
    (This)->lpVtbl -> RegisterService(This,pPropertyBag,ppService)

#define IObex_BindToDevice(This,pPropertyBag,ppDevice)	\
    (This)->lpVtbl -> BindToDevice(This,pPropertyBag,ppDevice)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IObex_Initialize_Proxy( 
    IObex * This);


void __RPC_STUB IObex_Initialize_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IObex_Shutdown_Proxy( 
    IObex * This);


void __RPC_STUB IObex_Shutdown_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IObex_EnumDevices_Proxy( 
    IObex * This,
    /* [out] */ IDeviceEnum **ppDeviceEnum,
    /* [in] */ REFCLSID uuidTransport);


void __RPC_STUB IObex_EnumDevices_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IObex_EnumTransports_Proxy( 
    IObex * This,
    /* [out] */ IPropertyBagEnum **ppTransportEnum);


void __RPC_STUB IObex_EnumTransports_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IObex_RegisterService_Proxy( 
    IObex * This,
    /* [in] */ IPropertyBag *pPropertyBag,
    /* [out] */ IObexService **ppService);


void __RPC_STUB IObex_RegisterService_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IObex_BindToDevice_Proxy( 
    IObex * This,
    /* [in] */ IPropertyBag *pPropertyBag,
    /* [out] */ IObexDevice **ppDevice);


void __RPC_STUB IObex_BindToDevice_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IObex_INTERFACE_DEFINED__ */


#ifndef __IObexDevice_INTERFACE_DEFINED__
#define __IObexDevice_INTERFACE_DEFINED__

/* interface IObexDevice */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IObexDevice;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("3ED60A15-6FB0-4A81-8ED3-49097A8E292C")
    IObexDevice : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Connect( 
            /* [in] */ LPCWSTR pszPassword,
            /* [in] */ DWORD dwCapability,
            /* [in] */ IHeaderCollection *pHeaders) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Disconnect( 
            /* [in] */ IHeaderCollection *pHeaders) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Get( 
            /* [in] */ IHeaderCollection *pHeaders,
            /* [out] */ IStream **ppStream) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Put( 
            /* [in] */ IHeaderCollection *pHeaders,
            /* [unique][out][in] */ IStream **ppStream) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Abort( 
            /* [in] */ IHeaderCollection *pHeaders) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetPath( 
            /* [in] */ LPCWSTR pszName,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IHeaderCollection *pHeaders) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE EnumProperties( 
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppv) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetPassword( 
            /* [in] */ LPCWSTR pszPassword) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE BindToStorage( 
            /* [in] */ DWORD dwCapability,
            /* [out] */ IStorage **ppStorage) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IObexDeviceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IObexDevice * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IObexDevice * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IObexDevice * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Connect )( 
            IObexDevice * This,
            /* [in] */ LPCWSTR pszPassword,
            /* [in] */ DWORD dwCapability,
            /* [in] */ IHeaderCollection *pHeaders);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Disconnect )( 
            IObexDevice * This,
            /* [in] */ IHeaderCollection *pHeaders);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Get )( 
            IObexDevice * This,
            /* [in] */ IHeaderCollection *pHeaders,
            /* [out] */ IStream **ppStream);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Put )( 
            IObexDevice * This,
            /* [in] */ IHeaderCollection *pHeaders,
            /* [unique][out][in] */ IStream **ppStream);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Abort )( 
            IObexDevice * This,
            /* [in] */ IHeaderCollection *pHeaders);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetPath )( 
            IObexDevice * This,
            /* [in] */ LPCWSTR pszName,
            /* [in] */ DWORD dwFlags,
            /* [in] */ IHeaderCollection *pHeaders);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *EnumProperties )( 
            IObexDevice * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppv);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetPassword )( 
            IObexDevice * This,
            /* [in] */ LPCWSTR pszPassword);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *BindToStorage )( 
            IObexDevice * This,
            /* [in] */ DWORD dwCapability,
            /* [out] */ IStorage **ppStorage);
        
        END_INTERFACE
    } IObexDeviceVtbl;

    interface IObexDevice
    {
        CONST_VTBL struct IObexDeviceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IObexDevice_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IObexDevice_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IObexDevice_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IObexDevice_Connect(This,pszPassword,dwCapability,pHeaders)	\
    (This)->lpVtbl -> Connect(This,pszPassword,dwCapability,pHeaders)

#define IObexDevice_Disconnect(This,pHeaders)	\
    (This)->lpVtbl -> Disconnect(This,pHeaders)

#define IObexDevice_Get(This,pHeaders,ppStream)	\
    (This)->lpVtbl -> Get(This,pHeaders,ppStream)

#define IObexDevice_Put(This,pHeaders,ppStream)	\
    (This)->lpVtbl -> Put(This,pHeaders,ppStream)

#define IObexDevice_Abort(This,pHeaders)	\
    (This)->lpVtbl -> Abort(This,pHeaders)

#define IObexDevice_SetPath(This,pszName,dwFlags,pHeaders)	\
    (This)->lpVtbl -> SetPath(This,pszName,dwFlags,pHeaders)

#define IObexDevice_EnumProperties(This,riid,ppv)	\
    (This)->lpVtbl -> EnumProperties(This,riid,ppv)

#define IObexDevice_SetPassword(This,pszPassword)	\
    (This)->lpVtbl -> SetPassword(This,pszPassword)

#define IObexDevice_BindToStorage(This,dwCapability,ppStorage)	\
    (This)->lpVtbl -> BindToStorage(This,dwCapability,ppStorage)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IObexDevice_Connect_Proxy( 
    IObexDevice * This,
    /* [in] */ LPCWSTR pszPassword,
    /* [in] */ DWORD dwCapability,
    /* [in] */ IHeaderCollection *pHeaders);


void __RPC_STUB IObexDevice_Connect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IObexDevice_Disconnect_Proxy( 
    IObexDevice * This,
    /* [in] */ IHeaderCollection *pHeaders);


void __RPC_STUB IObexDevice_Disconnect_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IObexDevice_Get_Proxy( 
    IObexDevice * This,
    /* [in] */ IHeaderCollection *pHeaders,
    /* [out] */ IStream **ppStream);


void __RPC_STUB IObexDevice_Get_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IObexDevice_Put_Proxy( 
    IObexDevice * This,
    /* [in] */ IHeaderCollection *pHeaders,
    /* [unique][out][in] */ IStream **ppStream);


void __RPC_STUB IObexDevice_Put_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IObexDevice_Abort_Proxy( 
    IObexDevice * This,
    /* [in] */ IHeaderCollection *pHeaders);


void __RPC_STUB IObexDevice_Abort_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IObexDevice_SetPath_Proxy( 
    IObexDevice * This,
    /* [in] */ LPCWSTR pszName,
    /* [in] */ DWORD dwFlags,
    /* [in] */ IHeaderCollection *pHeaders);


void __RPC_STUB IObexDevice_SetPath_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IObexDevice_EnumProperties_Proxy( 
    IObexDevice * This,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ void **ppv);


void __RPC_STUB IObexDevice_EnumProperties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IObexDevice_SetPassword_Proxy( 
    IObexDevice * This,
    /* [in] */ LPCWSTR pszPassword);


void __RPC_STUB IObexDevice_SetPassword_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IObexDevice_BindToStorage_Proxy( 
    IObexDevice * This,
    /* [in] */ DWORD dwCapability,
    /* [out] */ IStorage **ppStorage);


void __RPC_STUB IObexDevice_BindToStorage_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IObexDevice_INTERFACE_DEFINED__ */


#ifndef __IHeaderCollection_INTERFACE_DEFINED__
#define __IHeaderCollection_INTERFACE_DEFINED__

/* interface IHeaderCollection */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IHeaderCollection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6561D66B-8CC1-49F9-8071-632D288EDAF3")
    IHeaderCollection : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddByteArray( 
            /* [in] */ byte Id,
            /* [in] */ unsigned long ulSize,
            /* [size_is][in] */ byte *pData) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddLong( 
            /* [in] */ byte Id,
            /* [in] */ unsigned long ulData) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddByte( 
            /* [in] */ byte Id,
            /* [in] */ byte pData) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddUnicodeString( 
            /* [in] */ byte Id,
            /* [in] */ LPCWSTR pszData) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Remove( 
            /* [in] */ byte Id) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE RemoveAll( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddCount( 
            /* [in] */ unsigned long ulCount) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddName( 
            /* [in] */ LPCWSTR pszName) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddType( 
            /* [in] */ unsigned long ulSize,
            /* [size_is][in] */ byte *pData) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddLength( 
            /* [in] */ unsigned long ulLength) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddTimeOld( 
            /* [in] */ unsigned long ulTime) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddTime( 
            /* [in] */ FILETIME *pFiletime) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddDescription( 
            /* [in] */ LPCWSTR pszDescription) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddTarget( 
            /* [in] */ unsigned long ulSize,
            /* [size_is][in] */ byte *pData) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddHTTP( 
            /* [in] */ unsigned long ulSize,
            /* [size_is][in] */ byte *pData) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddBody( 
            /* [in] */ unsigned long ulSize,
            /* [size_is][in] */ byte *pData) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddEndOfBody( 
            /* [in] */ unsigned long ulSize,
            /* [size_is][in] */ byte *pData) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddWho( 
            /* [in] */ unsigned long ulSize,
            /* [size_is][in] */ byte *pData) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddConnectionId( 
            /* [in] */ unsigned long ulConnectionId) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddAppParams( 
            /* [in] */ unsigned long ulSize,
            /* [size_is][in] */ byte *pData) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE AddObjectClass( 
            /* [in] */ unsigned long ulSize,
            /* [size_is][in] */ byte *pData) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE EnumHeaders( 
            /* [out] */ IHeaderEnum **pHeaderEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHeaderCollectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IHeaderCollection * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IHeaderCollection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IHeaderCollection * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AddByteArray )( 
            IHeaderCollection * This,
            /* [in] */ byte Id,
            /* [in] */ unsigned long ulSize,
            /* [size_is][in] */ byte *pData);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AddLong )( 
            IHeaderCollection * This,
            /* [in] */ byte Id,
            /* [in] */ unsigned long ulData);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AddByte )( 
            IHeaderCollection * This,
            /* [in] */ byte Id,
            /* [in] */ byte pData);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AddUnicodeString )( 
            IHeaderCollection * This,
            /* [in] */ byte Id,
            /* [in] */ LPCWSTR pszData);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Remove )( 
            IHeaderCollection * This,
            /* [in] */ byte Id);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *RemoveAll )( 
            IHeaderCollection * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AddCount )( 
            IHeaderCollection * This,
            /* [in] */ unsigned long ulCount);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AddName )( 
            IHeaderCollection * This,
            /* [in] */ LPCWSTR pszName);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AddType )( 
            IHeaderCollection * This,
            /* [in] */ unsigned long ulSize,
            /* [size_is][in] */ byte *pData);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AddLength )( 
            IHeaderCollection * This,
            /* [in] */ unsigned long ulLength);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AddTimeOld )( 
            IHeaderCollection * This,
            /* [in] */ unsigned long ulTime);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AddTime )( 
            IHeaderCollection * This,
            /* [in] */ FILETIME *pFiletime);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AddDescription )( 
            IHeaderCollection * This,
            /* [in] */ LPCWSTR pszDescription);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AddTarget )( 
            IHeaderCollection * This,
            /* [in] */ unsigned long ulSize,
            /* [size_is][in] */ byte *pData);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AddHTTP )( 
            IHeaderCollection * This,
            /* [in] */ unsigned long ulSize,
            /* [size_is][in] */ byte *pData);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AddBody )( 
            IHeaderCollection * This,
            /* [in] */ unsigned long ulSize,
            /* [size_is][in] */ byte *pData);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AddEndOfBody )( 
            IHeaderCollection * This,
            /* [in] */ unsigned long ulSize,
            /* [size_is][in] */ byte *pData);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AddWho )( 
            IHeaderCollection * This,
            /* [in] */ unsigned long ulSize,
            /* [size_is][in] */ byte *pData);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AddConnectionId )( 
            IHeaderCollection * This,
            /* [in] */ unsigned long ulConnectionId);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AddAppParams )( 
            IHeaderCollection * This,
            /* [in] */ unsigned long ulSize,
            /* [size_is][in] */ byte *pData);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *AddObjectClass )( 
            IHeaderCollection * This,
            /* [in] */ unsigned long ulSize,
            /* [size_is][in] */ byte *pData);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *EnumHeaders )( 
            IHeaderCollection * This,
            /* [out] */ IHeaderEnum **pHeaderEnum);
        
        END_INTERFACE
    } IHeaderCollectionVtbl;

    interface IHeaderCollection
    {
        CONST_VTBL struct IHeaderCollectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHeaderCollection_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IHeaderCollection_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IHeaderCollection_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IHeaderCollection_AddByteArray(This,Id,ulSize,pData)	\
    (This)->lpVtbl -> AddByteArray(This,Id,ulSize,pData)

#define IHeaderCollection_AddLong(This,Id,ulData)	\
    (This)->lpVtbl -> AddLong(This,Id,ulData)

#define IHeaderCollection_AddByte(This,Id,pData)	\
    (This)->lpVtbl -> AddByte(This,Id,pData)

#define IHeaderCollection_AddUnicodeString(This,Id,pszData)	\
    (This)->lpVtbl -> AddUnicodeString(This,Id,pszData)

#define IHeaderCollection_Remove(This,Id)	\
    (This)->lpVtbl -> Remove(This,Id)

#define IHeaderCollection_RemoveAll(This)	\
    (This)->lpVtbl -> RemoveAll(This)

#define IHeaderCollection_AddCount(This,ulCount)	\
    (This)->lpVtbl -> AddCount(This,ulCount)

#define IHeaderCollection_AddName(This,pszName)	\
    (This)->lpVtbl -> AddName(This,pszName)

#define IHeaderCollection_AddType(This,ulSize,pData)	\
    (This)->lpVtbl -> AddType(This,ulSize,pData)

#define IHeaderCollection_AddLength(This,ulLength)	\
    (This)->lpVtbl -> AddLength(This,ulLength)

#define IHeaderCollection_AddTimeOld(This,ulTime)	\
    (This)->lpVtbl -> AddTimeOld(This,ulTime)

#define IHeaderCollection_AddTime(This,pFiletime)	\
    (This)->lpVtbl -> AddTime(This,pFiletime)

#define IHeaderCollection_AddDescription(This,pszDescription)	\
    (This)->lpVtbl -> AddDescription(This,pszDescription)

#define IHeaderCollection_AddTarget(This,ulSize,pData)	\
    (This)->lpVtbl -> AddTarget(This,ulSize,pData)

#define IHeaderCollection_AddHTTP(This,ulSize,pData)	\
    (This)->lpVtbl -> AddHTTP(This,ulSize,pData)

#define IHeaderCollection_AddBody(This,ulSize,pData)	\
    (This)->lpVtbl -> AddBody(This,ulSize,pData)

#define IHeaderCollection_AddEndOfBody(This,ulSize,pData)	\
    (This)->lpVtbl -> AddEndOfBody(This,ulSize,pData)

#define IHeaderCollection_AddWho(This,ulSize,pData)	\
    (This)->lpVtbl -> AddWho(This,ulSize,pData)

#define IHeaderCollection_AddConnectionId(This,ulConnectionId)	\
    (This)->lpVtbl -> AddConnectionId(This,ulConnectionId)

#define IHeaderCollection_AddAppParams(This,ulSize,pData)	\
    (This)->lpVtbl -> AddAppParams(This,ulSize,pData)

#define IHeaderCollection_AddObjectClass(This,ulSize,pData)	\
    (This)->lpVtbl -> AddObjectClass(This,ulSize,pData)

#define IHeaderCollection_EnumHeaders(This,pHeaderEnum)	\
    (This)->lpVtbl -> EnumHeaders(This,pHeaderEnum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IHeaderCollection_AddByteArray_Proxy( 
    IHeaderCollection * This,
    /* [in] */ byte Id,
    /* [in] */ unsigned long ulSize,
    /* [size_is][in] */ byte *pData);


void __RPC_STUB IHeaderCollection_AddByteArray_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IHeaderCollection_AddLong_Proxy( 
    IHeaderCollection * This,
    /* [in] */ byte Id,
    /* [in] */ unsigned long ulData);


void __RPC_STUB IHeaderCollection_AddLong_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IHeaderCollection_AddByte_Proxy( 
    IHeaderCollection * This,
    /* [in] */ byte Id,
    /* [in] */ byte pData);


void __RPC_STUB IHeaderCollection_AddByte_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IHeaderCollection_AddUnicodeString_Proxy( 
    IHeaderCollection * This,
    /* [in] */ byte Id,
    /* [in] */ LPCWSTR pszData);


void __RPC_STUB IHeaderCollection_AddUnicodeString_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IHeaderCollection_Remove_Proxy( 
    IHeaderCollection * This,
    /* [in] */ byte Id);


void __RPC_STUB IHeaderCollection_Remove_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IHeaderCollection_RemoveAll_Proxy( 
    IHeaderCollection * This);


void __RPC_STUB IHeaderCollection_RemoveAll_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IHeaderCollection_AddCount_Proxy( 
    IHeaderCollection * This,
    /* [in] */ unsigned long ulCount);


void __RPC_STUB IHeaderCollection_AddCount_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IHeaderCollection_AddName_Proxy( 
    IHeaderCollection * This,
    /* [in] */ LPCWSTR pszName);


void __RPC_STUB IHeaderCollection_AddName_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IHeaderCollection_AddType_Proxy( 
    IHeaderCollection * This,
    /* [in] */ unsigned long ulSize,
    /* [size_is][in] */ byte *pData);


void __RPC_STUB IHeaderCollection_AddType_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IHeaderCollection_AddLength_Proxy( 
    IHeaderCollection * This,
    /* [in] */ unsigned long ulLength);


void __RPC_STUB IHeaderCollection_AddLength_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IHeaderCollection_AddTimeOld_Proxy( 
    IHeaderCollection * This,
    /* [in] */ unsigned long ulTime);


void __RPC_STUB IHeaderCollection_AddTimeOld_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IHeaderCollection_AddTime_Proxy( 
    IHeaderCollection * This,
    /* [in] */ FILETIME *pFiletime);


void __RPC_STUB IHeaderCollection_AddTime_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IHeaderCollection_AddDescription_Proxy( 
    IHeaderCollection * This,
    /* [in] */ LPCWSTR pszDescription);


void __RPC_STUB IHeaderCollection_AddDescription_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IHeaderCollection_AddTarget_Proxy( 
    IHeaderCollection * This,
    /* [in] */ unsigned long ulSize,
    /* [size_is][in] */ byte *pData);


void __RPC_STUB IHeaderCollection_AddTarget_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IHeaderCollection_AddHTTP_Proxy( 
    IHeaderCollection * This,
    /* [in] */ unsigned long ulSize,
    /* [size_is][in] */ byte *pData);


void __RPC_STUB IHeaderCollection_AddHTTP_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IHeaderCollection_AddBody_Proxy( 
    IHeaderCollection * This,
    /* [in] */ unsigned long ulSize,
    /* [size_is][in] */ byte *pData);


void __RPC_STUB IHeaderCollection_AddBody_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IHeaderCollection_AddEndOfBody_Proxy( 
    IHeaderCollection * This,
    /* [in] */ unsigned long ulSize,
    /* [size_is][in] */ byte *pData);


void __RPC_STUB IHeaderCollection_AddEndOfBody_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IHeaderCollection_AddWho_Proxy( 
    IHeaderCollection * This,
    /* [in] */ unsigned long ulSize,
    /* [size_is][in] */ byte *pData);


void __RPC_STUB IHeaderCollection_AddWho_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IHeaderCollection_AddConnectionId_Proxy( 
    IHeaderCollection * This,
    /* [in] */ unsigned long ulConnectionId);


void __RPC_STUB IHeaderCollection_AddConnectionId_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IHeaderCollection_AddAppParams_Proxy( 
    IHeaderCollection * This,
    /* [in] */ unsigned long ulSize,
    /* [size_is][in] */ byte *pData);


void __RPC_STUB IHeaderCollection_AddAppParams_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IHeaderCollection_AddObjectClass_Proxy( 
    IHeaderCollection * This,
    /* [in] */ unsigned long ulSize,
    /* [size_is][in] */ byte *pData);


void __RPC_STUB IHeaderCollection_AddObjectClass_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IHeaderCollection_EnumHeaders_Proxy( 
    IHeaderCollection * This,
    /* [out] */ IHeaderEnum **pHeaderEnum);


void __RPC_STUB IHeaderCollection_EnumHeaders_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IHeaderCollection_INTERFACE_DEFINED__ */


#ifndef __IObexSink_INTERFACE_DEFINED__
#define __IObexSink_INTERFACE_DEFINED__

/* interface IObexSink */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IObexSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("80DFC5AB-BF07-4612-BACE-AEBC0129590A")
    IObexSink : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Notify( 
            /* [in] */ OBEX_EVENT Event,
            /* [in] */ IUnknown *pUnk1,
            /* [in] */ IUnknown *pUnk2) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IObexSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IObexSink * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IObexSink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IObexSink * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Notify )( 
            IObexSink * This,
            /* [in] */ OBEX_EVENT Event,
            /* [in] */ IUnknown *pUnk1,
            /* [in] */ IUnknown *pUnk2);
        
        END_INTERFACE
    } IObexSinkVtbl;

    interface IObexSink
    {
        CONST_VTBL struct IObexSinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IObexSink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IObexSink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IObexSink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IObexSink_Notify(This,Event,pUnk1,pUnk2)	\
    (This)->lpVtbl -> Notify(This,Event,pUnk1,pUnk2)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IObexSink_Notify_Proxy( 
    IObexSink * This,
    /* [in] */ OBEX_EVENT Event,
    /* [in] */ IUnknown *pUnk1,
    /* [in] */ IUnknown *pUnk2);


void __RPC_STUB IObexSink_Notify_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IObexSink_INTERFACE_DEFINED__ */


#ifndef __IObexService_INTERFACE_DEFINED__
#define __IObexService_INTERFACE_DEFINED__

/* interface IObexService */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IObexService;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("9B00990A-010D-4F19-AE6C-D60DA9B3783E")
    IObexService : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetConnection( 
            /* [out] */ IObexServiceConnection **ppConnection,
            /* [in] */ boolean fWait) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Close( void) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SetPassword( 
            /* [in] */ LPCWSTR pszPassword) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IObexServiceVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IObexService * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IObexService * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IObexService * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetConnection )( 
            IObexService * This,
            /* [out] */ IObexServiceConnection **ppConnection,
            /* [in] */ boolean fWait);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Close )( 
            IObexService * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SetPassword )( 
            IObexService * This,
            /* [in] */ LPCWSTR pszPassword);
        
        END_INTERFACE
    } IObexServiceVtbl;

    interface IObexService
    {
        CONST_VTBL struct IObexServiceVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IObexService_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IObexService_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IObexService_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IObexService_GetConnection(This,ppConnection,fWait)	\
    (This)->lpVtbl -> GetConnection(This,ppConnection,fWait)

#define IObexService_Close(This)	\
    (This)->lpVtbl -> Close(This)

#define IObexService_SetPassword(This,pszPassword)	\
    (This)->lpVtbl -> SetPassword(This,pszPassword)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IObexService_GetConnection_Proxy( 
    IObexService * This,
    /* [out] */ IObexServiceConnection **ppConnection,
    /* [in] */ boolean fWait);


void __RPC_STUB IObexService_GetConnection_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IObexService_Close_Proxy( 
    IObexService * This);


void __RPC_STUB IObexService_Close_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IObexService_SetPassword_Proxy( 
    IObexService * This,
    /* [in] */ LPCWSTR pszPassword);


void __RPC_STUB IObexService_SetPassword_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IObexService_INTERFACE_DEFINED__ */


#ifndef __IObexServiceConnection_INTERFACE_DEFINED__
#define __IObexServiceConnection_INTERFACE_DEFINED__

/* interface IObexServiceConnection */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IObexServiceConnection;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("CB258BBB-678B-414A-81A3-CB98B669EDD7")
    IObexServiceConnection : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Accept( 
            /* [in] */ IHeaderCollection *pHeaders) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Close( 
            /* [in] */ IHeaderCollection *pExtraHeaders) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE GetCommand( 
            /* [out][in] */ OBEX_REQUEST *pRequest,
            /* [in] */ boolean fWait) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE SendResponse( 
            /* [in] */ DWORD dwResponse,
            /* [in] */ IHeaderCollection *pHeaders) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE EnumProperties( 
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppv) = 0;
        
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE EnumHeaders( 
            /* [out] */ IHeaderEnum **ppEnum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IObexServiceConnectionVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IObexServiceConnection * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IObexServiceConnection * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IObexServiceConnection * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Accept )( 
            IObexServiceConnection * This,
            /* [in] */ IHeaderCollection *pHeaders);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Close )( 
            IObexServiceConnection * This,
            /* [in] */ IHeaderCollection *pExtraHeaders);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *GetCommand )( 
            IObexServiceConnection * This,
            /* [out][in] */ OBEX_REQUEST *pRequest,
            /* [in] */ boolean fWait);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *SendResponse )( 
            IObexServiceConnection * This,
            /* [in] */ DWORD dwResponse,
            /* [in] */ IHeaderCollection *pHeaders);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *EnumProperties )( 
            IObexServiceConnection * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppv);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *EnumHeaders )( 
            IObexServiceConnection * This,
            /* [out] */ IHeaderEnum **ppEnum);
        
        END_INTERFACE
    } IObexServiceConnectionVtbl;

    interface IObexServiceConnection
    {
        CONST_VTBL struct IObexServiceConnectionVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IObexServiceConnection_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IObexServiceConnection_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IObexServiceConnection_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IObexServiceConnection_Accept(This,pHeaders)	\
    (This)->lpVtbl -> Accept(This,pHeaders)

#define IObexServiceConnection_Close(This,pExtraHeaders)	\
    (This)->lpVtbl -> Close(This,pExtraHeaders)

#define IObexServiceConnection_GetCommand(This,pRequest,fWait)	\
    (This)->lpVtbl -> GetCommand(This,pRequest,fWait)

#define IObexServiceConnection_SendResponse(This,dwResponse,pHeaders)	\
    (This)->lpVtbl -> SendResponse(This,dwResponse,pHeaders)

#define IObexServiceConnection_EnumProperties(This,riid,ppv)	\
    (This)->lpVtbl -> EnumProperties(This,riid,ppv)

#define IObexServiceConnection_EnumHeaders(This,ppEnum)	\
    (This)->lpVtbl -> EnumHeaders(This,ppEnum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IObexServiceConnection_Accept_Proxy( 
    IObexServiceConnection * This,
    /* [in] */ IHeaderCollection *pHeaders);


void __RPC_STUB IObexServiceConnection_Accept_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IObexServiceConnection_Close_Proxy( 
    IObexServiceConnection * This,
    /* [in] */ IHeaderCollection *pExtraHeaders);


void __RPC_STUB IObexServiceConnection_Close_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IObexServiceConnection_GetCommand_Proxy( 
    IObexServiceConnection * This,
    /* [out][in] */ OBEX_REQUEST *pRequest,
    /* [in] */ boolean fWait);


void __RPC_STUB IObexServiceConnection_GetCommand_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IObexServiceConnection_SendResponse_Proxy( 
    IObexServiceConnection * This,
    /* [in] */ DWORD dwResponse,
    /* [in] */ IHeaderCollection *pHeaders);


void __RPC_STUB IObexServiceConnection_SendResponse_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IObexServiceConnection_EnumProperties_Proxy( 
    IObexServiceConnection * This,
    /* [in] */ REFIID riid,
    /* [iid_is][out] */ void **ppv);


void __RPC_STUB IObexServiceConnection_EnumProperties_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


/* [helpstring] */ HRESULT STDMETHODCALLTYPE IObexServiceConnection_EnumHeaders_Proxy( 
    IObexServiceConnection * This,
    /* [out] */ IHeaderEnum **ppEnum);


void __RPC_STUB IObexServiceConnection_EnumHeaders_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IObexServiceConnection_INTERFACE_DEFINED__ */


#ifndef __IInboxSink_INTERFACE_DEFINED__
#define __IInboxSink_INTERFACE_DEFINED__

/* interface IInboxSink */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IInboxSink;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5335417D-96D5-4AB4-9EF0-8F29C82232A3")
    IInboxSink : public IUnknown
    {
    public:
        virtual /* [helpstring] */ HRESULT STDMETHODCALLTYPE Notify( 
            /* [in] */ INBOX_EVENT event,
            /* [in] */ LPCWSTR bstrMimeType,
            /* [in] */ IStream *pStream) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IInboxSinkVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IInboxSink * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IInboxSink * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IInboxSink * This);
        
        /* [helpstring] */ HRESULT ( STDMETHODCALLTYPE *Notify )( 
            IInboxSink * This,
            /* [in] */ INBOX_EVENT event,
            /* [in] */ LPCWSTR bstrMimeType,
            /* [in] */ IStream *pStream);
        
        END_INTERFACE
    } IInboxSinkVtbl;

    interface IInboxSink
    {
        CONST_VTBL struct IInboxSinkVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IInboxSink_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IInboxSink_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IInboxSink_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IInboxSink_Notify(This,event,bstrMimeType,pStream)	\
    (This)->lpVtbl -> Notify(This,event,bstrMimeType,pStream)

#endif /* COBJMACROS */


#endif 	/* C style interface */



/* [helpstring] */ HRESULT STDMETHODCALLTYPE IInboxSink_Notify_Proxy( 
    IInboxSink * This,
    /* [in] */ INBOX_EVENT event,
    /* [in] */ LPCWSTR bstrMimeType,
    /* [in] */ IStream *pStream);


void __RPC_STUB IInboxSink_Notify_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IInboxSink_INTERFACE_DEFINED__ */


#ifndef __IHeaderEnum_INTERFACE_DEFINED__
#define __IHeaderEnum_INTERFACE_DEFINED__

/* interface IHeaderEnum */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IHeaderEnum;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("5507423D-0DD6-443D-A3CF-756D8E725C77")
    IHeaderEnum : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ OBEX_HEADER **rgelt,
            /* [unique][out][in] */ ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IHeaderEnum **ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IHeaderEnumVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IHeaderEnum * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IHeaderEnum * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IHeaderEnum * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IHeaderEnum * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ OBEX_HEADER **rgelt,
            /* [unique][out][in] */ ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IHeaderEnum * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IHeaderEnum * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IHeaderEnum * This,
            /* [out] */ IHeaderEnum **ppenum);
        
        END_INTERFACE
    } IHeaderEnumVtbl;

    interface IHeaderEnum
    {
        CONST_VTBL struct IHeaderEnumVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IHeaderEnum_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IHeaderEnum_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IHeaderEnum_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IHeaderEnum_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IHeaderEnum_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IHeaderEnum_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IHeaderEnum_Clone(This,ppenum)	\
    (This)->lpVtbl -> Clone(This,ppenum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IHeaderEnum_Next_Proxy( 
    IHeaderEnum * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ OBEX_HEADER **rgelt,
    /* [unique][out][in] */ ULONG *pceltFetched);


void __RPC_STUB IHeaderEnum_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHeaderEnum_Skip_Proxy( 
    IHeaderEnum * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IHeaderEnum_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHeaderEnum_Reset_Proxy( 
    IHeaderEnum * This);


void __RPC_STUB IHeaderEnum_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IHeaderEnum_Clone_Proxy( 
    IHeaderEnum * This,
    /* [out] */ IHeaderEnum **ppenum);


void __RPC_STUB IHeaderEnum_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IHeaderEnum_INTERFACE_DEFINED__ */


#ifndef __IPropertyBagEnum_INTERFACE_DEFINED__
#define __IPropertyBagEnum_INTERFACE_DEFINED__

/* interface IPropertyBagEnum */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IPropertyBagEnum;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("6194770D-2B61-47DE-8628-33C42E091181")
    IPropertyBagEnum : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ LPPROPERTYBAG2 *rgelt,
            /* [unique][out][in] */ ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IPropertyBagEnum **ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IPropertyBagEnumVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IPropertyBagEnum * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IPropertyBagEnum * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IPropertyBagEnum * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IPropertyBagEnum * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ LPPROPERTYBAG2 *rgelt,
            /* [unique][out][in] */ ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IPropertyBagEnum * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IPropertyBagEnum * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IPropertyBagEnum * This,
            /* [out] */ IPropertyBagEnum **ppenum);
        
        END_INTERFACE
    } IPropertyBagEnumVtbl;

    interface IPropertyBagEnum
    {
        CONST_VTBL struct IPropertyBagEnumVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IPropertyBagEnum_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IPropertyBagEnum_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IPropertyBagEnum_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IPropertyBagEnum_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IPropertyBagEnum_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IPropertyBagEnum_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IPropertyBagEnum_Clone(This,ppenum)	\
    (This)->lpVtbl -> Clone(This,ppenum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IPropertyBagEnum_Next_Proxy( 
    IPropertyBagEnum * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ LPPROPERTYBAG2 *rgelt,
    /* [unique][out][in] */ ULONG *pceltFetched);


void __RPC_STUB IPropertyBagEnum_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPropertyBagEnum_Skip_Proxy( 
    IPropertyBagEnum * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IPropertyBagEnum_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPropertyBagEnum_Reset_Proxy( 
    IPropertyBagEnum * This);


void __RPC_STUB IPropertyBagEnum_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IPropertyBagEnum_Clone_Proxy( 
    IPropertyBagEnum * This,
    /* [out] */ IPropertyBagEnum **ppenum);


void __RPC_STUB IPropertyBagEnum_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IPropertyBagEnum_INTERFACE_DEFINED__ */


#ifndef __IDeviceEnum_INTERFACE_DEFINED__
#define __IDeviceEnum_INTERFACE_DEFINED__

/* interface IDeviceEnum */
/* [unique][helpstring][uuid][object] */ 


EXTERN_C const IID IID_IDeviceEnum;

#if defined(__cplusplus) && !defined(CINTERFACE)
    
    MIDL_INTERFACE("53B5F567-DFE3-46DF-985A-BB993AE1AB00")
    IDeviceEnum : public IUnknown
    {
    public:
        virtual HRESULT STDMETHODCALLTYPE Next( 
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ IObexDevice **rgelt,
            /* [unique][out][in] */ ULONG *pceltFetched) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Skip( 
            /* [in] */ ULONG celt) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Reset( void) = 0;
        
        virtual HRESULT STDMETHODCALLTYPE Clone( 
            /* [out] */ IDeviceEnum **ppenum) = 0;
        
    };
    
#else 	/* C style interface */

    typedef struct IDeviceEnumVtbl
    {
        BEGIN_INTERFACE
        
        HRESULT ( STDMETHODCALLTYPE *QueryInterface )( 
            IDeviceEnum * This,
            /* [in] */ REFIID riid,
            /* [iid_is][out] */ void **ppvObject);
        
        ULONG ( STDMETHODCALLTYPE *AddRef )( 
            IDeviceEnum * This);
        
        ULONG ( STDMETHODCALLTYPE *Release )( 
            IDeviceEnum * This);
        
        HRESULT ( STDMETHODCALLTYPE *Next )( 
            IDeviceEnum * This,
            /* [in] */ ULONG celt,
            /* [length_is][size_is][out] */ IObexDevice **rgelt,
            /* [unique][out][in] */ ULONG *pceltFetched);
        
        HRESULT ( STDMETHODCALLTYPE *Skip )( 
            IDeviceEnum * This,
            /* [in] */ ULONG celt);
        
        HRESULT ( STDMETHODCALLTYPE *Reset )( 
            IDeviceEnum * This);
        
        HRESULT ( STDMETHODCALLTYPE *Clone )( 
            IDeviceEnum * This,
            /* [out] */ IDeviceEnum **ppenum);
        
        END_INTERFACE
    } IDeviceEnumVtbl;

    interface IDeviceEnum
    {
        CONST_VTBL struct IDeviceEnumVtbl *lpVtbl;
    };

    

#ifdef COBJMACROS


#define IDeviceEnum_QueryInterface(This,riid,ppvObject)	\
    (This)->lpVtbl -> QueryInterface(This,riid,ppvObject)

#define IDeviceEnum_AddRef(This)	\
    (This)->lpVtbl -> AddRef(This)

#define IDeviceEnum_Release(This)	\
    (This)->lpVtbl -> Release(This)


#define IDeviceEnum_Next(This,celt,rgelt,pceltFetched)	\
    (This)->lpVtbl -> Next(This,celt,rgelt,pceltFetched)

#define IDeviceEnum_Skip(This,celt)	\
    (This)->lpVtbl -> Skip(This,celt)

#define IDeviceEnum_Reset(This)	\
    (This)->lpVtbl -> Reset(This)

#define IDeviceEnum_Clone(This,ppenum)	\
    (This)->lpVtbl -> Clone(This,ppenum)

#endif /* COBJMACROS */


#endif 	/* C style interface */



HRESULT STDMETHODCALLTYPE IDeviceEnum_Next_Proxy( 
    IDeviceEnum * This,
    /* [in] */ ULONG celt,
    /* [length_is][size_is][out] */ IObexDevice **rgelt,
    /* [unique][out][in] */ ULONG *pceltFetched);


void __RPC_STUB IDeviceEnum_Next_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDeviceEnum_Skip_Proxy( 
    IDeviceEnum * This,
    /* [in] */ ULONG celt);


void __RPC_STUB IDeviceEnum_Skip_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDeviceEnum_Reset_Proxy( 
    IDeviceEnum * This);


void __RPC_STUB IDeviceEnum_Reset_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);


HRESULT STDMETHODCALLTYPE IDeviceEnum_Clone_Proxy( 
    IDeviceEnum * This,
    /* [out] */ IDeviceEnum **ppenum);


void __RPC_STUB IDeviceEnum_Clone_Stub(
    IRpcStubBuffer *This,
    IRpcChannelBuffer *_pRpcChannelBuffer,
    PRPC_MESSAGE _pRpcMessage,
    DWORD *_pdwStubPhase);



#endif 	/* __IDeviceEnum_INTERFACE_DEFINED__ */



#ifndef __OBEXLib_LIBRARY_DEFINED__
#define __OBEXLib_LIBRARY_DEFINED__

/* library OBEXLib */
/* [helpstring][version][uuid] */ 


EXTERN_C const IID LIBID_OBEXLib;

EXTERN_C const CLSID CLSID_Obex;

#ifdef __cplusplus

class DECLSPEC_UUID("30a7bc00-59b6-40bb-aa2b-89eb49ef274e")
Obex;
#endif

EXTERN_C const CLSID CLSID_HeaderCollection;

#ifdef __cplusplus

class DECLSPEC_UUID("30a7bc01-59b6-40bb-aa2b-89eb49ef274e")
HeaderCollection;
#endif

EXTERN_C const CLSID CLSID_PropertyBag;

#ifdef __cplusplus

class DECLSPEC_UUID("30a7bc05-59b6-40bb-aa2b-89eb49ef274e")
PropertyBag;
#endif

EXTERN_C const CLSID CLSID_IrdaTransport;

#ifdef __cplusplus

class DECLSPEC_UUID("30A7BC02-59B6-40BB-AA2B-89EB49EF274E")
IrdaTransport;
#endif

EXTERN_C const CLSID CLSID_BthTransport;

#ifdef __cplusplus

class DECLSPEC_UUID("30A7BC03-59B6-40BB-AA2B-89EB49EF274E")
BthTransport;
#endif

EXTERN_C const CLSID CLSID_IpTransport;

#ifdef __cplusplus

class DECLSPEC_UUID("30A7BC04-59B6-40BB-AA2B-89EB49EF274E")
IpTransport;
#endif
#endif /* __OBEXLib_LIBRARY_DEFINED__ */

/* Additional Prototypes for ALL interfaces */

/* end of Additional Prototypes */

#ifdef __cplusplus
}
#endif

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\nswalk.cpp ===
#include "shellprv.h"
#include "dpa.h"
#include "datautil.h"

typedef enum
{
    NSWALK_DONTWALK,
    NSWALK_FOLDER,
    NSWALK_ITEM,
    NSWALK_LINK
} NSWALK_ELEMENT_TYPE;

class CNamespaceWalk : public INamespaceWalk
{
public:
    CNamespaceWalk();

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // INamespaceWalk
    STDMETHODIMP Walk(IUnknown *punkToWalk, DWORD dwFlags, int cDepth, INamespaceWalkCB *pnswcb);
    STDMETHODIMP GetIDArrayResult(UINT *pcItems, LPITEMIDLIST **pppidl);

private:
    ~CNamespaceWalk();

    static int CALLBACK _FreeItems(LPITEMIDLIST pidl, IShellFolder *psf);
    static int CALLBACK _CompareItems(LPITEMIDLIST p1, LPITEMIDLIST p2, IShellFolder *psf);
    HRESULT _EnsureDPA();
    HRESULT _AddItem(IShellFolder *psf, LPCITEMIDLIST pidl);
    HRESULT _AppendFull(LPCITEMIDLIST pidlFull);
    HRESULT _EnumFolder(IShellFolder *psf, LPCITEMIDLIST pidlFirst, CDPA<UNALIGNED ITEMIDLIST> *pdpaItems);
    HRESULT _GetShortcutTarget(IShellFolder *psf, LPCITEMIDLIST pidl, LPITEMIDLIST *ppidlTarget);
    BOOL _IsFolderTarget(IShellFolder *psf, LPCITEMIDLIST pidl);
    HRESULT _WalkView(IFolderView *pfv);
    HRESULT _WalkFolder(IShellFolder *psf, LPCITEMIDLIST pidlFirst, int cDepth);
    HRESULT _WalkDataObject(IDataObject *pdtobj);
    HRESULT _WalkParentAndItem(IParentAndItem *ppai);
    HRESULT _WalkIDList(IShellFolder *psfRoot, LPCITEMIDLIST pidl, int cDepth, int cFolderDepthDelta);
    HRESULT _WalkFolderItem(IShellFolder *psf, LPCITEMIDLIST pidl, int cDepth);
    HRESULT _WalkShortcut(IShellFolder *psf, LPCITEMIDLIST pidl, int cDepth, int cFolderDepthDelta);

    NSWALK_ELEMENT_TYPE _GetType(IShellFolder *psf, LPCITEMIDLIST pidl);
    BOOL _OneImpliesAll(IShellFolder *psf, LPCITEMIDLIST pidl);

    HRESULT _ProgressDialogQueryCancel();
    void _ProgressDialogBegin();
    void _ProgressDialogUpdate(LPCWSTR pszText);
    void _ProgressDialogEnd();

    LONG _cRef;
    DWORD _dwFlags;
    int _cDepthMax;
    INamespaceWalkCB *_pnswcb;
    IActionProgressDialog *_papd;
    IActionProgress *_pap;
#ifdef DEBUG
    TCHAR _szLastFolder[MAX_PATH];   // to track what we failed on
#endif
    CDPA<UNALIGNED ITEMIDLIST> _dpaItems;
};


STDAPI CNamespaceWalk_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv)
{
    CNamespaceWalk *pnsw = new CNamespaceWalk();
    if (!pnsw)
        return E_OUTOFMEMORY;

    HRESULT hr = pnsw->QueryInterface(riid, ppv);
    pnsw->Release();
    return hr;
}

CNamespaceWalk::CNamespaceWalk() : _cRef(1)
{
    _papd = NULL;
    _pap = NULL;
}

CNamespaceWalk::~CNamespaceWalk()
{
    ASSERT(!_papd);
    ASSERT(!_pap);

    if ((HDPA)_dpaItems)
        _dpaItems.DestroyCallbackEx(_FreeItems, (IShellFolder *)NULL);
}

STDMETHODIMP_(ULONG) CNamespaceWalk::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CNamespaceWalk::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}

HRESULT CNamespaceWalk::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = 
    {
        QITABENT(CNamespaceWalk, INamespaceWalk),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

int CALLBACK CNamespaceWalk::_FreeItems(LPITEMIDLIST pidl, IShellFolder *psf)
{
    ILFree(pidl);
    return 1;
}

HRESULT CNamespaceWalk::_EnsureDPA()
{
    return (HDPA)_dpaItems ? S_OK : (_dpaItems.Create(10) ? S_OK : E_OUTOFMEMORY);
}

// consumes pidl in all cases (success and failure)

HRESULT CNamespaceWalk::_AppendFull(LPCITEMIDLIST pidlFull)
{
    HRESULT hr = _ProgressDialogQueryCancel(); // ERROR_CANCELLED -> cancelled

    if (SUCCEEDED(hr))
    {
        if (NSWF_DONT_ACCUMULATE_RESULT & _dwFlags)
        {
            hr = S_OK;
        }
        else
        {
            hr = _EnsureDPA();
            if (SUCCEEDED(hr))
            {
                LPITEMIDLIST pidlClone;
                hr = SHILClone(pidlFull, &pidlClone);
                if (SUCCEEDED(hr) && (-1 == _dpaItems.AppendPtr(pidlClone)))
                {
                    hr = E_OUTOFMEMORY;
                    ILFree(pidlClone);
                }
            }
        }
    }

    return hr;
}

HRESULT CNamespaceWalk::_AddItem(IShellFolder *psf, LPCITEMIDLIST pidl)
{
    HRESULT hr = S_OK;
    LPITEMIDLIST pidlFull = NULL;
    
    if (!(NSWF_DONT_ACCUMULATE_RESULT & _dwFlags))
    {
        hr = SUCCEEDED(SHFullIDListFromFolderAndItem(psf, pidl, &pidlFull)) ? S_OK : S_FALSE;//couldn't get the pidl?  Just skip the item
    }

    if (S_OK == hr)
    {
        hr = _pnswcb ? _pnswcb->FoundItem(psf, pidl) : S_OK;
        if (S_OK == hr)
        {
            hr = _AppendFull(pidlFull);
        }
        ILFree(pidlFull);
    }
    return SUCCEEDED(hr) ? S_OK : hr;   // filter out S_FALSE success cases
}

int CALLBACK CNamespaceWalk::_CompareItems(LPITEMIDLIST p1, LPITEMIDLIST p2, IShellFolder *psf)
{
    HRESULT hr = psf->CompareIDs(0, p1, p2);
    return (short)HRESULT_CODE(hr);
}

HRESULT CNamespaceWalk::_EnumFolder(IShellFolder *psf, LPCITEMIDLIST pidlFirst, CDPA<UNALIGNED ITEMIDLIST> *pdpaItems)
{
    CDPA<UNALIGNED ITEMIDLIST> dpaItems;
    HRESULT hr = dpaItems.Create(16) ? S_OK : E_OUTOFMEMORY;
    if (SUCCEEDED(hr))
    {
        IEnumIDList *penum;
        if (S_OK == psf->EnumObjects(NULL, SHCONTF_NONFOLDERS | SHCONTF_FOLDERS, &penum))
        {
            LPITEMIDLIST pidl;
            ULONG c;
            while (SUCCEEDED(hr) && (S_OK == penum->Next(1, &pidl, &c)))
            {
                if (-1 == dpaItems.AppendPtr(pidl))
                {
                    ILFree(pidl);
                    hr = E_OUTOFMEMORY;
                }
                else
                {
                    hr = _ProgressDialogQueryCancel();
                }
            }
            penum->Release();
        }

        if (SUCCEEDED(hr))
        {
            dpaItems.SortEx(_CompareItems, psf);

            if (pidlFirst && !(NSWF_FLAG_VIEWORDER & _dwFlags))
            {
                // rotate the items array so pidlFirst is first in the list
                // cast for bogus SearchEx decl
                int iMid = dpaItems.SearchEx((LPITEMIDLIST)pidlFirst, 0, _CompareItems, psf, DPAS_SORTED);
                if (-1 != iMid)
                {
                    int cItems = dpaItems.GetPtrCount();
                    CDPA<UNALIGNED ITEMIDLIST> dpaTemp;
                    if (dpaTemp.Create(cItems))
                    {
                        for (int i = 0; i < cItems; i++)
                        {
                            dpaTemp.SetPtr(i, dpaItems.GetPtr(iMid++));
                            if (iMid >= cItems)
                                iMid = 0;
                        }

                        for (int i = 0; i < cItems; i++)
                        {
                            dpaItems.SetPtr(i, dpaTemp.GetPtr(i));
                        }
                        dpaTemp.Destroy();    // don't free the pidls, just the array
                    }
                }
                else
                {
                    // pidlFirst not found in the enum, it might be hidden or filters
                    // out some way, but make sure this always ends up in the dpa in this case
                    LPITEMIDLIST pidlClone = ILClone(pidlFirst);
                    if (pidlClone)
                    {
                        dpaItems.InsertPtr(0, pidlClone);
                    }
                }
            }
        }
    }

    if (FAILED(hr))
    {
        dpaItems.DestroyCallbackEx(_FreeItems, psf);
        dpaItems = NULL;
    }

    *pdpaItems = dpaItems;
    return hr;
}

NSWALK_ELEMENT_TYPE CNamespaceWalk::_GetType(IShellFolder *psf, LPCITEMIDLIST pidl)
{
    NSWALK_ELEMENT_TYPE nwet = NSWALK_DONTWALK;

    DWORD dwAttribs = SHGetAttributes(psf, pidl, SFGAO_FOLDER | SFGAO_STREAM | SFGAO_FILESYSTEM | SFGAO_LINK);
    if ((dwAttribs & SFGAO_FOLDER) && (!(dwAttribs & SFGAO_STREAM) || (NSWF_TRAVERSE_STREAM_JUNCTIONS & _dwFlags)))
    {
        nwet = NSWALK_FOLDER;
    }
    else if ((dwAttribs & SFGAO_LINK) && !(NSWF_DONT_TRAVERSE_LINKS & _dwFlags))
    {
        nwet = NSWALK_LINK;
    }
    else if ((dwAttribs & SFGAO_FILESYSTEM) || !(NSWF_FILESYSTEM_ONLY & _dwFlags))
    {
        nwet = NSWALK_ITEM;
    }
    return nwet;
}

HRESULT CNamespaceWalk::_WalkIDList(IShellFolder *psfRoot, LPCITEMIDLIST pidl, int cDepth, int cFolderDepthDelta)
{
    IShellFolder *psf;
    LPCITEMIDLIST pidlLast;
    HRESULT hr = SHBindToFolderIDListParent(psfRoot, pidl, IID_PPV_ARG(IShellFolder, &psf), &pidlLast);
    if (SUCCEEDED(hr))
    {
        switch (_GetType(psf, pidlLast))
        {
        case NSWALK_FOLDER:
            hr = _WalkFolderItem(psf, pidlLast, cDepth + cFolderDepthDelta);
            break;

        case NSWALK_LINK:
            hr = _WalkShortcut(psf, pidlLast, cDepth, cFolderDepthDelta);
            break;

        case NSWALK_ITEM:
            hr = _AddItem(psf, pidlLast);
            break;
        }
        psf->Release();
    }
    return hr;
}

HRESULT CNamespaceWalk::_WalkShortcut(IShellFolder *psf, LPCITEMIDLIST pidl, int cDepth, int cFolderDepthDelta)
{
    HRESULT hr = S_OK;
    
    // If an error occured trying to resolve a shortcut then we simply skip
    // this shortcut and continue

    LPITEMIDLIST pidlTarget;
    if (SUCCEEDED(_GetShortcutTarget(psf, pidl, &pidlTarget)))
    {
        hr = _WalkIDList(NULL, pidlTarget, cDepth, cFolderDepthDelta);
        ILFree(pidlTarget);
    }

    return hr;
}

HRESULT CNamespaceWalk::_GetShortcutTarget(IShellFolder *psf, LPCITEMIDLIST pidl, LPITEMIDLIST *ppidlTarget)
{
    *ppidlTarget = NULL;

    IShellLink *psl;
    if (SUCCEEDED(psf->GetUIObjectOf(NULL, 1, (LPCITEMIDLIST *)&pidl, IID_PPV_ARG_NULL(IShellLink, &psl))))
    {
        if (S_OK == psl->Resolve(NULL, SLR_UPDATE | SLR_NO_UI))
        {
            psl->GetIDList(ppidlTarget);
        }
        psl->Release();
    }

    return *ppidlTarget ? S_OK : E_FAIL;
}

HRESULT CNamespaceWalk::_WalkFolder(IShellFolder *psf, LPCITEMIDLIST pidlFirst, int cDepth)
{
    if (cDepth > _cDepthMax)
        return S_OK;     // done

    CDPA<UNALIGNED ITEMIDLIST> dpaItems;
    HRESULT hr = _EnumFolder(psf, pidlFirst, &dpaItems);
    if (SUCCEEDED(hr))
    {
        UINT cFolders = 0;
        // breadth first traversal, so do the items (non folders) first
        // (this includes shortcuts and those can point to folders)

        for (int i = 0; (S_OK == hr) && (i < dpaItems.GetPtrCount()); i++)
        {
            switch (_GetType(psf, dpaItems.GetPtr(i)))
            {
            case NSWALK_FOLDER:
                cFolders++;
                break;

            case NSWALK_LINK:
                hr = _WalkShortcut(psf, dpaItems.GetPtr(i), cDepth, 1);
                break;

            case NSWALK_ITEM:
                hr = _AddItem(psf, dpaItems.GetPtr(i));
                break;
            }
        }

        // no go deep into the folders

        if (cFolders)
        {
            for (int i = 0; (S_OK == hr) && (i < dpaItems.GetPtrCount()); i++)
            {
                if (NSWALK_FOLDER == _GetType(psf, dpaItems.GetPtr(i)))
                {
                    hr = _WalkFolderItem(psf, dpaItems.GetPtr(i), cDepth + 1);
                }
            }
        }
        dpaItems.DestroyCallbackEx(_FreeItems, psf);
    }
    return hr;
}

HRESULT CNamespaceWalk::_WalkFolderItem(IShellFolder *psf, LPCITEMIDLIST pidl, int cDepth)
{
    IShellFolder *psfNew;
    HRESULT hr = psf->BindToObject(pidl, NULL, IID_PPV_ARG(IShellFolder, &psfNew));
    if (SUCCEEDED(hr))
    {
#ifdef DEBUG
        DisplayNameOf(psf, pidl, SHGDN_FORPARSING, _szLastFolder, ARRAYSIZE(_szLastFolder));
#endif
        hr = _pnswcb ? _pnswcb->EnterFolder(psf, pidl) : S_OK;
        if (S_OK == hr)
        {
            // Update progress dialog;  note we only update the progress dialog
            // with the folder names we're currently traversing.  Updating on a
            // per filename basis just caused far too much flicker, looked bad.
            if (NSWF_SHOW_PROGRESS & _dwFlags)
            {
                WCHAR sz[MAX_PATH];
                if (SUCCEEDED(DisplayNameOf(psf, pidl, SHGDN_NORMAL, sz, ARRAYSIZE(sz))))
                    _ProgressDialogUpdate(sz);

                hr = _ProgressDialogQueryCancel(); // ERROR_CANCELLED -> cancelled
            }

            if (SUCCEEDED(hr))
            {
                hr = _WalkFolder(psfNew, NULL, cDepth);
                if (_pnswcb)
                    _pnswcb->LeaveFolder(psf, pidl);             // ignore result
            }
        }
        hr = SUCCEEDED(hr) ? S_OK : hr; // filter out S_FALSE success cases
        psfNew->Release();
    }
    return hr;
}

BOOL CNamespaceWalk::_IsFolderTarget(IShellFolder *psf, LPCITEMIDLIST pidl)
{
    BOOL bIsFolder = FALSE;

    LPITEMIDLIST pidlTarget;
    if (SUCCEEDED(_GetShortcutTarget(psf, pidl, &pidlTarget)))
    {
        bIsFolder = SHGetAttributes(NULL, pidlTarget, SFGAO_FOLDER);
        ILFree(pidlTarget);
    }
    return bIsFolder;
}

// NSWF_ONE_IMPLIES_ALL applies only when the "one" is not a folder
// and if it is a shortcut if the target of the shortcut is a file

BOOL CNamespaceWalk::_OneImpliesAll(IShellFolder *psf, LPCITEMIDLIST pidl)
{
    BOOL bOneImpliesAll = FALSE;

    if (NSWF_ONE_IMPLIES_ALL & _dwFlags)
    {
        switch (_GetType(psf, pidl))
        {
        case NSWALK_LINK:
            if (!_IsFolderTarget(psf, pidl))
            {
                bOneImpliesAll = TRUE;  // shortcut to non folder, one-implies-all applies
            }
            break;

        case NSWALK_ITEM:
            bOneImpliesAll = TRUE;      // non folder
            break;
        }
    }
    return bOneImpliesAll;
}

// walk an IShellFolderView implementation. this is usually defview (only such impl now)
// the depth beings at level 0 here

HRESULT CNamespaceWalk::_WalkView(IFolderView *pfv)
{
    IShellFolder2 *psf;
    HRESULT hr = pfv->GetFolder(IID_PPV_ARG(IShellFolder2, &psf));
    if (SUCCEEDED(hr))
    {
        int uSelectedCount;
        hr = pfv->ItemCount(SVGIO_SELECTION, &uSelectedCount);
        if (SUCCEEDED(hr))
        {
            // folders explictly selected in the view are level 0
            // folders implictly selected are level 1
            UINT cFolderStartDepth = 0; // assume all folders explictly selected

            IEnumIDList *penum;
            // prop the NSWF_ flags to the IFolderView SVGIO_ flags
            UINT uFlags = (NSWF_FLAG_VIEWORDER & _dwFlags) ? SVGIO_FLAG_VIEWORDER : 0;

            if (uSelectedCount > 1)
            {
                hr = pfv->Items(SVGIO_SELECTION | uFlags, IID_PPV_ARG(IEnumIDList, &penum));
            }
            else if (uSelectedCount == 1)
            {
                hr = pfv->Items(SVGIO_SELECTION, IID_PPV_ARG(IEnumIDList, &penum));
                if (SUCCEEDED(hr))
                {
                    LPITEMIDLIST pidl;
                    ULONG c;
                    if (S_OK == penum->Next(1, &pidl, &c))
                    {
                        if (_OneImpliesAll(psf, pidl))
                        {
                            // this implies pidl is not a folder so folders are implictly selected
                            // consider them depth 1
                            cFolderStartDepth = 1;  

                            // one implies all -> release the "one" and grab "all"
                            penum->Release();   
                            hr = pfv->Items(SVGIO_ALLVIEW, IID_PPV_ARG(IEnumIDList, &penum));
                        }
                        else
                        {
                            // folder selected, keep this enumerator for below loop
                            penum->Reset();
                        }
                        ILFree(pidl);
                    }
                }
            }
            else if (uSelectedCount == 0)
            {
                // folders implictly selected, consider them depth 1
                cFolderStartDepth = 1;  

                // get "all" or the selection. in the selection case we know that will be empty
                // given uSelectedCount == 0
                uFlags |= ((NSWF_NONE_IMPLIES_ALL & _dwFlags) ? SVGIO_ALLVIEW : SVGIO_SELECTION);
                hr = pfv->Items(uFlags, IID_PPV_ARG(IEnumIDList, &penum));
            }

            if (SUCCEEDED(hr))
            {
                UINT cFolders = 0;
                LPITEMIDLIST pidl;
                ULONG c;

                while ((S_OK == hr) && (S_OK == penum->Next(1, &pidl, &c)))
                {
                    switch (_GetType(psf, pidl))
                    {
                    case NSWALK_FOLDER:
                        cFolders++;
                        break;

                    case NSWALK_LINK:
                        hr = _WalkShortcut(psf, pidl, 0, cFolderStartDepth);
                        break;

                    case NSWALK_ITEM:
                        hr = _AddItem(psf, pidl);
                        break;
                    }
                    ILFree(pidl);
                }

                if (cFolders)
                {
                    penum->Reset();
                    ULONG c;
                    while ((S_OK == hr) && (S_OK == penum->Next(1, &pidl, &c)))
                    {
                        if (NSWALK_FOLDER == _GetType(psf, pidl))
                        {
                            hr = _WalkFolderItem(psf, pidl, cFolderStartDepth); 
                        }
                        ILFree(pidl);
                    }
                }
                penum->Release();
            }
        }
        psf->Release();
    }
    return hr;
}

HRESULT _GetHIDA(IDataObject *pdtobj, BOOL fIgnoreAutoPlay, STGMEDIUM *pmed, LPIDA *ppida)
{
    HRESULT hr = E_FAIL;
    if (!fIgnoreAutoPlay)
    {
        IDLData_InitializeClipboardFormats(); // init our registerd formats
        *ppida = DataObj_GetHIDAEx(pdtobj, g_cfAutoPlayHIDA, pmed);
        hr = *ppida ? S_FALSE : E_FAIL;
    }
    
    if (FAILED(hr))
    {   
        *ppida = DataObj_GetHIDA(pdtobj, pmed);
        hr = *ppida ? S_OK : E_FAIL;
    }
    return hr;
}

HRESULT CNamespaceWalk::_WalkDataObject(IDataObject *pdtobj)
{
    STGMEDIUM medium = {0};
    LPIDA pida;
    HRESULT hr = _GetHIDA(pdtobj, NSWF_IGNORE_AUTOPLAY_HIDA & _dwFlags, &medium, &pida);
    if (SUCCEEDED(hr))
    {
        //  if we picked up the autoplay hida, then we dont want 
        //  to do a full traversal
        if (hr == S_FALSE)
            _cDepthMax = 0;
        
        IShellFolder *psfRoot;
        hr = SHBindToObjectEx(NULL, HIDA_GetPIDLFolder(pida), NULL, IID_PPV_ARG(IShellFolder, &psfRoot));
        if (SUCCEEDED(hr))
        {
            BOOL cFolders = 0;

            // pass 1, non folders and shortcuts
            for (UINT i = 0; (S_OK == hr) && (i < pida->cidl); i++)
            {
                IShellFolder *psf;
                LPCITEMIDLIST pidlLast;
                hr = SHBindToFolderIDListParent(psfRoot, IDA_GetIDListPtr(pida, i), IID_PPV_ARG(IShellFolder, &psf), &pidlLast);
                if (SUCCEEDED(hr))
                {
                    if ((pida->cidl == 1) && _OneImpliesAll(psf, pidlLast))
                    {
                        // when doing one implies all ignore the view order
                        // flag as that should only apply to explictly selected items
                        _dwFlags &= ~NSWF_FLAG_VIEWORDER;

                        hr = _WalkFolder(psf, pidlLast, 0);
                    }
                    else
                    {
                        switch (_GetType(psf, pidlLast))
                        {
                        case NSWALK_FOLDER:
                            cFolders++;
                            break;

                        case NSWALK_LINK:
                            hr = _WalkShortcut(psf, pidlLast, 0, 0);
                            break;

                        case NSWALK_ITEM:
                            hr = _AddItem(psf, pidlLast);
                            break;
                        }
                    }
                    psf->Release();
                }
            }

            if (cFolders)
            {
                // pass 2, recurse into folders
                for (UINT i = 0; (S_OK == hr) && (i < pida->cidl); i++)
                {
                    IShellFolder *psf;
                    LPCITEMIDLIST pidlLast;
                    hr = SHBindToFolderIDListParent(psfRoot, IDA_GetIDListPtr(pida, i), IID_PPV_ARG(IShellFolder, &psf), &pidlLast);
                    if (SUCCEEDED(hr))
                    {
                        if (NSWALK_FOLDER == _GetType(psf, pidlLast))
                        {
                            if (ILIsEmpty(pidlLast))
                            {
                                // in case of desktop folder we just walk the folder
                                // because empty pidl is not its child, and there can
                                // only be one desktop in the data object so always level 0
                                hr = _WalkFolder(psf, NULL, 0);
                            }
                            else
                            {
                                // all folders that are explictly selected are level 0
                                // in the walk. if the folder is in the data object then it is selected
                                hr = _WalkFolderItem(psf, pidlLast, 0);
                            }
                        }
                        psf->Release();
                    }
                }
            }

            psfRoot->Release();
        }
        HIDA_ReleaseStgMedium(pida, &medium);
    }
    else
    {
        // we have to use CF_HDROP instead of HIDA because this
        // data object comes from AutoPlay and that only supports CF_HDROP
        FORMATETC fmte = {CF_HDROP, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
        hr = pdtobj->GetData(&fmte, &medium);
        if (SUCCEEDED(hr))
        {
            TCHAR szPath[MAX_PATH];
            for (int i = 0; SUCCEEDED(hr) && DragQueryFile((HDROP)medium.hGlobal, i, szPath, ARRAYSIZE(szPath)); i++)
            {
                LPITEMIDLIST pidl;
                hr = SHParseDisplayName(szPath, NULL, &pidl, 0, NULL);
                if (SUCCEEDED(hr))
                {
                    // note, no filter being applied here!
                    hr = _AppendFull(pidl);
                    ILFree(pidl);
                }
            }
            ReleaseStgMedium(&medium);
        }
    }
    return hr;
}

HRESULT CNamespaceWalk::_WalkParentAndItem(IParentAndItem *ppai)
{
    LPITEMIDLIST pidlChild;
    IShellFolder *psf;
    HRESULT hr = ppai->GetParentAndItem(NULL, &psf, &pidlChild);
    if (SUCCEEDED(hr))
    {
        if (_OneImpliesAll(psf, pidlChild))
        {
            // a non folder item, this is level 0 of walk
            hr = _WalkFolder(psf, pidlChild, 0);
        }
        else
        {
            // folder or non folder, this is level 0 of walk
            // and level 0 if the item is a folder
            hr = _WalkIDList(psf, pidlChild, 0, 0);
        }

        psf->Release();
        ILFree(pidlChild);
    }
    return hr;
}

// punkToWalk can be a...
//      site that gives access to IFolderView (defview)
//      IShellFolder
//      IDataObject
//      IParentAndItem (CLSID_ShellItem usually)

STDMETHODIMP CNamespaceWalk::Walk(IUnknown *punkToWalk, DWORD dwFlags, int cDepth, INamespaceWalkCB *pnswcb)
{
    _dwFlags = dwFlags;
    _cDepthMax = cDepth;

    if (pnswcb)
        pnswcb->QueryInterface(IID_PPV_ARG(INamespaceWalkCB, &_pnswcb));

    _ProgressDialogBegin();

    IFolderView *pfv;
    HRESULT hr = IUnknown_QueryService(punkToWalk, SID_SFolderView, IID_PPV_ARG(IFolderView, &pfv));
    if (SUCCEEDED(hr))
    {
        hr = _WalkView(pfv);
        pfv->Release();
    }
    else
    {
        IShellFolder *psf;
        hr = punkToWalk->QueryInterface(IID_PPV_ARG(IShellFolder, &psf));
        if (SUCCEEDED(hr))
        {
            hr = _WalkFolder(psf, NULL, 0);
            psf->Release();
        }
        else
        {
            IDataObject *pdtobj;
            hr = punkToWalk->QueryInterface(IID_PPV_ARG(IDataObject, &pdtobj));
            if (SUCCEEDED(hr))
            {
                hr = _WalkDataObject(pdtobj);
                pdtobj->Release();
            }
            else
            {
                // IShellItem case, get to the things to walk via IParentAndItem
                IParentAndItem *ppai;
                hr = punkToWalk->QueryInterface(IID_PPV_ARG(IParentAndItem, &ppai));
                if (SUCCEEDED(hr))
                {
                    hr = _WalkParentAndItem(ppai);
                    ppai->Release();
                }
            }
        }
    }

    _ProgressDialogEnd();

    if (_pnswcb)
        _pnswcb->Release();

    return hr;
}

// caller should use FreeIDListArray() (inline helper in the .h file) to free this array

STDMETHODIMP CNamespaceWalk::GetIDArrayResult(UINT *pcItems, LPITEMIDLIST **pppidl)
{
    HRESULT hr;
    *pppidl = NULL;
    *pcItems = (HDPA)_dpaItems ? _dpaItems.GetPtrCount() : 0;
    if (*pcItems)
    {
        ULONG cb = *pcItems * sizeof(*pppidl);
        *pppidl = (LPITEMIDLIST *)CoTaskMemAlloc(cb);
        if (*pppidl)
        {
            memcpy(*pppidl, _dpaItems.GetPtrPtr(), cb);  // transfer ownership of pidls here
            _dpaItems.Destroy();    // don't free the pidls, just the array
            hr = S_OK;
        }
        else
        {
            hr = E_OUTOFMEMORY;
            *pcItems = 0;
        }
    }
    else
    {
        hr = S_FALSE;
    }
    return hr;
}

void CNamespaceWalk::_ProgressDialogBegin()
{
    ASSERT(!_papd);                         // Why are we initializing more than once???
    ASSERT(!_pap);                          // Why are we initializing more than once???
    if (_dwFlags & NSWF_SHOW_PROGRESS)
    {
        if (!_papd)
        {
            HRESULT hr = CoCreateInstance(CLSID_ProgressDialog, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IActionProgressDialog, &_papd));
            if (SUCCEEDED(hr))
            {
                LPWSTR pszTitle = NULL, pszCancel = NULL;

                // Retrieve dialog text from callback.
                hr = _pnswcb ? _pnswcb->InitializeProgressDialog(&pszTitle, &pszCancel) : S_OK;
                if (SUCCEEDED(hr))
                {
                    hr = _papd->Initialize(SPINITF_MODAL, pszTitle, pszCancel);
                    if (SUCCEEDED(hr))
                    {
                        hr = _papd->QueryInterface(IID_PPV_ARG(IActionProgress, &_pap));
                        if (SUCCEEDED(hr))
                        {
                            hr = _pap->Begin(SPACTION_SEARCHING_FILES, SPBEGINF_MARQUEEPROGRESS);
                            if (FAILED(hr))
                            {
                                ATOMICRELEASE(_pap);    // Cleanup if necessary.
                            }
                        }
                    }
                }
                CoTaskMemFree(pszTitle);
                CoTaskMemFree(pszCancel);

                // Cleanup if necessary.
                if (FAILED(hr))
                {
                    ATOMICRELEASE(_papd);
                }
            }
        }
    }
}

void CNamespaceWalk::_ProgressDialogUpdate(LPCWSTR pszText)
{
    if (_pap)
        _pap->UpdateText(SPTEXT_ACTIONDETAIL, pszText, TRUE);
}

// Note:
//  Returns S_OK if we should continue our walk.
//  Returns ERROR_CANCELLED if we should abort our walk due to user "Cancel".
//
HRESULT CNamespaceWalk::_ProgressDialogQueryCancel()
{
    HRESULT hr = S_OK;  // assume we keep going

    // Check progress dialog to see if user cancelled walk.
    if (_pap)
    {
        BOOL bCancelled;
        hr = _pap->QueryCancel(&bCancelled);
        if (SUCCEEDED(hr) && bCancelled)
            hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);
    }
    return hr;
}

void CNamespaceWalk::_ProgressDialogEnd()
{
    if (_pap)
    {
        _pap->End();
        ATOMICRELEASE(_pap);
    }

    if (_papd)
    {
        _papd->Stop();
        ATOMICRELEASE(_papd);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\openwith.h ===
/*
 * openwith.h -- Open With context menu handler
 */

#ifndef _OPENWITH_H_
#define _OPENWITH_H_

//
// Prototypes for all modules
//
    
STDAPI COpenWithMenu_CreateInstance(IUnknown* pUnkOuter, REFIID riid, OUT LPVOID *  ppvOut);

#endif  // _OPENWITH_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\ovrlayid.h ===
// Shell Icon Overlay Identifiers 

#ifndef _OVERLAYID_H_
#define _OVERLAYID_H_

#define REGSTR_ICONOVERLAYID     TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\ShellIconOverlayIdentifiers")
#define REGSTR_ICONOVERLAYCLSID  TEXT("CLSID\\%s")

STDAPI CFSIconOverlayIdentifier_SlowFile_CreateInstance(IUnknown* pUnkOuter, REFIID riid, void **ppvOut);

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\ovrlaymn.h ===
// Shell Icon Overlay Manager

#ifndef _OVERLAYMN_H_
#define _OVERLAYMN_H_

// HACK: This is defined in image.c, and it should be in one of the header files
#define MAX_OVERLAY_IMAGES  NUM_OVERLAY_IMAGES

#define REGSTR_ICONOVERLAYID     TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\ShellIconOverlayIdentifiers")
#define REGSTR_ICONOVERLAYCLSID  TEXT("CLSID\\%s")

STDAPI CFSIconOverlayManager_CreateInstance(IUnknown* pUnkOuter, REFIID riid, void **ppvOut);

STDAPI_(BOOL) IconOverlayManagerInit();
STDAPI_(void) IconOverlayManagerTerminate();

extern IShellIconOverlayManager * g_psiom;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\openwith.cpp ===
#include "shellprv.h"
#include "ids.h"
#include <shlwapi.h>
#include "openwith.h"
#include "uemapp.h"
#include "mtpt.h"
#include "fassoc.h"
#include "filetbl.h"
#include "datautil.h"
#include <dpa.h>
#include "defcm.h"

#define TF_OPENWITHMENU 0x00000000

#define SZOPENWITHLIST                  TEXT("OpenWithList")
#define REGSTR_PATH_EXPLORER_FILEEXTS   TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\FileExts")
#define OPEN_WITH_LIST_MAX_ITEMS        10

//
//  OpenWithListOpen() 
//  allocates and initializes the state for the openwithlist 
//
HRESULT OpenWithListOpen(IN LPCTSTR pszExt, HANDLE *phmru)
{
    *phmru = 0;
    if (pszExt && *pszExt) 
    {
        TCHAR szSubKey[MAX_PATH];
        //  Build up the subkey string.
        wnsprintf(szSubKey, SIZECHARS(szSubKey), TEXT("%s\\%s\\%s"), REGSTR_PATH_EXPLORER_FILEEXTS, pszExt, SZOPENWITHLIST);
        MRUINFO mi = {sizeof(mi), OPEN_WITH_LIST_MAX_ITEMS, 0, HKEY_CURRENT_USER, szSubKey, NULL};
        *phmru = CreateMRUList(&mi);

    }

    return *phmru ? S_OK : E_OUTOFMEMORY;
}

HRESULT _AddItem(HANDLE hmru, LPCTSTR pszName)
{
    HRESULT hr = S_OK;
    if (hmru)
    {
        int cItems = EnumMRUList(hmru, -1, NULL, 0);

        //  just trim us down to make room...
        while (cItems >= OPEN_WITH_LIST_MAX_ITEMS)
            DelMRUString(hmru, --cItems);
            
        if (0 > AddMRUString(hmru, pszName))
            hr = E_UNEXPECTED;

    }
    
    return hr;
}

void _DeleteItem(HANDLE hmru, LPCTSTR pszName)
{
    int iItem = FindMRUString(hmru, pszName, NULL);
    if (0 <= iItem) 
    {
        DelMRUString(hmru, iItem);
    } 
}

void _AddProgidForExt(LPCWSTR pszExt);

STDAPI OpenWithListRegister(DWORD dwFlags, LPCTSTR pszExt, LPCTSTR pszVerb, HKEY hkProgid)
{
    //
    //  ----> Peruser entries are stored here
    //  HKCU\Software\Microsoft\Windows\CurrentVersion\Explorer\FileExts
    //     \.Ext
    //         Application = "foo.exe"
    //         \OpenWithList
    //             MRUList = "ab"
    //             a = "App.exe"
    //             b = "foo.exe"
    //
    //  ----> for permanent entries are stored un HKCR
    //  HKCR
    //     \.Ext
    //         \OpenWithList
    //             \app.exe
    //
    //  ----> and applications or the system can write app association here
    //     \Applications
    //         \APP.EXE
    //             \shell...
    //         \foo.exe
    //             \shell...
    //
    //
    HANDLE hmru;
    HRESULT hr = OpenWithListOpen(pszExt, &hmru);
    if (SUCCEEDED(hr))
    {
        TCHAR szPath[MAX_PATH];
        hr = AssocQueryStringByKey(ASSOCF_VERIFY, ASSOCSTR_EXECUTABLE, hkProgid, pszVerb, szPath, (LPDWORD)MAKEINTRESOURCE(SIZECHARS(szPath)));
        if (SUCCEEDED(hr))
        {
            LPCTSTR pszExe = PathFindFileName(szPath);

            if (IsPathInOpenWithKillList(pszExe))
                hr = E_ACCESSDENIED;
            else
                hr = AssocMakeApplicationByKey(ASSOCMAKEF_VERIFY, hkProgid, pszVerb);
        
            if (SUCCEEDED(hr))
            {
                TraceMsg(TF_OPENWITHMENU, "[%X] OpenWithListRegister() adding %s",hmru, pszExe);
                hr = _AddItem(hmru, pszExe);
            }

            if (FAILED(hr)) 
                _DeleteItem(hmru, pszExe);

        }

        FreeMRUList(hmru);
    }

    _AddProgidForExt(pszExt);

    return hr;
}

STDAPI_(void) OpenWithListSoftRegisterProcess(DWORD dwFlags, LPCTSTR pszExt, LPCTSTR pszProcess)
{
    HANDLE hmru;
    if (SUCCEEDED(OpenWithListOpen(pszExt, &hmru)))
    {
        TCHAR szApp[MAX_PATH];  
        if (!pszProcess)
        {
           if (GetModuleFileName(NULL, szApp, SIZECHARS(szApp)))
               pszProcess = szApp;
        }

        if (pszProcess && !IsPathInOpenWithKillList(pszProcess))
            _AddItem(hmru, PathFindFileName(pszProcess));

        FreeMRUList(hmru);
    }
}

class COpenWithArray : public CDPA<CAppInfo>
{
public:
    ~COpenWithArray();
    HRESULT FillArray(PCWSTR pszExt);

private:
    static int CALLBACK _DeleteAppInfo(CAppInfo *pai, void *pv)
        { if (pai) delete pai; return 1; }

};

COpenWithArray::~COpenWithArray()
{
    if ((HDPA)this)
        DestroyCallback(_DeleteAppInfo, NULL);
}

HRESULT COpenWithArray::FillArray(PCWSTR pszExt)
{
    IEnumAssocHandlers *penum;
    HRESULT hr = SHAssocEnumHandlers(pszExt, &penum);
    if (SUCCEEDED(hr))
    {
        IAssocHandler *pah;
        while (S_OK == penum->Next(1, &pah, NULL))
        {
            // we only want the best
            if (S_OK == pah->IsRecommended())
            {
                CAppInfo *pai = new CAppInfo(pah);
                if (pai)
                {
                    if (pai->Init())
                    {
                        // Trim duplicate items before we add them for other programs
                        int i = 0;
                        for (; i < GetPtrCount(); i++)
                        {
                            if (0 == lstrcmpi(pai->Name(), GetPtr(i)->Name()))
                            {
                                //  its a match
                                break;
                            }
                        }

                        //  if we dont add this to the dpa
                        //  then we need to clean it up
                        if (i == GetPtrCount() && -1 != AppendPtr(pai))
                            pai = NULL;
                    }

                    if (pai)
                        delete pai;
                }
            }
            pah->Release();
        }
        penum->Release();
    }

    return hr;
}

class COpenWithMenu : public IContextMenu3, IShellExtInit
{
    // IUnknown
    STDMETHOD(QueryInterface)(REFIID riid, void **ppvObj);
    STDMETHOD_(ULONG,AddRef)(void);
    STDMETHOD_(ULONG,Release)(void);
    
    // IContextMenu
    STDMETHOD(QueryContextMenu)(HMENU hmenu, UINT indexMenu, UINT idCmdFirst, UINT idCmdLast, UINT uFlags);
    STDMETHOD(InvokeCommand)(LPCMINVOKECOMMANDINFO lpici);
    STDMETHOD(GetCommandString)(UINT_PTR idCmd, UINT uType, UINT *pRes, LPSTR pszName, UINT cchMax);
    
    // IContextMenu2
    STDMETHOD(HandleMenuMsg)(UINT uMsg, WPARAM wParam, LPARAM lParam);
    
    // IContextMenu3
    STDMETHOD(HandleMenuMsg2)(UINT uMsg, WPARAM wParam, LPARAM lParam,LRESULT *lResult);
    
    // IShellExtInit
    STDMETHOD(Initialize)(LPCITEMIDLIST pidlFolder, IDataObject *pdtobj, HKEY hkeyProgID);
    
    
    friend HRESULT COpenWithMenu_CreateInstance(IUnknown* pUnkOuter, REFIID riid, void **ppvOut);
    
protected:  // methods
    COpenWithMenu();
    ~COpenWithMenu();
    //Handle Menu messages submitted to HandleMenuMsg
    void DrawItem(DRAWITEMSTRUCT *lpdi);
    LRESULT MeasureItem(MEASUREITEMSTRUCT *lpmi);
    BOOL InitMenuPopup(HMENU hMenu);
    
    //Internal Helpers
    HRESULT _GetHelpText(UINT_PTR idCmd, LPSTR pszName, UINT cchMax, BOOL fUnicode);
    HRESULT _MatchMenuItem(TCHAR ch, LRESULT* plRes);

protected:  // members
    LONG                _cRef;
    HMENU               _hMenu;
    BOOL                _fMenuNeedsInit;
    UINT                _idCmdFirst;
    COpenWithArray      _owa;
    int                 _nItems;
    UINT                _uFlags;
    IDataObject        *_pdtobj;
    TCHAR               _szPath[MAX_PATH];
    
};


COpenWithMenu::COpenWithMenu() : _cRef(1)
{
    TraceMsg(TF_OPENWITHMENU, "ctor COpenWithMenu %x", this);
}

COpenWithMenu::~COpenWithMenu()
{
    TraceMsg(TF_OPENWITHMENU, "dtor COpenWithMenu %x", this);

    if (_pdtobj)
        _pdtobj->Release();

    if (_hMenu)
    {
        ASSERT(_nItems);
        DestroyMenu(_hMenu);
    }
}

STDAPI COpenWithMenu_CreateInstance(IUnknown* pUnkOuter, REFIID riid, void **ppvOut)
{
    *ppvOut = NULL;                     

    if (pUnkOuter)
        return CLASS_E_NOAGGREGATION;

    COpenWithMenu * powm = new COpenWithMenu();
    if (!powm)
        return E_OUTOFMEMORY;
    
    HRESULT hr = powm->QueryInterface(riid, ppvOut);
    powm->Release();
    return hr;
}

HRESULT COpenWithMenu::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENTMULTI(COpenWithMenu, IContextMenu, IContextMenu3),
        QITABENTMULTI(COpenWithMenu, IContextMenu2, IContextMenu3),
        QITABENT(COpenWithMenu, IContextMenu3),
        QITABENT(COpenWithMenu, IShellExtInit),
        { 0 },
    };
    return QISearch(this, qit, riid, ppvObj);
}

ULONG COpenWithMenu::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG COpenWithMenu::Release()
{
    if (InterlockedDecrement(&_cRef))
       return _cRef;

    delete this;
    return 0;
}

/*
    Purpose:
        Add Open/Edit/Default verb to extension app list
*/
HRESULT AddVerbItems(LPCTSTR pszExt)
{
    IQueryAssociations *pqa;
    HRESULT hr = AssocCreate(CLSID_QueryAssociations, IID_PPV_ARG(IQueryAssociations, &pqa));
    
    if (SUCCEEDED(hr))
    {
        hr = pqa->Init(0, pszExt, NULL, NULL);
        if (SUCCEEDED(hr))
        {
            HKEY hkeyClass;
            hr = pqa->GetKey(0, ASSOCKEY_SHELLEXECCLASS, NULL, &hkeyClass);
            if (SUCCEEDED(hr))
            {
                OpenWithListRegister(0, pszExt, NULL, hkeyClass);
                RegCloseKey(hkeyClass);
            }

            //  we add in the editor too
            if (SUCCEEDED(pqa->GetKey(0, ASSOCKEY_SHELLEXECCLASS, L"Edit", &hkeyClass)))
            {
                OpenWithListRegister(0, pszExt, NULL, hkeyClass);
                RegCloseKey(hkeyClass);
            }
                
            hr = S_OK;
        }
        pqa->Release();
    }
    return hr;
}

//
//  Our context menu IDs are assigned like this
//
//  idCmdFirst = Open With Custom Program (either on main menu or on popup)
//  idCmdFirst+1 through idCmdFirst+_nItems = Open With program in OpenWithList

#define OWMENU_BROWSE       0
#define OWMENU_APPFIRST     1


HRESULT COpenWithMenu::QueryContextMenu(HMENU hmenu, UINT indexMenu, UINT idCmdFirst, UINT idCmdLast, UINT uFlags)
{
    MENUITEMINFO mii;
    LPTSTR pszExt;
    TCHAR szOpenWithMenu[80];
    
    _idCmdFirst = idCmdFirst;
    _uFlags = uFlags;
    
    if (SUCCEEDED(PathFromDataObject(_pdtobj, _szPath, ARRAYSIZE(_szPath))))
    {
        // No openwith context menu for executables.
        if (PathIsExe(_szPath))
            return S_OK;

        pszExt = PathFindExtension(_szPath);
        if (pszExt && *pszExt)
        {
            // Add Open/Edit/Default verb to extension app list
            if (SUCCEEDED(AddVerbItems(pszExt)))
            {
                // Do this only if AddVerbItems succeeded; otherwise,
                // we would create an empty MRU for a nonexisting class,
                // causing the class to spring into existence and cause
                // the "Open With" dialog to think we are overriding
                // rather than creating new.
                // get extension app list
                
                if (_owa.Create(4) && SUCCEEDED(_owa.FillArray(pszExt)))
                {
                    _nItems = _owa.GetPtrCount();
                    if (1 == _nItems)
                    {
                        // For known file type(there is at least one verb under its progid), 
                        // if there is only one item in its openwithlist, don't show open with sub menu
                        _nItems = 0;
                    }
                }
            }
        }
    }

    LoadString(g_hinst, (_nItems ? IDS_OPENWITH : IDS_OPENWITHNEW), szOpenWithMenu, ARRAYSIZE(szOpenWithMenu));

    if (_nItems)
    {
        //  we need to create a submenu
        //  with all of our goodies
        _hMenu = CreatePopupMenu();
        if (_hMenu)
        {
            _fMenuNeedsInit = TRUE;
            
            mii.cbSize = sizeof(MENUITEMINFO);
            mii.fMask = MIIM_ID|MIIM_TYPE|MIIM_DATA;
            mii.wID = idCmdFirst+OWMENU_APPFIRST;
            mii.fType = MFT_STRING;
            mii.dwTypeData = szOpenWithMenu;
            mii.dwItemData = 0;
        
            InsertMenuItem(_hMenu,0,TRUE,&mii);
        
            mii.fMask = MIIM_ID|MIIM_SUBMENU|MIIM_TYPE;
            mii.fType = MFT_STRING;
            mii.wID = idCmdFirst+OWMENU_BROWSE;
            mii.hSubMenu = _hMenu;
            mii.dwTypeData = szOpenWithMenu;
        
            InsertMenuItem(hmenu,indexMenu,TRUE,&mii);
        }
    }
    else
    {
        mii.cbSize = sizeof(MENUITEMINFO);
        mii.fMask = MIIM_ID|MIIM_TYPE|MIIM_DATA;
        mii.fType = MFT_STRING;
        mii.wID = idCmdFirst+OWMENU_BROWSE;
        mii.dwTypeData = szOpenWithMenu;
        mii.dwItemData = 0;
        
        InsertMenuItem(hmenu,indexMenu,TRUE,&mii);

    }
    return ResultFromShort(_nItems + 1);

}

HRESULT COpenWithMenu::InvokeCommand(LPCMINVOKECOMMANDINFO pici)
{
    HRESULT hr = E_OUTOFMEMORY;
    CMINVOKECOMMANDINFOEX ici;
    void * pvFree;

    //  maybe these two routines should be collapsed into one?
    if ((IS_INTRESOURCE(pici->lpVerb) || 0 == lstrcmpiA(pici->lpVerb, "openas"))
    && SUCCEEDED(ICI2ICIX(pici, &ici, &pvFree)))
    {
        BOOL fOpenAs = TRUE;
        if (pici->lpVerb && IS_INTRESOURCE(pici->lpVerb))
        {
            int i = LOWORD(pici->lpVerb) - OWMENU_APPFIRST;
            if (i < _owa.GetPtrCount())
            {
                hr = _owa.GetPtr(i)->Handler()->Invoke(&ici, _szPath);
                fOpenAs = FALSE;
            }
        }

        if (fOpenAs)
        {
            SHELLEXECUTEINFO ei = {0};
            hr = ICIX2SEI(&ici, &ei);
            if (SUCCEEDED(hr))
            {
                // use the "Unknown" key so we get the openwith prompt
                ei.lpFile = _szPath;
                //  dont do the zone check before the user picks the app.
                //  wait until they actually try to invoke the file.
                ei.fMask |= SEE_MASK_NOZONECHECKS;
                RegOpenKeyEx(HKEY_CLASSES_ROOT, TEXT("Unknown"), 0, MAXIMUM_ALLOWED, &ei.hkeyClass);
                if (!(_uFlags & CMF_DEFAULTONLY))
                {
                    // defview sets CFM_DEFAULTONLY when the user is double-clicking. We check it
                    // here since we want do NOT want to query the class store if the user explicitly
                    // right-clicked on the menu and choo   se openwith.

                    // pop up open with dialog without querying class store
                    ei.fMask |= SEE_MASK_NOQUERYCLASSSTORE;
                }

                if (ei.hkeyClass)
                {
                    ei.fMask |= SEE_MASK_CLASSKEY;

                    if (ShellExecuteEx(&ei)) 
                    {
                        hr = S_OK;
                        if (UEMIsLoaded())
                        {
                            // note that we already got a UIBL_DOTASSOC (from
                            // OpenAs_RunDLL or whatever it is that 'Unknown'
                            // runs).  so the Uassist analysis app will have to
                            // subtract it off
                            UEMFireEvent(&UEMIID_SHELL, UEME_INSTRBROWSER, UEMF_INSTRUMENT, UIBW_RUNASSOC, UIBL_DOTNOASSOC);
                        }
                    }
                    else
                    {
                        hr = HRESULT_FROM_WIN32(GetLastError());
                    }
                    RegCloseKey(ei.hkeyClass);
                 }
                 else
                    hr = E_FAIL;
             }
        }

        LocalFree(pvFree);  // accepts NULL
    }        

    return hr;
}

HRESULT COpenWithMenu::_GetHelpText(UINT_PTR idCmd, LPSTR pszName, UINT cchMax, BOOL fUnicode)
{
    UINT ids;
    LPCTSTR pszFriendly = NULL;

    if (idCmd == OWMENU_BROWSE)
    {
        ids = IDS_OPENWITHHELP;
        pszFriendly = TEXT("");
    }
    else if ((idCmd-OWMENU_APPFIRST) < (UINT_PTR)_owa.GetPtrCount())
    {
        ids = IDS_OPENWITHAPPHELP;
        pszFriendly = _owa.GetPtr(idCmd-OWMENU_APPFIRST)->UIName();
    }

    if (!pszFriendly)
        return E_FAIL;

    if (fUnicode)
    {
        WCHAR wszFormat[80];
        LoadStringW(HINST_THISDLL, ids, wszFormat, ARRAYSIZE(wszFormat));
        wnsprintfW((LPWSTR)pszName, cchMax, wszFormat, pszFriendly);
    }
    else
    {
        CHAR szFormat[80];
        LoadStringA(HINST_THISDLL, ids, szFormat, ARRAYSIZE(szFormat));
        wnsprintfA(pszName, cchMax, szFormat, pszFriendly);
    }

    return S_OK;
}

const ICIVERBTOIDMAP c_sIDVerbMap[] = 
{
    { L"openas", "openas", OWMENU_BROWSE, OWMENU_BROWSE, },
};

HRESULT COpenWithMenu::GetCommandString(UINT_PTR idCmd, UINT uType, UINT *pRes, LPSTR pszName, UINT cchMax)
{
    switch (uType)
    {
        case GCS_VERBA:
        case GCS_VERBW:
            return SHMapCmdIDToVerb(idCmd, c_sIDVerbMap, ARRAYSIZE(c_sIDVerbMap), pszName, cchMax, GCS_VERBW == uType);

        case GCS_HELPTEXTA:
        case GCS_HELPTEXTW:
            return _GetHelpText(idCmd, pszName, cchMax, uType == GCS_HELPTEXTW);

    }

    return E_NOTIMPL;
}

HRESULT COpenWithMenu::HandleMenuMsg(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    return HandleMenuMsg2(uMsg,wParam,lParam,NULL);
}

// Defined in fsmenu.cpp
BOOL _MenuCharMatch(LPCTSTR lpsz, TCHAR ch, BOOL fIgnoreAmpersand);

HRESULT COpenWithMenu::_MatchMenuItem(TCHAR ch, LRESULT* plRes)
{
    if (plRes == NULL)
        return S_FALSE;

    int iLastSelectedItem = -1;
    int iNextMatch = -1;
    BOOL fMoreThanOneMatch = FALSE;
    int c = GetMenuItemCount(_hMenu);

    // Pass 1: Locate the Selected Item
    for (int i = 0; i < c; i++) 
    {
        MENUITEMINFO mii = {0};
        mii.cbSize = sizeof(mii);
        mii.fMask = MIIM_STATE;
        if (GetMenuItemInfo(_hMenu, i, MF_BYPOSITION, &mii))
        {
            if (mii.fState & MFS_HILITE)
            {
                iLastSelectedItem = i;
                break;
            }
        }
    }

    // Pass 2: Starting from the selected item, locate the first item with the matching name.
    for (int i = iLastSelectedItem + 1; i < c; i++) 
    {
        if (i < _owa.GetPtrCount()
        && _MenuCharMatch(_owa.GetPtr(i)->UIName(), ch, FALSE))
        {
            if (iNextMatch != -1)
            {
                fMoreThanOneMatch = TRUE;
                break;                      // We found all the info we need
            }
            else
            {
                iNextMatch = i;
            }
        }
    }

    // Pass 3: If we did not find a match, or if there was only one match
    // Search from the first item, to the Selected Item
    if (iNextMatch == -1 || fMoreThanOneMatch == FALSE)
    {
        for (int i = 0; i <= iLastSelectedItem; i++) 
        {
            if (i < _owa.GetPtrCount()
            && _MenuCharMatch(_owa.GetPtr(i)->UIName(), ch, FALSE))
            {
                if (iNextMatch != -1)
                {
                    fMoreThanOneMatch = TRUE;
                    break;
                }
                else
                {
                    iNextMatch = i;
                }
            }
        }
    }

    if (iNextMatch != -1)
    {
        *plRes = MAKELONG(iNextMatch, fMoreThanOneMatch? MNC_SELECT : MNC_EXECUTE);
    }
    else
    {
        *plRes = MAKELONG(0, MNC_IGNORE);
    }

    return S_OK;
}


HRESULT COpenWithMenu::HandleMenuMsg2(UINT uMsg, WPARAM wParam, LPARAM lParam,LRESULT *plResult)
{
    LRESULT lResult = 0;
    HRESULT hr = S_OK;

    switch (uMsg)
    {
    case WM_INITMENUPOPUP:
        InitMenuPopup(_hMenu);
        break;

    case WM_DRAWITEM:
        DrawItem((DRAWITEMSTRUCT *)lParam);
        break;
        
    case WM_MEASUREITEM:
        lResult = MeasureItem((MEASUREITEMSTRUCT *)lParam);    
        break;

    case WM_MENUCHAR:
        hr = _MatchMenuItem((TCHAR)LOWORD(wParam), &lResult);
        break;

    default:
        hr = E_NOTIMPL;
        break;
    }

    if (plResult)
        *plResult = lResult;

    return hr;
}

HRESULT COpenWithMenu::Initialize(LPCITEMIDLIST pidlFolder, IDataObject *pdtobj, HKEY hkeyProgID)
{
    IUnknown_Set((IUnknown **)&_pdtobj, pdtobj);
    return S_OK;
}

#define CXIMAGEGAP 6
#define SRCSTENCIL              0x00B8074AL

void COpenWithMenu::DrawItem(DRAWITEMSTRUCT *lpdi)
{
    CAppInfo *pai = _owa.GetPtr(lpdi->itemData);
    DrawMenuItem(lpdi,  pai->UIName(), pai->IconIndex());
}

LRESULT COpenWithMenu::MeasureItem(MEASUREITEMSTRUCT *pmi)
{
    CAppInfo *pai = _owa.GetPtr(pmi->itemData);
    return MeasureMenuItem(pmi, pai->UIName());
}
 
BOOL COpenWithMenu::InitMenuPopup(HMENU hmenu)
{
    TraceMsg(TF_OPENWITHMENU, "COpenWithMenu::InitMenuPopup");

    if (_fMenuNeedsInit)
    {
        TCHAR szMenuText[80];
        MENUITEMINFO mii;
        // remove the place holder.
        DeleteMenu(hmenu,0,MF_BYPOSITION);

        // add app's in mru list to context menu
        for (int i = 0; i < _owa.GetPtrCount(); i++)
        {
            mii.cbSize = sizeof(MENUITEMINFO);
            mii.fMask = MIIM_ID|MIIM_TYPE|MIIM_DATA;
            mii.wID = _idCmdFirst + OWMENU_APPFIRST + i;
            mii.fType = MFT_OWNERDRAW;
            mii.dwItemData = i;

            InsertMenuItem(hmenu,GetMenuItemCount(hmenu),TRUE,&mii);
        }

        // add seperator
        AppendMenu(hmenu,MF_SEPARATOR,0,NULL); 

        // add "Choose Program..."
        LoadString(g_hinst, IDS_OPENWITHBROWSE, szMenuText, ARRAYSIZE(szMenuText));
        mii.cbSize = sizeof(MENUITEMINFO);
        mii.fMask = MIIM_ID|MIIM_TYPE|MIIM_DATA;
        mii.wID = _idCmdFirst + OWMENU_BROWSE;
        mii.fType = MFT_STRING;
        mii.dwTypeData = szMenuText;
        mii.dwItemData = 0;

        InsertMenuItem(hmenu,GetMenuItemCount(hmenu),TRUE,&mii);
        _fMenuNeedsInit = FALSE;
        return TRUE;
    }
    return FALSE;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\os.c ===
#include "shellprv.h"
#pragma  hdrstop

#include <ntimage.h>    
#include <ntrtl.h>

static DWORD s_dwThreadIDSuspendNotify = 0;

STDAPI_(BOOL) SuspendSHNotify()
{
    DWORD dwID = GetCurrentThreadId();
    DWORD dwOldID = InterlockedCompareExchange(&s_dwThreadIDSuspendNotify, dwID, 0);
    return (dwOldID == 0);
}

STDAPI_(BOOL) ResumeSHNotify()
{
    DWORD dwID = GetCurrentThreadId();
    DWORD dwOldID = InterlockedCompareExchange(&s_dwThreadIDSuspendNotify, 0, dwID);
    return (dwOldID == dwID);
}

STDAPI_(BOOL) SHMoveFile(LPCTSTR pszExisting, LPCTSTR pszNew, LONG lEvent)
{
    BOOL res;

    // CreateDirectory fails if the directory name being created does
    // not have room for an 8.3 name to be tagged onto the end of it,
    // i.e., lstrlen(new_directory_name)+12 must be less or equal to MAX_PATH.
    // However, NT does not impose this restriction on MoveFile -- which the
    // shell sometimes uses to manipulate directory names.  So, in order to
    // maintain consistency, we now check the length of the name before we
    // move the directory...

    if (IsDirPathTooLongForCreateDir(pszNew) &&
        (GetFileAttributes(pszExisting) & FILE_ATTRIBUTE_DIRECTORY))
    {
        SetLastError(ERROR_FILENAME_EXCED_RANGE);
        res = FALSE;
    }
    else
    {
        res = MoveFile(pszExisting, pszNew);
        if (FALSE == res)
        {
            // If we couldn't move the file, see if it had the readonly or system attributes.
            // If so, clear them, move the file, and set them back on the destination

            DWORD dwAttributes = GetFileAttributes(pszExisting);
            if (-1 != dwAttributes && (dwAttributes & (FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_SYSTEM)))
            {
                if (SetFileAttributes(pszExisting, dwAttributes  & ~(FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_SYSTEM)))
                {
                    res = MoveFile(pszExisting, pszNew);
                    if (res)
                    {
                        SetFileAttributes(pszNew, dwAttributes);
                    }
                    else
                    {
                        SetFileAttributes(pszExisting, dwAttributes); // if move failed, return attributes.
                    }
                }
            }
        }
    }

    if (res && s_dwThreadIDSuspendNotify != GetCurrentThreadId())
    {
        SHChangeNotify(lEvent, SHCNF_PATH, pszExisting, pszNew);
    }

    return res;
}

STDAPI_(BOOL) Win32MoveFile(LPCTSTR pszExisting, LPCTSTR pszNew, BOOL fDir)
{
    return SHMoveFile(pszExisting, pszNew, fDir ? SHCNE_RENAMEFOLDER : SHCNE_RENAMEITEM);
}

STDAPI_(BOOL) Win32DeleteFilePidl(LPCTSTR pszFileName, LPCITEMIDLIST pidlFile)
{
    BOOL res = DeleteFile(pszFileName);
    if (FALSE == res)
    {
        // If we couldn't delete the file, see if it has the readonly or
        // system bits set.  If so, clear them and try again

        DWORD dwAttributes = GetFileAttributes(pszFileName);
        if (-1 != dwAttributes && (dwAttributes & (FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_SYSTEM)))
        {
            if (SetFileAttributes(pszFileName, dwAttributes  & ~(FILE_ATTRIBUTE_READONLY | FILE_ATTRIBUTE_SYSTEM)))
            {
                res = DeleteFile(pszFileName);
            }
        }
    }

    if (res && s_dwThreadIDSuspendNotify != GetCurrentThreadId())
    {
        if (pidlFile)
        {
            SHChangeNotify(SHCNE_DELETE, SHCNF_IDLIST, pidlFile, NULL);
        }
        else
        {
            SHChangeNotify(SHCNE_DELETE, SHCNF_PATH, pszFileName, NULL);
        }
    }

    return res;
}

STDAPI_(BOOL) Win32DeleteFile(LPCTSTR pszFileName)
{
    return Win32DeleteFilePidl(pszFileName, NULL);
}

STDAPI_(BOOL) Win32CreateDirectory(LPCTSTR pszPath, LPSECURITY_ATTRIBUTES lpsa)
{
    BOOL res = CreateDirectory(pszPath, lpsa);

    if (res && s_dwThreadIDSuspendNotify != GetCurrentThreadId())
    {
        SHChangeNotify(SHCNE_MKDIR, SHCNF_PATH, pszPath, NULL);
    }

    return res;
}

//
// Some filesystems (like NTFS, perchance) actually pay attention to
// the readonly bit on folders.  So, in order to pretend we're sort of
// FAT and dumb, we clear the attribute before trying to delete the
// directory.
//
STDAPI_(BOOL) Win32RemoveDirectory(LPCTSTR pszDir)
{
    BOOL res = RemoveDirectory(pszDir);

    if (FALSE == res) 
    {
        DWORD dwAttr = GetFileAttributes(pszDir);
        if ((-1 != dwAttr) && (dwAttr & FILE_ATTRIBUTE_READONLY))
        {
            dwAttr &= ~FILE_ATTRIBUTE_READONLY;
            SetFileAttributes(pszDir, dwAttr);
            res = RemoveDirectory(pszDir);
        }
    }
    
    if (res && s_dwThreadIDSuspendNotify != GetCurrentThreadId())
    {
        SHChangeNotify(SHCNE_RMDIR, SHCNF_PATH, pszDir, NULL);
    }

    return res;
}

STDAPI_(HANDLE) Win32CreateFile(LPCTSTR pszFileName, DWORD dwAttrib)
{
    HANDLE hFile = CreateFile(pszFileName, GENERIC_READ | GENERIC_WRITE,
                                      FILE_SHARE_READ | FILE_SHARE_WRITE,
                                      NULL, CREATE_ALWAYS, dwAttrib & FILE_ATTRIBUTE_VALID_FLAGS,
                                      NULL);
    if (INVALID_HANDLE_VALUE != hFile && s_dwThreadIDSuspendNotify != GetCurrentThreadId())
    {
        SHChangeNotify(SHCNE_CREATE, SHCNF_PATH, pszFileName, NULL);
    }

    return hFile;
}

STDAPI_(BOOL) CreateWriteCloseFile(HWND hwnd, LPCTSTR pszFile, void *pData, DWORD cbData)
{
    BOOL bRet;
    HANDLE hfile = Win32CreateFile(pszFile, 0);
    if (hfile != INVALID_HANDLE_VALUE)
    {
        if (cbData)
        {
            DWORD dwBytesWritten;
            WriteFile(hfile, pData, cbData, &dwBytesWritten, 0);
        }
        CloseHandle(hfile);
        bRet = TRUE;
    } 
    else 
    {
        TCHAR szPath[MAX_PATH];

        lstrcpyn(szPath, pszFile, ARRAYSIZE(szPath));
        PathRemoveExtension(szPath);

        SHSysErrorMessageBox(hwnd, NULL, IDS_CANNOTCREATEFILE,
                GetLastError(), PathFindFileName(szPath),
                MB_OK | MB_ICONEXCLAMATION);
        bRet = FALSE;
    }
    return bRet;
}

#undef SHGetProcessDword
STDAPI_(DWORD) SHGetProcessDword(DWORD idProcess, LONG iIndex)
{
    return 0;
}

STDAPI_(BOOL) SHSetShellWindowEx(HWND hwnd, HWND hwndChild)
{
    return SetShellWindowEx(hwnd, hwndChild);
}

#define ISEXETSAWARE_MAX_IMAGESIZE  (4 * 1024) // allocate at most a 4k block to hold the image header (eg 1 page on x86)

//
// this is a function that takes a full path to an executable and returns whether or not
// the exe has the TS_AWARE bit set in the image header
//
STDAPI_(BOOL) IsExeTSAware(LPCTSTR pszExe)
{
    BOOL bRet = FALSE;
    HANDLE hFile = CreateFile(pszExe,
                              GENERIC_READ, 
                              FILE_SHARE_READ | FILE_SHARE_WRITE,
                              NULL,
                              OPEN_EXISTING, 
                              FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,
                              NULL);

    if (hFile != INVALID_HANDLE_VALUE)
    {
        DWORD cbImageSize = GetFileSize(hFile, NULL);
        LPBYTE pBuffer;
        
        if (cbImageSize > ISEXETSAWARE_MAX_IMAGESIZE)
        {
            // 64k should be enough to get the image header for everything...
            cbImageSize = ISEXETSAWARE_MAX_IMAGESIZE;
        }

        pBuffer = LocalAlloc(LPTR, cbImageSize);

        if (pBuffer)
        {
            HANDLE hMap = CreateFileMapping(hFile, NULL, PAGE_READONLY | SEC_IMAGE, 0, cbImageSize, NULL);

            if (hMap)
            {
                // map the first 4k of the file in
                LPBYTE pFileMapping = (LPBYTE)MapViewOfFile(hMap, FILE_MAP_READ, 0, 0, cbImageSize);

                if (pFileMapping) 
                {
                    _try
                    {
                        memcpy(pBuffer, pFileMapping, cbImageSize);
                    }
                    _except(UnhandledExceptionFilter(GetExceptionInformation()))
                    {
                        // We hit an exception while copying! doh!
                        LocalFree(pBuffer);
                        pBuffer = NULL;
                    }
                    
                    UnmapViewOfFile(pFileMapping);
                }
                else
                {
                    LocalFree(pBuffer);
                    pBuffer = NULL;
                }

                CloseHandle(hMap);
            }
            else
            {
                LocalFree(pBuffer);
                pBuffer = NULL;
            }

            if (pBuffer)
            {
                PIMAGE_NT_HEADERS pImageNTHeader;

                // NOTE: this should work ok for 64-bit images too, since both the IMAGE_NT_HEADERS and the IMAGE_NT_HEADERS64
                // structs have a ->Signature and ->OptionalHeader that is identical up to the DllCharacteristics offset.
                pImageNTHeader = RtlImageNtHeader(pBuffer);

                if (pImageNTHeader)
                {
                    if (pImageNTHeader->OptionalHeader.DllCharacteristics & IMAGE_DLLCHARACTERISTICS_TERMINAL_SERVER_AWARE)
                    {
                        // yes, this is a TSAWARE executable!
                        bRet = TRUE;
                    }
                }

                LocalFree(pBuffer);
            }
        }

        CloseHandle(hFile);
    }

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\os.h ===
//
//  wrappers around Kernel API's that generate FS notification messages.
//
STDAPI_(BOOL) SHMoveFile(LPCTSTR pszExisting, LPCTSTR pszNew, LONG lEvent);
STDAPI_(BOOL) CreateWriteCloseFile(HWND hwnd, LPCTSTR pszFileName, void *pData, DWORD cbData);

STDAPI_(BOOL) Win32MoveFile(LPCTSTR pszExisting, LPCTSTR pszNew, BOOL fDir);
STDAPI_(BOOL) Win32CreateDirectory(LPCTSTR pszPath, LPSECURITY_ATTRIBUTES lpsa);
STDAPI_(BOOL) Win32RemoveDirectory(LPCTSTR pszDir);
STDAPI_(BOOL) Win32DeleteFile(LPCTSTR pszFileName);
STDAPI_(BOOL) Win32DeleteFilePidl(LPCTSTR pszFileName, LPCITEMIDLIST pidlFile);
STDAPI_(HANDLE) Win32CreateFile(LPCTSTR pszFileName, DWORD dwAttrib);


STDAPI_(BOOL) SuspendSHNotify();
STDAPI_(BOOL) ResumeSHNotify();
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\pchcpp.cpp ===
#include "pchcpp.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\path.c ===
#include "shellprv.h"
#pragma  hdrstop

// from mtpt.cpp
STDAPI_(BOOL) CMtPt_IsLFN(int iDrive);
STDAPI_(BOOL) CMtPt_IsSlow(int iDrive);

__inline BOOL DBL_BSLASH(LPNCTSTR psz)
{
    return (psz[0] == TEXT('\\') && psz[1] == TEXT('\\'));
}

#define IsPathSep(ch)  ((ch) == TEXT('\\') || (ch) == TEXT('/'))

// in:
//      pszPath         fully qualified path (unc or x:\) to test
//                      NULL for windows directory
//
// returns:
//      TRUE            volume supports name longer than 12 chars
//
// note: this caches drive letters, but UNCs go through every time
//
STDAPI_(BOOL) IsLFNDrive(LPCTSTR pszPath)
{
    TCHAR szRoot[MAX_PATH];
    DWORD dwMaxLength = 13;      // assume yes

    ASSERT(NULL == pszPath || IS_VALID_STRING_PTR(pszPath, -1));

    if ((pszPath == NULL) || !*pszPath)
    {
        *szRoot = 0;
        GetWindowsDirectory(szRoot, ARRAYSIZE(szRoot));
        pszPath = szRoot;
    }

    ASSERT(!PathIsRelative(pszPath));

    //
    // UNC name? gota check each time
    //
    if (PathIsUNC(pszPath))
    {
        lstrcpyn(szRoot, pszPath, ARRAYSIZE(szRoot));
        PathStripToRoot(szRoot);

        // Deal with busted kernel UNC stuff
        // Is it a \\foo or a \\foo\bar thing?

        if (StrChr(szRoot+2, TEXT('\\')))
        {
            // "\\foo\bar - Append a slash to be NT compatible.
            lstrcat(szRoot, TEXT("\\"));
        }
        else
        {
            // "\\foo" - assume it's always a LFN volume
            return TRUE;
        }
    }
    //
    // removable media? gota check each time
    //
    else if (IsRemovableDrive(DRIVEID(pszPath)))
    {
        PathBuildRoot(szRoot, DRIVEID(pszPath));
    }
    //
    // fixed media use cached value.
    //
    else
    {
        return CMtPt_IsLFN(DRIVEID(pszPath));
    }

    //
    // Right now we will say that it is an LFN Drive if the maximum
    // component is > 12
    GetVolumeInformation(szRoot, NULL, 0, NULL, &dwMaxLength, NULL, NULL, 0);
    return dwMaxLength > 12;
}


STDAPI_(BOOL) IsLFNDriveA(LPCSTR pszPath)   OPTIONAL
{
    WCHAR wsz[MAX_PATH];

    ASSERT(NULL == pszPath || IS_VALID_STRING_PTRA(pszPath, -1));

    if (pszPath)
    {
        SHAnsiToUnicode(pszPath, wsz, ARRAYSIZE(wsz));
        pszPath = (LPCSTR)wsz;
    }
    return IsLFNDrive((LPCWSTR)pszPath);
}   
 
STDAPI_(BOOL) PathIsRemovable(LPCTSTR pszPath)
{
    BOOL fIsEjectable = FALSE;
    int iDrive = PathGetDriveNumber(pszPath);

    if (iDrive != -1)
    {
        int nType = DriveType(iDrive);

        if ((DRIVE_CDROM == nType) ||
            (DRIVE_DVD == nType) ||
            (DRIVE_REMOVABLE == nType))
        {
            fIsEjectable = TRUE;
        }
    }

    return fIsEjectable;
}

STDAPI_(BOOL) PathIsRemote(LPCTSTR pszPath)
{
    BOOL fIsRemote = FALSE;
    if (PathIsUNC(pszPath))
    {
        fIsRemote = TRUE;
    }
    else
    {
        int iDrive = PathGetDriveNumber(pszPath);

        if (iDrive != -1)
        {
            int nType = DriveType(iDrive);

            if (DRIVE_REMOTE == nType || DRIVE_NO_ROOT_DIR == nType)
            {
                fIsRemote = TRUE;
            }
        }
    }
    return fIsRemote;
}


//----------------------------------------------------------------------------
// The following are creterias we currently use to tell whether a file is a temporary file
// Files with FILE_ATTRIBUTE_TEMPORARY set
// Files in Windows temp directory
// Files from the internet cache directory
// Files in the CD burning area
//---------------------------------------------------------------------------
STDAPI_(BOOL) PathIsTemporary(LPCTSTR pszPath)
{
    BOOL bRet = FALSE;
    DWORD dwAttrib = GetFileAttributes(pszPath);
    if ((-1 != dwAttrib) && (dwAttrib & FILE_ATTRIBUTE_TEMPORARY))
    {
        bRet = TRUE;    // we got the attributes and the file says it is temprary
    }
    else
    {
        TCHAR szTemp[MAX_PATH];
        if (GetTempPath(ARRAYSIZE(szTemp), szTemp))
        {
            // if possible, expand the input to the long path name so we can compare strings
            TCHAR szPath[MAX_PATH];
            if (GetLongPathName(pszPath, szPath, ARRAYSIZE(szPath)))
                pszPath = szPath;

            // GetTempPath() returns short name due to compatibility constraints.  
            // we need to convert to long name
            if (GetLongPathName(szTemp, szTemp, ARRAYSIZE(szTemp)))
            {
                bRet = PathIsEqualOrSubFolder(szTemp, pszPath) || 
                       PathIsEqualOrSubFolder(MAKEINTRESOURCE(CSIDL_INTERNET_CACHE), pszPath) ||
                       PathIsEqualOrSubFolder(MAKEINTRESOURCE(CSIDL_CDBURN_AREA), pszPath);
            }
        }
    }
    return bRet;
}


STDAPI_(BOOL) PathIsTemporaryA(LPCSTR pszPath)
{
    TCHAR szPath[MAX_PATH];
    SHOtherToTChar(pszPath, szPath, ARRAYSIZE(szPath));
    return PathIsTemporary(szPath);
}


// unfortunately, this is exported so we need to support it
STDAPI_(LPTSTR) PathGetExtension(LPCTSTR pszPath, LPTSTR pszExtension, int cchExt)
{
    LPTSTR pszExt = PathFindExtension(pszPath);

    RIPMSG(FALSE, "PathGetExtension should not be called, use PathFindExtension instead");

    if (pszExt && *pszExt)
        pszExt += 1;

    return pszExt;
}

//
// Attempts to truncate the filename pszSpec such that pszDir+pszSpec are less than MAX_PATH-5.
// The extension is protected so it won't get truncated or altered.
//
// in:
//      pszDir      the path to a directory.  No trailing '\' is needed.
//      pszSpec     the filespec to be truncated.  This should not include a path but can have an extension.
//                  This input buffer can be of any length.
//      iTruncLimit The minimum length to truncate pszSpec.  If addition truncation would be required we fail.
// out:
//      pszSpec     The truncated filespec with it's extension unaltered.
// return:
//      TRUE if the filename was truncated, FALSE if we were unable to truncate because the directory name
//      was too long, the extension was too long, or the iTruncLimit is too high.  pszSpec is unaltered
//      when this function returns FALSE.
//
STDAPI_(BOOL) PathTruncateKeepExtension(LPCTSTR pszDir, LPTSTR pszSpec, int iTruncLimit)
{
    LPTSTR pszExt = PathFindExtension(pszSpec);

    RIPMSG(pszDir && IS_VALID_STRING_PTR(pszDir, -1), "PathTruncateKeepExtension: Caller passed bad pszDir");
    RIPMSG(pszSpec && IS_VALID_STRING_PTR(pszSpec, -1) && IS_VALID_WRITE_BUFFER(pszSpec, TCHAR, MAX_PATH), "PathTruncateKeepExtension: Caller passed bad pszSpec");
    DEBUGWhackPathString(pszSpec, MAX_PATH);

    if (pszExt)
    {
        int cchExt = lstrlen(pszExt);
        int cchSpec = (int)(pszExt - pszSpec + cchExt);
        int cchKeep = MAX_PATH - lstrlen(pszDir) - 5;   // the -5 is just to provide extra padding (max lstrlen(pszExt))

        // IF...
        //  ...the filename is to long
        //  ...we are within the limit to which we can truncate
        //  ...the extension is short enough to allow the trunctation
        if ((cchSpec > cchKeep) && (cchKeep >= iTruncLimit) && (cchKeep > cchExt))
        {
            // THEN... go ahead and truncate
            StrCpy(pszSpec+cchKeep-cchExt, pszExt);
            return TRUE;
        }
    }
    return FALSE;
}


STDAPI_(int) PathCleanupSpec(LPCTSTR pszDir, LPTSTR pszSpec)
{
    LPTSTR pszNext, pszCur;
    UINT   uMatch = IsLFNDrive(pszDir) ? GCT_LFNCHAR : GCT_SHORTCHAR;
    int    iRet = 0;
    LPTSTR pszPrevDot = NULL;

    for (pszCur = pszNext = pszSpec; *pszNext; /*pszNext = CharNext(pszNext)*/)
    {
        if (PathGetCharType(*pszNext) & uMatch)
        {
            *pszCur = *pszNext;
            if (uMatch == GCT_SHORTCHAR && *pszCur == TEXT('.'))
            {
                if (pszPrevDot)    // Only one '.' allowed for short names
                {
                    *pszPrevDot = TEXT('-');
                    iRet |= PCS_REPLACEDCHAR;
                }
                pszPrevDot = pszCur;
            }
            if (IsDBCSLeadByte(*pszNext))
            {
                LPTSTR pszDBCSNext;

                pszDBCSNext = CharNext(pszNext);
                *(pszCur + 1) = *(pszNext + 1);
                pszNext = pszDBCSNext;
            }
            else
                pszNext = CharNext(pszNext);
            pszCur = CharNext(pszCur);
        }
        else
        {
            switch (*pszNext)
            {
            case TEXT('/'):         // used often for things like add/remove
            case TEXT(' '):         // blank (only replaced for short name drives)
               *pszCur = TEXT('-');
               pszCur = CharNext(pszCur);
               iRet |= PCS_REPLACEDCHAR;
               break;
            default:
               iRet |= PCS_REMOVEDCHAR;
            }
            pszNext = CharNext(pszNext);
        }
    }
    *pszCur = 0;     // null terminate

    //
    //  For short names, limit to 8.3
    //
    if (uMatch == GCT_SHORTCHAR)
    {
        int i = 8;
        for (pszCur = pszNext = pszSpec; *pszNext; pszNext = CharNext(pszNext))
        {
            if (*pszNext == TEXT('.'))
            {
                i = 4; // Copy "." + 3 more characters
            }
            if (i > 0)
            {
                *pszCur = *pszNext;
                pszCur = CharNext(pszCur);
                i--;
            }
            else
            {
                iRet |= PCS_TRUNCATED;
            }
        }
        *pszCur = 0;
        CharUpperNoDBCS(pszSpec);
    }
    else    // Path too long only possible on LFN drives
    {
        if (pszDir && (lstrlen(pszDir) + lstrlen(pszSpec) > MAX_PATH - 1))
        {
            iRet |= PCS_PATHTOOLONG | PCS_FATAL;
        }
    }
    return iRet;
}


// PathCleanupSpecEx
//
// Just like PathCleanupSpec, PathCleanupSpecEx removes illegal characters from pszSpec
// and enforces 8.3 format on non-LFN drives.  In addition, this function will attempt to
// truncate pszSpec if the combination of pszDir + pszSpec is greater than MAX_PATH.
//
// in:
//      pszDir      The directory in which the filespec pszSpec will reside
//      pszSpec     The filespec that is being cleaned up which includes any extension being used
// out:
//      pszSpec     The modified filespec with illegal characters removed, truncated to
//                  8.3 if pszDir is on a non-LFN drive, and truncated to a shorter number
//                  of characters if pszDir is an LFN drive but pszDir + pszSpec is more
//                  than MAX_PATH characters.
// return:
//      returns a bit mask indicating what happened.  This mask can include the following cases:
//          PCS_REPLACEDCHAR    One or more illegal characters were replaced with legal characters
//          PCS_REMOVEDCHAR     One or more illegal characters were removed
//          PCS_TRUNCATED       Truncated to fit 8.3 format or because pszDir+pszSpec was too long
//          PCS_PATHTOOLONG     pszDir is so long that we cannot truncate pszSpec to form a legal filename
//          PCS_FATAL           The resultant pszDir+pszSpec is not a legal filename.  Always used with PCS_PATHTOOLONG.
//
STDAPI_(int) PathCleanupSpecEx(LPCTSTR pszDir, LPTSTR pszSpec)
{
    int iRet = PathCleanupSpec(pszDir, pszSpec);
    if (iRet & (PCS_PATHTOOLONG | PCS_FATAL))
    {
        // 30 is the shortest we want to truncate pszSpec to to satisfy the
        // pszDir+pszSpec<MAX_PATH requirement.  If this amount of truncation isn't enough
        // then we go ahead and return PCS_PATHTOOLONG|PCS_FATAL without doing any further
        // truncation of pszSpec
        if (PathTruncateKeepExtension(pszDir, pszSpec, 30))
        {
            // We fixed the error returned by PathCleanupSpec so mask out the error.
            iRet |= PCS_TRUNCATED;
            iRet &= ~(PCS_PATHTOOLONG|PCS_FATAL);
        }
    }
    else
    {
        // ensure that if both of these aren't set then neither is set.
        ASSERT(!(iRet&PCS_PATHTOOLONG) && !(iRet&PCS_FATAL));
    }

    return iRet;
}


STDAPI_(BOOL) PathIsWild(LPCTSTR pszPath)
{
    while (*pszPath) 
    {
        if (*pszPath == TEXT('?') || *pszPath == TEXT('*'))
            return TRUE;
        pszPath = CharNext(pszPath);
    }
    return FALSE;
}


// given a path that potentially points to an un-extensioned program
// file, check to see if a program file exists with that name.
//
// returns: TRUE if a program with that name is found.
//               (extension is added to name).
//          FALSE no program file found or the path did not have an extension
//
BOOL LookForExtensions(LPTSTR pszPath, LPCTSTR dirs[], BOOL bPathSearch, UINT fExt)
{
    ASSERT(fExt);       // should have some bits set

    if (*PathFindExtension(pszPath) == 0)
    {
        if (bPathSearch)
        {
            // NB Try every extension on each path component in turn to
            // mimic command.com's search order.
            return PathFindOnPathEx(pszPath, dirs, fExt);
        }
        else
        {
            return PathFileExistsDefExt(pszPath, fExt);
        }
    }
    return FALSE;
}


//
// converts the relative or unqualified path name to the fully
// qualified path name.
//
// If this path is a URL, this function leaves it alone and
// returns FALSE.
//
// in:
//      pszPath        path to convert
//      pszCurrentDir  current directory to use
//
//  PRF_TRYPROGRAMEXTENSIONS (implies PRF_VERIFYEXISTS)
//  PRF_VERIFYEXISTS
//
// returns:
//      TRUE    the file was verified to exist
//      FALSE   the file was not verified to exist (but it may)
//
STDAPI_(BOOL) PathResolve(LPTSTR lpszPath, LPCTSTR dirs[], UINT fFlags)
{
    UINT fExt = (fFlags & PRF_DONTFINDLNK) ? (PFOPEX_COM | PFOPEX_BAT | PFOPEX_PIF | PFOPEX_EXE) : PFOPEX_DEFAULT;

    //
    //  NOTE:  if VERIFY SetLastError() default to FNF.  - ZekeL 9-APR-98
    //  ShellExec uses GLE() to find out why we failed.  
    //  any win32 API that we end up calling
    //  will do a SLE() to overrider ours.  specifically
    //  if VERIFY is set we call GetFileAttributes() 
    //
    if (fFlags & PRF_VERIFYEXISTS)
        SetLastError(ERROR_FILE_NOT_FOUND);
    
    PathUnquoteSpaces(lpszPath);

    if (PathIsRoot(lpszPath))
    {
        // No sense qualifying just a server or share name...
        if (!PathIsUNCServer(lpszPath) && !PathIsUNCServerShare(lpszPath))
        {
            // Be able to resolve "\" from different drives.
            if (lpszPath[0] == TEXT('\\') && lpszPath[1] == 0)
            {
                PathQualifyDef(lpszPath, fFlags & PRF_FIRSTDIRDEF ? dirs[0] : NULL, 0);
            }
        }

        if (fFlags & PRF_VERIFYEXISTS)
        {
            if (PathFileExistsAndAttributes(lpszPath, NULL))
            {
                return(TRUE);
            }
#ifdef DEBUG
            //   PathFileExistsAndAttributes() should catch this well enough.
            // If it is a UNC root, then we will see if the root exists
            //
            if (PathIsUNC(lpszPath))
            {
                // See if the network knows about this one.
                // It appears like some network provider croak if not everything
                // if filled in, so we might as well bloat ourself to make them happy...
                NETRESOURCE nr = {RESOURCE_GLOBALNET,RESOURCETYPE_ANY,
                        RESOURCEDISPLAYTYPE_GENERIC, RESOURCEUSAGE_CONTAINER,
                        NULL, lpszPath, NULL, NULL};
                HANDLE hEnum;

                if (WNetOpenEnum(RESOURCE_GLOBALNET, RESOURCETYPE_ANY,
                        RESOURCEUSAGE_ALL, &nr, &hEnum) == WN_SUCCESS)
                {
                    // If it succeeded then assume it worked...
                    WNetCloseEnum(hEnum);
                    ASSERT(FALSE);
                    return(TRUE);
                }
            }
#endif // DEBUG

            return FALSE;
        }

        return TRUE;
    }
    else if (PathIsFileSpec(lpszPath))
    {

        // REVIEW: look for programs before looking for paths

        if ((fFlags & PRF_TRYPROGRAMEXTENSIONS) && (LookForExtensions(lpszPath, dirs, TRUE, fExt)))
            return TRUE;

        if (PathFindOnPath(lpszPath, dirs))
        {
            // PathFindOnPath() returns TRUE iff PathFileExists(lpszPath),
            // so we always returns true here:
            //return (!(fFlags & PRF_VERIFYEXISTS)) || PathFileExists(lpszPath);
            return TRUE;
        }
    }
    else if (!PathIsURL(lpszPath))
    {
        // If there is a trailing '.', we should not try extensions
        PathQualifyDef(lpszPath, fFlags & PRF_FIRSTDIRDEF ? dirs[0] : NULL,
                PQD_NOSTRIPDOTS);
        if (fFlags & PRF_VERIFYEXISTS)
        {
            if ((fFlags & PRF_TRYPROGRAMEXTENSIONS) && (LookForExtensions(lpszPath, dirs, FALSE, fExt)))
                return TRUE;

            if (PathFileExistsAndAttributes(lpszPath, NULL))
                return TRUE;
        }
        else
        {
            return TRUE;
        }

    }
    return FALSE;
}


// qualify a DOS (or LFN) file name based on the currently active window.
// this code is not careful to not write more than MAX_PATH characters
// into psz
//
// in:
//      psz     path to be qualified of at least MAX_PATH characters
//              ANSI string
//
// out:
//      psz     fully qualified version of input string based
//              on the current active window (current directory)
//

void PathQualifyDef(LPTSTR psz, LPCTSTR szDefDir, DWORD dwFlags)
{
    int cb, nSpaceLeft;
    TCHAR szTemp[MAX_PATH], szRoot[MAX_PATH];
    int iDrive;
    LPTSTR pOrig, pFileName;
    BOOL fLFN;
    LPTSTR pExt;

    RIPMSG(psz && IS_VALID_STRING_PTR(psz, -1) && IS_VALID_WRITE_BUFFER(psz, TCHAR, MAX_PATH), "PathQualifyDef: caller passed bad psz");
    RIPMSG(!szDefDir || (IS_VALID_STRING_PTR(szDefDir, -1) && lstrlen(szDefDir)<MAX_PATH), "PathQualifyDef: caller passed bad szDefDir");
    DEBUGWhackPathString(psz, MAX_PATH);
    
    /* Save it away. */
    lstrcpyn(szTemp, psz, ARRAYSIZE(szTemp));
    
    FixSlashesAndColon(szTemp);
    
    nSpaceLeft = ARRAYSIZE(szTemp);
    
    pOrig = szTemp;
    pFileName = PathFindFileName(szTemp);
    
    if (PathIsUNC(pOrig))
    {
        // leave the \\ in thebuffer so that the various parts
        // of the UNC path will be qualified and appended.  Note
        // we must assume that UNCs are LFN's, since computernames
        // and sharenames can be longer than 11 characters.
        fLFN = IsLFNDrive(pOrig);
        if (fLFN)
        {
            psz[2] = 0;
            nSpaceLeft -= 3;
            pOrig += 2;
            goto GetComps;
        }
        else
        {
            // NB UNC doesn't support LFN's but we don't want to truncate
            // \\foo or \\foo\bar so skip them here.
            
            // Is it a \\foo\bar\fred thing?
            LPTSTR pszSlash = StrChr(psz+2, TEXT('\\'));
            if (pszSlash && (NULL != (pszSlash = StrChr(pszSlash+1, TEXT('\\')))))
            {
                // Yep - skip the first bits but mush the rest.
                *(pszSlash+1) = 0;
                nSpaceLeft -= (int)(pszSlash-psz)+1;
                pOrig += pszSlash-psz;
                goto GetComps;
            }
            else
            {
                // Nope - just pretend it's an LFN and leave it alone.
                fLFN = TRUE;
                psz[2] = 0;
                nSpaceLeft -= 2;
                pOrig+=2;
                goto GetComps;
            }
        }
    }
    
    iDrive = PathGetDriveNumber(pOrig);
    if (iDrive != -1)
    {
        PathBuildRoot(szRoot, iDrive);    // root specified by the file name
        
        ASSERT(pOrig[1] == TEXT(':'));    // PathGetDriveNumber does this
        
        pOrig += 2;   // Skip over the drive letter
        
        // and the slash if it is there...
        if (pOrig[0] == TEXT('\\'))
            pOrig++;
    }
    else
    {
        if (szDefDir)
            lstrcpyn(szRoot, szDefDir, ARRAYSIZE(szRoot));
        else
        {
            //
            // As a default, use the windows drive (usually "C:\").
            //
            *szRoot = 0;
            GetWindowsDirectory(szRoot, ARRAYSIZE(szRoot));
            iDrive = PathGetDriveNumber(szRoot);
            if (iDrive != -1)
            {
                PathBuildRoot(szRoot, iDrive);
            }
        }
        
        // if path is scopped to the root with "\" use working dir root
        
        if (pOrig[0] == TEXT('\\'))
            PathStripToRoot(szRoot);
    }
    fLFN = IsLFNDrive(szRoot);
    
    // REVIEW, do we really need to do different stuff on LFN names here?
    // on FAT devices, replace any illegal chars with underscores
    if (!fLFN)
    {
        LPTSTR pT;
        for (pT = pOrig; *pT; pT = CharNext(pT))
        {
            if (!PathIsValidChar(*pT, PIVC_SFN_FULLPATH))
            {
                // not a valid sfn path character
                *pT = TEXT('_');
            }
        }
    }
    
    lstrcpy(psz, szRoot);
    nSpaceLeft -= (lstrlen(psz) + 1);
    
GetComps:
    
    while (*pOrig && nSpaceLeft > 0)
    {
        // If the component 0is parent dir, go up one dir.
        // If its the current dir, skip it, else add it normally
        if (pOrig[0] == TEXT('.'))
        {
            if (pOrig[1] == TEXT('.') && (!pOrig[2] || pOrig[2] == TEXT('\\')))
                PathRemoveFileSpec(psz);
            else if (pOrig[1] && pOrig[1] != TEXT('\\'))
                goto addcomponent;
            
            while (*pOrig && *pOrig != TEXT('\\'))
                pOrig = CharNext(pOrig);
            
            if (*pOrig)
                pOrig++;
        }
        else
        {
            LPTSTR pT, pTT = NULL;
            
addcomponent:
            PathAddBackslash(psz);
            nSpaceLeft--;
            
            pT = psz + lstrlen(psz);
            
            if (fLFN)
            {
                // copy the component
                while (*pOrig && *pOrig != TEXT('\\') && nSpaceLeft>0)
                {
                    nSpaceLeft--;
                    if (IsDBCSLeadByte(*pOrig))
                    {
                        if (nSpaceLeft <= 0)
                        {
                            // Copy nothing more
                            continue;
                        }
                        
                        nSpaceLeft--;
                        *pT++ = *pOrig++;
                    }
                    *pT++ = *pOrig++;
                }
            }
            else
            {
                // copy the filename (up to 8 chars)
                for (cb = 8; *pOrig && !IsPathSep(*pOrig) && *pOrig != TEXT('.') && nSpaceLeft > 0;)
                {
                    if (cb > 0)
                    {
                        cb--;
                        nSpaceLeft--;
                        if (IsDBCSLeadByte(*pOrig))
                        {
                            if (nSpaceLeft<=0 || cb<=0)
                            {
                                // Copy nothing more
                                cb = 0;
                                continue;
                            }
                            
                            cb--;
                            nSpaceLeft--;
                            *pT++ = *pOrig++;
                        }
                        *pT++ = *pOrig++;
                    }
                    else
                    {
                        pOrig = CharNext(pOrig);
                    }
                }
                
                // if there's an extension, copy it, up to 3 chars
                if (*pOrig == TEXT('.') && nSpaceLeft > 0)
                {
                    int nOldSpaceLeft;
                    
                    *pT++ = TEXT('.');
                    nSpaceLeft--;
                    pOrig++;
                    pExt = pT;
                    nOldSpaceLeft = nSpaceLeft;
                    
                    for (cb = 3; *pOrig && *pOrig != TEXT('\\') && nSpaceLeft > 0;)
                    {
                        if (*pOrig == TEXT('.'))
                        {
                            // Another extension, start again.
                            cb = 3;
                            pT = pExt;
                            nSpaceLeft = nOldSpaceLeft;
                            pOrig++;
                        }
                        
                        if (cb > 0)
                        {
                            cb--;
                            nSpaceLeft--;
                            if (IsDBCSLeadByte(*pOrig))
                            {
                                if (nSpaceLeft<=0 || cb<=0)
                                {
                                    // Copy nothing more
                                    cb = 0;
                                    continue;
                                }
                                
                                cb--;
                                nSpaceLeft--;
                                *pT++ = *pOrig++;
                            }
                            *pT++ = *pOrig++;
                        }
                        else
                        {
                            pOrig = CharNext(pOrig);
                        }
                    }
                }
            }
            
            // skip the backslash
            
            if (*pOrig)
                pOrig++;
            
            // null terminate for next pass...
            *pT = 0;
        }
    }
    
    PathRemoveBackslash(psz);
    
    if (!(dwFlags & PQD_NOSTRIPDOTS))
    {
        // remove any trailing dots
        
        LPTSTR pszPrev = CharPrev(psz, psz + lstrlen(psz));
        if (*pszPrev == TEXT('.'))
        {
            *pszPrev = 0;
        }
    }
}

STDAPI_(void) PathQualify(LPTSTR psz)
{
    PathQualifyDef(psz, NULL, 0);
}

BOOL OnExtList(LPCTSTR pszExtList, LPCTSTR pszExt)
{
    for (; *pszExtList; pszExtList += lstrlen(pszExtList) + 1)
    {
        if (!lstrcmpi(pszExt, pszExtList))
        {
            // yes
            return TRUE;        
        }
    }

    return FALSE;
}

// Character offset where binary exe extensions begin in above
#define BINARY_EXE_OFFSET 20
const TCHAR c_achExes[] = TEXT(".cmd\0.bat\0.pif\0.scf\0.exe\0.com\0.scr\0");

STDAPI_(BOOL) PathIsBinaryExe(LPCTSTR szFile)
{
    ASSERT(BINARY_EXE_OFFSET < ARRAYSIZE(c_achExes) &&
           c_achExes[BINARY_EXE_OFFSET] == TEXT('.'));

    return OnExtList(c_achExes + BINARY_EXE_OFFSET, PathFindExtension(szFile));
}


//
// determine if a path is a program by looking at the extension
//
STDAPI_(BOOL) PathIsExe(LPCTSTR szFile)
{
    LPCTSTR temp = PathFindExtension(szFile);
    return OnExtList(c_achExes, temp);
}

//
// determine if a path is a .lnk file by looking at the extension
//
STDAPI_(BOOL) PathIsLnk(LPCTSTR szFile)
{
    if (szFile)
    {
        // Both PathFindExtension() and lstrcmpi() will crash
        // if passed NULL.  PathFindExtension() will never return
        // NULL.
        LPCTSTR lpszFileName = PathFindExtension(szFile);
        return lstrcmpi(TEXT(".lnk"), lpszFileName) == 0;
    }
    else
    {
        return FALSE;
    }
}

// Port names are invalid path names

#define IsDigit(c) ((c) >= TEXT('0') && c <= TEXT('9'))
STDAPI_(BOOL) PathIsInvalid(LPCWSTR pszName)
{
    static const TCHAR *rgszPorts3[] =  { 
        TEXT("NUL"),
        TEXT("PRN"),
        TEXT("CON"),
        TEXT("AUX"),
    };

    static const TCHAR *rgszPorts4[] =  { 
        TEXT("LPT"),  // LPT#
        TEXT("COM"),  // COM#
    };

    TCHAR sz[7];
    DWORD cch;
    int iMax;
    LPCTSTR* rgszPorts;
    
    StrCpyN(sz, pszName, ARRAYSIZE(sz));

    PathRemoveExtension(sz);
    cch = lstrlen(sz);

    iMax = ARRAYSIZE(rgszPorts3);
    rgszPorts = rgszPorts3;
    if (cch == 4 && IsDigit(sz[3]))
    {
        //  if 4 chars start with LPT checks
        //  need to filter out:
        //      COM1, COM2, etc.  LPT1, LPT2, etc
        //  but not:
        //      COM or LPT or LPT10 or COM10
        //  COM == 1 and LPT == 0

        iMax = ARRAYSIZE(rgszPorts4);
        rgszPorts = rgszPorts4;
        sz[3] = 0;
        cch = 3;
    }

    if (cch == 3)
    {
        int i;
        for (i = 0; i < iMax; i++)
        {
            if (!lstrcmpi(rgszPorts[i], sz))
            {
                break;
            }
        }
        return (i == iMax) ? FALSE : TRUE;
    }
    return FALSE;
}


//
// Funciton: PathMakeUniqueName
//
// Parameters:
//  pszUniqueName -- Specify the buffer where the unique name should be copied
//  cchMax        -- Specify the size of the buffer
//  pszTemplate   -- Specify the base name
//  pszLongPlate  -- Specify the base name for a LFN drive. format below
//  pszDir        -- Specify the directory (at most MAX_PATH in length)
//
// History:
//  03-11-93    SatoNa      Created
//
// REVIEW:
//  For long names, we should be able to generate more user friendly name
//  such as "Copy of MyDocument" of "Link #2 to MyDocument". In this case,
//  we need additional flags which indicates if it is copy, or link.
//
// Format:
// pszLongPlate will search for the first (and then finds the matching)
// to look for a number:
//    given:  Copy () of my doc       gives:  Copy (_number_) of my doc
//    given:  Copy (1023) of my doc   gives:  Copy (_number_) of my doc
//
// PERF: if making n unique names, the time grows n^2 because it always
// starts from 0 and checks for existing file.
//
STDAPI_(BOOL) PathMakeUniqueNameEx(LPTSTR pszUniqueName, UINT cchMax,
                                   LPCTSTR pszTemplate, LPCTSTR pszLongPlate, LPCTSTR pszDir, int iMinLong)
{
    TCHAR szFormat[MAX_PATH]; // should be plenty big
    LPTSTR pszName, pszDigit;
    LPCTSTR pszStem;
    int cchStem, cchDir;
    int iMax, iMin, i;
    int cchMaxName;

    RIPMSG(pszUniqueName && IS_VALID_WRITE_BUFFER(pszUniqueName, TCHAR, cchMax), "PathMakeUniqueNameEx: caller passed bad pszUniqueName");
    DEBUGWhackPathBuffer(pszUniqueName, cchMax);
    RIPMSG(!pszDir || lstrlen(pszDir)<MAX_PATH, "PathMakeUniqueNameEx: pszDir exceeds MAX_PATH, helper routines don't take cch so this call is broken");
    RIPMSG(iMinLong >= 0, "PathMakeUniqueNameEx: negative iMinLong doesn't make sense");

    if (0==cchMax || !pszUniqueName)
        return FALSE;
    *pszUniqueName = 0; // just in case of failure

    if (pszLongPlate == NULL)
        pszLongPlate = pszTemplate;

    // all cases below check the length of optional pszDir, calculate early.
    // side effect: this set's up pszName and the directory portion of pszUniqueName;
    if (pszDir)
    {
        cchDir = lstrlen(pszDir);
        if ((UINT)cchDir >= cchMax-2) // -2 to allow for NULL and '\' of PathAddBackslash
            return FALSE;
        lstrcpy(pszUniqueName, pszDir);
        pszName = PathAddBackslash(pszUniqueName);
        cchDir = lstrlen(pszDir); // we need an accurate count
    }
    else
    {
        cchDir = 0;
        pszName = pszUniqueName;
    }

    // Set up:
    //   pszStem    : template we're going to use
    //   cchStem    : length of pszStem we're going to use w/o wsprintf
    //   szFormat   : format string to wsprintf the number with, catenates on to pszStem[0..cchStem]
    //   iMin       : starting number for wsprintf loop
    //   iMax       : maximum number for wsprintf loop
    //   cchMaxname : !0 implies -> if resulting name length > cchMaxname, then --cchStem (only used in short name case)
    //
    if (pszLongPlate && IsLFNDrive(pszDir))
    {
        LPCTSTR pszRest;
        int cchTmp;

        cchMaxName = 0;

        // for long name drives
        pszStem = pszLongPlate;

        // Has this already been a uniquified name?
        pszRest = StrChr(pszLongPlate, TEXT('('));
        while (pszRest)
        {
            // First validate that this is the right one
            LPCTSTR pszEndUniq = CharNext(pszRest);
            while (*pszEndUniq && *pszEndUniq >= TEXT('0') && *pszEndUniq <= TEXT('9')) {
                pszEndUniq++;
            }
            if (*pszEndUniq == TEXT(')'))
                break;  // We have the right one!
            pszRest = StrChr(CharNext(pszRest), TEXT('('));
        }

        if (!pszRest)
        {
            // Never been unique'd before -- tack it on at the end. (but before the extension)
            // eg.  New Link yields New Link (1)
            pszRest = PathFindExtension(pszLongPlate);
            cchStem = (int)(pszRest - pszLongPlate);

            wnsprintf(szFormat, ARRAYSIZE(szFormat), TEXT(" (%%d)%s"), pszRest ? pszRest : c_szNULL);
        }
        else
        {
            // we found (#), so remove the #
            // eg.  New Link (999) yields  New Link (1)

            pszRest++; // step over the '('

            cchStem = (int) (pszRest - pszLongPlate);

            // eat the '#'
            while (*pszRest && *pszRest >= TEXT('0') && *pszRest <= TEXT('9')) {
                pszRest++;
            }

            // we are guaranteed enough room because we don't include
            // the stuff before the # in this format
            wnsprintf(szFormat, ARRAYSIZE(szFormat), TEXT("%%d%s"), pszRest);
        }

        // how much room do we have to play?
        iMin = iMinLong;
        cchTmp = cchMax - cchDir - cchStem - (lstrlen(szFormat)-2); // -2 for "%d" which will be replaced
        switch(cchTmp)
        {
            case 1:
                iMax = 10;
                break;
            case 2:
                iMax = 100;
                break;
            default:
                if (cchTmp <= 0)
                    iMax = iMin; // no room, bail
                else
                    iMax = 1000;
                break;
        }
    }
    else // short filename case
    {
        LPCTSTR pszRest;
        int cchRest;
        int cchFormat;

        if (pszTemplate == NULL)
            return FALSE;

        // for short name drives
        pszStem = pszTemplate;
        pszRest = PathFindExtension(pszTemplate);

        // Calculate cchMaxName, ensuring our base name (cchStem+digits) will never go over 8
        //
        cchRest=lstrlen(pszRest);
        cchMaxName = 8+cchRest;

        // Now that we have the extension, we know the format string
        //
        wnsprintf(szFormat, ARRAYSIZE(szFormat), TEXT("%%d%s"), pszRest);
        ASSERT(lstrlen(szFormat)-2 == cchRest); // -2 for "%d" in format string
        cchFormat = cchRest;

        // Figure out how long the stem really is:
        //
        cchStem = (int)(pszRest-pszTemplate);        // 8 for "fooobarr.foo"

        // Remove all the digit characters (previous uniquifying) from the stem
        //
        for(; cchStem > 1 ; cchStem--)
        {
            TCHAR ch;

            LPCTSTR pszPrev = CharPrev(pszTemplate, pszTemplate + cchStem);
            // Don't remove if it is a DBCS character
            if (pszPrev != pszTemplate+cchStem-1)
                break;

            // Don't remove it it is not a digit
            ch=pszPrev[0];
            if (ch<TEXT('0') || ch>TEXT('9'))
                break;
        }

        // Short file names mean we use the 8.3 rule, so the stem can't be > 8...
        //
        if ((UINT)cchStem > 8-1)
            cchStem = 8-1;  // need 1 for a digit

        // Truncate the stem to make it fit when we take the directory path into consideration
        //
        while ((cchStem + cchFormat + cchDir + 1 > (int)cchMax - 1) && (cchStem > 1)) // -1 for NULL, +1 for a digit
            cchStem--;

        // We've allowed for 1 character of digit space, but...
        // How many digits can we really use?
        //
        iMin = 1;
        if (cchStem < 1) 
            iMax = iMin; // NONE!
        else if (1 == cchStem)
            iMax = 10; // There's only 1 character of stem left, so use digits 0-9
        else
            iMax = 100; // Room for stem and digits 0-99
    }

    // pszUniqueName has the optional directory in it,
    // pszName points into pszUniqueName where the stem goes,
    // now try to find a unique name!
    //
    lstrcpyn(pszName, pszStem, cchStem+1);
    pszDigit = pszName + cchStem;

    for (i = iMin; i < iMax ; i++)
    {
        wsprintf(pszDigit, szFormat, i);

        //
        // if we have a limit on the length of the name (ie on a non-LFN drive)
        // backup the pszDigit pointer when i wraps from 9to10 and 99to100 etc
        //
        if (cchMaxName && lstrlen(pszName) > cchMaxName)
        {
            pszDigit = CharPrev(pszName, pszDigit);
            wsprintf(pszDigit, szFormat, i);
        }

        TraceMsg(TF_PATH, "PathMakeUniqueNameEx: trying %s", (LPCTSTR)pszUniqueName);

        //
        // Check if this name is unique or not.
        //
        if (!PathFileExists(pszUniqueName))
        {
            return TRUE;
        }
    }

    *pszUniqueName = 0; // we failed, clear out our last attempt

    return FALSE;
}

STDAPI_(BOOL) PathMakeUniqueName(LPTSTR pszUniqueName, UINT cchMax, 
                                 LPCTSTR pszTemplate, LPCTSTR pszLongPlate, LPCTSTR pszDir)
{
    return PathMakeUniqueNameEx(pszUniqueName, cchMax, pszTemplate, pszLongPlate, pszDir, 1);
}


// in:
//      pszPath         directory to do this into or full dest path
//                      if pszShort is NULL
//      pszShort        file name (short version) if NULL assumes
//                      pszPath is both path and spec
//      pszFileSpec     file name (long version)
//
// out:
//      pszUniqueName
//
// note:
//      pszUniqueName can be the same buffer as pszPath or pszShort or pszFileSpec
//
// returns:
//      TRUE    success, name can be used

STDAPI_(BOOL) PathYetAnotherMakeUniqueName(LPTSTR pszUniqueName, LPCTSTR pszPath, LPCTSTR pszShort, LPCTSTR pszFileSpec)
{
    BOOL fRet = FALSE;

    TCHAR szTemp[MAX_PATH];
    TCHAR szPath[MAX_PATH];

    RIPMSG(pszPath && IS_VALID_STRING_PTR(pszPath, -1) && lstrlen(pszPath)<MAX_PATH-1, "PathYetAnotherMakeUniqueName: caller passed invalid pszPath");
    RIPMSG(!pszShort || IS_VALID_STRING_PTR(pszShort, -1), "PathYetAnotherMakeUniqueName: caller passed invalid pszShort");
    RIPMSG(!pszFileSpec || (IS_VALID_STRING_PTR(pszFileSpec, -1) && lstrlen(pszPath)+lstrlen(pszFileSpec)<MAX_PATH-2), "PathYetAnotherMakeUniqueName: caller passed invalid pszFileSpec");
    RIPMSG(pszUniqueName && IS_VALID_WRITE_BUFFER(pszUniqueName, TCHAR, MAX_PATH), "PathYetAnotherMakeUniqueName: caller passed invalid pszUniqueName");
#ifdef DEBUG
    if (pszUniqueName == pszPath || pszUniqueName == pszShort || pszUniqueName == pszFileSpec)
        DEBUGWhackPathString(pszUniqueName, MAX_PATH);
    else
        DEBUGWhackPathBuffer(pszUniqueName, MAX_PATH);
#endif

    if (pszShort == NULL)
    {
        pszShort = PathFindFileName(pszPath);
        lstrcpy(szPath, pszPath);
        PathRemoveFileSpec(szPath);
        pszPath = szPath;
    }
    if (pszFileSpec == NULL)
    {
        pszFileSpec = pszShort;
    }

    if (IsLFNDrive(pszPath))
    {
        LPTSTR lpsz;
        LPTSTR lpszNew;

        // REVIEW:  If the path+filename is too long how about this, instead of bailing out we trunctate the name
        // using my new PathTruncateKeepExtension?  Currently we have many places where the return result of this
        // function is not checked which cause failures in abserdly long filename cases.  The result ends up having
        // the wrong path which screws things up.
        if ((lstrlen(pszPath) + lstrlen(pszFileSpec) + 5) > MAX_PATH)
            return FALSE;

        // try it without the (if there's a space after it
        lpsz = StrChr(pszFileSpec, TEXT('('));
        while (lpsz)
        {
            if (*(CharNext(lpsz)) == TEXT(')'))
                break;
             lpsz = StrChr(CharNext(lpsz), TEXT('('));
        }

        if (lpsz)
        {
            // We have the ().  See if we have either x () y or x ().y in which case
            // we probably want to get rid of one of the blanks...
            int ichSkip = 2;
            LPTSTR lpszT = CharPrev(pszFileSpec, lpsz);
            if (*lpszT == TEXT(' '))
            {
                ichSkip = 3;
                lpsz = lpszT;
            }

            lstrcpy(szTemp, pszPath);
            lpszNew = PathAddBackslash(szTemp);
            lstrcpy(lpszNew, pszFileSpec);
            lpszNew += (lpsz - pszFileSpec);
            lstrcpy(lpszNew, lpsz + ichSkip);
            fRet = !PathFileExists(szTemp);
        }
        else
        {
            // 1taro registers its document with '/'.
            if (lpsz = StrChr(pszFileSpec, '/'))
            {
                LPTSTR lpszT = CharNext(lpsz);
                lstrcpy(szTemp, pszPath);
                lpszNew = PathAddBackslash(szTemp);
                lstrcpy(lpszNew, pszFileSpec);
                lpszNew += (lpsz - pszFileSpec);
                lstrcpy(lpszNew, lpszT);
            }
            else
            {
                PathCombine(szTemp, pszPath, pszFileSpec);
            }
            fRet = !PathFileExists(szTemp);
        }
    }
    else
    {
        ASSERT(lstrlen(PathFindExtension(pszShort)) <= 4);

        lstrcpy(szTemp,pszShort);
        PathRemoveExtension(szTemp);

        if (lstrlen(szTemp) <= 8)
        {
            PathCombine(szTemp, pszPath, pszShort);
            fRet = !PathFileExists(szTemp);
        }
    }

    if (!fRet)
    {
        fRet =  PathMakeUniqueNameEx(szTemp, ARRAYSIZE(szTemp), pszShort, pszFileSpec, pszPath, 2);
        PathCombine(szTemp, pszPath, szTemp);
    }

    if (fRet)
        lstrcpy(pszUniqueName, szTemp);

    return fRet;
}
STDAPI_(void) PathGetShortPath(LPTSTR pszLongPath)
{
    TCHAR szShortPath[MAX_PATH];

    RIPMSG(pszLongPath && IS_VALID_STRING_PTR(pszLongPath, -1) && IS_VALID_WRITE_BUFFER(pszLongPath, TCHAR, MAX_PATH), "PathGetShortPath: caller passed invalid pszLongPath");
    DEBUGWhackPathString(pszLongPath, MAX_PATH);

    if (GetShortPathName(pszLongPath, szShortPath, ARRAYSIZE(szShortPath)))
        lstrcpy(pszLongPath, szShortPath);
}


//
//  pszFile    -- file path
//  dwFileAttr -- The file attributes, pass -1 if not available
//
//  Note: pszFile arg may be NULL if dwFileAttr != -1.

BOOL PathIsHighLatency(LPCTSTR pszFile /*optional*/, DWORD dwFileAttr)
{
    BOOL bRet = FALSE;
    if (dwFileAttr == -1)
    {
        ASSERT(pszFile != NULL) ;
        dwFileAttr = pszFile ? GetFileAttributes(pszFile) : -1;
    }
    
    if ((dwFileAttr != -1) && (dwFileAttr & FILE_ATTRIBUTE_OFFLINE))
    {
        bRet = TRUE;
    }

    return bRet;
}

//
//  is a path slow or not
//  dwFileAttr -- The file attributes, pass -1 if not available
//
STDAPI_(BOOL) PathIsSlow(LPCTSTR pszFile, DWORD dwFileAttr)
{
    BOOL bSlow = FALSE;
    if (PathIsUNC(pszFile))
    {
        DWORD speed = GetPathSpeed(pszFile);
        bSlow = (speed != 0) && (speed <= SPEED_SLOW);
    }
    else if (CMtPt_IsSlow(PathGetDriveNumber(pszFile)))
        bSlow = TRUE;

    if (!bSlow)
        bSlow = PathIsHighLatency(pszFile, dwFileAttr);

    return bSlow;
}

STDAPI_(BOOL) PathIsSlowA(LPCSTR pszFile, DWORD dwFileAttr)
{
    WCHAR szBuffer[MAX_PATH];

    SHAnsiToUnicode(pszFile, szBuffer, ARRAYSIZE(szBuffer));
    return PathIsSlowW(szBuffer, dwFileAttr);
}

/*----------------------------------------------------------------------------
/ Purpose:
/   Process the specified command line and generate a suitably quoted
/   name, with arguments attached if required.
/
/ Notes:
/   - The destination buffer size can be determined if NULL is passed as a
/     destination pointer.
/   - If the source string is quoted then we assume that it exists on the
/     filing system.
/
/ In:
/   lpSrc -> null terminate source path
/   lpDest -> destination buffer / = NULL to return buffer size
/   iMax = maximum number of characters to return into destination
/   dwFlags =
/       PPCF_ADDQUOTES         = 1 => if path requires quotes then add them
/       PPCF_ADDARGUMENTS      = 1 => append trailing arguments to resulting string (forces ADDQUOTES)
/       PPCF_NODIRECTORIES     = 1 => don't match against directories, only file objects
/       PPCF_NORELATIVEOBJECTQUALIFY = 1 => locate relative objects and return the full qualified path
/       PPCF_LONGESTPOSSIBLE   = 1 => always choose the longest possible executable name ex: d:\program files\fun.exe vs. d:\program.exe
/ Out:
/   > 0 if the call works
/   < 0 if the call fails (object not found, buffer too small for resulting string)
/----------------------------------------------------------------------------*/

STDAPI_(LONG) PathProcessCommand(LPCTSTR lpSrc, LPTSTR lpDest, int iDestMax, DWORD dwFlags)
{
    TCHAR szName[MAX_PATH];
    TCHAR szLastChoice[MAX_PATH];

    LPTSTR lpBuffer, lpBuffer2;
    LPCTSTR lpArgs = NULL;
    DWORD dwAttrib;
    LONG i, iTotal;
    LONG iResult = -1;
    BOOL bAddQuotes = FALSE;
    BOOL bQualify = FALSE;
    BOOL bFound = FALSE;
    BOOL bHitSpace = FALSE;
    BOOL bRelative = FALSE;
    LONG iLastChoice = 0;

    RIPMSG(lpSrc && IS_VALID_STRING_PTR(lpSrc, -1), "PathProcessCommand: caller passed invalid lpSrc");
    RIPMSG(!lpDest || (iDestMax > 0 && IS_VALID_WRITE_BUFFER(lpDest, TCHAR, iDestMax)), "PathProcessCommand: caller passed invalid lpDest,iDestMax");

    // Process the given source string, attempting to find what is that path, and what is its
    // arguments.

    if (lpSrc)
    {
        // Extract the sub string, if its is realative then resolve (if required).

        if (*lpSrc == TEXT('\"'))
        {
            for (lpSrc++, i=0 ; i<MAX_PATH && *lpSrc && *lpSrc!=TEXT('\"') ; i++, lpSrc++)
                szName[i] = *lpSrc;

            szName[i] = 0;

            if (*lpSrc)
                lpArgs = lpSrc+1;

            if (((dwFlags & PPCF_FORCEQUALIFY) || PathIsRelative(szName))
                    && !(dwFlags & PPCF_NORELATIVEOBJECTQUALIFY))
            {
                if (!PathResolve(szName, NULL, PRF_TRYPROGRAMEXTENSIONS))
                    goto exit_gracefully;
            }

            bFound = TRUE;
        }
        else
        {
            // Is this a relative object, and then take each element upto a seperator
            // and see if we hit an file system object.  If not then we can

            bRelative = PathIsRelative(lpSrc);
            if (bRelative)
                dwFlags &= ~PPCF_LONGESTPOSSIBLE;
            
            bQualify = bRelative || ((dwFlags & PPCF_FORCEQUALIFY) != 0);

            for (i=0; i < MAX_PATH; i++)
            {
                szName[i] = lpSrc[i];

                // If we hit a space then the string either contains a LFN or we have
                // some arguments.  Therefore attempt to get the attributes for the string
                // we have so far, if we are unable to then we can continue
                // checking, if we hit then we know that the object exists and the
                // trailing string are its arguments.

                if (!szName[i] || szName[i] == TEXT(' '))
                {
                    szName[i] = 0;
                    if (!bQualify || PathResolve(szName, NULL, PRF_TRYPROGRAMEXTENSIONS))
                    {
                        dwAttrib = GetFileAttributes(szName);

                        if ((dwAttrib != -1) && (! ((dwAttrib & FILE_ATTRIBUTE_DIRECTORY) && (dwFlags & PPCF_NODIRECTORIES))))
                        {
                            if (bQualify && (dwFlags & PPCF_NORELATIVEOBJECTQUALIFY))
                                *lstrcpyn(szName, lpSrc, i) = TEXT(' ');

                            bFound = TRUE;                  // success
                            lpArgs = &lpSrc[i];
                        
                            if (dwFlags & PPCF_LONGESTPOSSIBLE)
                            {
                                lstrcpyn(szLastChoice, szName, i+1);
                                iLastChoice = i;
                            }
                            else
                                goto exit_gracefully;
                        }
                    }

                    if (bQualify)
                        memcpy(szName, lpSrc, (i+1)*sizeof(TCHAR));
                    else
                        szName[i]=lpSrc[i];

                    bHitSpace = TRUE;
                }

                if (!szName[i])
                    break;
            }
        }
    }

exit_gracefully:

    // Work out how big the temporary buffer should be, allocate it and
    // build the returning string into it.  Then compose the string
    // to be returned.

    if (bFound)
    {
        if ((dwFlags & PPCF_LONGESTPOSSIBLE) && iLastChoice)
        {
            lstrcpyn(szName, szLastChoice, iLastChoice+1);
            lpArgs = &lpSrc[iLastChoice];
        }
        
        if (StrChr(szName, TEXT(' ')))
            bAddQuotes = dwFlags & PPCF_ADDQUOTES;

        iTotal  = lstrlen(szName) + 1;                // for terminator
        iTotal += bAddQuotes ? 2 : 0;
        iTotal += (dwFlags & PPCF_ADDARGUMENTS) && lpArgs ? lstrlen(lpArgs) : 0;

        if (lpDest)
        {
            if (iTotal <= iDestMax)
            {
                lpBuffer = lpBuffer2 = (LPTSTR)LocalAlloc(LPTR, sizeof(TCHAR) * iTotal);

                if (lpBuffer)
                {
                    // First quote if required
                    if (bAddQuotes)
                        *lpBuffer2++ = TEXT('\"');

                    // Matching name
                    lstrcpy(lpBuffer2, szName);

                    // Closing quote if required
                    if (bAddQuotes)
                        lstrcat(lpBuffer2, TEXT("\""));

                    // Arguments (if requested)
                    if ((dwFlags & PPCF_ADDARGUMENTS) && lpArgs)
                        lstrcat(lpBuffer2, lpArgs);

                    // Then copy into callers buffer, and free out temporary buffer
                    lstrcpy(lpDest, lpBuffer);
                    LocalFree((HGLOBAL)lpBuffer);

                    // Return the length of the resulting string
                    iResult = iTotal;
                }
            }
        }
        else
        {
            // Resulting string is this big, although nothing returned (allows them to allocate a buffer)
            iResult = iTotal;
        }
    }

    return iResult;
}


// Gets the mounting point for the path passed in
//
// Return Value: TRUE:  means that we found mountpoint, e.g. c:\ or c:\hostfolder\
//               FALSE: for now means that the path is UNC or buffer too small
//
//           Mounted volume                                 Returned Path
//
//      Passed in E:\MountPoint\path 1\path 2
// C:\ as E:\MountPoint                                 E:\MountPoint
//
//      Passed in E:\MountPoint\MountInter\path 1
// C:\ as D:\MountInter and D:\ as E:\MountPoint        E:\MountPoint\MountInter
//
//      Passed in E:\MountPoint\MountInter\path 1
// No mount                                             E:\ 
BOOL PathGetMountPointFromPath(LPCTSTR pcszPath, LPTSTR pszMountPoint, int cchMountPoint)
{
    BOOL bRet = FALSE;

    RIPMSG(pcszPath && IS_VALID_STRING_PTR(pcszPath, -1), "PathGetMountPointFromPath: caller passed invalid pcszPath");
    RIPMSG(pszMountPoint && cchMountPoint >= 0 && IS_VALID_WRITE_BUFFER(pszMountPoint, TCHAR, cchMountPoint), "PathGetMountPointFromPath: caller passed invalid pszMountPoint, cchMountPoint");

    if (!PathIsUNC(pcszPath) && (cchMountPoint >= lstrlen(pcszPath) + 1))
    {
        lstrcpy(pszMountPoint, pcszPath);

        // Is this only 'c:' or 'c:\'
        if (lstrlen(pcszPath) > 3)
        {
            //no
            LPTSTR pszNextComp = NULL;
            LPTSTR pszBestChoice = NULL;
            TCHAR cTmpChar;

            PathAddBackslash(pszMountPoint);
            //skip the first one, e.g. c:\ 
            pszBestChoice = pszNextComp = PathFindNextComponent(pszMountPoint);
            pszNextComp = PathFindNextComponent(pszNextComp);
            while (pszNextComp)
            {
                cTmpChar = *pszNextComp;
                *pszNextComp = 0;

                if (GetVolumeInformation(pszMountPoint, NULL, 0, NULL, NULL, NULL, NULL, 0))
                {//found something better than previous shorter path
                    pszBestChoice = pszNextComp;
                }

                *pszNextComp = cTmpChar;
                pszNextComp = PathFindNextComponent(pszNextComp);
            }

            *pszBestChoice = 0;
        }
        bRet = TRUE;
    }
    else
        *pszMountPoint = 0;

    return bRet;
}


// Returns TRUE if the path is a shortcut to an installed program that can
// be found under Add/Remvoe Programs 
// The current algorithm is just to make sure the target is an exe and is
// located under "program files"

STDAPI_(BOOL) PathIsShortcutToProgram(LPCTSTR pszFile)
{
    BOOL bRet = FALSE;
    if (PathIsShortcut(pszFile, -1))
    {
        TCHAR szTarget[MAX_PATH];
        HRESULT hr = GetPathFromLinkFile(pszFile, szTarget, ARRAYSIZE(szTarget));
        if (hr == S_OK)
        {
            if (PathIsExe(szTarget))
            {
                BOOL bSpecialApp = FALSE;
                HKEY hkeySystemPrograms = NULL;
                if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\App Management\\System Programs"), 
                    0, KEY_READ, &hkeySystemPrograms))
                {
                    TCHAR szValue[MAX_PATH];
                    TCHAR szSystemPrograms[MAX_PATH];
                    DWORD cbSystemPrograms = sizeof(szSystemPrograms);
                    DWORD cchValue = ARRAYSIZE(szValue);

                    DWORD dwType; 
                    LPTSTR pszFileName = PathFindFileName(szTarget);
                    int iValue = 0;
                    while (RegEnumValue(hkeySystemPrograms, iValue, szValue, &cchValue, NULL, &dwType,
                                        (LPBYTE)szSystemPrograms, &cbSystemPrograms) == ERROR_SUCCESS)
                    {
                        if ((dwType == REG_SZ) && !StrCmpI(pszFileName, szSystemPrograms))
                        {
                            bSpecialApp = TRUE;
                            break;
                        }

                        cbSystemPrograms = sizeof(szSystemPrograms);
                        cchValue = ARRAYSIZE(szValue);
                        iValue++;
                    }
                    
                    RegCloseKey(hkeySystemPrograms);
                }

                if (!bSpecialApp)
                {
                    TCHAR szProgramFiles[MAX_PATH];
                    if (SHGetSpecialFolderPath(NULL, szProgramFiles, CSIDL_PROGRAM_FILES, FALSE))
                    {
                        if (PathIsPrefix(szProgramFiles, szTarget))
                        {
                            bRet = TRUE;
                        }
                    }
                }
                else
                    bRet = FALSE;
            }
        }
        else if (hr == S_FALSE && szTarget[0])
        {
            // Darwin shortcuts, say yes
            bRet = TRUE;
        }
    }
    return bRet;
}

//
// needed because we export TCHAR versions of these functions that 
// internal components still call
//
// Functions are forwarded to shlwapi
//

#undef PathMakePretty
STDAPI_(BOOL) PathMakePretty(LPTSTR pszPath)
{
    SHELLSTATE ss;
    
    SHGetSetSettings(&ss, SSF_DONTPRETTYPATH, FALSE);
    if (ss.fDontPrettyPath)
        return FALSE;

    return PathMakePrettyW(pszPath);
}

#undef PathGetArgs
STDAPI_(LPTSTR) PathGetArgs(LPCTSTR pszPath)
{
    return PathGetArgsW(pszPath);
}

#undef PathRemoveArgs
STDAPI_(void) PathRemoveArgs(LPTSTR pszPath)
{
    PathRemoveArgsW(pszPath);
}

#undef PathFindOnPath
STDAPI_(BOOL) PathFindOnPath(LPTSTR pszFile, LPCTSTR *ppszOtherDirs)
{
    return PathFindOnPathW(pszFile, ppszOtherDirs);
}

#undef PathFindExtension
STDAPI_(LPTSTR) PathFindExtension(LPCTSTR pszPath)
{
    return PathFindExtensionW(pszPath);
}

#undef PathAddExtension
STDAPI_(BOOL) PathAddExtension(LPTSTR  pszPath, LPCTSTR pszExtension)
{
    return PathAddExtensionW(pszPath, pszExtension);
}

#undef PathRemoveExtension
STDAPI_(void) PathRemoveExtension(LPTSTR pszPath)
{
    PathRemoveExtensionW(pszPath);
}

#undef PathRenameExtension
STDAPI_(BOOL) PathRenameExtension(LPTSTR  pszPath, LPCTSTR pszExt)
{
    return PathRenameExtensionW(pszPath, pszExt);
}

#undef PathCommonPrefix
STDAPI_(int) PathCommonPrefix(LPCTSTR pszFile1, LPCTSTR pszFile2, LPTSTR pszPath)
{
    return PathCommonPrefixW(pszFile1, pszFile2, pszPath);
}

#undef PathIsPrefix
STDAPI_(BOOL) PathIsPrefix(IN LPCTSTR  pszPrefix, IN LPCTSTR  pszPath)
{
    return PathIsPrefixW(pszPrefix, pszPath);
}

#undef PathRelativePathTo
STDAPI_(BOOL) PathRelativePathTo(LPTSTR pszPath, 
     LPCTSTR pszFrom, DWORD dwAttrFrom,  LPCTSTR pszTo, DWORD dwAttrTo)
{
    return PathRelativePathToW(pszPath, pszFrom, dwAttrFrom, pszTo, dwAttrTo);
}

#undef PathRemoveBlanks
STDAPI_(void) PathRemoveBlanks(LPTSTR pszString)
{
    PathRemoveBlanksW(pszString);
}

#undef PathRemoveBackslash
STDAPI_(LPTSTR) PathRemoveBackslash(LPTSTR pszPath)
{
    return PathRemoveBackslashW(pszPath);
}

#undef PathCanonicalize
STDAPI_(BOOL) PathCanonicalize(LPTSTR  pszDst, LPCTSTR pszSrc)
{
    return PathCanonicalizeW(pszDst, pszSrc);
}

#undef PathStripToRoot
STDAPI_(BOOL) PathStripToRoot(LPTSTR szRoot)
{
    return PathStripToRootW(szRoot);
}

//CD-Autorun for Win9x called the TCHAR internal api's. So as a workaround we stub them through these function calls.

#undef PathRemoveFileSpec
STDAPI_(BOOL) PathRemoveFileSpec(LPTSTR pFile)
{
    if (SHGetAppCompatFlags(ACF_ANSI) == ACF_ANSI)
        return PathRemoveFileSpecA((LPSTR)pFile);
    else
        return PathRemoveFileSpecW(pFile);
}

#undef PathAddBackslash
STDAPI_(LPTSTR) PathAddBackslash(LPTSTR pszPath)
{
    return PathAddBackslashW(pszPath);
}

#undef PathFindFileName
STDAPI_(LPTSTR) PathFindFileName(LPCTSTR pszPath)
{
    return PathFindFileNameW(pszPath);
}

#undef PathIsFileSpec
STDAPI_(BOOL) PathIsFileSpec(LPCTSTR pszPath)
{
    return PathIsFileSpecW(pszPath);
}

#undef PathIsUNCServer
STDAPI_(BOOL) PathIsUNCServer(LPCTSTR pszPath)
{
    return PathIsUNCServerW(pszPath);
}

#undef PathIsUNCServerShare
STDAPI_(BOOL) PathIsUNCServerShare(LPCTSTR pszPath)
{
    return PathIsUNCServerShareW(pszPath);
}

#undef PathStripPath
STDAPI_(void) PathStripPath(LPTSTR pszPath)
{
    PathStripPathW(pszPath);
}

#undef PathSearchAndQualify
STDAPI_(BOOL) PathSearchAndQualify(LPCTSTR pcszPath, LPTSTR pszFullyQualifiedPath, UINT cchFullyQualifiedPath)
{
    return PathSearchAndQualifyW(pcszPath, pszFullyQualifiedPath, cchFullyQualifiedPath);
}

// CD-Autorun for Win9x called the TCHAR internal api's. So as a workaround we stub them through these function calls.

#undef PathIsRoot
STDAPI_(BOOL) PathIsRoot(LPCTSTR pszPath)
{
    if (SHGetAppCompatFlags(ACF_ANSI) == ACF_ANSI)
        return PathIsRootA((LPCSTR)pszPath);
    else
        return PathIsRootW(pszPath);
}

#undef PathCompactPath
STDAPI_(BOOL) PathCompactPath(HDC hDC, LPTSTR pszPath, UINT dx)
{
    return PathCompactPathW(hDC, pszPath, dx);
}

#undef PathCompactPathEx
STDAPI_(BOOL) PathCompactPathEx(LPTSTR  pszOut, LPCTSTR pszSrc, UINT cchMax, DWORD dwFlags)
{
    return PathCompactPathExW(pszOut, pszSrc, cchMax, dwFlags);
}

#undef PathSetDlgItemPath
STDAPI_(void) PathSetDlgItemPath(HWND hDlg, int id, LPCTSTR pszPath)
{
    PathSetDlgItemPathW(hDlg, id, pszPath);
}

#undef PathUnquoteSpaces
STDAPI_(void) PathUnquoteSpaces(LPTSTR psz)
{
    PathUnquoteSpacesW(psz);
}

#undef PathQuoteSpaces
STDAPI_(void) PathQuoteSpaces(LPTSTR psz)
{
    PathQuoteSpacesW(psz);
}

#undef PathFindNextComponent
STDAPI_(LPTSTR) PathFindNextComponent(LPCTSTR pszPath)
{
    return PathFindNextComponentW(pszPath);
}

#undef PathMatchSpec
STDAPI_(BOOL) PathMatchSpec(LPCTSTR pszFileParam, LPCTSTR pszSpec)
{
    return PathMatchSpecW(pszFileParam, pszSpec);
}

#undef PathSkipRoot
STDAPI_(LPTSTR) PathSkipRoot(LPCTSTR pszPath)
{
    return PathSkipRootW(pszPath);
}

#undef PathIsSameRoot
STDAPI_(BOOL) PathIsSameRoot(LPCTSTR pszPath1, LPCTSTR pszPath2)
{
    return PathIsSameRootW(pszPath1, pszPath2);
}

#undef PathParseIconLocation
STDAPI_(int) PathParseIconLocation(IN OUT LPTSTR pszIconFile)
{
    return PathParseIconLocationW(pszIconFile);
}

#undef PathIsURL
STDAPI_(BOOL) PathIsURL(IN LPCTSTR pszPath)
{
    return PathIsURLW(pszPath);
}

#undef PathIsDirectory
STDAPI_(BOOL) PathIsDirectory(LPCTSTR pszPath)
{
    return PathIsDirectoryW(pszPath);
}

// CD-Autorun for Win9x called the TCHAR internal api's. So as a workaround we stub them through these function calls.

#undef PathFileExists
STDAPI_(BOOL) PathFileExists(LPCTSTR pszPath)
{
    if (SHGetAppCompatFlags(ACF_ANSI) == ACF_ANSI)
        return PathFileExistsAndAttributesA((LPCSTR)pszPath, NULL);
    else
        return PathFileExistsAndAttributesW(pszPath, NULL);
}

#undef PathAppend
STDAPI_(BOOL) PathAppend(LPTSTR pszPath, LPCTSTR pszMore)
{
  if (SHGetAppCompatFlags(ACF_ANSI) == ACF_ANSI)
     return PathAppendA((LPSTR)pszPath, (LPCSTR)pszMore);
  else
     return PathAppendW(pszPath, pszMore);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\ovrlaymn.cpp ===
//---------------------------------------------------------------------------
//
// Copyright (c) Microsoft Corporation 
//
// File: overlayMN.cpp
//
// This file contains the implementation of CFSIconOverlayManager, a COM object
// that manages the IShellIconOverlayIdentifiers list.
// It aslo managess the Sytem Image List OverlayIndexes, since we have limited slots,
// exactly MAX_OVERLAY_IAMGES of them. 
// History:
//         5-2-97  by dli
//------------------------------------------------------------------------
#include "shellprv.h"
#include "ovrlaymn.h"
#include "fstreex.h"
#include "filetbl.h"
extern "C" {
#include "cstrings.h"
#include "ole2dup.h"
}


extern "C" UINT const c_SystemImageListIndexes[];
extern int g_lrFlags;

// NOTE: The value of OVERLAYINDEX_RESERVED is not the same as the overall
// size of the s_ReservedOverlays array, we need to reserved the overlay slot
// #3 for the non-existent Read-Only overaly.
// The Read Only overlay was once there in Win95, but got turned off on IE4
// however, because of the of the original overlay designs,( we used to
// assign overlay 1 to share and 2 to link and 3 to readonly, and the third parties
// just copied our scheme,) we have to keep overlay #3 as a ghost. 
#define OVERLAYINDEX_RESERVED 4

typedef struct _ReservedIconOverlay
{
    int iShellResvrdImageIndex;
    int iImageIndex;
    int iOverlayIndex;
    int iPriority;
} ReservedIconOverlay;

static ReservedIconOverlay s_ReservedOverlays[] = {
    {II_SHARE, II_SHARE, 1, 10}, 
    {II_LINK, II_LINK, 2, 10},
    // Slot 3 should be reserved as a ghost slot because of the read-only overlay
    {II_SLOWFILE, II_SLOWFILE, 4, 10},
};
    
// File system Icon overlay Identifiers
typedef struct _FSIconOverlay {
    IShellIconOverlayIdentifier * psioi;  
    CLSID clsid;
    int iIconIndex;                          // Index of the Overlay Icon in szIconFile
    int iImageIndex;                         // System Image List index of the icon overlay image
    int iOverlayIndex;
    int iPriority;
    TCHAR szIconFile[MAX_PATH];              // Path of the icon overlay
} FSIconOverlay;

#define FSIconOverlay_GROW 3
#define DSA_LAST    0x7fffffff
#define MAX_OVERLAY_PRIORITY  100
class CFSIconOverlayManager : public IShellIconOverlayManager
{
public:
    CFSIconOverlayManager();
    ~CFSIconOverlayManager();
    
    // *** IUnknown Methods
    virtual STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    virtual STDMETHODIMP_(ULONG) AddRef(void) ;
    virtual STDMETHODIMP_(ULONG) Release(void);

    // *** IShellIconOverlay Methods
    virtual STDMETHODIMP GetFileOverlayInfo(LPCWSTR pwszPath, DWORD dwAttrib, int * pIndex, DWORD dwFlags);
    virtual STDMETHODIMP GetReservedOverlayInfo(LPCWSTR pwszPath, DWORD dwAttrib, int * pIndex, DWORD dwFlags, int iReservedID);
    virtual STDMETHODIMP RefreshOverlayImages(DWORD dwFlags);
    virtual STDMETHODIMP LoadNonloadedOverlayIdentifiers(void);
    virtual STDMETHODIMP OverlayIndexFromImageIndex(int iImage, int * piIndex, BOOL fAdd);
                                             
    // *** Public Methods

    // *** Static Methods
    static HRESULT CreateInstance(IUnknown* pUnkOuter, REFIID riid, OUT LPVOID * ppvOut);

protected:
    
    // IUnknown 
    LONG _cRef;
    HDSA _hdsaIconOverlays;      // Icon Overlay Identifiers array, this list is ordered by the IOIs' priority
    HRESULT _InitializeHdsaIconOverlays(); // Initialize the Icon Overlay Identifiers array
    HRESULT _DestroyHdsaIconOverlays();
    int     _GetImageIndex(FSIconOverlay * pfsio);
    FSIconOverlay * _FindMatchingID(LPCWSTR pwszPath, DWORD dwAttrib, int iMinPriority, int * pIOverlayIndex);
    HRESULT _SetGetOverlayInfo(FSIconOverlay * pfsio, int iOverlayIndex, int * pIndex, DWORD dwFlags);
    HRESULT _InitializeReservedOverlays();
    HRESULT _LoadIconOverlayIdentifiers(HDSA hdsaOverlays, BOOL bSkipIfLoaded);

    BOOL _IsIdentifierLoaded(REFCLSID clsid);
//    int  _GetAvailableOverlayIndex(int imyhdsa);
//    HRESULT _SortIOIList();      // Sort the IOI's in the list according to their priority
}; 


HRESULT CFSIconOverlayManager::RefreshOverlayImages(DWORD dwFlags)
{
    ENTERCRITICAL;

    _InitializeReservedOverlays();

    if (dwFlags && _hdsaIconOverlays)
    {
        for (int ihdsa = 0; ihdsa < DSA_GetItemCount(_hdsaIconOverlays); ihdsa++)
        {
            FSIconOverlay * pfsio = (FSIconOverlay *)DSA_GetItemPtr(_hdsaIconOverlays, ihdsa);
            if (dwFlags & SIOM_ICONINDEX)
                pfsio->iImageIndex = -1;
            if (dwFlags & SIOM_OVERLAYINDEX)
                pfsio->iOverlayIndex = -1;
        }
    }

    LEAVECRITICAL;
    return S_OK;
}


HRESULT CFSIconOverlayManager::OverlayIndexFromImageIndex(int iImage, int * piIndex, BOOL fAdd)
{
    HRESULT hres = E_FAIL;
    *piIndex = -1;
    int i;
    for (i = 0; i < ARRAYSIZE(s_ReservedOverlays); i++)
    {
        if (s_ReservedOverlays[i].iImageIndex == iImage)
        {
            *piIndex = s_ReservedOverlays[i].iOverlayIndex;
            hres = S_OK;
            break;
        }
    }

    if (i == ARRAYSIZE(s_ReservedOverlays))
    {
        ENTERCRITICAL;

        if (_hdsaIconOverlays)
        {
            int nOverlays = DSA_GetItemCount(_hdsaIconOverlays);

            // 1. Try to find this overlay image in the list 
            int i;
            for (i = 0; i < nOverlays; i++)
            {
                FSIconOverlay * pfsio = (FSIconOverlay *)DSA_GetItemPtr(_hdsaIconOverlays, i);
                if (pfsio && pfsio->iImageIndex == iImage)
                {
                    *piIndex = pfsio->iOverlayIndex;
                    hres = S_OK;
                    break;
                }
            }

            // 2. Can't find it, let's add it (if requested)
            if (fAdd && (i == nOverlays) && (nOverlays < NUM_OVERLAY_IMAGES))
            {
                FSIconOverlay fsio = {0};
                fsio.iImageIndex = iImage;
                fsio.iOverlayIndex = nOverlays + OVERLAYINDEX_RESERVED + 1;
                if (DSA_InsertItem(_hdsaIconOverlays, DSA_LAST, &fsio) >= 0)
                {
                    hres = S_OK;
                    for (int j = 0; j < ARRAYSIZE(g_rgshil); j++)
                    {
                        if (!ImageList_SetOverlayImage(g_rgshil[j].himl, iImage, fsio.iOverlayIndex))
                        {
                            hres = E_FAIL;
                            break;
                        }
                    }

                    if (SUCCEEDED(hres))
                    {
                        *piIndex = fsio.iOverlayIndex;
                    }
                    else
                    {
                        DSA_DeleteItem(_hdsaIconOverlays, nOverlays);
                    }
                }
            }
        }
        LEAVECRITICAL;
    }
    return hres;
}


HRESULT CFSIconOverlayManager::_InitializeReservedOverlays()
{
    int i;
    TCHAR szModule[MAX_PATH];

    BOOL fInit = _IsSHILInited();
    if (!fInit)
        fInit = FileIconInit(FALSE);

    if (!fInit)
        return E_OUTOFMEMORY;

    HKEY hkeyIcons = SHGetShellKey(SHELLKEY_HKLM_EXPLORER, TEXT("Shell Icons"), FALSE);
        
    GetModuleFileName(HINST_THISDLL, szModule, ARRAYSIZE(szModule));

    for (i = 0; i < ARRAYSIZE(s_ReservedOverlays); i++)
    {
        ASSERT(s_ReservedOverlays[i].iShellResvrdImageIndex > 0);
        ASSERT(s_ReservedOverlays[i].iOverlayIndex > 0);
        ASSERT(s_ReservedOverlays[i].iOverlayIndex <= MAX_OVERLAY_IMAGES);
        
        //
        // Warning: This is used by non explorer processes on NT only
        // because their image list was initialized with only 4 icons
        //
        int iIndex = s_ReservedOverlays[i].iShellResvrdImageIndex;

        // re-acquire the image index
        s_ReservedOverlays[i].iImageIndex = LookupIconIndex(szModule, iIndex, 0);

        if (s_ReservedOverlays[i].iImageIndex == -1)
        {
            HICON rghicon[ARRAYSIZE(g_rgshil)] = {0};

            // check to see if icon is overridden in the registry
            if (hkeyIcons)
            {
                TCHAR val[10];
                TCHAR ach[MAX_PATH];
                DWORD cb = SIZEOF(ach);

                wsprintf(val, TEXT("%d"), iIndex);

                ach[0] = 0;
                SHQueryValueEx(hkeyIcons, val, NULL, NULL, (LPBYTE)ach, &cb);

                if (ach[0])
                {
                    int iIcon = PathParseIconLocation(ach);

                    for (int j = 0; j < ARRAYSIZE(rghicon); j++)
                    {
                        ExtractIcons(ach, iIcon, g_rgshil[j].size.cx, g_rgshil[j].size.cy,
                                        &rghicon[j], NULL, 1, g_lrFlags);
                    }
                }
            }

            // if we got a large icon, run with that for everyone.  otherwise fall back to loadimage.
            if (rghicon[SHIL_LARGE] == NULL)
            {
                for (int j = 0; j < ARRAYSIZE(g_rgshil); j++)
                {
                    if (rghicon[j] == NULL)
                    {
                        rghicon[j] = (HICON)LoadImage(HINST_THISDLL, MAKEINTRESOURCE(c_SystemImageListIndexes[iIndex]),
                                        IMAGE_ICON, g_rgshil[j].size.cx, g_rgshil[j].size.cy, g_lrFlags);
                    }
                }
            }

            s_ReservedOverlays[i].iImageIndex = SHAddIconsToCache(rghicon, szModule, iIndex, 0);

            _DestroyIcons(rghicon, ARRAYSIZE(rghicon));
        }
        for (int j = 0; j < ARRAYSIZE(g_rgshil); j++)
        {
            ImageList_SetOverlayImage(g_rgshil[j].himl, s_ReservedOverlays[i].iImageIndex, s_ReservedOverlays[i].iOverlayIndex);
        }
    }

    if (hkeyIcons)
        RegCloseKey(hkeyIcons);
        
    return S_OK;
}

//===========================================================================
// Initialize the IShellIconOverlayIdentifiers 
//===========================================================================
HRESULT CFSIconOverlayManager::_InitializeHdsaIconOverlays() 
{
    HRESULT hres = S_FALSE; // Already initialized.

    if (NULL == _hdsaIconOverlays)
    {
        hres = _InitializeReservedOverlays();
        if (SUCCEEDED(hres))
        {
            _hdsaIconOverlays = DSA_Create(SIZEOF(FSIconOverlay), FSIconOverlay_GROW);

            if(NULL != _hdsaIconOverlays)
            {
                hres = _LoadIconOverlayIdentifiers(_hdsaIconOverlays, FALSE);
            }
            else
            {
                hres = E_OUTOFMEMORY;
            }
        }
    }
    return hres;
}



HRESULT CFSIconOverlayManager::LoadNonloadedOverlayIdentifiers(void)
{
    HRESULT hres;

    ENTERCRITICAL;

    if (NULL == _hdsaIconOverlays)
    {
        //
        // No overlay HDSA yet.  We should never hit this but just in case,
        // this will be valid behavior.
        //
        hres = _InitializeHdsaIconOverlays();
    }
    else
    {
        //
        // Load unloaded identifiers into existing HDSA.
        //
        hres = _LoadIconOverlayIdentifiers(_hdsaIconOverlays, TRUE);
    }

    LEAVECRITICAL;
    return hres;
}


HRESULT CFSIconOverlayManager::_LoadIconOverlayIdentifiers(HDSA hdsaOverlays, BOOL bSkipIfLoaded)
{
    ASSERT(NULL != hdsaOverlays);

    HDCA hdca = DCA_Create();
    if (!hdca)
        return E_OUTOFMEMORY;

    HRESULT hrInit = SHCoInitialize();

    // Enumerate all of the Icon Identifiers in
    DCA_AddItemsFromKey(hdca, HKEY_LOCAL_MACHINE, REGSTR_ICONOVERLAYID);
    if (DCA_GetItemCount(hdca) <= 0)
        goto EXIT;

    int idca;
    for (idca = 0; idca < DCA_GetItemCount(hdca); idca++)
    {
        const CLSID * pclsid = DCA_GetItem(hdca, idca);

        if (bSkipIfLoaded && _IsIdentifierLoaded(*pclsid))
            continue;

        FSIconOverlay fsio;
        ZeroMemory(&fsio, sizeof(fsio));
        // These came from HKLM which only administrators can write to,
        // so don't need to go through administrator approval
        if (FAILED(DCA_CreateInstance(hdca, idca, IID_PPV_ARG(IShellIconOverlayIdentifier, &fsio.psioi))))
            continue;       

        SHPinDllOfCLSID(pclsid);
        
        DWORD dwFlags = 0;
        int iIndex;
        WCHAR wszIconFile[MAX_PATH];
        // Initialize the Overlay Index to -1
        fsio.iOverlayIndex = -1;

        // Try get the overlay icon information from the Overlay Identifiers 
        if (S_OK == fsio.psioi->GetOverlayInfo(wszIconFile, ARRAYSIZE(wszIconFile), &iIndex, &dwFlags))
        {
            if (dwFlags & ISIOI_ICONFILE)
            {
                SHUnicodeToTChar(wszIconFile, fsio.szIconFile, ARRAYSIZE(fsio.szIconFile));
                fsio.iImageIndex = -1;
                if (dwFlags & ISIOI_ICONINDEX)
                    fsio.iIconIndex = iIndex;
                else
                    fsio.iIconIndex = 0;
            }

            if (FAILED(fsio.psioi->GetPriority(&fsio.iPriority)))
                fsio.iPriority = MAX_OVERLAY_PRIORITY;

            CopyMemory(&fsio.clsid, pclsid, sizeof(fsio.clsid));
            DSA_InsertItem(hdsaOverlays, DSA_LAST, &fsio);
        }
        // Now try to look in the registry for the Overlay Icons 
        else
        {
            fsio.iImageIndex = -1;
            const CLSID * pclsid = DCA_GetItem(hdca, idca);
            if (pclsid)
            {
                TCHAR szCLSID[GUIDSTR_MAX];
                TCHAR szRegKey[GUIDSTR_MAX + 40];
                HKEY hkeyIcon;
                SHStringFromGUID(*pclsid, szCLSID, ARRAYSIZE(szCLSID));
                wsprintf(szRegKey, REGSTR_ICONOVERLAYCLSID, szCLSID);
                if (ERROR_SUCCESS == RegOpenKey(HKEY_CLASSES_ROOT, szRegKey, &hkeyIcon))
                {
                    LONG cb = SIZEOF(fsio.szIconFile);
                    if (SHRegQueryValue(hkeyIcon, c_szDefaultIcon, fsio.szIconFile, &cb) == ERROR_SUCCESS && fsio.szIconFile[0])
                    {
                        fsio.iIconIndex = PathParseIconLocation(fsio.szIconFile);
                        CopyMemory(&fsio.clsid, pclsid, sizeof(fsio.clsid));
                        DSA_InsertItem(hdsaOverlays, DSA_LAST, &fsio);
                    }

                    // Unfinished !!! Code to retrieve the priority here
                    fsio.iPriority = MAX_OVERLAY_PRIORITY;
                    RegCloseKey(hkeyIcon);
                }
            }
        }

        // Stop when we have more than we can handle
        if (DSA_GetItemCount(hdsaOverlays) >= (MAX_OVERLAY_IMAGES - OVERLAYINDEX_RESERVED))
            break;
    }
    
EXIT:
    DCA_Destroy(hdca);
    SHCoUninitialize(hrInit);
    return S_OK;
}
     

BOOL CFSIconOverlayManager::_IsIdentifierLoaded(REFCLSID clsid)
{
    if (NULL != _hdsaIconOverlays)
    {
        int cEntries = DSA_GetItemCount(_hdsaIconOverlays);
        for (int i = 0; i < cEntries; i++)
        {
            FSIconOverlay *pfsio = (FSIconOverlay *)DSA_GetItemPtr(_hdsaIconOverlays, i);            
            if (pfsio->clsid == clsid)
                return TRUE;
        }
    }
    return FALSE;
}


CFSIconOverlayManager::CFSIconOverlayManager() : _cRef(1) // _hdsaIconOverlays(NULL)
{
}

HRESULT CFSIconOverlayManager::_DestroyHdsaIconOverlays()
{
    if (_hdsaIconOverlays)
    {
        DSA_Destroy(_hdsaIconOverlays);
    }
    
    return S_OK;
}

CFSIconOverlayManager::~CFSIconOverlayManager()
{
    if (_hdsaIconOverlays)
        _DestroyHdsaIconOverlays();

}

//
// CFSFolder_GetAvailableOverlayIndex:
// This function first tries to find an empty slot in all the available overlay indexes
// If none found, it goes through the _hdsaIconOverlays array elements who have lower
// priorities and grab their overlay indexes if they are using one
//
/*int CFSIconOverlayManager::_GetAvailableOverlayIndex(int imyhdsa)
{
    int ib;
    for (ib = 0; ib < MAX_OVERLAY_IMAGES; ib++)
        if (_bOverlayIndexOccupied[ib] == FALSE)
            break;

    // Add code to grab indexes here.
    return ++ib;
}*/

HRESULT CFSIconOverlayManager::QueryInterface(REFIID riid, LPVOID * ppvObj)
{ 
    // ppvObj must not be NULL
    ASSERT(ppvObj != NULL);
    
    if (IsEqualIID(riid, IID_IUnknown))
    {    
        *ppvObj = SAFECAST(this, IUnknown *);
        DebugMsg(DM_TRACE, TEXT("QI IUnknown succeeded"));
    }
    else if (IsEqualIID(riid, IID_IShellIconOverlayManager))
    {
        *ppvObj = SAFECAST(this, IShellIconOverlayManager*);
        DebugMsg(DM_TRACE, TEXT("QI IShellIconOverlayManager succeeded"));
    } 
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;  // Otherwise, don't delegate to HTMLObj!!
    }
    
    AddRef();
    return S_OK;
}


ULONG CFSIconOverlayManager::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CFSIconOverlayManager::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}

int CFSIconOverlayManager::_GetImageIndex(FSIconOverlay * pfsio)
{
    int iImage = LookupIconIndex(pfsio->szIconFile, pfsio->iIconIndex, GIL_FORSHELL);

    if (iImage == -1)
    {
        // we couldn't find it from the cache
        HICON rghicon[ARRAYSIZE(g_rgshil)] = {0};

        for (int i = 0; i < ARRAYSIZE(g_rgshil); i++)
        {
            SHDefExtractIcon(pfsio->szIconFile, pfsio->iIconIndex, GIL_FORSHELL, &rghicon[i],
                             NULL, g_rgshil[i].size.cx);
        }

        iImage = SHAddIconsToCache(rghicon, pfsio->szIconFile, pfsio->iIconIndex, GIL_FORSHELL);

        _DestroyIcons(rghicon, ARRAYSIZE(rghicon));
    }
    
    return iImage;
}

FSIconOverlay * CFSIconOverlayManager::_FindMatchingID(LPCWSTR pwszPath, DWORD dwAttrib, int iMinPriority, int * pIOverlayIndex)
{
    // If we got here, we must have the DSA array
    ASSERT(_hdsaIconOverlays);
    if (_hdsaIconOverlays)
    {
        int ihdsa;
        for (ihdsa = 0; ihdsa < DSA_GetItemCount(_hdsaIconOverlays); ihdsa++)
        {
            FSIconOverlay * pfsio = (FSIconOverlay *)DSA_GetItemPtr(_hdsaIconOverlays, ihdsa);
            ASSERT(pfsio);
            if (pfsio->iPriority >= iMinPriority)
                continue;
            if (pfsio->psioi && pfsio->psioi->IsMemberOf(pwszPath, dwAttrib) == S_OK)
            {
                // Overlay indexes start from 1, and let's not use the reserved ones
                ASSERT(pIOverlayIndex);
                *pIOverlayIndex = ihdsa + OVERLAYINDEX_RESERVED + 1; 
                return pfsio;
            }
        }
    }
    return NULL;
}

HRESULT CFSIconOverlayManager::_SetGetOverlayInfo(FSIconOverlay * pfsio, int iOverlayIndex, int * pIndex, DWORD dwFlags)
{
    HRESULT hres = E_FAIL;
    RIP(pIndex);
    *pIndex = -1;
#if 0    // we don't want to return the priority for now
    if (dwFlags == SIOM_PRIORITY)
    {
        // This must have been initialized in the initialization function
        *pIndex = pfsio->iPriority;
    }
#endif
    if (pfsio->iImageIndex == -1)
    {
        int iImage = _GetImageIndex(pfsio);

        // Either we couldn't get it or we couldn't put it in cache 
        if (iImage == -1)
        {
            // leave this as a zombie
            pfsio->iImageIndex = 0;
            pfsio->iOverlayIndex = 0;
        }
        else
            pfsio->iImageIndex = iImage;
    }

    // Only if we have a reasonable image index will we proceed. 
    if (pfsio->iImageIndex > 0)
    {
        if (dwFlags == SIOM_ICONINDEX)
        {
            *pIndex = pfsio->iImageIndex;
        }
        else
        {
            ASSERT(iOverlayIndex > 0);
            ASSERT(iOverlayIndex <= MAX_OVERLAY_IMAGES);
            if (pfsio->iOverlayIndex == -1)
            {
                // Now set the overlay
                ASSERT(_IsSHILInited());

                for (int i = 0; i < ARRAYSIZE(g_rgshil); i++)
                {
                    ImageList_SetOverlayImage(g_rgshil[i].himl, pfsio->iImageIndex, iOverlayIndex);
                }

                pfsio->iOverlayIndex = iOverlayIndex;
            }

            // Must be the overlayindex flag
            ASSERT(dwFlags == SIOM_OVERLAYINDEX);
            *pIndex = pfsio->iOverlayIndex;
        }
        hres = S_OK;

    }
    return hres;
}

HRESULT CFSIconOverlayManager::GetFileOverlayInfo(LPCWSTR pwszPath, DWORD dwAttrib, int * pIndex, DWORD dwFlags)
{
    ASSERT((dwFlags == SIOM_OVERLAYINDEX) || (dwFlags == SIOM_ICONINDEX)); // || (dwFlags == SIOM_PRIORITY));

    HRESULT hres = E_FAIL;
    int iOverlayIndex;
    *pIndex = 0;

    ENTERCRITICAL;
    if (_hdsaIconOverlays)
    {
        FSIconOverlay * pfsio = _FindMatchingID(pwszPath, dwAttrib, MAX_OVERLAY_PRIORITY, &iOverlayIndex);
        if (pfsio)
            hres = _SetGetOverlayInfo(pfsio, iOverlayIndex, pIndex, dwFlags);
    }
    LEAVECRITICAL;
    return hres;
}

HRESULT CFSIconOverlayManager::GetReservedOverlayInfo(LPCWSTR pwszPath, DWORD dwAttrib, int * pIndex, DWORD dwFlags, int iReservedID)
{
    ASSERT(iReservedID < OVERLAYINDEX_RESERVED);
    HRESULT hres = S_OK;

    ENTERCRITICAL;
    if (_hdsaIconOverlays && pwszPath)
    {
        int iOverlayIndex;
        FSIconOverlay * pfsio = _FindMatchingID(pwszPath, dwAttrib, s_ReservedOverlays[iReservedID].iPriority, &iOverlayIndex);
        if (pfsio)
        {
            hres = _SetGetOverlayInfo(pfsio, iOverlayIndex, pIndex, dwFlags);
            LEAVECRITICAL;
            return hres;
        }
    }
    
    if (dwFlags == SIOM_ICONINDEX)
        *pIndex =  s_ReservedOverlays[iReservedID].iImageIndex;
    else
    {
        ASSERT(dwFlags == SIOM_OVERLAYINDEX);
        *pIndex =  s_ReservedOverlays[iReservedID].iOverlayIndex;
    }
    LEAVECRITICAL;

    return hres;
}


HRESULT CFSIconOverlayManager::CreateInstance(IUnknown* pUnkOuter, REFIID riid, OUT LPVOID * ppvOut)
{
    HRESULT hr;
    
    DebugMsg(DM_TRACE, TEXT("CFSIconOverlayManager::CreateInstance()"));
    
    *ppvOut = NULL;                     // null the out param

    CFSIconOverlayManager *pcfsiom = new CFSIconOverlayManager;

    if (!pcfsiom)
        return E_OUTOFMEMORY;

    hr = pcfsiom->_InitializeHdsaIconOverlays();
    if (SUCCEEDED(hr))
        hr = pcfsiom->QueryInterface(riid, ppvOut);
    pcfsiom->Release();

    return hr;
}


STDAPI CFSIconOverlayManager_CreateInstance(IUnknown* pUnkOuter, REFIID riid, OUT LPVOID *  ppvOut)
{
    return CFSIconOverlayManager::CreateInstance(pUnkOuter, riid, ppvOut);
}

STDAPI_(int) SHGetIconOverlayIndexW(LPCWSTR pwszIconPath, int iIconIndex)
{

    TCHAR szIconPath[MAX_PATH];
    int iRet = -1;
    int iImage = -1;

    // If NULL path is passed in, see if the index matches one of our special indexes
    if (pwszIconPath == NULL)
    {
        switch (iIconIndex)
        {
            case IDO_SHGIOI_SHARE:
                iImage = s_ReservedOverlays[0].iImageIndex;
                break;
            case IDO_SHGIOI_LINK:
                iImage = s_ReservedOverlays[1].iImageIndex;
                break;
            case IDO_SHGIOI_SLOWFILE:
                iImage = s_ReservedOverlays[2].iImageIndex;
                break;
        }
    }
    else if (SHUnicodeToTChar(pwszIconPath, szIconPath, ARRAYSIZE(szIconPath)))        
            // Try to load the image into the shell icon cache            
            iImage = Shell_GetCachedImageIndex(szIconPath, iIconIndex, 0);
    
    if (iImage >= 0)
    {
        IShellIconOverlayManager *psiom;
        if (SUCCEEDED(GetIconOverlayManager(&psiom)))
        {
            int iCandidate = -1;
            if (SUCCEEDED(psiom->OverlayIndexFromImageIndex(iImage, &iCandidate, TRUE)))
            {
                iRet = iCandidate;
            }
            psiom->Release();
        }
    }
    
    return iRet;
}

STDAPI_(int) SHGetIconOverlayIndexA(LPCSTR pszIconPath, int iIconIndex)
{
    int iRet = -1;
    WCHAR wszIconPath[MAX_PATH];
    LPCWSTR pwszIconPath = NULL;
    if (pszIconPath)
    {
        wszIconPath[0] = L'\0';
        SHAnsiToUnicode(pszIconPath, wszIconPath, ARRAYSIZE(wszIconPath));
        pwszIconPath = wszIconPath;
    }
    
    return  SHGetIconOverlayIndexW(pwszIconPath, iIconIndex);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\pchcpp.h ===
#define NO_INCLUDE_UNION

#include "shellprv.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\pidl.h ===
// no one should know what is in this file. this data is private to the folders
 
#ifndef _PIDL_H_
#define _PIDL_H_

#include <idhidden.h>
#include <lmcons.h> // UNLEN

// CRegFolder pidl
#pragma pack(1)
typedef struct
{
    WORD    cb;
    BYTE    bFlags;
    BYTE    bOrder;
    CLSID   clsid;
} IDREGITEM;
typedef UNALIGNED IDREGITEM *LPIDREGITEM;
typedef const UNALIGNED IDREGITEM *LPCIDREGITEM;
#pragma pack()

// CFSFolder pidl
typedef struct
{
    WORD        cb;                     // pidl size
    BYTE        bFlags;                 // SHID_FS_* bits
    DWORD       dwSize;                 // -1 implies > 4GB, hit the disk to get the real size
    WORD        dateModified;
    WORD        timeModified;
    WORD        wAttrs;                 // FILE_ATTRIBUTES_* cliped to 16bits
    CHAR        cFileName[MAX_PATH];    // this is WCHAR for names that don't round trip
    CHAR        cAltFileName[8+1+3+1];  // ANSI version of cFileName (some chars not converted)
} IDFOLDER;
typedef UNALIGNED IDFOLDER *LPIDFOLDER;
typedef const UNALIGNED IDFOLDER *LPCIDFOLDER;

// IDList factory
#pragma pack(1)
typedef struct
{
    WORD wDate;
    WORD wTime;
} DOSSTAMP;

typedef struct
{
    HIDDENITEMID hid;
    DOSSTAMP dsCreate;
    DOSSTAMP dsAccess;
    WORD offNameW;
    WORD offResourceA;   //  ascii
} IDFOLDEREX;   // IDLHID_IDFOLDEREX

typedef struct
{
    HIDDENITEMID hid;
    WCHAR szUserName[UNLEN];
} IDPERSONALIZED;   // IDLHID_PERSONALIZED

#pragma pack()

typedef UNALIGNED IDFOLDEREX *PIDFOLDEREX;
typedef const UNALIGNED IDFOLDEREX *PCIDFOLDEREX;

typedef UNALIGNED IDPERSONALIZED *PIDPERSONALIZED;
typedef const UNALIGNED IDPERSONALIZED *PCIDPERSONALIZED;

#define IDFXF_PERSONALIZED  0x0001
#define IDFXF_USELOOKASIDE  0x8000

//  rev the version when ever we change IDFOLDEREX
#define IDFX_V1    0x0003
#define IDFX_CV    IDFX_V1

// End of hidden data for IDFOLDER

#pragma pack(1)
typedef struct
{
    WORD    cb;
    BYTE    bFlags;
    CHAR    cName[4];
    ULONGLONG qwSize;  // this is a "guess" at the disk size and free space
    ULONGLONG qwFree;
    WORD    wSig;
    CLSID   clsid;
} IDDRIVE;
typedef const UNALIGNED IDDRIVE *LPCIDDRIVE;
typedef UNALIGNED IDDRIVE *LPIDDRIVE;
#pragma pack()

// wSig usage
// we dont have much space in the word, so the first byte is an ordinal representing what
// kind of pidl extension were doing
// the second byte is flags pertaining to that ordinal
#define IDDRIVE_ORDINAL_MASK            0xFF00
#define IDDRIVE_FLAGS_MASK              0x00FF

#define IDDRIVE_ORDINAL_DRIVEEXT        0x0100
#define IDDRIVE_FLAGS_DRIVEEXT_HASCLSID 0x0001

typedef struct
{
    IDDRIVE idd;
    USHORT  cbNext;
} DRIVE_IDLIST;

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\piffnt.c ===
/*
 *  Microsoft Confidential
 *  Copyright (C) Microsoft Corporation 1991
 *  All Rights Reserved.
 *
 *
 *  PIFFNT.C
 *  User interface dialogs for GROUP_FNT
 *
 *  History:
 *  Created 04-Jan-1993 1:10pm by Jeff Parsons
 *  Changed 05-May-1993 5:10pm by Raymond Chen -- New Chicago-look preview
 *  Changed 12-Aug-1993 4:14pm by Raymond Chen -- Remove font inc and dec
 *
 *  All font dialog code taken from font*.c in vmdosapp, 01-Apr-93
 */

#include "shellprv.h"
#pragma hdrstop

#define REGSTR_MSDOSEMU_DISPLAYPARAMS TEXT("DisplayParams")

#define REGSTR_PATH_MSDOSEMU "Software\\Microsoft\\Windows\\CurrentVersion\\MS-DOS Emulation"

const TCHAR szWndPreviewClass[] = TEXT("WOAWinPreview");
const TCHAR szFontPreviewClass[] = TEXT("WOAFontPreview");

// The preview strings for bilingual dosbox. 
// We'll load this from our resource that will be properly
// localized. We'll give up if it fails and use above sample
// instead.

UINT cxScreen, cyScreen, dyChar, dyItem;

// Macro definitions that handle codepages 
//
#define OEMCharsetFromCP(cp) \
    ((cp)==CP_JPN? SHIFTJIS_CHARSET : ((cp)==CP_WANSUNG? HANGEUL_CHARSET : OEM_CHARSET))
/*
 * Font cache information.  Note that this cache, being in PIFMGR,
 * is now global, which will make support for per-VM font files/faces
 * more problematic, if we even decide that's an interesting feature.
 *
 */
DWORD   bpfdiStart[2] =  {  0  };    /* strage for the offset to cache */
UINT    cfdiCache[2];                   /* # used entries in fdi cache */
UINT    cfdiCacheActual[2];             /* Total # entries in fdi cache */
LPVOID lpCache = NULL;


/*
 * Owner-draw list box information.
 *
 */
HBITMAP hbmFont;                        /* Handle to "TrueType" logo */
DWORD   dwTimeCheck;
COLORREF clrChecksum;

HCURSOR hcursorWait;

#define MAXDIMENSTRING 80

/*
 * Initial font heights for TT fonts
 *
 * This is read from an INI file, so it must remain writeable.
 *
 * We don't try generating TT fonts below 12pt by default because
 * they just look crappy.  Frosting setup will put a different
 * table into place because Lucida Console looks good down to 4pt.
 *
 * On NT, Lucida Console is installed be default, though.
 *
 * The Frosting table is
 *      4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 18, 20, 22
 */
WORD rgwInitialTtHeights[] = { 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 18, 20, 22 };



/*
 * rgpnlPenalties -- Initialize penalty array to default values
 */
INT rgpnlPenalties[] =
        { 5000, 1000, 0, 1000, 5000, 1000, 0, 1000, 1 };


POINT ptNonAspectMin = { -1, -1 };

// Context-sensitive help ids

const static DWORD rgdwHelp[] = {
    IDC_FONTGRP,            IDH_COMM_GROUPBOX,
    IDC_RASTERFONTS,        IDH_DOS_AVAIL_FONTS,
    IDC_TTFONTS,            IDH_DOS_AVAIL_FONTS,
    IDC_BOTHFONTS,          IDH_DOS_AVAIL_FONTS,
    IDC_FONTSIZELBL,        IDH_DOS_FONT_SIZE,
    IDC_FONTSIZE,           IDH_DOS_FONT_SIZE,
    IDC_WNDPREVIEWLBL,      IDH_DOS_FONT_WINDOW_PREVIEW,
    IDC_FONTPREVIEWLBL,     IDH_DOS_FONT_FONT_PREVIEW,
    IDC_WNDPREVIEW,         IDH_DOS_FONT_WINDOW_PREVIEW,
    IDC_FONTPREVIEW,        IDH_DOS_FONT_FONT_PREVIEW,
    IDC_REALMODEDISABLE,    IDH_DOS_REALMODEPROPS,
    0, 0
};


BOOL_PTR CALLBACK DlgFntProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    PFNTINFO pfi = (PFNTINFO)GetWindowLongPtr(hDlg, DWLP_USER);

    switch (uMsg) 
    {
    case WM_INITDIALOG:
        // allocate dialog instance data
        if (NULL != (pfi = (PFNTINFO)LocalAlloc(LPTR, sizeof(FNTINFO)))) 
        {
            pfi->ppl = (PPROPLINK)((LPPROPSHEETPAGE)lParam)->lParam;
            SetWindowLongPtr(hDlg, DWLP_USER, (LPARAM)pfi);
            InitFntDlg(hDlg, pfi);
            break;
        }
        else
        {
            EndDialog(hDlg, FALSE);     // fail the dialog create
        }
        break;

    case WM_DESTROY:
        // free any allocations/resources inside the pfi first!
        if (pfi) 
        {
            if (pfi->hFontPreview)
            {
                DeleteObject(pfi->hFontPreview);
                pfi->hFontPreview = NULL;
            }
            // ok, NOW we can free the pfi
            EVAL(LocalFree(pfi) == NULL);
            SetWindowLongPtr(hDlg, DWLP_USER, 0);
        }
        break;

    HELP_CASES(rgdwHelp)                // Handle help messages

    case WM_COMMAND:
        if (LOWORD(lParam) == 0)
            break;                      // message not from a control

        switch (LOWORD(wParam))
        {
        case IDC_RASTERFONTS:
        case IDC_TTFONTS:
        case IDC_BOTHFONTS:

            /*
             * Rebuild the font list based on the user's selection of
             * which fonts to include/exclude.
             */
            pfi->fntProposed.flFnt &= ~FNT_BOTHFONTS;
            pfi->fntProposed.flFnt |= FNTFLAGSFROMID(wParam);
            CreateFontList(GetDlgItem(hDlg, IDC_FONTSIZE), TRUE, &pfi->fntProposed);
            PreviewUpdate(GetDlgItem(hDlg, IDC_FONTSIZE), pfi);

            if (HIWORD(wParam) == BN_CLICKED)
                SendMessage(GetParent(hDlg), PSM_CHANGED, (WPARAM)hDlg, 0L);

            return FALSE;

        case IDC_FONTSIZE:

            if (HIWORD(wParam) == LBN_SELCHANGE)
            {
                PreviewUpdate(GetDlgItem(hDlg, IDC_FONTSIZE), pfi);
                SendMessage(GetParent(hDlg), PSM_CHANGED, (WPARAM)hDlg, 0L);
                return TRUE;
            }
            if (HIWORD(wParam) == LBN_DBLCLK)
                ApplyFntDlg(hDlg, pfi);

            return FALSE;
        }
        break;

    case WM_NOTIFY:
        switch (((NMHDR *)lParam)->code) {
        case PSN_SETACTIVE:
            AdjustRealModeControls(pfi->ppl, hDlg);
            break;

        case PSN_KILLACTIVE:
            // This gives the current page a chance to validate itself
            // SetWindowLong(hDlg, DWL_MSGRESULT, ValidFntDlg(hDlg, pfi));
            break;

        case PSN_APPLY:
            // This happens on OK....
            ApplyFntDlg(hDlg, pfi);
            break;

        case PSN_RESET:
            // This happens on Cancel....
            break;
        }
        break;

    /*
     *  For WM_MEASUREITEM and WM_DRAWITEM, since there is only one
     *  owner-draw list box in the entire dialog box, we don't have
     *  to do a GetDlgItem to figure out who he is.
     */

    case WM_MEASUREITEM:
        // measure the owner draw listbox
        MeasureItemFontList((LPMEASUREITEMSTRUCT)lParam);
        break;

    case WM_DRAWITEM:
        DrawItemFontList(TRUE, (LPDRAWITEMSTRUCT)lParam);
        break;

    case WM_SYSCOLORCHANGE:
        UpdateTTBitmap();
        break;

    default:
        return FALSE;                   // return 0 when not processing
    }
    return TRUE;
}


/** InitFntDlg
 *
 *  Create the list of appropriate fonts.
 *
 *  This routine is broken out of FontDlgProc because it chew
 *  up lots of stack for the message buffer, and we don't want to
 *  eat that much stack on every entry to FontDlgProc.
 *
 *  Note that we must defer CreateFontList until WM_INITDIALOG
 *  time because it is not until then that we have a list box that
 *  we can shove the data into.
 */

void InitFntDlg(HWND hDlg, register PFNTINFO pfi)
{
    HWND hwndList;              /* The listbox of fonts */
    PPROPLINK ppl = pfi->ppl;
    WINDOWPLACEMENT wp;

    ASSERTTRUE(ppl->iSig == PROP_SIG);

    if (!PifMgr_GetProperties(ppl, MAKELP(0,GROUP_FNT),
                        &pfi->fntProposed, sizeof(pfi->fntProposed), GETPROPS_NONE)
        ||
        !PifMgr_GetProperties(ppl, MAKELP(0,GROUP_WIN),
                        &pfi->winOriginal, sizeof(pfi->winOriginal), GETPROPS_NONE)) {
        Warning(hDlg, IDS_QUERY_ERROR, MB_ICONEXCLAMATION | MB_OK);
        return;
    }

    /*
     * Set up instance variables for the window preview window.
     */
     
    /* Show preview maximized if window is maximized or restores to max'd.
     * Also if it is open restored and has no scrollbars.
     * (Determined by comparing the client window size against the cell
     * size and font size.)
     */

    pfi->fMax = FALSE;

    /*
     * Preload winOriginal with up-to-the-minute goodies, if we have
     * them.
     */

#define HasScrollbars(z) \
    (pfi->winOriginal.c##z##Cells * pfi->fntProposed.c##z##FontActual > \
     pfi->winOriginal.c##z##Client)

    if (ppl->hwndTty) {
        wp.length = sizeof(WINDOWPLACEMENT);
        VERIFYTRUE(GetWindowPlacement(ppl->hwndTty, &wp));

        // Convert/Copy to 16-bit structure
        pfi->winOriginal.wLength          = (WORD)wp.length;
        pfi->winOriginal.wShowFlags       = (WORD)wp.flags;
        pfi->winOriginal.wShowCmd         = (WORD)wp.showCmd;
        pfi->winOriginal.xMinimize        = (WORD)wp.ptMinPosition.x;
        pfi->winOriginal.yMinimize        = (WORD)wp.ptMinPosition.y;
        pfi->winOriginal.xMaximize        = (WORD)wp.ptMaxPosition.x;
        pfi->winOriginal.yMaximize        = (WORD)wp.ptMaxPosition.y;
        pfi->winOriginal.rcNormal.left    = (WORD)wp.rcNormalPosition.left;
        pfi->winOriginal.rcNormal.top     = (WORD)wp.rcNormalPosition.top;
        pfi->winOriginal.rcNormal.right   = (WORD)wp.rcNormalPosition.right;
        pfi->winOriginal.rcNormal.bottom  = (WORD)wp.rcNormalPosition.bottom;

        if (!IsIconic(ppl->hwndTty) &&
                !HasScrollbars(x) && !HasScrollbars(y)) {
            pfi->fMax = TRUE;
        }
    }

    if ((pfi->winOriginal.wShowCmd == SW_SHOWMAXIMIZED) ||
        (pfi->winOriginal.wShowFlags & WPF_RESTORETOMAXIMIZED)) {
        pfi->fMax = TRUE;
    }

    if (pfi->winOriginal.wShowCmd == SW_SHOWMAXIMIZED) {
        pfi->ptCorner.x = (LONG)pfi->winOriginal.xMaximize;
        pfi->ptCorner.y = (LONG)pfi->winOriginal.yMaximize;
    } else {
        if (pfi->winOriginal.rcNormal.left==0)
        {
            pfi->ptCorner.x = -1;
        }
        else
        {
            pfi->ptCorner.x = (LONG)pfi->winOriginal.rcNormal.left;
        }
        pfi->ptCorner.y = (LONG)pfi->winOriginal.rcNormal.top;
    }

    /*
     * First, check which fonts the user wants to see.
     *
     */
    CheckDlgButton(hDlg, IDFROMFNTFLAGS(pfi->fntProposed.flFnt), TRUE);

    hwndList = GetDlgItem(hDlg, IDC_FONTSIZE);
    // SendMessage(hwndList, WM_SETFONT, (WPARAM)GetStockObject(SYSTEM_FIXED_FONT), FALSE);

    if (CreateFontList(hwndList, TRUE, &pfi->fntProposed) == LB_ERR) {
        MemoryWarning(hDlg);
        EndDialog(hDlg, PtrToLong(BPFDI_CANCEL));    /* Get out of the dialog */
        return;
    }

    /* Initialize the preview windows */
    PreviewInit(hDlg, pfi);
    PreviewUpdate(GetDlgItem(hDlg, IDC_FONTSIZE), pfi);
}


void ApplyFntDlg(HWND hDlg, register PFNTINFO pfi)
{
    PPROPLINK ppl = pfi->ppl;

    ASSERTTRUE(ppl->iSig == PROP_SIG);

    if (!PifMgr_SetProperties(ppl, MAKELP(0,GROUP_FNT),
                        &pfi->fntProposed, sizeof(pfi->fntProposed), SETPROPS_NONE))
        Warning(hDlg, IDS_UPDATE_ERROR, MB_ICONEXCLAMATION | MB_OK);
    else
    if (ppl->hwndNotify) {
        ppl->flProp |= PROP_NOTIFY;
        PostMessage(ppl->hwndNotify, ppl->uMsgNotify, sizeof(pfi->fntProposed), (LPARAM)MAKELP(0,GROUP_FNT));
    }
}

/*
 * Retrieves the name of the font to use for true-type DOS box
 * in a window given a registry tree root.
 *
 * Entry:
 *
 * hkRoot      -> registry tree root to search
 * pszFaceSbcs -> LF_FACESIZE buffer for SBCS font
 * pszFaceDbcs -> LF_FACESIZE buffer for DBCS font (may be null)
 *
 * Exit:
 *
 * Buffers filled with new font names, or left unchanged if nothing
 * found in registry.
 *
 */

#define REGSTR_MSDOSEMU_FONT "Font"
#define REGSTR_MSDOSEMU_FONTDBCS "FontDBCS"

void GetDosBoxTtFontsHkA(HKEY hkRoot, LPSTR pszFaceSbcs, LPSTR pszFaceDbcs)
{
    static CHAR const szMsdosemu[] = REGSTR_PATH_MSDOSEMU;
    HKEY hk;
    DWORD cb;

    if (RegOpenKeyExA(hkRoot, szMsdosemu, 0, KEY_READ, &hk) == ERROR_SUCCESS)
    {
        static CHAR const szFont[] = REGSTR_MSDOSEMU_FONT;
        cb = LF_FACESIZE;
        RegQueryValueExA(hk, szFont, 0, 0, (LPBYTE)pszFaceSbcs, &cb);

        if (pszFaceDbcs)
        {
            static CHAR const szDbcsFont[] = REGSTR_MSDOSEMU_FONTDBCS;
            cb = LF_FACESIZE;
            RegQueryValueExA(hk, szDbcsFont, 0, 0, (LPBYTE)pszFaceDbcs, &cb);
        }
        RegCloseKey(hk);
    }
}

/*
 * Retrieves the name of the font to use for true-type DOS box
 * in a window.
 *
 * This routine consults the appropriate registry keys.
 *
 * The DOS box font comes first from HKLM, to establish  a
 * machine-wide default, but can in turn be overridden by
 * HKCU for each user to override.
 *
 * Entry:
 *
 * pszFaceSbcs -> LF_FACESIZE buffer for SBCS font
 * pszFaceDbcs -> LF_FACESIZE buffer for DBCS font (may be null)
 *
 * Exit:
 *
 * Buffers filled with new font names, or left unchange if nothing
 * found in registry.
 *
 */

void CoolGetDosBoxTtFontsA(LPSTR pszFaceSbcs, LPSTR pszFaceDbcs)
{
    GetDosBoxTtFontsHkA(HKEY_LOCAL_MACHINE, pszFaceSbcs, pszFaceDbcs);
    GetDosBoxTtFontsHkA(HKEY_CURRENT_USER, pszFaceSbcs, pszFaceDbcs);
}

/** BroadcastFontChange
 *
 *  HACK! for MS PowerPoint 4.0.  These wallys, for some reason, will go
 *  off and eat up reams of CPU time if they receive a WM_FONTCHANGE
 *  message that was *posted*.  But if the message is *sent*, they do
 *  the right thing.  The puzzling thing is that they never call
 *  InSendMessage(), so how do they know?  What's more, why do they care?
 *  This was true in 3.1 also.  What's their problem?
 *
 *  The problem is that sending a broadcast risks deadlock city; see the
 *  various hacks in winoldap for places where DDE broadcasting is bypassed.
 *  In addition, since BroadcastFontChange is also called during the WEP,
 *  multi-threaded apps will deadlock if we SendMessage back to a window
 *  on a different thread in the app, because Kernel takes a process
 *  critical section during DLL unload.
 *
 *  So if PowerPig is running, we just don't tell anybody that we dorked
 *  with the fonts.
 *
 *  Returns:
 *
 *      None.
 *
 */

void BroadcastFontChange(void)
{
    if (!GetModuleHandle(szPP4)) {
        PostMessage(HWND_BROADCAST, WM_FONTCHANGE, 0, 0L);
    }
}

/** LoadGlobalFontData
 *
 *  Get the name of the DOS box raster font and load it.
 *
 *  Get the name of the TT font.  (CheckDisplayParameters needs this.)
 *
 *  Check the display parameters.
 *
 *  Initialize the fdi cache.  The cache remains in GlobalLock'd
 *  memory throughout its lifetime.  This is not a problem because
 *  we are guaranteed to be in protected mode.
 *
 *  We also load things necessary for the font combo/list boxes.
 *
 *  And compute the height of the owner-draw list box item.
 *
 *  Returns:
 *
 *      TRUE on success.  In which case the FDI cache and hbmFont
 *      are ready to use.
 *
 *      FALSE on failure.  In which case there is insufficient memory
 *      to complete the operation.
 */

typedef void (WINAPI *LPFNGDBTF)(LPTSTR, LPTSTR); /* GetDosBoxTtFonts */

BOOL LoadGlobalFontData(void)
{
    HDC hDC;
    TEXTMETRIC tm;
    TCHAR szBuffer[MAXPATHNAME];

    cxScreen = GetSystemMetrics(SM_CXSCREEN);
    cyScreen = GetSystemMetrics(SM_CYSCREEN);

    /*
     * Get the system char size and save it away for later use.
     */
    hDC = GetDC(NULL);
    SelectObject(hDC, GetStockObject(SYSTEM_FONT));
    GetTextMetrics(hDC, &tm);
    ReleaseDC(NULL, hDC);

    dyChar = tm.tmHeight + tm.tmExternalLeading;
    dyItem = max(tm.tmHeight, DY_TTBITMAP);

    /*
     * Chicago's AddFontResource looks in the FONTS directory first, which
     * is great because it saves us the trouble of doing goofy disk access
     * optimizations.
     */
    GetPrivateProfileString(sz386EnhSection, szWOAFontKey,
                            c_szNULL, szBuffer, ARRAYSIZE(szBuffer), szSystemINI);
    if (szBuffer[0] && AddFontResource(szBuffer)) {
        BroadcastFontChange();
    }

    /*
     * Add DBCS native font if it is present.
     */
    GetPrivateProfileString(sz386EnhSection, szWOADBCSFontKey,
                            c_szNULL, szBuffer, ARRAYSIZE(szBuffer), szSystemINI);
    if (szBuffer[0] && AddFontResource(szBuffer)) {
        BroadcastFontChange();
    }

    /*
     * Load default TT font name(s) and TT cache section names from resource
     */
    LoadStringA(g_hinst, IDS_TTFACENAME_SBCS, szTTFaceName[0], ARRAYSIZE(szTTFaceName[0]));
    LoadString(g_hinst,IDS_TTCACHESEC_SBCS, szTTCacheSection[0], ARRAYSIZE(szTTCacheSection[0]));

    if (IsBilingualCP(g_uCodePage))
    {
        LoadStringA(g_hinst, IDS_TTFACENAME_DBCS, szTTFaceName[1], ARRAYSIZE(szTTFaceName[1]));
        LoadString(g_hinst, IDS_TTCACHESEC_DBCS, szTTCacheSection[1], ARRAYSIZE(szTTCacheSection[1]));
    }        

    CoolGetDosBoxTtFontsA(szTTFaceName[0], szTTFaceName[1]);

    CheckDisplayParameters();

    // alloc needed # of cache
    //
    lpCache = (LPVOID)LocalAlloc(LPTR,
                    FDI_TABLE_START * sizeof(FONTDIMENINFO) * (IsBilingualCP(g_uCodePage)? 2:1));
                         
    if (!lpCache)
        return FALSE;

    hcursorWait = LoadCursor(NULL, IDC_WAIT);

    UpdateTTBitmap();
    if (!hbmFont)
        goto E0;

    // set initial value of # of cache entries which depends on whether we have
    // two codepage to handle
    //
    cfdiCacheActual[0] = FDI_TABLE_START;

    if (IsBilingualCP(g_uCodePage))
    {
        cfdiCacheActual[1] = FDI_TABLE_START;
        bpfdiStart[1] += FDI_TABLE_START;
    }

    FontSelInit();

    return TRUE;

E0: 
    EVAL(LocalFree(lpCache) == NULL);

    return FALSE;
}



void FreeGlobalFontData()
{
    TCHAR szBuffer[MAXPATHNAME] = {0};

    if (hbmFont)
        DeleteObject(hbmFont);

    EVAL(LocalFree(lpCache) == NULL);



    GetPrivateProfileString(sz386EnhSection, szWOAFontKey,
                            c_szNULL, szBuffer, ARRAYSIZE(szBuffer), szSystemINI);
    if (*szBuffer) {
        if (RemoveFontResource(szBuffer)) {
            BroadcastFontChange();
        }
    }
    GetPrivateProfileString(sz386EnhSection, szWOADBCSFontKey,
                            c_szNULL, szBuffer, ARRAYSIZE(szBuffer), szSystemINI);
    if (*szBuffer) {
        if (RemoveFontResource(szBuffer)) {
            BroadcastFontChange();
        }
    }
}


BOOL LoadGlobalFontEditData()
{
    WNDCLASS wc;

    // Set up the window preview class for piffnt.c

    wc.style         = 0L;
    wc.lpfnWndProc   = WndPreviewWndProc;
    wc.cbClsExtra    = 0;
    wc.cbWndExtra    = sizeof(PFNTINFO);
    wc.hInstance     = g_hinst;
    wc.hIcon         = NULL;
    wc.hCursor       = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = (HBRUSH)(COLOR_BACKGROUND + 1);
    wc.lpszMenuName  = NULL;
    wc.lpszClassName = szWndPreviewClass;

    // Don't go through RegisterClassD because we manually unregister
    // this class ourselves.
    if (!RealRegisterClass(&wc))
        return FALSE;

    // Set up the font preview class for piffnt.c

    wc.style         = 0L;
    wc.lpfnWndProc   = FontPreviewWndProc;
    wc.cbClsExtra    = 0;
    wc.cbWndExtra    = sizeof(PFNTINFO);
    wc.hInstance     = g_hinst;
    wc.hIcon         = NULL;
    wc.hCursor       = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = GetStockObject(BLACK_BRUSH);
    wc.lpszMenuName  = NULL;
    wc.lpszClassName = szFontPreviewClass;

    // Don't go through RegisterClassD because we manually unregister
    // this class ourselves.
    if (!RealRegisterClass(&wc))
        return FALSE;

    return TRUE;
}


void FreeGlobalFontEditData()
{
    UnregisterClass(szWndPreviewClass, g_hinst);
    UnregisterClass(szFontPreviewClass, g_hinst);
}


/*
 *  Make sure that the display parameters have not changed, including
 *  the name of the TT font(s).
 *
 *  If they have, we BLAST OUR CACHE since it is no longer any good.
 *
 *  Entry:
 *      szTTFaceName contains the name of the TrueType font to use.
 *
 *  Returns:
 *      None.
 */

void CheckDisplayParameters(void)
{
    HDC         hIC;
    HKEY        hk;
    DISPLAYPARAMETERS dpTrue, dpStored;

    hIC = CreateIC(szDisplay, 0, 0, 0);

    if (!hIC) {
        /*
         * If things are really screwy, stay conservative and assume
         * that all is well.
         */
        return;
    }

    dpTrue.dpHorzSize   = GetDeviceCaps(hIC, HORZSIZE);
    dpTrue.dpVertSize   = GetDeviceCaps(hIC, VERTSIZE);
    dpTrue.dpHorzRes    = GetDeviceCaps(hIC, HORZRES);
    dpTrue.dpVertRes    = GetDeviceCaps(hIC, VERTRES);
    dpTrue.dpLogPixelsX = GetDeviceCaps(hIC, LOGPIXELSX);
    dpTrue.dpLogPixelsY = GetDeviceCaps(hIC, LOGPIXELSY);
    dpTrue.dpAspectX    = GetDeviceCaps(hIC, ASPECTX);
    dpTrue.dpAspectY    = GetDeviceCaps(hIC, ASPECTY);
    dpTrue.dpBitsPerPixel = GetDeviceCaps(hIC, BITSPIXEL);
    DeleteDC(hIC);

    /*
     *  Since szTTFaceName is pre-initialized to "Courier New" padded
     *  with nulls, we can rely on the garbage after the end of the
     *  string always to be the same, so that a pure memory comparison
     *  will work.
     */
    MultiByteToWideChar(CP_ACP, 0, szTTFaceName[0], -1, dpTrue.szTTFace[0], ARRAYSIZE(dpTrue.szTTFace[0]));
    if (IsBilingualCP(g_uCodePage))
        MultiByteToWideChar(CP_ACP, 0, szTTFaceName[1], -1, dpTrue.szTTFace[1], ARRAYSIZE(dpTrue.szTTFace[1]));

    /*
     *  We must store the dimension information in the registry because
     *  the install program for Omar Sharif Bridge will ERASE! your
     *  SYSTEM.INI if it contains a line greater than 78 characters.
     *  (I am not making this up.  How could I?)
     */

    if (RegCreateKey(HKEY_LOCAL_MACHINE, TEXT(REGSTR_PATH_MSDOSEMU), &hk) == 0) {
        DWORD cb = sizeof(DISPLAYPARAMETERS);
        if (SHQueryValueEx(hk, REGSTR_MSDOSEMU_DISPLAYPARAMS, 0, 0, (LPVOID)&dpStored, &cb) != 0 || cb != sizeof(DISPLAYPARAMETERS) || IsBufferDifferent(&dpTrue, &dpStored, sizeof(DISPLAYPARAMETERS))) {
            /*
             * Not much we can do if the write fails, so don't check.
             */
            VERIFYTRUE(RegSetValueEx(hk, REGSTR_MSDOSEMU_DISPLAYPARAMS, 0, REG_BINARY, (LPVOID)&dpTrue, cb) == 0);

            /* Blast the font dimension cache */
            WritePrivateProfileString(szTTCacheSection[1], NULL, NULL, szSystemINI);
            if (IsBilingualCP(g_uCodePage))
                WritePrivateProfileString(szTTCacheSection[0], NULL, NULL, szSystemINI);
        }
        VERIFYTRUE(RegCloseKey(hk) == 0);
    } else {
        /*
         *  Couldn't access registry.  Oh well.
         */
    }

}

/*
 *  When the dialog box is created, we create the Window
 *  Preview child window, as well as the Font Preview window.
 *
 *  The creation is deferred until the actual dialog box creation
 *  because the size and shape of the Window Preview window depends
 *  on the current video driver.
 */

void PreviewInit(HWND hDlg, PFNTINFO pfi)
{
    HWND hwnd;
    RECT rectLabel, rcPreview;

    /*
     * Compute the size of our preview window.
     *
     *  The top is aligned with the top of IDC_WNDPREVIEWLBL,
     *          minus a top margin of 3/2 dyChar.
     *  The left edge is aligned with the left edge of IDC_WNDPREVIEWLBL.
     *  The maximum width is the width of IDC_WNDPREVIEWLBL.
     *  The bottom edge can go as far down as the bottom of the dialog,
     *          minus a bottom margin of 3/2 dyChar.
     *  And the shape of the preview window is determined by the screen
     *          dimensions.
     *
     * We make the preview window as large as possible, given these
     * constraints.
     *
     */
    GetWindowRect(GetDlgItem(hDlg, IDC_WNDPREVIEWLBL), &rectLabel);
    ScreenToClient(hDlg, (LPPOINT)&rectLabel);
    ScreenToClient(hDlg, (LPPOINT)&rectLabel.right);

    /*
     * This GetWindowRect/ScreenToClient sets rcPreview.top.
     */
    GetWindowRect(GetDlgItem(hDlg, IDC_WNDPREVIEWLBL), &rcPreview);
    ScreenToClient(hDlg, (LPPOINT)&rcPreview);

    /*
     * Compute height based on width.
     */
    rcPreview.top += 3 * dyChar / 2;
    rcPreview.left = rectLabel.left;
    rcPreview.right = rectLabel.right - rectLabel.left;
    rcPreview.bottom = AspectScale(cyScreen, cxScreen, rcPreview.right);

    /*
     * Phew.  Now we can create the preview window.
     */
    hwnd = CreateWindowEx(
        WS_EX_CLIENTEDGE,
        szWndPreviewClass, NULL,
        WS_CHILD | WS_VISIBLE,
        rcPreview.left, rcPreview.top,
        rcPreview.right, rcPreview.bottom,
        hDlg, (HMENU)IDC_WNDPREVIEW, g_hinst, NULL);

    if (hwnd)
        SetWindowLongPtr(hwnd, 0, (LONG_PTR)pfi);

    /*
     * Compute the size of the font preview.  This is easier.
     */
    GetWindowRect(GetDlgItem(hDlg, IDC_FONTPREVIEWLBL), &rectLabel);
    ScreenToClient(hDlg, (LPPOINT)&rectLabel.left);
    ScreenToClient(hDlg, (LPPOINT)&rectLabel.right);

    hwnd = CreateWindowEx(
        WS_EX_CLIENTEDGE,
        szFontPreviewClass, NULL,
        WS_CHILD | WS_VISIBLE,
        rectLabel.left,
        rectLabel.top + 3 * dyChar / 2,
        rectLabel.right - rectLabel.left,
        rcPreview.bottom,
        hDlg, (HMENU)IDC_FONTPREVIEW, g_hinst, NULL);

    if (hwnd)
        SetWindowLongPtr(hwnd, 0, (LONG_PTR)pfi);
}


/*  PreviewUpdate
 *
 *  Does the preview of the selected font.
 */

void PreviewUpdate(HWND hwndList, PFNTINFO pfi)
{
    HWND hDlg;
    BPFDI bpfdi;

    /* Delete the old font if necessary */
    if (pfi->hFontPreview)
    {
        DeleteObject(pfi->hFontPreview);
        pfi->hFontPreview = NULL;
    }

    /* When we select a font, we do the font preview by setting it
     * into the appropriate list box
     */
    bpfdi = (BPFDI)GetFont(hwndList, TRUE, pfi);
    if (IsSpecialBpfdi(bpfdi))
        return;

    /* Update our internal font structure so that preview window
     * will actually change
     */
    pfi->bpfdi = bpfdi;
    SetFont(&pfi->fntProposed, bpfdi);

    /* Make the new font */
    pfi->hFontPreview = CreateFontFromBpfdi(bpfdi, pfi);

    /* Force the preview windows to repaint */
    hDlg = GetParent(hwndList);
    InvalidateRect(GetDlgItem(hDlg, IDC_WNDPREVIEW), NULL, TRUE);
    InvalidateRect(GetDlgItem(hDlg, IDC_FONTPREVIEW), NULL, TRUE);
}


/*  WndPreviewWndProc
 *
 *  Handles the window preview window.
 */

LRESULT WndPreviewWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
    case WM_PAINT:
        WndPreviewPaint(GetParent(hwnd), hwnd);
        break;

    case WM_HELP:       // Handles title bar help button message
        WinHelp(hwnd, NULL, HELP_CONTEXTPOPUP, IDH_DOS_FONT_WINDOW_PREVIEW);
        break;

    case WM_RBUTTONUP:
    case WM_NCRBUTTONUP: // Equivalent of WM_CONTEXTMENU
        OnWmContextMenu((WPARAM)hwnd, &rgdwHelp[0]);
        break;

    default:
        return DefWindowProc(hwnd, uMsg, wParam, lParam);
    }

    return 0;
}

/*  Swiped from Control Panel / Metrics.
 *
 *  Draws the frame *and* modifies the rectangle to contain the
 *  shrunk coordinates.
 */
void _DrawFrame(HDC hdc, int clr, LPRECT lprc, int cx, int cy)
{
    HBRUSH hbr;
    RECT rcT;

    CopyRect(&rcT, lprc);
    hbr = SelectObject(hdc, GetSysColorBrush(clr));

    /* Left */
    PatBlt(hdc, rcT.left, rcT.top, cx, rcT.bottom-rcT.top, PATCOPY);
    rcT.left += cx;

    /* Top */
    PatBlt(hdc, rcT.left, rcT.top, rcT.right-rcT.left, cy, PATCOPY);
    rcT.top += cy;

    /* Right */
    rcT.right -= cx;
    PatBlt(hdc, rcT.right, rcT.top, cx, rcT.bottom-rcT.top, PATCOPY);

    /* Bottom */
    rcT.bottom -= cy;
    PatBlt(hdc, rcT.left, rcT.bottom, rcT.right-rcT.left, cy, PATCOPY);

    SelectObject(hdc, hbr);
    CopyRect(lprc, &rcT);
}


/*  WndPreviewPaint
 *
 *  Paints the window preview window.  This is called from its
 *  paint message handler.
 *
 */

void WndPreviewPaint(HWND hDlg, HWND hwnd)
{
    PPROPLINK ppl;
    PFNTINFO pfi;
    RECT rcPreview;
    RECT rcWin;
    RECT rcClient;
    RECT rcT;
    POINT ptButton;
#define cxButton    ptButton.x
#define cyButton    ptButton.y
    POINT ptCorner;
    POINT ptFrame;
#define cxFrame    ptFrame.x
#define cyFrame    ptFrame.y
    BPFDI bpfdi;
    int cxBorder, cyBorder;
    int dyToolbar;
    PAINTSTRUCT ps;
    BOOL bCenter;

    BeginPaint(hwnd, &ps);

    pfi = (PFNTINFO)GetWindowLongPtr(hwnd, 0);

    ppl = pfi->ppl;
    ASSERTTRUE(ppl->iSig == PROP_SIG);

    bpfdi = pfi->bpfdi;

    /* If we don't have a font, get out */
    if (!pfi->hFontPreview)
        return;

    /* Get the width of the preview "screen" */
    GetClientRect(hwnd, &rcPreview);

    /* Figure out how large we would be as a result of the change.
     * This isn't perfect, but it'll probably be close enough.
     * (Imperfection if we chose AUTO as the font.)
     */

    /* Assume maximized */
    rcClient.left = rcClient.top = 0;
    if (pfi->winOriginal.cxCells) {
        rcClient.right = pfi->winOriginal.cxCells * bpfdi->fdiWidthActual;
    } else {
        rcClient.right = 80 * bpfdi->fdiWidthActual;
    }

    if (pfi->winOriginal.cyCells) {
        rcClient.bottom = pfi->winOriginal.cyCells * bpfdi->fdiHeightActual;
    } else {
        PROPVID vid;

        // set default value
        rcClient.bottom = 25 * bpfdi->fdiHeightActual;

        // now see if there is a value in the pif file for size of window...
        if (PifMgr_GetProperties(ppl, MAKELP(0,GROUP_VID),
                        &vid, sizeof(vid), GETPROPS_NONE))
        {
            if (vid.cScreenLines > 0)
                rcClient.bottom = vid.cScreenLines * bpfdi->fdiHeightActual;

        }
    }
    if (!pfi->fMax && pfi->winOriginal.cxClient && pfi->winOriginal.cyClient) {
        /* Shrink down to window actual */
        if (rcClient.right > (int)pfi->winOriginal.cxClient)
            rcClient.right = (int)pfi->winOriginal.cxClient;
        if (rcClient.bottom > (int)pfi->winOriginal.cyClient)
            rcClient.bottom = (int)pfi->winOriginal.cyClient;
    }

    /* Get some more metrics */
    cxBorder = GetSystemMetrics(SM_CXBORDER);
    cyBorder = GetSystemMetrics(SM_CYBORDER);

    cxButton = GetSystemMetrics(SM_CXSIZE);
    cyButton = GetSystemMetrics(SM_CYSIZE);
//  cyButton *= 2;                      /* Double the height for "looks" */

    cxFrame = GetSystemMetrics(SM_CXFRAME);
    cyFrame = GetSystemMetrics(SM_CYFRAME);

    /* FLAG DAY!  Convert everything from desktop coordinates to
     * aspect ratio-scaled preview coordinates
     *
     * Do **not** convert cxBorder and cyBorder!
     *
     * ptCorner must not be modified in-place since its value is used at
     * the next go-round.
     *
     * After translation, cxFrame and cyFrame are adjusted so that the
     * cxBorder counts against them.  This allows for users who set
     * really wide frames, but doesn't penalize the users who have
     * narrow frames.
     */

    ptCorner = pfi->ptCorner;
    bCenter = (ptCorner.x == -1);
    AspectPoint(&rcPreview, &ptCorner);
    AspectPoint(&rcPreview, &ptFrame);
    AspectRect(&rcPreview, &rcClient);
    AspectPoint(&rcPreview, &ptButton);

    /*
     * The height of a toolbar is hard-coded at 30 pixels.
     */
    if (pfi->winOriginal.flWin & WIN_TOOLBAR) {
        dyToolbar = (int)AspectScale(rcPreview.bottom, cyScreen, 30);
    } else {
        dyToolbar = 0;
    }

    /* Make sure the buttons are nonzero in dimension */
    if (cxButton == 0) cxButton = 1;
    if (cyButton == 0) cyButton = 1;

    /*
     * Don't penalize people who have thin frames.
     */
    if (cxFrame < cxBorder) cxFrame = cxBorder;
    if (cyFrame < cyBorder) cyFrame = cyBorder;

    /*
     * Convert from client rectangle back to window rectangle.
     *
     * We must do this *AFTER* the flag day, because we need to use the
     * post-flag day cxBorder and cyBorder.
     */

    /* Put a (scaled-down) toolbar into place.  We'll expand the client
     * region to accomodate it.  (We'll subtract the toolbar off before
     * painting the client region.)
     */
    rcClient.bottom += dyToolbar;

    /* Shove the client region down to make room for the caption. */
    OffsetRect(&rcClient, 0, cyButton);

    rcWin = rcClient;
    rcWin.top = 0;
    InflateRect(&rcWin, cxFrame, cyFrame);

    /*
     * Now put it in the proper position on the (shrunk-down) desktop.
     * We cannot do this until rcWin's value is finalized.
     */
    if (bCenter)
    {
        ptCorner.x = ((rcPreview.right - rcPreview.left) -
                       (rcWin.right  - rcWin.left)
                     ) / 2;
        if (ptCorner.x < 0)
            ptCorner.x = 0;

        ptCorner.y = ((rcPreview.bottom - rcPreview.top) -
                       (rcWin.bottom  - rcWin.top)
                     ) / 5;
        if (ptCorner.y < 0)
            ptCorner.y = 0;

    }
    OffsetRect(&rcWin, ptCorner.x, ptCorner.y);
    OffsetRect(&rcClient, ptCorner.x, ptCorner.y);

    /* It's party time! */

    /* The outer border */
    DrawEdge(ps.hdc, &rcWin, BDR_RAISEDINNER, BF_RECT | BF_ADJUST);

    /* The sizing frame */
    _DrawFrame(ps.hdc, COLOR_ACTIVEBORDER,
                    &rcWin, cxFrame - cxBorder, cyFrame - cyBorder);

    /* rcWin has now shrunk to its inner edge */

    /* Move its bottom edge upwards to meet the top of the client region.
     * This turns rcWin into the caption area.
     */
    rcWin.bottom = rcClient.top;
    FillRect(ps.hdc, &rcWin, (HBRUSH)(COLOR_ACTIVECAPTION+1));

    /* Next comes the toolbar */
    rcT= rcClient;
    rcT.bottom = rcT.top + dyToolbar;
    FillRect(ps.hdc, &rcT, (HBRUSH)(COLOR_BTNFACE+1));

    /* Next, draw the client region */
    rcClient.top += dyToolbar;
    DrawEdge(ps.hdc, &rcClient, BDR_SUNKENOUTER, BF_RECT | BF_ADJUST);
    FillRect(ps.hdc, &rcClient, (HBRUSH)GetStockObject(BLACK_BRUSH));

    /*
     * Now draw the three caption buttons.
     */

    /*
     * The system menu.
     */
    rcT = rcWin;
    rcT.right = rcT.left + cxButton;
  //DrawFrameControl(ps.hdc, &rcT, DFC_SYSMENU, DFCS_SYSMENUMAIN);
    DrawFrameControl(ps.hdc, &rcT, DFC_CAPTION, DFCS_CAPTIONCLOSE);

    /*
     * The maximize menu.
     */
    rcWin.left = rcWin.right - cxButton;
  //DrawFrameControl(ps.hdc, &rcWin, DFC_SIZE, DFCS_SIZEMAX);
    DrawFrameControl(ps.hdc, &rcWin, DFC_CAPTION, DFCS_CAPTIONMAX);

    /*
     * The minimize menu.
     */
    rcWin.left -= cxButton;
    rcWin.right -= cxButton;
  //DrawFrameControl(ps.hdc, &rcWin, DFC_SIZE, DFCS_SIZEMIN);
    DrawFrameControl(ps.hdc, &rcWin, DFC_CAPTION, DFCS_CAPTIONMIN);

    EndPaint(hwnd, &ps);
}
#undef cxButton
#undef cyButton

#undef cxFrame
#undef cyFrame

LRESULT FontPreviewWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    RECT rect;
    PFNTINFO pfi;
    PAINTSTRUCT ps;

    switch (uMsg)
    {
    case WM_PAINT:
        BeginPaint(hwnd, &ps);

        pfi = (PFNTINFO)GetWindowLongPtr(hwnd, 0);

        /* Draw the font sample */
        SelectObject(ps.hdc, pfi->hFontPreview);
        SetTextColor(ps.hdc, RGB(192, 192, 192));
        SetBkColor(ps.hdc, RGB(0, 0, 0));
        GetClientRect(hwnd, &rect);
        InflateRect(&rect, -2, -2);

        {
            TCHAR szPreviewText[300];
            LoadString(g_hinst, IsBilingualCP(pfi->fntProposed.wCurrentCP) ? IDS_PREVIEWTEXT_BILNG : IDS_PREVIEWTEXT, szPreviewText, ARRAYSIZE(szPreviewText));
            // load a sample for their native codepage
            DrawText(ps.hdc, szPreviewText, -1, &rect, 0);
        }

        EndPaint(hwnd, &ps);
        break;

    case WM_HELP:       // Handles title bar help button message
        WinHelp(hwnd, NULL, HELP_CONTEXTPOPUP, IDH_DOS_FONT_FONT_PREVIEW);
        break;

    case WM_RBUTTONUP:
    case WM_NCRBUTTONUP: // Equivalent of WM_CONTEXTMENU
        OnWmContextMenu((WPARAM)hwnd, &rgdwHelp[0]);
        break;

    default:
        return DefWindowProc(hwnd, uMsg, wParam, lParam);
    }

    return 0;
}


/*
 *  Loads the dialog control hwndList with all available font
 *  dimensions for raster fonts, and a selected collection of
 *  dimensions for TrueType fonts.
 *
 *  The reference data for each control is an index into lpfniCache.
 *
 *  The hourglass cursor is displayed during the font list build.
 *
 *  Entry:
 *      hwndList == handle to listbox or combo box to fill
 *      fListBox == TRUE if hwndList is a listbox, FALSE if a combo box
 *      lpFnt    -> PROPFNT structure
 *
 *      If HIWORD(lpFnt) is NULL, then LOWORD(lpFnt) is used as an hProps
 *      to get obtain property info for that handle.
 *
 *  Returns:
 *      >= 0 on success, indicating the current selection.
 *      In which case the FDI cache is valid and hwndList has been filled
 *      with font information, and the currently-selected font has been
 *      made the current selection.
 *
 *      LB_ERR/CB_ERR on failure.  The list box hwndList is left in an
 *      indeterminate state.
 */

int WINAPI CreateFontList(HWND hwndList, BOOL fListBox, LPPROPFNT lpFnt)
{
    DWORD   dwIndex;
    HCURSOR hcursor;
    PROPFNT fntTemp;
    int     iReturn = LB_ERR;
    TCHAR   szBuf[MAXDIMENSTRING];

    if (IS_INTRESOURCE(lpFnt))
    {
        if (!PifMgr_GetProperties(lpFnt, MAKELP(0,GROUP_FNT),
                           &fntTemp, sizeof(fntTemp), GETPROPS_NONE))
            goto Exit2;

        lpFnt = &fntTemp;
    }

    /*
     * Put up an hourglass while the font list build is taking place,
     * since it might take a long time if we have to re-rasterize
     * TrueType fonts.
     *
     * NOTE!  That we do not do a ShowCursor.  Why?
     *
     *  If the user is on a mouseless system, then he can't access his
     *  toolbar, and hence the only time this code can get called is
     *  during the creation of the font selection dialog box.  In which
     *  case, DialogBox has already done a ShowCursor for us.
     *
     */
    hcursor = SetCursor(hcursorWait);

    /*
     * Initialize the list box.
     */
    if (hwndList) {
        SendMessage(hwndList, WM_SETREDRAW, FALSE, 0L);
        SendMessage(hwndList, fListBox ? LB_RESETCONTENT : CB_RESETCONTENT, 0, 0L);
    }

    /*
     * Add the fonts.
     */
    if ((lpFnt->flFnt & FNT_RASTERFONTS) &&
        !AddRasterFontsToFontListA(hwndList, fListBox,
                                  lpFnt->achRasterFaceName, lpFnt->wCurrentCP))
        goto Exit;

    if ((lpFnt->flFnt & FNT_TTFONTS) &&
        !AddTrueTypeFontsToFontListA(hwndList, fListBox,
                                  lpFnt->achTTFaceName, lpFnt->wCurrentCP))
        goto Exit;

    /*
     * And the magical "Auto" font size.
     */

    /*
     * Beyond this point, success is assured, so at the very least,
     * DON'T return LB_ERR;  we may optionally set the return code to
     * the current selection, below, too...
     */
    iReturn = 0;

    if (hwndList) {
        /*
         * No error checking here because if anything fails, then the
         * end result will be merely that the "Auto" option either
         * (1) exists but is invisible, or (2) doesn't appear at all.
         */
        LoadString(g_hinst, IDS_AUTO, szBuf, ARRAYSIZE(szBuf));
        dwIndex = lcbInsertString(hwndList, fListBox, szBuf, 0);
        lcbSetItemDataPair(hwndList, fListBox, dwIndex, BPFDI_AUTO, 0);

        /*
         * Make yet another pass through the list to find the current
         * font and select it.  Thanks to an intentional flakiness
         * in USER, we can't do this check at the point that the
         * font is added, because the selection does not move with the
         * item when a new item is inserted above the selection.
         *
         * Bleah.
         */
        if (!MatchCurrentFont(hwndList, fListBox, lpFnt)) {
            /*
             * If no font matched the current font, and we are a list box,
             * then make the first font the current selection.
             *
             * We don't want to make any default selection if we are a
             * combo box, because that would make the user think that the
             * current font was something it wasn't.
             */
            if (fListBox) {
                /*
                 * SORTING-SENSITIVE!  This assumes that "Auto" is at the top
                 * of the list.
                 */
                lcbSetCurSel(hwndList, TRUE, 0);
                lpFnt->flFnt |= FNT_AUTOSIZE;
            }
        }
        SendMessage(hwndList, WM_SETREDRAW, TRUE, 0L);

        iReturn = lcbGetCurSel(hwndList, fListBox);
    }
Exit:
    /*
     * Reset the mouse cursor.
     */
    SetCursor(hcursor);

Exit2:
    return iReturn;
}


/** UpdateTTBitmap
 *
 *  Recompute the colors for the TrueType bitmap hbmFont.
 *
 *  Since we may receive this several times for a single WM_SYSCOLORCHANGE,
 *  we update our colors under the following conditions:
 *
 *      1. More than one second has elapsed since the previous call, or
 *      2. A crude checksum fails.
 *
 *  Entry:
 *      None.
 *
 *  Returns:
 *      hbmFont recomputed.
 */

VOID WINAPI UpdateTTBitmap(void)
{
    COLORREF clr;

    /*
     *  Note that the checksum should not be a symmetric function,
     *  because a common color alteration is to exchange or permute
     *  the colors.
     */
    clr = +  GetSysColor(COLOR_BTNTEXT)
          -  GetSysColor(COLOR_BTNSHADOW)
          + (GetSysColor(COLOR_BTNFACE) ^ 1)
          - (GetSysColor(COLOR_BTNHIGHLIGHT) ^ 2)
          ^  GetSysColor(COLOR_WINDOW);

    if (!hbmFont || clr != clrChecksum || GetTickCount() - dwTimeCheck < 1000) {
        clrChecksum = clr;
        dwTimeCheck = GetTickCount();
        if (hbmFont) DeleteObject(hbmFont);
        hbmFont = CreateMappedBitmap(g_hinst, IDB_TTBITMAP, 0, NULL, 0);
    }
}


/** DrawItemFontList
 *
 *  Answer the WM_DRAWITEM message sent from the font list box or
 *  font combo box.
 *
 *  This code was originally lifted from FONT.C in sdk\commdlg.
 *
 *  See fontutil.h for an explanation of the \1 hack.
 *
 *  Entry:
 *      fListBox    =  TRUE if the item is a list box, FALSE if a combo box
 *      lpdis       -> DRAWITEMSTRUCT describing object to be drawn
 *
 *  Returns:
 *      None.
 *
 *      The object is drawn.
 */

#define cTabsList 3

typedef struct DIFLINFO {
    LPTSTR       di_lpsz;
    PINT        di_pTabs;
} DIFLINFO, *LPDIFLINFO;

#define lpdi ((LPDIFLINFO)lp)
BOOL CALLBACK diflGrayStringProc(HDC hdc, LPARAM lp, int cch)
{
    return (BOOL)TabbedTextOut(hdc, 0, 0,
                  lpdi->di_lpsz, lstrlen(lpdi->di_lpsz),
                  cTabsList, lpdi->di_pTabs, 0);

}
#undef lpdi

VOID WINAPI DrawItemFontList(BOOL fListBox, const LPDRAWITEMSTRUCT lpdis)
{
    HDC     hDC, hdcMem;
    DWORD   rgbBack, rgbText;
    int     iColorBack;
    COLORREF clrText;
    COLORREF clrBack;
    TCHAR    szDimen[MAXDIMENSTRING];
    HBITMAP hOld;
    int     dy;
    DIFLINFO di;
    static int rgTabsList[cTabsList] = {0, 0, 0};
    static int rgTabsCombo[cTabsList] = {0, 0, 0};
#define lpsz di.di_lpsz
#define pTabs di.di_pTabs

    if ((int)lpdis->itemID < 0)
        return;

    hDC = lpdis->hDC;

    if (lpdis->itemAction & ODA_FOCUS) {
        if (lpdis->itemState & ODS_SELECTED) {
            DrawFocusRect(hDC, &lpdis->rcItem);
        }
    } else {
        if (lpdis->itemState & ODS_SELECTED) {
            clrBack = GetSysColor(iColorBack = COLOR_HIGHLIGHT);
            clrText = GetSysColor(COLOR_HIGHLIGHTTEXT);
        } else {
            clrBack = GetSysColor(iColorBack = COLOR_WINDOW);
            clrText = GetSysColor(IsWindowEnabled(lpdis->hwndItem) ?
                                        COLOR_WINDOWTEXT : COLOR_GRAYTEXT);
        }
        rgbText = SetTextColor(hDC, clrText);
        rgbBack = SetBkColor(hDC, clrBack);

        // draw selection background
        FillRect(hDC, &lpdis->rcItem, (HBRUSH)UIntToPtr((iColorBack + 1)));

        // get the string
        SendMessage(lpdis->hwndItem, fListBox ? LB_GETTEXT : CB_GETLBTEXT, lpdis->itemID, (LPARAM)(LPTSTR)szDimen);

        lpsz = szDimen;
        if (szDimen[0] == TEXT('\1'))   // hack for "Auto" string
            lpsz++;

        if (fListBox)
            pTabs = rgTabsList;
        else
            pTabs = rgTabsCombo;

        if (pTabs[0] == 0) {            /* Never seen this font before */
            /* Assumes GetTextExtent(hDC, ANSI_TIMES, 1) < 2 * dxChar */
            SIZE sSize;
            GetTextExtentPoint32(hDC, szZero, 1, &sSize); // size of '0'
            /* A negative # for tab stop right aligns the tabs... */
            pTabs[0] = -sSize.cx * 3;
            pTabs[1] = -sSize.cx * 5;
            pTabs[2] = -sSize.cx * 8;
        }

        // draw the text
        //
        // Note that the SDK dox for GrayString says that you can detect
        // whether GrayString is needed by saying
        //
        //      if (GetSysColor(COLOR_GRAYTEXT) == 0) {
        //          GrayString(...);
        //      } else {
        //          TextOut(...);
        //      }
        //
        // This is incorrect.  The correct test is the one below, which
        // also catches bad color combinations on color devices.
        //
        if (clrText == clrBack) {
            SetTextColor(hDC, GetSysColor(COLOR_WINDOWTEXT));
            GrayString(hDC, GetStockObject(GRAY_BRUSH), diflGrayStringProc ,
                       (LPARAM)(LPVOID)&di, 0,
                        lpdis->rcItem.left + DX_TTBITMAP,
                        lpdis->rcItem.top,
                        lpdis->rcItem.right - lpdis->rcItem.left - DX_TTBITMAP,
                        lpdis->rcItem.bottom - lpdis->rcItem.top);
        } else {
            TabbedTextOut(hDC, lpdis->rcItem.left + DX_TTBITMAP, lpdis->rcItem.top, lpsz, lstrlen(lpsz), cTabsList, pTabs, DX_TTBITMAP);
        }

        // and the bitmap if needed
        if (!IsSpecialBpfdi((BPFDI)lpdis->itemData))
        {
            if (((BPFDI)(lpdis->itemData))->bTT) {
                hdcMem = CreateCompatibleDC(hDC);
                if (hdcMem) {
                    hOld = SelectObject(hdcMem, hbmFont);

                    dy = ((lpdis->rcItem.bottom - lpdis->rcItem.top) - DY_TTBITMAP) / 2;

                    BitBlt(hDC, lpdis->rcItem.left, lpdis->rcItem.top + dy,
                        DX_TTBITMAP, DY_TTBITMAP, hdcMem, 0,
                        lpdis->itemState & ODS_SELECTED ? 0 : DY_TTBITMAP, SRCCOPY);

                    if (hOld)
                        SelectObject(hdcMem, hOld);
                    DeleteDC(hdcMem);
                }
            }
        }

        SetTextColor(hDC, rgbText);
        SetBkColor(hDC, rgbBack);

        if (lpdis->itemState & ODS_FOCUS) {
            DrawFocusRect(hDC, &lpdis->rcItem);
        }
    }
}
#undef lpsz
#undef pTabs


/** MeasureItemFontList
 *
 *  Answer the WM_MEASUREITEM message sent from the font list box or
 *  font combo box. shared between the toolbar combo box code and
 *  the font preview property sheet
 *
 *  Entry:
 *      lpmi -> LPMEASUREITEMSTRUCT describing object to be measured
 *
 *  Returns:
 *      TRUE.
 *
 *      lpmi->itemHeight filled with actual item height.
 */

LONG WINAPI MeasureItemFontList(LPMEASUREITEMSTRUCT lpmi)
{
    lpmi->itemHeight = dyItem;
    return TRUE;
}


/** GetItemFontInfo
 *
 *  Returns font information for the current selection in the given
 *  listbox/combobox.
 *
 *  Entry:
 *      hwndList == handle to listbox or combo box to fill
 *                  if NULL, then AUTO is assumed
 *      fListBox == TRUE if hwndList is a listbox, FALSE if a combo box
 *      hProps   == property handle
 *      lpFnt    -> PROPFNT structure (filled in upon return)
 *
 *  Returns:
 *      LB_ERR/CB_ERR on error, index of current selection otherwise
 */

int WINAPI GetItemFontInfo(HWND hwndList, BOOL fListBox, HANDLE hProps, LPPROPFNT lpFnt)
{
    DWORD_PTR dw;
    int index;

    /*
     * Get font defaults;  the nice thing about this call is that
     * it also takes care of calling ChooseBestFont if AUTOSIZE is set,
     * which means we can tell GetFont() to not bother.
     */
    PifMgr_GetProperties(hProps, MAKELP(0,GROUP_FNT),
                  lpFnt, sizeof(PROPFNT), GETPROPS_NONE);

    dw = GetFont(hwndList, fListBox, NULL);
    if (IsSpecialBpfdi((BPFDI)dw))
    {
        return 0;
    }

    index = ((BPFDI)dw)->Index;
    if (index == 0)
        lpFnt->flFnt |= FNT_AUTOSIZE;
    else if (index > 0)
        lpFnt->flFnt &= ~FNT_AUTOSIZE;

    /*
     * Fill the caller's PROPFNT structure with all the font goodies (if any)
     *
     * Note that this does nothing if we ended up picking the AUTO font.
     */
    SetFont(lpFnt, (BPFDI)dw);

    return index;
}


/** MatchCurrentFont
 *
 *  Locates the current font in the indicated list box and
 *  makes him the current selection.
 *
 *  If we are in auto-mode, then "Auto" is selected.
 *
 *  Entry:
 *      hwndList == handle to listbox or combo box
 *      fListBox == TRUE if hwndList is a listbox, FALSE if a combo box
 *      lpFnt    -> PROPFNT structure
 *
 *  Returns:
 *      TRUE if the current font was found and selected.
 */
BOOL WINAPI MatchCurrentFont(HWND hwndList, BOOL fListBox, LPPROPFNT lpFnt)
{
    BPFDI bpfdi;
    DWORD dwCount, dwIndex;
    BOOL  fCurFontIsTt = !!(lpFnt->flFnt & FNT_TT);

    if (lpFnt->flFnt & FNT_AUTOSIZE) {
        /*
         * SORTING-SENSITIVE!  This assumes that "Auto" is at the top
         * of the list.
         */
        lcbSetCurSel(hwndList, fListBox, 0);
        return TRUE;
    }
    dwCount = lcbGetCount(hwndList, fListBox);
    for (dwIndex = 0; dwIndex < dwCount; dwIndex++) {

        bpfdi = lcbGetBpfdi(hwndList, fListBox, dwIndex);

        if (!IsSpecialBpfdi(bpfdi)) {
            // bpfdi = (BPFDI)((DWORD)bpfdi + (DWORD)lpCache);
            if (bpfdi->fdiWidthActual  == lpFnt->cxFontActual &&
                bpfdi->fdiHeightActual == lpFnt->cyFontActual &&
                fCurFontIsTt == (bpfdi->fdiHeightReq != 0)) {

                    lcbSetCurSel(hwndList, fListBox, dwIndex);
                    return TRUE;
            }
        }
    }
    return FALSE;
}

/** AddRasterFontsToFontList
 *
 *  Enumerate the available dimensions for our OEM raster font
 *  and add them to the list or combo box.
 *
 *  Entry:
 *      hwndList        =  List box or combo box to fill with info
 *      fListBox        =  TRUE if hwndList is a listbox, FALSE if a combo box
 *      lpszRasterFaceName
 *
 *  Returns:
 *      TRUE if fonts were enumerated to completion.
 *      FALSE if enumeration failed.  (Out of memory.)
 *
 */
BOOL AddRasterFontsToFontListA(HWND hwndList, BOOL fListBox,
                                       LPCSTR lpszRasterFaceName, INT CodePage)
{
    HDC     hDC;
    BOOL    fSuccess;
    FNTENUMINFO FntEnum;

    hDC = GetDC(hwndList);
    if (!hDC) return FALSE;

    FntEnum.hwndList = hwndList;
    FntEnum.fListBox = fListBox;
    FntEnum.CodePage = CodePage;
    fSuccess = EnumFontFamiliesA(hDC,
                                lpszRasterFaceName,
                                (FONTENUMPROCA)RasterFontEnum,
                                (LPARAM)&FntEnum);
    ReleaseDC(hwndList, hDC);
    return TRUE;
}


/** RasterFontEnum
 *
 *  FONTENUMPROC for enumerating all available dimensions of the OEM
 *  raster font.
 *
 *  This routine is used to load the logical and physical font
 *  dimensions cache with information about raster fonts.
 *
 *  Entry:
 *      lpelf           \
 *      lpntm            > from EnumFonts (see SDK)
 *      nFontType       /
 *      hwndList        =  List box or combo box to fill with info
 *      fListBox        =  TRUE if hwndList is a listbox, FALSE if a combo box
 *
 *  Returns:
 *      TRUE to continue enumeration.
 *      FALSE to stop enumeration.  (Out of memory.)
 */

int CALLBACK RasterFontEnum(ENUMLOGFONTA *lpelf, NEWTEXTMETRICA *lpntm, int nFontType, LPARAM lParam)
{
#define fListBox  (((LPFNTENUMINFO)lParam)->fListBox)
#define hwndList  (((LPFNTENUMINFO)lParam)->hwndList)
#define CodePage (((LPFNTENUMINFO)lParam)->CodePage)
#define lpLogFont (&(lpelf->elfLogFont))

    /*
     * We only care about OEM fixed-pitch fonts.
     */
    if (lpLogFont->lfCharSet != OEMCharsetFromCP(CodePage)
        || (lpLogFont->lfPitchAndFamily & (TMPF_TRUETYPE | TMPF_FIXED_PITCH))
            != TMPF_FIXED_PITCH)
        return TRUE;

    return AddToFontListCache(hwndList,
                              fListBox,
                              0, 0,
                              lpLogFont->lfHeight,
                              lpLogFont->lfWidth,
                              CodePage) != BPFDI_CANCEL;
#undef lpLogFont
#undef fListBox
#undef hwndList
#undef CodePage
}

/** AddToFontListCache
 *
 *  Adds an entry to the font dimension information cache,
 *  growing the cache if necessary.
 *
 *  It also adds the entry to the indicated list box, provided
 *  the entry is not a duplicate.
 *
 *  Returns:
 *      BPFDI of the recently-added font, or BPFDI_CANCEL if out of memory.
 *
 *  Overview:
 *      (1) Grow the cache if necessary.
 *      (2) Add the information to the list/combo box.
 *      (3) Add the information to the cache.
 */
BPFDI AddToFontListCache(HWND hwndList,
                         BOOL fListBox,
                         UINT uHeightReq,
                         UINT uWidthReq,
                         UINT uHeightActual,
                         UINT uWidthActual,
                         UINT uCodePage)
{
    LPVOID  hCache;
    LONG_PTR lCacheSave;
    DWORD   dwIndex, ifdi;
    BPFDI   bpfdi;
    TCHAR   szBuf[MAXDIMENSTRING];
    int     idx;
    
    ASSERT(!((uHeightReq==0) && (uWidthReq==0) && (uHeightActual==0) && (uWidthActual==0)));
    /* Reject too-large fonts out of hand. */
    if (uHeightActual > MAX_FONT_HEIGHT) {
        return BPFDI_IGNORE;
    }

    /*
     * FIRST, determine whether this font entry has already been cached
     */

    // we maintain two set of cache entries in case we have two code page
    // to support
    // 
    idx = IsBilingualCP(uCodePage) ? 1 : 0; 
    
    for (ifdi = 0, bpfdi = (BPFDI)((DWORD_PTR)lpCache + bpfdiStart[idx]); ifdi < cfdiCache[idx]; ++ifdi, ++bpfdi)
    {
        if (bpfdi->fdiWidthReq == uWidthReq &&
            bpfdi->fdiHeightReq == uHeightReq &&
            bpfdi->fdiWidthActual == uWidthActual &&
            bpfdi->fdiHeightActual == uHeightActual)
                goto UpdateListCombo;
    }

    /*
     * Grow the cache if necessary.
     */
    if (cfdiCache[idx] >= cfdiCacheActual[idx]) {

        /*
         * save offset from beginning of cache
         */
        bpfdi = (BPFDI)((DWORD_PTR)bpfdi - (DWORD_PTR)lpCache);

        /*
         * save current lpCache value so can adjust entries in listbox
         * when we're done...
         */
        lCacheSave = (LONG_PTR)lpCache;
        hCache = LocalReAlloc(lpCache,
        (cfdiCacheActual[0] + cfdiCacheActual[1] + FDI_TABLE_INC) *
        sizeof(FONTDIMENINFO), LMEM_ZEROINIT|LMEM_MOVEABLE);
        if (!hCache)
            return BPFDI_CANCEL;
        lpCache = hCache;
        
        if (!idx && IsBilingualCP(g_uCodePage)) {
            /*
             * We need to shift 2nd cache before using expanded 1st chache
             */
            BPFDI bpfdi2;
            for (ifdi = cfdiCache[1],
                              bpfdi2 = (BPFDI)((DWORD_PTR)lpCache + bpfdiStart[1]) + ifdi - 1 + FDI_TABLE_INC ;
                                                  ifdi ; ifdi--, bpfdi2--) {
                *bpfdi2 = *(bpfdi2 - FDI_TABLE_INC);
            }
            bpfdiStart[1] += FDI_TABLE_INC;
        }
        /* restore bpfdi from saved offset */
        bpfdi = (BPFDI)((DWORD_PTR)lpCache + (DWORD_PTR)bpfdi);
        cfdiCacheActual[idx] += FDI_TABLE_INC;

        /*
         * Convert lCacheSave to an offset...
         */
        lCacheSave = (LONG_PTR)lpCache - lCacheSave;

        if (lCacheSave)
        {
            /*
             * Now, adjust each entry in the listbox to account for the new
             * relocated cache position..
             */

            dwIndex = lcbGetCount(hwndList, fListBox);
            for(ifdi = 0; ifdi < dwIndex; ifdi++)
            {
                LONG_PTR lBpfdi;

                lBpfdi = (LONG_PTR)lcbGetItemDataPair(hwndList, fListBox, ifdi);
                if (!IsSpecialBpfdi((BPFDI)lBpfdi))
                {
                    lBpfdi += lCacheSave;
                    lcbSetItemDataPair(hwndList, fListBox, ifdi, lBpfdi, ((BPFDI)lBpfdi)->bTT);
                }
            }
        }
    }

    /*
     * Now add the information to the cache.  All the casting on bpfdiCache
     * is just to inhibit a bogus compiler complaint.
     */
    bpfdi->fdiWidthReq  = uWidthReq;
    bpfdi->fdiHeightReq = uHeightReq;

    bpfdi->fdiWidthActual  = uWidthActual;
    bpfdi->fdiHeightActual = uHeightActual;

    cfdiCache[idx]++;

  UpdateListCombo:

    if (hwndList) {
        /*
         * Add the string to the list/combo box if it isn't there already.
         */
        wsprintf(szBuf, TEXT("\t%2d\tx\t%2d"), uWidthActual, uHeightActual);

        dwIndex = lcbFindStringExact(hwndList, fListBox, szBuf);

        if (IsDlgError(dwIndex)) {
            /*
             * Not already on the list.  Add it.
             */
            dwIndex = lcbAddString(hwndList, fListBox, szBuf);

            if (IsDlgError(dwIndex)) {
                return BPFDI_CANCEL;
            }
            lcbSetItemDataPair(hwndList, fListBox, dwIndex,
                               bpfdi, uHeightReq);
        }
    }
    return bpfdi;
}


/** AddTrueTypeFontsToFontListA
 *
 *  To avoid rasterizing all the fonts unnecessarily, we load the
 *  information from the szTTCacheSection font cache.
 *
 *  Note that the cache information is not validated!  We just
 *  assume that if the value is in the cache, it is valid.
 *
 *  Entry:
 *      hwndList        =  List box or combo box to fill with info
 *      fListBox        =  TRUE if hwndList is a listbox, FALSE if a combo box
 *      lpszTTFaceName
 *
 *  Returns:
 *      TRUE if fonts were enumerated to completion.
 *      FALSE if enumeration failed.  (Out of memory.)
 *
 *  Caveats:
 *      The ParseIniWords call assumes that the values were written
 *      by AddOneNewTrueTypeFontToFontList, who wrote them out so
 *      that a single call to ParseIniWords will read the height and
 *      width directly into a dwHeightWidth.
 *
 *      Similarly, the second ParseIniWords reads the item directly into
 *      a dwHeightWidth.
 */

BOOL AddTrueTypeFontsToFontListA(HWND hwndList, BOOL fListBox,
                                        LPSTR lpszTTFaceName, INT CodePage)
{
    LPTSTR  pszBuf;
    LPTSTR  pszBufNew;
    LPTSTR  psz;
    LPTSTR  lpszNext;
    DWORD   dwHWReq;
    DWORD   dwHWActual;
    BOOL    fSuccess;
    DWORD   cchBuf;
    DWORD   cchActual;
    int     i;
    int     idx = IsBilingualCP(CodePage) ? 1 : 0;
    
    /*
     * See if we can load everything out of the szTTCacheSection.
     *
     * There is no API to get the size of a profile string, so we
     * have to fake it by reading, reallocing, and reading again
     * until it all fits.
     *
     * The initial value of 1024 characters means that we can handle
     * up to 128 font sizes.  A comfortable number, we hope.
     */

    cchBuf = 1024;
    cchActual = 0;
    pszBufNew = (LPTSTR)LocalAlloc(LPTR, cchBuf*sizeof(TCHAR));

    while (pszBufNew) {
        pszBuf = pszBufNew;
        cchActual = GetPrivateProfileString(szTTCacheSection[idx], NULL,
                                         c_szNULL, pszBuf, cchBuf, szSystemINI);
        if (cchActual < cchBuf - 5) goto Okay;

        cchBuf += 512;
        pszBufNew = (LPTSTR)LocalReAlloc(pszBuf, cchBuf*sizeof(TCHAR), LMEM_MOVEABLE|LMEM_ZEROINIT);
    }

    /* Bleargh.  Too much stuff in the cache.  Punt it and start anew. */
    goto FreshStart;

Okay:

    fSuccess = FALSE;

    /*
     *  In the time between flushing the cache and reloading it here,
     *  a handful of fonts may have gotten added to the cache due to
     *  WinOldAp trying to realize the font it got back.  So consider the
     *  font cache decent if there are at least ten fonts in it.
     */
    if (cchActual >= 4 * 10) {

        /*
         * We found cache information.  Party away.
         */

        psz = pszBuf;
        while (*psz) {

            if (ParseIniWords(psz, (PWORD)&dwHWReq, 2, &lpszNext) != 2 ||
                GetIniWords(szTTCacheSection[idx], psz,
                            (PWORD)&dwHWActual, 2, szSystemINI) != 2) {
                /* Font cache looks bogus.  Start with a new one. */
                goto FreshStart;
            }

            if (AddToFontListCache(hwndList, fListBox,
                                   (UINT)HIWORD(dwHWReq),
                                   (UINT)LOWORD(dwHWReq),
                                   (UINT)HIWORD(dwHWActual),
                                   (UINT)LOWORD(dwHWActual),
                                   CodePage) == BPFDI_CANCEL)
                goto E0;
                
            psz = (LPTSTR)(lpszNext + 1);       /* Skip past the NUL */
        }

    }
    else
    {
FreshStart:
        /* Blast the old cache, just make sure we have a clean slate */
        WritePrivateProfileString(szTTCacheSection[idx], NULL, NULL, szSystemINI);

        /* No cache available.  Need to build one. */
        for (i = 0; i < NUMINITIALTTHEIGHTS; i++) 
        {
            if (rgwInitialTtHeights[i]) 
            {
                AddOneNewTrueTypeFontToFontListA(hwndList, fListBox,
                                                0, (UINT)rgwInitialTtHeights[i],
                                                lpszTTFaceName, CodePage);
            }
        }
    }

    fSuccess = TRUE;
E0:
    EVAL(LocalFree(pszBuf) == NULL);
    return fSuccess;
}


/*  Given height and width, synthesize a TrueType font with those
 *  dimensions and record the actual font height and width in
 *  the persistent font cache, as well as a FDI.
 *
 *  Entry:
 *      hwndList        =  List box or combo box to fill with info
 *      fListBox        =  TRUE if hwndList is a listbox, FALSE if a combo box
 *      wHeight         =  Desired font height
 *      wWidth          =  Desired font width (can be zero for "default")
 *      lpszTTFaceName
 *
 *  Returns:
 *      BPFDI of font dimension info, or BPFDI_CANCEL on failure.
 *
 *  Caveats:
 *      The wsprintf assumes that the fdiWidthReq and
 *      fdiHeightReq fields appear in the indicated order,
 *      because the values will be read into a dwHeightWidth later.
 *
 *      Similarly for the WriteIniWords.
 */

BPFDI AddOneNewTrueTypeFontToFontListA(HWND hwndList,
                                      BOOL fListBox,
                                      UINT uWidth, UINT uHeight,
                                      LPSTR lpszTTFaceName, INT CodePage)
{
    BPFDI   bpfdi;
    HDC     hDC;
    HFONT   hFont;
    SIZE    sSize;
    HFONT   hFontPrev;
    DWORD   dwHeightWidth;
    TCHAR   szBuf[MAXDIMENSTRING];

    int     idx;
    BYTE    bCharset;
    DWORD   fdwClipPrecision;

    bpfdi = BPFDI_CANCEL;

    hDC = GetDC(NULL);          /* Get a screen DC */
    if (!hDC) goto E0;
    
    // choose charset, clip precision based on codepage
    // 0xFE is a hack for japanese platform
    //
    bCharset = (CodePage == CP_JPN? 0xFE: OEMCharsetFromCP(CodePage));
    
    if (CodePage == CP_US)
        fdwClipPrecision = CLIP_DEFAULT_PRECIS|(g_uCodePage == CP_WANSUNG? CLIP_DFA_OVERRIDE: 0);
    else
        fdwClipPrecision = CLIP_DEFAULT_PRECIS;

    hFont = CreateFontA((INT)uHeight, (INT)uWidth, 0, 0, 0, 0, 0, 0,
               bCharset, OUT_TT_PRECIS,
               fdwClipPrecision, 0, FIXED_PITCH | FF_DONTCARE, lpszTTFaceName);
               
    if (!hFont) goto E1;

    hFontPrev = SelectObject(hDC, hFont);
    if (!hFontPrev) goto E2;

    if (GetTextExtentPoint32(hDC, szZero, 1, &sSize))
    {
        dwHeightWidth = (sSize.cy << 16) | (sSize.cx & 0x00FF);
    }
    else
    {
        dwHeightWidth = 0;
    }

    if (!dwHeightWidth) goto E3;

    if (IsBilingualCP(CodePage) && (HIWORD(dwHeightWidth)%2))
        goto E3;

    wsprintf(szBuf, TEXT("%d %d"), uWidth, uHeight);

    idx = IsBilingualCP(CodePage) ? 0 : 1;
    
    WriteIniWords(szTTCacheSection[idx], szBuf, (PWORD)&dwHeightWidth, 2, szSystemINI);

    bpfdi = AddToFontListCache(hwndList, fListBox, uHeight, uWidth,
                               (UINT)sSize.cy, (UINT)sSize.cx,
                               CodePage);

E3: SelectObject(hDC, hFontPrev);
E2: DeleteObject(hFont);
E1: ReleaseDC(0, hDC);
E0: return bpfdi;

}


/*  Returns the BPFDI corresponding to the currently selected font in
 *  the indicated list or combo box, or BPFDI_CANCEL on error.
 *
 *  Entry:
 *      hwndList == handle to listbox or combo box to fill
 *                  if NULL, then AUTO font calculation is assumed
 *      fListBox == TRUE if hwndList is a listbox, FALSE if a combo box
 *      pfi      -> FNTINFO structure
 *                  if pfi is NULL, then AUTO font calculation is ignored
 *  Returns:
 *      BPFDI of the current selection, or BPFDI_CANCEL on error.
 */
DWORD_PTR GetFont(HWND hwndList, BOOL fListBox, PFNTINFO pfi)
{
    DWORD dwIndex = 0;
    BPFDI bpfdi = BPFDI_CANCEL;

    if (!hwndList) {            // just do AUTO calculations
        if (!pfi)
            goto Exit;          // whoops, can't even do those
        goto ChooseBest;
    }
    dwIndex = lcbGetCurSel(hwndList, fListBox);
    if (!IsDlgError(dwIndex)) {

        if (pfi)
            pfi->fntProposed.flFnt &= ~FNT_AUTOSIZE;

        bpfdi = lcbGetBpfdi(hwndList, fListBox, dwIndex);

        if (bpfdi == BPFDI_AUTO && pfi) {
            pfi->fntProposed.flFnt |= FNT_AUTOSIZE;

ChooseBest:
            bpfdi = ChooseBestFont((UINT)pfi->winOriginal.cxCells,
                                   (UINT)pfi->winOriginal.cyCells,
                                   (UINT)pfi->winOriginal.cxClient,
                                   (UINT)pfi->winOriginal.cyClient,
                                   (UINT)pfi->fntProposed.flFnt,
                                    (INT)pfi->fntProposed.wCurrentCP);
        }
        // Set the index of the current selection (HIWORD
        // of the return code) to LB_ERR if there's an error

        if (bpfdi == BPFDI_CANCEL)
            dwIndex = (DWORD)LB_ERR;
    }
  Exit:
    if (!IsSpecialBpfdi(bpfdi))
    {
        bpfdi->Index = dwIndex;
    }

    return (DWORD_PTR)bpfdi;
}


/*  Copies data from the given BPFDI to the given PROPFNT structure.
 *
 *  Entry:
 *      lpFnt = pointer to PROPFNT structure
 *      bpfdi = based pointer to a FONTDIMENINFO structure;
 *              if a special BPFDI_* constant, no font info is changed
 *  Returns:
 *      Nothing
 */
void SetFont(LPPROPFNT lpFnt, BPFDI bpfdi)
{
    if (!IsSpecialBpfdi(bpfdi)) 
    {
        lpFnt->flFnt &= ~(FNT_RASTER | FNT_TT);

        if (bpfdi->fdiHeightReq == 0) 
        {
            /* Raster font */
            lpFnt->flFnt |= FNT_RASTER;
            lpFnt->cxFont = lpFnt->cxFontActual = (WORD) bpfdi->fdiWidthActual;
            lpFnt->cyFont = lpFnt->cyFontActual = (WORD) bpfdi->fdiHeightActual;
        }
        else 
        {
            /* TrueType font */
            lpFnt->flFnt |= FNT_TT;
            lpFnt->cxFont = (WORD) bpfdi->fdiWidthReq;
            lpFnt->cyFont = (WORD) bpfdi->fdiHeightReq;
            lpFnt->cxFontActual = (WORD) bpfdi->fdiWidthActual;
            lpFnt->cyFontActual = (WORD) bpfdi->fdiHeightActual;
        }
    }
}


/*  Performs the following calculation in LONG arithmetic to avoid
 *  overflow:
 *      return = n1 * m / n2
 *  This can be used to make an aspect ration calculation where n1/n2
 *  is the aspect ratio and m is a known value.  The return value will
 *  be the value that corresponds to m with the correct apsect ratio.
 */

//
// <This is defined as a macro for Win32 >
//

/*  Scales a point to be preview-sized instead of screen-sized.
 *  Depends on the global vars cxScreen and cyScreen established at init.
 */

void AspectPoint(LPRECT lprcPreview, LPPOINT lppt)
{
    lppt->x = AspectScale(lprcPreview->right, cxScreen, lppt->x);
    lppt->y = AspectScale(lprcPreview->bottom, cyScreen, lppt->y);
}

/*  AspectRect
 *
 *  Scales a rectangle to be preview-sized instead of screen-sized.
 *  Depends on the global vars cxScreen and cyScreen established at init.
 */

void AspectRect(LPRECT lprcPreview, LPRECT lprc)
{
    AspectPoint(lprcPreview, &((LPPOINT)lprc)[0]); /* Upper left corner */
    AspectPoint(lprcPreview, &((LPPOINT)lprc)[1]); /* Lower right corner */
}

/*  Given a BPFDI, create a font that corresponds to it.
 *
 *  Entry:
 *      bpfdi       -> FDI describing the font we want to create
 *      pfi         -> proposed font info structure
 *
 *  Returns:
 *      HFONT that was created.
 */
HFONT CreateFontFromBpfdi(BPFDI bpfdi, PFNTINFO pfi)
{
    HFONT hf;
    int   fdwClipPrecision;
    BYTE  bT2Charset;

    // a hack for japanese charset
    bT2Charset = (pfi->fntProposed.wCurrentCP == CP_JPN? 
                  0xFE: OEMCharsetFromCP(pfi->fntProposed.wCurrentCP));
    
    if (pfi->fntProposed.wCurrentCP == CP_US)
        fdwClipPrecision = CLIP_DEFAULT_PRECIS|(g_uCodePage == CP_WANSUNG? CLIP_DFA_OVERRIDE: 0);
    else
        fdwClipPrecision = CLIP_DEFAULT_PRECIS;
        
    if (bpfdi->fdiHeightReq == 0) {
        /* Raster font */
        hf = CreateFontA(bpfdi->fdiHeightActual, bpfdi->fdiWidthActual,
            0, 0, 0, 0, 0, 0, (BYTE)OEMCharsetFromCP(pfi->fntProposed.wCurrentCP), 
            OUT_RASTER_PRECIS, fdwClipPrecision,
            0, FIXED_PITCH | FF_DONTCARE, pfi->fntProposed.achRasterFaceName);
    } else {
        /* a TrueType font */
        hf = CreateFontA(bpfdi->fdiHeightReq, bpfdi->fdiWidthReq,
            0, 0, 0, 0, 0, 0, (BYTE)bT2Charset, OUT_TT_PRECIS, fdwClipPrecision,
            0, FIXED_PITCH | FF_DONTCARE, pfi->fntProposed.achTTFaceName);
    }

    return hf;
}


/** FontSelInit
 *
 *  Obtain the various font selection penalties from SYSTEM.INI
 *  and force the values into range.
 *
 *  Entry:
 *      rgwInitialTtHeights contains default values for sizes.
 *
 *  Exit:
 *      rgwInitialTtHeights contains actual values for sizes.
 */

void FontSelInit(void)
{
    GetIniWords(szNonWinSection, szTTInitialSizes,
                rgwInitialTtHeights, sizeof(rgwInitialTtHeights)/sizeof(WORD), szSystemINI);
}


/*  Convert logical dimensions for a TrueType font into physical
 *  dimensions.  If possible, we get this information from the
 *  font dimension cache, but in the case where this is not possible,
 *  we synthesize the font and measure him directly.
 *
 *  Entry:
 *      dxWidth  = logical font width
 *      dyHeight = logical font height
 *
 *  Returns:
 *      BPFDI pointing to dimension information, or BPFDI_CANCEL on failure.
 */

BPFDI GetTrueTypeFontTrueDimensions(UINT dxWidth, UINT dyHeight, INT CodePage)
{
    IFDI    ifdi;
    BPFDI   bpfdi;
    int     idx = IsBilingualCP(CodePage)? 1 : 0;
    for (ifdi = 0, bpfdi = (BPFDI)((DWORD_PTR)lpCache + bpfdiStart[idx]);  
                    ifdi < cfdiCache[idx];  ifdi++, bpfdi++)
    {
        if (bpfdi->fdiWidthReq  == dxWidth &&
            bpfdi->fdiHeightReq == dyHeight) {
            return bpfdi;
        }
    }

    /*
     * The font dimensions have not been cached.  We have to create it.
     */
    return (BPFDI)AddOneNewTrueTypeFontToFontListA(0, 0, dxWidth, dyHeight,
                                                 szTTFaceName[idx], CodePage);
}


/*  Look for a font that matches the indicated dimensions, creating
 *  one if necessary.
 *
 *  But we never create a font which is too narrow or too short.
 *  The limits are controlled by the ptNonAspectMin variable.
 *
 *  Entry:
 *      dxWidth  = desired font width
 *      dyHeight = desired font height
 *      fPerfect = see below
 *
 *          If fPerfect is TRUE, then a perfect match is requested
 *          from the font cache (we should not try to synthesize a font).
 *          In which case, the sign of dyHeight determines whether a
 *          raster font (positive) or TrueType font (negative) is
 *          desired.  If a perfect match cannot be found, then we
 *          return BPFDI_CANCEL.
 *
 *  Returns:
 *      BPFDI of of the font that matches the best.
 *      BPFDI_CANCEL if no font could be found.
 */
BPFDI FindFontMatch(UINT dxWidth, UINT dyHeight, LPINT lpfl, INT CodePage)
{
    IFDI    ifdi;
    BPFDI   bpfdi;
    BPFDI   bpfdiBest = BPFDI_CANCEL;
    PENALTY pnlBest = SENTINELPENALTY;
    int     idx;

    int fl = *lpfl;
    /*
     * First, see if a perfect match already exists.
     */
    idx = IsBilingualCP(CodePage) ? 1 : 0;
    for (ifdi = 0, bpfdi = (BPFDI)((DWORD_PTR)lpCache+bpfdiStart[idx]);  
                    ifdi < cfdiCache[idx];  ifdi++, bpfdi++)
    {

        if (fl & FFM_RESTRICTED) {
            /* Deal with the restrictions.
             * Reject the font if it is raster but we want TTONLY, or v.v.
             *
             * The condition below reads as
             *
             *      If (is a raster font != want a raster font)
             */
            if (!bpfdi->fdiHeightReq != (fl == FFM_RASTERFONTS)) {
                continue;
            }
        }
        if (bpfdi->fdiHeightActual == dyHeight && bpfdi->fdiWidthActual == dxWidth) {
            *lpfl = FFM_PERFECT;
            return bpfdi;
    }   }

    if (fl != FFM_TTFONTS)
        return BPFDI_CANCEL;
    /*
     * We got here if we couldn't find a perfect match.
     *
     * Adjust the requested height and width for aspect ratio
     * constraints.  If adjustments are necessary, trust the height.
     *
     * Comparisons are as WORDs (unsigned) so that a setting of "-1 -1"
     * lets the user forbid all non-aspect ratio fonts.
     */
    if (dyHeight < (UINT)ptNonAspectMin.y || dxWidth < (UINT)ptNonAspectMin.x) {
        dxWidth = 0;
    }
    return GetTrueTypeFontTrueDimensions(dxWidth, dyHeight, CodePage);
}

/*  We have decided whether the desired size is larger or smaller.
 *  Compute the penalty corresponding to the Initial and Scale.
 *
 *  Entry:
 *      ppnlp   -> PENALTYPAIR to apply
 *      dSmaller = the smaller dimension
 *      dLarger  = the larger dimension
 *
 *  Exit:
 *      Returns penalty to apply to the difference in dimensions.
 */
PENALTY ComputePenaltyFromPair(PPENALTYPAIR ppnlp,
                               UINT dSmaller, UINT dLarger)
{
    return (ppnlp->pnlInitial +
            ppnlp->pnlScale - MulDiv(ppnlp->pnlScale, dSmaller, dLarger));
}


/*  Compute the penalty depending on whether the desired size
 *  is smaller, equal to, or larger than the actual size.
 *
 *  Entry:
 *      ppnll   -> PENALTYLIST to apply
 *      dActual  = the actual dimension
 *      dDesired = the desired dimension
 *
 *  Exit:
 *      Returns penalty to apply to the difference in dimensions,
 *      choosing between the Overshoot and Shortfall PENALTYPAIRS,
 *      accordingly.
 */
PENALTY ComputePenaltyFromList(PPENALTYLIST ppnll,
                               UINT dActual, UINT dDesired)
{
    if (dActual == dDesired)
        return 0;

    if (dActual < dDesired)
        return ComputePenaltyFromPair(&ppnll->pnlpOvershoot, dActual, dDesired);

    return ComputePenaltyFromPair(&ppnll->pnlpShortfall, dDesired, dActual);
}


/** ComputePenalty
 *
 *  Compute the total penalty associated to a window size.
 *
 *  Entry:
 *      dxCells  = width of window in cells
 *      dyCells  = height of window in cells
 *      dxClient = actual horizontal size of window
 *      dyClient = actual vertical   size of window
 *      dxFont   = width of one character in the font
 *      dyFont   = height of one character in the font
 *
 *  Exit:
 *      Returns total penalty associated to a window of the indicated
 *      size with a font of the indicated dimensions.
 */
PENALTY ComputePenalty(UINT cxCells,  UINT cyCells,
                       UINT dxClient, UINT dyClient,
                       UINT dxFont,   UINT dyFont)
{
    return
        (ComputePenaltyFromList(&pnllX, dxClient, dxFont * cxCells) +
         ComputePenaltyFromList(&pnllY, dyClient, dyFont * cyCells));
}


/** ChooseBestFont
 *
 *  Determine which font looks best for the specified window size
 *  by picking the one which has the smallest penalty.
 *
 *  Entry:
 *      dxCells = width of window in cells
 *      dyCells = height of window in cells
 *      dxClient= width of window we want to fit into
 *      dyClient= height of window we want to fit into
 *      fl      = font pool flags
 *
 *  Returns:
 *      Word offset from lpFontTable of the font we've decided to use.
 *      BPFDI_CANCEL if no font could be found.  (Should never happen.)
 *
 *  NOTE!
 *      We do *not* FontEnum through all the fonts because that would be
 *      too slow.  Instead, we inspect the cache of available font
 *      dimensions, and only after we've chosen the best font do we
 *      load all his other info.
 *
 *      This means that if the user installs new fonts, we won't see
 *      them until the cache is updated on receipt of a WM_FONTCHANGEff
 *      message, or the user either (1) pulls down the font list box,
 *      or (2) calls up the font selection dialog box.
 */

BPFDI ChooseBestFont(UINT cxCells, UINT cyCells, UINT dxClient, UINT dyClient,
                                                         INT fl, INT CodePage)
{
    int     flTemp;
    DWORD    ifdi;
    BPFDI   bpfdi;
    PENALTY pnl;
    UINT    dxWidth, dyHeight;
    BPFDI   bpfdiBest = BPFDI_CANCEL;
    PENALTY pnlBest = SENTINELPENALTY;
    int     idx;
    static int prev_CodePage;  // Only Japan is interested in prev_CodePage.

    /*
     * First, synthesize the theoretical best match.
     */
    if (!cxCells)
        cxCells = 80;           // if we get called with no real data,
    if (!cyCells)               // at least try to do something reasonable
        cyCells = 25;

    //
    // In the case where the values passed in don't make sense,
    // we default to raster 8x12.
    //
    dxWidth = (dxClient >= cxCells)? dxClient / cxCells : 8;
    dyHeight = (dyClient >= cyCells)? dyClient / cyCells : 12;

    //
    // Now, if we bad values, make some sense out of bad values for
    // dxClient & dyClient
    //

    if ((dxClient==0) || (dyClient==0))
    {
        dxClient = dxWidth * 80;
        dyClient = dyHeight * 25;
    }

    flTemp = 0;
    if ((fl & FNT_BOTHFONTS) != FNT_BOTHFONTS) {
        flTemp = FFM_RASTERFONTS;
        if (fl & FNT_TTFONTS)
            flTemp = FFM_TTFONTS;
    }
    bpfdi = FindFontMatch(dxWidth, dyHeight, &flTemp, CodePage);
    if (flTemp == FFM_PERFECT)
    {
        prev_CodePage = CodePage;
        return bpfdi;
    }

    idx = IsBilingualCP(CodePage)? 1 : 0;
    for (ifdi = 0, bpfdi = (BPFDI)((DWORD_PTR)lpCache+bpfdiStart[idx]);  
                    ifdi < cfdiCache[idx];  ifdi++, bpfdi++)
    {
        // If the font pool is restricted, then only look at like fonts

        if (flTemp)
            if (!bpfdi->fdiHeightReq != (flTemp == FFM_RASTERFONTS))
                continue;

// was ifdef JAPAN (hack)
// to prevent DOS_BOX shrinking which occurs toggling CP437 & CP932,
// just select one size bigger font when change CP437 to CP932
        if (CodePage == 932 && prev_CodePage == 437) {
           if (dxWidth < bpfdi->fdiWidthActual) {
              if (bpfdiBest->fdiWidthActual > bpfdi->fdiWidthActual)
                 bpfdiBest = bpfdi;
              else if (bpfdiBest->fdiWidthActual == bpfdi->fdiWidthActual &&
                       bpfdiBest->fdiHeightActual > bpfdi->fdiHeightActual)
                 bpfdiBest = bpfdi;
           }
           else {
              if (dxWidth == bpfdi->fdiWidthActual) {
                 if (bpfdi->fdiHeightActual > dyHeight &&
                     bpfdiBest->fdiHeightActual > bpfdi->fdiHeightActual)
                    bpfdiBest = bpfdi;
              }
           }
        }
        else 
// was the end of ifdef JAPAN
        {
        pnl = 0;
        if (bpfdi->fdiHeightReq)
            pnl = pnlTrueType;

        pnl += ComputePenalty(cxCells, cyCells,
                              dxClient, dyClient,
                              bpfdi->fdiWidthActual,
                              bpfdi->fdiHeightActual);

        if (pnl <= pnlBest) {
            pnlBest = pnl;
            bpfdiBest = bpfdi;
        }
        }
    }
// was ifdef JAPAN
    prev_CodePage = CodePage;
// was end of ifdef JAPAN
    return bpfdiBest;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\pifdat.c ===
#include "shellprv.h"
#pragma hdrstop

extern PROPTSK tskDefault;
extern PROPVID vidDefault;
extern PROPMEM memDefault;
extern PROPKBD kbdDefault;
extern WORD    flWinDefault;

#define _LP386_   ((LPW386PIF30)aDataPtrs[LP386_INDEX])
#define _LPENH_   ((LPWENHPIF40)aDataPtrs[LPENH_INDEX])
#define _LPWNT40_ ((LPWNTPIF40)aDataPtrs[LPNT40_INDEX])
#define _LPWNT31_ ((LPWNTPIF31)aDataPtrs[LPNT31_INDEX])
extern const TCHAR szDefIconFile[];


/*
 * INPUT
 *  ppl -> property (assumes it is LOCKED)
 *  lp386 -> 386 PIF data (may be NULL)
 *  lpenh -> enhanced PIF data (may be NULL)
 *  lpPrg -> where to store program property data
 *  cb = sizeof property data
 *
 * OUTPUT
 *  # of bytes returned
 */

int GetPrgData(PPROPLINK ppl, DATAPTRS aDataPtrs, LPPROPPRG lpPrg, int cb, UINT flOpt)
{
    LPSTR lpsz;
    LPPIFDATA lppd;
    FunctionName(GetPrgData);

    if (!(NULL != (lppd = ppl->lpPIFData)) || cb < sizeof(PROPPRG))
        return 0;

    lpPrg->flPrg = PRG_DEFAULT;
    lpPrg->flPrgInit = PRGINIT_DEFAULT;
    lpPrg->dwRealModeFlags = 0;

    lpPrg->flPrgInit |= ppl->flProp & (PROP_NOPIF | PROP_DEFAULTPIF | PROP_INFSETTINGS);

    PifMgr_WCtoMBPath( (LPWSTR)szDefIconFile, lpPrg->achIconFile, ARRAYSIZE(lpPrg->achIconFile) );
    PifMgr_WCtoMBPath( ppl->ofPIF.szPathName, lpPrg->achPIFFile, ARRAYSIZE(lpPrg->achPIFFile) );
    lpPrg->wIconIndex = ICONINDEX_DEFAULT;

    if (lppd->stdpifdata.MSflags & EXITMASK)
        lpPrg->flPrg |= PRG_CLOSEONEXIT;

    lstrcpytrimA(lpPrg->achTitle, lppd->stdpifdata.appname, ARRAYSIZE(lppd->stdpifdata.appname));

    cb = lstrcpyfnameA(lpPrg->achCmdLine, lppd->stdpifdata.startfile, ARRAYSIZE(lpPrg->achCmdLine));

    lpsz = lppd->stdpifdata.params;
    if (aDataPtrs[ LP386_INDEX ]) {
        lpsz = _LP386_->PfW386params;

        CTASSERTF(PRGINIT_MINIMIZED      == (fMinimized      >> fMinimizedBit));
        CTASSERTF(PRGINIT_MAXIMIZED      == (fMaximized      >> fMinimizedBit));
        CTASSERTF(PRGINIT_REALMODE       == (fRealMode       >> fMinimizedBit));
        CTASSERTF(PRGINIT_REALMODESILENT == (fRealModeSilent >> fMinimizedBit));
        CTASSERTF(PRGINIT_QUICKSTART     == (fQuickStart     >> fMinimizedBit));
        CTASSERTF(PRGINIT_AMBIGUOUSPIF   == (fAmbiguousPIF   >> fMinimizedBit));

        if (_LP386_->PfW386Flags & fWinLie)
            lpPrg->flPrgInit |= PRGINIT_WINLIE;

        if (_LP386_->PfW386Flags & fNoSuggestMSDOS)
            lpPrg->flPrg |= PRG_NOSUGGESTMSDOS;

        lpPrg->flPrgInit |= (WORD)((_LP386_->PfW386Flags & (fMinimized | fMaximized | fRealMode | fRealModeSilent | fQuickStart | fAmbiguousPIF)) >> fMinimizedBit);
        if (_LP386_->PfW386Flags & fHasHotKey) {
            lpPrg->wHotKey = HotKeyWindowsFromOem((LPPIFKEY)&_LP386_->PfHotKeyScan);
        } else {
            lpPrg->wHotKey = 0;
        }
    }
    if (*lpsz && ((int)(lstrlenA(lpsz)) < (int)(ARRAYSIZE(lpPrg->achCmdLine)-cb-1))) {
        lstrcatA(lpPrg->achCmdLine, " ");
        lstrcatA(lpPrg->achCmdLine, lpsz);
    }

    lstrcpyfnameA(lpPrg->achWorkDir, lppd->stdpifdata.defpath, ARRAYSIZE(lpPrg->achWorkDir));

    if (_LPENH_) {
        if (_LPENH_->achIconFileProp[0]) {
            lstrcpyA(lpPrg->achIconFile, _LPENH_->achIconFileProp);
            lpPrg->wIconIndex = _LPENH_->wIconIndexProp;
        }
        lpPrg->dwEnhModeFlags = _LPENH_->dwEnhModeFlagsProp;
        lpPrg->dwRealModeFlags = _LPENH_->dwRealModeFlagsProp;
        lstrcpyA(lpPrg->achOtherFile, _LPENH_->achOtherFileProp);
    }

    if (!(flOpt & GETPROPS_OEM)) {
        /* Convert all strings from OEM character set to Ansi */
        OemToCharA(lpPrg->achTitle, lpPrg->achTitle);
        OemToCharA(lpPrg->achCmdLine, lpPrg->achCmdLine);
        OemToCharA(lpPrg->achWorkDir, lpPrg->achWorkDir);
    }
    return sizeof(PROPPRG);
}


/** SetPrgData - set program property data
 *
 * INPUT
 *  ppl -> property (assumes it is LOCKED)
 *  lp386 -> 386 PIF data (GUARANTEED!)
 *  lpenh -> enhanced PIF data (GUARANTEED!)
 *  lpPrg -> where to store program property data
 *  cb = sizeof property data
 *
 * OUTPUT
 *  # of bytes set
 */

int SetPrgData(PPROPLINK ppl, DATAPTRS aDataPtrs, LPPROPPRG lpPrg, int cb, UINT flOpt)
{
    int i;
    LPPIFDATA lppd;
    FunctionName(SetPrgData);

    if (!(NULL != (lppd = ppl->lpPIFData)) || cb < sizeof(PROPPRG))
        return 0;

    lppd->stdpifdata.MSflags &= ~EXITMASK;
    if (lpPrg->flPrg & PRG_CLOSEONEXIT)
        lppd->stdpifdata.MSflags |= EXITMASK;

    CTASSERTF(PRGINIT_MINIMIZED      == (fMinimized      >> fMinimizedBit));
    CTASSERTF(PRGINIT_MAXIMIZED      == (fMaximized      >> fMinimizedBit));
    CTASSERTF(PRGINIT_REALMODE       == (fRealMode       >> fMinimizedBit));
    CTASSERTF(PRGINIT_REALMODESILENT == (fRealModeSilent >> fMinimizedBit));
    CTASSERTF(PRGINIT_QUICKSTART     == (fQuickStart     >> fMinimizedBit));
    CTASSERTF(PRGINIT_AMBIGUOUSPIF   == (fAmbiguousPIF   >> fMinimizedBit));

    _LP386_->PfW386Flags &= ~(fHasHotKey | fWinLie | fMinimized | fMaximized | fRealMode | fRealModeSilent | fQuickStart | fAmbiguousPIF | fNoSuggestMSDOS);
    if (lpPrg->wHotKey)
        _LP386_->PfW386Flags |= fHasHotKey;
    if (!(lpPrg->flPrg & PRGINIT_WINLIE))
        _LP386_->PfW386Flags |= fWinLie;
    if (lpPrg->flPrg & PRG_NOSUGGESTMSDOS)
        _LP386_->PfW386Flags |= fNoSuggestMSDOS;
    _LP386_->PfW386Flags |= (DWORD)(lpPrg->flPrgInit & (PRGINIT_MINIMIZED | PRGINIT_MAXIMIZED | PRGINIT_REALMODE | PRGINIT_REALMODESILENT | PRGINIT_QUICKSTART | PRGINIT_AMBIGUOUSPIF)) << fMinimizedBit;

    lstrcpypadA(lppd->stdpifdata.appname, lpPrg->achTitle, ARRAYSIZE(lppd->stdpifdata.appname));

    lstrunquotefnameA(lppd->stdpifdata.startfile, lpPrg->achCmdLine, ARRAYSIZE(lppd->stdpifdata.startfile), FALSE);

    i = lstrskipfnameA(lpPrg->achCmdLine);
    i += lstrskipcharA(lpPrg->achCmdLine+i, ' ');
    lstrcpynA(lppd->stdpifdata.params, lpPrg->achCmdLine+i, ARRAYSIZE(lppd->stdpifdata.params));
    lstrcpynA(_LP386_->PfW386params, lpPrg->achCmdLine+i, ARRAYSIZE(_LP386_->PfW386params));

    if (lpPrg->achWorkDir[0] != '\"')
        lstrcpyA(lppd->stdpifdata.defpath, lpPrg->achWorkDir);
    else
        lstrunquotefnameA(lppd->stdpifdata.defpath, lpPrg->achWorkDir, ARRAYSIZE(lppd->stdpifdata.defpath), FALSE);

    HotKeyOemFromWindows((LPPIFKEY)&_LP386_->PfHotKeyScan, lpPrg->wHotKey);

    lstrcpynA(_LPENH_->achIconFileProp, lpPrg->achIconFile, ARRAYSIZE(_LPENH_->achIconFileProp));
    _LPENH_->wIconIndexProp = lpPrg->wIconIndex;

    _LPENH_->dwEnhModeFlagsProp = lpPrg->dwEnhModeFlags;
    _LPENH_->dwRealModeFlagsProp = lpPrg->dwRealModeFlags;

    lstrcpynA(_LPENH_->achOtherFileProp, lpPrg->achOtherFile, ARRAYSIZE(_LPENH_->achOtherFileProp));

    MultiByteToWideChar( CP_ACP, 0,
                         lpPrg->achPIFFile, -1,
                         ppl->ofPIF.szPathName,
                         ARRAYSIZE(ppl->ofPIF.szPathName)
                        );

    if (!(flOpt & SETPROPS_OEM)) {
        /* Convert all strings from Ansi character set to OEM */
        CharToOemBuffA(lppd->stdpifdata.appname, lppd->stdpifdata.appname, ARRAYSIZE(lppd->stdpifdata.appname));
        CharToOemA(lppd->stdpifdata.startfile, lppd->stdpifdata.startfile);
        CharToOemA(lppd->stdpifdata.defpath, lppd->stdpifdata.defpath);
        CharToOemA(lppd->stdpifdata.params, lppd->stdpifdata.params);
    }
    ppl->flProp |= PROP_DIRTY;

    return sizeof(PROPPRG);
}


/*
 * INPUT
 *  ppl -> property (assumes it is LOCKED)
 *  lp386 -> 386 PIF data (may be NULL)
 *  lpenh -> enhanced PIF data (may be NULL)
 *  lpTsk -> where to store tasking property data
 *  cb = sizeof property data
 *
 * OUTPUT
 *  # of bytes returned
 */

int GetTskData(PPROPLINK ppl, DATAPTRS aDataPtrs, LPPROPTSK lpTsk, int cb, UINT flOpt)
{
    // Set defaults in case no appropriate section exists

    *lpTsk = tskDefault;

    // If an enh section exists, get it

    if (_LPENH_)
        *lpTsk = _LPENH_->tskProp;

    // Get any data that must still be maintained in the old 386 section

    if (_LP386_) {

        lpTsk->flTsk &= ~(TSK_ALLOWCLOSE | TSK_BACKGROUND | TSK_EXCLUSIVE);
        lpTsk->flTsk |= _LP386_->PfW386Flags & (fEnableClose | fBackground);
        if (!(_LP386_->PfW386Flags & fPollingDetect))
            lpTsk->wIdleSensitivity = 0;
    }
    return sizeof(PROPTSK);
}


/** SetTskData - set tasking property data
 *
 * INPUT
 *  ppl -> property (assumes it is LOCKED)
 *  lp386 -> 386 PIF data (GUARANTEED!)
 *  lpenh -> enhanced PIF data (GUARANTEED!)
 *  lpTsk -> where to store tasking property data
 *  cb = sizeof property data
 *
 * OUTPUT
 *  # of bytes set
 */

int SetTskData(PPROPLINK ppl, DATAPTRS aDataPtrs, LPPROPTSK lpTsk, int cb, UINT flOpt)
{
    _LPENH_->tskProp = *lpTsk;

    _LP386_->PfW386Flags &= ~(fEnableClose | fBackground | fExclusive | fPollingDetect);
    _LP386_->PfW386Flags |= (lpTsk->flTsk & (TSK_ALLOWCLOSE | TSK_BACKGROUND));
    if (lpTsk->wIdleSensitivity)
        _LP386_->PfW386Flags |= fPollingDetect;

    ppl->flProp |= PROP_DIRTY;

    return sizeof(PROPTSK);
}


/** GetVidData - get video property data
 *
 * INPUT
 *  ppl -> property (assumes it is LOCKED)
 *  lp386 -> 386 PIF data (may be NULL)
 *  lpenh -> enhanced PIF data (may be NULL)
 *  lpVid -> where to store video property data
 *  cb = sizeof property data
 *
 * OUTPUT
 *  # of bytes returned
 */

int GetVidData(PPROPLINK ppl, DATAPTRS aDataPtrs, LPPROPVID lpVid, int cb, UINT flOpt)
{
    // Set defaults in case no appropriate section exists

    *lpVid = vidDefault;

    // If an enh section exists, get it

    if (_LPENH_)
        *lpVid = _LPENH_->vidProp;

    // Get any data that must still be maintained in the old 386 section

    if (_LP386_) {

        // Clear bits that already existed in the 386 section

        lpVid->flVid &= ~(VID_TEXTEMULATE | VID_RETAINMEMORY | VID_FULLSCREEN);
        lpVid->flVid |= _LP386_->PfW386Flags2 & (fVidTxtEmulate | fVidRetainAllo);

        if (_LP386_->PfW386Flags & fFullScreen)
            lpVid->flVid |= VID_FULLSCREEN;

    }

    return sizeof(PROPVID);
}


/** SetVidData - set video property data
 *
 * INPUT
 *  ppl -> property (assumes it is LOCKED)
 *  lp386 -> 386 PIF data (GUARANTEED!)
 *  lpenh -> enhanced PIF data (GUARANTEED!)
 *  lpVid -> where to store video property data
 *  cb = sizeof property data
 *
 * OUTPUT
 *  # of bytes set
 */

int SetVidData(PPROPLINK ppl, DATAPTRS aDataPtrs, LPPROPVID lpVid, int cb, UINT flOpt)
{
    _LPENH_->vidProp = *lpVid;

    _LP386_->PfW386Flags &= ~(fFullScreen);
    if (lpVid->flVid & VID_FULLSCREEN)
        _LP386_->PfW386Flags |= fFullScreen;

    _LP386_->PfW386Flags2 &= ~(fVidTxtEmulate | fVidRetainAllo);
    _LP386_->PfW386Flags2 |= lpVid->flVid & (fVidTxtEmulate | fVidRetainAllo);

    ppl->flProp |= PROP_DIRTY;

    return sizeof(PROPVID);
}


/** GetMemData - get memory property data
 *
 * INPUT
 *  ppl -> property (assumes it is LOCKED)
 *  lp386 -> 386 PIF data (may be NULL)
 *  lpenh -> enhanced PIF data (NOT USED)
 *  lpMem -> where to store memory property data
 *  cb = sizeof property data
 *
 * OUTPUT
 *  # of bytes returned
 */

int GetMemData(PPROPLINK ppl, DATAPTRS aDataPtrs, LPPROPMEM lpMem, int cb, UINT flOpt)
{
    // Set defaults in case no appropriate section exists

    *lpMem = memDefault;

    // Get any data that must still be maintained in the old 386 section

    if (_LP386_) {

        // Clear bits that already exist in the 386 section

        lpMem->flMemInit &= ~(MEMINIT_NOHMA |
                              MEMINIT_LOWLOCKED |
                              MEMINIT_EMSLOCKED |
                              MEMINIT_XMSLOCKED |
                              MEMINIT_GLOBALPROTECT |
                              MEMINIT_LOCALUMBS |
                              MEMINIT_STRAYPTRDETECT);

        if (_LP386_->PfW386Flags & fNoHMA)
            lpMem->flMemInit |= MEMINIT_NOHMA;
        if (_LP386_->PfW386Flags & fVMLocked)
            lpMem->flMemInit |= MEMINIT_LOWLOCKED;
        if (_LP386_->PfW386Flags & fEMSLocked)
            lpMem->flMemInit |= MEMINIT_EMSLOCKED;
        if (_LP386_->PfW386Flags & fXMSLocked)
            lpMem->flMemInit |= MEMINIT_XMSLOCKED;
        if (_LP386_->PfW386Flags & fGlobalProtect)
            lpMem->flMemInit |= MEMINIT_GLOBALPROTECT;
        if (_LP386_->PfW386Flags & fLocalUMBs)
            lpMem->flMemInit |= MEMINIT_LOCALUMBS;

        // NOTE: we don't provide a UI for this (debugging) feature, but all
        // the support is still in place.

        if (_LP386_->PfW386Flags & fStrayPtrDetect)
            lpMem->flMemInit |= MEMINIT_STRAYPTRDETECT;

        lpMem->wMinLow = _LP386_->PfW386minmem;
        lpMem->wMinEMS = _LP386_->PfMinEMMK;
        lpMem->wMinXMS = _LP386_->PfMinXmsK;

        lpMem->wMaxLow = _LP386_->PfW386maxmem;
        lpMem->wMaxEMS = _LP386_->PfMaxEMMK;
        lpMem->wMaxXMS = _LP386_->PfMaxXmsK;
    }
    return sizeof(PROPMEM);
}


/** SetMemData - set memory property data
 *
 * INPUT
 *  ppl -> property (assumes it is LOCKED)
 *  lp386 -> 386 PIF data (GUARANTEED!)
 *  lpenh -> enhanced PIF data (NOT USED)
 *  lpMem -> where to store memory property data
 *  cb = sizeof property data
 *
 * OUTPUT
 *  # of bytes set
 */

int SetMemData(PPROPLINK ppl, DATAPTRS aDataPtrs, LPPROPMEM lpMem, int cb, UINT flOpt)
{
    _LP386_->PfW386Flags &= ~(fNoHMA |
                            fVMLocked |
                            fEMSLocked |
                            fXMSLocked |
                            fGlobalProtect |
                            fLocalUMBs |
                            fStrayPtrDetect);

    if (lpMem->flMemInit & MEMINIT_NOHMA)
        _LP386_->PfW386Flags |= fNoHMA;

    // Note that we now only honor updating the locked memory bits
    // if the corresponding memory quantity has been set to a SPECIFIC
    // value.  We want to avoid someone changing a memory setting to
    // "Automatic" and having an indeterminate amount of memory inadvertently
    // locked. -JTP

    if ((lpMem->flMemInit & MEMINIT_LOWLOCKED) && (lpMem->wMinLow == lpMem->wMaxLow))
        _LP386_->PfW386Flags |= fVMLocked;
    if ((lpMem->flMemInit & MEMINIT_EMSLOCKED) && (lpMem->wMinEMS == lpMem->wMaxEMS))
        _LP386_->PfW386Flags |= fEMSLocked;
    if ((lpMem->flMemInit & MEMINIT_XMSLOCKED) && (lpMem->wMinXMS == lpMem->wMaxXMS))
        _LP386_->PfW386Flags |= fXMSLocked;

    if (lpMem->flMemInit & MEMINIT_GLOBALPROTECT)
        _LP386_->PfW386Flags |= fGlobalProtect;
    if (lpMem->flMemInit & MEMINIT_LOCALUMBS)
        _LP386_->PfW386Flags |= fLocalUMBs;
    if (lpMem->flMemInit & MEMINIT_STRAYPTRDETECT)
        _LP386_->PfW386Flags |= fStrayPtrDetect;

    _LP386_->PfW386minmem = lpMem->wMinLow;
    _LP386_->PfMinEMMK    = lpMem->wMinEMS;
    _LP386_->PfMinXmsK    = lpMem->wMinXMS;

    _LP386_->PfW386maxmem = lpMem->wMaxLow;
    _LP386_->PfMaxEMMK    = lpMem->wMaxEMS;
    _LP386_->PfMaxXmsK    = lpMem->wMaxXMS;

    ppl->flProp |= PROP_DIRTY;

    return sizeof(PROPMEM);
}


/*
 * INPUT
 *  ppl -> property (assumes it is LOCKED)
 *  lp386 -> 386 PIF data (may be NULL)
 *  lpenh -> enhanced PIF data (may be NULL)
 *  lpKbd -> where to store keyboard property data
 *  cb = sizeof property data
 *
 * OUTPUT
 *  # of bytes returned
 */

int GetKbdData(PPROPLINK ppl, DATAPTRS aDataPtrs, LPPROPKBD lpKbd, int cb, UINT flOpt)
{
    // Set defaults in case no appropriate section exists

    *lpKbd = kbdDefault;

    // If an enh section exists, get it

    if (_LPENH_)
        *lpKbd = _LPENH_->kbdProp;

    // Perform limited validation; there are a variety of places we can
    // do validation (at the time defaults are captured from SYSTEM.INI,
    // and whenever properties are saved), but minimum validation requires
    // we at least check the values we're returning to the outside world
    //
    // I would also say that as a general rule ring 0 code should never
    // trust data coming from ring 3 as fully validated.  In addition, the
    // UI layer will want to do input validation to provide immediate feedback,
    // so validation in this layer seems pretty non-worthwhile.

    if (lpKbd->msAltDelay == 0)         // we know this is bad at any rate
        lpKbd->msAltDelay = KBDALTDELAY_DEFAULT;

    // Get any data that must still be maintained in the old 386 section

    if (_LP386_) {

        // Clear bits that already exist in the 386 section

        lpKbd->flKbd &= ~(KBD_FASTPASTE  |
                          KBD_NOALTTAB   |
                          KBD_NOALTESC   |
                          KBD_NOALTSPACE |
                          KBD_NOALTENTER |
                          KBD_NOALTPRTSC |
                          KBD_NOPRTSC    |
                          KBD_NOCTRLESC);

        lpKbd->flKbd |= _LP386_->PfW386Flags & (fALTTABdis | fALTESCdis | fALTSPACEdis | fALTENTERdis | fALTPRTSCdis | fPRTSCdis | fCTRLESCdis);

        if (_LP386_->PfW386Flags & fINT16Paste)
            lpKbd->flKbd |= KBD_FASTPASTE;
    }
    return sizeof(PROPKBD);
}


/** SetKbdData - set keyboard property data
 *
 * INPUT
 *  ppl -> property (assumes it is LOCKED)
 *  lp386 -> 386 PIF data (GUARANTEED!)
 *  _LPENH_ -> enhanced PIF data (GUARANTEED!)
 *  lpKbd -> where to store keyboard property data
 *  cb = sizeof property data
 *
 * OUTPUT
 *  # of bytes set
 */

int SetKbdData(PPROPLINK ppl, DATAPTRS aDataPtrs, LPPROPKBD lpKbd, int cb, UINT flOpt)
{
    _LPENH_->kbdProp = *lpKbd;

    _LP386_->PfW386Flags &= ~fINT16Paste;
    if (lpKbd->flKbd & KBD_FASTPASTE)
        _LP386_->PfW386Flags |= fINT16Paste;

    _LP386_->PfW386Flags &= ~(fALTTABdis | fALTESCdis | fALTSPACEdis | fALTENTERdis | fALTPRTSCdis | fPRTSCdis | fCTRLESCdis);
    _LP386_->PfW386Flags |= lpKbd->flKbd & (fALTTABdis | fALTESCdis | fALTSPACEdis | fALTENTERdis | fALTPRTSCdis | fPRTSCdis | fCTRLESCdis);

    ppl->flProp |= PROP_DIRTY;

    return sizeof(PROPKBD);
}


/*
 * INPUT
 *  ppl -> property (assumes it is LOCKED)
 *  ((LPW386PIF30)aDataPtrs[ LP386_INDEX ]) -> 386 PIF data (NOT USED)
 *  lpenh -> enhanced PIF data (may be NULL)
 *  lpMse -> where to store mouse property data
 *  cb = sizeof property data
 *
 * OUTPUT
 *  # of bytes returned
 */

int GetMseData(PPROPLINK ppl, DATAPTRS aDataPtrs, LPPROPMSE lpMse, int cb, UINT flOpt)
{
    lpMse->flMse = MSE_DEFAULT;
    lpMse->flMseInit = MSEINIT_DEFAULT;

    if (_LPENH_)
        *lpMse = _LPENH_->mseProp;

    return sizeof(PROPMSE);
}


/** SetMseData - set mouse property data
 *
 * INPUT
 *  ppl -> property (assumes it is LOCKED)
 *  lp386 -> 386 PIF data (NOT USED)
 *  lpenh -> enhanced PIF data (GUARANTEED!)
 *  lpMse -> where to store mouse property data
 *  cb = sizeof property data
 *
 * OUTPUT
 *  # of bytes set
 */

int SetMseData(PPROPLINK ppl, DATAPTRS aDataPtrs, LPPROPMSE lpMse, int cb, UINT flOpt)
{
    FunctionName(SetMseData);

    _LPENH_->mseProp = *lpMse;

    ppl->flProp |= PROP_DIRTY;

    return sizeof(PROPMSE);
}


/** GetSndData - get sound property data
 *
 * INPUT
 *  ppl -> property (assumes it is LOCKED)
 *  lp386 -> 386 PIF data (NOT USED)
 *  lpenh -> enhanced PIF data (may be NULL)
 *  lpSnd -> where to store sound property data
 *  cb = sizeof property data
 *
 * OUTPUT
 *  # of bytes returned
 */

int GetSndData(PPROPLINK ppl, DATAPTRS aDataPtrs, LPPROPSND lpSnd, int cb, UINT flOpt)
{
    lpSnd->flSnd = SND_DEFAULT;
    lpSnd->flSndInit = SNDINIT_DEFAULT;

    if (_LPENH_)
        *lpSnd = _LPENH_->sndProp;

    return sizeof(PROPSND);
}


/** SetSndData - set sound property data
 *
 * INPUT
 *  ppl -> property (assumes it is LOCKED)
 *  lp386 -> 386 PIF data (NOT USED)
 *  lpenh -> enhanced PIF data (GUARANTEED!)
 *  lpSnd -> where to store sound property data
 *  cb = sizeof property data
 *
 * OUTPUT
 *  # of bytes set
 */

int SetSndData(PPROPLINK ppl, DATAPTRS aDataPtrs, LPPROPSND lpSnd, int cb, UINT flOpt)
{
    _LPENH_->sndProp = *lpSnd;

    ppl->flProp |= PROP_DIRTY;

    return sizeof(PROPSND);
}


/** GetFntData - get font property data
 *
 * INPUT
 *  ppl -> property (assumes it is LOCKED)
 *  lp386 -> 386 PIF data (NOT USED)
 *  lpenh -> enhanced PIF data (may be NULL)
 *  lpFnt -> where to store font property data
 *  cb = sizeof property data
 *
 * OUTPUT
 *  # of bytes returned
 */

int GetFntData(PPROPLINK ppl, DATAPTRS aDataPtrs, LPPROPFNT lpFnt, int cb, UINT flOpt)
{
    int iCount;
    BPFDI bpfdi;
    INIINFO iiTemp;

    lpFnt->flFnt = FNT_DEFAULT;
    lpFnt->wCurrentCP = (WORD) g_uCodePage;

    if (_LPENH_) {
        //
        // If we don't have any actual font data, see if we can compute some
        //
        if (!_LPENH_->fntProp.cxFontActual && _LPENH_->winProp.cxCells)
            _LPENH_->fntProp.cxFontActual = _LPENH_->winProp.cxClient / _LPENH_->winProp.cxCells;

        if (!_LPENH_->fntProp.cyFontActual && _LPENH_->winProp.cyCells)
            _LPENH_->fntProp.cyFontActual = _LPENH_->winProp.cyClient / _LPENH_->winProp.cyCells;

        *lpFnt = _LPENH_->fntProp;

        if (lpFnt->flFnt & FNT_AUTOSIZE) {

            bpfdi = ChooseBestFont(_LPENH_->winProp.cxCells,
                                   _LPENH_->winProp.cyCells,
                                   _LPENH_->winProp.cxClient,
                                   _LPENH_->winProp.cyClient,
                                   _LPENH_->fntProp.flFnt,
                                   _LPENH_->fntProp.wCurrentCP);
            SetFont(lpFnt, bpfdi);
        }
    } else {

        // Read the default INI information from the DOSAPP.INI file.
        // We only really use the information if we recognize the number of
        // WORDs read.

        iCount = GetIniWords(szDOSAPPSection, szDOSAPPDefault,
                                (WORD*)&iiTemp, INI_WORDS, szDOSAPPINI);

        if (ISVALIDINI(iCount))
            CopyIniWordsToFntData(lpFnt, &iiTemp, iCount);

        // Try to read file-specific information.  Note that any information
        // found will replace the information just read.  We only really use
        // the information if we recognize the number of WORDs read.

        iCount = GetIniWords(szDOSAPPSection, ppl->szPathName,
                                (WORD*)&iiTemp, INI_WORDS, szDOSAPPINI);

        if (ISVALIDINI(iCount))
            CopyIniWordsToFntData(lpFnt, &iiTemp, iCount);

        // If there is no font pool data (likely, if this is a 3.1 DOSAPP.INI),
        // then default to both raster and truetype.

        if (!(lpFnt->flFnt & FNT_BOTHFONTS))
            lpFnt->flFnt |= FNT_BOTHFONTS;
    }

    // Face names are taken from Frosting; the value stored in the PIF is
    // irrelevant.

    lstrcpyA(lpFnt->achRasterFaceName, szRasterFaceName);
    lstrcpyA(lpFnt->achTTFaceName, szTTFaceName[IsBilingualCP(lpFnt->wCurrentCP)? 1 : 0]);

    return sizeof(PROPFNT);
}


/*
 * INPUT
 *  ppl -> property (assumes it is LOCKED)
 *  lp386 -> 386 PIF data (NOT USED)
 *  lpenh -> enhanced PIF data (GUARANTEED!)
 *  lpFnt -> where to store font property data
 *  cb = sizeof property data
 *
 * OUTPUT
 *  # of bytes set
 */

int SetFntData(PPROPLINK ppl, DATAPTRS aDataPtrs, LPPROPFNT lpFnt, int cb, UINT flOpt)
{
    _LPENH_->fntProp = *lpFnt;

    ppl->flProp |= PROP_DIRTY;

    return sizeof(PROPFNT);
}


/*
 * INPUT
 *  ppl -> property (assumes it is LOCKED)
 *  lp386 -> 386 PIF data (NOT USED)
 *  lpenh -> enhanced PIF data (may be NULL)
 *  lpWin -> where to store window property data
 *  cb = sizeof property data
 *
 * OUTPUT
 *  # of bytes returned
 */

int GetWinData(PPROPLINK ppl, DATAPTRS aDataPtrs, LPPROPWIN lpWin, int cb, UINT flOpt)
{
    int iCount;
    INIINFO iiTemp;

    lpWin->flWin = flWinDefault;
    lpWin->wLength = PIF_WP_SIZE;

    if (_LPENH_) {
        *lpWin = _LPENH_->winProp;
    } else {
        // Read the default INI information from the DOSAPP.INI file.
        // We only really use the information if we recognize the number of
        // WORDs read.

        iCount = GetIniWords(szDOSAPPSection, szDOSAPPDefault,
                                (WORD*)&iiTemp, INI_WORDS, szDOSAPPINI);

        if (ISVALIDINI(iCount))
            CopyIniWordsToWinData(lpWin, &iiTemp, iCount);

        // Try to read file-specific information.  Note that any information
        // found will replace the information just read.  We only really use
        // the information if we recognize the number of WORDs read.

        iCount = GetIniWords(szDOSAPPSection, ppl->szPathName,
                                (WORD*)&iiTemp, INI_WORDS, szDOSAPPINI);

        if (ISVALIDINI(iCount))
            CopyIniWordsToWinData(lpWin, &iiTemp, iCount);
    }
    return sizeof(PROPWIN);
}


/** SetWinData - set window property data
 *
 * INPUT
 *  ppl -> property (assumes it is LOCKED)
 *  lp386 -> 386 PIF data (NOT USED)
 *  lpenh -> enhanced PIF data (GUARANTEED!)
 *  lpWin -> where to store window property data
 *  cb = sizeof property data
 *
 * OUTPUT
 *  # of bytes set
 */

int SetWinData(PPROPLINK ppl, DATAPTRS aDataPtrs, LPPROPWIN lpWin, int cb, UINT flOpt)
{
    _LPENH_->winProp = *lpWin;

    // In order to avoid excessive PIF creation, we will not set the
    // dirty bit on this particular call unless the properties were not
    // simply derived from internal defaults (no PIF file) or _DEFAULT.PIF.

    if (!(ppl->flProp & (PROP_NOPIF | PROP_DEFAULTPIF))) {
        ppl->flProp |= PROP_DIRTY;
    }
    return sizeof(PROPWIN);
}


/** GetEnvData - get environment property data
 *
 * INPUT
 *  ppl -> property (assumes it is LOCKED)
 *  lp386 -> 386 PIF data (NOT USED)
 *  lpenh -> enhanced PIF data (may be NULL)
 *  lpEnv -> where to store environment property data
 *  cb = sizeof property data
 *
 * OUTPUT
 *  # of bytes returned
 */

int GetEnvData(PPROPLINK ppl, DATAPTRS aDataPtrs, LPPROPENV lpEnv, int cb, UINT flOpt)
{
    BZero(lpEnv, sizeof(PROPENV));

    if (_LPENH_) {
        *lpEnv = _LPENH_->envProp;
        lpEnv->achBatchFile[ARRAYSIZE(lpEnv->achBatchFile)-1] = TEXT('\0');

    }
    if (!(flOpt & GETPROPS_OEM)) {
        /* Convert all strings from OEM character set to Ansi */
        CharToOemA(lpEnv->achBatchFile, lpEnv->achBatchFile);
    }
    return sizeof(PROPENV);
}


/** SetEnvData - set environment property data
 *
 * INPUT
 *  ppl -> property (assumes it is LOCKED)
 *  lp386 -> 386 PIF data (NOT USED)
 *  lpenh -> enhanced PIF data (GUARANTEED!)
 *  lpEnv -> where to store environment property data
 *  cb = sizeof property data
 *
 * OUTPUT
 *  # of bytes set
 */

int SetEnvData(PPROPLINK ppl, DATAPTRS aDataPtrs, LPPROPENV lpEnv, int cb, UINT flOpt)
{
    _LPENH_->envProp = *lpEnv;
    _LPENH_->envProp.achBatchFile[ARRAYSIZE(_LPENH_->envProp.achBatchFile)-1] = TEXT('\0');

    if (!(flOpt & SETPROPS_OEM)) {
        /* Convert all strings from Ansi character set to OEM */
        CharToOemA(_LPENH_->envProp.achBatchFile, _LPENH_->envProp.achBatchFile);
    }
    ppl->flProp |= PROP_DIRTY;

    return sizeof(PROPENV);
}


/* INPUT
 *  ppl -> property (assumes it is LOCKED)
 *  lp386  -> 386 PIF data (NOT USED)
 *  lpenh  -> enhanced PIF data (may be NULL)
 *  lpNt40 -> where to store NT/UNICODE property data
 *  cb = sizeof property data
 *
 * OUTPUT
 *  # of bytes returned
 */

int GetNt40Data(PPROPLINK ppl, DATAPTRS aDataPtrs, LPPROPNT40 lpnt40, int cb, UINT flOpt)
{
    PROPPRG prg;
    WCHAR   awchTmp[ MAX_PATH ];

    if (GetPrgData( ppl, aDataPtrs, &prg, sizeof(prg), flOpt) < sizeof(PROPPRG))
        return 0;

    if (!_LPWNT40_)
        return 0;

    lpnt40->flWnt = _LPWNT40_->nt40Prop.flWnt;

    // Initialize Command Line string

    if (lstrcmpA(prg.achCmdLine,_LPWNT40_->nt40Prop.achSaveCmdLine)==0) {

        lstrcpyA(  lpnt40->achSaveCmdLine, _LPWNT40_->nt40Prop.achSaveCmdLine );
        ualstrcpy( lpnt40->awchCmdLine,    _LPWNT40_->nt40Prop.awchCmdLine );

    } else {

        lstrcpyA( lpnt40->achSaveCmdLine,            prg.achCmdLine );
        lstrcpyA( _LPWNT40_->nt40Prop.achSaveCmdLine, prg.achCmdLine );
        MultiByteToWideChar( CP_ACP, 0,
                             prg.achCmdLine, -1,
                             awchTmp, ARRAYSIZE(lpnt40->awchCmdLine)
                            );
        awchTmp[ARRAYSIZE(lpnt40->awchCmdLine)-1] = TEXT('\0');
        ualstrcpy( lpnt40->awchCmdLine, awchTmp );
        ualstrcpy( _LPWNT40_->nt40Prop.awchCmdLine, lpnt40->awchCmdLine );

    }

    // Initialize Other File string

    if (lstrcmpA(prg.achOtherFile,_LPWNT40_->nt40Prop.achSaveOtherFile)==0) {

        lstrcpyA(  lpnt40->achSaveOtherFile, _LPWNT40_->nt40Prop.achSaveOtherFile );
        ualstrcpy( lpnt40->awchOtherFile,    _LPWNT40_->nt40Prop.awchOtherFile );

    } else {

        lstrcpyA( lpnt40->achSaveOtherFile,            prg.achOtherFile );
        lstrcpyA( _LPWNT40_->nt40Prop.achSaveOtherFile, prg.achOtherFile );
        MultiByteToWideChar( CP_ACP, 0,
                             prg.achOtherFile, -1,
                             awchTmp, ARRAYSIZE(lpnt40->awchOtherFile)
                            );
        awchTmp[ARRAYSIZE(lpnt40->awchOtherFile)-1] = TEXT('\0');
        ualstrcpy( lpnt40->awchOtherFile, awchTmp );
        ualstrcpy( _LPWNT40_->nt40Prop.awchOtherFile, lpnt40->awchOtherFile );

    }

    // Initialize PIF File string

    if (lstrcmpA(prg.achPIFFile,_LPWNT40_->nt40Prop.achSavePIFFile)==0) {

        lstrcpyA(  lpnt40->achSavePIFFile, _LPWNT40_->nt40Prop.achSavePIFFile );
        ualstrcpy( lpnt40->awchPIFFile,    _LPWNT40_->nt40Prop.awchPIFFile );

    } else {

        lstrcpyA( lpnt40->achSavePIFFile,            prg.achPIFFile );
        lstrcpyA( _LPWNT40_->nt40Prop.achSavePIFFile, prg.achPIFFile );
        MultiByteToWideChar( CP_ACP, 0,
                             prg.achPIFFile, -1,
                             awchTmp, ARRAYSIZE(lpnt40->awchPIFFile)
                            );
        awchTmp[ARRAYSIZE(lpnt40->awchPIFFile)-1] = TEXT('\0');
        ualstrcpy( lpnt40->awchPIFFile, awchTmp );
        ualstrcpy( _LPWNT40_->nt40Prop.awchPIFFile, lpnt40->awchPIFFile );

    }

    // Initialize Title string

    if (lstrcmpA(prg.achTitle,_LPWNT40_->nt40Prop.achSaveTitle)==0) {

        lstrcpyA(  lpnt40->achSaveTitle, _LPWNT40_->nt40Prop.achSaveTitle );
        ualstrcpy( lpnt40->awchTitle,    _LPWNT40_->nt40Prop.awchTitle );

    } else {

        lstrcpyA( lpnt40->achSaveTitle,            prg.achTitle );
        lstrcpyA( _LPWNT40_->nt40Prop.achSaveTitle, prg.achTitle );
        MultiByteToWideChar( CP_ACP, 0,
                             prg.achTitle, -1,
                             awchTmp, ARRAYSIZE(lpnt40->awchTitle)
                            );
        awchTmp[ARRAYSIZE(lpnt40->awchTitle)-1] = TEXT('\0');
        ualstrcpy( lpnt40->awchTitle, awchTmp );
        ualstrcpy( _LPWNT40_->nt40Prop.awchTitle, lpnt40->awchTitle );

    }

    // Initialize IconFile string

    if (lstrcmpA(prg.achIconFile,_LPWNT40_->nt40Prop.achSaveIconFile)==0) {

        lstrcpyA(  lpnt40->achSaveIconFile, _LPWNT40_->nt40Prop.achSaveIconFile );
        ualstrcpy( lpnt40->awchIconFile,    _LPWNT40_->nt40Prop.awchIconFile );

    } else {

        lstrcpyA( lpnt40->achSaveIconFile,            prg.achIconFile );
        lstrcpyA( _LPWNT40_->nt40Prop.achSaveIconFile, prg.achIconFile );
        MultiByteToWideChar( CP_ACP, 0,
                             prg.achIconFile, -1,
                             awchTmp, ARRAYSIZE(lpnt40->awchIconFile)
                            );
        awchTmp[ARRAYSIZE(lpnt40->awchIconFile)-1] = TEXT('\0');
        ualstrcpy( lpnt40->awchIconFile, awchTmp );
        ualstrcpy( _LPWNT40_->nt40Prop.awchIconFile, lpnt40->awchIconFile );

    }

    // Initialize Working Directory string

    if (lstrcmpA(prg.achWorkDir,_LPWNT40_->nt40Prop.achSaveWorkDir)==0) {

        lstrcpyA(  lpnt40->achSaveWorkDir, _LPWNT40_->nt40Prop.achSaveWorkDir );
        ualstrcpy( lpnt40->awchWorkDir,    _LPWNT40_->nt40Prop.awchWorkDir );

    } else {

        lstrcpyA( lpnt40->achSaveWorkDir,            prg.achWorkDir );
        lstrcpyA( _LPWNT40_->nt40Prop.achSaveWorkDir, prg.achWorkDir );
        MultiByteToWideChar( CP_ACP, 0,
                             prg.achWorkDir, -1,
                             awchTmp, ARRAYSIZE(lpnt40->awchWorkDir)
                            );
        awchTmp[ARRAYSIZE(lpnt40->awchWorkDir)-1] = TEXT('\0');
        ualstrcpy( lpnt40->awchWorkDir, awchTmp );
        ualstrcpy( _LPWNT40_->nt40Prop.awchWorkDir, lpnt40->awchWorkDir );

    }

    // Initialize Batch File string

    if (_LPENH_) {

        if (lstrcmpA(_LPENH_->envProp.achBatchFile,_LPWNT40_->nt40Prop.achSaveBatchFile)==0) {

            lstrcpyA(  lpnt40->achSaveBatchFile, _LPWNT40_->nt40Prop.achSaveBatchFile );
            ualstrcpy( lpnt40->awchBatchFile,    _LPWNT40_->nt40Prop.awchBatchFile );

        } else {

            lstrcpyA( lpnt40->achSaveBatchFile,            _LPENH_->envProp.achBatchFile );
            lstrcpyA( _LPWNT40_->nt40Prop.achSaveBatchFile, _LPENH_->envProp.achBatchFile );
            MultiByteToWideChar( CP_ACP, 0,
                                 _LPENH_->envProp.achBatchFile, -1,
                                 awchTmp, ARRAYSIZE(lpnt40->awchBatchFile)
                                );
            awchTmp[ARRAYSIZE(lpnt40->awchBatchFile)-1] = TEXT('\0');
            ualstrcpy( lpnt40->awchBatchFile, awchTmp );
            ualstrcpy( _LPWNT40_->nt40Prop.awchBatchFile, lpnt40->awchBatchFile );

        }

    } else {

        lpnt40->achSaveBatchFile[0] = '\0';
        _LPWNT40_->nt40Prop.achSaveBatchFile[0] = '\0';
        lpnt40->awchBatchFile[0] = TEXT('\0');
        _LPWNT40_->nt40Prop.awchBatchFile[0] = TEXT('\0');

    }

    // Initialize Console properties

    lpnt40->dwForeColor      = _LPWNT40_->nt40Prop.dwForeColor;
    lpnt40->dwBackColor      = _LPWNT40_->nt40Prop.dwBackColor;
    lpnt40->dwPopupForeColor = _LPWNT40_->nt40Prop.dwPopupForeColor;
    lpnt40->dwPopupBackColor = _LPWNT40_->nt40Prop.dwPopupBackColor;
    lpnt40->WinSize          = _LPWNT40_->nt40Prop.WinSize;
    lpnt40->BuffSize         = _LPWNT40_->nt40Prop.BuffSize;
    lpnt40->WinPos           = _LPWNT40_->nt40Prop.WinPos;
    lpnt40->dwCursorSize     = _LPWNT40_->nt40Prop.dwCursorSize;
    lpnt40->dwCmdHistBufSize = _LPWNT40_->nt40Prop.dwCmdHistBufSize;
    lpnt40->dwNumCmdHist     = _LPWNT40_->nt40Prop.dwNumCmdHist;

    return sizeof(PROPNT40);
}

/*
 * INPUT
 *  ppl -> property (assumes it is LOCKED)
 *  lp386 -> 386 PIF data (NOT USED)
 *  lpenh -> enhanced PIF data (GUARANTEED!)
 *  lpWnt -> where to store NT/UNICODE property data
 *  cb = sizeof property data
 *
 * OUTPUT
 *  # of bytes set
 */

int SetNt40Data(PPROPLINK ppl, DATAPTRS aDataPtrs, LPPROPNT40 lpnt40, int cb, UINT flOpt)
{
    _LPWNT40_->nt40Prop.flWnt = lpnt40->flWnt;

    // Set Command Line string

    lstrcpyA(  _LPWNT40_->nt40Prop.achSaveCmdLine, lpnt40->achSaveCmdLine );
    ualstrcpy( _LPWNT40_->nt40Prop.awchCmdLine,    lpnt40->awchCmdLine );

    // Set Other File string

    lstrcpyA(  _LPWNT40_->nt40Prop.achSaveOtherFile, lpnt40->achSaveOtherFile );
    ualstrcpy( _LPWNT40_->nt40Prop.awchOtherFile,    lpnt40->awchOtherFile );

    // Set PIF File string

    lstrcpyA(  _LPWNT40_->nt40Prop.achSavePIFFile, lpnt40->achSavePIFFile );
    ualstrcpy( _LPWNT40_->nt40Prop.awchPIFFile,    lpnt40->awchPIFFile );

    // Set Title string

    lstrcpyA(  _LPWNT40_->nt40Prop.achSaveTitle, lpnt40->achSaveTitle );
    ualstrcpy( _LPWNT40_->nt40Prop.awchTitle,    lpnt40->awchTitle );

    // Set IconFile string

    lstrcpyA(  _LPWNT40_->nt40Prop.achSaveIconFile, lpnt40->achSaveIconFile );
    ualstrcpy( _LPWNT40_->nt40Prop.awchIconFile,    lpnt40->awchIconFile );

    // Set Working Directory string

    lstrcpyA(  _LPWNT40_->nt40Prop.achSaveWorkDir, lpnt40->achSaveWorkDir );
    ualstrcpy( _LPWNT40_->nt40Prop.awchWorkDir,    lpnt40->awchWorkDir );

    // Set Batch File string

    lstrcpyA(  _LPWNT40_->nt40Prop.achSaveBatchFile, lpnt40->achSaveBatchFile );
    ualstrcpy( _LPWNT40_->nt40Prop.awchBatchFile,    lpnt40->awchBatchFile );


    // Set Console properties

    _LPWNT40_->nt40Prop.dwForeColor      = lpnt40->dwForeColor;
    _LPWNT40_->nt40Prop.dwBackColor      = lpnt40->dwBackColor;
    _LPWNT40_->nt40Prop.dwPopupForeColor = lpnt40->dwPopupForeColor;
    _LPWNT40_->nt40Prop.dwPopupBackColor = lpnt40->dwPopupBackColor;
    _LPWNT40_->nt40Prop.WinSize          = lpnt40->WinSize;
    _LPWNT40_->nt40Prop.BuffSize         = lpnt40->BuffSize;
    _LPWNT40_->nt40Prop.WinPos           = lpnt40->WinPos;
    _LPWNT40_->nt40Prop.dwCursorSize     = lpnt40->dwCursorSize;
    _LPWNT40_->nt40Prop.dwCmdHistBufSize = lpnt40->dwCmdHistBufSize;
    _LPWNT40_->nt40Prop.dwNumCmdHist     = lpnt40->dwNumCmdHist;

    ppl->flProp |= PROP_DIRTY;

    return sizeof(PROPNT40);
}

/*
 * INPUT
 *  ppl -> property (assumes it is LOCKED)
 *  lp386 -> 386 PIF data (NOT USED)
 *  lpenh -> enhanced PIF data (GUARANTEED!)
 *  lpNt31 -> where to store NT/UNICODE property data
 *  cb = sizeof property data
 *
 * OUTPUT
 *  # of bytes set
 */
int GetNt31Data(PPROPLINK ppl, DATAPTRS aDataPtrs, LPPROPNT31 lpnt31, int cb, UINT flOpt)
{
    lpnt31->dwWNTFlags = _LPWNT31_->nt31Prop.dwWNTFlags;
    lpnt31->dwRes1     = _LPWNT31_->nt31Prop.dwRes1;
    lpnt31->dwRes2     = _LPWNT31_->nt31Prop.dwRes2;

    // Set Config.sys file string

    lstrcpyA( lpnt31->achConfigFile, _LPWNT31_->nt31Prop.achConfigFile );

    // Set Autoexec.bat file string
    lstrcpyA( lpnt31->achAutoexecFile, _LPWNT31_->nt31Prop.achAutoexecFile );

    return sizeof(PROPNT31);
}


/** SetNt31Data - set environment property data
 *
 * INPUT
 *  ppl -> property (assumes it is LOCKED)
 *  lp386 -> 386 PIF data (NOT USED)
 *  lpenh -> enhanced PIF data (GUARANTEED!)
 *  lpNt31 -> where to store NT/UNICODE property data
 *  cb = sizeof property data
 *
 * OUTPUT
 *  # of bytes set
 */
int SetNt31Data(PPROPLINK ppl, DATAPTRS aDataPtrs, LPPROPNT31 lpnt31, int cb, UINT flOpt)
{
    _LPWNT31_->nt31Prop.dwWNTFlags = lpnt31->dwWNTFlags;
    _LPWNT31_->nt31Prop.dwRes1     = lpnt31->dwRes1;
    _LPWNT31_->nt31Prop.dwRes2     = lpnt31->dwRes2;

    // Set Config.sys file string

    lstrcpyA( _LPWNT31_->nt31Prop.achConfigFile, lpnt31->achConfigFile );

    // Set Autoexec.bat file string
    lstrcpyA( _LPWNT31_->nt31Prop.achAutoexecFile, lpnt31->achAutoexecFile );

    ppl->flProp |= PROP_DIRTY;

    return sizeof(PROPNT31);
}

/** CopyIniWordsToFntData
 *
 *  Transfer INIINFO data to PROPFNT structure.
 *
 *  Entry:
 *      lpFnt   -> PROPFNT
 *      lpii    -> INIINFO
 *      cWords  == # of INIINFO words available
 *
 *  Exit:
 *      Nothing
 */

void CopyIniWordsToFntData(LPPROPFNT lpFnt, LPINIINFO lpii, int cWords)
{
    lpFnt->flFnt = (lpii->wFlags & FNT_BOTHFONTS);

    // cWords is transformed into cBytes (only the name is the same...)
    cWords *= 2;

    if (cWords > FIELD_OFFSET(INIINFO, wFontHeight)) {

        // Note that we can set both the desired and ACTUAL fields to
        // the same thing, because in 3.1, only raster fonts were supported.

        lpFnt->flFnt |= FNT_RASTER;
        lpFnt->cxFont = lpFnt->cxFontActual = lpii->wFontWidth;
        lpFnt->cyFont = lpFnt->cyFontActual = lpii->wFontHeight;
    }
}


/*
 *  Transfer INIINFO data to PROPWIN structure.
 *
 *  Entry:
 *      lpWin   -> PROPWIN
 *      lpii    -> INIINFO
 *      cWords  == # of INIINFO words available
 *
 *  Exit:
 *      Nothing
 */

void CopyIniWordsToWinData(LPPROPWIN lpWin, LPINIINFO lpii, int cWords)
{
    lpWin->flWin = lpii->wFlags & (WIN_SAVESETTINGS | WIN_TOOLBAR);

    // The new NORESTORE bit's setting should be the opposite
    // the user's SAVESETTINGS bit

    lpWin->flWinInit &= ~WININIT_NORESTORE;
    if (!(lpWin->flWin & WIN_SAVESETTINGS))
        lpWin->flWinInit |=  WININIT_NORESTORE;

    // cWords is transformed into cBytes (only the name is the same...)
    cWords *= 2;

    if (cWords > FIELD_OFFSET(INIINFO,wWinWidth))
        memcpy(&lpWin->cxWindow, &lpii->wWinWidth,
                 min(cWords-FIELD_OFFSET(INIINFO,wWinWidth),
                     sizeof(INIINFO)-FIELD_OFFSET(INIINFO,wWinWidth)));
}


/** GetIniWords
 *
 *  Reads a sequence of WORDs or SHORTs from a specified section
 *  of an INI file into a supplied array.
 *
 *  Entry:
 *      lpszSection     -> section name (major key)
 *      lpszEntry       -> entry name (minor key)
 *      lpwBuf          -> array of WORDs to receive data
 *      cwBuf           =  size of lpwBuf
 *      lpszFilename    -> name of INI file to inspect
 *
 *  Exit:
 *      Returns number of words read, 0 on error.
 *
 *  Overview:
 *      Grab the string via GetPrivateProfileString, then manually
 *      parse the numbers out of it.
 */

WORD GetIniWords(LPCTSTR lpszSection, LPCTSTR lpszEntry,
                 LPWORD lpwBuf, WORD cwBuf, LPCTSTR lpszFilename)
{
    TCHAR szBuffer[MAX_INI_BUFFER];

    // Read the profile entry as a string

    if (!GetPrivateProfileString(lpszSection, lpszEntry,
                                 c_szNULL, szBuffer, ARRAYSIZE(szBuffer),
                                 lpszFilename))
        return 0;

    return ParseIniWords(szBuffer, lpwBuf, cwBuf, NULL);
}


/*  Reads a sequence of WORDs or SHORTs from a LPSTR into a
 *  supplied array.
 *
 *  Entry:
 *      lpsz    -> string to parse
 *      lpwBuf  -> array of WORDs to receive data
 *      cwBuf   == size of lpwBuf
 *      lppsz   -> optional pointer for address of first unscanned character
 *
 *  Exit:
 *      Returns number of words read, 0 on error.
 */

WORD ParseIniWords(LPCTSTR lpsz, LPWORD lpwBuf, WORD cwBuf, LPTSTR *lplpsz)
{
    WORD wCount = 0;

    for (; cwBuf; --cwBuf) {

        while (*lpsz == TEXT(' ') || *lpsz == TEXT('\t') || *lpsz == TEXT(','))
            ++lpsz;

        if (!*lpsz)
            break;              // end of string reached

        *lpwBuf++ = (WORD) StrToInt(lpsz);
        ++wCount;

        while (*lpsz == TEXT('-') || *lpsz >= TEXT('0')  && *lpsz <= TEXT('9'))
            ++lpsz;
    }
    if (lplpsz)
        *lplpsz = (LPTSTR)lpsz;

    return wCount;
}


/*  Given an array of words, write them out to an INI file in a manner
 *  that GetIniWords can read back.
 *
 *  Entry:
 *      lpszSection     -> section name (major key)
 *      lpszEntry       -> entry name (minor key)
 *      lpwBuf          -> array of WORDs to write
 *      cwBuf           =  size of lpwBuf, may not exceed MAXINIWORDS
 *      lpszFilename    -> name of INI file to write to
 *
 *  Exit:
 *      Returns nonzero on success.
 *
 *  Overview:
 *      Build a giant string consisting of the WORDs glommed together
 *      (separated by spaces) and write it out via WritePrivateProfileString.
 */

BOOL WriteIniWords(LPCTSTR lpszSection, LPCTSTR lpszEntry,
                   LPCWORD lpwBuf, WORD cwBuf, LPCTSTR lpszFilename)
{
    LPTSTR lpsz;
    TCHAR  szBuffer[MAX_INI_BUFFER];

    for (lpsz = szBuffer; cwBuf; --cwBuf)
        lpsz += wsprintf(lpsz, TEXT("%d "), *lpwBuf++);

    return WritePrivateProfileString(lpszSection, lpszEntry, szBuffer, lpszFilename);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\pifhot.c ===
/*
 *  Microsoft Confidential
 *  Copyright (C) Microsoft Corporation 1991
 *  All Rights Reserved.
 *
 *
 *  PIFHOT.C
 *  User interface routines for hot-keys
 *
 *  History:
 *  Created 21-Dec-1992 5:30pm by Jeff Parsons (based on old PIFEDIT code)
 *  Rewritten 25-Dec-1993 by Raymond Chen
 */

#include "shellprv.h"
#pragma hdrstop

/*
 * Values for the second argument to MapVirtualKey, mysteriously
 * missing from windows.h.
 */
#define MVK_OEMFROMVK 0
#define MVK_VKFROMOEM 1

/*
 * BEWARE!  Converting a VK to a scan code and back again does not
 * necessarily get you back where you started!  The main culprit
 * is the numeric keypad, since (for example) VK_LEFT and VK_NUMPAD4
 * both map to scan code 0x4B.  We catch the numeric keypad specially
 * for exactly this purpose.
 *
 * The following table converts VK codes VK_NUMPAD0 through VK_NUMPAD9
 * to the corresponding VK_ code if NumLock is off.
 *
 * Note that this table and the loop that accesses it assume that the
 * scan codes VK_NUMPAD0 through VK_NUMPAD9 are consecutive.
 */

WORD mpvkvk[10] = {
    VK_INSERT,                  /* VK_NUMPAD0 */
    VK_END,                     /* VK_NUMPAD1 */
    VK_DOWN,                    /* VK_NUMPAD2 */
    VK_NEXT,                    /* VK_NUMPAD3 */
    VK_LEFT,                    /* VK_NUMPAD4 */
    VK_CLEAR,                   /* VK_NUMPAD5 */
    VK_RIGHT,                   /* VK_NUMPAD6 */
    VK_HOME,                    /* VK_NUMPAD7 */
    VK_UP,                      /* VK_NUMPAD8 */
    VK_PRIOR,                   /* VK_NUMPAD9 */
};


/** HotKeyWindowsFromOem - Convert OEM hotkey into Windows hotkey
 *
 * INPUT
 *  lppifkey -> PIFKEY describing OEM Hotkey
 *
 * OUTPUT
 *  Windows hotkey value corresponding to lpwHotkey.
 */

WORD HotKeyWindowsFromOem(LPCPIFKEY lppifkey)
{
    WORD wHotKey = 0;

    if (lppifkey->Scan) {
        wHotKey = (WORD) MapVirtualKey(lppifkey->Scan, MVK_VKFROMOEM);

        if (lppifkey->Val & 2) {
            WORD vk;
            for (vk = VK_NUMPAD0; vk <= VK_NUMPAD9; vk++) {
                if (wHotKey == mpvkvk[vk - VK_NUMPAD0]) {
                    wHotKey = vk; break;
                }
            }
            ASSERTTRUE(vk <= VK_NUMPAD9); /* Buggy PIF; do what we can */
        }

        if (lppifkey->Val & 1) wHotKey |= (HOTKEYF_EXT << 8);

        if (lppifkey->ShVal & (fPIFSh_RShf | fPIFSh_LShf))
            wHotKey |= (HOTKEYF_SHIFT << 8);

        if (lppifkey->ShVal & (fPIFSh_LCtrl|fPIFSh_RCtrl|fPIFSh_Ctrl))
            wHotKey |= (HOTKEYF_CONTROL << 8);

        if (lppifkey->ShVal & (fPIFSh_LAlt|fPIFSh_RAlt|fPIFSh_Alt))
            wHotKey |= (HOTKEYF_ALT << 8);
    }
    return wHotKey;
}


/** HotKeyOemFromWindows - Convert Windows hotkey into OEM hotkey
 *
 * INPUT
 *  lppifkey -> struct PIF_Key to receive OEM hotkey
 *  wHotKey  =  Windows hotkey
 *
 * OUTPUT
 *  lppifkey filled with hotkey info
 */

void HotKeyOemFromWindows(LPPIFKEY lppifkey, WORD wHotKey)
{
    lppifkey->Scan = 0;
    lppifkey->ShVal = 0;
    lppifkey->ShMsk = 0;
    lppifkey->Val = 0;

    if (wHotKey) {
        lppifkey->Scan = (WORD) MapVirtualKey(LOBYTE(wHotKey), MVK_OEMFROMVK);
        lppifkey->ShMsk = fPIFSh_RShf | fPIFSh_LShf | fPIFSh_Ctrl | fPIFSh_Alt;

        if (wHotKey & (HOTKEYF_EXT << 8)) lppifkey->Val |= 1;

        /* Assumes that VK_NUMPAD0 through VK_NUMPAD9 are consecutive */
        if ((wHotKey - VK_NUMPAD0) < 10) lppifkey->Val |= 2;

        if (wHotKey & (HOTKEYF_SHIFT << 8))
            lppifkey->ShVal |= fPIFSh_RShf | fPIFSh_LShf;

        if (wHotKey & (HOTKEYF_CONTROL << 8))
            lppifkey->ShVal |= fPIFSh_Ctrl;

        if (wHotKey & (HOTKEYF_ALT << 8))
            lppifkey->ShVal |= fPIFSh_Alt;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\pickicon.c ===
#include "shellprv.h"
#pragma  hdrstop

#define MAX_ICONS   500             // that is a lot 'o icons

#define CX_BORDER    4
#define CY_BORDER    12

typedef struct {
    LPCTSTR pszDialogTitle;           // input
    BOOL    bShowRestoreButton;       // input
    LPTSTR pszIconPath;              // input/output
    int cbIconPath;                 // input
    int iIconIndex;                 // input/output
    // private state variables
    HWND hDlg;
    BOOL fFirstPass;
    TCHAR szPathField[MAX_PATH];
    TCHAR szBuffer[MAX_PATH];
} PICKICON_DATA, *LPPICKICON_DATA;


typedef struct 
{
    int iResult;                    // icon index within the resources
    int iResId;                     // resource ID to search for!
} ICONENUMSTATE, *LPICONENUMSTATE;


// Call back function used when trying to find the correct icon to be 
// highlighted, called with the name of each resource - we compare this
// against the one specified in the structure and bail out if we get
// a match.

BOOL CALLBACK IconEnumProc( HANDLE hModule, LPCTSTR lpszType, LPTSTR lpszName, LONG_PTR lParam )
{
    LPICONENUMSTATE pState = (LPICONENUMSTATE)lParam;

    if ( (INT_PTR)lpszName == pState->iResId )
        return FALSE;                        // bail out of enum loop

    pState->iResult++;
    return TRUE;
}




// Checks if the file exists, if it doesn't it tries tagging on .exe and
// if that fails it reports an error. The given path is environment expanded.
// If it needs to put up an error box, it changes the cursor back.
// Path s assumed to be MAXITEMPATHLEN long.
// The main reason for moving this out of the DlgProc was because we're
// running out of stack space on the call to the comm dlg.

BOOL IconFileExists(LPPICKICON_DATA lppid)
{
    TCHAR szExpBuffer[ ARRAYSIZE(lppid->szBuffer) ];

    if (lppid->szBuffer[0] == 0)
        return FALSE;

    if (SHExpandEnvironmentStrings(lppid->szBuffer, szExpBuffer, ARRAYSIZE(szExpBuffer)))
    {
        PathUnquoteSpaces(lppid->szBuffer);
        PathUnquoteSpaces(szExpBuffer);

        if (PathResolve(szExpBuffer, NULL, PRF_VERIFYEXISTS | PRF_TRYPROGRAMEXTENSIONS))
            return TRUE;

        ShellMessageBox(HINST_THISDLL, lppid->hDlg, MAKEINTRESOURCE(IDS_BADPATHMSG), 0, MB_OK | MB_ICONEXCLAMATION, (LPTSTR)lppid->szPathField);
    }

    return FALSE;
}

//
// GetDefaultIconImageName:
//     szBuffer should be at least MAX_PATH chars big
//
void GetDefaultIconImageName( LPTSTR szBuffer )
{
    TCHAR szModName[ MAX_PATH ];
    TCHAR szSystemDir[ MAX_PATH ];
    DWORD cbSysDir;

    GetModuleFileName(HINST_THISDLL, szModName, ARRAYSIZE(szModName));
    cbSysDir = GetSystemDirectory(szSystemDir, ARRAYSIZE(szSystemDir) );
    if (CompareString(LOCALE_SYSTEM_DEFAULT, NORM_IGNORECASE, szSystemDir, cbSysDir, szModName, cbSysDir) == 2)
    {
        //
        // Okay, the path for SHELL32.DLL starts w/the system directory.
        // To be sneaky and helpfull, we're gonna change it to "%systemroot%"
        //

        lstrcpy( szBuffer, TEXT("%SystemRoot%\\system32") );
        PathAppend( szBuffer, PathFindFileName(szModName) );
    }
    else
    {
        lstrcpy(szBuffer, szModName );
    }
}

void PutIconsInList(LPPICKICON_DATA lppid)
{
    HICON  *rgIcons;
    int  cIcons;
    HWND hDlg = lppid->hDlg;
    DECLAREWAITCURSOR;
    LONG err = LB_ERR;

    SendDlgItemMessage(hDlg, IDD_ICON, LB_RESETCONTENT, 0, 0L);

    GetDlgItemText(hDlg, IDD_PATH, lppid->szPathField, ARRAYSIZE(lppid->szPathField));

    lstrcpy(lppid->szBuffer, lppid->szPathField);

    if (!IconFileExists(lppid)) {
        if (lppid->fFirstPass) {

            // Icon File doesn't exist, use progman
            lppid->fFirstPass = FALSE;  // Only do this bit once.
            GetDefaultIconImageName( lppid->szBuffer );
        } else {
            return;
        }
    }

    lstrcpy(lppid->szPathField, lppid->szBuffer);
    SetDlgItemText(hDlg, IDD_PATH, lppid->szPathField);

    SetWaitCursor();

    rgIcons = (HICON *)LocalAlloc(LPTR, MAX_ICONS*SIZEOF(HICON));

    if (rgIcons != NULL)
        cIcons = (int)ExtractIconEx(lppid->szBuffer, 0, rgIcons, NULL, MAX_ICONS);
    else
        cIcons = 0;

    ResetWaitCursor();
    if (!cIcons) {

        if (lppid->fFirstPass) {

            lppid->fFirstPass = FALSE;  // Only do this bit once.

            ShellMessageBox(HINST_THISDLL, hDlg, MAKEINTRESOURCE(IDS_NOICONSMSG1), 0, MB_OK | MB_ICONEXCLAMATION, (LPCTSTR)lppid->szBuffer);

            // No icons here - change the path do somewhere where we
            // know there are icons. Get the path to progman.
            GetDefaultIconImageName( lppid->szPathField );
            SetDlgItemText(hDlg, IDD_PATH, lppid->szPathField);
            PutIconsInList(lppid);
        } else {

            ShellMessageBox(HINST_THISDLL, hDlg, MAKEINTRESOURCE(IDS_NOICONSMSG), 0, MB_OK | MB_ICONEXCLAMATION, (LPCTSTR)lppid->szBuffer);
            return;
        }
    }

    SetWaitCursor();

    SendDlgItemMessage(hDlg, IDD_ICON, WM_SETREDRAW, FALSE, 0L);

    if (rgIcons) {
        int i;
        for (i = 0; i < cIcons; i++) {
            SendDlgItemMessage(hDlg, IDD_ICON, LB_ADDSTRING, 0, (LPARAM)(UINT_PTR)rgIcons[i]);
        }
        LocalFree((HLOCAL)rgIcons);
    }

    // Cope with being given a resource ID, not an index into the icon array.  To do this
    // we must enumerate the icon names checking for a match.  If we have one then highlight
    // that, otherwise default to the first.
    //
    // A resource icon reference is indicated by being passed a -ve iIconIndex.

    if ( lppid->iIconIndex >= 0 )
    {
        err = (LONG) SendDlgItemMessage( hDlg, IDD_ICON, LB_SETCURSEL, lppid->iIconIndex, 0L);
    }
    else
    {
        HMODULE hModule = LoadLibrary( lppid->szBuffer );
        if (hModule)
        {
            ICONENUMSTATE state;

            state.iResult = 0;
            state.iResId = -(lppid->iIconIndex);

            EnumResourceNames( hModule, RT_GROUP_ICON, IconEnumProc, (LONG_PTR)&state );

            err = (LONG) SendDlgItemMessage( hDlg, IDD_ICON, LB_SETCURSEL, state.iResult, 0L );
            FreeLibrary( hModule );
        }
    }

    // Check for failure, if we did then ensure we highlight the first!

    if ( err == LB_ERR )
        SendDlgItemMessage( hDlg, IDD_ICON, LB_SETCURSEL, 0, 0L );
       
    SendDlgItemMessage(hDlg, IDD_ICON, WM_SETREDRAW, TRUE, 0L);
    InvalidateRect(GetDlgItem(hDlg, IDD_ICON), NULL, TRUE);

    ResetWaitCursor();
}


void InitPickIconDlg(HWND hDlg, LPPICKICON_DATA lppid)
{
    RECT rc;
    UINT cy;
    HWND hwndIcons;

    // init state variables

    lppid->hDlg = hDlg;
    lstrcpyn(lppid->szPathField, lppid->pszIconPath, ARRAYSIZE(lppid->szPathField));

    // this first pass stuff is so that the first time something
    // bogus happens (file not found, no icons) we give the user
    // a list of icons from progman.
    lppid->fFirstPass = TRUE;

    // Override the Dialog Title if Set. Else use the default Title defined in the Dialog resource.
    if (lppid->pszDialogTitle && (lppid->pszDialogTitle[0] != TEXT('\0')))
    {
        SetWindowText(hDlg, lppid->pszDialogTitle);
    }

    // Enable or Disable the Restore Default button.
    if (lppid->bShowRestoreButton)
        ShowWindow(GetDlgItem(lppid->hDlg, IDD_RESTORE),SW_SHOW);
    else
        ShowWindow(GetDlgItem(lppid->hDlg, IDD_RESTORE), SW_HIDE);
    

    // init the dialog controls

    SetDlgItemText(hDlg, IDD_PATH, lppid->pszIconPath);

    // Cannot max against 0 because 0 means "no limit"
    SendDlgItemMessage(hDlg, IDD_PATH, EM_LIMITTEXT, max(lppid->cbIconPath-1, 1), 0L);

    SendDlgItemMessage(hDlg, IDD_ICON, LB_SETCOLUMNWIDTH, GetSystemMetrics(SM_CXICON) + CX_BORDER, 0L);

    hwndIcons = GetDlgItem(hDlg, IDD_ICON);

    /* compute the height of the listbox based on icon dimensions */
    GetClientRect(hwndIcons, &rc);

    cy = ((GetSystemMetrics(SM_CYICON) + CY_BORDER) * 4) + 
         GetSystemMetrics(SM_CYHSCROLL) + 
         GetSystemMetrics(SM_CYEDGE) * 3;

    SetWindowPos(hwndIcons, NULL, 0, 0, rc.right, cy, SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE);
    SHAutoComplete(GetDlgItem(hDlg, IDD_PATH), 0);

    PutIconsInList(lppid);
}


// call the common browse code for this

BOOL BrowseForIconFile(LPPICKICON_DATA lppid)
{
    TCHAR szTitle[80];

    GetWindowText(lppid->hDlg, szTitle, ARRAYSIZE(szTitle));
    GetDlgItemText(lppid->hDlg, IDD_PATH, lppid->szBuffer, ARRAYSIZE(lppid->szBuffer));

    // We will never be quoted here because IconFileExists() removes quotes (of course user could type them in)
    if (lppid->szBuffer[0] != '"')
        PathQuoteSpaces(lppid->szBuffer);

    if (GetFileNameFromBrowse(lppid->hDlg, lppid->szBuffer, ARRAYSIZE(lppid->szBuffer), NULL, MAKEINTRESOURCE(IDS_ICO), MAKEINTRESOURCE(IDS_ICONSFILTER), szTitle))
    {
        PathQuoteSpaces(lppid->szBuffer);
        SetDlgItemText(lppid->hDlg, IDD_PATH, lppid->szBuffer);
        // Set default button to OK.
        SendMessage(lppid->hDlg, DM_SETDEFID, IDOK, 0);
        return TRUE;
    } else
        return FALSE;
}

// test if the name field is different from the last file we looked at

BOOL NameChange(LPPICKICON_DATA lppid)
{
    GetDlgItemText(lppid->hDlg, IDD_PATH, lppid->szBuffer, ARRAYSIZE(lppid->szBuffer));

    return lstrcmpi(lppid->szBuffer, lppid->szPathField);
}


//
// dialog procedure for picking an icon (ala progman change icon)
// uses DLG_PICKICON template
//
// in:
//      pszIconFile
//      cbIconFile
//      iIndex
//
// out:
//      pszIconFile
//      iIndex
//

BOOL_PTR CALLBACK PickIconDlgProc(HWND hDlg, UINT wMsg, WPARAM wParam, LPARAM lParam)
{
    LPPICKICON_DATA lppid = (LPPICKICON_DATA)GetWindowLongPtr(hDlg, DWLP_USER);
    DWORD dwOldLayout;

        // Array for context help:

        static const DWORD aPickIconHelpIDs[] = {
                IDD_PATH,   IDH_FCAB_LINK_ICONNAME,
                IDD_ICON,   IDH_FCAB_LINK_CURRENT_ICON,
                IDD_BROWSE, IDH_BROWSE,

                0, 0
        };

    switch (wMsg) {
    case WM_INITDIALOG:
        SetWindowLongPtr(hDlg, DWLP_USER, lParam);
        InitPickIconDlg(hDlg, (LPPICKICON_DATA)lParam);
        break;

    case WM_COMMAND:
        switch (GET_WM_COMMAND_ID(wParam, lParam)) {
        case IDD_BROWSE:
            if (BrowseForIconFile(lppid))
                PutIconsInList(lppid);
            break;

        case IDD_PATH:
            if (NameChange(lppid))
                SendDlgItemMessage(hDlg, IDD_ICON, LB_SETCURSEL, (WPARAM)-1, 0);
            break;

        case IDD_ICON:
            if (NameChange(lppid)) {
                PutIconsInList(lppid);
                break;
            }

            if (GET_WM_COMMAND_CMD(wParam, lParam) != LBN_DBLCLK)
                break;

            /*** FALL THRU on double click ***/

        case IDOK:

            if (NameChange(lppid)) {
                PutIconsInList(lppid);
            } else {
                int iIconIndex = (int)SendDlgItemMessage(hDlg, IDD_ICON, LB_GETCURSEL, 0, 0L);
                if (iIconIndex < 0)
                    iIconIndex = 0;
                lppid->iIconIndex = iIconIndex;
                lstrcpyn(lppid->pszIconPath, lppid->szPathField, lppid->cbIconPath);

                EndDialog(hDlg, S_OK);
            }
            break;

        case IDCANCEL:
            EndDialog(hDlg, HRESULT_FROM_WIN32(ERROR_CANCELLED));
            break;

        case IDD_RESTORE:
            EndDialog(hDlg, S_FALSE);
            break;

        default:
            return(FALSE);
        }
        break;

    // owner draw messages for icon listbox

    case WM_DRAWITEM:
        #define lpdi ((DRAWITEMSTRUCT *)lParam)

        if (lpdi->itemState & ODS_SELECTED)
            SetBkColor(lpdi->hDC, GetSysColor(COLOR_HIGHLIGHT));
        else
            SetBkColor(lpdi->hDC, GetSysColor(COLOR_WINDOW));


        /* repaint the selection state */
        ExtTextOut(lpdi->hDC, 0, 0, ETO_OPAQUE, &lpdi->rcItem, NULL, 0, NULL);

        dwOldLayout = GET_DC_LAYOUT(lpdi->hDC);

        if (g_bMirroredOS && dwOldLayout)
        {
            SET_DC_LAYOUT(lpdi->hDC, dwOldLayout | LAYOUT_PRESERVEBITMAP);
        }

        /* draw the icon */
        if ((int)lpdi->itemID >= 0)
          DrawIcon(lpdi->hDC, (lpdi->rcItem.left + lpdi->rcItem.right - GetSystemMetrics(SM_CXICON)) / 2,
                              (lpdi->rcItem.bottom + lpdi->rcItem.top - GetSystemMetrics(SM_CYICON)) / 2, (HICON)lpdi->itemData);
        if (dwOldLayout)
        {
            SET_DC_LAYOUT(lpdi->hDC, dwOldLayout);
        }                              

        // InflateRect(&lpdi->rcItem, -1, -1);

        /* if it has the focus, draw the focus */
        if (lpdi->itemState & ODS_FOCUS)
            DrawFocusRect(lpdi->hDC, &lpdi->rcItem);

        #undef lpdi
        break;

    case WM_MEASUREITEM:
        #define lpmi ((MEASUREITEMSTRUCT *)lParam)

        lpmi->itemWidth = GetSystemMetrics(SM_CXICON) + CX_BORDER;
        lpmi->itemHeight = GetSystemMetrics(SM_CYICON) + CY_BORDER;

        #undef lpmi
        break;

    case WM_DELETEITEM:
        #define lpdi ((DELETEITEMSTRUCT *)lParam)

        DestroyIcon((HICON)lpdi->itemData);

        #undef lpdi
        break;

    case WM_HELP:
        WinHelp(((LPHELPINFO) lParam)->hItemHandle, NULL,
            HELP_WM_HELP, (ULONG_PTR)(LPTSTR) aPickIconHelpIDs);
        break;

    case WM_CONTEXTMENU:
        WinHelp((HWND) wParam, NULL, HELP_CONTEXTMENU,
            (ULONG_PTR)(LPVOID)aPickIconHelpIDs);
        break;

    default:
        return FALSE;
    }

    return TRUE;
}

// puts up the pick icon dialog

STDAPI_(int) PickIconDlg(HWND hwnd, IN OUT LPTSTR pszIconPath, UINT cbIconPath, int *piIconIndex)
{
    return SUCCEEDED(PickIconDlgWithTitle(hwnd, NULL, FALSE, pszIconPath, cbIconPath, piIconIndex));
}

// puts up the pick icon dialog with a customized Title for the Dialog Window.

STDAPI PickIconDlgWithTitle(HWND hwnd, LPCTSTR pszTitle, BOOL bShowRestoreButton, IN OUT LPTSTR pszIconPath, UINT cbIconPath, int *piIconIndex)
{
    RIPMSG(pszIconPath && IS_VALID_WRITE_BUFFER(pszIconPath, TCHAR, cbIconPath), "PickIconDlgWithTitle: caller passed bad pszIconPath");
    RIPMSG(piIconIndex != NULL, "PickIconDlgWithTitle: caller passed bad piIconIndex");

    if (pszIconPath && piIconIndex)
    {
        PICKICON_DATA *pid = (PICKICON_DATA *)LocalAlloc(LPTR, sizeof(PICKICON_DATA));
        if (pid)
        {
            HRESULT res;

            pid->pszDialogTitle = pszTitle;
            pid->bShowRestoreButton = bShowRestoreButton;
            pid->pszIconPath = pszIconPath;
            pid->cbIconPath = cbIconPath;
            pid->iIconIndex = *piIconIndex;

            res = (HRESULT)DialogBoxParam(HINST_THISDLL, MAKEINTRESOURCE(DLG_PICKICON), hwnd, PickIconDlgProc, (LPARAM)pid);

            *piIconIndex = pid->iIconIndex;

            LocalFree(pid);

            return res;
        }

        *piIconIndex = 0;
        *pszIconPath = 0;

        return HRESULT_FROM_WIN32(ERROR_CANCELLED);
    }
    return E_INVALIDARG;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\pifhotp.h ===
/*
 *  Microsoft Confidential
 *  Copyright (C) Microsoft Corporation 1992,1993
 *  All Rights Reserved.
 *
 *
 *  PIFHOTP.H
 *  Private PIFMGR include file
 *
 *  History:
 *  Created 22-Mar-1993 2:58pm by Jeff Parsons
 */

#ifdef  OLD_HOTKEY_GOOP

#define CLASS_PIFHOTKEY         TEXT("PIFHotKey")

#define WM_SETPIFHOTKEY         (WM_USER+0)
#define WM_GETPIFHOTKEY         (WM_USER+1)


#define HOTINFO_NEW             0x0001
#define HOTINFO_EDIT            0x0002
#define HOTINFO_COMPLETE        0x0004

typedef struct HOTINFO {        /* hi */
    HWND    hwnd;               //
    HWND    hDlg;               //
    HOTKEY  hk;                 //
    HOTKEY  hkTmp;              //
    HOTKEY  hkInit;             //
    int     flags;              // see HOTINFO_*
    TCHAR    cbText;             //
    TCHAR    szText[80];         //
} HOTINFO;
typedef HOTINFO *PHOTINFO;
typedef HOTINFO *LPHOTINFO;

/* XLATOFF */
#define ALT_LPARAM              ((DWORD)((DWORD)(MapVirtualKey(VK_MENU,0)) << 16))
#define CTRL_LPARAM             ((DWORD)((DWORD)(MapVirtualKey(VK_CONTROL,0)) << 16))
#define SHIFT_LPARAM            ((DWORD)((DWORD)(MapVirtualKey(VK_SHIFT,0)) << 16))
/* XLATON */


/*
 *  Internal function prototypes
 */

BOOL LoadGlobalHotKeyEditData(void);
void FreeGlobalHotKeyEditData(void);
long HotKeyWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
void SetHotKeyCaret(PHOTINFO phi);
void ChangeHotKey(PHOTINFO phi);
void SetHotKeyText(PHOTINFO phi, PHOTKEY phk);
void SetHotKeyLen(PHOTINFO phi);
void SetHotKeyState(PHOTINFO phi, WORD keyid, LONG lParam);

#endif /* OLD_HOTKEY_GOOP */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\piffntp.h ===
/*
 *  Microsoft Confidential
 *  Copyright (C) Microsoft Corporation 1992,1993
 *  All Rights Reserved.
 *
 *
 *  PIFFNTP.H
 *  Private PIFMGR include file
 *
 *  History:
 *  Created 22-Mar-1993 2:58pm by Jeff Parsons (from vmdosapp\fontutil.h)
 */

#define PREVIEW_BORDER          1

#define DY_TTBITMAP             12

/*
 *  These parameters control how fast the fdiCache should grow.
 */

#define FDI_TABLE_START         20      /* Number of entries to start */
#define FDI_TABLE_INC           10      /* Increment in number of slots */


typedef struct tagDISPLAYPARAMETERS {   /* dp */
    INT dpHorzSize;
    INT dpVertSize;
    INT dpHorzRes;
    INT dpVertRes;
    INT dpLogPixelsX;
    INT dpLogPixelsY;
    INT dpAspectX;
    INT dpAspectY;
    INT dpBitsPerPixel;
    TCHAR szTTFace[2][LF_FACESIZE];
} DISPLAYPARAMETERS;

//#define BACKGROUND    0x000000FF      /* bright blue  */
//#define BACKGROUNDSEL 0x00FF00FF      /* bright magenta */
//#define BUTTONFACE    0x00C0C0C0      /* bright grey  */
//#define BUTTONSHADOW  0x00808080      /* dark grey    */


#define FNTFLAGSFROMID(id)  ((id - IDC_RASTERFONTS + 1) << FNT_FONTMASKBITS)
#define IDFROMFNTFLAGS(fl)  (IDC_RASTERFONTS - 1 + (((fl) & FNT_FONTMASK) >> FNT_FONTMASKBITS))

#if FNTFLAGSFROMID(IDC_RASTERFONTS) != FNT_RASTERFONTS || \
    IDFROMFNTFLAGS(FNT_RASTERFONTS) != IDC_RASTERFONTS || \
    FNTFLAGSFROMID(IDC_TTFONTS) != FNT_TTFONTS         || \
    IDFROMFNTFLAGS(FNT_TTFONTS) != IDC_TTFONTS         || \
    FNTFLAGSFROMID(IDC_BOTHFONTS) != FNT_BOTHFONTS   || \
    IDFROMFNTFLAGS(FNT_BOTHFONTS) != IDC_BOTHFONTS
#error Dialog control IDs and FNT flags values are not compatible
#endif


/*
 * IsDlgError
 *
 *      To simplify error checking, we assume that all *_ERR values are -1
 *      and all *_ERRSPACE values are -2.
 *
 *      This also assumes a two's complement number system.
 *
 *  Entry:
 *
 *      A return code from a list box or combo box.
 *
 *  Exit:
 *
 *      Nonzero if the return code indicated an error of some sort.
 *      Zero    if the return code indiated no error.
 *
 */

#define B_ERR (-1)

#if LB_ERR != B_ERR || LB_ERRSPACE != -2 || \
    CB_ERR != B_ERR || CB_ERRSPACE != -2
#error Problem with manifest constants.
#endif

#define IsDlgError(dw) ((DWORD)(dw) >= (DWORD)(-2))


/*
 *  Low-level macros
 *
 *  BPFDIFROMREF(lParam)
 *
 *  These three macros pack and unpack list box reference data.
 *
 *  bpfdi     = based pointer into segCache describing the list box entry
 *  fTrueType = nonzero if the font is a TrueType font
 *  lParam    = the reference data
 *
 */

#define BPFDIFROMREF(lParam)         (BPFDI)(lParam)


/*
 *  High-level macros
 *
 *  These macros handle the SendMessages that go to/from list boxes
 *  and combo boxes.
 *
 *  The "lcb" prefix stands for "list or combo box".
 *
 *  Basically, we're providing mnemonic names for what would otherwise
 *  look like a whole slew of confusing SendMessage's.
 *
 */






#define lcbFindStringExact(hwnd, fListBox, lpsz) \
        (DWORD)SendMessage(hwnd, fListBox ? LB_FINDSTRINGEXACT : CB_FINDSTRINGEXACT, \
                          (WPARAM)-1, (LPARAM)(LPTSTR)lpsz)

#define lcbAddString(hwnd, fListBox, lpsz) \
        (DWORD)SendMessage(hwnd, fListBox ? LB_ADDSTRING : CB_ADDSTRING, \
                          0, (LPARAM)(LPTSTR)lpsz)

#define lcbSetItemDataPair(hwnd, fListBox, w, bpfdi, fIsTrueType) \
        if (!IsSpecialBpfdi((BPFDI)bpfdi)) \
            ((BPFDI)bpfdi)->bTT = fIsTrueType; \
        (DWORD)SendMessage(hwnd, fListBox ? LB_SETITEMDATA : CB_SETITEMDATA, \
                    (WPARAM)w, (LPARAM)bpfdi)

#define lcbGetCount(hwnd, fListBox) \
        (DWORD)SendMessage(hwnd, fListBox ? LB_GETCOUNT : CB_GETCOUNT, (WPARAM)0, (LPARAM)0)

#define lcbGetCurSel(hwnd, fListBox) \
        (DWORD)SendMessage(hwnd, fListBox ? LB_GETCURSEL : CB_GETCURSEL, (WPARAM)0, (LPARAM)0)

#define lcbSetCurSel(hwnd, fListBox, w) \
        (DWORD)SendMessage(hwnd, fListBox ? LB_SETCURSEL : CB_SETCURSEL, (WPARAM)w, (LPARAM)0)

#define lcbGetItemDataPair(hwnd, fListBox, w) \
        (DWORD_PTR)SendMessage(hwnd, fListBox ? LB_GETITEMDATA : CB_GETITEMDATA, (WPARAM)w, (LPARAM)0)

#define lcbGetBpfdi(hwnd, fListBox, w) \
        BPFDIFROMREF(lcbGetItemDataPair(hwnd, fListBox, w))

#define lcbInsertString(hwnd, fListBox, lpsz, i) \
        (DWORD)SendMessage(hwnd, fListBox ? LB_INSERTSTRING : CB_INSERTSTRING, \
                           (WPARAM)i, (LPARAM)(LPTSTR)lpsz)

/*
 * the listbox/combox strings are stored as follows. we use the tabs
 * to do TabbedTextOut().  The padding is used to keep the sorting right.
 * TT fonts are distinguished by the hiword of the item data
 *
 *  String:     \t%2d\tx\t%2d
 *               wd    ht
 *
 *  The "Auto" entry is stored as...
 *
 *  String:     \1Auto
 *
 *      The first character is \1 so that Auto sorts at the top of the list.
 *      (The \1 is not actually displayed.)
 *
 */


/*
 * FONTDIMENINFO
 *
 * The distinction between the requested and returned font dimensions is
 * important in the case of TrueType fonts, in which there is no guarantee
 * that what you ask for is what you will get.
 *
 * Note that the correspondence between "Requested" and "Actual" is broken
 * whenever the user changes his display driver, because GDI uses driver
 * parameters to control the font rasterization.
 *
 * The fdiHeightReq and fdiWidthReq fields are both zero if the font is
 * a raster font.
 *
 */

typedef struct tagFONTDIMENINFO {       /* fdi */
    UINT fdiWidthReq;                   /* Font width requested */
    UINT fdiHeightReq;                  /* Font height requested */
    UINT fdiWidthActual;                /* Font width returned */
    UINT fdiHeightActual;               /* Font height returned */
    BOOL bTT;                           /* Font is TT? */
    INT  Index;                         /* Index into listbox */
} FONTDIMENINFO, *LPFONTDIMENINFO, *LPFDI;

typedef FONTDIMENINFO *BPFDI;
typedef UINT    CFDI;
typedef UINT    IFDI;

// BILINGUAL stuff
#define CLIP_DFA_OVERRIDE   0x40    /* Disable Font Association */

extern  CFDI    cfdiCache[];            /* # used entries in fdi cache */
extern  CFDI    cfdiCacheActual[];      /* Total # entries in fdi cache */


/*
 * BPFDI_CANCEL must be 0xFFFF because that is what DialogBox returns on
 * failure.
 */
#define BPFDI_CANCEL    (BPFDI)(INT_PTR)(-1)
#define BPFDI_AUTO      (BPFDI)(INT_PTR)(-2)
#define BPFDI_IGNORE    (BPFDI)(INT_PTR)(-3)

#define IsSpecialBpfdi(bpfdi)       ((bpfdi) >= BPFDI_IGNORE)

/* This is the maximum size font we will create. */
#define MAX_FONT_HEIGHT     72          /* 72pt = 1inch */

typedef INT PENALTY;                    /* pnl */

/*
 *  Penalty structures
 *
 *  Do NOT change these structure definitions unless you know what you're
 *  doing, because the relative order of the values is crucial for proper
 *  reading and writing of the INI file in which they are stored.
 */

typedef struct tagPENALTYPAIR {         /* pnlp */
    PENALTY pnlInitial;
    PENALTY pnlScale;
} PENALTYPAIR, *PPENALTYPAIR;


typedef struct tagPENALTYLIST {         /* pnll */
    PENALTYPAIR pnlpOvershoot;
    PENALTYPAIR pnlpShortfall;
} PENALTYLIST, *PPENALTYLIST;


#define MINPENALTY      (-5000)
#define MAXPENALTY        5000
#define SENTINELPENALTY  MAXLONG      /* Must exceed any legitimate penalty */

#define NUMPENALTIES        (SIZEOF(rgpnlPenalties) / SIZEOF(INT))
#define NUMINITIALTTHEIGHTS (SIZEOF(rgwInitialTtHeights) / SIZEOF(WORD))

#define pnllX           ((PPENALTYLIST)rgpnlPenalties)[0]
#define pnllY           ((PPENALTYLIST)rgpnlPenalties)[1]
#define pnlTrueType     (rgpnlPenalties[8])

/*
 *  These values for FindFontMatch's third argument are magical.
 *  WindowInit uses the funky values (with the exception of FFM_PERFECT)
 */
#define FFM_BOTHFONTS   0x00000000
#define FFM_RESTRICTED  0x00000001
#define FFM_RASTERFONTS 0x00000001
#define FFM_TTFONTS     0x80000001

#define FFM_PERFECT     0xFFFFFFFF


/*
 *  Last but not least, per-dialog data (aka roll-your-own DLL instance data)
 */

typedef struct FNTINFO {        /* fi */
    PPROPLINK ppl;              // ppl must ALWAYS be the first field
    BPFDI     bpfdi;
    PROPFNT   fntProposed;      // The properties to use if the user selects OK
    PROPWIN   winOriginal;      // For window preview and auto font selection
    HFONT     hFontPreview;     // Used in font preview window
    BOOL      fMax;             // Should window preview show as maximized?
    POINT     ptCorner;         // Upper-left corner of window
    UINT      uDefaultCp;       // System default code page
} FNTINFO;
typedef FNTINFO *PFNTINFO;      /* pfi */


/*
 * for Font Enumlation
 */
typedef struct FNTENUMINFO {
    HWND      hwndList;
    BOOL      fListBox;
    INT       CodePage;
} FNTENUMINFO;
typedef FNTENUMINFO *LPFNTENUMINFO;

/*
 *  Internal function prototypes
 */

BOOL_PTR CALLBACK DlgFntProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
VOID InitFntDlg(HWND hDlg, PFNTINFO pfi);
VOID ApplyFntDlg(HWND hDlg, PFNTINFO pfi);

BOOL LoadGlobalFontData(void);
VOID FreeGlobalFontData(void);
BOOL LoadGlobalFontEditData(void);
VOID FreeGlobalFontEditData(void);
VOID CheckDisplayParameters(void);
HBITMAP LoadBitmaps(INT id);
DWORD GetFlippedSysColor(INT nDispElement);
VOID PreviewInit(HWND hDlg, PFNTINFO pfi);
VOID PreviewUpdate(HWND hwndList, PFNTINFO pfi);
LRESULT WndPreviewWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
VOID WndPreviewPaint(HWND hDlg, HWND hwnd);
LRESULT FontPreviewWndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

INT  WINAPI CreateFontList(HWND hwndList, BOOL fListBox, LPPROPFNT lpFnt);
VOID WINAPI DrawItemFontList(BOOL fListBox, const LPDRAWITEMSTRUCT lpdis);
INT  WINAPI GetItemFontInfo(HWND hwndFontList, BOOL fListBox, HANDLE hProps, LPPROPFNT lpFnt);
BOOL WINAPI MatchCurrentFont(HWND hwndList, BOOL fListBox, LPPROPFNT lpFnt);
LONG WINAPI MeasureItemFontList(LPMEASUREITEMSTRUCT lpmi);
VOID WINAPI UpdateTTBitmap(void);

BOOL AddRasterFontsToFontListA(HWND hwndList, BOOL fListBox,
                                                  LPCSTR lpszRasterFaceName, INT CodePage);
INT CALLBACK RasterFontEnum(ENUMLOGFONTA *lpelf,
                            NEWTEXTMETRICA *lpntm,
                            INT nFontType, LPARAM lParam);
BPFDI AddToFontListCache(HWND hwndList,
                         BOOL fListBox,
                         UINT uHeightReq,
                         UINT uWidthReq,
                         UINT uHeightActual,
                         UINT uWidthActual,
                         UINT uCodePage);
BOOL  AddTrueTypeFontsToFontListA(HWND hwndList, BOOL fListBox,
                                  LPSTR lpszTTFaceName, INT CodePage);
BPFDI AddOneNewTrueTypeFontToFontListA(HWND hwndList,
                                       BOOL fListBox,
                                       UINT uWidth, UINT uHeight,
                                       LPSTR lpszTTFaceName,
                                       INT CodePage);
DWORD_PTR GetFont(HWND hwndList, BOOL fListBox, PFNTINFO pfi);
void  SetFont(LPPROPFNT lpFnt, BPFDI bpfdi);

#define AspectScale(n1,n2,m) (UINT)(((UINT)n1*(UINT)m)/(UINT)n2)

VOID AspectPoint(LPRECT lprectPreview, LPPOINT lppt);
VOID AspectRect(LPRECT lprectPreview, LPRECT lprc);

HFONT CreateFontFromBpfdi(BPFDI bpfdi, PFNTINFO pfi);

void  FontSelInit(void);

BPFDI GetTrueTypeFontTrueDimensions(UINT dxWidth, UINT dyHeight, INT CodePage);
BPFDI FindFontMatch(UINT dxWidth, UINT dyHeight, LPINT lpfl, INT CodePage);
PENALTY ComputePenaltyFromPair(PPENALTYPAIR ppnlp, UINT dSmaller, UINT dLarger);
PENALTY ComputePenaltyFromList(PPENALTYLIST ppnll, UINT dActual, UINT dDesired);
PENALTY ComputePenalty(UINT cxCells,  UINT cyCells,
                       UINT dxClient, UINT dyClient,
                       UINT dxFont,   UINT dyFont);
BPFDI ChooseBestFont(UINT cxCells, UINT cyCells, UINT dxClient, UINT dyClient, INT fl, INT CodePage);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\pifinf.c ===
// Created 07-Jan-1993 11:20am by Jeff Parsons
 
#include "shellprv.h"
#pragma hdrstop
#include <setupapi.h>

const CHAR szIpOpen          []= "SetupOpenInfFileW";
const CHAR szIpFindFirstLine []= "SetupFindFirstLineW";
const CHAR szIpFindNextLine  []= "SetupFindNextLine";
const CHAR szIpGetStringField[]= "SetupGetStringFieldW";
const CHAR szIpGetIntField   []= "SetupGetIntField";
const CHAR szIpClose         []= "SetupCloseInfFile";
const TCHAR szOne             []= TEXT("1");

//
//  WARNING: Do not change the format of this structure (BPSTR followed by
//  FARPROC) unless you also plan on the changing the code below that fills
//  the structure in.  The sole purpose of this structure is and should
//  remain to obtain various exported procedure addresses from SETUPX.DLL!
//

typedef const CHAR *BPSTR;
struct {
    BPSTR   pszIpOpen;
    HINF   (WINAPI *lpIpOpen)(LPCTSTR pszFileSpec, LPCTSTR InfClass, DWORD InfStyle, UINT *ErrorLine);
    BPSTR   pszIpFindFirstLine;
    BOOL   (WINAPI *lpIpFindFirstLine)(HINF hInf, LPCTSTR lpszSect, LPCTSTR lpszKey, PINFCONTEXT Context);
    BPSTR   pszIpFindNextLine;
    BOOL   (WINAPI *lpIpFindNextLine)(PINFCONTEXT ContextIn, PINFCONTEXT ContextOut);
    BPSTR   pszIpGetStringField;
    BOOL   (WINAPI *lpIpGetStringField)(PINFCONTEXT Context, DWORD FieldIndex, LPTSTR ReturnBuffer, DWORD ReturnBufferSize, DWORD * RequiredSize);
    BPSTR   pszIpGetIntField;
    BOOL   (WINAPI *lpIpGetIntField)(PINFCONTEXT Context, DWORD FieldIndex, INT * IntegerValue);
    BPSTR   pszIpClose;
    VOID   (WINAPI *lpIpClose)(HINF hInf);
} sfnIp = {
    szIpOpen          ,NULL,
    szIpFindFirstLine ,NULL,
    szIpFindNextLine  ,NULL,
    szIpGetStringField,NULL,
    szIpGetIntField   ,NULL,
    szIpClose         ,NULL,
};
#define NUM_FUNCTIONS 6

static UINT g_SXUseCount = 0;
static HINSTANCE g_hSetupDLL = NULL;

const TCHAR szRegKeyMSDOSApps[] = REGSTR_PATH_NEWDOSBOX;

const TCHAR szParams[]          = KEY_PARAMS;
const TCHAR szBatchFile[]       = KEY_BATCHFILE;
const TCHAR szLowMem[]          = KEY_LOWMEM;
const TCHAR szEmsMem[]          = KEY_EMSMEM;
const TCHAR szXmsMem[]          = KEY_XMSMEM;
const TCHAR szDpmiMem[]         = KEY_DPMIMEM;
const TCHAR szEnable[]          = KEY_ENABLE;
const TCHAR szDisable[]         = KEY_DISABLE;

const TCHAR szWindowed[]        = KEYVAL_WINDOWED;
const TCHAR szBackground[]      = KEYVAL_BACKGROUND;
const TCHAR szExclusive[]       = KEYVAL_EXCLUSIVE;
const TCHAR szDetectIdle[]      = KEYVAL_DETECTIDLE;
const TCHAR szLowLocked[]       = KEYVAL_LOWLOCKED;
const TCHAR szEMSLocked[]       = KEYVAL_EMSLOCKED;
const TCHAR szXMSLocked[]       = KEYVAL_XMSLOCKED;
const TCHAR szUseHMA[]          = KEYVAL_USEHMA;
const TCHAR szEmulateROM[]      = KEYVAL_EMULATEROM;
const TCHAR szRetainVRAM[]      = KEYVAL_RETAINVRAM;
const TCHAR szFastPaste[]       = KEYVAL_FASTPASTE;
const TCHAR szALTTAB[]          = KEYVAL_ALTTAB;
const TCHAR szALTESC[]          = KEYVAL_ALTESC;
const TCHAR szCTRLESC[]         = KEYVAL_CTRLESC;
const TCHAR szPRTSCRN[]         = KEYVAL_PRTSCRN;
const TCHAR szALTPRTSCRN[]      = KEYVAL_ALTPRTSCRN;
const TCHAR szALTSPACE[]        = KEYVAL_ALTSPACE;
const TCHAR szALTENTER[]        = KEYVAL_ALTENTER;
const TCHAR szWinLie[]          = KEYVAL_WINLIE;
const TCHAR szGlobalMem[]       = KEYVAL_GLOBALMEM;
const TCHAR szRealMode[]        = KEYVAL_REALMODE;
const TCHAR szMouse[]           = KEYVAL_MOUSE;
const TCHAR szEMS[]             = KEYVAL_EMS;
const TCHAR szCDROM[]           = KEYVAL_CDROM;
const TCHAR szNetwork[]         = KEYVAL_NETWORK;
const TCHAR szDiskLock[]        = KEYVAL_DISKLOCK;
const TCHAR szPrivateCFG[]      = KEYVAL_PRIVATECFG;
const TCHAR szCloseOnExit[]     = KEYVAL_CLOSEONEXIT;
const TCHAR szAllowSSaver[]     = KEYVAL_ALLOWSSAVER;
const TCHAR szUniqueSettings[]  = KEYVAL_UNIQUESETTINGS;

const LPCTSTR apszKey[] = {
    szParams,
    szBatchFile,
    szLowMem,
    szEmsMem,
    szXmsMem,
    szDpmiMem,
    szEnable,
    szDisable,
};

const LPCTSTR apszKeyVal[] = {
    szWindowed,         // abKeyValIDBits[0]
    szBackground,       // abKeyValIDBits[1]
    szExclusive,        // abKeyValIDBits[2]
    szDetectIdle,       // abKeyValIDBits[3]
    szLowLocked,        // abKeyValIDBits[4]
    szEMSLocked,        // abKeyValIDBits[5]
    szXMSLocked,        // abKeyValIDBits[6]
    szUseHMA,           // abKeyValIDBits[7]
    szEmulateROM,       // abKeyValIDBits[8]
    szRetainVRAM,       // abKeyValIDBits[9]
    szFastPaste,        // abKeyValIDBits[10]
    szALTTAB,           // abKeyValIDBits[11]
    szALTESC,           // abKeyValIDBits[12]
    szCTRLESC,          // abKeyValIDBits[13]
    szPRTSCRN,          // abKeyValIDBits[14]
    szALTPRTSCRN,       // abKeyValIDBits[15]
    szALTSPACE,         // abKeyValIDBits[16]
    szALTENTER,         // abKeyValIDBits[17]
    szWinLie,           // abKeyValIDBits[18]
    szGlobalMem,        // abKeyValIDBits[19]
    szRealMode,         // abKeyValIDBits[20]
    szMouse,            // abRMKeyValIDBits[0]
    szEMS,              // abRMKeyValIDBits[1]
    szCDROM,            // abRMKeyValIDBits[2]
    szNetwork,          // abRMKeyValIDBits[3]
    szDiskLock,         // abRMKeyValIDBits[4]
    szPrivateCFG,       // abRMKeyValIDBits[5]
    szCloseOnExit,      // special case 0 (see "special case 0" below)
    szAllowSSaver,      // special case 1 (see "special case 1" below)
    szUniqueSettings,   // Never transferred to PIF - Used to populate registry
};

//  Array of bit numbers that must be kept in sync with KEYVALIDs
//
//  0x80 means bit must be inverted
//  0x40 means bit must be set in PfW386Flags2 instead of PfW386Flags

const BYTE abKeyValIDBits[] = {
    BITNUM(fFullScreen)     | 0x80,
    BITNUM(fBackground),
    BITNUM(fExclusive),
    BITNUM(fPollingDetect),
    BITNUM(fVMLocked),
    BITNUM(fEMSLocked),
    BITNUM(fXMSLocked),
    BITNUM(fNoHMA)          | 0x80,
    BITNUM(fVidTxtEmulate)  | 0x40,
    BITNUM(fVidRetainAllo)  | 0x40,
    BITNUM(fINT16Paste),
    BITNUM(fALTTABdis)      | 0x80,
    BITNUM(fALTESCdis)      | 0x80,
    BITNUM(fCTRLESCdis)     | 0x80,
    BITNUM(fPRTSCdis)       | 0x80,
    BITNUM(fALTPRTSCdis)    | 0x80,
    BITNUM(fALTSPACEdis)    | 0x80,
    BITNUM(fALTENTERdis)    | 0x80,
    BITNUM(fWinLie),
    BITNUM(fGlobalProtect),
    BITNUM(fRealMode),
};

const BYTE abRMKeyValIDBits[] = {
    BITNUM(RMOPT_MOUSE),
    BITNUM(RMOPT_EMS),
    BITNUM(RMOPT_CDROM),
    BITNUM(RMOPT_NETWORK),
    BITNUM(RMOPT_DISKLOCK),
    BITNUM(RMOPT_PRIVATECFG),
    BITNUM(RMOPT_VESA),
};
//  FEATURE: other bits to be supported (maybe):
//      WIN_TOOLBAR,
//      WIN_SAVESETTINGS,
//      MSE_WINDOWENABLE | 0x80,
//      MSE_EXCLUSIVE,
//      TSK_NOWARNTERMINATE | 0x80,


//
//  Load setupx.dll and get proc address for all entry points in table
//
BOOL InitSetupxDll(void)
{
    BOOL    fSuccess = TRUE;    // Assume it works
    if (g_SXUseCount == 0) {
        //
        // Dynamically load SETUPX.DLL
        //
        UINT uOldMode = SetErrorMode(SEM_NOOPENFILEERRORBOX);
        g_hSetupDLL = LoadLibrary(TEXT("SETUPAPI.DLL"));
        SetErrorMode(uOldMode);
        fSuccess = (g_hSetupDLL != NULL);

        if (fSuccess)
        {
            int i;
            BPSTR *ppsz;
            FARPROC *plpfn;

            ppsz = (BPSTR *)&sfnIp;

            for (i=0; i<NUM_FUNCTIONS; i++)
            {
                plpfn = (FARPROC *)(ppsz+1);
                *plpfn = GetProcAddress(g_hSetupDLL, *ppsz);
                if (*plpfn == NULL)
                {
                    FreeLibrary(g_hSetupDLL);
                    g_hSetupDLL = NULL;
                    fSuccess = FALSE;
                    break;
                }
                ppsz = (BPSTR *)(plpfn+1);
            }
        }
    }
    if (fSuccess) {
        g_SXUseCount++;
    }
    return(fSuccess);
}

//
//  When the last user of setupx.dll calls this function, the library is freed.
//
void FreeSetupxDll(void)
{
    g_SXUseCount--;
    if (g_SXUseCount == 0) {
        FreeLibrary(g_hSetupDLL);
        g_hSetupDLL = NULL;
    }
}


void InitWorkDir(PPROPLINK ppl, LPPROPPRG lpPrg, LPPROPNT40 lpnt40)
{
    int i;

    if (lpnt40)
    {
        lstrcpyn((LPTSTR)lpnt40->awchWorkDir,
                 ppl->szPathName,
                 min(ARRAYSIZE(lpnt40->awchWorkDir),ppl->iFileName+1));

        // Working directories like C:\ are ok, but C:\FOO\ are not,
        // so remove trailing '\' in that case

        i = lstrlen((LPTSTR)lpnt40->awchWorkDir)-1;
        if (i > 2 && lpnt40->awchWorkDir[i] == TEXT('\\'))
            lpnt40->awchWorkDir[i] = TEXT('\0');

        WideCharToMultiByte( CP_ACP, 0, (LPWSTR)lpnt40->awchWorkDir, -1, lpPrg->achWorkDir, ARRAYSIZE(lpPrg->achWorkDir), NULL, NULL );
    }
    else
    {
        WideCharToMultiByte( CP_ACP, 0,
                             ppl->szPathName,
                             min(ARRAYSIZE(lpPrg->achWorkDir),ppl->iFileName+1),
                             (LPSTR)lpPrg->achWorkDir,
                             ARRAYSIZE(lpPrg->achWorkDir),
                             NULL,
                             NULL
                            );

        // Working directories like C:\ are ok, but C:\FOO\ are not,
        // so remove trailing '\' in that case

        i = lstrlenA(lpPrg->achWorkDir)-1;
        if (i > 2 && lpPrg->achWorkDir[i] == '\\')
            lpPrg->achWorkDir[i] = '\0';
    }
}


BOOL FAR GetAppsInfData(PPROPLINK ppl, LPPROPPRG lpPrg, LPPROPNT40 lpnt40, HINF hInf, LPCTSTR lpszApp, BOOL fNotAmbiguous, int flOpt)
{
    HINF hinfApps;
    int id, i;
    TCHAR szTmp[MAX_PATH];
    TCHAR szPIFSection[MAX_KEY_SIZE];
    BOOL fSuccess = FALSE;
    INFCONTEXT InfContext;
    DWORD dwSize;
    FunctionName(GetAppsInfData);

    //
    // Although not strictly part of INF processing, it's most
    // convenient here to search for any ICO file that might exist
    // in the same directory as the app, and select it for our default icon.
    //
    lstrcpyn(szTmp, ppl->szPathName, ppl->iFileExt+1);
    lstrcpy(szTmp + ppl->iFileExt, TEXT(".ICO"));
    if ((int)GetFileAttributes(szTmp) != -1) {
        lstrcpyn((LPTSTR)lpnt40->awchIconFile, szTmp, ARRAYSIZE(lpnt40->awchIconFile));
        WideCharToMultiByte( CP_ACP, 0, (LPWSTR)lpnt40->awchIconFile, -1, lpPrg->achIconFile, ARRAYSIZE(lpPrg->achIconFile), NULL, NULL );
        lpPrg->wIconIndex = 0;
        PifMgr_SetProperties(ppl, MAKELP(0,GROUP_PRG),
                        lpPrg, SIZEOF(*lpPrg), SETPROPS_CACHE);
        PifMgr_SetProperties(ppl, MAKELP(0,GROUP_NT40),
                        lpnt40, SIZEOF(*lpnt40), SETPROPS_CACHE);
    }

    //
    // Dynamically load SETUPX.DLL
    //
    if (!InitSetupxDll())
        goto DllLoadFalied;

    if (hInf)
        hinfApps = hInf;
    else
        hinfApps = (*sfnIp.lpIpOpen)(LoadStringSafe(NULL,
                                                IDS_APPSINF,
                                                szTmp,
                                                ARRAYSIZE(szTmp)),
                                     0, INF_STYLE_WIN4, NULL );

    if (hinfApps==INVALID_HANDLE_VALUE) {
        id = IDS_CANTOPENAPPSINF;
        if (GetLastError()==ERROR_FILE_NOT_FOUND)
            id = IDS_NOAPPSINF;
        Warning((HWND)ppl, (WORD)id, MB_ICONEXCLAMATION | MB_OK | MB_NOFOCUS);
        goto CloseDLL;
    }

    // OK, now we have APPS.INF open, so let's bounce around the [pif95]
    // section and try to find the app of interest.

    if (!(*sfnIp.lpIpFindFirstLine)(hinfApps, TEXT("pif95"), NULL, &InfContext)) {
        Warning((HWND)ppl, IDS_APPSINFERROR, MB_ICONEXCLAMATION | MB_OK | MB_NOFOCUS);
        goto CloseInf;
    }

    // OK, we've found the [pif95] section, so let's go to it

    do {


        if (!(*sfnIp.lpIpGetStringField)(&InfContext, APPSINF_FILENAME, szTmp, ARRAYSIZE(szTmp), &dwSize))
            continue;

        // We need to read the rest of the fields now, before we do any
        // more processing, because otherwise we lose our place in the file

        if (lstrcmpi(szTmp, ppl->szPathName+ppl->iFileName) == 0) {

            // See if Other File was specified, and then make sure it
            // exists.  If it doesn't, then we need to continue the search.

            // Initialize szTmp with only the path portion of the app's
            // fully-qualified name.  Giving lstrcpyn a length of iFileName+1
            // insures that szTmp[ppl->iFileName] will be NULL.

            lstrcpyn(szTmp, ppl->szPathName, ppl->iFileName+1);

            (*sfnIp.lpIpGetStringField)(&InfContext, APPSINF_OTHERFILE,
                        &szTmp[ppl->iFileName], ARRAYSIZE(lpPrg->achOtherFile), &dwSize);

            // If szTmp[ppl->iFileName] is no longer NULL, then
            // GetStringField filled it in.  See if the file exists.

            if (szTmp[ppl->iFileName]) {
                if ((int)GetFileAttributes(szTmp) == -1)
                    continue;       // Other File didn't exist, continue search
            }

            // If the PIF data we have is ambiguous, and it has already
            // been initialized with data from this APPS.INF entry, then just
            // leave the PIF data alone and LEAVE.

            if (lpPrg->flPrgInit & PRGINIT_AMBIGUOUSPIF) {

                if (lstrcmpi((LPWSTR)lpnt40->awchOtherFile, szTmp+ppl->iFileName) == 0) {

                    if (!szTmp[ppl->iFileName]) {

                        // The comparison was inconclusive;  both filenames
                        // are blank.  See if the filename contained in
                        // lpPrg->achCmdLine matches lpszApp;  if not, again
                        // we should fail the search.
                        //
                        // It's ok to whack lpPrg->achCmdLine with a null;
                        // OpenProperties (our only caller) doesn't depend on
                        // that data in lpPrg.

                        lpnt40->awchCmdLine[lstrskipfnameA(lpPrg->achCmdLine)] = L'\0';

                        if (lstrcmpi((LPWSTR)lpnt40->awchCmdLine, lpszApp) != 0)


                            goto CloseInf;  // unsuccessful search
                    }
                    fSuccess++;             // successful search
                }

                // Otherwise, this APPS.INF entry isn't a match, implying
                // some of the PIF's settings don't really apply.  We need
                // to fail this search, get back to OpenProperties, look ONLY
                // for _DEFAULT.PIF, and let it try to call GetAppsInfData
                // one more time.

                goto CloseInf;
            }

            // Otherwise, update Other File.  THIS is the APPS.INF entry
            // we're going to use!

            lstrcpyn((LPWSTR)lpnt40->awchOtherFile, szTmp + ppl->iFileName, ARRAYSIZE(lpnt40->awchOtherFile));
            WideCharToMultiByte( CP_ACP, 0, (LPWSTR)lpnt40->awchOtherFile, -1, lpPrg->achOtherFile, ARRAYSIZE( lpPrg->achOtherFile ), NULL, NULL );

            (*sfnIp.lpIpGetStringField)(&InfContext, APPSINF_TITLE, (LPWSTR)lpnt40->awchTitle, ARRAYSIZE(lpnt40->awchTitle), &dwSize);
            WideCharToMultiByte( CP_ACP, 0, (LPWSTR)lpnt40->awchTitle, -1, lpPrg->achTitle, ARRAYSIZE( lpPrg->achTitle ), NULL, NULL );

            lstrcpyn((LPWSTR)lpnt40->awchCmdLine, lpszApp, ARRAYSIZE(lpnt40->awchCmdLine));
            WideCharToMultiByte( CP_ACP, 0, (LPWSTR)lpnt40->awchCmdLine, -1, lpPrg->achCmdLine, ARRAYSIZE( lpPrg->achCmdLine ), NULL, NULL );

            i = 0;
            (*sfnIp.lpIpGetIntField)(&InfContext, APPSINF_NOWORKDIR, &i);

            // Only set the working directory if "NoWorkDir" in the INF
            // is FALSE and no working directory was supplied by the caller.

            if (i == 0 && !lpnt40->awchWorkDir[0]) {
                // No hard-coded working directory, so let's provide one

                InitWorkDir(ppl, lpPrg, lpnt40);
            }

            szTmp[0] = 0;
            sfnIp.lpIpGetStringField(&InfContext, APPSINF_ICONFILE, szTmp, ARRAYSIZE(szTmp), &dwSize);

            if (!szTmp[0])
                lstrcpy(szTmp, TEXT("SHELL32.DLL"));

            i = 0;
            sfnIp.lpIpGetIntField(&InfContext, APPSINF_ICONINDEX, &i);

            // Update the icon info now, if it's valid

            if (i != 0) {
                lstrcpy((LPWSTR)lpnt40->awchIconFile, szTmp);
                WideCharToMultiByte( CP_ACP, 0, (LPWSTR)lpnt40->awchIconFile, -1, lpPrg->achIconFile, ARRAYSIZE( lpPrg->achIconFile ), NULL, NULL );
                lpPrg->wIconIndex = (WORD) i;
            }

            (*sfnIp.lpIpGetStringField)(&InfContext, APPSINF_SECTIONID,
                        szPIFSection, ARRAYSIZE(szPIFSection), &dwSize);

            szTmp[0] = TEXT('\0');
            (*sfnIp.lpIpGetStringField)(&InfContext, APPSINF_NOPIF,
                        szTmp, ARRAYSIZE(szTmp), &dwSize);

            // This code used to set INHBITPIF if the app was NOT on a
            // fixed disk, knowing that we would otherwise try to create
            // a PIF in the PIF directory instead of the app's directory;
            // in other words, NOPIF really meant "no PIF in the PIF
            // directory please, because this app is ambiguously named".

            // Now, we want to always allow PIF creation, so the user
            // always has a place to save properties for an app.  But we
            // also need to propagate the old NOPIF flag to AMBIGUOUSPIF,
            // so that we'll always check to see if the PIF should be
            // regenerated (based on the presence of a NEW Other File).

            lpPrg->flPrgInit &= ~PRGINIT_AMBIGUOUSPIF;
            if (!fNotAmbiguous && szTmp[0] == TEXT('1'))
                lpPrg->flPrgInit |= PRGINIT_AMBIGUOUSPIF;

            if (flOpt & OPENPROPS_FORCEREALMODE)
                lpPrg->flPrgInit |= PRGINIT_REALMODE;

            // Time to dirty those properties!

            PifMgr_SetProperties(ppl, MAKELP(0,GROUP_PRG),
                            lpPrg, SIZEOF(*lpPrg), SETPROPS_CACHE);
            PifMgr_SetProperties(ppl, MAKELP(0,GROUP_NT40),
                            lpnt40, SIZEOF(*lpnt40), SETPROPS_CACHE);

            GetAppsInfSectionData(&InfContext, APPSINF_DEFAULT_SECTION, ppl);

            if (*szPIFSection)
                GetAppsInfSectionData(&InfContext, szPIFSection, ppl);

            // Make a note that we found INF settings (appwiz cares)

            ppl->flProp |= PROP_INFSETTINGS;

            // GetAppsInfSectionData affects program props, so get fresh copy

            PifMgr_GetProperties(ppl, MAKELP(0,GROUP_PRG),
                            lpPrg, SIZEOF(*lpPrg), GETPROPS_NONE);

            // Now call appwiz in "silent configuration mode", to create the
            // per-app config and autoexec images, if app runs in real mode;
            // BUT don't do this if the caller (NOT the INF) specified no PIF,
            // to avoid unwanted dialog boxes popping up from appwiz.  Yes, I'm
            // telling appwiz to be quiet, but sometimes he just can't contain
            // himself (ie, silent configuration may not be possible given the
            // the real-mode configuration required).

            if (!(ppl->flProp & PROP_INHIBITPIF)) {
                if (lpPrg->flPrgInit & PRGINIT_REALMODE)
                    AppWizard(NULL, ppl, WIZACTION_SILENTCONFIGPROP);
            }
            FlushPIFData(ppl, FALSE);

            fSuccess++;             // successful search
            goto CloseInf;
        }

    } while ((*sfnIp.lpIpFindNextLine)(&InfContext, &InfContext));

  CloseInf:
    if (!hInf)
        (*sfnIp.lpIpClose)(hinfApps);

  CloseDLL:
    FreeSetupxDll();

  DllLoadFalied:
    return fSuccess;
}


void GetAppsInfSectionData(PINFCONTEXT pInfContext, LPCTSTR lpszSection, PPROPLINK ppl)
{
    int i, j, idKey;
    LPSTDPIF lpstd;
    LPW386PIF30 lp386;
    LPWENHPIF40 lpenh;
    TCHAR szVal[MAX_KEYVAL_SIZE];
    TCHAR szVal2[MAX_KEYVAL_SIZE];
    FunctionName(GetAppsInfSectionData);

    if (!(*sfnIp.lpIpFindFirstLine)(pInfContext, lpszSection, NULL, NULL))
        return;

    ppl->cLocks++;

    lpstd = (LPSTDPIF)ppl->lpPIFData;

    // lp386 may or may not exist, but we'll create if not

    lp386 = GetGroupData(ppl, szW386HDRSIG30, NULL, NULL);
    if (!lp386) {
        if (AddGroupData(ppl, szW386HDRSIG30, NULL, SIZEOF(W386PIF30))) {
            lp386 = GetGroupData(ppl, szW386HDRSIG30, NULL, NULL);
            if (!lp386)
                goto UnlockPIF;
        }
    }

    // lpenh may or may not exist, but we'll create if not

    lpenh = GetGroupData(ppl, szWENHHDRSIG40, NULL, NULL);
    if (!lpenh) {
        if (AddGroupData(ppl, szWENHHDRSIG40, NULL, SIZEOF(WENHPIF40))) {
            lpenh = GetGroupData(ppl, szWENHHDRSIG40, NULL, NULL);
            if (!lpenh)
                goto UnlockPIF;
        }
    }

    do {
        BYTE bInvert;
        DWORD dwSize;

        idKey = GetKeyID(pInfContext);

        if (!(*sfnIp.lpIpGetStringField)(pInfContext, APPSINF_KEYVAL, szVal, ARRAYSIZE(szVal), &dwSize))
            continue;

        szVal2[0] = TEXT('\0');
        if (idKey >= KEYID_LOWMEM && idKey <= KEYID_DPMIMEM)
            (*sfnIp.lpIpGetStringField)(pInfContext, APPSINF_KEYVAL2, szVal2, ARRAYSIZE(szVal2), &dwSize);

        bInvert = 0;

        switch (idKey)
        {
        case KEYID_UNKNOWN:
            ASSERTFAIL();
            break;

        case KEYID_NONE:
            break;

        case KEYID_PARAMS:
            {
            WCHAR szTmp[ ARRAYSIZE(lp386->PfW386params) ];

            MultiByteToWideChar( CP_ACP, 0, (LPSTR)lp386->PfW386params, -1, szTmp, ARRAYSIZE(szTmp) );
            (*sfnIp.lpIpGetStringField)(pInfContext, APPSINF_KEYVAL, szTmp, SIZEOF(lp386->PfW386params), &dwSize);
            }

            break;

        case KEYID_BATCHFILE:
            break;

        case KEYID_LOWMEM:
            if (!lstrcmpi(szVal, g_szAuto))
                lp386->PfW386minmem = 0xFFFF;
            else
                lp386->PfW386minmem = (WORD) StrToInt(szVal);

            if (!szVal2[0])
                lp386->PfW386maxmem = 0xFFFF;
            else
                lp386->PfW386maxmem = (WORD) StrToInt(szVal2);
            break;

        case KEYID_EMSMEM:
            if (!lstrcmpi(szVal, g_szNone)) {
                lp386->PfMaxEMMK = lp386->PfMinEMMK = 0;
            }
            if (!lstrcmpi(szVal, g_szAuto)) {
                lp386->PfMinEMMK = 0;
                lp386->PfMaxEMMK = 0xFFFF;
            }
            else
                lp386->PfMaxEMMK = lp386->PfMinEMMK = (WORD) StrToInt(szVal);

            if (szVal2[0])
                lp386->PfMaxEMMK = (WORD) StrToInt(szVal2);
            break;

        case KEYID_XMSMEM:
            if (!lstrcmpi(szVal, g_szNone)) {
                lp386->PfMaxXmsK = lp386->PfMinXmsK = 0;
            }
            if (!lstrcmpi(szVal, g_szAuto)) {
                lp386->PfMinXmsK = 0;
                lp386->PfMaxXmsK = 0xFFFF;
            }
            else
                lp386->PfMaxXmsK = lp386->PfMinXmsK = (WORD) StrToInt(szVal);

            if (szVal2[0])
                lp386->PfMaxXmsK = (WORD) StrToInt(szVal2);
            break;

        case KEYID_DPMIMEM:
            if (!lstrcmpi(szVal, g_szAuto))
                lpenh->envProp.wMaxDPMI = 0;
            else
                lpenh->envProp.wMaxDPMI = (WORD) StrToInt(szVal);
            break;

        case KEYID_DISABLE:
            bInvert = 0x80;
            // fall into KEYID_ENABLE...

        case KEYID_ENABLE:
            for (i=1; 0 != (j = GetKeyValID(pInfContext, i)); i++)
            {
                int s;
                BYTE b;

                if (j == KEYVAL_ID_UNKNOWN) {
                    ASSERTFAIL();
                    continue;
                }

                if (j == KEYVAL_ID_UNIQUESETTINGS) {
                    continue;
                }

                j--;

                if (j < ARRAYSIZE(abKeyValIDBits)) {

                    b = abKeyValIDBits[j];

                    s = b & 0x3F;
                    b ^= bInvert;
                    if (!(b & 0x80)) {
                        if (!(b & 0x40)) {
                            lp386->PfW386Flags |= 1L << s;
                        }
                        else
                            lp386->PfW386Flags2 |= 1L << s;
                    }
                    else {
                        if (!(b & 0x40))
                            lp386->PfW386Flags &= ~(1L << s);
                        else
                            lp386->PfW386Flags2 &= ~(1L << s);
                    }
                }
                else {
                    j -= ARRAYSIZE(abKeyValIDBits);

                    if (j < ARRAYSIZE(abRMKeyValIDBits)) {

                        b = abRMKeyValIDBits[j];

                        s = b & 0x3F;
                        b ^= bInvert;

                        if (!(b & 0x80))
                            lpenh->dwRealModeFlagsProp |= 1L << s;
                        else
                            lpenh->dwRealModeFlagsProp &= ~(1L << s);
                    }
                    else {
                        j -= ARRAYSIZE(abRMKeyValIDBits);

                        switch(j) {
                        case 0:         // special case 0
                            if (!bInvert)
                                lpstd->MSflags |= EXITMASK;
                            else
                                lpstd->MSflags &= ~EXITMASK;
                            break;

                        case 1:         // special case 1
                            if (bInvert)
                                lpenh->tskProp.flTsk |= TSK_NOSCREENSAVER;
                            else
                                lpenh->tskProp.flTsk &= ~TSK_NOSCREENSAVER;
                            break;

                        default:
                            ASSERTFAIL();
                            break;
                        }
                    }
                }
            }
            break;
        }
    } while ((*sfnIp.lpIpFindNextLine)(pInfContext, pInfContext));

  UnlockPIF:
    ppl->cLocks--;

}


int GetKeyID(PINFCONTEXT pInfContext)
{
    int i;
    TCHAR szCurKey[MAX_KEY_SIZE];
    DWORD dwSize;
    FunctionName(GetKeyID);

    if ((*sfnIp.lpIpGetStringField)(pInfContext, APPSINF_KEY, szCurKey, ARRAYSIZE(szCurKey), &dwSize)) {
        for (i=0; i<ARRAYSIZE(apszKey); i++) {
            if (!lstrcmpi(szCurKey, apszKey[i]))
                return i+1;
        }
        return KEYID_UNKNOWN;
    }
    return KEYID_NONE;
}


int GetKeyValID(PINFCONTEXT pInfContext, int i)
{
    TCHAR szCurKeyVal[MAX_KEYVAL_SIZE];
    DWORD dwSize;
    FunctionName(GetKeyValID);

    if ((*sfnIp.lpIpGetStringField)(pInfContext, i, szCurKeyVal, ARRAYSIZE(szCurKeyVal), &dwSize)) {
        for (i=0; i<ARRAYSIZE(apszKeyVal); i++) {
            if (!lstrcmpi(szCurKeyVal, apszKeyVal[i]))
                return i+1;
        }
        return KEYVAL_ID_UNKNOWN;
    }
    return KEYVAL_ID_NONE;
}

DWORD GetSettingsFlags(PINFCONTEXT pInfContext, LPCTSTR lpszSection)
{
    return(0);
}

BOOL Initialize1AppReg(HWND hwndParent)
{
    BOOL    fSuccess = FALSE;  // Assume failure
    TCHAR   szTmp[MAX_PATH];
    HINF    hinfApps;
    HKEY    hk1App;
    INFCONTEXT InfContext;

    if (!InitSetupxDll()) {
        goto DllLoadFailed;
    }


    hinfApps = (*sfnIp.lpIpOpen)(LoadStringSafe(NULL,
                                            IDS_APPSINF,
                                            szTmp,
                                            ARRAYSIZE(szTmp)),
                               0, INF_STYLE_WIN4, NULL );

    if (hinfApps==INVALID_HANDLE_VALUE) {
        int id = IDS_CANTOPENAPPSINF;
        if (GetLastError()==ERROR_FILE_NOT_FOUND)
            id = IDS_NOAPPSINF;
        Warning(hwndParent, (WORD)id, MB_ICONEXCLAMATION | MB_OK | MB_NOFOCUS);
        goto CloseDLL;
    }

    // OK, now we have APPS.INF open, so let's find [PIF95]

    if (!(*sfnIp.lpIpFindFirstLine)(hinfApps, TEXT("pif95"), NULL, &InfContext)) {
        Warning(hwndParent, IDS_APPSINFERROR, MB_ICONEXCLAMATION | MB_OK | MB_NOFOCUS);
        goto CloseInf;
    }

    // OK, we've found the [pif95] section, so now we'll create the reg branch

    //
    //  Always start with a clean slate!
    //
    RegDeleteKey(HKEY_LOCAL_MACHINE, szRegKeyMSDOSApps);

    if (RegCreateKey(HKEY_LOCAL_MACHINE, szRegKeyMSDOSApps, &hk1App) !=
        ERROR_SUCCESS) {
        goto CloseInf;
    }

    do {
        DWORD   dwSettings;
        DWORD   dwSize;
        TCHAR   szSectionName[MAX_KEY_SIZE];
        if (!(*sfnIp.lpIpGetStringField)(&InfContext, APPSINF_FILENAME,
                        szTmp, ARRAYSIZE(szTmp), &dwSize)) {
            continue;
        }
        (*sfnIp.lpIpGetStringField)(&InfContext, APPSINF_SECTIONID,
                    szSectionName, ARRAYSIZE(szSectionName), &dwSize);
        dwSettings = GetSettingsFlags(&InfContext, szSectionName);
        if (dwSettings) {
            HKEY hkThisApp;
            if (RegCreateKey(hk1App, szTmp, &hkThisApp) == ERROR_SUCCESS) {
                (*sfnIp.lpIpGetStringField)(&InfContext, APPSINF_OTHERFILE,
                            szTmp, ARRAYSIZE(szTmp), &dwSize);
                if (szTmp[0] == 0) {
                    (*sfnIp.lpIpGetStringField)(&InfContext, APPSINF_FILENAME,
                                    szTmp, ARRAYSIZE(szTmp), &dwSize);
                }
                RegSetValueEx(hkThisApp, szTmp, 0, REG_BINARY, (LPSTR)&dwSettings, sizeof(dwSettings));
                RegCloseKey(hkThisApp);
            }
        }
    } while ((*sfnIp.lpIpFindNextLine)(&InfContext, &InfContext));
    fSuccess = TRUE;

    RegCloseKey(hk1App);
CloseInf:
    (*sfnIp.lpIpClose)(hinfApps);
CloseDLL:
    FreeSetupxDll();
DllLoadFailed:
    return(fSuccess);
}

//
//  A RUNDLL entry point that is called at boot time to initialize the registry.
//
void WINAPI InitPIFRegEntries(HWND hwnd, HINSTANCE hAppInstance, LPSTR lpszCmdLine, int nCmdShow)
{
    Initialize1AppReg(hwnd);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\pifinfp.h ===
/*
 *  Microsoft Confidential
 *  Copyright (C) Microsoft Corporation 1992,1993
 *  All Rights Reserved.
 *
 *
 *  PIFINFP.H
 *  Private PIFMGR include file
 *
 *  History:
 *  Created 22-Mar-1993 2:58pm by Jeff Parsons
 */


/*
 *  APPS.INF [pif95] section fields
 */
#define APPSINF_FILENAME        0       //
#define APPSINF_TITLE           1       //
#define APPSINF_ICONFILE        2       // default is APPSINF_DEFAULT_ICONFILE
#define APPSINF_ICONINDEX       3       //
#define APPSINF_NOWORKDIR       4       //
#define APPSINF_SECTIONID       5       //
#define APPSINF_OTHERFILE       6       //
#define APPSINF_NOPIF           7       //

#define APPSINF_DEFAULT_SECTION  TEXT("default")


/*
 *  APPS.INF section key IDs
 */
#define APPSINF_KEY             0       // field number

#define KEY_PARAMS              TEXT("params")
#define KEY_BATCHFILE           TEXT("batchfile")
#define KEY_LOWMEM              TEXT("lowmem")
#define KEY_EMSMEM              TEXT("emsmem")
#define KEY_XMSMEM              TEXT("xmsmem")
#define KEY_DPMIMEM             TEXT("dpmimem")
#define KEY_ENABLE              TEXT("enable")
#define KEY_DISABLE             TEXT("disable")

#define MAX_KEY_SIZE            16

#define KEYID_UNKNOWN           -1
#define KEYID_NONE              0
#define KEYID_PARAMS            1
#define KEYID_BATCHFILE         2
#define KEYID_LOWMEM            3
#define KEYID_EMSMEM            4
#define KEYID_XMSMEM            5
#define KEYID_DPMIMEM           6
#define KEYID_ENABLE            7
#define KEYID_DISABLE           8


/*
 *  APPS.INF string switches used to set PIF options
 */
#define APPSINF_KEYVAL          1       // field number
#define APPSINF_KEYVAL2         2       // field number

#define KEYVAL_WINDOWED         TEXT("win")   // (formerly DISPUSAGE)
#define KEYVAL_BACKGROUND       TEXT("bgd")   // (formerly EXECFLAGS)
#define KEYVAL_EXCLUSIVE        TEXT("exc")   // (formerly EXECFLAGS)
#define KEYVAL_DETECTIDLE       TEXT("dit")   // (formerly PROCMEMFLAGS)
#define KEYVAL_LOWLOCKED        TEXT("lml")   // (formerly PROCMEMFLAGS:lam)
#define KEYVAL_EMSLOCKED        TEXT("eml")   // (formerly PROCMEMFLAGS)
#define KEYVAL_XMSLOCKED        TEXT("xml")   // (formerly PROCMEMFLAGS)
#define KEYVAL_USEHMA           TEXT("hma")   // (formerly PROCMEMFLAGS)
#define KEYVAL_EMULATEROM       TEXT("emt")   // (formerly DISPFLAGS)
#define KEYVAL_RETAINVRAM       TEXT("rvm")   // (formerly DISPFLAGS)
#define KEYVAL_FASTPASTE        TEXT("afp")   // (formerly OTHEROPTIONS)
#define KEYVAL_ALTTAB           TEXT("ata")   // (formerly OTHEROPTIONS)
#define KEYVAL_ALTESC           TEXT("aes")   // (formerly OTHEROPTIONS)
#define KEYVAL_CTRLESC          TEXT("ces")   // (formerly OTHEROPTIONS)
#define KEYVAL_PRTSCRN          TEXT("psc")   // (formerly OTHEROPTIONS)
#define KEYVAL_ALTPRTSCRN       TEXT("aps")   // (formerly OTHEROPTIONS)
#define KEYVAL_ALTSPACE         TEXT("asp")   // (formerly OTHEROPTIONS)
#define KEYVAL_ALTENTER         TEXT("aen")   // (formerly OTHEROPTIONS)
#define KEYVAL_WINLIE           TEXT("lie")   // (NEW)
#define KEYVAL_GLOBALMEM        TEXT("gmp")   // (NEW)
#define KEYVAL_REALMODE         TEXT("dos")   // (NEW)
#define KEYVAL_MOUSE            TEXT("mse")   // (NEW)
#define KEYVAL_EMS              TEXT("ems")   // (NEW)
#define KEYVAL_CDROM            TEXT("cdr")   // (NEW)
#define KEYVAL_NETWORK          TEXT("net")   // (NEW)
#define KEYVAL_DISKLOCK         TEXT("dsk")   // (NEW)
#define KEYVAL_PRIVATECFG       TEXT("cfg")   // (NEW)
#define KEYVAL_CLOSEONEXIT      TEXT("cwe")   // (NEW)
#define KEYVAL_ALLOWSSAVER      TEXT("sav")     // (NEW)
#define KEYVAL_UNIQUESETTINGS   TEXT("uus")     // (NEW)
#ifdef LATER
#define KEYVAL_DISPLAYTBAR      TEXT("dtb")   // (NEW)
#define KEYVAL_RESTOREWIN       TEXT("rws")   // (NEW)
#define KEYVAL_QUICKEDIT        TEXT("qme")   // (NEW)
#define KEYVAL_EXCLMOUSE        TEXT("exm")   // (NEW)
#define KEYVAL_WARNIFACTIVE     TEXT("wia")   // (NEW)
#endif

#define MAX_KEYVAL_SIZE         6

#define KEYVAL_ID_UNKNOWN       -1
#define KEYVAL_ID_NONE          0
#define KEYVAL_ID_WINDOWED      1
#define KEYVAL_ID_BACKGROUND    2
#define KEYVAL_ID_EXCLUSIVE     3
#define KEYVAL_ID_DETECTIDLE    4
#define KEYVAL_ID_LOWLOCKED     5
#define KEYVAL_ID_EMSLOCKED     6
#define KEYVAL_ID_XMSLOCKED     7
#define KEYVAL_ID_USEHMA        8
#define KEYVAL_ID_EMULATEROM    9
#define KEYVAL_ID_RETAINVRAM    10
#define KEYVAL_ID_FASTPASTE     11
#define KEYVAL_ID_ALTTAB        12
#define KEYVAL_ID_ALTESC        13
#define KEYVAL_ID_CTRLESC       14
#define KEYVAL_ID_PRTSCRN       15
#define KEYVAL_ID_ALTPRTSCRN    16
#define KEYVAL_ID_ALTSPACE      17
#define KEYVAL_ID_ALTENTER      18
#define KEYVAL_ID_WINLIE        19
#define KEYVAL_ID_GLOBALMEM     20
#define KEYVAL_ID_REALMODE      21
#define KEYVAL_ID_MOUSE         22
#define KEYVAL_ID_EMS           23
#define KEYVAL_ID_CDROM         24
#define KEYVAL_ID_NETWORK       25
#define KEYVAL_ID_DISKLOCK      26
#define KEYVAL_ID_PRIVATECFG    27
#define KEYVAL_ID_CLOSEONEXIT   28
#define KEYVAL_ID_ALLOWSSAVER   29
#define KEYVAL_ID_UNIQUESETTINGS 30
#ifdef LATER
#define KEYVAL_ID_DISPLAYTBAR   31
#define KEYVAL_ID_RESTOREWIN    32
#define KEYVAL_ID_QUICKEDIT     33
#define KEYVAL_ID_EXCLMOUSE     34
#define KEYVAL_ID_WARNIFACTIVE  35
#endif


/*
 *  Internal function prototypes
 */

#include <setupapi.h>

#ifdef UNICODE
BOOL GetAppsInfData(PPROPLINK ppl, LPPROPPRG lpPrg, LPPROPNT40 lpnt40, HINF hInf, LPCTSTR lpszApp, BOOL fNotAmbiguous, int flOpt);
#else
BOOL GetAppsInfData(PPROPLINK ppl, LPPROPPRG lpPrg, HINF hInf, LPCTSTR lpszApp, BOOL fNotAmbiguous, int flOpt);
#endif
void GetAppsInfSectionData(PINFCONTEXT pInfContext, LPCTSTR lpszSection, PPROPLINK ppl);
int  GetKeyID(PINFCONTEXT pInfContext);
int  GetKeyValID(PINFCONTEXT pInfContext, int i);

#ifdef UNICODE
void InitWorkDir(PPROPLINK ppl, LPPROPPRG lpPrg, LPPROPNT40 lpnt40);
#else
void InitWorkDir(PPROPLINK ppl, LPPROPPRG lpPrg);
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\piflib.c ===
/*
 *  Microsoft Confidential
 *  Copyright (C) Microsoft Corporation 1991
 *  All Rights Reserved.
 *
 *
 *  PIFLIB.C
 *  User interface routines for PIFMGR.DLL
 *
 *  History:
 *  Created 31-Jul-1992 3:30pm by Jeff Parsons
 */

#include "shellprv.h"
#pragma hdrstop


#define LIB_SIG                 0x504A

#define LIB_DEFER               LOADPROPLIB_DEFER

typedef struct LIBLINK {        /* ll */
    struct  LIBLINK *pllNext;   //
    struct  LIBLINK *pllPrev;   //
    int     iSig;               // liblink signature
    int     flLib;              // proplink flags (LIB_*)
    HINSTANCE hDLL;             // if NULL, then load has been deferred
    TCHAR    achDLL[80];        // name of DLL
} LIBLINK;
typedef LIBLINK *PLIBLINK;


#define SHEET_SIG               0x504A

typedef struct SHEETLINK {      /* sl */
    struct  SHEETLINK *pslNext;
    struct  SHEETLINK *pslPrev;
    int     iSig;
    int     iType;
    PROPSHEETPAGE psi;
} SHEETLINK;
typedef SHEETLINK *PSHEETLINK;


UINT    cEdits;                 // number of edit sessions in progress

PLIBLINK pllHead;               // pointer to first lib link
HANDLE   offHighestLibLink;      // highest offset of a lib link thus far recorded

PSHEETLINK pslHead;             // pointer to first sheet link
UINT    cSheetLinks;            // number of sheet links
HANDLE  offHighestSheetLink;    // highest offset of a sheet link thus far recorded


struct {                        // built-in property sheet info
    LPCTSTR  lpTemplateName;
    DLGPROC lpfnDlgProc;
    int     iType;
} const aPSInfo[] = {
    { MAKEINTRESOURCE(IDD_PROGRAM), DlgPrgProc, SHEETTYPE_SIMPLE},
    { MAKEINTRESOURCE(IDD_FONT),    DlgFntProc, SHEETTYPE_SIMPLE},
    { MAKEINTRESOURCE(IDD_MEMORY),  DlgMemProc, SHEETTYPE_SIMPLE},
    { MAKEINTRESOURCE(IDD_SCREEN),  DlgVidProc, SHEETTYPE_SIMPLE},
    { MAKEINTRESOURCE(IDD_MISC),    DlgMscProc, SHEETTYPE_SIMPLE},
};


/** LoadPropertyLib - load new property library
 *
 * INPUT
 *  lpszDLL -> name of DLL
 *  fLoad == flags (see LOADPROPLIB_*)
 *
 * OUTPUT
 *  handle to property library if loaded, FALSE if not
 */

HANDLE WINAPI LoadPropertyLib(LPCTSTR lpszDLL, int fLoad)
{
    HINSTANCE hDLL;
    register PLIBLINK pll;
    FunctionName(LoadPropertyLib);

    hDLL = NULL;
    if (!(fLoad & LOADPROPLIB_DEFER)) {

        hDLL = LoadLibrary(lpszDLL);

        if (hDLL < (HINSTANCE)HINSTANCE_ERROR)
            return FALSE;
    }

    // Allocate new lib link

    if (!(pll = (PLIBLINK)LocalAlloc(LPTR, SIZEOF(LIBLINK))))
        return FALSE;

    if ((HANDLE) pll > offHighestLibLink)
        offHighestLibLink = pll;

    // Initialize the lib link

    pll->pllPrev = NULL;
    pll->iSig = LIB_SIG;
    pll->hDLL = hDLL;
    pll->flLib = 0;
    if (!hDLL)
        pll->flLib |= LIB_DEFER;
    lstrcpyn(pll->achDLL, lpszDLL, ARRAYSIZE(pll->achDLL));

    // Link into the global lib list

    if (NULL != (pll->pllNext = pllHead))
        pllHead->pllPrev = pll;
    pllHead = pll;

    return pll;
}


/** EnumPropertyLibs - enumerate property libraries
 *
 * INPUT
 *  iLib    == 0 to begin enumeration, or result of previous call
 *  lphDLL  -> where to store handle (NULL if don't care)
 *  lpszDLL -> where to store name of library (NULL if don't care)
 *  cchszDLL == size of space (in chars) to store name
 *
 * OUTPUT
 *  lphDLL and lpszDLL filled in as appropriate, 0 if no more libs (or error)
 */

HANDLE WINAPI EnumPropertyLibs(HANDLE iLib, LPHANDLE lphDLL, LPTSTR lpszDLL, int cchszDLL)
{
    register PLIBLINK pll;
    FunctionName(EnumPropertyLibs);

    if (!iLib)
        pll = pllHead;
    else
        pll = ((PLIBLINK)iLib)->pllNext;

    // Validate the handle

    if (!pll)
        return 0;

    if ((HANDLE) pll > offHighestLibLink)
        return 0;

    if (pll->iSig != LIB_SIG)
        return 0;

    if (lphDLL)
        *lphDLL = pll->hDLL;

    if (lpszDLL)
        lstrcpyn(lpszDLL, pll->achDLL, min(cchszDLL, ARRAYSIZE(pll->achDLL)));

    return pll;
}


/** FreePropertyLib - free installable property library
 *
 * INPUT
 *  hLib == handle to property library
 *
 * OUTPUT
 *  TRUE if successful, FALSE otherwise
 */

BOOL WINAPI FreePropertyLib(HANDLE hLib)
{
    register PLIBLINK pll;
    FunctionName(FreePropertyLib);

    // Validate the handle

    if (!hLib)
        return FALSE;

    if ((HANDLE)hLib > offHighestLibLink)
        return FALSE;

    pll = (PLIBLINK)hLib;

    if (pll->iSig != LIB_SIG)
        return FALSE;

    // Free the associated library

    if (pll->hDLL)
        FreeLibrary(pll->hDLL);

    // Unlink from the global list

    if (pll->pllPrev)
        pll->pllPrev->pllNext = pll->pllNext;
    else
        pllHead = pll->pllNext;

    if (pll->pllNext)
        pll->pllNext->pllPrev = pll->pllPrev;

    EVAL(LocalFree(pll) == NULL);

    return TRUE;
}


/** AddPropertySheet - install new property sheet
 *
 * INPUT
 *  lppsi -> property sheet info structure
 *  iType  == sheet type (see SHEETTYPE_* constants)
 *
 * OUTPUT
 *  handle to property sheet link, or NULL if failure
 */

HANDLE WINAPI AddPropertySheet(const PROPSHEETPAGE *lppsi, int iType)
{
    register PSHEETLINK psl;
    FunctionName(AddPropertySheet);

    // Allocate new sheet link

    if (!(psl = (PSHEETLINK)LocalAlloc(LPTR, SIZEOF(SHEETLINK))))
        return FALSE;

    if ((HANDLE) psl > offHighestSheetLink)
        offHighestSheetLink = psl;

    // Initialize the sheet link

    psl->pslPrev = NULL;
    psl->iSig = SHEET_SIG;
    psl->psi = *lppsi;
    psl->iType = iType;

    // Link into the global sheet list

    if (NULL != (psl->pslNext = pslHead))
        pslHead->pslPrev = psl;
    pslHead = psl;

    cSheetLinks++;

    return psl;
}


/** RemovePropertySheet - remove installable property sheet
 *
 * INPUT
 *  hSheet == handle to sheet link
 *
 * OUTPUT
 *  TRUE if successful, FALSE otherwise
 */

BOOL WINAPI RemovePropertySheet(HANDLE hSheet)
{
    register PSHEETLINK psl;
    FunctionName(RemovePropertySheet);

    // Validate the handle

    if (!hSheet)
        return FALSE;

    if ((HANDLE)hSheet > offHighestSheetLink)
        return FALSE;

    psl = (PSHEETLINK)hSheet;

    if (psl->iSig != SHEET_SIG)
        return FALSE;

    // Unlink from the global list

    cSheetLinks--;

    if (psl->pslPrev)
        psl->pslPrev->pslNext = psl->pslNext;
    else
        pslHead = psl->pslNext;

    if (psl->pslNext)
        psl->pslNext->pslPrev = psl->pslPrev;

    EVAL(LocalFree(psl) == NULL);

    return TRUE;
}


/** LoadPropertySheets - load property sheets
 *
 * INPUT
 *  hProps = property handle
 *  flags = 0 (reserved)
 *
 * OUTPUT
 *  # of sheets loaded, 0 if error
 */

int WINAPI LoadPropertySheets(HANDLE hProps, int flags)
{
    register PLIBLINK pll;
    FunctionName(LoadPropertySheets);

    // If this is the first edit session, do global init now

    if (cEdits++ == 0)
        if (!LoadGlobalEditData())
            return 0;

    pll = NULL;
    while (NULL != (pll = (PLIBLINK)EnumPropertyLibs(pll, NULL, NULL, 0))) {
        if (!pll->hDLL && (pll->flLib & LIB_DEFER)) {

            pll->hDLL = LoadLibrary(pll->achDLL);

            // If the load failed, to us that simply means those sheets
            // will not be available; the particular error is not interesting,
            // so nullify the handle

            if (pll->hDLL < (HINSTANCE)HINSTANCE_ERROR)
                pll->hDLL = NULL;
        }
    }
    return cSheetLinks + ARRAYSIZE(aPSInfo);
}


/** EnumPropertySheets - enumerate property sheets
 *
 * INPUT
 *  hProps == property handle
 *  iType  == sheet type (see SHEETTYPE_* constants)
 *  iSheet == 0 to begin enumeration, or result of previous call
 *  lppsi -> property sheet info structure to be filled in
 *
 * OUTPUT
 *  lppsi filled in as appropriate, 0 if no more sheets (or error)
 */

INT_PTR WINAPI EnumPropertySheets(HANDLE hProps, int iType, INT_PTR iSheet, LPPROPSHEETPAGE lppsp)
{
    register PSHEETLINK psl;
    FunctionName(EnumPropertySheets);

    while (iSheet < ARRAYSIZE(aPSInfo)) {
        if (aPSInfo[iSheet].iType <= iType) {
            if (lppsp) {
                lppsp->dwSize      = SIZEOF(PROPSHEETPAGE);
                lppsp->dwFlags     = PSP_DEFAULT;
                lppsp->hInstance   = HINST_THISDLL;
                lppsp->pszTemplate = aPSInfo[iSheet].lpTemplateName;
                lppsp->pfnDlgProc  = aPSInfo[iSheet].lpfnDlgProc;
                // lppsp->pszTitle    = NULL;
                lppsp->lParam      = (LONG_PTR)hProps;
            }
            return ++iSheet;
        }
        ++iSheet;
    }
    if (iSheet == ARRAYSIZE(aPSInfo))
        psl = pslHead;
    else
        psl = ((PSHEETLINK)iSheet)->pslNext;

    // Validate the handle

    while (psl && (HANDLE) psl <= offHighestSheetLink && psl->iSig == SHEET_SIG) {

        if (psl->iType <= iType) {

            *lppsp = psl->psi;
            lppsp->lParam = (LONG_PTR)hProps;

            return (INT_PTR) psl;
        }
        psl = psl->pslNext;
    }
    return 0;                   // no more matching sheets
}


/** FreePropertySheets - free property sheets
 *
 * INPUT
 *  hProps = property handle
 *  flags = 0 (reserved)
 *
 * OUTPUT
 *  Nothing
 */

HANDLE WINAPI FreePropertySheets(HANDLE hProps, int flags)
{
    register PLIBLINK pll;
    FunctionName(FreePropertySheets);

    pll = NULL;
    while (NULL != (pll = (PLIBLINK)EnumPropertyLibs(pll, NULL, NULL, 0))) {
        if (pll->hDLL && (pll->flLib & LIB_DEFER)) {
            FreeLibrary(pll->hDLL);
            pll->hDLL = NULL;
        }
    }
    // If this is the last edit session, do global un-init now

    if (--cEdits == 0)
        FreeGlobalEditData();

    return 0;
}


/** InitRealModeFlag - Initialize PROP_REALMODE
 *
 * INPUT
 *  ppl = properties
 *
 * OUTPUT
 *  ppl->flProp PROP_REALMODE bit set if sheet is for real-mode app,
 *  else clear.
 */

void InitRealModeFlag(PPROPLINK ppl)
{
    PROPPRG prg;

    if (!PifMgr_GetProperties(ppl, MAKELP(0,GROUP_PRG),
                        &prg, SIZEOF(prg), GETPROPS_NONE)) {
        return;                 /* Weird */
    }
    if (prg.flPrgInit & PRGINIT_REALMODE) {
        ppl->flProp |= PROP_REALMODE;
    } else {
        ppl->flProp &= ~PROP_REALMODE;
    }
}


/** EditProperties - edit property info
 *
 * INPUT
 *  hProps = handle to properties
 *  lpszTitle = pointer to title to use (NULL if none)
 *  uStartPage = starting property sheet #
 *  hwnd = handle to window of parent (NULL if none)
 *  uMsgPost = msg # to post to hwnd with change notification (0 if none)
 *
 * OUTPUT
 *  TRUE if successful, FALSE otherwise
 */

int WINAPI EditProperties(HANDLE hProps, LPCTSTR lpszTitle, UINT uStartPage, HWND hwnd, UINT uMsgPost)
{
    int cSheets;
    INT_PTR iSheet;
    PPROPLINK ppl;
    PROPSHEETHEADER psh;
    PROPSHEETPAGE *ppsp;
    register PSHEETLINK psl;
    FunctionName(EditProperties);

    if (!(ppl = ValidPropHandle(hProps)))
        return FALSE;

    if (hwnd && uMsgPost) {
        ppl->hwndNotify = hwnd;
        ppl->uMsgNotify = uMsgPost;
    }
    cSheets = LoadPropertySheets(hProps, 0);

    psl = pslHead;
    if (!(ppsp = (PROPSHEETPAGE *)LocalAlloc(LPTR, cSheets*SIZEOF(PROPSHEETPAGE))))
        return FALSE;

    psh.dwSize = SIZEOF(psh);
    psh.dwFlags = PSH_PROPTITLE | PSH_PROPSHEETPAGE;
    psh.hwndParent = hwnd;
    if (!lpszTitle)
        psh.pszCaption = ppl->szPathName+ppl->iFileName;
    else
        psh.pszCaption = ppl->lpszTitle = lpszTitle;
    psh.nPages = 0;
    psh.nStartPage = uStartPage;
    psh.ppsp = ppsp;

    iSheet = cSheets = 0;

    while (0 != (iSheet = EnumPropertySheets(hProps, SHEETTYPE_SIMPLE, iSheet, ppsp))) {
        cSheets++;
        ppsp++;
    }
    psh.nPages = cSheets;

    // Since the user wishes to *explicitly* change settings for this app
    // we make sure that the DONTWRITE flag isn't going to get in his way...

    ppl->flProp &= ~PROP_DONTWRITE;

    InitRealModeFlag(ppl);

    PropertySheet(&psh);

    VERIFYFALSE(LocalFree((HLOCAL)psh.ppsp));

    FreePropertySheets(hProps, 0);

    if (ppl->flProp & PROP_NOTIFY) {
        ppl->flProp &= ~PROP_NOTIFY;
        PostMessage(ppl->hwndNotify, ppl->uMsgNotify, 0, 0);
    }
    ppl->hwndNotify = NULL;
    ppl->uMsgNotify = 0;
    ppl->lpszTitle = NULL;

    return TRUE;
}

BOOL LoadGlobalEditData()
{
    FunctionName(LoadGlobalEditData);

    if (!LoadGlobalFontEditData())
        return FALSE;

    return TRUE;
}


void FreeGlobalEditData()
{
    FunctionName(FreeGlobalEditData);
    FreeGlobalFontEditData();
}


UINT CALLBACK PifPropPageRelease(HWND hwnd, UINT uMsg, LPPROPSHEETPAGE lppsp)
{
    FunctionName(PifPropPageRelease);

    if (uMsg == PSPCB_RELEASE) {
        PPROPLINK ppl = (PPROPLINK)(INT_PTR)lppsp->lParam;

        if ((--ppl->iSheetUsage) == 0) {

            FreePropertySheets(ppl, 0);

            PifMgr_CloseProperties(ppl, CLOSEPROPS_NONE);
        }
    }
    return 1;
}

#define MZMAGIC      ((WORD)'M'+((WORD)'Z'<<8))

//
// call SHELL.DLL to get the EXE type.
//
BOOL IsWinExe(LPCTSTR lpszFile)
{
    DWORD dw = (DWORD) SHGetFileInfo(lpszFile, 0, NULL, 0, SHGFI_EXETYPE);

    return dw && LOWORD(dw) != MZMAGIC;
}

BOOL WINAPI PifPropGetPages(LPVOID lpv,
                            LPFNADDPROPSHEETPAGE lpfnAddPage,
                            LPARAM lParam)
{
#define hDrop   (HDROP)lpv
    PPROPLINK ppl;
    PROPSHEETPAGE psp;
    int iType, cSheets;
    INT_PTR iSheet;
    HPROPSHEETPAGE hpage;
    TCHAR szFileName[MAXPATHNAME];
    FunctionName(PifPropGetPages);

    // only process things if hDrop contains only one file
    if (DragQueryFile(hDrop, (UINT)-1, NULL, 0) != 1)
    {
        return TRUE;
    }

    // get the name of the file
    DragQueryFile(hDrop, 0, szFileName, ARRAYSIZE(szFileName));

    if (GetFileAttributes( szFileName) & FILE_ATTRIBUTE_OFFLINE)
    {
        return FALSE;
    }

    // if this is a windows app, don't do no properties
    if (IsWinExe(szFileName))
        return TRUE;

    // if we can't get a property handle, don't do no properties either
    if (!(ppl = (PPROPLINK)PifMgr_OpenProperties(szFileName, NULL, 0, OPENPROPS_NONE)))
        return TRUE;

    InitRealModeFlag(ppl);

    if (!(cSheets = LoadPropertySheets(ppl, 0)))
        goto CloseProps;

    // Since the user wishes to *explicitly* change settings for this app
    // we make sure that the DONTWRITE flag isn't going to get in his way...

    ppl->flProp &= ~PROP_DONTWRITE;

    iSheet = cSheets = 0;
    iType = (GetKeyState(VK_CONTROL) >= 0? SHEETTYPE_SIMPLE : SHEETTYPE_ADVANCED);

    while (TRUE) {

        if (!(iSheet = EnumPropertySheets(ppl, iType, iSheet, &psp))) {
            // done with enumeration
            break;
        }
        psp.dwFlags |= PSP_USECALLBACK;
        psp.pfnCallback = PifPropPageRelease;
        psp.pcRefParent = 0;

        hpage = CreatePropertySheetPage(&psp);
        if (hpage)
        {
            // the PROPLINK is now being used by this property sheet as well

            if (lpfnAddPage(hpage, lParam))
            {
                ppl->iSheetUsage++;
                cSheets++;
            }
            else
            {
                PifPropPageRelease(NULL, PSPCB_RELEASE, &psp);
            }
        }
    }

    if (!cSheets) {
        FreePropertySheets(ppl, 0);

CloseProps:
        PifMgr_CloseProperties(ppl, CLOSEPROPS_NONE);
    }
    return TRUE;
}
#undef hDrop
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\pifmsc.c ===
// Created 04-Jan-1993 1:10pm by Jeff Parsons

#include "shellprv.h"
#pragma hdrstop

#define VMD_DEVICE_ID           0x0000C


BINF abinfTsk[] = {
    {IDC_FGNDSCRNSAVER, BITNUM(TSK_NOSCREENSAVER)  | 0x80},
    {IDC_BGNDSUSPEND,   BITNUM(TSK_BACKGROUND)     | 0x80},
    {IDC_WARNTERMINATE, BITNUM(TSK_NOWARNTERMINATE)| 0x80},
};

BINF abinfKbd[] = {
    {IDC_ALTESC,        BITNUM(KBD_NOALTESC)    | 0x80},
    {IDC_ALTTAB,        BITNUM(KBD_NOALTTAB)    | 0x80},
    {IDC_CTRLESC,       BITNUM(KBD_NOCTRLESC)   | 0x80},
    {IDC_PRTSC,         BITNUM(KBD_NOPRTSC)     | 0x80},
    {IDC_ALTPRTSC,      BITNUM(KBD_NOALTPRTSC)  | 0x80},
    {IDC_ALTSPACE,      BITNUM(KBD_NOALTSPACE)  | 0x80},
    {IDC_ALTENTER,      BITNUM(KBD_NOALTENTER)  | 0x80},
    {IDC_FASTPASTE,     BITNUM(KBD_FASTPASTE)         },
};

BINF abinfMse[] = {
    {IDC_QUICKEDIT,     BITNUM(MSE_WINDOWENABLE)| 0x80},
    {IDC_EXCLMOUSE,     BITNUM(MSE_EXCLUSIVE)         },    // WARNING -- Assumed to be abinfMse[1] below
};

// Private function prototypes

BOOL GetSetMscProps(HWND hDlg, GETSETFN lpfn, PPROPLINK ppl, LPPROPTSK lptsk, LPPROPKBD lpkbd, LPPROPMSE lpmse, LPPROPENV lpenv, int idError);
void InitMscDlg(HWND hDlg, PPROPLINK ppl);
void ApplyMscDlg(HWND hDlg, PPROPLINK ppl);


// Context-sensitive help ids

const static DWORD rgdwHelp[] = {
    IDC_FGNDGRP,         IDH_COMM_GROUPBOX,
    IDC_FGNDSCRNSAVER,   IDH_DOS_TASKING_ALLOW_SCREENSAVER,
    IDC_BGNDGRP,         IDH_COMM_GROUPBOX,
    IDC_BGNDSUSPEND,     IDH_DOS_TASKING_SUSPEND,
    IDC_IDLEGRP,         IDH_COMM_GROUPBOX,
    IDC_IDLELOWLBL,      IDH_DOS_TASKING_IDLE_SLIDER,
    IDC_IDLEHIGHLBL,     IDH_DOS_TASKING_IDLE_SLIDER,
    IDC_IDLESENSE,       IDH_DOS_TASKING_IDLE_SLIDER,
    IDC_TERMGRP,         IDH_COMM_GROUPBOX,
    IDC_WARNTERMINATE,   IDH_DOS_WINDOWS_WARN,
    IDC_MISCMOUSEGRP,    IDH_COMM_GROUPBOX,
    IDC_QUICKEDIT,       IDH_DOS_WINDOWS_MOUSE_QUICKEDIT,
    IDC_EXCLMOUSE,       IDH_DOS_WINDOWS_MOUSE_EXCLUSIVE,
    IDC_ALTESC,          IDH_DOS_KEYBOARD_SHORTCUTS,
    IDC_MISCKBDGRP,      IDH_COMM_GROUPBOX,
    IDC_ALTTAB,          IDH_DOS_KEYBOARD_SHORTCUTS,
    IDC_CTRLESC,         IDH_DOS_KEYBOARD_SHORTCUTS,
    IDC_PRTSC,           IDH_DOS_KEYBOARD_SHORTCUTS,
    IDC_ALTPRTSC,        IDH_DOS_KEYBOARD_SHORTCUTS,
    IDC_ALTSPACE,        IDH_DOS_KEYBOARD_SHORTCUTS,
    IDC_ALTENTER,        IDH_DOS_KEYBOARD_SHORTCUTS,
    IDC_MISCOTHERGRP,    IDH_COMM_GROUPBOX,
    IDC_FASTPASTE,       IDH_DOS_KEYBOARD_FASTPASTE,
    IDC_TOOLBAR,         IDH_DOS_WINDOWS_TOOLBAR,
    IDC_WINRESTORE,      IDH_DOS_WINDOWS_RESTORE,
    IDC_REALMODEDISABLE, IDH_DOS_REALMODEPROPS,
    0, 0
};


BOOL_PTR CALLBACK DlgMscProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    PPROPLINK ppl;
    FunctionName(DlgMscProc);

    ppl = (PPROPLINK)GetWindowLongPtr(hDlg, DWLP_USER);

    switch (uMsg) {
    case WM_INITDIALOG:
        lParam = ((LPPROPSHEETPAGE)lParam)->lParam;
        SetWindowLongPtr(hDlg, DWLP_USER, lParam);
        ppl = (PPROPLINK)lParam;
        InitMscDlg(hDlg, ppl);
        break;

    HELP_CASES(rgdwHelp)                // Handle help messages

    case WM_HSCROLL:                    // assumed to be notifications
                                        // from our one and only trackbar
        SendMessage(GetParent(hDlg), PSM_CHANGED, (WPARAM)hDlg, 0L);
        break;

    case WM_COMMAND:
        if (LOWORD(lParam) == 0)
            break;                      // message not from a control

        switch (LOWORD(wParam)) {

        case IDC_FGNDSCRNSAVER:
        case IDC_BGNDSUSPEND:
        case IDC_QUICKEDIT:
        case IDC_EXCLMOUSE:
        case IDC_WARNTERMINATE:
        case IDC_FASTPASTE:
        case IDC_INSTRUCTIONS:
        case IDC_ALTTAB:
        case IDC_CTRLESC:
        case IDC_ALTPRTSC:
        case IDC_ALTESC:
        case IDC_PRTSC:
        case IDC_ALTENTER:
        case IDC_ALTSPACE:
            if (HIWORD(wParam) == BN_CLICKED)
                SendMessage(GetParent(hDlg), PSM_CHANGED, (WPARAM)hDlg, 0L);
            break;
        }
        break;

    case WM_NOTIFY:
        switch (((NMHDR *)lParam)->code) {

        case PSN_KILLACTIVE:
            // This gives the current page a chance to validate itself
            // SetWindowLong(hDlg, DWL_MSGRESULT, 0);
            break;

        case PSN_APPLY:
            // This happens on OK....
            ApplyMscDlg(hDlg, ppl);
            break;

        case PSN_RESET:
            // This happens on Cancel....
            break;
        }
        break;

    case WM_WININICHANGE:
    case WM_SYSCOLORCHANGE:
    case WM_DISPLAYCHANGE:
        RelayMessageToChildren(hDlg, uMsg, wParam, lParam);
        break;

    default:
        return FALSE;                   // return 0 when not processing
    }
    return TRUE;
}


BOOL GetSetMscProps(HWND hDlg, GETSETFN lpfn, PPROPLINK ppl, LPPROPTSK lptsk, LPPROPKBD lpkbd, LPPROPMSE lpmse, LPPROPENV lpenv, int idError)
{
    if (!(*lpfn)(ppl, MAKELP(0,GROUP_TSK),
                        lptsk, sizeof(*lptsk), GETPROPS_NONE) ||
        !(*lpfn)(ppl, MAKELP(0,GROUP_KBD),
                        lpkbd, sizeof(*lpkbd), GETPROPS_NONE) ||
        !(*lpfn)(ppl, MAKELP(0,GROUP_MSE),
                        lpmse, sizeof(*lpmse), GETPROPS_NONE) ||
        !(*lpfn)(ppl, MAKELP(0,GROUP_ENV),
                        lpenv, sizeof(*lpenv), GETPROPS_NONE)) {
        Warning(hDlg, (WORD)idError, (WORD)(MB_ICONEXCLAMATION | MB_OK));
        return FALSE;
    }
    return TRUE;
}


void InitMscDlg(HWND hDlg, PPROPLINK ppl)
{
    PROPTSK tsk;
    PROPKBD kbd;
    PROPMSE mse;
    PROPENV env;
    FunctionName(InitMscDlg);

    if (!GetSetMscProps(hDlg, PifMgr_GetProperties, ppl, &tsk, &kbd, &mse, &env, IDS_QUERY_ERROR))
        return;

    SetDlgItemPct(hDlg, IDC_IDLESENSE, tsk.wIdleSensitivity);
    SetDlgBits(hDlg, &abinfTsk[0], ARRAYSIZE(abinfTsk), tsk.flTsk);
    SetDlgBits(hDlg, &abinfKbd[0], ARRAYSIZE(abinfKbd), kbd.flKbd);
    SetDlgBits(hDlg, &abinfMse[0], ARRAYSIZE(abinfMse), mse.flMse);
}


void ApplyMscDlg(HWND hDlg, PPROPLINK ppl)
{
    PROPTSK tsk;
    PROPKBD kbd;
    PROPMSE mse;
    PROPENV env;
    FunctionName(ApplyMscDlg);

    if (!GetSetMscProps(hDlg, PifMgr_GetProperties, ppl, &tsk, &kbd, &mse, &env, IDS_UPDATE_ERROR))
        return;

    GetDlgBits(hDlg, &abinfTsk[0], ARRAYSIZE(abinfTsk), &tsk.flTsk);
    tsk.wIdleSensitivity = (WORD) GetDlgItemPct(hDlg, IDC_IDLESENSE);
    GetDlgBits(hDlg, &abinfKbd[0], ARRAYSIZE(abinfKbd), &kbd.flKbd);
    GetDlgBits(hDlg, &abinfMse[0], ARRAYSIZE(abinfMse), &mse.flMse);

    if (GetSetMscProps(hDlg, PifMgr_SetProperties, ppl, &tsk, &kbd, &mse, &env, IDS_UPDATE_ERROR)) {
        if (ppl->hwndNotify) {
            ppl->flProp |= PROP_NOTIFY;
            PostMessage(ppl->hwndNotify, ppl->uMsgNotify, sizeof(mse), (LPARAM)MAKELP(0,GROUP_MSE));
        }
    }
}


BOOL IsBufferDifferent( LPVOID lpBuff1, LPVOID lpBuff2, UINT cb )
{
    BYTE bRet = 0;
    LPBYTE lpByte1 = (LPBYTE)lpBuff1;
    LPBYTE lpByte2 = (LPBYTE)lpBuff2;

    ASSERT(cb>0);

    while ((cb!=0) && (bRet==0))
    {
        bRet = *lpByte1 - *lpByte2;

        cb--;
        lpByte1++;
        lpByte2++;

    }

    return (DWORD)bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\pifmem.c ===
// Created 04-Jan-1993 1:10pm by Jeff Parsons

#include "shellprv.h"
#pragma hdrstop

BINF abinfMem[] = {
    {IDC_HMA,           BITNUM(MEMINIT_NOHMA)   | 0x80},
    {IDC_GLOBALPROTECT, BITNUM(MEMINIT_GLOBALPROTECT) },
};

VINF avinfMem[] = {
    {FIELD_OFFSET(PROPMEM,wMinLow), VINF_AUTOMINMAX, IDC_LOWMEM, MEMLOW_MIN, MEMLOW_MAX, IDS_BAD_MEMLOW},
    {FIELD_OFFSET(PROPMEM,wMinEMS), VINF_AUTOMINMAX, IDC_EMSMEM, MEMEMS_MIN, MEMEMS_MAX, IDS_BAD_MEMEMS},
    {FIELD_OFFSET(PROPMEM,wMinXMS), VINF_AUTOMINMAX, IDC_XMSMEM, MEMXMS_MIN, MEMXMS_MAX, IDS_BAD_MEMXMS},
};

VINF avinfEnvMem[] = {
    {FIELD_OFFSET(PROPENV,cbEnvironment), VINF_AUTO, IDC_ENVMEM, ENVSIZE_MIN, ENVSIZE_MAX, IDS_BAD_ENVIRONMENT},
    {FIELD_OFFSET(PROPENV,wMaxDPMI), VINF_AUTO, IDC_DPMIMEM, ENVDPMI_MIN, ENVDPMI_MAX, IDS_BAD_MEMDPMI},
};

// Per-dialog data

#define MEMINFO_RELAUNCH        0x0001          // relaunch required to take effect

#define EMS_NOEMS               0x0001          // EMS no supported in protmode
#define EMS_EMM386              0x0002          // EM386 is installed
#define EMS_QEMM                0x0004          // Third-party mmgr installed
#define EMS_RMPAGEFRAME         0x0008          // Page frame present in real mode
#define EMS_SYSINIDISABLE       0x0010          // EMS forced off by system.ini

typedef struct MEMINFO {        /* mi */
    PPROPLINK ppl;                              // pointer to property info
    DWORD     flMemInfo;                        // initially zero thx to LocalAlloc(LPTR)
    DWORD     flEms;                            // EMS support flags
} MEMINFO;
typedef MEMINFO *PMEMINFO;      /* pmi */


// Private function prototypes

BOOL GetSetMemProps(HWND hDlg, GETSETFN lpfn, PPROPLINK ppl, LPPROPMEM lpmem, LPPROPENV lpenv, int idError);
void InitMemDlg(HWND hDlg, PMEMINFO pmi);
void ApplyMemDlg(HWND hDlg, PMEMINFO pmi);
void AdjustEmsControls(HWND hDlg, PMEMINFO pmi);
void ExplainNoEms(HWND hDlg, PMEMINFO pmi);

// Context-sensitive help ids

const static DWORD rgdwHelp[] = {
        IDC_CONVMEMLBL,      IDH_DOS_MEMORY_CONV,
        IDC_LOWMEM,          IDH_DOS_MEMORY_CONV,
        IDC_GLOBALPROTECT,   IDH_DOS_MEMORY_CONV_GLOBAL,
        IDC_EXPMEMGRP,       IDH_COMM_GROUPBOX,
        IDC_EXPMEMLBL,       IDH_DOS_MEMORY_EXP,
        IDC_EMSMEM,          IDH_DOS_MEMORY_EXP,
        IDC_EXTMEMGRP,       IDH_COMM_GROUPBOX,
        IDC_XMSMEM,          IDH_DOS_MEMORY_EXT,
        IDC_EXTMEMLBL,       IDH_DOS_MEMORY_EXT,
        IDC_DPMIMEMGRP,      IDH_COMM_GROUPBOX,
        IDC_DPMIMEM,         IDH_DOS_MEMORY_DPMI,
        IDC_DPMIMEMLBL,      IDH_DOS_MEMORY_DPMI,
        IDC_HMA,             IDH_DOS_MEMORY_EXT_HMA,
        IDC_CONVMEMGRP,      IDH_COMM_GROUPBOX,
        IDC_LOCALENVLBL,     IDH_DOS_PROGRAM_ENVIRSZ,
        IDC_ENVMEM,          IDH_DOS_PROGRAM_ENVIRSZ,
        IDC_REALMODEDISABLE, IDH_DOS_REALMODEPROPS,
        IDC_NOEMSDETAILS,    IDH_DOS_MEMORY_NOEMS_DETAILS,
        0, 0
};


BOOL_PTR CALLBACK DlgMemProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    BOOL fError;
    PMEMINFO pmi;
    FunctionName(DlgMemProc);

    pmi = (PMEMINFO)GetWindowLongPtr(hDlg, DWLP_USER);

    switch (uMsg) {
    case WM_INITDIALOG:
        // allocate dialog instance data
        if (NULL != (pmi = (PMEMINFO)LocalAlloc(LPTR, SIZEOF(MEMINFO)))) {
            pmi->ppl = (PPROPLINK)((LPPROPSHEETPAGE)lParam)->lParam;
            SetWindowLongPtr(hDlg, DWLP_USER, (LPARAM)pmi);
            InitMemDlg(hDlg, pmi);
        } else {
            EndDialog(hDlg, FALSE);     // fail the dialog create
        }
        break;

    case WM_DESTROY:
        // free the pmi
        if (pmi) {
            EVAL(LocalFree(pmi) == NULL);
            SetWindowLongPtr(hDlg, DWLP_USER, 0);
        }
        break;

    HELP_CASES(rgdwHelp)                // Handle help messages

    case WM_COMMAND:
        if (LOWORD(lParam) == 0)
            break;                      // message not from a control

        switch (LOWORD(wParam)) {

        case IDC_ENVMEM:
        case IDC_LOWMEM:
        case IDC_EMSMEM:
        case IDC_XMSMEM:
        case IDC_DPMIMEM:
            if (HIWORD(wParam) == CBN_SELCHANGE ||
                HIWORD(wParam) == CBN_EDITCHANGE) {
                SendMessage(GetParent(hDlg), PSM_CHANGED, (WPARAM)hDlg, 0L);
                pmi->flMemInfo |= MEMINFO_RELAUNCH;
            }
            break;

        case IDC_HMA:
        case IDC_GLOBALPROTECT:
            if (HIWORD(wParam) == BN_CLICKED) {
                SendMessage(GetParent(hDlg), PSM_CHANGED, (WPARAM)hDlg, 0L);
                if (LOWORD(wParam) != IDC_GLOBALPROTECT)
                    pmi->flMemInfo |= MEMINFO_RELAUNCH;
            }
            break;

        case IDC_NOEMSDETAILS:
            if (HIWORD(wParam) == BN_CLICKED) {
                ExplainNoEms(hDlg, pmi);
            }
            return FALSE;               // return 0 if we process WM_COMMAND

        }
        break;

    case WM_NOTIFY:
        switch (((NMHDR *)lParam)->code) {
        case PSN_SETACTIVE:
            AdjustRealModeControls(pmi->ppl, hDlg);
            AdjustEmsControls(hDlg, pmi);
                                        // make sure DWL_MSGRESULT is zero,
                                        // otherwise the prsht code thinks we
                                        // "failed" this notify and switches
                                        // to another (sometimes random) page -JTP
            SetWindowLongPtr(hDlg, DWLP_MSGRESULT, 0);
            break;

        case PSN_KILLACTIVE:
            // This gives the current page a chance to validate itself
            fError = ValidateDlgInts(hDlg, avinfMem, ARRAYSIZE(avinfMem));
            fError |= ValidateDlgInts(hDlg, avinfEnvMem, ARRAYSIZE(avinfEnvMem));
            SetWindowLongPtr(hDlg, DWLP_MSGRESULT, fError);
            break;

        case PSN_APPLY:
            // This happens on OK....
            ApplyMemDlg(hDlg, pmi);
            break;

        case PSN_RESET:
            // This happens on Cancel....
            break;
        }
        break;

    default:
        return FALSE;                   // return 0 when not processing
    }
    return TRUE;
}


BOOL GetSetMemProps(HWND hDlg, GETSETFN lpfn, PPROPLINK ppl, LPPROPMEM lpmem, LPPROPENV lpenv, int idError)
{
    if (!(*lpfn)(ppl, MAKELP(0,GROUP_MEM),
                        lpmem, SIZEOF(*lpmem), GETPROPS_NONE) ||
        !(*lpfn)(ppl, MAKELP(0,GROUP_ENV),
                        lpenv, SIZEOF(*lpenv), GETPROPS_NONE)) {
        Warning(hDlg, (WORD)idError, (WORD)MB_ICONEXCLAMATION | MB_OK);
        return FALSE;
    }
    return TRUE;
}


void InitMemDlg(HWND hDlg, PMEMINFO pmi)
{
    PROPMEM mem;
    PROPENV env;
    PPROPLINK ppl = pmi->ppl;
    FunctionName(InitMemDlg);

    if (!GetSetMemProps(hDlg, PifMgr_GetProperties, ppl, &mem, &env, IDS_QUERY_ERROR))
        return;

    SetDlgBits(hDlg, abinfMem, ARRAYSIZE(abinfMem), mem.flMemInit);
    SetDlgInts(hDlg, avinfMem, ARRAYSIZE(avinfMem), (LPVOID)&mem);
    SetDlgInts(hDlg, avinfEnvMem, ARRAYSIZE(avinfEnvMem), (LPVOID)&env);

    /* Disallow "None" as a valid setting for "Conventional memory" */
    SendDlgItemMessage(hDlg, IDC_LOWMEM, CB_DELETESTRING,
        (WPARAM)SendDlgItemMessage(hDlg, IDC_LOWMEM, CB_FINDSTRING,
                                   (WPARAM)-1, (LPARAM)(LPTSTR)g_szNone), 0L);

    pmi->flEms = (EMS_EMM386 | EMS_RMPAGEFRAME);
    AdjustEmsControls(hDlg, pmi);
}


void ApplyMemDlg(HWND hDlg, PMEMINFO pmi)
{
    PROPMEM mem;
    PROPENV env;
    PPROPLINK ppl = pmi->ppl;
    FunctionName(ApplyMemDlg);

    if (!GetSetMemProps(hDlg, PifMgr_GetProperties, ppl, &mem, &env, IDS_UPDATE_ERROR))
        return;

    GetDlgBits(hDlg, abinfMem, ARRAYSIZE(abinfMem), &mem.flMemInit);
    GetDlgInts(hDlg, avinfMem, ARRAYSIZE(avinfMem), (LPVOID)&mem);
    GetDlgInts(hDlg, avinfEnvMem, ARRAYSIZE(avinfEnvMem), (LPVOID)&env);

    if (GetSetMemProps(hDlg, PifMgr_SetProperties, ppl, &mem, &env, IDS_UPDATE_ERROR)) {
        if (ppl->hwndNotify) {
            ppl->flProp |= PROP_NOTIFY;
            PostMessage(ppl->hwndNotify, ppl->uMsgNotify, SIZEOF(mem), (LPARAM)MAKELP(0,GROUP_MEM));
            PostMessage(ppl->hwndNotify, ppl->uMsgNotify, SIZEOF(env), (LPARAM)MAKELP(0,GROUP_ENV));
        }
        if (ppl->hVM && (pmi->flMemInfo & MEMINFO_RELAUNCH)) {
            pmi->flMemInfo &= ~MEMINFO_RELAUNCH;
            Warning(hDlg, IDS_MEMORY_RELAUNCH, MB_ICONWARNING | MB_OK);
        }
    }
}

void HideAndDisable(HWND hwnd)
{
    ShowWindow(hwnd, SW_HIDE);
    EnableWindow(hwnd, FALSE);
}

void AdjustEmsControls(HWND hDlg, PMEMINFO pmi)
{
    if (!(pmi->ppl->flProp & PROP_REALMODE)) {
        /*
         *  When not marked as PROP_REALMODE, all the EMS-related controls
         *  are visible.  We need to choose which set to disable.
         *
         *  We cheat, because we know that there are only two controls
         *  in both cases, and they come right after each other.
         */
        UINT uiHide;
        if (pmi->flEms & EMS_NOEMS) {
            uiHide = IDC_EXPMEMLBL;
            CTASSERTF(IDC_EXPMEMLBL + 1 == IDC_EMSMEM);
        } else {
            uiHide = IDC_NOEMS;
            CTASSERTF(IDC_NOEMS + 1 == IDC_NOEMSDETAILS);
        }
        HideAndDisable(GetDlgItem(hDlg, uiHide));
        HideAndDisable(GetDlgItem(hDlg, uiHide+1));
    }
}


void ExplainNoEms(HWND hDlg, PMEMINFO pmi)
{
    WORD idsHelp;
    TCHAR szMsg[MAX_STRING_SIZE];

    /*
     * Here is where we stare at all the bits to try to figure
     * out what recommendation to make.
     */
    ASSERTTRUE(pmi->flEms & EMS_NOEMS);

    if (pmi->flEms & EMS_SYSINIDISABLE) {
        /*
         * System.ini contains the line NOEMMDRIVER=1.
         */
        idsHelp = IDS_SYSINI_NOEMS;
    } else if (pmi->flEms & EMS_RMPAGEFRAME) {
        /*
         * Had page-frame in real mode, which means that some protmode
         * guy must've messed it up.
         */
        idsHelp = IDS_RING0_NOEMS;
    } else if (pmi->flEms & EMS_EMM386) {
        /*
         * No page-frame in real mode, and EMM386 was in charge,
         * so it's EMM386's fault.
         */
        idsHelp = IDS_EMM386_NOEMS;
    } else {
        /*
         * No page-frame in real mode, and QEMM was in charge,
         * so it's QEMM's fault.
         */
        idsHelp = IDS_QEMM_NOEMS;
    }

    if (LoadStringSafe(hDlg, idsHelp+1, szMsg, ARRAYSIZE(szMsg))) {
        Warning(hDlg, idsHelp, MB_OK, (LPCTSTR)szMsg);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\pifprg.c ===
// Created 04-Jan-1993 1:10pm by Jeff Parsons

#include "shellprv.h"
#pragma hdrstop


BINF abinfPrg[] = {
    {IDC_CLOSEONEXIT,   BITNUM(PRG_CLOSEONEXIT)},
};

//  Per-Dialog data

typedef struct PRGINFO {     /* pi */
    PPROPLINK ppl;
    HICON     hIcon;
    TCHAR     atchIconFile[PIFDEFFILESIZE];
    WORD      wIconIndex;
    LPVOID    hConfig;
    LPVOID    hAutoexec;
    WORD      flPrgInitPrev;
    BOOL      fCfgSetByWiz;
} PRGINFO;
typedef PRGINFO * PPRGINFO;     /* ppi */


//  Private function prototypes

void            InitPrgDlg(HWND hDlg, PPRGINFO ppi);
void            AdjustMSDOSModeControls(PPROPLINK ppl, HWND hDlg);
void            ApplyPrgDlg(HWND hDlg, PPRGINFO ppi);
void            BrowseIcons(HWND hDlg, PPRGINFO ppi);

BOOL_PTR CALLBACK   DlgPifNtProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
WORD            InitNtPifDlg(HWND hDlg, register PPRGINFO ppi);
void            ApplyNtPifDlg( HWND hDlg, PPRGINFO ppi );

// Context-sensitive help ids

const static DWORD rgdwHelp[] = {
    IDC_ICONBMP,        IDH_DOS_PROGRAM_ICON,
    IDC_TITLE,          IDH_DOS_PROGRAM_DESCRIPTION,
    IDC_CMDLINE,        IDH_DOS_PROGRAM_CMD_LINE,
    IDC_CMDLINELBL,     IDH_DOS_PROGRAM_CMD_LINE,
    IDC_WORKDIR,        IDH_DOS_PROGRAM_WORKDIR,
    IDC_WORKDIRLBL,     IDH_DOS_PROGRAM_WORKDIR,
    IDC_HOTKEY,         IDH_DOS_PROGRAM_SHORTCUT,
    IDC_HOTKEYLBL,      IDH_DOS_PROGRAM_SHORTCUT,
    IDC_BATCHFILE,      IDH_DOS_PROGRAM_BATCH,
    IDC_BATCHFILELBL,   IDH_DOS_PROGRAM_BATCH,
    IDC_WINDOWSTATE,    IDH_DOS_PROGRAM_RUN,
    IDC_WINDOWSTATELBL, IDH_DOS_PROGRAM_RUN,
    IDC_CLOSEONEXIT,    IDH_DOS_WINDOWS_QUIT_CLOSE,
    IDC_CHANGEICON,     IDH_DOS_PROGRAM_CHANGEICON,
    IDC_ADVPROG,        IDH_DOS_PROGRAM_ADV_BUTTON,
    0, 0
};

const static DWORD rgdwNTHelp[] = {
    IDC_DOS,            IDH_COMM_GROUPBOX,
    10,                 IDH_DOS_ADV_AUTOEXEC,
    11,                 IDH_DOS_ADV_CONFIG,
    IDC_NTTIMER,        IDH_DOS_PROGRAM_PIF_TIMER_EMULATE,
    0, 0
};

BOOL MustRebootSystem(void)
{
    HKEY hk;
    BOOL bMustReboot = FALSE;

    if (RegOpenKey(HKEY_LOCAL_MACHINE, REGSTR_PATH_SHUTDOWN, &hk) == ERROR_SUCCESS) {
        bMustReboot = (SHQueryValueEx(hk, REGSTR_VAL_FORCEREBOOT, NULL,
                                       NULL, NULL, NULL) == ERROR_SUCCESS);
        RegCloseKey(hk);
    }
    return(bMustReboot);
}


DWORD GetMSDOSOptGlobalFlags(void)
{
    HKEY hk;
    DWORD dwDosOptGlobalFlags = 0;

    if (RegOpenKey(HKEY_LOCAL_MACHINE, REGSTR_PATH_MSDOSOPTS, &hk) == ERROR_SUCCESS) {
        DWORD cb = SIZEOF(dwDosOptGlobalFlags);
        if (SHQueryValueEx(hk, REGSTR_VAL_DOSOPTGLOBALFLAGS, NULL, NULL,
                            (LPVOID)(&dwDosOptGlobalFlags), &cb)
                            != ERROR_SUCCESS) {
            dwDosOptGlobalFlags = 0;
        }
        RegCloseKey(hk);
    }
    return(dwDosOptGlobalFlags);
}



BOOL_PTR CALLBACK DlgPrgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    PPRGINFO ppi = (PPRGINFO)GetWindowLongPtr(hDlg, DWLP_USER);

    switch (uMsg) {

    case WM_INITDIALOG:
        // allocate dialog instance data
        if (NULL != (ppi = (PPRGINFO)LocalAlloc(LPTR, SIZEOF(PRGINFO)))) {
            ppi->ppl = (PPROPLINK)((LPPROPSHEETPAGE)lParam)->lParam;
            SetWindowLongPtr(hDlg, DWLP_USER, (LPARAM)ppi);

            SHAutoComplete(GetDlgItem(hDlg, IDC_CMDLINE), 0);
            SHAutoComplete(GetDlgItem(hDlg, IDC_WORKDIR), 0);
            SHAutoComplete(GetDlgItem(hDlg, IDC_BATCHFILE), 0);
            InitPrgDlg(hDlg, ppi);
        } else {
            EndDialog(hDlg, FALSE);     // fail the dialog create
        }
        break;

    case WM_DESTROY:
        // free the ppi
        if (ppi) {
            EVAL(LocalFree(ppi) == NULL);
            SetWindowLongPtr(hDlg, DWLP_USER, 0);
        }
        break;

    HELP_CASES(rgdwHelp)                // handle help messages

    case WM_COMMAND:
        if (LOWORD(lParam) == 0)
            break;                      // message not from a control

        switch (LOWORD(wParam)) {

        case IDC_TITLE:
        case IDC_CMDLINE:
        case IDC_WORKDIR:
        case IDC_BATCHFILE:
        case IDC_HOTKEY:
            if (HIWORD(wParam) == EN_CHANGE)
                SendMessage(GetParent(hDlg), PSM_CHANGED, (WPARAM)hDlg, 0L);
            break;

        case IDC_WINDOWSTATE:
            if (HIWORD(wParam) == CBN_SELCHANGE)
                SendMessage(GetParent(hDlg), PSM_CHANGED, (WPARAM)hDlg, 0L);
            break;

        case IDC_CLOSEONEXIT:
            if (HIWORD(wParam) == BN_CLICKED)
                SendMessage(GetParent(hDlg), PSM_CHANGED, (WPARAM)hDlg, 0L);
            break;

        case IDC_ADVPROG:
            if (HIWORD(wParam) == BN_CLICKED) {
                DialogBoxParam(HINST_THISDLL,
                               MAKEINTRESOURCE(IDD_PIFNTTEMPLT),
                               hDlg,
                               DlgPifNtProc,
                               (LPARAM)ppi);
            }
            return FALSE;               // return 0 if we process WM_COMMAND

        case IDC_CHANGEICON:
            if (HIWORD(wParam) == BN_CLICKED)
                BrowseIcons(hDlg, ppi);
            return FALSE;               // return 0 if we process WM_COMMAND
        }
        break;

    case WM_NOTIFY:
        switch (((NMHDR *)lParam)->code) {

        case PSN_KILLACTIVE:
            // This gives the current page a chance to validate itself
            break;

        case PSN_APPLY:
            // This happens on OK....
            ApplyPrgDlg(hDlg, ppi);
            break;

        case PSN_RESET:
            // This happens on Cancel....
            break;
        }
        break;

    default:
        return FALSE;                   // return 0 when not processing
    }
    return TRUE;
}


void InitPrgDlg(HWND hDlg, register PPRGINFO ppi)
{
    int i;
    PROPPRG prg;
    PROPENV env;
    PROPNT40 nt40;
    PPROPLINK ppl = ppi->ppl;
    TCHAR szBuf[MAX_STRING_SIZE];
    FunctionName(InitPrgDlg);

    ASSERTTRUE(ppl->iSig == PROP_SIG);

    if (!PifMgr_GetProperties(ppl, MAKELP(0,GROUP_PRG),
                              &prg, SIZEOF(prg), GETPROPS_NONE
                             ) ||
        !PifMgr_GetProperties(ppl, MAKELP(0,GROUP_ENV),
                              &env, SIZEOF(env), GETPROPS_NONE
                             )
                               ||
        !PifMgr_GetProperties(ppl, MAKELP(0,GROUP_NT40),
                              &nt40, SIZEOF(nt40), GETPROPS_NONE
                             )
       ) {
        Warning(hDlg, IDS_QUERY_ERROR, MB_ICONEXCLAMATION | MB_OK);
        return;
    }

    /*
     * Initialize Icon and IconFile information
     *
     */

    ppi->wIconIndex = prg.wIconIndex;

    lstrcpyW(ppi->atchIconFile, nt40.awchIconFile);
    if (NULL != (ppi->hIcon = LoadPIFIcon(&prg, &nt40))) {
        VERIFYFALSE(SendDlgItemMessage(hDlg, IDC_ICONBMP, STM_SETICON, (WPARAM)ppi->hIcon, 0));
    }


    /*
     * Initialize window Title information
     *
     */

    LimitDlgItemText(hDlg, IDC_TITLE, ARRAYSIZE(prg.achTitle)-1);
    SetDlgItemTextW(hDlg, IDC_TITLE, nt40.awchTitle);

    /*
     * Initialize command line information
     *
     */

    LimitDlgItemText(hDlg, IDC_CMDLINE, ARRAYSIZE(prg.achCmdLine)-1);
    SetDlgItemTextW(hDlg, IDC_CMDLINE, nt40.awchCmdLine);

    /*
     * Initialize command line information
     *
     */

    LimitDlgItemText(hDlg, IDC_WORKDIR, ARRAYSIZE(prg.achWorkDir)-1);
    SetDlgItemTextW(hDlg, IDC_WORKDIR, nt40.awchWorkDir);

    /*
     *  Require at least one of Ctrl, Alt or Shift to be pressed.
     *  The hotkey control does not enforce the rule on function keys
     *  and other specials, which is good.
     */
    SendDlgItemMessage(hDlg, IDC_HOTKEY, HKM_SETRULES, HKCOMB_NONE, HOTKEYF_CONTROL | HOTKEYF_ALT);
    SendDlgItemMessage(hDlg, IDC_HOTKEY, HKM_SETHOTKEY, prg.wHotKey, 0);

    /*
     * Initialize batch file information
     *
     */

    LimitDlgItemText(hDlg, IDC_BATCHFILE, ARRAYSIZE(env.achBatchFile)-1);
    SetDlgItemTextW(hDlg, IDC_BATCHFILE, nt40.awchBatchFile);
    /*
     *  Fill in the "Run" combo box.
     */
    for (i=0; i < 3; i++) {
        VERIFYTRUE(LoadString(HINST_THISDLL, IDS_NORMALWINDOW+i, szBuf, ARRAYSIZE(szBuf)));
        VERIFYTRUE((int)SendDlgItemMessage(hDlg, IDC_WINDOWSTATE, CB_ADDSTRING, 0, (LPARAM)(LPTSTR)szBuf) == i);
    }
    i = 0;
    if (prg.flPrgInit & PRGINIT_MINIMIZED)
        i = 1;
    if (prg.flPrgInit & PRGINIT_MAXIMIZED)
        i = 2;
    SendDlgItemMessage(hDlg, IDC_WINDOWSTATE, CB_SETCURSEL, i, 0);

    SetDlgBits(hDlg, &abinfPrg[0], ARRAYSIZE(abinfPrg), prg.flPrg);

    AdjustMSDOSModeControls(ppl, hDlg);
}


void AdjustMSDOSModeControls(PPROPLINK ppl, HWND hDlg)
{
    int i;
    BOOL f = TRUE;

    AdjustRealModeControls(ppl, hDlg);

    /*
     *  The working directory and startup batch file controls are only
     *  supported in real-mode if there is a private configuration (only
     *  because it's more work).  So, disable the controls appropriately.
     */
    if (ppl->flProp & PROP_REALMODE) {
        f = (PifMgr_GetProperties(ppl, szCONFIGHDRSIG40, NULL, 0, GETPROPS_NONE) != 0 ||
             PifMgr_GetProperties(ppl, szAUTOEXECHDRSIG40, NULL, 0, GETPROPS_NONE) != 0);
    }
    #if (IDC_WORKDIRLBL != IDC_WORKDIR-1)
    #error Error in IDC constants: IDC_WORKDIRLBL != IDC_WORKDIR-1
    #endif

    #if (IDC_WORKDIR != IDC_BATCHFILELBL-1)
    #error Error in IDC constants: IDC_WORKDIR != IDC_BATCHFILELBL-1
    #endif

    #if (IDC_BATCHFILELBL != IDC_BATCHFILE-1)
    #error Error in IDC constants: IDC_BATCHFILELBL != IDC_BATCHFILE-1
    #endif

    for (i=IDC_WORKDIRLBL; i<=IDC_BATCHFILE; i++)
        EnableWindow(GetDlgItem(hDlg, i), f);
}


void ApplyPrgDlg(HWND hDlg, PPRGINFO ppi)
{
    int i;
    PROPPRG prg;
    PROPENV env;
    PROPNT40 nt40;
    PPROPLINK ppl = ppi->ppl;
    FunctionName(ApplyPrgDlg);

    ASSERTTRUE(ppl->iSig == PROP_SIG);

    // Get the current set of properties, then overlay the new settings

    if (!PifMgr_GetProperties(ppl, MAKELP(0,GROUP_PRG),
                              &prg, SIZEOF(prg), GETPROPS_NONE
                             ) ||
        !PifMgr_GetProperties(ppl, MAKELP(0,GROUP_ENV),
                              &env, SIZEOF(env), GETPROPS_NONE
                             )
                               ||
        !PifMgr_GetProperties(ppl, MAKELP(0,GROUP_NT40),
                              &nt40, SIZEOF(nt40), GETPROPS_NONE
                             )

       ) {
        Warning(hDlg, IDS_UPDATE_ERROR, MB_ICONEXCLAMATION | MB_OK);
        return;
    }


    // Retrieve Icon information

    lstrcpyW( nt40.awchIconFile, ppi->atchIconFile );
    PifMgr_WCtoMBPath( nt40.awchIconFile, nt40.achSaveIconFile, ARRAYSIZE(nt40.achSaveIconFile) );
    lstrcpyA( prg.achIconFile, nt40.achSaveIconFile );
    prg.wIconIndex = ppi->wIconIndex;

    // Retrieve strings for Title, Command Line,
    // Working Directory and Batch File

    // Title
    GetDlgItemTextW(hDlg, IDC_TITLE, nt40.awchTitle, ARRAYSIZE(nt40.awchTitle));
    GetDlgItemTextA(hDlg, IDC_TITLE, nt40.achSaveTitle, ARRAYSIZE(nt40.achSaveTitle));
    nt40.awchTitle[ ARRAYSIZE(nt40.awchTitle)-1 ] = TEXT('\0');
    nt40.achSaveTitle[ ARRAYSIZE(nt40.achSaveTitle)-1 ] = '\0';
    lstrcpyA( prg.achTitle, nt40.achSaveTitle );

    // Command Line
    GetDlgItemTextW(hDlg, IDC_CMDLINE, nt40.awchCmdLine, ARRAYSIZE(nt40.awchCmdLine));
    GetDlgItemTextA(hDlg, IDC_CMDLINE, nt40.achSaveCmdLine, ARRAYSIZE(nt40.achSaveCmdLine));
    nt40.awchCmdLine[ ARRAYSIZE(nt40.awchCmdLine)-1 ] = TEXT('\0');
    nt40.achSaveCmdLine[ ARRAYSIZE(nt40.achSaveCmdLine)-1 ] = '\0';
    lstrcpyA( prg.achCmdLine, nt40.achSaveCmdLine );

    // Working Directory
    GetDlgItemTextW(hDlg, IDC_WORKDIR, nt40.awchWorkDir, ARRAYSIZE(nt40.awchWorkDir));
    nt40.awchWorkDir[ ARRAYSIZE(nt40.awchWorkDir)-1 ] = TEXT('\0');
    PifMgr_WCtoMBPath(nt40.awchWorkDir, nt40.achSaveWorkDir, ARRAYSIZE(nt40.achSaveWorkDir));
    lstrcpyA(prg.achWorkDir, nt40.achSaveWorkDir);

    // Batch File
    GetDlgItemTextW(hDlg, IDC_BATCHFILE, nt40.awchBatchFile, ARRAYSIZE(nt40.awchBatchFile));
    nt40.awchBatchFile[ ARRAYSIZE(nt40.awchBatchFile)-1 ] = TEXT('\0');
    PifMgr_WCtoMBPath(nt40.awchBatchFile, nt40.achSaveBatchFile, ARRAYSIZE(nt40.achSaveBatchFile));
    lstrcpyA(env.achBatchFile, nt40.achSaveBatchFile);

    prg.wHotKey = (WORD)SendDlgItemMessage(hDlg, IDC_HOTKEY, HKM_GETHOTKEY, 0, 0);


    i = (int)SendDlgItemMessage(hDlg, IDC_WINDOWSTATE, CB_GETCURSEL, 0, 0);
    prg.flPrgInit &= ~(PRGINIT_MINIMIZED | PRGINIT_MAXIMIZED);
    if (i == 1)
        prg.flPrgInit |= PRGINIT_MINIMIZED;
    if (i == 2)
        prg.flPrgInit |= PRGINIT_MAXIMIZED;

    GetDlgBits(hDlg, &abinfPrg[0], ARRAYSIZE(abinfPrg), &prg.flPrg);

    if (!PifMgr_SetProperties(ppl, MAKELP(0,GROUP_PRG),
                        &prg, SIZEOF(prg), SETPROPS_NONE) ||
        !PifMgr_SetProperties(ppl, MAKELP(0,GROUP_ENV),
                        &env, SIZEOF(env), SETPROPS_NONE)
                                                           ||
        !PifMgr_SetProperties(ppl, MAKELP(0,GROUP_NT40),
                        &nt40, SIZEOF(nt40), SETPROPS_NONE)
       )
        Warning(hDlg, IDS_UPDATE_ERROR, MB_ICONEXCLAMATION | MB_OK);
    else
    if (ppl->hwndNotify) {
        ppl->flProp |= PROP_NOTIFY;
        PostMessage(ppl->hwndNotify, ppl->uMsgNotify, SIZEOF(prg), (LPARAM)MAKELP(0,GROUP_PRG));
        PostMessage(ppl->hwndNotify, ppl->uMsgNotify, SIZEOF(env), (LPARAM)MAKELP(0,GROUP_ENV));
        PostMessage(ppl->hwndNotify, ppl->uMsgNotify, SIZEOF(nt40), (LPARAM)MAKELP(0,GROUP_NT40));
    }
}


void BrowseIcons(HWND hDlg, PPRGINFO ppi)
{
    HICON hIcon;
    int wIconIndex = (int)ppi->wIconIndex;
    if (PickIconDlg(hDlg, ppi->atchIconFile, ARRAYSIZE(ppi->atchIconFile), (int *)&wIconIndex)) {
        hIcon = ExtractIcon(HINST_THISDLL, ppi->atchIconFile, wIconIndex);
        if ((UINT_PTR)hIcon <= 1)
            Warning(hDlg, IDS_NO_ICONS, MB_ICONINFORMATION | MB_OK);
        else {
            ppi->hIcon = hIcon;
            ppi->wIconIndex = (WORD)wIconIndex;
            hIcon = (HICON)SendDlgItemMessage(hDlg, IDC_ICONBMP, STM_SETICON, (WPARAM)ppi->hIcon, 0);
            if (hIcon)
                VERIFYTRUE(DestroyIcon(hIcon));
        }
    }
}


BOOL WarnUserCfgChange(HWND hDlg)
{
    TCHAR szTitle[MAX_STRING_SIZE];
    TCHAR szWarning[MAX_STRING_SIZE];

    LoadString(HINST_THISDLL, IDS_WARNING, szTitle, ARRAYSIZE(szTitle));
    LoadString(HINST_THISDLL, IDS_NUKECONFIGMSG, szWarning, ARRAYSIZE(szWarning));
    return(IDYES == MessageBox(hDlg, szWarning, szTitle,
                               MB_YESNO | MB_DEFBUTTON1 | MB_ICONHAND));
}

BOOL_PTR CALLBACK DlgPifNtProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    PPRGINFO ppi = (PPRGINFO)GetWindowLongPtr( hDlg, DWLP_USER );

    switch (uMsg) 
	{
    case WM_INITDIALOG:
        ppi = (PPRGINFO)lParam;
        SetWindowLongPtr(hDlg, DWLP_USER, lParam);
        InitNtPifDlg(hDlg, ppi);
        break;

    case WM_DESTROY:
        SetWindowLongPtr(hDlg, DWLP_USER, 0);
        break;

    HELP_CASES(rgdwNTHelp)               // handle help messages

    case WM_COMMAND:
        switch (LOWORD(wParam)) {

        case IDOK:
        case IDC_OK:
            ApplyNtPifDlg(hDlg, ppi);
            // fall through

        case IDCANCEL:
        case IDC_CANCEL :
            EndDialog(hDlg, 0);
            return FALSE;               // return 0 if we process WM_COMMAND

        case IDC_NTTIMER:
            CheckDlgButton(hDlg, IDC_NTTIMER, !IsDlgButtonChecked(hDlg, IDC_NTTIMER));
            break;
        }
        break;

    default:
        return(FALSE);

    }
    return(TRUE);
}


WORD InitNtPifDlg(HWND hDlg, register PPRGINFO ppi)
{
    PROPNT31 nt31;
    PPROPLINK ppl = ppi->ppl;
    FunctionName(InitAdvPrgDlg);

    ASSERTTRUE(ppl->iSig == PROP_SIG);

    if (!PifMgr_GetProperties(ppl, MAKELP(0,GROUP_NT31),
                        &nt31, SIZEOF(nt31), GETPROPS_NONE)
       ) {
        Warning(hDlg, IDS_QUERY_ERROR, MB_ICONEXCLAMATION | MB_OK);
        return 0;
    }

    // initialize the DLG controls
    SetDlgItemTextA( hDlg, IDC_CONFIGNT, nt31.achConfigFile );
    SetDlgItemTextA( hDlg, IDC_AUTOEXECNT, nt31.achAutoexecFile );

    if (nt31.dwWNTFlags & COMPAT_TIMERTIC)
        CheckDlgButton( hDlg, IDC_NTTIMER, 1 );
    else
        CheckDlgButton( hDlg, IDC_NTTIMER, 0 );

    SHAutoComplete(GetDlgItem(hDlg, IDC_AUTOEXECNT), 0);
    SHAutoComplete(GetDlgItem(hDlg, IDC_CONFIGNT), 0);
    return 0;
}


void ApplyNtPifDlg( HWND hDlg, PPRGINFO ppi )
{
    PROPNT31 nt31;
    PPROPLINK ppl = ppi->ppl;

    ASSERTTRUE(ppl->iSig == PROP_SIG);

    // Get current set of properties, then overlay new settings

    if (!PifMgr_GetProperties(ppl, MAKELP(0,GROUP_NT31),
                        &nt31, SIZEOF(nt31), GETPROPS_NONE)
       ) {
        Warning(hDlg, IDS_UPDATE_ERROR, MB_ICONEXCLAMATION | MB_OK);
        return;
    }

    GetDlgItemTextA( hDlg,
                     IDC_CONFIGNT,
                     nt31.achConfigFile,
                     ARRAYSIZE( nt31.achConfigFile )
                    );
    GetDlgItemTextA( hDlg,
                     IDC_AUTOEXECNT,
                     nt31.achAutoexecFile,
                     ARRAYSIZE( nt31.achAutoexecFile )
                    );

    nt31.dwWNTFlags &= (~COMPAT_TIMERTIC);
    if (IsDlgButtonChecked( hDlg, IDC_NTTIMER ))
        nt31.dwWNTFlags |= COMPAT_TIMERTIC;


    if (!PifMgr_SetProperties(ppl, MAKELP(0,GROUP_NT31),
                        &nt31, SIZEOF(nt31), SETPROPS_NONE)) {
        Warning(hDlg, IDS_UPDATE_ERROR, MB_ICONEXCLAMATION | MB_OK);
    }
    if (ppl->hwndNotify) {
        PostMessage(ppl->hwndNotify, ppl->uMsgNotify, SIZEOF(nt31), (LPARAM)MAKELP(0,GROUP_NT31));
    }


}


HICON LoadPIFIcon(LPPROPPRG lpprg, LPPROPNT40 lpnt40)
{
    HICON hIcon = NULL;
    WCHAR awchTmp[ MAX_PATH ];

    ualstrcpy( awchTmp, lpnt40->awchIconFile );
    PifMgr_WCtoMBPath( awchTmp, lpprg->achIconFile, ARRAYSIZE(lpprg->achIconFile) );
    hIcon = ExtractIcon(HINST_THISDLL, awchTmp, lpprg->wIconIndex);
    if ((DWORD_PTR)hIcon <= 1) {         // 0 means none, 1 means bad file
        hIcon = NULL;
    }
    return hIcon;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\pifmgr.c ===
/*
 *  Microsoft Confidential
 *  Copyright (C) Microsoft Corporation 1991
 *  All Rights Reserved.
 *
 *
 *  PIFMGR.C
 *  Main module for PIFMGR.DLL
 *
 *  History:
 *  Created 31-Jul-1992 3:30pm by Jeff Parsons
 *
 *  Exported Program Information File (PIF) Manager services:
 *
 *      PifMgr_OpenProperties()
 *          Give it the name of an DOS application (com, exe, or bat),
 *          and it will open the PIF associated with that application
 *          and return a "handle" to the app's "properties".  Use this
 *          handle when calling any of the other "properties" services (ie,
 *          Get, Set, and Close).
 *
 *          If no PIF exists, it will still allocate a PIF data block
 *          in memory and initialize it, either with data from _DEFAULT.PIF
 *          or its internal defaults.  It will also construct the PIF name
 *          it was looking for but couldn')t find and save that in its internal
 *          PIF data structure, so that if PifMgr_SetProperties is ever called, the
 *          data can be saved to disk.
 *
 *      PifMgr_GetProperties()
 *          Returns the specified block of data from the associated PIF.
 *          If it is a "named" block, it must be the name of a linked
 *          extension inside the PIF, which can be any predefined name
 *          (eg, "WINDOWS 386 3.0") or the name of your own block.  You can
 *          create your own named data blocks using the PifMgr_SetProperties()
 *          service.  "Named" data can also be thought of as "raw" data,
 *          because it is returned to the caller as-is -- without translation.
 *
 *          The size of a named block can be determined by calling
 *          PifMgr_GetProperties with a size of zero; no data is copied, but the size
 *          of the requested block is returned (0 if not found).
 *
 *          All named blocks can be enumerated by passing NULL for the name,
 *          a pointer to a 16-byte buffer for the requested block name, and a
 *          0-based block index in the size parameter.  The size returned
 *          is the size of the block (0 if none).
 *
 *          If an unnamed property block is requested (ie, the selector of
 *          the name parameter is NULL, and the offset is a property group
 *          ordinal), then the associated structure is returned.  For example,
 *          PifMgr_GetProperties(GROUP_TSK) returns a predefined structure (see
 *          PROPTSK in PIF.H) containing all the tasking-related information,
 *          in a format that is PIF-independent.  This is a valuable service,
 *          because it relieves callers from having to cope with PIFs
 *          containing a wide variety of sections (known as PIF extensions),
 *          only one of which is required.  Think of this as "cooked" data.
 *
 *          A third variation is raw read/write of the entire PIF data block,
 *          if lpszGroup is NULL.  This must be used with extreme caution, and
 *          will only be allowed if the properties were opened with the
 *          OPENPROPS_RAWIO flag specified.
 *
 *      PifMgr_SetProperties()
 *          This is pretty much the opposite of PifMgr_GetProperties, except that it
 *          also takes a flags parameter that can specify that the changes
 *          be made immediately, or deferred to PifMgr_CloseProperties.
 *
 *      PifMgr_CloseProperties()
 *          Flushes any dirty PIF data in memory, and frees the local heap
 *          storage.
 *
 */

#include "shellprv.h"
#pragma hdrstop

/* Global R/W DLL data
 */

PPROPLINK g_pplHead;              // pointer to first prop entry
HANDLE    g_offHighestPropLink;     // highest offset of a prop thus far recorded

TCHAR g_szNone[16];                // initialized by LibMainP,
TCHAR g_szAuto[16];                // and 16 chars to allow for localization

char g_szMSDOSSTSFile[] = "C:\\MSDOSSYS.STS";

TCHAR g_szConfigFile[] = TEXT("C:") CONFIGFILE;
TCHAR g_szAutoexecFile[] = TEXT("C:") AUTOEXECFILE;

TCHAR g_szMConfigFile[] = TEXT("C:") MCONFIGFILE;
TCHAR g_szMAutoexecFile[] = TEXT("C:") MAUTOEXECFILE;

TCHAR g_szWConfigFile[] = TEXT("C:") WCONFIGFILE;
TCHAR g_szWAutoexecFile[] = TEXT("C:") WAUTOEXECFILE;

#ifdef DBCS
char ImeBatchFile[] = "DOSIME\0";
#endif

#define NT_CONFIG_FILE "%SystemRoot%\\SYSTEM32\\CONFIG.NT"
#define NT_AUTOEXEC_FILE "%SystemRoot%\\SYSTEM32\\AUTOEXEC.NT"

#define LPPH_OFF(off) ((LPBYTE)lpph + off)
#define LPPIF_FIELDOFF(off) ((LPBYTE)ppl->lpPIFData + FIELD_OFFSET(PIFDATA,off))
#define LPPIF_OFF(off) ((LPBYTE)ppl->lpPIFData + off)

//
//  g_szDefaultPIF can be in one of three states:
//
//  1.  "_DEFAULT.PIF", which means that we have never needed to search
//          for a _default.pif yet.  The next time we need to locate
//          _default.pif, we must perform a full search.  On success,
//          move to state 2.  On failure, move to state 3.
//
//  2.  A fully-qualified path to _default.pif, which means that we have
//          searched for a _default.pif and found it in the specified
//          location.  The next time we need to locate _default.pif, we
//          will look here.  If found, remain in state 2, else move to
//          state 3.
//
//  3.  The null string, which means that we searched for a _default.pif
//          and didn't find one.  The next time we need to locate
//          _default.pif, we just fail without even looking on the disk.
//          (This is the common case for a clean install.)
//
//      Note that all the cases are "sticky"; once you reach a state, you
//      can never move back to a previous state.  This sacrifices flexibility
//      for performance.
//
//      The macro fTryDefaultPif() returns nonzero if we are in cases
//      1 or 2.
//
//      The macro fDefaultPifFound() returns nonzero if we are in case 2.
//
//  WARNING!  WARNING!  WARNING!  WARNING!
//
//      Evil hack relies on the fact that the three states can be
//      distinguished by the first character of g_szDefaultPIF, which
//      in turn relies on the fact that `_' cannot be the first character
//      of a fully-qualified path.  (It is not a valid drive letter,
//      and it cannot start a UNC.)
//
//

#define INIT_INIDATA                0x01
#define INIT_PIFDIR                 0x02

CHAR     fbInit = 0;                    // see INIT_* flags
INT      iPIFName = (12*sizeof(TCHAR)); // strlen(g_szPIFDir)
INT      iWinName = (12*sizeof(TCHAR)); // strlen(g_szPIFDir)
TCHAR    g_szPIFDir[MAXPATHNAME]     = TEXT("\\WINDOWS\\PIF");
TCHAR    g_szDefaultPIF[MAXPATHNAME] = TEXT("_DEFAULT.PIF");

#define fTryDefaultPif()            g_szDefaultPIF[0]
#define fDefaultPifFound()          (g_szDefaultPIF[0] != TEXT('_'))

//
// szComspec is the name of the COMSPEC program, usually "COMMAND.COM"
// or "CMD.EXE".
//
TCHAR   szComspec[8+1+3+1];

/* Global R/O DLL data
 */

extern const TCHAR c_szNULL[];              // A string so nice...

const TCHAR szZero[]            = TEXT("0");

const int acbData[] = {
                sizeof(PROPPRG),
                sizeof(PROPTSK),
                sizeof(PROPVID),
                sizeof(PROPMEM),
                sizeof(PROPKBD),
                sizeof(PROPMSE),
                sizeof(PROPSND),
                sizeof(PROPFNT),
                sizeof(PROPWIN),
                sizeof(PROPENV),
                sizeof(PROPNT31),
                sizeof(PROPNT40),
};

/*
 * The casts are used because we intentionally mis-prototyped the GetXxxData
 * and SetXxxData functions to receive their third argument as a LPXXX instead
 * of a LPVOID.
 */

const DATAGETFN afnGetData[] = {
                (DATAGETFN)GetPrgData,
                (DATAGETFN)GetTskData,
                (DATAGETFN)GetVidData,
                (DATAGETFN)GetMemData,
                (DATAGETFN)GetKbdData,
                (DATAGETFN)GetMseData,
                (DATAGETFN)GetSndData,
                (DATAGETFN)GetFntData,
                (DATAGETFN)GetWinData,
                (DATAGETFN)GetEnvData,
                (DATAGETFN)GetNt31Data,
                (DATAGETFN)GetNt40Data,
};

const DATASETFN afnSetData[] = {
                (DATASETFN)SetPrgData,
                (DATASETFN)SetTskData,
                (DATASETFN)SetVidData,
                (DATASETFN)SetMemData,
                (DATASETFN)SetKbdData,
                (DATASETFN)SetMseData,
                (DATASETFN)SetSndData,
                (DATASETFN)SetFntData,
                (DATASETFN)SetWinData,
                (DATASETFN)SetEnvData,
                (DATASETFN)SetNt31Data,
                (DATASETFN)SetNt40Data,
};


// WIN.INI things of interest
// Note: some of these NEED to be ANSI strings, and other TCHAR
// strings.  Please do not arbitrarily change the type casts of
// these strings!!!! (RickTu)


const TCHAR szMemory[]              = TEXT("MEMORY");
const TCHAR szComp[]                = TEXT("COMPATIBLE");

CHAR szSingle[]                     = "DOS=SINGLE\r\n";
CHAR szCRLF[]                       = "\r\n";
CHAR szEcho[]                       = "ECHO ";
CHAR szPause[]                      = "\r\nPAUSE\r\n";
CHAR szCall[]                       = "CALL ";
CHAR szCD[]                         = "CD ";
CHAR szWin[]                        = "WIN";

// SYSTEM.INI things of interest

const TCHAR szSystemINI[]           = TEXT("SYSTEM.INI");
const TCHAR sz386EnhSection[]       = TEXT("386Enh");
const TCHAR szWOAFontKey[]          = TEXT("WOAFont");
const TCHAR szWOADBCSFontKey[]      = TEXT("WOADBCSFont");
const TCHAR szNonWinSection[]       = TEXT("NonWindowsApp");
const TCHAR szTTInitialSizes[]      = TEXT("TTInitialSizes");
#ifdef  CUSTOMIZABLE_HEURISTICS
const TCHAR szTTHeuristics[]        = TEXT("TTHeuristics");
const TCHAR szTTNonAspectMin[]      = TEXT("TTNonAspectMin");
#endif
TCHAR szTTCacheSection[2][32] = {TEXT("TTFontDimenCache"), TEXT("TTFontDimenCacheDBCS")};

//
// These are because they are accessed only when we need to create
// a new PIF file or convert a 3.1 PIF file into a 4.0 PIF file.
//
const TCHAR szDOSAPPINI[]           = TEXT("DOSAPP.INI");
const TCHAR szDOSAPPSection[]       = TEXT("DOS Applications");
const TCHAR szDOSAPPDefault[]       = TEXT("Default");

const TCHAR szDisplay[]             = TEXT("DISPLAY");
const TCHAR szDefIconFile[]         = ICONFILE_DEFAULT;

const TCHAR szDotExe[]              = TEXT(".EXE");
const TCHAR szDotCom[]              = TEXT(".COM");
const TCHAR szDotBat[]              = TEXT(".BAT");
const TCHAR szDotPif[]              = TEXT(".PIF");
const TCHAR szDotCmd[]              = TEXT(".CMD");
const TCHAR * apszAppType[] =  {
    szDotExe, szDotCom, szDotBat, szDotCmd, szDotPif
};

CHAR szSTDHDRSIG[]                  = STDHDRSIG;
CHAR szW286HDRSIG30[]               = W286HDRSIG30;
CHAR szW386HDRSIG30[]               = W386HDRSIG30;
CHAR szWENHHDRSIG40[]               = WENHHDRSIG40;
CHAR szWNTHDRSIG31[]                = WNTHDRSIG31;
CHAR szWNTHDRSIG40[]                = WNTHDRSIG40;

CHAR szCONFIGHDRSIG40[]             = CONFIGHDRSIG40;
CHAR szAUTOEXECHDRSIG40[]           = AUTOEXECHDRSIG40;
const TCHAR szRunOnceKey[]          = REGSTR_PATH_RUNONCE;

const TCHAR szPIFConvert[]          = TEXT("PIFConvert");
const TCHAR szPIFConvertExe[]       = TEXT("RUNDLL.EXE PIFMGR.DLL,ProcessStartupProperties");
const TCHAR szPIFConvertKey[]       = REGSTR_PATH_PIFCONVERT;
const TCHAR szMSDOSMode[]           = REGSTR_VAL_MSDOSMODE;
const TCHAR szMSDOSModeDiscard[]    = REGSTR_VAL_MSDOSMODEDISCARD;


// wsprintf formatting strings
const TCHAR szDotPercent03d[]       = TEXT(".%03d");

// miscellaneous hack-o-ramas
const TCHAR szPP4[]                 = TEXT("PP4");      // MS Powerpoint 4.0

PROPTSK tskDefault          ={TSK_DEFAULT,
                              TSKINIT_DEFAULT,
                              TSKFGNDBOOST_DEFAULT,
                              TSKBGNDBOOST_DEFAULT,
                              0,
                              0,
                              TSKIDLESENS_DEFAULT,
};

PROPVID vidDefault          ={VID_DEFAULT,
                              VIDINIT_DEFAULT,
                              0,
                              0,
                              0,
};

PROPMEM memDefault          ={MEM_DEFAULT,
                              MEMINIT_DEFAULT,
                              MEMLOW_DEFAULT,   // ignore stdpifdata.minmem?
                              MEMLOW_MAX,       // ignore stdpifdata.maxmem?
                              MEMEMS_DEFAULT,
                              MEMEMS_MAX,
                              MEMXMS_DEFAULT,
                              MEMXMS_MAX,
};

PROPKBD kbdDefault          ={KBD_DEFAULT,
                              KBDINIT_DEFAULT,
                              KBDALTDELAY_DEFAULT,
                              KBDALTPASTEDELAY_DEFAULT,
                              KBDPASTEDELAY_DEFAULT,
                              KBDPASTEFULLDELAY_DEFAULT,
                              KBDPASTETIMEOUT_DEFAULT,
                              KBDPASTESKIP_DEFAULT,
                              KBDPASTECRSKIP_DEFAULT,
};

PROPMSE mseDefault          ={MSE_DEFAULT,
                              MSEINIT_DEFAULT,
};

PROPENV envDefault          ={ENV_DEFAULT,
                              ENVINIT_DEFAULT,
                              "",
                              ENVSIZE_DEFAULT,
                              ENVDPMI_DEFAULT,
};

WORD    flWinDefault        = WIN_DEFAULT;

/*
 * Default face name to use for Raster fonts.  Currently, this is
 * just a hard-coded value (ie, not maintained in any INI file).
 */
CHAR    szRasterFaceName[LF_FACESIZE] = "Terminal";


/*
 * Default face name to use for TrueType fonts.  It must be a monospace
 * font, and it must be a font that everyone is guaranteed to have.  Currently,
 * this can be changed by setting TTFont in [NonWindowsApp] in SYSTEM.INI.
 */
// now this is initialized with string resource. The 2nd element will get
// the native typeface for the bilingual dos prompt
CHAR    szTTFaceName[2][LF_FACESIZE] = {"Lucida Console", "Courier New"};

const TCHAR szAltKeyDelay        [] = TEXT("AltKeyDelay");
const TCHAR szAltPasteDelay      [] = TEXT("AltPasteDelay");
const TCHAR szKeyPasteDelay      [] = TEXT("KeyPasteDelay");
const TCHAR szKeyBufferDelay     [] = TEXT("KeyBufferDelay");
const TCHAR szKeyPasteTimeout    [] = TEXT("KeyPasteTimeout");
const TCHAR szKeyPasteSkipCount  [] = TEXT("KeyPasteSkipCount");
const TCHAR szKeyPasteCRSkipCount[] = TEXT("KeyPasteCRSkipCount");
const TCHAR szMouseInDosBox      [] = TEXT("MouseInDosBox");
const TCHAR szDisablePositionSave[] = TEXT("DisablePositionSave");
const TCHAR szDOSPromptExitInst  [] = TEXT("DOSPromptExitInstruc");
const TCHAR szCommandEnvSize     [] = TEXT("CommandEnvSize");
const TCHAR szScreenLines        [] = TEXT("ScreenLines");

const INIDATA aINIData[] = {
    {sz386EnhSection,   szAltKeyDelay,          &kbdDefault.msAltDelay,      INIDATA_FIXEDPOINT},
    {sz386EnhSection,   szAltPasteDelay,        &kbdDefault.msAltPasteDelay, INIDATA_FIXEDPOINT},
    {sz386EnhSection,   szKeyPasteDelay,        &kbdDefault.msPasteDelay,    INIDATA_FIXEDPOINT},
    {sz386EnhSection,   szKeyBufferDelay,       &kbdDefault.msPasteFullDelay,INIDATA_FIXEDPOINT},
    {sz386EnhSection,   szKeyPasteTimeout,      &kbdDefault.msPasteTimeout,  INIDATA_FIXEDPOINT},
    {sz386EnhSection,   szKeyPasteSkipCount,    &kbdDefault.cPasteSkip,      INIDATA_DECINT},
    {sz386EnhSection,   szKeyPasteCRSkipCount,  &kbdDefault.cPasteCRSkip,    INIDATA_DECINT},
    {szNonWinSection,   szMouseInDosBox,        &mseDefault.flMse,           INIDATA_BOOLEAN,  MSE_WINDOWENABLE},
    {szNonWinSection,   szDisablePositionSave,  &flWinDefault,               INIDATA_BOOLEAN | INIDATA_INVERT,  WIN_SAVESETTINGS},
#ifdef ENVINIT_INSTRUCTIONS
    {sz386EnhSection,   szDOSPromptExitInst,    &envDefault.flEnvInit,       INIDATA_BOOLEAN,  ENVINIT_INSTRUCTIONS},
#endif
    {szNonWinSection,   szCommandEnvSize,       &envDefault.cbEnvironment,   INIDATA_DECINT},
    {szNonWinSection,   szScreenLines,          &vidDefault.cScreenLines,    INIDATA_DECINT},
};

/**************************************************************************
 *
 *  OVERVIEW OF INI FILE USAGE
 *
 *
 *  SYSTEM.INI
 *
 *  [386Enh]
 *
 *  WOAFont=<fon filename>
 *
 *  Status:     Public
 *  Default:    dosapp.fon
 *  Purpose:
 *
 *      This setting allows the user to specify which Terminal font
 *      file should be loaded when DOS box is started.
 *
 *  To change:
 *
 *      Use Notepad to edit the SYSTEM.INI file.
 *
 *
 *  [NonWindowsApp]
 *
 *  DisablePositionSave=<Boolean>
 *
 *  Status:     Public
 *  Default:    0 (FALSE)
 *  Purpose:
 *
 *      When FALSE, the position and font used in a non-Windows
 *      application is saved in the application's PIF file when
 *      you exit the application.  When TRUE, the position, fonts, and
 *      toolbar state of a non-Windows application whose settings
 *      have not been previously saved in the DOSAPP.INI file will
 *      not be saved.
 *
 *      If enabled, the setting can be overridden for each
 *      non-Windows application by selecting the Save Settings On
 *      Exit check box in the Font dialog box.
 *
 *  To change:
 *
 *      Use Notepad to edit the SYSTEM.INI file.
 *
 *  Compatibility notes:
 *
 *      In Windows 3.x, the "position save" (and font) information was
 *      saved in DOSAPP.INI, and although we will still read DOSAPP.INI
 *      in the absence of any information in the PIF file, we only *write*
 *      settings back to the PIF file.  DOSAPP.INI should be considered
 *      obsolete.
 *
 *
 *  TTFont=<fontname>
 *
 *  Status:     ?
 *  Default:    Courier New     // FEATURE -- this should be a TT OEM font
 *  Purpose:
 *
 *      This setting allows the user to specify which TrueType font
 *      will be used in a DOS box.  It must be an OEM font.
 *
 *  To change:
 *
 *      Use Notepad to edit the SYSTEM.INI file.
 *
 *
 *  TTInitialSizes=<i1 i2 i3 i4 ... i16>
 *
 *  Status:     ?
 *  Default:    4 5 6 7 8 9 10 11 12 14 16 18 20 22 36 72
 *  Purpose:
 *
 *      This setting allows the user to specify which font sizes
 *      WinOldAp initially builds for the TrueType fonts in a DOS
 *      application window.
 *
 *      At most 16 font sizes can be requested.
 *
 *      Note that this INI entry is consulted only the first time
 *      Windows is restarted after changing video drivers or fonts.
 *
 *  To change:
 *
 *      Use Notepad to edit the SYSTEM.INI file.
 *
 *
 *  TTHeuristics=<i1 i2 i3 i4 i5 i6 i7 i8 i9>
 *
 *  Status:     Public
 *  Default:    5000 1000 0 1000 5000 1000 0 1000 1
 *  Purpose:
 *
 *      These integers control the way Windows chooses the font to
 *      display for DOS applications running inside a window if you
 *      have chosen "Auto" as the font size.
 *
 *      The parameters are named as follows:
 *
 *          i1=XOvershootInitial
 *          i2=XOvershootScale
 *          i3=XShortfallInitial
 *          i4=XShortfallScale
 *          i5=YOvershootInitial
 *          i6=YOvershootScale
 *          i7=YShortfallInitial
 *          i8=YShortfallScale
 *          i9=TrueTypePenalty
 *
 *      Each penalty value may not exceed 5000.
 *
 *      When Windows needs to select a font for use in a DOS
 *      application's window, it goes through the list of font
 *      sizes available and computes the "penalty" associated
 *      with using that font.  Windows then selects the font with
 *      the smallest penalty.
 *
 *      The horizontal penalty is computed as follows:
 *
 *          Let dxActual = <actual window width>
 *          Let dxDesired = <font width> * <characters per line>
 *
 *          If dxActual = dxDesired:
 *              xPenalty = 0
 *          If dxActual < dxDesired:
 *              Let Ratio = 1 - dxDesired / dxActual
 *              xPenalty = XOvershootInitial + Ratio * XOvershootScale
 *          If dxActual > dxDesired:
 *              Let Ratio = 1 - dxActual / dxDesired
 *              xPenalty = XShortfallInitial + Ratio * XShortfallScale
 *
 *      The vertical penalty is computed similarly.
 *
 *      Note that the Ratio is always a fraction between 0 and 1.
 *
 *      The penalty associated with a font is the sum of the vertical
 *      and horizontal penalties, plus the TrueTypePenalty if the font
 *      is a TrueType font.
 *
 *      The default value of 1 for the TrueTypePenalty means that,
 *      all other things being equal, Windows will select a raster
 *      font in preference to a TrueType font.  You can set this
 *      value to -1 if you wish the opposite preference.
 *
 *  To change:
 *
 *      Use Notepad to edit the SYSTEM.INI file.
 *
 *  Internals:
 *
 *      Even though floating point appears in the computations,
 *      everything is really done in integer arithmetic.
 *
 *      Pixels are NEVER MENTIONED anywhere in the penalty computations.
 *      (All pixel values are divided by other pixel values, so that
 *      we get a dimensionless number as a result.)
 *      This keeps us independent of the display resolution as well
 *      as the display aspect ratio.
 *
 *      Since the stretch and shrink are taken as fractions of the
 *      larger dimension, this keeps us from penalizing large
 *      differences by too much.  This is important because there
 *      isn't much visible difference between being ten times too
 *      big and being eleven times too big, but there is a big
 *      difference between being just right and being twice as big.
 *
 *      We must be careful not to let the maximum possible penalty
 *      exceed 32767.  This is done by making sure that each
 *      dimension cannot produce a penalty of greater than 10000
 *      (5000+5000), and that the TrueTypePenalty is at most 5000.
 *      This makes the maximum possible penalty 25000.
 *      This range checking is done by FontSelInit.
 *
 *
 *  TTNonAspectMin=<x y>
 *
 *  Status:     Public
 *  Default:    3 3
 *  Purpose:
 *
 *      These integers control the minimum width and height font that
 *      Windows will attempt to create automatically in response to a
 *      resize operation when TrueType fonts in DOS boxes are enabled
 *      and the "Auto" font size is selected.
 *
 *      These values prevent Windows from creating visually useless
 *      fonts like 10 x 1 or 1 x 10.  The default values prevent Windows
 *      from trying to create X x Y fonts if X < 3 or Y < 3.
 *
 *      TTNonAspectMin is not consulted if the font is being created at
 *      its default aspect ratio.  In other words, Windows will create,
 *      for example, a 1 x 3 font, if 1 x 3 is the standard aspect ratio
 *      for a 3-pixel-high font.
 *
 *      To permit all aspect ratios, set the values to "0 0".
 *
 *      To forbid all aspect ratios except for the standard aspect ratio,
 *      set the values to "-1 -1".
 *
 *  [TTFontDimenCache]
 *
 *  dxWidthRequested dyHeightRequested=dxWidthActual dyWidthActual
 *
 *  Status:     Private
 *  Default:    Null
 *  Purpose:
 *
 *      The [FontDimenCache] section contains information about
 *      TrueType font sizes that have been created.  Each entry
 *      has as the keyname the width and height that were passed
 *      to CreateFont and has as the value the width and height of
 *      the font that was actually created.
 *
 *  Internals:
 *
 *      Inspected by AddTrueTypeFontsToFontList.
 *      Set by AddOneNewTrueTypeFontToFontList.
 *
 *
 **************************************************************************
 *
 *  DOSAPP.INI (obsolete, supported on a read-only basis)
 *
 *  [Dos Applications]
 *
 *  C:\FULL\PATH\TO\EXE\COM\BAT\OR.PIF=<wFlags wFontWidth wFontHeight
 *          wWinWidth wWinHeight length flags showCmd ptMinPositionX
 *          ptMinPositionY ptMaxPositionX ptMaxPositionY
 *          rcNormalLeft rcNormalTop rcNormalRight rcNormalBottom>
 *
 *  Status:     Private
 *  Purpose:
 *
 *      These values are used to restore a DOS application's window
 *      to the state it was in when the DOS app last exited normally.
 *
 *      The values are taken directly from the INIINFO structure, qv.
 *
 *      The values of ptMinPositionX and ptMinPositionY are always -1,
 *      since we do not try to preserve the icon position.
 *
 *      If wFontHeight has the high bit set, then the font that
 *      should be used is a TrueType font.
 *
 *      If wFontWidth = 1 and wFontHeight = -1, then
 *      Auto-font-selection is active.
 *
 *  Compatibility notes:
 *
 *      In Windows 3.x, the "position save" (and font) information was
 *      saved in DOSAPP.INI, and although we will still read DOSAPP.INI
 *      in the absence of any information in the PIF file, we only *write*
 *      settings back to the PIF file.  DOSAPP.INI should be considered
 *      obsolete.
 *
 *
 **************************************************************************
 *
 * THE NEXT INI VAR IS NOT IMPLEMENTED BUT SHOULD BE
 *
 **************************************************************************
 *
 *  SYSTEM.INI
 *
 *  [NonWindowsApp]
 *
 *  TTFontTolerance=<i>
 *
 *  Status:     Public
 *  Default:    200
 *  Purpose:
 *
 *      This setting indicates how large a penalty (see TTHeuristics)
 *      Windows should tolerate before trying to synthesize new font
 *      sizes from TrueType fonts.
 *
 *      Decreasing this value will result in a tighter fit of the
 *      Windows-selected font to the actual window size, but at a
 *      cost in speed and memory.
 *
 *  To change:
 *
 *      Use Notepad to edit the SYSTEM.INI file.
 *
 *
 *  Internals:
 *
 *      Inspected by ChooseBestFont, if implemented.
 *
 **************************************************************************/



void PifMgrDLL_Init()
{
    static BOOL fInit = FALSE;
    if (!fInit)
    {
        LoadString(g_hinst, IDS_PIF_NONE, g_szNone, ARRAYSIZE(g_szNone));
        LoadString(g_hinst, IDS_AUTONORMAL, g_szAuto, ARRAYSIZE(g_szAuto));
        LoadGlobalFontData();
        fInit = TRUE;
    }
}

void PifMgrDLL_Term()
{
    FreeGlobalFontData();
}


/** GetPIFDir - Form default PIF directory name + name of given file
 *
 * INPUT
 *  None
 *
 * OUTPUT
 *  None
 */

void GetPIFDir(LPTSTR pszName)
{
    int i;
    static const TCHAR szBackslashPIF[] = TEXT("\\PIF");
    FunctionName(GetPIFDir);

    if (!(fbInit & INIT_PIFDIR)) {

        // Set up g_szPIFDir, less space for a filename, less space for \PIF

        i = ARRAYSIZE(g_szPIFDir)-lstrlen(pszName)-ARRAYSIZE(szBackslashPIF);
        if (i <= 0)                         // sanity check
            return;

        GetWindowsDirectory(g_szPIFDir, i);
        iPIFName = lstrlen(g_szPIFDir);
        if (StrRChr(g_szPIFDir, NULL, TEXT('\\')) == &g_szPIFDir[iPIFName-1])
            iPIFName--;
        iWinName = iPIFName;

        lstrcpy(g_szPIFDir+iPIFName, szBackslashPIF);
        iPIFName += ARRAYSIZE(szBackslashPIF)-1;

        i = (int)GetFileAttributes(g_szPIFDir);

        if (i == -1) {

            // It didn't exist, so try to create it (returns TRUE if success)

            i = CreateDirectory(g_szPIFDir, NULL);
            if (i)
                SetFileAttributes(g_szPIFDir, FILE_ATTRIBUTE_HIDDEN);
        }
        else if (i & FILE_ATTRIBUTE_DIRECTORY)
            i = TRUE;                       // directory already exists, cool!
        else
            i = FALSE;                      // some sort of file is in the way...

        if (i) {
            g_szPIFDir[iPIFName++] = TEXT('\\');    // append the slash we'll need
                                            // to separate future filenames (the
                                            // space after is already zero-init'ed)
        }
        else                                // we'll just have to use the Windows dir
            iPIFName -= ARRAYSIZE(szBackslashPIF)-2;

        fbInit |= INIT_PIFDIR;
    }

    // Now initialize g_szPIFDir with the name of the file we're processing

    if (pszName)
        lstrcpyn(g_szPIFDir+iPIFName, pszName, ARRAYSIZE(g_szPIFDir)-iPIFName);
}

/** GetINIData - Read WIN.INI/SYSTEM.INI/DOSAPP.INI for default settings
 *
 * INPUT
 *  Nothing
 *
 * OUTPUT
 *  Nothing; global defaults (re)set
 *
 * NOTES
 *  We only do this work now if GetPIFData couldn't open a PIF file, or
 *  could but it contained no enhanced section.  And we never do it more than
 *  once per fresh load of this DLL.
 */

void GetINIData()
{
    int t;
    const INIDATA *pid;
    LPCTSTR lpsz;
    DWORD dwRet;
    TCHAR szTemp[MAX_PATH];
    FunctionName(GetINIData);

    if (fbInit & INIT_INIDATA)          // if already done
        return;                         // then go away

    for (pid=aINIData; pid-aINIData < ARRAYSIZE(aINIData); pid++) {

        t = *(INT UNALIGNED *)pid->pValue;
        if (pid->iFlags & (INIDATA_DECINT | INIDATA_BOOLEAN)) {

            if (pid->iFlags & INIDATA_BOOLEAN) {
                t &= pid->iMask;
                if (pid->iFlags & INIDATA_INVERT)
                    t ^= pid->iMask;
            }
            t = GetPrivateProfileInt(pid->pszSection,
                                     pid->pszKey,
                                     t,
                                     szSystemINI);
            if (pid->iFlags & INIDATA_BOOLEAN) {
                if (t)
                    t = pid->iMask;
                if (pid->iFlags & INIDATA_INVERT)
                    t ^= pid->iMask;
                t |= *(INT UNALIGNED *)pid->pValue & ~pid->iMask;
            }
            *(INT UNALIGNED *)pid->pValue = t;
        }
        else
        if (pid->iFlags & INIDATA_FIXEDPOINT) {
            wsprintf(szTemp, szDotPercent03d, t);
            GetPrivateProfileString(pid->pszSection,
                                    pid->pszKey,
                                    szTemp,
                                    szTemp,
                                    ARRAYSIZE(szTemp),
                                    szSystemINI);
            *(INT UNALIGNED *)pid->pValue = StrToInt(szTemp+1);
        }
        else
            ASSERTFAIL();
    }

    //
    // Locate COMSPEC once and for all.
    //
    dwRet = GetEnvironmentVariable(TEXT("COMSPEC"), szTemp, ARRAYSIZE(szTemp));
    if (dwRet < ARRAYSIZE(szTemp) && dwRet > 0)
    {
        lpsz = StrRChr(szTemp, NULL, TEXT('\\'));
        if (lpsz) {
            lstrcpyn(szComspec, lpsz+1, ARRAYSIZE(szComspec));
        }
    }

    fbInit |= INIT_INIDATA;
}

/** InitProperties - initialize new property structure
 *
 * INPUT
 *  ppl -> property
 *  fLocked == TRUE to return data locked, FALSE unlocked
 *
 * OUTPUT
 *  Nothing (if successful, ppl->hPIFData will become non-zero)
 */

void InitProperties(PPROPLINK ppl, BOOL fLocked)
{
    LPSTDPIF lpstd;
    LPW386PIF30 lp386 = NULL;
    CHAR achPathName[ARRAYSIZE(ppl->szPathName)];
    BYTE behavior = 0;
    FunctionName(InitProperties);

    GetINIData();       // make sure we have all the right defaults

    if (ResizePIFData(ppl, sizeof(STDPIF)) != -1) {

        // We're no longer called *only* after a fresh ZERO'd HeapAlloc
        // by ResizePIFData.  We could be getting called because PifMgr_OpenProperties
        // was told to punt on an ambiguous PIF and create new settings.
        // Hence, we always zero-init the buffer ourselves now.

        BZero(ppl->lpPIFData, ppl->cbPIFData);

        lpstd = (LPSTDPIF)ppl->lpPIFData;
        lpstd->id = 0x78;
        PifMgr_WCtoMBPath( ppl->szPathName, achPathName, ARRAYSIZE(achPathName) );
        lstrcpyncharA(lpstd->appname, achPathName+ppl->iFileName, ARRAYSIZE(lpstd->appname), '.');
        CharToOemA(lpstd->appname, lpstd->appname);

        // NOTE: When 3.x Setup creates PIF files, it sets maxmem to 640;
        // that's typically what memDefault.wMaxLow will be too....

        lpstd->minmem = memDefault.wMinLow;
        lpstd->maxmem = (WORD) GetProfileInt(apszAppType[APPTYPE_PIF]+1, szMemory, memDefault.wMaxLow);
        lstrcpynA(lpstd->startfile, achPathName, ARRAYSIZE(lpstd->startfile));
        CharToOemA(lpstd->startfile, lpstd->startfile);

        //
        // New for 4.0:  fDestroy (close on exit) is disabled by default
        // for most apps, but is enabled by default for COMSPEC.
        //
        lpstd->MSflags = 0;
        if (!lstrcmpi(ppl->szPathName+ppl->iFileName, szComspec)) {
            lpstd->MSflags = fDestroy;
        }

        // Initialize various goofy non-zero stuff just to make it
        // look like a backward-compatible PIF file -- not that we use
        // or particularly care about any of it

        // NOTE: When 3.x Setup creates PIF files, it sets screen to 0x7F

        lpstd->cPages = 1;
        lpstd->highVector = 0xFF;
        lpstd->rows = 25;
        lpstd->cols = 80;
        lpstd->sysmem = 0x0007;

        // fFullScreen is no longer default, so only if an explicit
        // COMPATIBLE=FALSE exists in the PIF section of WIN.INI will
        // we set fScreen in behavior and fFullScreen in PfW386Flags
        // Similarly, fDestroy is no longer default, but we'll go
        // back to the old way if the switch tells us to.

        if (!GetProfileInt(apszAppType[APPTYPE_PIF]+1, szComp, TRUE)) {
            lpstd->behavior = behavior = fScreen;
            lpstd->MSflags = fDestroy;
        }

        if (ppl->ckbMem != -1 && ppl->ckbMem != 1)
            lpstd->minmem = lpstd->maxmem = (WORD) ppl->ckbMem;


        if (AddGroupData(ppl, szW386HDRSIG30, NULL, sizeof(W386PIF30))) {
            if (NULL != (lp386 = GetGroupData(ppl, szW386HDRSIG30, NULL, NULL))) {
                lp386->PfW386minmem = lpstd->minmem;
                lp386->PfW386maxmem = lpstd->maxmem;
                lp386->PfFPriority = TSKFGND_OLD_DEFAULT;
                lp386->PfBPriority = TSKBGND_OLD_DEFAULT;
                lp386->PfMinEMMK = memDefault.wMinEMS;
                lp386->PfMaxEMMK = memDefault.wMaxEMS;
                lp386->PfMinXmsK = memDefault.wMinXMS;
                lp386->PfMaxXmsK = memDefault.wMaxXMS;
                lp386->PfW386Flags = fBackground + fPollingDetect + fINT16Paste;
                if (behavior & fScreen)
                    lp386->PfW386Flags |= fFullScreen;
                lp386->PfW386Flags2 = fVidTxtEmulate + fVidNoTrpTxt + fVidNoTrpLRGrfx + fVidNoTrpHRGrfx + fVidTextMd;
            }
        }
        VERIFYTRUE(AddEnhancedData(ppl, lp386));
        if (AddGroupData(ppl, szWNTHDRSIG31, NULL, sizeof(WNTPIF31))) {
            LPWNTPIF31 lpnt31;

            if (NULL != (lpnt31 = GetGroupData(ppl, szWNTHDRSIG31, NULL, NULL))) {
                lstrcpyA( lpnt31->nt31Prop.achConfigFile, NT_CONFIG_FILE );
                lstrcpyA( lpnt31->nt31Prop.achAutoexecFile, NT_AUTOEXEC_FILE );
            }
        }
        VERIFYTRUE(AddGroupData(ppl, szWNTHDRSIG40, NULL, sizeof(WNTPIF40)));

        // Can't be dirty anymore, 'cause we just set everything to defaults

        ppl->flProp &= ~PROP_DIRTY;

        if (!fLocked)
            ppl->cLocks--;
    }
    else
        ASSERTFAIL();
}


/** OpenPIFFile - Wrapper around CreateFile for opening PIF files
 *
 *  The wrapper handles the following things:
 *
 *      Passing the proper access and sharing flags to CreateFile.
 *      Setting pof->nErrCode = 0 on success.
 *      Converting ERROR_PATH_NOT_FOUND to ERROR_FILE_NOT_FOUND.
 *
 * INPUT
 *
 *  pszFile -> name of file to attempt to open
 *  pof -> PIFOFSTRUCT to fill in
 *
 *  OUTPUT
 *
 *  Same return code as CreateFile.
 *
 */

HANDLE OpenPIFFile(LPCTSTR pszFile, LPPIFOFSTRUCT pof)
{
    HANDLE hf;
    TCHAR pszFullFile[ MAX_PATH ];
    LPTSTR pszTheFile;
    DWORD dwRet;

    //
    // CreateFile does not search the path, so do that first, then
    // give CreateFile a fully qualified file name to open...
    //

    dwRet = SearchPath( NULL,
                        pszFile,
                        NULL,
                        ARRAYSIZE(pszFullFile),
                        pszFullFile,
                        &pszTheFile
                       );

    if ((dwRet==0) || (dwRet > ARRAYSIZE(pszFullFile)))
    {
        pszTheFile = (LPTSTR)pszFile;
    }
    else
    {
        pszTheFile = pszFullFile;
    }

    hf = CreateFile( pszTheFile,
                     GENERIC_READ,
                     FILE_SHARE_READ,
                     NULL,
                     OPEN_EXISTING,
                     FILE_ATTRIBUTE_NORMAL,
                     NULL );


    if (hf == INVALID_HANDLE_VALUE)
    {
        pof->nErrCode = GetLastError();
        if (pof->nErrCode == ERROR_PATH_NOT_FOUND)
            pof->nErrCode = ERROR_FILE_NOT_FOUND;
    }
    else
    {
        LPTSTR lpDummy;

        //
        //  NOTE:  Special hack for creating shortcuts.  If the PIF file
        //  that we find is 0 bytes long, pretend we did not find one at all.
        //  This is because appwiz renames a 0 length file from "New shortcut.lnk"
        //  to "appname.pif" and we end up finding it.  We'll ignore this file.
        //

        if (SetFilePointer( hf, 0, NULL, FILE_END) == 0)
        {
            CloseHandle( hf );
            hf = INVALID_HANDLE_VALUE;
            pof->nErrCode = ERROR_FILE_NOT_FOUND;
        }
        else
        {
            LPCTSTR pszNewFile;
            TCHAR szTemp[ ARRAYSIZE(pof->szPathName) ];

            SetFilePointer( hf, 0, NULL, FILE_BEGIN );
            pof->nErrCode = ERROR_SUCCESS;

            // In some cases, people pass in two pointers to the same
            // buffer.  This will hose GetFullPathName, so if they
            // are the same, then make a copy before calling GetFullPathName.
            if (pszTheFile==pof->szPathName) {
                FillMemory( szTemp, sizeof(szTemp), 0 );
                lstrcpy( szTemp, pszTheFile );
                pszNewFile = szTemp;
            }
            else
            {
                pszNewFile = pszTheFile;
            }
            GetFullPathName( pszNewFile, ARRAYSIZE(pof->szPathName),
                             pof->szPathName, &lpDummy );
        }
    }

    return hf;
}


/** PifMgr_OpenProperties - return handle to property info for application
 *
 * INPUT
 *  lpszApp -> name of application
 *  lpszPIF -> name of PIF file to use/create
 *  hInf = Inf handle, 0 if none, -1 to inhibit Inf processing
 *  flOpt = OPENPROPS_RAWIO to allow raw file updates; otherwise, 0
 *
 * OUTPUT
 *  handle to properties, FALSE if could not be opened, or out of memory
 *
 * REMARKS
 *  This should not be thought of as a function that opens a file somewhere
 *  on the disk (although that's usually the effect), but rather as an
 *  property structure allocator that is optionally initialized by disk data
 *  (currently, the file does not even remain open after this call).  So the
 *  main reason for failure in this function will be either a low memory
 *  condition *or* inability to open a specific PIF file.
 *
 *  The rules for PIF file searching are as follows:
 *
 *      If not a .PIF file:
 *          Search in current directory.
 *      Endif.
 *
 *      If path components were specified:
 *          Search in specified directory.
 *      Endif.
 *
 *      Search in PIF directory.
 *      Search the path.
 *
 *  Note that this differs from the Windows 3.1 PIF search algorithm, which
 *  was...
 *
 *      Search current directory.
 *      Search the path.
 *      Search in application directory.
 *
 *  This was a really bogus search order.  Fortunately, it seems that
 *  very few people relied on it.
 *
 *  Things to watch out for when dorking the PIF file search order:
 *
 *      Make sure editing PIF properties from the shell works.  (I.e.,
 *      if a full path to a PIF is given, then use it; don't search.)
 *
 *  Extra special thing to watch out for when dorking the PIF file
 *  search order:
 *
 *      MS Delta execs its child process as follows:
 *
 *          CreatePif("C:\DELTA\DELTABAT.PIF");
 *          SetCurrentDirectory("C:\RANDOM\PLACE");
 *          WinExec("C:\TMP\DELTABAT.BAT", SW_HIDE);
 *
 *      It expects the PIF search to pick up C:\DELTA\DELTABAT.PIF
 *      from the path, even though the WinExec supplied a full path.
 *
 */

HANDLE WINAPI PifMgr_OpenProperties(LPCTSTR lpszApp, LPCTSTR lpszPIF, UINT hInf, UINT flOpt)
{
    PPROPLINK ppl;
    LPTSTR pszExt;
    BOOL fError = FALSE;
    BOOL fFixedDisk = FALSE;
    BOOL fSearchInf = FALSE;
    BOOL fExplicitPIF = FALSE;
    PROPPRG prg;
    PROPNT40 nt40;
    LPTSTR pszName, pszFullName;
#ifdef DBCS
    PROPENV env;
#endif
    FunctionName(PifMgr_OpenProperties);
    // Allocate new prop

    if (!(ppl = (PPROPLINK)LocalAlloc(LPTR, sizeof(PROPLINK))))
        return 0;

    if (!(pszFullName = (LPTSTR)LocalAlloc(LPTR, MAXPATHNAME*sizeof(TCHAR)))) {
        EVAL(LocalFree(ppl) == NULL);
        return 0;
    }

    if ((HANDLE)ppl > g_offHighestPropLink) {
        g_offHighestPropLink = (HANDLE)ppl;

    }

    // Initialize the new prop

    ppl->ppl = ppl;
    ppl->ckbMem = -1;
    ppl->iSig = PROP_SIG;
    ppl->hPIF = INVALID_HANDLE_VALUE;
    if (flOpt & OPENPROPS_RAWIO)
        ppl->flProp |= PROP_RAWIO;

    #if (PRGINIT_INHIBITPIF != PROP_INHIBITPIF)
    #error PRGINIT_INIHIBITPIF and PROP_INHIBITPIF out of sync!
    #endif

    ppl->flProp |= (flOpt & PROP_INHIBITPIF);

    // Link into the global list

    if (NULL != (ppl->pplNext = g_pplHead))
        g_pplHead->pplPrev = ppl;
    g_pplHead = ppl;

    // Copy app name to both temp and perm buffers, and record location
    // of base filename, and extension if any, within the buffer

    lstrcpyn(pszFullName, lpszApp, MAXPATHNAME-4);
    lstrcpyn(ppl->szPathName, pszFullName, ARRAYSIZE(ppl->szPathName));

    if (NULL != (pszName = StrRChr(pszFullName, NULL, TEXT('\\'))) ||
        NULL != (pszName = StrRChr(pszFullName, NULL, TEXT(':'))))
        pszName++;
    else
        pszName = pszFullName;

    if (!(pszExt = StrRChr(pszName, NULL, TEXT('.'))))
        pszExt = pszFullName + lstrlen(pszFullName);

    ppl->iFileName = (UINT) (pszName - pszFullName);
    ppl->iFileExt = (UINT) (pszExt - pszFullName);

    // Check the application's file extension

    if (!*pszExt) {
        lstrcat(pszFullName, apszAppType[APPTYPE_PIF]);
    }
    else if (!lstrcmpi(pszExt, apszAppType[APPTYPE_EXE]) ||
             !lstrcmpi(pszExt, apszAppType[APPTYPE_COM]) ||
             !lstrcmpi(pszExt, apszAppType[APPTYPE_BAT])) {
//             !lstrcmpi(pszExt, apszAppType[APPTYPE_CMD])) {
        lstrcpy(pszExt, apszAppType[APPTYPE_PIF]);
    }
    else if (!lstrcmpi(pszExt, apszAppType[APPTYPE_PIF]))
        fExplicitPIF = TRUE;
    else {
        // Let's disallow random file extensions, since WinOldAp never
        // allowed them either
        goto Error;
    }

    // INFONLY means the caller just wants to search the INF, so ignore
    // any WIN.INI garbage and any PIFs laying around.  We still look for
    // _DEFAULT.PIF, since that code takes care of other important
    // initialization that needs to happen when no PIF was found at all.

    if (flOpt & OPENPROPS_INFONLY)
        goto FindDefault;

    // Backward compatibility requires that if the app is not a PIF,
    // then we must check the PIF section of WIN.INI for an entry matching
    // the base name of the app.  If the entry exists, then we have to skip
    // the PIF search, and pass the value of the entry to InitProperties,
    // which it uses to establish default memory requirements
    //
    // Also note that if IGNOREPIF is set, then ofPIF.szPathName is nothing
    // more than the name of the app that was given to PifMgr_OpenProperties;  this
    // may give us the opportunity to do something more intelligent later...

    if (!fExplicitPIF) {
        ppl->ckbMem = GetProfileInt(apszAppType[APPTYPE_PIF]+1, ppl->szPathName+ppl->iFileName, -1);
        if (ppl->ckbMem != -1) {
            ppl->flProp |= PROP_IGNOREPIF | PROP_SKIPPIF;
            lstrcpyn(ppl->ofPIF.szPathName, lpszApp, ARRAYSIZE(ppl->ofPIF.szPathName));
            goto IgnorePIF;     // entry exists, skip PIF file search
        }
    }

    //
    // Initialize default error return code.  Once we get a successful
    // open, it will be set to zero.
    //
    ppl->flProp |= PROP_NOCREATEPIF;
    ppl->ofPIF.nErrCode = ERROR_FILE_NOT_FOUND;

    //
    // We must search in the current directory if not given a path to a PIF.
    // We need to prefix `.\' to the filename so that OpenFile will not do
    // a path search.
    //
    if (!fExplicitPIF || pszName == pszFullName) {
        //
        // This relies on a feature of OpenFile, that it copies the input
        // buffer to a private buffer before stomping the output buffer,
        // thus permitting precisely the stunt we are pulling here, namely,
        // passing an input buffer equal to the output buffer.
        //
        *(LPDWORD)(ppl->ofPIF.szPathName) = 0x005C002E; /*dot backslash prefix */
        lstrcpyn( &ppl->ofPIF.szPathName[2],
                  pszName,
                  ARRAYSIZE(ppl->ofPIF.szPathName) - 2);
        ppl->hPIF = OpenPIFFile(ppl->ofPIF.szPathName, &ppl->ofPIF);
    }

    //
    // If we were given a path component, then look in that directory.
    // (The fact that we have a backslash or drive letter will suppress
    // the path search.)
    //
    if (pszName != pszFullName && ppl->ofPIF.nErrCode == ERROR_FILE_NOT_FOUND) {

        ppl->hPIF = OpenPIFFile(pszFullName, &ppl->ofPIF);

        // If we didn't find a PIF there, we'd probably still like to create
        // one there if the media is a fixed disk.  Network shares, CD-ROM
        // drives, and floppies are not good targets for PIF files in general.
        //
        // So, if the media is a fixed disk, set the fFixedDisk flag so that
        // we'll leave pszFullName alone.

        if (ppl->hPIF == INVALID_HANDLE_VALUE && pszFullName[1] == TEXT(':')) {
            TCHAR szTemp[4];

            lstrcpyn( szTemp, pszFullName, 4 );

            szTemp[3] = (TCHAR)0;

            if (GetDriveType(szTemp) == DRIVE_FIXED)
                    fFixedDisk++;
        }
    }

    // PERF: replace this PIF dir search with a registry search -JTP
    //
    // Failing that, let's look in the PIF directory.  Again, since we're
    // supplying a full pathname, OpenFile won't try to search the PATH again.

    if (ppl->ofPIF.nErrCode == ERROR_FILE_NOT_FOUND) {
        GetPIFDir(pszName);
        ppl->hPIF = OpenPIFFile(g_szPIFDir, &ppl->ofPIF);
        if (ppl->hPIF != INVALID_HANDLE_VALUE)
            ppl->flProp |= PROP_PIFDIR;
    }

    // If we're still in trouble, our last chance is to do a path
    // search.  This is an unconditional search, thanks to the
    // wonders of MS-Delta.

    if (ppl->ofPIF.nErrCode == ERROR_FILE_NOT_FOUND) {
        ppl->hPIF = OpenPIFFile(pszName, &ppl->ofPIF);
    }

    if (ppl->hPIF == INVALID_HANDLE_VALUE) {

        if (ppl->ofPIF.nErrCode != ERROR_FILE_NOT_FOUND || fExplicitPIF) {

            // Hmmm, file *may* exist, but it cannot be opened;  if it's a
            // strange error, or we were specifically told to open that file,
            // then return error

            goto Error;
        }

    FindDefault:

        fSearchInf = TRUE;
        ppl->flProp &= ~PROP_NOCREATEPIF;

        // Any files we find now are NOT really what we wanted, so save
        // the name we'd like to use in the future, in case we need to save
        // updated properties later.
        //
        // We must save the name now because we might stomp g_szPIFDir while
        // searching for the _default.pif.  Furthermore, we must save it in
        // the buffer we HeapAlloc'ed (pszFullName) temporarily, because
        // the following calls to OpenPIFFile can still stomp on szPathName
        // in our OpenFile structure (ofPIF.szPathName).

        GetPIFDir(pszName);
        if (!fFixedDisk)                        // save desired name in
            lstrcpy(pszFullName, g_szPIFDir);     // temp buffer (pszFullName)

        //
        // Try to locate the _default.pif.
        //

        if (fTryDefaultPif()) {

            if (!fDefaultPifFound()) {          // Must search for it

                // First try PIFDir

                lstrcpy(g_szPIFDir+iPIFName, g_szDefaultPIF);
                ppl->hPIF = OpenPIFFile(g_szPIFDir, &ppl->ofPIF);

                if (ppl->ofPIF.nErrCode == ERROR_FILE_NOT_FOUND) { // try PATH
                    ppl->hPIF = OpenPIFFile(g_szDefaultPIF, &ppl->ofPIF);
                }

            } else {                            // Look in cached path

                // We've already found it once, so just open it

                ppl->hPIF = OpenPIFFile(g_szDefaultPIF, &ppl->ofPIF);
            }
        }

        if (ppl->hPIF != INVALID_HANDLE_VALUE) {

            ppl->flProp |= PROP_DEFAULTPIF;

            // Save the fully-qualified pathname of the default PIF file,
            // so that subsequent OpenFile() calls will be faster (note that
            // we don't specify OF_SEARCH on that particular call)

            lstrcpy(g_szDefaultPIF, ppl->ofPIF.szPathName);
        }
        else {

            // Not only could we not open any sort of PIF, we also need to
            // tell GetPIFData to not bother trying to open the file itself
            // (since it is unlikely someone created one in this short time)

            ppl->flProp |= PROP_NOPIF | PROP_SKIPPIF;

            if (ppl->ofPIF.nErrCode == ERROR_FILE_NOT_FOUND)
                g_szDefaultPIF[0] = 0;            // Invalidate cache.
        }

        // NOW we can set ppl->ofPIF.szPathName to the filename we REALLY
        // wanted, since we're done with all the calls to OpenPIFFile.

        lstrcpy(ppl->ofPIF.szPathName, pszFullName);
    }

    // Initialize the properties by PIF if we have one, by hand if not

  IgnorePIF:

    // We don't need to check the return code from GetPIFData() here,
    // because we validate hPIFData below anyway.  Please also note that
    // this GetPIFData call uses the handle we supplied (if any), and closes
    // it for us when it's done.  Furthermore, if we didn't supply a handle,
    // then we should have set PROP_SKIPPIF, so that GetPIFData won't try to
    // open anything (since we just tried!)

    GetPIFData(ppl, FALSE);

    // Now that the original file from which we obtained settings (if any) is
    // closed, we need to see if the caller wants us to create a new PIF file
    // using a specific name.  If so, force it to be created now.

    if (lpszPIF) {
        lstrcpy(ppl->ofPIF.szPathName, lpszPIF);
        ppl->flProp |= PROP_DIRTY;
        ppl->flProp &= ~PROP_NOCREATEPIF;
        fError = !FlushPIFData(ppl, FALSE);
    }

    // Apply INF data to the PIF data we just retrieved, as appropriate,
    // as long as it's an app file and not a PIF file (and if, in the case of
    // creating a specific PIF, we were actually able to create one).

    if (!fError && !fExplicitPIF && (hInf != -1)) {

        if (PifMgr_GetProperties(ppl, MAKELP(0,GROUP_PRG),
                            &prg, sizeof(prg), GETPROPS_NONE)) {

            // In the PRGINIT_AMBIGUOUSPIF case, GetAppsInfData must
            // again look for a matching entry;  however, if the entry it
            // finds is the same as what we've already got (based on Other
            // File), then it will leave the PIF data alone (ie, it doesn't
            // reinitialize it, it doesn't call AppWiz to silently
            // reconfigure it, etc).

            if (fSearchInf || (prg.flPrgInit & PRGINIT_AMBIGUOUSPIF)) {

                if (PifMgr_GetProperties(ppl, MAKELP(0,GROUP_NT40),
                                &nt40, sizeof(nt40), GETPROPS_NONE)) {

                if (!GetAppsInfData(ppl, &prg, &nt40, (HINF)IntToPtr( hInf ), lpszApp, fFixedDisk, flOpt)) {

                    // When GetAppsInfData fails and the PIF is ambiguous, then
                    // we need to restart the PIF search process at the point where
                    // it searches for _DEFAULT.PIF, so that the ambiguous PIF is
                    // effectively ignored now.

                    // Also, we avoid the ugly possibility of getting to this
                    // point again and infinitely jumping back FindDefault, by
                    // only jumping if fSearchInf was FALSE.  FindDefault sets
                    // it to TRUE.

                    if (!fSearchInf && (prg.flPrgInit & PRGINIT_AMBIGUOUSPIF)) {
                        goto FindDefault;
                    }
#ifdef DBCS
                    if (GetSystemDefaultLangID() == 0x0411) {
                        ZeroMemory(&env, sizeof(env));
                        lstrcpyA(env.achBatchFile, ImeBatchFile);
                        PifMgr_SetProperties(ppl, MAKELP(0,GROUP_ENV),
                                             &env, sizeof(env), SETPROPS_NONE);
                    }
#endif
                }
                }
            }
        }
    }

  Error:
    LocalFree(pszFullName);

    if (fError || !ppl->lpPIFData) {
        PifMgr_CloseProperties(ppl, 0);
        return 0;
    }

    // We should never leave PIFMGR with outstanding locks

    ASSERTTRUE(!ppl->cLocks);

    return ppl;
}


/** PifMgr_GetProperties - get property info by name
 *
 * INPUT
 *  hProps = handle to properties
 *  lpszGroup -> property group; may be one of the following:
 *      "WINDOWS 286 3.0"
 *      "WINDOWS 386 3.0"
 *      "WINDOWS VMM 4.0"
 *      "WINDOWS NT  3.1"
 *      "WINDOWS NT  4.0"
 *    or any other group name that is the name of a valid PIF extension;
 *    if NULL, then cbProps is a 0-based index of a named group, and lpProps
 *    must point to a 16-byte buffer to receive the name of the group (this
 *    enables the caller to enumerate the names of all the named groups)
 *  lpProps -> property group record to receive the data
 *  cbProps = size of property group record to get; if cbProps is zero
 *    and a named group is requested, lpProps is ignored, no data is copied,
 *    and the size of the group record is returned (this enables the caller
 *    to determine the size of a named group)
 *  flOpt = GETPROPS_RAWIO to perform raw file read (lpszGroup ignored)
 *
 *  Alternatively, if the high word (selector) of lpszGroup is 0, the low
 *  word must be a group ordinal (eg, GROUP_PRG, GROUP_TSK, etc)
 *
 * OUTPUT
 *  If the group is not found, or an error occurs, 0 is returned.
 *  Otherwise, the size of the group info transferred in bytes is returned.
 */

int WINAPI PifMgr_GetProperties(HANDLE hProps, LPCSTR lpszGroup, void *lpProps, int cbProps, UINT flOpt)
{
    int cb, i;
    void *lp;
    LPW386PIF30 lp386;
    LPWENHPIF40 lpenh;
    LPWNTPIF40 lpnt40;
    LPWNTPIF31 lpnt31;

    PPROPLINK ppl;
    FunctionName(PifMgr_GetProperties);

    cb = 0;

    if (!(ppl = ValidPropHandle(hProps)))
        return cb;

    // We should never enter PIFMGR with outstanding locks (we also call
    // here from *inside* PIFMGR, but none of those cases should require a
    // lock either)

    ASSERTTRUE(!ppl->cLocks);

    ppl->cLocks++;

    if (flOpt & GETPROPS_RAWIO) {
        if (ppl->flProp & PROP_RAWIO) {
            cb = min(ppl->cbPIFData, cbProps);
            hmemcpy(lpProps, ppl->lpPIFData, cb);
        }
        ppl->cLocks--;
        return cb;
    }

    if (!lpszGroup) {
        if (lpProps) {
            lp = GetGroupData(ppl, NULL, &cbProps, NULL);
            if (lp) {
                cb = cbProps;
                hmemcpy(lpProps, lp, PIFEXTSIGSIZE);
            }
        }
    }
    else if (IS_INTRESOURCE(lpszGroup) && lpProps) {

        // Special case: if GROUP_ICON, then do a nested call to
        // PifMgr_GetProperties to get GROUP_PRG data, then feed it to load
        // LoadPIFIcon, and finally return the hIcon, if any, to the user.

        if (LOWORD((DWORD_PTR) lpszGroup) == GROUP_ICON) {
            PPROPPRG pprg;
            PPROPNT40 pnt40 = (void *)LocalAlloc(LPTR, sizeof(PROPNT40));
            if ( pnt40 ) {
                pprg = (void *)LocalAlloc(LPTR, sizeof(PROPPRG));
                if (pprg) {
                    if ( PifMgr_GetProperties(ppl, MAKELP(0,GROUP_PRG), pprg, sizeof(PROPPRG), GETPROPS_NONE)
                          && PifMgr_GetProperties(ppl, MAKELP(0,GROUP_NT40), pnt40, sizeof(PROPNT40), GETPROPS_NONE) ) {
                        *(HICON *)lpProps = LoadPIFIcon(pprg, pnt40);
                        cb = 2;
                    }
                    EVAL(LocalFree(pprg) == NULL);
                }
                EVAL(LocalFree(pnt40) == NULL);
            }
        }
        else {
            lp386 = GetGroupData(ppl, szW386HDRSIG30, NULL, NULL);
            lpenh = GetGroupData(ppl, szWENHHDRSIG40, NULL, NULL);
            lpnt40 = GetGroupData(ppl, szWNTHDRSIG40, NULL, NULL);
            lpnt31  = GetGroupData(ppl, szWNTHDRSIG31, NULL, NULL);

            //
            // Fix anything from down-level PIF files.  Since this
            // is the first revision of the WENHPIF40 format, we
            // don't have anything to worry about (yet).
            //
            // Don't muck with PIF files from the future!
            //
            if (lpenh && lpenh->wInternalRevision != WENHPIF40_VERSION) {
                lpenh->wInternalRevision = WENHPIF40_VERSION;
                ppl->flProp |= PROP_DIRTY;

                //
                //  Old (pre-M7) PIFs did not zero-initialize the reserved
                //  fields of PIF files, so zero them out now.
                //
                lpenh->tskProp.wReserved1 = 0;
                lpenh->tskProp.wReserved2 = 0;
                lpenh->tskProp.wReserved3 = 0;
                lpenh->tskProp.wReserved4 = 0;
                lpenh->vidProp.wReserved1 = 0;
                lpenh->vidProp.wReserved2 = 0;
                lpenh->vidProp.wReserved3 = 0;
                lpenh->envProp.wMaxDPMI = 0;

                // Turn off bits that have been deleted during the development
                // cycle.
                lpenh->envProp.flEnv = 0;
                lpenh->envProp.flEnvInit = 0;
                if (lp386)
                    lp386->PfW386Flags &= ~0x00400000;
            }
            // End of "Remove this after M8"

            // Zero the input buffer first, so that the Get* functions
            // need not initialize every byte to obtain consistent results

            BZero(lpProps, cbProps);

            // The GetData functions CANNOT rely on either lp386 or lpenh

            i = LOWORD((DWORD_PTR) lpszGroup)-1;
            if (i >= 0 && i < ARRAYSIZE(afnGetData) && cbProps >= acbData[i]) {
                void *aDataPtrs[NUM_DATA_PTRS];

                aDataPtrs[ LP386_INDEX ] = (LPVOID)lp386;
                aDataPtrs[ LPENH_INDEX ] = (LPVOID)lpenh;
                aDataPtrs[ LPNT40_INDEX ] = (LPVOID)lpnt40;
                aDataPtrs[ LPNT31_INDEX ] = (LPVOID)lpnt31;

                cb = (afnGetData[i])(ppl, aDataPtrs, lpProps, cbProps, flOpt );
            }
        }
    }
    else if (NULL != (lp = GetGroupData(ppl, lpszGroup, &cb, NULL))) {
        if (lpProps && cbProps != 0) {
            cb = min(cb, cbProps);
            hmemcpy(lpProps, lp, cb);
        }
    }
    ppl->cLocks--;

#ifdef EXTENDED_DATA_SUPPORT

    // Note that for GETPROPS_EXTENDED, both the normal and extended
    // sections are returned, and that the return code reflects the success
    // or failure of reading the normal portion only.  We return both because
    // that's the most convenient thing to do for the caller.

    if (flOpt & GETPROPS_EXTENDED) {
        if (ppl->hVM) {
            WORD wGroup = EXT_GROUP_QUERY;
            if (!HIWORD(lpszGroup) && LOWORD(lpszGroup) <= MAX_GROUP)
                wGroup |= LOWORD(lpszGroup);
            GetSetExtendedData(ppl->hVM, wGroup, lpszGroup, lpProps);
        }
    }
#endif

    // We should never leave PIFMGR with outstanding locks (we also call
    // here from *inside* PIFMGR, but none of those cases should require a
    // lock either)

    ASSERTTRUE(!ppl->cLocks);

    return cb;
}


/** PifMgr_SetProperties - set property info by name
 *
 * INPUT
 *  hProps = handle to properties
 *  lpszGroup -> property group; may be one of the following:
 *      "WINDOWS 286 3.0"
 *      "WINDOWS 386 3.0"
 *      "WINDOWS PIF.400"
 *    or any other group name that is the name of a valid PIF extension
 *  lpProps -> property group record to copy the data from
 *  cbProps = size of property group record to set;  if cbProps is
 *    zero and lpszGroup is a group name, the group will be removed
 *  flOpt = SETPROPS_RAWIO to perform raw file write (lpszGroup ignored)
 *          SETPROPS_CACHE to cache changes until properties are closed
 *
 *  Alternatively, if the high word (selector) of lpszGroup is 0, the low
 *  word must be a group ordinal (eg, GROUP_PRG, GROUP_TSK, etc)
 *
 * OUTPUT
 *  If the group is not found, or an error occurs, 0 is returned.
 *  Otherwise, the size of the group info transferred in bytes is returned.
 */

int WINAPI PifMgr_SetProperties(HANDLE hProps, LPCSTR lpszGroup, void *lpProps, int cbProps, UINT flOpt)
{
    void *p = NULL;
    void *lp = NULL;
    LPW386PIF30 lp386;
    LPWENHPIF40 lpenh;
    LPWNTPIF40 lpnt40;
    LPWNTPIF31 lpnt31;
    int i, cb = 0;
    PPROPLINK ppl;

    FunctionName(PifMgr_SetProperties);

    // Can't set a NULL name (nor set-by-index)--causes squirlly behavior in RemoveGroupData
    if (!lpProps || !lpszGroup)
        return 0;

    ppl = ValidPropHandle(hProps);
    if (!ppl)
        return 0;

    // We should never enter PIFMGR with outstanding locks (we also call
    // here from *inside* PIFMGR, but none of those cases should require a
    // lock either)

    ASSERTTRUE(!ppl->cLocks);

    if (flOpt & SETPROPS_RAWIO) {
        if (ppl->flProp & PROP_RAWIO) {
            ppl->cLocks++;
            cb = min(ppl->cbPIFData, cbProps);
            if (IsBufferDifferent(ppl->lpPIFData, lpProps, cb)) {
                hmemcpy(ppl->lpPIFData, lpProps, cb);
                ppl->flProp |= PROP_DIRTY;
            }
            if (cb < ppl->cbPIFData)
                ppl->flProp |= PROP_DIRTY | PROP_TRUNCATE;
            ppl->cbPIFData = cb;
            ppl->cLocks--;
        }
        return cb;
    }

#ifdef EXTENDED_DATA_SUPPORT

    // Note that, unlike GETPROPS_EXTENDED, SETPROPS_EXTENDED only updates
    // the extended section, and that the return code reflects the existence
    // of a VM only.  This is because there's a performance hit associated
    // with setting the normal portion, and because the caller generally only
    // wants to set one or the other.

    if (flOpt & SETPROPS_EXTENDED) {
        if (ppl->hVM) {
            WORD wGroup = EXT_GROUP_UPDATE;
            cb = cbProps;
            if (!HIWORD(lpszGroup) && LOWORD(lpszGroup) <= MAX_GROUP)
                wGroup |= LOWORD(lpszGroup);
            GetSetExtendedData(ppl->hVM, wGroup, lpszGroup, lpProps);
        }
        return cb;
    }
#endif

    // For named groups, if the group does NOT exist, or DOES but is
    // a different size, then we have to remove the old data, if any, and
    // then add the new.

    if (!IS_INTRESOURCE(lpszGroup)) {

        cb = PifMgr_GetProperties(hProps, lpszGroup, NULL, 0, GETPROPS_NONE);

        if (cb == 0 || cb != cbProps) {
            if (cb) {
                RemoveGroupData(ppl, lpszGroup);
                cb = 0;
            }
            if (cbProps) {
                if (AddGroupData(ppl, lpszGroup, lpProps, cbProps))
                    cb = cbProps;
            }
            goto done;
        }
    }

    if (cbProps) {
        if (!lpszGroup)
            return cb;

        p = (void *)LocalAlloc(LPTR, cbProps);
        if (!p)
            return cb;
    }

    cb = PifMgr_GetProperties(hProps, lpszGroup, p, cbProps, GETPROPS_NONE);

    // If the group to set DOES exist, and if the data given is
    // different, copy into the appropriate group(s) in the PIF data

    if (cb != 0) {
        cbProps = min(cb, cbProps);
        if (IsBufferDifferent(p, lpProps, cbProps)) {
            cb = 0;
            ppl->cLocks++;
            i = LOWORD((DWORD_PTR) lpszGroup)-1;
            if (!IS_INTRESOURCE(lpszGroup)) {
                lp = GetGroupData(ppl, lpszGroup, NULL, NULL);
                if (lp) {
                    cb = cbProps;
                    hmemcpy(lp, lpProps, cbProps);
                    ppl->flProp |= PROP_DIRTY;
                }
            }
            else if (i >= 0 && i < ARRAYSIZE(afnSetData) && cbProps >= acbData[i]) {

                // Insure that both 386 and enhanced sections of PIF
                // file are present.  There are some exceptions:  all
                // groups from GROUP_MSE on up do not use the 386 section,
                // and GROUP_MEM does not need the enh section....

                lp386 = GetGroupData(ppl, szW386HDRSIG30, NULL, NULL);
                if (i < GROUP_MSE-1 && !lp386) {
                    if (AddGroupData(ppl, szW386HDRSIG30, NULL, sizeof(W386PIF30))) {
                        lp386 = GetGroupData(ppl, szW386HDRSIG30, NULL, NULL);
                        if (!lp386) {
                            ASSERTFAIL();
                            cbProps = 0;    // indicate error
                        }
                    }
                }
                if (cbProps) {
                    lpenh = GetGroupData(ppl, szWENHHDRSIG40, NULL, NULL);
                    if (i != GROUP_MEM-1 && !lpenh) {
                        if (!(lpenh = AddEnhancedData(ppl, lp386))) {
                            ASSERTFAIL();
                            cbProps = 0;    // indicate error
                        }
                    }
                    lpnt40 = GetGroupData(ppl, szWNTHDRSIG40, NULL, NULL);
                    if (!lpnt40)
                    {
                        if (AddGroupData(ppl, szWNTHDRSIG40, NULL, sizeof(WNTPIF40)))
                        {
                            lpnt40 = GetGroupData(ppl, szWNTHDRSIG40, NULL, NULL);
                        }
                    }
                    ASSERT(lpnt40);

                    lpnt31 = GetGroupData(ppl, szWNTHDRSIG31, NULL, NULL);
                    if (!lpnt31)
                    {
                        if (AddGroupData(ppl, szWNTHDRSIG31, NULL, sizeof(WNTPIF31)))
                        {
                            if (NULL != (lpnt31 = GetGroupData(ppl, szWNTHDRSIG31, NULL, NULL))) {
                                lstrcpyA( lpnt31->nt31Prop.achConfigFile, NT_CONFIG_FILE );
                                lstrcpyA( lpnt31->nt31Prop.achAutoexecFile, NT_AUTOEXEC_FILE );
                            }
                        }
                    }
                    ASSERT(lpnt31);
                }
                if (cbProps)
                {

                    void *aDataPtrs[NUM_DATA_PTRS];

                    //
                    // We need to re-establish the pointers because any of
                    // the AddGroupData's could have moved the block (via
                    // a HeapReAlloc call), so do that now...
                    //

                    lp386 = GetGroupData( ppl, szW386HDRSIG30, NULL, NULL );
                    lpenh = GetGroupData( ppl, szWENHHDRSIG40, NULL, NULL );
                    lpnt40 = GetGroupData( ppl, szWNTHDRSIG40, NULL, NULL );
                    lpnt31 = GetGroupData( ppl, szWNTHDRSIG31, NULL, NULL );

                    aDataPtrs[ LP386_INDEX ] = (LPVOID)lp386;
                    aDataPtrs[ LPENH_INDEX ] = (LPVOID)lpenh;
                    aDataPtrs[ LPNT40_INDEX ] = (LPVOID)lpnt40;
                    aDataPtrs[ LPNT31_INDEX ] = (LPVOID)lpnt31;
                    cb = (afnSetData[i])(ppl, aDataPtrs, lpProps, cbProps, flOpt );
                }
            }
            ppl->cLocks--;
        }
    }
    EVAL(LocalFree(p) == NULL);

  done:
    if (!(flOpt & SETPROPS_CACHE))
        if (!FlushPIFData(ppl, FALSE))
            cb = 0;

    // We should never leave PIFMGR with outstanding locks (we also call
    // here from *inside* PIFMGR, but none of those cases should require a
    // lock either)

    ASSERTTRUE(!ppl->cLocks);

    return cb;
}


/** FlushProperties - flush (or discard) any cached property info
 *
 * INPUT
 *  hProps = handle to properties
 *  flOpt = FLUSHPROPS_DISCARD to abandon cached PIF data, otherwise flush it
 *
 * OUTPUT
 *  TRUE if successful, FALSE otherwise
 */

int WINAPI FlushProperties(HANDLE hProps, UINT flOpt)
{
    PPROPLINK ppl;
    FunctionName(FlushProperties);

    if (!(ppl = ValidPropHandle(hProps)))
        return FALSE;

    return FlushPIFData(ppl, (flOpt & FLUSHPROPS_DISCARD));
}


/** EnumProperties - enumerate open properties
 *
 * INPUT
 *  hProps = handle to previous properties (NULL to start)
 *
 * OUTPUT
 *  next property handle, 0 if none
 */

HANDLE WINAPI EnumProperties(HANDLE hProps)
{
    PPROPLINK ppl;
    FunctionName(EnumProperties);

    if (!hProps)
        return g_pplHead;

    if (!(ppl = ValidPropHandle(hProps)))
        return NULL;

    return ppl->pplNext;
}


/** AssociateProperties - associate data with property info
 *
 * INPUT
 *  hProps = handle to properties
 *  iAssociate = association index (eg, HVM_ASSOCIATION)
 *  lData = new associated data
 *
 * OUTPUT
 *  previously associated data for the index, 0 if none (or error)
 *
 * NOTES
 *  If iAssociate is a negative association index, then the current
 *  associated value is returned and not modified (ie, lData is ignored)
 */

LONG_PTR WINAPI AssociateProperties(HANDLE hProps, int iAssociate, LONG_PTR lData)
{
    LONG_PTR l;
    int iIndex;
    PPROPLINK ppl;
    FunctionName(AssociateProperties);

    if (!(ppl = ValidPropHandle(hProps)))
        return FALSE;

    iIndex = iAssociate;
    if (iIndex < 0)
        iIndex *= -1;

    switch(iIndex) {
    case HVM_ASSOCIATION:
        l = ppl->hVM;
        break;
    case HWND_ASSOCIATION:
        l = (LONG_PTR)ppl->hwndTty;
        break;
    case LPARGS_ASSOCIATION:
        l = (LONG_PTR)ppl->lpArgs;
        break;
    default:
        return FALSE;
    }

    switch(iAssociate) {
    case HVM_ASSOCIATION:
        ppl->hVM = (DWORD) lData;
        break;
    case HWND_ASSOCIATION:
        ppl->hwndTty = (HWND)lData;
        break;
    case LPARGS_ASSOCIATION:
        ppl->lpArgs = (LPTSTR)lData;
        break;
    }
    return l;
}


void SetBootDrive(LPTSTR pszFile)
{
    TCHAR szPath[10];
    DWORD cbPath = sizeof(szPath);

    szPath[0] = 0;
    SHGetValue(HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Setup"), TEXT("BootDir"), NULL, szPath, &cbPath);

    pszFile[0] = szPath[0] ? szPath[0] : TEXT('C');
}

#define RENAME_DELETENEW    0x0001
#define RENAME_CREATEOLD    0x0002
#define RENAME_DELETEOLD    0x0004

/** RenameStartupFiles - rename startup files (for real-mode only)
 *
 * INPUT
 *  pszOld -> old filename (eg, C:CONFIG.SYS)
 *  pszNew -> new filename (eg, C:CONFIG.WOS)
 *  flRename == see RENAME_* above
 *
 * OUTPUT
 *  None
 */

void RenameStartupFiles(LPTSTR pszOld, LPTSTR pszNew, int flRename)
{
    SetBootDrive(pszOld);
    SetBootDrive(pszNew);

    // For RENAME_DELETENEW:  make sure there's no way an existing new filename
    // could block the rename process, not even a R/H/S file!

    if (flRename & RENAME_DELETENEW) {
        SetFileAttributes(pszNew, 0);
        DeleteFile(pszNew);
    }

    // For RENAME_CREATEOLD:  if the old filename doesn't exist, then we
    // want to create a hidden 0-length copy of the new filename, as a way
    // of telling ourselves later that the old file didn't exist.  Then,
    // when it's later (see RENAME_DELETEOLD), if the file we're to rename
    // is a hidden 0-length file, just delete it.

    if (flRename & RENAME_CREATEOLD) {

        int i;
        HANDLE hFile;

        i = (int)GetFileAttributes(pszOld);
        if (i == -1) {
            hFile = CreateFile( pszNew,
                                GENERIC_READ | GENERIC_WRITE,
                                FILE_SHARE_READ,
                                NULL,
                                CREATE_ALWAYS,
                                FILE_ATTRIBUTE_HIDDEN,
                                NULL
                               );
            if (hFile != INVALID_HANDLE_VALUE)
                CloseHandle(hFile);
            return;
        }
    }

    // For RENAME_DELETEOLD:  if the old file is a hidden 0-length
    // dummy file that we presumably created ourselves, then simply delete it.

    if (flRename & RENAME_DELETEOLD) {

        WIN32_FIND_DATA dFind;
        HANDLE hFind = FindFirstFile(pszOld, &dFind);
        if (hFind != INVALID_HFINDFILE) {
            FindClose(hFind);
            if ((dFind.dwFileAttributes & FILE_ATTRIBUTE_HIDDEN) && dFind.nFileSizeLow == 0) {
                DeleteFile(pszOld);
                return;
            }
        }
    }
    MoveFile(pszOld, pszNew);
}


/** CheckForceReboot - return TRUE if exit to real-mode has been disabled
 *
 *  This function largely copied from win\core\user\inexit.c -JTP
 *
 *  The key being examined is:
 *
 *      HKEY_LOCAL_MACHINE\\System\\CurrentControlSet\\Control\\Shutdown
 *
 *  The value-name is:
 *
 *      ForceReboot
 *
 *  The value to force a reboot is:
 *
 *      "1"
 *
 * INPUT
 *  None
 *
 * OUTPUT
 *  TRUE if reboot must be forced, FALSE if not
 */

BOOL CheckForceReboot()
{
    // Check to see if we have to force a reboot of the system. One reason is
    // so that the double space utilities can tell us the system must be reboot
    // since we can't exit to real mode double space...

    HKEY     hkey;
    static TCHAR szShutdown[] = REGSTR_PATH_SHUTDOWN;
    BOOL     fForce=FALSE;
    TCHAR    sz[12];
    DWORD    dwType;

    if (!RegOpenKey(HKEY_LOCAL_MACHINE, szShutdown, &hkey))
    {

        LONG cb = sizeof(sz);
        static TCHAR szForceReboot[] = REGSTR_VAL_FORCEREBOOT;

        if (!SHQueryValueEx(hkey, szForceReboot, NULL, &dwType, (LPBYTE)sz, &cb))
        {
            if (*sz==TEXT('1'))
                fForce = TRUE;
        }

        RegCloseKey(hkey);
    }

    return(fForce);
}


/** CreateStartupProperties - create startup files (for real-mode only)
 *
 * INPUT
 *  hProps = handle to properties
 *  flOpt = CREATEPROPS_NONE (all bits reserved)
 *
 * OUTPUT
 *  TRUE (1) if any files were created, FALSE (0) if there was an error
 *  creating 1 or more of the necessary files, and -1 there was no error and
 *  no files needed to be created.
 */

int WINAPI CreateStartupProperties(HANDLE hProps, UINT flOpt)
{
    BOOL fForceReboot;
    int fSuccess = FALSE;
    PPROPLINK ppl;
    FunctionName(CreateStartupProperties);

    if (NULL != (ppl = ValidPropHandle(hProps))) {

        InitRealModeFlag(ppl);

        if (ppl->flProp & PROP_REALMODE) {

            // WriteAdvPrgData only returns the exact value TRUE (1) if it
            // actually created a file.  If there was no need to create
            // a particular file, and therefore no error, it returns -1.

            fForceReboot = CheckForceReboot();
            fSuccess = WriteAdvPrgData(ppl, MAX_CONFIG_SIZE, szCONFIGHDRSIG40, g_szMConfigFile, g_szConfigFile, fForceReboot, fForceReboot);
            fSuccess &= WriteAdvPrgData(ppl, MAX_AUTOEXEC_SIZE, szAUTOEXECHDRSIG40, g_szMAutoexecFile, g_szAutoexecFile, fSuccess, fForceReboot);

        }
    }
    return fSuccess;
}


/** DoLargeEnvironmentSubstA - do large environment substitution
 *
 *  NOTE: the below comment is no longer true.  DoEnvironmentSubst
 *        calls ExpandEnvironmentStrings which does not have this restriction!
 *
 *  This is a wrapper around shell's DoEnvironmentSubst that can handle
 *  larger buffers.  Although not well-documented, DoEnvironmentSubst will
 *  fail if the input buffer simply contains more than 256 chars, hence
 *  it is not entirely suitable for our purposes.
 *
 *  The basic idea is:  find CR/LF-terminated lines, copy them to szTmp
 *  with a null terminator instead of the CR/LF, do environment substitution
 *  on szTmp, move the data in psz up by the number of bytes szTmp grew (if
 *  any), and then copy the expanded string back into psz.  Repeat until no
 *  more lines.
 */

int DoLargeEnvironmentSubstA(LPSTR psz, int cchsz, BOOL fStripWIN)
{
    int cch, cchNew, cchDiff;
    DWORD dwResult;
    CHAR szTmp[256];
    CHAR *pszCRLF, *pszCRLFNext;

    pszCRLF = psz;
    while (NULL != (pszCRLFNext = (PBYTE)(UINT_PTR)(ULONG_PTR)_fstrstr(pszCRLF, szCRLF))) {

        cch = (int)(pszCRLFNext - pszCRLF);
        pszCRLFNext += ARRAYSIZE(szCRLF)-1;

        if (cch >= ARRAYSIZE(szTmp))
            goto Next;

        hmemcpy(szTmp, pszCRLF, cch);
        szTmp[cch] = '\0';

        // fStripWIN means: strip WIN wherever you find it and do NOTHING else

        if (fStripWIN) {
            if (lstrcmpiA(szTmp, szWin) == 0) {
                cchNew = 0;
                goto Strip;
            }
            goto Next;
        }

        cchNew = cch;
        dwResult = DoEnvironmentSubstA(szTmp, ARRAYSIZE(szTmp));
        if (HIWORD(dwResult))
            cchNew = LOWORD(dwResult);

    Strip:
        cchDiff = cchNew - cch;            // cchDiff == # chars needed
        if (cchDiff) {

            if (cchDiff > cchsz - (lstrlenA(psz)+1))
                goto Next;              // not enough room left

            cch = lstrlenA(pszCRLFNext)+1;// cch == # chars required to copy

            hmemcpy(pszCRLFNext+(cchDiff*sizeof(CHAR)), pszCRLFNext, cch*sizeof(CHAR));
            pszCRLFNext += cchDiff;
        }

        hmemcpy(pszCRLF, szTmp, cchNew*sizeof(CHAR));
        hmemcpy(pszCRLF+cchNew, szCRLF, (ARRAYSIZE(szCRLF)-1)*sizeof(CHAR));

      Next:
        pszCRLF = pszCRLFNext;
    }
    return lstrlenA(psz);
}

void ReadAdvPrgData(PPROPLINK ppl, int cbMax, LPCSTR lpszName, LPTSTR pszFile, UINT flOpt)
{
    HANDLE hFile;
    int i;
    DWORD cbData = 0, cb;
    CHAR  szTmp[256];
    PBYTE pb, pbLast;
    PBYTE pbData = NULL, pbDataTmp, pbDataOrig = NULL;

    SetBootDrive(pszFile);

    if (flOpt & DELETEPROPS_DISCARD) {
        DeleteFile(pszFile);
        return;
    }

    hFile = CreateFile( pszFile,
                        GENERIC_READ,
                        FILE_SHARE_READ,
                        NULL,
                        OPEN_EXISTING,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL );

    if (hFile != INVALID_HANDLE_VALUE) {

        pbData = (PBYTE)LocalAlloc(LPTR, cbMax);

        if (pbData) {

            pbDataOrig = pbData;

            if (ReadFile( hFile, (PVOID)pbData, (DWORD)cbMax-1, &cbData, NULL))
            {

                // Guess what, this routine isn't so general purpose after all:
                // in the autoexec case, we must find the signature that precedes
                // the command-line that we added to the file.  For expediency,
                // we simply delete it and everything after it.

                if (pszFile == g_szMConfigFile) {

                    // If "DOS=SINGLE" is present, skip over it

                    if (pbData == (PBYTE)(UINT_PTR)(ULONG_PTR)_fstrstr(pbData, szSingle)) {
                        cb = lstrlenA(szSingle);
                        pbData += cb;
                        cbData -= cb;
                    }
                }

                if (pszFile == g_szMAutoexecFile) {

                    // If "@echo off" is present, skip over it

                    if (LoadStringA(g_hinst, IDS_AUTOEXECTOP, szTmp, ARRAYSIZE(szTmp))) {

                        if (pbData == (PBYTE)(UINT_PTR)(ULONG_PTR)_fstrstr(pbData, szTmp)) {
                            cb = lstrlenA(szTmp);
                            pbData += cb;
                            cbData -= cb;
                        }
                    }

                    // Try to find our signature at the end of the file now

                    if (LoadStringA(g_hinst, IDS_AUTOEXECBOTTOM, szTmp, ARRAYSIZE(szTmp))) {

                        pb = pbData;
                        pbLast = NULL;
                        while (NULL != (pb = (PBYTE)(UINT_PTR)(ULONG_PTR)_fstrstr(pb, szTmp))) {
                            pbLast = pb++;
                        }

                        // If there was a (last) occurrence of the signature
                        // in the file, then it's starting point is where we cut
                        // off the data we're about to rewrite.

                        if (pbLast)
                            cbData = (DWORD) (pbLast - pbData);
                    }
                }
            }
        }
        CloseHandle(hFile);

        DeleteFile(pszFile);
    }

    // Before we simply blast the data back out to the PIF, we check to
    // see if the data we're about to write is the same as what's already
    // there after environment string substitution.  If so, we leave the
    // data alone, so that environment strings are left in their pre-expanded
    // form whenever possible (and with a minimum of work on our part).

    i = -1;
    if (NULL != (pbDataTmp = (PBYTE)LocalAlloc(LPTR, cbMax))) {
        if (PifMgr_GetProperties(ppl, lpszName, pbDataTmp, cbMax-1, GETPROPS_NONE)) {
            DoLargeEnvironmentSubstA(pbDataTmp, cbMax, FALSE);
            i = lstrcmpA(pbDataTmp, pbData);
        }
        EVAL(LocalFree(pbDataTmp) == NULL);
    }

    // Note that if the file no longer exists, or does but is zero bytes
    // long, this call effectively removes the data from the PIF.  Otherwise,
    // the PIF gets refreshed with the contents of the startup file, which
    // we deleted immediately after pulling its contents out.

    if (i != 0)
        PifMgr_SetProperties(ppl, lpszName, pbData, cbData, SETPROPS_NONE);

    if (pbDataOrig)
        EVAL(LocalFree(pbDataOrig) == NULL);
}


BOOL WriteAdvPrgData(PPROPLINK ppl, int cbMax, LPCSTR lpszName, LPTSTR pszFile, LPTSTR pszOrigFile, BOOL fCreateAnyway, BOOL fForceReboot)
{
    HANDLE hFile;
    int cbData, cb, i, j;
    PBYTE pbData;
    PROPPRG prg;
    PROPENV env;
    DWORD   dwBytes;
    BOOL fPause = FALSE;
    BOOL fSuccess = FALSE;
    CHAR szTmp[MAXPATHNAME];

    cbData = PifMgr_GetProperties(ppl, lpszName, NULL, 0, GETPROPS_NONE);

    if (!cbData) {              // if there's no autoexec data
        if (fCreateAnyway != 1) // and no previous file was created
            return -1;          // then there's no need to create this file
    }

    // If fCreateAnyway is -1, then we know are being called for AUTOEXEC
    // *and* that no file was created for CONFIG.  Since we are committed to
    // creating an AUTOEXEC now, we therefore *force* the CONFIG file to
    // be created as well.  That way, the user won't end up with the default
    // CONFIG (he may have just not have needed/cared about device drivers, but
    // still wanted to run in real-mode).

    if (fCreateAnyway == -1) {
        if (!WriteAdvPrgData(ppl, MAX_CONFIG_SIZE, szCONFIGHDRSIG40, g_szMConfigFile, g_szConfigFile, TRUE, fForceReboot))
            return FALSE;
    }

    pbData = (PBYTE)LocalAlloc(LPTR, cbMax);
    if (pbData) {
        if (cbData) {
            if (cbData >= cbMax)
                cbData = cbMax-1;
            PifMgr_GetProperties(ppl, lpszName, pbData, cbData, GETPROPS_NONE);

        } else if (fForceReboot) {

            SetBootDrive(pszOrigFile);

            hFile = CreateFile( pszOrigFile,
                                GENERIC_READ | GENERIC_WRITE,
                                FILE_SHARE_READ,
                                NULL,
                                OPEN_EXISTING,
                                FILE_ATTRIBUTE_NORMAL,
                                NULL
                               );

            if (hFile != INVALID_HANDLE_VALUE) {

                cbData = (int)SetFilePointer( hFile, 0, NULL, FILE_END );
                if (cbData) {
                    if (cbData >= cbMax)
                        cbData = cbMax-1;
                    SetFilePointer( hFile, 0, NULL, FILE_BEGIN );
                    if (ReadFile( hFile, pbData, cbData, &dwBytes, NULL)) {
                        if (dwBytes != (UINT)cbData) {
                            cbData = 0;
                        } else {
                            cbData = (int)dwBytes;
                        }

                    }
                }

                CloseHandle(hFile);
            }
        }
    }
    else
        cbData = 0;

    SetBootDrive( pszFile );

    hFile = CreateFile( pszFile,
                        GENERIC_READ | GENERIC_WRITE,
                        FILE_SHARE_READ,
                        NULL,
                        CREATE_ALWAYS,
                        FILE_ATTRIBUTE_NORMAL,
                        NULL );

    if (hFile!=INVALID_HANDLE_VALUE) {

        // Do environment string substitution on the buffer before writing
        // it out.  Treat it like the huge null-terminated string that it is.

        if (pbData)
            cbData = DoLargeEnvironmentSubstA(pbData, cbMax, fForceReboot);

        // Do the simple thing:  ALWAYS write out the "@echo off" line;
        // if someone really wants to see the batch file execute, let them
        // put an explicit "echo on" in their autoexec edit control;  since it
        // comes after ours, it will override as appropriate.
        //
        // This rule also simplifies conversion on the way back:  if the
        // first line is "@echo off", we delete it.

        if (pszFile == g_szMConfigFile) {
            WriteFile( hFile, szSingle, lstrlenA(szSingle), &dwBytes, NULL );
        }

        if (pszFile == g_szMAutoexecFile) {
            szTmp[0] = '\0';
            LoadStringA(g_hinst, IDS_AUTOEXECTOP, szTmp, ARRAYSIZE(szTmp));
            WriteFile( hFile, szTmp, lstrlenA(szTmp), &dwBytes, NULL );
        }

        if (WriteFile(hFile, pbData, cbData, &dwBytes, NULL) && (dwBytes==(DWORD)cbData))
            fSuccess++;         // return TRUE to indicate file created

        // Make sure the user-defined gob-o-goo is CR/LF-terminated;
        // if not, spit one out.

        if (cbData != 0)
            if (cbData < 2 || lstrcmpA(pbData+cbData-(ARRAYSIZE(szCRLF)-1), szCRLF) != 0)
                WriteFile( hFile, szCRLF, sizeof(szCRLF)-1, &dwBytes, NULL);

        // Guess what, this routine isn't so general purpose after all:
        // in the autoexec case, we must append the command-line to
        // the file, followed by C:\WINDOWS\WIN.COM /W to restore everything

        if (pszFile == g_szMAutoexecFile) {

            if (PifMgr_GetProperties(ppl, MAKELP(0,GROUP_PRG),
                                &prg, sizeof(prg), GETPROPS_NONE)) {

                szTmp[0] = '\0';
                LoadStringA(g_hinst, IDS_AUTOEXECBOTTOM, szTmp, ARRAYSIZE(szTmp));
                WriteFile(hFile, szTmp, lstrlenA(szTmp), &dwBytes, NULL);

                // If the program is on drive A, then it is time emit:
                //
                //  ECHO Please insert the diskette for Mickey's ABCs in drive A now
                //  PAUSE
                //
                // since WinOldAp will have asked the user to remove it.

                if ((ppl->szPathName[0] == TEXT('a') ||
                     ppl->szPathName[0] == TEXT('A')) && ppl->szPathName[1] == TEXT(':')) {

                    CHAR szTmpFmt[128];

                    fPause++;
                    WriteFile(hFile, szEcho, sizeof(szEcho)-1, &dwBytes, NULL);

                    szTmpFmt[0] = '\0';
                    LoadStringA(g_hinst, IDS_DISKINSERT, szTmpFmt, ARRAYSIZE(szTmpFmt));

                    // The DISKINSERT string should have one %s for the title...

                    wsprintfA(szTmp, szTmpFmt, prg.achTitle);

                    WriteFile(hFile, szTmp, lstrlenA(szTmp), &dwBytes, NULL);
                    WriteFile(hFile, szPause, sizeof(szPause)-1, &dwBytes, NULL);
                }

                if (PifMgr_GetProperties(ppl, MAKELP(0,GROUP_ENV),
                                    &env, sizeof(env), GETPROPS_NONE)) {

                    if (env.achBatchFile[0]) {

                        WriteFile(hFile, szCall, sizeof(szCall)-1, &dwBytes, NULL);

                        // env.achBatchFile could be a long filename and/or
                        // quoted (since it could be followed by args).  Take
                        // care of it now.

                        i = lstrunquotefnameA(szTmp, env.achBatchFile, ARRAYSIZE(szTmp), TRUE);

                        j = lstrskipfnameA(env.achBatchFile);

                        if (env.achBatchFile[j])
                            lstrcpynA(szTmp+i, env.achBatchFile+j, ARRAYSIZE(szTmp)-i);

                        WriteFile(hFile, szTmp, lstrlenA(szTmp), &dwBytes, NULL);
                        WriteFile(hFile, szCRLF, sizeof(szCRLF)-1, &dwBytes, NULL);
                    }
                }
#ifdef DBCS
//                else if (!GetProperties(ppl, lpszName, NULL, 0, GETPROPS_NONE))
//                    _lwrite(hFile, szDOSIME, lstrlen(szDOSIME));
#endif

                if (!prg.achWorkDir[0]) {

                    // If there's no hard-coded working directory,
                    // create one.  It's ok to party on prg.achWorkDir because
                    // we're not going to call PifMgr_SetProperties and inadvertently
                    // change it.

                    InitWorkDir(ppl, &prg, NULL);
                }

                if (prg.achWorkDir[0]) {

                    cb = lstrunquotefnameA(szTmp, prg.achWorkDir, ARRAYSIZE(szTmp), TRUE);

                    if (szTmp[1] == ':') {
                        WriteFile(hFile, szTmp, 2, &dwBytes, NULL);
                        WriteFile(hFile, szCRLF, ARRAYSIZE(szCRLF)-1, &dwBytes, NULL);
                    }
                    WriteFile(hFile, szCD, sizeof(szCD)-1, &dwBytes, NULL);
                    WriteFile(hFile, szTmp, cb, &dwBytes, NULL);
                    WriteFile(hFile, szCRLF, sizeof(szCRLF)-1, &dwBytes, NULL);
                }

                // We now always CALL the cmd-line, in case it's a batch file.
                // If it isn't, no biggie, because command.com is smart enough
                // to ignore it.

                WriteFile(hFile, szCall, sizeof(szCall)-1, &dwBytes, NULL);

                // If the properties we have are ones *we* created in the
                // PIF dir, and it looks like the application name passed to
                // PifMgr_OpenProperties is a "qualified" pathname, then we'll use
                // that instead of the path stored in the PIF, since the app
                // might have moved since *we* created the PIF.

                if ((ppl->flProp & PROP_PIFDIR) &&
                    (ppl->szPathName[0] == TEXT('\\') ||
                     ppl->szPathName[0] && ppl->szPathName[1] == TEXT(':'))) {

                    // We're making this call not because ppl->szPathName
                    // is quoted (it shouldn't be), but because it could still
                    // be a long filename, so translate it.

                    CHAR achPathName[ ARRAYSIZE(ppl->szPathName) ];
                    PifMgr_WCtoMBPath( ppl->szPathName, achPathName, ARRAYSIZE(achPathName) );
                    i = lstrunquotefnameA(szTmp, achPathName, ARRAYSIZE(szTmp), -1);
                }
                else {

                    // As for the thing stored in the PIF, now *that* could
                    // both long and quoted.  Take care of it now.

                    i = lstrunquotefnameA(szTmp, prg.achCmdLine, ARRAYSIZE(szTmp), TRUE);
                }

                // NOTE: There is an obscure case where the preceding call
                // to lstrunquotefname can fail, returning i == 0, even though
                // WinOldAp already verified the app exists.  That case is when
                // the app name is NOT fully-qualified, so it exists somewhere
                // on the PATH, but NOT in the current directory, and the app
                // name is an LFN.  Because lstrunquotefname must call INT 21h,
                // function 7160h, subfunction 1 (NAMTRN_DO83QUERY), IFSMGR must
                // find the equivalent 8.3 name for the LFN app name, but all
                // IFSMGR has to work with is the current directory, and that's
                // not where the app is, so the INT 21h fails, returning error
                // #3 (ERROR_PATH_NOT_FOUND).
                //
                // To solve, we could do another PATH search for the app file,
                // via OpenFileEx;  if found, it would return the fully-qualifed
                // long-file-name of the app, in the OEM char set, which we
                // could then perform NameTrans on, to get full 8.3.  Yuck! -JP


                // If there are any arguments in the PIF, find them
                // and append them, giving PREFERENCE to any args that WINOLDAP
                // specifically associated with this instance of the app.

                if (ppl->lpArgs) {      // any associated args?
                    j = lstrlen(ppl->lpArgs);
                    if (j) {
                        szTmp[i++] = ' ';
                        if (ppl->lpArgs[j-1] == TEXT('\r'))
                            j--;
                        {
                            CHAR achArgs[ ARRAYSIZE(ppl->lpArgs) ];

                            WideCharToMultiByte( CP_ACP, 0,
                                                 ppl->lpArgs, -1,
                                                 achArgs, ARRAYSIZE(achArgs),
                                                 NULL, NULL );
                            lstrcpynA(szTmp+i, achArgs, min(sizeof(szTmp)-i,(unsigned)j+1));
                        }
                    }
                } else {
                    j = lstrskipfnameA(prg.achCmdLine);

                    if (prg.achCmdLine[j])
                        lstrcpynA(szTmp+i, prg.achCmdLine+j, ARRAYSIZE(szTmp)-i);
                }

                WriteFile(hFile, szTmp, lstrlenA(szTmp), &dwBytes, NULL);
                WriteFile(hFile, szCRLF, sizeof(szCRLF)-1, &dwBytes, NULL);

                // If we paused above to ask for a disk, we should pause
                // again to ask them to remove the disk.  We won't actually
                // emit a PAUSE though unless close-on-exit is set, since
                // WIN.COM should already pause for them when the cursor isn't
                // at 0,0.

                if (fPause) {
                    WriteFile(hFile, szEcho, sizeof(szEcho)-1, &dwBytes, NULL);

                    szTmp[0] = TEXT('\0');
                    LoadStringA(g_hinst, IDS_DISKREMOVE, szTmp, ARRAYSIZE(szTmp));

                    WriteFile(hFile, szTmp, lstrlenA(szTmp), &dwBytes, NULL);

                    if (prg.flPrg & PRG_CLOSEONEXIT)
                        WriteFile(hFile, szPause, sizeof(szPause)-1, &dwBytes, NULL);
                    else
                        WriteFile(hFile, szCRLF, sizeof(szCRLF)-1, &dwBytes, NULL);
                }
            }
        }
        CloseHandle(hFile);
    }
    if (pbData)
        EVAL(LocalFree(pbData) == NULL);

    return fSuccess;
}


/** PifMgr_CloseProperties - close property info for application
 *
 * INPUT
 *  hProps = handle to properties
 *  flOpt = CLOSEPROPS_DISCARD to abandon cached PIF data, otherwise save it
 *
 * OUTPUT
 *  NULL if successful, otherwise hProps is returned as given
 */

HANDLE WINAPI PifMgr_CloseProperties(HANDLE hProps, UINT flOpt)
{
    PPROPLINK ppl;
    FunctionName(PifMgr_CloseProperties);

    if (!(ppl = ValidPropHandle(hProps)))
        return hProps;

    // When discarding on a close, set the SKIPPIF flag, so that the
    // flush code won't say "oh, not only should I throw away my current
    // set of data, but I should read in clean data" -- new data is no use
    // since the caller is closing.

    if (flOpt & CLOSEPROPS_DISCARD)
        ppl->flProp |= PROP_SKIPPIF;

    if (ppl->flProp & PROP_DIRTY) {     // this redundant check added
                                        // to avoid making FlushPIFData PRELOAD -JTP

        // Note that we avoid calling FlushPIFData if INHIBITPIF is set,
        // since FlushPIFData will just return a fake TRUE result anyway.
        // But we don't want to be fooled, we want to make sure the block
        // gets unlocked now.

        if ((ppl->flProp & PROP_INHIBITPIF) || !FlushPIFData(ppl, (flOpt & CLOSEPROPS_DISCARD))) {

            // If FlushPIFData failed, then if we still have an outstanding
            // dirty lock, force the data to become unlocked, by clearing the
            // dirty flag in the middle of a pair otherwise pointless lock/unlock
            // calls (because that's the nice, clean way to do it!)

            if (ppl->flProp & PROP_DIRTYLOCK) {
                ppl->cLocks++;
                ppl->flProp &= ~PROP_DIRTY;
                ppl->cLocks--;
            }
        }
    }

    if (ppl->lpPIFData) {
        LocalFree(ppl->lpPIFData);
        ppl->lpPIFData = NULL;
    }

    if (ppl->hPIF != INVALID_HANDLE_VALUE)
        CloseHandle(ppl->hPIF);

    // Unlink from the global list

    if (ppl->pplPrev)
        ppl->pplPrev->pplNext = ppl->pplNext;
    else
        g_pplHead = ppl->pplNext;

    if (ppl->pplNext)
        ppl->pplNext->pplPrev = ppl->pplPrev;

    LocalFree(ppl);
    return NULL;
}


/** ValidPropHandle - verify handle
 *
 * INPUT
 *  hProps = handle to properties
 *
 * OUTPUT
 *  pointer to prop, NULL otherwise
 */

PPROPLINK ValidPropHandle(HANDLE hProps)
{
    FunctionName(ValidPropHandle);
    if (!hProps ||
        (HANDLE)hProps > g_offHighestPropLink ||
        ((PPROPLINK)hProps)->iSig != PROP_SIG) {
        ASSERTFAIL();
        return NULL;
    }
    return (PPROPLINK)hProps;
}


/** ResizePIFData - verify handle and resize PIF data
 *
 * INPUT
 *  ppl -> property
 *  cbResize = bytes to resize PIF data by
 *
 * OUTPUT
 *  previous size of PIF data if successful, -1 if not
 *
 *  on success, the PIF data is returned LOCKED, so successful
 *  ResizePIFData calls should be matched with UnlockPIFData calls.
 */

int ResizePIFData(PPROPLINK ppl, INT cbResize)
{
    INT cbOld, cbNew;
    void *lpNew;
    BOOL fInitStdHdr = FALSE;
    FunctionName(ResizePIFData);

    ASSERTTRUE(cbResize != 0);

    // Cope with empty or old PIF files

    cbOld = ppl->cbPIFData;
    cbNew = ppl->cbPIFData + cbResize;

    if ((cbNew < cbOld) == (cbResize > 0))
        return -1;      // underflow/overflow

    if (!ppl->lpPIFData && cbOld == 0) {
        if (cbNew >= sizeof(STDPIF) + sizeof(PIFEXTHDR))
            fInitStdHdr = TRUE;
        lpNew = LocalAlloc(LPTR, cbNew);
    }
    else
    {

        if (cbOld == sizeof(STDPIF))
        {
            fInitStdHdr = TRUE;
            cbOld += sizeof(PIFEXTHDR);
            cbNew += sizeof(PIFEXTHDR);
        }

        lpNew = LocalReAlloc( ppl->lpPIFData, cbNew, LMEM_MOVEABLE|LMEM_ZEROINIT);

    }

    if (lpNew) {
        ppl->cbPIFData = cbNew;
        ppl->lpPIFData = (LPPIFDATA)lpNew;
        ppl->cLocks++;
        if (fInitStdHdr) {
            lstrcpyA(ppl->lpPIFData->stdpifext.extsig, szSTDHDRSIG);
            ppl->lpPIFData->stdpifext.extnxthdrfloff = LASTHDRPTR;
            ppl->lpPIFData->stdpifext.extfileoffset = 0x0000;
            ppl->lpPIFData->stdpifext.extsizebytes = sizeof(STDPIF);
        }
        return cbOld;
    }
    return -1;
}



/** GetPIFData - read PIF data back from PIF
 *
 * INPUT
 *  ppl -> property
 *  fLocked == TRUE to return data locked, FALSE unlocked
 *
 * OUTPUT
 *  TRUE if succeeded, FALSE if not
 */

BOOL GetPIFData(PPROPLINK ppl, BOOL fLocked)
{
    DWORD dwOff;
    LPTSTR pszOpen;
    BOOL fSuccess = FALSE;
    FunctionName(GetPIFData);

    // Since we're going to (re)load the property data now, reset
    // the current size, so that ResizePIFData will resize it from zero

    ppl->cbPIFData = 0;

    // If SKIPPIF is set (eg, by PifMgr_OpenProperties), then don't
    // try to open anything (since PifMgr_OpenProperties already tried!),

    if (ppl->hPIF == INVALID_HANDLE_VALUE && !(ppl->flProp & PROP_SKIPPIF)) {
        pszOpen = g_szDefaultPIF;
        if (!(ppl->flProp & PROP_DEFAULTPIF))
            pszOpen = ppl->ofPIF.szPathName;
        ppl->hPIF = CreateFile( pszOpen,
                                GENERIC_READ | GENERIC_WRITE,
                                FILE_SHARE_READ | FILE_SHARE_WRITE,
                                NULL,
                                OPEN_EXISTING,
                                FILE_ATTRIBUTE_NORMAL,
                                NULL );
    }
    if (ppl->hPIF == INVALID_HANDLE_VALUE) {

        // The following warning is disabled because the presence of
        // the dialog box got WINOLDAP stuck in an infinite message loop -JTP

        InitProperties(ppl, fLocked);
        goto Exit;
    }
    dwOff = SetFilePointer(ppl->hPIF, 0, NULL, FILE_END);
    if (dwOff >= sizeof(STDPIF)) {

        ppl->flProp |= PROP_REGEN;

        if (ResizePIFData(ppl, dwOff) != -1) {

            SetFilePointer(ppl->hPIF, 0, NULL, FILE_BEGIN);
          
            if (ReadFile( ppl->hPIF, ppl->lpPIFData,
                         ppl->cbPIFData, &ppl->cbPIFData, NULL ))
            {

                // Can't be dirty anymore, 'cause we just read the PIF back in

                ppl->flProp &= ~PROP_DIRTY;

                if (ppl->flProp & PROP_DEFAULTPIF) {

                    WideCharToMultiByte( CP_ACP, 0,
                                         ppl->szPathName+ppl->iFileName,
                                         -1,
                                         ppl->lpPIFData->stdpifdata.appname,
                                         ARRAYSIZE(ppl->lpPIFData->stdpifdata.appname),
                                         NULL, NULL
                                        );

                    PifMgr_WCtoMBPath( ppl->szPathName,
                                       ppl->lpPIFData->stdpifdata.startfile,
                                       ARRAYSIZE(ppl->lpPIFData->stdpifdata.startfile)
                                      );
                    // I don't think this is generally worth dirtying the
                    // property info for, because otherwise every app that used
                    // _DEFAULT.PIF initially would get its own PIF file created
                    // later;  PIF file creation should only take place when
                    // substantive changes have been made

                    // ppl->flProp |= PROP_DIRTY;
                }

                // If we're not dealing with an enhanced PIF, then we
                // go to the various INI files to retrieve DOS app defaults

                if (!GetGroupData(ppl, szWENHHDRSIG40, NULL, NULL)) {
                    GetINIData();
                }

                // If we're not dealing with a new NT/UNICODE PIF, then
                // we add a new section so it's ALWAYS there when we're
                // UNICODE enabled.

                if (!GetGroupData(ppl, szWNTHDRSIG40, NULL, NULL)) {
                    VERIFYTRUE(AddGroupData(ppl, szWNTHDRSIG40, NULL, sizeof(WNTPIF40)));
                }
                // If we're not dealing with a NT PIF, then
                // we add the NT sections so it's ALWAYS there when we're
                // running on NT.

                if (!GetGroupData(ppl, szWNTHDRSIG31, NULL, NULL)) {
                    LPWNTPIF31 lpnt31;

                    VERIFYTRUE(AddGroupData(ppl, szWNTHDRSIG31, NULL, sizeof(WNTPIF31)));
                    if (NULL != (lpnt31 = GetGroupData(ppl, szWNTHDRSIG31, NULL, NULL))) {
                        lstrcpyA( lpnt31->nt31Prop.achConfigFile, NT_CONFIG_FILE );
                        lstrcpyA( lpnt31->nt31Prop.achAutoexecFile, NT_AUTOEXEC_FILE );
                    }
                }

                if (!fLocked)
                    ppl->cLocks--;  // UnlockPIFData(ppl);
                fSuccess++;
            }
        }
        else
            ASSERTFAIL();

        ppl->flProp &= ~PROP_REGEN;
    }
    CloseHandle(ppl->hPIF);
    ppl->hPIF = INVALID_HANDLE_VALUE;

    // As long as IGNOREPIF isn't set, clear SKIPPIF, because even if we
    // already knew the PIF didn't exist on *this* call, one may be created
    // (by someone else) by the next time we're called

  Exit:
    if (!(ppl->flProp & PROP_IGNOREPIF))
        ppl->flProp &= ~PROP_SKIPPIF;
    return fSuccess;
}


/** FlushPIFData - write dirty PIF data back to PIF
 *
 * INPUT
 *  ppl -> property
 *  fDiscard == TRUE to discard dirty data, FALSE to keep it
 *
 * OUTPUT
 *  TRUE if succeeded, FALSE if not
 *
 * NOTES
 *  We must first check the PROPLINK and see if the DONTWRITE bit has
 *  been set, in which case we have to fail the flush.  Once DONTWRITE is
 *  set in a PROPLINK, it will never be cleared, unless the caller
 *  specifies fDiscard == TRUE to reload the data.  This is BY DESIGN (ie,
 *  a UI compromise).  How does DONTWRITE get set?  By someone else
 *  having previously (and successfully) done a flush to the same PIF; at
 *  that point in time, we will look for all other properties that refer to
 *  the same file, and set their DONTWRITE bit.  What about PROPLINKs that
 *  are created later?  They're ok, they don't get DONTWRITE set until
 *  the above sequence takes place during their lifetime.
 */

BOOL FlushPIFData(PPROPLINK ppl, BOOL fDiscard)
{
    UINT u;
    BOOL fSuccess = FALSE;
    FunctionName(FlushPIFData);

    // If nothing dirty, nothing to do

    if (!(ppl->flProp & PROP_DIRTY) || (ppl->flProp & PROP_INHIBITPIF))
        return TRUE;            // ie, success

    // If discarding, then clear PROP_DIRTY and reload the data

    if (fDiscard) {
        ppl->flProp &= ~(PROP_DIRTY | PROP_DONTWRITE);
        return GetPIFData(ppl, FALSE);
    }

    if (ppl->flProp & PROP_DONTWRITE)
        return fSuccess;        // ie, FALSE (error)

    if (!ppl->lpPIFData)
        return fSuccess;        // ie, FALSE (error)

    ppl->cLocks++;

    // If we created properties without opening a file, it may have
    // been because normal PIF search processing was overridden by the
    // presence of a WIN.INI entry;  if that entry is still there,
    // then our data is not in sync with any existing file, nor is there
    // any point in creating a new file as long as that entry exists.  We
    // need to consider prompting the user as to whether he really wants
    // that WIN.INI entry, so that it's clear what the heck is going on

    if (ppl->flProp & PROP_IGNOREPIF) {

        HANDLE hProps;

        ppl->ckbMem = GetProfileInt(apszAppType[APPTYPE_PIF]+1, ppl->szPathName+ppl->iFileName, -1);
        if (ppl->ckbMem != -1)
            goto Exit;

        // The WIN.INI entry apparently went away, so let's re-attempt to
        // open the properties that we should have obtained in the first
        // place.  Assuming success, we will copy our entire block on top of
        // them (thereby flushing it), and also copy their PIF name to our
        // PIF name and their PIF flags to our PIF flags, so that future
        // flushes are of the more normal variety

        hProps = PifMgr_OpenProperties(ppl->ofPIF.szPathName, NULL, 0, OPENPROPS_RAWIO);
        if (hProps) {
            ppl->flProp &= ~(PROP_IGNOREPIF | PROP_SKIPPIF);
            ppl->flProp |= ((PPROPLINK)hProps)->flProp & (PROP_IGNOREPIF | PROP_SKIPPIF);
            lstrcpy(ppl->ofPIF.szPathName, ((PPROPLINK)hProps)->ofPIF.szPathName);
            if (PifMgr_SetProperties(hProps, NULL, ppl->lpPIFData, ppl->cbPIFData, SETPROPS_RAWIO) == ppl->cbPIFData) {
                fSuccess++;
                ppl->flProp &= ~(PROP_DIRTY | PROP_TRUNCATE);
            }
            PifMgr_CloseProperties(hProps, CLOSEPROPS_NONE);
        }
        goto Exit;
    }

    // Disable annoying critical error popups (NO MORE GOTOS PAST HERE PLEASE)

    u = SetErrorMode(SEM_FAILCRITICALERRORS);

    ppl->hPIF = CreateFile( ppl->ofPIF.szPathName,
                            GENERIC_READ | GENERIC_WRITE,
                            FILE_SHARE_READ | FILE_SHARE_WRITE,
                            NULL,
                            OPEN_ALWAYS,
                            FILE_ATTRIBUTE_NORMAL,
                            NULL );

    // If we couldn't open the file, then the presumption is that the
    // app didn't have a PIF (or did but someone but someone deleted it),
    // and so we use the name we constructed during PifMgr_OpenProperties in case
    // they ever opted to save new settings (which they obviously have done!)

    // 28-Feb-95: If the PIF did exist at one time (meaning NOCREATPIF is
    // set), then don't recreate it;  somebody's trying to delete their own
    // PIF, so let them. -JTP

    if ((ppl->hPIF != INVALID_HANDLE_VALUE) && (GetLastError()!=ERROR_FILE_EXISTS)) {

        if (!(ppl->flProp & PROP_NOCREATEPIF))
            SetFilePointer( ppl->hPIF, 0, NULL, FILE_BEGIN );

        // If the create succeeded, we're no longer using the default PIF

        if (ppl->hPIF != INVALID_HANDLE_VALUE) {

            ppl->flProp |= PROP_NOCREATEPIF;

            ppl->flProp &= ~(PROP_TRUNCATE | PROP_NOPIF | PROP_DEFAULTPIF);
        }
    }

    // If either the open or the create succeeded, write the PIF data out now

    if (ppl->hPIF != INVALID_HANDLE_VALUE) {

        PPROPLINK pplEnum;
        DWORD dwDummy;

        WriteFile( ppl->hPIF, (LPCVOID)ppl->lpPIFData,
                   ppl->cbPIFData, &dwDummy, NULL );
        if (ppl->flProp & PROP_TRUNCATE)
            WriteFile(ppl->hPIF, (LPCVOID)ppl->lpPIFData, 0, &dwDummy, NULL );
        CloseHandle(ppl->hPIF);
        ppl->hPIF = INVALID_HANDLE_VALUE;
        ppl->flProp &= ~(PROP_DIRTY | PROP_TRUNCATE);
        fSuccess++;

        // Here's where we want to check for other active PROPLINKs using the
        // same PIF.  For each one found, set its DONTWRITE bit.

        pplEnum = NULL;
        while (NULL != (pplEnum = (PPROPLINK)EnumProperties(pplEnum))) {
            if (lstrcmpi(ppl->ofPIF.szPathName, pplEnum->ofPIF.szPathName) == 0) {
                if (pplEnum != ppl)
                    pplEnum->flProp |= PROP_DONTWRITE;
            }
        }
    }

    // Re-enable annoying critical error popups

    SetErrorMode(u);

  Exit:
    ppl->cLocks--;
    return fSuccess;
}


/** AddEnhancedData - create enhanced section(s) of PIF data
 *
 * INPUT
 *  ppl -> property
 *
 * OUTPUT
 *  lpenh or NULL
 */

LPWENHPIF40 AddEnhancedData(PPROPLINK ppl, LPW386PIF30 lp386)
{
    PROPPRG prg;
    PROPTSK tsk;
    PROPVID vid;
    PROPKBD kbd;
    PROPMSE mse;
    PROPFNT fnt;
    PROPWIN win;
    PROPENV env;
    void *aDataPtrs[NUM_DATA_PTRS];
    LPWENHPIF40 lpenh = NULL;

    FunctionName(AddEnhancedData);

    // Get copies of pre-enhanced and/or default settings first,
    // and do them all *before* doing the AddGroupData, because the
    // functions' behavior will change once the enhanced section is added;

    // in addition, zero those strucs that contain strings, since lstrcpy()
    // may initialize a minimum of 1 byte, leaving garbage in the rest.

    BZero(&prg, sizeof(prg));
    BZero(&fnt, sizeof(fnt));
    BZero(&win, sizeof(win));
    BZero(&env, sizeof(env));
    BZero(aDataPtrs, sizeof(aDataPtrs));

    aDataPtrs[ LP386_INDEX ] = (LPVOID)lp386;
    GetPrgData(ppl, aDataPtrs, &prg, sizeof(prg), GETPROPS_NONE);
    GetTskData(ppl, aDataPtrs, &tsk, sizeof(tsk), GETPROPS_NONE);
    GetVidData(ppl, aDataPtrs, &vid, sizeof(vid), GETPROPS_NONE);
    GetKbdData(ppl, aDataPtrs, &kbd, sizeof(kbd), GETPROPS_NONE);
    GetMseData(ppl, aDataPtrs, &mse, sizeof(mse), GETPROPS_NONE);
    GetFntData(ppl, aDataPtrs, &fnt, sizeof(fnt), GETPROPS_NONE);
    GetWinData(ppl, aDataPtrs, &win, sizeof(win), GETPROPS_NONE);
    GetEnvData(ppl, aDataPtrs, &env, sizeof(env), GETPROPS_NONE);


    if (AddGroupData(ppl, szWENHHDRSIG40, NULL, sizeof(WENHPIF40))) {

        if (NULL != (lpenh = GetGroupData(ppl, szWENHHDRSIG40, NULL, NULL))) {

            lpenh->dwEnhModeFlagsProp = prg.dwEnhModeFlags;
            lpenh->dwRealModeFlagsProp = prg.dwRealModeFlags;
            lstrcpyA(lpenh->achOtherFileProp, prg.achOtherFile);
            lstrcpyA(lpenh->achIconFileProp, prg.achIconFile);
            lpenh->wIconIndexProp = prg.wIconIndex;
            lpenh->tskProp = tsk;
            lpenh->vidProp = vid;
            lpenh->kbdProp = kbd;
            lpenh->mseProp = mse;
            lpenh->fntProp = fnt;
            lpenh->winProp = win;
            lpenh->envProp = env;
            lpenh->wInternalRevision = WENHPIF40_VERSION;
        }
    }
    return lpenh;
}


/** AddGroupData - add NEW property group to PIF data
 *
 * INPUT
 *  ppl -> property
 *  lpszGroup -> name of new group
 *  lpGroup -> new group record (if NULL, then group data is zero-filled)
 *  cbGroup == size of new group record
 *
 * OUTPUT
 *  TRUE if successful, FALSE if not
 */

BOOL AddGroupData(PPROPLINK ppl, LPCSTR lpszGroup, LPCVOID lpGroup, int cbGroup)
{
    INT cbOld;
    LPPIFEXTHDR lpph;
    FunctionName(AddGroupData);

    if ((cbOld = ResizePIFData(ppl, cbGroup+sizeof(PIFEXTHDR))) != -1) {

        lpph = (LPPIFEXTHDR)LPPIF_FIELDOFF(stdpifext);

        while ((DWORD_PTR)lpph <= (DWORD_PTR)LPPIF_OFF(cbOld - sizeof(PIFEXTHDR)) &&
               (DWORD_PTR)lpph >= (DWORD_PTR)LPPIF_FIELDOFF(stdpifext)) {
            if (lpph->extnxthdrfloff == LASTHDRPTR) {
                lpph->extnxthdrfloff = (WORD) cbOld;
                lpph = (LPPIFEXTHDR)LPPIF_OFF(cbOld);
                lstrcpynA(lpph->extsig, lpszGroup, sizeof(lpph->extsig));
                lpph->extnxthdrfloff = LASTHDRPTR;
                lpph->extfileoffset = (INT)(cbOld + sizeof(PIFEXTHDR));
                lpph->extsizebytes = (WORD) cbGroup;
                if (lpGroup) {
                    hmemcpy((LPBYTE)LPPH_OFF(sizeof(PIFEXTHDR)), lpGroup, cbGroup);
                    ppl->flProp |= PROP_DIRTY;
                }
                break;
            }
            lpph = (LPPIFEXTHDR)LPPIF_OFF(lpph->extnxthdrfloff);
        }
        ppl->cLocks--;
        return TRUE;
    }
    ASSERTFAIL();
    return FALSE;
}


/** RemoveGroupData - remove EXISTING property group from PIF data
 *
 * INPUT
 *  ppl -> property
 *  lpszGroup -> name of group
 *
 * OUTPUT
 *  TRUE if successful, FALSE if not
 */

BOOL RemoveGroupData(PPROPLINK ppl, LPCSTR lpszGroup)
{
    INT cbGroup, fSuccess;
    LPBYTE lpGroup;
    WORD extnxthdrfloff;
    LPPIFEXTHDR lpph, lpphGroup;
    FunctionName(RemoveGroupData);

    ppl->cLocks++;

    fSuccess = FALSE;
    if (NULL != (lpGroup = GetGroupData(ppl, lpszGroup, &cbGroup, &lpphGroup))) {

        // Removing groups is a bit tedious, so here goes....

        // First, we will walk all the headers, attempting to find the
        // one that points to the one we're about to remove, and point it
        // to the next one, and at the same time adjust all file offsets that
        // equal or exceed the offsets of either the outgoing data or its
        // header.

        lpph = (LPPIFEXTHDR)LPPIF_FIELDOFF(stdpifext);

        while ((DWORD_PTR)lpph <= (DWORD_PTR)LPPIF_OFF(ppl->cbPIFData - sizeof(PIFEXTHDR)) &&
               (DWORD_PTR)lpph >= (DWORD_PTR)LPPIF_FIELDOFF(stdpifext)) {

            extnxthdrfloff = lpph->extnxthdrfloff;

            if ((DWORD_PTR)LPPH_OFF(lpph->extfileoffset) >= (DWORD_PTR)lpGroup)
                lpph->extfileoffset -= (WORD) cbGroup;

            if (lpphGroup) {
                if ((DWORD_PTR)LPPH_OFF(lpph->extfileoffset) >= (DWORD_PTR)lpphGroup)
                    lpph->extfileoffset -= sizeof(PIFEXTHDR);
                if ((DWORD_PTR)LPPH_OFF(lpph->extnxthdrfloff) == (DWORD_PTR)lpphGroup)
                    extnxthdrfloff = lpph->extnxthdrfloff = lpphGroup->extnxthdrfloff;
            }
            if (extnxthdrfloff == LASTHDRPTR)
                break;

            if ((DWORD_PTR)LPPH_OFF(lpph->extnxthdrfloff) >= (DWORD_PTR)lpGroup)
                lpph->extnxthdrfloff -= (WORD) cbGroup;

            if (lpphGroup)
                if ((DWORD_PTR)LPPH_OFF(lpph->extnxthdrfloff) >= (DWORD_PTR)lpphGroup)
                    lpph->extnxthdrfloff -= sizeof(PIFEXTHDR);

            lpph = (LPPIFEXTHDR)LPPIF_OFF(extnxthdrfloff);
        }

        // Next, move everything up over the data, then adjust lpph as
        // needed and move everything up over the header (this must be done
        // in two discrete steps, because we shouldn't assume anything
        // about the data's location relative to its header).

        hmemcpy(lpGroup, (LPBYTE)lpGroup+cbGroup,
                (DWORD_PTR)LPPIF_OFF(ppl->cbPIFData) - (DWORD_PTR)((LPBYTE)lpGroup+cbGroup));

        if (lpphGroup) {

            if ((DWORD_PTR)lpphGroup >= (DWORD_PTR)((LPBYTE)lpGroup+cbGroup))
                lpphGroup -= cbGroup;

            hmemcpy(lpphGroup, lpphGroup+1,
                    (DWORD_PTR)LPPIF_OFF(ppl->cbPIFData) - (DWORD_PTR)((LPBYTE)lpphGroup+1+cbGroup));

            cbGroup += sizeof(PIFEXTHDR);
        }
        ResizePIFData(ppl, -cbGroup);
        ppl->flProp |= PROP_DIRTY | PROP_TRUNCATE;
        ppl->cLocks--;
    }
    ppl->cLocks--;
    return fSuccess;
}


/** GetGroupData - get ptr to property group (by name)
 *
 * INPUT
 *  ppl -> property (assumes it is LOCKED)
 *  lpszGroup -> property group; may be one of the following:
 *      "WINDOWS 286 3.0"
 *      "WINDOWS 386 3.0"
 *      "WINDOWS PIF.400"
 *    or any other group name that is the name of a valid PIF extension.
 *    if NULL, then *lpcbGroup is a 0-based index of the group we are looking for
 *  lpcbGroup -> where to return size of group data (NULL if not)
 *  lplpph -> where to return ptr to pif extension header, if any (NULL if not)
 *
 * OUTPUT
 *  Returns ptr to property group info, NULL if not found
 */

void *GetGroupData(PPROPLINK ppl, LPCSTR lpszGroup,
                    LPINT lpcbGroup, LPPIFEXTHDR *lplpph)
{
    BOOL fFixMe;
    LPPIFEXTHDR lpph;
    FunctionName(GetGroupData);

    if (!ppl->lpPIFData)
        return NULL;

    lpph = (LPPIFEXTHDR)LPPIF_FIELDOFF(stdpifext);

    while ((DWORD_PTR)lpph <= (DWORD_PTR)LPPIF_OFF(ppl->cbPIFData-sizeof(PIFEXTHDR)) &&
           (DWORD_PTR)lpph >= (DWORD_PTR)LPPIF_FIELDOFF(stdpifext)) {

        // PIFEDIT 3.x can trash the first byte of our extended portion
        // (generally with a zero), so try to recover by stuffing the first
        // character of the group we're looking for into the signature;
        // if the rest of the signature matches, great, if it doesn't, then
        // re-zero it.

        if (!lpszGroup) {
            // searching by index *lpcbGroup
            if (!(*lpcbGroup)--) {
                if (lplpph)
                    *lplpph = lpph;
                *lpcbGroup = lpph->extsizebytes;
                return lpph;
            }
        }
        else {
            if (FALSE != (fFixMe = !lpph->extsig[0]))      // attempt to fix
                lpph->extsig[0] = *lpszGroup;
            if (lstrcmpiA(lpph->extsig, lpszGroup) == 0) {
                if (lplpph)
                    *lplpph = lpph;
                if (lpcbGroup)
                    *lpcbGroup = lpph->extsizebytes;
                if (lpph->extfileoffset >= (WORD)ppl->cbPIFData) {
                    ASSERTFAIL();
                    return NULL;
                }
                return (LPBYTE)LPPIF_OFF(lpph->extfileoffset);
            }
            if (fFixMe)                         // fix failed (this time anyway)
                lpph->extsig[0] = 0;
        }
        if (lpph->extnxthdrfloff == LASTHDRPTR)
            break;
        lpph = (LPPIFEXTHDR)LPPIF_OFF(lpph->extnxthdrfloff);
    }

    // If we didn't get anywhere, check if this is a "really old" PIF;
    // ie, one without any headers;  if so, then if all they were asking for
    // was the old stuff, return it

    if (ppl->cbPIFData == sizeof(STDPIF) && lpszGroup) {
        if (lstrcmpiA(szSTDHDRSIG, lpszGroup) == 0) {
            if (lplpph)
                *lplpph = NULL;
            if (lpcbGroup)
                *lpcbGroup = sizeof(STDPIF);
            return ppl->lpPIFData;
        }
    }
    return NULL;
}

/** AppWizard - call the AppWizard CPL (appwiz.cpl)
 */



TCHAR c_szAPPWIZ[]    = TEXT("appwiz.cpl");
CHAR  c_szAppWizard[] = "AppWizard";

typedef DWORD (WINAPI *LPAPPWIZARD)(HWND hwnd, HANDLE i, UINT ui);

UINT WINAPI AppWizard(HWND hwnd, HANDLE hProps, UINT action)
{
    DWORD err = 42;
    LPAPPWIZARD XAppWizard;
    HINSTANCE hAppWizard;

    hAppWizard = LoadLibrary(c_szAPPWIZ);

    if (hAppWizard)
    {
        if (NULL != (XAppWizard = (LPAPPWIZARD)GetProcAddress(hAppWizard, c_szAppWizard)))
        {
            err = XAppWizard( hwnd, hProps, action );
        }
        FreeLibrary((HINSTANCE)hAppWizard);
    }

    return (UINT)err;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\pifmgrp.h ===
/*
 *  Microsoft Confidential
 *  Copyright (C) Microsoft Corporation 1992,1993
 *  All Rights Reserved.
 *
 *
 *  PIFMGRP.H
 *  Private PIFMGR include file
 *
 *  History:
 *  Created 31-Jul-1992 3:45pm by Jeff Parsons
 */


#include <windows.h>    // declares NULL the "right" way (as 0)

#ifndef RC_INVOKED
#include <malloc.h>     // misc. C runtime goop
#include <memory.h>
#include <stdlib.h>
#include <string.h>
#ifndef WINNT
#include <setupx.h>     // for Ip (inf) API
#endif
#include <prsht.h>      // for PropertySheet(), pulls in shell.h
#include <commdlg.h>    // for GetOpenFileName(), GetSaveFileName()
#endif /* RC_INVOKED */

#include <commctrl.h>   // for TRACKBAR_CLASS, HOTKEY_CLASS...

#include <regstr.h>
#include <winerror.h>

#ifndef RC_INVOKED
#define PIF_PROPERTY_SHEETS
#include <pif.h>

#include "shellvm.h"    // for struct PIF_Key


#endif /* RC_INVOKED */


/*
 *  Supported app extension types
 */
#define APPTYPE_UNKNOWN         -1
#define APPTYPE_EXE             0
#define APPTYPE_COM             1
#define APPTYPE_BAT             2
#define APPTYPE_CMD             3
#define APPTYPE_PIF             4
#define MAX_APP_TYPES           5


/*
 *  Bitmap IDs
 */

#define DX_TTBITMAP             20
#define DY_TTBITMAP             12

#define MAX_STRING_SIZE         256

#ifndef RC_INVOKED


/*
 * Some typedefs mysteriously missing from windows.h
 */
typedef const WORD * LPCWORD;
typedef const VOID *LPCVOID;// pointer to const void

#define PROP_SIG                0x504A

/*  Property flags
 *
 *  Anyone can set PROP_DIRTY, but only Lock/UnlockPIFData should set
 *  PROP_DIRTYLOCK.  The latter is set/cleared when the last lock is about
 *  to be unlocked (ie, when cLocks is going back to zero).  At that time,
 *  if PROP_DIRTY is set, then we also set PROP_DIRTYLOCK and skip the
 *  call to GlobalUnlock;  on the other hand, if PROP_DIRTY is clear, then
 *  we also clear PROP_DIRTYLOCK and allow the call to GlobalUnlock to proceed.
 *
 *  A consequence is that you must NEVER clear PROP_DIRTY while the data
 *  is unlocked, unless you plan on checking PROP_DIRTYLOCK yourself and
 *  relinquishing that outstanding lock, if it exists.  It is much preferable
 *  to either clear PROP_DIRTY while the data is locked (so that UnlockPIFData
 *  will take care of it), or to simply call FlushPIFData with fDiscard set
 *  appropriately.
 */
#define PROP_DIRTY              0x0001  // memory block modified and unwritten
#define PROP_DIRTYLOCK          0x0002  // memory block locked
#define PROP_TRUNCATE           0x0004  // memory block shrunk, truncate on write
#define PROP_RAWIO              0x0008  // direct access to memory block allowed
#define PROP_NOTIFY             0x0010  // property sheet made changes
#define PROP_IGNOREPIF          0x0020  // entry in [pif] exists, ignore any PIF
#define PROP_SKIPPIF            0x0040  // don't try to open a PIF (various reasons)
#define PROP_NOCREATEPIF        0x0080  // we opened the PIF once, so don't recreate
#define PROP_REGEN              0x0100  // GetPIFData call in progress
#define PROP_DONTWRITE          0x0200  // someone else has flushed, don't write
#define PROP_REALMODE           0x0400  // disable non-real-mode props
#define PROP_PIFDIR             0x0800  // PIF found in PIF directory
#define PROP_NOPIF              0x1000  // no PIF found
#define PROP_DEFAULTPIF         0x2000  // default PIF found
#define PROP_INFSETTINGS        0x4000  // INF settings found
#define PROP_INHIBITPIF         0x8000  // INF or OpenProperties requested no PIF

#if (PROP_NOPIF != PRGINIT_NOPIF || PROP_DEFAULTPIF != PRGINIT_DEFAULTPIF || PROP_INFSETTINGS != PRGINIT_INFSETTINGS || PROP_INHIBITPIF != PRGINIT_INHIBITPIF)
#error Bit mismatch in PIF constants
#endif

#ifndef OF_READ
#define MAXPATHNAME 260
#else
#define MAXPATHNAME 260 // (sizeof(OFSTRUCTEX)-9)
#endif


typedef struct PIFOFSTRUCT {
    DWORD   nErrCode;
    TCHAR   szPathName[MAXPATHNAME];
} PIFOFSTRUCT, *LPPIFOFSTRUCT;


typedef struct PROPLINK {       /* pl */
    struct    PROPLINK *ppl;      //
    struct    PROPLINK *pplNext;  //
    struct    PROPLINK *pplPrev;  //
    int       iSig;               // proplink signature
    int       flProp;             // proplink flags (PROP_*)
    int       cbPIFData;          // size of PIF data
    int       cLocks;             // # of locks, if any
    LPPIFDATA lpPIFData;          // pointer (non-NULL if PIF data locked)
    int       ckbMem;             // memory setting from WIN.INI (-1 if none)
    int       iSheetUsage;        // number of prop sheets using this struct
    LPCTSTR   lpszTitle;          // title to use in dialogs (NULL if none)
    HWND      hwndNotify;         // who to notify when PROP_NOTIFY has been set
    UINT      uMsgNotify;         // message number to use when notifying, 0 if none
    DWORD     hVM;                // handle to associated VM (if any)
    HWND      hwndTty;            // handle to associated window (if any)
    LPTSTR    lpArgs;             // pointer to args for this instance (if any)
    HANDLE    hPIF;               // handle to PIF file
    PIFOFSTRUCT ofPIF;            // hacked OpenFile() structure for PIF
    UINT      iFileName;          // offset of base filename in szPathName
    UINT      iFileExt;           // offset of base filename extension in szPathName
    TCHAR     szPathName[MAXPATHNAME];
} PROPLINK;
typedef PROPLINK *PPROPLINK;


#ifndef ROUNDUNITS
#define ROUNDUNITS(a,b)    (((a)+(b)-1)/(b))
#define ARRAYSIZE(a)    (sizeof(a)/sizeof(a[0]))
#endif

#define INI_WORDS       (5 + ROUNDUNITS(sizeof (WINDOWPLACEMENT), 2))
#define MAX_INT_LENGTH  10      // "-32767" + separator + 3 chars of slop
#define MAX_INI_WORDS   20
#define MAX_INI_BUFFER  (MAX_INT_LENGTH * MAX_INI_WORDS)
#define ISVALIDINI(w)   ((w)==1 || (w)==3 || (w)==5 || (w) == INI_WORDS)

/*  Owing to the fact that wFlags was originally defined as a combination
 *  of font and window settings, WIN_SAVESETTINGS and WIN_TOOLBAR should be
 *  considered reserved FNT flags.  It is problematic to assert that no
 *  one ever use those FNT flags for anything, but I will at least try to
 *  catch them sticking those bits into FNT_DEFAULT....
 */

#if (FNT_DEFAULT & (WIN_SAVESETTINGS | WIN_TOOLBAR))
#error Reserved FNT flags incorrectly used
#endif

#if (FNT_TTFONTS - FNT_RASTERFONTS) != (FNT_BOTHFONTS - FNT_TTFONTS)
#error Incorrect bit value(s) for FNT_RASTERFONTS and/or FNT_TTFONTS
#endif

typedef struct INIINFO {
    WORD    wFlags;             // This order is the same as written to file
    WORD    wFontWidth;         // We assume that if zero width, nothing to init
    WORD    wFontHeight;
    WORD    wWinWidth;
    WORD    wWinHeight;
    WINDOWPLACEMENT wp;         // If normalposition.left & right are zero,
    BYTE    szInvokedName[128+1];//   there is no position to restore
} INIINFO;
typedef INIINFO *PINIINFO;
typedef INIINFO *LPINIINFO;


/*
 * Types/structures for GetINIData
 */
#define INIDATA_DECINT      0x0001
#define INIDATA_FIXEDPOINT  0x0002
#define INIDATA_BOOLEAN     0x0004
#define INIDATA_INVERT      0x1000

typedef struct _INIDATA {
    const TCHAR *pszSection;
    const TCHAR *pszKey;
    void *pValue;
    int  iFlags;
    int  iMask;
} INIDATA, *PINIDATA;

/*
 *  Structure used to define bits associated with control IDs
 */
typedef struct _BITINFO {   /* binf */
    WORD id;                /* Control ID (must be edit control) */
    BYTE bBit;              /* bit #; if bit 7 set, sense of bit reversed */
};
typedef const struct _BITINFO BINF;
typedef const struct _BITINFO *PBINF;

#define Z2(m)               ((m)&1?0:(m)&2?1:2)
#define Z4(m)               ((m)&3?Z2(m):Z2((m)>>2)+2)
#define Z8(m)               ((m)&15?Z4(m):Z4((m)>>4)+4)
#define Z16(m)              ((m)&255?Z8(m):Z8((m)>>8)+8)
#define Z32(m)              ((m)&65535?Z16(m):Z16((m)>>16)+16)
#define BITNUM(m)           Z32(m)

/*
 * Warning: There is some evil overloading of these switches because
 * there isn't enough time to do it `right'.
 *
 * VINF_AUTO means that a value of zero means `Auto' and a nonzero
 * value represents itself.
 *
 * VINF_AUTOMINMAX means that there are really two fields, a min and a
 * max.  If the two values are equal to each other, then the field value
 * is the common value, possibly zero for `None'.  Otherwise, the min
 * is iMin and the max is iMax, which indicates `Auto'.
 */

#define VINF_NONE           0x00
#define VINF_AUTO           0x01    /* integer field supports AUTO only */
#define VINF_AUTOMINMAX     0x02    /* integer field supports AUTO and NONE */

/*
 *  Structure used to validate integer parameters in property sheets.
 */
typedef struct _VALIDATIONINFO {/* vinf */
    BYTE off;               /* offset of integer in property structure */
    BYTE fbOpt;             /* See VINF_* constants */
    WORD id;                /* Control ID (must be edit control) */
    INT  iMin;              /* Minimum acceptable value */
    INT  iMax;              /* Maximum acceptable value */
    WORD idMsg;             /* Message resource for error message */
};
typedef const struct _VALIDATIONINFO VINF;
typedef const struct _VALIDATIONINFO *PVINF;

#define NUM_TICKS 20        /* Number of tick marks in slider control */

/*
 *  Macro to dispatch Help subsystem messages.
 */
#define HELP_CASES(rgdwHelp)                                        \
    case WM_HELP:               /* F1 or title-bar help button */   \
        OnWmHelp(lParam, &rgdwHelp[0]);                             \
        break;                                                      \
                                                                    \
    case WM_CONTEXTMENU:        /* right mouse click */             \
        OnWmContextMenu(wParam, &rgdwHelp[0]);                      \
        break;


/*
 *  Internal function prototypes
 */

/* XLATOFF */

#ifndef DEBUG
#define ASSERTFAIL()
#define ASSERTTRUE(exp)
#define ASSERTFALSE(exp)
#define VERIFYTRUE(exp)  (exp)
#define VERIFYFALSE(exp) (exp)
#else
#define ASSERTFAIL()     ASSERT(FALSE)
#define ASSERTTRUE(exp)  ASSERT((exp))
#define ASSERTFALSE(exp) ASSERT((!(exp)))
#define VERIFYTRUE(exp)  ASSERT((exp))
#define VERIFYFALSE(exp) ASSERT((!(exp)))
#endif

/*
 * CTASSERT  -- Assert at compile-time, standalone.
 * CTASSERTF -- Assert at compile-time, inside a function.
 */

#define CTASSERTF(c) switch (0) case 0: case c:
#define CTASSERTPP(c,l) \
    static INLINE void Assert##l(void) { CTASSERTF(c); }
#define CTASSERTP(c,l) CTASSERTPP(c,l)
#define CTASSERT(c) CTASSERTP(c,__LINE__)


/*
 * FunctionName allows us to make something happen on entry to every function.
 *
 * If SWAP_TUNING is defined, then the function name is squirted out the first
 * time it is called.  This is used to decide which functions should go into
 * the PRELOAD segment and which in the RARE segment.
 */

#ifndef DEBUG
#define FunctionName(f)
#else
#ifdef SWAP_TUNING
#define FunctionName(f) \
    static fSeen = 0; if (!fSeen) { OutputDebugString(#f TEXT("\r\n")); fSeen = 1; }
#else
#define FunctionName(f)
#endif
#endif


#ifdef WINNT
#ifdef UNICODE

// NT and UNICODE
#define NUM_DATA_PTRS 4
#else

// NT, but not UNICODE
#define NUM_DATA_PTRS 3
#endif

#else

// Neither NT or UNICODE
#define NUM_DATA_PTRS 2

#endif

#define LP386_INDEX 0
#define LPENH_INDEX 1
#define LPNT31_INDEX 2
#define LPNT40_INDEX 3

#ifdef WINNT
// Macro definitions that handle codepages 
//
#define CP_US       (UINT)437
#define CP_JPN      (UINT)932
#define CP_WANSUNG  (UINT)949
#define CP_TC       (UINT)950
#define CP_SC       (UINT)936

#define IsBilingualCP(cp) ((cp)==CP_JPN || (cp)==CP_WANSUNG)
#define IsFarEastCP(cp) ((cp)==CP_JPN || (cp)==CP_WANSUNG || (cp)==CP_TC || (cp)==CP_SC)
#endif

typedef LPVOID * DATAPTRS;


typedef int (*GETSETFN)(HANDLE hProps, LPCSTR lpszGroup, LPVOID lpProps, int cbProps, UINT flOpt);
typedef int (*DATAGETFN)(PPROPLINK ppl, DATAPTRS aDataPtrs, LPVOID lpData, int cbData, UINT flOpt);
typedef int (*DATASETFN)(PPROPLINK ppl, DATAPTRS aDataPtrs, LPCVOID lpData, int cbData, UINT flOpt);


/*
 *  Constant strings used in multiple places.
 *
 *  The null string is so popular, we keep a copy of it in each segment.
 */

extern const TCHAR c_szNULL[];     // Null string in nonresident code segment
extern const TCHAR r_szNULL[];     // Null string in resident code segment

extern TCHAR g_szNone[16];
extern TCHAR g_szAuto[16];

extern const TCHAR szNoPIFSection[];

extern CHAR szSTDHDRSIG[];
extern CHAR szW286HDRSIG30[];
extern CHAR szW386HDRSIG30[];
extern CHAR szWENHHDRSIG40[];

extern CHAR szCONFIGHDRSIG40[];
extern CHAR szAUTOEXECHDRSIG40[];

extern const TCHAR szDOSAPPDefault[];
extern const TCHAR szDOSAPPINI[];
extern const TCHAR szDOSAPPSection[];

// In alphabetical order, for sanity's sake.

extern const TCHAR sz386EnhSection[];
extern const TCHAR szDisplay[];
extern const TCHAR szTTDispDimKey[];
extern const TCHAR szTTInitialSizes[];

extern const TCHAR szNonWinSection[];
extern const TCHAR szPP4[];
extern const TCHAR szSystemINI[];
extern const TCHAR szWOAFontKey[];
extern const TCHAR szWOADBCSFontKey[];
extern const TCHAR szZero[];

// these are initialized at LoadGlobalFontData()
extern TCHAR szTTCacheSection[2][32];
extern CHAR szTTFaceName[2][LF_FACESIZE];

#ifdef  CUSTOMIZABLE_HEURISTICS
extern const TCHAR szTTHeuristics[];
extern const TCHAR szTTNonAspectMin[];
#endif

extern const TCHAR *apszAppType[];

// pifdll.asm
void GetSetExtendedData(DWORD hVM, WORD wGroup, LPCTSTR lpszGroup, LPVOID lpProps);
WORD GetVxDVersion(WORD wVxdId);
BOOL IsBufferDifferent(LPVOID lpv1, LPVOID lpv2, UINT cb);
#ifndef WIN32
void BZero(LPVOID lpvBuf, UINT cb);
#else
#define BZero(lpvBuf,cb) ZeroMemory(lpvBuf,(DWORD)cb)
#endif
#ifndef WINNT
WORD flEmsSupport(void);
#endif

// pifmgr.c

void GetINIData(void);
void InitProperties(PPROPLINK ppl, BOOL fLocked);

void ReadAdvPrgData(PPROPLINK ppl, int cbMax, LPCSTR lpszName, LPTSTR pszFile, UINT flOpt);
BOOL WriteAdvPrgData(PPROPLINK ppl, int cbMax, LPCSTR lpszName, LPTSTR pszFile, LPTSTR pszOrigFile, BOOL fCreateAnyway, BOOL fForceReboot);

PPROPLINK ValidPropHandle(HANDLE hProps);
int   ResizePIFData(PPROPLINK ppl, int cbResize);
BOOL  GetPIFData(PPROPLINK ppl, BOOL fLocked);
BOOL  FlushPIFData(PPROPLINK ppl, BOOL fDiscard);

LPWENHPIF40 AddEnhancedData(PPROPLINK ppl, LPW386PIF30 lp386);
BOOL        AddGroupData(PPROPLINK ppl, LPCSTR lpszGroup, LPVOID lpGroup, int cbGroup);
BOOL        RemoveGroupData(PPROPLINK ppl, LPCSTR lpszGroup);
LPVOID      GetGroupData(PPROPLINK ppl, LPCSTR lpszGroup, LPINT lpcbGroup, LPPIFEXTHDR *lplpph);

// pifdat.c


int GetPrgData(PPROPLINK ppl, DATAPTRS aDataPtrs, LPPROPPRG lpPrg, int cb, UINT flOpt);
int SetPrgData(PPROPLINK ppl, DATAPTRS aDataPtrs, LPPROPPRG lpPrg, int cb, UINT flOpt);
int GetTskData(PPROPLINK ppl, DATAPTRS aDataPtrs, LPPROPTSK lpTsk, int cb, UINT flOpt);
int SetTskData(PPROPLINK ppl, DATAPTRS aDataPtrs, LPPROPTSK lpTsk, int cb, UINT flOpt);
int GetVidData(PPROPLINK ppl, DATAPTRS aDataPtrs, LPPROPVID lpVid, int cb, UINT flOpt);
int SetVidData(PPROPLINK ppl, DATAPTRS aDataPtrs, LPPROPVID lpVid, int cb, UINT flOpt);
int GetMemData(PPROPLINK ppl, DATAPTRS aDataPtrs, LPPROPMEM lpMem, int cb, UINT flOpt);
int SetMemData(PPROPLINK ppl, DATAPTRS aDataPtrs, LPPROPMEM lpMem, int cb, UINT flOpt);
int GetKbdData(PPROPLINK ppl, DATAPTRS aDataPtrs, LPPROPKBD lpKbd, int cb, UINT flOpt);
int SetKbdData(PPROPLINK ppl, DATAPTRS aDataPtrs, LPPROPKBD lpKbd, int cb, UINT flOpt);
int GetMseData(PPROPLINK ppl, DATAPTRS aDataPtrs, LPPROPMSE lpMse, int cb, UINT flOpt);
int SetMseData(PPROPLINK ppl, DATAPTRS aDataPtrs, LPPROPMSE lpMse, int cb, UINT flOpt);
int GetSndData(PPROPLINK ppl, DATAPTRS aDataPtrs, LPPROPSND lpSnd, int cb, UINT flOpt);
int SetSndData(PPROPLINK ppl, DATAPTRS aDataPtrs, LPPROPSND lpSnd, int cb, UINT flOpt);
int GetFntData(PPROPLINK ppl, DATAPTRS aDataPtrs, LPPROPFNT lpFnt, int cb, UINT flOpt);
int SetFntData(PPROPLINK ppl, DATAPTRS aDataPtrs, LPPROPFNT lpFnt, int cb, UINT flOpt);
int GetWinData(PPROPLINK ppl, DATAPTRS aDataPtrs, LPPROPWIN lpWin, int cb, UINT flOpt);
int SetWinData(PPROPLINK ppl, DATAPTRS aDataPtrs, LPPROPWIN lpWin, int cb, UINT flOpt);
int GetEnvData(PPROPLINK ppl, DATAPTRS aDataPtrs, LPPROPENV lpEnv, int cb, UINT flOpt);
int SetEnvData(PPROPLINK ppl, DATAPTRS aDataPtrs, LPPROPENV lpEnv, int cb, UINT flOpt);
#ifdef WINNT
int GetNt31Data(PPROPLINK ppl, DATAPTRS aDataPtrs, LPPROPNT31 lpNt31, int cb, UINT flOpt);
int SetNt31Data(PPROPLINK ppl, DATAPTRS aDataPtrs, LPPROPNT31 lpNt31, int cb, UINT flOpt);
#endif
#ifdef UNICODE
int GetNt40Data(PPROPLINK ppl, DATAPTRS aDataPtrs, LPPROPNT40 lpNt40, int cb, UINT flOpt);
int SetNt40Data(PPROPLINK ppl, DATAPTRS aDataPtrs, LPPROPNT40 lpNt40, int cb, UINT flOpt);
#endif


void CopyIniWordsToFntData(LPPROPFNT lpFnt, LPINIINFO lpii, int cWords);
void CopyIniWordsToWinData(LPPROPWIN lpWin, LPINIINFO lpii, int cWords);

// These could be defined as WINAPI if we ever wanted to export them back to WinOldAp

WORD GetIniWords(LPCTSTR lpszSection, LPCTSTR lpszEntry, LPWORD lpwBuf, WORD cwBuf, LPCTSTR lpszFilename);
WORD ParseIniWords(LPCTSTR lpsz, LPWORD lpwBuf, WORD cwBuf, LPTSTR *lplpsz);
BOOL WriteIniWords(LPCTSTR lpszSection, LPCTSTR lpszEntry, LPCWORD lpwBuf, WORD cwBuf, LPCTSTR lpszFilename);

// piflib.c

BOOL LoadGlobalEditData(void);
void FreeGlobalEditData(void);
void InitRealModeFlag(PPROPLINK ppl);

// pifprg.c

BOOL_PTR CALLBACK DlgPrgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
#ifdef UNICODE
HICON LoadPIFIcon(LPPROPPRG lpprg, LPPROPNT40 lpnt40);
#else
HICON LoadPIFIcon(LPPROPPRG lpprg);
#endif

// pifvid.c

BOOL_PTR CALLBACK DlgVidProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

// pifmem.c

BOOL_PTR CALLBACK DlgMemProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

// pifmsc.c

BOOL_PTR CALLBACK DlgMscProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);

// pifhot.c
WORD HotKeyWindowsFromOem(LPCPIFKEY lppifkey);
void HotKeyOemFromWindows(LPPIFKEY lppifkey, WORD wHotKey);

// pifsub.c

void  lstrcpytrimA(LPSTR lpszDst, LPCSTR lpszSrc, int cbMax);
void  lstrcpypadA(LPSTR lpszDst, LPCSTR lpszSrc, int cbMax);
int   lstrcpyncharA(LPSTR lpszDst, LPCSTR lpszSrc, int cbMax, CHAR ch);
int   lstrskipcharA(LPCSTR lpszSrc, CHAR ch);
int   lstrskiptocharA(LPCSTR lpszSrc, CHAR ch);
int lstrcpyfnameA(LPSTR lpszDst, LPCSTR lpszSrc, int cbMax);
int lstrunquotefnameA(LPSTR lpszDst, LPCSTR lpszSrc, int cbMax, BOOL fShort);
int lstrskipfnameA(LPCSTR lpszSrc);

int cdecl Warning(HWND hwnd, WORD id, WORD type, ...);
int MemoryWarning(HWND hwnd);
LPTSTR LoadStringSafe(HWND hwnd, UINT id, LPTSTR lpsz, int cbsz);
void SetDlgBits(HWND hDlg, PBINF pbinf, UINT cbinf, WORD wFlags);
void GetDlgBits(HWND hDlg, PBINF pbinf, UINT cbinf, LPWORD lpwFlags);
void SetDlgInts(HWND hDlg, PVINF pvinf, UINT cvinf, LPVOID lp);
void AddDlgIntValues(HWND hDlg, int id, int iMax);
void GetDlgInts(HWND hDlg, PVINF pvinf, int cvinf, LPVOID lp);
BOOL ValidateDlgInts(HWND hDlg, PVINF pvinf, int cvinf);

void LimitDlgItemText(HWND hDlg, int iCtl, UINT uiLimit);
void SetDlgItemPct(HWND hDlg, int iCtl, UINT uiPct);
UINT GetDlgItemPct(HWND hDlg, int iCtl);
void SetDlgItemPosRange(HWND hDlg, int iCtl, UINT uiPos, DWORD dwRange);
UINT GetDlgItemPos(HWND hDlg, int iCtl);
void EnableDlgItems(HWND hDlg, PBINF pbinf, int cbinf, BOOL fEnable);
void DisableDlgItems(HWND hDlg, PBINF pbinf, int cbinf);
BOOL AdjustRealModeControls(PPROPLINK ppl, HWND hDlg);
void BrowsePrograms(HWND hDlg, UINT uiCtl, UINT uiCwd);
void OnWmHelp(LPARAM lparam, const DWORD *pdwHelp);
void OnWmContextMenu(WPARAM wparam, const DWORD *pdwHelp);
#ifdef UNICODE
void PifMgr_WCtoMBPath( LPWSTR lpUniPath, LPSTR lpAnsiPath, UINT cchBuf );
#endif

void PifMgrDLL_Init();
void PifMgrDLL_Term();

#ifdef  DEBUG
void DebugASSERT(TCHAR *pszModule, int line);
#endif

extern TCHAR   *pszNoMemory;

extern CHAR szRasterFaceName[];

#endif /* RC_INVOKED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\precomp.h ===
/* Precompiled Header */

#define UNICODE 1
#define NO_PIF_HDRS

#include "..\shellprv.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\pifsub.c ===
/*
 *  Microsoft Confidential
 *  Copyright (C) Microsoft Corporation 1991
 *  All Rights Reserved.
 *
 *
 *  PIFSUB.C
 *  Misc. subroutines for PIFMGR.DLL
 *
 *  History:
 *  Created 31-Jul-1992 3:30pm by Jeff Parsons
 */


#include "shellprv.h"
#pragma hdrstop

// shell priv can alter the definition of IsDBCSLeadByte!
#if defined(FE_SB)
#ifdef IsDBCSLeadByte
#undef IsDBCSLeadByte
#define IsDBCSLeadByte(x) IsDBCSLeadByteEx(CP_ACP,x)
#endif
#endif

/*
 * Most of the routines in this file will need to stay ANSI.  If a UNICODE
 * version is needed, it is supplied.
 *
 * This is because for the most part, the information in the PIF files
 * is ANSI and needs to stay that way.
 *
 * (RickTu)
 *
 */


/** lstrcpytrimA - copy fixed-length string, trimming trailing blanks
 *
 * INPUT
 *  lpszDst -> destination string
 *  lpszSrc -> fixed-length source string
 *  cchMax = size (in characters) of fixed-length source string
 *
 * OUTPUT
 *  Nothing
 */

void lstrcpytrimA(LPSTR lpszDst, LPCSTR lpszSrc, int cchMax)
{
    CHAR ch;
    int cchSave = 0;
    LPSTR lpszSave = lpszDst;
    FunctionName(lstrcpytrim);

    while (cchMax && *lpszSrc) {
        ch = *lpszSrc++;
        if (ch == ' ') {
            if (!cchSave) {
                cchSave = cchMax;
                lpszSave = lpszDst;
            }
        } else
            cchSave = 0;
        *lpszDst = ch;
        if (--cchMax) {
            lpszDst++;
#if (defined(DBCS) || defined(FE_SB))
            if (IsDBCSLeadByte(ch) && --cchMax) {
                *lpszDst++ = *lpszSrc++;
            }
#endif
        }
    }
    while (cchSave--)
        *lpszSave++ = '\0';
    *lpszDst = '\0';
}


/** lstrcpypadA - copy to fixed-length string, appending trailing blanks
 *
 * INPUT
 *  lpszDst -> fixed-length destination string
 *  lpszSrc -> source string
 *  cchMax = size of fixed-length destination string (count of characters)
 *
 * OUTPUT
 *  Nothing
 */

void lstrcpypadA(LPSTR lpszDst, LPCSTR lpszSrc, int cchMax)
{
    FunctionName(lstrcpypadA);
    while (cchMax && *lpszSrc) {
        cchMax--;
        *lpszDst++ = *lpszSrc++;
    }
    while (cchMax--) {
        *lpszDst++ = ' ';
    }
}


/** lstrcpyncharA - copy variable-length string, until char
 *
 * INPUT
 *  lpszDst -> fixed-length destination string
 *  lpszSrc -> source string
 *  cchMax = size of fixed-length destination string (count of characters)
 *  ch = character to stop copying at
 *
 * OUTPUT
 *  # of characters copied, excluding terminating NULL
 */

int lstrcpyncharA(LPSTR lpszDst, LPCSTR lpszSrc, int cchMax, CHAR ch)
{
    int cch = 0;
    FunctionName(lstrcpyncharA);

    while (--cchMax && *lpszSrc && *lpszSrc != ch) {
#if (defined(DBCS) || defined(FE_SB))
        if (IsDBCSLeadByte(*lpszSrc)) {
            cch++;
            *lpszDst++ = *lpszSrc++;
            if (!*lpszSrc) break;   /* Eek!  String ends in DBCS lead byte! */
        }
#endif
        cch++;
        *lpszDst++ = *lpszSrc++;
    }
    *lpszDst = '\0';
    return cch;
}


/** lstrskipcharA - skip char in variable-length string
 *
 * INPUT
 *  lpszSrc -> source string
 *  ch = character to skip
 *
 * OUTPUT
 *  # of characters skipped, 0 if none
 */

int lstrskipcharA(LPCSTR lpszSrc, CHAR ch)
{
    int cch = 0;
    FunctionName(lstrskipcharA);

    while (*lpszSrc && *lpszSrc == ch) {
        cch++;
        lpszSrc++;
    }
    return cch;
}

/** lstrskiptocharA - skip *to* char in variable-length string
 *
 * INPUT
 *  lpszSrc -> source string
 *  ch = character to skip *to*
 *
 * OUTPUT
 *  # of characters skipped, 0 if none;  if char didn't exist, then all
 *  characters are skipped.
 */

int lstrskiptocharA(LPCSTR lpszSrc, CHAR ch)
{
    int cch = 0;
    FunctionName(lstrskiptocharA);

    while (*lpszSrc && *lpszSrc != ch) {
        cch++;
        lpszSrc++;
    }
    return cch;
}


/** lstrcpyfnameA - copy filename appropriately
 *
 * INPUT
 *  lpszDst -> output buffer
 *  lpszSrc -> source filename
 *  cbMax = size of output buffer
 *
 * OUTPUT
 *  # of characters copied, including quotes if any, excluding terminating NULL
 */

int lstrcpyfnameA(LPSTR lpszDst, LPCSTR lpszSrc, int cchMax)
{
    int cch;
    CHAR ch;
    FunctionName(lstrcpyfnameA);

    if (TEXT('\0') != (ch = lpszSrc[lstrskiptocharA(lpszSrc, ' ')])) {
        cchMax -= 2;
        *lpszDst++ = '\"';
    }

    lstrcpynA(lpszDst, lpszSrc, cchMax);
    cch = lstrlenA(lpszDst);

    if (ch) {
        lpszDst[cch++] = '\"';
        lpszDst[cch] = 0;
    }
    return cch;
}


/** lstrunquotefnameA - unquote filename if it contains quotes
 *
 * INPUT
 *  lpszDst -> output buffer
 *  lpszSrc -> source filename (quoted or unquoted)
 *  cchMax = size of output buffer (count of characters)
 *  fShort = TRUE if filename should be converted to 8.3 (eg, for real-mode);
 *           -1 if the filename is known to not be quoted and should just be converted
 * OUTPUT
 *  # of characters copied, excluding terminating NULL
 */

int lstrunquotefnameA(LPSTR lpszDst, LPCSTR lpszSrc, int cchMax, BOOL fShort)
{
    int cch;
    FunctionName(lstrunquotefnameA);

    if (fShort != -1) {

        if (lpszSrc[0] == '\"') {
            cch = lstrcpyncharA(lpszDst, lpszSrc+1, cchMax, '\"');
        }
        else {
            cch = lstrcpyncharA(lpszDst, lpszSrc, cchMax, ' ');
        }
        lpszSrc = lpszDst;
    }
    if (fShort) {
        cch = 1;
        CharToOemA(lpszSrc, lpszDst);
        cch = GetShortPathNameA( lpszSrc, lpszDst, cchMax );
        if (cch) {                       // if no error...
            if (fShort == TRUE) {       // if conversion for real-mode...
                if ((int)GetFileAttributesA(lpszDst) == -1) {
                                        // if filename doesn't exist,
                                        // then just copy the 8.3 portion
                                        // and hope the user's real-mode PATH
                                        // ultimately finds it!

                    if (NULL != (lpszSrc = StrRChrA(lpszDst, NULL, '\\'))) {
                        lstrcpyA(lpszDst, lpszSrc+1);
                    }
                }
            }
            cch = lstrlenA(lpszDst);      // recompute the length of the string
        }
    }
    return cch;
}


/** lstrskipfnameA - skip filename in string
 *
 * INPUT
 *  lpszSrc -> string beginning with filename (quoted or unquoted)
 *
 * OUTPUT
 *  # of characters skipped, 0 if none
 */

int lstrskipfnameA(LPCSTR lpszSrc)
{
    int cch = 0;
    FunctionName(lstrskipfname);

    if (lpszSrc[0] == '\"') {
        cch = lstrskiptocharA(lpszSrc+1, '\"') + 1;
        if (lpszSrc[cch] == '\"')
            cch++;
    }
    else
        cch = lstrskiptocharA(lpszSrc, ' ');
    return cch;
}


/*
 * NOTE! The careful definitions of achBuf and achFmt, so that
 * we can support total output of 2 * MAX_STRING_SIZE bytes.
 */
int cdecl Warning(HWND hwnd, WORD id, WORD type, ...)
{
    LPCTSTR lpchFmt;
    PPROPLINK ppl = NULL;
    TCHAR achBuf[2*MAX_STRING_SIZE];
#define achFmt (&achBuf[MAX_STRING_SIZE])
    va_list ArgList;
    FunctionName(Warning);

    lpchFmt = achFmt;

    // We never use MB_FOCUS to mean whatever it's really supposed
    // to mean;  we just use it as a kludge to support warning dialogs
    // when all we have is a ppl, not an hwnd.

    if (type & MB_NOFOCUS) {
        ppl = (PPROPLINK)hwnd;
        hwnd = NULL;
        type &= ~MB_NOFOCUS;
    }
    else if (hwnd)
        ppl = ((PPROPLINK)GetWindowLongPtr(hwnd, DWLP_USER))->ppl;

    if (id == IDS_ERROR + ERROR_NOT_ENOUGH_MEMORY)
        lpchFmt = TEXT("");
    else {
        if (!LoadString(g_hinst, id, achFmt, MAX_STRING_SIZE)) {
            ASSERTFAIL();
            lpchFmt = TEXT("");
        }
    }

    va_start(ArgList,type);
    wvnsprintf(achBuf, MAX_STRING_SIZE, lpchFmt, ArgList);
    va_end(ArgList);

    lpchFmt = NULL;
    if (ppl) {
        ASSERTTRUE(ppl->iSig == PROP_SIG);
        if (!(lpchFmt = ppl->lpszTitle))
            lpchFmt = ppl->szPathName+ppl->iFileName;
    }
    return MessageBox(hwnd, achBuf, lpchFmt, type);
}
#undef achFmt

int MemoryWarning(HWND hwnd)
{
    FunctionName(MemoryWarning);
    return Warning(hwnd, IDS_ERROR + ERROR_NOT_ENOUGH_MEMORY, MB_ICONEXCLAMATION | MB_OK);
}


LPTSTR LoadStringSafe(HWND hwnd, UINT id, LPTSTR lpsz, int cchsz)
{
    FunctionName(LoadStringSafe);
    if (!LoadString(g_hinst, id, lpsz, cchsz)) {
        ASSERTFAIL();
        if (hwnd) {
            MemoryWarning(hwnd);
            return NULL;
        }
        lpsz = TEXT("");
    }
    return lpsz;
}


/** SetDlgBits - Check various dialog checkboxes according to given flags
 *
 * INPUT
 *  hDlg   = HWND of dialog box
 *  pbinf -> array of bitinfo descriptors
 *  cbinf  = size of array
 *  wFlags = flags
 *
 * OUTPUT
 *  Returns NOTHING
 */

void SetDlgBits(HWND hDlg, PBINF pbinf, UINT cbinf, WORD wFlags)
{
    FunctionName(SetDlgBits);

    ASSERTTRUE(cbinf > 0);
    do {
        ASSERTTRUE((pbinf->bBit & 0x3F) < 16);
        CheckDlgButton(hDlg, pbinf->id,
                       !!(wFlags & (1 << (pbinf->bBit & 0x3F))) == !(pbinf->bBit & 0x80));
    } while (++pbinf, --cbinf);
}


/** GetDlgBits - Set various flags according to dialog checkboxes
 *
 * INPUT
 *  hDlg   = HWND of dialog box
 *  pbinf -> array of bitinfo descriptors
 *  cbinf  = size of array
 *  lpwFlags -> flags word
 *
 * OUTPUT
 *  Returns NOTHING
 */

void GetDlgBits(HWND hDlg, PBINF pbinf, UINT cbinf, LPWORD lpwFlags)
{
    WORD wFlags;
    FunctionName(GetDlgBits);

    ASSERTTRUE(cbinf > 0);
    wFlags = *lpwFlags;
    do {
        ASSERTTRUE((pbinf->bBit & 0x3F) < 16);

        if (pbinf->bBit & 0x40)         // 0x40 is a special bit mask
            continue;                   // that means "set but don't get
                                        // this control's value"
        wFlags &= ~(1 << (pbinf->bBit & 0x3F));
        if (!!IsDlgButtonChecked(hDlg, pbinf->id) == !(pbinf->bBit & 0x80))
            wFlags |= (1 << (pbinf->bBit & 0x3F));

    } while (++pbinf, --cbinf);
    *lpwFlags = wFlags;
}


/** SetDlgInts - Set various edit controls according to integer fields
 *
 * INPUT
 *  hDlg   = HWND of dialog box
 *  pvinf -> array of validation info descriptors
 *  cvinf  = size of array
 *  lp    -> structure of integers
 *
 * OUTPUT
 *  Returns NOTHING
 */

void SetDlgInts(HWND hDlg, PVINF pvinf, UINT cvinf, LPVOID lp)
{
    WORD wMin, wMax;
    FunctionName(SetDlgInts);

    ASSERTTRUE(cvinf > 0);
    do {
        wMin = wMax = *(WORD UNALIGNED *)((LPBYTE)lp + pvinf->off);

        if (pvinf->fbOpt & VINF_AUTO) {

            SendDlgItemMessage(hDlg, pvinf->id, CB_ADDSTRING, 0, (LPARAM)(LPTSTR)g_szAuto);

            AddDlgIntValues(hDlg, pvinf->id, pvinf->iMax);

            if (wMin == 0) {
                SetDlgItemText(hDlg, pvinf->id, g_szAuto);
                continue;
            }
        }
        if (pvinf->fbOpt & VINF_AUTOMINMAX) {

            SendDlgItemMessage(hDlg, pvinf->id, CB_ADDSTRING, 0, (LPARAM)(LPTSTR)g_szAuto);
            SendDlgItemMessage(hDlg, pvinf->id, CB_ADDSTRING, 0, (LPARAM)(LPTSTR)g_szNone);

            AddDlgIntValues(hDlg, pvinf->id, pvinf->iMax);

            // When AUTOMINMAX is set, we assume that the field
            // we're validating is followed in its structure by a
            // corresponding max WORD.

            wMax = *(WORD UNALIGNED *)((LPBYTE)lp + pvinf->off + sizeof(WORD));

            if (wMin == 0 && wMax == 0) {
                SetDlgItemText(hDlg, pvinf->id, g_szNone);
                continue;
            }

            // Let's try to simplify things by mapping 0xFFFF (aka -1)
            // to settings that mean "Auto"

            if (wMin == 0xFFFF || wMax == 0xFFFF) {
                wMin = 0;
                wMax = (WORD)pvinf->iMax;
            }

            if (wMax == (WORD)pvinf->iMax) {
                SetDlgItemText(hDlg, pvinf->id, g_szAuto);
                continue;
            }

            if (wMin != wMax) {
                //
                // We're in a bit of a quandary here.  The settings show
                // explicit min and max values which are not equal, probably
                // due to settings inherited from a 3.1 PIF file.  We'll
                // just go with the wMax value.  Fortunately for us, we
                // don't actually have to *do* anything to make this happen.
                //
            }
        }
        SetDlgItemInt(hDlg, pvinf->id, wMin, pvinf->iMin < 0);

    } while (++pvinf, --cvinf);
}


/** AddDlgIntValues - Fill integer combo-box with appropriate values
 *
 * INPUT
 *  hDlg   = HWND of dialog box
 *  id     = dialog control ID
 *  iMax   = maximum value
 *
 * OUTPUT
 *  Returns NOTHING
 */

void AddDlgIntValues(HWND hDlg, int id, int iMax)
{
    int iStart, iInc;
    TCHAR achValue[16];

    // HACK to make this do something sensible with the environment max;
    // they can still enter larger values (up to ENVSIZE_MAX) but I don't
    // see any sense in encouraging it. -JTP

    if ((WORD)iMax == ENVSIZE_MAX)
        iMax = 4096;

    if ((iMax < 0) || (iMax == 0xFFFF)) // HACK to make this do something sensible
        iMax = 16384;           // with fields that allow huge maximums -JTP

    iStart = iInc = iMax/16;    // arbitrarily chop the range up 16 times

    while (iStart <= iMax) {
        wsprintf(achValue, TEXT("%d"), iStart);
        SendDlgItemMessage(hDlg, id, CB_ADDSTRING, 0, (LPARAM)(LPTSTR)achValue);
        iStart += iInc;
    }
}


/** GetDlgInts - Set various integer fields according to dialog edit controls
 *
 * INPUT
 *  hDlg   = HWND of dialog box
 *  pvinf -> array of validation info descriptors
 *  cvinf  = size of array
 *  lp    -> structure of integers
 *
 * OUTPUT
 *  Returns NOTHING
 */

void GetDlgInts(HWND hDlg, PVINF pvinf, int cvinf, LPVOID lp)
{
    WORD wMin, wMax;
    UINT uTemp;
    BOOL fSuccess;
    TCHAR achText[32];
    FunctionName(GetDlgInts);

    ASSERTTRUE(cvinf > 0);
    do {
        uTemp = GetDlgItemInt(hDlg, pvinf->id, &fSuccess, pvinf->iMin < 0);
        ASSERT(HIWORD(uTemp)==0);

        wMin = LOWORD(uTemp);

        // In case of error, make sure wMin doesn't actually change

        if (!fSuccess)
            wMin = *(WORD UNALIGNED *)((LPBYTE)lp + pvinf->off);

        if (pvinf->fbOpt & VINF_AUTO) {

            GetDlgItemText(hDlg, pvinf->id, achText, ARRAYSIZE(achText));

            if (lstrcmpi(achText, g_szAuto) == 0) {
                wMin = 0;
            }
        }

        if (pvinf->fbOpt & VINF_AUTOMINMAX) {

            // When AUTOMINMAX is set, we assume that the field
            // we're validating is followed in its structure by a
            // corresponding max WORD, which we will ZERO if the
            // user selects NONE, or set to its MAXIMUM if the user
            // selects AUTO, or otherwise set to match the specified
            // MINIMUM.

            wMax = wMin;

            GetDlgItemText(hDlg, pvinf->id, achText, ARRAYSIZE(achText));

            if (lstrcmpi(achText, g_szAuto) == 0) {
                wMin = 0;
                wMax = (WORD)pvinf->iMax;
            }
            else if (lstrcmpi(achText, g_szNone) == 0) {
                wMin = 0;
                wMax = 0;
            }

            *(WORD UNALIGNED *)((LPBYTE)lp + pvinf->off + sizeof(WORD)) = wMax;
        }

        *(WORD UNALIGNED *)((LPBYTE)lp + pvinf->off) = wMin;

    } while (++pvinf, --cvinf);
}


/** ValidateDlgInts - Validate that integer fields are value
 *
 * INPUT
 *  hDlg   = HWND of dialog box
 *  pvinf -> array of validation descriptors
 *  cvinf  = size of array
 *
 * OUTPUT
 *  Returns TRUE if something is wrong; FALSE if all is okay.
 */

BOOL ValidateDlgInts(HWND hDlg, PVINF pvinf, int cvinf)
{
    DWORD dw;
    BOOL fSuccess;
    TCHAR achText[32];
    FunctionName(ValidateDlgInts);

    ASSERTTRUE(cvinf > 0);
    do {
        dw = GetDlgItemInt(hDlg, pvinf->id, &fSuccess, pvinf->iMin < 0);

        // NOTE: AUTO is for "Auto" only, whereas AUTOMINMAX is for
        // "Auto" and "None".  However, in the interest of simplicity, I
        // don't complain if either string is used in either case.

        if (pvinf->fbOpt & (VINF_AUTO | VINF_AUTOMINMAX)) {
            if (!fSuccess) {
                GetDlgItemText(hDlg, pvinf->id, achText, ARRAYSIZE(achText));
                if (lstrcmpi(achText, g_szNone) == 0 ||
                    lstrcmpi(achText, g_szAuto) == 0) {
                    continue;   // things be lookin' good, check next int...
                }
            }
        }
        if (!fSuccess || dw < (DWORD)pvinf->iMin || dw > (DWORD)pvinf->iMax) {
            Warning(hDlg, pvinf->idMsg, MB_ICONEXCLAMATION | MB_OK, pvinf->iMin, pvinf->iMax);
            SendDlgItemMessage(hDlg, pvinf->id, EM_SETSEL, 0, MAKELPARAM(0,-1));
            SetFocus(GetDlgItem(hDlg, pvinf->id));
            return TRUE;        // things be lookin' bad, bail out...
        }
    } while (++pvinf, --cvinf);
    return FALSE;
}


/*
 * NOTE -- The compiler emits really bad code for some of these guys.
 * In those cases, we are merely wrapping a call; there is no need to save BP.
 */


/** LimitDlgItemText - Sets the limit for a dialog edit control
 *
 * INPUT
 *  hDlg = HWND of dialog box
 *  iCtl = ID of control
 *  uiLimit = text limit
 *
 * OUTPUT
 *  None.
 */
void LimitDlgItemText(HWND hDlg, int iCtl, UINT uiLimit)
{
    FunctionName(LimitDlgItemText);

    SendDlgItemMessage(hDlg, iCtl, EM_LIMITTEXT, uiLimit, 0);
}


/** SetDlgItemPosRange - Sets the pos and range for a dialog slider control
 *
 * INPUT
 *  hDlg = HWND of dialog box
 *  iCtl = ID of control
 *  uiPos = Current position
 *  dwRange = Range (min in low word, max in high word)
 *
 * OUTPUT
 *  None.
 */
void SetDlgItemPosRange(HWND hDlg, int iCtl, UINT uiPos, DWORD dwRange)
{
    FunctionName(SetDlgItemPosRange);

    SendDlgItemMessage(hDlg, iCtl, TBM_SETRANGE, 0, dwRange);
    SendDlgItemMessage(hDlg, iCtl, TBM_SETPOS, TRUE, uiPos);
}


/** GetDlgItemPos - Gets the pos of a dialog slider control
 *
 * INPUT
 *  hDlg = HWND of dialog box
 *  iCtl = ID of control
 *
 * OUTPUT
 *  Trackbar position.
 */
UINT GetDlgItemPos(HWND hDlg, int iCtl)
{
    FunctionName(GetDlgItemPos);

    return (UINT)SendDlgItemMessage(hDlg, iCtl, TBM_GETPOS, 0, 0);
}


/** SetDlgItemPct - Sets the pos for a dialog slider control that measures %
 *
 * INPUT
 *  hDlg = HWND of dialog box
 *  iCtl = ID of control
 *  uiPct = Current position (range 0 .. 100)
 *
 * OUTPUT
 *  None.
 */
void SetDlgItemPct(HWND hDlg, int iCtl, UINT uiPct)
{
    FunctionName(SetDlgItemPct);

    SetDlgItemPosRange(hDlg, iCtl, uiPct / (100/NUM_TICKS), MAKELONG(0, NUM_TICKS));
}


/** GetDlgItemPct - Gets the pos of a dialog slider control that measures %
 *
 * INPUT
 *  hDlg = HWND of dialog box
 *  iCtl = ID of control
 *
 * OUTPUT
 *  Slider position in the range 0 .. 100.
 */
UINT GetDlgItemPct(HWND hDlg, int iCtl)
{
    FunctionName(GetDlgItemPct);

    return GetDlgItemPos(hDlg, iCtl) * (100/NUM_TICKS);
}


/** EnableDlgItems - Enables or disables a collection of dialog controls
 *
 * INPUT
 *  hDlg = HWND of dialog box
 *  pbinf -> array of bitinfo descriptors
 *  cbinf  = size of array
 *  fEnable = whether the control should be enabled or disabled
 *
 * OUTPUT
 *  Dialog items have changed state.
 */
void EnableDlgItems(HWND hDlg, PBINF pbinf, int cbinf, BOOL fEnable)
{
    FunctionName(EnableDlgItems);

    ASSERTTRUE(cbinf > 0);
    do {
        EnableWindow(GetDlgItem(hDlg, pbinf->id), fEnable);
    } while (++pbinf, --cbinf);
}


/** DisableDlgItems - Disables a collection of dialog controls
 *
 * Most of the time, we call EnableDlgItems with fEnable = TRUE, so
 * this is a handy wrapper.  (Too bad the compiler emits awful code.)
 *
 * INPUT
 *  hDlg = HWND of dialog box
 *  pbinf -> array of bitinfo descriptors
 *  cbinf  = size of array
 *
 * OUTPUT
 *  Dialog items have been disabled.
 */
void DisableDlgItems(HWND hDlg, PBINF pbinf, int cbinf)
{
    FunctionName(DisableDlgItems);

    EnableDlgItems(hDlg, pbinf, cbinf, 0);
}


/** AdjustRealModeControls - Disables selected items if single-app mode
 *
 *  If the proplink says that "single-application mode" is enabled,
 *  then hide all controls whose IDs are less than 4000 and show all
 *  controls whose IDs are greater than or equal to 5000.  Controls whose
 *  IDs are in the 4000's are immune to all this hiding/showing.  Controls
 *  in the 3000's are actually disabled rather than hidden.  Controls in
 *  the 6000's are actually disabled rather than hidden as well.
 *
 *  RST: Ok, this is nice in theory, but now that we've pulled over this
 *       stuff into shell32.dll, we'll have to go off the actual IDC_
 *       defines instead of the magic #'s of 3000, 4000 and 5000.
 *
 *       IDC_ICONBMP        == 3001
 *       IDC_PIF_STATIC     == 4000
 *       IDC_REALMODEISABLE == 5001
 *
 *       So, when adding things to shell232.rc or ids.h, plan
 *       accordingly.
 *
 * INPUT
 *  ppl = proplink
 *  hDlg = HWND of dialog box
 *
 * OUTPUT
 *  Dialog items have been disabled/enabled shown/hidden.
 *  Returns nonzero if we are in normal (not single-app) mode.
 */

BOOL CALLBACK EnableEnumProc(HWND hwnd, LPARAM lp)
{
    int f;
    LONG l;

    f = SW_SHOW;
    l = GetWindowLong(hwnd, GWL_ID);

    if (!LOWORD(lp) && l < IDC_PIF_STATIC || LOWORD(lp) && l >= IDC_REALMODEDISABLE)
        f = SW_HIDE;

    if (l < IDC_ICONBMP || l >= IDC_PIF_STATIC && l < IDC_CONFIGLBL)
        ShowWindow(hwnd, f);
    else
        EnableWindow(hwnd, f == SW_SHOW);

    return TRUE;
}


BOOL AdjustRealModeControls(PPROPLINK ppl, HWND hDlg)
{
    BOOL fNormal;
    FunctionName(AdjustRealModeControls);

    fNormal = !(ppl->flProp & PROP_REALMODE);
    EnumChildWindows(hDlg, EnableEnumProc, fNormal);
    return fNormal;
}


/** OnWmHelp - Handle a WM_HELP message
 *
 *  This is called whenever the user presses F1 or clicks the help
 *  button in the title bar.  We forward the call on to the help engine.
 *
 * INPUT
 *  lparam  = LPARAM from WM_HELP message (LPHELPINFO)
 *  pdwHelp = array of DWORDs of help info
 *
 * OUTPUT
 *
 *  None.
 */

void OnWmHelp(LPARAM lparam, const DWORD *pdwHelp)
{
    FunctionName(OnWmHelp);

    WinHelp((HWND) ((LPHELPINFO) lparam)->hItemHandle, NULL,
            HELP_WM_HELP, (DWORD_PTR) (LPTSTR) pdwHelp);
}

/** OnWmContextMenu - Handle a WM_CONTEXTMENU message
 *
 *  This is called whenever the user right-clicks on a control.
 *  We forward the call on to the help engine.
 *
 * INPUT
 *  wparam  = WPARAM from WM_HELP message (HWND)
 *  pdwHelp = array of DWORDs of help info
 *
 * OUTPUT
 *
 *  None.
 */

void OnWmContextMenu(WPARAM wparam, const DWORD *pdwHelp)
{
    FunctionName(OnWmContextMenu);

    WinHelp((HWND) wparam, NULL, HELP_CONTEXTMENU,
            (DWORD_PTR) (LPTSTR) pdwHelp);
}

#ifdef UNICODE
/** PifMgr_WCtoMBPath - Converts UNICODE path to it's ANSI representation
 *
 *  This is called whenever we need to convert a UNICODE path to it's
 *  best approximation in ANSI.  Sometimes this will be a direct mapping,
 *  but sometimes not.  We may have to use the short name, etc.
 *
 * INPUT
 *  lpUniPath  -> pointer UNICODE path (NULL terminated)
 *  lpAnsiPath -> pointer to buffer to hold ANSI path
 *  cchBuf     -> size of ANSI buffer, in characters
 *
 * OUTPUT
 *
 *  lpAnsiPath buffer contains ANSI representation of lpUniPath
 */

void PifMgr_WCtoMBPath(LPWSTR lpUniPath, LPSTR lpAnsiPath, UINT cchBuf )
{
    WCHAR awchPath[ MAX_PATH ]; // Should be bigger than any PIF string
    CHAR  achPath[ MAX_PATH ];  // Should be bigger than any PIF string
    UINT  cchAnsi = 0;

    FunctionName(PifMgr_WCtoMBPath);

    // Try converting to Ansi and then converting back and comparing.
    // If we get back exactly what we started with, this is the "simple"
    // case.

    cchAnsi = WideCharToMultiByte( CP_ACP, 0,
                                   lpUniPath, -1,
                                   achPath, MAX_PATH,
                                   NULL, NULL );

    if (cchAnsi && (cchAnsi<=cchBuf)) {

        // Now try converting back
        MultiByteToWideChar( CP_ACP, 0,
                             achPath, -1,
                             awchPath, MAX_PATH
                            );

        if (lstrcmp(lpUniPath,awchPath)==0) {

            // We're done...copy over the string.
            lstrcpynA( lpAnsiPath, achPath, cchBuf );
            *(BYTE UNALIGNED *)(lpAnsiPath+cchBuf-1) = '\0';
            return;

        }

        // Well, the string has some unmappable UNICODE
        // character in it, so try option #2 -- using the
        // short path name.
        goto TryShortPathName;

    } else {

TryShortPathName:
        // Hmmm, the best we can do is to use the short path name and map
        // it to ANSI.

        GetShortPathName( lpUniPath, awchPath, MAX_PATH );
        awchPath[ MAX_PATH-1 ] = TEXT('\0');
        WideCharToMultiByte( CP_ACP, 0,
                             awchPath, -1,
                             lpAnsiPath, cchBuf,
                             NULL, NULL
                            );

        // Make sure we're NULL terminated
        *(BYTE UNALIGNED *)(lpAnsiPath+cchBuf-1) = '\0';

    }

}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\pifvid.c ===
// Created 04-Jan-1993 1:10pm by Jeff Parsons
 
#include "shellprv.h"
#pragma hdrstop


BINF abinfVid[] = {
    {IDC_WINDOWED,      BITNUM(VID_FULLSCREEN)   | 0x80},
    {IDC_FULLSCREEN,    BITNUM(VID_FULLSCREEN)},
    {IDC_TEXTEMULATE,   BITNUM(VID_TEXTEMULATE)},
    {IDC_DYNAMICVIDMEM, BITNUM(VID_RETAINMEMORY) | 0x80},
};

BINF abinfWinInit[] = {
    {IDC_WINRESTORE,    BITNUM(WININIT_NORESTORE) | 0x80},
};

// Private function prototypes

void EnableVidDlg(HWND hDlg, PPROPLINK ppl);
void InitVidDlg(HWND hDlg, PPROPLINK ppl);
void ApplyVidDlg(HWND hDlg, PPROPLINK ppl);


// Context-sensitive help ids

const static DWORD rgdwHelp[] = {
    IDC_SCREENUSAGEGRP, IDH_COMM_GROUPBOX,
    IDC_FULLSCREEN,     IDH_DOS_SCREEN_USAGE_FULL,
    IDC_WINDOWED,       IDH_DOS_SCREEN_USAGE_WINDOW,
    IDC_SCREENLINESLBL, IDH_DOS_DISPLAY_SCREEN_SETTINGS,
    IDC_SCREENLINES,    IDH_DOS_DISPLAY_SCREEN_SETTINGS,
    IDC_WINDOWUSAGEGRP, IDH_COMM_GROUPBOX,
    IDC_TOOLBAR,        IDH_DOS_WINDOWS_TOOLBAR,
    IDC_SCREENPERFGRP,  IDH_COMM_GROUPBOX,
    IDC_TEXTEMULATE,    IDH_DOS_DISPLAY_ROM,
    IDC_WINRESTORE,     IDH_DOS_SCREEN_RESTORE,
    IDC_DYNAMICVIDMEM,  IDH_DOS_SCREEN_DMA,
    IDC_REALMODEDISABLE,IDH_DOS_REALMODEPROPS,
    0, 0
};

/*
 *  This is a little table that converts listbox indices into
 *  screen lines.
 *
 *  The correspondences are...
 *
 *      IDS_WHATEVER = List box index + IDS_DEFAULTLINES
 *      nLines = awVideoLines[List box index]
 */
#if IDS_25LINES - IDS_DEFAULTLINES != 1 || \
    IDS_43LINES - IDS_DEFAULTLINES != 2 || \
    IDS_50LINES - IDS_DEFAULTLINES != 3
#error Manifest constants damaged.
#endif

WORD awVideoLines[] = { 0, 25, 43, 50 };


BOOL_PTR CALLBACK DlgVidProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    PPROPLINK ppl;
    FunctionName(DlgVidProc);

    ppl = (PPROPLINK)GetWindowLongPtr(hDlg, DWLP_USER);

    switch (uMsg) {
    case WM_INITDIALOG:
        lParam = ((LPPROPSHEETPAGE)lParam)->lParam;
        SetWindowLongPtr(hDlg, DWLP_USER, lParam);
        ppl = (PPROPLINK)(INT_PTR)lParam;
        InitVidDlg(hDlg, ppl);
        break;

    HELP_CASES(rgdwHelp)                // Handle help messages

    case WM_COMMAND:
        if (LOWORD(lParam) == 0)
            break;                      // message not from a control

        switch (LOWORD(wParam)) {

        case IDC_SCREENLINES:
            if (HIWORD(wParam) == CBN_SELCHANGE)
                SendMessage(GetParent(hDlg), PSM_CHANGED, (WPARAM)hDlg, 0L);
            break;

        case IDC_WINDOWED:
        case IDC_FULLSCREEN:
        case IDC_WINRESTORE:
        case IDC_TEXTEMULATE:
        case IDC_DYNAMICVIDMEM:
            if (HIWORD(wParam) == BN_CLICKED)
                SendMessage(GetParent(hDlg), PSM_CHANGED, (WPARAM)hDlg, 0L);
            break;
        }
        break;

    case WM_NOTIFY:
        switch (((NMHDR *)lParam)->code) {
        case PSN_SETACTIVE:
            AdjustRealModeControls(ppl, hDlg);
            break;

        case PSN_KILLACTIVE:
            // This gives the current page a chance to validate itself
            // SetWindowLong(hDlg, DWL_MSGRESULT, 0);
            break;

        case PSN_APPLY:
            // This happens on OK....
            ApplyVidDlg(hDlg, ppl);
            break;

        case PSN_RESET:
            // This happens on Cancel....
            break;
        }
        break;

    default:
        return FALSE;                   // return 0 when not processing
    }
    return TRUE;
}


void InitVidDlg(HWND hDlg, PPROPLINK ppl)
{
    WORD w;
    HWND hwnd;
    PROPVID vid;
    PROPWIN win;
    TCHAR szBuf[MAX_STRING_SIZE];
    FunctionName(InitVidDlg);

    if (!PifMgr_GetProperties(ppl, MAKELP(0,GROUP_VID),
                        &vid, SIZEOF(vid), GETPROPS_NONE) ||
        !PifMgr_GetProperties(ppl, MAKELP(0,GROUP_WIN),
                        &win, SIZEOF(win), GETPROPS_NONE)) {
        Warning(hDlg, IDS_QUERY_ERROR, MB_ICONEXCLAMATION | MB_OK);
        return;
    }

    SetDlgBits(hDlg, &abinfVid[0], ARRAYSIZE(abinfVid), vid.flVid);
    SetDlgBits(hDlg, &abinfWinInit[0], ARRAYSIZE(abinfWinInit), win.flWinInit);

    /*
     *  Fill in the "Initial screen size" combo box.  Note that
     *  we bail on low-memory errors.  Note also that if we have
     *  a nonstandard size, we just leave the combo box with no
     *  default selection.
     */

    VERIFYTRUE(hwnd = GetDlgItem(hDlg, IDC_SCREENLINES));
    for (w = 0; w < ARRAYSIZE(awVideoLines); w++) {
        VERIFYTRUE(LoadString(HINST_THISDLL, IDS_DEFAULTLINES + w, szBuf, ARRAYSIZE(szBuf)));
        VERIFYTRUE(SendMessage(hwnd, CB_ADDSTRING, 0, (LPARAM)(LPTSTR)szBuf) == w);
        if (vid.cScreenLines == awVideoLines[w]) {
            SendMessage(hwnd, CB_SETCURSEL, w, 0);
        }
    }
    if (!IsBilingualCP(g_uCodePage))
    {
        EnableWindow(GetDlgItem(hDlg, IDC_SCREENLINESLBL), FALSE);
        EnableWindow(hwnd, FALSE);
    }
}

void ApplyVidDlg(HWND hDlg, PPROPLINK ppl)
{
    DWORD dw;
    HWND hwnd;
    PROPVID vid;
    PROPWIN win;
    FunctionName(ApplyVidDlg);

    // Get the current set of properties, then overlay the new settings

    if (!PifMgr_GetProperties(ppl, MAKELP(0,GROUP_VID),
                        &vid, SIZEOF(vid), GETPROPS_NONE) ||
        !PifMgr_GetProperties(ppl, MAKELP(0,GROUP_WIN),
                        &win, SIZEOF(win), GETPROPS_NONE)) {
        Warning(hDlg, IDS_UPDATE_ERROR, MB_ICONEXCLAMATION | MB_OK);
        return;
    }

    GetDlgBits(hDlg, &abinfVid[0], ARRAYSIZE(abinfVid), &vid.flVid);
    GetDlgBits(hDlg, &abinfWinInit[0], ARRAYSIZE(abinfWinInit), &win.flWinInit);

    /*
     *  If there is no current selection, don't change the cScreenLines
     *  property.  This allows the user to retain an unusual number of
     *  screen lines by simply not touching the field.
     */
    VERIFYTRUE(hwnd = GetDlgItem(hDlg, IDC_SCREENLINES));

    dw = (DWORD) SendMessage(hwnd, CB_GETCURSEL, 0, 0L);
    if (dw < ARRAYSIZE(awVideoLines)) {
        vid.cScreenLines = awVideoLines[dw];
    }

    if (!PifMgr_SetProperties(ppl, MAKELP(0,GROUP_VID),
                        &vid, SIZEOF(vid), SETPROPS_NONE) ||
        !PifMgr_SetProperties(ppl, MAKELP(0,GROUP_WIN),
                        &win, SIZEOF(win), SETPROPS_NONE))
        Warning(hDlg, IDS_UPDATE_ERROR, MB_ICONEXCLAMATION | MB_OK);
    else
    if (ppl->hwndNotify) {
        ppl->flProp |= PROP_NOTIFY;
        PostMessage(ppl->hwndNotify, ppl->uMsgNotify, SIZEOF(vid), (LPARAM)MAKELP(0,GROUP_VID));
        PostMessage(ppl->hwndNotify, ppl->uMsgNotify, SIZEOF(win), (LPARAM)MAKELP(0,GROUP_WIN));
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\printer.h ===
#ifndef _PRINTER_H_
#define _PRINTER_H_

#include "shell32p.h"
#include <winspool.h>

#define MAXCOMPUTERNAME (2 + INTERNET_MAX_HOST_NAME_LENGTH + 1)
#define MAXNAMELEN MAX_PATH
#define MAXNAMELENBUFFER (MAXNAMELEN + MAXCOMPUTERNAME + 1)

STDAPI_(void) Printer_SplitFullName(LPTSTR pszScratch, LPCTSTR pszFullName, LPCTSTR *ppszServer, LPCTSTR *ppszPrinter);
STDAPI_(BOOL) Printer_CheckShowFolder(LPCTSTR pszMachine);
STDAPI_(BOOL) Printer_CheckNetworkPrinterByName(LPCTSTR pszPrinter, LPCTSTR* ppszLocal);

STDAPI_(IShellFolder2 *) CPrintRoot_GetPSF();
STDAPI_(BOOL) IsDefaultPrinter(LPCTSTR pszPrinter, DWORD dwAttributesHint);
STDAPI_(BOOL) IsPrinterInstalled(LPCTSTR pszPrinter);
STDAPI_(BOOL) IsAvoidAutoDefaultPrinter(LPCTSTR pszPrinter);

STDAPI_(DWORD) Printers_EnumPrinters(LPCTSTR pszServer, DWORD dwType, DWORD dwLevel, void **ppPrinters);
STDAPI_(DWORD) Printers_FolderEnumPrinters(HANDLE hFolder, void **ppPrinters);
STDAPI_(void *) Printer_FolderGetPrinter(HANDLE hFolder, LPCTSTR pszPrinter);
STDAPI_(BOOL) Printer_ModifyPrinter(LPCTSTR lpszPrinterName, DWORD dwCommand);
STDAPI_(void *) Printer_GetPrinterDriver(HANDLE hPrinter, DWORD dwLevel);
STDAPI_(void *) Printer_GetPrinter(HANDLE hPrinter, DWORD dwLevel);
STDAPI_(BOOL) Printers_DeletePrinter(HWND, LPCTSTR, DWORD, LPCTSTR, BOOL);
STDAPI_(BOOL) Printer_SetAsDefault(LPCTSTR lpszPrinterName);
STDAPI_(void) Printers_ChooseNewDefault(HWND hWnd);

typedef BOOL (*ENUMPROP)(void *lpData, HANDLE hPrinter, DWORD dwLevel,
        LPBYTE pEnum, DWORD dwSize, DWORD *lpdwNeeded, DWORD *lpdwNum);
STDAPI_(void *) Printer_EnumProps(HANDLE hPrinter, DWORD dwLevel, DWORD *lpdwNum,
        ENUMPROP lpfnEnum, void *lpData);

STDAPI_(HANDLE) Printer_OpenPrinter(LPCTSTR lpszPrinterName);
STDAPI_(HANDLE) Printer_OpenPrinterAdmin(LPCTSTR lpszPrinterName);

STDAPI_(void) Printer_ClosePrinter(HANDLE hPrinter);
STDAPI_(BOOL) Printer_GPI2CB(void *lpData, HANDLE hPrinter, DWORD dwLevel, LPBYTE pBuf, DWORD dwSize, DWORD *lpdwNeeded, DWORD *lpdwNum);
STDAPI_(void *) Printer_GetPrinterInfo(HANDLE hPrinter, DWORD dwLevel );
STDAPI_(void *) Printer_GetPrinterInfoStr(LPCTSTR lpszPrinterName, DWORD dwLevel);

// prqwnd.c
STDAPI_(LPITEMIDLIST) Printjob_GetPidl(LPCTSTR szName, LPSHCNF_PRINTJOB_DATA pData);

// printer1.c
STDAPI_(LPITEMIDLIST) Printers_GetInstalledNetPrinter(LPCTSTR lpNetPath);
STDAPI_(void) Printer_PrintFile(HWND hWnd, LPCTSTR pszFilePath, LPCITEMIDLIST pidl);
STDAPI_(LPITEMIDLIST) Printers_PrinterSetup(HWND hwndStub, UINT uAction, LPTSTR lpBuffer, LPCTSTR pszServerName);

// prnfldr.cpp
STDAPI CPrinterDropTarget_CreateInstance(HWND hwnd, LPCITEMIDLIST pidl, IDropTarget **ppdropt);

////////////////////////////////////////////////////////////////////
// IPrintersBindInfo - bind context info for parsing printer PIDLs
#undef  INTERFACE
#define INTERFACE  IPrintersBindInfo

DECLARE_INTERFACE_(IPrintersBindInfo, IUnknown)
{
    //////////////////
    // IUnknown
    STDMETHOD(QueryInterface)(THIS_ REFIID riid, LPVOID * ppvObj) PURE;
    STDMETHOD_(ULONG,AddRef)(THIS) PURE;
    STDMETHOD_(ULONG,Release)(THIS) PURE;

    ///////////////////////
    // IPrintersBindInfo
    STDMETHOD(SetPIDLType)(THIS_ DWORD dwType) PURE;
    STDMETHOD(GetPIDLType)(THIS_ LPDWORD pdwType) PURE;
    STDMETHOD(IsValidated)(THIS) PURE;
    STDMETHOD(SetCookie)(THIS_ LPVOID pCookie) PURE;
    STDMETHOD(GetCookie)(THIS_ LPVOID *ppCookie) PURE;
};

STDAPI Printers_CreateBindInfo(LPCTSTR pszPrinter, DWORD dwType, BOOL bValidated, LPVOID pCookie, IPrintersBindInfo **ppbc);

#endif // _PRINTER_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\printer1.c ===
#include "shellprv.h"
#pragma  hdrstop

#include "printer.h"
#include "copy.h"
#include "ids.h"

typedef struct
{
    UINT  uAction;
    LPTSTR lpBuf1;
    LPTSTR lpBuf2;
} PRINTERS_RUNDLL_INFO, *LPPRI;

// forward prototypes
void Printer_OpenMe(LPCTSTR pName, LPCTSTR pServer, BOOL fModal);
void Printers_ProcessCommand(HWND hwndStub, LPPRI lpPRI, BOOL fModal);

TCHAR const c_szPrintersGetCommand_RunDLL[] = TEXT("SHELL32,PrintersGetCommand_RunDLL");

//
// if uAction IS NOT MSP_NEWDRIVER then:
//    installs a printer (uAction).  If successful, notifies the shell and
//    returns a pidl to the printer.  ILFree() is callers responsibility.
// otherwise, if uAction IS MSP_NEWDRIVER then:
//    installs a printer driver (uAction).  If successful, fills the new
//    driver's name into pszPrinter (ASSUMED >= MAXNAMELEN).
//    Always returns NULL.
// if uAction is MSP_TESTPAGEPARTIALPROMPT then:
//    executes the test page code
//    Always returns NULL.
//

LPITEMIDLIST Printers_PrinterSetup(HWND hwnd, UINT uAction, LPTSTR pszPrinter, LPCTSTR pszServer)
{
    LPITEMIDLIST pidl = NULL;
    TCHAR szPrinter[MAXNAMELENBUFFER];
    DWORD cchBufLen;

    // HACK! This hack is related to BUG #272207
    // This function is called from Printers_DeletePrinter for
    // printer deletion and this case we should not check
    // for REST_NOPRINTERADD restriction. -LazarI

    if (MSP_NEWPRINTER == uAction ||
        MSP_NETPRINTER == uAction ||
        MSP_NEWPRINTER_MODELESS == uAction)
    {
        if (SHIsRestricted(hwnd, REST_NOPRINTERADD))
        {
            return NULL;
        }
    }

    cchBufLen = ARRAYSIZE(szPrinter);
    if (pszPrinter)
        StrCpyN(szPrinter, pszPrinter, ARRAYSIZE(szPrinter));
    else
        szPrinter[0] = 0;

    // We don't have to worry about PrinterSetup failing due to the
    // output buffer being too small.  It's the right size (MAXNAMELENBUFFER)
    if (bPrinterSetup(hwnd, LOWORD(uAction), cchBufLen, szPrinter, &cchBufLen, pszServer))
    {
        if (uAction == MSP_NEWDRIVER)
        {
            lstrcpy(pszPrinter, szPrinter); // return result
        }
        else if (uAction == MSP_TESTPAGEPARTIALPROMPT)
        {
            // nothing to do for this case
        }
        else if (uAction == MSP_REMOVEPRINTER || uAction == MSP_NEWPRINTER_MODELESS || uAction == MSP_REMOVENETPRINTER)
        {
            // a bit ugly, but we need to pass back success for this case
            pidl = (LPITEMIDLIST)TRUE;
        }
        else
        {
            // do not validate the printer PIDL here because the validation mechanism in ParseDisplayName 
            // is using the folder cache and since we just added it may still not be in the folder cache, 
            // and we fail, although this a valid local printer/connection already.
            ParsePrinterNameEx(szPrinter, &pidl, TRUE, 0, 0);
        }
    }

    return pidl;
}

SHSTDAPI_(BOOL) SHInvokePrinterCommand(
    IN HWND    hwnd,
    IN UINT    uAction,
    IN LPCTSTR lpBuf1,
    IN LPCTSTR lpBuf2,
    IN BOOL    fModal)
{
    PRINTERS_RUNDLL_INFO PRI;

    PRI.uAction = uAction;
    PRI.lpBuf1 = (LPTSTR)lpBuf1;
    PRI.lpBuf2 = (LPTSTR)lpBuf2;

    Printers_ProcessCommand(hwnd, &PRI, fModal);

    return TRUE;
}


#ifdef UNICODE

SHSTDAPI_(BOOL)
SHInvokePrinterCommandA(
    IN HWND    hwnd,
    IN UINT    uAction,
    IN LPCSTR  lpBuf1,      OPTIONAL
    IN LPCSTR  lpBuf2,      OPTIONAL
    IN BOOL    fModal)
{
    WCHAR szBuf1[MAX_PATH];
    WCHAR szBuf2[MAX_PATH];

    if (lpBuf1)
    {
        MultiByteToWideChar(CP_ACP, 0, lpBuf1, -1, szBuf1, SIZECHARS(szBuf1));
        lpBuf1 = (LPCSTR)szBuf1;
    }

    if (lpBuf2)
    {
        MultiByteToWideChar(CP_ACP, 0, lpBuf2, -1, szBuf2, SIZECHARS(szBuf2));
        lpBuf2 = (LPCSTR)szBuf2;
    }

    return SHInvokePrinterCommand(hwnd, uAction, (LPCWSTR)lpBuf1, (LPCWSTR)lpBuf2, fModal);
}

#else

SHSTDAPI_(BOOL) SHInvokePrinterCommandW(HWND hwnd, UINT uAction,
    LPCWSTR lpBuf1, LPCWSTR lpBuf2, BOOL fModal)
{
    CHAR szBuf1[MAX_PATH];
    CHAR szBuf2[MAX_PATH];

    if (lpBuf1)
    {
        WideCharToMultiByte(CP_ACP, 0, lpBuf1, -1, szBuf1, SIZECHARS(szBuf1), NULL, NULL);
        lpBuf1 = (LPCWSTR)szBuf1;
    }

    if (lpBuf2)
    {
        WideCharToMultiByte(CP_ACP, 0, lpBuf2, -1, szBuf2, SIZECHARS(szBuf2), NULL, NULL);
        lpBuf2 = (LPCWSTR)szBuf2;
    }

    return SHInvokePrinterCommand(hwnd, uAction, (LPCSTR)lpBuf1, (LPCSTR)lpBuf2, fModal);
}

#endif  // UNICODE

void WINAPI PrintersGetCommand_RunDLL_Common(HWND hwndStub, HINSTANCE hAppInstance, LPTSTR lpszCmdLine, int nCmdShow)
{
    PRINTERS_RUNDLL_INFO    PRI;
    UINT cchBuf1;
    UINT cchBuf2;
    LPTSTR lpComma;
    LPTSTR lpCommaNext;
    lpComma = StrChr(lpszCmdLine,TEXT(','));
    if (lpComma == NULL)
    {
        goto BadCmdLine;
    }
    *lpComma = TEXT('\0');        // Terminate it here
    PRI.uAction = StrToLong(lpszCmdLine);

    lpCommaNext = StrChr(lpComma+1,TEXT(','));
    if (lpCommaNext == NULL)
    {
        goto BadCmdLine;
    }
    *lpCommaNext = TEXT('\0');        // Terminate it here
    cchBuf1 = StrToLong(lpComma+1);
    lpComma = lpCommaNext;

    lpCommaNext = StrChr(lpComma+1,TEXT(','));
    if (lpCommaNext == NULL)
    {
        goto BadCmdLine;
    }
    *lpCommaNext = TEXT('\0');        // Terminate it here
    cchBuf2 = StrToLong(lpComma+1);
    lpComma = lpCommaNext;

    PRI.lpBuf1 = lpComma+1;     // Just past the comma
    *(PRI.lpBuf1+cchBuf1) = '\0';

    if (cchBuf2 == 0)
    {
        PRI.lpBuf2 = NULL;
    }
    else
    {
        PRI.lpBuf2 = PRI.lpBuf1+cchBuf1+1;
    }

    // Make this modal.
    Printers_ProcessCommand(hwndStub, &PRI, TRUE);
    return;

BadCmdLine:
    DebugMsg(DM_ERROR, TEXT("pgc_rd: bad command line: %s"), lpszCmdLine);
    return;
}

void WINAPI PrintersGetCommand_RunDLL(HWND hwndStub, HINSTANCE hAppInstance, LPSTR lpszCmdLine, int nCmdShow)
{
    HRESULT hrInit = SHOleInitialize(0);
#ifdef UNICODE
    UINT iLen = lstrlenA(lpszCmdLine)+1;
    LPWSTR lpwszCmdLine = (LPWSTR)LocalAlloc(LPTR,iLen*SIZEOF(WCHAR));
    if (lpwszCmdLine)
    {
        MultiByteToWideChar(CP_ACP, 0,
                            lpszCmdLine, -1,
                            lpwszCmdLine, iLen);
        PrintersGetCommand_RunDLL_Common( hwndStub,
                                          hAppInstance,
                                          lpwszCmdLine,
                                          nCmdShow );
        LocalFree(lpwszCmdLine);
    }
#else
    PrintersGetCommand_RunDLL_Common( hwndStub,
                                      hAppInstance,
                                      lpszCmdLine,
                                      nCmdShow );
#endif
    SHOleUninitialize(hrInit);
}

void WINAPI PrintersGetCommand_RunDLLW(HWND hwndStub, HINSTANCE hAppInstance, LPWSTR lpwszCmdLine, int nCmdShow)
{
#ifdef UNICODE
    PrintersGetCommand_RunDLL_Common( hwndStub,
                                      hAppInstance,
                                      lpwszCmdLine,
                                      nCmdShow );
#else
    UINT iLen = WideCharToMultiByte(CP_ACP, 0,
                                    lpwszCmdLine, -1,
                                    NULL, 0, NULL, NULL)+1;
    LPSTR  lpszCmdLine = (LPSTR)LocalAlloc(LPTR,iLen);
    if (lpszCmdLine)
    {
        WideCharToMultiByte(CP_ACP, 0,
                            lpwszCmdLine, -1,
                            lpszCmdLine, iLen,
                            NULL, NULL);
        PrintersGetCommand_RunDLL_Common( hwndStub,
                                          hAppInstance,
                                          lpszCmdLine,
                                          nCmdShow );
        LocalFree(lpszCmdLine);
    }
#endif
}

static void 
HandleOpenPrinter(HWND hwnd, LPCTSTR pszPrinter, BOOL fModal, BOOL bConnect)
{
    BOOL                bPrinterOK = FALSE;
    DWORD               dwError = ERROR_SUCCESS;
    TCHAR               szPrinter[MAXNAMELENBUFFER];
    HANDLE              hPrinter = NULL;
    LPITEMIDLIST        pidl = NULL;
    PRINTER_INFO_2     *pPrinter = NULL;

    // we need to open the printer and get the real printer name in case
    // the passed in printer name is a sharename
    lstrcpyn(szPrinter, pszPrinter, ARRAYSIZE(szPrinter));
    hPrinter = Printer_OpenPrinter(szPrinter);
    if (hPrinter)
    {
        pPrinter = (PRINTER_INFO_2 *)Printer_GetPrinterInfo(hPrinter, 2);
        if (pPrinter)
        {
            if (pPrinter->pPrinterName && pPrinter->pPrinterName[0])
            {
                // copy the real printer name
                bPrinterOK = TRUE;
                lstrcpyn(szPrinter, pPrinter->pPrinterName, ARRAYSIZE(szPrinter));
            }
            LocalFree((HLOCAL)pPrinter);
        }
        else
        {
            // save last error
            dwError = GetLastError();
        }
        Printer_ClosePrinter(hPrinter);
    }
    else
    {
        // save last error
        dwError = GetLastError();
    }

    if (bPrinterOK)
    {
        if (bConnect)
        {
            // if the printer is not installed then we'll silently install it
            // since this is what most users will expect.
            if (FAILED(ParsePrinterName(szPrinter, &pidl)))
            {
                // connect....
                pidl = Printers_PrinterSetup(hwnd, MSP_NETPRINTER, szPrinter, NULL);

                if (pidl)
                {
                    // get the real printer name from the printer's folder...
                    SHGetNameAndFlags(pidl, SHGDN_INFOLDER | SHGDN_FORPARSING, szPrinter, ARRAYSIZE(szPrinter), NULL);
                    ILFree(pidl);
                }
                else
                {
                    // failed to install the printer (it shows UI, so we shouldn't)
                    bPrinterOK = FALSE;
                }
            }
            else
            {
                // the printer is already installed
                ILFree(pidl);
            }
        }

        if (bPrinterOK)
        {
            Printer_OpenMe(szPrinter, NULL, fModal);
        }
    }
    else
    {
        // something else failed -- show up an error message
        ShowErrorMessageSC(NULL, NULL, hwnd, NULL, NULL, MB_OK|MB_ICONEXCLAMATION, dwError);
    }
}

/********************************************************************

    lpPRI structure description based on uAction.

    uAction             lpBuf1   lpBuf2

    OPEN,               printer, server
    PROPERTIES,         printer, SheetName
    NETINSTALL,         printer,
    NETINSTALLLINK,     printer, target directory to create link
    OPENNETPRN,         printer,
    TESTPAGE            printer

********************************************************************/

void Printers_ProcessCommand(HWND hwndStub, LPPRI lpPRI, BOOL fModal)
{
    switch (lpPRI->uAction)
    {
    case PRINTACTION_OPEN:
        if (!lstrcmpi(lpPRI->lpBuf1, c_szNewObject))
        {
            Printers_PrinterSetup(hwndStub, MSP_NEWPRINTER_MODELESS,
                                  lpPRI->lpBuf1, lpPRI->lpBuf2);
        }
        else
        {
            HandleOpenPrinter(hwndStub, lpPRI->lpBuf1, fModal, FALSE);
        }
        break;

    case PRINTACTION_SERVERPROPERTIES:
    {
        LPCTSTR pszServer = (LPTSTR)(lpPRI->lpBuf1);

        // we should never get called with c_szNewObject
        ASSERT(lstrcmpi(lpPRI->lpBuf1, c_szNewObject));
        vServerPropPages(hwndStub, pszServer, SW_SHOWNORMAL, 0);
        break;
    }
    case PRINTACTION_DOCUMENTDEFAULTS:
    {
        // we should never get called with c_szNewObject
        ASSERT(lstrcmpi(lpPRI->lpBuf1, c_szNewObject));
        vDocumentDefaults(hwndStub, lpPRI->lpBuf1, SW_SHOWNORMAL, (LPARAM)(lpPRI->lpBuf2));
        break;
    }

    case PRINTACTION_PROPERTIES:
    {
        // we should never get called with c_szNewObject
        ASSERT(lstrcmpi(lpPRI->lpBuf1, c_szNewObject));
        vPrinterPropPages(hwndStub, lpPRI->lpBuf1, SW_SHOWNORMAL, (LPARAM)(lpPRI->lpBuf2));
        break;
    }

    case PRINTACTION_NETINSTALLLINK:
    case PRINTACTION_NETINSTALL:
    {
        LPITEMIDLIST pidl = Printers_PrinterSetup(hwndStub, MSP_NETPRINTER, lpPRI->lpBuf1, NULL);
        if (pidl)
        {
            if (lpPRI->uAction == PRINTACTION_NETINSTALLLINK)
            {
                IDataObject *pdtobj;
                if (SUCCEEDED(SHGetUIObjectFromFullPIDL(pidl, NULL, IID_PPV_ARG(IDataObject, &pdtobj))))
                {
                    SHCreateLinks(hwndStub, lpPRI->lpBuf2, pdtobj, SHCL_USETEMPLATE, NULL);
                    pdtobj->lpVtbl->Release(pdtobj);
                }
            }
            ILFree(pidl);
        }

        break;
    }

    case PRINTACTION_OPENNETPRN:
    {
        HandleOpenPrinter(hwndStub, lpPRI->lpBuf1, fModal, TRUE);
        break;
    } // case PRINTACTION_OPENNETPRN

    case PRINTACTION_TESTPAGE:
        Printers_PrinterSetup(hwndStub, MSP_TESTPAGEPARTIALPROMPT,
                        lpPRI->lpBuf1, NULL);
        break;

    default:
        DebugMsg(TF_WARNING, TEXT("PrintersGetCommand_RunDLL() received unrecognized uAction %d"), lpPRI->uAction);
        break;
    }
}

void Printer_OpenMe(LPCTSTR pName, LPCTSTR pServer, BOOL fModal)
{
    BOOL fOpened = FALSE;
    HKEY hkeyPrn;
    TCHAR buf[50+MAXNAMELEN];

    wsprintf(buf, TEXT("Printers\\%s"), pName);
    if (ERROR_SUCCESS == RegOpenKey(HKEY_CLASSES_ROOT, buf, &hkeyPrn))
    {
        SHELLEXECUTEINFO sei =
        {
            SIZEOF(SHELLEXECUTEINFO),
            SEE_MASK_CLASSKEY | SEE_MASK_FLAG_NO_UI, // fMask
            NULL,                       // hwnd - queue view should not be modal on the printer's folder, make it top level
            NULL,                       // lpVerb
            pName,                      // lpFile
            NULL,                       // lpParameters
            NULL,                       // lpDirectory
            SW_SHOWNORMAL,              // nShow
            NULL,                       // hInstApp
            NULL,                       // lpIDList
            NULL,                       // lpClass
            hkeyPrn,                    // hkeyClass
            0,                          // dwHotKey
            NULL                        // hIcon
        };

        fOpened = ShellExecuteEx(&sei);

        RegCloseKey(hkeyPrn);
    }

    if (!fOpened)
    {
        vQueueCreate(NULL, pName, SW_SHOWNORMAL, (LPARAM)fModal);
    }
}

//
// Arguments:
//  pidl -- (absolute) pidl to the object of interest
//
// Return '"""<Printer Name>""" """<Driver Name>""" """<Path>"""' if success,
//        NULL if failure
//
// We need """ because shlexec strips the outer quotes and converts "" to "
//
UINT Printer_GetPrinterInfoFromPidl(LPCITEMIDLIST pidl, LPTSTR *plpParms)
{
    LPTSTR lpBuffer = NULL;
    UINT uErr = ERROR_NOT_ENOUGH_MEMORY;
    HANDLE hPrinter;
    TCHAR szPrinter[MAXNAMELENBUFFER];

    SHGetNameAndFlags(pidl, SHGDN_INFOLDER | SHGDN_FORPARSING, szPrinter, ARRAYSIZE(szPrinter), NULL);
    hPrinter = Printer_OpenPrinter(szPrinter);
    if (NULL == hPrinter)
    {
        // fallback to the full name in case this was as \\server\share
        // printer drop target
        SHGetNameAndFlags(pidl, SHGDN_FORPARSING, szPrinter, ARRAYSIZE(szPrinter), NULL);
        hPrinter = Printer_OpenPrinter(szPrinter);
    }

    if (hPrinter)
    {
        PRINTER_INFO_5 *pPrinter;
        pPrinter = Printer_GetPrinterInfo(hPrinter, 5);
        if (pPrinter)
        {
            DRIVER_INFO_2 *pPrinterDriver;
            pPrinterDriver = Printer_GetPrinterDriver(hPrinter, 2);
            if (pPrinterDriver)
            {
                LPTSTR lpDriverName = PathFindFileName(pPrinterDriver->pDriverPath);

                lpBuffer = (void*)LocalAlloc(LPTR, (2+lstrlen(szPrinter)+1+
                                 2+lstrlen(lpDriverName)+1+
                                 2+lstrlen(pPrinter->pPortName)+1) * SIZEOF(TCHAR));
                if (lpBuffer)
                {
                    wsprintf(lpBuffer,TEXT("\"%s\" \"%s\" \"%s\""),
                             szPrinter, lpDriverName, pPrinter->pPortName);
                    uErr = ERROR_SUCCESS;
                }

                LocalFree((HLOCAL)pPrinterDriver);
            }
            LocalFree((HLOCAL)pPrinter);
        }
        Printer_ClosePrinter(hPrinter);
    }
    else
    {
        // HACK: special case this error return in calling function,
        // as we need a special error message
        uErr = ERROR_SUCCESS;
    }

    *plpParms = lpBuffer;

    return(uErr);
}


//
// Arguments:
//  hwndParent -- Specifies the parent window.
//  szFilePath -- The file to printed.
//
void Printer_PrintFile(HWND hWnd, LPCTSTR pszFilePath, LPCITEMIDLIST pidl)
{
    UINT             uErr;
    LPTSTR           lpParms       = NULL;
    BOOL             bTryPrintVerb = TRUE;
    BOOL             bShowError    = FALSE;
    LPITEMIDLIST     pidlFull      = NULL;
    SHELLEXECUTEINFO ExecInfo      = {0};


    uErr = Printer_GetPrinterInfoFromPidl(pidl, &lpParms);
    if (uErr != ERROR_SUCCESS)
    {
        bShowError = TRUE;
    }
    if (!bShowError && !lpParms)
    {
        // If you rename a printer and then try to use a link to that
        // printer, we hit this case. Also, if you get a link to a printer
        // on another computer, we'll likely hit this case.
        ShellMessageBox(HINST_THISDLL, hWnd,
            MAKEINTRESOURCE(IDS_CANTPRINT),
            MAKEINTRESOURCE(IDS_PRINTERS),
            MB_OK|MB_ICONEXCLAMATION);
        return;
    }

    //
    // Get the context menu for the file
    //

    pidlFull = ILCreateFromPath( pszFilePath );
    if (!bShowError && pidlFull)
    {
        //
        // Try the "printto" verb first...
        //

        ExecInfo.cbSize         = sizeof(ExecInfo);
        ExecInfo.fMask          = SEE_MASK_UNICODE | SEE_MASK_INVOKEIDLIST |
                                  SEE_MASK_IDLIST  | SEE_MASK_FLAG_NO_UI;
        ExecInfo.hwnd           = hWnd;
        ExecInfo.lpVerb         = c_szPrintTo;
        ExecInfo.lpParameters   = lpParms;
        ExecInfo.nShow          = SW_SHOWNORMAL;
        ExecInfo.lpIDList       = pidlFull;

        if (!ShellExecuteEx( &ExecInfo ))
        {
            //
            // Since we can't print specifying the printer name (i.e., printto),
            // our next option is to print to the default printer.  However,
            // that might not be the printer the user dragged the files onto
            // so check here and let the user set the desired printer to be
            // the default if they want...
            //

            TCHAR szPrinter[MAXNAMELENBUFFER];
            SHGetNameAndFlags(pidl, SHGDN_INFOLDER | SHGDN_FORPARSING, szPrinter, ARRAYSIZE(szPrinter), NULL);

            if (!IsDefaultPrinter(szPrinter, 0))
            {
                //
                // this isn't the default printer, ask first
                //

                if (IDYES==ShellMessageBox(
                        HINST_THISDLL, GetTopLevelAncestor(hWnd),
                        MAKEINTRESOURCE(IDS_CHANGEDEFAULTPRINTER),
                        MAKEINTRESOURCE(IDS_PRINTERS),
                        MB_YESNO|MB_ICONEXCLAMATION))
                {
                    Printer_SetAsDefault(szPrinter);
                }
                else
                {
                    bTryPrintVerb = FALSE;
                }

            }

            if (bTryPrintVerb)
            {
                //
                // Try the "print" verb
                //

                ExecInfo.lpVerb = c_szPrint;

                if (!ShellExecuteEx( &ExecInfo ))
                {
                    uErr = GetLastError();
                    bShowError = TRUE;
                }
            }

        }

        ILFree(pidlFull);
    }

    if (lpParms)
        LocalFree((HLOCAL)lpParms);

    if (bShowError)
    {
        ShellMessageBox(HINST_THISDLL, hWnd, 
            MAKEINTRESOURCE(IDS_ERRORPRINTING),
            MAKEINTRESOURCE(IDS_PRINTERS),
            MB_OK|MB_ICONEXCLAMATION);
    }
}


BOOL Printer_ModifyPrinter(LPCTSTR lpszPrinterName, DWORD dwCommand)
{
    HANDLE hPrinter = Printer_OpenPrinterAdmin(lpszPrinterName);
    BOOL fRet = FALSE;
    if (hPrinter)
    {
        fRet = SetPrinter(hPrinter, 0, NULL, dwCommand);
        Printer_ClosePrinter(hPrinter);
    }
    return fRet;
}

BOOL IsAvoidAutoDefaultPrinter(LPCTSTR pszPrinter);

// this will find the first printer (if any) and set  it as the default
// and inform the user
void Printers_ChooseNewDefault(HWND hwnd)
{
    PRINTER_INFO_4 *pPrinters = NULL;
    DWORD iPrinter, dwNumPrinters = Printers_EnumPrinters(NULL,
                                          PRINTER_ENUM_LOCAL | PRINTER_ENUM_FAVORITE,
                                          4,
                                          &pPrinters);
    if (dwNumPrinters)
    {
        if (pPrinters)
        {
            for (iPrinter = 0 ; iPrinter < dwNumPrinters ; iPrinter++)
            {
                if (!IsAvoidAutoDefaultPrinter(pPrinters[iPrinter].pPrinterName))
                    break;
            }
            if (iPrinter == dwNumPrinters)
            {
                dwNumPrinters = 0;
            }
            else
            {
                Printer_SetAsDefault(pPrinters[iPrinter].pPrinterName);
            }
        }
        else
        {
            dwNumPrinters = 0;
        }
    }

    // Inform user
    if (dwNumPrinters)
    {
        ShellMessageBox(HINST_THISDLL,
                        hwnd,
                        MAKEINTRESOURCE(IDS_DELNEWDEFAULT),
                        MAKEINTRESOURCE(IDS_PRINTERS),
                        MB_OK,
                        pPrinters[iPrinter].pPrinterName);
    }
    else
    {
        Printer_SetAsDefault(NULL); // clear the default printer
        ShellMessageBox(HINST_THISDLL, hwnd, MAKEINTRESOURCE(IDS_DELNODEFAULT),
                    MAKEINTRESOURCE(IDS_PRINTERS),  MB_OK);
    }

    if (pPrinters)
        LocalFree((HLOCAL)pPrinters);
}

BOOL Printer_SetAsDefault(LPCTSTR lpszPrinterName)
{
    TCHAR szDefaultPrinterString[MAX_PATH * 2];
    TCHAR szBuffer[MAX_PATH * 2];

    if (lpszPrinterName)
    {
        // Not the default, set it.
        if( !GetProfileString( TEXT( "Devices" ), lpszPrinterName, TEXT( "" ), szBuffer, ARRAYSIZE( szBuffer )))
        {
            return FALSE;
        }

        lstrcpy( szDefaultPrinterString, lpszPrinterName );
        lstrcat( szDefaultPrinterString, TEXT( "," ));
        lstrcat( szDefaultPrinterString, szBuffer );

        //
        // Use the new string for Windows.Device.
        //
        lpszPrinterName = szDefaultPrinterString;
    }

    if (!WriteProfileString( TEXT( "Windows" ), TEXT( "Device" ), lpszPrinterName ))
    {
        return FALSE;
    }

    // Tell the world and make everyone flash.
    SendNotifyMessage( HWND_BROADCAST, WM_WININICHANGE, 0, (LPARAM)TEXT( "Windows" ));

   return TRUE;
}

void *Printer_EnumProps(HANDLE hPrinter, DWORD dwLevel, DWORD *lpdwNum,
    ENUMPROP lpfnEnum, void *lpData)
{
    DWORD dwSize, dwNeeded;
    LPBYTE pEnum;

    dwSize = 0;
    SetLastError(0);
    lpfnEnum(lpData, hPrinter, dwLevel, NULL, 0, &dwSize, lpdwNum);
    if (GetLastError() != ERROR_INSUFFICIENT_BUFFER)
    {
        pEnum = NULL;
        goto Error1;
    }

    ASSERT(dwSize < 0x100000L);

    pEnum = (void*)LocalAlloc(LPTR, dwSize);
TryAgain:
    if (!pEnum)
    {
        goto Error1;
    }

    SetLastError(0);
    if (!lpfnEnum(lpData, hPrinter, dwLevel, pEnum, dwSize, &dwNeeded, lpdwNum))
    {
        if (GetLastError() == ERROR_INSUFFICIENT_BUFFER)
        {
            LPBYTE pTmp;
            dwSize = dwNeeded;
            pTmp = (void*)LocalReAlloc((HLOCAL)pEnum, dwSize,
                    LMEM_MOVEABLE|LMEM_ZEROINIT);
            if (pTmp)
            {
                pEnum = pTmp;
                goto TryAgain;
            }
        }

        LocalFree((HLOCAL)pEnum);
        pEnum = NULL;
    }

Error1:
    return pEnum;
}


BOOL Printers_EnumPrintersCB(void *lpData, HANDLE hPrinter, DWORD dwLevel,
    LPBYTE pEnum, DWORD dwSize, DWORD *lpdwNeeded, DWORD *lpdwNum)
{
    return EnumPrinters(PtrToUlong(lpData), (LPTSTR)hPrinter, dwLevel,
                             pEnum, dwSize, lpdwNeeded, lpdwNum);
}

DWORD Printers_EnumPrinters(LPCTSTR pszServer, DWORD dwType, DWORD dwLevel, void **ppPrinters)
{
    DWORD dwNum = 0L;

    //
    // If the server is szNULL, pass in NULL, since EnumPrinters expects
    // this for the local server.
    //
    if (pszServer && !pszServer[0])
    {
        pszServer = NULL;
    }

    *ppPrinters = Printer_EnumProps((HANDLE)pszServer, dwLevel, &dwNum, Printers_EnumPrintersCB, ULongToPtr(dwType));
    if (*ppPrinters==NULL)
    {
        dwNum = 0;
    }
    return dwNum;
}

BOOL Printers_FolderEnumPrintersCB(void *lpData, HANDLE hFolder, DWORD dwLevel,
    LPBYTE pEnum, DWORD dwSize, DWORD *lpdwNeeded, DWORD *lpdwNum)
{
    return bFolderEnumPrinters(hFolder, (PFOLDER_PRINTER_DATA)pEnum,
                                   dwSize, lpdwNeeded, lpdwNum);
}

DWORD Printers_FolderEnumPrinters(HANDLE hFolder, void **ppPrinters)
{
    DWORD dwNum = 0L;

    *ppPrinters = Printer_EnumProps(hFolder, 0, &dwNum,
                                    Printers_FolderEnumPrintersCB,
                                    NULL);
    if (*ppPrinters==NULL)
    {
        dwNum=0;
    }
    return dwNum;
}

BOOL Printers_FolderGetPrinterCB(void *lpData, HANDLE hFolder, DWORD dwLevel,
    LPBYTE pEnum, DWORD dwSize, DWORD *lpdwNeeded, DWORD *lpdwNum)
{
    return bFolderGetPrinter(hFolder, (LPCTSTR)lpData, (PFOLDER_PRINTER_DATA)pEnum, dwSize, lpdwNeeded);
}


void *Printer_FolderGetPrinter(HANDLE hFolder, LPCTSTR pszPrinter)
{
    return Printer_EnumProps(hFolder, 0, NULL, Printers_FolderGetPrinterCB, (LPVOID)pszPrinter);
}

BOOL Printers_GetPrinterDriverCB(void *lpData, HANDLE hPrinter, DWORD dwLevel,
    LPBYTE pEnum, DWORD dwSize, DWORD *lpdwNeeded, DWORD *lpdwNum)
{
    return GetPrinterDriver(hPrinter, NULL, dwLevel, pEnum, dwSize, lpdwNeeded);
}


void *Printer_GetPrinterDriver(HANDLE hPrinter, DWORD dwLevel)
{
    return Printer_EnumProps(hPrinter, dwLevel, NULL, Printers_GetPrinterDriverCB, NULL);
}

////////////////////////////////////////////////////////////////////////////////
// code moved from prcache.c
//
HANDLE Printer_OpenPrinterAdmin(LPCTSTR lpszPrinterName)
{
    HANDLE hPrinter = NULL;

    PRINTER_DEFAULTS PrinterDefaults;
    PrinterDefaults.pDatatype = NULL;
    PrinterDefaults.pDevMode  = NULL;
    PrinterDefaults.DesiredAccess  = PRINTER_ALL_ACCESS;

    // PRINTER_READ ? READ_CONTROL

    if (!OpenPrinter((LPTSTR)lpszPrinterName, &hPrinter, &PrinterDefaults))
    {
        hPrinter = NULL; // OpenPrinter may trash hPrinter
    }

    return(hPrinter);
}

HANDLE Printer_OpenPrinter(LPCTSTR lpszPrinterName)
{
    HANDLE hPrinter = NULL;

    if (!OpenPrinter((LPTSTR)lpszPrinterName, &hPrinter, NULL))
    {
        hPrinter = NULL; // OpenPrinter may trash hPrinter
    }

    return(hPrinter);
}

VOID Printer_ClosePrinter(HANDLE hPrinter)
{
    ClosePrinter(hPrinter);
}

BOOL Printers_DeletePrinter(HWND hWnd, LPCTSTR pszFullPrinter, DWORD dwAttributes, LPCTSTR pszServer, BOOL bQuietMode)
{
    DWORD dwCommand = MSP_REMOVEPRINTER;

    if (SHIsRestricted(hWnd, REST_NOPRINTERDELETE))
        return FALSE;

    if ((dwAttributes & PRINTER_ATTRIBUTE_NETWORK) && !(dwAttributes & PRINTER_ATTRIBUTE_LOCAL))
    {
        //
        // If it's not local, then it must be a remote connection.  Note
        // that we can't just check for PRINTER_ATTRIBUTE_NETWORK because
        // NT's spooler has 'masq' printers that are local printers
        // that masquarade as network printers.  Even though they
        // are created by connecting to a printer, the have both LOCAL
        // and NETWORK bits set.
        //
        dwCommand = MSP_REMOVENETPRINTER;
    }

    //
    // Don't show the confirmation dialog box if in quiet mode
    //
    if (!bQuietMode)
    {
        if (pszServer && pszServer[0])
        {
            //
            // It's a printer on the remote server.  (Skip \\ prefix on server.)
            //
            if (ShellMessageBox(HINST_THISDLL, hWnd,
                MAKEINTRESOURCE(IDS_SUREDELETEREMOTE),
                MAKEINTRESOURCE(IDS_PRINTERS), MB_YESNO|MB_ICONQUESTION,
                pszFullPrinter, SkipServerSlashes(pszServer)) != IDYES)
            {
                return FALSE;
            }
        }
        else if (dwAttributes & PRINTER_ATTRIBUTE_NETWORK)
        {
            TCHAR szScratch[MAXNAMELENBUFFER];
            LPTSTR pszPrinter, pszServer;

            Printer_SplitFullName(szScratch, pszFullPrinter, &pszServer, &pszPrinter);

            if (pszServer && *pszServer)
            {
                //
                // It's a printer connection.
                //
                if (ShellMessageBox(HINST_THISDLL, hWnd,
                    MAKEINTRESOURCE(IDS_SUREDELETECONNECTION),
                    MAKEINTRESOURCE(IDS_PRINTERS), MB_YESNO|MB_ICONQUESTION,
                    pszPrinter, SkipServerSlashes(pszServer)) != IDYES)
                {
                    return FALSE;
                }
            }
            else
            {
                //
                // It's a printer connection with a printer name that 
                // does not have a server name prefix i.e. \\server\printer.  This
                // is true for the http connected printer, which have printer names
                // of the form http://server/printer on NT these printers are 
                // 'masq' printers.  A 'masq' printer is a printer which 
                // is a local printer acting as network connection.
                //
                if (ShellMessageBox(HINST_THISDLL, hWnd,
                    MAKEINTRESOURCE(IDS_SUREDELETECONNECTIONNOSERVERNAME),
                    MAKEINTRESOURCE(IDS_PRINTERS), MB_YESNO|MB_ICONQUESTION,
                    pszPrinter) != IDYES)
                {
                    return FALSE;
                }
            }
        }
        else

        //
        // Neither a remote printer nor a local connection.  The final
        // upcoming else clause is a local printer.
        //
        if (ShellMessageBox(HINST_THISDLL, hWnd, MAKEINTRESOURCE(IDS_SUREDELETE),
            MAKEINTRESOURCE(IDS_PRINTERS), MB_YESNO|MB_ICONQUESTION, pszFullPrinter)
            != IDYES)
        {
            return FALSE;
        }
    }

    if (CallPrinterCopyHooks(hWnd, PO_DELETE, 0, pszFullPrinter, 0, NULL, 0)
        != IDYES)
    {
        return FALSE;
    }

    //
    // Cast away const.  Safe since Printers_PrinterSetup only modifies
    // pszPrinter if dwCommand is MSP_NEWDRIVER.
    //
    return BOOLFROMPTR(Printers_PrinterSetup(hWnd, dwCommand,
        (LPTSTR)pszFullPrinter, pszServer));
}

BOOL Printer_GPI2CB(LPVOID lpData, HANDLE hPrinter, DWORD dwLevel,
    LPBYTE pBuf, DWORD dwSize, DWORD *lpdwNeeded, DWORD *lpdwNum)
{
    return GetPrinter(hPrinter, dwLevel, pBuf, dwSize, lpdwNeeded);
}

//
// Old NT printers don't support the level 5.  So we try for the 2 after 5.
// Win96 WILL PROBABLY WANT TO DO THIS TOO!
//
LPPRINTER_INFO_5 Printer_MakePrinterInfo5( HANDLE hPrinter )
{
    LPPRINTER_INFO_5 pPI5;
    DWORD cbPI5;
    DWORD cbName;
    LPPRINTER_INFO_2 pPI2 = Printer_EnumProps(hPrinter, 2, NULL, Printer_GPI2CB, (LPVOID)0);
    if (!pPI2)
        return NULL;

    cbName = (lstrlen(pPI2->pPrinterName)+1) * SIZEOF(TCHAR);

    cbPI5 = SIZEOF(PRINTER_INFO_5) + cbName;

    //
    // Port name may not be supported (e.g., downlevel machines).
    //
    if (pPI2->pPortName)
    {
        cbPI5 += (lstrlen(pPI2->pPortName)+1) * SIZEOF(TCHAR);
    }

    pPI5 = (LPPRINTER_INFO_5)LocalAlloc(LPTR, cbPI5);
    if (pPI5)
    {
        ASSERT(pPI5->pPrinterName==NULL);   // These should be null for the
        ASSERT(pPI5->pPortName==NULL);      // no names case

        if (pPI2->pPrinterName)
        {
            pPI5->pPrinterName = (LPTSTR)(pPI5+1);
            lstrcpy(pPI5->pPrinterName, pPI2->pPrinterName);
        }
        if (pPI2->pPortName)
        {
            pPI5->pPortName    = (LPTSTR)((LPBYTE)(pPI5+1) + cbName);
            lstrcpy(pPI5->pPortName, pPI2->pPortName);
        }
        pPI5->Attributes = pPI2->Attributes;
        pPI5->DeviceNotSelectedTimeout = 0;
        pPI5->TransmissionRetryTimeout = 0;
    }
    LocalFree(pPI2);

    return(pPI5);
}

LPVOID Printer_GetPrinterInfo(HANDLE hPrinter, DWORD dwLevel)
{
    LPVOID pPrinter = Printer_EnumProps(hPrinter, dwLevel, NULL, Printer_GPI2CB, (LPVOID)0);
    //
    // Old NT printers don't support the level 5.  So we try for the 2 after 5.
    // Win96 WILL PROBABLY WANT TO DO THIS TOO!
    //
    if (!pPrinter && dwLevel == 5)
        return(Printer_MakePrinterInfo5(hPrinter));
    return pPrinter;

}

LPVOID Printer_GetPrinterInfoStr(LPCTSTR lpszPrinterName, DWORD dwLevel)
{
    LPPRINTER_INFO_2 pPI2 = NULL;
    HANDLE hPrinter = Printer_OpenPrinter(lpszPrinterName);
    if (hPrinter)
    {
        pPI2 = Printer_GetPrinterInfo(hPrinter, dwLevel);
        Printer_ClosePrinter(hPrinter);
    }
    return pPI2;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\privshl.h ===
#define WCHAR_COLON     L':'
#define WCHAR_NULL      L'\0'
#define WCHAR_COMMA     L','
#define WCHAR_A         L'a'
#define WCHAR_CAP_A     L'A'
#define WCHAR_C         L'c'
#define WCHAR_Z         L'z'
#define WCHAR_BSLASH    L'\\'
#define WCHAR_DOT       L'.'
#define WCHAR_QMARK     L'?'
#define WCHAR_STAR      L'*'
#define WCHAR_SLASH     L'/'
#define WCHAR_SPACE     L' '
#define WCHAR_QUOTE     L'"'
#define WCHAR_PLUS      L'+'
#define WCHAR_LTHAN     L'<'
#define WCHAR_BAR       L'|'
#define WCHAR_LBRACKET  L'['
#define WCHAR_RBRACKET  L']'
#define WCHAR_EQUAL     L'='
#define WCHAR_SEMICOLON L';'
#define WCHAR_HAT       L'^'

#define WSTR_DOT L"."
#define WSTR_BLANK L""
#define WSTR_SPACE L" "

#define CHAR_COLON      ':'
#define CHAR_BSLASH     '\\'
#define CHAR_NULL       '\0'
#define CHAR_COMMA      ','
#define CHAR_A          'a'
#define CHAR_CAP_A      'A'
#define CHAR_C          'c'
#define CHAR_Z          'z'
#define CHAR_BSLASH     '\\'
#define CHAR_DOT        '.'
#define CHAR_QMARK      '?'
#define CHAR_STAR       '*'
#define CHAR_SLASH      '/'
#define CHAR_SPACE      ' '
#define CHAR_QUOTE      '"'
#define CHAR_PLUS       '+'
#define CHAR_LTHAN      '<'
#define CHAR_BAR        '|'
#define CHAR_LBRACKET   '['
#define CHAR_RBRACKET   ']'
#define CHAR_EQUAL      '='
#define CHAR_SEMICOLON  ';'
#define CHAR_HAT        '^'
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\prnfldr.h ===
// this is really private data to CPrinterFolder
typedef struct
{
    USHORT  cb;
    USHORT  uFlags;

    #define PRINTER_MAGIC 0xBEBADB00

    DWORD   dwMagic;
    DWORD   dwType;
    WCHAR   cName[MAXNAMELENBUFFER];
    USHORT  uTerm;
} IDPRINTER;
typedef UNALIGNED IDPRINTER *LPIDPRINTER;
typedef const UNALIGNED IDPRINTER *LPCIDPRINTER;

// W95 IDPrinter structure
typedef struct
{
    USHORT  cb;
    char    cName[32];      // Win9x limitation
    USHORT  uTerm;
} W95IDPRINTER;
typedef const UNALIGNED W95IDPRINTER *LPW95IDPRINTER;

//
// Constants
//
const UINT kDNSMax = INTERNET_MAX_HOST_NAME_LENGTH;
const UINT kServerBufMax = kDNSMax + 2 + 1;

//
// Max printer name should really be MAX_PATH, but if you create
// a max path printer and connect to it remotely, win32spl prepends
// "\\server\" to it, causing it to exceed max path.  The new UI
// therefore makes the max path MAX_PATH-kServerLenMax, but we still
// allow the old case to work.
//
const UINT kPrinterBufMax = MAX_PATH + kServerBufMax + 1;


class CPrinterFolder : public IRemoteComputer,
                       public IPrinterFolder,
                       public IFolderNotify,
                       public IShellFolder2,
                       public IPersistFolder2,
                       public IContextMenuCB,
                       public IShellIconOverlay
{
    friend class CPrintersEnum;
    friend class CPrinterFolderViewCB;
public:
    CPrinterFolder();

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void** ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IShellFolder
    STDMETHODIMP BindToObject(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void** ppvOut);
    STDMETHODIMP BindToStorage(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void** ppvOut);
    STDMETHODIMP CompareIDs(LPARAM iCol, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);
    STDMETHODIMP CreateViewObject(HWND hwnd, REFIID riid, void** ppvOut);
    STDMETHODIMP EnumObjects(HWND hwndOwner, DWORD grfFlags, IEnumIDList** ppenum);
    STDMETHODIMP GetAttributesOf(UINT cidl, LPCITEMIDLIST* apidl, ULONG* prgfInOut);
    STDMETHODIMP GetDisplayNameOf(LPCITEMIDLIST pidl, DWORD uFlags, LPSTRRET lpName);
    STDMETHODIMP GetUIObjectOf(HWND hwndOwner, UINT cidl, LPCITEMIDLIST* apidl, REFIID riid, UINT* prgfInOut, void** ppvOut);
    STDMETHODIMP ParseDisplayName(HWND hwnd, LPBC pbc, LPOLESTR lpszDisplayName, ULONG* pchEaten, LPITEMIDLIST* ppidl, ULONG* pdwAttributes);
    STDMETHODIMP SetNameOf(HWND hwndOwner, LPCITEMIDLIST pidl, LPCOLESTR lpszName, DWORD dwReserved, LPITEMIDLIST* ppidlOut);

    // IShellFolder2
    STDMETHODIMP EnumSearches(IEnumExtraSearch **ppenum);
    STDMETHODIMP GetDefaultColumn(DWORD dwRes, ULONG* pSort, ULONG* pDisplay);
    STDMETHODIMP GetDefaultColumnState(UINT iColumn, DWORD* pdwState);
    STDMETHODIMP GetDefaultSearchGUID(LPGUID pGuid);
    STDMETHODIMP GetDetailsEx(LPCITEMIDLIST pidl, const SHCOLUMNID* pscid, VARIANT* pv);
    STDMETHODIMP GetDetailsOf(LPCITEMIDLIST pidl, UINT iColumn, SHELLDETAILS* pDetails);
    STDMETHODIMP MapColumnToSCID(UINT iCol, SHCOLUMNID* pscid);

    // IPersistFolder2
    STDMETHODIMP GetCurFolder(LPITEMIDLIST *ppidl);
    STDMETHODIMP Initialize(LPCITEMIDLIST pidl);
    STDMETHODIMP GetClassID(LPCLSID lpClassID);

    // IShellIconOverlay
    STDMETHODIMP GetOverlayIndex(LPCITEMIDLIST pidl, int* pIndex);
    STDMETHODIMP GetOverlayIconIndex(LPCITEMIDLIST pidl, int *pIndex);

    // IRemoteComputer
    STDMETHODIMP Initialize(const WCHAR *pszMachine, BOOL bEnumerating);

    // IPrinterFolder
    STDMETHODIMP_(BOOL) IsPrinter(LPCITEMIDLIST pidl);

    // IFolderNotify
    STDMETHODIMP_(BOOL) ProcessNotify(FOLDER_NOTIFY_TYPE NotifyType, LPCWSTR pszName, LPCWSTR pszNewName);

    // IContextMenuCB
    STDMETHODIMP CallBack(IShellFolder *psf, HWND hwnd,IDataObject *pdo, UINT uMsg, WPARAM wParam, LPARAM lParam);

    // DUI webview impl.
    HRESULT GetWebViewLayout(IUnknown *pv, UINT uViewMode, SFVM_WEBVIEW_LAYOUT_DATA* pData);
    HRESULT GetWebViewContent(IUnknown *pv, SFVM_WEBVIEW_CONTENT_DATA* pData);
    HRESULT GetWebViewTasks(IUnknown *pv, SFVM_WEBVIEW_TASKSECTION_DATA* pTasks);

    // mask passsed to _IsContextMenuVerbEnabled to determine the selection type in which 
    // this command is applicable
    enum 
    {
        // nothing is selected
        SEL_NONE                = 0x0000, // nothing is selected 

        // single selection types
        SEL_SINGLE_ADDPRN       = 0x0001, // the add printer wizard object is selected
        SEL_SINGLE_PRINTER      = 0x0002, // 1 printer is selected
        SEL_SINGLE_LINK         = 0x0004, // 1 link is selected
        
        // any single selection type
        SEL_SINGLE_ANY          = SEL_SINGLE_ADDPRN | SEL_SINGLE_PRINTER | SEL_SINGLE_LINK,

        // multi selection types
        SEL_MULTI_PRINTER       = 0x0010, // 2+ printers are selected
        SEL_MULTI_LINK          = 0x0020, // 2+ links are selected
        SEL_MULTI_MIXED         = 0x0040, // 2+ objects of any type are selected

        // any link in the selection
        SEL_LINK_ANY            = SEL_SINGLE_LINK | SEL_MULTI_LINK | SEL_MULTI_MIXED,

        // any printer in the selection
        SEL_PRINTER_ANY         = SEL_SINGLE_ADDPRN | SEL_SINGLE_ADDPRN | 
                                  SEL_MULTI_PRINTER | SEL_MULTI_MIXED,
        
        // any multi selection type
        SEL_MULTI_ANY           = SEL_MULTI_PRINTER | SEL_MULTI_LINK | SEL_MULTI_MIXED,

        // any selection type
        SEL_ANY                 = SEL_SINGLE_ANY | SEL_MULTI_ANY,
    };

    // split the selection into its parts (printers and links) and determine the 
    // selection type (see the enum above)
    HRESULT SplitSelection(IDataObject *pdo, UINT *puSelType, IDataObject **ppdoPrinters, IDataObject **ppdoLinks);

    // webview verbs
    enum WV_VERB
    {
        // standard verbs
        WVIDM_DELETE,
        WVIDM_RENAME,
        WVIDM_PROPERTIES,

        // common verbs
        WVIDM_ADDPRINTERWIZARD,
        WVIDM_SERVERPROPERTIES,
        WVIDM_SETUPFAXING,
        WVIDM_CREATELOCALFAX,
        WVIDM_SENDFAXWIZARD,

        // special common verbs
        WVIDM_TROUBLESHOOTER,
        WVIDM_GOTOSUPPORT,

        // printer verbs
        WVIDM_OPENPRN,
        WVIDM_NETPRN_INSTALL,
        WVIDM_SETDEFAULTPRN,
        WVIDM_DOCUMENTDEFAULTS,
        WVIDM_PAUSEPRN,
        WVIDM_RESUMEPRN,
        WVIDM_PURGEPRN,
        WVIDM_SHARING,
        WVIDM_WORKOFFLINE,
        WVIDM_WORKONLINE,

        // special commands
        WVIDM_VENDORURL,
        WVIDM_PRINTERURL,

        WVIDM_COUNT,
    };

    // webview support - core APIs
    HRESULT _WebviewVerbIsEnabled(WV_VERB eVerbID, UINT uSelMask, BOOL *pbEnabled);
    HRESULT _WebviewVerbInvoke(WV_VERB eVerbID, IUnknown* pv, IShellItemArray *psiItemArray);
    HRESULT _WebviewCheckToUpdateDataObjectCache(IDataObject *pdo);

private:
    virtual ~CPrinterFolder();

    // data access
    LPCTSTR GetServer() { return _pszServer; }
    HANDLE GetFolder()  { CheckToRegisterNotify(); return _hFolder; }
    BOOL GetAdminAccess() { CheckToRegisterNotify(); return _bAdminAccess; }

    static LPCTSTR GetStatusString(PFOLDER_PRINTER_DATA pData, LPTSTR pBuff, UINT uSize);
    static INT GetCompareDisplayName(LPCTSTR pName1, LPCTSTR pName2);
    INT CompareData(LPCIDPRINTER pidp1, LPCIDPRINTER pidp2, LPARAM iCol);
    static ReduceToLikeKinds(UINT *pcidl, LPCITEMIDLIST **papidl, BOOL fPrintObjects);
    DWORD SpoolerVersion();
    void CheckToRegisterNotify();
    void CheckToRefresh();
    void RequestRefresh();
    HRESULT _GetFullIDList(LPCWSTR pszPrinter, LPITEMIDLIST *ppidl);
    static HRESULT _Parse(LPCWSTR pszPrinter, LPITEMIDLIST *ppidl, DWORD dwType = 0, USHORT uFlags = 0);
    static void _FillPidl(LPIDPRINTER pidl, LPCTSTR szName, DWORD dwType = 0, USHORT uFlags = 0);
    LPCTSTR _BuildPrinterName(LPTSTR pszFullPrinter, LPCIDPRINTER pidp, LPCTSTR pszPrinter);
    void _MergeMenu(LPQCMINFO pqcm, LPCTSTR pszPrinter);
    HRESULT _InvokeCommand(HWND hwnd, LPCIDPRINTER pidp, WPARAM wParam, LPARAM lParam, LPBOOL pfChooseNewDefault);
    HRESULT _InvokeCommandRunAs(HWND hwnd, LPCIDPRINTER pidp, WPARAM wParam, LPARAM lParam, LPBOOL pfChooseNewDefault);
    BOOL _PurgePrinter(HWND hwnd, LPCTSTR pszFullPrinter, UINT uAction, BOOL bQuietMode);
    LPTSTR _FindIcon(LPCTSTR pszPrinterName, LPTSTR pszModule, ULONG cbModule, int *piIcon, int *piShortcutIcon);
    static HRESULT CALLBACK _DFMCallBack(IShellFolder *psf, HWND hwnd,
        IDataObject *pdo, UINT uMsg, WPARAM wParam, LPARAM lParam);
    HRESULT _PrinterObjectsCallBack(HWND hwnd, UINT uSelType, 
        IDataObject *pdo, UINT uMsg, WPARAM wParam, LPARAM lParam);
    static LPTSTR _ItemName(LPCIDPRINTER pidp, LPTSTR pszName, UINT cch);
    static BOOL _IsAddPrinter(LPCIDPRINTER pidp);
   
    HRESULT _UpdateDataObjectCache();
    HRESULT _AssocCreate(REFIID riid, void **ppv);
    HRESULT _OnRefresh(BOOL bPriorRefresh);

    LONG                _cRef;                  // ref count
    LPITEMIDLIST        _pidl;                  // the PIDL of this folder
    LPTSTR              _pszServer;             // the print server this folder is browsing (NULL means local PF)
    DWORD               _dwSpoolerVersion;      // the spooler version
    HANDLE              _hFolder;               // handle to the printer folder cache (in printui)
    BOOL                _bAdminAccess;          // TRUE if you have admin access to this print server
    BOOL                _bReqRefresh;           // whether we should request a full refresh during the next enum


    // our webview get command state cache. we have 35+ commands and unpacking 
    // the same data object each time we need to verify the state of a command 
    // can be very expensive! we are going to maintain a cache with each command 
    // state and update the cache each time the data object gets changed, so 
    // the get state callbacks will finish very quickly just by consulting 
    // the cache.
    
    IDataObject        *_pdoCache;                          // current data object
    UINT                _uSelCurrent;                       // current selection type
    BOOL                _aWVCommandStates[WVIDM_COUNT];     // commands state cache

    // the folder has to be MT safe
    CCSLock             _csLock;

    // slow data. this members below should refresh every time the selection changes,
    // but we should do this in a separate thread since updating them can take a while

    enum ESlowWebviewDataType
    {
        WV_SLOW_DATA_OEM_SUPPORT_URL,
        WV_SLOW_DATA_PRINTER_WEB_URL,

        WV_SLOW_DATA_COUNT,
    };

    enum 
    {
        // in miliseconds
        WV_SLOW_DATA_CACHE_TIMEOUT = 5000,
    };

    class CSlowWVDataCacheEntry
    {
    public:
        CSlowWVDataCacheEntry(CPrinterFolder *ppf):
            _ppf(ppf),
            _bDataPending(TRUE),
            _nLastTimeUpdated(0)
        {}

        HRESULT Initialize(LPCTSTR pszPrinterName)
        { 
            HRESULT hr = S_OK;
            if (pszPrinterName)
            {
                _bstrPrinterName = pszPrinterName; 
                hr = _bstrPrinterName ? S_OK : E_OUTOFMEMORY;
            }
            else
            {
                hr = E_INVALIDARG;
            }
            return hr;
        }

        CPrinterFolder     *_ppf;
        BOOL                _bDataPending;
        DWORD               _nLastTimeUpdated;
        CComBSTR            _bstrPrinterName;
        CComBSTR            _arrData[WV_SLOW_DATA_COUNT];
    };

    static DWORD WINAPI _SlowWebviewData_WorkerProc(LPVOID lpParameter);
    static HRESULT _SlowWVDataRetrieve(LPCTSTR pszPrinterName, BSTR *pbstrSupportUrl, BSTR *pbstrPrinterWebUrl);
    static int _CompareSlowWVDataCacheEntries(CSlowWVDataCacheEntry *p1, 
        CSlowWVDataCacheEntry *p2, LPARAM lParam);

    HRESULT _GetSelectedPrinter(BSTR *pbstrVal);
    HRESULT _GetSlowWVDataForCurrentPrinter(ESlowWebviewDataType eType, BSTR *pbstrVal);
    HRESULT _GetSlowWVData(LPCTSTR pszPrinterName, ESlowWebviewDataType eType, BSTR *pbstrVal);
    HRESULT _UpdateSlowWVDataCacheEntry(CSlowWVDataCacheEntry *pCacheEntry);
    HRESULT _SlowWVDataUpdateWebviewPane();
    HRESULT _SlowWVDataCacheResetUnsafe();
    HRESULT _GetCustomSupportURL(BSTR *pbstrVal);

    CComBSTR _bstrSelectedPrinter;
    CDPA<CSlowWVDataCacheEntry> _dpaSlowWVDataCache;

    // fax support...
    static HRESULT _GetFaxControl(IDispatch **ppDisp);
    static HRESULT _GetFaxCommand(UINT_PTR *puCmd);
    static HRESULT _InvokeFaxControlMethod(LPCTSTR pszMethodName);
    static DWORD WINAPI _ThreadProc_InstallFaxService(LPVOID lpParameter);
    static DWORD WINAPI _ThreadProc_InstallLocalFaxPrinter(LPVOID lpParameter);
};

STDAPI CPrinterFolderDropTarget_CreateInstance(HWND hwnd, IDropTarget **ppdropt);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\prndrop.cpp ===
#include "shellprv.h"
#pragma  hdrstop

// Must have access to:
// IID_IPrinterFolder & IID_IFolderNotify interfaces
// declared in windows\inc\winprtp.h
//
#include <initguid.h>
#include <winprtp.h>

#include "w32utils.h"
#include "dpa.h"
#include <msprintx.h>
#include "ids.h"
#include "printer.h"
#include "copy.h"
#include "fstreex.h"
#include "datautil.h"
#include "infotip.h"
#include "idldrop.h"
#include "ovrlaymn.h"
#include "netview.h"
#include "prnfldr.h"

// thread data param
typedef struct {
    CIDLDropTarget *pdt;
    IStream     *pstmDataObj;
    IDataObject *pdtobj;
    DWORD        grfKeyState;
    POINTL       pt;
    DWORD        dwEffect;
} PRINT_DROP_THREAD;

class CPrinterFolderDropTarget : public CIDLDropTarget
{
    friend HRESULT CPrinterFolderDropTarget_CreateInstance(HWND hwnd, IDropTarget **ppdropt);
public:
    CPrinterFolderDropTarget(HWND hwnd) : CIDLDropTarget(hwnd) { };

    // IDropTarget methods overwirte
    STDMETHODIMP DragEnter(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    STDMETHODIMP Drop(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);

    static STDMETHODIMP _HIDATestForRmPrns( LPIDA pida, int * pcRPFs, int * pcNonRPFs );
    static void _FreePrintDropData(PRINT_DROP_THREAD *pthp);
    static DWORD CALLBACK _ThreadProc(void *pv);
};

STDMETHODIMP CPrinterFolderDropTarget::_HIDATestForRmPrns(LPIDA pida, int *pcRPFs, int *pcNonRPFs)
{
    // check to see if any of the ID's are remote printers....
    for (UINT i = 0; i < pida->cidl; i++)
    {
        LPITEMIDLIST pidlTo = IDA_ILClone(pida, i);
        if (pidlTo)
        {
            LPCITEMIDLIST pidlRemainder = NULL;
            // *pidlRemainder will be NULL for remote print folders,
            // and non-NULL for printers under remote print folders
            if (NET_IsRemoteRegItem(pidlTo, CLSID_Printers, &pidlRemainder)) // && (pidlRemainder->mkid.cb == 0))
            {
                (*pcRPFs)++;
            }
            else
            {
                (*pcNonRPFs)++;
            }
            ILFree(pidlTo);
        }
    }

    return S_OK;
}

STDMETHODIMP CPrinterFolderDropTarget::DragEnter(IDataObject * pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    // We allow printer shares to be dropped for installing
    // But we don't want to spend the time on DragEnter finding out if it's
    // a printer share, so allow drops of any net resource or HIDA
    // REVIEW: Actually, it wouldn't take long to check the first one, but
    // sequencing through everything does seem like a pain.

    // let the base-class process it now to save away the pdwEffect
    CIDLDropTarget::DragEnter(pdtobj, grfKeyState, pt, pdwEffect);

    // are we dropping on the background ? Do we have the IDLIST clipformat ?
    if (m_dwData & DTID_HIDA)
    {
        int cRPFs = 0;
        int cNonRPFs = 0;
        
        STGMEDIUM medium;
        FORMATETC fmte = {g_cfNetResource, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
        
        LPIDA pida = DataObj_GetHIDA(pdtobj, &medium);
        if (pida)
        {
            _HIDATestForRmPrns( pida, &cRPFs, &cNonRPFs );
            HIDA_ReleaseStgMedium(pida, &medium);
        }

        // if we have no Remote printers or we have any non "remote printers"
        // and we have no other clipformat to test...
        if ((( cRPFs == 0 ) || ( cNonRPFs != 0 )) && !( m_dwData & DTID_NETRES ))
        {
            // the Drop code below only handles drops for HIDA format on NT
            // and only if all off them are Remote Printers
            *pdwEffect &= ~DROPEFFECT_LINK;
        }
    }   

    if ((m_dwData & DTID_NETRES) || (m_dwData & DTID_HIDA))
    {
        *pdwEffect &= DROPEFFECT_LINK;
    }
    else
    {
        *pdwEffect = DROPEFFECT_NONE;
    }

    m_dwEffectLastReturned = *pdwEffect;
    return S_OK;
}

void CPrinterFolderDropTarget::_FreePrintDropData(PRINT_DROP_THREAD *pthp)
{
    if (pthp->pstmDataObj)
        pthp->pstmDataObj->Release();

    if (pthp->pdtobj)
        pthp->pdtobj->Release();

    pthp->pdt->Release();
    LocalFree((HLOCAL)pthp);
}

DWORD CALLBACK CPrinterFolderDropTarget::_ThreadProc(void *pv)
{
    PRINT_DROP_THREAD *pthp = (PRINT_DROP_THREAD *)pv;
    STGMEDIUM medium;
    HRESULT hres = E_FAIL;
    FORMATETC fmte = {g_cfHIDA, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};

    CoGetInterfaceAndReleaseStream(pthp->pstmDataObj, IID_IDataObject, (void **)&pthp->pdtobj);
    pthp->pstmDataObj = NULL;

    if (pthp->pdtobj == NULL)
    {
        _FreePrintDropData(pthp);
        return 0;
    }

    // First try to drop as a link to a remote print folder
    LPIDA pida = DataObj_GetHIDA(pthp->pdtobj, &medium);
    if (pida)
    {
        // Make sure that if one item in the dataobject is a
        // remote print folder, that they are all remote print folders.

        // If none are, we just give up on dropping as a RPF link, and
        // fall through to checking for printer shares via the
        // NETRESOURCE clipboard format, below.
        int cRPFs = 0, cNonRPFs = 0;
        
        _HIDATestForRmPrns( pida, &cRPFs, &cNonRPFs );

        if ((cRPFs > 0) && (cNonRPFs == 0))
        {
            // All the items in the dataobject are remote print folders or
            // printers under remote printer folders
            for (UINT i = 0; i < pida->cidl; i++)
            {
                LPITEMIDLIST pidlTo = IDA_ILClone(pida, i);
                if (pidlTo)
                {
                    LPCITEMIDLIST pidlRemainder; // The part after the remote regitem
                    NET_IsRemoteRegItem(pidlTo, CLSID_Printers, &pidlRemainder);
                    if (ILIsEmpty(pidlRemainder))
                    {
                        // This is a remote printer folder.  Drop a link to the
                        // 'PrintHood' directory

                        IShellFolder2 *psf = CPrintRoot_GetPSF();
                        if (psf)
                        {
                            IDropTarget *pdt;
                            hres = psf->CreateViewObject(pthp->pdt->_GetWindow(),
                                                                 IID_PPV_ARG(IDropTarget, &pdt));
                            if (SUCCEEDED(hres))
                            {
                                pthp->dwEffect = DROPEFFECT_LINK;
                                hres = SHSimulateDrop(pdt, pthp->pdtobj, pthp->grfKeyState, &pthp->pt, &pthp->dwEffect);
                                pdt->Release();
                            }
                        }
                    }
                    else
                    {
                        TCHAR szPrinter[MAX_PATH];

                        SHGetNameAndFlags(pidlTo, SHGDN_FORPARSING, szPrinter, ARRAYSIZE(szPrinter), NULL);
                        //
                        // Setup if not the add printer wizard.
                        //
                        if (lstrcmpi(szPrinter, c_szNewObject))
                        {
                            LPITEMIDLIST pidl = Printers_PrinterSetup(pthp->pdt->_GetWindow(), MSP_NETPRINTER, szPrinter, NULL);
                            if (pidl)
                                ILFree(pidl);
                        }

                        // make sure we set hres to S_OK, so we don't break the main loop
                        hres = S_OK;
                    }
                    ILFree(pidlTo);

                    if (FAILED(hres))
                        break;
                }
            }
            HIDA_ReleaseStgMedium(pida, &medium);
            SHChangeNotifyHandleEvents();       // force update now
            goto Cleanup;
        }
        else if ((cRPFs > 0) && (cNonRPFs > 0))
        {
            // At least one, but not all, item(s) in this dataobject
            // was a remote printer folder.  Jump out now.
            goto Cleanup;
        }

        // else none of the items in the dataobject were remote print
        // folders, so fall through to the NETRESOURCE parsing
    }

    // Reset FORMATETC to NETRESOURCE clipformat for next GetData call
    fmte.cfFormat = g_cfNetResource;

    // DragEnter only allows network resources to be DROPEFFECT_LINKed
    ASSERT(S_OK == pthp->pdtobj->QueryGetData(&fmte));

    if (SUCCEEDED(pthp->pdtobj->GetData(&fmte, &medium)))
    {
        LPNETRESOURCE pnr = (LPNETRESOURCE)LocalAlloc(LPTR, 1024);
        if (pnr)
        {
            BOOL fNonPrnShare = FALSE;
            UINT cItems = SHGetNetResource(medium.hGlobal, (UINT)-1, NULL, 0);
            for (UINT iItem = 0; iItem < cItems; iItem++)
            {
                if (SHGetNetResource(medium.hGlobal, iItem, pnr, 1024) &&
                    pnr->dwDisplayType == RESOURCEDISPLAYTYPE_SHARE &&
                    pnr->dwType == RESOURCETYPE_PRINT)
                {
                    LPITEMIDLIST pidl = Printers_PrinterSetup(pthp->pdt->_GetWindow(),
                               MSP_NETPRINTER, pnr->lpRemoteName, NULL);

                    if (pidl)
                        ILFree(pidl);
                }
                else
                {
                    if (!fNonPrnShare)
                    {
                        // so we don't get > 1 of these messages per drop
                        fNonPrnShare = TRUE;

                        // let the user know that they can't drop non-printer
                        // shares into the printers folder
                        SetForegroundWindow(pthp->pdt->_GetWindow());
                        ShellMessageBox(HINST_THISDLL,
                            pthp->pdt->_GetWindow(),
                            MAKEINTRESOURCE(IDS_CANTINSTALLRESOURCE), NULL,
                            MB_OK|MB_ICONINFORMATION,
                            (LPTSTR)pnr->lpRemoteName);
                    }
                }
            }

            LocalFree((HLOCAL)pnr);
        }
        ReleaseStgMedium(&medium);
    }

Cleanup:
    _FreePrintDropData(pthp);
    return 0;
}

STDMETHODIMP CPrinterFolderDropTarget::Drop(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    *pdwEffect = DROPEFFECT_LINK;

    HRESULT hr = CIDLDropTarget::DragDropMenu(DROPEFFECT_LINK, pdtobj,
        pt, pdwEffect, NULL, NULL, MENU_PRINTOBJ_NEWPRN_DD, grfKeyState);

    if (*pdwEffect)
    {
        PRINT_DROP_THREAD *pthp = (PRINT_DROP_THREAD *)LocalAlloc(LPTR, SIZEOF(*pthp));
        if (pthp)
        {
            pthp->grfKeyState = grfKeyState;
            pthp->pt          = pt;
            pthp->dwEffect    = *pdwEffect;

            CoMarshalInterThreadInterfaceInStream(IID_IDataObject, (IUnknown *)pdtobj, &pthp->pstmDataObj);

            pthp->pdt = this;
            pthp->pdt->AddRef();

            if (SHCreateThread(_ThreadProc, pthp, CTF_COINIT, NULL))
            {
                hr = S_OK;
            }
            else
            {
                _FreePrintDropData(pthp);
                hr = E_OUTOFMEMORY;
            }
        }
    }
    CIDLDropTarget::DragLeave();

    return hr;
}

STDAPI CPrinterFolderDropTarget_CreateInstance(HWND hwnd, IDropTarget **ppdropt)
{
    *ppdropt = NULL;

    HRESULT hr;
    CPrinterFolderDropTarget *ppfdt = new CPrinterFolderDropTarget(hwnd);
    if (ppfdt)
    {
        hr = ppfdt->QueryInterface(IID_PPV_ARG(IDropTarget, ppdropt));
        ppfdt->Release();
    }
    else
        hr = E_OUTOFMEMORY;
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\prop.cpp ===
#include "shellprv.h"

#include "prop.h"
#include <ntquery.h>    // defines some values used for fmtid and pid
#include "findfilter.h" // includes oledb (which defines some values used for fmtid and pid) properly
#include "ids.h"
#include "imgprop.h"
#include <gdiplus\gdiplus.h> // for PropertyTag* definitions

#define MAX_UTF8_CHAR_SIZE        (sizeof(CHAR) * 3)

//  FMTID_ExeDllInformation,
//// {0CEF7D53-FA64-11d1-A203-0000F81FEDEE}
#define PSFMTID_VERSION { 0xcef7d53, 0xfa64, 0x11d1, 0xa2, 0x3, 0x0, 0x0, 0xf8, 0x1f, 0xed, 0xee }

#define PIDVSI_FileDescription   0x003
#define PIDVSI_FileVersion       0x004
#define PIDVSI_InternalName      0x005
#define PIDVSI_OriginalFileName  0x006
#define PIDVSI_ProductName       0x007
#define PIDVSI_ProductVersion    0x008

#define TIFFTAG_FAX_END_TIME            40052
#define TIFFTAG_SENDER_NAME             40021
#define TIFFTAG_TSID                    40002
#define TIFFTAG_CALLERID                40005
#define TIFFTAG_RECIP_NAME              40006
#define TIFFTAG_RECIP_NUMBER            40007
#define TIFFTAG_CSID                    40001
#define TIFFTAG_ROUTING                 40004


// Internal PSGUID/PIDs
//
// Note:
//  This section was added to allow SCIDs to be defined without exposing them
//  externally (via public header files).  In this way, we can define SCIDs
//  without having to worry about maintaining external support for them in
//  future.

// {8D72ACA1-0716-419a-9AC1-ACB07B18DC32}
#define PSGUID_PRV_STORAGE  {0x8d72aca1, 0x716, 0x419a, 0x9a, 0xc1, 0xac, 0xb0, 0x7b, 0x18, 0xdc, 0x32}
#define PID_PRV_STG_ATTRIBUTES_DESCRIPTION  2


DEFINE_SCID(SCID_Author                             , PSGUID_SUMMARYINFORMATION             , PIDSI_AUTHOR); 
DEFINE_SCID(SCID_LastAuthor                         , PSGUID_SUMMARYINFORMATION             , PIDSI_LASTAUTHOR);
DEFINE_SCID(SCID_RevNumber                          , PSGUID_SUMMARYINFORMATION             , PIDSI_REVNUMBER);
DEFINE_SCID(SCID_AppName                            , PSGUID_SUMMARYINFORMATION             , PIDSI_APPNAME);
DEFINE_SCID(SCID_Title                              , PSGUID_SUMMARYINFORMATION             , PIDSI_TITLE);
DEFINE_SCID(SCID_Subject                            , PSGUID_SUMMARYINFORMATION             , PIDSI_SUBJECT);
DEFINE_SCID(SCID_Category                           , PSGUID_DOCUMENTSUMMARYINFORMATION     , PIDDSI_CATEGORY);
DEFINE_SCID(SCID_Keywords                           , PSGUID_SUMMARYINFORMATION             , PIDSI_KEYWORDS );
DEFINE_SCID(SCID_Rating                             , PSGUID_MEDIAFILESUMMARYINFORMATION    , PIDMSI_RATING );
DEFINE_SCID(SCID_Template                           , PSGUID_SUMMARYINFORMATION             , PIDSI_TEMPLATE );
DEFINE_SCID(SCID_Copyright                          , PSGUID_MEDIAFILESUMMARYINFORMATION    , PIDMSI_COPYRIGHT);
DEFINE_SCID(SCID_CompanyName                        , PSGUID_DOCUMENTSUMMARYINFORMATION     , PIDDSI_COMPANY);
DEFINE_SCID(SCID_Manager                            , PSGUID_DOCUMENTSUMMARYINFORMATION     , PIDDSI_MANAGER);
DEFINE_SCID(SCID_PresFormat                         , PSGUID_DOCUMENTSUMMARYINFORMATION     , PIDDSI_PRESFORMAT);
DEFINE_SCID(SCID_PageCount                          , PSGUID_SUMMARYINFORMATION             , PIDSI_PAGECOUNT);
DEFINE_SCID(SCID_Comment                            , PSGUID_SUMMARYINFORMATION             , PIDSI_COMMENTS);
DEFINE_SCID(SCID_DocCreated                         , PSGUID_SUMMARYINFORMATION             , PIDSI_CREATE_DTM);   // in the doc, not file system
DEFINE_SCID(SCID_WordCount                          , PSGUID_SUMMARYINFORMATION             , PIDSI_WORDCOUNT);
DEFINE_SCID(SCID_CharCount                          , PSGUID_SUMMARYINFORMATION             , PIDSI_CHARCOUNT);
DEFINE_SCID(SCID_LastSaveDTM                        , PSGUID_SUMMARYINFORMATION             , PIDSI_LASTSAVE_DTM);
DEFINE_SCID(SCID_LastPrinted                        , PSGUID_SUMMARYINFORMATION             , PIDSI_LASTPRINTED);
DEFINE_SCID(SCID_EditTime                           , PSGUID_SUMMARYINFORMATION             , PIDSI_EDITTIME);
DEFINE_SCID(SCID_ByteCount                          , PSGUID_DOCUMENTSUMMARYINFORMATION     , PIDDSI_BYTECOUNT);
DEFINE_SCID(SCID_LineCount                          , PSGUID_DOCUMENTSUMMARYINFORMATION     , PIDDSI_LINECOUNT);
DEFINE_SCID(SCID_ParagraphCount                     , PSGUID_DOCUMENTSUMMARYINFORMATION     , PIDDSI_PARCOUNT);
DEFINE_SCID(SCID_SlideCount                         , PSGUID_DOCUMENTSUMMARYINFORMATION     , PIDDSI_SLIDECOUNT);
DEFINE_SCID(SCID_NoteCount                          , PSGUID_DOCUMENTSUMMARYINFORMATION     , PIDDSI_NOTECOUNT);
DEFINE_SCID(SCID_HiddenCount                        , PSGUID_DOCUMENTSUMMARYINFORMATION     , PIDDSI_HIDDENCOUNT);
DEFINE_SCID(SCID_MMClipCount                        , PSGUID_DOCUMENTSUMMARYINFORMATION     , PIDDSI_MMCLIPCOUNT);
DEFINE_SCID(SCID_Scale                              , PSGUID_DOCUMENTSUMMARYINFORMATION     , PIDDSI_SCALE);
DEFINE_SCID(SCID_LinksDirty                         , PSGUID_DOCUMENTSUMMARYINFORMATION     , PIDDSI_LINKSDIRTY);
DEFINE_SCID(SCID_TYPE                               , PSGUID_STORAGE                        , PID_STG_STORAGETYPE);
DEFINE_SCID(SCID_NAME                               , PSGUID_STORAGE                        , PID_STG_NAME);
DEFINE_SCID(SCID_SIZE                               , PSGUID_STORAGE                        , PID_STG_SIZE);
DEFINE_SCID(SCID_ATTRIBUTES                         , PSGUID_STORAGE                        , PID_STG_ATTRIBUTES);
DEFINE_SCID(SCID_WRITETIME                          , PSGUID_STORAGE                        , PID_STG_WRITETIME);
DEFINE_SCID(SCID_CREATETIME                         , PSGUID_STORAGE                        , PID_STG_CREATETIME);
DEFINE_SCID(SCID_ACCESSTIME                         , PSGUID_STORAGE                        , PID_STG_ACCESSTIME);
DEFINE_SCID(SCID_DIRECTORY                          , PSGUID_STORAGE                        , PID_STG_DIRECTORY);
DEFINE_SCID(SCID_FREESPACE                          , PSGUID_VOLUME                         , PID_VOLUME_FREE);
DEFINE_SCID(SCID_CAPACITY                           , PSGUID_VOLUME                         , PID_VOLUME_CAPACITY);
DEFINE_SCID(SCID_FILESYSTEM                         , PSGUID_VOLUME                         , PID_VOLUME_FILESYSTEM);
DEFINE_SCID(SCID_DELETEDFROM                        , PSGUID_DISPLACED                      , PID_DISPLACED_FROM);
DEFINE_SCID(SCID_DATEDELETED                        , PSGUID_DISPLACED                      , PID_DISPLACED_DATE);
DEFINE_SCID(SCID_SYNCCOPYIN                         , PSGUID_BRIEFCASE                      , PID_SYNC_COPY_IN);
DEFINE_SCID(SCID_RANK                               , PSGUID_QUERY_D                        , PID_QUERY_RANK);
DEFINE_SCID(SCID_LASTVISITED                        , PSGUID_INTERNETSITE                   , PID_INTSITE_LASTVISIT);
DEFINE_SCID(SCID_LASTMODIFIED                       , PSGUID_INTERNETSITE                   , PID_INTSITE_LASTMOD);
DEFINE_SCID(SCID_VISITCOUNT                         , PSGUID_INTERNETSITE                   , PID_INTSITE_VISITCOUNT);
DEFINE_SCID(SCID_STATUS                             , PSGUID_INTERNETSITE                   , PID_INTSITE_FLAGS);
DEFINE_SCID(SCID_FINDDATA                           , PSGUID_SHELLDETAILS                   , PID_FINDDATA);
DEFINE_SCID(SCID_NETRESOURCE                        , PSGUID_SHELLDETAILS                   , PID_NETRESOURCE);
DEFINE_SCID(SCID_DESCRIPTIONID                      , PSGUID_SHELLDETAILS                   , PID_DESCRIPTIONID);
DEFINE_SCID(SCID_WHICHFOLDER                        , PSGUID_SHELLDETAILS                   , PID_WHICHFOLDER);
DEFINE_SCID(SCID_NETWORKLOCATION                    , PSGUID_SHELLDETAILS                   , PID_NETWORKLOCATION);
DEFINE_SCID(SCID_COMPUTERNAME                       , PSGUID_SHELLDETAILS                   , PID_COMPUTERNAME);
DEFINE_SCID(SCID_OWNER                              , PSGUID_MISC                           , PID_MISC_OWNER);
// DEFINE_SCID(SCID_STATUS                          , PSGUID_MISC                            , PID_MISC_STATUS);
// DEFINE_SCID(SCID_ACCESSCOUNT                     , PSGUID_MISC                            , PID_MISC_ACCESSCOUNT);
DEFINE_SCID(SCID_DetailsProperties                  , PSGUID_WEBVIEW                        , PID_DISPLAY_PROPERTIES);
DEFINE_SCID(SCID_FolderIntroText                    , PSGUID_WEBVIEW                        , PID_INTROTEXT);
DEFINE_SCID(SCID_CONTROLPANELCATEGORY               , PSGUID_CONTROLPANEL                   , PID_CONTROLPANEL_CATEGORY);
DEFINE_SCID(SCID_MUSIC_Artist                       , PSGUID_MUSIC                          , PIDSI_ARTIST);
DEFINE_SCID(SCID_MUSIC_Album                        , PSGUID_MUSIC                          , PIDSI_ALBUM);
DEFINE_SCID(SCID_MUSIC_Year                         , PSGUID_MUSIC                          , PIDSI_YEAR);
DEFINE_SCID(SCID_MUSIC_Track                        , PSGUID_MUSIC                          , PIDSI_TRACK);
DEFINE_SCID(SCID_MUSIC_Genre                        , PSGUID_MUSIC                          , PIDSI_GENRE);
DEFINE_SCID(SCID_MUSIC_Lyrics                       , PSGUID_MUSIC                          , PIDSI_LYRICS);
DEFINE_SCID(SCID_DRM_Protected                      , PSGUID_DRM                            , PIDDRSI_PROTECTED);
DEFINE_SCID(SCID_DRM_Description                    , PSGUID_DRM                            , PIDDRSI_DESCRIPTION);
DEFINE_SCID(SCID_DRM_PlayCount                      , PSGUID_DRM                            , PIDDRSI_PLAYCOUNT);
DEFINE_SCID(SCID_DRM_PlayStarts                     , PSGUID_DRM                            , PIDDRSI_PLAYSTARTS);
DEFINE_SCID(SCID_DRM_PlayExpires                    , PSGUID_DRM                            , PIDDRSI_PLAYEXPIRES);
DEFINE_SCID(SCID_AUDIO_Duration                     , PSGUID_AUDIO                          , PIDASI_TIMELENGTH);       //100ns units, not milliseconds. VT_UI8, not VT_UI4
DEFINE_SCID(SCID_AUDIO_Bitrate                      , PSGUID_AUDIO                          , PIDASI_AVG_DATA_RATE);    // bits per second
DEFINE_SCID(SCID_AUDIO_SampleRate                   , PSGUID_AUDIO                          , PIDASI_SAMPLE_RATE);      // samples per second
DEFINE_SCID(SCID_AUDIO_SampleSize                   , PSGUID_AUDIO                          , PIDASI_SAMPLE_SIZE);      // bits per sample
DEFINE_SCID(SCID_AUDIO_ChannelCount                 , PSGUID_AUDIO                          , PIDASI_CHANNEL_COUNT);    // 1 (mono), 2(stero)
DEFINE_SCID(SCID_AUDIO_Format                       , PSGUID_AUDIO                          , PIDASI_FORMAT);
DEFINE_SCID(SCID_VIDEO_Bitrate                      , PSGUID_VIDEO                          , PIDVSI_DATA_RATE);        // bits per second
DEFINE_SCID(SCID_VIDEO_FrameRate                    , PSGUID_VIDEO                          , PIDVSI_FRAME_RATE);       // frames per 1000s
DEFINE_SCID(SCID_VIDEO_SampleSize                   , PSGUID_VIDEO                          , PIDVSI_SAMPLE_SIZE);      // bits
DEFINE_SCID(SCID_VIDEO_Compression                  , PSGUID_VIDEO                          , PIDVSI_COMPRESSION);
DEFINE_SCID(SCID_VIDEO_StreamName                   , PSGUID_VIDEO                          , PIDVSI_STREAM_NAME);
DEFINE_SCID(SCID_FileType                           , PSGUID_IMAGESUMMARYINFORMATION        , PIDISI_FILETYPE);
DEFINE_SCID(SCID_ImageCX                            , PSGUID_IMAGESUMMARYINFORMATION        , PIDISI_CX);
DEFINE_SCID(SCID_ImageCY                            , PSGUID_IMAGESUMMARYINFORMATION        , PIDISI_CY);
DEFINE_SCID(SCID_ResolutionX                        , PSGUID_IMAGESUMMARYINFORMATION        , PIDISI_RESOLUTIONX);
DEFINE_SCID(SCID_ResolutionY                        , PSGUID_IMAGESUMMARYINFORMATION        , PIDISI_RESOLUTIONY);
DEFINE_SCID(SCID_BitDepth                           , PSGUID_IMAGESUMMARYINFORMATION        , PIDISI_BITDEPTH);
DEFINE_SCID(SCID_Colorspace                         , PSGUID_IMAGESUMMARYINFORMATION        , PIDISI_COLORSPACE);
DEFINE_SCID(SCID_Compression                        , PSGUID_IMAGESUMMARYINFORMATION        , PIDISI_COMPRESSION);
DEFINE_SCID(SCID_Transparency                       , PSGUID_IMAGESUMMARYINFORMATION        , PIDISI_TRANSPARENCY);
DEFINE_SCID(SCID_GammaValue                         , PSGUID_IMAGESUMMARYINFORMATION        , PIDISI_GAMMAVALUE);
DEFINE_SCID(SCID_FrameCount                         , PSGUID_IMAGESUMMARYINFORMATION        , PIDISI_FRAMECOUNT);
DEFINE_SCID(SCID_ImageDimensions                    , PSGUID_IMAGESUMMARYINFORMATION        , PIDISI_DIMENSIONS);
DEFINE_SCID(SCID_CameraModel                        , PSGUID_IMAGEPROPERTIES                , PropertyTagEquipModel); 
DEFINE_SCID(SCID_TagCopyright                       , PSGUID_IMAGEPROPERTIES                , PropertyTagCopyright);
DEFINE_SCID(SCID_TagSoftwareUsed                    , PSGUID_IMAGEPROPERTIES                , PropertyTagSoftwareUsed);
DEFINE_SCID(SCID_WhenTaken                          , PSGUID_IMAGEPROPERTIES                , PropertyTagExifDTOrig);
DEFINE_SCID(SCID_Flash                              , PSGUID_IMAGEPROPERTIES                , PropertyTagExifFlash);
DEFINE_SCID(SCID_ColorSpace                         , PSGUID_IMAGEPROPERTIES                , PropertyTagExifColorSpace);
DEFINE_SCID(SCID_ShutterSpeed                       , PSGUID_IMAGEPROPERTIES                , PropertyTagExifShutterSpeed);
DEFINE_SCID(SCID_Aperture                           , PSGUID_IMAGEPROPERTIES                , PropertyTagExifAperture);
DEFINE_SCID(SCID_SubjectDist                        , PSGUID_IMAGEPROPERTIES                , PropertyTagExifSubjectDist);
DEFINE_SCID(SCID_FocalLength                        , PSGUID_IMAGEPROPERTIES                , PropertyTagExifFocalLength);
DEFINE_SCID(SCID_FNumber                            , PSGUID_IMAGEPROPERTIES                , PropertyTagExifFNumber);
DEFINE_SCID(SCID_ExposureTime                       , PSGUID_IMAGEPROPERTIES                , PropertyTagExifExposureTime);
DEFINE_SCID(SCID_FlashEnergy                        , PSGUID_IMAGEPROPERTIES                , PropertyTagExifFlashEnergy);
DEFINE_SCID(SCID_ISOSpeed                           , PSGUID_IMAGEPROPERTIES                , PropertyTagExifISOSpeed);
DEFINE_SCID(SCID_MeteringMode                       , PSGUID_IMAGEPROPERTIES                , PropertyTagExifMeteringMode);
DEFINE_SCID(SCID_LightSource                        , PSGUID_IMAGEPROPERTIES                , PropertyTagExifLightSource);
DEFINE_SCID(SCID_ExposureProg                       , PSGUID_IMAGEPROPERTIES                , PropertyTagExifExposureProg);
DEFINE_SCID(SCID_ExposureBias                       , PSGUID_IMAGEPROPERTIES                , PropertyTagExifExposureBias);
DEFINE_SCID(SCID_FaxEndTime                         , PSGUID_IMAGEPROPERTIES                , TIFFTAG_FAX_END_TIME);
DEFINE_SCID(SCID_FaxSenderName                      , PSGUID_IMAGEPROPERTIES                , TIFFTAG_SENDER_NAME);
DEFINE_SCID(SCID_FaxTSID                            , PSGUID_IMAGEPROPERTIES                , TIFFTAG_TSID);
DEFINE_SCID(SCID_FaxCallerId                        , PSGUID_IMAGEPROPERTIES                , TIFFTAG_CALLERID);
DEFINE_SCID(SCID_FaxRecipName                       , PSGUID_IMAGEPROPERTIES                , TIFFTAG_RECIP_NAME);
DEFINE_SCID(SCID_FaxRecipNumber                     , PSGUID_IMAGEPROPERTIES                , TIFFTAG_RECIP_NUMBER);
DEFINE_SCID(SCID_FaxCSID                            , PSGUID_IMAGEPROPERTIES                , TIFFTAG_CSID);
DEFINE_SCID(SCID_FaxRouting                         , PSGUID_IMAGEPROPERTIES                , TIFFTAG_ROUTING);
DEFINE_SCID(SCID_TagEquipMake                       , PSGUID_IMAGEPROPERTIES                , PropertyTagEquipMake);
DEFINE_SCID(SCID_Media_SequenceNumber               , PSGUID_MEDIAFILESUMMARYINFORMATION    , PIDMSI_SEQUENCE_NO);
DEFINE_SCID(SCID_Media_Owner                        , PSGUID_MEDIAFILESUMMARYINFORMATION    , PIDMSI_OWNER);
DEFINE_SCID(SCID_Media_Editor                       , PSGUID_MEDIAFILESUMMARYINFORMATION    , PIDMSI_EDITOR);
DEFINE_SCID(SCID_Media_Supplier                     , PSGUID_MEDIAFILESUMMARYINFORMATION    , PIDMSI_SUPPLIER);
DEFINE_SCID(SCID_Media_Source                       , PSGUID_MEDIAFILESUMMARYINFORMATION    , PIDMSI_SOURCE);
DEFINE_SCID(SCID_Media_Copyright                    , PSGUID_MEDIAFILESUMMARYINFORMATION    , PIDMSI_COPYRIGHT);
DEFINE_SCID(SCID_Media_Project                      , PSGUID_MEDIAFILESUMMARYINFORMATION    , PIDMSI_PROJECT);
DEFINE_SCID(SCID_Media_Status                       , PSGUID_MEDIAFILESUMMARYINFORMATION    , PIDMSI_STATUS);
DEFINE_SCID(SCID_Media_Production                   , PSGUID_MEDIAFILESUMMARYINFORMATION    , PIDMSI_PRODUCTION);
DEFINE_SCID(SCID_CSC_STATUS                         , PSGUID_SHARE                          , PID_SHARE_CSC_STATUS);
DEFINE_SCID(SCID_LINKTARGET                         , PSGUID_LINK                           , PID_LINK_TARGET);
DEFINE_SCID(SCID_ATTRIBUTES_DESCRIPTION             , PSGUID_PRV_STORAGE                    , PID_PRV_STG_ATTRIBUTES_DESCRIPTION);

typedef struct
{
    LPCWSTR pwszName;
    const SHCOLUMNID *pscid;
    UINT idDisplayName;
    UINT idMnemonicName;
    UINT idHelp;        // IDH_ values
} PROPUI_INFO;

#define PROPUI_ENTRY_NORES(name, scid)                           {L ## name, &scid, 0, 0, 0},
#define PROPUI_ENTRY(name, scid, idDisplayName, idMnemonicName, idHelp)  {L ## name, &scid, idDisplayName, idMnemonicName, idHelp},

const PROPUI_INFO c_rgPropUIInfo[] =
{
    PROPUI_ENTRY("Name"                 , SCID_NAME                     , IDS_NAME_COL              , IDS_MNEMONIC_NAME_COL             , 10114)
    PROPUI_ENTRY("Type"                 , SCID_TYPE                     , IDS_TYPE_COL              , IDS_MNEMONIC_TYPE_COL             , 10015)
    PROPUI_ENTRY("Size"                 , SCID_SIZE                     , IDS_SIZE_COL              , IDS_MNEMONIC_SIZE_COL             , 10115)
    PROPUI_ENTRY("Write"                , SCID_WRITETIME                , IDS_MODIFIED_COL          , IDS_MNEMONIC_MODIFIED_COL         , 10016)
    PROPUI_ENTRY("Attributes"           , SCID_ATTRIBUTES               , IDS_ATTRIB_COL            , IDS_MNEMONIC_ATTRIB_COL           , 10019)
    PROPUI_ENTRY("AttributesDescription", SCID_ATTRIBUTES_DESCRIPTION   , IDS_ATTRIB_COL            , IDS_MNEMONIC_ATTRIB_COL           , 10019)
    PROPUI_ENTRY("Owner"                , SCID_OWNER                    , IDS_EXCOL_OWNER           , IDS_MNEMONIC_EXCOL_OWNER          , 10021)
    PROPUI_ENTRY("Create"               , SCID_CREATETIME               , IDS_EXCOL_CREATE          , IDS_MNEMONIC_EXCOL_CREATE         , 10017)
    PROPUI_ENTRY("Access"               , SCID_ACCESSTIME               , IDS_EXCOL_ACCESSTIME      , IDS_MNEMONIC_EXCOL_ACCESSTIME     , 10018)
    PROPUI_ENTRY("DocCreatedTm"         , SCID_DocCreated               , IDS_EXCOL_CREATE          , IDS_MNEMONIC_EXCOL_CREATE         , 10068)
    PROPUI_ENTRY("DocTitle"             , SCID_Title                    , IDS_EXCOL_TITLE           , IDS_MNEMONIC_EXCOL_TITLE          , 10023)
    PROPUI_ENTRY("DocSubject"           , SCID_Subject                  , IDS_EXCOL_SUBJECT         , IDS_MNEMONIC_EXCOL_SUBJECT        , 10024)
    PROPUI_ENTRY("DocAuthor"            , SCID_Author                   , IDS_EXCOL_AUTHOR          , IDS_MNEMONIC_EXCOL_AUTHOR         , 10022)
    PROPUI_ENTRY("DocLastAuthor"        , SCID_LastAuthor               , IDS_EXCOL_LASTAUTHOR      , IDS_MNEMONIC_EXCOL_LASTAUTHOR     , 20010)
    PROPUI_ENTRY("DocRevNumber"         , SCID_RevNumber                , IDS_EXCOL_REVNUMBER       , IDS_MNEMONIC_EXCOL_REVNUMBER      , 20011)
    PROPUI_ENTRY("DocAppName"           , SCID_AppName                  , IDS_EXCOL_APPNAME         , IDS_MNEMONIC_EXCOL_APPNAME        , 20012)
    PROPUI_ENTRY("DocPageCount"         , SCID_PageCount                , IDS_EXCOL_PAGECOUNT       , IDS_MNEMONIC_EXCOL_PAGECOUNT      , 10026)
    PROPUI_ENTRY("DocComments"          , SCID_Comment                  , IDS_EXCOL_COMMENT         , IDS_MNEMONIC_EXCOL_COMMENT        , 10020)
    PROPUI_ENTRY("Copyright"            , SCID_Copyright                , IDS_EXCOL_COPYRIGHT       , IDS_MNEMONIC_EXCOL_COPYRIGHT      , 10027)
    PROPUI_ENTRY("DocCategory"          , SCID_Category                 , IDS_EXCOL_CATEGORY        , IDS_MNEMONIC_EXCOL_CATEGORY       , 10025)
    PROPUI_ENTRY("DocKeywords"          , SCID_Keywords                 , IDS_EXCOL_KEYWORDS        , IDS_MNEMONIC_EXCOL_KEYWORDS       , 20013)
    PROPUI_ENTRY("Rating"               , SCID_Rating                   , IDS_EXCOL_RATING          , IDS_MNEMONIC_EXCOL_RATING         , 20014)
    PROPUI_ENTRY("DocTemplate"          , SCID_Template                 , IDS_EXCOL_TEMPLATEPROP    , IDS_MNEMONIC_EXCOL_TEMPLATE       , 20015)
    PROPUI_ENTRY("DocWordCount"         , SCID_WordCount                , IDS_EXCOL_WORDCOUNT       , IDS_MNEMONIC_EXCOL_WORDCOUNT      , 20016)
    PROPUI_ENTRY("DocCharCount"         , SCID_CharCount                , IDS_EXCOL_CHARCOUNT       , IDS_MNEMONIC_EXCOL_CHARCOUNT      , 20017)
    PROPUI_ENTRY("DocLastSavedTm"       , SCID_LastSaveDTM              , IDS_EXCOL_LASTSAVEDTM     , IDS_MNEMONIC_EXCOL_LASTSAVEDTM    , 20018)
    PROPUI_ENTRY("DocLastPrinted"       , SCID_LastPrinted              , IDS_EXCOL_LASTPRINTED     , IDS_MNEMONIC_EXCOL_LASTPRINTED    , 20019)
    PROPUI_ENTRY("DocEditTime"          , SCID_EditTime                 , IDS_EXCOL_EDITTIME        , IDS_MNEMONIC_EXCOL_EDITTIME       , 20020)
    PROPUI_ENTRY("DocByteCount"         , SCID_ByteCount                , IDS_EXCOL_BYTECOUNT       , IDS_MNEMONIC_EXCOL_BYTECOUNT      , 20021)
    PROPUI_ENTRY("DocLineCount"         , SCID_LineCount                , IDS_EXCOL_LINECOUNT       , IDS_MNEMONIC_EXCOL_LINECOUNT      , 20022)
    PROPUI_ENTRY("DocParaCount"         , SCID_ParagraphCount           , IDS_EXCOL_PARCOUNT        , IDS_MNEMONIC_EXCOL_PARCOUNT       , 20023)
    PROPUI_ENTRY("DocSlideCount"        , SCID_SlideCount               , IDS_EXCOL_SLIDECOUNT      , IDS_MNEMONIC_EXCOL_SLIDECOUNT     , 20024)
    PROPUI_ENTRY("DocNoteCount"         , SCID_NoteCount                , IDS_EXCOL_NOTECOUNT       , IDS_MNEMONIC_EXCOL_NOTECOUNT      , 20025)
    PROPUI_ENTRY("DocHiddenCount"       , SCID_HiddenCount              , IDS_EXCOL_HIDDENCOUNT     , IDS_MNEMONIC_EXCOL_HIDDENCOUNT    , 20026)
    PROPUI_ENTRY("MMClipCount"          , SCID_MMClipCount              , IDS_EXCOL_MMCLIPCOUNT     , IDS_MNEMONIC_EXCOL_MMCLIPCOUNT    , 20027)
    PROPUI_ENTRY("Scale"                , SCID_Scale                    , IDS_EXCOL_SCALE           , IDS_MNEMONIC_EXCOL_SCALE          , 20028)
    PROPUI_ENTRY("LinksUpToDate"        , SCID_LinksDirty               , IDS_EXCOL_LINKSDIRTY      , IDS_MNEMONIC_EXCOL_LINKSDIRTY     , 20029)
    PROPUI_ENTRY("CameraModel"          , SCID_CameraModel              , IDS_EXCOL_CAMERAMODEL     , IDS_MNEMONIC_EXCOL_CAMERAMODEL    , 10037)
    PROPUI_ENTRY("Copyright"            , SCID_TagCopyright             , IDS_EXCOL_COPYRIGHT       , IDS_MNEMONIC_EXCOL_COPYRIGHT      , 20030)
    PROPUI_ENTRY("Software"             , SCID_TagSoftwareUsed          , IDS_EXCOL_SOFTWARE        , IDS_MNEMONIC_EXCOL_SOFTWARE       , 20031)
    PROPUI_ENTRY("WhenTaken"            , SCID_WhenTaken                , IDS_EXCOL_WHENTAKEN       , IDS_MNEMONIC_EXCOL_WHENTAKEN      , 10038)
    PROPUI_ENTRY("FileType"             , SCID_FileType                 , IDS_EXCOL_FILETYPE        , IDS_MNEMONIC_EXCOL_FILETYPE       , 20032)
    PROPUI_ENTRY("ImageX"               , SCID_ImageCX                  , IDS_EXCOL_IMAGECX         , IDS_MNEMONIC_EXCOL_IMAGECX        , 20033)
    PROPUI_ENTRY("ImageY"               , SCID_ImageCY                  , IDS_EXCOL_IMAGECY         , IDS_MNEMONIC_EXCOL_IMAGECY        , 20034)
    PROPUI_ENTRY("ResolutionX"          , SCID_ResolutionX              , IDS_EXCOL_RESOLUTIONX     , IDS_MNEMONIC_EXCOL_RESOLUTIONX    , 20035)
    PROPUI_ENTRY("ResolutionY"          , SCID_ResolutionY              , IDS_EXCOL_RESOLUTIONY     , IDS_MNEMONIC_EXCOL_RESOLUTIONY    , 20036)
    PROPUI_ENTRY("BitDepth"             , SCID_BitDepth                 , IDS_EXCOL_BITDEPTH        , IDS_MNEMONIC_EXCOL_BITDEPTH       , 20037)
    PROPUI_ENTRY("ColorSpace"           , SCID_ColorSpace               , IDS_EXCOL_COLORSPACE      , IDS_MNEMONIC_EXCOL_COLORSPACE     , 20038)
    PROPUI_ENTRY("ColorSpace"           , SCID_Colorspace               , IDS_EXCOL_COLORSPACE      , IDS_MNEMONIC_EXCOL_COLORSPACE     , 20038)
    PROPUI_ENTRY("Compression"          , SCID_Compression              , IDS_EXCOL_ACOMPRESSION    , IDS_MNEMONIC_EXCOL_ACOMPRESSION   , 20039)
    PROPUI_ENTRY("Transparency"         , SCID_Transparency             , IDS_EXCOL_TRANSPARENCY    , IDS_MNEMONIC_EXCOL_TRANSPARENCY   , 20040)
    PROPUI_ENTRY("Gamma"                , SCID_GammaValue               , IDS_EXCOL_GAMMAVALUE      , IDS_MNEMONIC_EXCOL_GAMMAVALUE     , 20041)
    PROPUI_ENTRY("FrameCount"           , SCID_FrameCount               , IDS_EXCOL_FRAMECOUNT      , IDS_MNEMONIC_EXCOL_FRAMECOUNT     , 10046)
    PROPUI_ENTRY("Dimensions"           , SCID_ImageDimensions          , IDS_EXCOL_DIMENSIONS      , IDS_MNEMONIC_EXCOL_DIMENSIONS     , 10059)
    PROPUI_ENTRY("Flash"                , SCID_Flash                    , IDS_EXCOL_FLASH           , IDS_MNEMONIC_EXCOL_FLASH          , 20042)
    PROPUI_ENTRY("ShutterSpeed"         , SCID_ShutterSpeed             , IDS_EXCOL_SHUTTERSPEED    , IDS_NMEMONIC_EXCOL_SHUTTERSPEED   , 20043)
    PROPUI_ENTRY("Aperture"             , SCID_Aperture                 , IDS_EXCOL_APERTURE        , IDS_NMEMONIC_EXCOL_APERTURE       , 20044)
    PROPUI_ENTRY("Distance"             , SCID_SubjectDist              , IDS_EXCOL_DISTANCE        , IDS_NMEMONIC_EXCOL_DISTANCE       , 20046)
    PROPUI_ENTRY("FocalLength"          , SCID_FocalLength              , IDS_EXCOL_FOCALLENGTH     , IDS_MNEMONIC_EXCOL_FOCALLENGTH    , 20047)
    PROPUI_ENTRY("FNumber"              , SCID_FNumber                  , IDS_EXCOL_FNUMBER         , IDS_MNEMONIC_EXCOL_FNUMBER        , 20049)
    PROPUI_ENTRY("ExposureTime"         , SCID_ExposureTime             , IDS_EXCOL_EXPOSURETIME    , IDS_MNEMONIC_EXCOL_EXPOSURETIME   , 20049)
    PROPUI_ENTRY("FlashEnergy"          , SCID_FlashEnergy              ,IDS_EXCOL_FLASHENERGY      , IDS_MNEMONIC_EXCOL_FLASHENERGY    , 20080)
    PROPUI_ENTRY("ISOSpeed"             , SCID_ISOSpeed                 ,IDS_EXCOL_ISOSPEED         , IDS_MNEMONIC_EXCOL_ISOSPEED       , 20081)
    PROPUI_ENTRY("MeteringMode"         , SCID_MeteringMode             ,IDS_EXCOL_METERINGMODE     , IDS_MNEMONIC_EXCOL_METERINGMODE   , 20082)
    PROPUI_ENTRY("LightSource"          , SCID_LightSource              ,IDS_EXCOL_LIGHTSOURCE      , IDS_MNEMONIC_EXCOL_LIGHTSOURCE    , 20083)
    PROPUI_ENTRY("ExposureProg"         , SCID_ExposureProg             ,IDS_EXCOL_EXPOSUREPROG     , IDS_MNEMONIC_EXCOL_EXPOSUREPROG   , 20084)
    PROPUI_ENTRY("ExposureBias"         , SCID_ExposureBias             ,IDS_EXCOL_EXPOSUREBIAS     , IDS_MNEMONIC_EXCOL_EXPOSUREBIAS   , 20085)
    PROPUI_ENTRY("Artist"               , SCID_MUSIC_Artist             , IDS_EXCOL_ARTIST          , IDS_MNEMONIC_EXCOL_ARTIST         , 10028)
    PROPUI_ENTRY("Album"                , SCID_MUSIC_Album              , IDS_EXCOL_ALBUM           , IDS_MNEMONIC_EXCOL_ALBUM          , 10029)
    PROPUI_ENTRY("Year"                 , SCID_MUSIC_Year               , IDS_EXCOL_YEAR            , IDS_MNEMONIC_EXCOL_YEAR           , 10030)
    PROPUI_ENTRY("Track"                , SCID_MUSIC_Track              , IDS_EXCOL_TRACK           , IDS_MNEMONIC_EXCOL_TRACK          , 10031)
    PROPUI_ENTRY("Duration"             , SCID_AUDIO_Duration           , IDS_EXCOL_DURATION        , IDS_MNEMONIC_EXCOL_DURATION       , 10032)
    PROPUI_ENTRY("Bitrate"              , SCID_AUDIO_Bitrate            , IDS_EXCOL_BITRATE         , IDS_MNEMONIC_EXCOL_BITRATE        , 10033)
    PROPUI_ENTRY("Sample Rate"          , SCID_AUDIO_SampleRate         , IDS_EXCOL_SAMPLERATE      , IDS_MNEMONIC_EXCOL_SAMPLERATE     , 20050)
    PROPUI_ENTRY("Audio Sample Size"    , SCID_AUDIO_SampleSize         , IDS_EXCOL_ASAMPLESIZE     , IDS_MNEMONIC_EXCOL_ASAMPLESIZE    , 10041)
    PROPUI_ENTRY("Channels"             , SCID_AUDIO_ChannelCount       , IDS_EXCOL_CHANNELS        , IDS_MNEMONIC_EXCOL_CHANNELS       , 10047)
    PROPUI_ENTRY("Audio Format"         , SCID_AUDIO_Format             , IDS_EXCOL_FORMAT          , IDS_MNEMONIC_EXCOL_FORMAT         , 10039)  
    PROPUI_ENTRY("Data Rate"            , SCID_VIDEO_Bitrate            , IDS_EXCOL_DATARATE        , IDS_MNEMONIC_EXCOL_DATARATE       , 20050)
    PROPUI_ENTRY("Frame Rate"           , SCID_VIDEO_FrameRate          , IDS_EXCOL_FRAMERATE       , IDS_MNEMONIC_EXCOL_FRAMERATE      , 10045)
    PROPUI_ENTRY("Video Sample Size"    , SCID_VIDEO_SampleSize         , IDS_EXCOL_VSAMPLESIZE     , IDS_MNEMONIC_EXCOL_VSAMPLESIZE    , 10044)
    PROPUI_ENTRY("Compression"          , SCID_VIDEO_Compression        , IDS_EXCOL_VCOMPRESSION    , IDS_MNEMONIC_EXCOL_VCOMPRESSION   , 10043)
    PROPUI_ENTRY("Stream Name"          , SCID_VIDEO_StreamName         , IDS_EXCOL_STREAMNAME      , IDS_MNEMONIC_EXCOL_STREAMNAME     , 20051)
    PROPUI_ENTRY("Genre"                , SCID_MUSIC_Genre              , IDS_EXCOL_GENRE           , IDS_MNEMONIC_EXCOL_GENRE          , 20052)
    PROPUI_ENTRY("Lyrics"               , SCID_MUSIC_Lyrics             , IDS_EXCOL_LYRICS          , IDS_EXCOL_LYRICS                  , 0)
    PROPUI_ENTRY("Protected"            , SCID_DRM_Protected            , IDS_EXCOL_PROTECTED       , IDS_MNEMONIC_EXCOL_PROTECTED      , 20074)
    PROPUI_ENTRY("DRM Description"      , SCID_DRM_Description          , IDS_EXCOL_DRMDESCRIPTION  , IDS_MNEMONIC_EXCOL_DRMDESCRIPTION , 20075)
    PROPUI_ENTRY("Play Count"           , SCID_DRM_PlayCount            , IDS_EXCOL_PLAYCOUNT       , IDS_MNEMONIC_EXCOL_PLAYCOUNT      , 20076)
    PROPUI_ENTRY("Play Starts"          , SCID_DRM_PlayStarts           , IDS_EXCOL_PLAYSTARTS      , IDS_MNEMONIC_EXCOL_PLAYSTARTS     , 20077)
    PROPUI_ENTRY("Play Expires"         , SCID_DRM_PlayExpires          , IDS_EXCOL_PLAYEXPIRES     , IDS_MNEMONIC_EXCOL_PLAYEXPIRES    , 20078)
    PROPUI_ENTRY("FaxTime"              , SCID_FaxEndTime               , IDS_EXCOL_FAXENDTIME      , IDS_MNEMONIC_EXCOL_FAXENDTIME     , 20053)
    PROPUI_ENTRY("FaxSenderName"        , SCID_FaxSenderName            , IDS_EXCOL_FAXSENDERNAME   , IDS_MNEMONIC_EXCOL_FAXSENDERNAME  , 20054)
    PROPUI_ENTRY("FaxTSID"              , SCID_FaxTSID                  , IDS_EXCOL_FAXTSID         , IDS_MNEMONIC_EXCOL_FAXTSID        , 20055)
    PROPUI_ENTRY("FaxCallerID"          , SCID_FaxCallerId              , IDS_EXCOL_FAXCALLERID     , IDS_MNEMONIC_EXCOL_FAXCALLERID    , 20056)
    PROPUI_ENTRY("FaxRecipientName"     , SCID_FaxRecipName             , IDS_EXCOL_FAXRECIPNAME    , IDS_MNEMONIC_EXCOL_FAXRECIPNAME   , 20057)
    PROPUI_ENTRY("FaxRecipientNumber"   , SCID_FaxRecipNumber           , IDS_EXCOL_FAXRECIPNUMBER  , IDS_MNEMONIC_EXCOL_FAXRECIPNUMBER , 20058)
    PROPUI_ENTRY("FaxCSID"              , SCID_FaxCSID                  , IDS_EXCOL_FAXCSID         , IDS_MNEMONIC_EXCOL_FAXCSID        , 20059)
    PROPUI_ENTRY("FaxRouting"           , SCID_FaxRouting               , IDS_EXCOL_FAXROUTING      , IDS_MNEMONIC_EXCOL_FAXROUTING     , 20060)
    PROPUI_ENTRY("EquipMake"            , SCID_TagEquipMake             , IDS_EXCOL_TAGEQUIPMAKE    , IDS_MNEMONIC_EXCOL_TAGEQUIPMAKE   , 20061)
    PROPUI_ENTRY("SequenceNo"           , SCID_Media_SequenceNumber     , IDS_EXCOL_SEQUENCENUMBER  , IDS_MNEMONIC_EXCOL_SEQUENCENUMBER , 20062)
    PROPUI_ENTRY("Owner"                , SCID_Media_Owner              , IDS_EXCOL_OWNER           , IDS_MNEMONIC_EXCOL_OWNER          , 20063)
    PROPUI_ENTRY("Editor"               , SCID_Media_Editor             , IDS_EXCOL_EDITOR          , IDS_MNEMONIC_EXCOL_EDITOR         , 20064)
    PROPUI_ENTRY("Supplier"             , SCID_Media_Supplier           , IDS_EXCOL_SUPPLIER        , IDS_MNEMONIC_EXCOL_SUPPLIER       , 20065)
    PROPUI_ENTRY("Source"               , SCID_Media_Source             , IDS_EXCOL_SOURCE          , IDS_MNEMONIC_EXCOL_SOURCE         , 20066)
    PROPUI_ENTRY("Copyright"            , SCID_Media_Copyright          , IDS_EXCOL_COPYRIGHT       , IDS_MNEMONIC_EXCOL_COPYRIGHT      , 20067)
    PROPUI_ENTRY("Project"              , SCID_Media_Project            , IDS_EXCOL_PROJECT         , IDS_MNEMONIC_EXCOL_PROJECT        , 20068)
    PROPUI_ENTRY("Status"               , SCID_Media_Status             , IDS_EXCOL_STATUS          , IDS_MNEMONIC_EXCOL_STATUS         , 20069)
    PROPUI_ENTRY("Production"           , SCID_Media_Production         , IDS_EXCOL_PRODUCTION      , IDS_MNEMONIC_EXCOL_PRODUCTION     , 20070)
    PROPUI_ENTRY("Company"              , SCID_CompanyName              , IDS_VN_COMPANYNAME        , IDS_MNEMONIC_VN_COMPANYNAME       , 10034)
    PROPUI_ENTRY("Manager"              , SCID_Manager                  , IDS_EXCOL_MANAGER         , IDS_MNEMONIC_EXCOL_MANAGER        , 20071)
    PROPUI_ENTRY("PresentationTarget"   , SCID_PresFormat               , IDS_EXCOL_PRESFORMAT      , IDS_MNEMONIC_EXCOL_PRESFORMAT     , 20072)
    PROPUI_ENTRY("FileDescription"      , SCID_FileDescription          , IDS_VN_FILEDESCRIPTION    , IDS_MNEMONIC_VN_FILEDESCRIPTION   , 10056)
    PROPUI_ENTRY("FileVersion"          , SCID_FileVersion              , IDS_VN_FILEVERSION        , IDS_MNEMONIC_VN_FILEVERSION       , 10057)
    PROPUI_ENTRY("ProductName"          , SCID_ProductName              , IDS_VN_PRODUCTNAME        , IDS_MNEMONIC_VN_PRODUCTNAME       , 10035)
    PROPUI_ENTRY("ProductVersion"       , SCID_ProductVersion           , IDS_VN_PRODUCTVERSION     , IDS_MNEMONIC_VN_PRODUCTVERSION    , 10036)
    PROPUI_ENTRY("DeletedFrom"          , SCID_DELETEDFROM              , IDS_DELETEDFROM_COL       , IDS_MNEMONIC_DELETEDFROM_COL      , 10048)
    PROPUI_ENTRY("DateDeleted"          , SCID_DATEDELETED              , IDS_DATEDELETED_COL       , IDS_MNEMONIC_DATEDELETED_COL      , 10049)
    PROPUI_ENTRY("SyncCopyIn"           , SCID_SYNCCOPYIN               , IDS_SYNCCOPYIN_COL        , IDS_MNEMONIC_SYNCCOPYIN_COL       , 10060)
    PROPUI_ENTRY("Status"               , SCID_STATUS                   , IDS_STATUS_COL            , IDS_MNEMONIC_STATUS_COL           , 0)    //  do we need help for this? What is it? 
    PROPUI_ENTRY("FreeSpace"            , SCID_FREESPACE                , IDS_DRIVES_FREE           , IDS_MNEMONIC_DRIVES_FREE          , 10051)
    PROPUI_ENTRY("Capacity"             , SCID_CAPACITY                 , IDS_DRIVES_CAPACITY       , IDS_MNEMONIC_DRIVES_CAPACITY      , 10050)
    PROPUI_ENTRY("FileSystem"           , SCID_FILESYSTEM               , IDS_DRIVES_FILESYSTEM     , IDS_MNEMONIC_DRIVES_FILESYSTEM    , 10062)
    PROPUI_ENTRY(""                     , SCID_PRN_QUEUESIZE            , IDS_PSD_QUEUESIZE         , IDS_MNEMONIC_PSD_QUEUESIZE        , 10063)
    PROPUI_ENTRY(""                     , SCID_PRN_LOCATION             , IDS_PSD_LOCATION          , IDS_MNEMONIC_PSD_LOCATION         , 10064)
    PROPUI_ENTRY(""                     , SCID_PRN_MODEL                , IDS_PSD_MODEL             , IDS_MNEMONIC_PSD_MODEL            , 10066)
    PROPUI_ENTRY(""                     , SCID_PRN_STATUS               , IDS_PRQ_STATUS            , IDS_MNEMONIC_PRQ_STATUS           , 10065)
    PROPUI_ENTRY("Directory"            , SCID_DIRECTORY                , IDS_PATH_COL              , IDS_MNEMONIC_PATH_COL             , 10053)
    PROPUI_ENTRY("Rank"                 , SCID_RANK                     , IDS_RANK_COL              , IDS_MNEMONIC_RANK_COL             , 10054)
    PROPUI_ENTRY(""                     , SCID_WHICHFOLDER              , IDS_WHICHFOLDER_COL       , IDS_MNEMONIC_WHICHFOLDER_COL      , 10067)
    PROPUI_ENTRY("CSCStatus"            , SCID_CSC_STATUS               , IDS_CSC_STATUS            , IDS_MNEMONIC_CSC_STATUS           , 20073)
    PROPUI_ENTRY_NORES("LinkTarget"     , SCID_LINKTARGET)
};

//  String resource mapping block
struct STRING_MAP
{
    ULONG uVal;
    UINT  idStr;
};

static const STRING_MAP g_cLightSourceStrings[] =
{
    { 1, IDS_PROPERTYUI_IMAGE_DAYLIGHT},
    { 2, IDS_PROPERTYUI_IMAGE_FLOURESCENT},
    { 3, IDS_PROPERTYUI_IMAGE_TUNGSTEN},
    {17, IDS_PROPERTYUI_IMAGE_STANDARDA},
    {18, IDS_PROPERTYUI_IMAGE_STANDARDB},
    {19, IDS_PROPERTYUI_IMAGE_STANDARDC},
    {20, IDS_PROPERTYUI_IMAGE_D55},
    {21, IDS_PROPERTYUI_IMAGE_D65},
    {22, IDS_PROPERTYUI_IMAGE_D75},
    { 0, IDS_PROPERTYUI_IMAGE_UNKNOWN}, // Last entry is default
};

static const STRING_MAP g_cExposureProgStrings[] =
{
    {1, IDS_PROPERTYUI_IMAGE_MANUAL},
    {2, IDS_PROPERTYUI_IMAGE_NORMAL},
    {3, IDS_PROPERTYUI_IMAGE_APERTUREPRI},
    {4, IDS_PROPERTYUI_IMAGE_SHUTTERPRI},
    {5, IDS_PROPERTYUI_IMAGE_CREATIVE},
    {6, IDS_PROPERTYUI_IMAGE_ACTION},
    {7, IDS_PROPERTYUI_IMAGE_PORTRAIT},
    {8, IDS_PROPERTYUI_IMAGE_LANDSCAPE},
    {0, IDS_PROPERTYUI_IMAGE_UNKNOWN}, // Last entry is default
};

static const STRING_MAP g_cMeteringModeStrings[] =
{
    {1, IDS_PROPERTYUI_IMAGE_AVERAGE},
    {2, IDS_PROPERTYUI_IMAGE_CWA},
    {3, IDS_PROPERTYUI_IMAGE_SPOT},
    {4, IDS_PROPERTYUI_IMAGE_MULTISPOT},
    {5, IDS_PROPERTYUI_IMAGE_PATTERN},
    {6, IDS_PROPERTYUI_IMAGE_PARTIAL},
    {0, IDS_PROPERTYUI_IMAGE_UNKNOWN}, // Last entry is default
};

static const STRING_MAP g_cFlashStrings[] = 
{
    {0, IDS_PROPERTYUI_IMAGE_NOFLASH},
    {1, IDS_PROPERTYUI_IMAGE_FLASHFIRED},
    {5, IDS_PROPERTYUI_IMAGE_NOSTROBERETURN},
    {7, IDS_PROPERTYUI_IMAGE_STROBERETURN},
    {0, 0},
};

static const STRING_MAP g_cColorStrings[] = 
{
    {1, IDS_PROPERTYUI_IMAGE_SRGB},
    {0xffff, IDS_PROPERTYUI_IMAGE_UNCALIBRATED},
    {0,0},
};

static const STRING_MAP g_cMediaStatus[] =
{
    { PIDMSI_STATUS_NORMAL       , IDS_STATUSVAL_NORMAL     },
    { PIDMSI_STATUS_NEW          , IDS_STATUSVAL_NEW        },
    { PIDMSI_STATUS_PRELIM       , IDS_STATUSVAL_PRELIM     },
    { PIDMSI_STATUS_DRAFT        , IDS_STATUSVAL_DRAFT      },
    { PIDMSI_STATUS_EDIT         , IDS_STATUSVAL_EDIT       },
    { PIDMSI_STATUS_INPROGRESS   , IDS_STATUSVAL_INPROGRESS },
    { PIDMSI_STATUS_REVIEW       , IDS_STATUSVAL_REVIEW     },
    { PIDMSI_STATUS_PROOF        , IDS_STATUSVAL_PROOF      },
    { PIDMSI_STATUS_FINAL        , IDS_STATUSVAL_FINAL      },
    { PIDMSI_STATUS_OTHER        , IDS_STATUSVAL_OTHER      },
    { 0,0 }
};

STDAPI SCIDCannonicalName(SHCOLUMNID *pscid, LPTSTR pszName, int cch)
{
    HRESULT hr = E_FAIL;

    pszName[0] = 0;
    for (int i = 0; i < ARRAYSIZE(c_rgPropUIInfo); i++)
    {
        if (IsEqualSCID(*pscid, *c_rgPropUIInfo[i].pscid))
        {
            SHUnicodeToTChar(c_rgPropUIInfo[i].pwszName, pszName, cch);
            hr = S_OK;
            break;
        }
    }

    return hr;
}

LPCTSTR TrimLeadingWhiteSpaces(LPCTSTR pszString)
{
    LPCTSTR psz = pszString;
    while (psz && ((*psz == TEXT(' ')) || (*psz == TEXT('\n')) || (*psz == TEXT('\t'))))
    {
        psz++;
    }
    return psz;
}

STDAPI_(BOOL) ParseSCIDString(LPCTSTR pszString, SHCOLUMNID *pscid, UINT *pidRes)
{
    BOOL bRet = FALSE;

    if (GUIDFromString(pszString, &pscid->fmtid))
    {
        // GUIDSTR_MAX includes space for the terminating NULL
        LPCTSTR pszPid = &pszString[GUIDSTR_MAX - 1];
        // Skip past any leading white space
        pszPid = TrimLeadingWhiteSpaces(pszPid);
        pscid->pid = StrToInt(pszPid);
        bRet = TRUE;
        if (pidRes)
            *pidRes = 0;
    }
    else
    {
        WCHAR szName[64];
        SHTCharToUnicode(pszString, szName, ARRAYSIZE(szName));

        for (int i = 0; i < ARRAYSIZE(c_rgPropUIInfo); i++)
        {
            if (StrCmpIW(szName, c_rgPropUIInfo[i].pwszName) == 0)
            {
                *pscid = *c_rgPropUIInfo[i].pscid;
                if (pidRes)
                    *pidRes = c_rgPropUIInfo[i].idDisplayName;
                bRet = TRUE;
                break;
            }
        }
    }
    return bRet;
}

//
// Function converts a SCID into a string.
// The string format is "{scid.fmtid} scid.pid" (There is a space in between)
// So for example, SCID_Category will yield the following string - 
// "{d5cdd502-2e9c-101b-9397-08002b2cf9ae} 2"
//
// See ParseSCIDString() above for the the complimentary function.
// Also see CFolderItem::ExtendedProperty() in sdflditm.cpp if you are curious 
// as to where is ParseSCIDString() used and see CtrlFldr.cpp and RegFldr.cpp for
// usage of StringFromSCID().
//
STDAPI_(int) StringFromSCID(const SHCOLUMNID *pscid, LPTSTR psz, UINT cch)
{
    TCHAR ach[GUIDSTR_MAX];
    
    if (0 != SHStringFromGUID(pscid->fmtid, ach, ARRAYSIZE(ach)))
    {
        return wnsprintf(psz, cch, TEXT("%s %d"), ach, pscid->pid);                
    }
    
    *psz = 0;
    return 0;
}

STDAPI MapColumnToSCIDImpl(const COLUMN_INFO* pcol, UINT nCols, UINT iColumn, SHCOLUMNID* pscid)
{
    HRESULT hr;

    if (iColumn < nCols)
    {
        *pscid = *pcol[iColumn].pscid;
        hr = S_OK;
    }
    else
    {
        ZeroMemory(pscid, sizeof(*pscid));
        hr = E_INVALIDARG;
    }
    return hr;
}

STDAPI_(int) FindSCID(const COLUMN_INFO* pcol, UINT nCols, const SHCOLUMNID* pscid)
{
    for (UINT i = 0; i < nCols; i++)
    {
        if (IsEqualSCID(*pscid, *pcol[i].pscid))
            return (int)i;
    }
    return -1;
}

STDAPI GetDetailsOfInfo(const COLUMN_INFO* pcol_data, UINT nCols, UINT iColumn, SHELLDETAILS *pdi)
{
    HRESULT hr;
    if (iColumn < nCols)
    {
        pdi->fmt = pcol_data[iColumn].fmt;
        pdi->cxChar = pcol_data[iColumn].cChars;
        hr = ResToStrRet(pcol_data[iColumn].idTitle, &pdi->str);
    }
    else
    {
        hr = E_NOTIMPL;     // we don't support his column
    }
    return hr;
}

// dead export
STDAPI SHStgOpenStorageW(LPCWSTR pwszPath, DWORD grfMode, DWORD grfAttr, DWORD grfFileAttr, REFIID riid, void **ppv)
{
    *ppv = NULL;
    return E_NOTIMPL;
}

// dead export
STDAPI SHStgOpenStorageA(LPCSTR pwszPath, DWORD grfMode, DWORD grfAttr, DWORD grfFileAttr, REFIID riid, void **ppv)
{
    *ppv = NULL;
    return E_NOTIMPL;
}

const PROPSPEC  codepage_spec = { PRSPEC_PROPID, PID_CODEPAGE } ;

// Retrieves the codepage value from an existing property set storage.

STDAPI SHPropStgReadCP(IPropertyStorage* ppss, UINT* puCodePage)
{
    *puCodePage = 0;    // CP_ACP == 0, assume failure here

    PROPVARIANT varCP;
    if (S_OK == ppss->ReadMultiple(1, &codepage_spec, &varCP))
    {
        if (VT_I2 == varCP.vt)
        {
            *puCodePage = (UINT)MAKELONG(varCP.iVal, 0);
        }
    }
    return (0 == *puCodePage) ? E_FAIL : S_OK;
}

// Modifies the property set codepage on a new property set storage.
// 
// Note: this function will fail if the property set already 
// contains properties.
STDAPI SHPropStgWriteCP(IPropertyStorage* ppss, IN UINT uCodePage)
{
    PROPVARIANT varCP;
    varCP.iVal = (SHORT)uCodePage;
    varCP.vt   = VT_I2;

    return ppss->WriteMultiple(1, &codepage_spec, &varCP, PID_CODEPAGE);
}

// IPropertySetStorage::Open/Create wrapper.
// The wrap properly retrieves/assigns the set's codepage value.

STDAPI SHPropStgCreate(
    IPropertySetStorage* psstg, // Address of IPropertySetStorage vtable
    REFFMTID    fmtid,          // property set ID
    CLSID*      pclsid,         // class ID associated with the set. This can be NULL
    DWORD       grfFlags,       // PROPSETFLAG_xxx.  All sets containing ansi bytes should be created with
                                // PROPSETFLAG_ANSI, otherwise PROPSETFLAG_DEFAULT
    DWORD       grfMode,        // STGM_ flags.  Must contain STGM_DIRECT|STGM_EXCLUSIVE.
    DWORD       dwDisposition,  // OPEN_EXISTING. OPEN_ALWAYS, CREATE_NEW, CREATE_ALWAYS
    OUT         IPropertyStorage** ppstg,  // Address to receive requested vtable
    OUT UINT*   puCodePage)    // Optional address to receive the code page ID for the set.
{
    ASSERT(psstg);
    ASSERT(ppstg);

    if (puCodePage)
        *puCodePage = 0;

    *ppstg = NULL;
    
    // Check legacy sets.  These MUST be flagged ANSI
    if (IsEqualGUID(fmtid, FMTID_SummaryInformation) || 
        IsEqualGUID(fmtid, FMTID_DocSummaryInformation) ||
        IsEqualGUID(fmtid, FMTID_UserDefinedProperties))
    {
        grfFlags |= PROPSETFLAG_ANSI;     // these legacy sets MUST be ansi.
    }

    // Attempt opening the set
    HRESULT hr = psstg->Open(fmtid, grfMode, ppstg);
    if (SUCCEEDED(hr))  // opened the set
    {
        // If a new set was requested, fail.
        if (CREATE_NEW == dwDisposition)
        {
            (*ppstg)->Release();
            *ppstg = NULL;
            return STG_E_FILEALREADYEXISTS;
        }

        // If the request was to overwrite any existing set, delete the current one.
        if (CREATE_ALWAYS == dwDisposition)
        {
            (*ppstg)->Release();
            *ppstg = NULL;
            
            if (FAILED((hr = psstg->Delete(fmtid))))
                return hr;

            hr = STG_E_FILENOTFOUND; // falls through to create
        }
    }
    else  // failed to open the set
    {   
        // if an existing set is requested, fail
        if (OPEN_EXISTING == dwDisposition)
            return hr;
    }
    
    if (STG_E_FILENOTFOUND == hr) // set doesn't exist, so create it.
    {
        hr = psstg->Create(fmtid, pclsid, grfFlags, grfMode, ppstg);
    }

    // If we haven't assigned a codepage, then read it from PID_CODEPAGE.
    if (SUCCEEDED(hr) && puCodePage)
    {
        ASSERT(*ppstg);
        SHPropStgReadCP(*ppstg, puCodePage);
    }

    return hr;
}

STDAPI_(BOOL) _IsAnsiPropertySet(REFFMTID fmtid);
STDAPI_(BOOL) _DoesStringRoundTripCPW(UINT uCodePage, LPCWSTR pwszIn, LPSTR pszOut, UINT cchOut);
STDAPI        _DoLegacyPropertiesRoundTrip(REFFMTID fmtid, UINT uCodePage, ULONG cvar, PROPVARIANT rgvar[]);
STDAPI        _UniversalizeSet(IPropertyStorage* pstg, IN OUT UINT* puCodePage, PROPID propidNameFirst);

STDAPI _LegacyPropertiesToUnicode(REFFMTID fmtid, UINT uCodePage, ULONG cpspec, PROPSPEC const rgpspec[], PROPVARIANT rgvar[]);
STDAPI _LegacyPropertiesToAnsi(REFFMTID fmtid, UINT uCodePage, ULONG cpspec, PROPSPEC const rgpspec[], PROPVARIANT rgvar[]);
    
// IPropertyStorage::ReadMultiple wrap
//
// The wrap ensures ANSI/UNICODE translations are handled properly for
// legacy property sets.
STDAPI SHPropStgReadMultiple(
    IPropertyStorage* pps,        // address of IPropertyStorage vtable.
    UINT              uCodePage,  // Code page value retrieved from SHCreatePropertySet
    ULONG             cpspec,     // Count of properties being read
    PROPSPEC const    rgpspec[],  // Array of the properties to be read
    PROPVARIANT       rgvar[])    // Array of PROPVARIANTs containing the 
                                  // property values on return
{
    // read the requested properties
    HRESULT hr = pps->ReadMultiple(cpspec, rgpspec, rgvar);
    if (S_OK == hr)
    {
        HRESULT hrTmp = S_OK;
        
        // grab the set's ANSI codepage if not provided.
        if (0 == uCodePage)
        {
            hrTmp = SHPropStgReadCP(pps, &uCodePage);
        }
        
        if (SUCCEEDED(hrTmp))
        {
            STATPROPSETSTG stat;
            if (SUCCEEDED(pps->Stat(&stat)))
            {
                hr = _LegacyPropertiesToUnicode(stat.fmtid, uCodePage, cpspec, rgpspec, rgvar);
            }
        }
    }
    return hr;
}

// IPropertyStorage::WriteMultiple wrap
//
// The wrap ensures ANSI/UNICODE translations are handled properly for
// legacy property sets.

STDAPI SHPropStgWriteMultiple(
    IPropertyStorage* pps,             // address of IPropertyStorage vtable.
    UINT*             puCodePage,      // code page retrieved from SHCreatePropertySet.
    ULONG             cpspec,          // The number of properties being set
    PROPSPEC const    rgpspec[],       // Property specifiers
    PROPVARIANT       rgvar[],         // Array of PROPVARIANT values
    PROPID            propidNameFirst) // Minimum value for property identifiers 
                                       // when they must be allocated
{ 
    UINT uCodePage = 0;
    if (!puCodePage)
        puCodePage = &uCodePage;

    ASSERT(propidNameFirst >= PID_FIRST_USABLE); // you're walking on OLE PIDs.

    STATPROPSETSTG stat;
    HRESULT hr = pps->Stat(&stat); // need the FMTID
    if (SUCCEEDED(hr))
    {
        // read in the codepage if it isn't provided.
        if (0 == *puCodePage)
        {
            hr = SHPropStgReadCP(pps, puCodePage);
        }

        if (SUCCEEDED(hr) )
        {
            // test for round-trippability
            hr = _DoLegacyPropertiesRoundTrip(stat.fmtid, *puCodePage, cpspec, rgvar);
            if (SUCCEEDED(hr))
            {
                if (S_FALSE == hr)
                {
                    hr = _UniversalizeSet(pps, puCodePage, propidNameFirst);
                }

                if (SUCCEEDED(hr))
                {
                    // convert legacy properties back to ansi
                    hr = _LegacyPropertiesToAnsi(stat.fmtid, *puCodePage, cpspec, rgpspec, rgvar);
                    if (SUCCEEDED(hr))
                    {
                        // write em.
                        hr = pps->WriteMultiple(cpspec, rgpspec, rgvar, propidNameFirst);

                        if (FAILED(hr))
                            _LegacyPropertiesToUnicode(stat.fmtid, *puCodePage, cpspec, rgpspec, rgvar);
                    }
                }
            }
        }
    }
    return hr;
}

// Helper: converts LPWSTR to LPSTR using the indicated codepage and returns 
// TRUE if the LPSTR can be converted back to LPWSTR without unacceptible data loss
STDAPI_(BOOL) _DoesStringRoundTripCPW(UINT uCodePage, LPCWSTR pwszIn, LPSTR pszOut, UINT cchOut)
{
    BOOL fRet = FALSE;

    // if we're being asked to roundtrip UTF8, don't bother test, it'll work.
    if (CP_UTF8 == uCodePage)
    {
        SHUnicodeToAnsiCP(uCodePage, pwszIn, pszOut, cchOut);
        fRet = TRUE;
    }
    else
    {
        WCHAR   wszTemp[MAX_PATH];
        LPWSTR  pwszTemp = wszTemp;
        UINT    cchTemp = ARRAYSIZE(wszTemp);

        // We better have enough room for the buffer.
        if (ARRAYSIZE(wszTemp) < cchOut)
        {
            pwszTemp = (LPWSTR)LocalAlloc(LPTR, cchOut*sizeof(WCHAR));
            cchTemp = cchOut;
        }
        if (pwszTemp)
        {
            SHUnicodeToAnsiCP(uCodePage, pwszIn, pszOut, cchOut);
            SHAnsiToUnicodeCP(uCodePage, pszOut, pwszTemp, cchTemp);
            fRet = StrCmpW(pwszIn, pwszTemp) == 0;     // are they the same?

            if (pwszTemp != wszTemp)
            {
                LocalFree(pwszTemp);
            }
        }
    }
    return fRet;
}

// Helper: determines whether the specified string properties of the indicate property set
// can round-trip to ansi and back.  
// Returns S_OK if all strings can round-trip, S_FALSE if not all strings can round trip,
// or an error code.
STDAPI _DoLegacyPropertiesRoundTrip(
    REFFMTID       fmtid, 
    UINT           uCodePage, 
    ULONG          cvar, 
    PROPVARIANT    rgvar[])
{
    ASSERT(uCodePage);

    HRESULT hr = S_OK; // assume all strings round-trip.

    if (uCodePage != CP_UTF8 && uCodePage != CP_WINUNICODE && _IsAnsiPropertySet(fmtid))
    {
        ASSERT (uCodePage != CP_WINUNICODE); 
            // either the set's creator is whacked, or this is simply an invalid arg.

        for (ULONG i = 0; i < cvar && S_OK == hr ; i++)
        {
            if (rgvar[i].vt == VT_LPWSTR && rgvar[i].pwszVal && *rgvar[i].pwszVal)
            {
                LPSTR pszVal;
                // make plenty of room for UTF-8 conversions.  each WCHAR
                // can turn into as many as three ANSI chars
                int   cb = MAX_UTF8_CHAR_SIZE * (lstrlenW(rgvar[i].pwszVal) + 1);
                if ((pszVal = new CHAR[cb]) != NULL)
                {
                    // Test round-trip to ANSI and back.
                    if (!_DoesStringRoundTripCPW(uCodePage, rgvar[i].pwszVal, pszVal, cb))
                    {
                        hr = S_FALSE;
                    }
                    delete pszVal;
                }
                else
                    hr = E_OUTOFMEMORY;
            }
        }
    }
    return hr;
}

// Helper: Reports whether the specified FMTID is a legacy ANSI property set.

STDAPI_(BOOL) _IsAnsiPropertySet(REFFMTID fmtid)
{
    const FMTID* _ansi_propertysets[] = 
    {
        &FMTID_SummaryInformation,
        &FMTID_DocSummaryInformation,
        &FMTID_UserDefinedProperties,
    };

    for (int i = 0; i < ARRAYSIZE(_ansi_propertysets); i++)
    {
        if (IsEqualGUID(fmtid, *_ansi_propertysets[i]))
            return TRUE;
    }
    return FALSE;
}

// Determine whether the property is a legacy ANSI property, and if so,
// compute a conversion type for the property.

typedef struct {
    PROPID      propid;
    VARTYPE     vt;
    VARTYPE     vtConvert;
} ANSIPROPDEF;

// (public) ansi SummaryInformation properties
const ANSIPROPDEF si_lpstr_pids[] =
{ 
    { PIDSI_TITLE,      VT_LPSTR,   VT_LPWSTR },
    { PIDSI_SUBJECT,    VT_LPSTR,   VT_LPWSTR },
    { PIDSI_AUTHOR,     VT_LPSTR,   VT_LPWSTR },
    { PIDSI_KEYWORDS,   VT_LPSTR,   VT_LPWSTR },
    { PIDSI_COMMENTS,   VT_LPSTR,   VT_LPWSTR },
    { PIDSI_TEMPLATE,   VT_LPSTR,   VT_LPWSTR },
    { PIDSI_LASTAUTHOR, VT_LPSTR,   VT_LPWSTR },
    { PIDSI_REVNUMBER,  VT_LPSTR,   VT_LPWSTR },
    { PIDSI_APPNAME,    VT_LPSTR,   VT_LPWSTR },
};

// (public) ansi DocSummaryInformation properties
const ANSIPROPDEF dsi_lpstr_pids[] =
{ 
    { PIDDSI_CATEGORY,  VT_LPSTR,           VT_LPWSTR },
    { PIDDSI_PRESFORMAT,VT_LPSTR,           VT_LPWSTR },
    { PIDDSI_DOCPARTS,  VT_LPSTR|VT_VECTOR, VT_LPWSTR|VT_VECTOR },
    { PIDDSI_MANAGER,   VT_LPSTR,           VT_LPWSTR },
    { PIDDSI_COMPANY,   VT_LPSTR,           VT_LPWSTR },
};

STDAPI_(BOOL) SHIsLegacyAnsiProperty(REFFMTID fmtid, PROPID propid, IN OUT OPTIONAL VARTYPE* pvt)
{
    const ANSIPROPDEF* rgapd = NULL;
    UINT capd  = 0;

    if (IsEqualGUID(fmtid, FMTID_SummaryInformation))
    {
        rgapd = si_lpstr_pids;
        capd  = ARRAYSIZE(si_lpstr_pids);
    }
    else if (IsEqualGUID(fmtid, FMTID_DocSummaryInformation))
    {
        rgapd = dsi_lpstr_pids;
        capd  = ARRAYSIZE(dsi_lpstr_pids);
    }
    else if (IsEqualGUID(fmtid, FMTID_UserDefinedProperties))
    {
        // Note: User defined properties are, by defintion, not defined
        // by the system.  We simply will convert any VT_LPSTR values to VT_LPWSTR.
        if (pvt)
        {
            if ((*pvt) & VT_LPSTR) // forward conversion?
            {
                (*pvt) &= ~VT_LPSTR;
                (*pvt) |= VT_LPWSTR;
                return TRUE;
            }
            else if ((*pvt) & VT_LPWSTR) // reverse conversion?
            {
                (*pvt) &= ~VT_LPWSTR;
                (*pvt) |= VT_LPSTR;
                return TRUE;
            }
        }
    }

    if (rgapd) // search among pre-defined property ids:
    {
        for (UINT i = 0; i < capd; i++)
        {
            if (propid == rgapd[i].propid)
            {
                if (pvt)
                {
                    if (*pvt == rgapd[i].vtConvert) // reverse conversion?
                        *pvt = rgapd[i].vt;
                    else // forward conversion?
                        *pvt = rgapd[i].vtConvert; 
                }
                return TRUE;
            }
        }
    }

    return FALSE;
}

// Helper: Properly converts a block of legacy ansi properties read from a 
// prop storage to unicode 

STDAPI _LegacyPropertiesToUnicode(
    REFFMTID       fmtid, 
    UINT           uCodePage, 
    ULONG          cpspec, 
    PROPSPEC const rgpspec[],
    PROPVARIANT    rgvar[])
{
    ASSERT(uCodePage);
    
    HRESULT hr = S_OK;
    if (_IsAnsiPropertySet(fmtid) && (uCodePage != CP_WINUNICODE))
    {
        for (ULONG i = 0; i < cpspec; i++)
        {
            if (VT_LPSTR == rgvar[i].vt)
            {
                // convert in-place to VT_LPWSTR.
                if (rgvar[i].pszVal)
                {
                    LPWSTR  pwszVal;
                    int     cch  = lstrlenA(rgvar[i].pszVal) + 1;
                    
                    if (NULL == (pwszVal = (LPWSTR)CoTaskMemAlloc(CbFromCchW(cch))))
                    {
                        hr = E_OUTOFMEMORY;
                        // reverse what we've already done
                        if (i > 0)
                            _LegacyPropertiesToAnsi(fmtid, uCodePage, i, rgpspec, rgvar);
                        break ;
                    }
                    
                    if (*rgvar[i].pszVal) // non-empty
                    {
                        // if we can't convert using the set's codepage, fall back on CP_UTF8
                        if (!MultiByteToWideChar(uCodePage, 0, rgvar[i].pszVal, -1, pwszVal, cch))
                            SHAnsiToUnicodeCP(CP_UTF8, rgvar[i].pszVal, pwszVal, cch);
                    }
                    else // empty string; why bother converting?
                        *pwszVal = 0;

                    CoTaskMemFree(rgvar[i].pszVal);

                    // assign propvalue.
                    rgvar[i].pwszVal = pwszVal;
                }
                rgvar[i].vt = VT_LPWSTR;
            }
        }
    }
    return hr;
}

// Helper: Properly converts a block of legacy ansi properties from unicode to 
// ansi in preparation for writing back to the storage stream.

STDAPI _LegacyPropertiesToAnsi(
    REFFMTID       fmtid, 
    UINT           uCodePage, 
    ULONG          cpspec, 
    PROPSPEC const rgpspec[],
    PROPVARIANT    rgvar[])
{
    ASSERT(uCodePage);
    
    HRESULT hr = S_OK;
    if (_IsAnsiPropertySet(fmtid) && (uCodePage != CP_WINUNICODE))
    {
        for (ULONG i = 0; i < cpspec; i++)
        {
            if (rgvar[i].vt == VT_LPWSTR)
            {
                // Revert back to ANSI in place
                if (rgvar[i].pwszVal)
                {
                    LPSTR pszVal;
                    // make plenty of room for UTF-8 conversions.  each WCHAR
                    // can turn into as many as three ANSI chars
                    int   cb = MAX_UTF8_CHAR_SIZE * (lstrlenW(rgvar[i].pwszVal) + 1);
                    if (NULL == (pszVal = (LPSTR)CoTaskMemAlloc(cb)))
                    {
                        hr = E_OUTOFMEMORY;
                        if (i > 0) // try to reverse what we've done.
                            _LegacyPropertiesToUnicode(fmtid, uCodePage, i, rgpspec, rgvar);
                        break;
                    }

                    if (*rgvar[i].pwszVal)
                    {
                        // Test round-trip to ANSI and back.  If fails, fall back on CP_UTF8.
                        if (!_DoesStringRoundTripCPW(uCodePage, rgvar[i].pwszVal, pszVal, cb))
                            SHUnicodeToAnsiCP(CP_UTF8, rgvar[i].pwszVal, pszVal, cb);
                    }
                    else
                        *pszVal = 0;

                    CoTaskMemFree(rgvar[i].pwszVal);
                    rgvar[i].pszVal = pszVal;
                }
                rgvar[i].vt = VT_LPSTR;
            }
        }
    }
    return hr;
}

// Helper: Converts the specified ansi string to a universal code page.

STDAPI _UniversalizeAnsiString(IN OUT LPSTR* ppszSrc, IN UINT uCodePage)
{
    ASSERT(ppszSrc);
    ASSERT(uCodePage != CP_UTF8);

    if (!(*ppszSrc))    // NULL string
        return S_FALSE;

    if (!(*ppszSrc)[0]) // empty string; nothing to do.
        return S_OK;
    
    HRESULT hr = E_FAIL;
    LPSTR   pszDest = NULL;
    WCHAR   wszVal[MAX_PATH];
    LPWSTR  pwszVal = wszVal;
    *wszVal = 0;
    
    UINT cch = lstrlenA(*ppszSrc) + 1;
    if (cch > ARRAYSIZE(wszVal))
        pwszVal = new WCHAR[cch];

    if (pwszVal != NULL)
    {
        // convert to Unicode using original codepage
        if (SHAnsiToUnicodeCP(uCodePage, *ppszSrc, pwszVal, cch))
        {
            int cb = MAX_UTF8_CHAR_SIZE * cch;
            if ((pszDest = (LPSTR)CoTaskMemAlloc(cb)) != NULL)
            {
                // convert to ANSI using UTF_8
                if (SHUnicodeToAnsiCP(CP_UTF8, pwszVal, pszDest, cb))
                {
                    CoTaskMemFree(*ppszSrc);
                    *ppszSrc = pszDest;
                    hr = S_OK;
                }
                else
                {
                    CoTaskMemFree(pszDest);
                    hr = E_FAIL;
                }
            }
            else
                hr = E_OUTOFMEMORY;
        }
        
        if (pwszVal != wszVal)
            delete [] pwszVal;
    }
    else
        hr = E_OUTOFMEMORY;

    return hr;
}

// Helper: Ensures that any ansi strings in the specified property
// are converted to a universal code page.

STDAPI _UniversalizeProperty(IN OUT PROPVARIANT* pvar, UINT uCodePage)
{
    ASSERT(uCodePage != CP_UTF8);

    HRESULT hr = S_OK;

    if (VT_LPSTR == pvar->vt)
    {
        hr = _UniversalizeAnsiString(&pvar->pszVal, uCodePage);
    }
    else if ((VT_LPSTR | VT_VECTOR) == pvar->vt)
    {
        for (ULONG i = 0; i < pvar->calpstr.cElems; i++)
        {
            HRESULT hrElem = _UniversalizeAnsiString(&pvar->calpstr.pElems[i], uCodePage);
            if (FAILED(hrElem))
                hr = hrElem;
        }
    }
    return hr;
}

// Helper: counts properties in the indicated property set.
ULONG _CountProperties(IEnumSTATPROPSTG* pEnum)
{
    ULONG cRet = 0;

    pEnum->Reset();

    STATPROPSTG stat[20] = {0};
    HRESULT hr;
    do
    {
        ULONG cFetched;
        hr = pEnum->Next(ARRAYSIZE(stat), stat, &cFetched);
        if (SUCCEEDED(hr))
            cRet += cFetched;
    
    }  while (S_OK == hr);

    pEnum->Reset();
    return cRet;
}

// Helper: Ensures that all ansi properties in the indicate set are converted to a 
// universal code page.

STDAPI _UniversalizeSet(IPropertyStorage* pstg, IN OUT UINT* puCodePage, PROPID propidNameFirst)
{
    UINT uCP = *puCodePage;

    if (CP_UTF8 == uCP)
        return S_OK;

    // Enumerate property values
    IEnumSTATPROPSTG* pEnum;
    HRESULT hr = pstg->Enum(&pEnum);
    if (SUCCEEDED(hr))
    {
        ULONG cProps = _CountProperties(pEnum);
        if (cProps > 0)
        {
            STATPROPSTG* rgstat = NULL;
            PROPSPEC*    rgpspec = NULL;
            PROPVARIANT* rgvar  = NULL;

            if ((rgstat  = new STATPROPSTG[cProps]) != NULL &&
                (rgpspec = new PROPSPEC[cProps]) != NULL &&
                (rgvar   = new PROPVARIANT[cProps]) != NULL)
            {
                ULONG        cFetched = 0;
                ZeroMemory(rgstat, cProps * sizeof(*rgstat));

                hr = pEnum->Next(cProps, rgstat, &cFetched);
                
                if (SUCCEEDED(hr) && cFetched > 0)
                {
                    for (ULONG i = 0; i < cFetched; i++)
                    {
                        rgpspec[i].ulKind = PRSPEC_PROPID;
                        rgpspec[i].propid = rgstat[i].propid;
                    }
                    ZeroMemory(rgvar, sizeof(rgvar));

                    // Read properties
                    hr = pstg->ReadMultiple(cFetched, rgpspec, rgvar);
                    if (S_OK == hr)
                    {
                        BOOL bConversionError = FALSE;

                        // Convert properties
                        for (i = 0; i < cFetched; i++)
                        {
                            hr = _UniversalizeProperty(rgvar + i, uCP);
                            if (FAILED(hr))
                            {
                                bConversionError = TRUE;
                                break;
                            }
                        }

                        // Delete set, write out converted values and update PID_CODEPAGE
                        if (!bConversionError)
                        {
                            hr = pstg->DeleteMultiple(cFetched, rgpspec);
                            if (SUCCEEDED(hr))
                            {
                                hr = SHPropStgWriteCP(pstg, CP_UTF8);
                                if (SUCCEEDED(hr))
                                {
                                    *puCodePage = CP_UTF8;     
                                    hr = pstg->WriteMultiple(cFetched, rgpspec, rgvar, propidNameFirst);
                                }
                            }
                        }

                        for (i = 0; i < cFetched; i++)
                            PropVariantClear(rgvar + i);
                    }
                }
            }

            if (rgstat)  delete [] rgstat;
            if (rgpspec) delete [] rgpspec;
            if (rgvar)   delete [] rgvar;
        }
        else if (0 == cProps) // no properties: brand-new, empty set.
        {
            hr = SHPropStgWriteCP(pstg, CP_UTF8);
            if (SUCCEEDED(hr))
            {
                *puCodePage = CP_UTF8;     
            }
        }

        pEnum->Release();
    }

    return hr;
}

// A PROPVARIANT can hold a few more types than a VARIANT can.  We convert the types that are
// only supported by a PROPVARIANT into equivalent VARIANT types.
HRESULT PropVariantToVariant(const PROPVARIANT *pPropVar, VARIANT *pVar)
{
    HRESULT hr = E_OUTOFMEMORY;

    ASSERT(pPropVar && pVar);

    // if pVar isn't empty, this will properly free before overwriting it
    VariantClear(pVar);

    switch (pPropVar->vt)
    {
    case VT_LPSTR: 
        pVar->bstrVal = SysAllocStringA(pPropVar->pszVal);
        if (pVar->bstrVal)
        {
            pVar->vt = VT_BSTR;
            hr = S_OK;
        }
        break;

    case VT_LPWSTR:
        pVar->bstrVal = SysAllocString(pPropVar->pwszVal);
        if (pVar->bstrVal)
        {
            pVar->vt = VT_BSTR;
            hr = S_OK;
        }
        break;

    case VT_FILETIME:
    {
        SYSTEMTIME st;
        if (FileTimeToSystemTime(&pPropVar->filetime, &st) &&
            SystemTimeToVariantTime(&st, &pVar->date)) // delay load...
        {
            pVar->vt = VT_DATE;
            hr = S_OK;
        }
        break;
    }

    case VT_CLSID:
        if (pVar->bstrVal = SysAllocStringLen(NULL, GUIDSTR_MAX))
        {
            if (SUCCEEDED(SHStringFromGUIDW(*pPropVar->puuid, pVar->bstrVal, GUIDSTR_MAX)))
            {
                pVar->vt = VT_BSTR;
                hr = S_OK;
            }
            else
            {
                SysFreeString(pVar->bstrVal);
                pVar->bstrVal = NULL;
            }
        }
        break;

    case VT_BLOB:
    case VT_STREAM:
    case VT_STORAGE:
    case VT_BLOB_OBJECT:
    case VT_STREAMED_OBJECT:
    case VT_STORED_OBJECT:
    case VT_CF:
        ASSERT(0); // leave the output cleared
        break;

    case VT_UI4:
        pVar->vt = VT_I4;
        pVar->lVal = (INT)pPropVar->ulVal;
        hr = S_OK;
        break;

    default:
        hr = VariantCopy(pVar, (VARIANT *)pPropVar);
        break;
    }

    return hr;
}


class CPropertyUI : public IPropertyUI
{
public:
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // IPropertyUI
    STDMETHODIMP ParsePropertyName(LPCWSTR pwszProperties, FMTID *pfmtid, PROPID *ppid, ULONG *pchEaten);
    STDMETHODIMP GetCannonicalName(REFFMTID fmtid, PROPID pid, LPWSTR pwszText, DWORD cchText);
    STDMETHODIMP GetDisplayName(REFFMTID fmtid, PROPID pid, PROPERTYUI_NAME_FLAGS flags, LPWSTR pwszText, DWORD cchText);
    STDMETHODIMP GetPropertyDescription(REFFMTID fmtid, PROPID pid, LPWSTR pwszText, DWORD cchText);
    STDMETHODIMP GetDefaultWidth(REFFMTID fmtid, PROPID pid, ULONG *pcxChars);
    STDMETHODIMP GetFlags(REFFMTID fmtid, PROPID pid, PROPERTYUI_FLAGS *pdwFlags);
    STDMETHODIMP FormatForDisplay(REFFMTID fmtid, PROPID pid, const PROPVARIANT *pvar, 
                                  PROPERTYUI_FORMAT_FLAGS flags, LPWSTR pwszText, DWORD cchText);
    STDMETHODIMP GetHelpInfo(REFFMTID fmtid, PROPID pid, LPWSTR pwszHelpFile, DWORD cch, UINT *puHelpID);

    CPropertyUI();

private:
    ~CPropertyUI();
    const PROPUI_INFO *_FindInfoByName(LPCWSTR pszName);

    long _cRef;
};

const PROPUI_INFO *_FindInfoByFMTIDPID(REFFMTID fmtid, PROPID pid);

CPropertyUI::CPropertyUI() : _cRef(1)
{
    DllAddRef();
}

CPropertyUI::~CPropertyUI()
{
    DllRelease();
}

HRESULT CPropertyUI::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENT(CPropertyUI, IPropertyUI),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

ULONG CPropertyUI::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CPropertyUI::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}

const PROPUI_INFO *CPropertyUI::_FindInfoByName(LPCWSTR pszName)
{
    const PROPUI_INFO *pinfo = NULL;
    for (int i = 0; i < ARRAYSIZE(c_rgPropUIInfo); i++)
    {
        if (StrCmpIW(pszName, c_rgPropUIInfo[i].pwszName) == 0)
        {
            pinfo = &c_rgPropUIInfo[i];
            break;
        }
    }
    return pinfo;
}

const PROPUI_INFO *_FindInfoByFMTIDPID(REFFMTID fmtid, PROPID pid)
{
    const PROPUI_INFO *pinfo = NULL;
    for (int i = 0; i < ARRAYSIZE(c_rgPropUIInfo); i++)
    {
        if ((pid == c_rgPropUIInfo[i].pscid->pid) && 
            (fmtid == c_rgPropUIInfo[i].pscid->fmtid))
        {
            pinfo = &c_rgPropUIInfo[i];
            break;
        }
    }
    return pinfo;
}

HRESULT _NextProp(LPCWSTR pwszProperties, ULONG *pchEaten, LPWSTR pwszProp, UINT cchProp)
{
    HRESULT hr = E_FAIL;
    ULONG ulStrLen = lstrlenW(pwszProperties);

    *pwszProp = L'\0';
    if (*pchEaten < ulStrLen)
    {
        LPCWSTR pwszStart = pwszProperties + (*pchEaten);
        LPCWSTR pwszSemi = StrChrW(pwszStart, L';');
        if (pwszSemi)
        {
            // make sure its well formed (no dbl slashes)
            if (pwszSemi > pwszStart)
            {
                // Make sure we don't overrun the prop buffer size
                ULONG ulPropLen = (ULONG)(pwszSemi - pwszStart) + 1; // includes L'\0'
                if (ulPropLen > cchProp)
                {
                    ulPropLen = cchProp;
                }
                
                StrCpyNW(pwszProp, pwszStart, ulPropLen);
                // Make sure that there is another segment to return
                if (!*(pwszSemi + 1))
                {
                    pwszSemi = NULL;
                }
                hr = S_OK;
            }
            else
            {
                pwszSemi = NULL;
                hr = E_INVALIDARG;    // bad input
            }
        }
        else
        {
            // No semi-colon; so copy till the end
            StrCpyNW(pwszProp, pwszStart, cchProp);
            hr = S_OK;       
        }

        // Set *pchEaten
        if (pwszSemi)
        {
            *pchEaten = (int)(pwszSemi - pwszProperties) + 1; // Skip ;
        }
        else
        {
            *pchEaten = ulStrLen;
        }
    }
    else
    {
        hr = S_FALSE;     // done with loop
    }
    return hr;
}

#define PROP_PREFIX         TEXT("prop:")
#define PROP_PREFIX_LEN     (ARRAYSIZE(PROP_PREFIX) - 1)

// [in/out] *pchEaten   used to sequence through the property names

STDMETHODIMP CPropertyUI::ParsePropertyName(LPCWSTR pwszProperties, FMTID *pfmtid, PROPID *ppid, ULONG *pchEaten)
{
    // Nobody should call us without a reason
    ASSERT(pfmtid && ppid);
    
    HRESULT hr = E_FAIL;
    WCHAR wszProp[MAX_PATH];
    SHCOLUMNID scid;

    // If pwszProperties starts with prop:, skip it
    if ((*pchEaten == 0)
            && (StrCmpNIW(pwszProperties, PROP_PREFIX, PROP_PREFIX_LEN) == 0))
    {
        *pchEaten += PROP_PREFIX_LEN;
    }
    
    if ((_NextProp(pwszProperties, pchEaten, wszProp, ARRAYSIZE(wszProp)) == S_OK)
            && ParseSCIDString(wszProp, &scid, NULL))
    {
        *pfmtid = scid.fmtid;
        *ppid = scid.pid;
        hr = S_OK;
    }
    return hr;
}

STDMETHODIMP CPropertyUI::GetCannonicalName(REFFMTID fmtid, PROPID pid, LPWSTR pwszText, DWORD cchText)
{
    HRESULT hr = E_FAIL;
    *pwszText = NULL;

    const PROPUI_INFO *pinfo = _FindInfoByFMTIDPID(fmtid, pid);
    if (pinfo)
    {
        hr = S_OK;
        StrCpyNW(pwszText, pinfo->pwszName, cchText);
    }
    else if (SHStringFromGUIDW(fmtid, pwszText, cchText))
    {
        WCHAR wszPid[20];   // Pid's can't be longer than 20 chars
        wnsprintfW(wszPid, ARRAYSIZE(wszPid), L"%lu", pid);
        StrCatBuffW(pwszText, wszPid, cchText);
        hr = S_OK;
    }
    return hr;
}

STDMETHODIMP CPropertyUI::GetDisplayName(REFFMTID fmtid, PROPID pid, PROPERTYUI_NAME_FLAGS flags, LPWSTR pwszText, DWORD cchText)
{
    HRESULT hr = E_FAIL;
    *pwszText = NULL;

    const PROPUI_INFO *pinfo = _FindInfoByFMTIDPID(fmtid, pid);
    if (pinfo)
    {
        UINT uID;

        if (flags & PUIFNF_MNEMONIC)
        {
            // Name with mnemonic requested.
            if (pinfo->idMnemonicName)
            {
                // Name with mnemonic defined for scid.
                uID = pinfo->idMnemonicName;
                hr = S_OK;
            }
            else
            {
                // Name with mnemonic NOT defined for scid -- use name without mnemonic as fallback.
                uID = pinfo->idDisplayName;
                hr = S_FALSE;
            }
        }
        else
        {
            // Name without mnemonic requested.
            uID = pinfo->idDisplayName;
            hr = S_OK;
        }

        LoadStringW(HINST_THISDLL, uID, pwszText, cchText);
    }
    return hr;
}

STDMETHODIMP CPropertyUI::GetPropertyDescription(REFFMTID fmtid, PROPID pid, LPWSTR pwszText, DWORD cchText)
{
    HRESULT hr = E_FAIL;
    *pwszText = NULL;

    const PROPUI_INFO *pinfo = _FindInfoByFMTIDPID(fmtid, pid);
    if (pinfo)
    {
        *pwszText = 0;
        // LoadStringW(HINST_THISDLL, pinfo->idPropertyDescription, pwszText, cchText);
        hr = S_OK;
    }
    return hr;
}

STDMETHODIMP CPropertyUI::GetDefaultWidth(REFFMTID fmtid, PROPID pid, ULONG *pcxChars)
{
    HRESULT hr = E_FAIL;
    *pcxChars = 0;

    const PROPUI_INFO *pinfo = _FindInfoByFMTIDPID(fmtid, pid);
    if (pinfo)
    {
        *pcxChars = 20;     // pinfo->nWidth;
        hr = S_OK;
    }
    return hr;
}

STDMETHODIMP CPropertyUI::GetFlags(REFFMTID fmtid, PROPID pid, PROPERTYUI_FLAGS *pdwFlags)
{
    HRESULT hr = E_FAIL;
    *pdwFlags = PUIF_DEFAULT;

    const PROPUI_INFO *pinfo = _FindInfoByFMTIDPID(fmtid, pid);
    if (pinfo)
    {
        *pdwFlags = PUIF_DEFAULT; // pinfo->dwFlags;
        hr = S_OK;
    }
    return hr;
}

HRESULT _LookupStringFromLong(const STRING_MAP *pMap, ULONG ulVal, LPWSTR pszText, DWORD cchText)
{
    HRESULT hr = E_FAIL;
    while (pMap->idStr && pMap->uVal != ulVal)
    {
        pMap++;
    }
    if (pMap->idStr)
    {
        LoadString(HINST_THISDLL, pMap->idStr, pszText, cchText);
        hr = S_OK;
    }
    return hr;
}

// expose this method as an API as this is very commonly needed

STDAPI SHFormatForDisplay(REFFMTID fmtid, PROPID pid, const PROPVARIANT *pPropVar, 
                          PROPERTYUI_FORMAT_FLAGS flags, LPWSTR pwszText, DWORD cchText)
{
    HRESULT hr = S_OK;
    *pwszText = 0;

    TCHAR szBuffer[MAX_PATH];

    // Property-specific:
    if (CompareSCIDFMTIDPID(fmtid, pid, SCID_SIZE) ||
        CompareSCIDFMTIDPID(fmtid, pid, SCID_CAPACITY) ||
        CompareSCIDFMTIDPID(fmtid, pid, SCID_FREESPACE))
    {
        ASSERT(pPropVar->vt == VT_UI8);
        StrFormatByteSizeW(pPropVar->uhVal.QuadPart, pwszText, cchText);
    }
    else if (CompareSCIDFMTIDPID(fmtid, pid, SCID_AUDIO_Duration))
    {
        if (pPropVar->vt == VT_EMPTY)
        {
            StrCpyN(pwszText, L"", cchText);
        }
        else
        {
            ASSERT(pPropVar->vt == VT_UI8);
            FILETIME ft = {pPropVar->uhVal.LowPart, pPropVar->uhVal.HighPart};
            SYSTEMTIME st;
            FileTimeToSystemTime(&ft, &st);

            GetTimeFormat(LOCALE_USER_DEFAULT, TIME_FORCE24HOURFORMAT | TIME_NOTIMEMARKER, 
                &st, NULL, pwszText, cchText);
        }
    }
    else if (CompareSCIDFMTIDPID(fmtid, pid, SCID_AUDIO_Bitrate) || CompareSCIDFMTIDPID(fmtid, pid, SCID_VIDEO_Bitrate))
    {
        LoadString(HINST_THISDLL, IDS_PROPERTYUI_MUSIC_BITRATE, szBuffer, ARRAYSIZE(szBuffer));
        ASSERT(pPropVar->vt == VT_UI4 || pPropVar->vt == VT_I4)
        wnsprintf(pwszText, cchText, szBuffer, pPropVar->ulVal / 1000);
    }
    else if (CompareSCIDFMTIDPID(fmtid, pid, SCID_DRM_Protected)
           ||CompareSCIDFMTIDPID(fmtid, pid, SCID_Scale))
    {
        ASSERT(pPropVar->vt == VT_BOOL);
        UINT uID = (pPropVar->boolVal) ? IDS_PROPERTYUI_YES : IDS_PROPERTYUI_NO;
        LoadString(HINST_THISDLL, uID, pwszText, cchText);
    }
    else if (CompareSCIDFMTIDPID(fmtid, pid, SCID_AUDIO_SampleSize) || CompareSCIDFMTIDPID(fmtid, pid, SCID_VIDEO_SampleSize))
    {
        ASSERT(pPropVar->vt == VT_UI4);
        LoadString(HINST_THISDLL, IDS_PROPERTYUI_AV_SAMPLESIZE, szBuffer, ARRAYSIZE(szBuffer));
        wnsprintf(pwszText, cchText, szBuffer, pPropVar->ulVal);
    }
    else if (CompareSCIDFMTIDPID(fmtid, pid, SCID_AUDIO_SampleRate))
    {
        ASSERT(pPropVar->vt == VT_UI4);
        LoadString(HINST_THISDLL, IDS_PROPERTYUI_AUDIO_SAMPLERATE, szBuffer, ARRAYSIZE(szBuffer));
        wnsprintf(pwszText, cchText, szBuffer, pPropVar->ulVal / 1000); // 1000: Hz -> kHz
    }
    else if (CompareSCIDFMTIDPID(fmtid, pid, SCID_AUDIO_ChannelCount))
    {
        ASSERT(pPropVar->vt == VT_UI4);
        switch (pPropVar->ulVal)
        {
        case 1:
            LoadString(HINST_THISDLL, IDS_PROPERTYUI_AUDIO_CHANNELCOUNT1, pwszText, cchText);
            break;
        case 2:
            LoadString(HINST_THISDLL, IDS_PROPERTYUI_AUDIO_CHANNELCOUNT2, pwszText, cchText);
            break;
        default:
            wnsprintf(pwszText, cchText, L"%u", pPropVar->ulVal);

        }
    }
    else if (CompareSCIDFMTIDPID(fmtid, pid, SCID_VIDEO_FrameRate))
    {
        ASSERT(pPropVar->vt == VT_UI4);
        LoadString(HINST_THISDLL, IDS_PROPERTYUI_VIDEO_FRAMERATE, szBuffer, ARRAYSIZE(szBuffer));
        wnsprintf(pwszText, cchText, szBuffer, pPropVar->ulVal/1000); // 1000 -> convert to frames/second
    }
    else if (CompareSCIDFMTIDPID(fmtid, pid, SCID_ImageCX) || CompareSCIDFMTIDPID(fmtid, pid, SCID_ImageCY))
    {
        ASSERT(pPropVar->vt == VT_UI4);
        LoadString(HINST_THISDLL, IDS_PROPERTYUI_IMAGE_PIXELS, szBuffer, ARRAYSIZE(szBuffer));
        wnsprintf(pwszText, cchText, szBuffer, pPropVar->ulVal);
    }
    else if (CompareSCIDFMTIDPID(fmtid, pid, SCID_Flash))             
    {
        ASSERT(pPropVar->vt == VT_UI2);
        hr = _LookupStringFromLong(g_cFlashStrings,pPropVar->uiVal,pwszText, cchText);
    }
    else if (CompareSCIDFMTIDPID(fmtid, pid, SCID_ColorSpace))
    {
        ASSERT(pPropVar->vt == VT_UI2);
        hr = _LookupStringFromLong(g_cColorStrings,pPropVar->uiVal,pwszText, cchText);
    }
    else if (CompareSCIDFMTIDPID(fmtid, pid, SCID_Media_Status))
    {
        hr = _LookupStringFromLong(g_cMediaStatus, pPropVar->ulVal, pwszText, cchText);
    }
    else if (CompareSCIDFMTIDPID(fmtid, pid, SCID_MeteringMode))
    {
        ASSERT(pPropVar->vt == VT_UI2);
        hr = _LookupStringFromLong(g_cMeteringModeStrings, pPropVar->uiVal, pwszText, cchText);
    }
    else if (CompareSCIDFMTIDPID(fmtid, pid, SCID_LightSource))
    {
        ASSERT(pPropVar->vt == VT_UI2);
        hr = _LookupStringFromLong(g_cLightSourceStrings, pPropVar->uiVal, pwszText, cchText);
    }
    else if (CompareSCIDFMTIDPID(fmtid, pid, SCID_ExposureProg))
    {
        ASSERT(pPropVar->vt == VT_UI2);
        hr = _LookupStringFromLong(g_cExposureProgStrings, pPropVar->uiVal, pwszText, cchText);
    }
    else if (CompareSCIDFMTIDPID(fmtid, pid, SCID_ISOSpeed))
    {
        ASSERT(pPropVar->vt == VT_UI2);
        LoadString(HINST_THISDLL, IDS_PROPERTYUI_IMAGE_ISO, szBuffer, ARRAYSIZE(szBuffer));
        wnsprintf(pwszText, cchText, szBuffer, pPropVar->ulVal);
    }
    else if (CompareSCIDFMTIDPID(fmtid, pid, SCID_ShutterSpeed))
    {
        ASSERT(pPropVar->vt == VT_R8);

        // ShutterSpeed is stored as an APEX value Tv = -log2(Et)
        // we want to display the exposure time so we calculate it as follows
        // Et = 2^(-Tv) then if the value is less than 0.5 then take the inverse
        // so we can represent like 1/250
        
        TCHAR szFloatBuffer[MAX_PATH];

        VARIANT vTv = {0};
        hr = PropVariantToVariant(pPropVar, &vTv);
        if (SUCCEEDED(hr))
        {
            VARIANT vTemp = {0};
            VARIANT vTemp2 = {0};
            VARIANT vTemp3 = {0};

            hr = VarNeg(&vTv, &vTemp);
            if (SUCCEEDED(hr))
            {
                V_VT(&vTemp2) = VT_R8;
                V_R8(&vTemp2) = 2;

                hr = VarPow(&vTemp2, &vTemp, &vTemp3);
                if (SUCCEEDED(hr))
                {
                    if (V_R8(&vTemp3) > 0.5)
                    {
                        hr = VarRound(&vTemp3, 2, &vTemp);
                        if (SUCCEEDED(hr))
                        {
                            hr = VariantToStr(&vTemp, szFloatBuffer, ARRAYSIZE(szFloatBuffer)) ? S_OK : E_OUTOFMEMORY;
                            if (SUCCEEDED(hr))
                            {
                                LoadString(HINST_THISDLL, IDS_PROPERTYUI_IMAGE_SEC, szBuffer, ARRAYSIZE(szBuffer));
                                wnsprintf(pwszText, cchText, szBuffer, szFloatBuffer);
                            }
                        }
                    }
                    else
                    {
                        V_VT(&vTemp) = VT_R8;
                        V_R8(&vTemp) = 1;

                        hr = VarDiv(&vTemp, &vTemp3, &vTemp2);
                        if (SUCCEEDED(hr))
                        {
                            hr = VarRound(&vTemp2, 0, &vTemp);
                            if (SUCCEEDED(hr))
                            {
                                hr = VariantToStr(&vTemp, szFloatBuffer, ARRAYSIZE(szFloatBuffer)) ? S_OK : E_OUTOFMEMORY;
                                if (SUCCEEDED(hr))
                                {
                                    LoadString(HINST_THISDLL, IDS_PROPERTYUI_IMAGE_SEC_FRAC, szBuffer, ARRAYSIZE(szBuffer));
                                    wnsprintf(pwszText, cchText, szBuffer, szFloatBuffer);
                                }
                            }
                        }
                    }
                }
            }

            VariantClear(&vTv);
            VariantClear(&vTemp);
            VariantClear(&vTemp2);
            VariantClear(&vTemp3);
        }
    }
    else if (CompareSCIDFMTIDPID(fmtid, pid, SCID_ExposureTime))
    {
        ASSERT(pPropVar->vt == VT_R8);
        
        // ExposureTime is store as a R8 value if the value is less 
        // than 0.5 then take the inverse so we can represent like 1/250
        
        TCHAR szFloatBuffer[MAX_PATH];

        VARIANT vEt = {0};
        hr = PropVariantToVariant(pPropVar, &vEt);
        if (SUCCEEDED(hr))
        {
            VARIANT vTemp = {0};
            VARIANT vTemp2 = {0};

            if (V_R8(&vEt) > 0.5)
            {
                hr = VarRound(&vEt, 2, &vTemp);
                if (SUCCEEDED(hr))
                {
                    hr = VariantToStr(&vTemp, szFloatBuffer, ARRAYSIZE(szFloatBuffer)) ? S_OK : E_OUTOFMEMORY;
                    if (SUCCEEDED(hr))
                    {
                        LoadString(HINST_THISDLL, IDS_PROPERTYUI_IMAGE_SEC, szBuffer, ARRAYSIZE(szBuffer));
                        wnsprintf(pwszText, cchText, szBuffer, szFloatBuffer);
                    }
                }
            }
            else
            {
                V_VT(&vTemp) = VT_R8;
                V_R8(&vTemp) = 1;

                hr = VarDiv(&vTemp, &vEt, &vTemp2);
                if (SUCCEEDED(hr))
                {
                    hr = VarRound(&vTemp2, 0, &vTemp);
                    if (SUCCEEDED(hr))
                    {
                        hr = VariantToStr(&vTemp, szFloatBuffer, ARRAYSIZE(szFloatBuffer)) ? S_OK : E_OUTOFMEMORY;
                        if (SUCCEEDED(hr))
                        {
                            LoadString(HINST_THISDLL, IDS_PROPERTYUI_IMAGE_SEC_FRAC, szBuffer, ARRAYSIZE(szBuffer));
                            wnsprintf(pwszText, cchText, szBuffer, szFloatBuffer);
                        }
                    }
                }
            }

            VariantClear(&vEt);
            VariantClear(&vTemp);
            VariantClear(&vTemp2);
        }
    }
    else if (CompareSCIDFMTIDPID(fmtid, pid, SCID_Aperture))
    {
        ASSERT(pPropVar->vt == VT_R8);
        
        // Aperture is stored as an APEX value Av = 2*log2(Fn)
        // we want to display the F-number so we calculate it as follows
        // Fn = 2^(Av/2)
        
        TCHAR szFloatBuffer[MAX_PATH];

        VARIANT vAv = {0};
        hr = PropVariantToVariant(pPropVar, &vAv);
        if (SUCCEEDED(hr))
        {
            VARIANT vTemp = {0};
            VARIANT vTemp2 = {0};
            VARIANT vTemp3 = {0};

            V_VT(&vTemp) = VT_R8;
            V_R8(&vTemp) = 2;

            hr = VarDiv(&vAv, &vTemp, &vTemp2);
            if (SUCCEEDED(hr))
            {
                hr = VarPow(&vTemp, &vTemp2, &vTemp3);
                if (SUCCEEDED(hr))
                {
                    hr = VarRound(&vTemp3, 1, &vTemp);
                    if (SUCCEEDED(hr))
                    {
                        hr = VariantToStr(&vTemp, szFloatBuffer, ARRAYSIZE(szFloatBuffer)) ? S_OK : E_OUTOFMEMORY;
                        if (SUCCEEDED(hr))
                        {
                            LoadString(HINST_THISDLL, IDS_PROPERTYUI_IMAGE_F, szBuffer, ARRAYSIZE(szBuffer));
                            wnsprintf(pwszText, cchText, szBuffer, szFloatBuffer);
                        }
                    }
                }
            }

            VariantClear(&vAv);
            VariantClear(&vTemp);
            VariantClear(&vTemp2);
            VariantClear(&vTemp3);
        }
    }
    else if (CompareSCIDFMTIDPID(fmtid, pid, SCID_FNumber))
    {
        ASSERT(pPropVar->vt == VT_R8);
        
        // Fn is stored as a R8 value that needs to be rounded
        
        TCHAR szFloatBuffer[MAX_PATH];

        VARIANT vFn = {0};
        hr = PropVariantToVariant(pPropVar, &vFn);
        if (SUCCEEDED(hr))
        {
            VARIANT vTemp = {0};

            V_VT(&vTemp) = VT_R8;
            V_R8(&vTemp) = 2;

            hr = VarRound(&vFn, 1, &vTemp);
            if (SUCCEEDED(hr))
            {
                hr = VariantToStr(&vTemp, szFloatBuffer, ARRAYSIZE(szFloatBuffer)) ? S_OK : E_OUTOFMEMORY;
                if (SUCCEEDED(hr))
                {
                    LoadString(HINST_THISDLL, IDS_PROPERTYUI_IMAGE_F, szBuffer, ARRAYSIZE(szBuffer));
                    wnsprintf(pwszText, cchText, szBuffer, szFloatBuffer);
                }
            }

            VariantClear(&vFn);
            VariantClear(&vTemp);
        }
    }
    else if (CompareSCIDFMTIDPID(fmtid, pid, SCID_SubjectDist))
    {
        ASSERT(pPropVar->vt == VT_R8);
        
        // Distance is store as a R8 value in meters if the value is less 
        // than 1 then multiple by 1000 to convert to mm
        
        TCHAR szFloatBuffer[MAX_PATH];

        VARIANT vD = {0};
        hr = PropVariantToVariant(pPropVar, &vD);
        if (SUCCEEDED(hr))
        {
            VARIANT vTemp = {0};
            VARIANT vTemp2 = {0};

            if (V_R8(&vD) >= 1.0)
            {
                hr = VarRound(&vD, 1, &vTemp);
                if (SUCCEEDED(hr))
                {
                    hr = VariantToStr(&vTemp, szFloatBuffer, ARRAYSIZE(szFloatBuffer)) ? S_OK : E_OUTOFMEMORY;
                    if (SUCCEEDED(hr))
                    {
                        LoadString(HINST_THISDLL, IDS_PROPERTYUI_IMAGE_M, szBuffer, ARRAYSIZE(szBuffer));
                        wnsprintf(pwszText, cchText, szBuffer, szFloatBuffer);
                    }
                }
            }
            else
            {
                V_VT(&vTemp) = VT_R8;
                V_R8(&vTemp) = 1000;

                hr = VarMul(&vTemp, &vD, &vTemp2);
                if (SUCCEEDED(hr))
                {
                    hr = VarRound(&vTemp2, 0, &vTemp);
                    if (SUCCEEDED(hr))
                    {
                        hr = VariantToStr(&vTemp, szFloatBuffer, ARRAYSIZE(szFloatBuffer)) ? S_OK : E_OUTOFMEMORY;
                        if (SUCCEEDED(hr))
                        {
                            LoadString(HINST_THISDLL, IDS_PROPERTYUI_IMAGE_MM, szBuffer, ARRAYSIZE(szBuffer));
                            wnsprintf(pwszText, cchText, szBuffer, szFloatBuffer);
                        }
                    }
                }
            }

            VariantClear(&vD);
            VariantClear(&vTemp);
            VariantClear(&vTemp2);
        }
    }
    else if (CompareSCIDFMTIDPID(fmtid, pid, SCID_FocalLength))
    {
        ASSERT(pPropVar->vt == VT_R8);
        
        // Focal Length is store as a R8 value in mm
        // so round it and display it
        
        TCHAR szFloatBuffer[MAX_PATH];

        VARIANT vLen = {0};
        hr = PropVariantToVariant(pPropVar, &vLen);
        if (SUCCEEDED(hr))
        {
             VARIANT vTemp = {0};

            hr = VarRound(&vLen, 0, &vTemp);
            if (SUCCEEDED(hr))
            {
                hr = VariantToStr(&vTemp, szFloatBuffer, ARRAYSIZE(szFloatBuffer)) ? S_OK : E_OUTOFMEMORY;
                if (SUCCEEDED(hr))
                {
                    LoadString(HINST_THISDLL, IDS_PROPERTYUI_IMAGE_MM, szBuffer, ARRAYSIZE(szBuffer));
                    wnsprintf(pwszText, cchText, szBuffer, szFloatBuffer);
                }
            }

            VariantClear(&vLen);
            VariantClear(&vTemp);
        }
    }
    else if (CompareSCIDFMTIDPID(fmtid, pid, SCID_FlashEnergy))
    {
        ASSERT(pPropVar->vt == VT_R8);
        
        // Flash Energy is store as a R8 value in bcps
        // so round it and display it
        
        TCHAR szFloatBuffer[MAX_PATH];

        VARIANT vBCPS = {0};
        hr = PropVariantToVariant(pPropVar, &vBCPS);
        if (SUCCEEDED(hr))
        {
            VARIANT vTemp = {0};

            hr = VarRound(&vBCPS, 0, &vTemp);
            if (SUCCEEDED(hr))
            {
                hr = VariantToStr(&vTemp, szFloatBuffer, ARRAYSIZE(szFloatBuffer)) ? S_OK : E_OUTOFMEMORY;
                if (SUCCEEDED(hr))
                {
                    LoadString(HINST_THISDLL, IDS_PROPERTYUI_IMAGE_BCPS, szBuffer, ARRAYSIZE(szBuffer));
                    wnsprintf(pwszText, cchText, szBuffer, szFloatBuffer);
                }
            }

            VariantClear(&vBCPS);
            VariantClear(&vTemp);
        }
    }
    else if (CompareSCIDFMTIDPID(fmtid, pid, SCID_ExposureBias))
    {
        ASSERT(pPropVar->vt == VT_R8);
        
        // ExposureBias is store as a R8 value in steps
        // so round it to the nearest tenth and display 
        // it with a + or minus
        
        TCHAR szFloatBuffer[MAX_PATH];

        VARIANT vBias = {0};
        hr = PropVariantToVariant(pPropVar, &vBias);
        if (SUCCEEDED(hr))
        {
            VARIANT vTemp = {0};

            hr = VarRound(&vBias, 1, &vTemp);
            if (SUCCEEDED(hr))
            {
                TCHAR* pszSign;
                if (V_R8(&vBias) > 0)
                    pszSign = L"+";
                else
                    pszSign = L"";
                
                hr = VariantToStr(&vTemp, szFloatBuffer, ARRAYSIZE(szFloatBuffer)) ? S_OK : E_OUTOFMEMORY;
                if (SUCCEEDED(hr))
                {
                    LoadString(HINST_THISDLL, IDS_PROPERTYUI_IMAGE_STEP, szBuffer, ARRAYSIZE(szBuffer));
                    wnsprintf(pwszText, cchText, szBuffer, pszSign, szFloatBuffer);
                }
            }

            VariantClear(&vBias);
            VariantClear(&vTemp);
        }
    }
    else if (CompareSCIDFMTIDPID(fmtid, pid, SCID_ResolutionX) || CompareSCIDFMTIDPID(fmtid, pid, SCID_ResolutionY))
    {
        ASSERT(pPropVar->vt == VT_UI4);
        LoadString(HINST_THISDLL, IDS_PROPERTYUI_IMAGE_DPI, szBuffer, ARRAYSIZE(szBuffer));
        wnsprintf(pwszText, cchText, szBuffer, pPropVar->ulVal);
    }
    else if ((pPropVar->vt == VT_DATE) || (pPropVar->vt == VT_FILETIME))
    {
        FILETIME ft;
        if (pPropVar->vt == VT_DATE)
        {
            WORD wDosDate, wDosTime;
            if (VariantTimeToDosDateTime(pPropVar->date, &wDosDate, &wDosTime) && wDosDate)
            {
                DosDateTimeToFileTime(wDosDate, wDosTime, &ft);
                hr = S_OK;
            }
            else
                hr = E_FAIL;
        }
        else
        {
            ft = pPropVar->filetime;
            hr = S_OK;
        }

        if (SUCCEEDED(hr))
        {
            DWORD dwFlags = FDTF_DEFAULT;
            if (flags & PUIFFDF_RIGHTTOLEFT)
            {
                dwFlags |= FDTF_RTLDATE;
            }
            if (flags & PUIFFDF_SHORTFORMAT)
            {
                dwFlags |= FDTF_SHORTDATE;
            }
            if (flags & PUIFFDF_NOTIME)
            {
                dwFlags |= FDTF_LONGDATE;
            }
            if (flags & PUIFFDF_FRIENDLYDATE)
            {
                dwFlags |= (FDTF_RELATIVE | FDTF_LONGDATE);
            }
            
            SHFormatDateTime(&ft, &dwFlags, pwszText, cchText);
        }
    }
    else
    {
        VARIANT var = {0};
        hr = PropVariantToVariant(pPropVar, &var);
        if (SUCCEEDED(hr))
        {
            hr = VariantToStr(&var, pwszText, cchText) ? S_OK : E_OUTOFMEMORY;
            VariantClear(&var);
        }
    }
    return hr;
}

STDMETHODIMP CPropertyUI::FormatForDisplay(REFFMTID fmtid, PROPID pid, const PROPVARIANT *pPropVar, 
                                           PROPERTYUI_FORMAT_FLAGS flags, LPWSTR pwszText, DWORD cchText)
{
    return SHFormatForDisplay(fmtid, pid, pPropVar, flags, pwszText, cchText);
}

STDMETHODIMP CPropertyUI::GetHelpInfo(REFFMTID fmtid, PROPID pid, LPWSTR pwszHelpFile, DWORD cch, UINT *puHelpID)
{
    HRESULT hr = E_INVALIDARG;  // assume failure
    if (pwszHelpFile && puHelpID)
    {
        *pwszHelpFile = 0;
        *puHelpID = 0;

        const PROPUI_INFO *pinfo = _FindInfoByFMTIDPID(fmtid, pid);
        if (pinfo)
        {
            *puHelpID = pinfo->idHelp;
            StrCpyN(pwszHelpFile, L"filefold.hlp", cch);
            hr = S_OK;
        }
        else
        {
            hr = HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND);  // close approximation
        }
    }
    return hr;
}

STDAPI CPropertyUI_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv)
{
    HRESULT hr;
    CPropertyUI *ppui = new CPropertyUI();
    if (ppui)
    {
        hr = ppui->QueryInterface(riid, ppv);
        ppui->Release();
    }
    else
    {
        *ppv = NULL;
        hr = E_OUTOFMEMORY;
    }
    return hr;
}

#if 0
  // this table defines the CI names for properties that we don't yet have CPropertyUI support for

  // Storage Propset
  { 0, L"ClassId",         {PSGUID_STORAGE, DBKIND_GUID_PROPID, (LPWSTR)PID_STG_CLASSID },  36, TRUE,  TRUE, DBTYPE_GUID              },
  { 0, L"FileIndex",       {PSGUID_STORAGE, DBKIND_GUID_PROPID, (LPWSTR)PID_STG_FILEINDEX },   8, TRUE,  TRUE, DBTYPE_UI8               },
  { 0, L"USN",             {PSGUID_STORAGE, DBKIND_GUID_PROPID, (LPWSTR)PID_STG_LASTCHANGEUSN },   8, TRUE,  TRUE, DBTYPE_I8                },
  { 0, L"Filename",        {PSGUID_STORAGE, DBKIND_GUID_PROPID, (LPWSTR)PID_STG_NAME }, 15, TRUE,  TRUE, DBTYPE_WSTR|DBTYPE_BYREF },
  { 0, L"Path",            {PSGUID_STORAGE, DBKIND_GUID_PROPID, (LPWSTR)PID_STG_PATH }, 50, TRUE,  TRUE, DBTYPE_WSTR|DBTYPE_BYREF },
  { 0, L"Attrib",          {PSGUID_STORAGE, DBKIND_GUID_PROPID, (LPWSTR)PID_STG_ATTRIBUTES },  7, TRUE,  TRUE, DBTYPE_UI4               },

  { 0, L"AllocSize",       {PSGUID_STORAGE, DBKIND_GUID_PROPID, (LPWSTR)18 }, 11, TRUE,  TRUE, DBTYPE_I8                },
  { 0, L"Contents",        {PSGUID_STORAGE, DBKIND_GUID_PROPID, (LPWSTR)19 },  0, FALSE, TRUE, DBTYPE_WSTR|DBTYPE_BYREF },

  // Query Propset
  { 0, L"RankVector",      {QueryGuid, DBKIND_GUID_PROPID, (LPWSTR)2 }, 20, TRUE, TRUE, DBTYPE_UI4|DBTYPE_VECTOR },
  { 0, L"Rank",            {QueryGuid, DBKIND_GUID_PROPID, (LPWSTR)3 },  7, TRUE, TRUE, DBTYPE_I4                },
  { 0, L"HitCount",        {QueryGuid, DBKIND_GUID_PROPID, (LPWSTR)4 }, 10, TRUE, TRUE, DBTYPE_I4                },
  { 0, L"WorkId",          {QueryGuid, DBKIND_GUID_PROPID, (LPWSTR)5 }, 10, TRUE, TRUE, DBTYPE_I4                },
  { 0, L"All",             {QueryGuid, DBKIND_GUID_PROPID, (LPWSTR)6 },  0, FALSE,TRUE, DBTYPE_WSTR|DBTYPE_BYREF },
  { 0, L"VPath",           {QueryGuid, DBKIND_GUID_PROPID, (LPWSTR)9 }, 50, TRUE, TRUE, DBTYPE_WSTR|DBTYPE_BYREF },

  // standard document
  { 0, L"DocSecurity",     {PSGUID_SUMMARYINFORMATION, DBKIND_GUID_PROPID, (LPWSTR)PIDSI_DOC_SECURITY }, 10, TRUE, TRUE, DBTYPE_I4                },

  // who invented these?
  { 0, L"DocPresentationTarget",  {DocPropSetGuid2, DBKIND_GUID_PROPID, (LPWSTR)3 }, 10, TRUE, TRUE, DBTYPE_STR|DBTYPE_BYREF  },
  { 0, L"DocPartTitles",   {DocPropSetGuid2, DBKIND_GUID_PROPID, (LPWSTR)13 }, 10, TRUE, TRUE, DBTYPE_STR|DBTYPE_VECTOR },
  { 0, L"DocManager",      {DocPropSetGuid2, DBKIND_GUID_PROPID, (LPWSTR)14 }, 10, TRUE, TRUE, DBTYPE_STR|DBTYPE_BYREF  },
  { 0, L"DocCompany",      {DocPropSetGuid2, DBKIND_GUID_PROPID, (LPWSTR)15 }, 10, TRUE, 

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\prop.h ===
EXTERN_C const SHCOLUMNID SCID_Author;
EXTERN_C const SHCOLUMNID SCID_Title;
EXTERN_C const SHCOLUMNID SCID_Subject;
EXTERN_C const SHCOLUMNID SCID_Category;
EXTERN_C const SHCOLUMNID SCID_Copyright;
EXTERN_C const SHCOLUMNID SCID_CompanyName;
EXTERN_C const SHCOLUMNID SCID_PageCount;
EXTERN_C const SHCOLUMNID SCID_Comment;
EXTERN_C const SHCOLUMNID SCID_DocCreated;
EXTERN_C const SHCOLUMNID SCID_TYPE;
EXTERN_C const SHCOLUMNID SCID_WRITETIME;
EXTERN_C const SHCOLUMNID SCID_CREATETIME;
EXTERN_C const SHCOLUMNID SCID_ACCESSTIME;
EXTERN_C const SHCOLUMNID SCID_OWNER;
EXTERN_C const SHCOLUMNID SCID_NAME;
EXTERN_C const SHCOLUMNID SCID_DELETEDFROM;
EXTERN_C const SHCOLUMNID SCID_DATEDELETED;
EXTERN_C const SHCOLUMNID SCID_SIZE;
EXTERN_C const SHCOLUMNID SCID_SYNCCOPYIN;
EXTERN_C const SHCOLUMNID SCID_STATUS;
EXTERN_C const SHCOLUMNID SCID_DIRECTORY;
EXTERN_C const SHCOLUMNID SCID_RANK;
EXTERN_C const SHCOLUMNID SCID_FREESPACE;
EXTERN_C const SHCOLUMNID SCID_CAPACITY;
EXTERN_C const SHCOLUMNID SCID_FILESYSTEM;
EXTERN_C const SHCOLUMNID SCID_CSC_STATUS;
EXTERN_C const SHCOLUMNID SCID_LINKTARGET;
EXTERN_C const SHCOLUMNID SCID_LASTVISITED;
EXTERN_C const SHCOLUMNID SCID_LASTMODIFIED;
EXTERN_C const SHCOLUMNID SCID_VISITCOUNT;
EXTERN_C const SHCOLUMNID SCID_ATTRIBUTES;
EXTERN_C const SHCOLUMNID SCID_ATTRIBUTES_DESCRIPTION;
EXTERN_C const SHCOLUMNID SCID_LOCATION;
EXTERN_C const SHCOLUMNID SCID_FINDDATA;
EXTERN_C const SHCOLUMNID SCID_NETRESOURCE;
EXTERN_C const SHCOLUMNID SCID_DESCRIPTIONID;
EXTERN_C const SHCOLUMNID SCID_WHICHFOLDER;
EXTERN_C const SHCOLUMNID SCID_NETWORKLOCATION;
EXTERN_C const SHCOLUMNID SCID_COMPUTERNAME;
EXTERN_C const SHCOLUMNID SCID_DetailsProperties;
EXTERN_C const SHCOLUMNID SCID_FolderIntroText;
EXTERN_C const SHCOLUMNID SCID_CONTROLPANELCATEGORY;
EXTERN_C const SHCOLUMNID SCID_MUSIC_Artist;
EXTERN_C const SHCOLUMNID SCID_MUSIC_Album;
EXTERN_C const SHCOLUMNID SCID_MUSIC_Year;
EXTERN_C const SHCOLUMNID SCID_MUSIC_Track;
EXTERN_C const SHCOLUMNID SCID_MUSIC_Genre;
EXTERN_C const SHCOLUMNID SCID_AUDIO_Duration;
EXTERN_C const SHCOLUMNID SCID_AUDIO_Bitrate;
EXTERN_C const SHCOLUMNID SCID_ImageCX;
EXTERN_C const SHCOLUMNID SCID_ImageCY;
EXTERN_C const SHCOLUMNID SCID_ImageDimensions;
EXTERN_C const SHCOLUMNID SCID_CameraModel;
EXTERN_C const SHCOLUMNID SCID_WhenTaken;
EXTERN_C const SHCOLUMNID SCID_Flash;
EXTERN_C const SHCOLUMNID SCID_ColorSpace;
EXTERN_C const SHCOLUMNID SCID_DRM_Protected;

// Printer Folder column identifier defs...
EXTERN_C const SHCOLUMNID SCID_PRN_QUEUESIZE;
EXTERN_C const SHCOLUMNID SCID_PRN_STATUS;
EXTERN_C const SHCOLUMNID SCID_PRN_LOCATION;
EXTERN_C const SHCOLUMNID SCID_PRN_MODEL;

//  Win32 PE (exe, dll) Version Information column identifier defs...
EXTERN_C const SHCOLUMNID SCID_FileDescription;
EXTERN_C const SHCOLUMNID SCID_FileVersion;
EXTERN_C const SHCOLUMNID SCID_InternalName;
EXTERN_C const SHCOLUMNID SCID_OriginalFileName;
EXTERN_C const SHCOLUMNID SCID_ProductName;
EXTERN_C const SHCOLUMNID SCID_ProductVersion;

typedef struct {
    const SHCOLUMNID *pscid;
    VARTYPE vt;             // Note that the type of a given FMTID/PID pair is a known, fixed value
    DWORD fmt;              // listview format (LVCFMT_LEFT, usually)
    UINT cChars;            // count of chars (default col width)
    DWORD csFlags;          // SHCOLSTATE flags
    UINT idTitle;           // string id for title
    UINT idDescription;     // add these, make defview display them too!
} COLUMN_INFO;

#define DEFINE_COL_ENTRY(scid, vt, fmt, cChars, shcs, ids) \
    { &scid, vt, fmt, cChars, shcs, ids, 0 }

#define DEFINE_COL_STR_ENTRY(scid, cChars, ids) \
    { &scid, VT_LPWSTR, LVCFMT_LEFT, cChars, SHCOLSTATE_TYPE_STR | SHCOLSTATE_ONBYDEFAULT, ids, 0 }

#define DEFINE_COL_STR_MENU_ENTRY(scid, cChars, ids) \
    { &scid, VT_LPWSTR, LVCFMT_LEFT, cChars, SHCOLSTATE_TYPE_STR, ids, 0 }

#define DEFINE_COL_STR_DLG_ENTRY(scid, cChars, ids) \
    { &scid, VT_LPWSTR, LVCFMT_LEFT, cChars, SHCOLSTATE_TYPE_STR | SHCOLSTATE_SECONDARYUI, ids, 0 }

#define DEFINE_COL_STR_HIDDEN_ENTRY(scid) \
    { &scid, VT_LPWSTR, LVCFMT_LEFT, 20, SHCOLSTATE_TYPE_STR | SHCOLSTATE_HIDDEN, 0, 0 }

#define DEFINE_COL_DATE_ENTRY(scid, ids) \
    { &scid, VT_DATE, LVCFMT_LEFT, 20, SHCOLSTATE_TYPE_DATE | SHCOLSTATE_ONBYDEFAULT, ids, 0 }

#define DEFINE_COL_DATE_HIDDEN_ENTRY(scid) \
    { &scid, VT_DATE, LVCFMT_LEFT, 20, SHCOLSTATE_TYPE_DATE | SHCOLSTATE_HIDDEN, 0, 0 }

#define DEFINE_COL_INT_ENTRY(scid, cChars, ids) \
    { &scid, VT_I4, LVCFMT_LEFT, cChars, SHCOLSTATE_TYPE_INT | SHCOLSTATE_ONBYDEFAULT, ids, 0 }

#define DEFINE_COL_INT_DLG_ENTRY(scid, cChars, ids) \
    { &scid, VT_I4, LVCFMT_LEFT, cChars, SHCOLSTATE_TYPE_INT | SHCOLSTATE_SECONDARYUI, ids, 0 }

#define DEFINE_COL_INT_HIDDEN_ENTRY(scid) \
    { &scid, VT_I4, LVCFMT_LEFT, 5, SHCOLSTATE_TYPE_STR | SHCOLSTATE_HIDDEN, 0, 0 }

#define DEFINE_COL_SIZE_ENTRY(scid, ids) \
    DEFINE_COL_ENTRY(scid, VT_UI8, LVCFMT_RIGHT, 16, SHCOLSTATE_TYPE_INT | SHCOLSTATE_ONBYDEFAULT, ids)


STDAPI GetDetailsOfInfo(const COLUMN_INFO* pcol_data, UINT nCols, UINT iColumn, SHELLDETAILS *pdi);
STDAPI_(int) FindSCID(const COLUMN_INFO* pcol_data, UINT nCols, const SHCOLUMNID* pscid);
STDAPI MapColumnToSCIDImpl(const COLUMN_INFO* pcol_data, UINT nCols, UINT iColumn, SHCOLUMNID* pscid);
STDAPI_(BOOL) ParseSCIDString(LPCTSTR pszString, SHCOLUMNID *pscid, UINT *pidRes);
STDAPI SCIDCannonicalName(SHCOLUMNID *pscid, LPTSTR pszName, int cch);
HRESULT PropVariantToVariant(const PROPVARIANT *pPropVar, VARIANT *pVar);

#define CompareSCIDFMTIDPID(fmtid, pid, scid)   ((pid == (scid).pid) && IsEqualIID(fmtid, (scid).fmtid))
#define DEFINE_SCID(name, fmtid, pid) const SHCOLUMNID name = { fmtid, pid }

//
// Constants used while converting a SCID to a string
//
#define SCID_PIDSTR_MAX     10   // will take care of any long integer value  
#define SCIDSTR_MAX         (GUIDSTR_MAX + 1 + SCID_PIDSTR_MAX)

STDAPI_(int) StringFromSCID(const SHCOLUMNID *pscid, LPTSTR lpsz, UINT cch);

STDAPI SHFormatForDisplay(REFFMTID fmtid, PROPID pid, const PROPVARIANT *pPropVar, 
                          PROPERTYUI_FORMAT_FLAGS flags, LPWSTR pwszText, DWORD cchText);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\proxynt.c ===
#include "shellprv.h"
#pragma  hdrstop


STDAPI PIF_AddPages(IDataObject *pdtobj, LPFNADDPROPSHEETPAGE pfnAddPage, LPARAM lParam)
{
    STGMEDIUM medium;
    FORMATETC fmte = { CF_HDROP, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};

    HRESULT hr = pdtobj->lpVtbl->GetData(pdtobj, &fmte, &medium);
    if (SUCCEEDED(hr))
    {
        HDROP hdrop = (HDROP)GlobalLock(medium.hGlobal);
        if (hdrop)
        {
            PifMgrDLL_Init();       // Initialize pif stuff

            PifPropGetPages(hdrop, pfnAddPage, lParam);
            GlobalUnlock(medium.hGlobal);
        }
        ReleaseStgMedium(&medium);
    }
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\prnfldr.cpp ===
#include "shellprv.h"
#pragma  hdrstop

#include <initguid.h>
#include <winprtp.h>    // IID_IPrinterFolder & IID_IFolderNotify interfaces declared in windows\inc\winprtp.h
#include <guids.h>      // IID_IPrintersBindInfo

#include "w32utils.h"
#include "dpa.h"
#include "idlcomm.h"
#include "idldrop.h"
#include "printer.h"
#include "copy.h"
#include "fstreex.h"
#include "datautil.h"
#include "infotip.h"
#include "idldata.h"
#include "ovrlaymn.h"
#include "netview.h"
#include "ids.h"
#include "views.h"
#include "basefvcb.h"
#include "prnfldr.h"
#include "shstr.h"
#include "views.h"
#include "defview.h"
#include "prop.h"
#undef PATH_SEPARATOR_STR
#include "faxreg.h"
#include "filetbl.h"
#include "msprintx.h"
#include "defcm.h"
#include "enumidlist.h"
#include "ole2dup.h"

// FMTID_GroupByDetails - {FE9E4C12-AACB-4aa3-966D-91A29E6128B5}
#define STR_FMTID_GroupByDetails    TEXT("{FE9E4C12-AACB-4aa3-966D-91A29E6128B5}")
DEFINE_GUID(FMTID_GroupByDetails,   0xfe9e4c12, 0xaacb, 0x4aa3, 0x96, 0x6d, 0x91, 0xa2, 0x9e, 0x61, 0x28, 0xb5);
#define PSCID_GroupByDetails       {0xfe9e4c12, 0xaacb, 0x4aa3, 0x96, 0x6d, 0x91, 0xa2, 0x9e, 0x61, 0x28, 0xb5}

#define PID_PRN_NAME            0
#define PID_PRN_QUEUESIZE       1
#define PID_PRN_STATUS          2
#define PID_PRN_COMMENT         3
#define PID_PRN_LOCATION        4
#define PID_PRN_MODEL           5

DEFINE_SCID(SCID_PRN_QUEUESIZE,     PSCID_GroupByDetails,   PID_PRN_QUEUESIZE);
DEFINE_SCID(SCID_PRN_STATUS,        PSCID_GroupByDetails,   PID_PRN_STATUS);
DEFINE_SCID(SCID_PRN_LOCATION,      PSCID_GroupByDetails,   PID_PRN_LOCATION);
DEFINE_SCID(SCID_PRN_MODEL,         PSCID_GroupByDetails,   PID_PRN_MODEL);

// file system folder, CSIDL_PRINTHOOD for printer shortcuts
IShellFolder2 *g_psfPrintHood = NULL;

enum
{
    PRINTERS_ICOL_NAME = 0,
    PRINTERS_ICOL_QUEUESIZE,
    PRINTERS_ICOL_STATUS,
    PRINTERS_ICOL_COMMENT,
    PRINTERS_ICOL_LOCATION,
    PRINTERS_ICOL_MODEL,
};

const COLUMN_INFO c_printers_cols[] =
{
    DEFINE_COL_STR_ENTRY(SCID_NAME,             20, IDS_NAME_COL),
    DEFINE_COL_INT_ENTRY(SCID_PRN_QUEUESIZE,    12, IDS_PSD_QUEUESIZE),
    DEFINE_COL_STR_ENTRY(SCID_PRN_STATUS,       12, IDS_PRQ_STATUS),
    DEFINE_COL_STR_ENTRY(SCID_Comment,          30, IDS_EXCOL_COMMENT),
    DEFINE_COL_STR_ENTRY(SCID_PRN_LOCATION,     20, IDS_PSD_LOCATION),
    DEFINE_COL_STR_ENTRY(SCID_PRN_MODEL,        20, IDS_PSD_MODEL),
};

// converts ProgID or string representation of a GUID to a GUID.
static HRESULT _GetClassIDFromString(LPCTSTR psz, LPCLSID pClsID)
{
    HRESULT hr = E_FAIL;
    if (psz[0] == TEXT('{'))
    {
        hr = CLSIDFromString((LPOLESTR)T2COLE(psz), pClsID);
    }
    else
    {
        hr = CLSIDFromProgID(T2COLE(psz), pClsID);
    }
    return hr;
}

class CPrintersBindInfo: public IPrintersBindInfo
{
public:
    // construction/destruction
    CPrintersBindInfo();
    CPrintersBindInfo(DWORD dwType, BOOL bValidated, LPVOID pCookie = NULL);
    ~CPrintersBindInfo();

    //////////////////
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, LPVOID * ppvObj);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    ///////////////////////
    // IPrintersBindInfo
    STDMETHODIMP SetPIDLType(DWORD dwType);
    STDMETHODIMP GetPIDLType(LPDWORD pdwType);
    STDMETHODIMP IsValidated();
    STDMETHODIMP SetCookie(LPVOID pCookie);
    STDMETHODIMP GetCookie(LPVOID *ppCookie);

private:
    LONG    m_cRef;
    DWORD   m_dwType;
    BOOL    m_bValidated;
    LPVOID  m_pCookie;
};

// construction/destruction
CPrintersBindInfo::CPrintersBindInfo()
    : m_cRef(1),
      m_dwType(0),
      m_bValidated(FALSE),
      m_pCookie(NULL)
{
}

CPrintersBindInfo::CPrintersBindInfo(DWORD dwType, BOOL bValidated, LPVOID pCookie)
    : m_cRef(1),
      m_dwType(dwType),
      m_bValidated(bValidated),
      m_pCookie(pCookie)
{
}

CPrintersBindInfo::~CPrintersBindInfo()
{
    // nothing special to do here
}

/////////////////////////////////
// IUnknown - standard impl.
STDMETHODIMP CPrintersBindInfo::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] =
    {
        QITABENT(CPrintersBindInfo, IPrintersBindInfo),
        { 0 },
    };

    return QISearch(this, qit, riid, ppv);
}

STDMETHODIMP_(ULONG) CPrintersBindInfo::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

STDMETHODIMP_(ULONG) CPrintersBindInfo::Release()
{
    ULONG cRefs = InterlockedDecrement(&m_cRef);
    if (0 == cRefs)
    {
        delete this;
    }
    return cRefs;
}

///////////////////////
// IPrintersBindInfo
STDMETHODIMP CPrintersBindInfo::SetPIDLType(DWORD dwType)
{
    m_dwType = dwType;
    return S_OK;
}

STDMETHODIMP CPrintersBindInfo::GetPIDLType(LPDWORD pdwType)
{
    HRESULT hr = E_INVALIDARG;
    if (pdwType)
    {
        *pdwType = m_dwType;
        hr = S_OK;
    }
    return hr;
}

STDMETHODIMP CPrintersBindInfo::IsValidated()
{
    return m_bValidated ? S_OK : S_FALSE;
}

STDMETHODIMP CPrintersBindInfo::SetCookie(LPVOID pCookie)
{
    m_pCookie = pCookie;
    return S_OK;
}

STDMETHODIMP CPrintersBindInfo::GetCookie(LPVOID *ppCookie)
{
    HRESULT hr = E_INVALIDARG;
    if (ppCookie)
    {
        *ppCookie = m_pCookie;
        hr = S_OK;
    }
    return hr;
}

STDAPI Printers_CreateBindInfo(LPCTSTR pszPrinter, DWORD dwType, BOOL bValidated, LPVOID pCookie, IPrintersBindInfo **ppbc)
{
    HRESULT hr = E_INVALIDARG;
    if (ppbc)
    {
        *ppbc = NULL;

        CPrintersBindInfo *pObj = new CPrintersBindInfo(dwType, bValidated, pCookie);
        hr = pObj ? pObj->QueryInterface(IID_PPV_ARG(IPrintersBindInfo, ppbc)) : E_OUTOFMEMORY;

        if (pObj)
        {
            pObj->Release();
        }
    }
    return hr;
}

#define PRINTER_HACK_WORK_OFFLINE 0x80000000

// {EAE0A5E1-CE32-4296-9A44-9F0C069F73D4}
DEFINE_GUID(SID_SAuxDataObject, 0xeae0a5e1, 0xce32, 0x4296, 0x9a, 0x44, 0x9f, 0xc, 0x6, 0x9f, 0x73, 0xd4);

class CPrintersData: public CIDLDataObj,
                     public IServiceProvider
{
public:
    CPrintersData(IDataObject *pdoAux, LPCITEMIDLIST pidlFolder, UINT cidl, LPCITEMIDLIST apidl[]):
      _pdoAux(pdoAux), CIDLDataObj(pidlFolder, cidl, apidl)
    {
        if (_pdoAux)
            _pdoAux->AddRef();
    }

    ~CPrintersData()
    {
        IUnknown_SafeReleaseAndNullPtr(_pdoAux);
    }

    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef(void)   { return CIDLDataObj::AddRef();  }
    STDMETHODIMP_(ULONG) Release(void)  { return CIDLDataObj::Release(); }

    // IDataObject
    STDMETHODIMP GetData(FORMATETC *pformatetcIn, STGMEDIUM *pmedium);
    STDMETHODIMP QueryGetData(FORMATETC *pFmtEtc);

    // IServiceProvider
    STDMETHODIMP QueryService(REFGUID guidService, REFIID riid, void **ppv);

private:
    // auxiliary data object. we are going to use this data object to store the
    // selected printhood objects since they are in a different folder which is
    // a file system folder and their PIDLs don't have the printers folder as
    // parent. This is a limitation of the IDL array clipboard format -- it can
    // hold only PIDLs that have the same parent folder. the zero PIDL is the
    // PIDL of the parent folder and then we have the array of relative PIDLs
    // of the selected objects (childs).
    IDataObject *_pdoAux;
};


UINT Printer_BitsToString(DWORD bits, UINT idsSep, LPTSTR lpszBuf, UINT cchMax);



#define PRINTERS_EVENTS \
    SHCNE_UPDATEITEM | \
    SHCNE_DELETE | \
    SHCNE_RENAMEITEM | \
    SHCNE_ATTRIBUTES | \
    SHCNE_CREATE

class CPrinterFolderViewCB : public CBaseShellFolderViewCB
{
public:
    CPrinterFolderViewCB(CPrinterFolder *ppf, LPCITEMIDLIST pidl)
        : CBaseShellFolderViewCB(pidl, PRINTERS_EVENTS),  _ppf(ppf)
    {
        _ppf->AddRef();
    }

    // IShellFolderViewCB
    STDMETHODIMP RealMessage(UINT uMsg, WPARAM wParam, LPARAM lParam);

    // IServiceProvider
    STDMETHODIMP QueryService(REFGUID guidService, REFIID riid, void **ppv);


private:
    ~CPrinterFolderViewCB()
    {
        _ppf->Release();
    }

    HRESULT OnINVOKECOMMAND(DWORD pv, UINT wP)
    {
        return _ppf->CallBack(_ppf, _hwndMain, NULL, DFM_INVOKECOMMAND, wP, 0);
    }

    HRESULT OnGETHELPTEXT(DWORD pv, UINT id, UINT cch, LPTSTR lP)
    {
#ifdef UNICODE
        return _ppf->CallBack(_ppf, _hwndMain, NULL, DFM_GETHELPTEXTW, MAKEWPARAM(id, cch), (LPARAM)lP);
#else
        return _ppf->CallBack(_ppf, _hwndMain, NULL, DFM_GETHELPTEXT, MAKEWPARAM(id, cch), (LPARAM)lP);
#endif
    }

    HRESULT OnBACKGROUNDENUM(DWORD pv)
    {
        return _ppf->GetServer() ? S_OK : E_FAIL;
    }

    HRESULT OnREFRESH(DWORD pv, UINT wP)
    {
        HRESULT hr = S_OK;
        if (wP)
        {
            // start the net crawler
            RefreshNetCrawler();
        }

        if (_ppf)
        {
            // delegate to the folder
            hr = _ppf->_OnRefresh(static_cast<BOOL>(wP));
        }
        else
        {
            hr = E_UNEXPECTED;
        }
        return hr;
    }

    HRESULT OnGETHELPTOPIC(DWORD pv, SFVM_HELPTOPIC_DATA * phtd)
    {
        lstrcpynW(phtd->wszHelpTopic, 
            L"hcp://services/layout/xml?definition=MS-ITS%3A%25HELP_LOCATION%25%5Cntdef.chm%3A%3A/Printers_and_Faxes.xml",
            ARRAYSIZE(phtd->wszHelpTopic));
        return S_OK;
    }

    HRESULT OnDELAYWINDOWCREATE(DWORD pv, HWND hwnd)
    {
        RefreshNetCrawler();        // start the net crawler
        return S_OK;
    }

    // by default we want tiles, grouped by location
    HRESULT OnDEFERRED_VIEW_SETTING(DWORD pv, SFVM_DEFERRED_VIEW_SETTINGS *pdvs)
    {
        pdvs->fvm = FVM_TILE;
        pdvs->fGroupView = FALSE;
        pdvs->uSortCol = PRINTERS_ICOL_NAME;
        pdvs->iSortDirection = 1; // ascending
        return S_OK;
    }

    // DUI webview commands
    HRESULT OnGetWebViewLayout(DWORD pv, UINT uViewMode, SFVM_WEBVIEW_LAYOUT_DATA* pData)
    {
        return _ppf ? _ppf->GetWebViewLayout(
            static_cast<IServiceProvider*>(this), uViewMode, pData) : E_UNEXPECTED;
    }

    HRESULT OnGetWebViewContent(DWORD pv, SFVM_WEBVIEW_CONTENT_DATA* pData)
    {
        return _ppf ? _ppf->GetWebViewContent(
            static_cast<IServiceProvider*>(this), pData) : E_UNEXPECTED;
    }

    HRESULT OnGetWebViewTasks(DWORD pv, SFVM_WEBVIEW_TASKSECTION_DATA* pTasks)
    {
        return _ppf ? _ppf->GetWebViewTasks(
            static_cast<IServiceProvider*>(this), pTasks) : E_UNEXPECTED;
    }

    CPrinterFolder *_ppf;
};


class CPrinterDropTarget : public CIDLDropTarget
{
    friend HRESULT CPrinterDropTarget_CreateInstance(HWND hwnd, LPCITEMIDLIST pidl, IDropTarget **ppdropt);
public:
    CPrinterDropTarget(HWND hwnd) : CIDLDropTarget(hwnd) { };

    // IDropTarget methods overwirte
    STDMETHODIMP DragEnter(IDataObject *pDataObj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    STDMETHODIMP Drop(IDataObject *pDataObj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);

private:
    STDMETHODIMP _DropCallback(IDataObject *pDataObj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect, LPTHREAD_START_ROUTINE pfn);
};

LPCTSTR GetPrinterName(PFOLDER_PRINTER_DATA pPrinter, UINT Index)
{
    return ((PFOLDER_PRINTER_DATA)(((PBYTE)pPrinter)+pPrinter->cbSize*Index))->pName;
}

IShellFolder2* CPrintRoot_GetPSF()
{
    SHCacheTrackingFolder(MAKEINTIDLIST(CSIDL_PRINTERS), CSIDL_PRINTHOOD | CSIDL_FLAG_CREATE, &g_psfPrintHood);
    return g_psfPrintHood;
}

typedef enum
{
    HOOD_COL_PRINTER = 0,
    HOOD_COL_FILE    = 1
} PIDLTYPE ;


PIDLTYPE _IDListType(LPCITEMIDLIST pidl)
{
    LPCIDPRINTER pidlprint = (LPCIDPRINTER) pidl;
    if (pidlprint->cb >= sizeof(DWORD) + FIELD_OFFSET(IDPRINTER, dwMagic) &&
        pidlprint->dwMagic == PRINTER_MAGIC)
    {
        return HOOD_COL_PRINTER;
    }
    else
    {
        // This HACK is a little ugly but have to do it, in order to support
        // the legacy Win9x printer shortcuts under Win2k.
        //
        // Details: If the PRINTER_MAGIC field check fails it might still
        // be a valid Win9x PIDL. The only reliable way I can think of
        // to determine whether this is the case is to check if pidlprint->cb
        // points inside a W95IDPRINTER structure and also to check whether
        // the name is tighten up to the PIDL size.
        LPW95IDPRINTER pidlprint95 = (LPW95IDPRINTER)pidl;
        int nPIDLSize = sizeof(pidlprint95->cb) + lstrlenA(pidlprint95->cName) + 1;

        if (nPIDLSize < sizeof(W95IDPRINTER) &&     // Must be inside W95IDPRINTER
            pidlprint95->cb == nPIDLSize)                  // The PIDL size must match the ANSI name
        {
            // Well it might be a Win95 printer PIDL.
            return  HOOD_COL_PRINTER;
        }
        else
        {
            // This PIDL is not a valid printer PIDL.
            return HOOD_COL_FILE;
        }
    }
}

/*++
   Inserts a backslash before each double quote in a string and saves the new string in a pre-allocated memory.
   For all the backslash immediately before the double, we will insert additional backslashes. 
   This is mostly used by passing a command line between processes. 
  
   The rule is the same as rundll32. 
   Rules: each double quote ==> backslash + double quote
          N backslashes + double quote ==> 2N + 1 backslashes + double quote 
          N backslashes ==> N backslashes 

   Arguments:
        pszSrc -- [IN] source string
        pszDest -- [IN] destination string
        cbBuf -- [IN] size of the buffer for the destination string.
        pcbNeeded -- [OUT] the size of the buffer needed for destination string. If cbBuf is less than this value,
                     this function will return E_OUTOFMEMORY.
                     
   Return:
        standard HRESULT value.
--*/

HRESULT CheckAndVerboseQuote(LPTSTR pszSrc, LPTSTR pszDest, DWORD cbBuf, LPDWORD pcbNeeded)
{
    LPTSTR  pBegin;
    LPTSTR  pBack; // for back tracing '\\' when we meet a '\"'
    UINT    cAdd = 0;
    TCHAR const cchQuote = TEXT('\"');
    TCHAR const cchSlash = TEXT('\\');
    HRESULT hr = E_INVALIDARG;

    if (pszSrc && pcbNeeded)
    {
        hr = S_OK;
        pBegin = pszSrc;
        while (*pBegin) 
        {
            // check whether the buffer is large enough
            if (*pBegin == cchQuote) 
            {
                // check if the case is N backslashes + double quote
                // for each backslash before double quote, we add an additional backslash
                pBack = pBegin - 1; 
                // make sure pBack will not be out of bound
                while (pBack >= pszSrc && *pBack-- == cchSlash)
                {
                    cAdd++;
                }

                // for each double quote, we change it to backslash + double quote
                cAdd++;
            }
            pBegin++;
        }

        *pcbNeeded = (lstrlen(pszSrc) + cAdd + 1) * sizeof(TCHAR);
        if (*pcbNeeded > cbBuf)
        {
            hr = E_OUTOFMEMORY;
        }

        if (SUCCEEDED(hr))
        {
            // do the copy and verbose work
            pBegin = pszSrc;
            while (*pBegin) 
            {
                if (*pBegin == cchQuote) 
                {
                    pBack = pBegin - 1; 
                    while (pBack >= pszSrc && *pBack-- == cchSlash)
                    {
                        *pszDest++ = cchSlash;
                    }

                    *pszDest++ = cchSlash;
                }
                *pszDest++ = *pBegin++;
            }
            *pszDest = 0;
        }
    }
    return hr;
}

/*++
    Inserts a backslash before each double quote in a string and allocates memory to save the new string.
    For all the backslash immediately before the double, we will insert additional backslashes. 
    This is mostly used by passing a command line between processes. 

    Arguments:
        pszSrc -- [IN] source string
        ppszDest -- [OUT] destination string
                     
    Return:
        standard HRESULT value.

    Note: CheckAndVerboseQuote() does the real work.
--*/

HRESULT InsertBackSlash(LPTSTR pszSrc, LPTSTR *ppszDest)
{
    LPTSTR  pszDest;
    DWORD   cbNeeded = 0;
    HRESULT hr = E_INVALIDARG;

    if (pszSrc && ppszDest)
    {
        hr = CheckAndVerboseQuote(pszSrc, NULL, 0, &cbNeeded);

        if (hr == E_OUTOFMEMORY && cbNeeded)
        {
            pszDest = (LPTSTR)SHAlloc(cbNeeded);

            if (pszDest)
            {
                hr = CheckAndVerboseQuote(pszSrc, pszDest, cbNeeded, &cbNeeded);
                if (SUCCEEDED(hr))
                {
                    *ppszDest = pszDest;
                }
                else
                {
                    SHFree(pszDest);
                }
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }

    return hr;
}

/*  Registers a modeless, non-top level window with the shell.  When
    the user requests a window, we search for other instances of that
    window.  If we find one, we switch to it rather than creating
    a new window.

    This function is used by PRINTUI.DLL

    pszPrinter - Name of the printer resource.  Generally a fully
        qualified printer name (\\server\printer for remote print
        folders) or a server name for the folder itself.

    dwType - Type of property window.  May refer to properties, document
        defaults, or job details.  Should use the PRINTER_PIDL_TYPE_*
        flags.

    ph - Receives the newly created handle to the registered
        object.  NULL if window already exists.

    phwnd - Receives the newly created hwndStub.  The property sheet
        should use this as the parent, since subsequent calls to
        this function will set focus to the last active popup of
        hwndStub.  phwnd will be set to NULL if the window already
        exists.

    TRUE - Success, either the printer was registered, or a window
           already exists.
*/

STDAPI_(BOOL) Printers_RegisterWindow(LPCTSTR pszPrinter, DWORD dwType, HANDLE *ph, HWND *phwnd)
{
    BOOL bReturn = FALSE;

    *ph = NULL;
    *phwnd = NULL;

    LPITEMIDLIST pidl = NULL;
    if (NULL == pszPrinter || 0 == pszPrinter[0])
    {
        // they ask us to register the local print server - i.e. server properties dialog
        pidl = SHCloneSpecialIDList(NULL, CSIDL_PRINTERS, FALSE);
        bReturn = (pidl != NULL);
    }
    else
    {
        bReturn = SUCCEEDED(ParsePrinterNameEx(pszPrinter, &pidl, TRUE, dwType, 0));
    }

    if (bReturn && pidl)
    {
        UNIQUESTUBINFO *pusi = (UNIQUESTUBINFO *)LocalAlloc(LPTR, sizeof(*pusi));

        if (pusi)
        {
            // Create a new stub window if necessary.
            if (EnsureUniqueStub(pidl, STUBCLASS_PROPSHEET, NULL, pusi))
            {
                *phwnd = pusi->hwndStub;
                *ph = pusi;     // it's just a cookie
            }
            else
            {
                LocalFree(pusi);
            }
        }

        ILFree(pidl);
    }

    return bReturn;
}

/* Unregister a window handle.

    hClassPidl - Registration handle returned from Printers_RegisterWindow.
        It's really a pointer to a UNIQUESTUBINFO structure.
*/
void Printers_UnregisterWindow(HANDLE hClassPidl, HWND hwnd)
{
    UNIQUESTUBINFO* pusi = (UNIQUESTUBINFO*)hClassPidl;
    if (pusi)
    {
        ASSERT(pusi->hwndStub == hwnd);
        FreeUniqueStub(pusi);
        LocalFree(pusi);
    }
}

void CPrinterFolder::_FillPidl(LPIDPRINTER pidl, LPCTSTR pszName, DWORD dwType, USHORT uFlags)
{
    ualstrcpyn(pidl->cName, pszName, ARRAYSIZE(pidl->cName));

    pidl->cb = (USHORT)(FIELD_OFFSET(IDPRINTER, cName) + (ualstrlen(pidl->cName) + 1) * sizeof(pidl->cName[0]));
    *(UNALIGNED USHORT *)((LPBYTE)(pidl) + pidl->cb) = 0;
    pidl->uFlags = uFlags;
    pidl->dwType = dwType;
    pidl->dwMagic = PRINTER_MAGIC;
}

// creates a relative PIDL to a printer.
HRESULT CPrinterFolder::_Parse(LPCTSTR pszPrinterName, LPITEMIDLIST *ppidl, DWORD dwType, USHORT uFlags)
{
    HRESULT hr = E_INVALIDARG;
    if (pszPrinterName && ppidl)
    {
        IDPRINTER idp;
        _FillPidl(&idp, pszPrinterName, dwType, uFlags);
        *ppidl = ILClone((LPCITEMIDLIST)&idp);
        hr = (*ppidl) ? S_OK : E_OUTOFMEMORY;
    }
    return hr;
}

TCHAR const c_szNewObject[]             =  TEXT("WinUtils_NewObject");
TCHAR const c_szFileColon[]             =  TEXT("FILE:");
TCHAR const c_szTwoSlashes[]            =  TEXT("\\\\");
TCHAR const c_szPrinters[]              =  TEXT("Printers");
TCHAR const c_szPrintersDefIcon[]       =  TEXT("Printers\\%s\\DefaultIcon");
TCHAR const c_szNewLine[]               =  TEXT("\r\n");

BOOL IsAvoidAutoDefaultPrinter(LPCTSTR pszPrinter)
{
    return lstrcmp(pszPrinter, TEXT("Fax")) == 0;
}

//---------------------------------------------------------------------------
//
// this implements IContextMenu via defcm.c for a printer object
//

BOOL Printer_WorkOnLine(LPCTSTR pszPrinter, BOOL fWorkOnLine)
{
    LPPRINTER_INFO_5 ppi5;
    BOOL bRet = FALSE;
    HANDLE hPrinter = Printer_OpenPrinterAdmin(pszPrinter);
    if (hPrinter)
    {
        ppi5 = (LPPRINTER_INFO_5)Printer_GetPrinterInfo(hPrinter, 5);
        if (ppi5)
        {
            if (fWorkOnLine)
                ppi5->Attributes &= ~PRINTER_ATTRIBUTE_WORK_OFFLINE;
            else
                ppi5->Attributes |= PRINTER_ATTRIBUTE_WORK_OFFLINE;

            bRet = SetPrinter(hPrinter, 5, (LPBYTE)ppi5, 0);
            LocalFree((HLOCAL)ppi5);
        }
        Printer_ClosePrinter(hPrinter);
    }

    return bRet;
}

TCHAR const c_szConfig[] =  TEXT("Config");

BOOL IsWinIniDefaultPrinter(LPCTSTR pszPrinter)
{
    BOOL bRet = FALSE;
    TCHAR szPrinterDefault[kPrinterBufMax];
    DWORD dwSize = ARRAYSIZE(szPrinterDefault);

    if(GetDefaultPrinter(szPrinterDefault, &dwSize))
    {
        bRet = lstrcmpi(szPrinterDefault, pszPrinter) == 0;
    }

    return bRet;
}

BOOL IsDefaultPrinter(LPCTSTR pszPrinter, DWORD dwAttributesHint)
{
    return (dwAttributesHint & PRINTER_ATTRIBUTE_DEFAULT) ||
            IsWinIniDefaultPrinter(pszPrinter);
}

// more win.ini uglyness
BOOL IsPrinterInstalled(LPCTSTR pszPrinter)
{
    TCHAR szScratch[2];
    return GetProfileString(TEXT("Devices"), pszPrinter, TEXT(""), szScratch, ARRAYSIZE(szScratch));
}

BOOL IsRedirectedPort(LPCTSTR pszPortName)
{
    if (!pszPortName || lstrlen(pszPortName) < 2)
    {
        return FALSE;
    }
    else
    {
        return (*(pszPortName+0) == TEXT('\\')) && (*(pszPortName+1) == TEXT('\\'));
    }
}

void CPrinterFolder::_MergeMenu(LPQCMINFO pqcm, LPCTSTR pszPrinter)
{
    INT idCmdFirst = pqcm->idCmdFirst;

    //
    // pszPrinter may be the share name of a printer rather than
    // the "real" printer name.  Use the real printer name instead,
    // which is returned from GetPrinter().
    //
    // These three only valid if pData != NULL.
    //
    LPCTSTR pszRealPrinterName;
    DWORD dwAttributes;
    DWORD dwStatus;
    PFOLDER_PRINTER_DATA pData = NULL;
    HMENU hmenuRunAs = NULL;
    BOOL bRemoveOffline = FALSE;

    TCHAR szFullPrinter[MAXNAMELENBUFFER];
    TCHAR szMenuText[255];

    // Insert verbs
    CDefFolderMenu_MergeMenu(HINST_THISDLL, MENU_PRINTOBJ_VERBS, 0, pqcm);

    // find the "Run as..." menu (if there is one) and update it in sync
    // with the main menu.
    MENUITEMINFO mii = {0};
    mii.cbSize = sizeof(mii);
    mii.fMask = MIIM_SUBMENU;
    if (GetMenuItemInfo(pqcm->hmenu, idCmdFirst + FSIDM_RUNAS, MF_BYCOMMAND, &mii))
    {
        hmenuRunAs = mii.hSubMenu;
    }

    if (pszPrinter && GetFolder())
    {
        pData = (PFOLDER_PRINTER_DATA)Printer_FolderGetPrinter(GetFolder(), pszPrinter);
        if (pData)
        {
            _BuildPrinterName(szFullPrinter, NULL, ((PFOLDER_PRINTER_DATA)pData)->pName);
            pszRealPrinterName = szFullPrinter;
            dwStatus = ((PFOLDER_PRINTER_DATA)pData)->Status;
            dwAttributes = ((PFOLDER_PRINTER_DATA)pData)->Attributes;
        }
    }

    // Remove document defaults if it's a remote print folder.
    // This command should be removed from the context menu independently
    // on whether we have mutiple selection or not - i.e. pData.
    if (GetServer())
    {
        DeleteMenu(pqcm->hmenu, idCmdFirst + FSIDM_DOCUMENTDEFAULTS, MF_BYCOMMAND);
    }

    // disable/remove/rename verbs
    if (pData)
    {
        if (dwStatus & PRINTER_STATUS_PAUSED)
        {
            MENUITEMINFO mii;

            // we need to change the menu text to "Resume Printer" anc change the command ID
            LoadString(HINST_THISDLL, IDS_RESUMEPRINTER, szMenuText, ARRAYSIZE(szMenuText));
            mii.cbSize = sizeof(MENUITEMINFO);
            mii.fMask = MIIM_STRING | MIIM_ID;
            mii.dwTypeData = szMenuText;
            mii.wID = idCmdFirst + FSIDM_RESUMEPRN;
            SetMenuItemInfo(pqcm->hmenu, idCmdFirst + FSIDM_PAUSEPRN, MF_BYCOMMAND, &mii);

            if (hmenuRunAs)
            {
                mii.wID = idCmdFirst + FSIDM_RUNAS_RESUMEPRN;
                SetMenuItemInfo(hmenuRunAs, idCmdFirst + FSIDM_RUNAS_PAUSEPRN, MF_BYCOMMAND, &mii);
            }
        }

        if (0 == pData->cJobs)
        {
            // delete "Cancel All Documents" command if there are no any jobs in the queue
            DeleteMenu(pqcm->hmenu, idCmdFirst + FSIDM_PURGEPRN, MF_BYCOMMAND);
            if (hmenuRunAs)
            {
                DeleteMenu(hmenuRunAs, idCmdFirst + FSIDM_RUNAS_PURGEPRN, MF_BYCOMMAND);
            }
        }

        // Remove default printer if it's a remote print folder.
        if (GetServer() || IsDefaultPrinter(pszRealPrinterName, dwAttributes))
        {
            DeleteMenu(pqcm->hmenu, idCmdFirst + FSIDM_SETDEFAULTPRN, MF_BYCOMMAND);
        }

        // Check whether the printer is already installed. If it
        // is, remove the option to install it.

        if (IsPrinterInstalled(pszRealPrinterName))
        {
            DeleteMenu(pqcm->hmenu, idCmdFirst + FSIDM_NETPRN_INSTALL, MF_BYCOMMAND);
        }

        // Remove Delete if it is a network printer but not a masq printer
        // or a down level print server (SMB connection)
        //
        // can't delete printer connections as another user (they are per user)
        DWORD dwSpoolerVersion = SpoolerVersion();

        if ((dwAttributes & PRINTER_ATTRIBUTE_NETWORK) || (dwSpoolerVersion <= 2))
        {
            if (hmenuRunAs && !(dwAttributes & PRINTER_ATTRIBUTE_LOCAL))
            {
                DeleteMenu(hmenuRunAs, idCmdFirst + FSIDM_RUNAS_DELETE, MF_BYCOMMAND);
            }
        }

        // Remove work on/off-line if any of the following is met
        //  - remote print folder
        //  - network printer (including masq printer)
        //  - down level print server

        // Remove work offline if it's a redirected port printer
        // But we may show online command if a the printer is currently offline
        if (IsRedirectedPort(pData->pPortName))
        {
            bRemoveOffline = TRUE;
        }

        if (GetServer() ||
            (dwAttributes & PRINTER_ATTRIBUTE_NETWORK) ||
            (dwSpoolerVersion <= 2))
        {
            bRemoveOffline = TRUE;
        }
        else if (dwAttributes & PRINTER_ATTRIBUTE_WORK_OFFLINE)
        {
            MENUITEMINFO mii;

            // we need to change the menu text to "Use Printer Online" anc change the command ID
            LoadString(HINST_THISDLL, IDS_WORKONLINE, szMenuText, ARRAYSIZE(szMenuText));
            mii.cbSize = sizeof(MENUITEMINFO);
            mii.fMask = MIIM_STRING | MIIM_ID;
            mii.dwTypeData = szMenuText;
            mii.wID = idCmdFirst + FSIDM_WORKONLINE;
            SetMenuItemInfo(pqcm->hmenu, idCmdFirst + FSIDM_WORKOFFLINE, MF_BYCOMMAND, &mii);

            if (hmenuRunAs)
            {
                mii.wID = idCmdFirst + FSIDM_RUNAS_WORKONLINE;
                SetMenuItemInfo(hmenuRunAs, idCmdFirst + FSIDM_RUNAS_WORKOFFLINE, MF_BYCOMMAND, &mii);
            }

            bRemoveOffline = FALSE;
        }
    }
    else
    {
        // we have multiple printers selected
        if (!GetServer())
        {
            // if we are in the local printer's folder, do not display the "Connect..."
            // verb for the multiple selection case...
            DeleteMenu(pqcm->hmenu, idCmdFirst + FSIDM_NETPRN_INSTALL, MF_BYCOMMAND);
        }

        DeleteMenu(pqcm->hmenu, idCmdFirst + FSIDM_SETDEFAULTPRN, MF_BYCOMMAND);

        DeleteMenu(pqcm->hmenu, idCmdFirst + FSIDM_PAUSEPRN, MF_BYCOMMAND);
        if (hmenuRunAs)
        {
            DeleteMenu(hmenuRunAs, idCmdFirst + FSIDM_RUNAS_PAUSEPRN, MF_BYCOMMAND);
        }

        bRemoveOffline = TRUE;
    }

    if (bRemoveOffline)
    {
        DeleteMenu(pqcm->hmenu, idCmdFirst + FSIDM_WORKOFFLINE, MF_BYCOMMAND);
        if (hmenuRunAs)
        {
            DeleteMenu(hmenuRunAs, idCmdFirst + FSIDM_RUNAS_WORKOFFLINE, MF_BYCOMMAND);
        }
    }

    if (hmenuRunAs)
    {
        _SHPrettyMenu(hmenuRunAs);
    }

    if (pData)
    {
        LocalFree((HLOCAL)pData);
    }
}

//
// All string parsing functions should be localized here.
//

void Printer_SplitFullName(LPTSTR pszScratch, LPCTSTR pszFullName, LPCTSTR *ppszServer, LPCTSTR *ppszPrinter)

/*++

    Splits a fully qualified printer connection name into server and
    printer name parts.

Arguments:

    pszScratch - Scratch buffer used to store output strings.  Must
        be MAXNAMELENBUFFER in size.

    pszFullName - Input name of a printer.  If it is a printer
        connection (\\server\printer), then we will split it.  If
        it is a true local printer (not a masq) then the server is
        szNULL.

    ppszServer - Receives pointer to the server string.  If it is a
        local printer, szNULL is returned.

    ppszPrinter - Receives a pointer to the printer string.  OPTIONAL

Return Value:

--*/

{
    LPTSTR pszPrinter;

    lstrcpyn(pszScratch, pszFullName, MAXNAMELENBUFFER);

    if (pszFullName[0] != TEXT('\\') || pszFullName[1] != TEXT('\\'))
    {
        //
        // Set *ppszServer to szNULL since it's the local machine.
        //
        *ppszServer = szNULL;
        pszPrinter = pszScratch;
    }
    else
    {
        *ppszServer = pszScratch;
        pszPrinter = StrChr(*ppszServer + 2, TEXT('\\'));

        if (!pszPrinter)
        {
            //
            // We've encountered a printer called "\\server"
            // (only two backslashes in the string).  We'll treat
            // it as a local printer.  We should never hit this,
            // but the spooler doesn't enforce this.  We won't
            // format the string.  Server is local, so set to szNULL.
            //
            pszPrinter = pszScratch;
            *ppszServer = szNULL;
        }
        else
        {
            //
            // We found the third backslash; null terminate our
            // copy and set bRemote TRUE to format the string.
            //
            *pszPrinter++ = 0;
        }
    }

    if (ppszPrinter)
    {
        *ppszPrinter = pszPrinter;
    }
}

BOOL Printer_CheckShowFolder(LPCTSTR pszMachine)
{
    HANDLE hServer = Printer_OpenPrinter(pszMachine);
    if (hServer)
    {
        Printer_ClosePrinter(hServer);
        return TRUE;
    }
    return FALSE;
}

//
// Routine to tack on the specified string with some formating
// to the existing infotip string.  If there was a previous string,
// then we also insert a newline.
//
HRESULT _FormatInfoTip(LPTSTR *ppszText, UINT idFmt, LPCTSTR pszBuf)
{
    // If no string was returned, then nothing to do, and we should
    // return success
    if (*pszBuf)
    {
        TCHAR szFmt[MAX_PATH];
        LoadString(HINST_THISDLL, idFmt, szFmt, ARRAYSIZE(szFmt));

        // Note: This calculation only works because we assume
        // all the format strings will contain string specifiers.
        UINT uLen = (*ppszText ? lstrlen(*ppszText) : 0) +
               lstrlen(szFmt) + lstrlen(pszBuf) +
               (*ppszText ? lstrlen(c_szNewLine) : 0) + 1;

        LPTSTR pszText = (TCHAR *)SHAlloc(uLen * sizeof(*pszText));
        if (pszText)
        {
            *pszText = 0;

            if (*ppszText)
            {
                lstrcat(pszText, *ppszText);
                lstrcat(pszText, c_szNewLine);
            }

            uLen = lstrlen(pszText);

            wsprintf(pszText+uLen, szFmt, pszBuf);

            if (*ppszText)
                SHFree(*ppszText);

            *ppszText = pszText;
        }
    }

    return S_OK;
}

LPTSTR CPrinterFolder::_ItemName(LPCIDPRINTER pidp, LPTSTR pszName, UINT cch)
{
    ualstrcpyn(pszName, pidp->cName, cch);
    return pszName;
}

BOOL CPrinterFolder::_IsAddPrinter(LPCIDPRINTER pidp)
{
    TCHAR szPrinter[MAXNAMELENBUFFER];
    return 0 == lstrcmp(c_szNewObject, _ItemName(pidp, szPrinter, ARRAYSIZE(szPrinter)));
}

/*++
    Parses an unaligned partial printer name and printer shell folder
    into a fullly qualified printer name, and pointer to aligned printer
    name.

Arguments:

    pszFullPrinter - Buffer to receive fully qualified printer name
        Must be MAXNAMELENBUFFER is size.

    pidp - Optional pass in the pidl to allow us to try to handle cases where maybe an
        old style printer pidl was passed in.

    pszPrinter - Unaligned partial (local) printer name.

Return Value:

    LPCTSTR pointer to aligned partal (local) printer name.
--*/
LPCTSTR CPrinterFolder::_BuildPrinterName(LPTSTR pszFullPrinter, LPCIDPRINTER pidp, LPCTSTR pszPrinter)
{
    UINT cchLen = 0;

    if (GetServer())
    {
        ASSERT(!pszPrinter || (lstrlen(pszPrinter) < MAXNAMELEN));

        cchLen = wsprintf(pszFullPrinter, TEXT("%s\\"), GetServer());
    }

    if (pidp)
    {
        LPCIDPRINTER pidlprint = (LPCIDPRINTER) pidp;
        if (pidlprint->cb >= sizeof(DWORD) + FIELD_OFFSET(IDPRINTER, dwMagic) &&
            (pidlprint->dwMagic == PRINTER_MAGIC))
        {
            _ItemName(pidlprint, &pszFullPrinter[cchLen], MAXNAMELEN);
        }
        else
        {
            // Win95 form...
            SHAnsiToTChar(((LPW95IDPRINTER)pidp)->cName, &pszFullPrinter[cchLen], MAXNAMELEN);
        }
    }
    else
        lstrcpyn(&pszFullPrinter[cchLen], pszPrinter, MAXNAMELEN);

    ASSERT(lstrlen(pszFullPrinter) < MAXNAMELENBUFFER);

    return pszFullPrinter + cchLen;
}

/*++
    Check whether the printer is a local printer by looking at
    the name for the "\\localmachine\" prefix or no server prefix.

    This is a HACK: we should check by printer attributes, but when
    it's too costly or impossible (e.g., if the printer connection
    no longer exists), then we use this routine.

    Note: this only works for WINNT since the WINNT spooler forces
    printer connections to be prefixed with "\\server\."  Win9x
    allows the user to rename the printer connection to any arbitrary
    name.

    We determine if it's a masq  printer by looking for the
    weird format "\\localserver\\\remoteserver\printer."

Arguments:

    pszPrinter - Printer name.

    ppszLocal - Returns local name only if the printer is a local printer.
        (May be network and local if it's a masq printer.)

Return Value:

    TRUE: it's a network printer (true or masq).

    FALSE: it's a local printer.

--*/

BOOL Printer_CheckNetworkPrinterByName(LPCTSTR pszPrinter, LPCTSTR* ppszLocal)
{
    BOOL bNetwork = FALSE;
    LPCTSTR pszLocal = NULL;

    if (pszPrinter[0] == TEXT('\\') && pszPrinter[1] == TEXT('\\'))
    {
        TCHAR szComputer[MAX_COMPUTERNAME_LENGTH+1];
        DWORD cchComputer = ARRAYSIZE(szComputer);

        bNetwork = TRUE;
        pszLocal = NULL;

        //
        // Check if it's a masq printer.  If it has the format
        // \\localserver\\\server\printer then it's a masq case.
        //
        if (GetComputerName(szComputer, &cchComputer))
        {
            if (IntlStrEqNI(&pszPrinter[2], szComputer, cchComputer) &&
                pszPrinter[cchComputer] == TEXT('\\'))
            {
                if (pszPrinter[cchComputer+1] == TEXT('\\') &&
                    pszPrinter[cchComputer+2] == TEXT('\\'))
                {
                    //
                    // It's a masq printer.
                    //
                    pszLocal = &pszPrinter[cchComputer+1];
                }
            }
        }
    }
    else
    {
        // It's a local printer.
        pszLocal = pszPrinter;
    }

    if (ppszLocal)
    {
        *ppszLocal = pszLocal;
    }
    return bNetwork;
}

/*++
    Purges the specified printer, and prompting the user if
    they are really sure they want to purge the deviece.   It is
    kind of an extreme action to cancel all the documents on
    the printer.

    psf - pointer to shell folder
    hwnd - handle to view window
    pszFullPrinter - Fully qualified printer name.
    uAction - action to execute.

Return Value:

    TRUE: printer was purged successfully or the user choose to cancel
    the action, FALSE: an error occurred attempting to purge the device.

--*/
BOOL CPrinterFolder::_PurgePrinter(HWND hwnd, LPCTSTR pszFullPrinter, UINT uAction, BOOL bQuietMode)
{
    BOOL                    bRetval     = FALSE;
    LPTSTR                  pszRet      = NULL;
    LPCTSTR                 pszPrinter  = NULL;
    LPCTSTR                 pszServer   = NULL;
    TCHAR                   szTemp[MAXNAMELENBUFFER] = {0};
    BOOL                    bPurge = TRUE;

    if (!bQuietMode)
    {
        // We need to break up the full printer name in its components.
        // in order to construct the display name string.
        Printer_SplitFullName(szTemp, pszFullPrinter, &pszServer, &pszPrinter);

        // If there is a server name then construct a friendly printer name.
        if (pszServer && *pszServer)
        {
            pszRet = ShellConstructMessageString(HINST_THISDLL,
                                                  MAKEINTRESOURCE(IDS_DSPTEMPLATE_WITH_ON),
                                                  &pszServer[2],
                                                  pszPrinter);
            pszPrinter = pszRet;
        }

        // If we are referring to a local printer or shell construct message
        // sting failed then just use the full printer name in the warning
        // message.
        if (!pszRet)
        {
            pszPrinter = pszFullPrinter;
        }

        // Ask the user if they are sure they want to cancel all documents.
        if (IDYES == ShellMessageBox(HINST_THISDLL, hwnd,
                             MAKEINTRESOURCE(IDS_SUREPURGE), MAKEINTRESOURCE(IDS_PRINTERS),
                             MB_YESNO | MB_ICONQUESTION, pszPrinter))
        {
            bPurge = TRUE;
        }
        else
        {
            bPurge = FALSE;
        }
    }

    // invoke the purge command
    bRetval = bPurge ? Printer_ModifyPrinter(pszFullPrinter, uAction) : TRUE;

    if (pszRet)
    {
        LocalFree(pszRet);
    }

    return bRetval;
}

HRESULT CPrinterFolder::_InvokeCommand(HWND hwnd, LPCIDPRINTER pidp, WPARAM wParam, LPARAM lParam,
                              BOOL *pfChooseNewDefault)
{
    HRESULT hr = S_OK;
    BOOL bNewObject = _IsAddPrinter(pidp);
    LPCTSTR pszPrinter;
    LPCTSTR pszFullPrinter;

    //
    // If it's a remote machine, prepend server name.
    //
    TCHAR szFullPrinter[MAXNAMELENBUFFER];

    if (bNewObject)
    {
        pszFullPrinter = pszPrinter = c_szNewObject;
    }
    else
    {
        pszPrinter = _BuildPrinterName(szFullPrinter, pidp, NULL);
        pszFullPrinter = szFullPrinter;
    }

    switch(wParam)
    {
        case FSIDM_RUNAS_SHARING:
        case FSIDM_RUNAS_OPENPRN:
        case FSIDM_RUNAS_RESUMEPRN:
        case FSIDM_RUNAS_PAUSEPRN:
        case FSIDM_RUNAS_WORKONLINE:
        case FSIDM_RUNAS_WORKOFFLINE:
        case FSIDM_RUNAS_PURGEPRN:
        case FSIDM_RUNAS_DELETE:
        case FSIDM_RUNAS_PROPERTIES:
            {
                // handle all "Run As..." commands here
                hr = _InvokeCommandRunAs(hwnd, pidp, wParam, lParam, pfChooseNewDefault);
            }
            break;

    case FSIDM_OPENPRN:
        SHInvokePrinterCommand(hwnd, PRINTACTION_OPEN, pszFullPrinter, GetServer(), FALSE);
        break;

    case FSIDM_ADDPRINTERWIZARD:
        if (NULL == GetServer() || GetAdminAccess())
        {
            // This is the local printers folder or it is the remote printers folder, but you have
            // admin access to to the remote machine - go ahead.
            SHInvokePrinterCommand(hwnd, PRINTACTION_OPEN, pszFullPrinter, GetServer(), FALSE);
        }
        else
        {
            // This is the remote printers folder and the user don't have the necessary access to install
            // a printer - then ask to run as different user.
            if (IDYES == ShellMessageBox(HINST_THISDLL, hwnd, MAKEINTRESOURCE(IDS_ADDPRINTERTRYRUNAS),
                MAKEINTRESOURCE(IDS_PRINTERS), MB_YESNO|MB_ICONQUESTION, GetServer()))
            {
                _InvokeCommandRunAs(hwnd, pidp, FSIDM_RUNAS_ADDPRN, lParam, pfChooseNewDefault);
            }
        }
        break;

    case FSIDM_RUNAS_ADDPRN:
        if (bNewObject)
        {
            _InvokeCommandRunAs(hwnd, pidp, FSIDM_RUNAS_ADDPRN, lParam, pfChooseNewDefault);
        }
        break;

    case FSIDM_DOCUMENTDEFAULTS:
        if (!bNewObject)
        {
            SHInvokePrinterCommand(hwnd, PRINTACTION_DOCUMENTDEFAULTS, pszFullPrinter, NULL, 0);
        }
        break;

    case FSIDM_SHARING:
    case DFM_CMD_PROPERTIES:

        if (!bNewObject)
        {
            SHInvokePrinterCommand(hwnd, PRINTACTION_PROPERTIES, pszFullPrinter,
                                 wParam == FSIDM_SHARING ?
                                     (LPCTSTR)PRINTER_SHARING_PAGE :
                                     (LPCTSTR)lParam, FALSE);
        }
        break;

    case DFM_CMD_DELETE:
        if (!bNewObject &&
            IDYES == CallPrinterCopyHooks(hwnd, PO_DELETE,
                0, pszFullPrinter, 0, NULL, 0))
        {
            BOOL bNukedDefault = FALSE;
            DWORD dwAttributes = 0;

            LPCTSTR pszPrinterCheck = pszFullPrinter;
            PFOLDER_PRINTER_DATA pData = (PFOLDER_PRINTER_DATA)Printer_FolderGetPrinter(GetFolder(), pszFullPrinter);
            if (pData)
            {
                dwAttributes = pData->Attributes;
                pszPrinterCheck = pData->pName;
            }

            if (GetServer() == NULL)
            {
                // this is a local print folder then
                // we need to check if we're deleting the default printer.
                bNukedDefault = IsDefaultPrinter(pszPrinterCheck, dwAttributes);
            }

            if (pData)
                LocalFree((HLOCAL)pData);

            BOOL fSuccess = Printers_DeletePrinter(hwnd, pszPrinter, dwAttributes, GetServer(), (BOOL)lParam);
            // if so, make another one the default
            if (bNukedDefault && fSuccess && pfChooseNewDefault)
            {
                // don't choose in the middle of deletion,
                // or we might delete the "default" again.
                *pfChooseNewDefault = TRUE;
            }
        }
        break;

    case FSIDM_SETDEFAULTPRN:
        Printer_SetAsDefault(pszFullPrinter);
        break;

    case FSIDM_PAUSEPRN:
        if (!Printer_ModifyPrinter(pszFullPrinter, PRINTER_CONTROL_PAUSE))
            goto WarnOnError;
        break;

    case FSIDM_RESUMEPRN:
        if (!Printer_ModifyPrinter(pszFullPrinter, PRINTER_CONTROL_RESUME))
            goto WarnOnError;
        break;

    case FSIDM_PURGEPRN:
        if (!bNewObject)
        {
            if (!_PurgePrinter(hwnd, pszFullPrinter, PRINTER_CONTROL_PURGE, (BOOL)lParam))
            {
WarnOnError:
                // show an appropriate error message based on the last error
                ShowErrorMessageSC(NULL, NULL, hwnd, NULL, NULL, MB_OK|MB_ICONEXCLAMATION, GetLastError());
            }
        }
        break;

    case FSIDM_NETPRN_INSTALL:
        {
            SHInvokePrinterCommand(hwnd, PRINTACTION_NETINSTALL, pszFullPrinter, NULL, FALSE);
        }
        break;

    case FSIDM_WORKONLINE:
        if (!Printer_WorkOnLine(pszFullPrinter, TRUE))
        {
            // show an appropriate error message based on the last error
            ShowErrorMessageSC(NULL, NULL, hwnd, NULL, NULL, MB_OK|MB_ICONEXCLAMATION, GetLastError());
        }
        break;

    case FSIDM_WORKOFFLINE:
        if (!Printer_WorkOnLine(pszFullPrinter, FALSE))
        {
            // show an appropriate error message based on the last error
            ShowErrorMessageSC(NULL, NULL, hwnd, NULL, NULL, MB_OK|MB_ICONEXCLAMATION, GetLastError());
        }
        break;

    case DFM_CMD_LINK:
    case DFM_CMD_RENAME:
    case DFM_CMD_PASTE:
        // let defcm handle this too
        hr = S_FALSE;
        break;

    default:
        // GetAttributesOf doesn't set other SFGAO_ bits,
        // BUT accelerator keys will get unavailable menu items,
        // so we need to return failure here.
        hr = E_NOTIMPL;
        break;
    } // switch(wParam)

    return hr;
}

// implements a bunch of admin related "Run as..." command using printui.dll rundll32 interface.
HRESULT CPrinterFolder::_InvokeCommandRunAs(HWND hwnd, LPCIDPRINTER pidp, WPARAM wParam, LPARAM lParam,
                                            LPBOOL pfChooseNewDefault)
{
    HRESULT hr = S_OK;                      // assume success
    TCHAR szCmdLine[2048];                  // the command line buffer - 2K should be enough.
    BOOL bNewObject = FALSE;                // TRUE if "Add Printer" icon is selected
    TCHAR szFullPrinter[MAXNAMELENBUFFER];  // buffer to expand the full printer name i.e. \\server\printer
    LPCTSTR pszPrinter = NULL;              // only the printer name is here
    LPTSTR pszFullPrinter = NULL;           // the fully qulified printer name i.e. \\server\printer

    if (pidp)
    {
        bNewObject = _IsAddPrinter(pidp);
        if (!bNewObject)
        {
            pszPrinter = _BuildPrinterName(szFullPrinter, pidp, NULL);

            // insert backslashes for command parsing
            hr = InsertBackSlash(szFullPrinter, &pszFullPrinter);
            if (FAILED(hr))
            {
                goto Done;
            }
        }
    }

    // build the command line here
    szCmdLine[0] = 0;
    int iResult = -1;

    switch(wParam)
    {
    case FSIDM_RUNAS_SHARING:
        // bring up the properties dialog for this printer, positioned on the sharing page
        iResult = wnsprintf(szCmdLine, ARRAYSIZE(szCmdLine), TEXT("printui.dll,PrintUIEntry /p /t1 /n\"%s\""), pszFullPrinter);
        break;

    case FSIDM_RUNAS_ADDPRN:
        {
            // invoke the add printer wizard here
            iResult = (NULL == GetServer()) ?
                // local server - simply format the command
                wnsprintf(szCmdLine, ARRAYSIZE(szCmdLine), TEXT("%s"), TEXT("printui.dll,PrintUIEntry /il")):
                // remote server case - specify the machine name
                wnsprintf(szCmdLine, ARRAYSIZE(szCmdLine), TEXT("printui.dll,PrintUIEntry /il /c\"%s\""), GetServer());
        }
        break;

    case FSIDM_RUNAS_SVRPROP:
        {
            // bring up the server properties dialog for this print server
            iResult = (NULL == GetServer()) ?
                // local server - simply format the command
                wnsprintf(szCmdLine, ARRAYSIZE(szCmdLine), TEXT("%s"), TEXT("printui.dll,PrintUIEntry /s /t0")):
                // remote server case - specify the machine name
                wnsprintf(szCmdLine, ARRAYSIZE(szCmdLine), TEXT("printui.dll,PrintUIEntry /s /t0 /n\"%s\""), GetServer());
        }
        break;

    case FSIDM_RUNAS_OPENPRN:
        // bring up the print queue for this printer
        iResult = wnsprintf(szCmdLine, ARRAYSIZE(szCmdLine), TEXT("printui.dll,PrintUIEntry /o /n\"%s\""), pszFullPrinter);
        break;

    case FSIDM_RUNAS_RESUMEPRN:
        // pause the printer (assume ready)
        iResult = wnsprintf(szCmdLine, ARRAYSIZE(szCmdLine), TEXT("printui.dll,PrintUIEntry /Xs /n\"%s\" Status Resume"), pszFullPrinter);
        break;

    case FSIDM_RUNAS_PAUSEPRN:
        // resume a paused printer back to ready mode
        iResult = wnsprintf(szCmdLine, ARRAYSIZE(szCmdLine), TEXT("printui.dll,PrintUIEntry /Xs /n\"%s\" Status Pause"), pszFullPrinter);
        break;

    case FSIDM_RUNAS_WORKONLINE:
        // resume an offline printer back to online mode
        iResult = wnsprintf(szCmdLine, ARRAYSIZE(szCmdLine), TEXT("printui.dll,PrintUIEntry /Xs /n\"%s\" Attributes -WorkOffline"), pszFullPrinter);
        break;

    case FSIDM_RUNAS_WORKOFFLINE:
        // make the printer available offline (assume online mode)
        iResult = wnsprintf(szCmdLine, ARRAYSIZE(szCmdLine), TEXT("printui.dll,PrintUIEntry /Xs /n\"%s\" Attributes +WorkOffline"), pszFullPrinter);
        break;

    case FSIDM_RUNAS_PURGEPRN:
        {
            // cancel all documents pending to print on this printer
            LPTSTR pszMsg = ShellConstructMessageString(HINST_THISDLL, MAKEINTRESOURCE(IDS_SUREPURGE), szFullPrinter);

            if (pszMsg)
            {
                LPTSTR pszNewMsg = NULL;
                if (SUCCEEDED(hr = InsertBackSlash(pszMsg, &pszNewMsg)))
                {
                    iResult = wnsprintf(szCmdLine, ARRAYSIZE(szCmdLine), TEXT("printui.dll,PrintUIEntry /Mq\"%s\" /Xs /n\"%s\" Status Purge"), pszNewMsg, pszFullPrinter);
                    SHFree(pszNewMsg);
                }
                SHFree(pszMsg);
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }

        }
        break;

    case FSIDM_RUNAS_DELETE:
        {
            LPTSTR pszMsg = NULL;
            LPCTSTR pszP = NULL, pszS = NULL;
            TCHAR szBuffer[MAXNAMELENBUFFER] = {0};

            Printer_SplitFullName(szBuffer, pszPrinter, &pszS, &pszP);

            if (pszS && *pszS)
            {
                // this can be a masq printer - use the connection template in this case
                pszMsg = ShellConstructMessageString(HINST_THISDLL, MAKEINTRESOURCE(IDS_SUREDELETECONNECTION), 
                    pszP, SkipServerSlashes(pszS));
            }
            else
            {
                if (GetServer())
                {
                    // this is a local printer in the remote PF - use the remote PF template
                    pszMsg = ShellConstructMessageString(HINST_THISDLL, MAKEINTRESOURCE(IDS_SUREDELETEREMOTE), 
                        pszPrinter, SkipServerSlashes(GetServer()));
                }
                else
                {
                    // this is a local printer in the local PF - use the local PF template
                    pszMsg = ShellConstructMessageString(HINST_THISDLL, MAKEINTRESOURCE(IDS_SUREDELETE), pszPrinter);
                }
            }

            hr = pszMsg ? S_OK : E_OUTOFMEMORY;

            if (SUCCEEDED(hr))
            {
                LPTSTR pszNewMsg = NULL;
                if (SUCCEEDED(hr = InsertBackSlash(pszMsg, &pszNewMsg)))
                {
                    iResult = wnsprintf(szCmdLine, ARRAYSIZE(szCmdLine), TEXT("printui.dll,PrintUIEntry /Mq\"%s\" /dl /n\"%s\""), pszNewMsg, pszFullPrinter);
                    SHFree(pszNewMsg);
                }
                SHFree(pszMsg);
            }
        }
        break;

    case FSIDM_RUNAS_PROPERTIES:
        // bring up the properties dialog for this printer
        iResult = wnsprintf(szCmdLine, ARRAYSIZE(szCmdLine), TEXT("printui.dll,PrintUIEntry /p /t0 /n\"%s\""), pszFullPrinter);
        break;

    default:
        hr = E_NOTIMPL;
        break;
    }

    if (SUCCEEDED(hr) && -1 == iResult)
    {
        hr = E_NOTIMPL;
    }

    if (SUCCEEDED(hr))
    {
        // invokes the command as different user (run as) through rundll process...
        SHRunDLLProcess(hwnd, szCmdLine, SW_SHOWNORMAL, IDS_PRINTERS, TRUE);
    }

Done:
    // clean up
    SHFree(pszFullPrinter);
    return hr;
}


//
// The printer name specified in the _SHARE_INFO_502 structure in a call
// to NetShareAdd() which is in localspl.dll, contains a printer name that
// is expressed as \\server_name\printer_name,LocalsplOnly.  (',LocalsplOnly'
// post fix string was recently added for clustering support)  The server
// name prefix and the post fix string prevent the maximum printer name from
// being a valid size in a call to NetShareAdd(), because NetShareAdd() will
// only accept a maximum share name path of 256 characters, therefore the
// maximum printer name calculation has been changed to.  This change only
// applies to the windows nt spooler.  Because the remote printers folder can
// view non shared printers on downlevel print servers we cannot change the
// maxnamelen define to 220 this would break long printer name printers on
// downlevel print servers.
//
// max local printer name = max shared net path - (wack + wack + max server name + wack + comma + 'LocalsplOnly' + null)
// max local printer name = 256 - (1 + 1 + 13 + 1 + 1 + 12 + 1)
// max local printer name = 256 - 30
// max local printer name = 226 - 5 to round to some reasonable number
// max local printer name = 221
//
#define MAXLOCALNAMELEN 221

// returns 0 if this is a legal name
// returns the IDS_ string id of the error string for an illegal name
int _IllegalPrinterName(LPTSTR pszName)
{
    int fIllegal = 0;

    if (*pszName == 0)
    {
        fIllegal = IDS_PRTPROP_RENAME_NULL;
    }
    else if (lstrlen(pszName) >= MAXLOCALNAMELEN)
    {
        fIllegal = IDS_PRTPROP_RENAME_TOO_LONG;
    }
    else
    {
        while (*pszName         &&
               *pszName != TEXT('!')  &&
               *pszName != TEXT('\\') &&
               *pszName != TEXT(',')   )
        {
            pszName++ ;
        }
        if (*pszName)
        {
            fIllegal = IDS_PRTPROP_RENAME_BADCHARS;
        }
    }

    return fIllegal;
}

const struct
{
    UINT_PTR    uVerbID;
    LPCSTR      pszCanonicalName;
}
g_CanonicalVerbNames[] =
{
    {DFM_CMD_DELETE,        "delete"        },
    {DFM_CMD_MOVE,          "cut"           },
    {DFM_CMD_COPY,          "copy"          },
    {DFM_CMD_PASTE,         "paste"         },
    {DFM_CMD_LINK,          "link"          },
    {DFM_CMD_PROPERTIES,    "properties"    },
    {DFM_CMD_PASTELINK,     "pastelink"     },
    {DFM_CMD_RENAME,        "rename"        },
};

static LPCSTR _GetStandardCommandCanonicalName(UINT_PTR uVerbID)
{
    LPCSTR pszCmd = NULL;
    for (int i=0; i<ARRAYSIZE(g_CanonicalVerbNames); i++)
    {
        if (uVerbID == g_CanonicalVerbNames[i].uVerbID)
        {
            pszCmd = g_CanonicalVerbNames[i].pszCanonicalName;
            break;
        }
    }
    return pszCmd;
}

HRESULT CALLBACK CPrinterFolder::_DFMCallBack(IShellFolder *psf, HWND hwnd,
   IDataObject *pdo, UINT uMsg, WPARAM wParam, LPARAM lParam)

{

    CPrinterFolder* This;
    HRESULT hr = psf->QueryInterface(CLSID_Printers, (void**)&This);
    if (FAILED(hr))
        return hr;

    hr = E_INVALIDARG;
    if (pdo)
    {
        // let't split the selection into its components (printers and links)
        IDataObject *pdoP = NULL;
        IDataObject *pdoL = NULL;
        UINT uSelType = SEL_NONE;

        if (SUCCEEDED(hr = This->SplitSelection(pdo, &uSelType, &pdoP, &pdoL)))
        {
            if (pdoP)
            {
                // we have printer objects in the selection delegate the call to
                // _PrinterObjectsCallBack
                hr = This->_PrinterObjectsCallBack(hwnd, uSelType, pdoP, uMsg, wParam, lParam);
            }

            if (SUCCEEDED(hr) && pdoL && DFM_INVOKECOMMAND == uMsg)
            {
                // we have link objects. this can only happen if we have mixed selection
                // of print and link objects. we need to handle some of the commands through
                // printhood
                IShellFolder2* psfPrinthood = CPrintRoot_GetPSF();
                if (psfPrinthood)
                {
                    LPCSTR pszCmd = _GetStandardCommandCanonicalName(wParam);
                    hr = pszCmd ? SHInvokeCommandOnDataObject(hwnd, psfPrinthood, pdoL, 0, pszCmd) : E_NOTIMPL;
                }
            }
        }

        if (pdoP)
            pdoP->Release();

        if (pdoL)
            pdoL->Release();
    }

    This->Release();
    return hr;
}

HRESULT CPrinterFolder::_PrinterObjectsCallBack(HWND hwnd, UINT uSelType,
    IDataObject *pdo, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HRESULT hr = E_INVALIDARG;

    if (pdo)
    {
        STGMEDIUM medium;
        LPIDA pida = DataObj_GetHIDA(pdo, &medium);

        hr = E_OUTOFMEMORY;
        if (pida)
        {
            hr = S_OK;
            switch (uMsg)
            {
            case DFM_MERGECONTEXTMENU:
                //  returning S_FALSE indicates no need to use default verbs
                hr = S_FALSE;
                break;

            case DFM_MERGECONTEXTMENU_TOP:
            {
                // merge the printer commands in the context menu only if
                // there are no link objects in the selection
                if (0 == (SEL_LINK_ANY & uSelType))
                {
                    LPQCMINFO pqcm = (LPQCMINFO)lParam;
                    UINT idCmdBase = pqcm->idCmdFirst; // must be called before merge
                    UINT idRunAs =  FSIDM_RUNAS;

                    if (pida->cidl == 1 && _IsAddPrinter((LPCIDPRINTER)IDA_GetIDListPtr(pida, 0)))
                    {
                        // The only selected object is the "New Printer" thing

                        // insert verbs
                        CDefFolderMenu_MergeMenu(HINST_THISDLL, MENU_ADDPRINTER_OPEN_VERBS, 0, pqcm);

                        idRunAs = FSIDM_RUNAS_ADDPRN;
                    }
                    else
                    {
                        LPCTSTR pszFullPrinter = NULL;
                        TCHAR szFullPrinter[MAXNAMELENBUFFER];
                        // We're dealing with printer objects

                        if (!(wParam & CMF_DEFAULTONLY))
                        {
                            if (pida->cidl == 1)
                            {
                                LPIDPRINTER pidp = (LPIDPRINTER)IDA_GetIDListPtr(pida, 0);
                                if (pidp)
                                {
                                    _BuildPrinterName(szFullPrinter, pidp, NULL);
                                    pszFullPrinter = szFullPrinter;
                                }
                            }
                        }

                        _MergeMenu(pqcm, pszFullPrinter);
                    }

                    if (!(wParam & CMF_EXTENDEDVERBS) || (pida->cidl > 1))
                    {
                        // if the extended verbs are not enabled (shift key is not down) then
                        // delete the "Run as..." command(s).
                        DeleteMenu(pqcm->hmenu, idCmdBase + idRunAs, MF_BYCOMMAND);
                    }

                    SetMenuDefaultItem(pqcm->hmenu, 0, MF_BYPOSITION);
                }
                break;
            }

            case DFM_GETHELPTEXT:
            case DFM_GETHELPTEXTW:
            {
                // this is applicale only for our printer commands
                if (0 == (SEL_LINK_ANY & uSelType))
                {
                    int idCmd = LOWORD(wParam);
                    int cchMax = HIWORD(wParam);
                    LPBYTE pBuf = (LPBYTE)lParam;

                    if (FSIDM_RUNAS_FIRST < idCmd && idCmd < FSIDM_RUNAS_LAST)
                    {
                        // all runas commands have the same help text (FSIDM_RUNAS)
                        idCmd = FSIDM_RUNAS;
                    }

                    if (uMsg == DFM_GETHELPTEXTW)
                        LoadStringW(HINST_THISDLL, idCmd + IDS_MH_FSIDM_FIRST,
                                    (LPWSTR)pBuf, cchMax);
                    else
                        LoadStringA(HINST_THISDLL, idCmd + IDS_MH_FSIDM_FIRST,
                                    (LPSTR)pBuf, cchMax);

                    break;
                }
            }

            case DFM_INVOKECOMMAND:
            {
                BOOL fChooseNewDefault = FALSE;

                // Assume not quiet mode
                lParam = 0;
                switch (wParam)
                {
                    case (DFM_CMD_DELETE):
                    case (FSIDM_PURGEPRN):
                    {
                        UINT uMsgID = DFM_CMD_DELETE == wParam ? IDS_SUREDELETEMULTIPLE :
                                      FSIDM_PURGEPRN == wParam ? IDS_SUREPURGEMULTIPLE : 0;

                        if (uMsgID && pida->cidl > 1)
                        {
                            // delete multiple printers. ask the user once for confirmation and then delete
                            // all the selected printers quietly
                            if (ShellMessageBox(HINST_THISDLL, hwnd, MAKEINTRESOURCE(uMsgID),
                                MAKEINTRESOURCE(IDS_PRINTERS), MB_YESNO|MB_ICONQUESTION)
                                != IDYES)
                            {
                                goto Bail;
                            }

                            // Turn on the quiet mode
                            lParam = 1;
                        }
                    }
                    break;
                }

                for (int i = pida->cidl - 1; i >= 0; i--)
                {
                    LPIDPRINTER pidp = (LPIDPRINTER)IDA_GetIDListPtr(pida, i);

                    hr = _InvokeCommand(hwnd, pidp, wParam, lParam, &fChooseNewDefault);

                    if (hr != S_OK)
                        goto Bail;
                }

                if (fChooseNewDefault)
                    Printers_ChooseNewDefault(hwnd);

                break;
            } // case DFM_INVOKECOMMAND

            default:
                hr = E_NOTIMPL;
                break;
            } // switch (uMsg)

Bail:
            HIDA_ReleaseStgMedium(pida, &medium);
        }
    }

    return hr;
}

//
// IContextMenuCB::Callback entry for the background menu (right click backgrond of folder)
//
HRESULT CPrinterFolder::CallBack(IShellFolder *psf, HWND hwnd, IDataObject *pdo,
                                  UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HRESULT hr = S_OK;
    LPQCMINFO pqcm;
    UINT idCmdBase;

    switch(uMsg)
    {
        case DFM_MERGECONTEXTMENU:
            //  returning S_FALSE indicates no need to use default verbs
            hr = S_FALSE;
            break;

        case DFM_MERGECONTEXTMENU_TOP:
        {
            pqcm = (LPQCMINFO)lParam;
            idCmdBase = pqcm->idCmdFirst; // must be called before merge
            CDefFolderMenu_MergeMenu(HINST_THISDLL, POPUP_DRIVES_PRINTERS, 0, pqcm);

            if (!(wParam & CMF_EXTENDEDVERBS))
            {
                // if the extended verbs are not enabled (shift key is not down) then
                // delete the "Run as..." command(s).
                DeleteMenu(pqcm->hmenu, idCmdBase + FSIDM_RUNAS, MF_BYCOMMAND);
            }

            // fax related commands are applicable only for the local printers folder
            UINT_PTR uCmd;
            if (GetServer() || FAILED(_GetFaxCommand(&uCmd)))
            {
                uCmd = 0;
            }

            UINT_PTR arrFaxCmds[] = 
            { 
                FSIDM_SETUPFAXING, 
                FSIDM_CREATELOCALFAX, 
                FSIDM_SENDFAXWIZARD
            };

            // all fax commands are mutually exclusive - only the one returned from 
            // _GetFaxCommand is applicable. 

            for (INT_PTR i = 0; i < ARRAYSIZE(arrFaxCmds); i++)
            {
                if (uCmd != arrFaxCmds[i])
                {
                    DeleteMenu(pqcm->hmenu, idCmdBase + arrFaxCmds[i], MF_BYCOMMAND);
                }
            }
        }
        break;

    case DFM_GETHELPTEXT:
    case DFM_GETHELPTEXTW:
        {
            int idCmd = LOWORD(wParam);
            int cchMax = HIWORD(wParam);

            if (FSIDM_RUNAS_FIRST < idCmd && idCmd < FSIDM_RUNAS_LAST)
            {
                // all runas commands have the same help text (FSIDM_RUNAS)
                idCmd = FSIDM_RUNAS;
            }

            if (DFM_GETHELPTEXT == uMsg)
            {
                LoadStringA(HINST_THISDLL, idCmd + IDS_MH_FSIDM_FIRST, (LPSTR)lParam, cchMax);
            }
            else
            {
                LoadStringW(HINST_THISDLL, idCmd + IDS_MH_FSIDM_FIRST, (LPWSTR)lParam, cchMax);
            }
        }
        break;

    case DFM_INVOKECOMMAND:
        switch (wParam)
        {
        case FSIDM_CONNECT_PRN:
            SHNetConnectionDialog(hwnd, NULL, RESOURCETYPE_PRINT);
            break;

        case FSIDM_DISCONNECT_PRN:
            WNetDisconnectDialog(hwnd, RESOURCETYPE_PRINT);
            break;

        case FSIDM_ADDPRINTERWIZARD:
            if (NULL == GetServer() || GetAdminAccess())
            {
                // This is the local printers folder or it is the remote printers folder, but you have
                // admin access to to the remote machine - go ahead.
                SHInvokePrinterCommand(hwnd, PRINTACTION_OPEN, c_szNewObject, GetServer(), FALSE);
            }
            else
            {
                // This is the remote printers folder and the user don't have the necessary access to install
                // a printer - then ask to run as different user.
                if (IDYES == ShellMessageBox(HINST_THISDLL, hwnd, MAKEINTRESOURCE(IDS_ADDPRINTERTRYRUNAS),
                    MAKEINTRESOURCE(IDS_PRINTERS), MB_YESNO|MB_ICONQUESTION, GetServer()))
                {
                    _InvokeCommandRunAs(hwnd, NULL, FSIDM_RUNAS_ADDPRN, lParam, NULL);
                }
            }
            break;

        case FSIDM_SERVERPROPERTIES:
            SHInvokePrinterCommand(hwnd, PRINTACTION_SERVERPROPERTIES,
                GetServer() ? GetServer() : TEXT(""), NULL, FALSE);
            break;

        case FSIDM_SENDFAXWIZARD:
            // just invoke faxsend.exe here
            ShellExecute(hwnd, TEXT("open"), FAX_SEND_IMAGE_NAME, TEXT(""), NULL, SW_SHOWNORMAL);
            break;

        case FSIDM_SETUPFAXING:
            // push the command in background
            SHQueueUserWorkItem(reinterpret_cast<LPTHREAD_START_ROUTINE>(_ThreadProc_InstallFaxService), 
                NULL, 0, 0, NULL, "shell32.dll", 0);
            break;

        case FSIDM_CREATELOCALFAX:
            // push the command in background
            SHQueueUserWorkItem(reinterpret_cast<LPTHREAD_START_ROUTINE>(_ThreadProc_InstallLocalFaxPrinter), 
                NULL, 0, 0, NULL, "shell32.dll", 0);
            break;

        case FSIDM_RUNAS_ADDPRN:
        case FSIDM_RUNAS_SVRPROP:
            {
                // handle all "Run As..." commands here
                hr = _InvokeCommandRunAs(hwnd, NULL, wParam, lParam, NULL);
            }
            break;

        default:
            // one of view menu items, use the default code.
            hr = S_FALSE;
            break;
        }
        break;

    default:
        hr = E_NOTIMPL;
        break;
    }

    return hr;
}


////////////////////////
// CPrintersEnum
////////////////////////

class CPrintersEnum: public CEnumIDListBase
{
public:
    // IEnumIDList
    STDMETHODIMP Next(ULONG celt, LPITEMIDLIST* ppidl, ULONG* pceltFetched);

    // CreateInstance
    static HRESULT CreateInstance(DWORD grfFlags, DWORD dwRemote, IEnumIDList* peunk, CPrinterFolder* ppsf, IEnumIDList **ppenum);

private:
    CPrintersEnum(DWORD grfFlags, DWORD dwRemote, IEnumIDList* peunk, CPrinterFolder* ppsf);
    virtual ~CPrintersEnum();

    DWORD _grfFlags;
    int _nLastFound;
    CPrinterFolder* _ppsf;
    PFOLDER_PRINTER_DATA _pPrinters;
    DWORD _dwNumPrinters;
    DWORD _dwRemote;
    IEnumIDList* _peunk;            // file system enumerator
};

// Flags for the dwRemote field
//

#define RMF_SHOWLINKS   0x00000001  // Hoodlinks need to be shown

CPrintersEnum::CPrintersEnum(DWORD grfFlags, DWORD dwRemote, IEnumIDList* peunk, CPrinterFolder* ppsf)
{
    _nLastFound = -1;
    _pPrinters = NULL;

    _grfFlags = grfFlags;
    _dwRemote = dwRemote;
    _peunk = peunk;
    _ppsf = ppsf;
}

CPrintersEnum::~CPrintersEnum()
{
    if (_pPrinters)
        LocalFree((HLOCAL)_pPrinters);

    // Release the link (filesystem) enumerator.
    if (_peunk)
        _peunk->Release();
}

//
// IEnumIDList
//

STDMETHODIMP CPrintersEnum::Next(ULONG celt, LPITEMIDLIST* ppidl, ULONG* pceltFetched)
{
    HRESULT hr = S_OK;

    if (pceltFetched)
        *pceltFetched = 0;

    // We don't do any form of folder

    if (!(_grfFlags & SHCONTF_NONFOLDERS))
    {
        return S_FALSE;
    }

    // Are we looking for the links right now?
    if (_dwRemote & RMF_SHOWLINKS)
    {
        // Yes, use the link (PrintHood folder) enumerator
        if (_peunk)
        {
            hr = _peunk->Next(1, ppidl, pceltFetched);
            if (hr == S_OK)
            {
                // Added link
                return S_OK;
            }
        }
        _dwRemote &= ~RMF_SHOWLINKS; // Done enumerating links
    }

    // Carry on with enumerating printers now
    ASSERT(_nLastFound >= 0 || _nLastFound == -1);

    if (_nLastFound == -1)
    {
        // check if refresh has been requested
        _ppsf->CheckToRefresh();

        // free up the memory if _pPrinters is not NULL
        if (_pPrinters)
        {
            LocalFree((HLOCAL)_pPrinters);
            _pPrinters = NULL;
        }

        // note that _pPrinters may be NULL if no printers are installed.
        _dwNumPrinters = _ppsf->GetFolder() ? Printers_FolderEnumPrinters(
            _ppsf->GetFolder(), (void**)&_pPrinters) : 0;

        if (S_FALSE != SHShouldShowWizards(_punkSite) && !SHRestricted(REST_NOPRINTERADD))
        {
            // special case the Add Printer Wizard.
            hr = _ppsf->_Parse(c_szNewObject, ppidl);
            goto Done;
        }

        // Not an admin, skip the add printer wizard and return the
        // first item.
        _nLastFound = 0;
    }

    if (_nLastFound >= (int)_dwNumPrinters)
        return S_FALSE;

    hr = _ppsf->_Parse(GetPrinterName(_pPrinters, _nLastFound), ppidl);

Done:

    if (SUCCEEDED(hr))
    {
        ++_nLastFound;
        if (pceltFetched)
            *pceltFetched = 1;
    }

    return hr;
}

// CreateInstance
HRESULT CPrintersEnum::CreateInstance(DWORD grfFlags, DWORD dwRemote, IEnumIDList *peunk, CPrinterFolder *ppsf, IEnumIDList **ppenum)
{
    HRESULT hr = E_INVALIDARG;
    if (ppenum && ppsf)
    {
        *ppenum = NULL;
        hr = E_OUTOFMEMORY;
        CPrintersEnum *pObj = new CPrintersEnum(grfFlags, dwRemote, peunk, ppsf);
        if (pObj)
        {
            hr = pObj->QueryInterface(IID_PPV_ARG(IEnumIDList, ppenum));
            pObj->Release();
        }
    }
    return hr;
}

//
// CPrinterFolder
//

CPrinterFolder::CPrinterFolder()
{
    _cRef = 1;
    _pszServer = NULL;
    _dwSpoolerVersion = -1;
    _pidl = NULL;

    _hFolder = NULL;
    _bAdminAccess = FALSE;
    _bReqRefresh = FALSE;
}

CPrinterFolder::~CPrinterFolder()
{
    if (_hFolder)
    {
        // unregister from the folder cache
        UnregisterPrintNotify(_pszServer, this, &_hFolder);
    }

    //
    // The pidl must be freed here!! (after unregister from PRUNTUI.DLL),
    // because if you move this code before the call to PRINTUI
    // serious race condition occurs. Have in mind that the interface which
    // is used for communication with PRINTUI is part this class and
    // and uses the pidl in its ProcessNotify(...) member
    //
    if (_pidl)
    {
        ILFree(_pidl);
    }

    if (_pszServer)
    {
        LocalFree(_pszServer);
    }

    // clear the PDO cache
    _WebviewCheckToUpdateDataObjectCache(NULL);

    // cleanup the slow webview data cache
    if (_dpaSlowWVDataCache)
    {
        _SlowWVDataCacheResetUnsafe();
        ASSERT(0 == _dpaSlowWVDataCache.GetPtrCount());
        _dpaSlowWVDataCache.Destroy();
    }
}


/*++

    Returns the printer status string in the privided
    buffer.

Arguments:

    pData - pointer to printer data, i.e. cache data
    pBuff - pointer to buffer where to return status string.
    uSize - size in characters of status buffer.

Return Value:

    pointer to printer status string.

--*/

LPCTSTR CPrinterFolder::GetStatusString(PFOLDER_PRINTER_DATA pData, LPTSTR pBuff, UINT uSize)
{
    LPCTSTR pszReturn = pBuff;
    DWORD dwStatus = pData->Status;

    *pBuff = 0;

    // HACK: Use this free bit for "Work Offline"
    // 99/03/30 #308785 vtan: compare the strings displayed. Adjust
    // for this hack from GetDetailsOf().
    if (pData->Attributes & PRINTER_ATTRIBUTE_WORK_OFFLINE)
        dwStatus |= PRINTER_HACK_WORK_OFFLINE;

    // If there is queue status value then convert the status id to a
    // readable status string.
    if (dwStatus)
    {
        Printer_BitsToString(dwStatus, IDS_PRQSTATUS_SEPARATOR, pBuff, uSize);
    }
    else
    {
        // If we do not have queue status string then the status of the queue
        // is 0 and assumed ready, display ready rather than an empty string.
        if (!pData->pStatus)
        {
            LoadString(HINST_THISDLL, IDS_PRN_INFOTIP_READY, pBuff, uSize);
        }
        else
        {
            // If we do not have a queue status value then we assume we
            // must have a queue status string.  Queue status strings
            // are cooked up string from printui to indicate pending
            // connection status. i.e. opening|retrying|unable to connect|etc.
            pszReturn = pData->pStatus;
        }
    }
    return pszReturn;
}

/*++
    Compares the printers display name for column sorting
    support.

Arguments:

    pName1 - pointer to unalligned printer name.
    pName2 - pointer to unalligned printer name.

Return Value:

    -1 = pName1 less than pName2
     0 = pName1 equal to pName2
     1 = pName1 greather than pName2

--*/

INT CPrinterFolder::GetCompareDisplayName(LPCTSTR pName1, LPCTSTR pName2)
{
    LPCTSTR pszServer = NULL;
    LPCTSTR pszPrinter = NULL;
    LPTSTR  pszRet2 = NULL;
    TCHAR   szTemp[MAXNAMELENBUFFER]    = {0};

    //
    // We need to break up the full printer name in its components.
    // in order to construct the display name string.
    //
    Printer_SplitFullName(szTemp, pName1, &pszServer, &pszPrinter);
    LPTSTR pszRet1 = ShellConstructMessageString(HINST_THISDLL, MAKEINTRESOURCE(IDS_DSPTEMPLATE_WITH_ON),
                                          &pszServer[2], pszPrinter);
    if (pszRet1)
    {
        Printer_SplitFullName(szTemp, pName2, &pszServer, &pszPrinter);
        pszRet2 = ShellConstructMessageString(HINST_THISDLL, MAKEINTRESOURCE(IDS_DSPTEMPLATE_WITH_ON),
                                              &pszServer[2], pszPrinter);

        if (pszRet2)
        {
            pName1 = pszRet1;
            pName2 = pszRet2;
        }
    }

    int iResult = lstrcmpi(pName1, pName2);

    if (pszRet1)
        LocalFree(pszRet1);

    if (pszRet2)
        LocalFree(pszRet2);

    return iResult;
}

/*++

    Compares printer column  data using the
    column index as a guide indicating which data to compare.

Arguments:

    psf   - pointer to the containter shell folder.
    pidp1 - pointer to unalligned printer name.
    pidp1 - pointer to unalligned printer name.
    iCol  - column index shich to sort on.

Return Value:

    -1 = pName1 less than pName2
     0 = pName1 equal to pName2
     1 = pName1 greather than pName2

--*/

INT CPrinterFolder::CompareData(LPCIDPRINTER pidp1, LPCIDPRINTER pidp2, LPARAM iCol)
{
    LPCTSTR pName1              = NULL;
    LPCTSTR pName2              = NULL;
    INT     iResult             = 0;
    TCHAR   szTemp1[MAX_PATH]   = {0};
    TCHAR   szTemp2[MAX_PATH]   = {0};
    BOOL    bDoStringCompare    = TRUE;

    // since the pidp's are UNALIGNED we need to copy the strings out.
    TCHAR   szName1[MAX_PATH];
    _ItemName(pidp1, szName1, ARRAYSIZE(szName1));
    TCHAR   szName2[MAX_PATH];
    _ItemName(pidp2, szName2, ARRAYSIZE(szName2));

    // There is no reason to hit the cache for the printer name.
    if ((iCol & SHCIDS_COLUMNMASK) == PRINTERS_ICOL_NAME)
    {
        return GetCompareDisplayName(szName1, szName2);
    }

    PFOLDER_PRINTER_DATA pData1 = (PFOLDER_PRINTER_DATA)Printer_FolderGetPrinter(GetFolder(), szName1);
    PFOLDER_PRINTER_DATA pData2 = (PFOLDER_PRINTER_DATA)Printer_FolderGetPrinter(GetFolder(), szName2);

    if (pData1 && pData2)
    {
        switch (iCol & SHCIDS_COLUMNMASK)
        {
        case PRINTERS_ICOL_QUEUESIZE:
            iResult = pData1->cJobs - pData2->cJobs;
            bDoStringCompare = FALSE;
            break;

        case PRINTERS_ICOL_STATUS:
            pName1 = GetStatusString(pData1, szTemp1, ARRAYSIZE(szTemp1));
            pName2 = GetStatusString(pData2, szTemp2, ARRAYSIZE(szTemp1));
            break;

        case PRINTERS_ICOL_COMMENT:
            pName1 = pData1->pComment;
            pName2 = pData2->pComment;
            break;

        case PRINTERS_ICOL_LOCATION:
            pName1 = pData1->pLocation;
            pName2 = pData2->pLocation;
            break;

        case PRINTERS_ICOL_MODEL:
            pName1 = pData1->pDriverName;
            pName2 = pData2->pDriverName;
            break;

        default:
            bDoStringCompare = FALSE;
            break;
        }

        if (bDoStringCompare)
        {
            if (!pName1)
                pName1 = TEXT("");

            if (!pName2)
                pName2 = TEXT("");

            TraceMsg(TF_GENERAL, "CPrinters_SF_CompareData %ws %ws", pName1, pName2);

            iResult = lstrcmpi(pName1, pName2);
        }
    }

    if (pData1)
        LocalFree((HLOCAL)pData1);

    if (pData2)
        LocalFree((HLOCAL)pData2);
    return iResult;
}

//
// Stolen almost verbatim from netviewx.c's CNetRoot_MakeStripToLikeKinds
//
// Takes a possibly-heterogenous pidl array, and strips out the pidls that
// don't match the requested type.  (If fPrinterObjects is TRUE, we're asking
// for printers pidls, otherwise we're asking for the filesystem/link
// objects.)  The return value is TRUE if we had to allocate a new array
// in which to return the reduced set of pidls (in which case the caller
// should free the array with LocalFree()), FALSE if we are returning the
// original array of pidls (in which case no cleanup is required).
//
BOOL CPrinterFolder::ReduceToLikeKinds(UINT *pcidl, LPCITEMIDLIST **papidl, BOOL fPrintObjects)
{
    LPITEMIDLIST *apidl = (LPITEMIDLIST*)*papidl;
    int cidl = *pcidl;

    int iidl;
    LPITEMIDLIST *apidlHomo;
    int cpidlHomo;

    for (iidl = 0; iidl < cidl; iidl++)
    {
        if ((HOOD_COL_PRINTER == _IDListType(apidl[iidl])) != fPrintObjects)
        {
            apidlHomo = (LPITEMIDLIST *)LocalAlloc(LPTR, sizeof(LPITEMIDLIST) * cidl);
            if (!apidlHomo)
                return FALSE;

            cpidlHomo = 0;
            for (iidl = 0; iidl < cidl; iidl++)
            {
                if ((HOOD_COL_PRINTER == _IDListType(apidl[iidl])) == fPrintObjects)
                    apidlHomo[cpidlHomo++] = apidl[iidl];
            }

            // Setup to use the stripped version of the pidl array...
            *pcidl = cpidlHomo;
            *papidl = (LPCITEMIDLIST*)apidlHomo;
            return TRUE;
        }
    }

    return FALSE;
}

DWORD CPrinterFolder::SpoolerVersion()
{
    CCSLock::Locker lock(_csLock);
    if (lock)
    {
        if (_dwSpoolerVersion == -1)
        {
            _dwSpoolerVersion = 0;

            HANDLE hServer = Printer_OpenPrinter(_pszServer);
            if (hServer)
            {
                DWORD dwNeeded = 0, dwType = REG_DWORD;
                GetPrinterData(hServer, TEXT("MajorVersion"), &dwType, (PBYTE)&_dwSpoolerVersion,
                                    sizeof(_dwSpoolerVersion), &dwNeeded);
                Printer_ClosePrinter(hServer);
            }
        }
    }
    else
    {
        // unable to enter the CS -- this can happen only in extremely low memory conditions!
        SetLastError(ERROR_OUTOFMEMORY);
    }
    return _dwSpoolerVersion;
}

void CPrinterFolder::CheckToRegisterNotify()
{
    CCSLock::Locker lock(_csLock);
    if (lock)
    {
        if (NULL == _hFolder && FAILED(RegisterPrintNotify(_pszServer, this, &_hFolder, &_bAdminAccess)))
        {
            // paranoia...
            ASSERT(NULL == _hFolder);
            _hFolder = NULL;
        }
    }
    else
    {
        // unable to enter the CS -- this can happen only in extremely low memory conditions!
        SetLastError(ERROR_OUTOFMEMORY);
    }
}

void CPrinterFolder::CheckToRefresh()
{
    if (_bReqRefresh)
    {
        // kick off a full refresh...
        _bReqRefresh = FALSE;
        bFolderRefresh(_hFolder, &_bAdminAccess);
    }
}

void CPrinterFolder::RequestRefresh()
{
    _bReqRefresh = TRUE;
}

HRESULT CPrinterFolder::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] =
    {
        QITABENT(CPrinterFolder, IShellFolder),
        QITABENTMULTI(CPrinterFolder, IShellFolder2, IShellFolder),
        QITABENT(CPrinterFolder, IPersist),
        QITABENTMULTI(CPrinterFolder, IPersistFolder, IPersist),
        QITABENTMULTI(CPrinterFolder, IPersistFolder2, IPersistFolder),
        QITABENT(CPrinterFolder, IShellIconOverlay),
        QITABENT(CPrinterFolder, IRemoteComputer),
        QITABENT(CPrinterFolder, IPrinterFolder),
        QITABENT(CPrinterFolder, IFolderNotify),
        QITABENT(CPrinterFolder, IContextMenuCB),
        { 0 },
    };

    HRESULT hr = QISearch(this, qit, riid, ppv);
    if (FAILED(hr))
    {
        // Internal only
        if (IsEqualGUID(riid, CLSID_Printers))
        {
            *ppv = (CPrinterFolder*)this;
            AddRef();
            hr = S_OK;
        }
    }

    return hr;
}

ULONG CPrinterFolder::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CPrinterFolder::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}

// IShellFolder2

STDMETHODIMP CPrinterFolder::BindToObject(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv)
{
    *ppv = NULL;
    return E_NOTIMPL;
}

STDMETHODIMP CPrinterFolder::BindToStorage(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv)
{
    return BindToObject(pidl, pbc, riid, ppv);
}

STDMETHODIMP CPrinterFolder::CompareIDs(LPARAM iCol, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    UNALIGNED IDPRINTER *pidp1 = (UNALIGNED IDPRINTER*)pidl1;
    UNALIGNED IDPRINTER *pidp2 = (UNALIGNED IDPRINTER*)pidl2;

    PIDLTYPE ColateType1 = _IDListType(pidl1);
    PIDLTYPE ColateType2 = _IDListType(pidl2);

    if (ColateType1 == ColateType2)
    {
        // pidls are of same type.

        if (ColateType1 == HOOD_COL_FILE)
        {
            // pidls are both of type file, so pass on to the IShellFolder
            // interface for the hoods custom directory.

            IShellFolder2* psf = CPrintRoot_GetPSF();
            if (psf)
                return psf->CompareIDs(iCol, pidl1, pidl2);
        }
        else
        {
            // pidls are same and not files, so must be printers
            if (pidp1->dwType != pidp2->dwType)
            {
                return (pidp1->dwType < pidp2->dwType) ?
                       ResultFromShort(-1) :
                       ResultFromShort(1);
            }
            int i = ualstrcmpi(pidp1->cName, pidp2->cName);
            if (i != 0)
            {
                // add printer wizard is "less" than everything else
                // This implies that when the list is sorted
                // either accending or decending the add printer
                // wizard object will always appear at the extream
                // ends of the list, i.e. the top or bottom.
                //
                if (_IsAddPrinter(pidp1))
                    i = -1;
                else if (_IsAddPrinter(pidp2))
                    i = 1;
                else
                {
                    // Both of the names are not the add printer wizard
                    // object then compare further i.e. using the cached
                    // column data.

                    // 99/03/24 #308785 vtan: Make the compare data call.
                    // If that fails use the name compare result which is
                    // known to be non-zero.

                    int iDataCompareResult = CompareData(pidp1, pidp2, iCol);
                    if (iDataCompareResult != 0)
                        i = iDataCompareResult;
                }
            }
            return ResultFromShort(i);
        }
    }
    else
    {
        // pidls are not of same type, so have already been correctly
        // collated (consequently, sorting is first by type and
        // then by subfield).

        return ResultFromShort((((INT)(ColateType2 - ColateType1)) > 0) ? -1 : 1);
    }
    return E_FAIL;
}

STDMETHODIMP CPrinterFolder::CreateViewObject(HWND hwnd, REFIID riid, void **ppv)
{
    HRESULT hr;

    if (IsEqualIID(riid, IID_IShellView))
    {
        SFV_CREATE sSFV;

        sSFV.cbSize   = sizeof(sSFV);
        sSFV.pshf     = this;
        sSFV.psvOuter = NULL;
        sSFV.psfvcb   = new CPrinterFolderViewCB(this, _pidl);

        hr = SHCreateShellFolderView(&sSFV, (IShellView**)ppv);

        if (sSFV.psfvcb)
            sSFV.psfvcb->Release();
    }
    else if (IsEqualIID(riid, IID_IDropTarget))
    {
        hr = CPrinterFolderDropTarget_CreateInstance(hwnd, (IDropTarget **)ppv);
    }
    else if (IsEqualIID(riid, IID_IContextMenu))
    {
        hr = CDefFolderMenu_Create2Ex(NULL, hwnd,
                0, NULL, this, this,
                0, NULL, (IContextMenu **)ppv);
    }
    else
    {
        *ppv = NULL;
        hr = E_NOINTERFACE;
    }
    return hr;
}

STDMETHODIMP CPrinterFolder::EnumObjects(HWND hwnd, DWORD grfFlags, IEnumIDList** ppenum)
{
    // By default we always do standard (printer) enumeration
    DWORD dwRemote = 0;

    // Only add links (from the PrintHood directory) to the enumeration
    // if this is the local print folder

    IEnumIDList* peunk = NULL;

    if (_pszServer == NULL)
    {
        // Always try to enum links.
        IShellFolder2 *psfPrintHood = CPrintRoot_GetPSF();

        if (psfPrintHood)
            psfPrintHood->EnumObjects(NULL, grfFlags, &peunk);

        if (peunk)
        {
            // If this went OK, we will also enumerate links
            dwRemote |= RMF_SHOWLINKS;
        }
    }

    return CPrintersEnum::CreateInstance(grfFlags, dwRemote, peunk, this, ppenum);
}

STDMETHODIMP CPrinterFolder::GetAttributesOf(UINT cidl, LPCITEMIDLIST* apidl, ULONG* prgf)
{
    HRESULT hr = S_OK;
    ULONG rgfOut = SFGAO_CANLINK | SFGAO_CANDELETE | SFGAO_CANRENAME | SFGAO_HASPROPSHEET | SFGAO_DROPTARGET;
    ULONG rgfIn = *prgf;

    if (cidl && (HOOD_COL_FILE == _IDListType(apidl[0])))
    {
        IShellFolder2 *psf = CPrintRoot_GetPSF();
        if (psf)
            return psf->GetAttributesOf(cidl, apidl, prgf);
        return E_INVALIDARG;
    }

    // if new printer wizard is selected, we support CANLINK *only*
    for (UINT i = 0 ; i < cidl ; i++)
    {
        LPIDPRINTER pidp = (LPIDPRINTER)apidl[i];

        TCHAR szPrinter[MAXNAMELENBUFFER];
        _ItemName(pidp, szPrinter, ARRAYSIZE(szPrinter));

        if (_IsAddPrinter(pidp))
        {
            // add printer wiz, we support CANLINK *only*
            rgfOut &= SFGAO_CANLINK;

            // added SFGAO_CANDELETE if multiple printers are selected
            // otherwise it's hard to tell why the del key doesn't work.
            if (cidl > 1)
            {
                rgfOut |= SFGAO_CANDELETE;
            }
        }
        else if (Printer_CheckNetworkPrinterByName(szPrinter, NULL))
        {
            // Don't allow renaming of printer connections on WINNT.
            // This is disallowed becase on WINNT, the printer connection
            // name _must_ be the in the format \\server\printer.  On
            // win9x, the user can rename printer connections.
            rgfOut &= ~SFGAO_CANRENAME;
        }
    }

    *prgf &= rgfOut;

    if (cidl == 1 && (rgfIn & (SFGAO_SHARE | SFGAO_GHOSTED)))
    {
        LPIDPRINTER pidp = (LPIDPRINTER)apidl[0];
        void *pData = NULL;
        DWORD dwAttributes = 0;
        TCHAR szFullPrinter[MAXNAMELENBUFFER];
        LPCTSTR pszPrinter = _BuildPrinterName(szFullPrinter, pidp, NULL);

        // If we have notification code, use the hFolder to get
        // printer data instead of querying the printer directly.
        if (GetFolder())
        {
            pData = Printer_FolderGetPrinter(GetFolder(), pszPrinter);
            if (pData)
                dwAttributes = ((PFOLDER_PRINTER_DATA)pData)->Attributes;
        }
        else
        {
            pData = Printer_GetPrinterInfoStr(szFullPrinter, 5);
            if (pData)
                dwAttributes = ((PPRINTER_INFO_5)pData)->Attributes;
        }

        if (pData)
        {
            if (dwAttributes & PRINTER_ATTRIBUTE_SHARED
                // NT appears to return all network printers with their
                // share bit on. I think this is intentional.
                //
                && (dwAttributes & PRINTER_ATTRIBUTE_NETWORK) == 0
               )
            {
                *prgf |= SFGAO_SHARE;
            }
            if (dwAttributes & PRINTER_ATTRIBUTE_WORK_OFFLINE)
                *prgf |= SFGAO_GHOSTED;
            else
                *prgf &= ~SFGAO_GHOSTED;

            LocalFree((HLOCAL)pData);
        }
        else
        {
            // This fct used to always return E_OUTOFMEMORY if pData was NULL.  pData can be
            // NULL for other reasons than out of memory.  So this failure is not really valid.
            // However the Shell handle this failure (which is bad in the first place).
            // If we fail, we just set the attributes to 0 and go on as if nothing happenned.
            // Star Office 5.0, does not handle the E_OUTOFMEMORY properly, they handle it as
            // a failure (which is exactly what we report to them) and they stop their
            // processing to show the Add Printer icon.  But they're bad on one point, they
            // check for S_OK directly so I cannot return S_FALSE. (stephstm, 07/30/99)

            if (SHGetAppCompatFlags(ACF_STAROFFICE5PRINTER) &&
                (ERROR_INVALID_PRINTER_NAME == GetLastError()))
            {
                hr = S_OK;
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }
    return hr;
}

STDMETHODIMP CPrinterFolder::GetDisplayNameOf(LPCITEMIDLIST pidl, DWORD uFlags, STRRET *psr)
{
    LPIDPRINTER pidc = (LPIDPRINTER)pidl;
    BOOL bPrinterOnServerFormat = FALSE;
    LPCTSTR pszServer;
    TCHAR szBuffer[MAXNAMELENBUFFER];
    TCHAR szTemp[MAXNAMELENBUFFER];
    LPCTSTR pszTemp;
    LPCTSTR pszPrinter = szBuffer;

    if (pidl && HOOD_COL_FILE == _IDListType(pidl))
    {
        IShellFolder2 *psf = CPrintRoot_GetPSF();
        if (psf)
            return psf->GetDisplayNameOf(pidl, uFlags, psr);
        return E_INVALIDARG;
    }

    if (!_IsAddPrinter(pidc))
    {
        pszPrinter = _ItemName(pidc, szBuffer, ARRAYSIZE(szBuffer));

        if (uFlags & SHGDN_INFOLDER)
        {
            // relative name (to the folder)

            if (!(SHGDN_FORPARSING & uFlags))
            {
                // If it's a connection then format as "printer on server."

                Printer_SplitFullName(szTemp, pszPrinter, &pszServer, &pszTemp);

                if (pszServer[0])
                {
                    bPrinterOnServerFormat = TRUE;
                    pszPrinter = pszTemp;
                }
            }
        }
        else                        // SHGDN_NORMAL
        {
            if (!(SHGDN_FORPARSING & uFlags))
            {
                // If it's a RPF then extract the server name from psf.
                // Note in the case of masq connections, we still do this
                // (for gateway services: sharing a masq printer).

                if (_pszServer)
                {
                    pszServer = _pszServer;
                    bPrinterOnServerFormat = TRUE;
                }
                else
                {
                    // If it's a connection then format as "printer on server."
                    Printer_SplitFullName(szTemp, pszPrinter, &pszServer, &pszTemp);

                    if (pszServer[0])
                    {
                        bPrinterOnServerFormat = TRUE;
                        pszPrinter = pszTemp;
                    }
                }
            }
            else                      // SHGDN_NORMAL | SHGDN_FORPARSING
            {
                // Fully qualify the printer name if it's not
                // the add printer wizard.
                if (!_IsAddPrinter(pidc))
                {
                    _BuildPrinterName(szTemp, pidc, NULL);
                    pszPrinter = szTemp;
                }
            }
        }
    }
    else
    {
        LoadString(HINST_THISDLL, IDS_NEWPRN, szBuffer, ARRAYSIZE(szBuffer));

        // Use "Add Printer Wizard on \\server" description only if not
        // remote and if not in folder view (e.g., on the desktop).
        if (_pszServer && (uFlags == SHGDN_NORMAL))
        {
            bPrinterOnServerFormat = TRUE;
            pszServer = _pszServer;
            pszPrinter = szBuffer;
        }
        else if (uFlags & SHGDN_FORPARSING)
        {
            // Return the raw add printer wizard object.
            pszPrinter = (LPTSTR)c_szNewObject;
        }
    }

    HRESULT hr;
    if (bPrinterOnServerFormat)
    {
        // When bRemote is set, we want to translate the name to
        // "printer on server."  Note: we should not have a rename problem
        // since renaming connections is disallowed.
        //
        // pszServer and pszPrinter must be initialize if bRemote is TRUE.
        // Also skip the leading backslashes for the server name.

        ASSERT(pszServer[0] == TEXT('\\') && pszServer[1] == TEXT('\\'));
        LPTSTR pszRet = ShellConstructMessageString(HINST_THISDLL,
                     MAKEINTRESOURCE(IDS_DSPTEMPLATE_WITH_ON),
                     &pszServer[2], pszPrinter);
        if (pszRet)
        {
            hr = StringToStrRet(pszRet, psr);
            LocalFree(pszRet);
        }
        else
            hr = E_FAIL;
    }
    else
    {
        hr = StringToStrRet(pszPrinter, psr);
    }
    return hr;
}

STDMETHODIMP CPrinterFolder::GetUIObjectOf(HWND hwnd, UINT cidl, LPCITEMIDLIST* apidl, REFIID riid, UINT *prgf, void **ppv)
{
    HRESULT hr = E_INVALIDARG;

    UINT cidlPrinters = cidl;
    LPCITEMIDLIST *apidlPrinters = apidl;
    BOOL bStrippedLinks = FALSE;

    if (cidl)
    {
        // strip out the link PIDLs and leave only the printer ones
        bStrippedLinks = ReduceToLikeKinds(&cidlPrinters, &apidlPrinters, TRUE);
    }

    if (cidl && 0 == cidlPrinters)
    {
        // if we don't have any printer PIDLs then just defer the operation
        // to the printhood folder.
        IShellFolder2* psfPrintRoot = CPrintRoot_GetPSF();
        hr = psfPrintRoot ? psfPrintRoot->GetUIObjectOf(hwnd, cidl, apidl, riid, prgf, ppv) : E_INVALIDARG;
    }
    else
    {
        //
        // we have some printer PIDLs selected, but it could be a mixed selection
        // of printer PIDLs and file system link objects. we will handle the data
        // object explicitly not to loose information about the selection type.
        // the IDL array format doesn't support different type of PIDLs so we have
        // to create two data objects and combine them into one data object which
        // supports IServiceProvider and then the caller can query our compound data
        // object for SID_SAuxDataObject service to get IDataObject interface of our
        // auxiliary data object (in case it needs access to the link PIDLs).
        //
        if (cidl && IsEqualIID(riid, IID_IDataObject))
        {
            // strip out the printer PIDLs and leave only the link ones
            // we are going to use those PIDLs to create our auxiliary data object
            UINT cidlLinks = cidl;
            LPCITEMIDLIST *apidlLinks = apidl;
            BOOL bStrippedPrinters = FALSE;

            if (cidl)
            {
                // strip out the printer PIDLs and leave only the link ones
                bStrippedPrinters = ReduceToLikeKinds(&cidlLinks, &apidlLinks, FALSE);
            }

            hr = S_OK;
            IDataObject *pdoLinks = NULL;
            if (cidlLinks && apidlLinks)
            {
                // we have some link PIDLs. let's ask the printhood folder to create
                // data object for us to embedd into our data object.
                IShellFolder2* psfPrintRoot = CPrintRoot_GetPSF();
                hr = psfPrintRoot ?
                     psfPrintRoot->GetUIObjectOf(hwnd, cidlLinks, apidlLinks, riid, prgf, (void **)&pdoLinks) :
                     E_INVALIDARG;

                // just out of paranoia...
                if (FAILED(hr))
                    pdoLinks = NULL;
            }

            if (SUCCEEDED(hr))
            {
                // create our compund printers data object and pass in the private
                // auxiliary data object which will contain the link PIDLs
                CPrintersData *ppd = new CPrintersData(pdoLinks, _pidl, cidlPrinters, apidlPrinters);
                if (ppd)
                {
                    hr = ppd->QueryInterface(riid, ppv);
                    ppd->Release();
                }
                else
                    hr = E_OUTOFMEMORY;
            }

            // release allocated objects/memory
            if (pdoLinks)
                pdoLinks->Release();

            if (bStrippedPrinters)
                LocalFree((HLOCAL)apidlLinks);
        }
        else
        {
            // operate only on the printer PIDLs selection (the current behaviour)
            // and ignore the links selection. this may be wrong in some cases, but
            // this code has been busted either way (so far), so we'll fix those on
            // per case basis. the best solution will be to cut of the printhood
            // functionality, but alas...
            LPCIDPRINTER pidp = cidlPrinters > 0 ? (LPIDPRINTER)apidlPrinters[0] : NULL;

            if (pidp && (IsEqualIID(riid, IID_IExtractIconA) || IsEqualIID(riid, IID_IExtractIconW)))
            {
                int iIcon;
                int iShortcutIcon;
                TCHAR szBuf[MAX_PATH+20];
                TCHAR szFullPrinter[MAXNAMELENBUFFER];
                LPTSTR pszModule = NULL;

                _BuildPrinterName(szFullPrinter, pidp, NULL);

                if (_IsAddPrinter(pidp))
                    iIcon = iShortcutIcon = IDI_NEWPRN;
                else
                {
                    pszModule = _FindIcon(szFullPrinter, szBuf, ARRAYSIZE(szBuf), &iIcon, &iShortcutIcon);
                }

                hr = SHCreateDefExtIconKey(NULL, pszModule, EIRESID(iIcon), -1, -1, EIRESID(iShortcutIcon), GIL_PERINSTANCE, riid, ppv);
            }
            else if (pidp && IsEqualIID(riid, IID_IContextMenu))
            {
                HKEY hkeyBaseProgID = NULL;
                int nCount = 0;

                if (ERROR_SUCCESS == RegOpenKey(HKEY_CLASSES_ROOT, c_szPrinters, &hkeyBaseProgID))
                    nCount++;

                hr = CDefFolderMenu_Create2(_pidl, hwnd,
                    cidl, apidl, SAFECAST(this, IShellFolder*), _DFMCallBack,
                    nCount, &hkeyBaseProgID, (IContextMenu **)ppv);

                if (hkeyBaseProgID)
                    RegCloseKey(hkeyBaseProgID);
            }
            else if (pidp && IsEqualIID(riid, IID_IDropTarget))
            {
                if (_IsAddPrinter(pidp))
                {
                    // "NewPrinter" accepts network printer shares
                    hr = CreateViewObject(hwnd, riid, ppv);   // folder drop target
                }
                else
                {
                    LPITEMIDLIST pidl;
                    hr = SHILCombine(_pidl, apidl[0], &pidl);
                    if (SUCCEEDED(hr))
                    {
                        hr = CPrinterDropTarget_CreateInstance(hwnd, pidl, (IDropTarget**)ppv);
                        ILFree(pidl);
                    }
                }
            }
            else if (pidp && IsEqualIID(riid, IID_IQueryInfo))
            {
                // get the infotip from IQA
                IQueryAssociations *pqa;
                hr = _AssocCreate(IID_PPV_ARG(IQueryAssociations, &pqa));

                if (SUCCEEDED(hr))
                {
                    WCHAR szText[INFOTIPSIZE];
                    DWORD cch = ARRAYSIZE(szText);
                    hr = pqa->GetString(0, ASSOCSTR_INFOTIP, NULL, szText, &cch);
                    if (SUCCEEDED(hr))
                    {
                        hr = CreateInfoTipFromItem(SAFECAST(this, IShellFolder2*),
                            (LPCITEMIDLIST)pidp, szText, riid, ppv);
                    }
                    pqa->Release();
                }
            }
            else if (pidp && IsEqualIID(riid, IID_IQueryAssociations))
            {
                // return our IQA
                hr = _AssocCreate(riid, ppv);
            }
        }
    }

    // release the memory allocated from ReduceToLikeKinds
    if (bStrippedLinks)
        LocalFree((HLOCAL)apidlPrinters);

    return hr;
}

STDMETHODIMP CPrinterFolder::ParseDisplayName(HWND hwnd, LPBC pbc, LPOLESTR pszName, ULONG* pchEaten, LPITEMIDLIST* ppidl, ULONG* pdwAttributes)
{
    HRESULT hr = E_INVALIDARG;

    // check if this is not a PrintHood object first
    IShellFolder2 *psfPrintHood = CPrintRoot_GetPSF();
    if (psfPrintHood)
    {
        hr = psfPrintHood->ParseDisplayName(hwnd, pbc, pszName, pchEaten, ppidl, pdwAttributes);
    }

    if (FAILED(hr))
    {
        // not a printhood object - try the folder cache
        hr = E_INVALIDARG;

        if (ppidl)
            *ppidl = NULL;

        if (pszName && ppidl)
        {
            hr = S_OK;
            DWORD dwType = 0;
            BOOL bValidated = FALSE;
            void *pData = NULL;

            // check the bind info first
            if (pbc)
            {
                IUnknown *pUnk;
                hr = pbc->GetObjectParam(PRINTER_BIND_INFO, &pUnk);
                if (SUCCEEDED(hr))
                {
                    IPrintersBindInfo *pInfo;
                    hr = pUnk->QueryInterface(IID_PPV_ARG(IPrintersBindInfo, &pInfo));
                    if (SUCCEEDED(hr))
                    {
                        // update dwType & bValidated from the bind info
                        pInfo->GetPIDLType(&dwType);
                        bValidated = (S_OK == pInfo->IsValidated());
                        pInfo->Release();
                    }
                    pUnk->Release();
                }
            }

            if (SUCCEEDED(hr))
            {
                // the "add printer" icon doesn't need validation
                if (StrStrIW(pszName, c_szNewObject))
                {
                    bValidated = TRUE;
                }

                // hit the folder cache to see if this printer belongs to this folder.
                if (bValidated || (pData = (GetFolder() ? Printer_FolderGetPrinter(GetFolder(), pszName) : NULL)))
                {
                    // well, looks like this printer belongs to our folder -
                    // create a printer PIDL (relative to this folder).
                    hr = _Parse(pszName, ppidl, dwType);
                }
                else
                {
                    // the printer doesn't belong to this folder - cook up correct HRESULT.
                    // usually the last error here is ERROR_INVALID_PRINTER_NAME
                    DWORD dwLastErr = GetLastError();
                    hr = ERROR_SUCCESS == dwLastErr ? HRESULT_FROM_WIN32(ERROR_INVALID_PRINTER_NAME)
                                                    : HRESULT_FROM_WIN32(dwLastErr);
                }
            }

            if (pData)
                LocalFree((HLOCAL)pData);
        }

        // check to return pchEaten
        if (SUCCEEDED(hr) && pchEaten)
        {
            *pchEaten = lstrlen(pszName);
        }

        // check to return pdwAttributes
        if (SUCCEEDED(hr) && pdwAttributes)
        {
            hr = GetAttributesOf(1, (LPCITEMIDLIST *)ppidl, pdwAttributes);
        }
    }

    return hr;
}

STDMETHODIMP CPrinterFolder::SetNameOf(HWND hwnd, LPCITEMIDLIST pidl, LPCOLESTR pszNewName, DWORD dwRes, LPITEMIDLIST* ppidlOut)
{
    HRESULT hr = S_OK;
    HANDLE hPrinter = NULL;
    LPPRINTER_INFO_2 pPrinter = NULL;

    if (HOOD_COL_FILE == _IDListType(pidl))
    {
        IShellFolder2 *psf = CPrintRoot_GetPSF();
        hr = psf ?  psf->SetNameOf(hwnd, pidl, pszNewName, dwRes, ppidlOut) : E_INVALIDARG;
        goto Exit;
    }
    else
    {
        LPIDPRINTER pidc = (LPIDPRINTER)pidl;

        ASSERT(!_IsAddPrinter(pidc));  // does not have _CANRENAME bit

        TCHAR szNewName[MAX_PATH];
        SHUnicodeToTChar(pszNewName, szNewName, ARRAYSIZE(szNewName));
        PathRemoveBlanks(szNewName);

        TCHAR szOldName[MAXNAMELENBUFFER];
        _ItemName(pidc, szOldName, ARRAYSIZE(szOldName));

        if (0 == lstrcmp(szOldName, szNewName))
            goto Exit;

        TCHAR szFullPrinter[MAXNAMELENBUFFER];
        _BuildPrinterName(szFullPrinter, NULL, szOldName);
        LPCTSTR pszFullOldName = szFullPrinter;

        hPrinter = Printer_OpenPrinterAdmin(pszFullOldName);
        if (NULL == hPrinter)
            goto Error;

        pPrinter = (LPPRINTER_INFO_2)Printer_GetPrinterInfo(hPrinter, 2);
        if (NULL == pPrinter)
            goto Error;

        int nTmp = _IllegalPrinterName(szNewName);
        if (0 != nTmp)
        {
            // NTRAID95214-2000-03-17:
            // We need to impl ::SetSite() and pass it to UI APIs
            // to go modal if we display UI.
            if (hwnd)
            {
                ShellMessageBox(HINST_THISDLL, hwnd, MAKEINTRESOURCE(nTmp),
                    MAKEINTRESOURCE(IDS_PRINTERS),
                    MB_OK|MB_ICONEXCLAMATION);
                hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);
                goto Exit;
            }
        }
        else if (IDYES != CallPrinterCopyHooks(hwnd, PO_RENAME, 0, szNewName, 0, pszFullOldName, 0))
        {
            // user canceled a shared printer name change, bail.
            hr = HRESULT_FROM_WIN32(ERROR_CANCELLED);
            goto Exit;
        }
        else
        {
            pPrinter->pPrinterName = szNewName;
            if (FALSE == SetPrinter(hPrinter, 2, (LPBYTE)pPrinter, 0))
                goto Error;

            // return the new pidl if requested
            hr = ppidlOut ? _Parse(szNewName, ppidlOut) : S_OK;

            if (SUCCEEDED(hr))
                goto Exit;
        }
    }

Error:
    if (SUCCEEDED(hr))
    {
        // get the correct error from win32
        hr = HRESULT_FROM_WIN32(GetLastError());
    }
    // show an appropriate error message based on the HRESULT
    ShowErrorMessageHR(NULL, NULL, hwnd, NULL, NULL, MB_OK|MB_ICONEXCLAMATION, hr);

Exit:
    if( pPrinter )
    {
        LocalFree((HLOCAL)pPrinter);
    }

    if( hPrinter )
    {
        Printer_ClosePrinter(hPrinter);
    }
    return hr;
}

STDMETHODIMP CPrinterFolder::EnumSearches(IEnumExtraSearch **ppenum)
{
    *ppenum = NULL;
    return E_NOTIMPL;
}

STDMETHODIMP CPrinterFolder::GetDefaultColumn(DWORD dwRes, ULONG* pSort, ULONG* pDisplay)
{
    return E_NOTIMPL;
}

STDMETHODIMP CPrinterFolder::GetDefaultColumnState(UINT iColumn, DWORD* pdwState)
{
    HRESULT hr;

    if (iColumn < ARRAYSIZE(c_printers_cols))
    {
        *pdwState = c_printers_cols[iColumn].csFlags;
        hr = S_OK;
    }
    else
    {
        *pdwState = 0;
        hr = E_NOTIMPL;
    }
    return hr;
}

STDMETHODIMP CPrinterFolder::GetDefaultSearchGUID(LPGUID pGuid)
{
    *pGuid = SRCID_SFindPrinter;
    return S_OK;
}

STDMETHODIMP CPrinterFolder::GetDetailsEx(LPCITEMIDLIST pidl, const SHCOLUMNID* pscid, VARIANT* pv)
{
    BOOL fFound;
    HRESULT hr = AssocGetDetailsOfSCID(this, pidl, pscid, pv, &fFound);
    if (FAILED(hr) && !fFound)
    {
        int iCol = FindSCID(c_printers_cols, ARRAYSIZE(c_printers_cols), pscid);
        if (iCol >= 0)
        {
            SHELLDETAILS sd;
            hr = GetDetailsOf(pidl, iCol, &sd);
            if (SUCCEEDED(hr))
            {
                if (PRINTERS_ICOL_LOCATION == iCol)
                {
                    // widen the scope of the location by 1, so it does make more sense
                    WCHAR szTemp[MAX_PATH];
                    hr = StrRetToBufW(&sd.str, pidl, szTemp, ARRAYSIZE(szTemp));

                    if (SUCCEEDED(hr))
                    {
                        WCHAR *p = szTemp + lstrlen(szTemp);

                        // cut the last slash if any
                        if (p > szTemp && L'/' == *p)
                        {
                            p--;
                        }

                        // search for a slash from the end
                        while(p > szTemp && L'/' != *p)
                        {
                            p--;
                        }

                        // if found, cut the text here, so the scope gets wider
                        if (p > szTemp)
                        {
                            *p = 0;
                        }

                        hr = InitVariantFromStr(pv, szTemp);
                    }
                }
                else
                {
                    hr = InitVariantFromStrRet(&sd.str, pidl, pv);
                }
            }
        }
    }

    return hr;
}

STDMETHODIMP CPrinterFolder::GetDetailsOf(LPCITEMIDLIST pidl, UINT iColumn, SHELLDETAILS *psd)
{
    LPIDPRINTER pidp = (LPIDPRINTER)pidl;
    HRESULT hr = S_OK;
    TCHAR szTemp[MAX_PATH];
    TCHAR szPrinter[MAXNAMELENBUFFER];

    if (pidl && (HOOD_COL_FILE == _IDListType(pidl)))
    {
        IShellFolder2 *psf = CPrintRoot_GetPSF();
        if (psf)
        {
            if (iColumn >= 1)
                return E_NOTIMPL;

            return psf->GetDisplayNameOf(pidl, SHGDN_INFOLDER, &(psd->str));
        }
        return E_INVALIDARG;
    }

    psd->str.uType = STRRET_CSTR;
    psd->str.cStr[0] = 0;

    if (!pidp)
    {
        return GetDetailsOfInfo(c_printers_cols, ARRAYSIZE(c_printers_cols), iColumn, psd);
    }

    _ItemName(pidp, szPrinter, ARRAYSIZE(szPrinter));

    if (iColumn == PRINTERS_ICOL_NAME)
    {
#ifdef UNICODE
        LPCTSTR pszPrinterName = szPrinter;
        TCHAR szPrinterName[MAXNAMELENBUFFER];

        //
        // If we have a valid server name and the printer is not
        // the add printer wizard object then return a fully qualified
        // printer name in the remote printers folder.
        //
        if (GetServer() && !_IsAddPrinter(pidp))
        {
            //
            // Build the name which consists of the
            // server name plus slash plus the printer name.
            //
            lstrcpyn(szPrinterName, GetServer(), ARRAYSIZE(szPrinterName));
            UINT len = lstrlen(szPrinterName);
            lstrcpyn(&szPrinterName[len++], TEXT("\\"), ARRAYSIZE(szPrinterName) - len);
            lstrcpyn(&szPrinterName[len], pszPrinterName, ARRAYSIZE(szPrinterName) - len);
            pszPrinterName = szPrinterName;
        }
        hr = StringToStrRet(pszPrinterName, &psd->str);
#else
        hr = StringToStrRet(szPrinter, &psd->str);
#endif
    }
    else if (!_IsAddPrinter(pidp))
    {
        PFOLDER_PRINTER_DATA pData = (PFOLDER_PRINTER_DATA)Printer_FolderGetPrinter(GetFolder(), szPrinter);
        if (pData)
        {
            switch (iColumn)
            {
            case PRINTERS_ICOL_QUEUESIZE:
                wsprintf(szTemp, TEXT("%ld"), pData->cJobs);
                hr = StringToStrRet(szTemp, &psd->str);
                break;

            case PRINTERS_ICOL_STATUS:
            {
                DWORD dwStatus = pData->Status;

                // HACK: Use this free bit for "Work Offline"
                if (pData->Attributes & PRINTER_ATTRIBUTE_WORK_OFFLINE)
                    dwStatus |= PRINTER_HACK_WORK_OFFLINE;

                szTemp[0] = 0;
                Printer_BitsToString(dwStatus, IDS_PRQSTATUS_SEPARATOR, szTemp, ARRAYSIZE(szTemp));

                hr = StringToStrRet(szTemp, &psd->str);

                // If the status word is null and we have a connection status string
                // display the status string.  This only works on NT because printui.dll
                // in will generate printer connection status i.e. <opening> | <access denied> etc.
                if (!dwStatus)
                {
                    LPCTSTR pStr = pData->pStatus;

                    // Discard the previous status StrRet if any.
                    StrRetToBuf(&psd->str, NULL, szTemp, ARRAYSIZE(szTemp));

                    //
                    // If we do not have a connection status string and the status
                    // is 0 then the printer is ready, display ready rather than an empty string.
                    //
                    if (!pStr)
                    {
                        LoadString(HINST_THISDLL, IDS_PRN_INFOTIP_READY, szTemp, ARRAYSIZE(szTemp));
                        pStr = szTemp;
                    }
                    hr = StringToStrRet(pStr, &psd->str);
                }
                break;
            }

            case PRINTERS_ICOL_COMMENT:
                if (pData->pComment)
                {
                    // pComment can have newlines in it because it comes from
                    // a multi-line edit box. BUT we display it here in a
                    // single line edit box. Strip out the newlines
                    // to avoid the ugly characters.
                    lstrcpyn(szTemp, pData->pComment, ARRAYSIZE(szTemp));
                    LPTSTR pStr = szTemp;
                    while (*pStr)
                    {
                        if (*pStr == TEXT('\r') || *pStr == TEXT('\n'))
                            *pStr = TEXT(' ');
                        pStr = CharNext(pStr);
                    }
                    hr = StringToStrRet(szTemp, &psd->str);
                }
                break;

            case PRINTERS_ICOL_LOCATION:
                if (pData->pLocation)
                    hr = StringToStrRet(pData->pLocation, &psd->str);
                break;

            case PRINTERS_ICOL_MODEL:
                if (pData->pDriverName)
                    hr = StringToStrRet(pData->pDriverName, &psd->str);
                break;
            }

            LocalFree((HLOCAL)pData);
        }
    }

    return hr;
}

STDMETHODIMP CPrinterFolder::MapColumnToSCID(UINT iCol, SHCOLUMNID* pscid)
{
    return MapColumnToSCIDImpl(c_printers_cols, ARRAYSIZE(c_printers_cols), iCol, pscid);
}

// IPersistFolder2

STDMETHODIMP CPrinterFolder::GetCurFolder(LPITEMIDLIST *ppidl)
{
    return GetCurFolderImpl(_pidl, ppidl);
}

STDMETHODIMP CPrinterFolder::Initialize(LPCITEMIDLIST pidl)
{
    ASSERT(_pidl == NULL);

    // if _csLock is false then InitializeCriticalSection has thrown exception.
    // this can happen only in extremely low memory conditions!
    HRESULT hr = _csLock ? S_OK : E_OUTOFMEMORY;

    if (SUCCEEDED(hr))
    {
        hr = SHILClone(pidl, &_pidl);
    }

    if (!_dpaSlowWVDataCache.Create(16))
    {
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

STDMETHODIMP CPrinterFolder::GetClassID(LPCLSID lpClassID)
{
    *lpClassID = CLSID_Printers;
    return S_OK;
}

// IShellIconOverlay

STDMETHODIMP CPrinterFolder::GetOverlayIndex(LPCITEMIDLIST pidl, int* pIndex)
{
    HRESULT hr = E_INVALIDARG;
    if (pidl)
    {
        ULONG uAttrib = SFGAO_SHARE;

        hr = E_FAIL;      // Until proven otherwise...
        GetAttributesOf(1, &pidl, &uAttrib);
        if (uAttrib & SFGAO_SHARE)
        {
            IShellIconOverlayManager* psiom;
            hr = GetIconOverlayManager(&psiom);
            if (SUCCEEDED(hr))
            {
                hr = psiom->GetReservedOverlayInfo(L"0", 0, pIndex, SIOM_OVERLAYINDEX, SIOM_RESERVED_SHARED);
                psiom->Release();
            }
        }
    }
    return hr;
}

STDMETHODIMP CPrinterFolder::GetOverlayIconIndex(LPCITEMIDLIST pidl, int *pIndex)
{
    return E_NOTIMPL;
}

// this function is assuming the printer name is valid. it is for private use.
// if you need a printer PIDL call CPrinterFolder::ParseDisplayName instead.
// we don't use CPrinterFolder::ParseDisplayName because it's heavy to use.
// it's hitting the folder cache (and potentionally creating it!).
HRESULT CPrinterFolder::_GetFullIDList(LPCWSTR pszPrinter, LPITEMIDLIST *ppidl)
{
    HRESULT hr = E_INVALIDARG;

    if (ppidl)
    {
        *ppidl = NULL;

        if (pszPrinter)
        {
            // if pszPrinter isn't NULL this means a printer PIDL is requested.
            LPITEMIDLIST pidl;
            hr = _Parse(pszPrinter, &pidl, 0, 0);

            if (SUCCEEDED(hr))
            {
                hr = SHILCombine(_pidl, pidl, ppidl);
                ILFree(pidl);
            }
        }
        else
        {
            // if pszPrinter is NULL this means the printers folder PIDL is requested.
            hr = SHILClone(_pidl, ppidl);
        }
    }

    return hr;
}

// IRemoteComputer

STDMETHODIMP CPrinterFolder::Initialize(const WCHAR *pszMachine, BOOL bEnumerating)
{
    // if _csLock is false then InitializeCriticalSection has thrown exception.
    // this can happen only in extremely low memory conditions!
    HRESULT hr = _csLock ? S_OK : E_OUTOFMEMORY;

    if (SUCCEEDED(hr))
    {
        // for servers, we want to show the remote printer folder. only check during enumeration
        hr = (bEnumerating && !Printer_CheckShowFolder(pszMachine)) ? E_FAIL : S_OK;
        if (SUCCEEDED(hr))
        {
            TCHAR szBuf[MAXCOMPUTERNAME];
            SHUnicodeToTChar(pszMachine, szBuf, ARRAYSIZE(szBuf));
            _pszServer = StrDup(szBuf);
            hr = _pszServer ? S_OK : E_OUTOFMEMORY;
        }
    }

    return hr;
}

// IPrinterFolder

BOOL CPrinterFolder::IsPrinter(LPCITEMIDLIST pidl)
{
    return _IDListType(pidl) == HOOD_COL_PRINTER;
}

// IFolderNotify

STDMETHODIMP_(BOOL) CPrinterFolder::ProcessNotify(FOLDER_NOTIFY_TYPE NotifyType, LPCWSTR pszName, LPCWSTR pszNewName)
{
    static const DWORD aNotifyTypes[] = {
        kFolderUpdate,        SHCNE_UPDATEITEM,
        kFolderCreate,        SHCNE_CREATE,
        kFolderDelete,        SHCNE_DELETE,
        kFolderRename,        SHCNE_RENAMEITEM,
        kFolderAttributes,    SHCNE_ATTRIBUTES };

    BOOL bReturn = FALSE;
    UINT uFlags = SHCNF_IDLIST | SHCNF_FLUSH | SHCNF_FLUSHNOWAIT;

    if (kFolderUpdateAll == NotifyType)
    {
        //
        // Clear the this->bRefreshed flag, which will force invalidating the folder cache
        // during the next print folder enumeration, and then request the defview to update
        // the entire printers folder content (i.e. to re-enumerate the folder).
        //
        RequestRefresh();
        NotifyType = kFolderUpdate;
        pszName = NULL;
    }

    for (int i = 0; i < ARRAYSIZE(aNotifyTypes); i += 2)
    {
        if (aNotifyTypes[i] == (DWORD)NotifyType)
        {
            LPITEMIDLIST pidl = NULL;
            LPITEMIDLIST pidlNew = NULL;
            HRESULT hr = _GetFullIDList(pszName, &pidl);
            if (SUCCEEDED(hr) && pszNewName)
                hr = _GetFullIDList(pszNewName, &pidlNew);

            // We can get a null pidl if the printer receives a refresh,
            // and before we call Printers_GetPidl the printer is gone.
            if (SUCCEEDED(hr))
                SHChangeNotify(aNotifyTypes[i+1], uFlags, pidl, pidlNew);

            ILFree(pidl);
            ILFree(pidlNew);

            bReturn = SUCCEEDED(hr);
            break;
        }
    }

    return bReturn;
}

// The IClassFactory callback for CLSID_Printers

STDAPI CPrinters_CreateInstance(IUnknown *pUnkOuter, REFIID riid, void **ppv)
{
    HRESULT hr;

    CPrinterFolder* ppf = new CPrinterFolder();
    if (!ppf)
    {
        *ppv = NULL;
        hr = E_OUTOFMEMORY;
    }
    else
    {
        hr = ppf->QueryInterface(riid, ppv);
        ppf->Release();  // Already have a ref count from new
    }

    return hr;
}

////////////////////////////////////////////////////////////////////////////////
// CPrintersData
//

// IUnknown
STDMETHODIMP CPrintersData::QueryInterface(REFIID riid, void **ppv)
{
    HRESULT hr = E_INVALIDARG;
    if (ppv)
    {
        if (IsEqualIID(riid, IID_IServiceProvider))
        {
            // we implement IServiceProvider
            *ppv = reinterpret_cast<void*>(static_cast<IServiceProvider*>(this));
            reinterpret_cast<IUnknown*>(*ppv)->AddRef();
            hr = S_OK;
        }
        else
        {
            // delegate to CIDLDataObj
            hr = CIDLDataObj::QueryInterface(riid, ppv);
        }
    }
    return hr;
}

STDMETHODIMP CPrintersData::QueryGetData(FORMATETC *pformatetc)
{
    if ((pformatetc->cfFormat == g_cfPrinterFriendlyName) &&
        (pformatetc->tymed & TYMED_HGLOBAL))
    {
        return S_OK;
    }

    return CIDLDataObj::QueryGetData(pformatetc);
}

STDMETHODIMP CPrintersData::GetData(FORMATETC *pformatetcIn, STGMEDIUM *pmedium)
{
    HRESULT hr = E_INVALIDARG;

    // g_cfPrinterFriendlyName creates an HDROP-like structure that contains
    // friendly printer names (instead of absolute paths) for the objects
    // in pdo. The handle returned from this can be used by the HDROP
    // functions DragQueryFile, DragQueryInfo, ...
    //
    if ((pformatetcIn->cfFormat == g_cfPrinterFriendlyName) &&
        (pformatetcIn->tymed & TYMED_HGLOBAL))
    {
        STGMEDIUM medium;
        UINT cbRequired = sizeof(DROPFILES) + sizeof(TCHAR); // dbl null terminated
        LPIDA pida = DataObj_GetHIDA(this, &medium);

        for (UINT i = 0; i < pida->cidl; i++)
        {
            LPIDPRINTER pidp = (LPIDPRINTER)IDA_GetIDListPtr(pida, i);
            cbRequired += ualstrlen(pidp->cName) * sizeof(pidp->cName[0]) + sizeof(pidp->cName[0]);
        }

        pmedium->pUnkForRelease = NULL; // caller should release hmem
        pmedium->tymed = TYMED_HGLOBAL;
        pmedium->hGlobal = GlobalAlloc(GPTR, cbRequired);
        if (pmedium->hGlobal)
        {
            LPDROPFILES pdf = (LPDROPFILES)pmedium->hGlobal;

            pdf->pFiles = sizeof(DROPFILES);
            pdf->fWide = (sizeof(TCHAR) == sizeof(WCHAR));

            LPTSTR lps = (LPTSTR)((LPBYTE)pdf + pdf->pFiles);
            for (i = 0; i < pida->cidl; i++)
            {
                LPIDPRINTER pidp = (LPIDPRINTER)IDA_GetIDListPtr(pida, i);
                ualstrcpy(lps, pidp->cName);
                lps += lstrlen(lps) + 1;
            }
            ASSERT(*lps == 0);

            hr = S_OK;
        }
        else
            hr = E_OUTOFMEMORY;

        HIDA_ReleaseStgMedium(pida, &medium);
    }
    else
    {
        hr = CIDLDataObj::GetData(pformatetcIn, pmedium);
    }

    return hr;
}

// IServiceProvider
STDMETHODIMP CPrintersData::QueryService(REFGUID guidService, REFIID riid, void **ppv)
{
    HRESULT hr = E_NOINTERFACE;
    if (_pdoAux && IsEqualIID(guidService, SID_SAuxDataObject))
    {
        hr = _pdoAux->QueryInterface(riid, ppv);
    }
    return hr;
}

////////////////////////////////////////////////////////////////////////////////
// CPrinterDropTarget
//

STDAPI CPrinterDropTarget_CreateInstance(HWND hwnd, LPCITEMIDLIST pidl, IDropTarget **ppdropt)
{
    *ppdropt = NULL;

    HRESULT hr;
    CPrinterDropTarget *ppdt = new CPrinterDropTarget(hwnd);
    if (ppdt)
    {
        hr = ppdt->_Init(pidl);
        if (SUCCEEDED(hr))
            ppdt->QueryInterface(IID_PPV_ARG(IDropTarget, ppdropt));
        ppdt->Release();
    }
    else
        hr = E_OUTOFMEMORY;
    return hr;
}

STDMETHODIMP CPrinterDropTarget::DragEnter(IDataObject *pDataObj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    // let the base-class process it now to save away pdwEffect
    CIDLDropTarget::DragEnter(pDataObj, grfKeyState, pt, pdwEffect);

    // We allow files to be dropped for printing
    // if it is from the bitbucket only DROEFFECT_MOVE will be set in *pdwEffect
    // so this will keep us from printing wastbasket items.

    if (m_dwData & DTID_HDROP)
        *pdwEffect &= DROPEFFECT_COPY;
    else
        *pdwEffect = DROPEFFECT_NONE;   // Default action is nothing

    m_dwEffectLastReturned = *pdwEffect;

    return S_OK;
}

void _PrintHDROPFiles(HWND hwnd, HDROP hdrop, LPCITEMIDLIST pidlPrinter)
{
    DRAGINFO di;

    di.uSize = sizeof(di);
    if (DragQueryInfo(hdrop, &di))
    {
        BOOL bInstalled = FALSE;
        TCHAR szPrinter[MAXNAMELENBUFFER];

        //
        // first check if the printer is already installed (in the local printer's folder)
        // and if not installed asks the user if he wants to install it. you can't print
        // to a printer which isn't installed locally.
        //
        if (SUCCEEDED(SHGetNameAndFlags(pidlPrinter, SHGDN_FORPARSING, szPrinter, ARRAYSIZE(szPrinter), NULL)))
        {
            //
            // let's see if this printer is accessible and get the real printer name
            // (since szPrinter could be a share name - \\machine\share)
            //
            DWORD dwError = ERROR_SUCCESS;
            BOOL bPrinterOK = FALSE;

            HANDLE hPrinter = Printer_OpenPrinter(szPrinter);
            if (hPrinter)
            {
                PRINTER_INFO_5 *pPrinter = (PRINTER_INFO_5 *)Printer_GetPrinterInfo(hPrinter, 5);
                if (pPrinter)
                {
                    // the printer looks accessible, get the real printer name
                    bPrinterOK = TRUE;
                    lstrcpyn(szPrinter, pPrinter->pPrinterName, ARRAYSIZE(szPrinter));
                    LocalFree((HLOCAL)pPrinter);
                }
                else
                {
                    // save the last error
                    dwError = GetLastError();
                }
                Printer_ClosePrinter(hPrinter);
            }
            else
            {
                // save the last error
                dwError = GetLastError();
            }

            if (bPrinterOK)
            {
                LPITEMIDLIST pidl = NULL;
                if (SUCCEEDED(ParsePrinterName(szPrinter, &pidl)))
                {
                    // the printer is installed in the local printer's folder
                    bInstalled = TRUE;
                    ILFree(pidl);
                }
                else
                {
                    //
                    // tell the user this printer isn't installed and ask if he wants to install the printer
                    // before printing the files(s).
                    //
                    if (IDYES == ShellMessageBox(HINST_THISDLL, hwnd, MAKEINTRESOURCE(IDS_PRINTER_NOTCONNECTED),
                                    MAKEINTRESOURCE(IDS_PRINTERS), MB_YESNO|MB_ICONQUESTION))
                    {
                        pidl = Printers_PrinterSetup(hwnd, MSP_NETPRINTER, szPrinter, NULL);
                        if (pidl)
                        {
                            bInstalled = TRUE;
                            ILFree(pidl);
                        }
                    }
                }
            }
            else
            {
                if( ERROR_SUCCESS == dwError )
                {
                    //
                    // the printer is unreachable for some reason or some other weird error occured -
                    // just show up an appropriate error message and continue.
                    //
                    // since all the above APIs are poorly designed it's very hard to tell what
                    // exactly has failed. it isn't possible to use the last error, since it's already
                    // stomped and probably totally wrong.
                    //
                    ShellMessageBox(HINST_THISDLL, hwnd,
                        MAKEINTRESOURCE(IDS_CANTPRINT),
                        MAKEINTRESOURCE(IDS_PRINTERS),
                        MB_OK|MB_ICONEXCLAMATION);
                }
                else
                {
                    // if ERROR_SUCCESS != dwError then we have meaningfull error to show up to
                    // the user. just do it.
                    ShowErrorMessageSC(NULL, NULL, hwnd, NULL, NULL, MB_OK|MB_ICONEXCLAMATION, dwError);
                }
            }
        }

        if (bInstalled)
        {
            //
            // at this point the printer we are trying to print to should be installed
            // locally, so we can safely proceed with printing the selected files(s).
            //
            LPTSTR pszFile = di.lpFileList;
            int i = IDYES;

            // Printing more than one file at a time can easily fail.
            // Ask the user to confirm this operation.
            if (*pszFile && *(pszFile + lstrlen(pszFile) + 1))
            {
                i = ShellMessageBox(HINST_THISDLL,
                    NULL,
                    MAKEINTRESOURCE(IDS_MULTIPLEPRINTFILE),
                    MAKEINTRESOURCE(IDS_PRINTERS),
                    MB_YESNO|MB_ICONINFORMATION);
            }

            if (i == IDYES)
            {
                // FEATURE: It would be really nice to have a progress bar when
                // printing multiple files.  And there should definitely be a way
                // to cancel this operation. Oh well, we warned them...

                while (*pszFile)
                {
                    Printer_PrintFile(hwnd, pszFile, pidlPrinter);
                    pszFile += lstrlen(pszFile) + 1;
                }
            }
        }

        SHFree(di.lpFileList);
    }
}

typedef struct {
    HWND        hwnd;
    IDataObject *pDataObj;
    IStream *pstmDataObj;       // to marshall the data object
    DWORD       dwEffect;
    POINT       ptDrop;
    LPITEMIDLIST    pidl;   // relative pidl of printer printing to
} PRNTHREADPARAM;


void FreePrinterThreadParam(PRNTHREADPARAM *pthp)
{
    if (pthp->pDataObj)
        pthp->pDataObj->Release();

    if (pthp->pstmDataObj)
        pthp->pstmDataObj->Release();

    ILFree(pthp->pidl);
    LocalFree((HLOCAL)pthp);
}
//
// This is the entry of "drop thread"
//
DWORD CALLBACK CPrintObj_DropThreadProc(void *pv)
{
    PRNTHREADPARAM *pthp = (PRNTHREADPARAM *)pv;
    STGMEDIUM medium;
    FORMATETC fmte = {CF_HDROP, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};

    CoGetInterfaceAndReleaseStream(pthp->pstmDataObj, IID_PPV_ARG(IDataObject, &pthp->pDataObj));
    pthp->pstmDataObj = NULL;

    if (pthp->pDataObj && SUCCEEDED(pthp->pDataObj->GetData(&fmte, &medium)))
    {
        _PrintHDROPFiles(pthp->hwnd, (HDROP)medium.hGlobal, pthp->pidl);
        ReleaseStgMedium(&medium);
    }

    FreePrinterThreadParam(pthp);
    return 0;
}

HRESULT PrintObj_DropPrint(IDataObject *pDataObj, HWND hwnd, DWORD dwEffect, LPCITEMIDLIST pidl, LPTHREAD_START_ROUTINE pfn)
{
    HRESULT hr = E_OUTOFMEMORY; // assume the worst

    PRNTHREADPARAM *pthp = (PRNTHREADPARAM *)LocalAlloc(LPTR, sizeof(*pthp));
    if (pthp)
    {
        hr = CoMarshalInterThreadInterfaceInStream(IID_IDataObject, (IUnknown *)pDataObj, &pthp->pstmDataObj);

        if (SUCCEEDED(hr))
        {
            if (hwnd)
                ShellFolderView_GetAnchorPoint(hwnd, FALSE, &pthp->ptDrop);
            pthp->hwnd = hwnd;
            pthp->dwEffect = dwEffect;
            hr = SHILClone(pidl, &pthp->pidl);
            if (SUCCEEDED(hr))
            {
                if (!SHCreateThread(pfn, pthp, CTF_COINIT, NULL))
                {
                    hr = E_OUTOFMEMORY;
                }
            }
        }

        if (FAILED(hr))
            FreePrinterThreadParam(pthp);
    }
    return hr;
}

STDMETHODIMP CPrinterDropTarget::_DropCallback(IDataObject *pDataObj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect, LPTHREAD_START_ROUTINE pfn)
{
    *pdwEffect = m_dwEffectLastReturned;

    HRESULT hr;

    if (*pdwEffect)
        hr = DragDropMenu(DROPEFFECT_COPY, pDataObj, pt, pdwEffect, NULL, NULL, MENU_PRINTOBJ_DD, grfKeyState);
    else
        hr = S_FALSE;

    if (*pdwEffect)
        hr = PrintObj_DropPrint(pDataObj, _GetWindow(), *pdwEffect, m_pidl, pfn);

    CIDLDropTarget::DragLeave();
    return hr;
}

STDMETHODIMP CPrinterDropTarget::Drop(IDataObject *pDataObj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect)
{
    return _DropCallback(pDataObj, grfKeyState, pt, pdwEffect, CPrintObj_DropThreadProc);
}



// cbModule = sizeof(*pszModule)  and  cbModule ~== MAX_PATH+slop
// returns NULL and sets *pid to the icon id in HINST_THISDLL   or
// returns pszModule and sets *pid to the icon id for module pszModule

LPTSTR CPrinterFolder::_FindIcon(LPCTSTR pszPrinterName, LPTSTR pszModule, ULONG cbModule, int *piIcon, int *piShortcutIcon)
{
    TCHAR szFullPrinter[MAXNAMELENBUFFER];
    LPTSTR pszRet = NULL;
    TCHAR szKeyName[256];
    int iStandardIcon;
    int iDefaultIcon;

    // Sanitize the printer name so it doesn't have backslashes.
    // We're about to use the string as a registry key name, where
    // backslashes are illegal.
    lstrcpyn(szFullPrinter, pszPrinterName, ARRAYSIZE(szFullPrinter));
    LPTSTR psz = szFullPrinter;
    while ((psz = StrChr(psz, TEXT('\\'))) != NULL)
    {
        *psz = TEXT('/');
    }

    // registry override of the icon
    wnsprintf(szKeyName, ARRAYSIZE(szKeyName), c_szPrintersDefIcon, szFullPrinter);
    if (SHGetValue(HKEY_CLASSES_ROOT, szKeyName, NULL, NULL, pszModule, &cbModule) && cbModule)
    {
        *piIcon = *piShortcutIcon = PathParseIconLocation(pszModule);
        pszRet = pszModule;
    }
    else
    {
        void *pData = NULL;
        DWORD dwAttributes = 0;
        LPTSTR pszPort = NULL;
        BOOL fDef;
        BOOL bIsFax = FALSE;

        // Try retrieving the information from hFolder if it's remote
        // to avoid hitting the net.
        //
        if (GetServer() && (pData = Printer_FolderGetPrinter(GetFolder(), pszPrinterName)))
        {
            dwAttributes = ((PFOLDER_PRINTER_DATA)pData)->Attributes;
            bIsFax = dwAttributes & PRINTER_ATTRIBUTE_FAX;

            LocalFree((HLOCAL)pData);
            pData = NULL;
        }
        else if (Printer_CheckNetworkPrinterByName(pszPrinterName, NULL))
        {
            // no remote fax icon if we have to resort to this
            // avoid hitting the network.
            dwAttributes = PRINTER_ATTRIBUTE_NETWORK;
        }
        else
        {
            pData = Printer_GetPrinterInfoStr(pszPrinterName, 5);
            if (pData)
            {
                dwAttributes = ((LPPRINTER_INFO_5)pData)->Attributes;
                pszPort = ((LPPRINTER_INFO_5)pData)->pPortName;
                bIsFax = dwAttributes & PRINTER_ATTRIBUTE_FAX;

                if (!bIsFax)
                {
                    // the last resort -- check by port name
                    bIsFax = !lstrcmp(pszPort, FAX_MONITOR_PORT_NAME);
                }
            }
        }

        // check if the delected printer is default
        fDef = IsDefaultPrinter(pszPrinterName, dwAttributes);

        if (dwAttributes & PRINTER_ATTRIBUTE_NETWORK)
        {
            if (bIsFax)
            {
                iStandardIcon = IDI_FAX_PRINTER_NET;
                iDefaultIcon = IDI_FAX_PRINTER_DEF_NET;
            }
            else
            {
                iStandardIcon = IDI_PRINTER_NET;
                iDefaultIcon = IDI_DEF_PRINTER_NET;
            }
        }
        else if (pszPort && !lstrcmp(pszPort, c_szFileColon))
        {
            iStandardIcon = IDI_PRINTER_FILE;
            iDefaultIcon = IDI_DEF_PRINTER_FILE;
        }
        else if (pszPort && !StrCmpNI(pszPort, c_szTwoSlashes, lstrlen(c_szTwoSlashes)))
        {
            iStandardIcon = IDI_PRINTER_NET;
            iDefaultIcon = IDI_DEF_PRINTER_NET;
        }
        else if (bIsFax)
        {
            iStandardIcon = IDI_FAX_PRINTER;
            iDefaultIcon = IDI_FAX_PRINTER_DEF;
        }
        else
        {
            iStandardIcon = IDI_PRINTER;
            iDefaultIcon = IDI_DEF_PRINTER;
        }

        // Shortcut icon never shows "default" checkmark...
        *piShortcutIcon = iStandardIcon;

        if (fDef)
            *piIcon = iDefaultIcon;
        else
            *piIcon = iStandardIcon;

        if (pData)
            LocalFree((HLOCAL)pData);
    }
    return pszRet;
}

////////////////////////////////////////////////////////
////////////////////////////////////////////////////////
//
// DUI WebView
//

// path to the scanners & cameras folder
const TCHAR g_szScanAndCam_Path[] =
    TEXT("::{20D04FE0-3AEA-1069-A2D8-08002B30309D}\\")
    TEXT("::{21EC2020-3AEA-1069-A2DD-08002B30309D}\\")
    TEXT("::{E211B736-43FD-11D1-9EFB-0000F8757FCD}");

// printer's folder webview callbacks namespace
namespace PF_WV_CB
{
    HRESULT WebviewVerbIsEnabled(CPrinterFolder::WV_VERB eVerbID, UINT uSelMask,
        IUnknown* pv, IShellItemArray *psiItemArray, BOOL *pbEnabled)
    {
        HRESULT hr = E_FAIL;

        CPrinterFolder *ppf;
        hr = IUnknown_QueryService(pv, CLSID_Printers, CLSID_Printers, (void**)&ppf);
        if (SUCCEEDED(hr))
        {
            IDataObject *pdo = NULL;

            if (psiItemArray)
            {
                hr = psiItemArray->BindToHandler(NULL,BHID_DataObject,IID_PPV_ARG(IDataObject,&pdo));
            }

            if (SUCCEEDED(hr))
            {

                hr = ppf->_WebviewCheckToUpdateDataObjectCache(pdo);
                if (SUCCEEDED(hr))
                {
                    hr = ppf->_WebviewVerbIsEnabled(eVerbID, uSelMask, pbEnabled);
                }

                ATOMICRELEASE(pdo);
            }
    
            ppf->Release();

        }

        return hr;
    }

    HRESULT WebviewVerbInvoke(CPrinterFolder::WV_VERB eVerbID, IUnknown* pv,IShellItemArray *psiItemArray)
    {
        CPrinterFolder *ppf;
        HRESULT hr = E_NOINTERFACE;
        if (SUCCEEDED(hr = IUnknown_QueryService(pv, CLSID_Printers, CLSID_Printers, (void**)&ppf)))
        {
            // just delegate the call to the printer's folder
            ULONG_PTR ulCookie = 0;
            if (SHActivateContext(&ulCookie))
            {
                hr = ppf->_WebviewVerbInvoke(eVerbID, pv, psiItemArray);
                SHDeactivateContext(ulCookie);
            }
            ppf->Release();
        }
        return hr;
    }

// get state handler
#define DEFINE_WEBVIEW_STATE_HANDLER(verb, eSelType)                \
{                                                                   \
    BOOL bEnabled = FALSE;                                          \
    HRESULT hr = WebviewVerbIsEnabled(                              \
        CPrinterFolder::##verb,                                     \
        CPrinterFolder::##eSelType,                                 \
            pv, psiItemArray, &bEnabled);                                    \
    *puisState = (SUCCEEDED(hr) ?                                   \
        (bEnabled ? UIS_ENABLED : UIS_HIDDEN) : UIS_HIDDEN);        \
    return hr;                                                      \
}                                                                   \

// invoke handler
#define DEFINE_WEBVIEW_INVOKE_HANDLER(verb)                         \
{                                                                   \
    return WebviewVerbInvoke(CPrinterFolder::##verb, pv, psiItemArray);  \
}                                                                   \

    ////////////////////////////////////////////////////////////////////////////////////
    // getState callbacks
    HRESULT CanADDPRINTER          (IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState)
    {
        DEFINE_WEBVIEW_STATE_HANDLER(WVIDM_ADDPRINTERWIZARD, SEL_ANY)
    }

    HRESULT CanSRVPROPS            (IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState)
    {
        DEFINE_WEBVIEW_STATE_HANDLER(WVIDM_SERVERPROPERTIES, SEL_ANY)
    }

    HRESULT CanSENDFAX             (IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState)
    {
        DEFINE_WEBVIEW_STATE_HANDLER(WVIDM_SENDFAXWIZARD, SEL_ANY)
    }

    HRESULT CanTROUBLESHOOTER      (IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState)
    {
        DEFINE_WEBVIEW_STATE_HANDLER(WVIDM_TROUBLESHOOTER, SEL_ANY)
    }

    HRESULT CanGOTOSUPPORT         (IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState)
    {
        DEFINE_WEBVIEW_STATE_HANDLER(WVIDM_GOTOSUPPORT, SEL_ANY)
    }

    HRESULT CanSETUPFAXING         (IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState)
    {
        DEFINE_WEBVIEW_STATE_HANDLER(WVIDM_SETUPFAXING, SEL_ANY)
    }

    HRESULT CanCREATELOCALFAX      (IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState)
    {
        DEFINE_WEBVIEW_STATE_HANDLER(WVIDM_CREATELOCALFAX, SEL_ANY)
    }

    HRESULT CanFLD_RENAME          (IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState)
    {
        DEFINE_WEBVIEW_STATE_HANDLER(WVIDM_RENAME, SEL_SINGLE_LINK)
    }

    HRESULT CanFLD_DELETE          (IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState)
    {
        DEFINE_WEBVIEW_STATE_HANDLER(WVIDM_DELETE, SEL_SINGLE_LINK)
    }

    HRESULT CanFLD_PROPERTIES      (IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState)
    {
        DEFINE_WEBVIEW_STATE_HANDLER(WVIDM_PROPERTIES, SEL_SINGLE_LINK)
    }

    HRESULT CanPRN_RENAME          (IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState)
    {
        DEFINE_WEBVIEW_STATE_HANDLER(WVIDM_RENAME, SEL_SINGLE_PRINTER)
    }

    HRESULT CanPRN_DELETE          (IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState)
    {
        DEFINE_WEBVIEW_STATE_HANDLER(WVIDM_DELETE, SEL_SINGLE_PRINTER)
    }

    HRESULT CanPRN_PROPERTIES      (IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState)
    {
        DEFINE_WEBVIEW_STATE_HANDLER(WVIDM_PROPERTIES, SEL_SINGLE_PRINTER)
    }

    HRESULT CanPRN_OPENQUEUE       (IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState)
    {
        DEFINE_WEBVIEW_STATE_HANDLER(WVIDM_OPENPRN, SEL_SINGLE_PRINTER)
    }

    HRESULT CanPRN_PREFERENCES     (IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState)
    {
        DEFINE_WEBVIEW_STATE_HANDLER(WVIDM_DOCUMENTDEFAULTS, SEL_SINGLE_PRINTER)
    }

    HRESULT CanPRN_PAUSE           (IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState)
    {
        DEFINE_WEBVIEW_STATE_HANDLER(WVIDM_PAUSEPRN, SEL_SINGLE_PRINTER)
    }

    HRESULT CanPRN_RESUME          (IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState)
    {
        DEFINE_WEBVIEW_STATE_HANDLER(WVIDM_RESUMEPRN, SEL_SINGLE_PRINTER)
    }

    HRESULT CanPRN_SHARE           (IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState)
    {
        DEFINE_WEBVIEW_STATE_HANDLER(WVIDM_SHARING, SEL_SINGLE_PRINTER)
    }

    HRESULT CanPRN_VENDORURL       (IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState)
    {
        DEFINE_WEBVIEW_STATE_HANDLER(WVIDM_VENDORURL, SEL_SINGLE_PRINTER)
    }

    HRESULT CanPRN_PRINTERURL      (IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState)
    {
        DEFINE_WEBVIEW_STATE_HANDLER(WVIDM_PRINTERURL, SEL_SINGLE_PRINTER)
    }

    HRESULT CanMUL_DELETE          (IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState)
    {
        DEFINE_WEBVIEW_STATE_HANDLER(WVIDM_DELETE, SEL_MULTI_PRINTER)
    }

    HRESULT CanMUL_PROPERTIES      (IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState)
    {
        DEFINE_WEBVIEW_STATE_HANDLER(WVIDM_PROPERTIES, SEL_MULTI_PRINTER)
    }

    HRESULT CanFLDMUL_DELETE       (IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState)
    {
        DEFINE_WEBVIEW_STATE_HANDLER(WVIDM_DELETE, SEL_MULTI_LINK)
    }

    HRESULT CanFLDMUL_PROPERTIES   (IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState)
    {
        DEFINE_WEBVIEW_STATE_HANDLER(WVIDM_PROPERTIES, SEL_MULTI_LINK)
    }

    HRESULT CanANYMUL_DELETE       (IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState)
    {
        DEFINE_WEBVIEW_STATE_HANDLER(WVIDM_DELETE, SEL_MULTI_MIXED)
    }

    HRESULT CanANYMUL_PROPERTIES   (IUnknown* pv, IShellItemArray *psiItemArray, BOOL fOkToBeSlow, UISTATE* puisState)
    {
        DEFINE_WEBVIEW_STATE_HANDLER(WVIDM_PROPERTIES, SEL_MULTI_MIXED)
    }

    ////////////////////////////////////////////////////////////////////////////////////
    // Invoke callbacks
    //

    HRESULT OnADDPRINTER          (IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc)
    {
        DEFINE_WEBVIEW_INVOKE_HANDLER(WVIDM_ADDPRINTERWIZARD)
    }

    HRESULT OnSRVPROPS            (IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc)
    {
        DEFINE_WEBVIEW_INVOKE_HANDLER(WVIDM_SERVERPROPERTIES)
    }

    HRESULT OnSENDFAX             (IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc)
    {
        DEFINE_WEBVIEW_INVOKE_HANDLER(WVIDM_SENDFAXWIZARD)
    }

    HRESULT OnTROUBLESHOOTER      (IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc)
    {
        DEFINE_WEBVIEW_INVOKE_HANDLER(WVIDM_TROUBLESHOOTER)
    }

    HRESULT OnGOTOSUPPORT         (IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc)
    {
        DEFINE_WEBVIEW_INVOKE_HANDLER(WVIDM_GOTOSUPPORT)
    }

    HRESULT OnSETUPFAXING         (IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc)
    {
        DEFINE_WEBVIEW_INVOKE_HANDLER(WVIDM_SETUPFAXING)
    }

    HRESULT OnCREATELOCALFAX      (IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc)
    {
        DEFINE_WEBVIEW_INVOKE_HANDLER(WVIDM_CREATELOCALFAX)
    }

    HRESULT OnFLD_RENAME          (IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc)
    {
        DEFINE_WEBVIEW_INVOKE_HANDLER(WVIDM_RENAME)
    }

    HRESULT OnFLD_DELETE          (IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc)
    {
        DEFINE_WEBVIEW_INVOKE_HANDLER(WVIDM_DELETE)
    }

    HRESULT OnFLD_PROPERTIES      (IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc)
    {
        DEFINE_WEBVIEW_INVOKE_HANDLER(WVIDM_PROPERTIES)
    }

    HRESULT OnPRN_RENAME          (IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc)
    {
        DEFINE_WEBVIEW_INVOKE_HANDLER(WVIDM_RENAME)
    }

    HRESULT OnPRN_DELETE          (IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc)
    {
        DEFINE_WEBVIEW_INVOKE_HANDLER(WVIDM_DELETE)
    }

    HRESULT OnPRN_PROPERTIES      (IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc)
    {
        DEFINE_WEBVIEW_INVOKE_HANDLER(WVIDM_PROPERTIES)
    }

    HRESULT OnPRN_OPENQUEUE       (IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc)
    {
        DEFINE_WEBVIEW_INVOKE_HANDLER(WVIDM_OPENPRN)
    }

    HRESULT OnPRN_PREFERENCES     (IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc)
    {
        DEFINE_WEBVIEW_INVOKE_HANDLER(WVIDM_DOCUMENTDEFAULTS)
    }

    HRESULT OnPRN_PAUSE           (IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc)
    {
        DEFINE_WEBVIEW_INVOKE_HANDLER(WVIDM_PAUSEPRN)
    }

    HRESULT OnPRN_RESUME          (IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc)
    {
        DEFINE_WEBVIEW_INVOKE_HANDLER(WVIDM_RESUMEPRN)
    }

    HRESULT OnPRN_SHARE           (IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc)
    {
        DEFINE_WEBVIEW_INVOKE_HANDLER(WVIDM_SHARING)
    }

    HRESULT OnPRN_VENDORURL       (IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc)
    {
        DEFINE_WEBVIEW_INVOKE_HANDLER(WVIDM_VENDORURL)
    }

    HRESULT OnPRN_PRINTERURL      (IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc)
    {
        DEFINE_WEBVIEW_INVOKE_HANDLER(WVIDM_PRINTERURL)
    }

    HRESULT OnMUL_DELETE          (IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc)
    {
        DEFINE_WEBVIEW_INVOKE_HANDLER(WVIDM_DELETE)
    }

    HRESULT OnMUL_PROPERTIES      (IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc)
    {
        DEFINE_WEBVIEW_INVOKE_HANDLER(WVIDM_PROPERTIES)
    }

    HRESULT OnFLDMUL_DELETE       (IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc)
    {
        DEFINE_WEBVIEW_INVOKE_HANDLER(WVIDM_DELETE)
    }

    HRESULT OnFLDMUL_PROPERTIES   (IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc)
    {
        DEFINE_WEBVIEW_INVOKE_HANDLER(WVIDM_PROPERTIES)
    }

    HRESULT OnANYMUL_DELETE       (IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc)
    {
        DEFINE_WEBVIEW_INVOKE_HANDLER(WVIDM_DELETE)
    }

    HRESULT OnANYMUL_PROPERTIES   (IUnknown* pv, IShellItemArray *psiItemArray, IBindCtx *pbc)
    {
        DEFINE_WEBVIEW_INVOKE_HANDLER(WVIDM_PROPERTIES)
    }

}; // namespace PFWV_CALLBACKS

///////////////////////////////////////////////////////////////////
// GUIDS for the printer's folder webview commands
//

// *************************************** PRINTER COMMANDS ***************************************

// {D351FCED-C179-41ae-AD50-CAAC892DF24A}
DEFINE_GUID(UICID_Printers_OpenQueue,   0xd351fced, 0xc179, 0x41ae, 0xad, 0x50, 0xca, 0xac, 0x89, 0x2d, 0xf2, 0x4a);

// {A263A9D6-F1BA-4607-B7AA-CF471DEA17FF}
DEFINE_GUID(UICID_Printers_Preferences, 0xa263a9d6, 0xf1ba, 0x4607, 0xb7, 0xaa, 0xcf, 0x47, 0x1d, 0xea, 0x17, 0xff);

// {73149B3F-1E6D-4b00-9047-4576BC853A41}
DEFINE_GUID(UICID_Printers_Pause,       0x73149b3f, 0x1e6d, 0x4b00, 0x90, 0x47, 0x45, 0x76, 0xbc, 0x85, 0x3a, 0x41);

// {A7920561-FAAD-44a0-8C4C-FD769587F807}
DEFINE_GUID(UICID_Printers_Resume,      0xa7920561, 0xfaad, 0x44a0, 0x8c, 0x4c, 0xfd, 0x76, 0x95, 0x87, 0xf8, 0x7);

// {538536A1-5BC3-4b9c-8287-7562D53BE380}
DEFINE_GUID(UICID_Printers_Share,       0x538536a1, 0x5bc3, 0x4b9c, 0x82, 0x87, 0x75, 0x62, 0xd5, 0x3b, 0xe3, 0x80);

// {1461CC4A-308E-4ae5-B03A-F9682E3232B0}
DEFINE_GUID(UICID_Printers_Properties,  0x1461cc4a, 0x308e, 0x4ae5, 0xb0, 0x3a, 0xf9, 0x68, 0x2e, 0x32, 0x32, 0xb0);

// {A1F67BA0-5DEF-4e12-9E64-EA77670BFF26}
DEFINE_GUID(UICID_Printers_VendorURL,   0xa1f67ba0, 0x5def, 0x4e12, 0x9e, 0x64, 0xea, 0x77, 0x67, 0xb, 0xff, 0x26);

// {8D4D326C-30A4-47dc-BF51-4BC5863883E3}
DEFINE_GUID(UICID_Printers_PrinterURL,  0x8d4d326c, 0x30a4, 0x47dc, 0xbf, 0x51, 0x4b, 0xc5, 0x86, 0x38, 0x83, 0xe3);

// *************************************** STANDARD COMMANDS ***************************************

// those are defined in shlguidp.h
//
// UICID_Rename
// UICID_Delete

// *************************************** COMMON COMMANDS ***************************************

// {6D9778A5-C27D-464a-8511-36F7243BD0ED}
DEFINE_GUID(UICID_Printers_AddPrinter,      0x6d9778a5, 0xc27d, 0x464a, 0x85, 0x11, 0x36, 0xf7, 0x24, 0x3b, 0xd0, 0xed);

// {E1391312-2DAC-48db-994B-0BF22DB7576D}
DEFINE_GUID(UICID_Printers_SrvProps,        0xe1391312, 0x2dac, 0x48db, 0x99, 0x4b, 0xb, 0xf2, 0x2d, 0xb7, 0x57, 0x6d);

// {27DC81DF-73DB-406a-9A86-5EF38BA67CA8}
DEFINE_GUID(UICID_Printers_SendFax,         0x27dc81df, 0x73db, 0x406a, 0x9a, 0x86, 0x5e, 0xf3, 0x8b, 0xa6, 0x7c, 0xa8);

// {A21E3CCF-68D4-49cd-99A2-A272E9FF3A20}
DEFINE_GUID(UICID_Printers_GotoSupport, 0xa21e3ccf, 0x68d4, 0x49cd, 0x99, 0xa2, 0xa2, 0x72, 0xe9, 0xff, 0x3a, 0x20);

// {793542CF-5720-49f3-9A09-CAA3079508B9}
DEFINE_GUID(UICID_Printers_Troubleshooter,  0x793542cf, 0x5720, 0x49f3, 0x9a, 0x9, 0xca, 0xa3, 0x7, 0x95, 0x8, 0xb9);

// {EED61EFC-6A20-48dd-82FD-958DFDB96F1E}
DEFINE_GUID(UICID_Printers_SetupFaxing,     0xeed61efc, 0x6a20, 0x48dd, 0x82, 0xfd, 0x95, 0x8d, 0xfd, 0xb9, 0x6f, 0x1e);

// {224ACF1D-BB4E-4979-A8B8-D078E2154BCC}
DEFINE_GUID(UICID_Printers_CreateFax,       0x224acf1d, 0xbb4e, 0x4979, 0xa8, 0xb8, 0xd0, 0x78, 0xe2, 0x15, 0x4b, 0xcc);


///////////////////////////////////////////////////////////////////
// Header items
//

const WVTASKITEM
g_cPrintersVW_HeaderTasks =
    WVTI_HEADER(
        L"shell32.dll",                     // module where the resources are
        IDS_PRINTERS_WV_HEADER_TASKS,       // statis header for all cases
        IDS_PRINTERS_WV_HEADER_TASKS_TT     // tooltip
        );

const WVTASKITEM
g_cPrintersVW_HeaderSeeAlso =
    WVTI_HEADER(
        L"shell32.dll",                     // module where the resources are
        IDS_PRINTERS_WV_HEADER_SEEALSO,     // statis header for all cases
        IDS_PRINTERS_WV_HEADER_SEEALSO_TT   // tooltip
        );

// **************************************************************************************
// ****************************** sample command definition *****************************
//
//    WVTI_ENTRY_ALL_TITLE(
//        UICID_MyCmd,                                      // command GUID
//        L"shell32.dll",                                   // module
//        IDS_PRINTERS_WV_MYCMD,                            // no selection
//        IDS_PRINTERS_WV_MYCMD,                            // 1 file
//        IDS_PRINTERS_WV_MYCMD,                            // 1 folder selected
//        IDS_PRINTERS_WV_MYCMD,                            // multiple selection
//        IDS_PRINTERS_WV_MYCMD_TT,                         // tooltip
//        IDI_PRINTERS_WV_MYCMD,                            // icon
//        PF_WV_CB::CanMYCMD,                               // get UI state callback
//        PF_WV_CB::OnMYCMD                                 // OnVerb callback
//        ),
//

const WVTASKITEM g_cPrintersTasks[] =
{
    ////////////////////////////////////////////////////////////////////////////////////
    // commands in the 'Tasks' section when there is no selection
    ////////////////////////////////////////////////////////////////////////////////////

    // add printer command - always enabled regardless of the selection type!
    WVTI_ENTRY_ALL_TITLE(
        UICID_Printers_AddPrinter,                          // command GUID
        L"shell32.dll",                                     // module
        IDS_PRINTERS_WV_ADDPRINTER,                         // no selection
        IDS_PRINTERS_WV_ADDPRINTER,                         // 1 file
        IDS_PRINTERS_WV_ADDPRINTER,                         // 1 folder selected
        IDS_PRINTERS_WV_ADDPRINTER,                         // multiple selection
        IDS_PRINTERS_WV_ADDPRINTER_TT,                      // tooltip
        IDI_PRINTERS_WV_ADDPRINTER,                         // icon
        PF_WV_CB::CanADDPRINTER,                            // get UI state callback
        PF_WV_CB::OnADDPRINTER                              // OnVerb callback
        ),

    // server properties command
    WVTI_ENTRY_ALL_TITLE(
        UICID_Printers_SrvProps,                            // command GUID
        L"shell32.dll",                                     // module
        IDS_PRINTERS_WV_SRVPROPS,                           // no selection
        0,                                                  // 1 file
        0,                                                  // 1 folder selected
        0,                                                  // multiple selection
        IDS_PRINTERS_WV_SRVPROPS_TT,                        // tooltip
        IDI_PRINTERS_WV_SRVPROPS,                           // icon
        PF_WV_CB::CanSRVPROPS,                              // get UI state callback
        PF_WV_CB::OnSRVPROPS                                // OnVerb callback
        ),

    // send fax command
    WVTI_ENTRY_ALL_TITLE(
        UICID_Printers_SendFax,                             // command GUID
        L"shell32.dll",                                     // module
        IDS_PRINTERS_WV_SENDFAX,                            // no selection
        0,                                                  // 1 file
        0,                                                  // 1 folder selected
        0,                                                  // multiple selection
        IDS_PRINTERS_WV_SENDFAX_TT,                         // tooltip
        IDI_PRINTERS_WV_SENDFAX,                            // icon
        PF_WV_CB::CanSENDFAX,                               // get UI state callback
        PF_WV_CB::OnSENDFAX                                 // OnVerb callback
        ),

    // setup faxing
    WVTI_ENTRY_ALL_TITLE(
        UICID_Printers_SetupFaxing,                         // command GUID
        L"shell32.dll",                                     // module
        IDS_PRINTERS_WV_SETUPFAXING,                        // no selection
        0,                                                  // 1 file
        0,                                                  // 1 folder selected
        0,                                                  // multiple selection
        IDS_PRINTERS_WV_SETUPFAXING_TT,                     // tooltip
        IDI_PRINTERS_WV_FAXING,                             // icon
        PF_WV_CB::CanSETUPFAXING,                           // get UI state callback
        PF_WV_CB::OnSETUPFAXING                             // OnVerb callback
        ),

    // create fax printer
    WVTI_ENTRY_ALL_TITLE(
        UICID_Printers_CreateFax,                           // command GUID
        L"shell32.dll",                                     // module
        IDS_PRINTERS_WV_CREATEFAXPRN,                       // no selection
        0,                                                  // 1 file
        0,                                                  // 1 folder selected
        0,                                                  // multiple selection
        IDS_PRINTERS_WV_CREATEFAXPRN_TT,                    // tooltip
        IDI_PRINTERS_WV_FAXING,                             // icon
        PF_WV_CB::CanCREATELOCALFAX,                        // get UI state callback
        PF_WV_CB::OnCREATELOCALFAX                          // OnVerb callback
        ),

    // open printer queue command
    WVTI_ENTRY_ALL_TITLE(
        UICID_Printers_OpenQueue,                           // command GUID
        L"shell32.dll",                                     // module
        0,                                                  // no selection
        IDS_PRINTERS_WV_PRN_OPENQUEUE,                      // 1 file
        0,                                                  // 1 folder selected
        0,                                                  // multiple selection
        IDS_PRINTERS_WV_PRN_OPENQUEUE_TT,                   // tooltip
        IDI_PRINTERS_WV_OPENQUEUE,                          // icon
        PF_WV_CB::CanPRN_OPENQUEUE,                         // get UI state callback
        PF_WV_CB::OnPRN_OPENQUEUE                           // OnVerb callback
        ),

    // single selection printer preferences
    WVTI_ENTRY_ALL_TITLE(
        UICID_Printers_Preferences,                         // command GUID
        L"shell32.dll",                                     // module
        0,                                                  // no selection
        IDS_PRINTERS_WV_PRN_PREFERENCES,                    // 1 file
        0,                                                  // 1 folder selected
        0,                                                  // multiple selection
        IDS_PRINTERS_WV_PRN_PREFERENCES_TT,                 // tooltip
        IDI_PRINTERS_WV_PREFERENCES,                        // icon
        PF_WV_CB::CanPRN_PREFERENCES,                       // get UI state callback
        PF_WV_CB::OnPRN_PREFERENCES                         // OnVerb callback
        ),

    // pause printer
    WVTI_ENTRY_ALL_TITLE(
        UICID_Printers_Pause,                               // command GUID
        L"shell32.dll",                                     // module
        0,                                                  // no selection
        IDS_PRINTERS_WV_PRN_PAUSE,                          // 1 file
        0,                                                  // 1 folder selected
        0,                                                  // multiple selection
        IDS_PRINTERS_WV_PRN_PAUSE_TT,                       // tooltip
        IDI_PRINTERS_WV_PAUSE,                              // icon
        PF_WV_CB::CanPRN_PAUSE,                             // get UI state callback
        PF_WV_CB::OnPRN_PAUSE                               // OnVerb callback
        ),

    // resume printer
    WVTI_ENTRY_ALL_TITLE(
        UICID_Printers_Resume,                              // command GUID
        L"shell32.dll",                                     // module
        0,                                                  // no selection
        IDS_PRINTERS_WV_PRN_RESUME,                         // 1 file
        0,                                                  // 1 folder selected
        0,                                                  // multiple selection
        IDS_PRINTERS_WV_PRN_RESUME_TT,                      // tooltip
        IDI_PRINTERS_WV_RESUME,                             // icon
        PF_WV_CB::CanPRN_RESUME,                            // get UI state callback
        PF_WV_CB::OnPRN_RESUME                              // OnVerb callback
        ),

    // single selection share printer
    WVTI_ENTRY_ALL_TITLE(
        UICID_Printers_Share,                               // command GUID
        L"shell32.dll",                                     // module
        0,                                                  // no selection
        IDS_PRINTERS_WV_PRN_SHARE,                          // 1 file
        0,                                                  // 1 folder selected
        0,                                                  // multiple selection
        IDS_PRINTERS_WV_PRN_SHARE_TT,                       // tooltip
        IDI_PRINTERS_WV_SHARE,                              // icon
        PF_WV_CB::CanPRN_SHARE,                             // get UI state callback
        PF_WV_CB::OnPRN_SHARE                               // OnVerb callback
        ),

    // single sel. rename for printer
    WVTI_ENTRY_ALL_TITLE(
        UICID_Rename,                                       // command GUID
        L"shell32.dll",                                     // module
        0,                                                  // no selection
        IDS_PRINTERS_WV_PRN_RENAME,                         // 1 file
        0,                                                  // 1 folder selected
        0,                                                  // multiple selection
        IDS_PRINTERS_WV_PRN_RENAME_TT,                      // tooltip
        IDI_PRINTERS_WV_RENAME,                             // icon
        PF_WV_CB::CanPRN_RENAME,                            // get UI state callback
        PF_WV_CB::OnPRN_RENAME                              // OnVerb callback
        ),

    // single sel. rename for link
    WVTI_ENTRY_ALL_TITLE(
        UICID_Rename,                                       // command GUID
        L"shell32.dll",                                     // module
        0,                                                  // no selection
        IDS_PRINTERS_WV_FLD_RENAME,                         // 1 file
        0,                                                  // 1 folder selected
        0,                                                  // multiple selection
        IDS_PRINTERS_WV_FLD_RENAME_TT,                      // tooltip
        IDI_PRINTERS_WV_RENAME,                             // icon
        PF_WV_CB::CanFLD_RENAME,                            // get UI state callback
        PF_WV_CB::OnFLD_RENAME                              // OnVerb callback
        ),

    // single sel. delete for printer
    WVTI_ENTRY_ALL_TITLE(
        UICID_Delete,                                       // command GUID
        L"shell32.dll",                                     // module
        0,                                                  // no selection
        IDS_PRINTERS_WV_PRN_DELETE,                         // 1 file
        0,                                                  // 1 folder selected
        0,                                                  // multiple selection
        IDS_PRINTERS_WV_PRN_DELETE_TT,                      // tooltip
        IDI_PRINTERS_WV_DELETE,                             // icon
        PF_WV_CB::CanPRN_DELETE,                            // get UI state callback
        PF_WV_CB::OnPRN_DELETE                              // OnVerb callback
        ),

    // single sel. delete for link
    WVTI_ENTRY_ALL_TITLE(
        UICID_Delete,                                       // command GUID
        L"shell32.dll",                                     // module
        0,                                                  // no selection
        IDS_PRINTERS_WV_FLD_DELETE,                         // 1 file
        0,                                                  // 1 folder selected
        0,                                                  // multiple selection
        IDS_PRINTERS_WV_FLD_DELETE_TT,                      // tooltip
        IDI_PRINTERS_WV_DELETE,                             // icon
        PF_WV_CB::CanFLD_DELETE,                            // get UI state callback
        PF_WV_CB::OnFLD_DELETE                              // OnVerb callback
        ),

    // multi sel. delete for printers
    WVTI_ENTRY_ALL_TITLE(
        UICID_Delete,                                       // command GUID
        L"shell32.dll",                                     // module
        0,                                                  // no selection
        0,                                                  // 1 file
        0,                                                  // 1 folder selected
        IDS_PRINTERS_WV_MUL_DELETE,                         // multiple selection
        IDS_PRINTERS_WV_MUL_DELETE_TT,                      // tooltip
        IDI_PRINTERS_WV_DELETE,                             // icon
        PF_WV_CB::CanMUL_DELETE,                            // get UI state callback
        PF_WV_CB::OnMUL_DELETE                              // OnVerb callback
        ),

    // multi sel. delete for links
    //
    // NOTE: note that this command will be enabled for
    // the single selection as well because we don't really know
    // what has been selected until we verify the selection type
    WVTI_ENTRY_ALL_TITLE(
        UICID_Delete,                                       // command GUID
        L"shell32.dll",                                     // module
        0,                                                  // no selection
        IDS_PRINTERS_WV_FLDMUL_DELETE,                      // 1 file
        0,                                                  // 1 folder selected
        IDS_PRINTERS_WV_FLDMUL_DELETE,                      // multiple selection
        IDS_PRINTERS_WV_FLDMUL_DELETE_TT,                   // tooltip
        IDI_PRINTERS_WV_DELETE,                             // icon
        PF_WV_CB::CanFLDMUL_DELETE,                         // get UI state callback
        PF_WV_CB::OnFLDMUL_DELETE                           // OnVerb callback
        ),

    // multi sel. delete for mixed objects...
    //
    // NOTE: note that this command will be enabled for
    // the single selection as well because we don't really know
    // what has been selected until we verify the selection type
    WVTI_ENTRY_ALL_TITLE(
        UICID_Delete,                                       // command GUID
        L"shell32.dll",                                     // module
        0,                                                  // no selection
        IDS_PRINTERS_WV_ANYMUL_DELETE,                      // 1 file
        0,                                                  // 1 folder selected
        IDS_PRINTERS_WV_ANYMUL_DELETE,                      // multiple selection
        IDS_PRINTERS_WV_ANYMUL_DELETE_TT,                   // tooltip
        IDI_PRINTERS_WV_DELETE,                             // icon
        PF_WV_CB::CanANYMUL_DELETE,                         // get UI state callback
        PF_WV_CB::OnANYMUL_DELETE                           // OnVerb callback
        ),

    // single sel. properties for printer
    WVTI_ENTRY_ALL_TITLE(
        UICID_Printers_Properties,                          // command GUID
        L"shell32.dll",                                     // module
        0,                                                  // no selection
        IDS_PRINTERS_WV_PRN_PROPERTIES,                     // 1 file
        0,                                                  // 1 folder selected
        0,                                                  // multiple selection
        IDS_PRINTERS_WV_PRN_PROPERTIES_TT,                  // tooltip
        IDI_PRINTERS_WV_PROPERTIES,                         // icon
        PF_WV_CB::CanPRN_PROPERTIES,                        // get UI state callback
        PF_WV_CB::OnPRN_PROPERTIES                          // OnVerb callback
        ),

    // single sel. properties for link
    WVTI_ENTRY_ALL_TITLE(
        UICID_Printers_Properties,                          // command GUID
        L"shell32.dll",                                     // module
        0,                                                  // no selection
        IDS_PRINTERS_WV_FLD_PROPERTIES,                     // 1 file
        0,                                                  // 1 folder selected
        0,                                                  // multiple selection
        IDS_PRINTERS_WV_FLD_PROPERTIES_TT,                  // tooltip
        IDI_PRINTERS_WV_PROPERTIES,                         // icon
        PF_WV_CB::CanFLD_PROPERTIES,                        // get UI state callback
        PF_WV_CB::OnFLD_PROPERTIES                          // OnVerb callback
        ),

    // multi sel. properties of printers
    WVTI_ENTRY_ALL_TITLE(
        UICID_Printers_Properties,                          // command GUID
        L"shell32.dll",                                     // module
        0,                                                  // no selection
        0,                                                  // 1 file
        0,                                                  // 1 folder selected
        IDS_PRINTERS_WV_MUL_PROPERTIES,                     // multiple selection
        IDS_PRINTERS_WV_MUL_PROPERTIES_TT,                  // tooltip
        IDI_PRINTERS_WV_PROPERTIES,                         // icon
        PF_WV_CB::CanMUL_PROPERTIES,                        // get UI state callback
        PF_WV_CB::OnMUL_PROPERTIES                          // OnVerb callback
        ),

    // multi sel. properties of links
    //
    // NOTE: note that this command will be enabled for
    // the single selection as well because we don't really know
    // what has been selected until we verify the selection type
    WVTI_ENTRY_ALL_TITLE(
        UICID_Printers_Properties,                          // command GUID
        L"shell32.dll",                                     // module
        0,                                                  // no selection
        IDS_PRINTERS_WV_FLDMUL_PROPERTIES,                  // 1 file
        0,                                                  // 1 folder selected
        IDS_PRINTERS_WV_FLDMUL_PROPERTIES,                  // multiple selection
        IDS_PRINTERS_WV_FLDMUL_PROPERTIES_TT,               // tooltip
        IDI_PRINTERS_WV_PROPERTIES,                         // icon
        PF_WV_CB::CanFLDMUL_PROPERTIES,                     // get UI state callback
        PF_WV_CB::OnFLDMUL_PROPERTIES                       // OnVerb callback
        ),

    // multi sel. properties of mixed objects
    //
    // NOTE: note that this command will be enabled for
    // the single selection as well because we don't really know
    // what has been selected until we verify the selection type
    WVTI_ENTRY_ALL_TITLE(
        UICID_Printers_Properties,                          // command GUID
        L"shell32.dll",                                     // module
        0,                                                  // no selection
        IDS_PRINTERS_WV_ANYMUL_PROPERTIES,                  // 1 file
        0,                                                  // 1 folder selected
        IDS_PRINTERS_WV_ANYMUL_PROPERTIES,                  // multiple selection
        IDS_PRINTERS_WV_ANYMUL_PROPERTIES_TT,               // tooltip
        IDI_PRINTERS_WV_PROPERTIES,                         // icon
        PF_WV_CB::CanANYMUL_PROPERTIES,                     // get UI state callback
        PF_WV_CB::OnANYMUL_PROPERTIES                       // OnVerb callback
        ),
};

const WVTASKITEM g_cPrintersSeeAlso[] =
{
    ////////////////////////////////////////////////////////////////////////////////////
    // commands in the 'See Also' section when there is no selection
    ////////////////////////////////////////////////////////////////////////////////////

    // open print troubleshooter
    WVTI_ENTRY_ALL_TITLE(
        UICID_Printers_Troubleshooter,                      // command GUID
        L"shell32.dll",                                     // module
        IDS_PRINTERS_WV_TROUBLESHOOTER,                     // no selection
        0,                                                  // 1 file
        0,                                                  // 1 folder selected
        0,                                                  // multiple selection
        IDS_PRINTERS_WV_TROUBLESHOOTER_TT,                  // tooltip
        IDI_PRINTERS_WV_TROUBLESHOOTER,                     // icon
        PF_WV_CB::CanTROUBLESHOOTER,                        // get UI state callback
        PF_WV_CB::OnTROUBLESHOOTER                          // OnVerb callback
        ),

    // goto support
    WVTI_ENTRY_ALL_TITLE(
        UICID_Printers_GotoSupport,                         // command GUID
        L"shell32.dll",                                     // module
        IDS_PRINTERS_WV_GOTOSUPPORT,                        // no selection
        0,                                                  // 1 file
        0,                                                  // 1 folder selected
        0,                                                  // multiple selection
        IDS_PRINTERS_WV_GOTOSUPPORT_TT,                     // tooltip
        IDI_PRINTERS_WV_GOTOSUPPORT,                        // icon
        PF_WV_CB::CanGOTOSUPPORT,                           // get UI state callback
        PF_WV_CB::OnGOTOSUPPORT                             // OnVerb callback
        ),

    ////////////////////////////////////////////////////////////////////////////////////
    // commands in the 'See Also' section when there is 1 printer selected
    ////////////////////////////////////////////////////////////////////////////////////

    // goto vendor URL command
    WVTI_ENTRY_ALL_TITLE(
        UICID_Printers_VendorURL,                           // command GUID
        L"shell32.dll",                                     // module
        0,                                                  // no selection
        IDS_PRINTERS_WV_PRN_VENDORURL,                      // 1 file
        0,                                                  // 1 folder selected
        0,                                                  // multiple selection
        IDS_PRINTERS_WV_PRN_VENDORURL_TT,                   // tooltip
        IDI_PRINTERS_WV_VENDORURL,                          // icon
        PF_WV_CB::CanPRN_VENDORURL,                         // get UI state callback
        PF_WV_CB::OnPRN_VENDORURL                           // OnVerb callback
        ),

    // goto printer URL command
    WVTI_ENTRY_ALL_TITLE(
        UICID_Printers_PrinterURL,                          // command GUID
        L"shell32.dll",                                     // module
        0,                                                  // no selection
        IDS_PRINTERS_WV_PRN_PRINTERURL,                     // 1 file
        0,                                                  // 1 folder selected
        0,                                                  // multiple selection
        IDS_PRINTERS_WV_PRN_PRINTERURL_TT,                  // tooltip
        IDI_PRINTERS_WV_PRINTERURL,                         // icon
        PF_WV_CB::CanPRN_PRINTERURL,                        // get UI state callback
        PF_WV_CB::OnPRN_PRINTERURL                          // OnVerb callback
        ),
};

// DUI webview impl.
HRESULT CPrinterFolder::GetWebViewLayout(IUnknown *pv, UINT uViewMode, SFVM_WEBVIEW_LAYOUT_DATA* pData)
{
    pData->dwLayout = SFVMWVL_NORMAL;
    return S_OK;
}

HRESULT CPrinterFolder::GetWebViewContent(IUnknown *pv, SFVM_WEBVIEW_CONTENT_DATA* pData)
{
    // those must be NULL when called
    ASSERT(NULL == pData->pIntroText);
    ASSERT(NULL == pData->pSpecialTaskHeader);
    ASSERT(NULL == pData->pFolderTaskHeader);
    ASSERT(NULL == pData->penumOtherPlaces);

    LPCTSTR rgCsidls[] = { g_szScanAndCam_Path, MAKEINTRESOURCE(CSIDL_PERSONAL), MAKEINTRESOURCE(CSIDL_MYPICTURES), MAKEINTRESOURCE(CSIDL_DRIVES) };
    HRESULT hr = CreateIEnumIDListOnCSIDLs(_pidl, rgCsidls, ARRAYSIZE(rgCsidls), &pData->penumOtherPlaces);
    if (FAILED(hr) ||
        FAILED(hr = Create_IUIElement(&g_cPrintersVW_HeaderTasks, &pData->pSpecialTaskHeader)) ||
        FAILED(hr = Create_IUIElement(&g_cPrintersVW_HeaderSeeAlso, &pData->pFolderTaskHeader)))
    {
        // something has failed - cleanup
        IUnknown_SafeReleaseAndNullPtr(pData->pIntroText);
        IUnknown_SafeReleaseAndNullPtr(pData->pSpecialTaskHeader);
        IUnknown_SafeReleaseAndNullPtr(pData->pFolderTaskHeader);
        IUnknown_SafeReleaseAndNullPtr(pData->penumOtherPlaces);
    }

    return hr;
}

HRESULT CPrinterFolder::GetWebViewTasks(IUnknown *pv, SFVM_WEBVIEW_TASKSECTION_DATA* pTasks)
{
    ZeroMemory(pTasks, sizeof(*pTasks));

    HRESULT hr = S_OK;
    if (FAILED(hr = Create_IEnumUICommand(pv, g_cPrintersTasks,
            ARRAYSIZE(g_cPrintersTasks), &pTasks->penumSpecialTasks)) ||
        FAILED(hr = Create_IEnumUICommand(pv, g_cPrintersSeeAlso,
            ARRAYSIZE(g_cPrintersSeeAlso), &pTasks->penumFolderTasks)))
    {
        // something has failed - cleanup.
        IUnknown_SafeReleaseAndNullPtr(pTasks->penumSpecialTasks);
        IUnknown_SafeReleaseAndNullPtr(pTasks->penumFolderTasks);
    }
    else
    {
        // request to update webview each time the contents change
        pTasks->dwUpdateFlags = SFVMWVTSDF_CONTENTSCHANGE;
    }

    return hr;
}

HRESULT CPrinterFolder::SplitSelection(IDataObject *pdo,
    UINT *puSelType, IDataObject **ppdoPrinters, IDataObject **ppdoLinks)
{
    HRESULT hr = E_INVALIDARG;
    if (pdo)
    {
        hr = S_OK;
        UINT uSel = SEL_NONE;
        IDataObject *pdoPrinters = NULL;
        IDataObject *pdoLinks = NULL;

        // create a PIDL array from the passed in data object
        STGMEDIUM medium, mediumAux;
        LPIDA pida = NULL, pidaAux = NULL;
        pida = DataObj_GetHIDA(pdo, &medium);

        // now we'll query this data object for SID_SAuxDataObject to see if we have such
        IDataObject *pdoAux;
        if (SUCCEEDED(IUnknown_QueryService(pdo, SID_SAuxDataObject, IID_PPV_ARG(IDataObject, &pdoAux))))
        {
            pidaAux = DataObj_GetHIDA(pdoAux, &mediumAux);
        }
        else
        {
            pdoAux = NULL;
        }

        // check to see if PIDL array is created
        if (pida && pida->cidl)
        {
            PIDLTYPE pidlType;
            LPCITEMIDLIST pidl;
            UINT uPrinters = 0, uLinks = 0, uAddPrn = 0;

            // walk through the PIDLs array to count the number of PIDLs of each type
            for (UINT i = 0; i < pida->cidl; i++)
            {
                pidl = (LPCITEMIDLIST)IDA_GetIDListPtr(pida, i);
                pidlType = _IDListType(pidl);

                if (HOOD_COL_PRINTER == pidlType)
                {
                    // this is a printer PIDL - it could be a printer object
                    // or the add printer wizard special PIDL
                    if (_IsAddPrinter((LPCIDPRINTER)pidl))
                    {
                        // this is the wizard object
                        uAddPrn++;
                    }
                    else
                    {
                        // this is a regular printer object
                        uPrinters++;
                    }
                }
                else
                {
                    // not a printer PIDL - link is the only other possiblity
                    uLinks++;
                }
            }

            if (pidaAux)
            {
                // the auxiliary data object (if any) can contain only links
                uLinks += pidaAux->cidl;
            }

            // determine the selection type
            UINT uTotal = uPrinters + uLinks + uAddPrn;
            if (uTotal)
            {
                if (1 == uTotal)
                {
                    // single selection case
                    if (uPrinters)
                    {
                        pdoPrinters = pdo;
                        uSel = SEL_SINGLE_PRINTER;
                    }
                    else if (uLinks)
                    {
                        pdoLinks = pdo;
                        uSel = SEL_SINGLE_LINK;
                    }
                    else
                    {
                        pdoPrinters = pdo;
                        uSel = SEL_SINGLE_ADDPRN;
                    }
                }
                else
                {
                    // multiple selection case
                    if (0 == uLinks)
                    {
                        // only printers are selected
                        pdoPrinters = pdo;
                        uSel = SEL_MULTI_PRINTER;
                    }
                    else if (0 == uPrinters)
                    {
                        if (uAddPrn)
                        {
                            // only add printer wizard and links are selected
                            pdoPrinters = pdo;
                            pdoLinks = pdoAux;
                        }
                        else
                        {
                            // only links are selected
                            pdoLinks = pdo;
                        }
                        uSel = SEL_MULTI_LINK;
                    }
                    else
                    {
                        // mixed selection case
                        pdoPrinters = pdo;
                        pdoLinks = pdoAux;
                        uSel = SEL_MULTI_MIXED;
                    }
                }
            }
        }

        // addref and return the out parameters
        if (ppdoPrinters)
        {
            if (pdoPrinters)
                pdoPrinters->AddRef();
            *ppdoPrinters = pdoPrinters;
        }

        if (ppdoLinks)
        {
            if (pdoLinks)
                pdoLinks->AddRef();
            *ppdoLinks = pdoLinks;
        }

        if (puSelType)
        {
            *puSelType = uSel;
        }

        // check to release the PIDL array
        if (pida)
            HIDA_ReleaseStgMedium(pida, &medium);

        // check to release the auxiliary data object and storage medium
        if (pidaAux)
            HIDA_ReleaseStgMedium(pidaAux, &mediumAux);

        if (pdoAux)
            pdoAux->Release();

    }
    return hr;
}

HRESULT CPrinterFolder::_UpdateDataObjectCache()
{
    HRESULT hr = S_OK;

    CCSLock::Locker lock(_csLock);
    if (lock)
    {
        _bstrSelectedPrinter.Empty();

        // clear the cache -- zero can mean disabled or undefined --
        // we don't really care about the difference
        _uSelCurrent = SEL_NONE;
        ZeroMemory(&_aWVCommandStates, sizeof(_aWVCommandStates));

        if (_pdoCache)
        {
            IDataObject *pdoP = NULL;

            // collect state information relevant to the selection
            if (SUCCEEDED(hr = SplitSelection(_pdoCache, &_uSelCurrent, &pdoP, NULL)) &&
                SEL_SINGLE_PRINTER == _uSelCurrent)
            {
                STGMEDIUM medium;
                LPIDA pida = DataObj_GetHIDA(pdoP, &medium);

                if (pida)
                {
                    // this is pretty much the same type of logic we do in _MergeMenu()
                    TCHAR szFullPrinter[MAXNAMELENBUFFER];
                    LPCTSTR pszPrinter = _BuildPrinterName(szFullPrinter,
                        (LPIDPRINTER)IDA_GetIDListPtr(pida, 0), NULL);

                    PFOLDER_PRINTER_DATA pData = (PFOLDER_PRINTER_DATA)
                        Printer_FolderGetPrinter(GetFolder(), szFullPrinter);

                    if (pData)
                    {
                        ULONG ulAttributes;
                        LPCITEMIDLIST pidl = IDA_GetIDListPtr(pida, 0);

                        ulAttributes = SFGAO_CANDELETE;
                        _aWVCommandStates[WVIDM_DELETE] =
                            SUCCEEDED(GetAttributesOf(1, &pidl, &ulAttributes)) ? !!ulAttributes : FALSE;

                        ulAttributes = SFGAO_CANRENAME;
                        _aWVCommandStates[WVIDM_RENAME] =
                            SUCCEEDED(GetAttributesOf(1, &pidl, &ulAttributes)) ? !!ulAttributes : FALSE;

                        // enabled only for the local PF and if not default already
                        _aWVCommandStates[WVIDM_SETDEFAULTPRN] =
                            (NULL == GetServer() && FALSE == IsDefaultPrinter(szFullPrinter, pData->Attributes));

                        // enabled only for the local PF
                        _aWVCommandStates[WVIDM_DOCUMENTDEFAULTS] = (NULL == GetServer());

                        // enabled only if not paused already
                        _aWVCommandStates[WVIDM_PAUSEPRN] = !(pData->Status & PRINTER_STATUS_PAUSED);

                        // enabled only if paused
                        _aWVCommandStates[WVIDM_RESUMEPRN] = !!(pData->Status & PRINTER_STATUS_PAUSED);

                        // enabled only if the printer has jobs in the queue
                        _aWVCommandStates[WVIDM_PURGEPRN] = (0 != pData->cJobs);

                        if ((pData->Attributes & PRINTER_ATTRIBUTE_NETWORK) || (SpoolerVersion() <= 2))
                        {
                            // not enabled for network, masq and downlevel printers
                            _aWVCommandStates[WVIDM_WORKOFFLINE] = FALSE;
                        }
                        else
                        {
                            // enabled only if not offline already
                            _aWVCommandStates[WVIDM_WORKOFFLINE] =
                                !(pData->Attributes & PRINTER_ATTRIBUTE_WORK_OFFLINE);
                        }

                        if ((pData->Attributes & PRINTER_ATTRIBUTE_NETWORK) || (SpoolerVersion() <= 2))
                        {
                            // not enabled for network, masq and downlevel printers
                            _aWVCommandStates[WVIDM_WORKONLINE] = FALSE;
                        }
                        else
                        {
                            // enabled only if offline
                            _aWVCommandStates[WVIDM_WORKONLINE] =
                                !!(pData->Attributes & PRINTER_ATTRIBUTE_WORK_OFFLINE);
                        }

                        // remember the name of the selected printer
                        _bstrSelectedPrinter = szFullPrinter;
                        if (!_bstrSelectedPrinter)
                        {
                            hr = E_OUTOFMEMORY;
                        }

                        // free up the memory allocated from Printer_FolderGetPrinter
                        LocalFree((HLOCAL)pData);
                    }
                    else
                    {
                        // Printer_FolderGetPrinter failed
                        hr = E_OUTOFMEMORY;
                    }

                    // release the PIDL array
                    HIDA_ReleaseStgMedium(pida, &medium);
                }
                else
                {
                    // DataObj_GetHIDA failed
                    hr = E_OUTOFMEMORY;
                }
            }

            if (pdoP)
                pdoP->Release();
        }
    }
    else
    {
        // unable to enter the CS -- this can happen only in extremely low memory conditions!
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

HRESULT CPrinterFolder::_AssocCreate(REFIID riid, void **ppv)
{
    HRESULT hr = E_FAIL;
    IQueryAssociations *pqa;
    hr = AssocCreate(CLSID_QueryAssociations, IID_PPV_ARG(IQueryAssociations, &pqa));

    if (SUCCEEDED(hr))
    {
        hr = pqa->Init(0, c_szPrinters, NULL, NULL);
        if (SUCCEEDED(hr))
        {
            hr = pqa->QueryInterface(riid, ppv);
        }
        pqa->Release();
    }
    return hr;
}

HRESULT CPrinterFolder::_OnRefresh(BOOL bPriorRefresh)
{
    HRESULT hr = S_OK;
    if (bPriorRefresh)
    {
        CCSLock::Locker lock(_csLock);
        if (lock)
        {
            // reset the slow webview data cache
            _SlowWVDataCacheResetUnsafe();

            // request a full refresh during the next enum
            RequestRefresh();
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    return hr;
}

// thread proc for obtaining the slow webview data
DWORD WINAPI CPrinterFolder::_SlowWebviewData_WorkerProc(LPVOID lpParameter)
{
    HRESULT hr = S_OK;
    CSlowWVDataCacheEntry *pCacheEntry = reinterpret_cast<CSlowWVDataCacheEntry*>(lpParameter);
    if (pCacheEntry && pCacheEntry->_ppf && pCacheEntry->_bDataPending)
    {
        CPrinterFolder *ppf = pCacheEntry->_ppf;
        CComBSTR bstrOemSupportUrl;
        CComBSTR bstrPrinterWebUrl;

        // retreive the slow webview data...
        HRESULT hrCOMInit = SHCoInitialize();
        if (SUCCEEDED(hr = hrCOMInit))
        {
            ASSERT(pCacheEntry->_bstrPrinterName);
            hr = _SlowWVDataRetrieve(pCacheEntry->_bstrPrinterName, &bstrOemSupportUrl, &bstrPrinterWebUrl);
        }

        // update the cache...
        do
        {
            CCSLock::Locker lock(pCacheEntry->_ppf->_csLock);
            if (lock)
            {
                pCacheEntry->_arrData[WV_SLOW_DATA_OEM_SUPPORT_URL].Empty();
                pCacheEntry->_arrData[WV_SLOW_DATA_PRINTER_WEB_URL].Empty();

                if (SUCCEEDED(hr))
                {
                    if (bstrOemSupportUrl)
                    {
                        pCacheEntry->_arrData[WV_SLOW_DATA_OEM_SUPPORT_URL] = bstrOemSupportUrl;
                    }

                    if (bstrPrinterWebUrl)
                    {
                        pCacheEntry->_arrData[WV_SLOW_DATA_PRINTER_WEB_URL] = bstrPrinterWebUrl;
                    }
                }

                // mark the data as ready...
                pCacheEntry->_nLastTimeUpdated = GetTickCount();
                pCacheEntry->_bDataPending = FALSE;
                hr = S_OK;
            }
            else
            {
                // even if we fail to enter the CS then we still should update
                // those fields to prevent further leaks.

                pCacheEntry->_nLastTimeUpdated = GetTickCount();
                pCacheEntry->_bDataPending = FALSE;
                hr = E_OUTOFMEMORY;
            }

            // pCacheEntry shouldn't be accessed beyond this point!
            pCacheEntry = NULL;
        }
        while (false);

        // update the webview pane...
        hr = ppf->_SlowWVDataUpdateWebviewPane();

        // shutdown...
        ppf->Release();
        SHCoUninitialize(hrCOMInit);
    }
    else
    {
        hr = E_INVALIDARG;
    }
    return SUCCEEDED(hr) ? EXIT_SUCCESS : EXIT_FAILURE;
}

HRESULT CPrinterFolder::_SlowWVDataRetrieve(LPCTSTR pszPrinterName, BSTR *pbstrOemSupportUrl, BSTR *pbstrPrinterWebUrl)
{
    HRESULT hr = S_OK;

    // pszPrinterName can be NULL. if pszPrinterName is NULL that means that the 
    // custom support URL is requested (if any)

    if (pbstrOemSupportUrl && pbstrPrinterWebUrl)
    {
        *pbstrOemSupportUrl = NULL;
        *pbstrPrinterWebUrl = NULL;

        CLSID clsID = GUID_NULL;
        hr = _GetClassIDFromString(TEXT("OlePrn.PrinterURL"), &clsID);
        if (SUCCEEDED(hr))
        {
            IDispatch *pDisp = NULL;
            // SHExtCoCreateInstance to go through approval/app compat layer
            hr = SHExtCoCreateInstance(NULL, &clsID, NULL, IID_PPV_ARG(IDispatch, &pDisp));
            if (SUCCEEDED(hr))
            {
                CComVariant varOemSupportURL;
                CComVariant varPrinterWebURL;
                CComDispatchDriver drvDispatch(pDisp);

                // if pszPrinterName isn't NULL then on return pbstrOemSupportUrl will be the OEM
                // support URL. if it is NULL then it will be the custom support URL (if any)

                if (pszPrinterName)
                {
                    CComVariant varPrinterName(pszPrinterName);
                    if (varPrinterName.vt && varPrinterName.bstrVal)
                    {
                        hr = drvDispatch.PutPropertyByName(TEXT("PrinterName"), &varPrinterName);
                        if (SUCCEEDED(hr))
                        {
                            if (SUCCEEDED(drvDispatch.GetPropertyByName(TEXT("PrinterOemURL"), &varOemSupportURL)) &&
                                VT_BSTR == varOemSupportURL.vt && varOemSupportURL.bstrVal && varOemSupportURL.bstrVal[0])
                            {
                                *pbstrOemSupportUrl = SysAllocString(varOemSupportURL.bstrVal);
                            }

                            if (SUCCEEDED(drvDispatch.GetPropertyByName(TEXT("PrinterWebURL"), &varPrinterWebURL)) &&
                                VT_BSTR == varPrinterWebURL.vt && varPrinterWebURL.bstrVal && varPrinterWebURL.bstrVal[0])
                            {
                                *pbstrPrinterWebUrl = SysAllocString(varPrinterWebURL.bstrVal);
                            }

                            hr = S_OK;
                        }
                    }
                    else
                    {
                        hr = E_OUTOFMEMORY;
                    }
                }
                else
                {
                    hr = drvDispatch.GetPropertyByName(TEXT("SupportLink"), &varOemSupportURL);
                    if (SUCCEEDED(hr))
                    {
                        if (VT_BSTR == varOemSupportURL.vt && varOemSupportURL.bstrVal && varOemSupportURL.bstrVal[0])
                        {
                            *pbstrOemSupportUrl = SysAllocString(varOemSupportURL.bstrVal);
                            hr = S_OK;
                        }
                        else
                        {
                            hr = E_UNEXPECTED;
                        }
                    }
                }

                pDisp->Release();
            }
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }

    return hr;
}

int CPrinterFolder::_CompareSlowWVDataCacheEntries(CSlowWVDataCacheEntry *p1, 
    CSlowWVDataCacheEntry *p2, LPARAM lParam)
{
    ASSERT(p1 && p1->_bstrPrinterName);
    ASSERT(p2 && p2->_bstrPrinterName);

    return lstrcmpi(p1->_bstrPrinterName, p2->_bstrPrinterName);
}

HRESULT CPrinterFolder::_GetSelectedPrinter(BSTR *pbstrVal)
{
    HRESULT hr = S_OK;
    if (pbstrVal)
    {
        CCSLock::Locker lock(_csLock);
        if (lock)
        {
            if (_bstrSelectedPrinter)
            {
                *pbstrVal = _bstrSelectedPrinter.Copy();
                hr = (*pbstrVal) ? S_OK : E_OUTOFMEMORY;
            }
            else
            {
                hr = E_UNEXPECTED;
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }
    return hr;
}

HRESULT CPrinterFolder::_GetSlowWVDataForCurrentPrinter(ESlowWebviewDataType eType, BSTR *pbstrVal)
{
    HRESULT hr = S_OK;

    CComBSTR bstrSelectedPrinter;
    if (SUCCEEDED(hr = _GetSelectedPrinter(&bstrSelectedPrinter)) &&
        SUCCEEDED(hr = _GetSlowWVData(bstrSelectedPrinter, eType, pbstrVal)))
    {
        hr = S_OK;
    }

    return hr;
}

HRESULT CPrinterFolder::_GetSlowWVData(LPCTSTR pszPrinterName, ESlowWebviewDataType eType, BSTR *pbstrVal)
{
    HRESULT hr = S_OK;
    if (pszPrinterName && pbstrVal && eType >= 0 && eType < WV_SLOW_DATA_COUNT)
    {
        *pbstrVal = NULL;
        CCSLock::Locker lock(_csLock);
        if (lock)
        {
            CSlowWVDataCacheEntry entry(this);
            hr = entry.Initialize(pszPrinterName);
            if (SUCCEEDED(hr))
            {
                CSlowWVDataCacheEntry *pCacheEntry = NULL;
                // search the cache...
                INT iPos = _dpaSlowWVDataCache.Search(&entry, 0, 
                    _CompareSlowWVDataCacheEntries, 0L, DPAS_SORTED);

                if (iPos >= 0)
                {
                    // this item in the cache, check if it hasn't expired
                    pCacheEntry = _dpaSlowWVDataCache.GetPtr(iPos);
                    ASSERT(pCacheEntry);

                    // let's see if the requested data is available...
                    if (pCacheEntry->_arrData[eType])
                    {
                        *pbstrVal = pCacheEntry->_arrData[eType].Copy();
                        hr = (*pbstrVal) ? S_OK : E_OUTOFMEMORY;
                    }
                    else
                    {
                        hr = E_PENDING;
                    }

                    if (!pCacheEntry->_bDataPending)
                    {
                        // let's see if this entry hasn't expired...
                        DWORD dwTicks = GetTickCount();

                        // this can happen if the cache entry hasn't been touched for more than 49 days!
                        // pretty unlikely, but we should handle properly.

                        if (dwTicks < pCacheEntry->_nLastTimeUpdated)
                        {
                            pCacheEntry->_nLastTimeUpdated = 0;
                            _UpdateSlowWVDataCacheEntry(pCacheEntry);
                        }
                        else
                        {
                            if ((dwTicks - pCacheEntry->_nLastTimeUpdated) > WV_SLOW_DATA_CACHE_TIMEOUT)
                            {
                                // this cache entry has expired, kick off a thread to update...
                                _UpdateSlowWVDataCacheEntry(pCacheEntry);
                            }
                        }
                    }
                }
                else
                {
                    // this item isn't in the cache - let's create a new one and request update.
                    pCacheEntry = new CSlowWVDataCacheEntry(this);
                    if (pCacheEntry)
                    {
                        hr = pCacheEntry->Initialize(pszPrinterName);
                        if (SUCCEEDED(hr))
                        {
                            iPos = _dpaSlowWVDataCache.Search(pCacheEntry, 0, 
                                _CompareSlowWVDataCacheEntries, 0L, DPAS_SORTED | DPAS_INSERTAFTER);
                            iPos = _dpaSlowWVDataCache.InsertPtr(iPos, pCacheEntry);

                            if (-1 == iPos)
                            {
                                // failed to insert, bail...
                                delete pCacheEntry;
                                pCacheEntry = NULL;
                                hr = E_OUTOFMEMORY;
                            }
                            else
                            {
                                // kick off a thread to update...
                                hr = _UpdateSlowWVDataCacheEntry(pCacheEntry);

                                if (SUCCEEDED(hr))
                                {
                                    // everything succeeded - return pending to the caller
                                    hr = E_PENDING;
                                }
                                else
                                {
                                    // failed to create the thread, cleanup
                                    delete _dpaSlowWVDataCache.DeletePtr(iPos);
                                    pCacheEntry = NULL;
                                }
                            }
                        }
                    }
                    else
                    {
                        hr = E_OUTOFMEMORY;
                    }
                }
            }
        }
        else
        {
            hr = E_OUTOFMEMORY;
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }
    return hr;
}

HRESULT CPrinterFolder::_UpdateSlowWVDataCacheEntry(CSlowWVDataCacheEntry *pCacheEntry)
{
    HRESULT hr = S_OK;
    if (pCacheEntry)
    {
        pCacheEntry->_bDataPending = TRUE;
        pCacheEntry->_ppf->AddRef();
        if (!SHQueueUserWorkItem(reinterpret_cast<LPTHREAD_START_ROUTINE>(_SlowWebviewData_WorkerProc), 
                pCacheEntry, 0, 0, NULL, "shell32.dll", 0))
        {
            // failed to queue the work item - call Release() to balance the AddRef() call. 
            pCacheEntry->_bDataPending = FALSE;
            pCacheEntry->_nLastTimeUpdated = GetTickCount();
            pCacheEntry->_ppf->Release();

            // let's see if we can make something out of the win32 last error
            DWORD dw = GetLastError();
            hr = ((ERROR_SUCCESS == dw) ? E_FAIL : HRESULT_FROM_WIN32(dw));
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }
    return hr;
}

HRESULT CPrinterFolder::_SlowWVDataUpdateWebviewPane()
{
    HRESULT hr = S_OK;
    CComBSTR bstrSelectedPrinter;
    UINT uFlags = SHCNF_IDLIST | SHCNF_FLUSH | SHCNF_FLUSHNOWAIT;

    // we fire SHCNE_UPDATEITEM for the PIDL of the currently selected printer 
    // to force refresh of the webview pane. 

    if (SUCCEEDED(hr = _GetSelectedPrinter(&bstrSelectedPrinter)))
    {
        if (GetServer())
        {
            LPCTSTR pszServer = NULL;
            LPCTSTR pszPrinter = NULL;
            TCHAR szBuffer[MAXNAMELENBUFFER] = {0};

            // in the remote printer's folder we need to strip off the server
            // part from the full printer name.

            Printer_SplitFullName(szBuffer, bstrSelectedPrinter, &pszServer, &pszPrinter);
            if (pszPrinter && pszPrinter[0])
            {
                bstrSelectedPrinter = pszPrinter;
            }
        }

        LPITEMIDLIST pidl = NULL;
        if (SUCCEEDED(hr = _GetFullIDList(bstrSelectedPrinter, &pidl)))
        {
            SHChangeNotify(SHCNE_UPDATEITEM, uFlags, pidl, NULL);
            ILFree(pidl);
        }
    }

    return hr;
}

HRESULT CPrinterFolder::_SlowWVDataCacheResetUnsafe()
{
    // this is reseting the slow webview data cache
    if (_dpaSlowWVDataCache)
    {
        INT_PTR iPos = 0;
        CSlowWVDataCacheEntry *pCacheEntry = NULL;
        while (iPos < _dpaSlowWVDataCache.GetPtrCount())
        {
            // delete only the entries which are not in pending 
            pCacheEntry = _dpaSlowWVDataCache.GetPtr(iPos);
            if (!pCacheEntry->_bDataPending)
            {
                delete _dpaSlowWVDataCache.DeletePtr(iPos);
            }
            else
            {
                // this one is pending - skip.
                iPos++;
            }
        }
    }
    return S_OK;
}

HRESULT CPrinterFolder::_GetCustomSupportURL(BSTR *pbstrVal)
{
    HRESULT hr = S_OK;
    if (pbstrVal)
    {
        *pbstrVal = NULL;
        CComBSTR bstrOemSupportUrl;
        CComBSTR bstrPrinterWebUrl;
        hr = _SlowWVDataRetrieve(NULL, &bstrOemSupportUrl, &bstrPrinterWebUrl);

        if (SUCCEEDED(hr))
        {
            *pbstrVal = bstrOemSupportUrl.Copy();
            hr = S_OK;
        }
    }
    else
    {
        hr = E_INVALIDARG;
    }
    return hr;
}

HRESULT CPrinterFolder::_GetFaxControl(IDispatch **ppDisp)
{
    HRESULT hr = E_INVALIDARG;
    if (ppDisp)
    {
        *ppDisp = NULL;
        CLSID clsID = GUID_NULL;
        hr = _GetClassIDFromString(TEXT("FaxControl.FaxControl"), &clsID);

        if (SUCCEEDED(hr))
        {
            // SHExtCoCreateInstance to go through approval/app compat layer
            hr = SHExtCoCreateInstance(NULL, &clsID, NULL, IID_PPV_ARG(IDispatch, ppDisp));
        }
    }
    return hr;
}

HRESULT CPrinterFolder::_GetFaxCommand(UINT_PTR *puCmd)
{
    HRESULT hr = E_INVALIDARG;
    if (puCmd)
    {
        *puCmd = 0;
        IDispatch *pDisp = NULL;
        hr = _GetFaxControl(&pDisp);

        if (SUCCEEDED(hr))
        {
            CComDispatchDriver drvDispatch(pDisp);

            CComVariant varIsFxSvcInstalled;
            CComVariant varIsFxPrnInstalled;

            if (SUCCEEDED(hr = drvDispatch.GetPropertyByName(TEXT("IsFaxServiceInstalled"), &varIsFxSvcInstalled)) &&
                SUCCEEDED(hr = drvDispatch.GetPropertyByName(TEXT("IsLocalFaxPrinterInstalled"), &varIsFxPrnInstalled)))
            {
                if (VT_BOOL == varIsFxSvcInstalled.vt && VT_BOOL == varIsFxPrnInstalled.vt)
                {
                    if (VARIANT_TRUE == varIsFxSvcInstalled.boolVal)
                    {
                        if (VARIANT_TRUE == varIsFxPrnInstalled.boolVal)
                        {
                            *puCmd = FSIDM_SENDFAXWIZARD;
                        }
                        else
                        {
                            *puCmd = FSIDM_CREATELOCALFAX;
                        }
                    }
                    else
                    {
                        *puCmd = FSIDM_SETUPFAXING;
                    }
                    
                    hr = S_OK;
                }
                else
                {
                    hr = E_UNEXPECTED;
                }
            }

            pDisp->Release();
        }
    }
    return hr;
}

HRESULT CPrinterFolder::_InvokeFaxControlMethod(LPCTSTR pszMethodName)
{
    HRESULT hr = E_INVALIDARG;
    if (pszMethodName)
    {
        // this function will be called from background threads, so
        // we need to call SHCoInitialize first.

        HRESULT hrCOMInit = SHCoInitialize();
        if (SUCCEEDED(hr = hrCOMInit))
        {
            IDispatch *pDisp = NULL;
            hr = _GetFaxControl(&pDisp);

            if (SUCCEEDED(hr))
            {
                CComDispatchDriver drvDispatch(pDisp);
                hr = drvDispatch.Invoke0(pszMethodName);
                pDisp->Release();
            }
        }
        SHCoUninitialize(hrCOMInit);
    }
    return hr;
}

DWORD WINAPI CPrinterFolder::_ThreadProc_InstallFaxService(LPVOID lpParameter)
{
    HRESULT hr = _InvokeFaxControlMethod(TEXT("InstallFaxService"));
    return SUCCEEDED(hr) ? EXIT_SUCCESS : EXIT_FAILURE;
}

DWORD WINAPI CPrinterFolder::_ThreadProc_InstallLocalFaxPrinter(LPVOID lpParameter)
{
    HRESULT hr = _InvokeFaxControlMethod(TEXT("InstallLocalFaxPrinter"));
    return SUCCEEDED(hr) ? EXIT_SUCCESS : EXIT_FAILURE;
}


// conversion table from webview verbs into printer folder verbs
static const UINT_PTR
g_cVerbWV2VerbFolder[CPrinterFolder::WVIDM_COUNT] =
{
    #define INVALID_CMD static_cast<UINT_PTR>(-1)

    // folder verbs                                 // corresponding webview verbs
    DFM_CMD_DELETE,                                 // WVIDM_DELETE,
    DFM_CMD_RENAME,                                 // WVIDM_RENAME,
    DFM_CMD_PROPERTIES,                             // WVIDM_PROPERTIES,

    // common verbs// common verbs
    FSIDM_ADDPRINTERWIZARD,                         // WVIDM_ADDPRINTERWIZARD,
    FSIDM_SERVERPROPERTIES,                         // WVIDM_SERVERPROPERTIES,
    FSIDM_SETUPFAXING,                              // WVIDM_SETUPFAXING,
    FSIDM_CREATELOCALFAX,                           // WVIDM_CREATELOCALFAX,
    FSIDM_SENDFAXWIZARD,                            // WVIDM_SENDFAXWIZARD,

    // special common verbs// special common verbs
    INVALID_CMD,                                    // WVIDM_TROUBLESHOOTER,
    INVALID_CMD,                                    // WVIDM_GOTOSUPPORT,

    // printer verbs// printer verbs
    FSIDM_OPENPRN,                                  // WVIDM_OPENPRN,
    FSIDM_NETPRN_INSTALL,                           // WVIDM_NETPRN_INSTALL,
    FSIDM_SETDEFAULTPRN,                            // WVIDM_SETDEFAULTPRN,
    FSIDM_DOCUMENTDEFAULTS,                         // WVIDM_DOCUMENTDEFAULTS,
    FSIDM_PAUSEPRN,                                 // WVIDM_PAUSEPRN,
    FSIDM_RESUMEPRN,                                // WVIDM_RESUMEPRN,
    FSIDM_PURGEPRN,                                 // WVIDM_PURGEPRN,
    FSIDM_SHARING,                                  // WVIDM_SHARING,
    FSIDM_WORKOFFLINE,                              // WVIDM_WORKOFFLINE,
    FSIDM_WORKONLINE,                               // WVIDM_WORKONLINE,

    // special commands// special commands
    INVALID_CMD,                                    // WVIDM_VENDORURL,
    INVALID_CMD,                                    // WVIDM_PRINTERURL,
};

HRESULT CPrinterFolder::_WebviewVerbIsEnabled(WV_VERB eVerbID, UINT uSelMask, BOOL *pbEnabled)
{
    HRESULT hr = S_OK;

    CCSLock::Locker lock(_csLock);
    if (lock)
    {
        // not enabled by default
        ASSERT(pbEnabled);
        *pbEnabled = FALSE;

        if (_pdoCache)
        {
            // if _pdoCache isn't NULL that means we have a selection
            // let's see what command set will be enabled depending on
            // the current selection (_uSelCurrent, _pdoCache) and on
            // the passed in selection mask (uSelMask)

            if (uSelMask & _uSelCurrent)
            {
                switch (_uSelCurrent)
                {
                    case SEL_SINGLE_ADDPRN:
                        // only WVIDM_ADDPRINTERWIZARD is enabled
                        *pbEnabled = ((eVerbID == WVIDM_ADDPRINTERWIZARD) && !SHRestricted(REST_NOPRINTERADD));
                        break;

                    case SEL_SINGLE_PRINTER:
                        {
                            switch (eVerbID)
                            {
                                case WVIDM_PROPERTIES:
                                case WVIDM_OPENPRN:
                                case WVIDM_SHARING:
                                    // always enabled
                                    *pbEnabled = TRUE;
                                    break;

                                case WVIDM_VENDORURL:
                                    {
                                        *pbEnabled = FALSE;
                                        CComBSTR bstrCustomSupportURL;
                                        if (FAILED(_GetCustomSupportURL(&bstrCustomSupportURL)))
                                        {
                                            // OEM support URL will be enabled only if there is no custom support URL.
                                            CComBSTR bstrURL;
                                            *pbEnabled = SUCCEEDED(_GetSlowWVDataForCurrentPrinter(WV_SLOW_DATA_OEM_SUPPORT_URL, &bstrURL));
                                        }
                                    }
                                    break;

                                case WVIDM_PRINTERURL:
                                    {
                                        CComBSTR bstrURL;
                                        *pbEnabled = SUCCEEDED(_GetSlowWVDataForCurrentPrinter(WV_SLOW_DATA_PRINTER_WEB_URL, &bstrURL));
                                    }
                                    break;

                                default:
                                    // consult the cache
                                    *pbEnabled = _aWVCommandStates[eVerbID];
                                    break;
                            }
                        }
                        break;

                    case SEL_SINGLE_LINK:
                        {
                            // commands enabled for multiple selection of printer objects
                            switch (eVerbID)
                            {
                                case WVIDM_DELETE:
                                case WVIDM_RENAME:
                                case WVIDM_PROPERTIES:
                                    *pbEnabled = TRUE;
                                    break;

                                default:
                                    break;
                            }
                        }
                        break;

                    case SEL_MULTI_PRINTER:
                        {
                            switch (eVerbID)
                            {
                                case WVIDM_DELETE:
                                case WVIDM_PROPERTIES:

                                case WVIDM_OPENPRN:
                                case WVIDM_DOCUMENTDEFAULTS:
                                case WVIDM_PURGEPRN:
                                case WVIDM_SHARING:
                                    // those are always enabled
                                    *pbEnabled = TRUE;
                                    break;

                                default:
                                    break;
                            }
                        }
                        break;

                    case SEL_MULTI_LINK:
                    case SEL_MULTI_MIXED:
                        {
                            switch (eVerbID)
                            {
                                case WVIDM_DELETE:
                                case WVIDM_PROPERTIES:
                                    // those are always enabled
                                    *pbEnabled = TRUE;
                                    break;

                                default:
                                    break;
                            }
                        }
                        break;
                }

                // here we deal with commands which are always enabled regardless 
                // of the selection type.

                switch (eVerbID)
                {
                    case WVIDM_ADDPRINTERWIZARD:
                        *pbEnabled = !SHRestricted(REST_NOPRINTERADD);
                        break;

                    default:
                        break;
                }
            }
        }
        else
        {
            // if _pdoCache is NULL that means we have no selection
            // let's see what command set will be enabled depending
            // on the passed in selection mask (uSelMask)

            switch (eVerbID)
            {
                case WVIDM_ADDPRINTERWIZARD:
                    *pbEnabled = !SHRestricted(REST_NOPRINTERADD);
                    break;

                case WVIDM_TROUBLESHOOTER:
                case WVIDM_GOTOSUPPORT:
                    // the troubleshooter and goto support commands are always enabled.
                    *pbEnabled = TRUE;
                    break;

                case WVIDM_SERVERPROPERTIES:
                    // server properties will be enabled in the non-selection case
                    // only on server SKUs.
                    *pbEnabled = IsOS(OS_ANYSERVER);
                    break;

                case WVIDM_SETUPFAXING:
                case WVIDM_CREATELOCALFAX:
                case WVIDM_SENDFAXWIZARD:
                    {
                        UINT_PTR uCmd;
                        if (GetServer() || FAILED(_GetFaxCommand(&uCmd)))
                        {
                            uCmd = 0;
                        }
                        *pbEnabled = (uCmd == g_cVerbWV2VerbFolder[eVerbID]);
                    }
                    break;

                default:
                    break;
            }
        }
    }
    else
    {
        // unable to enter the CS -- this can happen only in extremely low memory conditions!
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

HRESULT CPrinterFolder::_WebviewVerbInvoke(WV_VERB eVerbID, IUnknown* pv, IShellItemArray *psiItemArray)
{
    HRESULT hr = S_OK;
    HWND hwnd = NULL;
    IShellView *psv = NULL;
    IDataObject *pdo = NULL;

    if (psiItemArray)
    {
        hr = psiItemArray->BindToHandler(NULL,BHID_DataObject,IID_PPV_ARG(IDataObject,&pdo));
    }

    if (SUCCEEDED(hr))
    {
        // quey some basic interfaces from the PIDL array
        if (SUCCEEDED(hr = IUnknown_QueryService(pv, IID_IShellView, IID_PPV_ARG(IShellView, &psv))) &&
            SUCCEEDED(hr = psv->GetWindow(&hwnd)))
        {
            switch( eVerbID)
            {
            // special common verbs
            case WVIDM_TROUBLESHOOTER:
                ShellExecute(hwnd, TEXT("open"), TEXT("helpctr.exe"),
                    TEXT("-Url hcp://help/tshoot/tsprint.htm"), NULL, SW_SHOWNORMAL);
                break;

            case WVIDM_GOTOSUPPORT:
                {
                    CComBSTR bstrURL;
                    if (SUCCEEDED(_GetCustomSupportURL(&bstrURL)))
                    {
                        // the admin has provided a custom URL for support - navigate to it.
                        ShellExecute(hwnd, TEXT("open"), bstrURL, NULL, NULL, SW_SHOWNORMAL);
                    }
                    else
                    {
                        // custom support isn't provided - go to the default support URL.
                        ShellExecute(hwnd, TEXT("open"),
                            TEXT("http://www.microsoft.com/isapi/redir.dll?prd=Win2000&ar=Support&sba=printing"),
                            NULL, NULL, SW_SHOWNORMAL);
                    }
                }
                break;


                // common verbs
                case WVIDM_ADDPRINTERWIZARD:
                case WVIDM_SERVERPROPERTIES:
                case WVIDM_SETUPFAXING:
                case WVIDM_CREATELOCALFAX:
                case WVIDM_SENDFAXWIZARD:
                    {
                        // delegate the command to CPrinterFolder::CallBack
                        ASSERT(INVALID_CMD != g_cVerbWV2VerbFolder[eVerbID]);
                        hr = CallBack(this, hwnd, pdo, DFM_INVOKECOMMAND, g_cVerbWV2VerbFolder[eVerbID], 0L);
                    }
                    break;


            // standard verbs
            case WVIDM_DELETE:
            case WVIDM_RENAME:
            case WVIDM_PROPERTIES:

            // printer verbs
            case WVIDM_OPENPRN:
            case WVIDM_NETPRN_INSTALL:
            case WVIDM_SETDEFAULTPRN:
            case WVIDM_DOCUMENTDEFAULTS:
            case WVIDM_PAUSEPRN:
            case WVIDM_RESUMEPRN:
            case WVIDM_PURGEPRN:
            case WVIDM_SHARING:
            case WVIDM_WORKOFFLINE:
            case WVIDM_WORKONLINE:
                {
                    if (DFM_CMD_RENAME == g_cVerbWV2VerbFolder[eVerbID])
                    {
                        // we need to handle rename explicitly through IShellView2
                        IShellView2 *psv2;
                        if (SUCCEEDED(hr = IUnknown_QueryService(pv, IID_IShellView2,
                            IID_PPV_ARG(IShellView2, &psv2))))
                        {
                            // passing NULL to HandleRename is making defview to
                            // operate on the currently selected object
                            hr = psv2->HandleRename(NULL);
                            psv2->Release();
                        }
                    }
                    else
                    {
                        // just delegate the command to CPrinterFolder::_DFMCallBack
                        hr = _DFMCallBack(this, hwnd, pdo, DFM_INVOKECOMMAND, g_cVerbWV2VerbFolder[eVerbID], 0L);
                    }
                }
                break;

            // special commands
            case WVIDM_VENDORURL:
                {
                    CComBSTR bstrVendorURL;
                    hr = _GetSlowWVDataForCurrentPrinter(WV_SLOW_DATA_OEM_SUPPORT_URL, &bstrVendorURL);
                    if (SUCCEEDED(hr))
                    {
                        ShellExecute(hwnd, TEXT("open"), bstrVendorURL, NULL, NULL, SW_SHOWNORMAL);
                    }
                }
                break;

            case WVIDM_PRINTERURL:
                {
                    CComBSTR bstrPrinterURL;
                    hr = _GetSlowWVDataForCurrentPrinter(WV_SLOW_DATA_PRINTER_WEB_URL, &bstrPrinterURL);
                    if (SUCCEEDED(hr))
                    {
                        ShellExecute(hwnd, TEXT("open"), bstrPrinterURL, NULL, NULL, SW_SHOWNORMAL);
                    }
                }
                break;
            }
        }

        ATOMICRELEASE(pdo);
        ATOMICRELEASE(psv);
    }

    return hr;
}

HRESULT CPrinterFolder::_WebviewCheckToUpdateDataObjectCache(IDataObject *pdo)
{
    HRESULT hr = S_OK;

    CCSLock::Locker lock(_csLock);
    if (lock)
    {
        if (pdo)
        {
            // we need to compare the passed in data object with the one we are
            // caching and update the cache if necessary
            if (_pdoCache)
            {
                // compare the objects using the COM rules
                IUnknown *punk1;
                IUnknown *punk2;

                if (SUCCEEDED(hr = pdo->QueryInterface(IID_PPV_ARG(IUnknown, &punk1))))
                {
                    if (SUCCEEDED(hr = _pdoCache->QueryInterface(IID_PPV_ARG(IUnknown, &punk2))))
                    {
                        if (punk1 != punk2)
                        {
                            // release the current data object
                            _pdoCache->Release();
                            _pdoCache = pdo;
                            _pdoCache->AddRef();

                            // update the cache
                            hr = _UpdateDataObjectCache();
                        }
                        punk2->Release();
                    }
                    punk1->Release();
                }
            }
            else
            {
                // _pdoCache is NULL, rebuild the cache
                _pdoCache = pdo;
                _pdoCache->AddRef();

                // update the cache
                hr = _UpdateDataObjectCache();
            }
        }
        else
        {
            if (_pdoCache)
            {
                // clear the cache
                _pdoCache->Release();
                _pdoCache = NULL;

                // update the cache
                hr = _UpdateDataObjectCache();
            }
        }
    }
    else
    {
        // unable to enter the CS -- this can happen only in extremely low memory conditions!
        hr = E_OUTOFMEMORY;
    }

    return hr;
}

// export for printui. uses standard namespace stuff
STDAPI_(void) Printer_LoadIcons(LPCTSTR pszPrinterName, HICON *phLargeIcon, HICON *phSmallIcon)
{
    if (phLargeIcon) *phLargeIcon = NULL;
    if (phSmallIcon) *phSmallIcon = NULL;

    LPITEMIDLIST pidl;
    if (SUCCEEDED(ParsePrinterNameEx(pszPrinterName, &pidl, TRUE, 0, 0)))
    {
        SHFILEINFO sfi;

        if (phLargeIcon && SHGetFileInfo((LPCTSTR)pidl, 0, &sfi, sizeof(sfi), SHGFI_ICON | SHGFI_PIDL))
        {
            *phLargeIcon = sfi.hIcon;
        }

        if (phSmallIcon && SHGetFileInfo((LPCTSTR)pidl, 0, &sfi, sizeof(sfi), SHGFI_ICON | SHGFI_SMALLICON | SHGFI_PIDL))
        {
            *phSmallIcon = sfi.hIcon;
        }
        ILFree(pidl);
    }

    // if above fails fallback to default icons
    if (phLargeIcon && (NULL == *phLargeIcon))
        *phLargeIcon = (HICON)LoadImage(HINST_THISDLL, MAKEINTRESOURCE(IDI_PRINTER), IMAGE_ICON, 0, 0, LR_DEFAULTSIZE);
    if (phSmallIcon && (NULL == *phSmallIcon))
        *phSmallIcon = (HICON)LoadImage(HINST_THISDLL, MAKEINTRESOURCE(IDI_PRINTER), IMAGE_ICON, g_cxSmIcon, g_cxSmIcon, 0);
}

typedef struct
{
    USHORT              cb;
    SHCNF_PRINTJOB_DATA data;
    USHORT              uTerm;
} IDPRINTJOB, *LPIDPRINTJOB;
typedef const IDPRINTJOB *LPCIDPRINTJOB;

void Printjob_FillPidl(LPIDPRINTJOB pidl, LPSHCNF_PRINTJOB_DATA pData)
{
    pidl->cb = FIELD_OFFSET(IDPRINTJOB, uTerm);
    if (pData)
    {
        pidl->data = *pData;
    }
    else
    {
        ZeroMemory(&(pidl->data), sizeof(SHCNF_PRINTJOB_DATA));
    }
    pidl->uTerm = 0;
}

LPITEMIDLIST Printjob_GetPidl(LPCTSTR szName, LPSHCNF_PRINTJOB_DATA pData)
{
    LPITEMIDLIST pidl = NULL;

    LPITEMIDLIST pidlParent;
    if (SUCCEEDED(ParsePrinterNameEx(szName, &pidlParent, TRUE, 0, 0)))
    {
        IDPRINTJOB idj;
        Printjob_FillPidl(&idj, pData);
        pidl = ILCombine(pidlParent, (LPITEMIDLIST)&idj);
        ILFree(pidlParent);
    }

    return pidl;
}

const struct
{
    DWORD bit;          // bit of a bitfield
    UINT  uStringID;    // the string id this bit maps to
}
c_map_bit_to_status[] =
{
    PRINTER_STATUS_PAUSED,              IDS_PRQSTATUS_PAUSED,
    PRINTER_STATUS_ERROR,               IDS_PRQSTATUS_ERROR,
    PRINTER_STATUS_PENDING_DELETION,    IDS_PRQSTATUS_PENDING_DELETION,
    PRINTER_STATUS_PAPER_JAM,           IDS_PRQSTATUS_PAPER_JAM,
    PRINTER_STATUS_PAPER_OUT,           IDS_PRQSTATUS_PAPER_OUT,
    PRINTER_STATUS_MANUAL_FEED,         IDS_PRQSTATUS_MANUAL_FEED,
    PRINTER_STATUS_PAPER_PROBLEM,       IDS_PRQSTATUS_PAPER_PROBLEM,
    PRINTER_STATUS_OFFLINE,             IDS_PRQSTATUS_OFFLINE,
    PRINTER_STATUS_IO_ACTIVE,           IDS_PRQSTATUS_IO_ACTIVE,
    PRINTER_STATUS_BUSY,                IDS_PRQSTATUS_BUSY,
    PRINTER_STATUS_PRINTING,            IDS_PRQSTATUS_PRINTING,
    PRINTER_STATUS_OUTPUT_BIN_FULL,     IDS_PRQSTATUS_OUTPUT_BIN_FULL,
    PRINTER_STATUS_NOT_AVAILABLE,       IDS_PRQSTATUS_NOT_AVAILABLE,
    PRINTER_STATUS_WAITING,             IDS_PRQSTATUS_WAITING,
    PRINTER_STATUS_PROCESSING,          IDS_PRQSTATUS_PROCESSING,
    PRINTER_STATUS_INITIALIZING,        IDS_PRQSTATUS_INITIALIZING,
    PRINTER_STATUS_WARMING_UP,          IDS_PRQSTATUS_WARMING_UP,
    PRINTER_STATUS_TONER_LOW,           IDS_PRQSTATUS_TONER_LOW,
    PRINTER_STATUS_NO_TONER,            IDS_PRQSTATUS_NO_TONER,
    PRINTER_STATUS_PAGE_PUNT,           IDS_PRQSTATUS_PAGE_PUNT,
    PRINTER_STATUS_USER_INTERVENTION,   IDS_PRQSTATUS_USER_INTERVENTION,
    PRINTER_STATUS_OUT_OF_MEMORY,       IDS_PRQSTATUS_OUT_OF_MEMORY,
    PRINTER_STATUS_DOOR_OPEN,           IDS_PRQSTATUS_DOOR_OPEN,

    PRINTER_HACK_WORK_OFFLINE,          IDS_PRQSTATUS_WORK_OFFLINE,
} ;



// maps bits into a string representation, putting
// the string idsSep in between each found bit.
// Returns the size of the created string.
UINT Printer_BitsToString(DWORD bits, UINT idsSep, LPTSTR lpszBuf, UINT cchMax)
{
    UINT cchBuf = 0;
    UINT cchSep = 0;
    TCHAR szSep[20];

    if (LoadString(HINST_THISDLL, idsSep, szSep, ARRAYSIZE(szSep)))
        cchSep = lstrlen(szSep);

    for (UINT i = 0; i < ARRAYSIZE(c_map_bit_to_status); i++)
    {
        if (bits & c_map_bit_to_status[i].bit)
        {
            TCHAR szTmp[258];

            if (LoadString(HINST_THISDLL, c_map_bit_to_status[i].uStringID, szTmp, ARRAYSIZE(szTmp)))
            {
                UINT cchTmp = lstrlen(szTmp);

                if (cchBuf + cchSep + cchTmp < cchMax)
                {
                    if (cchBuf)
                    {
                        lstrcat(lpszBuf, szSep);
                        cchBuf += cchSep;
                    }
                    lstrcat(lpszBuf, szTmp);
                    cchBuf += cchTmp;
                }
            }
        }
    }

    return cchBuf;
}

STDMETHODIMP CPrinterFolderViewCB::RealMessage(UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch (uMsg)
    {
    HANDLE_MSG(0, SFVM_INVOKECOMMAND, OnINVOKECOMMAND);
    HANDLE_MSG(0, SFVM_GETHELPTEXT, OnGETHELPTEXT);
    HANDLE_MSG(0, SFVM_BACKGROUNDENUM, OnBACKGROUNDENUM);
    HANDLE_MSG(0, SFVM_GETHELPTOPIC, OnGETHELPTOPIC);
    HANDLE_MSG(0, SFVM_REFRESH, OnREFRESH);
    HANDLE_MSG(0, SFVM_DELAYWINDOWCREATE, OnDELAYWINDOWCREATE);
    HANDLE_MSG(0, SFVM_GETDEFERREDVIEWSETTINGS, OnDEFERRED_VIEW_SETTING);

    // DUI webview commands
    HANDLE_MSG(0, SFVM_GETWEBVIEWLAYOUT, OnGetWebViewLayout);
    HANDLE_MSG(0, SFVM_GETWEBVIEWCONTENT, OnGetWebViewContent);
    HANDLE_MSG(0, SFVM_GETWEBVIEWTASKS, OnGetWebViewTasks);

    default:
        return E_FAIL;
    }

    return S_OK;
}

STDMETHODIMP CPrinterFolderViewCB::QueryService(REFGUID guidService, REFIID riid, void **ppv)
{
    IUnknown *punkThis = static_cast<IServiceProvider*>(this);
    IUnknown *punkSite = NULL;
    HRESULT hr = E_NOINTERFACE;

    //
    // we are going to use IServiceProvider to be able to query the callback for some
    // core interfaces associated with it (like IShellFolderView and IShellFolder, etc...).
    // basically the idea is that we try QueryService/QueryInterafce on the printer's
    // folder first and then if it fails we try our current site which supposedly will
    // be defview.
    //

    if (_ppf)
    {
        IUnknown *punkPF = static_cast<IShellFolder*>(_ppf);

        // try QueryService on the printer's folder
        if (SUCCEEDED(hr = IUnknown_QueryService(punkPF, riid, riid, ppv)))
            goto Exit;

        // try QueryInterface on the printer's folder
        if (SUCCEEDED(hr = punkPF->QueryInterface(riid, ppv)))
            goto Exit;
    }

    if (FAILED(hr) && (SUCCEEDED(hr = IUnknown_GetSite(punkThis, IID_PPV_ARG(IUnknown, &punkSite)))))
    {
        ASSERT(punkSite);

        // try QueryService on the site object
        if (SUCCEEDED(hr = IUnknown_QueryService(punkSite, riid, riid, ppv)))
            goto Exit;

        // try QueryInterface on the site object
        if (SUCCEEDED(hr = punkSite->QueryInterface(riid, ppv)))
            goto Exit;
    }
    else
    {
        ASSERT(NULL == punkSite);
    }

Exit:
    if (punkSite)
    {
        punkSite->Release();
    }
    return hr;
}

// shell32.dll export, from srch.exe results no one uses this
STDAPI Printers_GetPidl(LPCITEMIDLIST pidlParent, LPCTSTR pszPrinterName, DWORD dwType, LPITEMIDLIST *ppidl)
{
    return E_FAIL;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\prshtcpp.h ===
#ifndef _PRSHTCPP_INC
#define _PRSHTCPP_INC

#include "propsht.h"

// attrib treewalkcb
STDAPI_(BOOL) ApplyRecursiveFolderAttribs(LPCTSTR pszDir, FILEPROPSHEETPAGE* pfpsp);

// progress dlg
STDAPI_(BOOL) CreateAttributeProgressDlg(FILEPROPSHEETPAGE* pfpsp);
STDAPI_(BOOL) DestroyAttributeProgressDlg(FILEPROPSHEETPAGE* pfpsp);
STDAPI SetProgressDlgPath(FILEPROPSHEETPAGE* pfpsp, LPCTSTR pszPath, BOOL fCompactPath);
STDAPI UpdateProgressBar(FILEPROPSHEETPAGE* pfpsp);
STDAPI_(BOOL) HasUserCanceledAttributeProgressDlg(FILEPROPSHEETPAGE* pfpsp);
STDAPI_(HWND) GetProgressWindow(FILEPROPSHEETPAGE* pfpsp);

// assoc store stuff
STDAPI UpdateOpensWithInfo(FILEPROPSHEETPAGE* pfpsp);

#endif // _PRSHTCPP_INC
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\propsht.h ===
#ifndef _MULPRSHT_H
#define _MULPRSHT_H

#include "idlcomm.h" // for HIDA
#include "ids.h"

// we recycle this string from the printer stringtable in shell32.rc
#define IDS_UNKNOWNERROR IDS_PRTPROP_UNKNOWNERROR

#define IDT_SIZE 1

// file attribute state
typedef struct 
{
    DWORD   fReadOnly;      // each dword is one of BST_CHECKED, BST_UNCHECKED, or BST_INDETERMINATE 
    DWORD   fHidden;
    DWORD   fArchive;     
    DWORD   fIndex;
    DWORD   fCompress;
    DWORD   fEncrypt;
    DWORD   fRecordingEnabled;
} ATTRIBUTESTATE;

typedef struct _FILEPROPSHEETPAGE FILEPROPSHEETPAGE;

// FOLDERCONTENTSINFO includes members which are referenced across UI Thread and Size Thread.
typedef struct {
    LONG            _cRef;
    BOOL            fIsSizeThreadAlive;
    HWND            hDlg;
    BOOL            bContinue;      // tell thread to stop or mark as done
    ULONGLONG       cbSize;         // total size of all files in folder
    ULONGLONG       cbActualSize;   // total size on disk, taking into account compression and cluster slop
    DWORD           dwClusterSize;  // the size of a cluster
    int             cFiles;         // # files in folder
    int             cFolders;       // # folders in folder
    TCHAR           szPath[MAX_PATH];
    WIN32_FIND_DATA fd;             // for thread stack savings
    HIDA            hida;
    BOOL            fMultipleFiles;             // are there multiple files?
    BOOL            fIsCompressionAvailable;    // is comrpession supported on the volume?
    ULARGE_INTEGER  ulTotalNumberOfBytes;       // total # of bytes to apply attributes to (for progress dlg)
} FOLDERCONTENTSINFO;

typedef struct _FILEPROPSHEETPAGE
{
    PROPSHEETPAGE       psp;
    BOOL                fMountedDrive;              // Are we dealing with a mounted drive or not?
    BOOL                fIsLink;                    // Is this a .lnk file?

    //the following fields are used by both the structures
    HWND                hDlg;
    TCHAR               szPath[MAX_PATH];           // full path to the file (single file case)
    LPITEMIDLIST        pidl;                       // pidl for the item == NULL if not initialized
    TCHAR               szLinkTarget[MAX_PATH];     // full path of link target (if the file is a .lnk)
    ATTRIBUTESTATE      asInitial;                  // initial file attribute state
    ATTRIBUTESTATE      asCurrent;                  // current file attribute state
    BOOL                fIsEncryptionAvailable;     // is encryption supported on the volume?
    BOOL                fIsIndexAvailable;          // is conten indexing supported in the filesystem?

    //This is used only by the single file dialog proc
    LPVOID              pAssocStore;                // pointer to the Association Store, we use it to query type info
    IProgressDialog*    pProgressDlg;               // pointer to the IProgressDialog object
    ULARGE_INTEGER      ulNumberOfBytesDone;        // # of bytes that we have already applied attribs to (for progress dlg)    
    FOLDERCONTENTSINFO* pfci;                       // the background size thread fills this structure with size info
    WIN32_FIND_DATA     fd;                         // info about the file we are currently applying attribs to
    HWND                hwndTip;                    // window handle for location tooltip
    HDPA                hdpaBadFiles;               // this dpa holds the names of the files that we dont want to apply attribs to

    TCHAR               szInitialName[MAX_PATH];    // the original "short" name we display in the edit box

    BOOL                fWMInitFinshed;             // are we finished processing the WM_INITDIALOG message (needed for rename)
    BOOL                fRecursive;                 // should we recurse into subdirs when applying attributes?
    BOOL                fIsDirectory;               // is this file a directory (in multiple files case: are any of the files a directory?)
    BOOL                fIsExe;                     // if this is an .exe, we ask if they want to support user logon
    BOOL                fRename;                    // has the user renamed the file/folder?
    BOOL                fIgnoreAllErrors;           // has the user hit "ignore all" to the error message?
    BOOL                fShowExtension;             // are we showing the real extension for this file in the name editbox?
    BOOL                fFolderShortcut;

    int                 cItemsDone;                 // Number of items we have already applied attribs to (for progress dlg)
    BOOL                fDisableRename;             // Should the name edit box be disabled?

    //The following is used only by the mounted drv dialog proc
    int                 iDrive;                     // Drive id of the mounted drive if there is one
    TCHAR               szFileSys[48];              // file system name.
    BOOL                fCanRename;                 // is the name a valid name for renaming?

    // Folder shortcut specific stuff.
    LPITEMIDLIST        pidlTarget;
    BOOL                fValidateEdit;
} FILEPROPSHEETPAGE;

typedef struct 
{
    PROPSHEETPAGE   psp;

    HWND            hDlg;

    //szDrive will contain the mountpoint (e.g. c:\ or c:\folder\folder2\)
    TCHAR           szDrive[MAX_PATH];
    int             iDrive;

    _int64          qwTot;
    _int64          qwFree;

    DWORD           dwPieShadowHgt;

    ULARGE_INTEGER  ulTotalNumberOfBytes;       // total # of bytes to apply attributes to (for progress dlg)
    ATTRIBUTESTATE  asInitial;                  // initial attribute state
    ATTRIBUTESTATE  asCurrent;                  // current attribute state

    BOOL            fIsCompressionAvailable;    // is file-based compression available on this volume (NTFS?)
    BOOL            fIsIndexAvailable;   // is content indexing available on this volume?
    BOOL            fRecursive;                 // should we recurse into subdirs when applying attributes?
    BOOL            fMountedDrive;              // is the proppage invoked from mounted point proppage
} DRIVEPROPSHEETPAGE;

typedef struct 
{
    LPCTSTR pszPath;
    DWORD dwLastError;
} ATTRIBUTEERROR;

STDAPI_(BOOL) ApplyFileAttributes(LPCTSTR pszPath, FILEPROPSHEETPAGE* pfpsp, HWND hWndParent, BOOL* pbSomethingChanged);
STDAPI_(BOOL) ApplySingleFileAttributes(FILEPROPSHEETPAGE* pfpsp);
STDAPI_(BOOL_PTR) CALLBACK RecursivePromptDlgProc(HWND hDlgRecurse, UINT uMessage, WPARAM wParam, LPARAM lParam);
STDAPI_(void) SetDateTimeText(HWND hdlg, int id, const FILETIME *pftUTC);
STDAPI_(void)SetDateTimeTextEx(HWND hdlg, int id, const FILETIME *pftUTC, DWORD dwFlags);
STDAPI_(DWORD) GetVolumeFlags(LPCTSTR pszPath, OUT OPTIONAL LPTSTR pszFileSys, int cchFileSys);
STDAPI_(void) SetInitialFileAttribs(FILEPROPSHEETPAGE* pfpsp, DWORD dwFlags, DWORD dwMask);
BOOL_PTR CALLBACK AdvancedFileAttribsDlgProc(HWND hDlgAttribs, UINT uMessage, WPARAM wParam, LPARAM lParam);
STDAPI_(void) SetDlgItemTextWithToolTip(HWND hDlg, UINT id, LPCTSTR pszText, HWND *phwndTT);

STDAPI_(FOLDERCONTENTSINFO*) Create_FolderContentsInfo();
STDAPI_(LONG) AddRef_FolderContentsInfo(FOLDERCONTENTSINFO *pfci);
STDAPI_(LONG) Release_FolderContentsInfo(FOLDERCONTENTSINFO *pfci);
STDAPI InitCommonPrsht(FILEPROPSHEETPAGE *pfpsp);

STDAPI FolderSize(LPCTSTR pszDir, FOLDERCONTENTSINFO * pfci);

#endif // _MULPRSHT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\prtprop.c ===
#include "shellprv.h"
#pragma  hdrstop

#include "printer.h"

// PRINTUI.DLL calls this export to load shell exts registered for this printer

STDAPI_(void) Printer_AddPrinterPropPages(LPCTSTR pszPrinterName, LPPROPSHEETHEADER lpsh)
{
    // Add hooked pages if they exist in the registry
    HKEY hkeyBaseProgID = NULL;
    RegOpenKey(HKEY_CLASSES_ROOT, c_szPrinters, &hkeyBaseProgID);
    if (hkeyBaseProgID)
    {
        // we need an IDataObject
        LPITEMIDLIST pidl;
        HRESULT hr = ParsePrinterNameEx(pszPrinterName, &pidl, TRUE, 0, 0);
        if (SUCCEEDED(hr))
        {
            IDataObject *pdtobj;
            hr = SHGetUIObjectFromFullPIDL(pidl, NULL, IID_PPV_ARG(IDataObject, &pdtobj));
            if (SUCCEEDED(hr))
            {
                // add the hooked pages
                HDCA hdca = DCA_Create();
                if (hdca)
                {
                    DCA_AddItemsFromKey(hdca, hkeyBaseProgID, STRREG_SHEX_PROPSHEET);
                    DCA_AppendClassSheetInfo(hdca, hkeyBaseProgID, lpsh, pdtobj);
                    DCA_Destroy(hdca);
                }
                pdtobj->lpVtbl->Release(pdtobj);
            }
            ILFree(pidl);
        }
        RegCloseKey(hkeyBaseProgID);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\prshtcpp.cpp ===
#include "shellprv.h"
#pragma  hdrstop

#include "prshtcpp.h"
#include "propsht.h"
#include "treewkcb.h"   // for CBaseTreeWalkerCB class
#include "ftascstr.h"   // for CFTAssocStore
#include "ftcmmn.h"     // for MAX_APPFRIENDLYNAME
#include "ascstr.h"     // for IAssocInfo class

//
// Folder attribute tree waker class
//
class CFolderAttribTreeWalker : public CBaseTreeWalkerCB
{
public:
    // constructor
    CFolderAttribTreeWalker(FILEPROPSHEETPAGE* pfpsp);

    // IShellTreeWalkerCallBack
    STDMETHODIMP FoundFile(LPCWSTR pwszPath, TREEWALKERSTATS *ptws, WIN32_FIND_DATAW * pwfd);
    STDMETHODIMP EnterFolder(LPCWSTR pwszPath, TREEWALKERSTATS *ptws, WIN32_FIND_DATAW * pwfd);

protected:
    FILEPROPSHEETPAGE *_pfpsp;
};


CFolderAttribTreeWalker::CFolderAttribTreeWalker(FILEPROPSHEETPAGE* pfpsp): _pfpsp(pfpsp)
{
}


HRESULT CFolderAttribTreeWalker::FoundFile(LPCWSTR pwszFile, TREEWALKERSTATS *ptws, WIN32_FIND_DATAW* pwfd)
{
    HWND hwndParent = NULL;
    TCHAR szFileName[MAX_PATH];
    ULARGE_INTEGER ulSizeOnDisk;
    BOOL bSomethingChanged;

    // check to see if the user hit cancel on the progress dlg
    if (HasUserCanceledAttributeProgressDlg(_pfpsp))
    {
        return E_FAIL;
    }

    if (_pfpsp->pProgressDlg)
    {
        // if we have a progress hwnd, try to use it
        // this will fail if the progress dialog hasent been displayed yet.
        IUnknown_GetWindow(_pfpsp->pProgressDlg, &hwndParent);
    }

    if (!hwndParent)
    {
        // if we dont have a progress hwnd, use the property page hwnd
        hwndParent = GetParent(_pfpsp->hDlg);
    }

    // thunk the pwszFile string
    SHUnicodeToTChar(pwszFile, szFileName, ARRAYSIZE(szFileName));

    if (pwfd->dwFileAttributes & FILE_ATTRIBUTE_DIRECTORY)
    {
        // (reinerf) - in the directory case, we set the size to zero since the
        // FolderSize() function dosen't add in the sizes of directories, and we need
        // the sizes to match when doing progress calcuations.
        _pfpsp->fd.nFileSizeLow = 0;
        _pfpsp->fd.nFileSizeHigh = 0;
    }
    else
    {
        // if compression is supported, we check to see if the file is sparse or compressed
        if (_pfpsp->pfci->fIsCompressionAvailable && (pwfd->dwFileAttributes & (FILE_ATTRIBUTE_COMPRESSED | FILE_ATTRIBUTE_SPARSE_FILE)))
        {
            ulSizeOnDisk.LowPart = SHGetCompressedFileSize(szFileName, &ulSizeOnDisk.HighPart);
        }
        else
        {
            // the file isint comrpessed so just round to the cluster size
            ulSizeOnDisk.LowPart = pwfd->nFileSizeLow;
            ulSizeOnDisk.HighPart = pwfd->nFileSizeHigh;
            ulSizeOnDisk.QuadPart = ROUND_TO_CLUSTER(ulSizeOnDisk.QuadPart, ptws->dwClusterSize);
        }

        // we set this so the progress dialog knows how much to update the progress slider
        _pfpsp->fd.nFileSizeLow = ulSizeOnDisk.LowPart;
        _pfpsp->fd.nFileSizeHigh = ulSizeOnDisk.HighPart;
    }

    if (!ApplyFileAttributes(szFileName, _pfpsp, hwndParent, &bSomethingChanged))
    {
        // the user hit cancel, so stop
        return E_FAIL;
    }

    return S_OK;
}
 
HRESULT CFolderAttribTreeWalker::EnterFolder(LPCWSTR pwszDir, TREEWALKERSTATS *ptws, WIN32_FIND_DATAW* pwfd)
{
    return FoundFile(pwszDir, ptws, pwfd);
}

STDAPI_(BOOL) ApplyRecursiveFolderAttribs(LPCTSTR pszDir, FILEPROPSHEETPAGE* pfpsp)
{
    HRESULT hrInit = SHCoInitialize();

    HRESULT hr = E_FAIL;
    CFolderAttribTreeWalker* pfatw = new CFolderAttribTreeWalker(pfpsp);
    if (pfatw)
    {
        IShellTreeWalker *pstw;
        hr = CoCreateInstance(CLSID_CShellTreeWalker, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IShellTreeWalker, &pstw));
        if (SUCCEEDED(hr))
        {
            hr = pstw->WalkTree(WT_NOTIFYFOLDERENTER, pszDir, NULL, 0, SAFECAST(pfatw, IShellTreeWalkerCallBack*));
            pstw->Release();
        }
        pfatw->Release();
    }
    SHCoUninitialize(hrInit);

    return SUCCEEDED(hr) ? TRUE : FALSE;
}

//
// Checks the progress dialog to see if the user has hit cancel
//
STDAPI_(BOOL) HasUserCanceledAttributeProgressDlg(FILEPROPSHEETPAGE* pfpsp)
{
    BOOL fReturn = FALSE;

    if (pfpsp && pfpsp->pProgressDlg)
    {
        fReturn = pfpsp->pProgressDlg->HasUserCancelled();
    }

    return fReturn;
}


//
// Creates the CProgressDialog object used by the attribs dlg
//
STDAPI_(BOOL) CreateAttributeProgressDlg(FILEPROPSHEETPAGE* pfpsp)
{
    WCHAR wzBuffer[MAX_PATH];

    ASSERT(pfpsp->pfci->fMultipleFiles || pfpsp->fRecursive);
    
    // create the progress dialog as a modal window
    pfpsp->pProgressDlg = CProgressDialog_CreateInstance(IDS_APPLYINGATTRIBS, IDA_APPLYATTRIBS, HINST_THISDLL);

    if (!pfpsp->pProgressDlg)
    {
        // couldn't create a progress dialog, so bail
        return FALSE;
    }

    // set the static string "Applying Attrbiutes to:"
    LoadStringW(HINST_THISDLL, IDS_APPLYINGATTRIBSTO, wzBuffer, ARRAYSIZE(wzBuffer));
    pfpsp->pProgressDlg->SetLine(1, wzBuffer, FALSE, NULL);

    pfpsp->pProgressDlg->StartProgressDialog(GetParent(pfpsp->hDlg), NULL, (PROGDLG_MODAL | PROGDLG_AUTOTIME), NULL);
    return TRUE;
}


//
// Delets the CProgressDialog object used by the attribs dlg
//
STDAPI_(BOOL) DestroyAttributeProgressDlg(FILEPROPSHEETPAGE* pfpsp)
{
    if (!pfpsp->pProgressDlg)
    {
        ASSERT(FALSE);
        return FALSE;
    }

    pfpsp->pProgressDlg->StopProgressDialog();
    pfpsp->pProgressDlg->Release();
    pfpsp->pProgressDlg = NULL;

    // reset NumberOfBytesDone so we are back to zero if the user tries something else,
    // we will start over at zero
    pfpsp->ulNumberOfBytesDone.QuadPart = 0;
    pfpsp->cItemsDone = 0;
    
    return TRUE;
}


//
// Sets the current file we are applying attribs for in the progress dlg
//
STDAPI SetProgressDlgPath(FILEPROPSHEETPAGE* pfpsp, LPCTSTR pszPath, BOOL fCompactPath)
{
    HRESULT hr = E_INVALIDARG;

    ASSERT(pfpsp->pProgressDlg);
    if (pfpsp && pfpsp->pProgressDlg)
    {
        WCHAR wzPath[MAX_PATH];

        SHTCharToUnicode(pszPath, wzPath, ARRAYSIZE(wzPath));
        hr = pfpsp->pProgressDlg->SetLine(2, wzPath, fCompactPath, NULL);
    }

    return hr;
}


//
// Updates the progress bar in the dlg
//
STDAPI UpdateProgressBar(FILEPROPSHEETPAGE* pfpsp)
{
    HRESULT hr = E_INVALIDARG;

    ASSERT(pfpsp->pProgressDlg);
    if (pfpsp && pfpsp->pProgressDlg)
    {
        pfpsp->cItemsDone++;
    
        // if we are not changing compression or encryption, then
        // do progress based on the number of items we are applying to.
        if (pfpsp->asCurrent.fCompress == pfpsp->asInitial.fCompress &&
            pfpsp->asCurrent.fEncrypt == pfpsp->asInitial.fEncrypt)
        {
            if (pfpsp->fRecursive)
            {
                //progress is based on number of items done out of total items in all folders
                hr = pfpsp->pProgressDlg->SetProgress(pfpsp->cItemsDone, pfpsp->pfci->cFiles + pfpsp->pfci->cFolders);
            }
            else
            {
                //progress is based on number of items done out of total selected items
                hr = pfpsp->pProgressDlg->SetProgress(pfpsp->cItemsDone, HIDA_GetCount(pfpsp->pfci->hida));
            }
        }
        else
        {
            // since we are either encrypting or compressing, we do progress based on the sizes of the files
            hr = pfpsp->pProgressDlg->SetProgress64(pfpsp->ulNumberOfBytesDone.QuadPart, pfpsp->pfci->ulTotalNumberOfBytes.QuadPart);
        }
    }

    return hr;
}


// we dynamically size the text depeneding on whether or not the small icon is visible and
// if the "Change..." button is visible
void SizeOpensWithTextBox(FILEPROPSHEETPAGE* pfpsp, BOOL bIsSmallIconVisible, BOOL bIsOpensWithEnabled)
{
    RECT rcArray[3]; // array of three rects: the IDD_TYPEICON rect, the IDC_CHANGEFILETYPE rect, and the IDD_OPENSWITH rect
    RECT* prcSmallIcon = &rcArray[0];
    RECT* prcChangeButton = &rcArray[1];
    RECT* prcText = &rcArray[2];
    BOOL  bFailed = FALSE;

    GetWindowRect(GetDlgItem(pfpsp->hDlg, IDD_TYPEICON), &rcArray[0]);
    GetWindowRect(GetDlgItem(pfpsp->hDlg, IDC_CHANGEFILETYPE), &rcArray[1]);
    GetWindowRect(GetDlgItem(pfpsp->hDlg, IDD_OPENSWITH), &rcArray[2]);

    // map the rects into dlg coordiates
    // MapWindowPoints is mirroring aware only when you pass one rect. let's loop.
    for (int i =0; i < ARRAYSIZE(rcArray); i++ )
    {
        if(!(MapWindowPoints(NULL, pfpsp->hDlg, (LPPOINT)(&rcArray[i]), 2)))
        {
            bFailed = TRUE;
            break;
        }
    }
    if (!bFailed)
    {
        RECT rcTemp = {0,0,4,0}; // we need to find out how many pixels are in 4 DLU's worth of witdth

        MapDialogRect(pfpsp->hDlg, &rcTemp);

        if (bIsSmallIconVisible)
        {
            prcText->left = prcSmallIcon->right + rcTemp.right; // spacing between controls is 4 DLU's
        }
        else
        {
            prcText->left = prcSmallIcon->left;
        }

        if (bIsOpensWithEnabled)
        {
            prcText->right = prcChangeButton->left - rcTemp.right; // spacing between controls is 4 DLU's
        }
        else
        {
            prcText->right = prcChangeButton->right;
        }

        SetWindowPos(GetDlgItem(pfpsp->hDlg, IDD_OPENSWITH),
                     HWND_BOTTOM,
                     prcText->left,
                     prcText->top,
                     (prcText->right - prcText->left),
                     (prcText->bottom - prcText->top),
                     SWP_NOZORDER);
    }
}

// this function sets the "Opens With:" / "Description:" text based on whether or not 
// we are allowed to change the assocation, and enables / disables the "Opens With..." button
void SetDescriptionAndOpensWithBtn(FILEPROPSHEETPAGE* pfpsp, BOOL fAllowModifyOpenWith)
{
    TCHAR szOpensWithText[MAX_PATH];

    LoadString(HINST_THISDLL, fAllowModifyOpenWith ? IDS_OPENSWITH : IDS_DESCRIPTION, szOpensWithText, ARRAYSIZE(szOpensWithText));
    SetDlgItemText(pfpsp->hDlg, IDD_OPENSWITH_TXT, szOpensWithText);
    
    // enable/disable the "Change..." button accordingly
    EnableAndShowWindow(GetDlgItem(pfpsp->hDlg, IDC_CHANGEFILETYPE), fAllowModifyOpenWith);
}

// set the Friendly Name text (eg the text to the right of the "Opens With:" / "Description:" field
void SetFriendlyNameText(LPTSTR pszPath, FILEPROPSHEETPAGE* pfpsp, IAssocInfo* pai, BOOL bIsSmallIconVisible)
{
    TCHAR szAppFriendlyName[MAX_PATH];
    DWORD cchFriendlyName = ARRAYSIZE(szAppFriendlyName);
    szAppFriendlyName[0] = TEXT('\0');

    if (pai)
    {
        if (FAILED(pai->GetString(AISTR_APPFRIENDLY, szAppFriendlyName, &cchFriendlyName)))
        {
            // if we failed, it could mean that this app is not associated yet. in this
            // case we just use "Unknown Applicaion"
            LoadString(HINST_THISDLL, IDS_UNKNOWNAPPLICATION, szAppFriendlyName, ARRAYSIZE(szAppFriendlyName));
        }
    }
    else
    {
        UINT cchBuff = (UINT)cchFriendlyName;

        // get the friendly name from the file itself
        if (!pszPath || !pszPath[0] || !GetFileDescription(pszPath, szAppFriendlyName, &cchBuff))
        {
            // use the short name as it appears in the "rename" edit box if something above didnt work
            lstrcpyn(szAppFriendlyName, pfpsp->szInitialName, ARRAYSIZE(szAppFriendlyName));
        }
    }

    ASSERT(szAppFriendlyName[0]);

    SetDlgItemTextWithToolTip(pfpsp->hDlg, IDD_OPENSWITH, szAppFriendlyName, &pfpsp->hwndTip);


    // size and position the text properly depending on wether the small icon is visible and
    // the state of the "Change..." button
    SizeOpensWithTextBox(pfpsp, bIsSmallIconVisible, IsWindowEnabled(GetDlgItem(pfpsp->hDlg, IDC_CHANGEFILETYPE)));
}

// sets the small icon in the description field
//
// return value:  TRUE  - a small icon is visible
//                FALSE - small icon was not set
//
BOOL SetSmallIcon(FILEPROPSHEETPAGE* pfpsp, IAssocInfo* pai, BOOL fAllowModifyOpenWith)
{
    HICON hIcon = NULL;
    HICON hIconOld = NULL;
    int iIcon;
    BOOL bShowSmallIcon;
    
    // only setup the small icon of the associated app if we have the "Change..." button 
    // and we were able to get the friendly name.
    if (fAllowModifyOpenWith && pai && SUCCEEDED(pai->GetDWORD(AIDWORD_APPSMALLICON, (DWORD*)&iIcon)))
    {
        HIMAGELIST hIL = NULL;

        Shell_GetImageLists(NULL, &hIL);
        if (hIL)
        {
            hIcon = ImageList_ExtractIcon(g_hinst, hIL, iIcon);
        }
    }

    // we will show the small icon if we got one and if we are allowed to modify the opens with
    bShowSmallIcon = (hIcon != NULL);

    hIconOld = (HICON)SendDlgItemMessage(pfpsp->hDlg, IDD_TYPEICON, STM_SETICON, (WPARAM)hIcon, 0);

    if (hIconOld)
        DestroyIcon(hIconOld);

    // enable/disable the IDD_TYPEICON icon accordingly
    EnableAndShowWindow(GetDlgItem(pfpsp->hDlg, IDD_TYPEICON), bShowSmallIcon);

    return bShowSmallIcon;
}


//
// We use this to set the text for the associated application and other goodies
//
STDAPI UpdateOpensWithInfo(FILEPROPSHEETPAGE* pfpsp)
{
    HRESULT hr;
    TCHAR szPath[MAX_PATH];
    IAssocStore* pas = NULL;
    IAssocInfo* pai = NULL;
    BOOL fAllowChangeAssoc = TRUE;
    BOOL fAllowModifyOpenWith = TRUE;
    BOOL fIsLink = FALSE;
    BOOL bShowSmallIcon;
    
    szPath[0] = TEXT('\0');

    // We need to check to see if this is a link. If so, then we need to get the information for
    // the link target
    if (pfpsp->fIsLink)
    {
        if (S_OK != GetPathFromLinkFile(pfpsp->szPath, szPath, ARRAYSIZE(szPath)))
        {
            // we failed for some strange reason, perhaps its a darwin link,
            // we just treat the file as if it were not a link. And we do not let
            // the user change the association
            fAllowModifyOpenWith = FALSE;
            pfpsp->fIsLink = FALSE;
        }
        else
        {
            // if the link target didn't change, we dont need to update anything
            if (pfpsp->szLinkTarget[0] && lstrcmpi(pfpsp->szLinkTarget, szPath) == 0)
            {
                return S_FALSE;
            }
        }
    }
    else
    {
        // just use the path of the file since it is not a link
        lstrcpyn(szPath, pfpsp->szPath, ARRAYSIZE(szPath));
    }

    // if we haven't initialized the AssocStore, do so now
    pas = (IAssocStore*)pfpsp->pAssocStore;
    if (!pas)
    {
        pas = new CFTAssocStore();
        pfpsp->pAssocStore = (void *)pas;
    }

    if (!pfpsp->pAssocStore)
    {
        // if we couldn't make an AssocStore, so bail
        return E_OUTOFMEMORY;
    }

    LPTSTR pszExt = PathFindExtension(szPath);
    if (PathIsExe(szPath) || !szPath[0] || *pszExt == TEXT('\0'))
    {
        // this file is an .exe (or .com, .bat, etc) or GetPathFromLinkFile returned a 
        // null path (eg link to a special folder) or the file has no extension (eg 'c:\foo.',
        // or 'c:\'), then we dont want the user to be able to change the association since 
        // there isint one.
        fAllowModifyOpenWith = FALSE;
    }

    if (fAllowModifyOpenWith)
    {
        // get the AssocInfo for this file, based on its extension
        hr = pas->GetAssocInfo(pszExt, AIINIT_EXT, &pai);

#ifdef DEBUG
        if (FAILED(hr))
        {
            ASSERT(pai == NULL);
        }
#endif
    }

    if (SHRestricted(REST_NOFILEASSOCIATE))
    {
        // we are not allowed to change file assocoations, so remove the opens with button
        fAllowModifyOpenWith = FALSE;
    }

    SetDescriptionAndOpensWithBtn(pfpsp, fAllowModifyOpenWith);
    bShowSmallIcon = SetSmallIcon(pfpsp, pai, fAllowModifyOpenWith);
    SetFriendlyNameText(szPath, pfpsp, pai, bShowSmallIcon);

    if (pai)
    {
        pai->Release();
    }

    // save off the link target so we only update the stuff above when the target changes.
    if (pfpsp->fIsLink)
    {
        lstrcpyn(pfpsp->szLinkTarget, szPath, ARRAYSIZE(pfpsp->szLinkTarget));
    }
    else
    {
        // its not a link so reset the link target to the empty string
        pfpsp->szLinkTarget[0] = TEXT('\0');
    }

    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\rdrag.c ===
#include "shellprv.h"
#pragma  hdrstop

// warning: this will fail given a UNICODE hDrop on an ANSI build and
// the DRAGINFO is esentially a TCHAR struct with no A/W versions exported
//
// in:
//      hDrop   drop handle
//
// out:
//      a bunch of info about the hdrop
//      (mostly the pointer to the double NULL file name list in TCHAR format)
//
// returns:
//      TRUE    the DRAGINFO struct was filled in
//      FALSE   the hDrop was bad
//

STDAPI_(BOOL) DragQueryInfo(HDROP hDrop, DRAGINFO *pdi)
{
    if (hDrop && (pdi->uSize == sizeof(DRAGINFO))) 
    {
        LPDROPFILES lpdfx = (LPDROPFILES)GlobalLock((HGLOBAL)hDrop);
        
        pdi->lpFileList = NULL;
        
        if (lpdfx)
        {
            LPTSTR lpOldFileList;
            if (LOWORD(lpdfx->pFiles) == sizeof(DROPFILES16))
            {
                //
                // This is Win31-stye HDROP
                //
                LPDROPFILES16 pdf16 = (LPDROPFILES16)lpdfx;
                pdi->pt.x  = pdf16->pt.x;
                pdi->pt.y  = pdf16->pt.y;
                pdi->fNC   = pdf16->fNC;
                pdi->grfKeyState = 0;
                lpOldFileList = (LPTSTR)((LPBYTE)pdf16 + pdf16->pFiles);
            }
            else
            {
                //
                // This is a new (NT-compatible) HDROP.
                //
                pdi->pt.x  = lpdfx->pt.x;
                pdi->pt.y  = lpdfx->pt.y;
                pdi->fNC   = lpdfx->fNC;
                pdi->grfKeyState = 0;
                lpOldFileList = (LPTSTR)((LPBYTE)lpdfx + lpdfx->pFiles);
                
                // there could be other data in there, but all
                // the HDROPs we build should be this size
                ASSERT(lpdfx->pFiles == sizeof(DROPFILES));
            }
            
            {
                BOOL fListMatchesBuild;
                
                if ((LOWORD(lpdfx->pFiles) == sizeof(DROPFILES16)) || lpdfx->fWide == FALSE)
                {
                    fListMatchesBuild = FALSE;
                }
                else
                {
                    fListMatchesBuild = TRUE;
                }
                if (fListMatchesBuild)
                {
                    LPTSTR pTStr = (LPTSTR) lpOldFileList;
                    LPTSTR pNewFileList;
                    UINT   cChar;
                    
                    // Look for the end of the file list
                    
                    while (*pTStr || *(pTStr + 1))
                    {
                        pTStr++;
                    }
                    pTStr++;    // Advance to last NUL of double terminator
                    
                    cChar = (UINT)(pTStr - lpOldFileList);
                    
                    pNewFileList = (LPTSTR) SHAlloc((cChar + 1) * sizeof(TCHAR));
                    if (NULL == pNewFileList)
                    {
                        GlobalUnlock((HGLOBAL)hDrop);
                        return FALSE;
                    }
                    
                    // Copy strings to new buffer and set LPDROPINFO filelist
                    // pointer to point to this new buffer
                    
                    CopyMemory(pNewFileList, lpOldFileList, ((cChar + 1) * sizeof(TCHAR)));
                    pdi->lpFileList = pNewFileList;
                }
                else
                {
                    LPXSTR pXStr = (LPXSTR) lpOldFileList;
                    LPTSTR pNewFileList;
                    LPTSTR pSaveFileList;
                    UINT   cChar;
                    UINT   cchConverted;
                    
                    // Look for the end of the file list
                    
                    while (*pXStr || (*(pXStr + 1)))
                    {
                        pXStr++;
                    }
                    pXStr++;   // Advance to the last NUL of the double terminator
                    
                    cChar = (UINT)(pXStr - ((LPXSTR) lpOldFileList));
                    
                    pNewFileList = (LPTSTR) SHAlloc((cChar + 1) * sizeof(TCHAR));
                    if (NULL == pNewFileList)
                    {
                        GlobalUnlock((HGLOBAL)hDrop);
                        return FALSE;
                    }
                    pSaveFileList = pNewFileList;
                    
                    pXStr = (LPXSTR) lpOldFileList;
                    
                    do
                    {
                        cchConverted = MultiByteToWideChar(CP_ACP, 0, pXStr, -1, 
                            pNewFileList, ((cChar + 1) * sizeof(TCHAR)));        // Not really, but... "trust me"
                        
                        if (0 == cchConverted)
                        {
                            ASSERT(0 && "Unable to convert HDROP filename ANSI -> UNICODE");
                            GlobalUnlock((HGLOBAL)hDrop);
                            SHFree(pSaveFileList);
                            return FALSE;
                        }
                        
                        pNewFileList += cchConverted;
                        pXStr += lstrlenX(pXStr) + 1;
                    } while (*pXStr);
                    
                    // Add the double-null-terminator to the output list
                    
                    *pNewFileList = 0;
                    pdi->lpFileList = pSaveFileList;
                }
            }
            
            GlobalUnlock((HGLOBAL)hDrop);
            
            return TRUE;
        }
    }
    return FALSE;
}

// 3.1 API

STDAPI_(BOOL) DragQueryPoint(HDROP hDrop, POINT *ppt)
{
    BOOL fRet = FALSE;
    LPDROPFILES lpdfs = (LPDROPFILES)GlobalLock((HGLOBAL)hDrop);
    if (lpdfs)
    {
        if (LOWORD(lpdfs->pFiles) == sizeof(DROPFILES16))
        {
            //
            // This is Win31-stye HDROP
            //
            LPDROPFILES16 pdf16 = (LPDROPFILES16)lpdfs;
            ppt->x = pdf16->pt.x;
            ppt->y = pdf16->pt.y;
            fRet = !pdf16->fNC;
        }
        else
        {
            //
            // This is a new (NT-compatible) HDROP
            //
            ppt->x = (UINT)lpdfs->pt.x;
            ppt->y = (UINT)lpdfs->pt.y;
            fRet = !lpdfs->fNC;

            // there could be other data in there, but all
            // the HDROPs we build should be this size
            ASSERT(lpdfs->pFiles == sizeof(DROPFILES));
        }
        GlobalUnlock((HGLOBAL)hDrop);
    }

    return fRet;
}

//
// Unfortunately we need it split out this way because WOW needs to
// able to call a function named DragQueryFileAorW (so it can shorten them)
//
STDAPI_(UINT) DragQueryFileAorW(HDROP hDrop, UINT iFile, void *lpFile, UINT cb, BOOL fNeedAnsi, BOOL fShorten)
{
    UINT i;
    LPDROPFILESTRUCT lpdfs = (LPDROPFILESTRUCT)GlobalLock(hDrop);
    if (lpdfs)
    {
        // see if it is the new format
        BOOL fWide = LOWORD(lpdfs->pFiles) == sizeof(DROPFILES) && lpdfs->fWide;
        if (fWide)
        {
            LPWSTR lpList;
            WCHAR szPath[MAX_PATH];

            //
            // UNICODE HDROP
            //

            lpList = (LPWSTR)((LPBYTE)lpdfs + lpdfs->pFiles);

            // find either the number of files or the start of the file
            // we're looking for
            //
            for (i = 0; (iFile == (UINT)-1 || i != iFile) && *lpList; i++)
            {
                while (*lpList++)
                    ;
            }

            if (iFile == (UINT)-1)
                goto Exit;


            iFile = i = lstrlenW(lpList);
            if (fShorten && iFile < MAX_PATH)
            {
                wcscpy(szPath, lpList);
                SheShortenPathW(szPath, TRUE);
                lpList = szPath;
                iFile = i = lstrlenW(lpList);
            }

            if (fNeedAnsi)
            {
                // Do not assume that a count of characters == a count of bytes
                i = WideCharToMultiByte(CP_ACP, 0, lpList, -1, NULL, 0, NULL, NULL);
                iFile = i ? --i : i;
            }

            if (!i || !cb || !lpFile)
                goto Exit;

            if (fNeedAnsi) 
            {
                SHUnicodeToAnsi(lpList, (LPSTR)lpFile, cb);
            } 
            else 
            {
                cb--;
                if (cb < i)
                    i = cb;
                lstrcpynW((LPWSTR)lpFile, lpList, i + 1);
            }
        }
        else
        {
            LPSTR lpList;
            CHAR szPath[MAX_PATH];

            //
            // This is Win31-style HDROP or an ANSI NT Style HDROP
            //
            lpList = (LPSTR)((LPBYTE)lpdfs + lpdfs->pFiles);

            // find either the number of files or the start of the file
            // we're looking for
            //
            for (i = 0; (iFile == (UINT)-1 || i != iFile) && *lpList; i++)
            {
                while (*lpList++)
                    ;
            }

            if (iFile == (UINT)-1)
                goto Exit;

            iFile = i = lstrlenA(lpList);
            if (fShorten && iFile < MAX_PATH)
            {
                strcpy(szPath, lpList);
                SheShortenPathA(szPath, TRUE);
                lpList = szPath;
                iFile = i = lstrlenA(lpList);
            }

            if (!fNeedAnsi)
            {
                i = MultiByteToWideChar(CP_ACP, 0, lpList, -1, NULL, 0);
                iFile = i ? --i : i;
            }

            if (!i || !cb || !lpFile)
                goto Exit;

            if (fNeedAnsi) 
            {
                cb--;
                if (cb < i)
                    i = cb;
    
                lstrcpynA((LPSTR)lpFile, lpList, i + 1);
            } 
            else 
            {
                SHAnsiToUnicode(lpList, (LPWSTR)lpFile, cb);
            }
        }
    }

    i = iFile;

Exit:
    GlobalUnlock(hDrop);

    return i;
}

STDAPI_(UINT) DragQueryFileW(HDROP hDrop, UINT wFile, LPWSTR lpFile, UINT cb)
{
   return DragQueryFileAorW(hDrop, wFile, lpFile, cb, FALSE, FALSE);
}

STDAPI_(UINT) DragQueryFileA(HDROP hDrop, UINT wFile, LPSTR lpFile, UINT cb)
{
   return DragQueryFileAorW(hDrop, wFile, lpFile, cb, TRUE, FALSE);
}

STDAPI_(void) DragFinish(HDROP hDrop)
{
    GlobalFree((HGLOBAL)hDrop);
}

STDAPI_(void) DragAcceptFiles(HWND hwnd, BOOL fAccept)
{
    long exstyle = GetWindowLong(hwnd, GWL_EXSTYLE);
    if (fAccept)
        exstyle |= WS_EX_ACCEPTFILES;
    else
        exstyle &= (~WS_EX_ACCEPTFILES);
    SetWindowLong(hwnd, GWL_EXSTYLE, exstyle);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\psdocurd.c ===
// PSeuDO CURrentDirectory module (psdocurd.c)
//
// This was swiped from cmd.exe sources to use the environment to emulate
// per process per drive current directory stuff.
//
// This uses the special '=A:=' environment strings to remember the
// current directories.
//
// Since the library is a DLL, all globals are process based.
//
#define UNICODE 1

#include "shellprv.h"
#pragma  hdrstop

#define SUCCESS FALSE
#define FAILURE TRUE
#define GD_DEFAULT 0

WCHAR CurDrvDirW[MAX_PATH] = L"";

#define DBL_BSLASH(sz) \
   (*(WCHAR *)(sz) == CHAR_BSLASH) && \
   (*(WCHAR *)((sz)+1) == CHAR_BSLASH)

INT
SheSetEnvVarW(
   WCHAR *varname,
   WCHAR *varvalue
   )
{
   if (!wcslen(varvalue)) {
      varvalue = NULL; // null to remove from env
   }
   return (!SetEnvironmentVariable(varname, varvalue));
}

WCHAR *
SheGetEnvVarW(
   WCHAR *varname)
{
   static WCHAR GetEnvVarBuffer[ 1024 ];

   if (GetEnvironmentVariableW(varname, GetEnvVarBuffer, 1024)) {
      return(GetEnvVarBuffer);
   } else {
      return(NULL);
   }
}

INT
SheGetPathOffsetW(
   LPWSTR lpszDir)
{
   // sanity
   if (!lpszDir || !*lpszDir) {
      return(-1);
   }

   if ((*(lpszDir+1) == WCHAR_COLON) &&
       ((*(lpszDir+2) == WCHAR_BSLASH) ||
        (*(lpszDir+2) == WCHAR_SLASH) ||
        (*(lpszDir+2) == WCHAR_NULL)) ) {

      return(2);

   } else if (DBL_BSLASH(lpszDir)) {

      // Deviceless, assume LanMan Provided UNC names (i.e. DBL_BSLASH above)

      INT cchServerShareLen = -1;
      DWORD dwSlashesSeen = 0;

      // There are exactly 4 b-slashes from here

      while (dwSlashesSeen != 4) {
         cchServerShareLen++;

         if (!*lpszDir) {
            if (dwSlashesSeen == 3) {
               return(cchServerShareLen);
            } else {
               return(-1);
            }
         }

         if ((*lpszDir == CHAR_BSLASH) || (*lpszDir == CHAR_SLASH)) {
            dwSlashesSeen++;
         }

         lpszDir++;
      }

      return(cchServerShareLen);

   } else {

      // unrecognized format
      return(-1);
   }
}

INT
SheGetDirW(
   INT  iDrive,             // 0 = default, 1=A....
   WCHAR *str
   )
{
   WCHAR        denvname[ 4 ];
   WCHAR        *denvvalue;
   WCHAR        *strT = str;

   if (iDrive-- == GD_DEFAULT) {
      GetCurrentDirectoryW(MAX_PATH, str);
      return(SUCCESS);
   }

   denvname[ 0 ] = WCHAR_EQUAL;
   denvname[ 1 ] = (WCHAR)(WCHAR_CAP_A + (WCHAR)iDrive);
   denvname[ 2 ] = WCHAR_COLON;
   denvname[ 3 ] = WCHAR_NULL;

   denvvalue = SheGetEnvVarW( denvname );
   if (!denvvalue) {
      *str++ = (WCHAR)(WCHAR_CAP_A + (WCHAR)iDrive);
      *str++ = WCHAR_COLON;
      *str++ = WCHAR_BSLASH;
      *str   = WCHAR_NULL;
   }
   else {
      wcscpy( str, denvvalue );
   }

   // there is a subtle difference between getcurrentdirectory() of DOS and the
   // equivalent SheGetDir() of NT. On dos, getcurrentdirectory() accesses the
   // floppy drives while in NT SheGetDir() returns the values that are set in
   // the environment variables. So we hit the disk on NT too, by calling
   // GetFileAttributes. We return SUCCESS or FAILURE based on the return value
   // of GetFileAttributes.

   if (GetFileAttributesW(strT) == (DWORD)0xffffffff)
      return(FAILURE);
   else
      return(SUCCESS);
}

// Should be BOOL, but possible mips breakage
INT
SheGetDirA(
   INT iDrive,             // 0 = default, 1=A....
   CHAR *szDirA)
{
   WCHAR szDirW[MAX_PATH];
   BOOL fDefCharUsed;
   INT nRet;

   if (!szDirA) {
      return(FAILURE);
   }

   nRet = SheGetDirW(iDrive, szDirW);
   WideCharToMultiByte(CP_ACP, 0, (LPWSTR)szDirW, -1, (LPSTR)szDirA,
      MAX_PATH, NULL, &fDefCharUsed);

   return(nRet);
}

INT
SheChangeDirW(
   WCHAR *newdir
   )
{
   WCHAR       denvname[ 4 ];
   WCHAR       newpath[ MAX_PATH ];
   WCHAR       denvvalue[ MAX_PATH ];
   WCHAR       c, *s;
   DWORD       attr;

   GetCurrentDirectoryW( MAX_PATH, denvvalue );
   c = (WCHAR)(DWORD_PTR)CharUpperW((LPTSTR)(DWORD_PTR)denvvalue[0]);

   denvname[0] = WCHAR_EQUAL;
   if (IsCharAlphaW(*newdir) && newdir[1] == WCHAR_COLON) {
      denvname[1] = (WCHAR)(DWORD_PTR)CharUpperW((LPTSTR)(DWORD_PTR)*newdir);
      newdir += 2;
   } else {
      denvname[ 1 ] = c;
   }
   denvname[ 2 ] = WCHAR_COLON;
   denvname[ 3 ] = WCHAR_NULL;

   if ((*newdir == WCHAR_BSLASH) || (*newdir == WCHAR_SLASH)) {
      newpath[ 0 ] = denvname[ 1 ];
      newpath[ 1 ] = denvname[ 2 ];
      wcscpy( &newpath[ 2 ], newdir );
   } else {
      if (NULL != (s = SheGetEnvVarW( denvname ))) {
         wcscpy( newpath, s );
      } else {
         newpath[ 0 ] = denvname[ 1 ];
         newpath[ 1 ] = denvname[ 2 ];
         newpath[ 2 ] = WCHAR_NULL;
      }
      s = newpath + wcslen( newpath );
      *s++ = WCHAR_BSLASH;
      wcscpy( s, newdir );
   }

   if (!GetFullPathNameW(newpath, MAX_PATH, denvvalue, &s )) {
      return( ERROR_ACCESS_DENIED );
   }

   attr = GetFileAttributesW( denvvalue );
   if (attr == -1 || !(attr & FILE_ATTRIBUTE_DIRECTORY)) {
      return( ERROR_ACCESS_DENIED );
   }

   if (SheSetEnvVarW(denvname,denvvalue)) {
      return( ERROR_NOT_ENOUGH_MEMORY );
   }

   SetCurrentDirectoryW( denvvalue );

   // this seems wrong... SheGetDir(GD_DEFAULT, CurDrvDirW) ;
   wcscpy(CurDrvDirW, denvvalue);   // this seems right to me.
   return(SUCCESS) ;
}

INT
SheChangeDirA(
   CHAR *szNewDirA
   )
{
   WCHAR szNewDirW[MAX_PATH];

   if (szNewDirA) {
      MultiByteToWideChar(CP_ACP, 0, (LPSTR)szNewDirA, -1, szNewDirW, MAX_PATH);
      return(SheChangeDirW(szNewDirW));
   } else {
     return(FAILURE);
   }
}

INT
SheChangeDirExW(
   WCHAR *newdir)
{
   WCHAR wcEnvName[MAX_PATH];
   WCHAR wcNewPath[MAX_PATH];
   WCHAR wcEnvValue[MAX_PATH];

   DWORD cchPathOffset;

   WCHAR *s;
   DWORD attr;
   BOOL bUsedEnv = FALSE;

   if (newdir && *newdir &&
       ((cchPathOffset = SheGetPathOffsetW((LPWSTR)newdir)) != 0xFFFFFFFF)) {
      WCHAR wc = newdir[cchPathOffset];

      newdir[cchPathOffset] = WCHAR_NULL;
      wcscpy((LPWSTR)&wcEnvName[1], (LPWSTR)newdir);

      newdir[cchPathOffset] = wc;
      newdir += cchPathOffset;

   } else {

      GetCurrentDirectoryW(MAX_PATH, wcEnvValue);

      wcscpy((LPWSTR)&wcEnvName[1], (LPWSTR)wcEnvValue);
   }

   wcEnvName[0] = WCHAR_EQUAL;
   if ((cchPathOffset = SheGetPathOffsetW((LPWSTR)&wcEnvName[1])) != 0xFFFFFFFF) {

      // add one since the first character is "="
      wcEnvName[cchPathOffset + 1] = WCHAR_NULL;
   }

   //
   // If return value is 2, then we are a drive letter like A:
   // We need to uppercase the drive letter here, since the environ
   // vars are usually set as uppercase.
   //
   if (cchPathOffset == 2) {

      wcEnvName[1] = (WCHAR)(DWORD_PTR)CharUpper((LPWSTR)(DWORD_PTR) wcEnvName[1]);
   }

   if (newdir && *newdir &&
       ((*newdir == WCHAR_BSLASH) || (*newdir == WCHAR_SLASH))) {

      wcscpy((LPWSTR)wcNewPath, (LPWSTR)&wcEnvName[1]);
      if (lstrlen(wcNewPath) + lstrlen(newdir) < MAX_PATH ) {
          lstrcat((LPWSTR)wcNewPath, (LPWSTR)newdir);
      }

   } else {
      LPWSTR lpszEnvName;

      if (NULL != (lpszEnvName = (LPWSTR)SheGetEnvVarW(wcEnvName))) {

         wcscpy((LPWSTR)wcNewPath, lpszEnvName);
         bUsedEnv = TRUE;

      } else {

         wcscpy((LPWSTR)wcNewPath, (LPWSTR)&wcEnvName[1]);
      }

      if (newdir && *newdir) {
         if (wcNewPath[lstrlen(wcNewPath)-1] != WCHAR_BSLASH) {
            lstrcat((LPWSTR)wcNewPath, TEXT("\\"));
         }
         if (lstrlen(wcNewPath) + lstrlen(newdir) < MAX_PATH ) {
             lstrcat((LPWSTR)wcNewPath, (LPWSTR)newdir);
         }
      }
   }

   if (!GetFullPathNameW((LPWSTR)wcNewPath, MAX_PATH, wcEnvValue, &s)) {
      return( ERROR_ACCESS_DENIED );
   }

   attr = GetFileAttributesW((LPWSTR)wcEnvValue);

   if ((attr == 0xFFFFFFFF ||
       ((attr & FILE_ATTRIBUTE_DIRECTORY) &&
         !SetCurrentDirectoryW((LPWSTR)wcEnvValue)))
       && bUsedEnv ) {

      wcscpy((LPWSTR)wcEnvValue, (LPWSTR)&wcEnvName[1]);
      lstrcat((LPWSTR)wcEnvValue, TEXT("\\"));

      attr = GetFileAttributesW((LPWSTR)wcEnvValue);

   }

   if (attr == 0xFFFFFFFF || !(attr & FILE_ATTRIBUTE_DIRECTORY)) {

      return(ERROR_ACCESS_DENIED);
   }

   if (!SetCurrentDirectoryW((LPWSTR)wcEnvValue)) {
      return( ERROR_ACCESS_DENIED );
   }

   // It's ok if this fails
   SheSetEnvVarW(wcEnvName, wcEnvValue);

   wcscpy(CurDrvDirW, (LPWSTR)wcEnvValue);   // this seems right to me.
   return(SUCCESS) ;
}

INT
SheChangeDirExA(
   CHAR *szNewDirA
   )
{
   WCHAR szNewDirW[MAX_PATH];

   if (szNewDirA) {
      MultiByteToWideChar(CP_ACP, 0, (LPSTR)szNewDirA, -1, szNewDirW, MAX_PATH);
      return(SheChangeDirExW(szNewDirW));
   } else {
     return(FAILURE);
   }
}

INT
SheGetCurDrive()
{
   if (!CurDrvDirW[0]) {
      SheGetDirW(GD_DEFAULT, CurDrvDirW) ;
   }
   return(CurDrvDirW[0] - WCHAR_CAP_A);
}


INT
SheSetCurDrive(
   INT iDrive
   )
{
   WCHAR chT[MAX_PATH];

   if (CurDrvDirW[0] != (WCHAR)(WCHAR_CAP_A + iDrive)) {
      SheGetDirW(iDrive + 1, chT);
      return(SheChangeDirW(chT));
   }
   return(SUCCESS);
}

INT
SheFullPathA(
   CHAR *fname,
   DWORD sizpath,
   CHAR *buf)
{
   DWORD rc = SUCCESS;         /* prime with good rc */
   DWORD buflen;               /* buffer length      */
   CHAR *filepart;

   if (*fname == CHAR_NULL) {
      SheGetDirA(GD_DEFAULT, buf);
      buf += 2;                           /* Inc past drivespec      */
      buflen = strlen(buf);             /* Is curdir root only?    */
      if (buflen >= MAX_PATH-3) {  /* If too big then stop    */
         rc = FAILURE;
       } else if (buflen != 1) {              /* if not root then append */
         *(buf+buflen++) = CHAR_BSLASH;      /* ...a pathchar and...    */
         *(buf+buflen) = CHAR_NULL ;              /* ...a null CHAR...       */
       }                                 /*                         */
   } else {
      if ((strlen(fname) == 2) &&
          (*(fname + 1) == CHAR_COLON)
          // && (!is_dbcsleadchar(*fname))
         ) {
         SheGetDirA((CHAR)(DWORD_PTR)CharUpperA((LPSTR)(DWORD_PTR)*fname) - CHAR_CAP_A, buf);                 /* Get curdrvdir           */
         if ((buflen = strlen(buf)) > 3) {
            *(buf+buflen++) = CHAR_BSLASH;      /* ...a pathchar and...    */
            *(buf+buflen) = CHAR_NULL ;          /* ...a null CHAR...           */
         }
      } else {
         if (!GetFullPathNameA( fname, sizpath, buf, &filepart )) {
            rc = FAILURE;
         }
      }
   }
   return(rc);
}

INT
SheFullPathW(
   WCHAR *fname,
   DWORD sizpath,
   WCHAR *buf)
{
   DWORD rc = SUCCESS;         /* prime with good rc */
   DWORD buflen;               /* buffer length      */
   WCHAR *filepart;

   if (*fname == WCHAR_NULL) {
      SheGetDirW(GD_DEFAULT, buf);
      buf += 2;                           /* Inc past drivespec      */
      buflen = wcslen(buf);             /* Is curdir root only?    */
      if (buflen >= MAX_PATH-3) {  /* If too big then stop    */
         rc = FAILURE;
       } else if (buflen != 1) {              /* if not root then append */
         *(buf+buflen++) = WCHAR_BSLASH;      /* ...a pathchar and...    */
         *(buf+buflen) = WCHAR_NULL ;              /* ...a null CHAR...       */
       }                                 /*                         */
   } else {
      if ((wcslen(fname) == 2) &&
          (*(fname + 1) == WCHAR_COLON)
          // && (!is_dbcsleadchar(*fname))
         ) {
         SheGetDirW((WCHAR)(DWORD_PTR)CharUpperW((LPWSTR)(DWORD_PTR)*fname) - WCHAR_CAP_A, buf);                 /* Get curdrvdir           */
         if ((buflen = wcslen(buf)) > 3) {
            *(buf+buflen++) = WCHAR_BSLASH;      /* ...a pathchar and...    */
            *(buf+buflen) = WCHAR_NULL ;          /* ...a null CHAR...           */
         }
      } else {
         if (!GetFullPathNameW( fname, sizpath, buf, &filepart )) {
            rc = FAILURE;
         }
      }
   }
   return(rc);
}



BOOL
SheGetDirExW(
   LPWSTR lpszCurDisk,
   LPDWORD lpcchCurDir,
   LPWSTR lpszCurDir)
{
   WCHAR wcEnvName[MAX_PATH];
   LPWSTR lpszEnvValue;
   INT cchPathOffset;

   // if lpszCurDisk NULL, do default
   if (!lpszCurDisk) {
      DWORD dwRet = GetCurrentDirectoryW(*lpcchCurDir, lpszCurDir);

      if (dwRet) {
         *lpcchCurDir = dwRet;
         return(TRUE);
      } else {
         return(FALSE);
      }

   }

   cchPathOffset = SheGetPathOffsetW(lpszCurDisk);

   if (cchPathOffset != 0xFFFFFFFF) {
      WCHAR wc = *(lpszCurDisk + cchPathOffset);

      *(lpszCurDisk + cchPathOffset) = WCHAR_NULL;
      lstrcpy(&wcEnvName[1], lpszCurDisk);
      wcEnvName[0] = WCHAR_EQUAL;

      *(lpszCurDisk + cchPathOffset) = wc;

      if (NULL != (lpszEnvValue = SheGetEnvVarW(wcEnvName))) {
         DWORD cchEnvValue = lstrlen(lpszEnvValue) + 1;

         if (cchEnvValue <= *lpcchCurDir) {
            wcscpy(lpszCurDir, lpszEnvValue);
            return(TRUE);
         } else {
            *lpcchCurDir = cchEnvValue;
            return(FALSE);
         }
      }

      wcscpy(lpszCurDir, lpszCurDisk);
      *(lpszCurDir + cchPathOffset) = WCHAR_BSLASH;
      *(lpszCurDir + cchPathOffset + 1) = WCHAR_NULL;

      return(TRUE);

   } else {

      // parsing error
      return(FALSE);

   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\recdocs.h ===
#ifndef _RECDOCS_H_
#define _RECDOCS_H_

STDAPI CreateRecentMRUList(IMruDataList **ppmru);
STDAPI RecentDocs_Enum(IMruDataList *pmru, int iItem, LPITEMIDLIST *ppidl);
STDAPI_(void) AddToRecentDocs( LPCITEMIDLIST pidl, LPCTSTR lpszPath );
STDAPI CTaskAddDoc_Create(HANDLE hMem, DWORD dwProcId, IRunnableTask **pptask);
STDAPI RecentDocs_GetDisplayName(LPCITEMIDLIST pidl, LPTSTR pszName, DWORD cchName);

#define MAXRECENTDOCS 15

#endif  //  _RECDOCS_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\psxa.c ===
//
// PropSheetExtArray implementation, use for control panel applets to extend their pages
//
// Manipulates a group of property sheet extension objects (see PSXA.H)
//
#include "shellprv.h"
#pragma  hdrstop

// header for an array of IShellPropSheetExt interface pointers

typedef struct
{
    UINT count, alloc;
    IShellPropSheetExt *interfaces[ 0 ];
} PSXA;


// used to forward LPFNADDPROPSHEETPAGE calls with added error checking

typedef struct
{
    LPFNADDPROPSHEETPAGE pfn;
    LPARAM lparam;
    UINT count;
    BOOL allowmulti;
    BOOL alreadycalled;
} _PSXACALLINFO;


// forwards an LPFNADDPROPSHEETPAGE call with added error checking

BOOL CALLBACK _PsxaCallOwner(HPROPSHEETPAGE hpage, LPARAM lparam)
{
    _PSXACALLINFO *callinfo = (_PSXACALLINFO *)lparam;
    if (callinfo)
    {
        if (!callinfo->allowmulti && callinfo->alreadycalled)
            return FALSE;

        if (callinfo->pfn(hpage, callinfo->lparam))
        {
            callinfo->alreadycalled = TRUE;
            callinfo->count++;
            return TRUE;
        }
    }
    return FALSE;
}

// creates an instance of the property sheet extension referred to by szCLSID
// initializes it via the IShellExtInit (if IShellExtInit is supported)

BOOL InitPropSheetExt(IShellPropSheetExt **ppspx, LPCTSTR pszCLSID, HKEY hKey, IDataObject *pDataObj)
{
    if (SUCCEEDED(SHExtCoCreateInstance(pszCLSID, NULL, NULL, &IID_IShellPropSheetExt, ppspx)))
    {
        IShellExtInit *psxi;

        if (SUCCEEDED((*ppspx)->lpVtbl->QueryInterface(*ppspx, &IID_IShellExtInit, &psxi)))
        {
            if (FAILED(psxi->lpVtbl->Initialize(psxi, NULL, pDataObj, hKey)))
            {
                (*ppspx)->lpVtbl->Release(*ppspx);
                *ppspx = NULL;
            }

            psxi->lpVtbl->Release(psxi);
        }
    }

    return BOOLFROMPTR(*ppspx);
}


// uses hKey and pszSubKey to find property sheet handlers in the registry
// loads up to max_iface IShellPropSheetExt interfaces (so I'm lazy...)
// returns a handle (pointer) to a newly allocated PSXA

HPSXA SHCreatePropSheetExtArrayEx(HKEY hKey, LPCTSTR pszLocation, UINT max_iface, IDataObject *pDataObj)
{
    BOOL success = FALSE;

    PSXA *psxa = LocalAlloc(LPTR, sizeof(*psxa) + sizeof(IShellPropSheetExt *) * max_iface);
    if (psxa)
    {
        IShellPropSheetExt **spsx = psxa->interfaces;
        HKEY hkLocation;
        UINT i;

        psxa->count = 0;
        psxa->alloc = max_iface;

        for (i = 0; i < psxa->alloc; i++, spsx++)
            *spsx = NULL;

        if (RegOpenKey(hKey, pszLocation, &hkLocation) == ERROR_SUCCESS)
        {
            HKEY hkHandlers;

            if (RegOpenKey(hkLocation, STRREG_SHEX_PROPSHEET, &hkHandlers) == ERROR_SUCCESS)
            {
                TCHAR szChild[ 64 ]; // yes, this is totally arbitrary...

                // fill until there's no room or no more subkeys to get
                for (i = 0;
                    (psxa->count < psxa->alloc) &&
                    (RegEnumKey(hkHandlers, (int)i, szChild,
                    ARRAYSIZE(szChild)) == ERROR_SUCCESS);
                    i++)
                {
                    TCHAR szCLSID[ MAX_PATH ];
                    LONG len_szCLSID = ARRAYSIZE(szCLSID);

                    if (SHRegQueryValue(hkHandlers, szChild, szCLSID,
                        &len_szCLSID) == ERROR_SUCCESS)
                    {
                        if (InitPropSheetExt(&psxa->interfaces[ psxa->count ],
                            szCLSID, hKey, pDataObj))
                        {
                            psxa->count++;
                        }
                    }
                }

                RegCloseKey(hkHandlers);
                success = TRUE;
            }

            RegCloseKey(hkLocation);
        }
    }

    if (!success && psxa)
    {
        SHDestroyPropSheetExtArray((HPSXA)psxa);
        psxa = NULL;
    }

    return (HPSXA)psxa;
}

HPSXA SHCreatePropSheetExtArray(HKEY hKey, LPCTSTR pszLocation, UINT max_iface)
{
    return SHCreatePropSheetExtArrayEx(hKey, pszLocation, max_iface, NULL);
}

// releases interfaces in a PSXA and frees the memory it occupies

void SHDestroyPropSheetExtArray(HPSXA hpsxa)
{
    PSXA *psxa = (PSXA *)hpsxa;
    IShellPropSheetExt **spsx = psxa->interfaces;
    UINT i;

    // release the interfaces
    for (i = 0; i < psxa->count; i++, spsx++)
        (*spsx)->lpVtbl->Release(*spsx);

    LocalFree(psxa);
}


// asks each interface in a PSXA to add pages for a proprty sheet
// returns the number of pages actually added

UINT SHAddFromPropSheetExtArray(HPSXA hpsxa, LPFNADDPROPSHEETPAGE lpfnAddPage, LPARAM lParam)
{
    PSXA *psxa = (PSXA *)hpsxa;
    IShellPropSheetExt **spsx = psxa->interfaces;
    _PSXACALLINFO callinfo = { lpfnAddPage, lParam, 0, TRUE, FALSE };
    UINT i;

    for (i = 0; i < psxa->count; i++, spsx++)
        (*spsx)->lpVtbl->AddPages(*spsx, _PsxaCallOwner, (LPARAM)&callinfo);

    return callinfo.count;
}


// asks each interface in a PSXA to replace a page in a prop sheet
// each interface is only allowed to add up to one replacement
// returns the total number of replacements added

UINT SHReplaceFromPropSheetExtArray(HPSXA hpsxa, UINT uPageID,
                                    LPFNADDPROPSHEETPAGE lpfnReplaceWith, LPARAM lParam)
{
    PSXA *psxa = (PSXA *)hpsxa;
    IShellPropSheetExt **spsx = psxa->interfaces;
    _PSXACALLINFO callinfo = { lpfnReplaceWith, lParam, 0, FALSE, FALSE };
    UINT i;

    for (i = 0; i < psxa->count; i++, spsx++)
    {
        // reset the call flag so that each provider gets a chance
        callinfo.alreadycalled = FALSE;

        if ((*spsx)->lpVtbl->ReplacePage)
            (*spsx)->lpVtbl->ReplacePage(*spsx, uPageID, _PsxaCallOwner, (LPARAM)&callinfo);
    }

    return callinfo.count;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\recdocs.cpp ===
//---------------------------------------------------------------------------
//
// Copyright (c) Microsoft Corporation 1991-1996
//
// File:      recdocs.cpp
//
// History -  created from recent.c in explorer  - ZekeL - 5-MAR-98
//              combining functionality in to one place
//              now that the desktop lives here.
//---------------------------------------------------------------------------

#include "shellprv.h"
#include "recdocs.h"
#include "fstreex.h"
#include "shcombox.h"
#include "ids.h"
#include <urlhist.h>
#include <runtask.h>

#define DM_RECENTDOCS 0x00000000

#define GETRECNAME(p) ((LPCTSTR)(p))
#define GETRECPIDL(p) ((LPCITEMIDLIST) (((LPBYTE) (p)) + CbFromCch(lstrlen(GETRECNAME(p)) +1)))

#define REGSTR_KEY_RECENTDOCS TEXT("RecentDocs")

#define MAX_RECMRU_BUF      (CbFromCch(3 * MAX_PATH))   // Max MRUBuf size

// Used to blow off adding the same file multiple times
TCHAR g_szLastFile[MAX_URL_STRING] = {0};
FILETIME g_ftLastFileCacheUpdate = {0};

STDAPI_(BOOL) SetFolderString(BOOL fCreate, LPCTSTR pszFolder, LPCTSTR pszProvider, LPCTSTR pszSection, LPCTSTR pszKey, LPCTSTR pszData);

STDAPI_(void) OpenWithListSoftRegisterProcess(DWORD dwFlags, LPCTSTR pszExt, LPCTSTR pszProcess);

class CTaskAddDoc : public CRunnableTask
{
public:
    CTaskAddDoc();
    HRESULT Init(HANDLE hMem, DWORD dwProcId);

    // *** pure virtuals ***
    virtual STDMETHODIMP RunInitRT(void);

private:
    virtual ~CTaskAddDoc();

    void _AddToRecentDocs(LPCITEMIDLIST pidlItem, LPCTSTR pszPath);
    void _TryDeleteMRUItem(IMruDataList *pmru, DWORD cMax, LPCTSTR pszFileName, LPCITEMIDLIST pidlItem, IMruDataList *pmruOther, BOOL fOverwrite);
    LPBYTE _CreateMRUItem(LPCITEMIDLIST pidlItem, LPCTSTR pszItem, DWORD *pcbItem, UINT uFlags);
    BOOL _AddDocToRecentAndExtRecent(LPCITEMIDLIST pidlItem, LPCTSTR pszFileName, LPCTSTR pszExt);
    void _TryUpdateNetHood(LPCITEMIDLIST pidlFolder, LPCTSTR pszFolder);
    void _UpdateNetHood(LPCITEMIDLIST pidlFolder, LPCTSTR pszShare);

    //  private members
    HANDLE _hMem;
    DWORD  _dwProcId;
    IMruDataList *_pmruRecent;
    DWORD _cMaxRecent;
    LPITEMIDLIST _pidlTarget;
};


BOOL ShouldAddToRecentDocs(LPCITEMIDLIST pidl)
{
    BOOL fRet = TRUE;  //  default to true
    IQueryAssociations *pqa;
    if (SUCCEEDED(SHGetAssociations(pidl, (void **)&pqa)))
    {
        DWORD dwAttributes, dwSize = sizeof(dwAttributes);
        if (SUCCEEDED(pqa->GetData(NULL, ASSOCDATA_EDITFLAGS, NULL, &dwAttributes, &dwSize)))
        {
            fRet = !(dwAttributes & FTA_NoRecentDocs);
        }
        pqa->Release();
    }  
    return fRet;
}

int RecentDocsComparePidl(const BYTE * p1, const BYTE *p2, int cb)
{
    int iRet;

    LPCIDFOLDER pidf1 = CFSFolder_IsValidID((LPCITEMIDLIST)p1);
    LPCIDFOLDER pidf2 = CFSFolder_IsValidID(GETRECPIDL(p2));

    if (pidf1 && pidf2)
    {
        iRet = CFSFolder_CompareNames(pidf1, pidf2);
    }
    else
    {
        ASSERTMSG(0, "Caller shouldn't be passing in bogus data");
        // return 0 (equal) if they're both NULL.
        iRet = (pidf1 != pidf2);
    }

    return iRet;
}

CTaskAddDoc::~CTaskAddDoc(void)
{
    TraceMsg(DM_RECENTDOCS, "[%X] CTaskAddDoc destroyed", this);
}

CTaskAddDoc::CTaskAddDoc(void) : CRunnableTask(RTF_DEFAULT)
{
    TraceMsg(DM_RECENTDOCS, "[%X] CTaskAddDoc created", this);
}


HRESULT CTaskAddDoc::Init( HANDLE hMem, DWORD dwProcId)
{
    if (hMem)
    {
        _hMem = hMem;
        _dwProcId = dwProcId;
        return S_OK;
    }
    return E_FAIL;
}

typedef struct {
    DWORD   dwOffsetPath;
    DWORD   dwOffsetPidl;
    DWORD   dwOffsetProcess;
} XMITARD;


LPCTSTR _OffsetToStrValidate(void *px, DWORD dw)
{
    LPCTSTR psz = dw ? (LPTSTR)((LPBYTE)px + dw) : NULL;
    if (psz && IsBadStringPtr(psz, MAX_PATH))
        psz = NULL;
    return psz;
}

HRESULT CTaskAddDoc::RunInitRT(void)
{
    TraceMsg(DM_RECENTDOCS, "[%X] CTaskAddDoc::RunInitRT() running", this);

    XMITARD *px = (XMITARD *)SHLockShared(_hMem, _dwProcId);
    if (px)
    {
        LPITEMIDLIST pidl = px->dwOffsetPidl ? (LPITEMIDLIST)((LPBYTE)px+px->dwOffsetPidl) : NULL;
        LPCTSTR pszPath = _OffsetToStrValidate(px, px->dwOffsetPath);
        LPCTSTR pszProcess = _OffsetToStrValidate(px, px->dwOffsetProcess);

        ASSERT(pszPath);
        
        if (pszPath && pszProcess)
            OpenWithListSoftRegisterProcess(0, PathFindExtension(pszPath), pszProcess);

        _AddToRecentDocs(pidl, pszPath);

        SHUnlockShared(px);
        SHFreeShared(_hMem, _dwProcId);
    }
    
    return S_OK;
}


BOOL GetExtensionClassDescription(LPCTSTR pszFile)
{
    LPTSTR pszExt = PathFindExtension(pszFile);
    HKEY hk;
    if (*pszExt && SUCCEEDED(AssocQueryKey(0, ASSOCKEY_SHELLEXECCLASS, pszExt, NULL, &hk)))
    {
        RegCloseKey(hk);
        return TRUE;
    }
    return FALSE;
}

STDAPI_(void) FlushRunDlgMRU(void);

#define MAXRECENT_DEFAULTDOC      10
#define MAXRECENT_MAJORDOC        20

//  SRMLF_* flags to pass into CreateSharedRecentMRUList()
#define SRMLF_COMPNAME  0x00000000   // default:  compare using the name of the recent file
#define SRMLF_COMPPIDL  0x00000001   // use the pidl in the recent folder


IMruDataList *CreateSharedRecentMRUList(LPCTSTR pszClass, DWORD *pcMax, DWORD dwFlags)
{
    IMruDataList *pmru = NULL;

    if (SHRestricted(REST_NORECENTDOCSHISTORY))
        return NULL;

    HKEY hk = SHGetShellKey(SHELLKEY_HKCU_EXPLORER, REGSTR_KEY_RECENTDOCS, TRUE);

    if (hk)
    {
        DWORD cMax;

        if (pszClass)
        {

            //  we need to find out how many
            if (NOERROR == SHGetValue(HKEY_CLASSES_ROOT, pszClass, TEXT("MajorDoc"), NULL, NULL, NULL))
                cMax = MAXRECENT_MAJORDOC;
            else
                cMax = MAXRECENT_DEFAULTDOC;
        }
        else
        {
            //  this the root MRU
            cMax = SHRestricted(REST_MaxRecentDocs);

            //  default max docs...
            if (cMax < 1)
                cMax = MAXRECENTDOCS * MAXRECENT_DEFAULTDOC;
        }

        if (pcMax)
            *pcMax = cMax;

        if (SUCCEEDED(SHCoCreateInstance(NULL, &CLSID_MruLongList, NULL, IID_PPV_ARG(IMruDataList, &pmru))))
        {
            if (FAILED(pmru->InitData(cMax, MRULISTF_USE_STRCMPIW, hk, pszClass, dwFlags & SRMLF_COMPPIDL ? RecentDocsComparePidl : NULL)))
            {
                pmru->Release();
                pmru = NULL;
            }
        }

        RegCloseKey(hk);
    }
    
    return pmru;
}

HRESULT CreateRecentMRUList(IMruDataList **ppmru)
{
    *ppmru = CreateSharedRecentMRUList(NULL, NULL, SRMLF_COMPPIDL);
    return *ppmru ? S_OK : E_OUTOFMEMORY;
}



//
//  _CleanRecentDocs()
//  cleans out the recent docs folder and the associate registry keys.
//
void _CleanRecentDocs(void)
{
    LPITEMIDLIST pidlTargetLocal = SHCloneSpecialIDList(NULL, CSIDL_RECENT, TRUE);
    if (pidlTargetLocal)
    {
        TCHAR szDir[MAX_PATH];

        // first, delete all the files
        SHFILEOPSTRUCT sFileOp =
        {
            NULL,
            FO_DELETE,
            szDir,
            NULL,
            FOF_NOCONFIRMATION | FOF_SILENT,
        };
        
        SHGetPathFromIDList(pidlTargetLocal, szDir);
        szDir[lstrlen(szDir) +1] = 0;     // double null terminate
        SHFileOperation(&sFileOp);


        ILFree(pidlTargetLocal);

        pidlTargetLocal = SHCloneSpecialIDList(NULL, CSIDL_NETHOOD, TRUE);

        if (pidlTargetLocal)
        {
            //  now we take care of cleaning out the nethood
            //  we have to more careful, cuz we let other people
            //  add their own stuff in here.
            
            IMruDataList *pmru = CreateSharedRecentMRUList(TEXT("NetHood"), NULL, SRMLF_COMPPIDL);

            if (pmru)
            {
                IShellFolder* psf;

                if (SUCCEEDED(SHBindToObject(NULL, IID_X_PPV_ARG(IShellFolder, pidlTargetLocal, &psf))))
                {
                    BOOL fUpdate = FALSE;
                    int iItem = 0;
                    LPITEMIDLIST pidlItem;

                    ASSERT(psf);

                    while (SUCCEEDED(RecentDocs_Enum(pmru, iItem++, &pidlItem)))
                    {
                        ASSERT(pidlItem);
                        STRRET str;
                        if (SUCCEEDED(psf->GetDisplayNameOf(pidlItem, SHGDN_FORPARSING, &str))
                        && SUCCEEDED(StrRetToBuf(&str, pidlItem, szDir, ARRAYSIZE(szDir))))
                        {
                            szDir[lstrlen(szDir) +1] = 0;     // double null terminate
                            SHFileOperation(&sFileOp);
                        }
                            
                        ILFree(pidlItem);
                    }

                    if (fUpdate)
                        SHChangeNotify(SHCNE_UPDATEDIR, 0, (void *)pidlTargetLocal, NULL);

                    psf->Release();
                }

                pmru->Release();
            }

            ILFree(pidlTargetLocal);
        }

        //  force the recreation of the recent folder.
        SHGetFolderPath(NULL, CSIDL_RECENT | CSIDL_FLAG_CREATE, NULL, SHGFP_TYPE_CURRENT, szDir);

        // now delete the registry stuff
        HKEY hk = SHGetShellKey(SHELLKEY_HKCU_EXPLORER, NULL, FALSE);
        if (hk)
        {
            SHDeleteKey(hk, REGSTR_KEY_RECENTDOCS);
            RegCloseKey(hk);
        }

        SHChangeNotifyHandleEvents();
    }
    
    FlushRunDlgMRU();

    ENTERCRITICAL;
    g_szLastFile[0] = 0;
    g_ftLastFileCacheUpdate.dwLowDateTime = 0;
    g_ftLastFileCacheUpdate.dwHighDateTime = 0;
    LEAVECRITICAL;

    return;
}

//
//  WARNING - _TryDeleteMRUItem() returns an allocated string that must be freed
//
void CTaskAddDoc::_TryDeleteMRUItem(IMruDataList *pmru, DWORD cMax, LPCTSTR pszFileName, LPCITEMIDLIST pidlItem, IMruDataList *pmruOther, BOOL fOverwrite)
{
    BYTE buf[MAX_RECMRU_BUF] = {0};

    DWORD cbItem = CbFromCch(lstrlen(pszFileName) + 1);
    int iItem;
    if (!fOverwrite || FAILED(pmru->FindData((BYTE *)pszFileName, cbItem, &iItem)))
    {
        //
        //  if iItem is not -1 then it is already existing item that we will replace.
        //  if it is -1 then we need to point iItem to the last in the list.
        //  torch the last one if we have the max number of items in the list.
        //  default to success, cuz if we dont find it we dont need to delete it
        iItem = cMax - 1;
    }

    //  if we cannot get it in order to delete it, 
    //  then we will not overwrite the item.
    if (SUCCEEDED(pmru->GetData(iItem, buf, sizeof(buf))))
    {
        //  convert the buf into the last segment of the pidl
        LPITEMIDLIST pidlFullLink = ILCombine(_pidlTarget, GETRECPIDL(buf));
        if (pidlFullLink)
        {
            // This is semi-gross, but some link types like calling cards are the
            // actual data.  If we delete and recreate they lose their info for the
            // run.  We will detect this by knowing that their pidl will be the
            // same as the one we are deleting...
            if (!ILIsEqual(pidlFullLink, pidlItem))
            {
                TCHAR sz[MAX_PATH];

                // now remove out link to it
                SHGetPathFromIDList(pidlFullLink, sz);

                Win32DeleteFile(sz);
                TraceMsg(DM_RECENTDOCS, "[%X] CTaskAddDoc::_TryDeleteMRUItem() deleting '%s'", this, sz);   

                if (pmruOther) 
                {
                    //  deleted a shortcut, 
                    //  need to try and remove it from the pmruOther...
                    if (SUCCEEDED(pmruOther->FindData((BYTE *)GETRECNAME(buf), CbFromCch(lstrlen(GETRECNAME(buf)) +1), &iItem)))
                        pmruOther->Delete(iItem);
                }
            }
            ILFree(pidlFullLink);
        }
    }
}

// in:
// pidlItem - full IDList for the item being added
// pszItem  - name (file spec) of the item (used in the display to the user)
// uFlags   - SHCL_ flags

LPBYTE CTaskAddDoc::_CreateMRUItem(LPCITEMIDLIST pidlItem, LPCTSTR pszItem, 
                                   DWORD *pcbOut, UINT uFlags)
{
    TCHAR sz[MAX_PATH];
    LPBYTE pitem = NULL;

    // create the new one
    if (SHGetPathFromIDList(_pidlTarget, sz)) 
    {
        LPITEMIDLIST pidlFullLink;

        if (SUCCEEDED(CreateLinkToPidl(pidlItem, sz, &pidlFullLink, uFlags)) &&
            pidlFullLink)
        {
            LPCITEMIDLIST pidlLinkLast = ILFindLastID(pidlFullLink);
            int cbLinkLast = ILGetSize(pidlLinkLast);
            DWORD cbItem = CbFromCch(lstrlen(pszItem) + 1);

            pitem = (LPBYTE) LocalAlloc(NONZEROLPTR, cbItem + cbLinkLast);
            if (pitem)
            {
                memcpy( pitem, pszItem, cbItem );
                memcpy( pitem + cbItem, pidlLinkLast, cbLinkLast);
                *pcbOut = cbItem + cbLinkLast;
            }
            ILFree(pidlFullLink);
        }
    }
    
    return pitem;
}

HRESULT RecentDocs_Enum(IMruDataList *pmru, int iItem, LPITEMIDLIST *ppidl)
{
    BYTE buf[MAX_RECMRU_BUF] = {0};
    *ppidl = NULL;
        
    if (SUCCEEDED(pmru->GetData(iItem, buf, sizeof(buf))))
    {
        *ppidl = ILClone(GETRECPIDL(buf));
    }

    return *ppidl ? S_OK : E_FAIL;
}
BOOL CTaskAddDoc::_AddDocToRecentAndExtRecent(LPCITEMIDLIST pidlItem, LPCTSTR pszFileName, 
                                              LPCTSTR pszExt)
{
    DWORD cbItem = CbFromCch(lstrlen(pszFileName) + 1);
    DWORD cMax;
    IMruDataList *pmru = CreateSharedRecentMRUList(pszExt, &cMax, SRMLF_COMPNAME);

    _TryDeleteMRUItem(_pmruRecent, _cMaxRecent, pszFileName, pidlItem, pmru, TRUE);

    LPBYTE pitem = _CreateMRUItem(pidlItem, pszFileName, &cbItem, 0);
    if (pitem)
    {
        _pmruRecent->AddData(pitem, cbItem, NULL);

        if (pmru)
        {
            //  we dont want to delete the file if it already existed, because
            //  the TryDelete on the RecentMRU would have already done that
            //  we only want to delete if we have some overflow from the ExtMRU
            _TryDeleteMRUItem(pmru, cMax, pszFileName, pidlItem, _pmruRecent, FALSE);

            //  can reuse the already created item to this mru
            pmru->AddData(pitem, cbItem, NULL);

            pmru->Release();
        }
                
        LocalFree(pitem);
    }

    //  its been freed but not nulled out...
    return (pitem != NULL);
}


// 
//  WARNING:  UpdateNetHood() changes _pidlTarget to the NetHood then frees it!
//
void CTaskAddDoc::_UpdateNetHood(LPCITEMIDLIST pidlFolder, LPCTSTR pszShare)
{
    if (SHRestricted(REST_NORECENTDOCSNETHOOD))
        return;

    //  need to add this boy to the Network Places
    LPITEMIDLIST pidl = ILCreateFromPath(pszShare);
    if (pidl)
    {
        //
        //  NOTE - must verify parentage here - ZekeL - 27-MAY-99
        //  http servers exist in both the webfolders namespace 
        //  and the Internet namespace.  thus we must make sure
        //  that what ever parent the folder had, the share has
        //  the same one.
        //
        if (ILIsParent(pidl, pidlFolder, FALSE))
        {
            ASSERT(_pidlTarget);
            ILFree(_pidlTarget);
            
            _pidlTarget = SHCloneSpecialIDList(NULL, CSIDL_NETHOOD, TRUE);
            if (_pidlTarget)
            {
                DWORD cMax;
                IMruDataList *pmru = CreateSharedRecentMRUList(TEXT("NetHood"), &cMax, SRMLF_COMPNAME);
                if (pmru)
                {
                    _TryDeleteMRUItem(pmru, cMax, pszShare, pidl, NULL, TRUE);
                    DWORD cbItem = CbFromCch(lstrlen(pszShare) + 1);
                    // SHCL_NOUNIQUE - if there is already a shortcut with the same name,
                    // just overwrite it; this avoids pointless duplicates in nethood
                    LPBYTE pitem = _CreateMRUItem(pidl, pszShare, &cbItem, SHCL_MAKEFOLDERSHORTCUT | SHCL_NOUNIQUE);
                    if (pitem)
                    {
                        pmru->AddData(pitem, cbItem, NULL);
                        LocalFree(pitem);
                    }

                    pmru->Release();
                }

                ILFree(_pidlTarget);
                _pidlTarget = NULL;
            }
        }
        
        ILFree(pidl);
    }
}
            
BOOL _IsPlacesFolder(LPCTSTR pszFolder)
{
    static const UINT places[] = {
        CSIDL_PERSONAL,
        CSIDL_DESKTOPDIRECTORY,
        CSIDL_COMMON_DESKTOPDIRECTORY,
        CSIDL_NETHOOD,
        CSIDL_FAVORITES,
    };
    return PathIsOneOf(pszFolder, places, ARRAYSIZE(places));
}

void _AddToUrlHistory(LPCTSTR pszPath)
{
    ASSERT(pszPath);
    WCHAR szUrl[MAX_URL_STRING];
    DWORD cchUrl = ARRAYSIZE(szUrl);

    //  the URL parsing APIs tolerate same in/out buffer
    if (SUCCEEDED(UrlCreateFromPathW(pszPath, szUrl, &cchUrl, 0)))
    {
        IUrlHistoryStg *puhs;
        if (SUCCEEDED(CoCreateInstance(CLSID_CUrlHistory, NULL, CLSCTX_INPROC_SERVER, 
                IID_PPV_ARG(IUrlHistoryStg, &puhs))))
        {
            ASSERT(puhs);
            puhs->AddUrl(szUrl, NULL, 0);
            puhs->Release();
        }
    }
}

void CTaskAddDoc::_TryUpdateNetHood(LPCITEMIDLIST pidlFolder, LPCTSTR pszFolder)
{
    TCHAR sz[MAX_URL_STRING];
    DWORD cch = SIZECHARS(sz);
    BOOL fUpdate = FALSE;
    // changing szFolder, and changing _pidlTarget here...
    //  if this is an URL or a UNC share add it to the nethood

    if (UrlIs(pszFolder, URLIS_URL) 
    && !UrlIs(pszFolder, URLIS_OPAQUE)
    && SUCCEEDED(UrlCombine(pszFolder, TEXT("/"), sz, &cch, 0)))
        fUpdate = TRUE;
    else if (PathIsUNC(pszFolder) 
    && StrCpyN(sz, pszFolder, cch)
    && PathStripToRoot(sz))
        fUpdate = TRUE;

    if (fUpdate)
        _UpdateNetHood(pidlFolder, sz);
}

//-----------------------------------------------------------------
//
// Add the named file to the Recently opened MRU list, that is used
// by the shell to display the recent menu of the tray.

// this registry will hold two pidls:  the target pointing to followed by
// the pidl of the link created pointing it.  In both cases,
// only the last item id is stored. (we may want to change this... but
// then again, we may not)

void CTaskAddDoc::_AddToRecentDocs(LPCITEMIDLIST pidlItem, LPCTSTR pszItem)
{
    TCHAR szUnescaped[MAX_PATH];
    LPTSTR pszFileName;

    //  if these are NULL the caller meant to call _CleanRecentDocs()
    ASSERT(pszItem && *pszItem);

    TraceMsg(DM_RECENTDOCS, "[%X] CTaskAddDoc::_AddToRecentDocs() called for '%s'", this, pszItem);   
    // allow only classes with default commands
    //
    //  dont add if:
    //     it is RESTRICTED
    //     it is in the temporary directory
    //     it actually has a file name
    //     it can be shell exec'd with "open" verb
    //
    if ( (SHRestricted(REST_NORECENTDOCSHISTORY))     ||
         (PathIsTemporary(pszItem))                   ||
         (!(pszFileName = PathFindFileName(pszItem))) ||
         (!*pszFileName)                              ||
         (!GetExtensionClassDescription(pszFileName))   
       )  
        return;

    //  pretty up the URL file names.
    if (UrlIs(pszItem, URLIS_URL))
    {
        StrCpyN(szUnescaped, pszFileName, SIZECHARS(szUnescaped));
        UrlUnescapeInPlace(szUnescaped, 0);
        pszFileName = szUnescaped;
    }
    
    //  otherwise we try our best.
    ASSERT(!_pidlTarget);
    _pidlTarget = SHCloneSpecialIDList(NULL, CSIDL_RECENT, TRUE);
    if (_pidlTarget) 
    {
        _pmruRecent = CreateSharedRecentMRUList(NULL, &_cMaxRecent, SRMLF_COMPNAME);
        if (_pmruRecent)
        {
            if (_AddDocToRecentAndExtRecent(pidlItem, pszFileName, PathFindExtension(pszFileName)))
            {
                _AddToUrlHistory(pszItem);
                //  get the folder and do it to the folder
                LPITEMIDLIST pidlFolder = ILClone(pidlItem);
                
                if (pidlFolder)
                {
                    ILRemoveLastID(pidlFolder);
                    //  if it is a folder we already have quick
                    //  access to from the shell, dont put it in here

                    TCHAR szFolder[MAX_URL_STRING];
                    if (SUCCEEDED(SHGetNameAndFlags(pidlFolder, SHGDN_FORPARSING, szFolder, SIZECHARS(szFolder), NULL))
                    && !_IsPlacesFolder(szFolder))
                    {
                        //  get the friendly name for the folder
                        TCHAR szTitle[MAX_PATH];
                        if (FAILED(SHGetNameAndFlags(pidlFolder, SHGDN_NORMAL, szTitle, SIZECHARS(szTitle), NULL)))
                            StrCpyN(szTitle, PathFindFileName(szFolder), ARRAYSIZE(szTitle));
                            
                        _AddDocToRecentAndExtRecent(pidlFolder, szTitle, TEXT("Folder"));

                        _TryUpdateNetHood(pidlFolder, szFolder);
                    }
                    
                    ILFree(pidlFolder);
                }
            }
            
            _pmruRecent->Release();
            _pmruRecent = NULL;
        }

        //cleanup
        if (_pidlTarget)
        {
            ILFree(_pidlTarget);
            _pidlTarget = NULL;
        }
    }
    
    SHChangeNotifyHandleEvents();
}

// This cache helps winstone!
// The 1 minute timeout is incase another process cleared recent docs, or filled it
// to capacity & scrolled out our cached item.

#define FT_ONEMINUTE (10000000*60)

BOOL CheckIfFileIsCached(LPCTSTR pszItem)
{
    BOOL bRet = FALSE;

    ENTERCRITICAL;
    if (StrCmp(pszItem, g_szLastFile) == 0)
    {
        FILETIME ftNow;
        GetSystemTimeAsFileTime(&ftNow);

        // Pull one minute off the current time, then compare to cache time
        DecrementFILETIME(&ftNow, FT_ONEMINUTE);

        // if the cache'd time is greater than 1 minute ago, use cache
        if (CompareFileTime(&g_ftLastFileCacheUpdate, &ftNow) >= 0)
            bRet = TRUE;
    }
    LEAVECRITICAL;
    return bRet;
}


void AddToRecentDocs(LPCITEMIDLIST pidl, LPCTSTR pszItem)
{
    HWND hwnd = GetShellWindow();
    // Check to see if we just added the same file to recent docs.
    //  or this is an executeable
    //  or something else that shouldnt be added
    if (!CheckIfFileIsCached(pszItem)
    && (!PathIsExe(pszItem))
    && (ShouldAddToRecentDocs(pidl))
    && (hwnd))
    {
        DWORD cbSizePidl = ILGetSize(pidl);
        DWORD cbSizePath = CbFromCch(lstrlen(pszItem) + 1);
        XMITARD *px;
        DWORD dwProcId, dwOffset;
        HANDLE hARD;
        TCHAR szApp[MAX_PATH];  // name of the app which is calling us
        DWORD cbSizeApp;
        DWORD cbSizePidlRound, cbSizePathRound, cbSizeAppRound;

        GetWindowThreadProcessId(hwnd, &dwProcId);
        if (GetModuleFileName(NULL, szApp, ARRAYSIZE(szApp)) && szApp[0])
            cbSizeApp = CbFromCch(1 + lstrlen(szApp));
        else
            cbSizeApp = 0;

        cbSizePidlRound = ROUNDUP(cbSizePidl,4);
        cbSizePathRound = ROUNDUP(cbSizePath,4);
        cbSizeAppRound  = ROUNDUP(cbSizeApp,4);

        hARD = SHAllocShared(NULL, sizeof(XMITARD)+cbSizePathRound+cbSizePidlRound+cbSizeAppRound, dwProcId);
        if (!hARD)
            return;         // Well, we are going to miss one, sorry.

        px = (XMITARD *)SHLockShared(hARD,dwProcId);
        if (!px)
        {
            SHFreeShared(hARD,dwProcId);
            return;         // Well, we are going to miss one, sorry.
        }

        px->dwOffsetPidl = 0;
        px->dwOffsetPath = 0;
        px->dwOffsetProcess = 0;

        dwOffset = sizeof(XMITARD);

        {
            px->dwOffsetPath = dwOffset;
            memcpy((LPBYTE)px + dwOffset, pszItem, cbSizePath);
            dwOffset += cbSizePathRound;
        }

        {
            px->dwOffsetPidl = dwOffset;
            memcpy((LPBYTE)px + dwOffset, pidl, cbSizePidl);
            dwOffset += cbSizePidlRound;
        }

        if (cbSizeApp)
        {
            px->dwOffsetProcess = dwOffset;
            memcpy((LPBYTE)px + dwOffset, szApp, cbSizeApp);
        }


        SHUnlockShared(px);

        PostMessage(hwnd, CWM_ADDTORECENT, (WPARAM)hARD, (LPARAM)dwProcId);
        ENTERCRITICAL;
        StrCpyN(g_szLastFile, pszItem, ARRAYSIZE(g_szLastFile));
        GetSystemTimeAsFileTime(&g_ftLastFileCacheUpdate);
        LEAVECRITICAL;
    }
}

#if 0
void DisplayRecentDebugMessage(LPTSTR psz, BOOL bPidl)
{
    TCHAR szTmp[1024];
    TCHAR szFN[MAX_PATH];
    GetModuleFileName(NULL, szFN, ARRAYSIZE(szFN));
    wsprintf(szTmp, TEXT("[%d], process %s: AddToRecentDocs(%s) by %s\n"),
    GetTickCount(), szFN, psz,
    (bPidl)?TEXT("pidl"):TEXT("path"));
    OutputDebugString(szTmp);
}
#else
#define DisplayRecentDebugMessage(x,y)
#endif

HRESULT _ParseRecentDoc(LPCWSTR psz, LPITEMIDLIST *ppidl)
{
    BINDCTX_PARAM rgParams[] = 
    { 
        { STR_PARSE_TRANSLATE_ALIASES, NULL},
        { STR_PARSE_PREFER_FOLDER_BROWSING, NULL},
    };
    
    IBindCtx *pbc;
    HRESULT hr = BindCtx_RegisterObjectParams(NULL, rgParams, ARRAYSIZE(rgParams), &pbc);
    if (SUCCEEDED(hr))
    {
        hr = SHParseDisplayName(psz, pbc, ppidl, 0, 0);
        pbc->Release();
        
        if (FAILED(hr))
        {
            //  we need to fallback to a simple parsing
            IBindCtx *pbcSimple;
            hr = SHCreateFileSysBindCtx(NULL, &pbcSimple);
            if (SUCCEEDED(hr))
            {
                hr = BindCtx_RegisterObjectParams(pbcSimple, rgParams, ARRAYSIZE(rgParams), &pbc);
                if (SUCCEEDED(hr))
                {
                    hr = SHParseDisplayName(psz, pbc, ppidl, 0, 0);
                    pbc->Release();
                }
                pbcSimple->Release();
            }
        }
    }

    return hr;
}

//
// put things in the shells recent docs list for the start menu
//
// in:
//      uFlags  SHARD_ (shell add recent docs) flags
//      pv      LPCSTR or LPCITEMIDLIST (path or pidl indicated by uFlags)
//              may be NULL, meaning clear the recent list
//
STDAPI_(void) SHAddToRecentDocs(UINT uFlags, LPCVOID pv)
{
    TCHAR szTemp[MAX_URL_STRING]; // for double null

    TraceMsg(DM_RECENTDOCS, "SHAddToRecentDocs() called with %d, [%X]", uFlags, pv);
    
    if (pv == NULL)     // we should nuke all recent docs.
    {
        //  we do this synchronously
        _CleanRecentDocs();
        return;
    }

    if (SHRestricted(REST_NORECENTDOCSHISTORY))
        // Don't bother tracking recent documents if restriction is set
        // for privacy.
        return;

    switch (uFlags)
    {
    case SHARD_PIDL:
        // pv is a LPCITEMIDLIST (pidl)
        if (SUCCEEDED(SHGetNameAndFlags((LPCITEMIDLIST)pv, SHGDN_FORPARSING, szTemp, SIZECHARS(szTemp), NULL)))
        {
            DisplayRecentDebugMessage((LPTSTR)pv, TRUE);
            AddToRecentDocs((LPCITEMIDLIST)pv, szTemp);
        }
        break;

    case SHARD_PATHA:
        //  pv is an ANSI path
        SHAnsiToUnicode((LPCSTR)pv, szTemp, ARRAYSIZE(szTemp));
        pv = szTemp;
        //  fall through to SHARD_PATHW;
    
    case SHARD_PATHW:
        {
            // pv is a UNICODE path
            LPITEMIDLIST pidl;
            if (SUCCEEDED(_ParseRecentDoc((LPCWSTR)pv, &pidl)))
            {
                DisplayRecentDebugMessage((LPTSTR)pv, FALSE);
                AddToRecentDocs(pidl, (LPCTSTR)pv);
                ILFree(pidl);
            }
            break;
        }
    default:
        ASSERTMSG(FALSE, "SHAddToRecent() called with invalid params");
        break;
    }
}

STDAPI CTaskAddDoc_Create(HANDLE hMem, DWORD dwProcId, IRunnableTask **pptask)
{
    HRESULT hres;
    CTaskAddDoc *ptad = new CTaskAddDoc();
    if (ptad)
    {
        hres = ptad->Init(hMem, dwProcId);
        if (SUCCEEDED(hres))
            hres = ptad->QueryInterface(IID_PPV_ARG(IRunnableTask, pptask));
        ptad->Release();
    }
    else
        hres = E_OUTOFMEMORY;
    return hres;
}


STDAPI RecentDocs_GetDisplayName(LPCITEMIDLIST pidl, LPTSTR pszName, DWORD cchName)
{
    IMruDataList *pmru;
    HRESULT hr = CreateRecentMRUList(&pmru);

    if (SUCCEEDED(hr))
    {
        int iItem;
        hr = pmru->FindData((BYTE *)pidl, ILGetSize(pidl), &iItem);
        if (SUCCEEDED(hr))
        {
            BYTE buf[MAX_RECMRU_BUF];

            hr = pmru->GetData(iItem, buf, sizeof(buf));
            if (SUCCEEDED(hr))
            {
                StrCpyN(pszName, GETRECNAME(buf), cchName);
            }
        }

        pmru->Release();
     }

     return hr;
 }
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\regenv.c ===
#define UNICODE 1

#include "shellprv.h"
#include <regapi.h>
#pragma  hdrstop

char * __cdecl StrTokEx (char ** pstring, const char * control);

//
// Value names for for different environment variables
//

#define PATH_VARIABLE            TEXT("Path")
#define LIBPATH_VARIABLE         TEXT("LibPath")
#define OS2LIBPATH_VARIABLE      TEXT("Os2LibPath")
#define AUTOEXECPATH_VARIABLE    TEXT("AutoexecPath")

#define HOMEDRIVE_VARIABLE       TEXT("HOMEDRIVE")
#define HOMESHARE_VARIABLE       TEXT("HOMESHARE")
#define HOMEPATH_VARIABLE        TEXT("HOMEPATH")

#define COMPUTERNAME_VARIABLE    TEXT("COMPUTERNAME")
#define USERNAME_VARIABLE        TEXT("USERNAME")
#define USERDOMAIN_VARIABLE      TEXT("USERDOMAIN")
#define USERDNSDOMAIN_VARIABLE   TEXT("USERDNSDOMAIN")
#define USERPROFILE_VARIABLE     TEXT("USERPROFILE")
#define ALLUSERSPROFILE_VARIABLE TEXT("ALLUSERSPROFILE")
#define OS_VARIABLE              TEXT("OS")
#define PROCESSOR_VARIABLE       TEXT("PROCESSOR_ARCHITECTURE")
#define PROCESSOR_LEVEL_VARIABLE TEXT("PROCESSOR_LEVEL")

#define SYSTEMDRIVE_VARIABLE     TEXT("SystemDrive")
#define SYSTEMROOT_VARIABLE      TEXT("SystemRoot")
#define PROGRAMFILES_VARIABLE    TEXT("ProgramFiles")
#define COMMONPROGRAMFILES_VARIABLE     TEXT("CommonProgramFiles")
#if defined(WX86) || defined(_WIN64)
#define PROGRAMFILESX86_VARIABLE        TEXT("ProgramFiles(x86)")
#define COMMONPROGRAMFILESX86_VARIABLE  TEXT("CommonProgramFiles(x86)")
#endif
#define SYSTEM_ENV_SUBKEY        TEXT("SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Environment")
#define USER_ENV_SUBKEY          TEXT("Environment")
#define USER_VOLATILE_ENV_SUBKEY TEXT("Volatile Environment")

//
// Max environment variable length
//

#define MAX_VALUE_LEN          1024

//
// Parsing information for autoexec.bat
//
#define PARSE_AUTOEXEC_KEY     TEXT("Software\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon")
#define PARSE_AUTOEXEC_ENTRY   TEXT("ParseAutoexec")
#define PARSE_AUTOEXEC_DEFAULT TEXT("1")
#define MAX_PARSE_AUTOEXEC_BUFFER 2


#ifdef _X86_
BOOL IsPathIncludeRemovable(LPCTSTR lpValue)
{
    BOOL ret = FALSE;
    LPTSTR pszDup = StrDup(lpValue);
    if (pszDup)
    {
        LPTSTR pszTemp = pszDup;
        while (*pszTemp) 
        {
            // skip spaces
            for ( ; *pszTemp && *pszTemp == TEXT(' '); pszTemp++)
                ;

            // check if the drive is removable
            if (pszTemp[0] && pszTemp[1] && pszTemp[1] == TEXT(':') && pszTemp[2]) {        // ex) "A:\"
                TCHAR c = pszTemp[3];
                pszTemp[3] = 0;
                if (PathIsRemovable(pszTemp)) {
                    pszTemp[3] = c;
                    ret = TRUE;
                    break;
                }
                pszTemp[3] = c;
            }

            // skip to the next path
            for ( ; *pszTemp && *pszTemp != TEXT(';'); pszTemp++)
                ;
            if (*pszTemp)
                pszTemp++;
        }
        LocalFree(pszDup);
    }
    return ret;
}
#endif

/***************************************************************************\
* SetUserEvironmentVariable
*
*
* History:
* 2-28-92  Johannec     Created
*
\***************************************************************************/
BOOL SetUserEnvironmentVariable(void **pEnv, LPTSTR lpVariable, LPTSTR lpValue, BOOL bOverwrite)
{
    NTSTATUS Status;
    UNICODE_STRING Name;
    UNICODE_STRING Value;
    DWORD cb;
    TCHAR szValue[1024];

    if (!*pEnv || !lpVariable || !*lpVariable) {
        return(FALSE);
    }
    RtlInitUnicodeString(&Name, lpVariable);
    cb = 1024;
    Value.Buffer = (PTCHAR)LocalAlloc(LPTR, cb*sizeof(WCHAR));
    if (Value.Buffer) {
        Value.Length = (USHORT)cb;
        Value.MaximumLength = (USHORT)cb;
        Status = RtlQueryEnvironmentVariable_U(*pEnv, &Name, &Value);
        LocalFree(Value.Buffer);
        if (NT_SUCCESS(Status) && !bOverwrite) {
            return(TRUE);
        }
    }
    if (lpValue && *lpValue) {

        //
        // Special case TEMP and TMP and shorten the path names
        //

        if ((!lstrcmpi(lpVariable, TEXT("TEMP"))) ||
            (!lstrcmpi(lpVariable, TEXT("TMP")))) {

             if (!GetShortPathName (lpValue, szValue, 1024)) {
                 lstrcpyn (szValue, lpValue, 1024);
             }
        } else {
            lstrcpyn (szValue, lpValue, 1024);
        }

        RtlInitUnicodeString(&Value, szValue);
        Status = RtlSetEnvironmentVariable(pEnv, &Name, &Value);
    }
    else {
        Status = RtlSetEnvironmentVariable( pEnv, &Name, NULL);
    }
    return NT_SUCCESS(Status);
}


/***************************************************************************\
* ExpandUserEvironmentVariable
*
*
* History:
* 2-28-92  Johannec     Created
*
\***************************************************************************/
DWORD ExpandUserEnvironmentStrings(void *pEnv, LPTSTR lpSrc, LPTSTR lpDst, DWORD nSize)
{
    NTSTATUS Status;
    UNICODE_STRING Source, Destination;
    ULONG Length;
    
    RtlInitUnicodeString( &Source, lpSrc );
    Destination.Buffer = lpDst;
    Destination.Length = 0;
    Destination.MaximumLength = (USHORT)(nSize*SIZEOF(WCHAR));
    Length = 0;
    Status = RtlExpandEnvironmentStrings_U( pEnv,
        (PUNICODE_STRING)&Source,
        (PUNICODE_STRING)&Destination,
        &Length
        );
    if (NT_SUCCESS( Status ) || Status == STATUS_BUFFER_TOO_SMALL) {
        return( Length );
    }
    else {
        return( 0 );
    }
}


/***************************************************************************\
* BuildEnvironmentPath
*
*
* History:
* 2-28-92  Johannec     Created
*
\***************************************************************************/
BOOL BuildEnvironmentPath(void **pEnv, LPTSTR lpPathVariable, LPTSTR lpPathValue)
{
    NTSTATUS Status;
    UNICODE_STRING Name;
    UNICODE_STRING Value;
    WCHAR lpTemp[1025];
    DWORD cb;

    if (!*pEnv) {
        return(FALSE);
    }
    RtlInitUnicodeString(&Name, lpPathVariable);
    cb = 1024;
    Value.Buffer = (PWCHAR)LocalAlloc(LPTR, cb*sizeof(WCHAR));
    if (!Value.Buffer) {
        return(FALSE);
    }
    Value.Length = (USHORT)(sizeof(WCHAR) * cb);
    Value.MaximumLength = (USHORT)(sizeof(WCHAR) * cb);
    Status = RtlQueryEnvironmentVariable_U(*pEnv, &Name, &Value);
    if (!NT_SUCCESS(Status)) {
        LocalFree(Value.Buffer);
        Value.Length = 0;
        *lpTemp = 0;
    }
    if (Value.Length) {
        lstrcpy(lpTemp, Value.Buffer);
        if ( *( lpTemp + lstrlen(lpTemp) - 1) != TEXT(';') ) {
            lstrcat(lpTemp, TEXT(";"));
        }
        LocalFree(Value.Buffer);
    }
    if (lpPathValue && ((lstrlen(lpTemp) + lstrlen(lpPathValue) + 1) < (INT)cb)) {
        lstrcat(lpTemp, lpPathValue);

        RtlInitUnicodeString(&Value, lpTemp);

        Status = RtlSetEnvironmentVariable(pEnv, &Name, &Value);
    }
    if (NT_SUCCESS(Status)) {
        return(TRUE);
    }
    return(FALSE);
}


/***************************************************************************\
* SetEnvironmentVariables
*
* Reads the user-defined environment variables from the user registry
* and adds them to the environment block at pEnv.
*
* History:
* 2-28-92  Johannec     Created
*
\***************************************************************************/
BOOL SetEnvironmentVariables(void **pEnv, LPTSTR lpRegSubKey)
{
    WCHAR lpValueName[MAX_PATH];
    LPBYTE  lpDataBuffer;
    DWORD cbDataBuffer;
    LPBYTE  lpData;
    LPTSTR lpExpandedValue = NULL;
    DWORD cbValueName = MAX_PATH;
    DWORD cbData;
    DWORD dwType;
    DWORD dwIndex = 0;
    HKEY hkey;
    BOOL bResult;

    if (RegOpenKeyExW(HKEY_CURRENT_USER, lpRegSubKey, 0, KEY_READ, &hkey)) {
        return(FALSE);
    }

    cbDataBuffer = 4096;
    lpDataBuffer = (LPBYTE)LocalAlloc(LPTR, cbDataBuffer*sizeof(WCHAR));
    if (lpDataBuffer == NULL) {
        RegCloseKey(hkey);
        return(FALSE);
    }
    lpData = lpDataBuffer;
    cbData = cbDataBuffer;
    bResult = TRUE;
    while (!RegEnumValue(hkey, dwIndex, lpValueName, &cbValueName, 0, &dwType,
                         lpData, &cbData)) {
        if (cbValueName) {

            //
            // Limit environment variable length
            //

            lpData[MAX_VALUE_LEN-1] = TEXT('\0');


            if (dwType == REG_SZ) {
                //
                // The path variables PATH, LIBPATH and OS2LIBPATH must have
                // their values apppended to the system path.
                //

                if ( !lstrcmpi(lpValueName, PATH_VARIABLE) ||
                     !lstrcmpi(lpValueName, LIBPATH_VARIABLE) ||
                     !lstrcmpi(lpValueName, OS2LIBPATH_VARIABLE) ) {

                    BuildEnvironmentPath(pEnv, lpValueName, (LPTSTR)lpData);
                }
                else {

                    //
                    // the other environment variables are just set.
                    //

                    SetUserEnvironmentVariable(pEnv, lpValueName, (LPTSTR)lpData, TRUE);
                }
            }
        }
        dwIndex++;
        cbData = cbDataBuffer;
        cbValueName = MAX_PATH;
    }

    dwIndex = 0;
    cbData = cbDataBuffer;
    cbValueName = MAX_PATH;


    while (!RegEnumValue(hkey, dwIndex, lpValueName, &cbValueName, 0, &dwType,
                         lpData, &cbData)) {
        if (cbValueName) {

            //
            // Limit environment variable length
            //

            lpData[MAX_VALUE_LEN-1] = TEXT('\0');


            if (dwType == REG_EXPAND_SZ) {
                DWORD cb, cbNeeded;

                cb = 1024;
                lpExpandedValue = (LPTSTR)LocalAlloc(LPTR, cb*sizeof(WCHAR));
                if (lpExpandedValue) {
                    cbNeeded = ExpandUserEnvironmentStrings(*pEnv, (LPTSTR)lpData, lpExpandedValue, cb);
                    if (cbNeeded > cb) {
                        LocalFree(lpExpandedValue);
                        cb = cbNeeded;
                        lpExpandedValue = (LPTSTR)LocalAlloc(LPTR, cb*sizeof(WCHAR));
                        if (lpExpandedValue) {
                            ExpandUserEnvironmentStrings(*pEnv, (LPTSTR)lpData, lpExpandedValue, cb);
                        }
                    }
                }

                if (lpExpandedValue == NULL) {
                    bResult = FALSE;
                    break;
                }


                //
                // The path variables PATH, LIBPATH and OS2LIBPATH must have
                // their values apppended to the system path.
                //

                if ( !lstrcmpi(lpValueName, PATH_VARIABLE) ||
                     !lstrcmpi(lpValueName, LIBPATH_VARIABLE) ||
                     !lstrcmpi(lpValueName, OS2LIBPATH_VARIABLE) ) {

                    BuildEnvironmentPath(pEnv, lpValueName, (LPTSTR)lpExpandedValue);
                }
                else {

                    //
                    // the other environment variables are just set.
                    //

                    SetUserEnvironmentVariable(pEnv, lpValueName, (LPTSTR)lpExpandedValue, TRUE);
                }

                LocalFree(lpExpandedValue);

            }

        }
        dwIndex++;
        cbData = cbDataBuffer;
        cbValueName = MAX_PATH;
    }



    LocalFree(lpDataBuffer);
    RegCloseKey(hkey);

    return(bResult);
}

/***************************************************************************\
* SetSystemEnvironmentVariables
*
* Reads the system environment variables from the LOCAL_MACHINE registry
* and adds them to the environment block at pEnv.
*
* History:
* 2-28-92  Johannec     Created
*
\***************************************************************************/
BOOL SetSystemEnvironmentVariables(void **pEnv)
{
    WCHAR lpValueName[MAX_PATH];
    LPBYTE  lpDataBuffer;
    DWORD cbDataBuffer;
    LPBYTE  lpData;
    LPTSTR lpExpandedValue = NULL;
    DWORD cbValueName = MAX_PATH;
    DWORD cbData;
    DWORD dwType;
    DWORD dwIndex = 0;
    HKEY hkey;
    BOOL bResult;

    if (RegOpenKeyExW(HKEY_LOCAL_MACHINE, SYSTEM_ENV_SUBKEY, 0, KEY_READ, &hkey)) {
        return(FALSE);
    }

    cbDataBuffer = 4096;
    lpDataBuffer = (LPBYTE)LocalAlloc(LPTR, cbDataBuffer*sizeof(WCHAR));
    if (lpDataBuffer == NULL) {
        KdPrint(("REGENENV: SetSystemEnvironmentVariables: Failed to allocate %d bytes\n", cbDataBuffer));
        RegCloseKey(hkey);
        return(FALSE);
    }

    //
    // First start by getting the systemroot and systemdrive values and
    // setting it in the new environment.
    //
    GetEnvironmentVariable(SYSTEMROOT_VARIABLE, (LPTSTR)lpDataBuffer, cbDataBuffer);
    SetUserEnvironmentVariable(pEnv, SYSTEMROOT_VARIABLE, (LPTSTR)lpDataBuffer, TRUE);

    GetEnvironmentVariable(SYSTEMDRIVE_VARIABLE, (LPTSTR)lpDataBuffer, cbDataBuffer);
    SetUserEnvironmentVariable(pEnv, SYSTEMDRIVE_VARIABLE, (LPTSTR)lpDataBuffer, TRUE);

    GetEnvironmentVariable(ALLUSERSPROFILE_VARIABLE, (LPTSTR)lpDataBuffer, cbDataBuffer);
    SetUserEnvironmentVariable(pEnv, ALLUSERSPROFILE_VARIABLE, (LPTSTR)lpDataBuffer, TRUE);

    lpData = lpDataBuffer;
    cbData = cbDataBuffer;
    bResult = TRUE;

    //
    // To generate the environment, this requires two passes.  First pass
    // sets all the variables which do not need to be expanded.  The
    // second pass expands variables (so it can use the variables from
    // the first pass.
    //

    while (!RegEnumValue(hkey, dwIndex, lpValueName, &cbValueName, 0, &dwType,
                         lpData, &cbData)) {
        if (cbValueName) {

            //
            // Limit environment variable length
            //

            lpData[MAX_VALUE_LEN-1] = TEXT('\0');

            if (dwType == REG_SZ) {
                SetUserEnvironmentVariable(pEnv, lpValueName, (LPTSTR)lpData, TRUE);
            }
        }
        dwIndex++;
        cbData = cbDataBuffer;
        cbValueName = MAX_PATH;
    }

    dwIndex = 0;
    cbData = cbDataBuffer;
    cbValueName = MAX_PATH;


    while (!RegEnumValue(hkey, dwIndex, lpValueName, &cbValueName, 0, &dwType,
                         lpData, &cbData)) {
        if (cbValueName) {

            //
            // Limit environment variable length
            //

            lpData[MAX_VALUE_LEN-1] = TEXT('\0');


            if (dwType == REG_EXPAND_SZ) {
                DWORD cb, cbNeeded;

                cb = 1024;
                lpExpandedValue = (LPTSTR)LocalAlloc(LPTR, cb*sizeof(WCHAR));
                if (lpExpandedValue) {
                    cbNeeded = ExpandUserEnvironmentStrings(*pEnv, (LPTSTR)lpData, lpExpandedValue, cb);
                    if (cbNeeded > cb) {
                        LocalFree(lpExpandedValue);
                        cb = cbNeeded;
                        lpExpandedValue = (LPTSTR)LocalAlloc(LPTR, cb);
                        if (lpExpandedValue) {
                            ExpandUserEnvironmentStrings(*pEnv, (LPTSTR)lpData, lpExpandedValue, cb);
                        }
                    }
                }

                if (lpExpandedValue == NULL) {
                    bResult = FALSE;
                    break;
                }

                SetUserEnvironmentVariable(pEnv, lpValueName, (LPTSTR)lpExpandedValue, TRUE);

                LocalFree(lpExpandedValue);

            }
        }
        dwIndex++;
        cbData = cbDataBuffer;
        cbValueName = MAX_PATH;
    }


    LocalFree(lpDataBuffer);
    RegCloseKey(hkey);

    return(bResult);
}

/***************************************************************************\
* ProcessAutoexecPath
*
* Creates AutoexecPath environment variable using autoexec.bat
* LpValue may be freed by this routine.
*
* History:
* 06-02-92  Johannec     Created.
*
\***************************************************************************/
LPTSTR ProcessAutoexecPath(void *pEnv, LPTSTR lpValue, DWORD cb)
{
    LPTSTR lpt;
    LPTSTR lpStart;
    LPTSTR lpPath;
    DWORD cbt;
    UNICODE_STRING Name;
    UNICODE_STRING Value;
    BOOL bPrevAutoexecPath;
    WCHAR ch;
    DWORD dwTemp, dwCount = 0;

    cbt = 1024;
    lpt = (LPTSTR)LocalAlloc(LPTR, cbt*sizeof(WCHAR));
    if (!lpt) {
        return(lpValue);
    }
    *lpt = 0;
    lpStart = lpValue;

    RtlInitUnicodeString(&Name, AUTOEXECPATH_VARIABLE);
    Value.Buffer = (PWCHAR)LocalAlloc(LPTR, cbt*sizeof(WCHAR));
    if (!Value.Buffer) {
        goto Fail;
    }

    while (NULL != (lpPath = wcsstr (lpValue, TEXT("%")))) {
        if (!_wcsnicmp(lpPath+1, TEXT("PATH%"), 5)) {
            //
            // check if we have an autoexecpath already set, if not just remove
            // the %path%
            //
            Value.Length = (USHORT)cbt;
            Value.MaximumLength = (USHORT)cbt;
            bPrevAutoexecPath = (BOOL)!RtlQueryEnvironmentVariable_U(pEnv, &Name, &Value);

            *lpPath = 0;
            dwTemp = dwCount + lstrlen (lpValue);
            if (dwTemp < cbt) {
               lstrcat(lpt, lpValue);
               dwCount = dwTemp;
            }
            if (bPrevAutoexecPath) {
                dwTemp = dwCount + lstrlen (Value.Buffer);
                if (dwTemp < cbt) {
                    lstrcat(lpt, Value.Buffer);
                    dwCount = dwTemp;
                }
            }

            *lpPath++ = TEXT('%');
            lpPath += 5;  // go passed %path%
            lpValue = lpPath;
        }
        else {
            lpPath = wcsstr(lpPath+1, TEXT("%"));
            if (!lpPath) {
                lpStart = NULL;
                goto Fail;
            }
            lpPath++;
            ch = *lpPath;
            *lpPath = 0;
            dwTemp = dwCount + lstrlen (lpValue);
            if (dwTemp < cbt) {
                lstrcat(lpt, lpValue);
                dwCount = dwTemp;
            }
            *lpPath = ch;
            lpValue = lpPath;
        }
    }

    if (*lpValue) {
       dwTemp = dwCount + lstrlen (lpValue);
       if (dwTemp < cbt) {
           lstrcat(lpt, lpValue);
           dwCount = dwTemp;
       }
    }

    LocalFree(Value.Buffer);
    LocalFree(lpStart);

    return(lpt);
Fail:
    LocalFree(lpt);
    return(lpStart);
}

/***************************************************************************\
* ProcessCommand
*
* History:
* 01-24-92  Johannec     Created.
*
\***************************************************************************/
BOOL ProcessCommand(LPSTR lpStart, void **pEnv)
{
    LPTSTR lpt, lptt;
    LPTSTR lpVariable;
    LPTSTR lpValue;
    LPTSTR lpExpandedValue = NULL;
    WCHAR c;
    DWORD cb, cbNeeded;
    LPTSTR lpu;
    
    //
    // convert to Unicode
    //
    lpu = (LPTSTR)LocalAlloc(LPTR, (cb=lstrlenA(lpStart)+1)*sizeof(WCHAR));
    
    if (!lpu) {
        return FALSE;
    }
    
    MultiByteToWideChar(CP_OEMCP, 0, lpStart, -1, lpu, cb);
    
    //
    // Find environment variable.
    //
    for (lpt = lpu; *lpt && *lpt == TEXT(' '); lpt++) //skip spaces
        ;
    
    if (!*lpt) {
        LocalFree (lpu);
        return(FALSE);
    }
    
    lptt = lpt;
    for (; *lpt && *lpt != TEXT(' ') && *lpt != TEXT('='); lpt++) //find end of variable name
        ;
    
    c = *lpt;
    *lpt = 0;
    lpVariable = (LPTSTR)LocalAlloc(LPTR, (lstrlen(lptt) + 1)*sizeof(WCHAR));
    if (!lpVariable) {
        LocalFree (lpu);
        return(FALSE);
    }
    lstrcpy(lpVariable, lptt);
    *lpt = c;
    
    //
    // Find environment variable value.
    //
    for (; *lpt && (*lpt == TEXT(' ') || *lpt == TEXT('=')); lpt++)
        ;
    
    if (!*lpt) {
        // if we have a blank path statement in the autoexec file,
        // then we don't want to pass "PATH" as the environment
        // variable because it trashes the system's PATH.  Instead
        // we want to change the variable AutoexecPath.  This would have
        // be handled below if a value had been assigned to the
        // environment variable.
        if (lstrcmpi(lpVariable, PATH_VARIABLE) == 0)
        {
            SetUserEnvironmentVariable(pEnv, AUTOEXECPATH_VARIABLE, TEXT(""), TRUE);
        }
        else
        {
            SetUserEnvironmentVariable(pEnv, lpVariable, TEXT(""), TRUE);
        }
        LocalFree (lpu);
        LocalFree (lpVariable);
        return(FALSE);
    }
    
    lptt = lpt;
    for (; *lpt; lpt++)  //find end of varaible value
        ;
    
    c = *lpt;
    *lpt = 0;
    lpValue = (LPTSTR)LocalAlloc(LPTR, (lstrlen(lptt) + 1)*sizeof(WCHAR));
    if (!lpValue) {
        LocalFree (lpu);
        LocalFree(lpVariable);
        return(FALSE);
    }
    
    lstrcpy(lpValue, lptt);
    *lpt = c;
    
#ifdef _X86_
    // NEC98
    //
    // If the path includes removable drive,
    //  it is assumed that the drive assignment has changed from DOS.
    //
    if (IsNEC_98 && (lstrcmpi(lpVariable, PATH_VARIABLE) == 0) && IsPathIncludeRemovable(lpValue)) {
        LocalFree(lpVariable);
        LocalFree(lpValue);
        return(FALSE);
    }
#endif

    cb = 1024;
    lpExpandedValue = (LPTSTR)LocalAlloc(LPTR, cb*sizeof(WCHAR));
    if (lpExpandedValue) {
        if (!lstrcmpi(lpVariable, PATH_VARIABLE)) {
            lpValue = ProcessAutoexecPath(*pEnv, lpValue, (lstrlen(lpValue)+1)*sizeof(WCHAR));
        }
        cbNeeded = ExpandUserEnvironmentStrings(*pEnv, lpValue, lpExpandedValue, cb);
        if (cbNeeded > cb) {
            LocalFree(lpExpandedValue);
            cb = cbNeeded;
            lpExpandedValue = (LPTSTR)LocalAlloc(LPTR, cb*sizeof(WCHAR));
            if (lpExpandedValue) {
                ExpandUserEnvironmentStrings(*pEnv, lpValue, lpExpandedValue, cb);
            }
        }
    }
    
    if (!lpExpandedValue) {
        lpExpandedValue = lpValue;
    }
    if (lstrcmpi(lpVariable, PATH_VARIABLE)) {
        SetUserEnvironmentVariable(pEnv, lpVariable, lpExpandedValue, FALSE);
    }
    else {
        SetUserEnvironmentVariable(pEnv, AUTOEXECPATH_VARIABLE, lpExpandedValue, TRUE);
        
    }
    
    if (lpExpandedValue != lpValue) {
        LocalFree(lpExpandedValue);
    }
    LocalFree(lpVariable);
    LocalFree(lpValue);
    
    return(TRUE);
}

/***************************************************************************\
* ProcessSetCommand
*
* History:
* 01-24-92  Johannec     Created.
*
\***************************************************************************/
BOOL ProcessSetCommand(LPSTR lpStart, void **pEnv)
{
    LPSTR lpt;

    //
    // Find environment variable.
    //
    for (lpt = lpStart; *lpt && *lpt != TEXT(' '); lpt++)
        ;

    if (!*lpt)
       return(FALSE);

    return (ProcessCommand(lpt, pEnv));

}

/***************************************************************************\
* ProcessAutoexec
*
* History:
* 01-24-92  Johannec     Created.
*
\***************************************************************************/
BOOL ProcessAutoexec(void **pEnv, LPTSTR lpPathVariable)
{
    HANDLE fh;
    DWORD dwFileSize;
    DWORD dwBytesRead;
    CHAR *lpBuffer = NULL;
    CHAR *token;
    CHAR Seps[] = "&\n\r";   // Seperators for tokenizing autoexec.bat
    BOOL Status = FALSE;
    TCHAR szAutoExecBat [] = TEXT("c:\\autoexec.bat");
#ifdef _X86_
    TCHAR szTemp[3];
#endif
    UINT uiErrMode;
	CHAR *lpszStrTokBegin = NULL;


    // There is a case where the OS might not be booting from drive
    // C, so we can not assume that the autoexec.bat file is on c:\.
    // Set the error mode so the user doesn't see the critical error
    // popup and attempt to open the file on c:\.

    uiErrMode = SetErrorMode (SEM_FAILCRITICALERRORS | SEM_NOOPENFILEERRORBOX);

#ifdef _X86_
    if (IsNEC_98) {
        if (GetEnvironmentVariable (TEXT("SystemDrive"), szTemp, 3)) {
	    szAutoExecBat[0] = szTemp[0];
	}
    }
#endif

    fh = CreateFile (szAutoExecBat, GENERIC_READ, FILE_SHARE_READ,
                     NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);

    SetErrorMode (uiErrMode);

    if (fh ==  INVALID_HANDLE_VALUE) {
        return(FALSE);  //could not open autoexec.bat file, we're done.
    }
    dwFileSize = GetFileSize(fh, NULL);
    if (dwFileSize == -1) {
        goto Exit;      // can't read the file size
    }

    lpBuffer = (PCHAR)LocalAlloc(LPTR, dwFileSize+1);
    if (!lpBuffer) {
        goto Exit;
    }

    Status = ReadFile(fh, lpBuffer, dwFileSize, &dwBytesRead, NULL);
    if (!Status) {
        goto Exit;      // error reading file
    }

    //
    // Zero terminate the buffer so we don't walk off the end
    //

    ASSERT(dwBytesRead <= dwFileSize);
    lpBuffer[dwBytesRead] = 0;

    //
    // Search for SET and PATH commands
    //

	// save off lpBuffer 
	lpszStrTokBegin = lpBuffer;
	
    token = StrTokEx(&lpBuffer, Seps);
    while (token != NULL) {
        for (;*token && *token == ' ';token++) //skip spaces
            ;
        if (*token == TEXT('@'))
            token++;
        for (;*token && *token == ' ';token++) //skip spaces
            ;
        if (!_strnicmp(token, "Path", 4)) {
            ProcessCommand(token, pEnv);
        }
        if (!_strnicmp(token, "SET", 3)) {
            ProcessSetCommand(token, pEnv);
        }
        token = StrTokEx(&lpBuffer, Seps);
    }
	lpBuffer=lpszStrTokBegin;
	
Exit:
    CloseHandle(fh);
    if (lpBuffer) {
        LocalFree(lpBuffer);
    }
    return(Status);
}


/***************************************************************************\
* AppendNTPathWithAutoexecPath
*
* Gets the AutoexecPath created in ProcessAutoexec, and appends it to
* the NT path.
*
* History:
* 05-28-92  Johannec     Created.
*
\***************************************************************************/
BOOL
AppendNTPathWithAutoexecPath(
    void **pEnv,
    LPTSTR lpPathVariable,
    LPTSTR lpAutoexecPath
    )
{
    NTSTATUS Status;
    UNICODE_STRING Name;
    UNICODE_STRING Value;
    WCHAR AutoexecPathValue[1024];
    DWORD cb;
    BOOL Success;

    if (!*pEnv) {
        return(FALSE);
    }

    RtlInitUnicodeString(&Name, lpAutoexecPath);
    cb = 1024;
    Value.Buffer = (PWCHAR)LocalAlloc(LPTR, cb*sizeof(WCHAR));
    if (!Value.Buffer) {
        return(FALSE);
    }

    Value.Length = (USHORT)cb;
    Value.MaximumLength = (USHORT)cb;
    Status = RtlQueryEnvironmentVariable_U(*pEnv, &Name, &Value);
    if (!NT_SUCCESS(Status)) {
        LocalFree(Value.Buffer);
        return(FALSE);
    }

    if (Value.Length) {
        lstrcpy(AutoexecPathValue, Value.Buffer);
    }

    LocalFree(Value.Buffer);

    Success = BuildEnvironmentPath(pEnv, lpPathVariable, AutoexecPathValue);
    RtlSetEnvironmentVariable( pEnv, &Name, NULL);

    return(Success);
}

STDAPI_(BOOL) GetUserNameAndDomain(LPTSTR *ppszUserName, LPTSTR *ppszUserDomain)
{
    BOOL bRet = FALSE;
    HANDLE hToken;
    
    if (OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken))
    {
        DWORD cbTokenBuffer = 0;
        if (GetTokenInformation(hToken, TokenUser, NULL, 0, &cbTokenBuffer) ||
            GetLastError() == ERROR_INSUFFICIENT_BUFFER)
        {
            PTOKEN_USER pUserToken = (PTOKEN_USER)LocalAlloc(LPTR, cbTokenBuffer * sizeof(WCHAR));
            if (pUserToken) 
            {
                if (GetTokenInformation(hToken, TokenUser, pUserToken, cbTokenBuffer, &cbTokenBuffer)) 
                {
                    DWORD cbAccountName = 0, cbUserDomain = 0;
                    SID_NAME_USE SidNameUse;

                    if (LookupAccountSid(NULL, pUserToken->User.Sid, NULL, &cbAccountName, NULL, &cbUserDomain, &SidNameUse) || 
                        GetLastError() == ERROR_INSUFFICIENT_BUFFER)
                    {
                        LPTSTR pszUserName   = (LPTSTR)LocalAlloc(LPTR, cbAccountName * sizeof(WCHAR));
                        LPTSTR pszUserDomain = (LPTSTR)LocalAlloc(LPTR, cbUserDomain * sizeof(WCHAR));

                        if (pszUserName && pszUserDomain &&
                            LookupAccountSid(NULL, pUserToken->User.Sid, 
                                pszUserName, &cbAccountName, 
                                pszUserDomain, &cbUserDomain, &SidNameUse))
                        {
                            if (ppszUserName)
                            {
                                *ppszUserName = pszUserName;
                                pszUserName = NULL;
                            }
                            if (ppszUserDomain)
                            {
                                *ppszUserDomain = pszUserDomain;
                                pszUserDomain = NULL;
                            }

                            bRet = TRUE;
                        }

                        if (pszUserName)
                            LocalFree(pszUserName);
                        if (pszUserDomain)
                            LocalFree(pszUserDomain);
                    }
                }
                LocalFree(pUserToken);
            }
        }
        CloseHandle(hToken);
    }
    return bRet;
}

//
// tsnotify.dll export
//
typedef BOOL (*PTERMSRVCREATETEMPDIR) (PVOID *pEnv,HANDLE UserToken,PSECURITY_DESCRIPTOR SD);
/***************************************************************************\
* SetPerSessionTempDir - adds a session number to the TMP/TEMP path if necessary.
*
*
* History:
* 10-4-2000  skuzin     Created
*
\***************************************************************************/
void
SetPerSessionTempDir(
        PVOID *ppEnvironment)
{
    HKEY   Handle;
    DWORD  fPerSessionTempDir = 0;
    DWORD  dwValueData;
    
    /*
     *  Open registry value set thru TSCC
     */
    if ( RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                       REG_CONTROL_TSERVER,
                       0,
                       KEY_READ,
                       &Handle ) == ERROR_SUCCESS )
    {
        DWORD ValueSize;
        DWORD ValueType;
        LONG   rc;

        ValueSize = sizeof(fPerSessionTempDir);

        /*
         *  Read registry value
         */
        rc = RegQueryValueExW( Handle,
                               REG_TERMSRV_PERSESSIONTEMPDIR,
                               NULL,
                               &ValueType,
                               (LPBYTE) &fPerSessionTempDir,
                               &ValueSize );

        /*
         *  Close registry and key handle
         */
        RegCloseKey( Handle );
    }

    /*
     * Check the machine wide policy set thru Group Policy
     */

    if ( RegOpenKeyEx( HKEY_LOCAL_MACHINE,
                       TS_POLICY_SUB_TREE,
                       0,
                       KEY_READ,
                       &Handle ) == ERROR_SUCCESS )
    {
        DWORD ValueSize;
        DWORD ValueType;
        LONG   rc;

        ValueSize = sizeof(fPerSessionTempDir);

        /*
         *  Read registry value
         */
        rc = RegQueryValueExW( Handle,
                               REG_TERMSRV_PERSESSIONTEMPDIR,
                               NULL,
                               &ValueType,
                               (LPBYTE) &dwValueData,
                               &ValueSize );

        if (rc == ERROR_SUCCESS )
        {
            fPerSessionTempDir = dwValueData;
        }

        /*
         *  Close registry and key handle
         */
        RegCloseKey( Handle );
    }

    if (fPerSessionTempDir) 
    {
        PTERMSRVCREATETEMPDIR pfnTermsrvCreateTempDir;
        HANDLE dllHandle;

        dllHandle = LoadLibrary(TEXT("wlnotify.dll"));
        if (dllHandle) 
        {
            pfnTermsrvCreateTempDir = (PTERMSRVCREATETEMPDIR) 
                GetProcAddress(dllHandle, "TermsrvCreateTempDir");

            if (pfnTermsrvCreateTempDir)  
            {
                pfnTermsrvCreateTempDir(ppEnvironment, NULL, NULL);
            }

            FreeLibrary(dllHandle);
        }
    }
}

/***************************************************************************\
* RegenerateUserEnvironment
*
*
* History:
* 11-5-92  Johannec     Created
*
\***************************************************************************/
BOOL APIENTRY RegenerateUserEnvironment(void **pNewEnv, BOOL bSetCurrentEnv)
{
    NTSTATUS Status;
    WCHAR szValue[1025];
    TCHAR szExpValue[1025];
    void *pEnv = NULL;
    void *pPrevEnv;
    LPTSTR UserName = NULL;
    LPTSTR UserDomain = NULL;
    HKEY  hKey;
    DWORD dwDisp, dwType, dwMaxBufferSize;
    TCHAR szParseAutoexec[MAX_PARSE_AUTOEXEC_BUFFER];
    TCHAR szComputerName[MAX_COMPUTERNAME_LENGTH+1];
    DWORD dwComputerNameSize = MAX_COMPUTERNAME_LENGTH+1;



    /*
     * Create a new environment for the user.
     */
    Status = RtlCreateEnvironment((BOOLEAN)FALSE, &pEnv);
    if (!NT_SUCCESS(Status)) {
        return(FALSE);
    }

    SetSystemEnvironmentVariables(&pEnv);

    /*
     * Initialize user's environment.
     */
    if (GetComputerName (szComputerName, &dwComputerNameSize)) {
        SetUserEnvironmentVariable(&pEnv, COMPUTERNAME_VARIABLE, (LPTSTR) szComputerName, TRUE);
    }
    if (GetUserNameAndDomain(&UserName, &UserDomain))
    {
        SetUserEnvironmentVariable( &pEnv, USERNAME_VARIABLE, UserName, TRUE);
        SetUserEnvironmentVariable( &pEnv, USERDOMAIN_VARIABLE, UserDomain, TRUE);
        LocalFree(UserName);
        LocalFree(UserDomain);
    }

    if (GetEnvironmentVariable(USERDNSDOMAIN_VARIABLE, szValue, ARRAYSIZE(szValue)))
        SetUserEnvironmentVariable( &pEnv, USERDNSDOMAIN_VARIABLE, szValue, TRUE);

    //
    // Set home directory env. vars.
    //
    if (GetEnvironmentVariable(HOMEDRIVE_VARIABLE, szValue, ARRAYSIZE(szValue)))
        SetUserEnvironmentVariable( &pEnv, HOMEDRIVE_VARIABLE, szValue, TRUE);

    if (GetEnvironmentVariable(HOMESHARE_VARIABLE, szValue, ARRAYSIZE(szValue)))
        SetUserEnvironmentVariable( &pEnv, HOMESHARE_VARIABLE, szValue, TRUE);

    if (GetEnvironmentVariable(HOMEPATH_VARIABLE, szValue, ARRAYSIZE(szValue)))
        SetUserEnvironmentVariable( &pEnv, HOMEPATH_VARIABLE, szValue, TRUE);

    //
    // Set the user profile dir env var
    //

    if (GetEnvironmentVariable(USERPROFILE_VARIABLE, szValue, ARRAYSIZE(szValue)))
        SetUserEnvironmentVariable( &pEnv, USERPROFILE_VARIABLE, szValue, TRUE);


    //
    // Set the program files env var
    //

    if (RegOpenKeyEx (HKEY_LOCAL_MACHINE, TEXT("Software\\Microsoft\\Windows\\CurrentVersion"),
                      0, KEY_READ, &hKey) == ERROR_SUCCESS) {

        dwMaxBufferSize = sizeof(szValue);
        if (SHQueryValueEx (hKey, TEXT("ProgramFilesDir"), NULL, &dwType,
                             (LPBYTE) szValue, &dwMaxBufferSize) == ERROR_SUCCESS) {

            SHExpandEnvironmentStrings(szValue, szExpValue, ARRAYSIZE(szExpValue));
            SetUserEnvironmentVariable(&pEnv, PROGRAMFILES_VARIABLE, szExpValue, TRUE);
        }

        dwMaxBufferSize = sizeof(szValue);
        if (SHQueryValueEx (hKey, TEXT("CommonFilesDir"), NULL, &dwType,
                             (LPBYTE) szValue, &dwMaxBufferSize) == ERROR_SUCCESS) {

            SHExpandEnvironmentStrings (szValue, szExpValue, ARRAYSIZE(szExpValue));
            SetUserEnvironmentVariable(&pEnv, COMMONPROGRAMFILES_VARIABLE, szExpValue, TRUE);
        }

#if defined(WX86) || defined(_WIN64)
        dwMaxBufferSize = sizeof(szValue);
        if (SHQueryValueEx (hKey, TEXT("ProgramFilesDir (x86)"), NULL, &dwType,
                             (LPBYTE) szValue, &dwMaxBufferSize) == ERROR_SUCCESS) {

            SHExpandEnvironmentStrings(szValue, szExpValue, ARRAYSIZE(szExpValue));
            SetUserEnvironmentVariable(&pEnv, PROGRAMFILESX86_VARIABLE, szExpValue, TRUE);
        }

        dwMaxBufferSize = sizeof(szValue);
        if (SHQueryValueEx (hKey, TEXT("CommonFilesDir (x86)"), NULL, &dwType,
                             (LPBYTE) szValue, &dwMaxBufferSize) == ERROR_SUCCESS) {

            SHExpandEnvironmentStrings (szValue, szExpValue, ARRAYSIZE(szExpValue));
            SetUserEnvironmentVariable(&pEnv, COMMONPROGRAMFILESX86_VARIABLE, szExpValue, TRUE);
        }

#endif

        RegCloseKey (hKey);
    }

    /*
     * Set 16-bit apps environment variables by processing autoexec.bat
     * User can turn this off and on via the registry.
     */

    //
    // Set the default case, and open the key
    //

    lstrcpy (szParseAutoexec, PARSE_AUTOEXEC_DEFAULT);

    if (RegCreateKeyEx (HKEY_CURRENT_USER, PARSE_AUTOEXEC_KEY, 0, 0,
                    REG_OPTION_NON_VOLATILE, KEY_READ | KEY_WRITE,
                    NULL, &hKey, &dwDisp) == ERROR_SUCCESS) {


        //
        // Query the current value.  If it doesn't exist, then add
        // the entry for next time.
        //

        dwMaxBufferSize = sizeof (TCHAR) * MAX_PARSE_AUTOEXEC_BUFFER;
        if (SHQueryValueEx (hKey, PARSE_AUTOEXEC_ENTRY, NULL, &dwType,
                        (LPBYTE) szParseAutoexec, &dwMaxBufferSize)
                         != ERROR_SUCCESS) {

            //
            // Set the default value
            //

            RegSetValueEx (hKey, PARSE_AUTOEXEC_ENTRY, 0, REG_SZ,
                           (LPBYTE) szParseAutoexec,
                           sizeof (TCHAR) * lstrlen (szParseAutoexec) + 1);
        }

        //
        // Close key
        //

        RegCloseKey (hKey);
     }


    //
    // Process the autoexec if appropriate
    //

    if (szParseAutoexec[0] == TEXT('1')) {
        ProcessAutoexec(&pEnv, PATH_VARIABLE);
    }


    /*
     * Set User environment variables.
     */
    SetEnvironmentVariables( &pEnv, USER_ENV_SUBKEY);

    /*
     * Set User volatile environment variables.
     */
    SetEnvironmentVariables( &pEnv, USER_VOLATILE_ENV_SUBKEY);

    AppendNTPathWithAutoexecPath( &pEnv, PATH_VARIABLE, AUTOEXECPATH_VARIABLE);

    if (bSetCurrentEnv) {
        Status = RtlSetCurrentEnvironment( pEnv, &pPrevEnv);
        if (!NT_SUCCESS(Status)) {
//            RtlDestroyEnvironment(pEnv);
            return(FALSE);
        }
        else {
            RtlDestroyEnvironment(pPrevEnv);
        }
    }
    
    //
    //If it's not a session 0 we might need to change value of TMP/TEMP
    //so they will be different for each session.
    //
    if(NtCurrentPeb()->SessionId)
    {
        SetPerSessionTempDir(&pEnv);
    }

    *pNewEnv = pEnv;

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\recclean.h ===
class CRecycleBinCleaner : public IEmptyVolumeCache2
{
   public:
      CRecycleBinCleaner();
      ~CRecycleBinCleaner();
       
      // IUnknown methods
    
      STDMETHODIMP  QueryInterface(REFIID riid, PVOID *ppvObj);
      STDMETHODIMP_(ULONG) AddRef(void);
      STDMETHODIMP_(ULONG) Release(void);

      // IEmptyVolumeCache
      STDMETHODIMP Initialize(HKEY hRegKey, LPCWSTR pszVolume, 
                      LPWSTR  *ppszDisplayName, LPWSTR  *ppszDescription,
                      DWORD *pdwFlags);
                                
      STDMETHODIMP GetSpaceUsed(DWORDLONG *pdwSpaceUsed, IEmptyVolumeCacheCallBack *picb);
                                
      STDMETHODIMP Purge(DWORDLONG dwSpaceToFree, IEmptyVolumeCacheCallBack *picb);
                               
                                
      STDMETHODIMP ShowProperties(HWND hwnd);
                                
      STDMETHODIMP Deactivate(DWORD *pdwFlags);

      // IEmptyVolumeCache2
      STDMETHODIMP InitializeEx(HKEY hkRegKey, LPCWSTR pcwszVolume,
                                LPCWSTR pcwszKeyName,
                                LPWSTR *ppwszDisplayName, LPWSTR *ppwszDescription,
                                LPWSTR *ppwszBtnText,
                                DWORD *pdwFlags);

   private:
      ULONG m_cRef;
      WCHAR m_szVolume[5];
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\recclean.cpp ===
#include "shellprv.h"
#include "emptyvc.h"
#include "recclean.h"
#include "ids.h"

STDAPI CRecycleBinCleaner_CreateInstance(LPUNKNOWN punkOuter, REFIID riid, void **ppvOut)
{
    *ppvOut = NULL;

    CRecycleBinCleaner *p = new CRecycleBinCleaner();
    if (!p)
        return E_OUTOFMEMORY;

    HRESULT hres = p->QueryInterface(riid, ppvOut);
    p->Release();
    return hres;
}

CRecycleBinCleaner::CRecycleBinCleaner() : m_cRef(1)
{
   // start ref at one
}

CRecycleBinCleaner::~CRecycleBinCleaner()
{
   // cleanup - nothing yet
}

/*----------------------------------------------------------
QueryInterface handler for CRecycleBinCleaner
*/

STDMETHODIMP CRecycleBinCleaner::QueryInterface(REFIID riid, PVOID *ppvObj)
{
    if (IsEqualIID(riid, IID_IUnknown) ||
        IsEqualIID(riid, IID_IEmptyVolumeCache2))
    {
        *ppvObj = SAFECAST(this, IEmptyVolumeCache2 *);
    }
    else if (IsEqualIID(riid, IID_IEmptyVolumeCache))
    {
        *ppvObj = SAFECAST(this, IEmptyVolumeCache *);
    }
    else
    {
        *ppvObj = NULL;
        return E_NOINTERFACE;
    }
    AddRef();
   
    return NOERROR;
}


STDMETHODIMP_(ULONG) CRecycleBinCleaner::AddRef()
{
    return ++m_cRef;
}


STDMETHODIMP_(ULONG) CRecycleBinCleaner::Release()
{
    m_cRef--;
    if (m_cRef > 0)
        return m_cRef;

    delete this;
    return 0;
}

STDMETHODIMP CRecycleBinCleaner::InitializeEx(
    HKEY hkRegKey,
    LPCWSTR pcwszVolume,
    LPCWSTR pcwszKeyName,
    LPWSTR *ppwszDisplayName,
    LPWSTR *ppwszDescription,
    LPWSTR *ppwszBtnText,
    DWORD *pdwFlags
    )
{
    TCHAR szTmp[128];
    int iLen;

    iLen = 1 + LoadString( g_hinst, IDS_RECCLEAN_BTNTEXT, szTmp, ARRAYSIZE(szTmp));
    if (iLen == 1) // and hence LoadString returned 0 (error)
        return E_FAIL;

    *ppwszBtnText = (LPWSTR)CoTaskMemAlloc( iLen * sizeof(WCHAR) );
    if ( !*ppwszBtnText )
        return E_OUTOFMEMORY;
    SHTCharToUnicode(szTmp, *ppwszBtnText, iLen);

    return Initialize(hkRegKey, pcwszVolume, ppwszDisplayName, ppwszDescription, pdwFlags);
}

STDMETHODIMP CRecycleBinCleaner::Initialize(HKEY hRegKey, LPCWSTR pszVolume,
                      LPWSTR  *ppwszName, LPWSTR *ppwszDesc, DWORD *pdwFlags)
{
    TCHAR szTmpName[256], szTmpDesc[512];
    int iNameLen, iDescLen;

    if(!pdwFlags)
        return E_INVALIDARG;

    *pdwFlags = EVCF_HASSETTINGS;

    iNameLen = 1 + LoadString( g_hinst, IDS_RECCLEAN_NAMETEXT, szTmpName, ARRAYSIZE(szTmpName));
    iDescLen = 1 + LoadString( g_hinst, IDS_RECCLEAN_DESCTEXT, szTmpDesc, ARRAYSIZE(szTmpDesc));
    if ( (iNameLen == 1) || (iDescLen == 1) ) // meaning LoadString returned 0 (error)
        return E_FAIL;

    *ppwszName = (LPWSTR)CoTaskMemAlloc( iNameLen*sizeof(WCHAR) );
    *ppwszDesc = (LPWSTR)CoTaskMemAlloc( iDescLen*sizeof(WCHAR) );
    if ( !*ppwszName || !*ppwszDesc )
        return E_OUTOFMEMORY;

    SHTCharToUnicode(szTmpName, *ppwszName, iNameLen);
    SHTCharToUnicode(szTmpDesc, *ppwszDesc, iDescLen);

    StrCpyNW(m_szVolume, pszVolume, ARRAYSIZE(m_szVolume));
    
    return S_OK;
}


STDMETHODIMP CRecycleBinCleaner::GetSpaceUsed(DWORDLONG *pdwSpaceUsed, IEmptyVolumeCacheCallBack *picb)
{
   SHQUERYRBINFO qinfo;

   if(!pdwSpaceUsed)
       return E_INVALIDARG;

   qinfo.cbSize = sizeof(SHQUERYRBINFO);
   if(SUCCEEDED(SHQueryRecycleBinW(m_szVolume, &qinfo)))
   {
      *pdwSpaceUsed = qinfo.i64Size;
   }
   else
   {
      *pdwSpaceUsed = 0;
   }
   
   // call back to be nice
   if(picb)
       picb->ScanProgress(*pdwSpaceUsed, EVCCBF_LASTNOTIFICATION, NULL);

   return S_OK;
}

STDMETHODIMP CRecycleBinCleaner::Purge(DWORDLONG dwSpaceToFree, IEmptyVolumeCacheCallBack *picb)
{
    SHQUERYRBINFO qinfo;

    if (picb)
    {
        qinfo.cbSize = sizeof(SHQUERYRBINFO);
        SHQueryRecycleBinW(m_szVolume, &qinfo);
    }

    // we ignore dwSpaceToFree and clean everything
    SHEmptyRecycleBin(NULL, m_szVolume, SHERB_NOCONFIRMATION | SHERB_NOPROGRESSUI | SHERB_NOSOUND);
   
    // call back to be nice
    if (picb)
    {
        picb->PurgeProgress(qinfo.i64Size, qinfo.i64Size, EVCCBF_LASTNOTIFICATION, NULL); 
    }

    return S_OK;
}

STDMETHODIMP CRecycleBinCleaner::ShowProperties(HWND hwnd)
{
    LPITEMIDLIST pidlBitBuck = SHCloneSpecialIDList(hwnd, CSIDL_BITBUCKET, TRUE);
    if (pidlBitBuck) 
    {
        SHELLEXECUTEINFO ei;
        FillExecInfo(ei, hwnd, c_szOpen, szNULL, NULL, szNULL, SW_NORMAL);
        ei.fMask |= SEE_MASK_IDLIST;
        ei.lpIDList = pidlBitBuck;

        ShellExecuteEx(&ei);
        ILFree(pidlBitBuck);
    }
    return S_OK;
}

STDMETHODIMP CRecycleBinCleaner::Deactivate(LPDWORD pdwFlags)
{
    // whatever, nothing to deactivate
    return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\regsprtb.cpp ===
#include "shellprv.h"
#pragma  hdrstop

#include "regsprtb.h"


BOOL CRegSupportBuf::_InitSetRoot(LPCTSTR pszSubKey1, LPCTSTR pszSubKey2)
{
    lstrcpyn(_szRoot, pszSubKey1, ARRAYSIZE(_szRoot));

    if (pszSubKey2)
    {
        lstrcatn(_szRoot, TEXT("\\"), ARRAYSIZE(_szRoot));
        lstrcatn(_szRoot, pszSubKey2, ARRAYSIZE(_szRoot));
    }

    return TRUE;
}

LPCTSTR CRegSupportBuf::_GetRoot(LPTSTR pszRoot, DWORD cchRoot)
{
    return _szRoot;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\reglist.c ===
// History:
//   5-30-94 KurtE      Created.
#include "shellprv.h"
#pragma  hdrstop

//#define PARANOID_VALIDATE_UPDATE

// Define our global states here.  Note: we will do it per process
typedef struct _RLPI    // Registry List Process Info
{
    HDPA    hdpaRLList;             // The dpa of items
    BOOL    fCSInitialized;         // Have we initialized the CS in this process
    BOOL    fListValid;             // Is the list up to date and valid
    CRITICAL_SECTION csRLList;      // The critical section for the process
} RLPI;


RLPI g_rlpi = {NULL, FALSE, FALSE};

// Simple DPA compare function make sure we don't have elsewhere...

int CALLBACK _CompareStrings(LPVOID sz1, LPVOID sz2, LPARAM lparam)
{
    return lstrcmpi((LPTSTR)sz1, (LPTSTR)sz2);
}

void RLEnterCritical()
{
    if (!g_rlpi.fCSInitialized)
    {
        // Do this under the global critical section.
        ENTERCRITICAL;
        if (!g_rlpi.fCSInitialized)
        {
            g_rlpi.fCSInitialized = TRUE;
            InitializeCriticalSection(&g_rlpi.csRLList);
        }
        LEAVECRITICAL;
    }
    EnterCriticalSection(&g_rlpi.csRLList);
}

void RLLeaveCritical()
{
    LeaveCriticalSection(&g_rlpi.csRLList);
}


// Enumerate through the registry looking for paths that
//  we may wish to track.  The current ones that we look for

STDAPI_(BOOL) RLEnumRegistry(HDPA hdpa, PRLCALLBACK pfnrlcb, LPCTSTR pszSource, LPCTSTR pszDest)
{
    HKEY hkeyRoot;

    // First look in the App Paths section
    if (RegOpenKey(HKEY_LOCAL_MACHINE, REGSTR_PATH_APPPATHS, &hkeyRoot) == ERROR_SUCCESS)
    {
	    int iRootName;
	    TCHAR szRootName[80];
        for (iRootName = 0; 
             RegEnumKey(hkeyRoot, iRootName, szRootName, ARRAYSIZE(szRootName)) == ERROR_SUCCESS; 
             iRootName++)
        {
            // Now see if the app has a qualifid path here.
		    HKEY hkeySecond;
		    TCHAR szPath[MAX_PATH];
		    long cbValue = sizeof(szPath);
            if (SHRegQueryValue(hkeyRoot, szRootName, szPath, &cbValue) == ERROR_SUCCESS)
            {
                PathUnquoteSpaces(szPath);
                pfnrlcb(hdpa, hkeyRoot, szRootName, NULL, szPath, pszSource, pszDest);
            }

            // Now try to enum this key  for Path Value.
            if (RegOpenKey(hkeyRoot, szRootName, &hkeySecond) == ERROR_SUCCESS)
            {
                cbValue = sizeof(szPath);

                if (SHQueryValueEx(hkeySecond, TEXT("PATH"), NULL, NULL, szPath, &cbValue) == ERROR_SUCCESS)
                {
                    // this is a ";" separated list
                    LPTSTR psz = StrChr(szPath, TEXT(';'));
                    if (psz)
                        *psz = 0;
                    PathUnquoteSpaces(szPath);
                    pfnrlcb(hdpa, hkeySecond, NULL, TEXT("PATH"), szPath, pszSource, pszDest);
                }

                RegCloseKey(hkeySecond);
            }
        }
        RegCloseKey(hkeyRoot);
    }
    return TRUE;
}

// This is the call back called to build the list of paths.

BOOL CALLBACK _RLBuildListCallBack(HDPA hdpa, HKEY hkey, LPCTSTR pszKey,
        LPCTSTR pszValueName, LPTSTR pszValue, LPCTSTR pszSource, LPCTSTR pszDest)
{
    int iIndex;

    // Also don't add any relative paths.
    if (PathIsRelative(pszValue) || (lstrlen(pszValue) < 3))
        return TRUE;

    // Don't try UNC names as this can get expensive...
    if (PathIsUNC(pszValue))
        return TRUE;

    // If it is already in our list, we can simply return now..
    if (DPA_Search(hdpa, pszValue, 0, _CompareStrings, 0, DPAS_SORTED) != -1)
        return TRUE;

    // If it is in our old list then
    if (g_rlpi.hdpaRLList && ((iIndex = DPA_Search(g_rlpi.hdpaRLList, pszValue, 0,
            _CompareStrings, 0, DPAS_SORTED)) != -1))
    {
        // Found the item in the old list.
        TraceMsg(TF_REG, "_RLBuildListCallBack: Add from old list %s", pszValue);

        DPA_InsertPtr(hdpa,
                    DPA_Search(hdpa, pszValue, 0,
                    _CompareStrings, 0,
                    DPAS_SORTED|DPAS_INSERTBEFORE),
                    (LPTSTR)DPA_FastGetPtr(g_rlpi.hdpaRLList, iIndex));
        // now remove it from the old list
        DPA_DeletePtr(g_rlpi.hdpaRLList, iIndex);
    }
    else
    {
        // Not in either list.
        // Now see if we can convert the short name to a long name

        TCHAR szLongName[MAX_PATH];
        int cchName;
        LPTSTR psz;

        if (!GetLongPathName(pszValue, szLongName, ARRAYSIZE(szLongName)))
            szLongName[0] = 0;

        if (lstrcmpi(szLongName, pszValue) == 0)
            szLongName[0] = 0;   // Don't need both strings.

        cchName = lstrlen(pszValue);

        psz = (LPTSTR)LocalAlloc(LPTR,
                (cchName + 1 + lstrlen(szLongName) + 1) * sizeof(TCHAR));
        if (psz)
        {
            TraceMsg(TF_REG, "_RLBuildListCallBack: Add %s", pszValue);

            lstrcpy(psz, pszValue);
            lstrcpy(psz + cchName + 1, szLongName);

            return DPA_InsertPtr(hdpa,
                    DPA_Search(hdpa, pszValue, 0,
                    _CompareStrings, 0,
                    DPAS_SORTED|DPAS_INSERTBEFORE),
                    psz);
        }
    }
    return TRUE;
}

// This function will build the list of items that we
//      will look through to see if the user may have changed the path of
//      of one of the programs that is registered in the registry.
//

BOOL WINAPI RLBuildListOfPaths()
{
    BOOL fRet = FALSE;
    HDPA hdpa;

    DEBUG_CODE( DWORD   dwStart = GetCurrentTime(); )

    RLEnterCritical();

    hdpa = DPA_Create(0);
    if (!hdpa)
        goto Error;


    // And initialize the list
    fRet = RLEnumRegistry(hdpa, _RLBuildListCallBack, NULL, NULL);


    // If we had on old list destroy it now.

    if (g_rlpi.hdpaRLList)
    {
        // Walk through all of the items in the list and
        // delete all of the strings.
        int i;
        for (i = DPA_GetPtrCount(g_rlpi.hdpaRLList)-1; i >= 0; i--)
            LocalFree((HLOCAL)DPA_FastGetPtr(g_rlpi.hdpaRLList, i));
        DPA_Destroy(g_rlpi.hdpaRLList);
    }

    g_rlpi.hdpaRLList = hdpa;
    g_rlpi.fListValid = TRUE;     // Say that we are valid...

    DEBUG_CODE( TraceMsg(TF_REG, "RLBuildListOfPaths time: %ld", GetCurrentTime()-dwStart); )

Error:

    RLLeaveCritical();
    return fRet;
}

// this function does any cleanup necessary for when a process
//      is no longer going to use the Registry list.

void WINAPI RLTerminate()
{
    int i;

    if (!g_rlpi.hdpaRLList)
        return;

    RLEnterCritical();

    // Re-check under critical section in case somebody else destroyed
    // it while we were waiting
    if (g_rlpi.hdpaRLList)
    {
        // Walk through all of the items in the list and
        // delete all of the strings.
        for (i = DPA_GetPtrCount(g_rlpi.hdpaRLList)-1; i >= 0; i--)
            LocalFree((HLOCAL)DPA_FastGetPtr(g_rlpi.hdpaRLList, i));

        DPA_Destroy(g_rlpi.hdpaRLList);
        g_rlpi.hdpaRLList = NULL;
    }
    RLLeaveCritical();
}

// This function returns TRUE if the path that is passed
// in is contained in one or more of the paths that we extracted from
// the registry.

int WINAPI RLIsPathInList(LPCTSTR pszPath)
{
    int i = -1;
    RLEnterCritical();

    if (!g_rlpi.hdpaRLList || !g_rlpi.fListValid)
        RLBuildListOfPaths();

    if (g_rlpi.hdpaRLList)
    {
        int cchPath = lstrlen(pszPath);

        for (i = DPA_GetPtrCount(g_rlpi.hdpaRLList) - 1; i >= 0; i--)
        {
            LPTSTR psz = DPA_FastGetPtr(g_rlpi.hdpaRLList, i);
            if (PathCommonPrefix(pszPath, psz, NULL) == cchPath)
                break;

            // See if a long file name to check.
            psz += lstrlen(psz) + 1;
            if (*psz && (PathCommonPrefix(pszPath, psz, NULL) == cchPath))
                break;
        }
    }

    RLLeaveCritical();

    return i;   // -1 if none, >= 0 index
}

// This is the call back called to build the list of of paths.
//
BOOL CALLBACK _RLRenameCallBack(HDPA hdpa, HKEY hkey, LPCTSTR pszKey,
        LPCTSTR pszValueName, LPTSTR pszValue, LPCTSTR pszSource, LPCTSTR pszDest)
{
    int cbMatch = PathCommonPrefix(pszValue, pszSource, NULL);
    if (cbMatch == lstrlen(pszSource))
    {
        TCHAR szPath[MAX_PATH+64];   // Add some slop just in case...
        // Found a match, lets try to rebuild the new line
        lstrcpy(szPath, pszDest);
        lstrcat(szPath, pszValue + cbMatch);

        if (pszValueName)
            RegSetValueEx(hkey, pszValueName, 0, REG_SZ, (BYTE *)szPath, (lstrlen(szPath) + 1) * sizeof(TCHAR));
        else
            RegSetValue(hkey, pszKey, REG_SZ, szPath, lstrlen(szPath));
    }

    // Make sure that we have not allready added
    // this path to our list.
    if (DPA_Search(hdpa, pszValue, 0, _CompareStrings, 0, DPAS_SORTED) == -1)
    {
        // One to Add!
        LPTSTR psz = StrDup(pszValue);
        if (psz)
        {
            return DPA_InsertPtr(hdpa,
                    DPA_Search(hdpa, pszValue, 0,
                    _CompareStrings, 0,
                    DPAS_SORTED | DPAS_INSERTBEFORE), psz);
        }
    }
    return TRUE;
}

// This function handles the cases when we are notified of
// a change to the file system and then we need to see if there are
// any changes that we need to make to the regisry to handle the changes.

int WINAPI RLFSChanged(LONG lEvent, LPITEMIDLIST pidl, LPITEMIDLIST pidlExtra)
{
    TCHAR szSrc[MAX_PATH];
    TCHAR szDest[MAX_PATH+8];     // For slop like Quotes...
    int iIndex;
    LPTSTR psz;
    int iRet = -1;
    int i;

    // First see if the operation is something we are interested in.
    if ((lEvent & (SHCNE_RENAMEITEM | SHCNE_RENAMEFOLDER)) == 0)
        return -1; // Nope

    if (!SHGetPathFromIDList(pidl, szSrc))
    {
        // must be a rename of a non-filesys object (such as a printer!)
        return -1;
    }

    SHGetPathFromIDList(pidlExtra, szDest);

    // If either are roots we really can not rename them...
    if (PathIsRoot(szSrc) || PathIsRoot(szDest))
        return -1;

    // ignore if coming from bitbucket or going to ...
    // check bitbucket first.  that's a cheap call
    if ((lEvent & SHCNE_RENAMEITEM) &&
        (IsFileInBitBucket(szSrc) || IsFileInBitBucket(szDest)))
        return -1;

    RLEnterCritical();
    // Now see if the source file is in our list of paths
    iIndex = RLIsPathInList(szSrc);
    if (iIndex != -1)
    {
        // Now make sure we are working with the short name
        // Note we may only be a subpiece of this item.
        // Count how many fields there are in the szSrc Now;
        for (i = 0, psz = szSrc; psz; i++)
        {
            psz = StrChr(psz + 1, TEXT('\\'));
        }
        lstrcpy(szSrc, (LPTSTR)DPA_FastGetPtr(g_rlpi.hdpaRLList, iIndex));

        // Now truncate off stuff that is not from us Go one more then we countd
        // above and if we have a non null value cut it off there.
        for (psz = szSrc; i > 0; i--)
        {
            psz = StrChr(psz+1, TEXT('\\'));
        }
        if (psz)
            *psz = 0;

        // verify that this is a fully qulified path and that it exists
        // before we go and muck with the registry.
        if (!PathIsRelative(szDest) && PathFileExistsAndAttributes(szDest, NULL) && (lstrlen(szDest) >= 3))
        {
            // Yes, so now lets reenum and try to update the paths...
            PathGetShortPath(szDest);        // Convert to a short name...
            RLEnumRegistry(g_rlpi.hdpaRLList, _RLRenameCallBack, szSrc, szDest);

            // We changed something so mark it to be rebuilt
            g_rlpi.fListValid = FALSE;     // Force it to rebuild.
            iRet = 1;
        }
    }
    RLLeaveCritical();

    return iRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\regsprtb.h ===
#ifndef __REGSPRTB_H
#define __REGSPRTB_H

#include "regsuprt.h"

class CRegSupportBuf : public CRegSupport
{
protected:
    BOOL _InitSetRoot(LPCTSTR pszSubKey1, LPCTSTR pszSubKey2);

    LPCTSTR _GetRoot(LPTSTR pszRoot, DWORD cchRoot);

private:
    TCHAR                   _szRoot[MAX_PATH];
};

#endif //__REGSPRTB_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\regfldr.cpp ===
#include "shellprv.h"
#include "ids.h"
#include "infotip.h"
#include "datautil.h"
#include <caggunk.h>
#include "pidl.h"
#include "fstreex.h"
#include "views.h"
#include "shitemid.h"
#include "ole2dup.h"
#include "deskfldr.h"
#include "prop.h"
#include "util.h"  // GetVariantFromRegistryValue
#include "defcm.h"
#include "cowsite.h"
#pragma hdrstop


//
// HACKHACK: GUIDs for _IsInNameSpace hack
//

// {D6277990-4C6A-11CF-8D87-00AA0060F5BF}
const GUID CLSID_ScheduledTasks =  { 0xD6277990, 0x4C6A, 0x11CF, { 0x8D, 0x87, 0x00, 0xAA, 0x00, 0x60, 0xF5, 0xBF } };

// {7007ACC7-3202-11D1-AAD2-00805FC1270E}
const GUID CLSID_NetworkConnections = { 0x7007ACC7, 0x3202, 0x11D1, { 0xAA, 0xD2, 0x00, 0x80, 0x5F, 0xC1, 0x27, 0x0E } };


//
// delegate regitems are a special type of IDLIST.  they share the same type as a regular REGITEM however
// they have a different IDLIST format.  we are unable to change the format of REGITEM IDLISTs so to facilitate
// delegate objects we store items using the following format:
//
//  <DELEGATEITEMID> <folder specific data> <DELEGATEITEMDATA>
//
// DELEGATEITEMID 
//      is a shell structure which contains information about the folder specific information,
//      and a regular ITEMIDLIST header.
//
// <folder specific data>
//      this is specific to the IShellFolder that is being merged into the namespace.
//
// <DELEGATEITEMDATA>
//      this contains a signature so we can determine if the IDLIST is a special delegate, 
//      and the CLSID of the IShellFolder which owns this data.
//

// all delegate regitems are allocated using the IDelegateMalloc

// {5e591a74-df96-48d3-8d67-1733bcee28ba}
const GUID CLSID_DelegateItemSig = { 0x5e591a74, 0xdf96, 0x48d3, {0x8d, 0x67, 0x17, 0x33, 0xbc, 0xee, 0x28, 0xba} };

typedef struct
{
    CLSID clsidSignature;            // == CLSID_DelegateItemSig (indicating this is a delegate object)
    CLSID clsidShellFolder;           // == CLSID of IShellFolder implementing this delegateitem
} DELEGATEITEMDATA;
typedef UNALIGNED DELEGATEITEMDATA *PDELEGATEITEMDATA;
typedef const UNALIGNED DELEGATEITEMDATA *PCDELEGATEITEMDATA;

// IDREGITEM as implemented in NT5 Beta 3, breaks the ctrlfldr IShellFolder of downlevel
// platforms.  The clsid is interpreted as the IDCONTROL's oName and oInfo and these offsets
// are way to big for the following buffer (cBuf).  On downlevel platform, when we are lucky,
// the offset is still in memory readable by our process, and we just do random stuff.  When
// unlucky we try to read memory which we do not have access to and crash.  The IDREGITEMEX
// struct solves this by putting padding between bOrder and the CLSID and filling these bytes
// with 0's.  When persisted, downlevel platform will interpret these 0's as oName, oInfo and
// as L'\0' at the beggining of cBuf.  A _bFlagsLegacy was also added to handle the NT5 Beta3
// persisted pidls. (stephstm, 7/15/99)

// Note: in the case where CRegFldr::_cbPadding == 0, IDREGITEMEX.rgbPadding[0] is at
//       same location as the IDREGITEM.clsid

#pragma pack(1)
typedef struct
{
    WORD    cb;
    BYTE    bFlags;
    BYTE    bOrder;
    BYTE    rgbPadding[16]; // at least 16 to store the clsid
} IDREGITEMEX;
typedef UNALIGNED IDREGITEMEX *LPIDREGITEMEX;
typedef const UNALIGNED IDREGITEMEX *LPCIDREGITEMEX;
#pragma pack()

STDAPI_(BOOL) IsNameListedUnderKey(LPCTSTR pszFileName, LPCTSTR pszKey);

C_ASSERT(sizeof(IDREGITEMEX) == sizeof(IDREGITEM));

EXTERN_C const IDLREGITEM c_idlNet =
{
    {sizeof(IDREGITEM), SHID_ROOT_REGITEM, SORT_ORDER_NETWORK,
    { 0x208D2C60, 0x3AEA, 0x1069, 0xA2,0xD7,0x08,0x00,0x2B,0x30,0x30,0x9D, },}, // CLSID_NetworkPlaces
    0,
} ;

EXTERN_C const IDLREGITEM c_idlDrives =
{
    {sizeof(IDREGITEM), SHID_ROOT_REGITEM, SORT_ORDER_DRIVES,
    { 0x20D04FE0, 0x3AEA, 0x1069, 0xA2,0xD8,0x08,0x00,0x2B,0x30,0x30,0x9D, },}, // CLSID_MyComputer
    0,
} ;

EXTERN_C const IDLREGITEM c_idlInetRoot =
{
    {sizeof(IDREGITEM), SHID_ROOT_REGITEM, SORT_ORDER_INETROOT,
    { 0x871C5380, 0x42A0, 0x1069, 0xA2,0xEA,0x08,0x00,0x2B,0x30,0x30,0x9D, },}, // CSIDL_Internet
    0,
} ;

EXTERN_C const IDREGITEM c_aidlConnections[] =
{
    {sizeof(IDREGITEM), SHID_ROOT_REGITEM, SORT_ORDER_DRIVES,
    { 0x20D04FE0, 0x3AEA, 0x1069, 0xA2,0xD8,0x08,0x00,0x2B,0x30,0x30,0x9D, },}, // CLSID_MyComputer
    {sizeof(IDREGITEM), SHID_COMPUTER_REGITEM, 0,
    { 0x21EC2020, 0x3AEA, 0x1069, 0xA2,0xDD,0x08,0x00,0x2B,0x30,0x30,0x9D, },}, // CLSID_ControlPanel
    {sizeof(IDREGITEM), SHID_CONTROLPANEL_REGITEM, 0,
    { 0x7007ACC7, 0x3202, 0x11D1, 0xAA,0xD2,0x00,0x80,0x5F,0xC1,0x27,0x0E, },}, // CLSID_NetworkConnections
    { 0 },
};

enum
{
    REGORDERTYPE_OUTERBEFORE    = -1,
    REGORDERTYPE_REQITEM        = 0,   
    REGORDERTYPE_REGITEM,
    REGORDERTYPE_DELEGATE,
    REGORDERTYPE_OUTERAFTER
};


//
// class that implements the regitems folder
//

// CLSID_RegFolder {0997898B-0713-11d2-A4AA-00C04F8EEB3E}
const GUID CLSID_RegFolder =  { 0x997898b, 0x713, 0x11d2, { 0xa4, 0xaa, 0x0, 0xc0, 0x4f, 0x8e, 0xeb, 0x3e } };

class CRegFolderEnum;     // forward

class CRegFolder : public CAggregatedUnknown,
                   public IShellFolder2,
                   public IContextMenuCB,
                   public IShellIconOverlay
{
public:
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void ** ppvObj)
                { return CAggregatedUnknown::QueryInterface(riid, ppvObj); };
    STDMETHODIMP_(ULONG) AddRef(void) 
                { return CAggregatedUnknown::AddRef(); };

    //
    //  PowerDesk98 passes a CFSFolder to CRegFolder::Release(), so validate
    //  the pointer before proceeding down the path to iniquity.
    //
    STDMETHODIMP_(ULONG) Release(void) 
                { return _dwSignature == c_dwSignature ?
                            CAggregatedUnknown::Release() : 0; };

    // IShellFolder
    STDMETHODIMP ParseDisplayName(HWND hwnd, LPBC pbc, LPOLESTR pszName,
                                  ULONG * pchEaten, LPITEMIDLIST * ppidl, ULONG *pdwAttributes);
    STDMETHODIMP EnumObjects(HWND hwnd, DWORD grfFlags, IEnumIDList **ppenumIDList);
    STDMETHODIMP BindToObject(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppvOut);
    STDMETHODIMP BindToStorage(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppvObj);
    STDMETHODIMP CompareIDs(LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);
    STDMETHODIMP CreateViewObject (HWND hwndOwner, REFIID riid, void **ppvOut);
    STDMETHODIMP GetAttributesOf(UINT cidl, LPCITEMIDLIST * apidl, ULONG *rgfInOut);
    STDMETHODIMP GetUIObjectOf(HWND hwndOwner, UINT cidl, LPCITEMIDLIST * apidl,
                               REFIID riid, UINT * prgfInOut, void **ppvOut);
    STDMETHODIMP GetDisplayNameOf(LPCITEMIDLIST pidl, DWORD uFlags, LPSTRRET lpName);
    STDMETHODIMP SetNameOf(HWND hwnd, LPCITEMIDLIST pidl, LPCOLESTR pszName, DWORD uFlags,
                           LPITEMIDLIST * ppidlOut);

    // IShellFolder2
    STDMETHODIMP GetDefaultSearchGUID(GUID *pGuid);
    STDMETHODIMP EnumSearches(IEnumExtraSearch **ppenum);
    STDMETHODIMP GetDefaultColumn(DWORD dwRes, ULONG *pSort, ULONG *pDisplay);
    STDMETHODIMP GetDefaultColumnState(UINT iColumn, DWORD *pbState);
    STDMETHODIMP GetDetailsEx(LPCITEMIDLIST pidl, const SHCOLUMNID *pscid, VARIANT *pv);
    STDMETHODIMP GetDetailsOf(LPCITEMIDLIST pidl, UINT iColumn, SHELLDETAILS *pDetails);
    STDMETHODIMP MapColumnToSCID(UINT iColumn, SHCOLUMNID *pscid);

    // IShellIconOverlay
    STDMETHODIMP GetOverlayIndex(LPCITEMIDLIST pidl, int *pIndex);
    STDMETHODIMP GetOverlayIconIndex(LPCITEMIDLIST pidl, int *pIconIndex);

    // IContextMenuCB
    STDMETHODIMP CallBack(IShellFolder *psf, HWND hwndOwner, IDataObject *pdtobj, 
                     UINT uMsg, WPARAM wParam, LPARAM lParam);

    // IRegItemFolder 
    STDMETHODIMP Initialize(REGITEMSINFO *pri);

protected:
    CRegFolder(IUnknown *punkOuter);
    ~CRegFolder();

    // used by the CAggregatedUnknown stuff
    HRESULT v_InternalQueryInterface(REFIID riid,void **ppvObj);

    HRESULT _GetOverlayInfo(LPCIDLREGITEM pidlr, int *pIndex, BOOL fIconIndex);
    
    LPCITEMIDLIST _GetFolderIDList();
    LPCIDLREGITEM _AnyRegItem(UINT cidl, LPCITEMIDLIST apidl[]);
    BOOL _AllDelegates(UINT cidl, LPCITEMIDLIST *apidl, IShellFolder **ppsf);

    int _ReqItemIndex(LPCIDLREGITEM pidlr);
    BYTE _GetOrderPure(LPCIDLREGITEM pidlr);
    BYTE _GetOrder(LPCIDLREGITEM pidlr);
    int _GetOrderType(LPCITEMIDLIST pidl);
    LPITEMIDLIST _CreateSimpleIDList(const CLSID *pclsid, BYTE bFlags, BOOL bOrder);
    void _GetNameSpaceKey(LPCIDLREGITEM pidlr, LPTSTR pszKeyName);
    LPCIDLREGITEM _IsReg(LPCITEMIDLIST pidl);                                                               
    PDELEGATEITEMID _IsDelegate(LPCIDLREGITEM pidlr);
    HRESULT _CreateDelegateFolder(const CLSID* pclsid, REFIID riid, void **ppv);
    HRESULT _GetDelegateFolder(PDELEGATEITEMID pidld, REFIID riid, void **ppv);

    BOOL _IsInNameSpace(LPCIDLREGITEM pidlr);
    HDCA _ItemArray();
    HDCA _DelItemArray();
    HRESULT _InitFromMachine(IUnknown *punk, BOOL bEnum);
    LPITEMIDLIST _CreateIDList(const CLSID *pclsid);
    HRESULT _CreateAndInit(LPCIDLREGITEM pidlr, LPBC pbc, REFIID riid, void **ppv);
    HRESULT _BindToItem(LPCIDLREGITEM pidlr, LPBC pbc, REFIID riid, void **ppv, BOOL bOneLevel);
    HRESULT _GetInfoTip(LPCIDLREGITEM pidlr, void **ppv);
    HRESULT _GetRegItemColumnFromRegistry(LPCIDLREGITEM pidlr, LPCTSTR pszColumnName, LPTSTR pszColumnData, int cchColumnData);
    HRESULT _GetRegItemVariantFromRegistry(LPCIDLREGITEM pidlr, LPCTSTR pszColumnName, VARIANT *pv);
    void _GetClassKeys(LPCIDLREGITEM pidlr, HKEY *phkCLSID, HKEY *phkBase);
    HRESULT _GetDisplayNameFromSelf(LPCIDLREGITEM pidlr, DWORD dwFlags, LPTSTR pszName, UINT cchName);
    HRESULT _GetDisplayName(LPCIDLREGITEM pidlr, DWORD dwFlags, LPTSTR pszName, UINT cchName);
    HRESULT _DeleteRegItem(LPCIDLREGITEM pidlr);
    BOOL _GetDeleteMessage(LPCIDLREGITEM pidlr, LPTSTR pszMsg, int cchMax);

    HRESULT _ParseNextLevel(HWND hwnd, LPBC pbc, LPCIDLREGITEM pidlr,
                            LPOLESTR pwzRest, LPITEMIDLIST *ppidlOut, ULONG *pdwAttributes);

    HRESULT _ParseGUIDName(HWND hwnd, LPBC pbc, LPOLESTR pwzDisplayName, 
                           LPITEMIDLIST *ppidlOut, ULONG *pdwAttributes);

    HRESULT _ParseThroughItem(LPCIDLREGITEM pidlr, HWND hwnd, LPBC pbc,
                              LPOLESTR pszName, ULONG *pchEaten,
                              LPITEMIDLIST *ppidlOut, ULONG *pdwAttributes);
    HRESULT _SetAttributes(LPCIDLREGITEM pidlr, BOOL bPerUser, DWORD dwMask, DWORD dwNewBits);
    LONG _RegOpenCLSIDUSKey(CLSID clsid, PHUSKEY phk);
    ULONG _GetPerUserAttributes(LPCIDLREGITEM pidlr);
    HRESULT _AttributesOf(LPCIDLREGITEM pidlr, DWORD dwAttributesNeeded, DWORD *pdwAttributes);
    HRESULT _CreateDefExtIconKey(HKEY hkey, UINT cidl, LPCITEMIDLIST *apidl, int iItem,
                                 REFIID riid, void** ppvOut);
    BOOL _CanDelete(LPCIDLREGITEM pidlr);
    void _Delete(HWND hwnd, UINT uFlags, IDataObject *pdtobj);
    HRESULT _AssocCreate(LPCIDLREGITEM pidl, REFIID riid, void **ppv);
    //
    // inline
    //

    // Will probably not be expanded inline as _GetOrderPure is a behemoth of a fct
    void _FillIDList(const CLSID *pclsid, IDLREGITEM *pidlr)
    {
        pidlr->idri.cb = sizeof(pidlr->idri) + (WORD)_cbPadding;
        pidlr->idri.bFlags = _bFlags;
        _SetPIDLRCLSID(pidlr, pclsid);
        pidlr->idri.bOrder = _GetOrderPure((LPCIDLREGITEM)pidlr);
    };

    BOOL _IsDesktop() { return ILIsEmpty(_GetFolderIDList()); }

    int _MapToOuterColNo(int iCol);

    // CompareIDs Helpers
    int _CompareIDsOriginal(LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);
    int _CompareIDsFolderFirst(UINT iColumn, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);
    int _CompareIDsAlphabetical(UINT iColumn, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2);

    BOOL _IsFolder(LPCITEMIDLIST pidl);
    HRESULT _CreateViewObjectFor(LPCIDLREGITEM pidlr, HWND hwnd, REFIID riid, void **ppv, BOOL bOneLevel);

private:
    inline UNALIGNED CLSID& _GetPIDLRCLSID(LPCIDLREGITEM pidlr);
    inline void _SetPIDLRCLSID(LPIDLREGITEM pidlr, const CLSID *pclsid);
    inline IDLREGITEM* _CreateAndFillIDLREGITEM(const CLSID *pclsid);

    BOOL _GetNameFromCache(REFCLSID rclsid, DWORD dwFlags, LPTSTR pszName, UINT cchName);
    inline void _ClearNameFromCache();
    void _SaveNameInCache(REFCLSID rclsid, DWORD dwFlags, LPTSTR pszName);
    
private:
    enum { c_dwSignature = 0x38394450 }; // "PD98" - PowerDesk 98 hack
    DWORD           _dwSignature;
    LPTSTR          _pszMachine;
    LPITEMIDLIST    _pidl;

    IShellFolder2   *_psfOuter;
    IShellIconOverlay *_psioOuter;

    IPersistFreeThreadedObject *_pftoReg;   // cached pointer of last free threaded bind

    int             _iTypeOuter;            // default sort order for outer items
    LPCTSTR         _pszRegKey;
    LPCTSTR         _pszSesKey;
    REGITEMSPOLICY*  _pPolicy;
    TCHAR           _chRegItem;         // parsing prefix, must be TEXT(':')
    BYTE            _bFlags;            // flags field for PIDL construction
    DWORD           _dwDefAttributes;   // default attributes for items
    int             _nRequiredItems;    // # of required items
    DWORD           _dwSortAttrib;      // sorting attributes
    DWORD           _cbPadding;         // see comment in views.h      
    BYTE            _bFlagsLegacy;      // see comment in views.h

    CLSID           _clsidAttributesCache;
    ULONG           _dwAttributesCache;
    ULONG           _dwAttributesCacheValid;
    LONG            _lNameCacheInterlock;
    DWORD           _dwNameCacheTime;
    CLSID           _clsidNameCache;
    DWORD           _dwFlagsNameCache;
    TCHAR           _szNameCache[64];
    REQREGITEM      *_aReqItems;

    IPersistFreeThreadedObject *_pftoDelegate;

    CRITICAL_SECTION _cs;

    friend DWORD CALLBACK _RegFolderPropThreadProc(void *pv);
    friend HRESULT CRegFolder_CreateInstance(REGITEMSINFO *pri, IUnknown *punkOuter, REFIID riid, void **ppv);
    friend CRegFolderEnum;
};  

class CRegFolderEnum : public CObjectWithSite, IEnumIDList
{
public:
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppvObj);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IEnumIDList
    STDMETHODIMP Next(ULONG celt, LPITEMIDLIST *rgelt, ULONG *pceltFetched);
    STDMETHODIMP Skip(ULONG celt) { return E_NOTIMPL; };
    STDMETHODIMP Reset();
    STDMETHODIMP Clone(IEnumIDList **ppenum) { return E_NOTIMPL; };

    // IObjectWithSite
    STDMETHODIMP SetSite(IUnknown* punkSite); // we need to override this

protected:
    CRegFolderEnum(CRegFolder* prf, DWORD grfFlags, IEnumIDList* pesf, HDCA dcaItems, HDCA dcaDel, REGITEMSPOLICY* pPolicy);
    ~CRegFolderEnum();
    BOOL _IsRestricted();
    BOOL _WrongMachine();
    BOOL _TestFolderness(DWORD dwAttribItem);
    BOOL _TestHidden(LPCIDLREGITEM pidlRegItem);
    BOOL _TestHiddenInWebView(LPCLSID clsidRegItem);
    BOOL _TestHiddenInDomain(LPCLSID clsidRegItem);

private:
    LONG         _cRef;
    CRegFolder*  _prf;          // reg item folder
    IEnumIDList* _peidl;
    DWORD        _grfFlags;     // guy we are wrapping
    REGITEMSPOLICY* _pPolicy;   // controls what items are visible

    HDCA         _hdca;         // DCA of regitem objects
    INT          _iCur;

    HDCA        _hdcaDel;       // delegate shell folder;
    INT         _iCurDel;       // index into the delegate folder DCA.
    IEnumIDList *_peidlDel;     // delegate folder enumerator

    friend CRegFolder;
};

STDAPI CDelegateMalloc_Create(void *pv, SIZE_T cbSize, WORD wOuter, IMalloc **ppmalloc);

HRESULT ShowHideIconOnlyOnDesktop(const CLSID *pclsid, int StartIndex, int EndIndex, BOOL fHide);

//
// Construction / Destruction and aggregation
//

CRegFolder::CRegFolder(IUnknown *punkOuter) : 
    _dwSignature(c_dwSignature),
    CAggregatedUnknown(punkOuter),
    _pidl(NULL),
    _pszMachine(NULL),
    _psfOuter(NULL),
    _lNameCacheInterlock(-1)
{
    DllAddRef();
    InitializeCriticalSection(&_cs);
}

CRegFolder::~CRegFolder()
{
    IUnknown *punkCached = (IUnknown *)InterlockedExchangePointer((void**)&_pftoReg, NULL);
    if (punkCached)
        punkCached->Release();
        
    punkCached = (IUnknown *)InterlockedExchangePointer((void**)&_pftoDelegate, NULL);
    if (punkCached)
        punkCached->Release();

    ILFree(_pidl);
    Str_SetPtr(&_pszMachine, NULL);
    LocalFree(_aReqItems);

    SHReleaseOuterInterface(_GetOuter(), (IUnknown **)&_psfOuter);     // release _psfOuter
    SHReleaseOuterInterface(_GetOuter(), (IUnknown **)&_psioOuter);

    DeleteCriticalSection(&_cs);       
    DllRelease();
}

HRESULT CRegFolder::v_InternalQueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = {
        QITABENTMULTI(CRegFolder, IShellFolder, IShellFolder2), // IID_IShellFolder
        QITABENT(CRegFolder, IShellFolder2),                    // IID_IShellFolder2
        QITABENT(CRegFolder, IShellIconOverlay),                // IID_IShellIconOverlay
        { 0 },
    };
    HRESULT hr = QISearch(this, qit, riid, ppv);
    if (FAILED(hr) && IsEqualIID(CLSID_RegFolder, riid))
    {
        *ppv = this;                // not ref counted
        hr = S_OK;
    }
    return hr;
}


//
// get the pidl used to initialize this namespace
//

LPCITEMIDLIST CRegFolder::_GetFolderIDList()
{
    if (!_pidl)
        SHGetIDListFromUnk(_psfOuter, &_pidl);

    return _pidl;
}

//
// check to see if this pidl is a regitem
//

LPCIDLREGITEM CRegFolder::_IsReg(LPCITEMIDLIST pidl)
{
    if (pidl && !ILIsEmpty(pidl))
    {
        LPCIDLREGITEM pidlr = (LPCIDLREGITEM)pidl;
        if ((pidlr->idri.bFlags == _bFlags) && 
            ((pidl->mkid.cb >= (sizeof(pidlr->idri) + (WORD)_cbPadding)) || _IsDelegate(pidlr)))
        {
            return pidlr;
        }
        else if (_cbPadding && _bFlagsLegacy && (pidlr->idri.bFlags == _bFlagsLegacy))
        {
            // We needed to add padding to the Control Panel regitems.  There was CP
            // regitems out there without the padding.  If there is padding and we fail
            // the above case then maybe we are dealing with one of these. (stephstm)
            return pidlr;
        }
    }
    return NULL;
}

PDELEGATEITEMID CRegFolder::_IsDelegate(LPCIDLREGITEM pidlr)
{
    PDELEGATEITEMID pidld = (PDELEGATEITEMID)pidlr;             // save casting below
    if ((pidld->cbSize > sizeof(*pidld)) && 
        /* note, (int) casts needed to force signed evaluation as we need the < 0 case */
        (((int)pidld->cbSize - (int)pidld->cbInner) >= (int)sizeof(DELEGATEITEMDATA)))
    {
        PDELEGATEITEMDATA pdeidl = (PDELEGATEITEMDATA)&pidld->rgb[pidld->cbInner];
        const CLSID clsid = pdeidl->clsidSignature;    // alignment
        if (IsEqualGUID(clsid, CLSID_DelegateItemSig))
        {                
            return pidld;
        }
    }
    return NULL;
}

BOOL CRegFolder::_AllDelegates(UINT cidl, LPCITEMIDLIST *apidl, IShellFolder **ppsf)
{
    *ppsf = NULL;
    PDELEGATEITEMID pidld = NULL;
    CLSID clsid, clsidFirst;
    for (UINT i = 0; i < cidl; i++)
    {
        LPCIDLREGITEM pidlr = _IsReg(apidl[i]);
        if (pidlr)
        {
            pidld = _IsDelegate(pidlr);
            if (pidld)
            {
                if (i == 0)
                {
                    // get the clsid of the first guy
                    clsidFirst = _GetPIDLRCLSID(pidlr);
                }
                else if (clsid = _GetPIDLRCLSID(pidlr), clsidFirst != clsid)
                {
                    pidld = NULL;   // not from the same delegate
                    break;
                }
            }
            else
            {
                break;
            }
        }
        else
        {
            pidld = NULL;
            break;
        }
    }

    return pidld && SUCCEEDED(_GetDelegateFolder(pidld, IID_PPV_ARG(IShellFolder, ppsf)));
}

__inline IPersistFreeThreadedObject *ExchangeFTO(IPersistFreeThreadedObject **ppfto, IPersistFreeThreadedObject *pfto)
{
    return (IPersistFreeThreadedObject *)InterlockedExchangePointer((void**)ppfto, pfto);
}

HRESULT CRegFolder::_CreateDelegateFolder(const CLSID* pclsid, REFIID riid, void **ppv)
{
    HRESULT hr;

    *ppv = NULL;

    // try using the cached delegate (if it exists)
    IPersistFreeThreadedObject *pfto = ExchangeFTO(&_pftoDelegate, NULL);
    if (pfto)
    {
        CLSID clsidT;
        if (SUCCEEDED(pfto->GetClassID(&clsidT)) && IsEqualGUID(clsidT, *pclsid))
        {
            // if this fails, ppv will still be NULL
            // so we will create a new cache item...
            hr = pfto->QueryInterface(riid, ppv);
        }
    }
   
    if (NULL == *ppv)
    {
        IDelegateFolder *pdel;
        hr = SHExtCoCreateInstance(NULL, pclsid, NULL, IID_PPV_ARG(IDelegateFolder, &pdel));
        if (SUCCEEDED(hr))
        {
            DELEGATEITEMDATA delid = { 0 };
            delid.clsidSignature = CLSID_DelegateItemSig;
            delid.clsidShellFolder = *pclsid;

            IMalloc *pm;
            hr = CDelegateMalloc_Create(&delid, sizeof(delid), _bFlags, &pm);
            if (SUCCEEDED(hr))
            {
                hr = pdel->SetItemAlloc(pm);
                if (SUCCEEDED(hr))
                {
                    IPersistFolder *ppf;
                    if (SUCCEEDED(pdel->QueryInterface(IID_PPV_ARG(IPersistFolder, &ppf))))
                    {
                        hr = ppf->Initialize(_GetFolderIDList());
                        ppf->Release();
                    }

                    if (SUCCEEDED(hr))
                        hr = pdel->QueryInterface(riid, ppv);
                }
                pm->Release();
            }

            // now, we might be able to cache this guy if he is "free threaded"
            if (SUCCEEDED(hr))
            {
                if (pfto)
                {
                    pfto->Release();
                    pfto = NULL;
                }

                if (SUCCEEDED(pdel->QueryInterface(IID_PPV_ARG(IPersistFreeThreadedObject, &pfto))))
                {
                    SHPinDllOfCLSID(pclsid);
                }
            }

            pdel->Release();
        }
    }

    if (pfto)
    {
        pfto = ExchangeFTO(&_pftoDelegate, pfto);
        if (pfto)
            pfto->Release();    //  protect against race condition or re-entrancy
    }

    return hr;
}
    
HRESULT CRegFolder::_GetDelegateFolder(PDELEGATEITEMID pidld, REFIID riid, void **ppv)
{    
    PDELEGATEITEMDATA pdeidl = (PDELEGATEITEMDATA)&pidld->rgb[pidld->cbInner];
    CLSID clsid = pdeidl->clsidShellFolder; // alignment
    return _CreateDelegateFolder(&clsid, riid, ppv);
}

//
// returns a ~REFERENCE~ to the CLSID in the pidlr.  HintHint: the ref has
// the same scope as the pidlr.  This is to replace the pidlr->idri.clsid
// usage. (stephstm)
//

UNALIGNED CLSID& CRegFolder::_GetPIDLRCLSID(LPCIDLREGITEM pidlr)
{
#ifdef DEBUG
    if (_cbPadding && (_bFlagsLegacy != pidlr->idri.bFlags))
    {
        LPIDREGITEMEX pidriex = (LPIDREGITEMEX)&(pidlr->idri);

        for (DWORD i = 0; i < _cbPadding; ++i)
        {
            ASSERT(0 == pidriex->rgbPadding[i]);
        }
    }
#endif

    PDELEGATEITEMID pidld = _IsDelegate(pidlr);
    if (pidld)
    {
        PDELEGATEITEMDATA pdeidl = (PDELEGATEITEMDATA)&pidld->rgb[pidld->cbInner];
        return pdeidl->clsidShellFolder;
    }

    return (pidlr->idri.bFlags != _bFlagsLegacy) ?
        // return the new padded clsid
        ((UNALIGNED CLSID&)((LPIDREGITEMEX)&(pidlr->idri))->rgbPadding[_cbPadding]) :
        // return the old non-padded clsid
        (pidlr->idri.clsid);
}

// This fct is called only for IDREGITEMs created within this file.  It is not
// called for existing PIDL, so we do not need to check if it is a legacy pidl.
void CRegFolder::_SetPIDLRCLSID(LPIDLREGITEM pidlr, const CLSID *pclsid)
{
    LPIDREGITEMEX pidriex = (LPIDREGITEMEX)&(pidlr->idri);

    ((UNALIGNED CLSID&)pidriex->rgbPadding[_cbPadding]) = *pclsid;

    ZeroMemory(pidriex->rgbPadding, _cbPadding);
}

IDLREGITEM* CRegFolder::_CreateAndFillIDLREGITEM(const CLSID *pclsid)
{
    IDLREGITEM* pidlRegItem = (IDLREGITEM*)_ILCreate(sizeof(IDLREGITEM) + _cbPadding);

    if (pidlRegItem)
    {
        _FillIDList(pclsid, pidlRegItem);
    }

    return pidlRegItem;
}

//
// Returns: ptr to the first reg item if there are any
//

LPCIDLREGITEM CRegFolder::_AnyRegItem(UINT cidl, LPCITEMIDLIST apidl[])
{
    for (UINT i = 0; i < cidl; i++) 
    {
        LPCIDLREGITEM pidlr = _IsReg(apidl[i]);
        if (pidlr)
            return pidlr;
    }
    return NULL;
}


int CRegFolder::_ReqItemIndex(LPCIDLREGITEM pidlr)
{
    const CLSID clsid = _GetPIDLRCLSID(pidlr);    // alignment

    for (int i = _nRequiredItems - 1; i >= 0; i--)
    {
        if (IsEqualGUID(clsid, *_aReqItems[i].pclsid))
        {
            break;
        }
    }
    return i;
}


//
// a sort order of 0 means there is not specified sort order for this item
//

BYTE CRegFolder::_GetOrderPure(LPCIDLREGITEM pidlr)
{
    BYTE bRet;
    int i = _ReqItemIndex(pidlr);
    if (i != -1)
    {
        bRet = _aReqItems[i].bOrder;
    }
    else
    {
        HKEY hkey;
        TCHAR szKey[MAX_PATH], szCLSID[GUIDSTR_MAX];

        SHStringFromGUID(_GetPIDLRCLSID(pidlr), szCLSID, ARRAYSIZE(szCLSID));
        wsprintf(szKey, TEXT("CLSID\\%s"), szCLSID);

        bRet = 128;     // default for items that do not register a SortOrderIndex

        if (RegOpenKey(HKEY_CLASSES_ROOT, szKey, &hkey) == ERROR_SUCCESS)
        {
            DWORD dwOrder, cbSize = sizeof(dwOrder);
            if (SHQueryValueEx(hkey, TEXT("SortOrderIndex"), NULL, NULL, (BYTE *)&dwOrder, &cbSize) == ERROR_SUCCESS)
            {

                // B#221890 - PowerDesk assumes that it can do this:
                //      Desktop -> First child -> Third child
                // and it will get the C: drive.  This means that
                // My Computer must be the first regitem.  So any items
                // in front of My Computer are put immediately behind.
                if ((SHGetAppCompatFlags(ACF_MYCOMPUTERFIRST) & ACF_MYCOMPUTERFIRST) &&
                    dwOrder <= SORT_ORDER_DRIVES)
                    dwOrder = SORT_ORDER_DRIVES + 1;

                bRet = (BYTE)dwOrder;
            }
            RegCloseKey(hkey);
        }
    }
    return bRet;
}

BYTE CRegFolder::_GetOrder(LPCIDLREGITEM pidlr)
{
    if (!_IsDelegate(pidlr))
    {
        // If the bOrder values are less than 0x40, then they are the old values
        // Therefore compute the new bOrder values for these cases.
        if (pidlr->idri.bOrder <= 0x40) 
            return _GetOrderPure(pidlr);
        else 
            return pidlr->idri.bOrder;
    }
    else
        return 128;
}

LPITEMIDLIST CRegFolder::_CreateIDList(const CLSID *pclsid)
{
    return (LPITEMIDLIST)_CreateAndFillIDLREGITEM(pclsid);
}


LPITEMIDLIST CRegFolder::_CreateSimpleIDList(const CLSID *pclsid, BYTE bFlags, BOOL bOrder)
{
    IDLREGITEM* pidlRegItem = (IDLREGITEM*)_CreateIDList(pclsid);

    if (pidlRegItem)
    {
        pidlRegItem->idri.cb = sizeof(pidlRegItem->idri) + (WORD)_cbPadding;
        pidlRegItem->idri.bFlags = bFlags;
        pidlRegItem->idri.bOrder = (BYTE) bOrder;
        _SetPIDLRCLSID(pidlRegItem, pclsid);
    }

    return (LPITEMIDLIST)pidlRegItem;
}


//
// validate that this item exists in this name space (look in the registry)
//

BOOL CRegFolder::_IsInNameSpace(LPCIDLREGITEM pidlr)
{
    TCHAR szKeyName[MAX_PATH];

    if (_IsDelegate(pidlr))
        return FALSE;                    // its a delegate, therefore by default its transient

    if (_ReqItemIndex(pidlr) >= 0)
        return TRUE;

    // HACKHACK: we will return TRUE for Printers, N/W connections and Scheduled tasks
    //           since they've been moved from My Computer to Control Panel and they
    //           don't really care where they live

    const CLSID clsid = _GetPIDLRCLSID(pidlr); // alignment

    if (IsEqualGUID(CLSID_Printers, clsid) ||
        IsEqualGUID(CLSID_NetworkConnections, clsid) ||
        IsEqualGUID(CLSID_ScheduledTasks, clsid))
    {
        return TRUE;
    }

    _GetNameSpaceKey(pidlr, szKeyName);

   // Note that we do not look in the session key,
   // since it by definition is transient

    return (SHRegQueryValue(HKEY_LOCAL_MACHINE, szKeyName, NULL, NULL) == ERROR_SUCCESS) ||
           (SHRegQueryValue(HKEY_CURRENT_USER,  szKeyName, NULL, NULL) == ERROR_SUCCESS);
}

//
//  The "Session key" is a volatile registry key unique to this session.
//  A session is a single continuous logon.  If Explorer crashes and is
//  auto-restarted, the two Explorers share the same session.  But if you
//  log off and back on, that new Explorer is a new session.
//

//
//  The s_SessionKeyName is the name of the session key relative to
//  REGSTR_PATH_EXPLORER\SessionInfo.  On NT, this is normally the
//  Authentication ID, but we pre-initialize it to something safe so
//  we don't fault if for some reason we can't get to it.  Since
//  Win95 supports only one session at a time, it just stays at the
//  default value.
//
//  Sometimes we want to talk about the full path (SessionInfo\BlahBlah)
//  and sometimes just the partial path (BlahBlah) so we wrap it inside
//  this goofy structure.
//

union SESSIONKEYNAME {
    TCHAR szPath[12+16+1];
    struct {
        TCHAR szSessionInfo[12];    // strlen("SessionInfo\\")
        TCHAR szName[16+1];         // 16 = two DWORDs converted to hex
    };
} s_SessionKeyName = {
    { TEXT("SessionInfo\\.Default") }
};

BOOL g_fHaveSessionKeyName = FALSE;

//
//  samDesired = a registry security access mask, or the special value
//               0xFFFFFFFF to delete the session key.
//  phk        = receives the session key on success
//
//  NOTE!  Only Explorer should delete the session key (when the user
//         logs off).
//
STDAPI SHCreateSessionKey(REGSAM samDesired, HKEY *phk)
{
    LONG lRes;

    *phk = NULL;

    if (!g_fHaveSessionKeyName)
    {
        ENTERCRITICAL;

        //
        //  Build the name of the session key.  We use the authentication ID
        //  which is guaranteed to be unique forever.  We can't use the
        //  Hydra session ID since that can be recycled.
        //
        //  Note: Do not use OpenThreadToken since it will fail if the
        //  thread is not impersonating.  People who do impersonation
        //  cannot use SHCreateSessionKey anyway since we cache the
        //  session key on the assumption that there is no impersonation
        //  going on.  (And besides, HKCU is wrong when impersonating.)
        //
        HANDLE hToken;
        if (OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hToken))
        {
            TOKEN_STATISTICS stats;
            DWORD cbOut;

            if (GetTokenInformation(hToken, TokenStatistics, &stats, sizeof(stats), &cbOut))
            {
                wsprintf(s_SessionKeyName.szName, TEXT("%08x%08x"),
                         stats.AuthenticationId.HighPart,
                         stats.AuthenticationId.LowPart);
                g_fHaveSessionKeyName = TRUE;
            }
            CloseHandle(hToken);
        }

        LEAVECRITICAL;
    }

    HKEY hkExplorer = SHGetShellKey(SHELLKEY_HKCU_EXPLORER, NULL, TRUE);
    if (hkExplorer)
    {
        if (samDesired != 0xFFFFFFFF)
        {
            DWORD dwDisposition;
            lRes = RegCreateKeyEx(hkExplorer, s_SessionKeyName.szPath, 0,
                           NULL,
                           REG_OPTION_VOLATILE,
                           samDesired,
                           NULL,
                           phk,
                           &dwDisposition);
        }
        else
        {
            lRes = SHDeleteKey(hkExplorer, s_SessionKeyName.szPath);
        }

        RegCloseKey(hkExplorer);
    }
    else
    {
        lRes = ERROR_ACCESS_DENIED;
    }
    return HRESULT_FROM_WIN32(lRes);
}

//
// We use a HDCA to store the CLSIDs for the regitems in this folder, this call returns
// that HDCA>
//

HDCA CRegFolder::_ItemArray()
{
    HDCA hdca = DCA_Create();
    if (hdca)
    {
        for (int i = 0; i < _nRequiredItems; i++)
        {
            DCA_AddItem(hdca, *_aReqItems[i].pclsid);
        }

        DCA_AddItemsFromKey(hdca, HKEY_LOCAL_MACHINE, _pszRegKey);
        DCA_AddItemsFromKey(hdca, HKEY_CURRENT_USER,  _pszRegKey);

        if (_pszSesKey)
        {
            HKEY hkSession;
            if (SUCCEEDED(SHCreateSessionKey(KEY_READ, &hkSession)))
            {
                DCA_AddItemsFromKey(hdca, hkSession, _pszSesKey);
                RegCloseKey(hkSession);
            }
        }

    }
    return hdca;
}


HDCA CRegFolder::_DelItemArray()
{
    HDCA hdca = DCA_Create();
    if (hdca)
    {
        TCHAR szKey[MAX_PATH*2];
        wnsprintf(szKey, ARRAYSIZE(szKey), TEXT("%s\\DelegateFolders"), _pszRegKey);
        DCA_AddItemsFromKey(hdca, HKEY_LOCAL_MACHINE, szKey);
        DCA_AddItemsFromKey(hdca, HKEY_CURRENT_USER, szKey);

        if (_pszSesKey)
        {
            HKEY hkSession;
            if (SUCCEEDED(SHCreateSessionKey(KEY_READ, &hkSession)))
            {
                wnsprintf(szKey, ARRAYSIZE(szKey), TEXT("%s\\DelegateFolders"), _pszSesKey);
                DCA_AddItemsFromKey(hdca, hkSession, szKey);
                RegCloseKey(hkSession);
            }
        }
    }
    return hdca;
}


//
// Given our cached machine name, attempt get the object on that machine.
//

HRESULT CRegFolder::_InitFromMachine(IUnknown *punk, BOOL bEnum)
{
    HRESULT hr = S_OK;
    if (_pszMachine)
    {
        // prior to Win2K there was IRemoteComputerA/W, we removed IRemoteComputerA and
        // made IRemoteComputer map to the W version of the API, therefore we 
        // thunk the string to its wide version before calling the Initialize method. (daviddv 102099)

        IRemoteComputer * premc;
        hr = punk->QueryInterface(IID_PPV_ARG(IRemoteComputer, &premc));
        if (SUCCEEDED(hr))
        {
            WCHAR wszName[MAX_PATH];
            SHTCharToUnicode(_pszMachine, wszName, ARRAYSIZE(wszName));
            hr = premc->Initialize(wszName, bEnum);
            premc->Release();
        }
    }
    return hr;
}

//
// Given a pidl, lets get an instance of the namespace that provides it.
//  - handles caching accordingly
//

HRESULT CRegFolder::_CreateAndInit(LPCIDLREGITEM pidlr, LPBC pbc, REFIID riid, void **ppv)
{
    *ppv = NULL;

    HRESULT hr = E_FAIL;
    PDELEGATEITEMID pidld = _IsDelegate(pidlr);
    if (pidld)
    {
        IShellFolder *psf;
        hr = _GetDelegateFolder(pidld, IID_PPV_ARG(IShellFolder, &psf));
        if (SUCCEEDED(hr))
        {
            hr = psf->BindToObject((LPCITEMIDLIST)pidlr, pbc, riid, ppv);
            psf->Release();
        }
    }
    else
    {
        CLSID clsid = _GetPIDLRCLSID(pidlr); // alignment

        //  try using the cached pointer
        IPersistFreeThreadedObject *pfto = ExchangeFTO(&_pftoReg, NULL);
        if (pfto)
        {
            CLSID clsidT;
            if (SUCCEEDED(pfto->GetClassID(&clsidT)) && IsEqualGUID(clsidT, clsid))
            {
                // if this fails, ppv will still be NULL
                // so we will create a new cache item...
                hr = pfto->QueryInterface(riid, ppv);
            }
        }

        // cache failed, cocreate it ourself
        if (NULL == *ppv)
        {
            OBJCOMPATFLAGS ocf = SHGetObjectCompatFlags(NULL, &clsid);

            if (!(OBJCOMPATF_UNBINDABLE & ocf))
            {
                //
                //  HACKHACK - some regitems can only be CoCreated with IID_IShellFolder
                //  specifically the hummingbird shellext will DebugBreak() bringing
                //  down the shell...  but we can CoCreate() and then QI after...
                //
            
                hr = SHExtCoCreateInstance(NULL, &clsid, NULL, 
                    (OBJCOMPATF_COCREATESHELLFOLDERONLY & ocf) ? IID_IShellFolder : riid , ppv);

                if (SUCCEEDED(hr))
                {
                    IUnknown *punk = (IUnknown *)*ppv;  // avoid casts below

                    if ((OBJCOMPATF_COCREATESHELLFOLDERONLY & ocf))
                    {
                        hr = punk->QueryInterface(riid, ppv);
                        punk->Release();
                        punk = (IUnknown *)*ppv;  // avoid casts below
                    }

                    if (SUCCEEDED(hr))
                    {
                        hr = _InitFromMachine(punk, FALSE);
                        if (SUCCEEDED(hr))
                        {
                            IPersistFolder *ppf;
                            if (SUCCEEDED(punk->QueryInterface(IID_PPV_ARG(IPersistFolder, &ppf))))
                            {
                                LPITEMIDLIST pidlAbs = ILCombine(_GetFolderIDList(), (LPCITEMIDLIST)pidlr);
                                if (pidlAbs)
                                {
                                    hr = ppf->Initialize(pidlAbs);
                                    ILFree(pidlAbs);
                                }
                                else
                                {
                                    hr = E_OUTOFMEMORY;
                                }
                                ppf->Release();
                            }

                            if (SUCCEEDED(hr))
                            {
                                if (pfto)
                                {
                                    pfto->Release();    //  we are going to replace the cache
                                    pfto = NULL;
                                }
                                if (SUCCEEDED(punk->QueryInterface(IID_PPV_ARG(IPersistFreeThreadedObject, &pfto))))
                                {
                                    SHPinDllOfCLSID(&clsid);
                                }
                            }
                        }

                        if (FAILED(hr))
                        {
                            // we're going to return failure -- don't leak the object we created
                            punk->Release();
                            *ppv = NULL;
                        }
                    }
                }
            }
        }

        // recache the pfto
        if (pfto)
        {
            pfto = ExchangeFTO(&_pftoReg, pfto);
            if (pfto)
                pfto->Release();    //  protect against race condition or re-entrancy
        }
    }
    return hr;
}


//
// lets the reg item itself pick off the GetDisplayNameOf() impl for itself. this lets
// MyDocs on the desktop return c:\win\profile\name\My Documents as it's parsing name
//
// returns:
//      S_FALSE     do normal parsing, reg item did not handel
//
//

HRESULT CRegFolder::_GetDisplayNameFromSelf(LPCIDLREGITEM pidlr, DWORD dwFlags, LPTSTR pszName, UINT cchName)
{
    HRESULT hr        = S_FALSE;     // normal case
    const CLSID clsid = _GetPIDLRCLSID(pidlr);    // alignment
    BOOL bGetFromSelf = FALSE;
    const BOOL bForParsingOnly = ((dwFlags & (SHGDN_FORADDRESSBAR | SHGDN_INFOLDER | SHGDN_FORPARSING)) == SHGDN_FORPARSING);

    if (bForParsingOnly)
    {
        if (SHQueryShellFolderValue(&clsid, TEXT("WantsFORPARSING")))
        {
            bGetFromSelf = TRUE;
        }
    }
    else
    {
        const BOOL bForParsing    = (0 != (dwFlags & SHGDN_FORPARSING));
        const BOOL bForAddressBar = (0 != (dwFlags & SHGDN_FORADDRESSBAR));
        if (!bForParsing || bForAddressBar)
        {
            if (SHQueryShellFolderValue(&clsid, TEXT("WantsFORDISPLAY")))
            {
                bGetFromSelf = TRUE;
            }
        }
    }
    if (bGetFromSelf)
    {
        IShellFolder *psf;
        if (SUCCEEDED(_BindToItem(pidlr, NULL, IID_PPV_ARG(IShellFolder, &psf), TRUE)))
        {
            //
            // Pass NULL pidl (c_idlDesktop) to get display name of the folder itself.
            // Note that we can't use DisplayNameOf() because that function 
            // eats the S_FALSE that can be returned from the
            // IShellFolder::GetDisplayNameOf implementation to indicate
            // "do the default thing".
            //
            STRRET sr;
            hr = psf->GetDisplayNameOf(&c_idlDesktop, dwFlags, &sr);
            if (S_OK == hr)
            {
                hr = StrRetToBuf(&sr, &c_idlDesktop, pszName, cchName);
            }
            psf->Release();
        }
    }
    return hr;
}


//
//  Managing the name cache is tricky because it is hit frequently on
//  multiple threads, and collisions are frequent.  E.g., one thread
//  does a SetNameOf+SHChangeNotify, and multiple other threads try
//  to pull the name out simultaneously.  If you're not careful, these
//  threads step on each other and some poor schmuck gets invalid data.
//
//  _lNameCacheInterlock = -1 if nobody is using the name cache, else >= 0
//
//  Therefore, if InterlockedIncrement(&_lNameCacheInterlock) == 0, then
//  you are the sole owner of the cache.  Otherwise, the cache is busy
//  and you should get out.
//
//  Furthermore, we don't use the name cache if it is more than 500ms stale.
//
BOOL CRegFolder::_GetNameFromCache(REFCLSID rclsid, DWORD dwFlags, LPTSTR pszName, UINT cchName)
{
    BOOL fSuccess = FALSE;

    // Quick check to avoid entering the interlock unnecessarily
    if (rclsid.Data1 == _clsidNameCache.Data1 &&
        GetTickCount() - _dwNameCacheTime < 500)
    {
        if (InterlockedIncrement(&_lNameCacheInterlock) == 0)
        {
            if (IsEqualGUID(rclsid, _clsidNameCache) &&
                (_dwFlagsNameCache == dwFlags))
            {
                StrCpyN(pszName, _szNameCache, cchName);
                fSuccess = TRUE;
            }
        }
        InterlockedDecrement(&_lNameCacheInterlock);
    }
    return fSuccess;
}

void CRegFolder::_ClearNameFromCache()
{
    _clsidNameCache = CLSID_NULL;
}

void CRegFolder::_SaveNameInCache(REFCLSID rclsid, DWORD dwFlags, LPTSTR pszName)
{
    if (lstrlen(pszName) < ARRAYSIZE(_szNameCache))
    {
        if (InterlockedIncrement(&_lNameCacheInterlock) == 0)
        {
            lstrcpy(_szNameCache, pszName);
            _dwFlagsNameCache = dwFlags;
            _clsidNameCache = rclsid;
            _dwNameCacheTime = GetTickCount();
        }
        InterlockedDecrement(&_lNameCacheInterlock);
    }
}


//
// Given a pidl in the regitms folder, get the friendly name for this (trying the user
// store ones, then the global one).
//

#define GUIDSIZE    50

HRESULT CRegFolder::_GetDisplayName(LPCIDLREGITEM pidlr, DWORD dwFlags, LPTSTR pszName, UINT cchName)
{
    *pszName = 0;

    PDELEGATEITEMID pidld = _IsDelegate(pidlr);
    if (pidld)
    {
        IShellFolder *psf;
        HRESULT hr = _GetDelegateFolder(pidld, IID_PPV_ARG(IShellFolder, &psf));
        if (SUCCEEDED(hr))
        {
            hr = DisplayNameOf(psf, (LPCITEMIDLIST)pidlr, dwFlags, pszName, cchName);
            psf->Release();                
        }
        return hr;
    }
    else
    {
        HKEY hkCLSID;
        CLSID clsid = _GetPIDLRCLSID(pidlr);

        if (_GetNameFromCache(clsid, dwFlags, pszName, cchName))
        {
            // Satisfied from cache; all done!
        }
        else
        {
            HRESULT hr = _GetDisplayNameFromSelf(pidlr, dwFlags, pszName, cchName);
            if (hr != S_FALSE)
                return hr;

            if (dwFlags & SHGDN_FORPARSING)
            {
                if (!(dwFlags & SHGDN_FORADDRESSBAR))
                {
                    // Get the parent folder name
                    TCHAR szParentName[MAX_PATH];
                    szParentName[0] = 0;
                    if (!(dwFlags & SHGDN_INFOLDER) && !ILIsEmpty(_GetFolderIDList()))
                    {
                        SHGetNameAndFlags(_GetFolderIDList(), SHGDN_FORPARSING, szParentName, SIZECHARS(szParentName), NULL);
                        StrCatBuff(szParentName, TEXT("\\"), ARRAYSIZE(szParentName));                
                    }

                    // Win95 didn't support SHGDN_FORPARSING on regitems; it always
                    // returned the display name.  Norton Unerase relies on this,
                    // because it assumes that if the second character of the FORPARSING
                    // name is a colon, then it's a drive.  Therefore, we can't return
                    // ::{guid} or Norton will fault.  (I guess they didn't believe in
                    // SFGAO_FILESYSTEM.)  So if we are Norton Unerase, then ignore
                    // the FORPARSING flag; always get the name for display.
                    // And good luck to any user who sets his computer name to something
                    // with a colon as the second character...

                    if (SHGetAppCompatFlags(ACF_OLDREGITEMGDN) & ACF_OLDREGITEMGDN)
                    {

                        // In Application compatibility mode turn SHGDN_FORPARSING
                        // off and fall thru to the remainder of the function which
                        // avoids the ::{GUID} when required.
                    
                        dwFlags &= ~SHGDN_FORPARSING;
                    }
                    else
                    {
                        // Get this reg folder name
                        TCHAR szFolderName[GUIDSIZE + 2];
                        szFolderName[0] = szFolderName[1] = _chRegItem;
                        SHStringFromGUID(clsid, szFolderName + 2, cchName - 2);

                        // Copy the full path into szParentName.
                        StrCatBuff(szParentName, szFolderName, ARRAYSIZE(szParentName));

                        // Copy the full path into the output buffer.
                        lstrcpyn(pszName, szParentName, cchName);
                        return S_OK;
                    }
                }
            }

            // Check per-user settings first...
            if ((*pszName == 0) && SUCCEEDED(SHRegGetCLSIDKey(clsid, NULL, TRUE, FALSE, &hkCLSID)))
            {
                LONG lLen = cchName * sizeof(TCHAR);
                SHRegQueryValue(hkCLSID, NULL, pszName, &lLen);
                RegCloseKey(hkCLSID);
            }

            // If we have to, use per-machine settings...
            if (*pszName == 0)
            {
                _GetClassKeys(pidlr, &hkCLSID, NULL);

                if (hkCLSID)
                {
                    SHLoadLegacyRegUIString(hkCLSID, NULL, pszName, cchName);
                    RegCloseKey(hkCLSID);
                }
            }

            // try the required item names, they might not be in the registry
            if (*pszName == 0)
            {
                int iItem = _ReqItemIndex(pidlr);
                if (iItem >= 0)
                    LoadString(HINST_THISDLL, _aReqItems[iItem].uNameID, pszName, cchName);
            }

            if (*pszName)
            {
                if (_pszMachine && !(dwFlags & SHGDN_INFOLDER))
                {
                    // szName now holds the item name, and _pszMachine holds the machine.
                    LPTSTR pszRet = ShellConstructMessageString(HINST_THISDLL, MAKEINTRESOURCE(IDS_DSPTEMPLATE_WITH_ON), 
                                                                    SkipServerSlashes(_pszMachine), pszName);
                    if (pszRet)
                    {
                        lstrcpyn(pszName, pszRet, cchName);
                        LocalFree(pszRet);
                    }
                }

                _SaveNameInCache(clsid, dwFlags, pszName);
            }
        }
    }
    return *pszName ? S_OK : E_FAIL;
}


//
// get the HKEYs that map to the regitm.
//
// NOTE: this function returns a void so that the caller explicitly must check the keys
//       to see if they are non-null before using them.
//
void CRegFolder::_GetClassKeys(LPCIDLREGITEM pidlr, HKEY* phkCLSID, HKEY* phkBase)
{
    HRESULT hr;
    IQueryAssociations *pqa;
    
    if (phkCLSID)
        *phkCLSID = NULL;
    
    if (phkBase)
        *phkBase = NULL;

    hr = _AssocCreate(pidlr, IID_PPV_ARG(IQueryAssociations, &pqa));
    if (SUCCEEDED(hr))
    {
        if (phkCLSID)
        {
            hr = pqa->GetKey(0, ASSOCKEY_CLASS, NULL, phkCLSID);

            ASSERT((SUCCEEDED(hr) && *phkCLSID) || (FAILED(hr) && (*phkCLSID == NULL)));
        }

        if (phkBase)
        {
            hr = pqa->GetKey(0, ASSOCKEY_BASECLASS, NULL, phkBase);

            ASSERT((SUCCEEDED(hr) && *phkBase) || (FAILED(hr) && (*phkBase == NULL)));
        }

        pqa->Release();
    }
}

// {9EAC43C0-53EC-11CE-8230-CA8A32CF5494}
static const GUID GUID_WINAMP = { 0x9eac43c0, 0x53ec, 0x11ce, { 0x82, 0x30, 0xca, 0x8a, 0x32, 0xcf, 0x54, 0x94 } };

#define SZ_BROKEN_WINAMP_VERB   TEXT("OpenFileOrPlayList")


// IQA - Move this to Legacy Mapper.
void _MaybeDoWinAmpHack(UNALIGNED REFGUID rguid)
{
    if (IsEqualGUID(rguid, GUID_WINAMP))
    {
        // WinAmp writes in "OpenFileOrPlayList" as default value under shell, but they
        // don't write a corresponding "OpenFileorPlayList" verb key.  So we need to whack
        // the registry into shape for them.  Otherwise, they won't get the default verb
        // they want (due to an NT5 change in CDefExt_QueryContextMenu's behavior).

        TCHAR szCLSID[GUIDSTR_MAX];
        SHStringFromGUID(rguid, szCLSID, ARRAYSIZE(szCLSID));

        TCHAR szRegKey[GUIDSTR_MAX + 40];
        wsprintf(szRegKey, TEXT("CLSID\\%s\\shell"), szCLSID);

        TCHAR szValue[ARRAYSIZE(SZ_BROKEN_WINAMP_VERB)+2];
        DWORD dwType;
        DWORD dwSize = sizeof(szValue);
        if (SHGetValue(HKEY_CLASSES_ROOT, szRegKey, NULL, &dwType, szValue, &dwSize) == 0)
        {
            if (dwType == REG_SZ && lstrcmp(szValue, SZ_BROKEN_WINAMP_VERB) == 0)
            {
                // Make "open" the default verb
                SHSetValue(HKEY_CLASSES_ROOT, szRegKey, NULL, REG_SZ, TEXT("open"), sizeof(TEXT("open")));
            }
        }
    }
}

HRESULT CRegFolder::_AssocCreate(LPCIDLREGITEM pidlr, REFIID riid, void **ppv)
{
    *ppv = NULL;

    IQueryAssociations *pqa;
    HRESULT hr = AssocCreate(CLSID_QueryAssociations, IID_PPV_ARG(IQueryAssociations, &pqa));
    if (SUCCEEDED(hr))
    {
        WCHAR szCLSID[GUIDSTR_MAX];
        const CLSID clsid = _GetPIDLRCLSID(pidlr);    // alignment
        ASSOCF flags = ASSOCF_INIT_NOREMAPCLSID;
        DWORD dwAttributes;

        if ((SUCCEEDED(_AttributesOf(pidlr, SFGAO_FOLDER, &dwAttributes)) && 
            (dwAttributes & SFGAO_FOLDER)) && 
            !SHQueryShellFolderValue(&clsid, TEXT("HideFolderVerbs")))
            flags |= ASSOCF_INIT_DEFAULTTOFOLDER;

        SHStringFromGUIDW(clsid, szCLSID, ARRAYSIZE(szCLSID));

        _MaybeDoWinAmpHack(clsid);

        hr = pqa->Init(flags, szCLSID, NULL, NULL);

        if (SUCCEEDED(hr))
            hr = pqa->QueryInterface(riid, ppv);

        pqa->Release();
    }

    return hr;
}

//
// get the namespace key for this objec.
//

void CRegFolder::_GetNameSpaceKey(LPCIDLREGITEM pidlr, LPTSTR pszKeyName)
{
    TCHAR szClass[GUIDSTR_MAX];
    SHStringFromGUID(_GetPIDLRCLSID(pidlr), szClass, ARRAYSIZE(szClass));
    wsprintf(pszKeyName, TEXT("%s\\%s"), _pszRegKey, szClass);
}


BOOL CRegFolder::_CanDelete(LPCIDLREGITEM pidlr)
{
    DWORD dwAttributes;
    return pidlr && 
           SUCCEEDED(_AttributesOf(pidlr, SFGAO_CANDELETE, &dwAttributes)) &&
           (dwAttributes & SFGAO_CANDELETE);
}
//
// the user is trying to delete an object from a regitem folder, therefore
// lets look in the IDataObject to see if that includes any regitems, if
// so then handle their deletion, before passing to the outer guy to 
// handle the other objects.
//

#define MAX_REGITEM_WARNTEXT 1024

void CRegFolder::_Delete(HWND hwnd, UINT uFlags, IDataObject *pdtobj)
{
    STGMEDIUM medium;
    LPIDA pida = DataObj_GetHIDA(pdtobj, &medium);
    if (pida)
    {
        TCHAR szItemWarning[MAX_REGITEM_WARNTEXT];
        UINT nregfirst = (UINT)-1;
        UINT creg = 0;
        UINT cwarn = 0;
        UINT countfs = 0;
        LPCITEMIDLIST *ppidlFS = NULL;

        // calc number of regitems and index of first
        for (UINT i = 0; i < pida->cidl; i++)
        {
            LPCITEMIDLIST pidl = IDA_GetIDListPtr(pida, i);
            LPCIDLREGITEM pidlr = _IsReg(pidl);
            if (_CanDelete(pidlr))
            {
                TCHAR szTemp[MAX_REGITEM_WARNTEXT];
                creg++;
                if (nregfirst == (UINT)-1)
                    nregfirst = i;

                // use a temporary here because _GetDeleteMessage clobbers the buffer
                // when it doesn't get a delete message --ccooney
                if ((cwarn < 2) && _GetDeleteMessage(pidlr, szTemp, ARRAYSIZE(szTemp)))
                {
                    lstrcpy(szItemWarning, szTemp);
                    cwarn++;
                }
            }
            else if (!pidlr) //only do this for non reg items
            {
                // alloc an alternate array for FS pidls 
                // for simplicitu over alloc in the case where there are reg items
                if (ppidlFS == NULL)
                    ppidlFS = (LPCITEMIDLIST *)LocalAlloc(LPTR, pida->cidl * sizeof(LPCITEMIDLIST));
                if (ppidlFS)
                {
                    ppidlFS[countfs++] = pidl;
                }
            }
        }

        //
        // compose the confirmation message / ask the user / fry the items...
        //
        if (creg)
        {
            SHELLSTATE ss = {0};

            SHGetSetSettings(&ss, SSF_NOCONFIRMRECYCLE, FALSE);

            if ((uFlags & CMIC_MASK_FLAG_NO_UI) || ss.fNoConfirmRecycle)
            {
                for (i = 0; i < pida->cidl; i++)
                {
                    LPCIDLREGITEM pidlr = _IsReg(IDA_GetIDListPtr(pida, i));
                    if (_CanDelete(pidlr))
                        _DeleteRegItem(pidlr);
                }
            }
            else
            {
                TCHAR szItemName[MAX_PATH];
                TCHAR szWarnText[1024 + MAX_REGITEM_WARNTEXT];
                TCHAR szWarnCaption[128];
                TCHAR szTemp[256];
                MSGBOXPARAMS mbp = {sizeof(mbp), hwnd,
                    HINST_THISDLL, szWarnText, szWarnCaption,
                    MB_YESNO | MB_USERICON, MAKEINTRESOURCE(IDI_NUKEFILE),
                    0, NULL, 0};

                //
                // so we can tell if we got these later
                //
                *szItemName = 0;
                *szWarnText = 0;

                //
                // if there is only one, retrieve its name
                //
                if (creg == 1)
                {
                    LPCIDLREGITEM pidlr = _IsReg(IDA_GetIDListPtr(pida, nregfirst));

                    _GetDisplayName(pidlr, SHGDN_NORMAL, szItemName, ARRAYSIZE(szItemName));
                }
                //
                // ask the question "are you sure..."
                //
                if ((pida->cidl == 1) && *szItemName)
                {
                    TCHAR szTemp2[256];
                    LoadString(HINST_THISDLL, _IsDesktop() ? IDS_CONFIRMDELETEDESKTOPREGITEM : IDS_CONFIRMDELETEREGITEM, szTemp2, ARRAYSIZE(szTemp2));
                    wsprintf(szTemp, szTemp2, szItemName);
                }
                else
                {
                    LoadString(HINST_THISDLL, _IsDesktop() ? IDS_CONFIRMDELETEDESKTOPREGITEMS : IDS_CONFIRMDELETEREGITEMS, szTemp, ARRAYSIZE(szTemp));
                }
                lstrcat(szWarnText, szTemp);


                //
                // if there is exactly one special warning message and one item total, add it in
                //
                if (creg == 1 && cwarn == 1 && *szItemWarning)
                {
                    lstrcat(szWarnText, TEXT("\r\n\n"));
                    lstrcat(szWarnText, szItemWarning);
                }
                else
                {
                    if (creg == 1)
                    {
                        TCHAR szTemp2[256];
                        TCHAR szControlPanel[256];
                        LPCIDLREGITEM pidlr = _IsReg(IDA_GetIDListPtr(pida, nregfirst));
                        CLSID clsid = _GetPIDLRCLSID(pidlr); // alignment

                        int idString = (1 == pida->cidl) ?
                            IDS_CANTRECYCLEREGITEMS_NAME :
                            IDS_CANTRECYCLEREGITEMS_INCL_NAME;

                        LoadString(HINST_THISDLL, idString, szTemp, ARRAYSIZE(szTemp));
                        if ((IsEqualCLSID(CLSID_NetworkPlaces, clsid)) ||
                                 (IsEqualCLSID(CLSID_Internet, clsid)) ||
                                 (IsEqualCLSID(CLSID_MyComputer, clsid)) ||
                                 (IsEqualCLSID(CLSID_MyDocuments, clsid)))
                        {
                            LoadString(HINST_THISDLL, IDS_CANTRECYLE_FOLDER, szControlPanel, ARRAYSIZE(szControlPanel));
                        }
                        else
                        {
                            LoadString(HINST_THISDLL, IDS_CANTRECYLE_GENERAL, szControlPanel, ARRAYSIZE(szControlPanel));
                        }
                        lstrcat(szWarnText, TEXT("\r\n\n"));
                        wsprintf(szTemp2, szTemp, szControlPanel);
                        lstrcat(szWarnText,szTemp2);
                    }

                    //
                    // otherwise, say "these items..." or "some of these items..."
                    //
                    else
                    {
                        TCHAR szTemp2[256];
                        TCHAR szControlPanel[256];
                        int idString = (creg == pida->cidl) ? IDS_CANTRECYCLEREGITEMS_ALL : IDS_CANTRECYCLEREGITEMS_SOME;
                        LoadString(HINST_THISDLL, idString, szTemp, ARRAYSIZE(szTemp));
                        LoadString(HINST_THISDLL, IDS_CANTRECYLE_GENERAL, szControlPanel, ARRAYSIZE(szControlPanel));
                        lstrcat(szWarnText, TEXT("\r\n\n"));
                        wsprintf(szTemp2, szTemp, szControlPanel);
                        lstrcat(szWarnText,szTemp2);

                        //
                        // we just loaded a very vague message
                        // don't confuse the user any more by adding random text
                        // if these is a special warning, force it to show separately
                        //
                        if (cwarn == 1)
                            cwarn++;
                    }
                }


                //
                // finally, the message box caption (also needed in loop below)
                //
                LoadString(HINST_THISDLL, IDS_CONFIRMDELETE_CAPTION, szWarnCaption, ARRAYSIZE(szWarnCaption));

                // make sure the user is cool with it
                if (MessageBoxIndirect(&mbp) == IDYES)
                {
                    // go ahead and delete the reg items
                    for (i = 0; i < pida->cidl; i++)
                    {
                        LPCIDLREGITEM pidlr = _IsReg(IDA_GetIDListPtr(pida, i));
                        if (_CanDelete(pidlr))
                        {
                            if ((cwarn > 1) && _GetDeleteMessage(pidlr, szItemWarning, ARRAYSIZE(szItemWarning)))
                            {
                                if (FAILED(_GetDisplayName(pidlr, SHGDN_NORMAL, szItemName, ARRAYSIZE(szItemName))))
                                    lstrcpy(szItemName, szWarnCaption);

                                MessageBox(hwnd, szItemWarning, szItemName, MB_OK | MB_ICONINFORMATION);
                            }
                            _DeleteRegItem(pidlr);
                        }
                    }
                }
            }
        }

        // now delete the fs objects
        if (ppidlFS)
        {
            SHInvokeCommandOnPidlArray(hwnd, NULL, (IShellFolder *)this, ppidlFS, countfs, uFlags, "delete");
            LocalFree((HANDLE)ppidlFS);
        }

        HIDA_ReleaseStgMedium(pida, &medium);
    }
}

//
// Delete a regitem given its pidl.
//

HRESULT CRegFolder::_DeleteRegItem(LPCIDLREGITEM pidlr)
{
    if (_IsDelegate(pidlr))
        return E_INVALIDARG;

    HRESULT hr = E_ACCESSDENIED;
    if (_CanDelete(pidlr))
    {
        const CLSID clsid = _GetPIDLRCLSID(pidlr);    // alignment

        if (SHQueryShellFolderValue(&clsid, TEXT("HideOnDesktopPerUser")))
        {
            // hide this icon only on desktop for StartPanel on (0) and off (1)
            hr = ShowHideIconOnlyOnDesktop(&clsid, 0, 1, TRUE);  
        }
        else if (SHQueryShellFolderValue(&clsid, TEXT("HideAsDeletePerUser")))
        {
            // clear the non enuerated bit to hide this item
            hr = _SetAttributes(pidlr, TRUE, SFGAO_NONENUMERATED, SFGAO_NONENUMERATED);
        }
        else if (SHQueryShellFolderValue(&clsid, TEXT("HideAsDelete")))
        {
            // clear the non enuerated bit to hide this item
            hr = _SetAttributes(pidlr, FALSE, SFGAO_NONENUMERATED, SFGAO_NONENUMERATED);
        }
        else
        {
            // remove from the key to delete it
            TCHAR szKeyName[MAX_PATH];

            _GetNameSpaceKey(pidlr, szKeyName);

            if ((RegDeleteKey(HKEY_CURRENT_USER,  szKeyName) == ERROR_SUCCESS) ||
                (RegDeleteKey(HKEY_LOCAL_MACHINE, szKeyName) == ERROR_SUCCESS))
            {
                hr = S_OK;
            }
        }

        if (SUCCEEDED(hr))
        {
            // tell the world
            LPITEMIDLIST pidlAbs = ILCombine(_GetFolderIDList(), (LPCITEMIDLIST)pidlr);
            if (pidlAbs)
            {
                SHChangeNotify(SHCNE_DELETE, SHCNF_IDLIST, pidlAbs, NULL);
                ILFree(pidlAbs);
            }
        }
    }
    return hr;
}


// 
// Get the prompt to be displayed if the user tries to delete the regitem,
// this is stored both globally (HKLM) and as s user configured preference.
//

BOOL CRegFolder::_GetDeleteMessage(LPCIDLREGITEM pidlr, LPTSTR pszMsg, int cchMax)
{
    HKEY hk;
    TCHAR szKeyName[MAX_PATH];

    ASSERT(!_IsDelegate(pidlr));
    *pszMsg = 0;

    _GetNameSpaceKey(pidlr, szKeyName);
    if ((RegOpenKey(HKEY_LOCAL_MACHINE, szKeyName, &hk) == ERROR_SUCCESS) ||
        (RegOpenKey(HKEY_CURRENT_USER,  szKeyName, &hk) == ERROR_SUCCESS))
    {
        SHLoadRegUIString(hk, REGSTR_VAL_REGITEMDELETEMESSAGE, pszMsg, cchMax);
        RegCloseKey(hk);
    }
    return *pszMsg != 0;
}


HRESULT CRegFolder::_GetRegItemColumnFromRegistry(LPCIDLREGITEM pidlr, LPCTSTR pszColumnName, LPTSTR pszColumnData, int cchColumnData)
{
    HKEY hkCLSID;
    HRESULT hr = E_FAIL;
    
    _GetClassKeys(pidlr, &hkCLSID, NULL);
    
    *pszColumnData = 0; // Default string
    
    if (hkCLSID)
    {
        // Use SHLoadRegUIString to allow the string to be localized
        if (SUCCEEDED(SHLoadRegUIString(hkCLSID, pszColumnName, pszColumnData, cchColumnData)))
        {
            
            hr = S_OK;
        }        
        
        // FIXED kenwic 052699 #342955
        RegCloseKey(hkCLSID);
    }
    return hr;
}

//
// A more generic version of _GetRegItemColumnFromRegistry which takes a pidlr and a string 
// and finds the corresponding variant value from the registry. 
//
// pidlr:           pidl of the regitem, we open the registry key corresponding to its CLSID
// pszColumnName:   name of the value to took for under the opened key
// pv:              variant to return the value
//
HRESULT CRegFolder::_GetRegItemVariantFromRegistry(LPCIDLREGITEM pidlr, LPCTSTR pszColumnName, VARIANT *pv)
{
    HKEY hkCLSID;
    HRESULT hr = E_FAIL;
    
    _GetClassKeys(pidlr, &hkCLSID, NULL);
    
    if (hkCLSID)
    {   
        hr = GetVariantFromRegistryValue(hkCLSID, pszColumnName, pv);                
        RegCloseKey(hkCLSID);        
    }
    return hr;
}

//
//  App compat:  McAfee Nuts & Bolts Quick Copy has the wrong function
//  signature for CreateViewObject.  They implemented it as
//
//      STDAPI CreateViewObject(HWND hwnd) { return S_OK; }
//
//  so we must manually reset the stack after the call.
//
#ifdef _X86_
STDAPI SHAppCompatCreateViewObject(IShellFolder *psf, HWND hwnd, REFIID riid, void * *ppv)
{
    HRESULT hr;
    _asm mov edi, esp
    hr = psf->CreateViewObject(hwnd, riid, ppv);
    _asm mov esp, edi

    // AppCompat - Undelete 2.0 returns S_OK for interfaces that it doesnt support
    // but they do correctly NULL the ppv out param so we check for that as well
    if (SUCCEEDED(hr) && !*ppv)
        hr = E_NOINTERFACE;
    return hr;
}
#else
#define SHAppCompatCreateViewObject(psf, hwnd, riid, ppv) \
        psf->CreateViewObject(hwnd, riid, ppv)
#endif

HRESULT CRegFolder::_CreateViewObjectFor(LPCIDLREGITEM pidlr, HWND hwnd, REFIID riid, void **ppv, BOOL bOneLevel)
{
    IShellFolder *psf;
    HRESULT hr = _BindToItem(pidlr, NULL, IID_PPV_ARG(IShellFolder, &psf), bOneLevel);
    if (SUCCEEDED(hr))
    {
        hr = SHAppCompatCreateViewObject(psf, hwnd, riid, ppv);
        psf->Release();
    }
    else
        *ppv = NULL;
    return hr;
}

// Geta an infotip object for the namespace

HRESULT CRegFolder::_GetInfoTip(LPCIDLREGITEM pidlr, void **ppv)
{
    HKEY hkCLSID;
    HRESULT hr = E_FAIL;
    
    _GetClassKeys(pidlr, &hkCLSID, NULL);

    if (hkCLSID)
    {
        DWORD dwQuery, lLen = sizeof(dwQuery);

        // let the regitem code compute the info tip if it wants to...
        if (SHQueryValueEx(hkCLSID, TEXT("QueryForInfoTip"), NULL, NULL, (BYTE *)&dwQuery, &lLen) == ERROR_SUCCESS)
        {
            hr = _CreateViewObjectFor(pidlr, NULL, IID_IQueryInfo, ppv, TRUE);
        }
        else
        {
            hr = E_FAIL;
        }

        // fall back to reading it from the registry
        if (FAILED(hr))
        {
            TCHAR szText[INFOTIPSIZE];

            // Use SHLoadRegUIString to allow the info tip to be localized
            if (SUCCEEDED(SHLoadRegUIString(hkCLSID, TEXT("InfoTip"), szText, ARRAYSIZE(szText))) &&
                szText[0])
            {
                hr = CreateInfoTipFromText(szText, IID_IQueryInfo, ppv); //The InfoTip COM object
            }
        }

        RegCloseKey(hkCLSID);
    }

    return hr;
}

// there are 2 forms for parsing syntax we support
//
// to parse reg items in this folder
//  ::{clsid reg item} [\ optional extra stuff to parse]
//
// to parse items that might live in a delegate folder
//  ::{clsid delegate folder},<delegate folder specific parse string> [\ optional extra stuff to parse]
//
// in both cases the optional remander stuff gets passed through to complete 
// the parse in that name space

HRESULT CRegFolder::_ParseGUIDName(HWND hwnd, LPBC pbc, LPOLESTR pwzDisplayName, 
                                   LPITEMIDLIST *ppidlOut, ULONG *pdwAttributes)
{
    TCHAR szDisplayName[GUIDSTR_MAX+10];
    CLSID clsid;
    LPOLESTR pwzNext;
    LPOLESTR pwzDelegateInfo = NULL;

    // Note that we add 2 to skip the RegItem identifier characters
    pwzDisplayName += 2;

    // Skip to a '\\'
    for (pwzNext = pwzDisplayName; *pwzNext && *pwzNext != TEXT('\\'); pwzNext++)
    {
        // if we hit a ',' then eg, ::{GUID},stuff then we assume the stuff is for a delegate 
        if ((*pwzNext == TEXT(',')) && !pwzDelegateInfo)
        {
            pwzDelegateInfo = pwzNext + 1;        // skip comma
        }
    }

    OleStrToStrN(szDisplayName, ARRAYSIZE(szDisplayName), pwzDisplayName, (int)(pwzNext - pwzDisplayName));

    // szDisplayName is NOT NULL terminated, but 
    // SHCLSIDFromString doesn't seem to mind.
    HRESULT hr = SHCLSIDFromString(szDisplayName, &clsid);
    if (SUCCEEDED(hr))
    {
        if (pwzDelegateInfo)
        {
            IShellFolder *psf;
            if (SUCCEEDED(_CreateDelegateFolder(&clsid, IID_PPV_ARG(IShellFolder, &psf))))
            {
                ULONG chEaten;
                hr = psf->ParseDisplayName(hwnd, pbc, pwzDelegateInfo, &chEaten, ppidlOut, pdwAttributes);
                psf->Release();
            }
        }
        else
        {
            IDLREGITEM* pidlRegItem = _CreateAndFillIDLREGITEM(&clsid);
            if (pidlRegItem)
            {
                if (_IsInNameSpace(pidlRegItem) || (BindCtx_GetMode(pbc, 0) & STGM_CREATE))
                {
                    hr = _ParseNextLevel(hwnd, pbc, pidlRegItem, pwzNext, ppidlOut, pdwAttributes);
                }
                else
                    hr = E_INVALIDARG;

                ILFree((LPITEMIDLIST)pidlRegItem);
            }
            else
            {
                hr = E_OUTOFMEMORY;
            }
        }
    }
    return hr;
}

//
// ask a (known) regitem to parse a displayname
//

HRESULT CRegFolder::_ParseThroughItem(LPCIDLREGITEM pidlr, HWND hwnd, LPBC pbc,
                                      LPOLESTR pszName, ULONG *pchEaten,
                                      LPITEMIDLIST *ppidlOut, ULONG *pdwAttributes)
{
    IShellFolder *psfItem;
    HRESULT hr = _BindToItem(pidlr, pbc, IID_PPV_ARG(IShellFolder, &psfItem), FALSE);
    if (SUCCEEDED(hr))
    {
        LPITEMIDLIST pidlRight;
        hr = psfItem->ParseDisplayName(hwnd, pbc, pszName, pchEaten,
                                         &pidlRight, pdwAttributes);
        if (SUCCEEDED(hr))
        {
            hr = SHILCombine((LPCITEMIDLIST)pidlr, pidlRight, ppidlOut);
            ILFree(pidlRight);
        }
        psfItem->Release();
    }
    return hr;
}

//
// Parse through the GUID to the namespace below
//

HRESULT CRegFolder::_ParseNextLevel(HWND hwnd, LPBC pbc, LPCIDLREGITEM pidlr,
                                    LPOLESTR pwzRest, LPITEMIDLIST *ppidlOut, ULONG *pdwAttributes)
{
    if (!*pwzRest)
    {
        // base case for recursive calls
        // pidlNext should be a simple pidl.
        ASSERT(!ILIsEmpty((LPCITEMIDLIST)pidlr) && ILIsEmpty(_ILNext((LPCITEMIDLIST)pidlr)));
        if (pdwAttributes && *pdwAttributes)
            _AttributesOf(pidlr, *pdwAttributes, pdwAttributes);
        return SHILClone((LPCITEMIDLIST)pidlr, ppidlOut);
    }

    ASSERT(*pwzRest == TEXT('\\'));

    ++pwzRest;

    IShellFolder *psfNext;
    HRESULT hr = _BindToItem(pidlr, pbc, IID_PPV_ARG(IShellFolder, &psfNext), FALSE);
    if (SUCCEEDED(hr))
    {
        ULONG chEaten;
        LPITEMIDLIST pidlRest;
        hr = psfNext->ParseDisplayName(hwnd, pbc, pwzRest, &chEaten, &pidlRest, pdwAttributes);
        if (SUCCEEDED(hr))
        {
            hr = SHILCombine((LPCITEMIDLIST)pidlr, pidlRest, ppidlOut);
            SHFree(pidlRest);
        }
        psfNext->Release();
    }
    return hr;
}

BOOL _FailForceReturn(HRESULT hr)
{
    switch (hr)
    {
    case HRESULT_FROM_WIN32(ERROR_FILE_NOT_FOUND):
    case HRESULT_FROM_WIN32(ERROR_PATH_NOT_FOUND):
    case HRESULT_FROM_WIN32(ERROR_BAD_NET_NAME):
    case HRESULT_FROM_WIN32(ERROR_BAD_NETPATH):
    case HRESULT_FROM_WIN32(ERROR_CANCELLED):
        return TRUE;
    }
    return FALSE;
}


HRESULT CRegFolder::ParseDisplayName(HWND hwnd, LPBC pbc, LPOLESTR pszName, 
                                     ULONG *pchEaten, LPITEMIDLIST *ppidlOut, ULONG *pdwAttributes)
{
    HRESULT hr = E_INVALIDARG;

    if (ppidlOut)
        *ppidlOut = NULL;

    if (ppidlOut && pszName)
    {
        // ::{guid} lets you get the pidl for a reg item

        if (*pszName && (pszName[0] == _chRegItem) && (pszName[1] == _chRegItem))
        {
            hr = _ParseGUIDName(hwnd, pbc, pszName, ppidlOut, pdwAttributes);
        }
        else
        {
            // inner folder gets a chance to parse

            hr = _psfOuter->ParseDisplayName(hwnd, pbc, pszName, pchEaten, ppidlOut, pdwAttributes);
            if (FAILED(hr) && 
                !_FailForceReturn(hr) &&
                !SHSkipJunctionBinding(pbc, NULL))
            {
                // loop over all of the items
            
                HDCA hdca = _ItemArray();
                if (hdca)
                {
                    HRESULT hrTemp = E_FAIL;
                    for (int i = 0; FAILED(hrTemp) && (i < DCA_GetItemCount(hdca)); i++)
                    {
                        const CLSID clsid = *DCA_GetItem(hdca, i);
                        if (!SHSkipJunction(pbc, &clsid)
                        && SHQueryShellFolderValue(&clsid, L"WantsParseDisplayName"))
                        {
                            IDLREGITEM* pidlRegItem = _CreateAndFillIDLREGITEM(DCA_GetItem(hdca, i));
                            if (pidlRegItem)
                            {
                                hrTemp = _ParseThroughItem(pidlRegItem, hwnd, pbc, pszName, pchEaten, ppidlOut, pdwAttributes);
                            }
                            ILFree((LPITEMIDLIST)pidlRegItem);
                        }
                    }
                    DCA_Destroy(hdca);

                    if (SUCCEEDED(hrTemp) || _FailForceReturn(hrTemp))
                        hr = hrTemp;
                    else
                        hr = E_INVALIDARG; // no one could handle it
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
            }
        }
        ASSERT(SUCCEEDED(hr) ? *ppidlOut != NULL : *ppidlOut == NULL);
    }

    if (FAILED(hr))
        TraceMsg(TF_WARNING, "CRegFolder::ParseDisplayName(), hr:%x %hs", hr, pszName);

    return hr;
}

HRESULT CRegFolder::EnumObjects(HWND hwnd, DWORD grfFlags, IEnumIDList **ppenum)
{
    *ppenum = NULL;

    IEnumIDList *penumOuter;
    HRESULT hr = _psfOuter->EnumObjects(hwnd, grfFlags, &penumOuter);
    if (SUCCEEDED(hr))
    {
        // SUCCEEDED(hr) may be S_FALSE with penumOuter == NULL
        // CRegFolderEnum deals with this just fine
        CRegFolderEnum *preidl = new CRegFolderEnum(this, grfFlags, penumOuter, 
                                                    _ItemArray(), _DelItemArray(), 
                                                    _pPolicy);
        if (preidl)
        {
            *ppenum = SAFECAST(preidl, IEnumIDList*);
            hr = S_OK;
        }
        else
            hr = E_OUTOFMEMORY;

        if (penumOuter)
            penumOuter->Release();       // _psfOuter returned S_FALSE
    }
    return hr;
}

// Handle binding to the inner namespace, or the regitem accordingly given its pidl.

HRESULT CRegFolder::_BindToItem(LPCIDLREGITEM pidlr, LPBC pbc, REFIID riid, void **ppv, BOOL bOneLevel)
{
    LPITEMIDLIST pidlAlloc;

    *ppv = NULL;

    LPCITEMIDLIST pidlNext = _ILNext((LPCITEMIDLIST)pidlr);
    if (ILIsEmpty(pidlNext))
    {
        pidlAlloc = NULL;
        bOneLevel = TRUE;   // we know for sure it is one level
    }
    else
    {
        pidlAlloc = ILCloneFirst((LPCITEMIDLIST)pidlr);
        if (!pidlAlloc)
            return E_OUTOFMEMORY;

        pidlr = (LPCIDLREGITEM)pidlAlloc;   // a single item IDLIST
    }

    HRESULT hr;
    if (bOneLevel)
    {
        hr = _CreateAndInit(pidlr, pbc, riid, ppv);    // create on riid to avoid loads on interfaces not supported
    }
    else
    {
        IShellFolder *psfNext;
        hr = _CreateAndInit(pidlr, pbc, IID_PPV_ARG(IShellFolder, &psfNext));
        if (SUCCEEDED(hr))
        {
            hr = psfNext->BindToObject(pidlNext, pbc, riid, ppv);
            psfNext->Release();
        }
    }

    if (pidlAlloc)
        ILFree(pidlAlloc);      // we allocated in this case

    return hr;
}

HRESULT CRegFolder::BindToObject(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv)
{
    HRESULT hr;
    LPCIDLREGITEM pidlr = _IsReg(pidl);
    if (pidlr)
        hr = _BindToItem(pidlr, pbc, riid, ppv, FALSE);
    else
        hr = _psfOuter->BindToObject(pidl, pbc, riid, ppv);
    return hr;
}

HRESULT CRegFolder::BindToStorage(LPCITEMIDLIST pidl, LPBC pbc, REFIID riid, void **ppv)
{
    return BindToObject(pidl, pbc, riid, ppv);
}

// I can't believe there is no "^^"
#define LOGICALXOR(a, b) (((a) && !(b)) || (!(a) && (b)))

BOOL CRegFolder::_IsFolder(LPCITEMIDLIST pidl)
{
    BOOL fRet = FALSE;

    if (pidl)
    {
        ULONG uAttrib = SFGAO_FOLDER;
        if (SUCCEEDED(GetAttributesOf(1, &pidl, &uAttrib)) && (SFGAO_FOLDER & uAttrib))
            fRet = TRUE;            
    }

    return fRet;
}

int CRegFolder::_CompareIDsOriginal(LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    LPCIDLREGITEM pidlr1 = _IsReg(pidl1);
    LPCIDLREGITEM pidlr2 = _IsReg(pidl2);
    int iRes = 0;
    
    if (pidlr1 && pidlr2)
    {
        iRes = memcmp(&(_GetPIDLRCLSID(pidlr1)), &(_GetPIDLRCLSID(pidlr2)), sizeof(CLSID));
        if (0 == iRes)
        {
            //  if they are the same clsid
            //  and delegates then we need to query
            //  the delegate for the compare
            PDELEGATEITEMID pidld1 = _IsDelegate(pidlr1);
            PDELEGATEITEMID pidld2 = _IsDelegate(pidlr2);
            if (pidld1 && pidld2)
            {
                //  these are both the same delegate
                IShellFolder *psf;
                if (SUCCEEDED(_GetDelegateFolder(pidld1, IID_PPV_ARG(IShellFolder, &psf))))
                {
                    HRESULT hr = psf->CompareIDs(lParam, pidl1, pidl2);
                    psf->Release();
                    iRes = HRESULT_CODE(hr);
                }
            }
            else
            {
                ASSERT(!pidld1 && !pidld2);
            }
        }
        else if (!(SHCIDS_CANONICALONLY & lParam))
        {
            //  sort by defined order
            BYTE bOrder1 = _GetOrder(pidlr1);
            BYTE bOrder2 = _GetOrder(pidlr2);
            int iUI = bOrder1 - bOrder2;
            if (0 == iUI)
            {
                // All of the required items come first, in reverse
                // order (to make this simpler)
                int iItem1 = _ReqItemIndex(pidlr1);
                int iItem2 = _ReqItemIndex(pidlr2);

                if (iItem1 == -1 && iItem2 == -1)
                {
                    TCHAR szName1[MAX_PATH], szName2[MAX_PATH];
                    _GetDisplayName(pidlr1, SHGDN_NORMAL, szName1, ARRAYSIZE(szName1));
                    _GetDisplayName(pidlr2, SHGDN_NORMAL, szName2, ARRAYSIZE(szName2));

                    iUI = StrCmpLogicalRestricted(szName1, szName2);
                }
                else
                {
                    iUI = iItem2 - iItem1;
                }
            }

            if (iUI)
                iRes = iUI;
        }
    }

    return iRes;
}

// Alphabetical (doesn't care about folder, regitems, ...)
int CRegFolder::_CompareIDsAlphabetical(UINT iColumn, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    int iRes = 0;

    // Do we have only one ptr?
    if (!LOGICALXOR(pidl1, pidl2))
    {
        // No,  either we have two or none.
        if (pidl1 && pidl2)
        {
            iRes = CompareIDsAlphabetical(SAFECAST(this, IShellFolder2*), iColumn, pidl1, pidl2);
        }
        // else iRes already = 0
    }
    else
    {
        // Yes, the one which is non-NULL is first
        iRes = (pidl1 ? -1 : 1);
    }

    return iRes;
}

// Folders comes first, and are ordered in alphabetical order among themselves,
// then comes all the non-folders again sorted among thmeselves
int CRegFolder::_CompareIDsFolderFirst(UINT iColumn, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    int iRes = 0;

    BOOL fIsFolder1 = _IsFolder(pidl1);
    BOOL fIsFolder2 = _IsFolder(pidl2);

    // Is there one folder and one non-folder?
    if (LOGICALXOR(fIsFolder1, fIsFolder2))
    {
        // Yes, the folder will be first
        iRes = fIsFolder1 ? -1 : 1;
    }
    else
    {
        // No, either both are folders or both are not.  One way or the other, go
        // alphabetically
        iRes = _CompareIDsAlphabetical(iColumn, pidl1, pidl2);
    }

    return iRes;
}

int CRegFolder::_GetOrderType(LPCITEMIDLIST pidl)
{
    if (_IsReg(pidl))
    {
        if (_IsDelegate((LPCIDLREGITEM)pidl))
            return REGORDERTYPE_DELEGATE;
        else if (-1 == _ReqItemIndex((LPCIDLREGITEM)pidl))
            return REGORDERTYPE_REGITEM;
        else 
            return REGORDERTYPE_REQITEM;
    }
    return _iTypeOuter;
}

HRESULT CRegFolder::CompareIDs(LPARAM lParam, LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    int iType1 = _GetOrderType(pidl1);
    int iType2 = _GetOrderType(pidl2);
    int iTypeCompare = iType1 - iType2;
    int iRes = 0;
    UINT iColumn = (UINT) (SHCIDS_COLUMNMASK & lParam);

    // first we compare the first level only
    
    switch (_dwSortAttrib)
    {
    case RIISA_ORIGINAL:
        if (0 == iTypeCompare && iType1 == _iTypeOuter)
        {
            // neither are regitems
            return _psfOuter->CompareIDs(lParam, pidl1, pidl2);
        }
        else
        {
            ASSERT(iRes == 0);  // this handled by by CompareIDsOriginal() below
        }
        break;

    case RIISA_FOLDERFIRST:
        iRes = _CompareIDsFolderFirst(iColumn, pidl1, pidl2);
        break;

    case RIISA_ALPHABETICAL:
        iRes = _CompareIDsAlphabetical(iColumn, pidl1, pidl2);
        break;
    }

    //  all our foofy compares and it still looks the same to us
    //  time to get medieval.
    if (0 == iRes)
    {
        iRes = _CompareIDsOriginal(lParam, pidl1, pidl2);
        
        if (0 == iRes)
            iRes = iTypeCompare;

        if (0 == iRes)
        {
            // If the class ID's really are the same, 
            // we'd better check the next level(s)
            return ILCompareRelIDs(SAFECAST(this, IShellFolder *), pidl1, pidl2, lParam);
        }
    }

    return ResultFromShort(iRes);
}

HRESULT CRegFolder::CreateViewObject(HWND hwnd, REFIID riid, void **ppv)
{
    return _psfOuter->CreateViewObject(hwnd, riid, ppv);
}

HRESULT CRegFolder::_SetAttributes(LPCIDLREGITEM pidlr, BOOL bPerUser, DWORD dwMask, DWORD dwNewBits)
{
    HKEY hk;
    HRESULT hr = SHRegGetCLSIDKey(_GetPIDLRCLSID(pidlr), TEXT("ShellFolder"), bPerUser, TRUE, &hk);
    if (SUCCEEDED(hr))
    {
        DWORD err, dwValue = 0, cbSize = sizeof(dwValue);
        SHQueryValueEx(hk, TEXT("Attributes"), NULL, NULL, (BYTE *)&dwValue, &cbSize);

        dwValue = (dwValue & ~dwMask) | (dwNewBits & dwMask);

        err = RegSetValueEx(hk, TEXT("Attributes"), 0, REG_DWORD, (BYTE *)&dwValue, sizeof(dwValue));
        hr = HRESULT_FROM_WIN32(err);
        RegCloseKey(hk);
    }

    EnterCriticalSection(&_cs);
    _clsidAttributesCache = CLSID_NULL;
    LeaveCriticalSection(&_cs);

    return hr;
}

LONG CRegFolder::_RegOpenCLSIDUSKey(CLSID clsid, PHUSKEY phk)
{
    WCHAR wszCLSID[39];
    LONG iRetVal = ERROR_INVALID_PARAMETER;

    if (StringFromGUID2(clsid, wszCLSID, ARRAYSIZE(wszCLSID)))
    {
        TCHAR szCLSID[39];
        TCHAR szKey[MAXIMUM_SUB_KEY_LENGTH];

        SHUnicodeToTChar(wszCLSID, szCLSID, ARRAYSIZE(szCLSID));
        StrCpyN(szKey, TEXT("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\CLSID\\"), ARRAYSIZE(szKey));
        StrCatBuff(szKey, szCLSID, ARRAYSIZE(szKey));
        StrCatBuff(szKey, TEXT("\\ShellFolder"), ARRAYSIZE(szKey));

        iRetVal = SHRegOpenUSKey(szKey, KEY_READ, NULL, phk, FALSE);
    }

    return iRetVal;    
}

ULONG CRegFolder::_GetPerUserAttributes(LPCIDLREGITEM pidlr)
{
    DWORD dwAttribute = 0;
    HUSKEY hk;
    if (ERROR_SUCCESS == _RegOpenCLSIDUSKey(_GetPIDLRCLSID(pidlr), &hk))
    {
        DWORD cb = sizeof(dwAttribute);
        DWORD dwType = REG_DWORD;
        SHRegQueryUSValue(hk, TEXT("Attributes"), &dwType, &dwAttribute, &cb, FALSE, 0, sizeof(DWORD));
        SHRegCloseUSKey(hk);
    }

    // we only allow these bits to change
    return dwAttribute & (SFGAO_NONENUMERATED | SFGAO_CANDELETE | SFGAO_CANMOVE);
}


#define SFGAO_REQ_MASK (SFGAO_NONENUMERATED | SFGAO_CANDELETE | SFGAO_CANMOVE)

HRESULT CRegFolder::_AttributesOf(LPCIDLREGITEM pidlr, DWORD dwAttributesNeeded, DWORD *pdwAttributes)
{
    HRESULT hr = S_OK;
    *pdwAttributes = 0;

    PDELEGATEITEMID pidld = _IsDelegate(pidlr);
    if (pidld)
    {
        IShellFolder *psf;
        hr = _GetDelegateFolder(pidld, IID_PPV_ARG(IShellFolder, &psf));
        if (SUCCEEDED(hr))
        {
            *pdwAttributes = dwAttributesNeeded;
            hr = psf->GetAttributesOf(1, (LPCITEMIDLIST*)&pidlr, pdwAttributes);
            psf->Release();
        }
    }        
    else
    {
        EnterCriticalSection(&_cs);
        CLSID clsid = _GetPIDLRCLSID(pidlr); // alignment
        BOOL bGuidMatch = IsEqualGUID(clsid, _clsidAttributesCache);
        if (bGuidMatch && ((dwAttributesNeeded & _dwAttributesCacheValid) == dwAttributesNeeded))
        {
            *pdwAttributes = _dwAttributesCache;
        }
        else
        {
            int iItem = _ReqItemIndex(pidlr);

            // if the guid didn't match, we need to start from scratch.
            // otherwise, we'll or back in the cahced bits...
            if (!bGuidMatch)
            {
                _dwAttributesCacheValid = 0;
                _dwAttributesCache = 0;
            }

            if (iItem >= 0)
            {
                *pdwAttributes = _aReqItems[iItem].dwAttributes;
                // per machine attributes allow items to be hidden per machine
                *pdwAttributes |= SHGetAttributesFromCLSID2(&clsid, 0, SFGAO_REQ_MASK) & SFGAO_REQ_MASK;
            }
            else
            {
                *pdwAttributes = SHGetAttributesFromCLSID2(&clsid, SFGAO_CANMOVE | SFGAO_CANDELETE, dwAttributesNeeded & ~_dwAttributesCacheValid);
            }
            *pdwAttributes |= _GetPerUserAttributes(pidlr);   // hidden per user
            *pdwAttributes |= _dwDefAttributes;               // per folder defaults
            *pdwAttributes |= _dwAttributesCache;

            _clsidAttributesCache = clsid;
            _dwAttributesCache = *pdwAttributes;
            _dwAttributesCacheValid |= dwAttributesNeeded | *pdwAttributes; // if they gave us more than we asked for, cache them 
        }
        LeaveCriticalSection(&_cs);
    }
    return hr;
}

HRESULT CRegFolder::GetAttributesOf(UINT cidl, LPCITEMIDLIST *apidl, ULONG *prgfInOut)
{
    HRESULT hr;

    if (!cidl)
    {
        // special case for the folder as a whole, so I know nothing about it.
        hr = _psfOuter->GetAttributesOf(cidl, apidl, prgfInOut);
    }
    else
    {
        hr = S_OK;
        UINT rgfOut = *prgfInOut;
        LPCITEMIDLIST *ppidl = (LPCITEMIDLIST*)LocalAlloc(LPTR, cidl * sizeof(*ppidl));
        if (ppidl)
        {
            LPCITEMIDLIST *ppidlEnd = ppidl + cidl;

            for (int i = cidl - 1; SUCCEEDED(hr) && (i >= 0); --i)
            {
                LPCIDLREGITEM pidlr = _IsReg(apidl[i]);
                if (pidlr)
                {
                    if ((*prgfInOut & SFGAO_VALIDATE) && !_IsDelegate(pidlr))
                    {
                        if (!_IsInNameSpace(pidlr))
                        {
                            // validate by binding
                            IUnknown *punk;
                            hr = _BindToItem(pidlr, NULL, IID_PPV_ARG(IUnknown, &punk), FALSE);
                            if (SUCCEEDED(hr))
                                punk->Release();
                        }
                    }
                    DWORD dwAttributes;
                    hr = _AttributesOf(pidlr, *prgfInOut, &dwAttributes);
                    if (SUCCEEDED(hr))
                        rgfOut &= dwAttributes;
                    cidl--;     // remove this from the list used below...
                }
                else
                {
                    --ppidlEnd;
                    *ppidlEnd = apidl[i];
                }
            }

            if (SUCCEEDED(hr) && cidl)   // any non reg items left?
            {
                ULONG rgfThis = rgfOut;
                hr = _psfOuter->GetAttributesOf(cidl, ppidlEnd, &rgfThis);
                rgfOut &= rgfThis;
            }

            LocalFree((HLOCAL)ppidl);
            *prgfInOut = rgfOut;
        }
        else
            hr = E_OUTOFMEMORY;
    }
    return hr;
}

HRESULT CRegFolder::_CreateDefExtIconKey(HKEY hkey,
                        UINT cidl, LPCITEMIDLIST *apidl, int iItem,
                        REFIID riid, void** ppvOut)
{
    // See if this guy has an icon handler

    TCHAR szHandler[GUIDSTR_MAX];
    HRESULT hr;

    if (hkey &&
        SUCCEEDED(AssocQueryStringByKey(NULL, ASSOCSTR_SHELLEXTENSION, hkey,
                        TEXT("IconHandler"), szHandler, IntToPtr_(LPDWORD, ARRAYSIZE(szHandler)))) &&
        SUCCEEDED(SHExtCoCreateInstance(szHandler, NULL, NULL, riid, ppvOut)))
    {
        IShellExtInit *psei;
        if (SUCCEEDED(((IUnknown*)*ppvOut)->QueryInterface(IID_PPV_ARG(IShellExtInit, &psei))))
        {
            IDataObject *pdto;
            hr = GetUIObjectOf(NULL, cidl, apidl, IID_PPV_ARG_NULL(IDataObject, &pdto));
            if (SUCCEEDED(hr))
            {
                hr = psei->Initialize(_GetFolderIDList(), pdto, hkey);
                pdto->Release();
            }
            psei->Release();
        }
        else
        {   // Object doesn't need to be initialized, no problemo
            hr = S_OK;
        }
        if (SUCCEEDED(hr))
        {
            return S_OK;
        }

        ((IUnknown *)*ppvOut)->Release();  // Lose this bad guy
    }

    // No icon handler (or icon handler punted); look for DefaultIcon key.

    LPCTSTR pszIconFile;
    int iDefIcon;

    if (iItem >= 0)
    {
        pszIconFile = _aReqItems[iItem].pszIconFile;
        iDefIcon = _aReqItems[iItem].iDefIcon;
    }
    else
    {
        pszIconFile = NULL;
        iDefIcon = II_FOLDER;
    }

    return SHCreateDefExtIconKey(hkey, pszIconFile, iDefIcon, iDefIcon, -1, -1, GIL_PERCLASS, riid, ppvOut);
}

HRESULT CRegFolder::GetUIObjectOf(HWND hwnd, UINT cidl, LPCITEMIDLIST *apidl, 
                                  REFIID riid, UINT *prgfInOut, void **ppv)
{
    HRESULT hr;
    
    *ppv = NULL;
    LPCIDLREGITEM pidlr = _AnyRegItem(cidl, apidl);
    if (pidlr)
    {
        IShellFolder *psf;
        if (_AllDelegates(cidl, apidl, &psf))
        {
            hr = psf->GetUIObjectOf(hwnd, cidl, apidl, riid, prgfInOut, ppv);
            psf->Release();
        }
        else
        {
            if (IsEqualIID(riid, IID_IExtractIconA) || IsEqualIID(riid, IID_IExtractIconW))
            {
                HKEY hkCLSID;
                int iItem = _ReqItemIndex(pidlr);

                // try first to get a per-user icon
                hr = SHRegGetCLSIDKey(_GetPIDLRCLSID(pidlr), NULL, TRUE, FALSE, &hkCLSID);
                if (SUCCEEDED(hr))
                {
                    hr = _CreateDefExtIconKey(hkCLSID, cidl, apidl, iItem, riid, ppv);
                    if (hr == S_FALSE)
                    {
                        ((IUnknown *)*ppv)->Release();    // Lose this bad guy
                        *ppv = NULL;
                    }
                    RegCloseKey(hkCLSID);
                }

                //
                // fall back to a per-class icon
                //
                if (*ppv == NULL)
                {
                    SHRegGetCLSIDKey(_GetPIDLRCLSID(pidlr), NULL, FALSE, FALSE, &hkCLSID);
                    hr = _CreateDefExtIconKey(hkCLSID, cidl, apidl, iItem, riid, ppv);
                    RegCloseKey(hkCLSID);
                }
            }
            else if (IsEqualIID(riid, IID_IQueryInfo))
            {
                hr = _GetInfoTip(pidlr, ppv);
            }
            else if (IsEqualIID(riid, IID_IQueryAssociations))
            {
                hr = _AssocCreate(pidlr, riid, ppv);
            }
            else if (IsEqualIID(riid, IID_IDataObject))
            {
                hr = CIDLData_CreateFromIDArray(_GetFolderIDList(), cidl, apidl, (IDataObject **)ppv);
            }
            else if (IsEqualIID(riid, IID_IContextMenu))
            {
                hr = _psfOuter->QueryInterface(IID_PPV_ARG(IShellFolder, &psf));
                if (SUCCEEDED(hr))
                {
                    HKEY keys[2];

                    _GetClassKeys(pidlr, &keys[0], &keys[1]);
                    hr = CDefFolderMenu_Create2Ex(_GetFolderIDList(), hwnd,
                                                   cidl, apidl, 
                                                   psf, this,
                                                   ARRAYSIZE(keys), keys, 
                                                   (IContextMenu **)ppv);

                    SHRegCloseKeys(keys, ARRAYSIZE(keys));
                    psf->Release();
                }
            }
            else if (cidl == 1)
            {
                // blindly delegate unknown riid (IDropTarget, IShellLink, etc) through
                // APP COMPAT!  GetUIObjectOf does not support multilevel pidls, but
                // Symantec Internet Fast Find does a
                //
                //      psfDesktop->GetUIObjectOf(1, &pidlComplex, IID_IDropTarget, ...)
                //
                //  on a multilevel pidl and expects it to work.  I guess it worked by
                //  lucky accident once upon a time, so now it must continue to work,
                //  but only on the desktop.
                //
                hr = _CreateViewObjectFor(pidlr, hwnd, riid, ppv, !_IsDesktop());
            }
            else
            {
                hr = E_NOINTERFACE;
            }
        }
    }
    else
    {
        hr = _psfOuter->GetUIObjectOf(hwnd, cidl, apidl, riid, prgfInOut, ppv);
    }
    return hr;
}

HRESULT CRegFolder::GetDisplayNameOf(LPCITEMIDLIST pidl, DWORD dwFlags, STRRET *pStrRet)
{
    HRESULT hr;
    LPCIDLREGITEM pidlr = _IsReg(pidl);
    if (pidlr)
    {
        LPCITEMIDLIST pidlNext = _ILNext(pidl);

        if (ILIsEmpty(pidlNext))
        {
            TCHAR szName[MAX_PATH];
            hr = _GetDisplayName(pidlr, dwFlags, szName, ARRAYSIZE(szName));
            if (SUCCEEDED(hr))
                hr = StringToStrRet(szName, pStrRet);
        }
        else
        {
            IShellFolder *psfNext;
            hr = _BindToItem(pidlr, NULL, IID_PPV_ARG(IShellFolder, &psfNext), TRUE);
            if (SUCCEEDED(hr))
            {
                hr = psfNext->GetDisplayNameOf(pidlNext, dwFlags, pStrRet);
                //  If it returns an offset to the pidlNext, we should
                // change the offset relative to pidl.
                if (SUCCEEDED(hr) && pStrRet->uType == STRRET_OFFSET)
                    pStrRet->uOffset += (DWORD)((BYTE *)pidlNext - (BYTE *)pidl);

                psfNext->Release();
            }
        }
    }
    else
        hr = _psfOuter->GetDisplayNameOf(pidl, dwFlags, pStrRet);

    return hr;
}

HRESULT CRegFolder::SetNameOf(HWND hwnd, LPCITEMIDLIST pidl, 
                              LPCOLESTR pszName, DWORD dwFlags, LPITEMIDLIST *ppidlOut)
{
    LPCIDLREGITEM pidlr = _IsReg(pidl);
    if (pidlr)
    {
        HRESULT hr = E_INVALIDARG;

        if (ppidlOut)
            *ppidlOut = NULL;

        PDELEGATEITEMID pidld = _IsDelegate(pidlr);
        if (pidld)
        {
            IShellFolder *psf;
            hr = _GetDelegateFolder(pidld, IID_PPV_ARG(IShellFolder, &psf));
            if (SUCCEEDED(hr))
            {
                hr = psf->SetNameOf(hwnd, pidl, pszName, dwFlags, ppidlOut);
                psf->Release();
            }
        }        
        else
        {        
            HKEY hkCLSID;

            _ClearNameFromCache();

            // See if per-user entry exists...
            hr = SHRegGetCLSIDKey(_GetPIDLRCLSID(pidlr), NULL, TRUE, TRUE, &hkCLSID);

            // If no per-user, then use per-machine...
            if (FAILED(hr))
            {
                _GetClassKeys(pidlr, &hkCLSID, NULL);

                if (hkCLSID)
                {
                    hr = S_OK;
                }
                else
                {
                    hr = E_FAIL;
                }
            }

            if (SUCCEEDED(hr))
            {
                TCHAR szName[MAX_PATH];

                SHUnicodeToTChar(pszName, szName, ARRAYSIZE(szName));

                if (RegSetValue(hkCLSID, NULL, REG_SZ, szName, (lstrlen(szName) + 1) * sizeof(szName[0])) == ERROR_SUCCESS)
                {
                    LPITEMIDLIST pidlAbs = ILCombine(_GetFolderIDList(), pidl);
                    if (pidlAbs)
                    {
                        SHChangeNotify(SHCNE_UPDATEITEM, SHCNF_IDLIST, pidlAbs, NULL);
                        ILFree(pidlAbs);
                    }

                    if (ppidlOut)
                        *ppidlOut = ILClone(pidl);  // name is not in the PIDL so old == new

                    hr = S_OK;
                }
                else
                    hr = E_FAIL;

                RegCloseKey(hkCLSID);
            }
        }
        return hr;
    }
    return _psfOuter->SetNameOf(hwnd, pidl, pszName, dwFlags, ppidlOut);
}

HRESULT CRegFolder::GetDefaultSearchGUID(LPGUID lpGuid)
{
    return _psfOuter->GetDefaultSearchGUID(lpGuid);
}   

HRESULT CRegFolder::EnumSearches(LPENUMEXTRASEARCH *ppenum)
{
    return _psfOuter->EnumSearches(ppenum);
}

HRESULT CRegFolder::GetDefaultColumn(DWORD dwRes, ULONG *pSort, ULONG *pDisplay)
{
    return _psfOuter->GetDefaultColumn(dwRes, pSort, pDisplay);
}

HRESULT CRegFolder::GetDefaultColumnState(UINT iColumn, DWORD *pbState)
{
    return _psfOuter->GetDefaultColumnState(iColumn, pbState);
}

HRESULT CRegFolder::GetDetailsEx(LPCITEMIDLIST pidl, const SHCOLUMNID *pscid, VARIANT *pv)
{
    HRESULT hr = E_NOTIMPL;
    LPCIDLREGITEM pidlr = _IsReg(pidl);
    if (pidlr)
    {
        PDELEGATEITEMID pidld = _IsDelegate(pidlr);
        if (pidld)
        {
            IShellFolder2 *psf2;
            hr = _GetDelegateFolder(pidld, IID_PPV_ARG(IShellFolder2, &psf2));
            if (SUCCEEDED(hr))
            {
                hr = psf2->GetDetailsEx(pidl, pscid, pv);
                psf2->Release();
            }
        }        
        else
        {
            TCHAR szTemp[INFOTIPSIZE];
            szTemp[0] = 0;
            if (IsEqualSCID(*pscid, SCID_DESCRIPTIONID))
            {
                SHDESCRIPTIONID did;
                did.dwDescriptionId = SHDID_ROOT_REGITEM;
                did.clsid = _GetPIDLRCLSID(pidlr);
                hr = InitVariantFromBuffer(pv, &did, sizeof(did));
            }
            else if (IsEqualSCID(*pscid, SCID_NAME))
            {
                _GetDisplayName(pidlr, SHGDN_NORMAL, szTemp, ARRAYSIZE(szTemp));
                hr = InitVariantFromStr(pv, szTemp);                    
            }
            else if (IsEqualSCID(*pscid, SCID_TYPE))
            {
                LoadString(HINST_THISDLL, IDS_DRIVES_REGITEM, szTemp, ARRAYSIZE(szTemp));
                hr = InitVariantFromStr(pv, szTemp);                    
            }
            else if (IsEqualSCID(*pscid, SCID_Comment))
            {
                _GetRegItemColumnFromRegistry(pidlr, TEXT("InfoTip"), szTemp, ARRAYSIZE(szTemp));
                hr = InitVariantFromStr(pv, szTemp);                    
            }
            else if (IsEqualSCID(*pscid, SCID_FolderIntroText))
            {
                _GetRegItemColumnFromRegistry(pidlr, TEXT("IntroText"), szTemp, ARRAYSIZE(szTemp));
                hr = InitVariantFromStr(pv, szTemp);                    
            }
            else
            {
                TCHAR ach[SCIDSTR_MAX];
                StringFromSCID(pscid, ach, ARRAYSIZE(ach));                    
                hr = _GetRegItemVariantFromRegistry(pidlr, ach, pv);
            }
        }
    }
    else
    {
        hr = _psfOuter->GetDetailsEx(pidl, pscid, pv);
    }
    return hr;
}

HRESULT CRegFolder::GetDetailsOf(LPCITEMIDLIST pidl, UINT iColumn, SHELLDETAILS *pDetail)
{
    HRESULT hr = E_FAIL;
    LPCIDLREGITEM pidlr = _IsReg(pidl);
    if (pidlr)
    {
        pDetail->str.uType = STRRET_CSTR;
        pDetail->str.cStr[0] = 0;
        SHCOLUMNID scid;

        hr = _psfOuter->MapColumnToSCID(iColumn, &scid);
        if (SUCCEEDED(hr))
        {
            VARIANT var = {0};
            hr = GetDetailsEx(pidl, &scid, &var);
            if (SUCCEEDED(hr))
            {
                // we need to use SHFormatForDisplay (or we could have use IPropertyUI)
                // to format arbitrary properties into the right display type

                TCHAR szText[MAX_PATH];
                hr = SHFormatForDisplay(scid.fmtid, scid.pid, (PROPVARIANT *)&var, 
                    PUIFFDF_DEFAULT, szText, ARRAYSIZE(szText));
                if (SUCCEEDED(hr))
                {
                    hr = StringToStrRet(szText, &pDetail->str);
                }
                VariantClear(&var);
            }
        }
    }
    else
    {
        hr = _psfOuter->GetDetailsOf(pidl, iColumn, pDetail);
    }
    return hr;
}

HRESULT CRegFolder::MapColumnToSCID(UINT iColumn, SHCOLUMNID *pscid)
{
    return _psfOuter->MapColumnToSCID(iColumn, pscid);
}

HRESULT CRegFolder::_GetOverlayInfo(LPCIDLREGITEM pidlr, int *pIndex, BOOL fIconIndex)
{
    HRESULT hr = E_FAIL;
    const CLSID clsid = _GetPIDLRCLSID(pidlr);    // alignment  
    if (SHQueryShellFolderValue(&clsid, TEXT("QueryForOverlay")))
    {
        IShellIconOverlay* psio;
        hr = _BindToItem(pidlr, NULL, IID_PPV_ARG(IShellIconOverlay, &psio), TRUE);
        if (SUCCEEDED(hr))
        {
            // NULL pidl means "I want to know about YOU, folder, not one of your kids",
            // we only pass that though when its is not a deligate.

            LPITEMIDLIST pidlToPass = (LPITEMIDLIST)_IsDelegate(pidlr);
            if (fIconIndex)
                hr = psio->GetOverlayIconIndex(pidlToPass, pIndex);
            else
                hr = psio->GetOverlayIndex(pidlToPass, pIndex);

            psio->Release();
        }
    }

    return hr;
}

// IShellIconOverlay
HRESULT CRegFolder::GetOverlayIndex(LPCITEMIDLIST pidl, int *pIndex)
{
    HRESULT hr = E_FAIL;

    LPCIDLREGITEM pidlr = _IsReg(pidl);
    if (pidlr)
    {
        hr = _GetOverlayInfo(pidlr, pIndex, FALSE);
    }
    else if (_psioOuter)
    {
        hr = _psioOuter->GetOverlayIndex(pidl, pIndex);
    }

    return hr;
}

HRESULT CRegFolder::GetOverlayIconIndex(LPCITEMIDLIST pidl, int *pIconIndex)
{
    HRESULT hr = E_FAIL;

    LPCIDLREGITEM pidlr = _IsReg(pidl);
    if (pidlr)
    {
        hr = _GetOverlayInfo(pidlr, pIconIndex, TRUE);
    }
    else if (_psioOuter)
    {
        hr = _psioOuter->GetOverlayIconIndex(pidl, pIconIndex);
    }

    return hr;
}


// CContextMenuCB

DWORD CALLBACK _RegFolderPropThreadProc(void *pv)
{
    PROPSTUFF *pdps = (PROPSTUFF *)pv;
    CRegFolder *prf = (CRegFolder *)pdps->psf;
    STGMEDIUM medium;
    ULONG_PTR dwCookie = 0;
    ActivateActCtx(NULL, &dwCookie);

    LPIDA pida = DataObj_GetHIDA(pdps->pdtobj, &medium);
    if (pida)
    {
        LPCIDLREGITEM pidlr = prf->_IsReg(IDA_GetIDListPtr(pida, 0));
        if (pidlr)
        {
            int iItem = prf->_ReqItemIndex(pidlr);
            if (iItem >= 0 && prf->_aReqItems[iItem].pszCPL)
                SHRunControlPanel(prf->_aReqItems[iItem].pszCPL, NULL);
            else
            {
                TCHAR szName[MAX_PATH];
                if (SUCCEEDED(prf->_GetDisplayName(pidlr, SHGDN_NORMAL, szName, ARRAYSIZE(szName))))
                {
                    HKEY hk;

                    prf->_GetClassKeys(pidlr, &hk, NULL);

                    if (hk)
                    {
                        SHOpenPropSheet(szName, &hk, 1, NULL, pdps->pdtobj, NULL, (LPCTSTR)pdps->pStartPage);
                        RegCloseKey(hk);
                    }
                }   
            }
        }
        HIDA_ReleaseStgMedium(pida, &medium);
    }
    return 0;
}

DWORD DisconnectDialogOnThread(void *pv)
{
    WNetDisconnectDialog(NULL, RESOURCETYPE_DISK);
    SHChangeNotifyHandleEvents();       // flush any drive notifications
    return 0;
}

HRESULT CRegFolder::CallBack(IShellFolder *psf, HWND hwnd, IDataObject *pdtobj, 
                                       UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    HRESULT hr = S_OK;

    switch (uMsg)
    {
    case DFM_MERGECONTEXTMENU:
        {
            STGMEDIUM medium;
            LPIDA pida = DataObj_GetHIDA(pdtobj, &medium);
            if (pida)
            {
                // some ugly specal cases...
                if (HIDA_GetCount(medium.hGlobal) == 1)
                {
                    LPCIDLREGITEM pidlr = _IsReg(IDA_GetIDListPtr(pida, 0));
                    if (pidlr && !_IsDelegate(pidlr))
                    {
                        const CLSID clsid = _GetPIDLRCLSID(pidlr);  // alignment

                        if ((IsEqualGUID(clsid, CLSID_MyComputer) ||
                             IsEqualGUID(clsid, CLSID_NetworkPlaces)) &&
                            (GetSystemMetrics(SM_NETWORK) & RNC_NETWORKS) &&
                             !SHRestricted(REST_NONETCONNECTDISCONNECT))
                        {
                            CDefFolderMenu_MergeMenu(HINST_THISDLL, POPUP_DESKTOP_ITEM, 0, (LPQCMINFO)lParam);
                        }
                    }
                }
                HIDA_ReleaseStgMedium(pida, &medium);
            }
        }
        break;

    case DFM_GETHELPTEXT:
        LoadStringA(HINST_THISDLL, LOWORD(wParam) + IDS_MH_FSIDM_FIRST, (LPSTR)lParam, HIWORD(wParam));;
        break;

    case DFM_GETHELPTEXTW:
        LoadStringW(HINST_THISDLL, LOWORD(wParam) + IDS_MH_FSIDM_FIRST, (LPWSTR)lParam, HIWORD(wParam));;
        break;

    case DFM_INVOKECOMMANDEX:
        {
            DFMICS *pdfmics = (DFMICS *)lParam;
            switch (wParam)
            {
            case FSIDM_CONNECT:
                SHStartNetConnectionDialog(NULL, NULL, RESOURCETYPE_DISK);
                break;

            case FSIDM_DISCONNECT:
                SHCreateThread(DisconnectDialogOnThread, NULL, CTF_COINIT, NULL);
                break;

            case DFM_CMD_PROPERTIES:
                hr = SHLaunchPropSheet(_RegFolderPropThreadProc, pdtobj, (LPCTSTR)pdfmics->lParam, this, NULL);
                break;

            case DFM_CMD_DELETE:
                _Delete(hwnd, pdfmics->fMask, pdtobj);
                break;

            default:
                // This is one of view menu items, use the default code.
                hr = S_FALSE;
                break;
            }
        }
        break;

    default:
        hr = E_NOTIMPL;
        break;
    }
    return hr;
}

// IRegItemsFolder

TCHAR const c_szRegExplorerBackslash[] = REGSTR_PATH_EXPLORER  TEXT("\\");

HRESULT CRegFolder::Initialize(REGITEMSINFO *pri)
{
    ASSERT(pri != NULL);
    HRESULT hr = E_INVALIDARG;

    _pszRegKey        = pri->pszRegKey;
    _pPolicy          = pri->pPolicy;
    _chRegItem        = pri->cRegItem;
    _bFlags           = pri->bFlags;
    _iTypeOuter       = pri->iCmp > 0 ? REGORDERTYPE_OUTERAFTER : REGORDERTYPE_OUTERBEFORE ;
    _dwDefAttributes  = pri->rgfRegItems;
    _dwSortAttrib     = pri->dwSortAttrib;
    _cbPadding        = pri->cbPadding;
    _bFlagsLegacy     = pri->bFlagsLegacy;

    // If the registry key lives under HKEY_PATH_EXPLORER, then
    // we will also support per-session regitems.
    //
    int cchPrefix = ARRAYSIZE(c_szRegExplorerBackslash) - 1;
    if (StrCmpNI(_pszRegKey, c_szRegExplorerBackslash, cchPrefix) == 0)
    {
        _pszSesKey = _pszRegKey + cchPrefix;
    } 
    else 
    {
        _pszSesKey = NULL;
    }

    if ((RIISA_ORIGINAL == _dwSortAttrib) ||
        (RIISA_FOLDERFIRST == _dwSortAttrib) ||
        (RIISA_ALPHABETICAL == _dwSortAttrib))
    {
        Str_SetPtr(&_pszMachine, pri->pszMachine);    // save a copy of this

        _aReqItems = (REQREGITEM *)LocalAlloc(LPTR, sizeof(*_aReqItems) * pri->iReqItems);
        if (!_aReqItems)
            return E_OUTOFMEMORY;

        memcpy(_aReqItems, pri->pReqItems, sizeof(*_aReqItems) * pri->iReqItems);
        _nRequiredItems = pri->iReqItems;

        // If we are aggregated, cache the _psioOuter and _psfOuter
        _QueryOuterInterface(IID_PPV_ARG(IShellIconOverlay, &_psioOuter));
        hr = _QueryOuterInterface(IID_PPV_ARG(IShellFolder2, &_psfOuter));
    }
    return hr;
}


//
// instance creation of the RegItems object
//

STDAPI CRegFolder_CreateInstance(REGITEMSINFO *pri, IUnknown *punkOuter, REFIID riid, void **ppv) 
{
    HRESULT hr;

    // we only suport being created as an agregate
    if (!punkOuter || !IsEqualIID(riid, IID_IUnknown))
    {
        ASSERT(0);
        return E_FAIL;
    }

    CRegFolder *prif = new CRegFolder(punkOuter);
    if (prif)
    {
        hr = prif->Initialize(pri);           // initialize the regfolder
        if (SUCCEEDED(hr))
            hr = prif->_GetInner()->QueryInterface(riid, ppv);

        //
        //  If the Initalize and QueryInterface succeeded, this will drop
        //  the refcount from 2 to 1.  If they failed, then this will drop
        //  the refcount from 1 to 0 and free the object.
        //
        ULONG cRef = prif->_GetInner()->Release();

        //
        //  On success, the object should have a refcout of exactly 1.
        //  On failure, the object should have a refcout of exactly 0.
        //
        ASSERT(SUCCEEDED(hr) == (BOOL)cRef);
    }
    else
        hr = E_OUTOFMEMORY;

    return hr;
}

CRegFolderEnum::CRegFolderEnum(CRegFolder* prf, DWORD grfFlags, IEnumIDList* peidl, 
                               HDCA hdca, HDCA hdcaDel, 
                               REGITEMSPOLICY* pPolicy) :
    _cRef(1),
    _grfFlags(grfFlags),
    _prf(prf),
    _peidl(peidl),
    _hdca(hdca),
    _pPolicy(pPolicy),
    _hdcaDel(hdcaDel)
{
    ASSERT(_iCur == 0);
    ASSERT(_iCurDel == 0);
    ASSERT(_peidlDel == NULL);

    _prf->AddRef();

    if (_peidl)
        _peidl->AddRef();

    DllAddRef();
}

CRegFolderEnum::~CRegFolderEnum()
{
    if (_hdca)
        DCA_Destroy(_hdca);
    if (_hdcaDel)
        DCA_Destroy(_hdcaDel);

    ATOMICRELEASE(_prf);
    ATOMICRELEASE(_peidl);
    ATOMICRELEASE(_peidlDel);

    DllRelease();
}

//
// IUnknown
//

STDMETHODIMP_(ULONG) CRegFolderEnum::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

STDMETHODIMP_(ULONG) CRegFolderEnum::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}

HRESULT CRegFolderEnum::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] =  {
        QITABENT(CRegFolderEnum, IEnumIDList), // IID_IEnumIDList
        QITABENT(CRegFolderEnum, IObjectWithSite), // IID_IObjectWithSite
        { 0 },
    };    
    return QISearch(this, qit, riid, ppv);
}

//
// IEnumIDList
//

BOOL CRegFolderEnum::_TestFolderness(DWORD dwAttribItem)
{
    if ((_grfFlags & (SHCONTF_FOLDERS | SHCONTF_NONFOLDERS)) != (SHCONTF_FOLDERS | SHCONTF_NONFOLDERS))
    {
        if (dwAttribItem & SFGAO_FOLDER)
        {
            if (!(_grfFlags & SHCONTF_FOLDERS))
                return FALSE;
        }
        else
        {
            if (!(_grfFlags & SHCONTF_NONFOLDERS))
                return FALSE;
        }
    }
    return TRUE;
}

BOOL CRegFolderEnum::_TestHidden(LPCIDLREGITEM pidlRegItem)
{
    CLSID clsidRegItem = _prf->_GetPIDLRCLSID(pidlRegItem);
    return _TestHiddenInWebView(&clsidRegItem) || _TestHiddenInDomain(&clsidRegItem);
}

BOOL CRegFolderEnum::_TestHiddenInWebView(LPCLSID clsidRegItem)
{
    BOOL fRetVal = FALSE;
    if (S_FALSE == SHShouldShowWizards(_punkSite))
    {
        fRetVal = SHQueryShellFolderValue(clsidRegItem, TEXT("HideInWebView"));
    }
    return fRetVal;
}

BOOL CRegFolderEnum::_TestHiddenInDomain(LPCLSID clsidRegItem)
{
    return IsOS(OS_DOMAINMEMBER) && SHQueryShellFolderValue(clsidRegItem, TEXT("HideInDomain"));
}

// Check policy restrictions
BOOL CRegFolderEnum::_IsRestricted()
{
    BOOL bIsRestricted = FALSE;
    if (_pPolicy)
    {
        TCHAR szName[256];
        szName[0] = 0;
    
        HKEY hkRoot;
        if (RegOpenKey(HKEY_CLASSES_ROOT, _T("CLSID"), &hkRoot) == ERROR_SUCCESS)
        {
            TCHAR szGUID[64];
            SHStringFromGUID(*DCA_GetItem(_hdca, _iCur - 1), szGUID, ARRAYSIZE(szGUID));
        
            SHLoadLegacyRegUIString(hkRoot, szGUID, szName, ARRAYSIZE(szName));
            RegCloseKey(hkRoot);
        }

        if (szName[0])
        {
            if (SHRestricted(_pPolicy->restAllow) && !IsNameListedUnderKey(szName, _pPolicy->pszAllow))
                bIsRestricted = TRUE;

            if (SHRestricted(_pPolicy->restDisallow) && IsNameListedUnderKey(szName, _pPolicy->pszDisallow))
                bIsRestricted = TRUE;
        }
    }
    return bIsRestricted;
}

BOOL CRegFolderEnum::_WrongMachine()
{
    BOOL bWrongMachine = FALSE;

    // We're filling the regitem with class id clsid. If this is a
    // remote item, first invoke the class to see if it really wants
    // to be enumerated for this remote computer.
    if (_prf->_pszMachine)
    {
        IUnknown* punk;
        // Don't need DCA_ExtCreateInstance since these keys come from
        // HKLM which is already trusted and HKCU which is the user's
        // own fault.
        HRESULT hr = DCA_CreateInstance(_hdca, _iCur - 1, IID_PPV_ARG(IUnknown, &punk));
        if (SUCCEEDED(hr))
        {
            hr = _prf->_InitFromMachine(punk, TRUE);
            punk->Release();
        }
        
        bWrongMachine = FAILED(hr);
    }
    return bWrongMachine;
}

HRESULT CRegFolderEnum::Next(ULONG celt, LPITEMIDLIST *ppidlOut, ULONG *pceltFetched)
{
    // enumerate from the DCA containing the regitems objects
    if (_hdca)
    {
        if (0 == (SHCONTF_NETPRINTERSRCH & _grfFlags)) //don't enumerate phantom folders for printer search dialog
        {
            while (_iCur < DCA_GetItemCount(_hdca))
            {
                _iCur++;

                if (_WrongMachine())
                    continue;

                if (_IsRestricted())
                    continue;

                // Ok, actually enumerate the item
                
                HRESULT hr;
                IDLREGITEM* pidlRegItem = _prf->_CreateAndFillIDLREGITEM(DCA_GetItem(_hdca, _iCur-1));
                if (pidlRegItem)
                {
                    DWORD dwAttribItem;
                    _prf->_AttributesOf(pidlRegItem, SFGAO_NONENUMERATED | SFGAO_FOLDER, &dwAttribItem);
    
                    if (!(dwAttribItem & SFGAO_NONENUMERATED) &&
                        _TestFolderness(dwAttribItem) &&
                        !_TestHidden(pidlRegItem))
                    {
                        *ppidlOut = (LPITEMIDLIST)pidlRegItem;
                        hr = S_OK;
                    }
                    else
                    {
                        SHFree(pidlRegItem);
                        continue;
                    }
                }
                else
                {
                    hr = E_OUTOFMEMORY;
                }
                
                if (SUCCEEDED(hr) && pceltFetched)
                    *pceltFetched = 1;
                
                return hr;
            }
        }
    }

    // enumerate from the DCA containing the delegate shell folders

    while (_peidlDel || (_hdcaDel && (_iCurDel < DCA_GetItemCount(_hdcaDel))))
    {
        // we have an enumerator object, so lets call it and see
        // what it generates, if it runs out of items then we either
        // give up (saying were done) or allow us to be called again.

        if (_peidlDel)
        {
            if (S_OK == _peidlDel->Next(celt, ppidlOut, pceltFetched))
                return S_OK;

            ATOMICRELEASE(_peidlDel);
        }
        else
        {
            // we didn't have an enumerator to call, so lets try and 
            // create an new IDelegateFolderObject, if that worked
            // then we can set its item allocator, then get an
            // enumerator back from it.

            IShellFolder *psfDelegate;
            if (SUCCEEDED(_prf->_CreateDelegateFolder(DCA_GetItem(_hdcaDel, _iCurDel++), IID_PPV_ARG(IShellFolder, &psfDelegate))))
            {
                psfDelegate->EnumObjects(NULL, _grfFlags, &_peidlDel);
                psfDelegate->Release();
            }
        }
    }     

    // now DKA, or we are just about done so lets pass to the inner ISF
    // and see what they return.

    if (_peidl)
        return _peidl->Next(celt, ppidlOut, pceltFetched);

    *ppidlOut = NULL;
    if (pceltFetched)
        pceltFetched = 0;

    return S_FALSE;
}

STDMETHODIMP CRegFolderEnum::Reset()
{
    // Adaptec Easy CD Creator (versions 3.0, 3.01, 3.5) enumerates the
    // items in an IShellFolder like this:
    //
    //  psf->EnumObjects(&penum);
    //  UINT cObjects = 0;
    //  while (SUCCEEDED(penum->Next(...)) {
    //      [code]
    //      penum->Reset();
    //      penum->Skip(++cObjects);
    //  }
    //
    //  So they took an O(n) algorithm and turned it into an O(n^2)
    //  algorithm.  They got away with it because in the old days,
    //  regfldr implemented neither IEnumIDList::Reset nor
    //  IEnumIDList::Skip, so the two calls were just NOPs.
    //
    //  Now we implement IEnumIDList::Reset, so without this hack,
    //  they end up enumerating the same object over and over again.

    if (SHGetAppCompatFlags(ACF_IGNOREENUMRESET) & ACF_IGNOREENUMRESET)
        return E_NOTIMPL;

    _iCurDel = _iCur = 0;
    ATOMICRELEASE(_peidlDel);

    if (_peidl)
        return _peidl->Reset();

    return S_OK;
}

STDMETHODIMP CRegFolderEnum::SetSite(IUnknown *punkSite)
{
    IUnknown_SetSite(_peidl, punkSite);

    return CObjectWithSite::SetSite(punkSite);
}

//
// Delegate Malloc functions
//

#undef new // Hack!! Need to remove this (daviddv)

class CDelagateMalloc : public IMalloc
{
public:
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID,void **);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);

    // IMalloc
    STDMETHODIMP_(void *) Alloc(SIZE_T cb);
    STDMETHODIMP_(void *) Realloc(void *pv, SIZE_T cb);
    STDMETHODIMP_(void) Free(void *pv);
    STDMETHODIMP_(SIZE_T) GetSize(void *pv);
    STDMETHODIMP_(int) DidAlloc(void *pv);
    STDMETHODIMP_(void) HeapMinimize();

private:
    CDelagateMalloc(void *pv, SIZE_T cbSize, WORD wOuter);
    ~CDelagateMalloc() {}
    void* operator new(size_t cbClass, SIZE_T cbSize)
    {
        return ::operator new(cbClass + cbSize);
    }


    friend HRESULT CDelegateMalloc_Create(void *pv, SIZE_T cbSize, WORD wOuter, IMalloc **ppmalloc);

protected:
    LONG _cRef;
    WORD _wOuter;           // delegate item outer signature
    WORD _wUnused;          // to allign
#ifdef DEBUG
    UINT _cAllocs;
#endif
    SIZE_T _cb;
    BYTE _data[EMPTY_SIZE];
};

CDelagateMalloc::CDelagateMalloc(void *pv, SIZE_T cbSize, WORD wOuter)
{
    _cRef = 1;
    _wOuter = wOuter;
    _cb = cbSize;

    memcpy(_data, pv, _cb);
}

HRESULT CDelagateMalloc::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CDelagateMalloc, IMalloc),
        { 0 },
    };
    return QISearch(this, qit, riid, ppvObj);
}

ULONG CDelagateMalloc::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CDelagateMalloc::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}

// the cbInner is the size of the data needed by the delegate. we need to compute
// the full size of the pidl for the allocation and init that we the outer folder data

void *CDelagateMalloc::Alloc(SIZE_T cbInner)
{
    DELEGATEITEMID *pidl;
    SIZE_T cbAlloc = 
        sizeof(DELEGATEITEMID) - sizeof(pidl->rgb[0]) + // header
        cbInner +                                       // inner
        _cb +                                           // outer data
        sizeof(WORD);                                   // trailing null (pidl terminator)

    pidl = (DELEGATEITEMID *)SHAlloc(cbAlloc);
    if (pidl)
    {
        ZeroMemory(pidl, cbAlloc);              // make it all empty
        pidl->cbSize = (WORD)cbAlloc - sizeof(WORD);
        pidl->wOuter = _wOuter;
        pidl->cbInner = (WORD)cbInner;
        memcpy(&pidl->rgb[cbInner], _data, _cb);
#ifdef DEBUG
        _cAllocs++;
#endif
    }
    return pidl;
}

void *CDelagateMalloc::Realloc(void *pv, SIZE_T cb)
{
    return NULL;
}

void CDelagateMalloc::Free(void *pv)
{
    SHFree(pv);
}

SIZE_T CDelagateMalloc::GetSize(void *pv)
{
    return (SIZE_T)-1;
}

int CDelagateMalloc::DidAlloc(void *pv)
{
    return -1;
}

void CDelagateMalloc::HeapMinimize()
{
}

STDAPI CDelegateMalloc_Create(void *pv, SIZE_T cbSize, WORD wOuter, IMalloc **ppmalloc)
{
    HRESULT hr;
    CDelagateMalloc *pdm = new(cbSize) CDelagateMalloc(pv, cbSize, wOuter);
    if (pdm)
    {
        hr = pdm->QueryInterface(IID_PPV_ARG(IMalloc, ppmalloc));
        pdm->Release();
    }
    else
        hr = E_OUTOFMEMORY;
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\regsuprt.h ===
#ifndef __REGSUPRT_H
#define __REGSUPRT_H

#define REG_OPTION_INVALID  0xFFFFFFFF

// MAX_ROOT is the maximum we support for the root
#define MAX_ROOT            MAX_PATH

class CRegSupport
{
public:
    CRegSupport();
    virtual ~CRegSupport();

public:
    void RSInitRoot(HKEY hkey, LPCTSTR pszSubKey1, LPCTSTR pszSubKey2, 
        DWORD dwRootOptions = REG_OPTION_VOLATILE, 
        DWORD dwDefaultOptions = REG_OPTION_VOLATILE);

    virtual BOOL RSValueExist(LPCTSTR pszSubKey, LPCTSTR pszValueName);
    virtual BOOL RSSubKeyExist(LPCTSTR pszSubKey);

    virtual BOOL RSDeleteValue(LPCTSTR pszSubKey, LPCTSTR pszValueName);
    virtual BOOL RSDeleteSubKey(LPCTSTR pszSubKey);
    virtual BOOL RSDeleteKey();

    virtual HKEY RSDuplicateRootKey();
    virtual HKEY RSDuplicateSubKey(LPCTSTR pszSubKey, BOOL fCreate, BOOL fVolatile);

    BOOL RSGetTextValue(LPCTSTR pszSubKey, LPCTSTR pszValueName,
                               LPTSTR pszValue, DWORD* pcchValue);
    BOOL RSGetBinaryValue(LPCTSTR pszSubKey, LPCTSTR pszValueName,
                               PBYTE pb, DWORD* pcb);
    BOOL RSGetDWORDValue(LPCTSTR pszSubKey, LPCTSTR pszValueName, DWORD* pdwValue);

    BOOL RSSetTextValue(LPCTSTR pszSubKey, LPCTSTR pszValueName, LPCTSTR pszValue,
        DWORD dwOptions = REG_OPTION_INVALID);
    BOOL RSSetBinaryValue(LPCTSTR pszSubKey, LPCTSTR pszValueName, PBYTE pb, DWORD cb,
        DWORD dwOptions = REG_OPTION_INVALID);
    BOOL RSSetDWORDValue(LPCTSTR pszSubKey, LPCTSTR pszValueName, DWORD dwValue,
        DWORD dwOptions = REG_OPTION_INVALID);

protected:
    virtual void _CloseRegSubKey(HKEY hkeyVolumeSubKey);

    virtual HKEY _GetRootKey(BOOL fCreate, DWORD dwOptions = REG_OPTION_INVALID);

    virtual BOOL _SetGeneric(LPCTSTR pszSubKey, LPCTSTR pszValueName,
                                PBYTE pb, DWORD cb, DWORD dwType,
                                DWORD dwOptions);
    virtual BOOL _GetGeneric(LPCTSTR pszSubKey, LPCTSTR pszValueName,
                                PBYTE pb, DWORD* pcb);

    HKEY _GetSubKey(LPCTSTR pszSubKey, BOOL fCreate,
        DWORD dwOptions = REG_OPTION_INVALID);

    static HKEY _RegCreateKeyExHelper(HKEY hkey, LPCTSTR pszSubKey,
        DWORD dwOptions);
    static HKEY _RegOpenKeyExHelper(HKEY hkey, LPCTSTR pszSubKey);

protected:
    virtual BOOL _InitSetRoot(LPCTSTR pszSubKey1, LPCTSTR pszSubKey2);
    void _InitCSKeyRoot();
    void _EnterCSKeyRoot();
    void _LeaveCSKeyRoot();

    virtual LPCTSTR _GetRoot(LPTSTR pszRoot, DWORD cchRoot);

protected:
    LPCTSTR                 _pszSubKey1;
    LPCTSTR                 _pszSubKey2;

private:
    DWORD                   _dwRootOptions;
    DWORD                   _dwDefaultOptions;

    HKEY                    _hkeyInit; // HKEY_CURRENT_USER, ...
    
    CRITICAL_SECTION        _csKeyRoot;
    BOOL                    _fcsKeyRoot;

#ifdef DEBUG
    static UINT             _cRefHKEY;
    static UINT             _cRefExternalHKEY;

    BOOL                    _fInited;
#endif
};

#endif //__REGSUPRT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\regtreeitems.cpp ===
#include "shellprv.h"
#include "clsobj.h"
#include "theme.h"


class CRegTreeItemBase : public IRegTreeItem
{
public:
    STDMETHODIMP QueryInterface(REFIID riid, void** ppvObj)
    {
        static const QITAB qit[] =
        {
            QITABENT(CRegTreeItemBase, IRegTreeItem),
            { 0 },
        };

        return QISearch(this, qit, riid, ppvObj);
    }
    STDMETHODIMP_(ULONG) AddRef()
    {
        return ++_cRef;
    }
    STDMETHODIMP_(ULONG) Release()
    {
        if (--_cRef == 0)
        {
            delete this;
            return 0;
        }
        return _cRef;
    }
    STDMETHODIMP GetCheckState(BOOL *pbCheck) PURE;
    STDMETHODIMP SetCheckState(BOOL bCheck) PURE;

    virtual ~CRegTreeItemBase() { }

protected:
    CRegTreeItemBase() : _cRef(1) { }

    ULONG _cRef;
};


class CWebViewRegTreeItem : public CRegTreeItemBase
{
public:
    STDMETHODIMP GetCheckState(BOOL *pbCheck)
    {
        SHELLSTATE ss;
        SHGetSetSettings(&ss, SSF_WEBVIEW, FALSE);
        *pbCheck = BOOLIFY(ss.fWebView);

        return S_OK;
    }

    STDMETHODIMP SetCheckState(BOOL bCheck)
    {
        SHELLSTATE ss;
        ss.fWebView = bCheck;
        SHGetSetSettings(&ss, SSF_WEBVIEW, TRUE);

        return S_OK;
    }

protected:

    friend HRESULT CWebViewRegTreeItem_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv);
};

// aggregation checking is handled in class factory

HRESULT CWebViewRegTreeItem_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv)
{
    HRESULT hr = E_OUTOFMEMORY;
    CWebViewRegTreeItem* pwvi = new CWebViewRegTreeItem();
    if (pwvi)
    {
        hr = pwvi->QueryInterface(riid, ppv);
        pwvi->Release();
    }

    return hr;
}

class CThemesRegTreeItem : public CRegTreeItemBase
{
    CThemesRegTreeItem() { m_fVisualStyleOn = 2;}
    
public:
    STDMETHODIMP GetCheckState(BOOL *pbCheck)
    {
        // We want to return TRUE if the visual style has a path.
        IThemeManager * pThemeManager;
        HRESULT hr = CoCreateInstance(CLSID_ThemeManager, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IThemeManager, &pThemeManager));

        *pbCheck = FALSE;
        if (SUCCEEDED(hr))
        {
            IThemeScheme * pThemeScheme;

            hr = pThemeManager->get_SelectedScheme(&pThemeScheme);
            if (SUCCEEDED(hr))
            {
                CComBSTR bstrPathSelected;

                // This will return failure if no "Visual Style" is selected.
                if (SUCCEEDED(pThemeScheme->get_Path(&bstrPathSelected)) &&
                    bstrPathSelected && bstrPathSelected[0])
                {
                    *pbCheck = TRUE;
                }

                pThemeScheme->Release();
            }

            pThemeManager->Release();
        }

        m_fVisualStyleOn = *pbCheck;
        return hr;
    }


    STDMETHODIMP SetCheckState(BOOL bCheck)
    {
        HRESULT hr = S_OK;

        if (2 == m_fVisualStyleOn)
        {
            GetCheckState(&m_fVisualStyleOn);
        }

        // The user will loose settings when visual styles are switch so
        // only do it if the user made a change.
        if (bCheck != m_fVisualStyleOn)
        {
            IThemeManager * pThemeManager;

            hr = CoCreateInstance(CLSID_ThemeManager, NULL, CLSCTX_INPROC_SERVER, IID_PPV_ARG(IThemeManager, &pThemeManager));
            if (SUCCEEDED(hr))
            {
                IThemeScheme * pThemeSchemeNew;
                IThemeStyle * pThemeColorNew;
                IThemeSize * pThemeSizeNew;

                hr = pThemeManager->GetSpecialScheme((bCheck ? SZ_SSDEFAULVISUALSTYLEON : SZ_SSDEFAULVISUALSTYLEOFF), &pThemeSchemeNew, &pThemeColorNew, &pThemeSizeNew);
                if (SUCCEEDED(hr))
                {
                    hr = pThemeColorNew->put_SelectedSize(pThemeSizeNew);
                    if (SUCCEEDED(hr))
                    {
                        hr = pThemeSchemeNew->put_SelectedStyle(pThemeColorNew);
                        if (SUCCEEDED(hr))
                        {
                            hr = pThemeManager->put_SelectedScheme(pThemeSchemeNew);
                            if (SUCCEEDED(hr))
                            {
                                // This ApplyNow() call will take a little while in normal situation (~10-20 seconds) in order
                                // to broadcast the message to all open apps.  If a top level window is hung, it may take the
                                // full 30 seconds to timeout.  This code may want to move this code onto a background thread.
                                hr = pThemeManager->ApplyNow();
                            }
                        }
                    }

                    pThemeSchemeNew->Release();
                    pThemeColorNew->Release();
                    pThemeSizeNew->Release();
                }

                pThemeManager->Release();
            }
        }

        return hr;
    }

protected:
    friend HRESULT CThemesRegTreeItem_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv);

private:
    BOOL    m_fVisualStyleOn;
};

HRESULT CThemesRegTreeItem_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv)
{
    HRESULT hr = E_OUTOFMEMORY;
    CThemesRegTreeItem* pti = new CThemesRegTreeItem();
    if (pti)
    {
        hr = pti->QueryInterface(riid, ppv);
        pti->Release();
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\reglist.h ===
//---------------------------------------------------------------------------
//
// Copyright (c) Microsoft Corporation 1991-1993
//
// File: reglist.h
//
// History:
//   5-30-94 KurtE      Created.
//
//---------------------------------------------------------------------------

// Define Callback used for different enumeration functions.
typedef BOOL (CALLBACK *PRLCALLBACK)(HDPA hdpa, HKEY hkey, LPCTSTR pszKey,
        LPCTSTR pszValueName, LPTSTR pszValue, LPCTSTR pszSrc,
        LPCTSTR pszDest);       

// Called to force rebuilding the list of paths.
BOOL WINAPI RLBuildListOfPaths(void);

// Terminate and cleanup our use of the Registry list.
void WINAPI RLTerminate(void);

// Define the main iterater function that uses the call back.
BOOL WINAPI RLEnumRegistry(HDPA hdpa, PRLCALLBACK prlcb,
        LPCTSTR pszSrc, LPCTSTR pszDest);


// RLIsPathInList: This function returns ht index of which item a string
// is in the list or -1 if not found.

int WINAPI RLIsPathInList(LPCTSTR pszPath);


// Function to call when the files really have changed...
int WINAPI RLFSChanged (LONG lEvent, LPITEMIDLIST pidl, LPITEMIDLIST pidlExtra);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\regsuprt.cpp ===
#include "shellprv.h"
#pragma  hdrstop

#include "regsuprt.h"

#ifdef DEBUG
UINT CRegSupport::_cRefHKEY = 0;
UINT CRegSupport::_cRefExternalHKEY = 0;
#endif

void CRegSupport::RSInitRoot(HKEY hkey, LPCTSTR pszSubKey1, LPCTSTR pszSubKey2,
        DWORD dwRootOptions, DWORD dwDefaultOptions)
{
    _dwRootOptions = dwRootOptions; 
    _dwDefaultOptions = dwDefaultOptions;
    
    _hkeyInit = hkey;

    _InitSetRoot(pszSubKey1, pszSubKey2);

#ifdef DEBUG
    ASSERT(!_fInited);

    _fInited = TRUE;
#endif
}

BOOL CRegSupport::RSSubKeyExist(LPCTSTR pszSubKey)
{
    BOOL fRet = FALSE;
    HKEY hkeySubKey = NULL;
    
    _EnterCSKeyRoot();

    if (pszSubKey && *pszSubKey)
        hkeySubKey = _GetSubKey(pszSubKey, FALSE);
    else
        hkeySubKey = _GetRootKey(FALSE);

    if (hkeySubKey)
    {
        fRet = TRUE;
        _CloseRegSubKey(hkeySubKey);
    }

    _LeaveCSKeyRoot();

    return fRet;
}

BOOL CRegSupport::RSValueExist(LPCTSTR pszSubKey, LPCTSTR pszValueName)
{
    BOOL fRet = FALSE;
    HKEY hkeySubKey = NULL;
    
    _EnterCSKeyRoot();

    if (pszSubKey && *pszSubKey)
        hkeySubKey = _GetSubKey(pszSubKey, FALSE);
    else
        hkeySubKey = _GetRootKey(FALSE);

    if (hkeySubKey)
    {
        fRet = (RegQueryValueEx(hkeySubKey, pszValueName, 0, NULL, NULL, NULL) ==
            ERROR_SUCCESS);

        _CloseRegSubKey(hkeySubKey);
    }

    _LeaveCSKeyRoot();

    return fRet;
}

BOOL CRegSupport::RSDeleteValue(LPCTSTR pszSubKey, LPCTSTR pszValueName)
{
    BOOL fRet = FALSE;
    HKEY hkeySubKey = NULL;
    
    _EnterCSKeyRoot();

    if (pszSubKey && *pszSubKey)
        hkeySubKey = _GetSubKey(pszSubKey, FALSE);
    else
        hkeySubKey = _GetRootKey(FALSE);

    if (hkeySubKey)
    {
        if (ERROR_SUCCESS == RegDeleteValue(hkeySubKey, pszValueName))
        {
            fRet = TRUE;
        }
        _CloseRegSubKey(hkeySubKey);
    }

    _LeaveCSKeyRoot();

    return fRet;
}

BOOL CRegSupport::RSDeleteKey()
{
    TCHAR szRoot[MAX_ROOT];

    return (ERROR_SUCCESS == SHDeleteKey(_hkeyInit, _GetRoot(szRoot, ARRAYSIZE(szRoot))));
}

BOOL CRegSupport::RSDeleteSubKey(LPCTSTR pszSubKey)
{
    BOOL fRet = FALSE;

    _EnterCSKeyRoot();

    HKEY hkey = _GetRootKey(FALSE);

    if (hkey)
    {
        if (ERROR_SUCCESS == SHDeleteKey(hkey, pszSubKey))
        {
            fRet = TRUE;
        }
        _CloseRegSubKey(hkey);
    }

    _LeaveCSKeyRoot();

    return fRet;
}

BOOL CRegSupport::RSSetBinaryValue(LPCTSTR pszSubKey, LPCTSTR pszValueName,
                               PBYTE pb, DWORD cb,
                               DWORD dwOptions)
{
    return _SetGeneric(pszSubKey, pszValueName, pb, cb, REG_BINARY, dwOptions);
}

BOOL CRegSupport::RSSetTextValue(LPCTSTR pszSubKey, LPCTSTR pszValueName,
                               LPCTSTR pszValue,
                               DWORD dwOptions)
{
    return _SetGeneric(pszSubKey, pszValueName, (PBYTE)pszValue,
        (lstrlen(pszValue) + 1) * sizeof(TCHAR), REG_SZ, dwOptions);
}

BOOL CRegSupport::RSSetDWORDValue(LPCTSTR pszSubKey, LPCTSTR pszValueName,
                               DWORD dwValue,
                               DWORD dwOptions)
{
    return _SetGeneric(pszSubKey, pszValueName, (PBYTE)&dwValue, 
        sizeof(DWORD), REG_DWORD, dwOptions);
}

BOOL CRegSupport::RSGetBinaryValue(LPCTSTR pszSubKey, LPCTSTR pszValueName,
                                PBYTE pb, DWORD* pcb)
{
    return _GetGeneric(pszSubKey, pszValueName, pb, pcb);
}

BOOL CRegSupport::RSGetTextValue(LPCTSTR pszSubKey, LPCTSTR pszValueName,
                                LPTSTR pszValue, DWORD* pcchValue)
{
    DWORD cbData = *pcchValue * sizeof(TCHAR);

    return _GetGeneric(pszSubKey, pszValueName, (PBYTE)pszValue, &cbData);
}

BOOL CRegSupport::RSGetDWORDValue(LPCTSTR pszSubKey, LPCTSTR pszValueName, DWORD* pdwValue)
{
    DWORD cbData = sizeof(DWORD);

    return _GetGeneric(pszSubKey, pszValueName, (PBYTE)pdwValue, &cbData);
}

BOOL CRegSupport::_SetGeneric(LPCTSTR pszSubKey, LPCTSTR pszValueName,
                                PBYTE pb, DWORD cb, DWORD dwType,
                                DWORD dwOptions)
{
    BOOL fRet = FALSE;
    HKEY hkeySubKey = NULL;
    
    _EnterCSKeyRoot();

    if (pszSubKey && *pszSubKey)
        hkeySubKey = _GetSubKey(pszSubKey, TRUE, dwOptions);
    else
        hkeySubKey = _GetRootKey(TRUE, dwOptions);

    if (hkeySubKey)
    {
        if (ERROR_SUCCESS == RegSetValueEx(hkeySubKey, pszValueName, 0, 
            dwType, pb, cb))
        {
            fRet = TRUE;
        }
        _CloseRegSubKey(hkeySubKey);
    }

    _LeaveCSKeyRoot();

    return fRet;
}

BOOL CRegSupport::_GetGeneric(LPCTSTR pszSubKey, LPCTSTR pszValueName,
                               PBYTE pb, DWORD* pcb)
{
    BOOL fRet = FALSE;
    HKEY hkeySubKey = NULL;
    
    _EnterCSKeyRoot();

    if (pszSubKey && *pszSubKey)
        hkeySubKey = _GetSubKey(pszSubKey, FALSE);
    else
        hkeySubKey = _GetRootKey(FALSE);

    if (hkeySubKey)
    {
        if (ERROR_SUCCESS == SHQueryValueEx(hkeySubKey, pszValueName, 0, 
            NULL, pb, pcb))
        {
            fRet = TRUE;
        }
        _CloseRegSubKey(hkeySubKey);
    }

    _LeaveCSKeyRoot();

    return fRet;
}

HKEY CRegSupport::RSDuplicateRootKey()
{
    RIP(_fInited);
#ifdef DEBUG
    // we need to decrement here since it will be icnremented inside this fct
    // and the key will not be close by this object
    --_cRefHKEY;
    ++_cRefExternalHKEY;
#endif
    TCHAR szRoot[MAX_ROOT];

    return _RegCreateKeyExHelper(_hkeyInit, _GetRoot(szRoot, ARRAYSIZE(szRoot)), _dwRootOptions);
}

HKEY CRegSupport::RSDuplicateSubKey(LPCTSTR pszSubKey, BOOL fCreate, BOOL fVolatile)
{
    return _GetSubKey(pszSubKey, fCreate, fVolatile ? REG_OPTION_VOLATILE : REG_OPTION_NON_VOLATILE);
}

HKEY CRegSupport::_GetRootKey(BOOL fCreate, DWORD dwOptions)
{
    RIP(_fInited);

    HKEY hkey;
    TCHAR szRoot[MAX_ROOT];

    if (REG_OPTION_INVALID == dwOptions)
        dwOptions = _dwRootOptions;

    if (fCreate)
        hkey = _RegCreateKeyExHelper(_hkeyInit, _GetRoot(szRoot, ARRAYSIZE(szRoot)), dwOptions);
    else
        hkey = _RegOpenKeyExHelper(_hkeyInit, _GetRoot(szRoot, ARRAYSIZE(szRoot)));

    return hkey;
}

void CRegSupport::_CloseRegSubKey(HKEY hkeySubKey)
{
    RegCloseKey(hkeySubKey);

#ifdef DEBUG
    --_cRefHKEY;
#endif
}

// Always need to be called from within the _csRootKey critical section (when critical section
// stuff is enabled)

HKEY CRegSupport::_GetSubKey(LPCTSTR pszSubKey, BOOL fCreate, DWORD dwOptions)
{
    HKEY hkey = NULL;

    HKEY hRootKey = _GetRootKey(fCreate, dwOptions);

    if (REG_OPTION_INVALID == dwOptions)
        dwOptions = _dwDefaultOptions;

    if (hRootKey)
    {
        if (fCreate)
            hkey = _RegCreateKeyExHelper(hRootKey, pszSubKey, dwOptions);
        else
            hkey = _RegOpenKeyExHelper(hRootKey, pszSubKey);

        _CloseRegSubKey(hRootKey);
    }

    return hkey;
}

//static
HKEY CRegSupport::_RegCreateKeyExHelper(HKEY hkey, LPCTSTR pszSubKey, DWORD dwOptions)
{
    HKEY hkeyTmp;
    DWORD dwDisp;

    ASSERT(REG_OPTION_INVALID != dwOptions);

    if (ERROR_SUCCESS != RegCreateKeyEx(hkey, pszSubKey, 0, NULL, 
        dwOptions, MAXIMUM_ALLOWED, NULL, &hkeyTmp, &dwDisp))
    {
        hkeyTmp = NULL;
    }
#ifdef DEBUG
    else
    {
        ++_cRefHKEY;
    }
#endif

    return hkeyTmp;
}

//static
HKEY CRegSupport::_RegOpenKeyExHelper(HKEY hkey, LPCTSTR pszSubKey)
{
    HKEY hkeyTmp;

    if (ERROR_SUCCESS != RegOpenKeyEx(hkey, pszSubKey, 0,
        MAXIMUM_ALLOWED, &hkeyTmp))
    {
        hkeyTmp = NULL;
    }
#ifdef DEBUG
    else
    {
        ++_cRefHKEY;
    }
#endif

    return hkeyTmp;
}

BOOL CRegSupport::_InitSetRoot(LPCTSTR pszSubKey1, LPCTSTR pszSubKey2)
{
    _pszSubKey1 = pszSubKey1;
    _pszSubKey2 = pszSubKey2;

    return TRUE;
}

LPCTSTR CRegSupport::_GetRoot(LPTSTR pszRoot, DWORD cchRoot)
{
    ASSERT(cchRoot > 0);

    lstrcpyn(pszRoot, _pszSubKey1, cchRoot);

    if (_pszSubKey2)
    {
        lstrcatn(pszRoot, TEXT("\\"), cchRoot);
        lstrcatn(pszRoot, _pszSubKey2, cchRoot);
    }

    return pszRoot;
}

void CRegSupport::_InitCSKeyRoot()
{
    ASSERT(!_fcsKeyRoot);

    _fcsKeyRoot = TRUE;
    InitializeCriticalSection(&_csKeyRoot);
}

void CRegSupport::_EnterCSKeyRoot()
{
    if (_fcsKeyRoot)
    {
        EnterCriticalSection(&_csKeyRoot);
    }
}

void CRegSupport::_LeaveCSKeyRoot()
{
    if (_fcsKeyRoot)
    {
        LeaveCriticalSection(&_csKeyRoot);
    }
}

CRegSupport::CRegSupport()
{}

CRegSupport::~CRegSupport()
{
    if (_fcsKeyRoot)
    {
        DeleteCriticalSection(&_csKeyRoot);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\resource.h ===
//{{NO_DEPENDENCIES}}
// App Studio generated include file.
// Used by SHELL2.RC
//
#define CTLWID                          60

#define IDC_STATIC                      -1

// Next default values for new objects
// 
#ifdef APSTUDIO_INVOKED
#ifndef APSTUDIO_READONLY_SYMBOLS

#define _APS_NEXT_RESOURCE_VALUE        109
#define _APS_NEXT_COMMAND_VALUE         101
#define _APS_NEXT_CONTROL_VALUE         1000
#define _APS_NEXT_SYMED_VALUE           101
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\rgsprtc.cpp ===
#include "shellprv.h"
#pragma  hdrstop

#include "rgsprtc.h"

BOOL CRegSupportCached::_fUseCaching = FALSE;

CRegSupportCached::CRegSupportCached()
{
    _InitCSKeyRoot();
}

CRegSupportCached::~CRegSupportCached()
{
    // need to close cached key
    _CloseCachedRootKey();
}

void CRegSupportCached::_CloseRegSubKey(HKEY hkey)
{
    if (!_fUseCaching)
    {
        CRegSupport::_CloseRegSubKey(hkey);

        if (_hkeyRoot == hkey)
        {
            _hkeyRoot = NULL;
        }
    }
    else
    {
        if (_hkeyRoot != hkey)
        {
            CRegSupport::_CloseRegSubKey(hkey);
        }
    }
}

HKEY CRegSupportCached::_GetRootKey(BOOL fCreate, DWORD dwOptions)
{
    if (!_hkeyRoot)
    {
        _hkeyRoot = CRegSupport::_GetRootKey(fCreate, dwOptions);
    }

    return _hkeyRoot;
}

BOOL CRegSupportCached::_SetGeneric(LPCTSTR pszSubKey, LPCTSTR pszValueName,
                            PBYTE pb, DWORD cb, DWORD dwType,
                            DWORD dwOptions)
{
    int cTry = 0;
    BOOL fRet = FALSE;

    do
    {
        ++cTry;

        fRet = CRegSupport::_SetGeneric(pszSubKey, pszValueName,
                                pb, cb, dwType, dwOptions);

        // Did we fail?
        if (!fRet)
        {
            // Yes, maybe some other process deleted the key, so we'll close
            // the cached one and try to reopen it, and retry the operation 
            // (for a maximum of two times)
            _CloseCachedRootKey();
        }
    }
    while (!fRet && (cTry < 2));

    return fRet;
}

BOOL CRegSupportCached::_GetGeneric(LPCTSTR pszSubKey, LPCTSTR pszValueName,
                            PBYTE pb, DWORD* pcb)
{
    int cTry = 0;
    BOOL fRet = FALSE;

    DWORD cbLocal;

    do
    {
        cbLocal = *pcb;

        ++cTry;

        fRet = CRegSupport::_GetGeneric(pszSubKey, pszValueName,
                                pb, &cbLocal);

        // Did we fail?
        if (!fRet)
        {
            // Yes, maybe some other process deleted the key, so we'll close
            // the cached one and try to reopen it, and retry the operation 
            // (for a maximum of two times)
            _CloseCachedRootKey();
        }
    }
    while (!fRet && (cTry < 2));

    *pcb = cbLocal;

    return fRet;
}

///////////////////////////////////////////////////////////////////////////////
// Reset the cache in the next fcts, to increase our chances of returning the
// true answer, this only increase the chances, there is still na opportunity
// to miss.  Does not really matter for these fcts.
///////////////////////////////////////////////////////////////////////////////
BOOL CRegSupportCached::RSValueExist(LPCTSTR pszSubKey, LPCTSTR pszValueName)
{
    // Close the cache one, or else we might get wrong results
    _CloseCachedRootKey();

    return CRegSupport::RSValueExist(pszSubKey, pszValueName);
}

BOOL CRegSupportCached::RSSubKeyExist(LPCTSTR pszSubKey)
{
    // Close the cache one, or else we might get wrong results
    _CloseCachedRootKey();

    return CRegSupport::RSSubKeyExist(pszSubKey);
}

HKEY CRegSupportCached::RSDuplicateRootKey()
{
    // Close the cache one, or else we might get wrong results
    _CloseCachedRootKey();

    return CRegSupport::RSDuplicateRootKey();
}

BOOL CRegSupportCached::RSDeleteSubKey(LPCTSTR pszSubKey)
{
    // Close the cache one, or else we might get wrong results
    _CloseCachedRootKey();

    return CRegSupport::RSDeleteSubKey(pszSubKey);
}

BOOL CRegSupportCached::RSDeleteValue(LPCTSTR pszSubKey, LPCTSTR pszValueName)
{
    // Close the cache one, or else we might get wrong results
    _CloseCachedRootKey();

    return CRegSupport::RSDeleteValue(pszSubKey, pszValueName);
}

STDAPI_(void) CRegSupportCached_RSEnableKeyCaching(BOOL fEnable)
{
    CRegSupportCached::_fUseCaching = fEnable;
}
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
void CRegSupportCached::_CloseCachedRootKey()
{
    _EnterCSKeyRoot();

    if (_hkeyRoot)
    {
        RegCloseKey(_hkeyRoot);

        _hkeyRoot = NULL;
    }

    _LeaveCSKeyRoot();
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\reminder.cpp ===
#include "shellprv.h"
#include "clsobj.h"
#include "ole2dup.h"

class CPostBootReminder : public IShellReminderManager, 
                          public IOleCommandTarget,
                          public IQueryContinue
{
public:
    // IUnknown
    STDMETHOD(QueryInterface)(REFIID iid, LPVOID* ppv);
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

    // IShellReminderManager
    STDMETHOD(Add)(const SHELLREMINDER* psr);
    STDMETHOD(Delete)(LPCWSTR pszName);
    STDMETHOD(Enum)(IEnumShellReminder** ppesr);

    // IOleCommandTarget Implementation (used to display the PostBootReminders as a shell service object)
    STDMETHOD(QueryStatus)(const GUID* pguidCmdGroup, ULONG cCmds, OLECMD prgCmds[], OLECMDTEXT* pCmdText);
    STDMETHOD(Exec)(const GUID* pguidCmdGroup, DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG* pvaIn, VARIANTARG* pvaOut);

    // IQueryContinue
    STDMETHOD(QueryContinue)(void);

    CPostBootReminder();
    
private:
    static DWORD _ThreadProc(void* pv);

    LONG  _cRef;
    TCHAR _szKeyShowing[MAX_PATH];
};

HRESULT CPostBootReminder_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv)
{
    if (NULL != punkOuter)
    {
        return CLASS_E_NOAGGREGATION;
    }

    CPostBootReminder* pPbr = new CPostBootReminder();

    if (!pPbr)
    {
        return E_OUTOFMEMORY;
    }

    HRESULT hr = pPbr->QueryInterface(riid, ppv);
    pPbr->Release();

    return hr;
}

// Per-user (HKCU)
#define REGPATH_POSTBOOTREMINDERS REGSTR_PATH_EXPLORER TEXT("\\PostBootReminders")
#define REGPATH_POSTBOOTTODO      REGSTR_PATH_EXPLORER TEXT("\\PostBootToDo")

#define PROP_POSTBOOT_TITLE           TEXT("Title")                   // REG_SZ
#define PROP_POSTBOOT_TEXT            TEXT("Text")                    // REG_SZ
#define PROP_POSTBOOT_TOOLTIP         TEXT("ToolTip")                 // REG_SZ
#define PROP_POSTBOOT_CLSID           TEXT("Clsid")                   // REG_SZ
#define PROP_POSTBOOT_SHELLEXECUTE    TEXT("ShellExecute")            // REG_SZ
#define PROP_POSTBOOT_ICONRESOURCE    TEXT("IconResource")            // REG_SZ "module,-resid"
#define PROP_POSTBOOT_SHOWTIME        TEXT("ShowTime")                // REG_DWORD
#define PROP_POSTBOOT_RETRYINTERVAL   TEXT("RetryInterval")           // REG_DWORD
#define PROP_POSTBOOT_RETRYCOUNT      TEXT("RetryCount")              // REG_DWORD
#define PROP_POSTBOOT_TYPEFLAGS       TEXT("TypeFlags")               // REG_DWORD (NIIF_WARNING, NIIF_INFO, NIIF_ERROR)

CPostBootReminder::CPostBootReminder()
{
    _cRef = 1;
}

// IUnknown

HRESULT CPostBootReminder::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = 
    {
        QITABENT(CPostBootReminder, IShellReminderManager),
        QITABENT(CPostBootReminder, IOleCommandTarget),
        QITABENT(CPostBootReminder, IQueryContinue),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

ULONG CPostBootReminder::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CPostBootReminder::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}

// IShellReminderManager

HRESULT CPostBootReminder::Add(const SHELLREMINDER* psr)
{
    HRESULT hr = E_FAIL;

    // Ensure the parent key is created
    HKEY hkeyCurrentUser;
    if (ERROR_SUCCESS == RegOpenCurrentUser(KEY_WRITE, &hkeyCurrentUser))
    {
        HKEY hkeyReminders;
        if (ERROR_SUCCESS == RegCreateKeyEx(hkeyCurrentUser, REGPATH_POSTBOOTREMINDERS, 0, NULL, 0, KEY_WRITE, NULL, &hkeyReminders, NULL))
        {
            IPropertyBag* pPb;
            hr = SHCreatePropertyBagOnRegKey(hkeyReminders, psr->pszName, STGM_WRITE | STGM_CREATE, IID_PPV_ARG(IPropertyBag, &pPb));

            if (SUCCEEDED(hr))
            {
                // need to check the SHELLREMINDER values for null or we will RIP in SHPropertyBag_WriteStr/GUID
                if (psr->pszTitle)
                {
                    SHPropertyBag_WriteStr(pPb, PROP_POSTBOOT_TITLE, psr->pszTitle);
                }

                if (psr->pszText)
                {
                    SHPropertyBag_WriteStr(pPb, PROP_POSTBOOT_TEXT, psr->pszText);
                }
                
                if (psr->pszTooltip)
                {
                    SHPropertyBag_WriteStr(pPb, PROP_POSTBOOT_TOOLTIP, psr->pszTooltip);
                }

                if (psr->pszIconResource)
                {
                    SHPropertyBag_WriteStr(pPb, PROP_POSTBOOT_ICONRESOURCE, psr->pszIconResource);
                }

                if (psr->pszShellExecute)
                {
                    SHPropertyBag_WriteStr(pPb, PROP_POSTBOOT_SHELLEXECUTE, psr->pszShellExecute);
                }

                if (psr->pclsid)
                {
                    SHPropertyBag_WriteGUID(pPb, PROP_POSTBOOT_CLSID, psr->pclsid);
                }

                SHPropertyBag_WriteDWORD(pPb, PROP_POSTBOOT_SHOWTIME, psr->dwShowTime);
                SHPropertyBag_WriteDWORD(pPb, PROP_POSTBOOT_RETRYINTERVAL, psr->dwRetryInterval);
                SHPropertyBag_WriteDWORD(pPb, PROP_POSTBOOT_RETRYCOUNT, psr->dwRetryCount);
                SHPropertyBag_WriteDWORD(pPb, PROP_POSTBOOT_TYPEFLAGS, psr->dwTypeFlags);

                pPb->Release();
            }

            RegCloseKey(hkeyReminders);
            hr = S_OK;
        }
        RegCloseKey(hkeyCurrentUser);
    }

    return hr;
}

HRESULT CPostBootReminder::Delete(LPCWSTR pszName)
{
    HRESULT hr = E_FAIL;

    HKEY hKey;
    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, REGPATH_POSTBOOTREMINDERS, 0, KEY_WRITE, &hKey))
    {
        SHDeleteKey(hKey, pszName);
        RegCloseKey(hKey);
        hr = S_OK;
    }
    else
    {
        hr = S_FALSE;
    }

    return hr;
}

HRESULT CPostBootReminder::Enum(IEnumShellReminder** ppesr)
{
    *ppesr = NULL;
    return E_NOTIMPL;
}

// IOleCommandTarget implementation

HRESULT CPostBootReminder::QueryStatus(const GUID* pguidCmdGroup, ULONG cCmds, OLECMD prgCmds[], OLECMDTEXT* pCmdText)
{
    HRESULT hr = OLECMDERR_E_UNKNOWNGROUP;

    if (*pguidCmdGroup == CGID_ShellServiceObject)
    {
        // We like Shell Service Object notifications...
        hr = S_OK;
    }

    return hr;
}

HRESULT CPostBootReminder::Exec(const GUID* pguidCmdGroup, DWORD nCmdID, DWORD nCmdExecOpt, VARIANTARG* pvaIn, VARIANTARG* pvaOut)
{
    HRESULT hr = OLECMDERR_E_UNKNOWNGROUP;

    if (*pguidCmdGroup == CGID_ShellServiceObject)
    {
        hr = S_OK; // Any ol' notification is ok with us
        // Handle Shell Service Object notifications here.
        switch (nCmdID)
        {
        case SSOCMDID_OPEN:
            AddRef();       // AddRef so that this instance stays around. An equivalent Release() is in _ThreadProc
            if (!SHCreateThread(_ThreadProc, this, CTF_COINIT, NULL))
            {
                Release();
            }
            break;
        }
    }

    return hr;
}


// IQueryContinue implementation

HRESULT CPostBootReminder::QueryContinue()
{
    HRESULT hr = S_OK;

    if (_szKeyShowing[0])
    {
        HKEY hKey;
        if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, _szKeyShowing, 0, KEY_READ, &hKey))
        {
            RegCloseKey(hKey);
        }
        else
        {
            hr = S_FALSE;
        }
    }

    return hr;
}

// Function prototypes
HRESULT CreateUserNotificationFromPropertyBag(IPropertyBag* pPb, IUserNotification** ppun);
HRESULT _SetBalloonInfoFromPropertyBag(IPropertyBag* pPb, IUserNotification* pun);
HRESULT _SetBalloonRetryFromPropertyBag(IPropertyBag* pPb, IUserNotification* pun);
HRESULT _SetBalloonIconFromPropertyBag(IPropertyBag* pPb, IUserNotification* pun);
HRESULT _InvokeFromPropertyBag(IPropertyBag* pPb);

HRESULT GetSubKeyPropertyBag(HKEY hkey, DWORD iSubKey, DWORD grfMode, IPropertyBag** ppPb, TCHAR * szKey, DWORD cbKey);

HRESULT _SetBalloonInfoFromPropertyBag(IPropertyBag* pPb, IUserNotification* pun)
{
    TCHAR szTitle[256];
    HRESULT hr = SHPropertyBag_ReadStr(pPb, PROP_POSTBOOT_TITLE, szTitle, ARRAYSIZE(szTitle));
    if (SUCCEEDED(hr))
    {
        TCHAR szText[512];
        hr = SHPropertyBag_ReadStr(pPb, PROP_POSTBOOT_TEXT, szText, ARRAYSIZE(szText));
        if (SUCCEEDED(hr))
        {
            DWORD dwFlags = 0;
            hr = SHPropertyBag_ReadDWORD(pPb, PROP_POSTBOOT_TYPEFLAGS, &dwFlags);
            if (SUCCEEDED(hr))
            {
                hr = pun->SetBalloonInfo(szTitle, szText, dwFlags);
            }
        }
    }

    return hr;
}

HRESULT _SetBalloonRetryFromPropertyBag(IPropertyBag* pPb, IUserNotification* pun)
{
    DWORD dwShowTime;
    HRESULT hr = SHPropertyBag_ReadDWORD(pPb, PROP_POSTBOOT_SHOWTIME, &dwShowTime);
    if (SUCCEEDED(hr))
    {
        DWORD dwRetryInterval;
        hr = SHPropertyBag_ReadDWORD(pPb, PROP_POSTBOOT_RETRYINTERVAL, &dwRetryInterval);
        if (SUCCEEDED(hr))
        {
            DWORD dwRetryCount;
            hr = SHPropertyBag_ReadDWORD(pPb, PROP_POSTBOOT_RETRYCOUNT, &dwRetryCount);
            if (SUCCEEDED(hr))
            {
                hr = pun->SetBalloonRetry(dwShowTime, dwRetryInterval, dwRetryCount);
            }
        }
    }

    return hr;
}

HRESULT _SetBalloonIconFromPropertyBag(IPropertyBag* pPb, IUserNotification* pun)
{
    TCHAR szTooltip[256];
    HRESULT hr = SHPropertyBag_ReadStr(pPb, PROP_POSTBOOT_TOOLTIP, szTooltip, ARRAYSIZE(szTooltip));

    if (FAILED(hr))
    {
        *szTooltip = 0;
    }

    TCHAR szIcon[MAX_PATH + 6];
    hr = SHPropertyBag_ReadStr(pPb, PROP_POSTBOOT_ICONRESOURCE, szIcon, ARRAYSIZE(szIcon));
    if (SUCCEEDED(hr))
    {
        int iIcon = PathParseIconLocation(szIcon);
        HICON hIcon;
        hr = (0 == ExtractIconEx(szIcon, iIcon, NULL, &hIcon, 1)) ? E_FAIL : S_OK;
        if (SUCCEEDED(hr))
        {
            pun->SetIconInfo(hIcon, szTooltip);

            DestroyIcon(hIcon);
        }
    }

    return hr;
}

HRESULT _InvokeFromPropertyBag(IPropertyBag* pPb)
{
    // First try to use the CLSID to find a handler for the click
    CLSID clsid;
    HRESULT hr = SHPropertyBag_ReadGUID(pPb, PROP_POSTBOOT_CLSID, &clsid);

    if (SUCCEEDED(hr))
    {
        IContextMenu* pcm;
        hr = SHExtCoCreateInstance(NULL, &clsid, NULL, IID_PPV_ARG(IContextMenu, &pcm));
        if (SUCCEEDED(hr))
        {
            CMINVOKECOMMANDINFO ici = {0};
            ici.cbSize = sizeof(ici);
            ici.lpVerb = "open";
            ici.nShow = SW_SHOWNORMAL;

            pcm->InvokeCommand(&ici);
            pcm->Release();
        }
    }

    if (FAILED(hr))
    {
        // Second, use the shellexecute line
        TCHAR szExecute[MAX_PATH + 1];
        hr = SHPropertyBag_ReadStr(pPb, PROP_POSTBOOT_SHELLEXECUTE, szExecute, ARRAYSIZE(szExecute));
        if (SUCCEEDED(hr))
        {
            // Use shellexecuteex to open a view folder
            SHELLEXECUTEINFO shexinfo = {0};
            shexinfo.cbSize = sizeof (shexinfo);
            shexinfo.fMask = SEE_MASK_FLAG_NO_UI;
            shexinfo.nShow = SW_SHOWNORMAL;
            shexinfo.lpFile = szExecute;

            ShellExecuteEx(&shexinfo);
        }
    }

    return hr;
}

DWORD CPostBootReminder::_ThreadProc(void* pv)
{
    HKEY hkeyReminders;
    CPostBootReminder * ppbr = (CPostBootReminder *) pv;

    if (ERROR_SUCCESS == RegOpenKeyEx(HKEY_CURRENT_USER, REGPATH_POSTBOOTREMINDERS, 0, KEY_READ, &hkeyReminders))
    {
        DWORD iReminder = 0;
        HRESULT hr = S_OK;
        while (S_OK == hr)
        {
            IPropertyBag* pPb;
            hr = GetSubKeyPropertyBag(hkeyReminders, iReminder, STGM_READ, &pPb, ppbr->_szKeyShowing, ARRAYSIZE(ppbr->_szKeyShowing));
            if (S_OK == hr)
            {
                IUserNotification* pun;
                hr = CreateUserNotificationFromPropertyBag(pPb, &pun);
                if (SUCCEEDED(hr))
                {
                    if (S_OK == pun->Show(SAFECAST(ppbr, IQueryContinue *), 0))
                    {
                        _InvokeFromPropertyBag(pPb);
                    }
                    pun->Release();
                }

                pPb->Release();
            }

            // No key is showing now...
            ppbr->_szKeyShowing[0] = 0;

            iReminder++;
        }

        RegCloseKey(hkeyReminders);

        SHDeleteKey(HKEY_CURRENT_USER, REGPATH_POSTBOOTREMINDERS);         // Recursive delete
    }
    ppbr->Release();

    return 0;
}

HRESULT CreateUserNotificationFromPropertyBag(IPropertyBag* pPb, IUserNotification** ppun)
{
    HRESULT hr = CUserNotification_CreateInstance(NULL, IID_PPV_ARG(IUserNotification, ppun));
    if (SUCCEEDED(hr))
    {
        hr = _SetBalloonInfoFromPropertyBag(pPb, *ppun);

        if (SUCCEEDED(hr))
        {
            _SetBalloonRetryFromPropertyBag(pPb, *ppun);
            _SetBalloonIconFromPropertyBag(pPb, *ppun);
        }
        else
        {
            (*ppun)->Release();
            *ppun = NULL;
        }
    }
    return hr;
}

HRESULT GetSubKeyPropertyBag(HKEY hkey, DWORD iSubKey, DWORD grfMode, IPropertyBag** ppPb, TCHAR *pszKey, DWORD cbKey)
{
    *ppPb = NULL;

    TCHAR szName[256];
    DWORD cchSize = ARRAYSIZE(szName);
    LONG lResult = RegEnumKeyEx(hkey, iSubKey, szName, &cchSize, NULL, NULL, NULL, NULL);

    if (ERROR_NO_MORE_ITEMS == lResult)
        return S_FALSE;

    if (ERROR_SUCCESS != lResult)
        return E_FAIL;

    StrCpyN(pszKey, REGPATH_POSTBOOTREMINDERS, cbKey);
    StrCatBuff(pszKey, TEXT("\\"), cbKey);
    StrCatBuff(pszKey, szName, cbKey);

    return SHCreatePropertyBagOnRegKey(hkey, szName, grfMode, IID_PPV_ARG(IPropertyBag, ppPb));    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\rgsprtc.h ===
#ifndef __RGSPRTC_H
#define __RGSPRTC_H

#include "regsuprt.h"

class CRegSupportCached : public CRegSupport
{
public:
    CRegSupportCached();
    virtual ~CRegSupportCached();

    BOOL RSValueExist(LPCTSTR pszSubKey, LPCTSTR pszValueName);
    BOOL RSSubKeyExist(LPCTSTR pszSubKey);

    BOOL RSDeleteValue(LPCTSTR pszSubKey, LPCTSTR pszValueName);
    BOOL RSDeleteSubKey(LPCTSTR pszSubKey);

    HKEY RSDuplicateRootKey();

protected:
    void _CloseRegSubKey(HKEY hkeyVolumeSubKey);

    HKEY _GetRootKey(BOOL fCreate, DWORD dwOptions = REG_OPTION_INVALID);

    BOOL _SetGeneric(LPCTSTR pszSubKey, LPCTSTR pszValueName,
                                PBYTE pb, DWORD cb, DWORD dwType,
                                DWORD dwOptions);
    BOOL _GetGeneric(LPCTSTR pszSubKey, LPCTSTR pszValueName,
                                PBYTE pb, DWORD* pcb);

private:
    void _CloseCachedRootKey();

    HKEY            _hkeyRoot;

public:
    static BOOL     _fUseCaching;
};

#endif //__RGSPRTC_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\rscchvr.h ===
#ifndef _RSCCHVR_H
#define _RSCCHVR_H

#include "rgsprtc.h"

class CRSCacheVersion : public CRegSupportCached
{
public:
    void RSCVInitSubKey(LPCTSTR pszSubKey);
    LPCTSTR RSCVGetSubKey();

protected:
    void _RSCVUpdateVersionOnCacheRead();
    void _RSCVUpdateVersionOnCacheWrite();
    BOOL _RSCVIsValidVersion();
    void _RSCVIncrementRegVersion();

    virtual void _RSCVDeleteRegCache() = 0;

#ifdef DEBUG
protected:
#else
private:
#endif

    DWORD               _dwVersion;
    LPCTSTR             _pszSubKey;
};

#endif //_RSCCHVR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\rscchvr.cpp ===
#include "shellprv.h"
#pragma  hdrstop

#include "rscchvr.h"

void CRSCacheVersion::_RSCVUpdateVersionOnCacheRead()
{
    DWORD dwVersion;

    if (RSGetDWORDValue(_pszSubKey, TEXT("Version"), &dwVersion))
    {
        _dwVersion = dwVersion;
    }
    else
    {
        _dwVersion = 0;
        RSSetDWORDValue(_pszSubKey, TEXT("Version"), _dwVersion);
    }
}

void CRSCacheVersion::_RSCVUpdateVersionOnCacheWrite()
{
    DWORD dwVersion;

    if (RSGetDWORDValue(_pszSubKey, TEXT("Version"), &dwVersion))
    {
        _dwVersion = dwVersion + 1;
    }
    else
    {
        _dwVersion = 0;
    }

    RSSetDWORDValue(_pszSubKey, TEXT("Version"), _dwVersion);
}

BOOL CRSCacheVersion::_RSCVIsValidVersion()
{
    DWORD dwVersion;
    BOOL fRet = FALSE;

    if (RSGetDWORDValue(_pszSubKey, TEXT("Version"), &dwVersion))
    {
        if (_dwVersion == dwVersion)
        {
            fRet = TRUE;
        }
    }

    return fRet;
}

void CRSCacheVersion::_RSCVIncrementRegVersion()
{
    DWORD dwVersion;

    _RSCVDeleteRegCache();

    if (RSGetDWORDValue(_pszSubKey, TEXT("Version"), &dwVersion))
    {
        ++dwVersion;

        RSSetDWORDValue(_pszSubKey, TEXT("Version"), dwVersion);
    }
}

void CRSCacheVersion::RSCVInitSubKey(LPCTSTR pszSubKey)
{
    _pszSubKey = pszSubKey;
}

LPCTSTR CRSCacheVersion::RSCVGetSubKey()
{
    return _pszSubKey;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\restart.c ===
#include "shellprv.h"
#pragma  hdrstop

#include <msginaexports.h>
#include <ntddapmt.h>
#include <lmcons.h>     // Username length constant
#include <winsta.h>     // Hydra functions/constants
#include <powrprof.h>

#include "SwitchUserDialog.h"
#include "filetbl.h"

#define DOCKSTATE_DOCKED            0
#define DOCKSTATE_UNDOCKED          1
#define DOCKSTATE_UNKNOWN           2

void FlushRunDlgMRU(void);

// Disconnect API fn-ptr
typedef BOOLEAN (WINAPI *PWINSTATION_DISCONNECT) (HANDLE hServer, ULONG SessionId, BOOL bWait);

// Process all of the strange ExitWindowsEx codes and privileges.
STDAPI_(BOOL) CommonRestart(DWORD dwExitWinCode, DWORD dwReasonCode)
{
    BOOL fOk;
    DWORD dwExtraExitCode = 0;
    DWORD OldState;
    DWORD dwError;

    DebugMsg(DM_TRACE, TEXT("CommonRestart(0x%x, 0x%x)"), dwExitWinCode, dwReasonCode);

    IconCacheSave();

    if ((dwExitWinCode == EWX_SHUTDOWN) && IsPwrShutdownAllowed())
    {
        dwExtraExitCode = EWX_POWEROFF;
    }

    dwError = SetPrivilegeAttribute(SE_SHUTDOWN_NAME, SE_PRIVILEGE_ENABLED, &OldState);

    switch (dwExitWinCode) 
    {
    case EWX_SHUTDOWN:
    case EWX_REBOOT:
    case EWX_LOGOFF:

        if (GetKeyState(VK_CONTROL) < 0)
        {
            dwExtraExitCode |= EWX_FORCE;
        }

        break;
    }

    fOk = ExitWindowsEx(dwExitWinCode | dwExtraExitCode, dwReasonCode);

    // If we were able to set the privilege, then reset it.
    if (dwError == ERROR_SUCCESS)
    {
        SetPrivilegeAttribute(SE_SHUTDOWN_NAME, OldState, NULL);
    }
    else
    {
        // Otherwise, if we failed, then it must have been some
        // security stuff.
        if (!fOk)
        {
            ShellMessageBox(HINST_THISDLL, NULL,
                            dwExitWinCode == EWX_SHUTDOWN ?
                             MAKEINTRESOURCE(IDS_NO_PERMISSION_SHUTDOWN) :
                             MAKEINTRESOURCE(IDS_NO_PERMISSION_RESTART),
                            dwExitWinCode == EWX_SHUTDOWN ?
                             MAKEINTRESOURCE(IDS_SHUTDOWN) :
                             MAKEINTRESOURCE(IDS_RESTART),
                            MB_OK | MB_ICONSTOP);
        }
    }

    DebugMsg(DM_TRACE, TEXT("CommonRestart done"));

    return fOk;
}

void EarlySaveSomeShellState()
{
    // We flush two MRU's here (RecentMRU and RunDlgMRU).
    // Note that they won't flush if there is any reference count.
    
    FlushRunDlgMRU();
}


/*
 * Display a dialog asking the user to restart Windows, with a button that
 * will do it for them if possible.
 */
STDAPI_(int) RestartDialog(HWND hParent, LPCTSTR lpPrompt, DWORD dwReturn)
{
    return RestartDialogEx(hParent, lpPrompt, dwReturn, 0);
}

STDAPI_(int) RestartDialogEx(HWND hParent, LPCTSTR lpPrompt, DWORD dwReturn, DWORD dwReasonCode)
{
    UINT id;
    LPCTSTR pszMsg;

    EarlySaveSomeShellState();

    if (lpPrompt && *lpPrompt == TEXT('#'))
    {
        pszMsg = lpPrompt + 1;
    }
    else if (dwReturn == EWX_SHUTDOWN)
    {
        pszMsg = MAKEINTRESOURCE(IDS_RSDLG_SHUTDOWN);
    }
    else
    {
        pszMsg = MAKEINTRESOURCE(IDS_RSDLG_RESTART);
    }

    id = ShellMessageBox(HINST_THISDLL, hParent, pszMsg, MAKEINTRESOURCE(IDS_RSDLG_TITLE),
                MB_YESNO | MB_ICONQUESTION, lpPrompt ? lpPrompt : c_szNULL);

    if (id == IDYES)
    {
        CommonRestart(dwReturn, dwReasonCode);
    }
    return id;
}


const TCHAR c_szREGSTR_ROOT_APM[] = REGSTR_KEY_ENUM TEXT("\\") REGSTR_KEY_ROOTENUM TEXT("\\") REGSTR_KEY_APM TEXT("\\") REGSTR_DEFAULT_INSTANCE;
const TCHAR c_szREGSTR_BIOS_APM[] = REGSTR_KEY_ENUM TEXT("\\") REGSTR_KEY_BIOSENUM TEXT("\\") REGSTR_KEY_APM;
const TCHAR c_szREGSTR_VAL_APMMENUSUSPEND[] = REGSTR_VAL_APMMENUSUSPEND;

/* Open the registry APM device key
 */

BOOL OpenAPMKey(HKEY *phKey)
{
    HKEY hBiosSys;
    BOOL rc = FALSE;
    TCHAR szInst[MAX_PATH+1];
    DWORD cchInst = ARRAYSIZE(szInst);

    // Open HKLM\Enum\Root\*PNP0C05\0000 - This is the APM key for
    // non-PnP BIOS machines.

    if (RegOpenKey(HKEY_LOCAL_MACHINE, c_szREGSTR_ROOT_APM, phKey) == ERROR_SUCCESS)
        return TRUE;

    // Open HKLM\Enum\BIOS\*PNP0C05, Enum the 1st subkey, open that.  Example:
    // HKLM\Enum\BIOS\*PNP0C05\03.

    if (RegOpenKey(HKEY_LOCAL_MACHINE,c_szREGSTR_BIOS_APM,&hBiosSys) == ERROR_SUCCESS)
    {
        if (RegEnumKey(hBiosSys, 0, szInst, cchInst) == ERROR_SUCCESS &&
            RegOpenKey(hBiosSys, szInst, phKey) == ERROR_SUCCESS)
            rc = TRUE;

        RegCloseKey(hBiosSys);
    }

    return rc;
}

BOOL CheckBIOS(void)
{
    HKEY hkey;
    BOOL fRet = TRUE;
    BOOL fSuspendUndocked = TRUE;

    /* Check the Registry APM key for an APMMenuSuspend value.
     * APMMenuSuspend may have the following values: APMMENUSUSPEND_DISABLED,
     * APMMENUSUSPEND_ENABLED, or APMMENUSUSPEND_UNDOCKED.
     *
     * An APMMenuSuspend value of APMMENUSUSPEND_DISABLED means the
     * tray should never show the Suspend menu item on its menu.
     *
     * APMMENUSUSPEND_ENABLED means the Suspend menu item should be shown
     * if the machine has APM support enabled (VPOWERD is loaded).  This is
     * the default.
     *
     * APMMENUSUSPEND_UNDOCKED means the Suspend menu item should be shown,
     * but only enabled when the machine is not in a docking station.
     *
     */

    if (OpenAPMKey(&hkey))
    {
        BYTE bMenuSuspend = APMMENUSUSPEND_ENABLED;
        DWORD dwType, cbSize = sizeof(bMenuSuspend);

        if (SHQueryValueEx(hkey, c_szREGSTR_VAL_APMMENUSUSPEND, 0,
                            &dwType, &bMenuSuspend, &cbSize) == ERROR_SUCCESS)
        {
            bMenuSuspend &= ~(APMMENUSUSPEND_NOCHANGE);     // don't care about nochange flag
            if (bMenuSuspend == APMMENUSUSPEND_UNDOCKED)
                fSuspendUndocked = TRUE;
            else
            {
                fSuspendUndocked = FALSE;

                if (bMenuSuspend == APMMENUSUSPEND_DISABLED)
                    fRet = FALSE;
            }
        }
        RegCloseKey(hkey);
    }

    if (fRet)
    {
        // Disable Suspend menu item if 1) only wanted when undocked and
        // system is currently docked, 2) power mgnt level < advanced

        if (fSuspendUndocked && SHGetMachineInfo(GMI_DOCKSTATE) != GMID_UNDOCKED)
            fRet = FALSE;
        else
        {
            DWORD dwPmLevel, cbOut;
            BOOL fIoSuccess;
            HANDLE hVPowerD = CreateFile(TEXT("\\\\.\\APMTEST"),
                                  GENERIC_READ|GENERIC_WRITE,
                                  FILE_SHARE_READ|FILE_SHARE_WRITE,
                                  NULL, OPEN_EXISTING, 0, NULL);

            if (hVPowerD != INVALID_HANDLE_VALUE) 
            {
                fIoSuccess = DeviceIoControl(hVPowerD, APM_IOCTL_GET_PM_LEVEL, NULL, 0, &dwPmLevel, sizeof(dwPmLevel), &cbOut, NULL);

                fRet = (fIoSuccess && (dwPmLevel == PMLEVEL_ADVANCED));

                CloseHandle (hVPowerD);
            } 
            else 
            {
                fRet = FALSE;
            }
        }
    }

    return fRet;
}

BOOL IsShutdownAllowed(void)
{
    return SHTestTokenPrivilege(NULL, SE_SHUTDOWN_NAME);
}

// Determine if "Suspend" should appear in the shutdown dialog.
// Returns: TRUE if Suspend should appear, FALSE if not.

STDAPI_(BOOL) IsSuspendAllowed(void)
{
    //
    // Suspend requires SE_SHUTDOWN_PRIVILEGE
    // Call IsShutdownAllowed() to test for this
    //

    return IsShutdownAllowed() && IsPwrSuspendAllowed();
}

BOOL _LogoffAvailable()
{
    // If dwStartMenuLogoff is zero, then we remove it.
    BOOL fUpgradeFromIE4 = FALSE;
    BOOL fUserWantsLogoff = FALSE;
    DWORD dwStartMenuLogoff = 0;
    TCHAR sz[MAX_PATH];
    DWORD dwRestriction = SHRestricted(REST_STARTMENULOGOFF);

    DWORD cbData = sizeof(dwStartMenuLogoff);

    if (ERROR_SUCCESS == SHGetValue(HKEY_CURRENT_USER, REGSTR_EXPLORER_ADVANCED, 
                    TEXT("StartMenuLogoff"), NULL, &dwStartMenuLogoff, &cbData))
    {
        fUserWantsLogoff = (dwStartMenuLogoff != 0);
    }

    cbData = ARRAYSIZE(sz);
    if (SUCCEEDED(SKGetValue(SHELLKEY_HKLM_EXPLORER, TEXT("WindowsUpdate"), 
                    TEXT("UpdateURL"), NULL, sz, &cbData)))
    {
        fUpgradeFromIE4 = (sz[0] != TEXT('\0'));
    }

    // Admin is forcing the logoff to be on the menu
    if (dwRestriction == 2)
        return FALSE;

    // The user does wants logoff on the start menu.
    // Or it's an upgrade from IE4
    if ((fUpgradeFromIE4 || fUserWantsLogoff) && dwRestriction != 1)
        return FALSE;

    return TRUE;
}

DWORD GetShutdownOptions()
{
    LONG lResult = ERROR_SUCCESS + 1;
    DWORD dwOptions = SHTDN_SHUTDOWN;

    // No shutdown on terminal server
    if (!GetSystemMetrics(SM_REMOTESESSION))
    {
        dwOptions |= SHTDN_RESTART;
    }

    // Add logoff if supported
    if (_LogoffAvailable())
    {
        dwOptions |= SHTDN_LOGOFF;
    }

    // Add the hibernate option if it's supported.

    if (IsPwrHibernateAllowed())
    {
        dwOptions |= SHTDN_HIBERNATE;
    }

    if (IsSuspendAllowed())
    {
        HKEY hKey;
        DWORD dwAdvSuspend = 0;
        DWORD dwType, dwSize;

        // At least basic sleep is supported
        dwOptions |= SHTDN_SLEEP;

        //
        // Check if we should offer advanced suspend options
        //

        if (RegOpenKeyEx(HKEY_LOCAL_MACHINE,
                         TEXT("SYSTEM\\CurrentControlSet\\Control\\Session Manager\\Power"),
                         0, KEY_READ, &hKey) == ERROR_SUCCESS)
        {
            dwSize = sizeof(dwAdvSuspend);
            SHQueryValueEx(hKey, TEXT("Shutdown"), NULL, &dwType,
                                 (LPBYTE) &dwAdvSuspend, &dwSize);

            RegCloseKey(hKey);
        }


        if (dwAdvSuspend != 0)
        {
            dwOptions |= SHTDN_SLEEP2;
        }
    }

    return dwOptions;
}

BOOL_PTR CALLBACK LogoffDlgProc(HWND hdlg, UINT msg, WPARAM wparam, LPARAM lparam)
{
    static BOOL s_fLogoffDialog = FALSE;
    HICON hIcon;

    switch (msg)
    {
    case WM_INITMENUPOPUP:
        EnableMenuItem((HMENU)wparam, SC_MOVE, MF_BYCOMMAND|MF_GRAYED);
        break;

    case WM_INITDIALOG:
        // We could call them when the user actually selects the shutdown,
        // but I put them here to leave the shutdown process faster.
        //
        EarlySaveSomeShellState();

        s_fLogoffDialog = FALSE;
        hIcon = LoadImage (HINST_THISDLL, MAKEINTRESOURCE(IDI_STLOGOFF),
                           IMAGE_ICON, 48, 48, LR_DEFAULTCOLOR);

        if (hIcon)
        {
            SendDlgItemMessage (hdlg, IDD_LOGOFFICON, STM_SETICON, (WPARAM) hIcon, 0);
        }
        return TRUE;

    // Blow off moves (only really needed for 32bit land).
    case WM_SYSCOMMAND:
        if ((wparam & ~0x0F) == SC_MOVE)
            return TRUE;
        break;

    case WM_COMMAND:
        switch (LOWORD(wparam))
        {
        case IDOK:
            s_fLogoffDialog = TRUE;
            EndDialog(hdlg, SHTDN_LOGOFF);
            break;

        case IDCANCEL:
            s_fLogoffDialog = TRUE;
            EndDialog(hdlg, SHTDN_NONE);
            break;

        case IDHELP:
            WinHelp(hdlg, TEXT("windows.hlp>proc4"), HELP_CONTEXT, (DWORD) IDH_TRAY_SHUTDOWN_HELP);
            break;
        }
        break;

    case WM_ACTIVATE:
        // If we're loosing the activation for some other reason than
        // the user click OK/CANCEL then bail.
        if (LOWORD(wparam) == WA_INACTIVE && !s_fLogoffDialog)
        {
            s_fLogoffDialog = TRUE;
            EndDialog(hdlg, SHTDN_NONE);
        }
        break;
    }
    return FALSE;
}

//  These dialog procedures more or less mirror the behavior of LogoffDlgProc.

INT_PTR CALLBACK DisconnectDlgProc(HWND hwndDialog, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    static BOOL s_fIgnoreActivate = FALSE;

    INT_PTR ipResult = FALSE;
    switch (uMsg)
    {
    case WM_INITMENUPOPUP:
        EnableMenuItem((HMENU)wParam, SC_MOVE, MF_BYCOMMAND | MF_GRAYED);
        break;

    case WM_INITDIALOG:
    {
        HICON   hIcon;

        EarlySaveSomeShellState();
        s_fIgnoreActivate = FALSE;
        hIcon = LoadImage(HINST_THISDLL, MAKEINTRESOURCE(IDI_MU_DISCONN), IMAGE_ICON, 48, 48, LR_DEFAULTCOLOR);
        if (hIcon != NULL)
        {
            SendDlgItemMessage(hwndDialog, IDD_DISCONNECTICON, STM_SETICON, (WPARAM)hIcon, 0);
        }
        ipResult = TRUE;
        break;
    }

    case WM_SYSCOMMAND:
        ipResult = ((wParam & ~0x0F) == SC_MOVE);
        break;

    case WM_COMMAND:
        switch (LOWORD(wParam))
        {
        case IDOK:
            s_fIgnoreActivate = TRUE;
            TBOOL(EndDialog(hwndDialog, SHTDN_DISCONNECT));
            break;
        case IDCANCEL:
            s_fIgnoreActivate = TRUE;
            TBOOL(EndDialog(hwndDialog, SHTDN_NONE));
            break;
        }
        break;

    case WM_ACTIVATE:
        if ((WA_INACTIVE == LOWORD(wParam)) && !s_fIgnoreActivate)
        {
            s_fIgnoreActivate = TRUE;
            TBOOL(EndDialog(hwndDialog, SHTDN_NONE));
        }
        break;
    }
    return ipResult;
}

BOOL CanDoFastRestart()
{
    return GetAsyncKeyState(VK_SHIFT) < 0;
}

// ---------------------------------------------------------------------------
// Shutdown thread

typedef struct 
{
    DWORD_PTR nCmd;
    HWND hwndParent;
} SDTP_PARAMS;

// Hydra-specific
void Disconnect(void)
{
    TW32(ShellSwitchUser(FALSE));
}

DWORD CALLBACK ShutdownThreadProc(void *pv)
{
    SDTP_PARAMS *psdtp = (SDTP_PARAMS *)pv;

    BOOL fShutdownWorked = FALSE;

    // tell USER that anybody can steal foreground from us
    // This allows apps to put up UI during shutdown/suspend/etc.
    //    AllowSetForegroundWindow(ASFW_ANY);
 
    switch (psdtp->nCmd) 
    {
    case SHTDN_SHUTDOWN:
        fShutdownWorked = CommonRestart(EWX_SHUTDOWN, 0);
        break;

    case SHTDN_RESTART:
        fShutdownWorked = CommonRestart(CanDoFastRestart() ? EW_RESTARTWINDOWS : EWX_REBOOT, 0);
        break;

    case SHTDN_LOGOFF:
        fShutdownWorked = CommonRestart(EWX_LOGOFF, 0);
        break;

    case SHTDN_RESTART_DOS:        // Special hack to mean exit to dos
    case SHTDN_SLEEP:
    case SHTDN_SLEEP2:
    case SHTDN_HIBERNATE:
        SetSuspendState((psdtp->nCmd == SHTDN_HIBERNATE) ? TRUE : FALSE,
                        (GetKeyState(VK_CONTROL) < 0) ? TRUE : FALSE,
                        (psdtp->nCmd == SHTDN_SLEEP2) ? TRUE : FALSE);
        break;
    }

    LocalFree(psdtp);

    return fShutdownWorked;
}

#define DIALOG_LOGOFF       1
#define DIALOG_EXIT         2
#define DIALOG_DISCONNECT   3

void CloseWindowsDialog(HWND hwndParent, int iDialogType)
{
    INT_PTR     nCmd = SHTDN_NONE;
    IUnknown*   pIUnknown;
    HWND        hwndBackground;

    if (FAILED(ShellDimScreen(&pIUnknown, &hwndBackground)))
    {
        pIUnknown = NULL;
        hwndBackground = NULL;
    }

    switch (iDialogType)
    {
        LPCTSTR     pszDialogID;
        DLGPROC     pfnDialogProc;

        case DIALOG_LOGOFF:
        case DIALOG_DISCONNECT:
        {
            if (!GetSystemMetrics(SM_REMOTESESSION) && IsOS(OS_FRIENDLYLOGONUI) && IsOS(OS_FASTUSERSWITCHING))
            {

                //  If not remote with friendly UI and FUS show the licky button dialog.

                nCmd = SwitchUserDialog_Show(hwndBackground);
                pszDialogID = 0;
                pfnDialogProc = NULL;
            }
            else if (iDialogType == DIALOG_LOGOFF)
            {

                //  Otherwise show the Win32 log off dialog if log off.

                pszDialogID = MAKEINTRESOURCE(DLG_LOGOFFWINDOWS);
                pfnDialogProc = LogoffDlgProc;
            }
            else if (iDialogType == DIALOG_DISCONNECT)
            {

                //  Or the Win32 disconnect dialog if disconnect.

                pszDialogID = MAKEINTRESOURCE(DLG_DISCONNECTWINDOWS);
                pfnDialogProc = DisconnectDlgProc;
            }
            else
            {
                ASSERTMSG(FALSE, "Unexpected case hit in CloseWindowsDialog");
            }
            if ((pszDialogID != 0) && (pfnDialogProc != NULL))
            {
                nCmd = DialogBoxParam(HINST_THISDLL, pszDialogID, hwndBackground, pfnDialogProc, 0);
            }
            if (nCmd == SHTDN_DISCONNECT)
            {
                Disconnect();
                nCmd = SHTDN_NONE;
            }
            break;
        }
        case DIALOG_EXIT:
        {
            BOOL fGinaShutdownCalled = FALSE;
            HINSTANCE hGina;

            TCHAR szUsername[UNLEN];
            DWORD cchUsernameLength = UNLEN;
            DWORD dwOptions;

            if (WNetGetUser(NULL, szUsername, &cchUsernameLength) != NO_ERROR)
            {
                szUsername[0] = TEXT('\0');
            }
          
            EarlySaveSomeShellState();

            // Load MSGINA.DLL and get appropriate shutdown function
            hGina = LoadLibrary(TEXT("msgina.dll"));
            if (hGina != NULL)
            {
                if (IsOS(OS_FRIENDLYLOGONUI))
                {
                    nCmd = ShellTurnOffDialog(hwndBackground);
                    fGinaShutdownCalled = TRUE;
                }
                else
                {
                    PFNSHELLSHUTDOWNDIALOG pfnShellShutdownDialog = (PFNSHELLSHUTDOWNDIALOG)
                        GetProcAddress(hGina, "ShellShutdownDialog");

                    if (pfnShellShutdownDialog != NULL)
                    {
                        nCmd = pfnShellShutdownDialog(hwndBackground,
                            szUsername, 0);

                        // Handle disconnect right now
                        if (nCmd == SHTDN_DISCONNECT)
                        {

                            Disconnect();

                            // No other action
                            nCmd = SHTDN_NONE;
                        }

                        fGinaShutdownCalled = TRUE;
                    }
                }
                FreeLibrary(hGina);
            }

            if (!fGinaShutdownCalled)
            {
                dwOptions = GetShutdownOptions();
        
                // Gina call failed; use our cheesy private version
                nCmd = DownlevelShellShutdownDialog(hwndBackground,
                        dwOptions, szUsername);
            }
            break;
        }
    }

    if (hwndBackground)
        SetForegroundWindow(hwndBackground);

    if (nCmd == SHTDN_NONE)
    {
        if (hwndBackground)
        {
            ShowWindow(hwndBackground, SW_HIDE);
            PostMessage(hwndBackground, WM_CLOSE, 0, 0);
        }
    }
    else
    {
        SDTP_PARAMS *psdtp = LocalAlloc(LPTR, sizeof(*psdtp));
        if (psdtp)
        {
            DWORD dw;
            HANDLE h;

            psdtp->nCmd = nCmd;
            psdtp->hwndParent = hwndParent;

            //  have another thread call ExitWindows() so our
            //  main pump keeps running durring shutdown.
            //
            h = CreateThread(NULL, 0, ShutdownThreadProc, psdtp, 0, &dw);
            if (h)
            {
                CloseHandle(h);
            }
            else
            {
                if (hwndBackground)
                    ShowWindow(hwndBackground, SW_HIDE);
                ShutdownThreadProc(psdtp);
            }
        }
    }
    if (pIUnknown != NULL)
    {
        pIUnknown->lpVtbl->Release(pIUnknown);
    }
}

// API functions

STDAPI_(void) ExitWindowsDialog(HWND hwndParent)
{
    if (!IsOS(OS_FRIENDLYLOGONUI) || IsShutdownAllowed())
    {
        CloseWindowsDialog (hwndParent, DIALOG_EXIT);
    }
    else
    {
        LogoffWindowsDialog(hwndParent);
    }
}

STDAPI_(void) LogoffWindowsDialog(HWND hwndParent)
{
    CloseWindowsDialog (hwndParent, DIALOG_LOGOFF);
}

STDAPI_(void) DisconnectWindowsDialog(HWND hwndParent)
{
    CloseWindowsDialog(hwndParent, DIALOG_DISCONNECT);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\rssubdat.cpp ===
#include "shellprv.h"
#pragma  hdrstop

#include "rssubdat.h"

///////////////////////////////////////////////////////////////////////////////
// Public methods
///////////////////////////////////////////////////////////////////////////////
BOOL CRSSubData::InitRegSupport(HKEY hkey, LPCTSTR pszKey1, LPCTSTR pszKey2,
                                LPCTSTR pszKey3, DWORD cbSizeOfData,
                                BOOL fVolatile)
{
    DWORD dwDefaultOptions = REG_OPTION_NON_VOLATILE;

    if (fVolatile)
    {
        dwDefaultOptions = REG_OPTION_VOLATILE;
    }
     
    _SetSizeOfData(cbSizeOfData);

    RSInitRoot(hkey, pszKey1, pszKey2, REG_OPTION_NON_VOLATILE, dwDefaultOptions);

    RSCVInitSubKey(pszKey3);

    return TRUE;
}

BOOL CRSSubData::Update()
{
    BOOL fRet = TRUE;
    BOOL fNeedUpdate = FALSE;

    if (!_fHoldUpdate)
    {
        if (_IsValid())
        {
            if (!_RSCVIsValidVersion())
            {
                DWORD cbSizeOfData = _cbSizeOfData;

                if (RSGetDWORDValue(RSCVGetSubKey(), TEXT("LastUpdate"), _GetTickLastUpdatePtr()) && 
                    RSGetBinaryValue(RSCVGetSubKey(), TEXT("Cache"), (PBYTE)_GetDataPtr(), &cbSizeOfData))
                {
                    if (cbSizeOfData != _cbSizeOfData)
                    {
                        fNeedUpdate = TRUE;
                    }
                    else
                    {
                        _RSCVUpdateVersionOnCacheRead();
                    }
                }
                else
                {
                    fNeedUpdate = TRUE;
                }
            }

            // Is the information expired?
            if (!fNeedUpdate && _IsExpired())
            {
                // Yes
                fNeedUpdate = TRUE;
            }
        }

        if (!_IsValid() || fNeedUpdate)
        {
            Invalidate();

            fRet = CSubData::Update();

            if (fRet)
            {
                _Propagate();
            }
        }
    }

    return fRet;
}

BOOL CRSSubData::Propagate()
{
    return _Propagate();
}

BOOL CRSSubData::ExistInReg()
{
    return RSSubKeyExist(RSCVGetSubKey());
}

void CRSSubData::WipeReg()
{
    RSDeleteSubKey(RSCVGetSubKey());
}

void CRSSubData::Invalidate()
{
    _RSCVIncrementRegVersion();

    CSubData::Invalidate();
}

CRSSubData::CRSSubData()
{}

void CRSSubData::_RSCVDeleteRegCache()
{
    RSDeleteValue(RSCVGetSubKey(), TEXT("LastUpdate"));
    RSDeleteValue(RSCVGetSubKey(), TEXT("Cache"));
}

BOOL CRSSubData::_Propagate()
{
    RSSetDWORDValue(RSCVGetSubKey(), TEXT("LastUpdate"), _GetTickLastUpdate());
    RSSetBinaryValue(RSCVGetSubKey(), TEXT("Cache"), (PBYTE)_GetDataPtr(), _cbSizeOfData);

    // HACKHACK -  we increment twice, because it dont work if we do it only once.
    _RSCVUpdateVersionOnCacheWrite();
    _RSCVUpdateVersionOnCacheWrite();

    return TRUE;
}

BOOL CRSSubData::_RSSDGetDataFromReg()
{
    DWORD cbSizeOfData = _cbSizeOfData;

    return RSGetBinaryValue(RSCVGetSubKey(), TEXT("Cache"),
        (PBYTE)_GetDataPtr(), &cbSizeOfData);
}

void CRSSubData::_SetSizeOfData(DWORD cbSizeOfData)
{
    _cbSizeOfData = cbSizeOfData;
}

DWORD CRSSubData::_GetSizeOfData()
{
    return _cbSizeOfData;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\rssubdat.h ===
#include "shellprv.h"
#pragma  hdrstop

#include "rscchvr.h"
#include "subdata.h"

class CRSSubData : public CSubData, private CRSCacheVersion
{
///////////////////////////////////////////////////////////////////////////////
// Public methods
///////////////////////////////////////////////////////////////////////////////
public:
    BOOL InitRegSupport(HKEY hkey, LPCTSTR pszKey1, LPCTSTR pszKey2, LPCTSTR pszKey3,
        DWORD cbSizeOfData, BOOL fVolatile = FALSE);

    virtual BOOL Update();
    BOOL Propagate();

    BOOL ExistInReg();

    void WipeReg();

    void Invalidate();

#ifndef WINNT
    void FakeVolatileOnWin9X();
#endif

    CRSSubData();

///////////////////////////////////////////////////////////////////////////////
// Miscellaneous helpers
///////////////////////////////////////////////////////////////////////////////
protected:
    void _RSCVDeleteRegCache();

    BOOL _RSSDGetDataFromReg();

    DWORD _GetSizeOfData();
    void _SetSizeOfData(DWORD cbSizeOfData);

private:
    BOOL _Propagate();

///////////////////////////////////////////////////////////////////////////////
// Data
///////////////////////////////////////////////////////////////////////////////
private:
    DWORD _cbSizeOfData;

#ifndef WINNT
    BOOL  _fVolatile;
#endif
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\scffile.cpp ===
// this file implements shell command files.
// .scf scffile
// when executed, they run a shell internal command.
// they can have stream storage, or whatnot in them
//
// file format is *PURPOSELY* text so that folks can create and modify by hand

#include "shellprv.h"
#include <desktopp.h>
#include <trayp.h>

extern HWND g_hwndTray; // desktop.cpp

void SFC_IECommand(LPCTSTR pszFile)
{
    TCHAR szCommand[40];
    
    if (GetPrivateProfileString(TEXT("IE"), TEXT("Command"), TEXT(""), szCommand, ARRAYSIZE(szCommand), pszFile)) 
    {
        if (!lstrcmpi(szCommand, TEXT("Channels"))
            && !SHRestricted2W(REST_NoChannelUI, NULL, 0))
        {
            Channel_QuickLaunch();
        }
    }
}

void SFC_TrayCommand(LPCTSTR pszFile)
{
    HWND hwnd = g_hwndTray;
    if (hwnd && IsWindowInProcess(hwnd))
    {
        TCHAR szCommand[40];
        if (GetPrivateProfileString(TEXT("Taskbar"), TEXT("Command"), TEXT(""), szCommand, ARRAYSIZE(szCommand), pszFile)) 
        {
            char szAnsiCommand[40];
            SHTCharToAnsi(szCommand, szAnsiCommand, ARRAYSIZE(szAnsiCommand));

            LPSTR psz = StrDupA(szAnsiCommand);
            if (psz) 
            {
                if (!PostMessage(hwnd, TM_PRIVATECOMMAND, 0, (LPARAM)psz))
                    LocalFree(psz);
            }
        }
    }
}

const struct
{
    UINT id;
    void (*pfn)(LPCTSTR pszBuf);
} 
c_sCmdInfo[] = 
{
    { 2, SFC_TrayCommand},
    { 3, SFC_IECommand},
};

STDAPI_(void) ShellExecCommandFile(LPCITEMIDLIST pidl)
{
    TCHAR szFile[MAX_PATH];

    if (SHGetPathFromIDList(pidl, szFile)) 
    {
        UINT uID = GetPrivateProfileInt(TEXT("Shell"), TEXT("Command"), 0, szFile);
        if (uID) 
        {
            for (int i = 0; i < ARRAYSIZE(c_sCmdInfo); i++) 
            {
                if (uID == c_sCmdInfo[i].id) 
                {
                    c_sCmdInfo[i].pfn(szFile);
                    break;
                }
            }
        }
    }
}

class CShellCmdFileIcon : public IExtractIconA, public IExtractIconW, public IPersistFile
{
public:
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void** ppv);
    STDMETHODIMP_(ULONG) AddRef();
    STDMETHODIMP_(ULONG) Release();

    // IExtractIconA
    STDMETHODIMP GetIconLocation(UINT uFlags, LPSTR pszIconFile, UINT cchMax, int* piIndex, UINT* pwFlags);
    STDMETHODIMP Extract(LPCSTR pszFile, UINT nIconIndex, HICON* phiconLarge, HICON* phiconSmall, UINT nIconSize) {return S_FALSE;};

    // IExtractIconW
    STDMETHODIMP GetIconLocation(UINT uFlags, LPWSTR pszIconFile, UINT cchMax, int* piIndex, UINT* pwFlags);
    STDMETHODIMP Extract(LPCWSTR pszFile, UINT nIconIndex, HICON* phiconLarge, HICON* phiconSmall, UINT nIconSize) {return S_FALSE;};

    // IPersist
    STDMETHODIMP GetClassID(CLSID *pclsid) { *pclsid = CLSID_CmdFileIcon; return S_OK;};
    
    // IPersistFile
    STDMETHODIMP IsDirty(void) {return S_FALSE;};
    STDMETHODIMP Save(LPCOLESTR pcwszFileName, BOOL bRemember) {return S_OK;};
    STDMETHODIMP SaveCompleted(LPCOLESTR pcwszFileName){return S_OK;};
    STDMETHODIMP Load(LPCOLESTR pcwszFileName, DWORD dwMode);
    STDMETHODIMP GetCurFile(LPOLESTR *ppwszFileName);
    
    CShellCmdFileIcon() { _cRef = 1; DllAddRef(); };
private:
    ~CShellCmdFileIcon() { DllRelease(); };

    LONG _cRef;
    TCHAR _szFile[MAX_PATH];
};


ULONG CShellCmdFileIcon::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CShellCmdFileIcon::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;
    delete this;
    return 0;
}

HRESULT CShellCmdFileIcon::GetIconLocation(UINT uFlags, LPTSTR szIconFile, UINT cchMax, int *piIndex, UINT *pwFlags)
{
    TCHAR szData[MAX_PATH + 80];

    if (_szFile[0]) 
    {
        *pwFlags = 0;
        *piIndex = 0;
        szIconFile[0] = 0;

        GetPrivateProfileString(TEXT("Shell"), TEXT("IconFile"), TEXT(""), szData, ARRAYSIZE(szData), _szFile);
        
        *piIndex = PathParseIconLocation(szData);
        lstrcpyn(szIconFile, szData, cchMax);
        return S_OK;
    }
    
    return E_FAIL;
}

HRESULT CShellCmdFileIcon::GetIconLocation(UINT uFlags, LPSTR szIconFile, UINT cchMax, int *piIndex, UINT *pwFlags)
{
    WCHAR szAnsiIconPath[MAX_PATH];
    HRESULT hr = GetIconLocation(uFlags, szAnsiIconPath, MAX_PATH, piIndex, pwFlags);
    if (SUCCEEDED(hr))
    {
        SHUnicodeToAnsi(szAnsiIconPath, szIconFile, cchMax);
    }
    
    return hr;
}


// IPersistFile::Load

STDMETHODIMP CShellCmdFileIcon::Load(LPCOLESTR pwszFile, DWORD dwMode)
{
    SHUnicodeToTChar(pwszFile, _szFile, ARRAYSIZE(_szFile));
    return S_OK;
}

STDMETHODIMP CShellCmdFileIcon::GetCurFile(LPOLESTR *ppwszFileName)
{
    SHTCharToUnicode(_szFile, *ppwszFileName, ARRAYSIZE(_szFile));
    return S_OK;
}

HRESULT CShellCmdFileIcon::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] =
    {
        QITABENT(CShellCmdFileIcon, IExtractIconA),
        QITABENT(CShellCmdFileIcon, IExtractIconW),
        QITABENT(CShellCmdFileIcon, IPersistFile),
        QITABENTMULTI(CShellCmdFileIcon, IPersist, IPersistFile),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

STDAPI CShellCmdFileIcon_CreateInstance(IUnknown* pUnkOuter, REFIID riid, void **ppv)
{
    HRESULT hr;
    CShellCmdFileIcon *pObj = new CShellCmdFileIcon();
    if (pObj)
    {
        hr = pObj->QueryInterface(riid, ppv);
        pObj->Release();
    }
    else
    {
        *ppv = NULL;
        hr = E_OUTOFMEMORY;
    }

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\scnotifyp.h ===
//  private declarations for scnotify.cpp

typedef struct
{
    DWORD   dwSig;
    UINT    uCmd;                                                       
    ULONG   ulID;                                                       
    ULONG   ulHwnd;
    UINT    uMsg;                                                       
    DWORD   fSources;                                                   
    LONG    lEvents;                                                    
    BOOL    fRecursive;                                                 
    UINT    uidlRegister;                                               
} CHANGEREGISTER;                        
                                                                        
typedef struct 
{
    DWORD   dwSig;
    DWORD   cbSize;                                                     
    LONG    lEvent;                                                     
    UINT    uFlags;                                                     
    DWORD   dwEventTime;                                                
    UINT    uidlMain;                                                   
    UINT    uidlExtra;                                                  
} CHANGEEVENT;                        
                                                                        
typedef struct 
{
    DWORD dwSig;
    LPITEMIDLIST pidlMain;                                   
    LPITEMIDLIST pidlExtra;                                  
    CHANGEEVENT *pce;                                      
} CHANGELOCK;               

HANDLE SHChangeNotification_Create(LONG lEvent, UINT uFlags, LPCITEMIDLIST pidlMain, LPCITEMIDLIST pidlExtra, DWORD dwProcId, DWORD dwEventTime);


class CNotifyEvent;
class CCollapsingClient;
class CRegisteredClient;
class CInterruptSource;
class CAnyAlias;

//
//  this is the global object g_pscn
//  its lifetime is tied to the SCNotify thread and window.
//  if the thread or window dies, then the object is destroyed
//
class CChangeNotify
{
public:  //  methods
    CNotifyEvent *GetEvent(LONG lEvent, LPCITEMIDLIST pidl, LPCITEMIDLIST pidlExtra, DWORD dwEventTime, UINT uEventFlags);
    BOOL AddClient(IDLDATAF flags, LPCITEMIDLIST pidl, BOOL *pfInterrupt, BOOL fRecursive, CCollapsingClient *pclient);
    HRESULT RemoveClient(LPCITEMIDLIST pidl, BOOL fInterrupt, CCollapsingClient *pclient);
    BOOL AddInterruptSource(LPCITEMIDLIST pidlClient, BOOL fRecursive);
    void ReleaseInterruptSource(LPCITEMIDLIST pidlClient);
    void AddAlias(LPCITEMIDLIST pidlReal, LPCITEMIDLIST pidlAlias, DWORD dwEventTime);
    void AddSpecialAlias(int csidlReal, int csidlAlias);
    void UpdateSpecialAlias(int csidlAlias);
    void NotifyEvent(LONG lEvent, UINT uFlags, LPCITEMIDLIST pidl, LPCITEMIDLIST pidlExtra, DWORD dwEventTime);
    void PendingCallbacks(BOOL fAdd);
    void SetFlush(int idt);

    static DWORD WINAPI ThreadProc(void *pv);
    static DWORD WINAPI ThreadStartUp(void *pv);
    static LRESULT CALLBACK WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

protected:  //  methods
    BOOL _OnChangeRegistration(HANDLE hChangeRegistration, DWORD dwProcId);
    LRESULT _OnNotifyEvent(HANDLE hChange, DWORD dwProcId);
    LRESULT _OnSuspendResume(HANDLE hChange, DWORD dwProcId);
    void _OnDeviceBroadcast(ULONG_PTR code, DEV_BROADCAST_HANDLE *pbhnd);
    ULONG _RegisterClient(HWND hwnd, int fSources, LONG fEvents, UINT wMsg, SHChangeNotifyEntry *pfsne);
    BOOL _DeregisterClient(CRegisteredClient *pclient);
    BOOL _DeregisterClientByID(ULONG ulID);
    BOOL _DeregisterClientsByWindow(HWND hwnd);
    void _FreshenClients(void);
    BOOL _InitTree(CIDLTree **pptree);
    BOOL _AddToClients(LONG lEvent, LPCITEMIDLIST pidl, LPCITEMIDLIST pidlExtra, DWORD dwEventTime, UINT uEventFlags);
    void _MatchAndNotify(LPCITEMIDLIST pidl, CNotifyEvent *pne, BOOL fFromExtra);
    void _AddGlobalEvent(CNotifyEvent *pne);
    CInterruptSource *_InsertInterruptSource(LPCITEMIDLIST pidl, BOOL fRecursive);
    DWORD _GetInterruptEvents(HANDLE *ahEvents, DWORD cEvents);
    void _ResetRelatedInterrupts(LPCITEMIDLIST pidl);
    void _FlushInterrupts();
    void _Flush(BOOL fShouldWait);
    void _WaitForCallbacks(void);
    BOOL _SuspendResume(BOOL fSuspend, BOOL fRecursive, LPCITEMIDLIST pidl);

    BOOL _HandleMessages(void);
    void _MessagePump(void);
    void _SignalInterrupt(HANDLE hEvent);
    void _FreshenUp(void);

    CAnyAlias *_FindAlias(LPCITEMIDLIST pidlReal, LPCITEMIDLIST pidlAlias);
    CAnyAlias *_FindSpecialAlias(int csidlReal, int csidlAlias);
    void _CheckAliasRollover(void);
    void _FreshenAliases(void);
    BOOL _InsertAlias(CLinkedNode<CAnyAlias> *p);
    void _ActivateAliases(LPCITEMIDLIST pidl, BOOL fActivate);
    
protected:  //  members

    CIDLTree *_ptreeClients;
    CIDLTree *_ptreeInterrupts;
    CIDLTree *_ptreeAliases;
    
    CLinkedList<CInterruptSource> _listInterrupts;
    CLinkedList<CRegisteredClient> _listClients;
    CLinkedList<CAnyAlias> _listAliases;

    LONG _cFlushing;
    LONG _cCallbacks;
    HANDLE _hCallbackEvent;
};

typedef struct _MSGEVENT
{
    HANDLE hChange;
    DWORD dwProcId;
} MSGEVENT;

//
//  LIFETIME - based on clients holding references
//  Each event can have multiple references
//  each CRegisteredClient has a DPA that points to a list
//  of events that the client will want to know.
//  the first time an event is used, it is added
//  to the ptreeEvents, so that it may be reused.
//  when the last client stops using the event, then
//  it is removed from the tree.
//
class CNotifyEvent
{
public:
    STDMETHOD_(ULONG, AddRef)();
    STDMETHOD_(ULONG, Release)();

    MSGEVENT *GetNotification(DWORD dwProcId)
    {
        MSGEVENT *pme = new MSGEVENT;

        if (pme)
        {
            pme->dwProcId = dwProcId;
            pme->hChange = SHChangeNotification_Create((lEvent & ~SHCNE_INTERRUPT), // clients should never see the SHCNE_INTERRUPT flag
                                           0,
                                           pidl,
                                           pidlExtra,
                                           dwProcId,
                                           dwEventTime);
            if (!pme->hChange)
            {
                delete pme;
                pme = NULL;
            }
        }

        return pme;
    }
    
    BOOL Init(LPCITEMIDLIST pidlIn, LPCITEMIDLIST pidlExtraIn);

    LONG  lEvent;
    LPITEMIDLIST pidl;
    LPITEMIDLIST pidlExtra;
    DWORD dwEventTime;
    UINT uEventFlags;
    
protected:
    LONG _cRef;

    static CNotifyEvent *Create(LONG lEvent, LPCITEMIDLIST pidl, LPCITEMIDLIST pidlExtra, DWORD dwEventTime, UINT uEventFlags);
    CNotifyEvent(LONG lEventIn, DWORD dwEventTimeIn, UINT uEventFlagsIn) 
        : lEvent(lEventIn), dwEventTime(dwEventTimeIn), uEventFlags(uEventFlagsIn), _cRef(1) {}
    ~CNotifyEvent() { ILFree(pidl); ILFree(pidlExtra); }
    //  so CSCN can set fUsed;
    friend class CChangeNotify;
    friend class CRegisteredClient;
};

class CCollapsingClient
{
public:  // methods
    void Notify(CNotifyEvent *pne, BOOL fFromExtra);
    BOOL Flush(BOOL fNeedsCallbackEvent);
    BOOL Init(LPCITEMIDLIST pidl, BOOL fRecursive);

    CCollapsingClient();

protected:
    virtual ~CCollapsingClient();

    virtual BOOL _WantsEvent(LONG lEvent) = 0;
    virtual void _SendNotification(CNotifyEvent *pne, BOOL fNeedsCallbackEvent, SENDASYNCPROC pfncb) = 0;
    virtual BOOL _IsValidClient() = 0;
    virtual BOOL _CheckUpdatingSelf() = 0;

    LPITEMIDLIST        _pidl;
    LONG                _fEvents;
    HWND                _hwnd;
    BOOL                _fUpdatingSelf;
    BOOL                _fRecursive;

private:

    BOOL _Flush(BOOL fNeedsCallbackEvent);
    BOOL _CanCollapse(LONG lEvent);
    BOOL _IsDupe(CNotifyEvent *pne);
    BOOL _AddEvent(CNotifyEvent *pne, BOOL fFromExtra);

    CDPA<CNotifyEvent>  _dpaPendingEvents;
    int                 _iUpdatingSelfIndex;
    int                 _cEvents;
};

//
//  LIFETIME - based on client registration
//  when an SCN client calls Register, we create
//  a corresponding object that lives
//  as long as the client window is valid
//  or until Deregister is called.
//  references are kept in ptreeClients and in 
//  the pclientFirst list.  when a client is
//  removed from the list, it is also removed
//  from the tree.
//
class CRegisteredClient : public CCollapsingClient
{
public:  // methods
    CRegisteredClient();
    ~CRegisteredClient();
    BOOL Init(HWND hwnd, int fSources, LONG fEvents, UINT wMsg, SHChangeNotifyEntry *pfsne);
    
protected:  // methods
    void _SendNotification(CNotifyEvent *pne, BOOL fNeedsCallbackEvent, SENDASYNCPROC pfncb);
    BOOL _WantsEvent(LONG lEvent);
    BOOL _IsValidClient() { return (!_fDeadClient); }
    BOOL _CheckUpdatingSelf() { return _fUpdatingSelf; }

protected:  // members
    ULONG               _ulID;
    BOOL                _fDeadClient;
    BOOL                _fInterrupt;

private: // members
    DWORD               _dwProcId;
    int                 _fSources;
    UINT                _wMsg;
    
    friend class CChangeNotify;
};

class CAnyAlias : public CCollapsingClient
{
public:  // methods
    void Activate(BOOL fActivate);
    BOOL Remove();
    BOOL Init(LPCITEMIDLIST pidlReal, LPCITEMIDLIST pidlAlias);
    BOOL InitSpecial(int csidlReal, int csidlAlias);
    BOOL IsAlias(LPCITEMIDLIST pidlReal, LPCITEMIDLIST pidlAlias);
    BOOL IsSpecial(int csidlReal, int csidlAlias);
    ~CAnyAlias();

protected:
    BOOL _CustomTranslate();
    
    void _SendNotification(CNotifyEvent *pne, BOOL fNeedsCallbackEvent, SENDASYNCPROC pfncb);
    BOOL _WantsEvent(LONG lEvent);
    BOOL _IsValidClient() { return TRUE; }
    BOOL _CheckUpdatingSelf() { return FALSE; }
    BOOL _OkayToNotifyTranslatedEvent(CNotifyEvent *pne, LONG lEvent, LPCITEMIDLIST pidl, LPCITEMIDLIST pidlExtra);

private:
    LONG _cActivated;
    LPITEMIDLIST _pidlAlias;
    ITranslateShellChangeNotify *_ptscn;
    DWORD _dwTime;
    BOOL _fRemove;
    BOOL _fInterrupt;
    BOOL _fCheckedCustom;
    BOOL _fSpecial;
    int _csidlReal;
    int _csidlAlias;
    
    friend class CChangeNotify;
};

//
//  LIFETIME - based on client registration
//  when an SCN client calls Register, we may create
//  a corresponding object that lives
//  as long as the client window is valid
//  or until Deregister is called.
//  references are kept in ptreeClients and in 
//  the pclientFirst list.  when a client is
//  removed from the list, it is also removed
//  from the tree.
//
class CInterruptSource
{
public:  // methods
    BOOL Init(LPCITEMIDLIST pidl, BOOL fRecursive);
    void Reset(BOOL fSignal);
    BOOL GetEvent(HANDLE *phEvent);
    void Suspend(BOOL fSuspend);
    BOOL SuspendDevice(BOOL fSuspend, HDEVNOTIFY hPNP);
    BOOL Flush(void);
    ~CInterruptSource();
    
protected: // methods
    void _Reset(BOOL fDeviceNotify);
    
protected: // members
    LPITEMIDLIST pidl;     // this is SHARED with the fs registered client structure.
    DWORD cClients;         // how many clients are interested in this. (ref counts)

private:
    typedef enum
    {
        NO_SIGNAL = 0,
        SH_SIGNAL,
        FS_SIGNAL
    } SIGNAL_STATE;

    BOOL _fRecursive;        // is this a recursive interrupt client?
    HANDLE _hEvent;
    // cRecursive  clients
    LONG _cSuspend;         //  suspended for extended fileops
    SIGNAL_STATE _ssSignal;  //  FS has signaled us with an event on this directory
    HDEVNOTIFY _hPNP;        // PnP handle to warn us about drives coming and going
    HDEVNOTIFY _hSuspended;  // suspended PnP handle

    friend class CChangeNotify;
};
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\rundlg.cpp ===
#include "shellprv.h"
#include <regstr.h>
#include <shellp.h>
#include "ole2dup.h"
#include "ids.h"
#include "defview.h"
#include "lvutil.h"
#include "idlcomm.h"
#include "filetbl.h"
#include "undo.h"
#include "vdate.h"
#include "cnctnpt.h"

BOOL g_bCheckRunInSep = FALSE;
HANDLE g_hCheckNow = NULL;
HANDLE h_hRunDlgCS = NULL;

const TCHAR c_szRunMRU[] = REGSTR_PATH_EXPLORER TEXT("\\RunMRU");
const TCHAR c_szRunDlgReady[] = TEXT("MSShellRunDlgReady");
const TCHAR c_szWaitingThreadID[] = TEXT("WaitingThreadID");

BOOL RunDlgNotifyParent(HWND hDlg, HWND hwnd, LPTSTR pszCmd, LPCTSTR pszWorkingDir);
void ExchangeWindowPos(HWND hwnd0, HWND hwnd1);

#define WM_SETUPAUTOCOMPLETE (WM_APP)

// implements the Dialog that can navigate through the Shell Name Space and ShellExec() commands.
class CRunDlg : public IDropTarget
{
public:
    CRunDlg();

    // *** IUnknown ***
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);
    STDMETHODIMP QueryInterface(REFIID riid, void ** ppvObj);

    // *** IDropTarget methods ***
    STDMETHODIMP DragEnter(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    STDMETHODIMP DragOver(DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);
    STDMETHODIMP DragLeave(void);
    STDMETHODIMP Drop(IDataObject *pdtobj, DWORD grfKeyState, POINTL pt, DWORD *pdwEffect);


private:
    ~CRunDlg(void);        // This is now an OLE Object and cannot be used as a normal Class.

    BOOL OKPushed(void);
    void ExitRunDlg(BOOL bOK);
    void InitRunDlg(HWND hDlg);
    void InitRunDlg2(HWND hDlg);
    void BrowsePushed(void);

    friend DWORD CALLBACK CheckRunInSeparateThreadProc(void *pv);
    friend BOOL_PTR CALLBACK RunDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam);
    friend WINAPI RunFileDlg(HWND hwndParent, HICON hIcon, LPCTSTR pszWorkingDir, LPCTSTR pszTitle,
        LPCTSTR pszPrompt, DWORD dwFlags);

    LONG            m_cRef;

    HWND            m_hDlg;

    // parameters
    HICON           m_hIcon;
    LPCTSTR         m_pszWorkingDir;
    LPCTSTR         m_pszTitle;
    LPCTSTR         m_pszPrompt;
    DWORD           m_dwFlags;
    HANDLE          m_hEventReady;
    DWORD           m_dwThreadId;

    BOOL            _fDone : 1;
    BOOL            _fAutoCompInitialized : 1;
    BOOL            _fOleInited : 1;
};


// optimistic cache for this
HANDLE g_hMRURunDlg = NULL;

HANDLE OpenRunDlgMRU()
{
    HANDLE hmru = InterlockedExchangePointer(&g_hMRURunDlg, NULL);
    if (hmru == NULL)
    {
        MRUINFO mi =  {
            sizeof(MRUINFO),
            26,
            MRU_CACHEWRITE,
            HKEY_CURRENT_USER,
            c_szRunMRU,
            NULL        // NOTE: use default string compare
                        // since this is a GLOBAL MRU
        } ;
        hmru = CreateMRUList(&mi);
    }
    return hmru;
}

void CloseRunDlgMRU(HANDLE hmru)
{
    hmru = InterlockedExchangePointer(&g_hMRURunDlg, hmru);
    if (hmru)
        FreeMRUList(hmru);  // race, destroy copy
}

STDAPI_(void) FlushRunDlgMRU(void)
{
    CloseRunDlgMRU(NULL);
}

HRESULT CRunDlg_CreateInstance(IUnknown *punkOuter, REFIID riid, void **ppv)
{
    if (punkOuter)
        return E_FAIL;

    *ppv = NULL;
    CRunDlg * p = new CRunDlg();
    if (p) 
    {
    	*ppv = SAFECAST(p, IDropTarget *);
	    return S_OK;
    }

    return E_OUTOFMEMORY;
}

CRunDlg::CRunDlg() : m_cRef(1)
{
    // This needs to be allocated in Zero Inited Memory.
    // ASSERT that all Member Variables are inited to Zero.
    ASSERT(!m_hDlg);
    ASSERT(!m_hIcon);
    ASSERT(!m_pszWorkingDir);
    ASSERT(!m_pszTitle);
    ASSERT(!m_pszPrompt);
    ASSERT(!m_dwFlags);
    ASSERT(!m_hEventReady);
    ASSERT(!_fDone);
    ASSERT(!m_dwThreadId);
}

CRunDlg::~CRunDlg()
{
}

// IUnknown
HRESULT CRunDlg::QueryInterface(REFIID riid, void **ppv)
{
    static const QITAB qit[] = 
    {
        QITABENT(CRunDlg, IDropTarget),
        { 0 },
    };
    return QISearch(this, qit, riid, ppv);
}

ULONG CRunDlg::AddRef()
{
    return InterlockedIncrement(&m_cRef);
}

ULONG CRunDlg::Release()
{
    if (InterlockedDecrement(&m_cRef))
        return m_cRef;

    delete this;
    return 0;
}

// IDropTarget

STDMETHODIMP CRunDlg::DragEnter(IDataObject *pdtobj, DWORD grfKeyState, POINTL ptl, DWORD *pdwEffect)
{
    DAD_DragEnterEx3(m_hDlg, ptl, pdtobj);
    *pdwEffect &= DROPEFFECT_LINK | DROPEFFECT_COPY;
    return S_OK;
}

STDMETHODIMP CRunDlg::DragOver(DWORD grfKeyState, POINTL ptl, DWORD *pdwEffect)
{
    DAD_DragMoveEx(m_hDlg, ptl);
    *pdwEffect &= DROPEFFECT_LINK | DROPEFFECT_COPY;
    return S_OK;
}

STDMETHODIMP CRunDlg::DragLeave(void)
{
    DAD_DragLeave();
    return S_OK;
}

typedef struct {
    HRESULT (*pfnGetData)(STGMEDIUM *, LPTSTR pszFile);
    FORMATETC fmte;
} DATA_HANDLER;

HRESULT _GetHDROPFromData(STGMEDIUM *pmedium, LPTSTR pszPath)
{
    return DragQueryFile((HDROP)pmedium->hGlobal, 0, pszPath, MAX_PATH) ? S_OK : E_FAIL;
}

HRESULT _GetText(STGMEDIUM *pmedium, LPTSTR pszPath)
{
    LPCSTR psz = (LPCSTR)GlobalLock(pmedium->hGlobal);
    if (psz)
    {
        SHAnsiToTChar(psz, pszPath, MAX_PATH);
        GlobalUnlock(pmedium->hGlobal);
        return S_OK;
    }
    return E_FAIL;
}

HRESULT _GetUnicodeText(STGMEDIUM *pmedium, LPTSTR pszPath)
{
    LPCWSTR pwsz = (LPCWSTR)GlobalLock(pmedium->hGlobal);
    if (pwsz)
    {
        SHUnicodeToTChar(pwsz, pszPath, MAX_PATH);
        GlobalUnlock(pmedium->hGlobal);
        return S_OK;
    }
    return E_FAIL;
}

STDMETHODIMP CRunDlg::Drop(IDataObject * pdtobj, DWORD grfKeyState, 
                           POINTL pt, DWORD *pdwEffect)
{
    TCHAR szPath[MAX_PATH];

    DAD_DragLeave();

    szPath[0] = 0;

    DATA_HANDLER rg_data_handlers[] = {
        _GetHDROPFromData,  {CF_HDROP, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL},
        _GetUnicodeText,    {CF_UNICODETEXT, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL},
        _GetText,           {g_cfShellURL, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL},
        _GetText,           {CF_TEXT, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL},
    };

    IEnumFORMATETC *penum;

    if (SUCCEEDED(pdtobj->EnumFormatEtc(DATADIR_GET, &penum)))
    {
        FORMATETC fmte;
        while (penum->Next(1, &fmte, NULL) == S_OK)
        {
            SHFree(fmte.ptd);
            fmte.ptd = NULL; // so nobody will look at it
            for (int i = 0; i < ARRAYSIZE(rg_data_handlers); i++)
            {
                STGMEDIUM medium;
                if ((rg_data_handlers[i].fmte.cfFormat == fmte.cfFormat) && 
                    SUCCEEDED(pdtobj->GetData(&rg_data_handlers[i].fmte, &medium)))
                {
                    HRESULT hres = rg_data_handlers[i].pfnGetData(&medium, szPath);
                    ReleaseStgMedium(&medium);

                    if (SUCCEEDED(hres))
                        goto Done;
                }
            }
        }
Done:
        penum->Release();
    }

    if (szPath[0])
    {
        TCHAR szText[MAX_PATH + MAX_PATH];

        GetDlgItemText(m_hDlg, IDD_COMMAND, szText, ARRAYSIZE(szText) - ARRAYSIZE(szPath));
        if (szText[0])
            lstrcat(szText, c_szSpace);

        if (StrChr(szPath, TEXT(' '))) 
            PathQuoteSpaces(szPath);    // there's a space in the file... add qutoes

        lstrcat(szText, szPath);

        SetDlgItemText(m_hDlg, IDD_COMMAND, szText);
        EnableOKButtonFromID(m_hDlg, IDD_COMMAND);

        if (g_hCheckNow)
            SetEvent(g_hCheckNow);

        *pdwEffect &= DROPEFFECT_COPY | DROPEFFECT_LINK;
    }
    else
        *pdwEffect = 0;

    return S_OK;
}


BOOL PromptForMedia(HWND hwnd, LPCTSTR pszPath)
{
    BOOL fContinue = TRUE;
    TCHAR szPathTemp[MAX_URL_STRING];
    
    StrCpyN(szPathTemp, pszPath, ARRAYSIZE(szPathTemp));
    PathRemoveArgs(szPathTemp);
    PathUnquoteSpaces(szPathTemp);

    // We only want to check for media if it's a drive path
    // because the Start->Run dialog can receive all kinds of
    // wacky stuff. (Relative paths, URLs, App Path exes, 
    // any shell exec hooks, etc.)
    if (-1 != PathGetDriveNumber(szPathTemp))
    {
        if (FAILED(SHPathPrepareForWrite(hwnd, NULL, szPathTemp, SHPPFW_IGNOREFILENAME)))
            fContinue = FALSE;      // User decliened to insert or format media.
    }

    return fContinue;
}

BOOL CRunDlg::OKPushed(void)
{
    TCHAR szText[MAX_PATH];
    BOOL fSuccess = FALSE;
    TCHAR szNotExp[MAX_PATH + 2];

    if (_fDone)
        return TRUE;

    // Get out of the "synchronized input queues" state
    if (m_dwThreadId)
    {
        AttachThreadInput(GetCurrentThreadId(), m_dwThreadId, FALSE);
    }

    // Get the command line and dialog title, leave some room for the slash on the end
    GetDlgItemText(m_hDlg, IDD_COMMAND, szNotExp, ARRAYSIZE(szNotExp) - 2);
    PathRemoveBlanks(szNotExp);

    // This used to happen only on NT, do it everywhere:
    SHExpandEnvironmentStrings(szNotExp, szText, ARRAYSIZE(szText));

    // We will go ahead if this isn't a file path.  If it is, we
    if (PromptForMedia(m_hDlg, szText))
    {
        TCHAR szTitle[64];
        GetWindowText(m_hDlg, szTitle, ARRAYSIZE(szTitle));

        // Hide this dialog (REVIEW, to avoid save bits window flash)
        SetWindowPos(m_hDlg, 0, 0, 0, 0, 0, SWP_HIDEWINDOW|SWP_NOACTIVATE|SWP_NOMOVE|SWP_NOSIZE|SWP_NOZORDER);

        //
        // HACK: We need to activate the owner window before we call
        //  ShellexecCmdLine, so that our folder DDE code can find an
        //  explorer window as the ForegroundWindow.
        //
        HWND hwndOwner = GetWindow(m_hDlg, GW_OWNER);
        if (hwndOwner)
        {
            SetActiveWindow(hwndOwner);
        }
        else
        {
            hwndOwner = m_hDlg;
        }

        int iRun = RunDlgNotifyParent(m_hDlg, hwndOwner, szText, m_pszWorkingDir);
        switch (iRun)
        {
        case RFR_NOTHANDLED:
            {
                DWORD dwFlags;
                if (m_dwFlags & RFD_USEFULLPATHDIR)
                {
                    dwFlags = SECL_USEFULLPATHDIR;
                }
                else
                {
                    dwFlags = 0;
                }

                if ((!(m_dwFlags & RFD_NOSEPMEMORY_BOX)) && (m_dwFlags & RFD_WOW_APP))
                {
                    if (IsDlgButtonChecked(m_hDlg, IDD_RUNINSEPARATE) == 1)
                    {
                        if (IsDlgButtonChecked(m_hDlg, IDD_RUNINSEPARATE ) == 1 )
                        {
                            dwFlags |= SECL_SEPARATE_VDM;
                        }
                    }
                }

                dwFlags |= SECL_LOG_USAGE;
                fSuccess = ShellExecCmdLine(hwndOwner, szText, m_pszWorkingDir, SW_SHOWNORMAL, szTitle, dwFlags);
            }
            break;

        case RFR_SUCCESS:
            fSuccess = TRUE;
            break;

        case RFR_FAILURE:
            fSuccess = FALSE;
            break;
        }
    }

    // Get back into "synchronized input queues" state
    if (m_dwThreadId)
    {
        AttachThreadInput(GetCurrentThreadId(), m_dwThreadId, TRUE);
    }

    if (fSuccess)
    {
        HANDLE hmru = OpenRunDlgMRU();
        if (hmru)
        {
            // NB the old MRU format has a slash and the show cmd on the end
            // we need to maintain that so we don't end up with garbage on
            // the end of the line
            StrCatBuff(szNotExp, TEXT("\\1"), ARRAYSIZE(szNotExp));
            AddMRUString(hmru, szNotExp);

            CloseRunDlgMRU(hmru);
        }
        return TRUE;
    }

    // Something went wrong. Put the dialog back up.
    SetWindowPos(m_hDlg, 0, 0, 0, 0, 0, SWP_SHOWWINDOW|SWP_NOMOVE|SWP_NOSIZE|SWP_NOZORDER);
    if (!SetForegroundWindow(m_hDlg))
    {
        // HACKHACK:
        // If ShellHook is working on, SetForegroundWindow() can failed to
        // bring RunDlg to foreground window. To force focus to RunDlg, wait
        // a second and retry SetForegroundWindow() again.
        SHWaitForSendMessageThread(GetCurrentThread(), 300);
        SetForegroundWindow(m_hDlg);
    }
    SetFocus(GetDlgItem(m_hDlg, IDD_COMMAND));
    return FALSE;
}


void CRunDlg::ExitRunDlg(BOOL bOK)
{
    if (!_fDone) 
    {
        if (_fOleInited)
        {
            // Need to call oleinit/uninit, because if anyone else does it down the line,
            // and theirs is the last OleUninit, that will NULL out the clipboard hwnd, which
            // is what RevokeDragDrop uses to determine if it is being called on the same
            // thread as RegisterDragDrop.  If the clipboard hwnd is NULL and therefore not
            // equal to the original, and it therefore thinks we're on a different thread,
            // it will bail, and thus won't release it's ref to CRunDlg ... leak!
            RevokeDragDrop(m_hDlg);
            OleUninitialize();
        }
        _fDone = TRUE;
    }

    if (!(m_dwFlags & RFD_NOSEPMEMORY_BOX))
    {
        g_bCheckRunInSep = FALSE;
        SetEvent(g_hCheckNow);
    }

    EndDialog(m_hDlg, bOK);
}


void CRunDlg::InitRunDlg(HWND hDlg)
{
    HWND hCB;

    SetWindowLongPtr(hDlg, DWLP_USER, (LONG_PTR)this);

    if (m_pszTitle)
        SetWindowText(hDlg, m_pszTitle);

    if (m_pszPrompt)
        SetDlgItemText(hDlg, IDD_PROMPT, m_pszPrompt);

    if (m_hIcon)
        Static_SetIcon(GetDlgItem(hDlg, IDD_ICON), m_hIcon);

    if (m_dwFlags & RFD_NOBROWSE)
    {
        HWND hBrowse = GetDlgItem(hDlg, IDD_BROWSE);

        ExchangeWindowPos(hBrowse, GetDlgItem(hDlg, IDCANCEL));
        ExchangeWindowPos(hBrowse, GetDlgItem(hDlg, IDOK));

        ShowWindow(hBrowse, SW_HIDE);
    }

    if (m_dwFlags & RFD_NOSHOWOPEN)
        ShowWindow(GetDlgItem(hDlg, IDD_RUNDLGOPENPROMPT), SW_HIDE);

    hCB = GetDlgItem(hDlg, IDD_COMMAND);
    SendMessage(hCB, CB_LIMITTEXT, MAX_PATH - 1, 0L);

    HANDLE hmru = OpenRunDlgMRU();
    if (hmru)
    {
        for (int nMax = EnumMRUList(hmru, -1, NULL, 0), i=0; i<nMax; ++i)
        {
            TCHAR szCommand[MAX_PATH + 2];
            if (EnumMRUList(hmru, i, szCommand, ARRAYSIZE(szCommand)) > 0)
            {
                // old MRU format has a slash at the end with the show cmd
                LPTSTR pszField = StrRChr(szCommand, NULL, TEXT('\\'));
                if (pszField)
                    *pszField = 0;

                // The command to run goes in the combobox.
                SendMessage(hCB, CB_ADDSTRING, 0, (LPARAM)(LPTSTR)szCommand);
            }
        }
        CloseRunDlgMRU(hmru);
    }

    if (!(m_dwFlags & RFD_NODEFFILE))
        SendMessage(hCB, CB_SETCURSEL, 0, 0L);

    SendMessage(hDlg, WM_COMMAND, MAKEWPARAM(IDD_COMMAND, CBN_SELCHANGE), (LPARAM) hCB);

    // Make sure the OK button is initialized properly
    EnableOKButtonFromID(hDlg, IDD_COMMAND);

    // Create the thread that will take care of the
    // "Run in Separate Memory Space" checkbox in the background.
    //
    if (m_dwFlags & RFD_NOSEPMEMORY_BOX)
    {
        ShowWindow(GetDlgItem(hDlg, IDD_RUNINSEPARATE), SW_HIDE);
    }
    else
    {
        HANDLE hThread = NULL;
        ASSERT(g_hCheckNow == NULL);
        g_hCheckNow = CreateEvent(NULL, TRUE, FALSE, NULL);
        if (g_hCheckNow) 
        {
            DWORD dwDummy;
            g_bCheckRunInSep = TRUE;
            hThread = CreateThread(NULL, 0, CheckRunInSeparateThreadProc, hDlg, 0, &dwDummy);
        }

        if ((g_hCheckNow==NULL) || (!g_bCheckRunInSep) || (hThread==NULL)) 
        {
            // We've encountered a problem setting up, so make the user
            // choose.
            CheckDlgButton(hDlg, IDD_RUNINSEPARATE, 1);
            EnableWindow(GetDlgItem(hDlg, IDD_RUNINSEPARATE), TRUE);
            g_bCheckRunInSep = FALSE;
        }

        //
        // These calls will just do nothing if either handle is NULL.
        //
        if (hThread)
            CloseHandle(hThread);
        if (g_hCheckNow)
            SetEvent(g_hCheckNow);
    }
}

//
// InitRunDlg 2nd phase. It must be called after freeing parent thread.
//
void CRunDlg::InitRunDlg2(HWND hDlg)
{
    // Register ourselves as a drop target. Allow people to drop on
    // both the dlg box and edit control.
    _fOleInited = SUCCEEDED(OleInitialize(NULL));

    if (_fOleInited)
    {
        RegisterDragDrop(hDlg, SAFECAST(this, IDropTarget*));
    }
}


void CRunDlg::BrowsePushed(void)
{
    HWND hDlg = m_hDlg;
    TCHAR szText[MAX_PATH];

    // Get out of the "synchronized input queues" state
    if (m_dwThreadId)
    {
        AttachThreadInput(GetCurrentThreadId(), m_dwThreadId, FALSE);
        m_dwThreadId = 0;
    }

    GetDlgItemText(hDlg, IDD_COMMAND, szText, ARRAYSIZE(szText));
    PathUnquoteSpaces(szText);

    if (GetFileNameFromBrowse(hDlg, szText, ARRAYSIZE(szText), m_pszWorkingDir,
            MAKEINTRESOURCE(IDS_EXE), MAKEINTRESOURCE(IDS_PROGRAMSFILTER),
            MAKEINTRESOURCE(IDS_BROWSE)))
    {
        PathQuoteSpaces(szText);
        SetDlgItemText(hDlg, IDD_COMMAND, szText);
        EnableOKButtonFromID(hDlg, IDD_COMMAND);
        SendMessage(hDlg, WM_NEXTDLGCTL, (WPARAM)GetDlgItem(hDlg, IDOK), TRUE);
    }
}


// Use the common browse dialog to get a filename.
// The working directory of the common dialog will be set to the directory
// part of the file path if it is more than just a filename.
// If the filepath consists of just a filename then the working directory
// will be used.
// The full path to the selected file will be returned in szFilePath.
//    HWND hDlg,           // Owner for browse dialog.
//    LPSTR szFilePath,    // Path to file
//    UINT cchFilePath,     // Max length of file path buffer.
//    LPSTR szWorkingDir,  // Working directory
//    LPSTR szDefExt,      // Default extension to use if the user doesn't
//                         // specify enter one.
//    LPSTR szFilters,     // Filter string.
//    LPSTR szTitle        // Title for dialog.

STDAPI_(BOOL) _GetFileNameFromBrowse(HWND hwnd, LPTSTR szFilePath, UINT cbFilePath,
                                       LPCTSTR szWorkingDir, LPCTSTR szDefExt, LPCTSTR szFilters, LPCTSTR szTitle,
                                       DWORD dwFlags)
{
    TCHAR szBrowserDir[MAX_PATH];      // Directory to start browsing from.
    TCHAR szFilterBuf[MAX_PATH];       // if szFilters is MAKEINTRESOURCE
    TCHAR szDefExtBuf[10];             // if szDefExt is MAKEINTRESOURCE
    TCHAR szTitleBuf[64];              // if szTitleBuf is MAKEINTRESOURCE

    szBrowserDir[0] = TEXT('0'); // By default use CWD.

    // Set up info for browser.
    lstrcpy(szBrowserDir, szFilePath);
    PathRemoveArgs(szBrowserDir);
    PathRemoveFileSpec(szBrowserDir);

    if (*szBrowserDir == TEXT('\0') && szWorkingDir)
    {
        lstrcpyn(szBrowserDir, szWorkingDir, ARRAYSIZE(szBrowserDir));
    }

    // Stomp on the file path so that the dialog doesn't
    // try to use it to initialise the dialog. The result is put
    // in here.
    szFilePath[0] = TEXT('\0');

    // Set up szDefExt
    if (IS_INTRESOURCE(szDefExt))
    {
        LoadString(HINST_THISDLL, (UINT)LOWORD((DWORD_PTR)szDefExt), szDefExtBuf, ARRAYSIZE(szDefExtBuf));
        szDefExt = szDefExtBuf;
    }

    // Set up szFilters
    if (IS_INTRESOURCE(szFilters))
    {
        LPTSTR psz;

        LoadString(HINST_THISDLL, (UINT)LOWORD((DWORD_PTR)szFilters), szFilterBuf, ARRAYSIZE(szFilterBuf));
        psz = szFilterBuf;
        while (*psz)
        {
            if (*psz == TEXT('#'))
#if (defined(DBCS) || (defined(FE_SB) && !defined(UNICODE)))
                *psz++ = TEXT('\0');
            else
                psz = CharNext(psz);
#else
            *psz = TEXT('\0');
            psz = CharNext(psz);
#endif
        }
        szFilters = szFilterBuf;
    }

    // Set up szTitle
    if (IS_INTRESOURCE(szTitle))
    {
        LoadString(HINST_THISDLL, (UINT)LOWORD((DWORD_PTR)szTitle), szTitleBuf, ARRAYSIZE(szTitleBuf));
        szTitle = szTitleBuf;
    }

    OPENFILENAME ofn = { 0 };          // Structure used to init dialog.
    // Setup info for comm dialog.
    ofn.lStructSize       = sizeof(ofn);
    ofn.hwndOwner         = hwnd;
    ofn.hInstance         = NULL;
    ofn.lpstrFilter       = szFilters;
    ofn.lpstrCustomFilter = NULL;
    ofn.nFilterIndex      = 1;
    ofn.nMaxCustFilter    = 0;
    ofn.lpstrFile         = szFilePath;
    ofn.nMaxFile          = cbFilePath;
    ofn.lpstrInitialDir   = szBrowserDir;
    ofn.lpstrTitle        = szTitle;
    ofn.Flags             = dwFlags;
    ofn.lpfnHook          = NULL;
    ofn.lpstrDefExt       = szDefExt;
    ofn.lpstrFileTitle    = NULL;

    // Call it.
    return GetOpenFileName(&ofn);
}


BOOL WINAPI GetFileNameFromBrowse(HWND hwnd, LPTSTR szFilePath, UINT cchFilePath,
        LPCTSTR szWorkingDir, LPCTSTR szDefExt, LPCTSTR szFilters, LPCTSTR szTitle)
{
    RIPMSG(szFilePath && IS_VALID_WRITE_BUFFER(szFilePath, TCHAR, cchFilePath), "GetFileNameFromBrowse: caller passed bad szFilePath");
    DEBUGWhackPathBuffer(szFilePath , cchFilePath);
    if (!szFilePath)
        return FALSE;

    return _GetFileNameFromBrowse(hwnd, szFilePath, cchFilePath,
                                 szWorkingDir, szDefExt, szFilters, szTitle,
                                 OFN_HIDEREADONLY | OFN_FILEMUSTEXIST | OFN_NOCHANGEDIR | OFN_NODEREFERENCELINKS);
}


//
// Do checking of the .exe type in the background so the UI doesn't
// get hung up while we scan.  This is particularly important with
// the .exe is over the network or on a floppy.
//
DWORD CALLBACK CheckRunInSeparateThreadProc(void *pv)
{
    DWORD dwBinaryType;
    DWORD cch;
    LPTSTR pszFilePart;
    TCHAR szFile[MAX_PATH+1];
    TCHAR szFullFile[MAX_PATH+1];
    TCHAR szExp[MAX_PATH+1];
    HWND hDlg = (HWND)pv;
    BOOL fCheck = TRUE, fEnable = FALSE;

    HRESULT hrInit = SHCoInitialize();

    // PERF: Re-write to use PIDL from CShellUrl because it will prevent from having
    //         to do the Search for the file name a second time.

    DebugMsg(DM_TRACE, TEXT("CheckRunInSeparateThreadProc created and running"));

    while (g_bCheckRunInSep)
    {
        WaitForSingleObject(g_hCheckNow, INFINITE);
        ResetEvent(g_hCheckNow);

        if (g_bCheckRunInSep)
        {
            CRunDlg * prd;
            LPTSTR pszT;
            BOOL f16bit = FALSE;

            szFile[0] = 0;
            szFullFile[0] = 0;
            cch = 0;
            GetWindowText(GetDlgItem(hDlg, IDD_COMMAND), szFile, ARRAYSIZE(szFile));
            // Remove & throw away arguments
            PathRemoveBlanks(szFile);

            if (PathIsNetworkPath(szFile))
            {
                f16bit = TRUE;
                fCheck = FALSE;
                fEnable = TRUE;
                goto ChangeTheBox;
            }

            // if the unquoted string exists as a file, just use it

            if (!PathFileExistsAndAttributes(szFile, NULL))
            {
                pszT = PathGetArgs(szFile);
                if (*pszT)
                    *(pszT - 1) = TEXT('\0');

                PathUnquoteSpaces(szFile);
            }

            if (szFile[0])
            {
                SHExpandEnvironmentStrings(szFile, szExp, ARRAYSIZE(szExp));

                if (PathIsRemote(szExp))
                {
                    f16bit = TRUE;
                    fCheck = FALSE;
                    fEnable = TRUE;
                    goto ChangeTheBox;
                }

                cch = SearchPath(NULL, szExp, TEXT(".EXE"),
                                 ARRAYSIZE(szExp), szFullFile, &pszFilePart);
            }

            if ((cch != 0) && (cch <= (ARRAYSIZE(szFullFile) - 1)))
            {
                if ((GetBinaryType(szFullFile, &dwBinaryType) &&
                     (dwBinaryType == SCS_WOW_BINARY)))
                {
                    f16bit = TRUE;
                    fCheck = FALSE;
                    fEnable = TRUE;
                } 
                else 
                {
                    f16bit = FALSE;
                    fCheck = TRUE;
                    fEnable = FALSE;
                }
            } 
            else 
            {
                f16bit = FALSE;
                fCheck = TRUE;
                fEnable = FALSE;
            }

ChangeTheBox:
            CheckDlgButton(hDlg, IDD_RUNINSEPARATE, fCheck ? 1 : 0);
            EnableWindow(GetDlgItem(hDlg, IDD_RUNINSEPARATE), fEnable);

            prd = (CRunDlg *)GetWindowLongPtr(hDlg, DWLP_USER);
            if (prd)
            {
                if (f16bit)
                    prd->m_dwFlags |= RFD_WOW_APP;
                else
                    prd->m_dwFlags &= (~RFD_WOW_APP);
            }
        }
    }
    CloseHandle(g_hCheckNow);
    g_hCheckNow = NULL;

    SHCoUninitialize(hrInit);
    return 0;
}


void ExchangeWindowPos(HWND hwnd0, HWND hwnd1)
{
    HWND hParent;
    RECT rc[2];

    hParent = GetParent(hwnd0);
    ASSERT(hParent == GetParent(hwnd1));

    GetWindowRect(hwnd0, &rc[0]);
    GetWindowRect(hwnd1, &rc[1]);

    MapWindowPoints(HWND_DESKTOP, hParent, (LPPOINT)rc, 4);

    SetWindowPos(hwnd0, NULL, rc[1].left, rc[1].top, 0, 0,
            SWP_NOZORDER|SWP_NOSIZE);
    SetWindowPos(hwnd1, NULL, rc[0].left, rc[0].top, 0, 0,
            SWP_NOZORDER|SWP_NOSIZE);
}

BOOL RunDlgNotifyParent(HWND hDlg, HWND hwnd, LPTSTR pszCmd, LPCTSTR pszWorkingDir)
{
    NMRUNFILE rfn;

    rfn.hdr.hwndFrom = hDlg;
    rfn.hdr.idFrom = 0;
    rfn.hdr.code = RFN_EXECUTE;
    rfn.lpszCmd = pszCmd;
    rfn.lpszWorkingDir = pszWorkingDir;
    rfn.nShowCmd = SW_SHOWNORMAL;

    return (BOOL) SendMessage(hwnd, WM_NOTIFY, 0, (LPARAM)&rfn);
}

void MRUSelChange(HWND hDlg)
{
    TCHAR szCmd[MAX_PATH];
    HWND hCB = GetDlgItem(hDlg, IDD_COMMAND);
    int nItem = (int)SendMessage(hCB, CB_GETCURSEL, 0, 0L);
    if (nItem < 0)
        return;

    // CB_LIMITTEXT has been done, so there's no chance of buffer overrun here.
    SendMessage(hCB, CB_GETLBTEXT, nItem, (LPARAM)szCmd);

    // We can't use EnableOKButtonFromID here because when we get this message,
    // the window does not have the text yet, so it will fail.
    EnableOKButtonFromString(hDlg, szCmd);
}

const DWORD aRunHelpIds[] = {
    IDD_ICON,             NO_HELP,
    IDD_PROMPT,           NO_HELP,
    IDD_RUNDLGOPENPROMPT, IDH_TRAY_RUN_COMMAND,
    IDD_COMMAND,          IDH_TRAY_RUN_COMMAND,
    IDD_RUNINSEPARATE,    IDH_TRAY_RUN_SEPMEM,
    IDD_BROWSE,           IDH_BROWSE,
    IDOK,                 IDH_TRAY_RUN_OK,
    IDCANCEL,             IDH_TRAY_RUN_CANCEL,
    0, 0
};

BOOL_PTR CALLBACK RunDlgProc(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    CRunDlg * prd = (CRunDlg *)GetWindowLongPtr(hDlg, DWLP_USER);

    switch (uMsg)
    {
    case WM_INITDIALOG:
        /* The title will be in the lParam. */
        prd = (CRunDlg *)lParam;
        prd->m_hDlg = hDlg;
        prd->_fDone = FALSE;
        prd->InitRunDlg(hDlg);
        // Let the parent thread run on if it was waiting for us to
        // grab type-ahead.
        if (prd->m_hEventReady)
        {
            // We need to grab the activation so we can process input.
            // DebugMsg(DM_TRACE, "s.rdp: Getting activation.");
            SetForegroundWindow(hDlg);
            SetFocus(GetDlgItem(hDlg, IDD_COMMAND));
            // Now it's safe to wake the guy up properly.
            // DebugMsg(DM_TRACE, "s.rdp: Waking sleeping parent.");
            SetEvent(prd->m_hEventReady);
            CloseHandle(prd->m_hEventReady);
        }       
        else
        {
            SetForegroundWindow(hDlg);
            SetFocus(GetDlgItem(hDlg, IDD_COMMAND));
        }

        // InitRunDlg 2nd phase (must be called after SetEvent)
        prd->InitRunDlg2(hDlg);

        // We're handling focus changes.
        return FALSE;

    case WM_PAINT:
        if (!prd->_fAutoCompInitialized)
        {
            prd->_fAutoCompInitialized = TRUE;
            PostMessage(hDlg, WM_SETUPAUTOCOMPLETE, 0, 0);
        }
        return FALSE;

    case WM_SETUPAUTOCOMPLETE:
        SHAutoComplete(GetWindow(GetDlgItem(hDlg, IDD_COMMAND), GW_CHILD), (SHACF_FILESYSTEM | SHACF_URLALL | SHACF_FILESYS_ONLY));
        break;

    case WM_HELP:
        WinHelp((HWND) ((LPHELPINFO) lParam)->hItemHandle, NULL, HELP_WM_HELP,
            (ULONG_PTR) (LPTSTR) aRunHelpIds);
        break;

    case WM_CONTEXTMENU:      // right mouse click
        WinHelp((HWND) wParam, NULL, HELP_CONTEXTMENU,
            (ULONG_PTR) (LPTSTR) aRunHelpIds);
        break;

    case WM_DESTROY:
        break;
    case WM_COMMAND:
            switch (GET_WM_COMMAND_ID(wParam, lParam))
            {
            case IDHELP:
                break;

            case IDD_COMMAND:
                switch (GET_WM_COMMAND_CMD(wParam, lParam))
                {
                case CBN_SELCHANGE:
                    MRUSelChange(hDlg);
                    if (g_hCheckNow)
                        SetEvent(g_hCheckNow);
                    break;

                case CBN_EDITCHANGE:
                case CBN_SELENDOK:
                    EnableOKButtonFromID(hDlg, IDD_COMMAND);
                    if (g_hCheckNow)
                        SetEvent(g_hCheckNow);
                    break;

                case CBN_SETFOCUS:

                    SetModeBias(MODEBIASMODE_FILENAME);
                    break;

                case CBN_KILLFOCUS:

                    SetModeBias(MODEBIASMODE_DEFAULT);
                    break;

                }
                break;

            case IDOK:
            // fake an ENTER key press so AutoComplete can do it's thing
            if (SendMessage(GetDlgItem(hDlg, IDD_COMMAND), WM_KEYDOWN, VK_RETURN, 0x1c0001))
            {
                if (!prd->OKPushed()) 
                {
                    if (!(prd->m_dwFlags & RFD_NOSEPMEMORY_BOX))
                    {
                        g_bCheckRunInSep = FALSE;
                        SetEvent(g_hCheckNow);
                    }
                    break;
                }
            }
            else
            {
                break;  // AutoComplete wants more user input
            }
            // fall through

            case IDCANCEL:
                prd->ExitRunDlg(FALSE);
                break;

            case IDD_BROWSE:
                prd->BrowsePushed();
                SetEvent(g_hCheckNow);
                break;

            default:
                return FALSE;
            }
            break;

    default:
        return FALSE;
    }
    return TRUE;
}

// Puts up the standard file.run dialog.
// REVIEW UNDONE This should use a RUNDLG structure for all the various
// options instead of just passing them as parameters, a ptr to the struct
// would be passed to the dialog via the lParam.

STDAPI_(int) RunFileDlg(HWND hwndParent, HICON hIcon, 
                        LPCTSTR pszWorkingDir, LPCTSTR pszTitle,
                        LPCTSTR pszPrompt, DWORD dwFlags)
{
    int rc = 0;

    HRESULT hrInit = SHCoInitialize();

    IDropTarget *pdt;
    if (SUCCEEDED(CRunDlg_CreateInstance(NULL, IID_PPV_ARG(IDropTarget, &pdt))))
    {
        CRunDlg * prd = (CRunDlg *) pdt;

        prd->m_hIcon = hIcon;
        prd->m_pszWorkingDir = pszWorkingDir;
        prd->m_pszTitle = pszTitle;
        prd->m_pszPrompt = pszPrompt;
        prd->m_dwFlags = dwFlags;

        if (SHRestricted(REST_RUNDLGMEMCHECKBOX))
            ClearFlag(prd->m_dwFlags, RFD_NOSEPMEMORY_BOX);
        else
            SetFlag(prd->m_dwFlags, RFD_NOSEPMEMORY_BOX);

        // prd->m_hEventReady = 0;
        // prd->m_dwThreadId = 0;

        // We do this so we can get type-ahead when we're running on a
        // separate thread. The parent thread needs to block to give us time
        // to do the attach and then get some messages out of the queue hence
        // the event.
        if (hwndParent)
        {
            // HACK The parent signals it's waiting for the dialog to grab type-ahead
            // by sticking it's threadId in a property on the parent.
            prd->m_dwThreadId = PtrToUlong(GetProp(hwndParent, c_szWaitingThreadID));
            if (prd->m_dwThreadId)
            {
                // DebugMsg(DM_TRACE, "s.rfd: Attaching input to %x.", idThread);
                AttachThreadInput(GetCurrentThreadId(), prd->m_dwThreadId, TRUE);
                // NB Hack.
                prd->m_hEventReady = OpenEvent(EVENT_ALL_ACCESS, TRUE, c_szRunDlgReady);
            }
        }

        rc = (int)DialogBoxParam(HINST_THISDLL, MAKEINTRESOURCE(DLG_RUN), hwndParent,
                            RunDlgProc, (LPARAM)prd);

        if (hwndParent && prd->m_dwThreadId)
        {
            AttachThreadInput(GetCurrentThreadId(), prd->m_dwThreadId, FALSE);
        }

        pdt->Release();
    }

    SHCoUninitialize(hrInit);

    return rc;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\scnotify.cpp ===
#include "shellprv.h"
#pragma  hdrstop

#include <initguid.h>

#include <dbt.h>
#include "printer.h"
#include <dpa.h>
#include "idltree.h"
#include "scnotifyp.h"
#include "mtpt.h"

#include "shitemid.h"

#include <ioevent.h>

#define TF_SHELLCHANGENOTIFY        0x40000

#define SCNM_REGISTERCLIENT         WM_USER + 1
#define SCNM_DEREGISTERCLIENT       WM_USER + 2
#define SCNM_NOTIFYEVENT            WM_USER + 3
#define SCNM_FLUSHEVENTS            WM_USER + 4
#define SCNM_TERMINATE              WM_USER + 5
#define SCNM_SUSPENDRESUME          WM_USER + 6
#define SCNM_DEREGISTERWINDOW       WM_USER + 7
#define SCNM_AUTOPLAYDRIVE          WM_USER + 8

enum
{
    FLUSH_OVERFLOW = 1,
    FLUSH_SOFT,
    FLUSH_HARD,
    FLUSH_INTERRUPT,
};

#define IDT_SCN_FLUSHEVENTS     1
#define IDT_SCN_FRESHENTREES    2

#define EVENT_OVERFLOW          10

HWND g_hwndSCN = NULL;
CChangeNotify *g_pscn = NULL;
EXTERN_C CRITICAL_SECTION g_csSCN;
CRITICAL_SECTION g_csSCN = {0};

#define PERFTEST(x)

EXTERN_C void SFP_FSEvent        (LONG lEvent, LPCITEMIDLIST pidl, LPCITEMIDLIST pidlExtra);
EXTERN_C int WINAPI RLFSChanged (LONG lEvent, LPITEMIDLIST pidl, LPITEMIDLIST pidlExtra);
STDAPI CFSFolder_IconEvent(LONG lEvent, LPCITEMIDLIST pidl, LPCITEMIDLIST pidlExtra);
STDAPI_(HWND) _SCNGetWindow(BOOL fUseDesktop, BOOL fNeedsFallback);

STDAPI SHChangeNotifyAutoplayDrive(PCWSTR pszDrive)
{
    ASSERT(PathIsRoot(pszDrive));
    HWND hwnd = _SCNGetWindow(TRUE, FALSE);
    if (hwnd)
    {
        DWORD dwProcessID = 0;
        GetWindowThreadProcessId(hwnd, &dwProcessID);
        if (dwProcessID)
        {
            AllowSetForegroundWindow(dwProcessID);
        }
        PostMessage(g_hwndSCN, SCNM_AUTOPLAYDRIVE, DRIVEID(pszDrive), 0);
        return S_OK;
    }
    return E_FAIL;
}

//
//  special folders that are aliases.  these are always running
//  csidlAlias refers to the users perceived namespace
//  csidlReal refers to the actual filesystem folder behind the alias
//
typedef struct ALIASFOLDER {
    int     csidlAlias;
    int     csidlReal;
} ALIASFOLDER, *PALIASFOLDER;

static const ALIASFOLDER s_rgaf[] = {
  {CSIDL_DESKTOP, CSIDL_DESKTOPDIRECTORY},
  {CSIDL_DESKTOP, CSIDL_COMMON_DESKTOPDIRECTORY },
  {CSIDL_PERSONAL, CSIDL_PERSONAL | CSIDL_FLAG_NO_ALIAS},
  {CSIDL_NETWORK, CSIDL_NETHOOD},
  {CSIDL_PRINTERS, CSIDL_PRINTHOOD},
};

void InitAliasFolderTable(void)
{
    for (int i = 0; i < ARRAYSIZE(s_rgaf); i++)
    {
        g_pscn->AddSpecialAlias(s_rgaf[i].csidlReal, s_rgaf[i].csidlAlias);
    }
}

#pragma pack(1)
typedef struct {
    WORD cb;
    LONG lEEvent;
} ALIASREGISTER;

typedef struct {
    ALIASREGISTER ar;
    WORD wNull;
} ALIASREGISTERLIST;
#pragma pack()

STDAPI_(void) SHChangeNotifyRegisterAlias(LPCITEMIDLIST pidlReal, LPCITEMIDLIST pidlAlias)
{
    static const ALIASREGISTERLIST arl = { {sizeof(ALIASREGISTER), SHCNEE_ALIASINUSE}, 0};
    LPITEMIDLIST pidlRegister = ILCombine((LPCITEMIDLIST)&arl, pidlReal);

    if (pidlRegister)
    {
        SHChangeNotify(SHCNE_EXTENDED_EVENT, SHCNF_ONLYNOTIFYINTERNALS | SHCNF_IDLIST, pidlRegister, pidlAlias);
        ILFree(pidlRegister);
    }
}

LPCITEMIDLIST IsAliasRegisterPidl(LPCITEMIDLIST pidl)
{
    ALIASREGISTER *par = (ALIASREGISTER *)pidl;

    if (par->cb == sizeof(ALIASREGISTER)
    && par->lEEvent == SHCNEE_ALIASINUSE)
        return _ILNext(pidl);
    return NULL;
}

LONG g_cAliases = 0;

LPITEMIDLIST TranslateAlias(LPCITEMIDLIST pidl, LPCITEMIDLIST pidlReal, LPCITEMIDLIST pidlAlias)
{
    //  see if its child of one of our watched items
    
    LPCITEMIDLIST pidlChild = pidl ? ILFindChild(pidlReal, pidl) : NULL;
    if (pidlChild)
    {
        return ILCombine(pidlAlias, pidlChild);
    }
    return NULL;
}

CAnyAlias::~CAnyAlias()
{
    ILFree(_pidlAlias);

    ATOMICRELEASE(_ptscn);
}

BOOL CCollapsingClient::Init(LPCITEMIDLIST pidl, BOOL fRecursive)
{
    _pidl = ILClone(pidl);
    _fRecursive = fRecursive;
    return (_pidl && _dpaPendingEvents.Create(EVENT_OVERFLOW + 1));
}

BOOL CAnyAlias::Init(LPCITEMIDLIST pidlReal, LPCITEMIDLIST pidlAlias)
{
    ASSERT(!_fSpecial);
    _pidlAlias = ILClone(pidlAlias);

    return (_pidlAlias && CCollapsingClient::Init(pidlReal, TRUE));
}

BOOL CAnyAlias::_WantsEvent(LONG lEvent)
{
    return (lEvent & (SHCNE_DISKEVENTS | SHCNE_DRIVEREMOVED | SHCNE_NETSHARE | SHCNE_NETUNSHARE));
}

BOOL CAnyAlias::InitSpecial(int csidlReal, int csidlAlias)
{
    _fSpecial = TRUE;
    _csidlReal = csidlReal;
    _csidlAlias = csidlAlias;

    LPITEMIDLIST pidlNew;

    WIN32_FIND_DATA fd = {0};

    fd.dwFileAttributes = FILE_ATTRIBUTE_DIRECTORY; // Special folders are always directories
    SHGetSpecialFolderPath(NULL, fd.cFileName, csidlReal | CSIDL_FLAG_DONT_VERIFY, FALSE);
    SHSimpleIDListFromFindData(fd.cFileName, &fd, &pidlNew);

    SHGetSpecialFolderLocation(NULL, csidlAlias | CSIDL_FLAG_DONT_VERIFY, &_pidlAlias);

    BOOL fRet = _pidlAlias && CCollapsingClient::Init(pidlNew, TRUE);
    ILFree(pidlNew);
    return fRet;
}

BOOL CAnyAlias::IsAlias(LPCITEMIDLIST pidlReal, LPCITEMIDLIST pidlAlias)
{
    // if this hits, an alias has been registered already
    // this means the guy doing the registration isn't doing it at the junction point like
    // theyre supposed to
    ASSERT((ILIsEqual(pidlReal, _pidl) && ILIsEqual(pidlAlias, _pidlAlias)) ||
           !(ILIsParent(_pidl, pidlReal, FALSE) && ILIsParent(_pidlAlias, pidlAlias, FALSE)));

    return (ILIsEqual(pidlReal, _pidl)
         && ILIsEqual(pidlAlias, _pidlAlias));
}

BOOL CAnyAlias::IsSpecial(int csidlReal, int csidlAlias)
{
    return (_fSpecial && csidlReal == _csidlReal && csidlAlias == _csidlAlias);
}

CAnyAlias::_CustomTranslate()
{
    if (!_fCheckedCustom)
    {
        SHBindToObjectEx(NULL, _pidlAlias, NULL, IID_PPV_ARG(ITranslateShellChangeNotify, &_ptscn));
        _fCheckedCustom = TRUE;
    }
    return  (_ptscn != NULL);
}

// some pidl translators may not translate the event.  if we pass on a notifyevent thats identical,
// we'll get into an infinite loop.  our translators are good about this so this doesnt happen, but
// we'll catch it here to be more robust -- we wouldnt want a bad translating shell extension to
// be able to spinlock the changenotify thread.
BOOL CAnyAlias::_OkayToNotifyTranslatedEvent(CNotifyEvent *pne, LONG lEvent, LPCITEMIDLIST pidl, LPCITEMIDLIST pidlExtra)
{
    //  mydocs has an issue where it can be removed from the desktop when 
    //  it is redirected, because the alias only propagates the first
    //  half of the notification (remove). so we dont Translate the remove.
    if (_fSpecial && _csidlAlias == CSIDL_PERSONAL)
    {
        if (pne->lEvent == SHCNE_RENAMEFOLDER || pne->lEvent == SHCNE_RMDIR)
        {
            if (ILIsEqual(pidl, _pidlAlias))
                return FALSE;
        }
    }
    
    // if the original event wasn't already translated, let it proceed.

    // if its a different event, its fine -- a translator could flip-flop between events but we cant detect that case.

    // in addition we need to beware of aliases that translate to themselves or their children --
    // for example a my computer shortcut in the start menu will be registered recursively, so if you try
    // to delete it it will get into a loop.
    // so if the events are the same, verify that both the resultant pidls aren't underneath _pidl.

    return !(pne->uEventFlags & SHCNF_TRANSLATEDALIAS) ||
           (lEvent != pne->lEvent) ||
           !(pidl && ILIsParent(_pidl, pidl, FALSE)) && !(pidlExtra && ILIsParent(_pidl, pidlExtra, FALSE));
}

void CAnyAlias::_SendNotification(CNotifyEvent *pne, BOOL fNeedsCallbackEvent, SENDASYNCPROC pfncb)
{
    //
    //  see if its child of one of our watched items
    
    if (_CustomTranslate())
    {
        LPITEMIDLIST pidl1Alias = pne->pidl;
        LPITEMIDLIST pidl1AliasExtra = pne->pidlExtra;
        LPITEMIDLIST pidl2Alias = NULL, pidl2AliasExtra = NULL;
        LONG lEvent1 = pne->lEvent & ~SHCNE_INTERRUPT;  // translator shouldn't see this flag
        LONG lEvent2 = -1;
        if (SUCCEEDED(_ptscn->TranslateIDs(&lEvent1, pne->pidl, pne->pidlExtra, &pidl1Alias, &pidl1AliasExtra,
                                           &lEvent2, &pidl2Alias, &pidl2AliasExtra)))
        {
            if (_OkayToNotifyTranslatedEvent(pne, lEvent1, pidl1Alias, pidl1AliasExtra))
            {
                g_pscn->NotifyEvent(lEvent1, SHCNF_IDLIST | SHCNF_TRANSLATEDALIAS,
                    pidl1Alias, pidl1AliasExtra, 
                    pne->dwEventTime);
            }

            if ((lEvent2 != -1) && _OkayToNotifyTranslatedEvent(pne, lEvent2, pidl2Alias, pidl2AliasExtra))
            {
                g_pscn->NotifyEvent(lEvent2, SHCNF_IDLIST | SHCNF_TRANSLATEDALIAS,
                    pidl2Alias, pidl2AliasExtra,
                    pne->dwEventTime);
            }
            if (pidl1Alias != pne->pidl)
                ILFree(pidl1Alias);
            if (pidl1AliasExtra != pne->pidlExtra)
                ILFree(pidl1AliasExtra);
            ILFree(pidl2Alias);
            ILFree(pidl2AliasExtra);
        }
    }
    else
    {
        LPITEMIDLIST pidlAlias = TranslateAlias(pne->pidl, _pidl, _pidlAlias);
        LPITEMIDLIST pidlAliasExtra = TranslateAlias(pne->pidlExtra, _pidl, _pidlAlias);

        if (pidlAlias || pidlAliasExtra)
        {
            LPCITEMIDLIST pidlNotify = pidlAlias ? pidlAlias : pne->pidl;
            LPCITEMIDLIST pidlNotifyExtra = pidlAliasExtra ? pidlAliasExtra : pne->pidlExtra;
            if (_OkayToNotifyTranslatedEvent(pne, pne->lEvent, pidlNotify, pidlNotifyExtra))
            {
                g_pscn->NotifyEvent(pne->lEvent, SHCNF_IDLIST | SHCNF_TRANSLATEDALIAS,
                    pidlNotify, pidlNotifyExtra,
                    pne->dwEventTime);
            }

            //  do some special handling here
            //  like refresh folders or something will clean out an entry.
            switch (pne->lEvent)
            {
            case SHCNE_UPDATEDIR:
                if (!_fSpecial && ILIsEqual(pne->pidl, _pidl))
                {
                    //  this is target, and it will be refreshed.
                    //  if the alias is still around, then it will
                    //  have to reenum and re-register
                    //  there-fore we will clean this out now.
                    _fRemove = TRUE;
                }
                break;

            default:
                break;
            }
            ILFree(pidlAlias);
            ILFree(pidlAliasExtra);
        }
    }

    //  this is the notify we get when a drive mapping is deleted
    //  when this happens we need to kill the aliases to that drive
    if (pne->lEvent == SHCNE_DRIVEREMOVED)
    {
        if (!_fSpecial && ILIsEqual(pne->pidl, _pidlAlias))
        {
            //  when net drives are removed
            //  pidlExtra is the UNC 
            _fRemove = TRUE;
        }
    }
}

void CAnyAlias::Activate(BOOL fActivate)
{
    if (fActivate)
    {
        ASSERT(_cActivated >= 0);
        if (!_cActivated++)
        {
            // turn this puppy on!
            _fRemove = FALSE;
            if (!_fInterrupt)
                _fInterrupt = g_pscn->AddInterruptSource(_pidl, TRUE);
        }
    }
    else
    {
        ASSERT(_cActivated > 0);
        if (!--_cActivated)
        {
            // now turn it off
            _fRemove = TRUE;
            g_pscn->SetFlush(FLUSH_SOFT);
        }
    }
}
            
void CChangeNotify::_CheckAliasRollover(void)
{
    static DWORD s_tick = 0;
    DWORD tick = GetTickCount();

    if (tick < s_tick)
    {
        // we rolled the tick count over
        CLinkedWalk<CAnyAlias> lw(&_listAliases);
        
        while (lw.Step())
        {
            lw.That()->_dwTime = tick;
        }
    }

    s_tick = tick;
}

CAnyAlias *CChangeNotify::_FindSpecialAlias(int csidlReal, int csidlAlias)
{
    CLinkedWalk<CAnyAlias> lw(&_listAliases);
    
    while (lw.Step())
    {
        CAnyAlias *paa = lw.That();    
        if (paa->IsSpecial(csidlReal, csidlAlias))
        {
            //  we found it
            return paa;
        }
    }
    return NULL;
}

CAnyAlias *CChangeNotify::_FindAlias(LPCITEMIDLIST pidlReal, LPCITEMIDLIST pidlAlias)
{
    CLinkedWalk<CAnyAlias> lw(&_listAliases);
    
    while (lw.Step())
    {
        CAnyAlias *paa = lw.That();    
        if (paa->IsAlias(pidlReal, pidlAlias))
        {
            //  we found it
            return paa;
        }
    }
    return NULL;
}

void CChangeNotify::AddSpecialAlias(int csidlReal, int csidlAlias)
{
    CAnyAlias *paa = _FindSpecialAlias(csidlReal, csidlAlias);

    if (!paa)
    {
        CLinkedNode<CAnyAlias> *p = new CLinkedNode<CAnyAlias>;
        if (p)
        {
            if (p->that.InitSpecial(csidlReal, csidlAlias))
            {
                if (_InsertAlias(p))
                    paa = &p->that;
            }

            if (!paa)
                delete p;
        }
    }
}

void CChangeNotify::UpdateSpecialAlias(int csidlAlias)
{
    for (int i = 0; i < ARRAYSIZE(s_rgaf); i++)
    {
        if (csidlAlias == s_rgaf[i].csidlAlias)
        {
            CLinkedNode<CAnyAlias> *p = new CLinkedNode<CAnyAlias>;
            if (p)
            {
                if (!p->that.InitSpecial(s_rgaf[i].csidlReal, csidlAlias)
                || !_InsertAlias(p))
                {
                    delete p;
                }
            }
            break;
        }
    }
}

// the semantic of the return value of this function is not necessarily success or failure,
// since it's possible to stick something in _ptreeAliases with AddData and not be able to
// clean up and remove it with RemoveData (if CompareIDs fails along the way).
// reordering our inserts won't help since g_pscn->AddClient does the same thing.
// so,
// return TRUE == do not free p, something has ownership
// return FALSE == free p, we dont reference it anywhere
BOOL CChangeNotify::_InsertAlias(CLinkedNode<CAnyAlias> *p)
{
    BOOL fRet = _InitTree(&_ptreeAliases); 
    if (fRet)
    {
        fRet = _listAliases.Insert(p);
        if (fRet)
        {
            fRet = SUCCEEDED(_ptreeAliases->AddData(IDLDATAF_MATCH_RECURSIVE, p->that._pidlAlias, (INT_PTR)&p->that));
            if (fRet)
            {
                fRet = g_pscn->AddClient(IDLDATAF_MATCH_RECURSIVE, p->that._pidl, NULL, FALSE, SAFECAST(&p->that, CCollapsingClient *));
                if (fRet)
                {
                    if (_ptreeClients)
                    {
                        // now tell all the registered clients already waiting on this to wake up.
                        CLinkedWalk<CRegisteredClient> lw(&_listClients);

                        while (lw.Step())
                        {
                            if (ILIsParent(p->that._pidlAlias, lw.That()->_pidl, FALSE))
                            {
                                // increase activation count one time on this alias for each client that wants this one.
                                p->that.Activate(TRUE);
                            }
                        }
                    }
                }
                else
                {
                    // if we blow it, then we need to clean up.
                    // right now both the tree and _listAliases have p.
                    _listAliases.Remove(p); // the list always succeeds
                    if (FAILED(_ptreeAliases->RemoveData(p->that._pidlAlias, (INT_PTR)&p->that)))
                    {
                        // oh no!  we added it to the tree but we cant find it to remove it.
                        // return TRUE to prevent freeing it later.
                        fRet = TRUE;
                    }
                }
            }
            else
            {
                // we only have to remove from _listAliases.
                _listAliases.Remove(p); // the list always succeeds
            }
        }
    }
    
    return fRet;
}

void CChangeNotify::AddAlias(LPCITEMIDLIST pidlReal, LPCITEMIDLIST pidlAlias, DWORD dwEventTime)
{
    CAnyAlias *paa = _FindAlias(pidlReal, pidlAlias);

    if (!paa)
    {
        CLinkedNode<CAnyAlias> *p = new CLinkedNode<CAnyAlias>;
        if (p)
        {
            if (p->that.Init(pidlReal, pidlAlias))
            {
                if (_InsertAlias(p))
                {
                    paa = &p->that;
                    g_cAliases++;
                }
            }

            if (!paa)
                delete p;
        }
    }
    
    if (paa)
    {
        //  we just want to update the time on the existing entry
        paa->_dwTime = dwEventTime;
        paa->_fRemove = FALSE;
        _CheckAliasRollover();
    }
}        

BOOL CAnyAlias::Remove()
{
    if (_fRemove)
    {
        if (_fSpecial)
        {
            //  we dont remove the special aliases, 
            //  we only quiet them a little
            if (_fInterrupt)
            {
                g_pscn->ReleaseInterruptSource(_pidl);
                _fInterrupt = FALSE;
            }
            _fRemove = FALSE;
        }
        else
        {
            return SUCCEEDED(g_pscn->RemoveClient(_pidl, _fInterrupt, SAFECAST(this, CCollapsingClient *)));
        }
    }
    return FALSE;
}
   
void CChangeNotify::_FreshenAliases(void)
{
    CLinkedWalk<CAnyAlias> lw(&_listAliases);

    while (lw.Step())
    {
        CAnyAlias *paa = lw.That();
        if (paa->Remove())
        {
            if (SUCCEEDED(_ptreeAliases->RemoveData(paa->_pidlAlias, (INT_PTR)paa)))
            {
                // if RemoveData failed, we have to leak the client so the tree doesnt point to freed memory.
                lw.Delete();
            }
        }
    }
}
    
void AnyAlias_Change(LONG lEvent, LPCITEMIDLIST pidl, LPCITEMIDLIST pidlExtra, DWORD dwEventTime)
{
    if (lEvent == SHCNE_EXTENDED_EVENT)
    {
        LPCITEMIDLIST pidlAlias = IsAliasRegisterPidl(pidl);
        if (pidlAlias)
            g_pscn->AddAlias(pidlAlias, pidlExtra, dwEventTime);
        else 
        {
            SHChangeDWORDAsIDList *pdwidl = (SHChangeDWORDAsIDList *)pidl;
            if (pdwidl->dwItem1 == SHCNEE_UPDATEFOLDERLOCATION)
            {
                g_pscn->UpdateSpecialAlias(pdwidl->dwItem2);
            }
        }
    }
}

void NotifyShellInternals(LONG lEvent, UINT uFlags, LPCITEMIDLIST pidl, LPCITEMIDLIST pidlExtra, DWORD dwEventTime)
{
    //  if they are only interested in the real deal
    //  make sure we dont pass them the translated events
    //  this keeps them from getting multiple notifications 
    //  about the same paths, since the alias and the non-alias
    //  pidls will generally resolve to the same parsing name
    //  for the events/pidls that these guys are interested in
    if (!(SHCNF_TRANSLATEDALIAS & uFlags))
    {
        PERFTEST(RLFS_EVENT) RLFSChanged(lEvent, (LPITEMIDLIST)pidl, (LPITEMIDLIST)pidlExtra);
        PERFTEST(SFP_EVENT) SFP_FSEvent(lEvent, pidl,  pidlExtra);
        PERFTEST(ICON_EVENT) CFSFolder_IconEvent(lEvent, pidl,  pidlExtra);
    }
    //  aliases actually can be children of other aliases, so we need
    //  them to get the translated events
    PERFTEST(ALIAS_EVENT) AnyAlias_Change(lEvent, pidl, pidlExtra, dwEventTime);
}

BOOL IsMultiBitSet(LONG l)
{
    return (l && (l & (l-1)));
}

#define CHANGELOCK_SIG          0xbabebabe
#define CHANGEEVENT_SIG         0xfadefade
#define CHANGEREGISTER_SIG      0xdeafdeaf

#ifdef DEBUG

BOOL IsValidChangeEvent(CHANGEEVENT *pce)
{
    return (pce && (pce->dwSig == CHANGEEVENT_SIG)
        && (!IsMultiBitSet(pce->lEvent)));
}

BOOL _LockSizeMatchEvent(CHANGELOCK *pcl)
{
    UINT cbPidlMainAligned = (ILGetSize(pcl->pidlMain) + 3) & ~(0x0000003);       // Round up to dword size
    UINT cbPidlExtra = ILGetSize(pcl->pidlExtra);
    DWORD cbSize = sizeof(CHANGEEVENT) + cbPidlMainAligned + cbPidlExtra;
    return cbSize == pcl->pce->cbSize;
}

BOOL IsValidChangeLock(CHANGELOCK *pcl)
{
    return (pcl && IsValidChangeEvent(pcl->pce)
        && (pcl->dwSig == CHANGELOCK_SIG)
        && _LockSizeMatchEvent(pcl));
}

BOOL IsValidChangeEventHandle(HANDLE h, DWORD id)
{
    CHANGEEVENT *pce = (CHANGEEVENT *)SHLockSharedEx(h, id, FALSE);
#ifdef DEBUG
    BOOL fRet = TRUE; //  can fail in low memory so must default to TRUE
#endif // force DEBUG
    if (pce)
    {
        fRet = IsValidChangeEvent(pce);
        SHUnlockShared(pce);
    }

    return fRet;
}

#define ISVALIDCHANGEEVENTHANDLE(h, id)   IsValidChangeEventHandle(h, id)
#define ISVALIDCHANGEEVENT(p)   IsValidChangeEvent(p)
#define ISVALIDCHANGELOCK(p)    IsValidChangeLock(p)
#define ISVALIDCHANGEREGISTER(p)    TRUE
#endif 

ULONG SHChangeNotification_Destroy(HANDLE hChange, DWORD dwProcId)
{
    ASSERT(ISVALIDCHANGEEVENTHANDLE(hChange, dwProcId));
    TraceMsg(TF_SHELLCHANGENOTIFY, "CHANGEEVENT destroyed [0x%X]", hChange);

    return SHFreeShared(hChange, dwProcId);
}

HANDLE SHChangeNotification_Create(LONG lEvent, UINT uFlags, LPCITEMIDLIST pidlMain, LPCITEMIDLIST pidlExtra, DWORD dwProcId, DWORD dwEventTime)
{
    //  some bad callers send us multiple events
    RIP(!IsMultiBitSet(lEvent));
    if (!IsMultiBitSet(lEvent))
    {
        UINT cbPidlMain = ILGetSize(pidlMain);
        UINT cbPidlMainAligned = (cbPidlMain + 3) & ~(0x0000003);       // Round up to dword size
        UINT cbPidlExtra = ILGetSize(pidlExtra);
        DWORD cbSize = sizeof(CHANGEEVENT) + cbPidlMainAligned + cbPidlExtra;
        HANDLE h = SHAllocShared(NULL, cbSize, dwProcId);
        if (h)
        {
            CHANGEEVENT * pce = (CHANGEEVENT *) SHLockSharedEx(h, dwProcId, TRUE);
            if (pce)
            {
                BYTE *lpb = (LPBYTE)(pce + 1);
                
                pce->cbSize   = cbSize;
                pce->dwSig    = CHANGEEVENT_SIG;
                pce->lEvent   = lEvent;
                pce->uFlags   = uFlags;
                pce->dwEventTime = dwEventTime;

                if (pidlMain)
                {
                    pce->uidlMain = sizeof(CHANGEEVENT);
                    CopyMemory(lpb, pidlMain, cbPidlMain);
                    lpb += cbPidlMainAligned;
                }            

                if (pidlExtra)
                {
                    pce->uidlExtra = (UINT) (lpb - (LPBYTE)pce);
                    CopyMemory(lpb, pidlExtra, cbPidlExtra);
                }
                
                SHUnlockShared(pce);

                TraceMsg(TF_SHELLCHANGENOTIFY, "CHANGEEVENT created [0x%X]", h);
            }
            else
            {
                SHFreeShared(h, dwProcId);
                h = NULL;
            }
        }

        return h;
    }

    return NULL;
}

CHANGELOCK *_SHChangeNotification_Lock(HANDLE hChange, DWORD dwProcId)
{
    CHANGEEVENT *pce = (CHANGEEVENT *) SHLockSharedEx(hChange, dwProcId, FALSE);
    if (pce)
    {
#ifdef DEBUG
        if (!ISVALIDCHANGEEVENT(pce))
        {
            // during shell32 development it is convenient to use .local to use
            // a different version of shell32 than the os version.  but then
            // non-explorer processes use the old shell32 which might have
            // a different CHANGEEVENT structure causing this assert to fire
            // and us to fault shortly after.  do this hack check to see if
            // we are in this situation...
            //
            static int nExplorerIsLocalized = -1;
            if (nExplorerIsLocalized < 1)
            {
                TCHAR szPath[MAX_PATH];
                if (GetModuleFileName(HINST_THISDLL, szPath, ARRAYSIZE(szPath)))
                {
                    PathRemoveFileSpec(szPath);
                    PathCombine(szPath, szPath, TEXT("explorer.exe.local"));
                    if (PathFileExists(szPath))
                        nExplorerIsLocalized = 1;
                    else
                        nExplorerIsLocalized = 0;
                }
            }
            if (0==nExplorerIsLocalized)
            {
                // We should never send ourselves an invalid changeevent!
                ASSERT(ISVALIDCHANGEEVENT(pce));
            }
            else
            {
                // Except in this case.  Rip this out once hit -- I haven't been
                // able to repro this in a while...
                ASSERTMSG(ISVALIDCHANGEEVENT(pce), "Press 'g', if this doesn't fault you've validated a known .local bug fix for debug only that's hard to repro but a pain when it does.  Remove this assert.  Thanks.");
                return NULL;
            }

        }
#endif
        CHANGELOCK *pcl = (CHANGELOCK *)LocalAlloc(LPTR, sizeof(CHANGELOCK));
        if (pcl)
        {
            pcl->dwSig = CHANGELOCK_SIG;
            pcl->pce   = pce;
            
            if (pce->uidlMain)
                pcl->pidlMain  = _ILSkip(pce, pce->uidlMain);

            if (pce->uidlExtra)
                pcl->pidlExtra = _ILSkip(pce, pce->uidlExtra);

            return pcl;
        }
        else
            SHUnlockShared(pce);
    }

    return NULL;
}

HANDLE SHChangeNotification_Lock(HANDLE hChange, DWORD dwProcId, LPITEMIDLIST **pppidl, LONG *plEvent)
{
    CHANGELOCK *pcl = _SHChangeNotification_Lock(hChange, dwProcId);
    if (pcl)
    {
        //
        // Give back some easy values (causes less code to change for now)
        //
        if (pppidl)
            *pppidl = &(pcl->pidlMain);

        if (plEvent)
            *plEvent = pcl->pce->lEvent;
    }
    return (HANDLE) pcl;
}


BOOL SHChangeNotification_Unlock(HANDLE hLock)
{
    CHANGELOCK *pcl = (CHANGELOCK *)hLock;

    ASSERT(ISVALIDCHANGELOCK(pcl));

    BOOL fRet = SHUnlockShared(pcl->pce);
    LocalFree(pcl); 

    ASSERT(fRet);
    return fRet; 
}

STDMETHODIMP_(ULONG) CNotifyEvent::AddRef()
{
    return InterlockedIncrement(&_cRef);
}


STDMETHODIMP_(ULONG) CNotifyEvent::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;

    delete this;
    return 0;
}

BOOL CNotifyEvent::Init(LPCITEMIDLIST pidl, LPCITEMIDLIST pidlExtra)
{
    if (pidl)
        this->pidl = ILClone(pidl);

    if (pidlExtra)
        this->pidlExtra = ILClone(pidlExtra);

    return ((!pidl || this->pidl) && (!pidlExtra || this->pidlExtra));
}

CNotifyEvent *CNotifyEvent::Create(LONG lEvent, LPCITEMIDLIST pidl, LPCITEMIDLIST pidlExtra, DWORD dwEventTime, UINT uEventFlags)
{
    CNotifyEvent *p = new CNotifyEvent(lEvent, dwEventTime, uEventFlags);

    if (p)
    {
        if (!p->Init(pidl, pidlExtra))
        {
            //  we failed here
            p->Release();
            p = NULL;
        }
    }

    return p;
}

CCollapsingClient::CCollapsingClient()
{
}

CCollapsingClient::~CCollapsingClient()
{
    ILFree(_pidl);
    if (_dpaPendingEvents)
    {
        int iCount = _dpaPendingEvents.GetPtrCount();
        while (iCount--) 
        {
            CNotifyEvent *pne = _dpaPendingEvents.FastGetPtr(iCount);
            //  to parallel our UsingEvent() call
            pne->Release();
        }
        _dpaPendingEvents.Destroy();
    }
}

ULONG g_ulNextID = 1;
CRegisteredClient::CRegisteredClient()
{
    //
    // Skip ID 0, as this is our error value.
    //
    _ulID = g_ulNextID;
    if (!++g_ulNextID)
        g_ulNextID = 1;
}

CRegisteredClient::~CRegisteredClient()
{
    TraceMsg(TF_SHELLCHANGENOTIFY, "SCN::~CRegisteredClient() [0x%X] id = %d", this, _ulID);
}

BOOL CRegisteredClient::Init(HWND hwnd, int fSources, LONG fEvents, UINT wMsg, SHChangeNotifyEntry *pfsne)
{
    //  need one or the other
    ASSERT(fSources & (SHCNRF_InterruptLevel | SHCNRF_ShellLevel));
    
    _hwnd = hwnd;
    GetWindowThreadProcessId(hwnd, &_dwProcId);
    _fSources = fSources;
    _fInterrupt = fSources & SHCNRF_InterruptLevel;
    _fEvents = fEvents;
    _wMsg = wMsg;

    LPITEMIDLIST pidlNew;
    if (pfsne->pidl)
        pidlNew = ILClone(pfsne->pidl);
    else
        pidlNew = SHCloneSpecialIDList(NULL, CSIDL_DESKTOP, FALSE);

    BOOL fRet = CCollapsingClient::Init(pidlNew, pfsne->fRecursive);
    ILFree(pidlNew);
    return fRet;
}

BOOL CRegisteredClient::_WantsEvent(LONG lEvent)
{
    if (!_fDeadClient && (lEvent & _fEvents))
    {
        //
        //  if this event was generated by an interrupt, and the
        //  client has interrupt notification turned off, we dont want it
        //
        if (lEvent & SHCNE_INTERRUPT)
        {
            if (!(_fSources & SHCNRF_InterruptLevel))
            {
                return FALSE;
            }
        }
        else if (!(_fSources & SHCNRF_ShellLevel))
        {
            //
            //  This event was generated by the shell, and the
            //  client has shell notification turned off, so
            //  we skip it.
            //

            return FALSE;
        }
        return TRUE;
    }
    return FALSE;
}

BOOL CCollapsingClient::_CanCollapse(LONG lEvent)
{
    return (!_CheckUpdatingSelf()
    && (lEvent & SHCNE_DISKEVENTS)
    && !(lEvent & SHCNE_GLOBALEVENTS)
    && (_dpaPendingEvents.GetPtrCount() >= EVENT_OVERFLOW));
}

STDAPI_(BOOL) ILIsEqualEx(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2, BOOL fMatchDepth, LPARAM lParam);

//
// checks for null so we dont assert in ILIsEqual
//
BOOL ILIsEqualOrBothNull(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2, BOOL fMemCmpOnly)
{
    if (!pidl1 || !pidl2)
    {
        return (pidl1 == pidl2);
    }

    if (!fMemCmpOnly)
        return ILIsEqualEx(pidl1, pidl2, TRUE, SHCIDS_CANONICALONLY);
    else
    {
        UINT cb1 = ILGetSize(pidl1);

        return (cb1 == ILGetSize(pidl2) && 0 == memcmp(pidl1, pidl2, cb1));
    }        
}

#define SHCNE_ELIMINATE_DUPE_EVENTS (SHCNE_ATTRIBUTES | SHCNE_UPDATEDIR | SHCNE_UPDATEITEM | SHCNE_UPDATEIMAGE | SHCNE_FREESPACE)

BOOL CCollapsingClient::_IsDupe(CNotifyEvent *pne)
{
    BOOL fRet = FALSE;
    if (pne->lEvent & SHCNE_ELIMINATE_DUPE_EVENTS)
    {
        //  look for duplicates starting with the last one
        for (int i = _dpaPendingEvents.GetPtrCount() - 1; !fRet && i >= 0; i--)
        {
            CNotifyEvent *pneMaybe = _dpaPendingEvents.FastGetPtr(i);
            if (pne == pneMaybe)
                fRet = TRUE;
            else if ((pneMaybe->lEvent == pne->lEvent)
            && ILIsEqualOrBothNull(pne->pidl, pneMaybe->pidl, (pne->lEvent & SHCNE_GLOBALEVENTS))
            && ILIsEqualOrBothNull(pne->pidlExtra, pneMaybe->pidlExtra, (pneMaybe->lEvent & SHCNE_GLOBALEVENTS)))
                fRet = TRUE;
        }
    }

    return fRet;
}

BOOL CCollapsingClient::_AddEvent(CNotifyEvent *pneOld, BOOL fFromExtra)
{
    CNotifyEvent *pne = pneOld;
    pne->AddRef();

    BOOL fCollapse = _CanCollapse(pne->lEvent);

    if (fCollapse)
    {
        //
        // If we get too many messages in the queue at any given time,
        // we set the last message in the cue to be an UPDATEDIR that will
        // stand for all messages that we cant fit because the queue is full.
        //
        BOOL fAddSelf = TRUE;
        if (_fRecursive && _dpaPendingEvents.GetPtrCount() < (EVENT_OVERFLOW *2))
        {
            BOOL fFreeUpdate = FALSE;
            LPITEMIDLIST pidlUpdate = fFromExtra ? pne->pidlExtra : pne->pidl;
            DWORD dwAttrs = SFGAO_FOLDER;

            SHGetNameAndFlags(pidlUpdate, 0, NULL, 0, &dwAttrs);
            if (!(dwAttrs & SFGAO_FOLDER))
            {
                pidlUpdate = ILCloneParent(pidlUpdate);
                fFreeUpdate = TRUE;
            }

            if (pidlUpdate)
            {
                if (ILGetSize(pidlUpdate) > ILGetSize(_pidl))
                {
                    pne->Release();

                    //  then we should add this folder to the update list
                    pne = g_pscn->GetEvent(SHCNE_UPDATEDIR, pidlUpdate, NULL, pne->dwEventTime, 0);
                    if (pne)
                    {
                        fAddSelf = FALSE;
                    }
                }

                if (fFreeUpdate)
                    ILFree(pidlUpdate);
            }
        }
        
        if (fAddSelf && pne)
        {
            pne->Release();
            pne = g_pscn->GetEvent(SHCNE_UPDATEDIR, _pidl, NULL, pne->dwEventTime, 0);
        }
    }

    if (pne)
    {
        if (!_IsDupe(pne))
        {
            //  if this is one of our special collapsed
            //  events then we force it in even if we are full
            if ((fCollapse || _dpaPendingEvents.GetPtrCount() < EVENT_OVERFLOW)
            && _dpaPendingEvents.AppendPtr(pne) != -1)
            {
                pne->AddRef();
                g_pscn->SetFlush(FLUSH_SOFT);

                if (!_fUpdatingSelf && (pne->lEvent & SHCNE_UPDATEDIR) && ILIsEqualEx(_pidl, pne->pidl, TRUE, SHCIDS_CANONICALONLY))
                {
                    _fUpdatingSelf = TRUE;
                    _iUpdatingSelfIndex = _dpaPendingEvents.GetPtrCount() - 1;
                }
            }

            //  if we are getting filesystem updates
            //  always pretend that we overflowed
            //  this is because UPDATEDIR's are the
            //  most expensive thing we do.
            if (pne->lEvent & SHCNE_INTERRUPT)
            {
                TraceMsg(TF_SHELLCHANGENOTIFY, "SCN [0x%X]->_AddEvent adding interrupt", this);
                _cEvents += EVENT_OVERFLOW;
            }

            //  count all events even if they 
            //  they werent added.
            _cEvents++;
        }

        pne->Release();
    }

    return TRUE;
}

void CCollapsingClient::Notify(CNotifyEvent *pne, BOOL fFromExtra)
{
    if (_WantsEvent(pne->lEvent))
    {
        _AddEvent(pne, fFromExtra);
    }
}


//--------------------------------------------------------------------------
//  Notifies hCallbackEvent when all the notification packets for
//  all clients in this process have been handled.
//
// This function is primarily called from the FSNotifyThreadProc thread,
// but in flush cases, it can be called from the desktop thread
//
void CALLBACK _DispatchCallbackNoRef(HWND hwnd, UINT uiMsg,
                                DWORD_PTR dwParam, LRESULT result)
{
    MSGEVENT *pme = (MSGEVENT *)dwParam;
    SHChangeNotification_Destroy(pme->hChange, pme->dwProcId);
    delete pme;
}

void CALLBACK _DispatchCallback(HWND hwnd, UINT uiMsg,
                                DWORD_PTR hChange, LRESULT result)
{
    _DispatchCallbackNoRef(hwnd, uiMsg, hChange, result);

    if (EVAL(g_pscn))
        g_pscn->PendingCallbacks(FALSE);
}

void CChangeNotify::PendingCallbacks(BOOL fAdd)
{
    if (fAdd)
    {
        _cCallbacks++;

        ASSERT(_cCallbacks != 0);
        //
        // callback count must be non-zero, we just incremented it.
        // Put the event into the reset/false state.
        //
        if (!_hCallbackEvent)
        {
            _hCallbackEvent = CreateEvent(NULL, TRUE, FALSE, TEXT("Shell_NotificationCallbacksOutstanding"));
        }
        else
        {
            ResetEvent(_hCallbackEvent);
        }
    }
    else
    {
        //  
        // PERF: Waits like this happen on flush, but that really cares about flushing that thread
        // only, and this hCallbackEvent is per-process.  So that thread may be stuck
        // waiting for some dead app to respond.  Fortunately the wait is only 30 seconds,
        // but some wedged window could really make the system crawl...
        //
        ASSERT(_cCallbacks != 0);
        _cCallbacks--;

        if (!_cCallbacks && _hCallbackEvent)
        {
            //  we just got the last of our callbacks
            //  signal incase somebody is waiting
            SetEvent(_hCallbackEvent);    
        }
    }
}

BOOL CCollapsingClient::Flush(BOOL fNeedsCallbackEvent)
{
    BOOL fRet = FALSE;
    if (fNeedsCallbackEvent || _cEvents < EVENT_OVERFLOW)
    {
        TraceMsg(TF_SHELLCHANGENOTIFY, "SCN [0x%X]->Flush is completing", this);
        fRet = _Flush(fNeedsCallbackEvent);
    }
    else
    {
        TraceMsg(TF_SHELLCHANGENOTIFY, "SCN [0x%X]->Flush is deferred", this);

        g_pscn->SetFlush(FLUSH_OVERFLOW);
    }

    _cEvents = 0;
    return fRet;
}
    
void CRegisteredClient::_SendNotification(CNotifyEvent *pne, BOOL fNeedsCallbackEvent, SENDASYNCPROC pfncb)
{
    //  we could possibly reuse one in some cases
    MSGEVENT * pme = pne->GetNotification(_dwProcId);
    if (pme)
    {
        if (fNeedsCallbackEvent)
        {
            g_pscn->PendingCallbacks(TRUE);
        }

        if (!SendMessageCallback(_hwnd, _wMsg,
                                        (WPARAM)pme->hChange,
                                        (LPARAM)_dwProcId,
                                        pfncb,
                                        (DWORD_PTR)pme))
        {
            pfncb(_hwnd, _wMsg, (DWORD_PTR)pme, 0);
            TraceMsg(TF_WARNING, "(_SHChangeNotifyHandleClientEvents) SendMessageCB timed out");
            
            // if the hwnd is bad, the process probably died,
            // remove the window from future notifications.
            if (!IsWindow(_hwnd))
            {
                _fDeadClient = TRUE;
                //  we failed to Flush
            }
        }
    }
}

BOOL CCollapsingClient::_Flush(BOOL fNeedsCallbackEvent)
{
    if (fNeedsCallbackEvent && _hwnd)
    {
        DWORD_PTR dwResult = 0;
        fNeedsCallbackEvent = (0 != SendMessageTimeout(_hwnd, WM_NULL, 0, 0, SMTO_ABORTIFHUNG, 0, &dwResult));
    }
    SENDASYNCPROC pfncb = fNeedsCallbackEvent ? _DispatchCallback : _DispatchCallbackNoRef;

    BOOL fProcessedAny = FALSE;
    //  as long as there are events keep pulling them out
    while (_dpaPendingEvents.GetPtrCount())
    {
        //
        //  2000JUL3 - ZekeL - remove each one from our dpa so that if we reenter 
        //  a flush during the sendmessage, we wont reprocess the event
        //  this also allows for an event to be added to the dpa while
        //  we proccessing and still be flushed on this pass.
        //
        CNotifyEvent *pne = _dpaPendingEvents.DeletePtr(0);
        if (pne)
        {
            fProcessedAny = TRUE;
            //  we never send this if we are dead
            if (_IsValidClient())
            {
                //
                //  if we are about to refresh this client (_fUpdatingSelf)
                //  only send if we are looking at the UPDATEDIR of _pidl
                //  or if this event is not a disk event.
                //
                if (!_CheckUpdatingSelf()
                || (0 == _iUpdatingSelfIndex) 
                || !(pne->lEvent & SHCNE_DISKEVENTS))
                {
                    BOOL fPreCall = BOOLIFY(_fUpdatingSelf);
                    _SendNotification(pne, fNeedsCallbackEvent, pfncb);
                    if (_fUpdatingSelf && !fPreCall)
                    {
                        // we were re-entered while sending this notification and
                        // during the re-entered call we collapsed notifications.
                        // the _iUpdatingSelfIndex value was set without knowing
                        // that we were going to decrement it after unwinding.
                        // account for that now:
                        _iUpdatingSelfIndex++;
                    }
                }
#ifdef DEBUG
                if (_fUpdatingSelf && 0 == _iUpdatingSelfIndex)
                {
                    // RIP because fault injection 
                    // can make this fail
                    if (!ILIsEqual(_pidl, pne->pidl))
                        TraceMsg(TF_WARNING, "CCollapsingClient::_Flush() maybe mismatched _fUpdatingSelf");
                }
#endif // DEBUG                    
            }
            _iUpdatingSelfIndex--;
            pne->Release();
        }
    }
    _fUpdatingSelf = FALSE;
    return fProcessedAny;
}

HRESULT CChangeNotify::RemoveClient(LPCITEMIDLIST pidl, BOOL fInterrupt, CCollapsingClient *pclient)
{
    HRESULT hr = S_OK;
    // remove this boy from the tree
    if (_ptreeClients)
    {
        hr = _ptreeClients->RemoveData(pidl, (INT_PTR)pclient);

        if (fInterrupt)
            ReleaseInterruptSource(pidl);
    }
    return hr;
}


BOOL CChangeNotify::AddClient(IDLDATAF flags, LPCITEMIDLIST pidl, BOOL *pfInterrupt, BOOL fRecursive, CCollapsingClient *pclient)
{
    BOOL fRet = FALSE;
    if (_InitTree(&_ptreeClients))
    {
        ASSERT(pclient);
        
        if (SUCCEEDED(_ptreeClients->AddData(flags, pidl, (INT_PTR)pclient)))
        {
            fRet = TRUE;
            // set up the interrupt events if desired
            if (pfInterrupt && *pfInterrupt)
            {
                *pfInterrupt = AddInterruptSource(pidl, fRecursive);
            }
        }
    }

    return fRet;
}

LPITEMIDLIST _ILCloneInterruptID(LPCITEMIDLIST pidl)
{
    LPITEMIDLIST pidlRet = NULL;
    if (pidl)
    {
        TCHAR sz[MAX_PATH];
        if (SHGetPathFromIDList(pidl, sz))
        {
            WIN32_FIND_DATA fd = {0};
            fd.dwFileAttributes = FILE_ATTRIBUTE_DIRECTORY;        
            SHSimpleIDListFromFindData(sz, &fd, &pidlRet);
        }
    }
    else // NULL is special for desktop
        pidlRet = SHCloneSpecialIDList(NULL, CSIDL_DESKTOPDIRECTORY, FALSE);
        
    return pidlRet;
}

CInterruptSource *CChangeNotify::_InsertInterruptSource(LPCITEMIDLIST pidl, BOOL fRecursive)
{
    CLinkedNode<CInterruptSource> *p = new CLinkedNode<CInterruptSource>;

    if (p)
    {
        IDLDATAF flags = fRecursive ? IDLDATAF_MATCH_RECURSIVE : IDLDATAF_MATCH_IMMEDIATE;
        if (p->that.Init(pidl, fRecursive)
        && _listInterrupts.Insert(p))
        {
            if (SUCCEEDED(_ptreeInterrupts->AddData(flags, p->that.pidl, (INT_PTR)&p->that)))
            {
                return &p->that;
            }
            else
            {
                _listInterrupts.Remove(p);
                delete p;
            }
        }
        else
            delete p;
    }
    return NULL;
}

BOOL CChangeNotify::AddInterruptSource(LPCITEMIDLIST pidlClient, BOOL fRecursive)
{
    if (_InitTree(&_ptreeInterrupts))
    {
        LPITEMIDLIST pidl = _ILCloneInterruptID(pidlClient);

        if (pidl)
        {
            CInterruptSource *pintc = NULL;

            if (FAILED(_ptreeInterrupts->MatchOne(IDLDATAF_MATCH_EXACT, pidl, (INT_PTR*)&pintc, NULL)))
            {
                pintc = _InsertInterruptSource(pidl, fRecursive);
            }

            ILFree(pidl);

            if (pintc)
            {
                pintc->cClients++;
                return TRUE;
            }
        }
    }
    return FALSE;
}

void CChangeNotify::ReleaseInterruptSource(LPCITEMIDLIST pidlClient)
{
    if (_ptreeInterrupts)
    {
        LPITEMIDLIST pidl = _ILCloneInterruptID(pidlClient);
        if (pidl)
        {
            CInterruptSource *pintc;
            if (SUCCEEDED(_ptreeInterrupts->MatchOne(IDLDATAF_MATCH_EXACT, pidl, (INT_PTR*)&pintc, NULL)))
            {
                if (--(pintc->cClients) == 0)
                {
                    // if RemoveData fails, we have to leak the client so the tree doesnt point to freed memory.
                    if (SUCCEEDED(_ptreeInterrupts->RemoveData(pidl, (INT_PTR)pintc)))
                    {
                        CLinkedWalk<CInterruptSource> lw(&_listInterrupts);

                        while (lw.Step())
                        {
                            if (lw.That() == pintc)
                            {
                                lw.Delete();
                                break;
                            }
                        }
                    }
                }
            }
            ILFree(pidl);
        }
    }
}

void CChangeNotify::_ActivateAliases(LPCITEMIDLIST pidl, BOOL fActivate)
{
    if (_ptreeAliases)
    {
        CIDLMatchMany *pmany;

        if (SUCCEEDED(_ptreeAliases->MatchMany(IDLDATAF_MATCH_RECURSIVE, pidl, &pmany)))
        {
            CAnyAlias *paa;
            while (S_OK == pmany->Next((INT_PTR *)&paa, NULL))
            {
                paa->Activate(fActivate);
            }

            delete pmany;
        }
    }
}

ULONG CChangeNotify::_RegisterClient(HWND hwnd, int fSources, LONG fEvents, UINT wMsg, SHChangeNotifyEntry *pfsne)
{
    ULONG ulRet = 0;
    CLinkedNode<CRegisteredClient> *p = new CLinkedNode<CRegisteredClient>;

    if (p)
    {
        if (p->that.Init(hwnd, fSources, fEvents, wMsg, pfsne))
        {
            IDLDATAF flags = IDLDATAF_MATCH_IMMEDIATE;
            if (!pfsne->pidl || pfsne->fRecursive)
                flags = IDLDATAF_MATCH_RECURSIVE;

            if (_listClients.Insert(p)  
            && AddClient(   flags, 
                            pfsne->pidl, 
                            &(p->that._fInterrupt), 
                            pfsne->fRecursive && (fSources & SHCNRF_RecursiveInterrupt),
                            SAFECAST(&p->that, CCollapsingClient *)))
            {
#ifdef DEBUG        
                TCHAR szName[MAX_PATH];
                SHGetNameAndFlags(p->that._pidl, 0, szName, ARRAYSIZE(szName), NULL);
                TraceMsg(TF_SHELLCHANGENOTIFY, "SCN::RegCli() added %s [0x%X] id = %d", szName, p, p->that._ulID);
#endif
                _ActivateAliases(pfsne->pidl, TRUE);
                ulRet = p->that._ulID;
            }
        }

        if (!ulRet)
        {
            _listClients.Remove(p);
            delete p;
        }
    }

    return ulRet;
}

BOOL CChangeNotify::_InitTree(CIDLTree**pptree)
{
    if (!*pptree)
    {
        CIDLTree::Create(pptree);
    }

    return *pptree != NULL;
}

CNotifyEvent *CChangeNotify::GetEvent(LONG lEvent, LPCITEMIDLIST pidl, LPCITEMIDLIST pidlExtra, DWORD dwEventTime, UINT uEventFlags)
{
    return CNotifyEvent::Create(lEvent, pidl, pidlExtra, dwEventTime, uEventFlags);
}

BOOL CChangeNotify::_DeregisterClient(CRegisteredClient *pclient)
{
    TraceMsg(TF_SHELLCHANGENOTIFY, "SCN::RegCli() removing [0x%X] id = %d", pclient, pclient->_ulID);
    if (SUCCEEDED(RemoveClient(pclient->_pidl, pclient->_fInterrupt, SAFECAST(pclient, CCollapsingClient *))))
    {
        _ActivateAliases(pclient->_pidl, FALSE);
        return TRUE;
    }
    return FALSE;
}
    
BOOL CChangeNotify::_DeregisterClientByID(ULONG ulID)
{
    BOOL fRet = FALSE;
    CLinkedWalk <CRegisteredClient> lw(&_listClients);

    while (lw.Step())
    {
        if (lw.That()->_ulID == ulID)
        {
            //  if we are flushing,
            //  then this is coming in while
            //  we are in SendMessageTimeout()
            if (!_cFlushing)
            {
                fRet = _DeregisterClient(lw.That());
                if (fRet)
                {
                    lw.Delete();
                }
            }
            else
                lw.That()->_fDeadClient = TRUE;
                
            break;
        }
    }

    return fRet;
}

BOOL CChangeNotify::_DeregisterClientsByWindow(HWND hwnd)
{
    BOOL fRet = FALSE;
    CLinkedWalk <CRegisteredClient> lw(&_listClients);

    while (lw.Step())
    {
        if (lw.That()->_hwnd == hwnd)
        {
            //  if we are flushing,
            //  then this is coming in while
            //  we are in SendMessageTimeout()
            if (!_cFlushing)
            {
                fRet = _DeregisterClient(lw.That());
                if (fRet)
                {
                    lw.Delete();
                }
            }
            else
                lw.That()->_fDeadClient = TRUE;
        }
    }

    return fRet;
}

void CChangeNotify::_AddGlobalEvent(CNotifyEvent *pne)
{
    CLinkedWalk <CRegisteredClient> lw(&_listClients);

    while (lw.Step())
    {
        lw.That()->Notify(pne, FALSE);
    }

    //  this is the notify we get when a drive mapping is deleted
    //  when this happens we need to kill the aliases to that drive
    if ((pne->lEvent == SHCNE_DRIVEREMOVED) && !(pne->uEventFlags & SHCNF_TRANSLATEDALIAS))
    {
        CLinkedWalk<CAnyAlias> lw(&_listAliases);
        while (lw.Step())
        {
            lw.That()->Notify(pne, FALSE);
        }
    }
}


void CChangeNotify::_MatchAndNotify(LPCITEMIDLIST pidl, CNotifyEvent *pne, BOOL fFromExtra)
{
    if (_ptreeClients)
    {
        CIDLMatchMany *pmany;

        if (SUCCEEDED(_ptreeClients->MatchMany(IDLDATAF_MATCH_RECURSIVE, pidl, &pmany)))
        {
            CCollapsingClient *pclient;
            while (S_OK == pmany->Next((INT_PTR *)&pclient, NULL))
            {
                pclient->Notify(pne, fFromExtra);
            }

            delete pmany;
        }
    }
}

BOOL CChangeNotify::_AddToClients(LONG lEvent, LPCITEMIDLIST pidl, LPCITEMIDLIST pidlExtra, DWORD dwEventTime, UINT uEventFlags)
{
    BOOL bOnlyUpdateDirs = TRUE;

    CNotifyEvent *pne = GetEvent(lEvent, pidl, pidlExtra, dwEventTime, uEventFlags);

    if (pne)
    {
        if (lEvent & SHCNE_GLOBALEVENTS)
        {
            _AddGlobalEvent(pne);
        }
        else
        {
            _MatchAndNotify(pidl, pne, FALSE);

            if (pidlExtra)
                _MatchAndNotify(pidlExtra, pne, TRUE);
        }

        pne->Release();
    }

    return bOnlyUpdateDirs;
}

BOOL CChangeNotify::_HandleMessages(void)
{
    MSG msg;
    // There was some message put in our queue, so we need to dispose
    // of it
    while (PeekMessage(&msg, NULL, 0, 0, PM_REMOVE))
    {
        if (msg.hwnd)
        {
            TranslateMessage(&msg);
            DispatchMessage(&msg);
        }
        else
        {
            switch (msg.message)
            {
            case SCNM_TERMINATE:
                DestroyWindow(g_hwndSCN);
                g_hwndSCN = NULL;
                return TRUE;
                break;
                
            default:
                TraceMsg(TF_SHELLCHANGENOTIFY, "SCN thread proc: eating unknown message %#lx", msg.message);
                break;
            }
        }
    }
    return FALSE;
}

CInterruptSource::~CInterruptSource()
{
    _Reset(TRUE);
    ILFree(pidl);
}

BOOL CInterruptSource::Init(LPCITEMIDLIST pidl, BOOL fRecursive)
{
    this->pidl = ILClone(pidl);
    _fRecursive = fRecursive;
    return (this->pidl != NULL);
}

BOOL CInterruptSource::Flush(void)
{
    if (FS_SIGNAL == _ssSignal)
    {
        g_pscn->NotifyEvent(SHCNE_UPDATEDIR | SHCNE_INTERRUPT, SHCNF_IDLIST, pidl, NULL, GetTickCount());
    }

    _ssSignal = NO_SIGNAL;

    return TRUE;
}

void CInterruptSource::_Reset(BOOL fDeviceNotify)
{
    if (_hEvent && _hEvent != INVALID_HANDLE_VALUE)
    {
        FindCloseChangeNotification(_hEvent);
        _hEvent = NULL;
    }

    if (fDeviceNotify && _hPNP)
    {
        UnregisterDeviceNotification(_hPNP);
        _hPNP = NULL;
    }
}

void CInterruptSource::Reset(BOOL fSignal)
{
    if (fSignal)           // file system event
    {
        switch(_ssSignal)
        {
            case NO_SIGNAL:  _ssSignal = FS_SIGNAL;  break;
            case SH_SIGNAL:  _ssSignal = NO_SIGNAL;  break;
        }

        if (!FindNextChangeNotification(_hEvent))
        {
            _Reset(FALSE);
            //  when we fail, we dont want
            //  to retry.  which we will do
            //  in the case of _hEvent = NULL;
            _hEvent = INVALID_HANDLE_VALUE;
        }
    }
    else                   // shell event
    {
        switch(_ssSignal)
        {
            case NO_SIGNAL:  _ssSignal = SH_SIGNAL;  break;
            case FS_SIGNAL:  _ssSignal = NO_SIGNAL;  break;
        }
    }
}

#define FFCN_INTERESTING_EVENTS     (FILE_NOTIFY_CHANGE_FILE_NAME | FILE_NOTIFY_CHANGE_DIR_NAME | FILE_NOTIFY_CHANGE_LAST_WRITE | FILE_NOTIFY_CHANGE_ATTRIBUTES)

BOOL CInterruptSource::GetEvent(HANDLE *phEvent)
{
    if (_cSuspend == 0 && cClients)
    {
        // create this here so that it will be owned by our global thread
        if (!_hEvent)
        {
            TCHAR szPath[MAX_PATH];
            if (SHGetPathFromIDList(pidl, szPath))
            {
                _hEvent = FindFirstChangeNotification(szPath, _fRecursive, FFCN_INTERESTING_EVENTS);

                if (_hEvent != INVALID_HANDLE_VALUE)
                {
                    // PERF optimization alert: RegisterDeviceNotification is being used for removable drives
                    // to ensure that the FindFirstChangeNotification call will not prevent the disk
                    // from being ejected or dismounted. However, RegisterDeviceNotification is a very expensive
                    // call to make at startup as it brings a bunch of DLLs in the address space. Besides,
                    // we really don't need to call this for the system drive since it needs to remain 
                    // mounted at all times. - FabriceD

                    // Exclude FIXED drives too
                    int iDrive = PathGetDriveNumber(szPath);
                    int nType = DRIVE_UNKNOWN;
                    if (iDrive != -1)
                    {
                        nType = DriveType(iDrive);
                    }

                    // PERF: Exclude the system drive from the RegisterDeviceNotification calls.
                    TCHAR chDrive = *szPath;
                    if ((!GetEnvironmentVariable(TEXT("SystemDrive"), szPath, ARRAYSIZE(szPath)) || *szPath != chDrive) &&
                            nType != DRIVE_FIXED)
                    {
                        //  DO WE NEED TO UnRegister() first?
                        DEV_BROADCAST_HANDLE dbh;
                        ZeroMemory(&dbh, sizeof(dbh));
                        dbh.dbch_size = sizeof(dbh);
                        dbh.dbch_devicetype = DBT_DEVTYP_HANDLE;
                        dbh.dbch_handle = _hEvent;
                        _hPNP = RegisterDeviceNotification(g_hwndSCN, &dbh, DEVICE_NOTIFY_WINDOW_HANDLE);
                    }
                }
            }
            else
                _hEvent = INVALID_HANDLE_VALUE;
        }

        if (_hEvent != INVALID_HANDLE_VALUE)
        {
            *phEvent = _hEvent;
            return TRUE;
        }
    }
    return FALSE;
}
    
void CChangeNotify::_SignalInterrupt(HANDLE hEvent)
{
    CLinkedWalk<CInterruptSource> lw(&_listInterrupts);

    while (lw.Step())
    {   
        //  searching for valid clients
        HANDLE h;
        if (lw.That()->GetEvent(&h) && h == hEvent)
        {
            g_pscn->SetFlush(FLUSH_INTERRUPT);
            lw.That()->Reset(TRUE);
            break;
        }
    }
}

DWORD CChangeNotify::_GetInterruptEvents(HANDLE *ahEvents, DWORD cEventsSize)
{
    DWORD cEvents = 0;
    CLinkedWalk<CInterruptSource> lw(&_listInterrupts);

    while (cEvents < cEventsSize && lw.Step())
    {   
        //  go through and find all the valid
        //  clients that need waiting on
        if (lw.That()->GetEvent(&ahEvents[cEvents]))
        {
//            lw.That()->Reset(FALSE);
            cEvents++;
        }
    }

    return cEvents;
}

void CChangeNotify::_MessagePump(void)
{
    DWORD cFails = 0;
    while (TRUE)
    {
        HANDLE ahEvents[MAXIMUM_WAIT_OBJECTS - 1];
        DWORD cEvents = _GetInterruptEvents(ahEvents, ARRAYSIZE(ahEvents));
        //  maybe cache the events?
        
        //  NEED to handle pending Events with a Timer

        DWORD dwWaitResult = MsgWaitForMultipleObjectsEx(cEvents, ahEvents,
                INFINITE, QS_ALLINPUT, MWMO_ALERTABLE);
        if (dwWaitResult != (DWORD)-1)
        {
            if (dwWaitResult != WAIT_IO_COMPLETION)
            {
                dwWaitResult -= WAIT_OBJECT_0;
                if (dwWaitResult == cEvents)
                {
                    //  there is a message
                    if (_HandleMessages())
                        break;
                } 
                else if (dwWaitResult < cEvents) 
                {
                    _SignalInterrupt(ahEvents[dwWaitResult]);
                }
            }

            cFails = 0;
        }
        else
        {
            //  there was some kind of error
            TraceMsg(TF_ERROR, "SCNotify WaitForMulti() failed with %d", GetLastError());
            //  if MWFM() fails over and over, we give up.
            if (++cFails > 10)
            {
                TraceMsg(TF_ERROR, "SCNotify WaitForMulti() bailing out");
                break;
            }
        }
    }
}

void SCNUninitialize(void)
{
    if (g_pscn)
    {
        if (IsWindow(g_hwndSCN))
            DestroyWindow(g_hwndSCN);
        g_hwndSCN = NULL;

        delete g_pscn;
        g_pscn = NULL;
    }
}

// the real thread proc, runs after CChangeNotify::ThreadStartUp runs sync

DWORD WINAPI CChangeNotify::ThreadProc(void *pv)
{
    if (g_pscn)
    {
        CMountPoint::RegisterForHardwareNotifications();

#ifdef RESTARTSCN
        __try 
#endif
        {
            g_pscn->_MessagePump();
        }
#ifdef RESTARTSCN
        __except (EXCEPTION_EXECUTE_HANDLER)
        {
            ASSERT(FALSE);
        }
#endif
    }
    SCNUninitialize();
    return 0;
}

BOOL CChangeNotify::_OnChangeRegistration(HANDLE hChangeRegistration, DWORD dwProcId)
{
    BOOL fResult = FALSE;
    CHANGEREGISTER *pcr = (CHANGEREGISTER *)SHLockSharedEx(hChangeRegistration, dwProcId, TRUE);
    if (pcr)
    {
        SHChangeNotifyEntry fsne;

        fsne.pidl = NULL;
        fsne.fRecursive = pcr->fRecursive;
        if (pcr->uidlRegister)
            fsne.pidl = _ILSkip(pcr, pcr->uidlRegister);

        pcr->ulID = _RegisterClient((HWND)ULongToPtr(pcr->ulHwnd), pcr->fSources,
                                pcr->lEvents, pcr->uMsg, &fsne);
        fResult = TRUE;
        SHUnlockShared(pcr);
    }
    return fResult;
}

void CChangeNotify::_ResetRelatedInterrupts(LPCITEMIDLIST pidl)
{
    if (_ptreeInterrupts)
    {
        //  we need to match whoever listens on this pidl
        CIDLMatchMany *pmany;

        if (SUCCEEDED(_ptreeInterrupts->MatchMany(IDLDATAF_MATCH_RECURSIVE, pidl, &pmany)))
        {
            CInterruptSource *pintc;
            while (S_OK == pmany->Next((INT_PTR *)&pintc, NULL))
            {
                //  we might need WFSO(pintc->GetEvent()) here first
                //  if this is already signaled,
                //  we need to unsignal
                pintc->Reset(FALSE);
            }
            delete pmany;
        }
    }
}

void CChangeNotify::_FlushInterrupts(void)
{
    CLinkedWalk<CInterruptSource> lw(&_listInterrupts);

    while (lw.Step())
    {   
        lw.That()->Flush();
    }
}


#define CALLBACK_TIMEOUT    30000       // 30 seconds
void CChangeNotify::_WaitForCallbacks(void)
{
    while (_cCallbacks)
    {
        MSG msg;
        DWORD dwWaitResult = MsgWaitForMultipleObjects(1, &_hCallbackEvent, FALSE,
                              CALLBACK_TIMEOUT, QS_SENDMESSAGE);

        TraceMsg(TF_SHELLCHANGENOTIFY, "FSN_WaitForCallbacks returned 0x%X", dwWaitResult);
        if (dwWaitResult == WAIT_OBJECT_0) break;   // Event completed
        if (dwWaitResult == WAIT_TIMEOUT)  break;   // Ran out of time

        if (dwWaitResult == WAIT_OBJECT_0+1) 
        {
            //
            // Some message came in, reset message event, deliver callbacks, etc.
            //
            PeekMessage(&msg, NULL, 0, 0, PM_NOREMOVE);  // we need to do this to flush callbacks
        }
    } 

    if (_hCallbackEvent)
    {
        CloseHandle(_hCallbackEvent);
        _hCallbackEvent = NULL;
    }
}

void CChangeNotify::SetFlush(int idt)
{
    switch (idt)
    {
    case FLUSH_OVERFLOW:
    case FLUSH_SOFT:
        SetTimer(g_hwndSCN, IDT_SCN_FLUSHEVENTS, 500, NULL);
        break;
        
    case FLUSH_HARD:
        PostMessage(g_hwndSCN, SCNM_FLUSHEVENTS, 0, 0);
        break;
        
    case FLUSH_INTERRUPT:
        SetTimer(g_hwndSCN, IDT_SCN_FLUSHEVENTS, 1000, NULL);
        break;
    }
}
    

void CChangeNotify::_Flush(BOOL fShouldWait)
{
    _cFlushing++;
    KillTimer(g_hwndSCN, IDT_SCN_FLUSHEVENTS);
    // flush any pending interrupt events
    _FlushInterrupts();

    int iNumLoops = 0;
    BOOL fProcessedAny;
    do
    {
        fProcessedAny = FALSE;
        CLinkedWalk<CAnyAlias> lwAliases(&_listAliases);
        while (lwAliases.Step())
        {
            if (lwAliases.That()->Flush(TRUE))
            {
                fProcessedAny = TRUE;
            }
        }

        iNumLoops++;
        // in free builds bail out if there's a loop so we don't spin the thread.
        // but this is pretty bad so assert anyway (the most people would usually have
        // is 2 -- a folder shortcut to something on the desktop / mydocs)
        ASSERTMSG(iNumLoops < 10, "we're in an alias loop, we're screwed");
    } while (fProcessedAny && (iNumLoops < 10));

    CLinkedWalk<CRegisteredClient> lwRegistered(&_listClients);
    while (lwRegistered.Step())
    {
        lwRegistered.That()->Flush(fShouldWait);
    }

    if (fShouldWait)
    {
        // now wait for all the callbacks to empty out
        _WaitForCallbacks();
    }
    _cFlushing--;

    //  wait until we have 10 seconds of free time
    SetTimer(g_hwndSCN, IDT_SCN_FRESHENTREES, 10000, NULL);
}

BOOL IsILShared(LPCITEMIDLIST pidl, BOOL fUpdateCache)
{
    TCHAR szTemp[MAXPATHLEN];
    SHGetPathFromIDList(pidl, szTemp);
    return IsShared(szTemp, fUpdateCache);
}

void CChangeNotify::NotifyEvent(LONG lEvent, UINT uFlags, LPCITEMIDLIST pidl, LPCITEMIDLIST pidlExtra, DWORD dwEventTime)
{
    if (!(uFlags & SHCNF_ONLYNOTIFYINTERNALS) && lEvent)
    {
        /// now do the actual generating of the event
        if (lEvent & (SHCNE_NETSHARE | SHCNE_NETUNSHARE))
        {
            // Update the cache.

            IsILShared(pidl, TRUE);
        }

        _AddToClients(lEvent, pidl, pidlExtra, dwEventTime, uFlags);

        // remove any shell generated events for the file system
        if ((lEvent & SHCNE_DISKEVENTS) &&
            !(lEvent & (SHCNE_INTERRUPT | SHCNE_UPDATEDIR)))
        {
            _ResetRelatedInterrupts(pidl);

            if (pidlExtra)
                _ResetRelatedInterrupts(pidlExtra);

        }
    }

    // note make sure the internal events go first.
    if (lEvent)
        NotifyShellInternals(lEvent, uFlags, pidl, pidlExtra, dwEventTime);

    //
    // then the registered events
    //
    if (uFlags & (SHCNF_FLUSH)) 
    {
        if (uFlags & SHCNF_FLUSHNOWAIT)
        {
            SetFlush(FLUSH_HARD);
        }
        else
            _Flush(TRUE);
    }
}

LRESULT CChangeNotify::_OnNotifyEvent(HANDLE hChange, DWORD dwProcId)
{
    CHANGELOCK *pcl = _SHChangeNotification_Lock(hChange, dwProcId);
    if (pcl)
    {
        NotifyEvent(pcl->pce->lEvent,
                                pcl->pce->uFlags,
                                pcl->pidlMain,
                                pcl->pidlExtra,
                                pcl->pce->dwEventTime);
        SHChangeNotification_Unlock(pcl);
        SHChangeNotification_Destroy(hChange, dwProcId);
    }
    return TRUE;
}


void CInterruptSource::Suspend(BOOL fSuspend) 
{ 
    if (fSuspend) 
    {
        if (!_cSuspend)
            _Reset(FALSE);

        _cSuspend++; 
    }
    else if (_cSuspend)
        _cSuspend--; 
}

BOOL CChangeNotify::_SuspendResume(BOOL fSuspend, BOOL fRecursive, LPCITEMIDLIST pidl)
{
    if (_ptreeInterrupts)
    {
        CInterruptSource *pintc;
        if (!fRecursive)
        {
            if (SUCCEEDED(_ptreeInterrupts->MatchOne(IDLDATAF_MATCH_EXACT, pidl, (INT_PTR*)&pintc, NULL)))
            {
                pintc->Suspend(fSuspend);
            }
        }
        else
        {
            CIDLMatchMany *pmany;
            if (SUCCEEDED(_ptreeInterrupts->MatchMany(IDLDATAF_MATCH_RECURSIVE, pidl, &pmany)))
            {
                while (S_OK == pmany->Next((INT_PTR *)&pintc, NULL))
                {
                    pintc->Suspend(fSuspend);
                }
                delete pmany;
            }
        }
    }
    return TRUE;
}

#define SCNSUSPEND_SUSPEND      1
#define SCNSUSPEND_RECURSIVE    2

LRESULT CChangeNotify::_OnSuspendResume(HANDLE hChange, DWORD dwProcId)
{
    BOOL fRet = FALSE;
    CHANGELOCK *pcl = _SHChangeNotification_Lock(hChange, dwProcId);
    if (pcl)
    {
        fRet = _SuspendResume(pcl->pce->uFlags & SCNSUSPEND_SUSPEND, pcl->pce->uFlags & SCNSUSPEND_RECURSIVE, pcl->pidlMain);
        SHChangeNotification_Unlock((HANDLE)pcl);
    }
    return fRet;
}

BOOL CInterruptSource::SuspendDevice(BOOL fSuspend, HDEVNOTIFY hPNP)
{
    BOOL fRet = FALSE;
    if (hPNP)
    {
        if (fSuspend && _hPNP == hPNP)
        {
            _hSuspended = _hPNP;
            Suspend(fSuspend);
            _Reset(TRUE);
            fRet = TRUE;
        }
        else if (!fSuspend && _hSuspended == hPNP)
        {
            _hSuspended = NULL;
            Suspend(fSuspend);
            fRet = TRUE;
        }
    }
    else if (_hPNP)
    {
        // NULL means we are shutting down and should close all handles.
        UnregisterDeviceNotification(_hPNP);
        _hPNP = NULL;
    }
    return fRet;
}

//  __HandleDevice
void CChangeNotify::_OnDeviceBroadcast(ULONG_PTR code, DEV_BROADCAST_HANDLE *pbhnd)
{
    if (IsWindowVisible(GetShellWindow()) && pbhnd
    && (pbhnd->dbch_devicetype == DBT_DEVTYP_HANDLE && pbhnd->dbch_hdevnotify))
    {
        BOOL fSuspend;
        switch (code)
        {

        // When PnP is finished messing with the drive (either successfully
        // or unsuccessfully), resume notifications on that drive.
        case DBT_DEVICEREMOVECOMPLETE:
        case DBT_DEVICEQUERYREMOVEFAILED:
            fSuspend = FALSE;
            break;

        // When PnP is starting to mess with the drive, suspend notifications
        // so it can do its thing
        case DBT_DEVICEQUERYREMOVE:

            // This will wait on another thread to exit if this hdevnotify
            // was registered for a Sniffing Dialog
            CSniffDrive::HandleNotif(pbhnd->dbch_hdevnotify);

            fSuspend = TRUE;
            break;

        case DBT_CUSTOMEVENT:
            if (GUID_IO_VOLUME_LOCK == pbhnd->dbch_eventguid)
            {
                TraceMsg(TF_MOUNTPOINT, "GUID_IO_VOLUME_LOCK: Suspending!");
                fSuspend = TRUE;
            }
            else
            {
                if (GUID_IO_VOLUME_LOCK_FAILED == pbhnd->dbch_eventguid)
                {
                    TraceMsg(TF_MOUNTPOINT, "GUID_IO_VOLUME_LOCK_FAILED: Resuming!");
                    fSuspend = FALSE;
                }
                else
                {
                    if (GUID_IO_VOLUME_UNLOCK == pbhnd->dbch_eventguid)
                    {
                        TraceMsg(TF_MOUNTPOINT, "GUID_IO_VOLUME_UNLOCK: Resuming!");
                        fSuspend = FALSE;
                    }
                }
            }
            
            break;

        default:
            //  we dont handle anything else here
            return;
        }

        CLinkedWalk<CInterruptSource> lw(&_listInterrupts);

        while (lw.Step())
        {
            //  returns true if found
            if (lw.That()->SuspendDevice(fSuspend, pbhnd->dbch_hdevnotify))
                break;
        }
    }
}

void CChangeNotify::_FreshenClients(void)
{
    CLinkedWalk<CRegisteredClient> lw(&_listClients);

    while (lw.Step())
    {
        if (lw.That()->_fDeadClient || !IsWindow(lw.That()->_hwnd))
        {
            if (_DeregisterClient(lw.That()))
            {
                lw.Delete();
            }
        }
    }
}

void CChangeNotify::_FreshenUp(void)
{
    ASSERT(!_cFlushing);
    KillTimer(g_hwndSCN, IDT_SCN_FRESHENTREES);
    
    if (_ptreeClients)
        _ptreeClients->Freshen();

    if (_ptreeInterrupts)
        _ptreeInterrupts->Freshen();

    _FreshenAliases();
    _FreshenClients();
}

LRESULT CChangeNotify::WndProc(HWND hwnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    LRESULT lRes = 0;
    ASSERT(g_pscn);

    switch (uMsg)
    {
    case SCNM_REGISTERCLIENT:
        lRes = g_pscn->_OnChangeRegistration((HANDLE)wParam, (DWORD)lParam);
        break;

    case SCNM_DEREGISTERCLIENT:
        lRes = g_pscn->_DeregisterClientByID((ULONG)wParam);
        break;

    case SCNM_DEREGISTERWINDOW:
        lRes = g_pscn->_DeregisterClientsByWindow((HWND)wParam);
        break;
        
    case SCNM_NOTIFYEVENT:
        lRes = g_pscn->_OnNotifyEvent((HANDLE)wParam, (DWORD)lParam);
        break;
        
    case SCNM_SUSPENDRESUME:
        lRes = g_pscn->_OnSuspendResume((HANDLE)wParam, (DWORD)lParam);
        break;

    case WM_TIMER:
        if (wParam == IDT_SCN_FRESHENTREES)
        {
            g_pscn->_FreshenUp();
            break;
        }
        // Fall through to SCNM_FLUSHEVENTS
    case SCNM_FLUSHEVENTS:
        g_pscn->_Flush(FALSE);
        break;

    case SCNM_AUTOPLAYDRIVE:
        CMountPoint::DoAutorunPrompt(wParam);
        break;
        
    case WM_DEVICECHANGE:
        g_pscn->_OnDeviceBroadcast(wParam, (DEV_BROADCAST_HANDLE *)lParam);
        break;

    default:
        lRes = DefWindowProc(hwnd, uMsg, wParam, lParam);
        break;
    }

    return lRes;
}

// thread setup routine, executed before SHCreateThread() returns

DWORD WINAPI CChangeNotify::ThreadStartUp(void *pv)
{
    g_pscn = new CChangeNotify();
    if (g_pscn)
    {
        g_hwndSCN = SHCreateWorkerWindow(CChangeNotify::WndProc, NULL, 0, 0, NULL, g_pscn);

        CSniffDrive::InitNotifyWindow(g_hwndSCN);

        InitAliasFolderTable();
    }
    return 0;
}

// now we create the window
BOOL SCNInitialize()
{
    EnterCriticalSection(&g_csSCN);
    if (!IsWindow(g_hwndSCN))
    {
        SHCreateThread(CChangeNotify::ThreadProc, NULL, CTF_COINIT, CChangeNotify::ThreadStartUp);
    }
    LeaveCriticalSection(&g_csSCN);
    return g_hwndSCN ? TRUE : FALSE;    // ThreadStartUp is executed sync
}

BOOL _IsImpersonating()
{
    HANDLE hToken;
    if (OpenThreadToken(GetCurrentThread(), TOKEN_QUERY | TOKEN_IMPERSONATE, TRUE, &hToken))
    {
        CloseHandle(hToken);
        return TRUE;
    }
    return FALSE;
}

STDAPI_(HWND) _SCNGetWindow(BOOL fUseDesktop, BOOL fNeedsFallback)
{
    //  if explorer is trashed
    //  then this hwnd can go bad
    //  get a new copy from the desktop
    if (!g_hwndSCN || !IsWindow(g_hwndSCN))
    {
        HWND hwndDesktop = fUseDesktop ? GetShellWindow() : NULL;
        if (hwndDesktop)
        {
            HWND hwndSCN = (HWND) SendMessage(hwndDesktop, CWM_GETSCNWINDOW, 0, 0);
            if (_IsImpersonating())
                return hwndSCN;
            else
                g_hwndSCN = hwndSCN;
        }
        else if (fNeedsFallback && SHIsCurrentThreadInteractive())
        {
            //  there is no desktop.
            //  so we create a private desktop
            //  this will create the thread and window
            //  and set
            SCNInitialize();
        }
    }

    return g_hwndSCN;
}

STDAPI_(HWND) SCNGetWindow(BOOL fUseDesktop)
{
    return _SCNGetWindow(fUseDesktop, TRUE);
}

HANDLE SHChangeRegistration_Create(ULONG ulID,
                                    HWND hwnd, UINT uMsg,
                                    DWORD fSources, LONG lEvents,
                                    BOOL fRecursive, LPCITEMIDLIST pidl,
                                    DWORD dwProcId)
{
    UINT uidlSize = ILGetSize(pidl);
    HANDLE hReg = SHAllocShared(NULL, sizeof(CHANGEREGISTER) + uidlSize, dwProcId);
    if (hReg)
    {
        CHANGEREGISTER *pcr = (CHANGEREGISTER *) SHLockSharedEx(hReg, dwProcId, TRUE);
        if (pcr)
        {
            pcr->dwSig        = CHANGEREGISTER_SIG;
            pcr->ulID         = ulID;
            pcr->ulHwnd       = PtrToUlong(hwnd);
            pcr->uMsg         = uMsg;
            pcr->fSources     = fSources;
            pcr->lEvents      = lEvents;
            pcr->fRecursive   = fRecursive;
            pcr->uidlRegister = 0;

            if (pidl)
            {
                pcr->uidlRegister = sizeof(CHANGEREGISTER);
                memcpy((pcr + 1), pidl, uidlSize);
            }
            SHUnlockShared(pcr);
        }
        else
        {
            SHFreeShared(hReg, dwProcId);
            hReg = NULL;
        }

    }

    return hReg;
}

typedef struct 
{
    HWND hwnd;
    UINT wMsg;
} NOTIFY_PROXY_DATA;
#define WM_CHANGENOTIFYMSG    WM_USER + 1
LRESULT CALLBACK _HiddenNotifyWndProc(HWND hWnd, UINT iMessage, WPARAM wParam, LPARAM lParam)
{
    LRESULT lRes = FALSE;
    NOTIFY_PROXY_DATA *pData = (NOTIFY_PROXY_DATA *) GetWindowLongPtr( hWnd, 0 );

    switch (iMessage)
    {
     case WM_NCDESTROY:
        ASSERT(pData != NULL );

        // clear it so it won't be in use....
        SetWindowLongPtr( hWnd, 0, (LONG_PTR)NULL );

        // free the memory ...
        LocalFree( pData );
        break;

    case WM_CHANGENOTIFYMSG :
        if (pData)
        {
            // lock and break the info structure ....
            LPITEMIDLIST *ppidl;
            LONG lEvent;
            HANDLE hLock = SHChangeNotification_Lock((HANDLE)wParam, (DWORD)lParam, &ppidl, &lEvent);

            if (hLock)
            {
                // pass on to the old style client. ...
                lRes = SendMessage( pData->hwnd, pData->wMsg, (WPARAM) ppidl, (LPARAM) lEvent );

                // new notifications ......
                SHChangeNotification_Unlock(hLock);
            }
        }
        break;

    default:
        lRes = DefWindowProc(hWnd, iMessage, wParam, lParam);
        break;
    }

    return lRes;
}


HWND _CreateProxyWindow(HWND hwnd, UINT wMsg)
{
    HWND hwndRet = NULL;
    // This is an old style notification, we need to create a hidden
    // proxy type of window to properly handle the messages...

    NOTIFY_PROXY_DATA *pnpd = (NOTIFY_PROXY_DATA *)LocalAlloc(LPTR, sizeof(*pnpd));

    if (pnpd)
    {
        pnpd->hwnd = hwnd;
        pnpd->wMsg = wMsg;

        hwndRet = SHCreateWorkerWindow(_HiddenNotifyWndProc, NULL, 0, 0, NULL, pnpd);

        if (!hwndRet)
            LocalFree(pnpd);

    }

    return hwndRet;
}
            


//--------------------------------------------------------------------------
//
//  Returns a positive integer registration ID, or 0 if out of memory or if
//  invalid parameters were passed in.
//
//  If the hwnd is != NULL we do a PostMessage(hwnd, wMsg, ...) when a
//  relevant FS event takes place, otherwise if fsncb is != NULL we call it.
//
STDAPI_(ULONG) SHChangeNotifyRegister(HWND hwnd,
                               int fSources, LONG fEvents,
                               UINT wMsg, int cEntries,
                               SHChangeNotifyEntry *pfsne)
{
    ULONG ulID = 0;
    BOOL fResult = FALSE;
    HWND hwndSCN = SCNGetWindow(TRUE);

    if (hwndSCN)
    {
        if (!(fSources & SHCNRF_NewDelivery))
        {
            // Now setup to use the proxy window instead
            hwnd = _CreateProxyWindow(hwnd, wMsg);
            wMsg = WM_CHANGENOTIFYMSG;
        }

        if ((fSources & SHCNRF_RecursiveInterrupt) && !(fSources & SHCNRF_InterruptLevel))
        {
            // bad caller, they asked for recursive interrupt events, but not interrupt events
            ASSERTMSG(FALSE, "SHChangeNotifyRegister: caller passed SHCNRF_RecursiveInterrupt but NOT SHCNRF_InterruptLevel !!");

            // clear the flag
            fSources = fSources & (~SHCNRF_RecursiveInterrupt);
        }

        // This same assert is CRegisteredClient::Init, caled by SCNM_REGISTERCLIENT message below
        ASSERT(fSources & (SHCNRF_InterruptLevel | SHCNRF_ShellLevel));
    
        //  NOTE - if we have more than one registration entry here, 
        //  we only support Deregister'ing the last one
        for (int i = 0; i < cEntries; i++)
        {
            DWORD dwProcId;
            GetWindowThreadProcessId(hwndSCN, &dwProcId);
            HANDLE hChangeRegistration = SHChangeRegistration_Create(
                                        ulID, hwnd, wMsg,
                                        fSources, fEvents,
                                        pfsne[i].fRecursive, pfsne[i].pidl,
                                        dwProcId);
            if (hChangeRegistration)
            {
                CHANGEREGISTER * pcr;
                //
                // Transmit the change regsitration
                //
                SendMessage(hwndSCN, SCNM_REGISTERCLIENT,
                            (WPARAM)hChangeRegistration, (LPARAM)dwProcId);

                //
                // Now get back the ulID value, for further registrations and
                // for returning to the calling function...
                //
                pcr = (CHANGEREGISTER *)SHLockSharedEx(hChangeRegistration, dwProcId, FALSE);
                if (pcr)
                {
                    ulID = pcr->ulID;
                    SHUnlockShared(pcr);
                }
                else
                {
                    ASSERT(0 == ulID);       // Error condition initialized above
                }
                
                SHFreeShared(hChangeRegistration, dwProcId);
            }

            if ((ulID == 0) && !(fSources & SHCNRF_NewDelivery))
            {
                //  this is our proxy window
                DestroyWindow(hwnd);
                break;
            }
        }
    }
    return ulID;
}

//--------------------------------------------------------------------------
//
//  Returns TRUE if we found and removed the specified Client, otherwise
//  returns FALSE.
//
STDAPI_(BOOL) SHChangeNotifyDeregister(ULONG ulID)
{
    BOOL fResult = FALSE;
    HWND hwnd = _SCNGetWindow(TRUE, FALSE);

    if (hwnd)
    {
        //
        // Transmit the change registration
        //
        fResult = (BOOL) SendMessage(hwnd, SCNM_DEREGISTERCLIENT, ulID, 0);
    }
    return fResult;
}

// send the notify to the desktop... telling it to put it in the queue.
// if we are in the desktop's process, we can handle it directly ourselves.
// the one exception is flush.  we want the desktop to be one serializing flush so
// we send in that case as well
void SHChangeNotifyTransmit(LONG lEvent, UINT uFlags, LPCITEMIDLIST pidl, LPCITEMIDLIST pidlExtra, DWORD dwEventTime)
{
    HWND hwndSCN = _SCNGetWindow(TRUE, FALSE);

    if (hwndSCN)
    {
        DWORD   dwProcId;
        GetWindowThreadProcessId(hwndSCN, &dwProcId);
        HANDLE  hChange = SHChangeNotification_Create(lEvent, uFlags, pidl, pidlExtra, dwProcId, dwEventTime);

        if (hChange)
        {
            BOOL fFlushNow = ((uFlags & (SHCNF_FLUSH | SHCNF_FLUSHNOWAIT)) == SHCNF_FLUSH);
            
            // Flush but not flush no wait
            if (fFlushNow)
            {
                SendMessage(hwndSCN, SCNM_NOTIFYEVENT,
                            (WPARAM)hChange, (LPARAM)dwProcId);
            }
            else
            {
                SendNotifyMessage(hwndSCN, SCNM_NOTIFYEVENT,
                                  (WPARAM)hChange, (LPARAM)dwProcId);
            }
        }
    }
}

void FreeSpacePidlToPath(LPCITEMIDLIST pidl1, LPCITEMIDLIST pidl2)
{
    TCHAR szPath1[MAX_PATH];
    if (SHGetPathFromIDList(pidl1, szPath1)) 
    {
        TCHAR szPath2[MAX_PATH];
        szPath2[0] = 0;
        if (pidl2) 
        {
            SHGetPathFromIDList(pidl2, szPath2);
        }
        SHChangeNotify(SHCNE_FREESPACE, SHCNF_PATH, szPath1, szPath2[0] ? szPath2 : NULL);
    }
}
    
STDAPI_(void) SHChangeNotify(LONG lEvent, UINT uFlags, const void * dwItem1, const void * dwItem2)
{
    if (!_SCNGetWindow(TRUE, FALSE))
        return;
        
    LPCITEMIDLIST pidl = NULL;
    LPCITEMIDLIST pidlExtra = NULL;
    LPITEMIDLIST pidlFree = NULL;
    LPITEMIDLIST pidlExtraFree = NULL;
    UINT uType = uFlags & SHCNF_TYPE;
    SHChangeDWORDAsIDList dwidl;
    BOOL    fPrinter = FALSE;
    BOOL    fPrintJob = FALSE;
    DWORD dwEventTime = GetTickCount();

    // first setup anything the flags request
    switch (uType)
    {
    case SHCNF_PRINTJOBA:
        fPrintJob = TRUE;
        // fall through
    case SHCNF_PRINTERA:
        fPrinter = TRUE;
        // fall through
    case SHCNF_PATHA:
        {
            TCHAR szPath1[MAX_PATH], szPath2[MAX_PATH];
            LPCVOID pvItem1 = NULL;
            LPCVOID pvItem2 = NULL;

            if (dwItem1)
            {
                SHAnsiToTChar((LPSTR)dwItem1, szPath1, ARRAYSIZE(szPath1));
                pvItem1 = szPath1;
            }

            if (dwItem2)
            {
                if (fPrintJob)
                    pvItem2 = dwItem2;  // SHCNF_PRINTJOB_DATA needs no conversion
                else
                {
                    SHAnsiToTChar((LPSTR)dwItem2, szPath2, ARRAYSIZE(szPath2));
                    pvItem2 = szPath2;
                }
            }

            SHChangeNotify(lEvent, (fPrintJob ? SHCNF_PRINTJOB : (fPrinter ? SHCNF_PRINTER : SHCNF_PATH)),
                           pvItem1, pvItem2);
            goto Cleanup;       // Let the recursive version do all the work
        }
        break;

    case SHCNF_PATH:
        if (lEvent == SHCNE_FREESPACE) 
        {
            DWORD dwItem = 0;
            int idDrive = PathGetDriveNumber((LPCTSTR)dwItem1);
            if (idDrive != -1)
                dwItem = (1 << idDrive);

            if (dwItem2) 
            {
                idDrive = PathGetDriveNumber((LPCTSTR)dwItem2);
                if (idDrive != -1)
                    dwItem |= (1 << idDrive);
            }

            dwItem1 = (LPCVOID)ULongToPtr( dwItem );
            if (dwItem1)
                goto DoDWORD;
            goto Cleanup;
        } 
        else 
        {
            if (dwItem1)
            {
                pidl = pidlFree = SHSimpleIDListFromPath((LPCTSTR)dwItem1);
                if (!pidl)
                    goto Cleanup;

                if (dwItem2) 
                {
                    pidlExtra = pidlExtraFree = SHSimpleIDListFromPath((LPCTSTR)dwItem2);
                    if (!pidlExtra)
                        goto Cleanup;
                }
            }
        }
        break;

    case SHCNF_PRINTER:
        if (dwItem1)
        {
            TraceMsg(TF_SHELLCHANGENOTIFY, "SHChangeNotify: SHCNF_PRINTER %s", (LPTSTR)dwItem1);

            if (FAILED(ParsePrinterName((LPCTSTR)dwItem1, &pidlFree)))
            {
                goto Cleanup;
            }
            pidl = pidlFree;

            if (dwItem2)
            {
                if (FAILED(ParsePrinterName((LPCTSTR)dwItem2, &pidlExtraFree)))
                {
                    goto Cleanup;
                }
                pidlExtra = pidlExtraFree;
            }
        }
        break;

    case SHCNF_PRINTJOB:
        if (dwItem1)
        {
#ifdef DEBUG
            switch (lEvent)
            {
            case SHCNE_CREATE:
                TraceMsg(TF_SHELLCHANGENOTIFY, "SHChangeNotify: SHCNE_CREATE SHCNF_PRINTJOB %s", (LPTSTR)dwItem1);
                break;
            case SHCNE_DELETE:
                TraceMsg(TF_SHELLCHANGENOTIFY, "SHChangeNotify: SHCNE_DELETE SHCNF_PRINTJOB %s", (LPTSTR)dwItem1);
                break;
            case SHCNE_UPDATEITEM:
                TraceMsg(TF_SHELLCHANGENOTIFY, "SHChangeNotify: SHCNE_UPDATEITEM SHCNF_PRINTJOB %s", (LPTSTR)dwItem1);
                break;
            default:
                TraceMsg(TF_SHELLCHANGENOTIFY, "SHChangeNotify: SHCNE_? SHCNF_PRINTJOB %s", (LPTSTR)dwItem1);
                break;
            }
#endif
            pidl = pidlFree = Printjob_GetPidl((LPCTSTR)dwItem1, (LPSHCNF_PRINTJOB_DATA)dwItem2);
            if (!pidl)
                goto Cleanup;
        }
        else
        {
            // Caller goofed.
            goto Cleanup;
        }
        break;

    case SHCNF_DWORD:
DoDWORD:
        ASSERT(lEvent & SHCNE_GLOBALEVENTS);

        dwidl.cb      = sizeof(dwidl) - sizeof(dwidl.cbZero);
        dwidl.dwItem1 = PtrToUlong(dwItem1);
        dwidl.dwItem2 = PtrToUlong(dwItem2);
        dwidl.cbZero  = 0;
        pidl = (LPCITEMIDLIST)&dwidl;
        pidlExtra = NULL;
        break;

    case 0:
        if (lEvent == SHCNE_FREESPACE) {
            // convert this to paths.
            FreeSpacePidlToPath((LPCITEMIDLIST)dwItem1, (LPCITEMIDLIST)dwItem2);
            goto Cleanup;
        }
        pidl = (LPCITEMIDLIST)dwItem1;
        pidlExtra = (LPCITEMIDLIST)dwItem2;
        break;

    default:
        TraceMsg(TF_ERROR, "SHChangeNotify: Unrecognized uFlags 0x%X", uFlags);
        return;
    }

    if (lEvent && !(lEvent & SHCNE_ASSOCCHANGED) && !pidl)
    {
        // Caller goofed. SHChangeNotifyTransmit & clients assume pidl is
        // non-NULL if lEvent is non-zero (except in the SHCNE_ASSOCCHANGED case),
        // and they will crash if we try to send this bogus event. So throw out 
        // this event and rip.
        RIP(FALSE);
        goto Cleanup;
    }

    SHChangeNotifyTransmit(lEvent, uFlags, pidl, pidlExtra, dwEventTime);

Cleanup:

    if (pidlFree)
        ILFree(pidlFree);
    if (pidlExtraFree)
        ILFree(pidlExtraFree);
}

// SHChangeNotifySuspendResume
//
// Suspends or resumes filesystem notifications on a path.  If bRecursive
// is set, disable/enables them for all child paths as well.

STDAPI_(BOOL) SHChangeNotifySuspendResume(BOOL         bSuspend, 
                                          LPITEMIDLIST pidlSuspend, 
                                          BOOL         bRecursive, 
                                          DWORD        dwReserved)
{
    BOOL fRet = FALSE;
    HWND hwndSCN = _SCNGetWindow(TRUE, FALSE);

    if (hwndSCN)
    {
        HANDLE  hChange;
        DWORD   dwProcId;
        UINT uiFlags = bSuspend ? SCNSUSPEND_SUSPEND : 0;
        if (bRecursive)
            uiFlags |= SCNSUSPEND_RECURSIVE;

        GetWindowThreadProcessId(hwndSCN, &dwProcId);

        //  overloading the structure semantics here a little bit.
        //  our two flags
        hChange = SHChangeNotification_Create(0, uiFlags, pidlSuspend, NULL, dwProcId, 0);
        if (hChange)
        {
            // Transmit to SCN
            fRet = (BOOL)SendMessage(hwndSCN, SCNM_SUSPENDRESUME, (WPARAM)hChange, (LPARAM)dwProcId);
            SHChangeNotification_Destroy(hChange, dwProcId);
        }
    }

    return fRet;
}


STDAPI_(void) SHChangeNotifyTerminate(BOOL bLastTerm, BOOL bProcessShutdown)
{
    if (g_pscn)
    {
        PostThreadMessage(GetWindowThreadProcessId(g_hwndSCN, NULL), SCNM_TERMINATE, 0, 0);
    }
}

// this deregisters anything that this window might have been registered in
STDAPI_(void) SHChangeNotifyDeregisterWindow(HWND hwnd)
{
    HWND hwndSCN = _SCNGetWindow(TRUE, FALSE);

    if (hwndSCN)
    {
        SendMessage(hwndSCN, SCNM_DEREGISTERWINDOW, (WPARAM)hwnd, 0);
    }
}

//--------------------------------------------------------------------------
// We changed the way that the SHChangeNotifyRegister function worked, so
// to prevent people from calling the old function, we stub it out here.
// The change we made would have broken everbody because we changed the
// lparam and wparam for the notification messages which are sent to the
// registered window.
//
STDAPI_(ULONG) NTSHChangeNotifyRegister(HWND hwnd,
                               int fSources, LONG fEvents,
                               UINT wMsg, int cEntries,
                               SHChangeNotifyEntry *pfsne)
{
    return SHChangeNotifyRegister(hwnd, fSources | SHCNRF_NewDelivery , fEvents, wMsg, cEntries, pfsne);
}
STDAPI_(BOOL) NTSHChangeNotifyDeregister(ULONG ulID)
{
    return SHChangeNotifyDeregister(ulID);
}



// NOTE: There is a copy of these functions in shdocvw util.cpp for browser only mode supprt.
// NOTE: functionality changes should also be reflected there.
STDAPI_(void) SHUpdateImageA( LPCSTR pszHashItem, int iIndex, UINT uFlags, int iImageIndex )
{
    WCHAR szWHash[MAX_PATH];

    SHAnsiToUnicode(pszHashItem, szWHash, ARRAYSIZE(szWHash));

    SHUpdateImageW(szWHash, iIndex, uFlags, iImageIndex);
}

STDAPI_(void) SHUpdateImageW( LPCWSTR pszHashItem, int iIndex, UINT uFlags, int iImageIndex )
{
    SHChangeUpdateImageIDList rgPidl;
    SHChangeDWORDAsIDList rgDWord;

    int cLen = MAX_PATH - (lstrlenW( pszHashItem ) + 1);
    cLen *= sizeof( WCHAR );

    if ( cLen < 0 )
    {
        cLen = 0;
    }

    // make sure we send a valid index
    if ( iImageIndex == -1 )
    {
        iImageIndex = II_DOCUMENT;
    }
        
    rgPidl.dwProcessID = GetCurrentProcessId();
    rgPidl.iIconIndex = iIndex;
    rgPidl.iCurIndex = iImageIndex;
    rgPidl.uFlags = uFlags;
    StrCpyNW( rgPidl.szName, pszHashItem, MAX_PATH );
    rgPidl.cb = (USHORT)(sizeof( rgPidl ) - cLen);
    _ILNext( (LPITEMIDLIST) &rgPidl )->mkid.cb = 0;

    rgDWord.cb = sizeof( rgDWord) - sizeof(USHORT);
    rgDWord.dwItem1 = iImageIndex;
    rgDWord.dwItem2 = 0;
    rgDWord.cbZero = 0;

    // pump it as an extended event
    SHChangeNotify(SHCNE_UPDATEIMAGE, SHCNF_IDLIST, &rgDWord, &rgPidl);
}

// REVIEW: pretty poor implementation of handling updateimage, requiring the caller
// to handle the pidl case instead of passing both pidls down here.
//
STDAPI_(int) SHHandleUpdateImage( LPCITEMIDLIST pidlExtra )
{
    SHChangeUpdateImageIDList * pUs = (SHChangeUpdateImageIDList*) pidlExtra;

    if ( !pUs )
    {
        return -1;
    }

    // if in the same process, or an old style notification
    if ( pUs->dwProcessID == GetCurrentProcessId())
    {
        return *(int UNALIGNED *)((BYTE *)&pUs->iCurIndex);
    }
    else
    {
        WCHAR szBuffer[MAX_PATH];
        int iIconIndex = *(int UNALIGNED *)((BYTE *)&pUs->iIconIndex);
        UINT uFlags = *(UINT UNALIGNED *)((BYTE *)&pUs->uFlags);

        ualstrcpyW( szBuffer, pUs->szName );
        
        // we are in a different process, look up the hash in our index to get the right one...
        return SHLookupIconIndexW( szBuffer, iIconIndex, uFlags );
    }
}

//
// NOTE: these are OLD APIs, new clients should use new APIs
//
// REVIEW: BobDay - SHChangeNotifyUpdateEntryList doesn't appear to be
// called by anybody and since we've change the notification message
// structure, anybody who calls it needs to be identified and fixed.
//
BOOL  WINAPI SHChangeNotifyUpdateEntryList(ULONG ulID, int iUpdateType,
                               int cEntries, SHChangeNotifyEntry *pfsne)
{
    ASSERT(FALSE);
    return FALSE;
}


void SHChangeNotifyReceive(LONG lEvent, UINT uFlags, LPCITEMIDLIST pidl, LPCITEMIDLIST pidlExtra)
{
    ASSERT(FALSE);
}

BOOL WINAPI SHChangeRegistrationReceive(HANDLE hChangeRegistration, DWORD dwProcId)
{
    ASSERT(FALSE);
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\securent.h ===
#ifndef _SECURENT_INC
#define _SECURENT_INC

// all this seurity mumbo-jumbo is only necessary on NT
#ifdef WINNT

//
// Shell helper functions for security
//
STDAPI_(PTOKEN_USER) GetUserToken(HANDLE hUser);
STDAPI_(LPTSTR) GetUserSid(HANDLE hToken);

STDAPI_(BOOL) GetUserProfileKey(HANDLE hToken, HKEY *phkey);
STDAPI_(BOOL) IsUserAnAdmin();
STDAPI_(BOOL) IsUserAGuest();
#else
// on win95 we just return FALSE here
#define GetUserProfileKey(hToken, phkey) FALSE
#endif // WINNT

#endif // _SECURENT_INC
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\security.cpp ===
#include "shellprv.h"

extern "C" {
#include <shellp.h>
#include "ole2dup.h"
};

#include "util.h"
#include "_security.h"

/**********************************************************************\
    FUNCTION: ZoneCheckPidl

    DESCRIPTION:
        Return S_OK if access is allowed.  This function will return
    S_FALSE if access was not allowed.
\**********************************************************************/
STDAPI ZoneCheckPidl(LPCITEMIDLIST pidl, DWORD dwActionType, DWORD dwFlags, IInternetSecurityMgrSite * pisms)
{
    HRESULT hr = E_FAIL;
    TCHAR szUrl[MAX_URL_STRING];

    SetFlag(dwFlags, PUAF_ISFILE);

    if (SUCCEEDED(SHGetNameAndFlags(pidl, SHGDN_FORPARSING | SHGDN_FORADDRESSBAR, szUrl, SIZECHARS(szUrl), NULL)))
        hr = ZoneCheckUrl(szUrl, dwActionType, dwFlags, pisms);

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\securent.cpp ===
#include "shellprv.h"
#include "TokenUtil.h"
#pragma  hdrstop


//  Gets the current process's user token and returns
//  it. It can later be free'd with LocalFree.
//
//  NOTE: This code is duped in shlwapi\shellacl.c. If you change it, modify
//        it there as well.

STDAPI_(PTOKEN_USER) GetUserToken(HANDLE hUser)
{
    DWORD dwSize = 64;
    HANDLE hToClose = NULL;

    if (hUser == NULL)
    {
        OpenProcessToken(GetCurrentProcess(), TOKEN_QUERY, &hUser);
        hToClose = hUser;
    }

    PTOKEN_USER pUser = (PTOKEN_USER)LocalAlloc(LPTR, dwSize);
    if (pUser)
    {
        DWORD dwNewSize;
        BOOL fOk = GetTokenInformation(hUser, TokenUser, pUser, dwSize, &dwNewSize);
        if (!fOk && (GetLastError() == ERROR_INSUFFICIENT_BUFFER))
        {
            LocalFree((HLOCAL)pUser);

            pUser = (PTOKEN_USER)LocalAlloc(LPTR, dwNewSize);
            if (pUser)
            {
                fOk = GetTokenInformation(hUser, TokenUser, pUser, dwNewSize, &dwNewSize);
            }
        }
        if (!fOk)
        {
            LocalFree((HLOCAL)pUser);
            pUser = NULL;
        }
    }

    if (hToClose)
    {
        CloseHandle(hToClose);
    }

    return pUser;
}

//  Returns a localalloc'd string containing the text version of the current user's SID.

STDAPI_(LPTSTR) GetUserSid(HANDLE hToken)
{
    LPTSTR pString = NULL;
    PTOKEN_USER pUser = GetUserToken(hToken);
    if (pUser)
    {
        UNICODE_STRING UnicodeString;
        if (STATUS_SUCCESS == RtlConvertSidToUnicodeString(&UnicodeString, pUser->User.Sid, TRUE))
        {
            UINT nChars = (UnicodeString.Length / 2) + 1;
            pString = (LPTSTR)LocalAlloc(LPTR, nChars * sizeof(TCHAR));
            if (pString)
            {
                SHUnicodeToTChar(UnicodeString.Buffer, pString, nChars);
            }
            RtlFreeUnicodeString(&UnicodeString);
        }
        LocalFree((HLOCAL)pUser);
    }
    return pString;
}


/*++

    sets the security attributes for a given privilege.

Arguments:

    PrivilegeName - Name of the privilege we are manipulating.

    NewPrivilegeAttribute - The new attribute value to use.

    OldPrivilegeAttribute - Pointer to receive the old privilege value. OPTIONAL

Return value:

    NO_ERROR or WIN32 error.

--*/

DWORD SetPrivilegeAttribute(LPCTSTR PrivilegeName, DWORD NewPrivilegeAttribute, DWORD *OldPrivilegeAttribute)
{
    LUID             PrivilegeValue;
    TOKEN_PRIVILEGES TokenPrivileges, OldTokenPrivileges;
    DWORD            ReturnLength;
    HANDLE           TokenHandle;

    //
    // First, find out the LUID Value of the privilege
    //

    if (!LookupPrivilegeValue(NULL, PrivilegeName, &PrivilegeValue)) 
    {
        return GetLastError();
    }

    //
    // Get the token handle
    //
    if (!OpenProcessToken(GetCurrentProcess(), TOKEN_ADJUST_PRIVILEGES | TOKEN_QUERY, &TokenHandle)) 
    {
        return GetLastError();
    }

    //
    // Set up the privilege set we will need
    //

    TokenPrivileges.PrivilegeCount = 1;
    TokenPrivileges.Privileges[0].Luid = PrivilegeValue;
    TokenPrivileges.Privileges[0].Attributes = NewPrivilegeAttribute;

    ReturnLength = sizeof( TOKEN_PRIVILEGES );
    if (!AdjustTokenPrivileges (
                TokenHandle,
                FALSE,
                &TokenPrivileges,
                sizeof( TOKEN_PRIVILEGES ),
                &OldTokenPrivileges,
                &ReturnLength
                )) 
    {
        CloseHandle(TokenHandle);
        return GetLastError();
    }
    else 
    {
        if (OldPrivilegeAttribute != NULL) 
        {
            *OldPrivilegeAttribute = OldTokenPrivileges.Privileges[0].Attributes;
        }
        CloseHandle(TokenHandle);
        return NO_ERROR;
    }
}

//
//  Purpose:    Determines if the user is a member of the administrators group.
//
//  Parameters: void
//
//  Return:     TRUE if user is a admin
//              FALSE if not
//  Comments:
//
//  History:    Date        Author     Comment
//              4/12/95     ericflo    Created
//              11/4/99     jeffreys   Use CheckTokenMembership
//

STDAPI_(BOOL) IsUserAnAdmin()
{
    return SHTestTokenMembership(NULL, DOMAIN_ALIAS_RID_ADMINS);
}

// is user a guest but not a full user?
STDAPI_(BOOL) IsUserAGuest()
{
    return SHTestTokenMembership(NULL, DOMAIN_ALIAS_RID_GUESTS);
}

STDAPI_(BOOL) GetUserProfileKey(HANDLE hToken, HKEY *phkey)
{
    LPTSTR pUserSid = GetUserSid(hToken);
    if (pUserSid)
    {
        LONG err = RegOpenKeyEx(HKEY_USERS, pUserSid, 0, KEY_READ | KEY_WRITE, phkey);
        if (err == ERROR_ACCESS_DENIED)
            err = RegOpenKeyEx(HKEY_USERS, pUserSid, 0, KEY_READ, phkey);

        LocalFree(pUserSid);
        return err == ERROR_SUCCESS;
    }
    return FALSE;
}

//
//  Arguments:  phToken     =   Handle to token.
//
//  Returns:    BOOL
//
//  Purpose:    Opens the thread token. If no thread impersonation token is
//              present open the process token.
//
//  History:    2000-02-28  vtan        created


STDAPI_(BOOL) SHOpenEffectiveToken(HANDLE *phToken)
{
    return OpenEffectiveToken(TOKEN_QUERY | TOKEN_ADJUST_PRIVILEGES, phToken);
}

//
//  Arguments:  hToken              =   Handle to token (may be NULL).
//              pszPrivilegeName    =   Name of privilege to check for.
//
//  Returns:    BOOL
//
//  Purpose:    Uses the given token or if no token is specified the effective
//              token and looks through the list of privileges contained in
//              token for a match against the given privilege being checked.
//
//  History:    2000-02-28  vtan        created


STDAPI_(BOOL) SHTestTokenPrivilege(HANDLE hToken, LPCTSTR pszPrivilegeName)
{
    //  Validate privilege name.

    if (pszPrivilegeName == NULL)
    {
        return FALSE;
    }

    BOOL fResult = FALSE;
    HANDLE hTokenToFree = NULL;
    if (hToken == NULL)
    {
        if (SHOpenEffectiveToken(&hTokenToFree) != FALSE)
        {
            hToken = hTokenToFree;
        }
    }
    if (hToken != NULL)
    {
        LUID luidPrivilege;

        if (LookupPrivilegeValue(NULL, pszPrivilegeName, &luidPrivilege) != FALSE)
        {
            DWORD dwTokenPrivilegesSize = 0;
            GetTokenInformation(hToken, TokenPrivileges, NULL, 0, &dwTokenPrivilegesSize);
            TOKEN_PRIVILEGES *pTokenPrivileges = static_cast<TOKEN_PRIVILEGES*>(LocalAlloc(LMEM_FIXED, dwTokenPrivilegesSize));
            if (pTokenPrivileges != NULL)
            {
                DWORD dwReturnLength;

                if (GetTokenInformation(hToken, TokenPrivileges, pTokenPrivileges, dwTokenPrivilegesSize, &dwReturnLength) != FALSE)
                {
                    DWORD   dwIndex;

                    for (dwIndex = 0; !fResult && (dwIndex < pTokenPrivileges->PrivilegeCount); ++dwIndex)
                    {
                        fResult = (RtlEqualLuid(&luidPrivilege, &pTokenPrivileges->Privileges[dwIndex].Luid));
                    }
                }
                (HLOCAL)LocalFree(pTokenPrivileges);
            }
        }
    }
    if (hTokenToFree != NULL)
    {
        TBOOL(CloseHandle(hTokenToFree));
    }
    return fResult;
}

//
//  Arguments:  hToken  =   Handle to token (may be NULL).
//              ulRID   =   RID of local group to test membership of.
//
//  Returns:    BOOL
//
//  Purpose:    Uses advapi32!CheckTokenMembership to test whether the given
//              token is a member of the local group with the specified RID.
//              This function wraps CheckTokenMember and only checks local
//              groups.
//
//  History:    2000-03-22  vtan        created


STDAPI_(BOOL) SHTestTokenMembership(HANDLE hToken, ULONG ulRID)
{
    static  SID_IDENTIFIER_AUTHORITY    sSystemSidAuthority     =   SECURITY_NT_AUTHORITY;

    PSID pSIDLocalGroup;
    BOOL fResult = FALSE;
    if (AllocateAndInitializeSid(&sSystemSidAuthority,
                                 2,
                                 SECURITY_BUILTIN_DOMAIN_RID,
                                 ulRID,
                                 0, 0, 0, 0, 0, 0,
                                 &pSIDLocalGroup) != FALSE)
    {
        if (CheckTokenMembership(hToken, pSIDLocalGroup, &fResult) == FALSE)
        {
            TraceMsg(TF_WARNING, "shell32: SHTestTokenMembership call to advapi32!CheckTokenMembership failed with error %d", GetLastError());
            fResult = FALSE;
        }
        FreeSid(pSIDLocalGroup);
    }
    return fResult;
}

//
//  Arguments:  pszPrivilegeName        =   Name of privilege to be enabled.
//              pfnPrivilegedFunction   =   Pointer to function to invoke.
//              pv                      =   Caller supplied data.
//
//  Returns:    HRESULT
//
//  Purpose:    Enables the given privilege in the current thread's
//              impersonation or primary process' token, invokes the given
//              function pointer with the caller supplied data and then
//              restores the privilege back to its previous state.
//
//  History:    2000-03-13  vtan        created


STDAPI SHInvokePrivilegedFunction(LPCTSTR pszPrivilegeName, PFNPRIVILEGEDFUNCTION pfnPrivilegedFunction, void *pv)
{
    if ((pszPrivilegeName == NULL) || (pfnPrivilegedFunction == NULL))
    {
        return E_INVALIDARG;
    }

    CPrivilegeEnable privilege(pszPrivilegeName);

    return pfnPrivilegedFunction(pv);
}

//
//  Arguments:  <none>
//
//  Returns:    DWORD
//
//  Purpose:    Returns the ID of the active console session.
//
//  History:    2000-03-13  vtan        created


STDAPI_(DWORD)  SHGetActiveConsoleSessionId (void)

{
    return static_cast<DWORD>(USER_SHARED_DATA->ActiveConsoleId);
}

//
//  Arguments:  hToken  =   Handle to the user token.
//
//  Returns:    DWORD
//
//  Purpose:    Returns the session ID associated with the given token. If no
//              token is specified the effective token is used. This will
//              allow a service to call this function when impersonating a
//              client.
//
//              The token must have TOKEN_QUERY access.
//
//  History:    2000-03-13  vtan        created


STDAPI_(DWORD) SHGetUserSessionId(HANDLE hToken)
{
    ULONG   ulUserSessionID = 0;        // default to session 0
    HANDLE  hTokenToFree = NULL;
    if (hToken == NULL)
    {
        TBOOL(SHOpenEffectiveToken(&hTokenToFree));
        hToken = hTokenToFree;
    }
    if (hToken != NULL)
    {
        DWORD dwReturnLength;
        TBOOL(GetTokenInformation(hToken,
                                  TokenSessionId,
                                  &ulUserSessionID,
                                  sizeof(ulUserSessionID),
                                  &dwReturnLength));
    }
    if (hTokenToFree != NULL)
    {
        TBOOL(CloseHandle(hTokenToFree));
    }
    return ulUserSessionID;
}


//
//  Arguments:  <none>
//
//  Returns:    BOOL
//
//  Purpose:    Returns whether the current process is the console session.
//
//  History:    2000-03-27  vtan        created


STDAPI_(BOOL) SHIsCurrentProcessConsoleSession(void)

{
    return USER_SHARED_DATA->ActiveConsoleId == NtCurrentPeb()->SessionId;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\rundll32.c ===
#include "shellprv.h"
#pragma  hdrstop
#include <regstr.h>

TCHAR const c_szRunDll[] = TEXT("rundll32.exe");

//
// Emulate multi-threads with multi-processes.
//
STDAPI_(BOOL) SHRunDLLProcess(HWND hwnd, LPCTSTR pszCmdLine, int nCmdShow, UINT idStr, BOOL fRunAsNewUser)
{
    BOOL bRet;
    HKEY hkey;
    SHELLEXECUTEINFO ExecInfo = {0};
    TCHAR szPath[MAX_PATH];

    // I hate network install. The windows directory is not the windows
    // directory
    szPath[0] = TEXT('\0');
    if (RegOpenKey(HKEY_LOCAL_MACHINE, REGSTR_PATH_SETUP TEXT("\\Setup"), &hkey) == ERROR_SUCCESS)
    {
        DWORD dwType;
        DWORD cbData = SIZEOF(szPath);;
        if (SHQueryValueEx(hkey, TEXT("SharedDir"), NULL, &dwType, (LPBYTE)szPath, &cbData) != ERROR_SUCCESS)
            szPath[0] = TEXT('\0');
        RegCloseKey(hkey);
    }
    PathCombine(szPath, szPath, c_szRunDll);

    DebugMsg(DM_TRACE, TEXT("sh TR - RunDLLProcess (%s)"), pszCmdLine);
    FillExecInfo(ExecInfo, hwnd, NULL, szPath, pszCmdLine, szNULL, nCmdShow);

    // if we want to launch this cpl as a new user, set the verb to be "runas"
    if (fRunAsNewUser)
    {
        ExecInfo.lpVerb = TEXT("runas");
    }
    else
    {
        // normal execute so no ui, we do our own error messages
        ExecInfo.fMask = SEE_MASK_FLAG_NO_UI;
    }

    //
    // We need to put an appropriate message box.
    //
    bRet = ShellExecuteEx(&ExecInfo);

    if (!bRet && !fRunAsNewUser)
    {
        // If we failed and we werent passing fRunAsNewUser, then we put up our own error UI,
        // else, if we were running this as a new user, then we didnt pass SEE_MASK_FLAG_NO_UI
        // so the error is already taken care of for us by shellexec.
        TCHAR szTitle[64];
        DWORD dwErr = GetLastError(); // LoadString can stomp on this (on failure)
        LoadString(HINST_THISDLL, idStr, szTitle, ARRAYSIZE(szTitle));
        ExecInfo.fMask = 0;
        _ShellExecuteError(&ExecInfo, szTitle, dwErr);
    }

    return bRet;
}

LRESULT CALLBACK WndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam)
{
    switch(uMsg)
    {
    case STUBM_SETICONTITLE:
        if (lParam)
            SetWindowText(hWnd, (LPCTSTR)lParam);
        if (wParam)
            SendMessage(hWnd, WM_SETICON, ICON_BIG, wParam);
        break;

    case STUBM_SETDATA:
        SetWindowLongPtr(hWnd, 0, wParam);
        break;
        
    case STUBM_GETDATA:
        return GetWindowLong(hWnd, 0);
        
    default:
        return DefWindowProc(hWnd, uMsg, wParam, lParam) ;
    }
    
    return 0;
}


HWND _CreateStubWindow(POINT * ppt, HWND hwndParent)
{
    WNDCLASS wc;
    int cx, cy;
    // If the stub window is parented, then we want it to be a tool window. This prevents activation
    // problems when this is used in multimon for positioning.

    DWORD dwExStyle = hwndParent? WS_EX_TOOLWINDOW : WS_EX_APPWINDOW;
    if (!GetClassInfo(HINST_THISDLL, c_szStubWindowClass, &wc))
    {
        wc.style         = 0;
        wc.lpfnWndProc   = WndProc;
        wc.cbClsExtra    = 0;
        wc.cbWndExtra    = SIZEOF(DWORD) * 2;
        wc.hInstance     = HINST_THISDLL;
        wc.hIcon         = NULL;
        wc.hCursor       = LoadCursor (NULL, IDC_ARROW);
        wc.hbrBackground = GetStockObject (WHITE_BRUSH);
        wc.lpszMenuName  = NULL;
        wc.lpszClassName = c_szStubWindowClass;

        RegisterClass(&wc);
    }

    cx = cy = CW_USEDEFAULT;
    if (ppt)
    {
        cx = (int)ppt->x;
        cy = (int)ppt->y;
    }

    if (IS_BIDI_LOCALIZED_SYSTEM()) 
    {
        dwExStyle |= dwExStyleRTLMirrorWnd;
    }
    
    // WS_EX_APPWINDOW makes this show up in ALT+TAB, but not the tray.
        
    return CreateWindowEx(dwExStyle, c_szStubWindowClass, c_szNULL, hwndParent? WS_POPUP : WS_OVERLAPPED, cx, cy, 0, 0, hwndParent, NULL, HINST_THISDLL, NULL);
}


typedef struct  // dlle
{
    HINSTANCE  hinst;
    RUNDLLPROC lpfn;
    BOOL       fCmdIsANSI;
} DLLENTRY;


BOOL _InitializeDLLEntry(LPTSTR lpszCmdLine, DLLENTRY * pdlle)
{
    LPTSTR lpStart, lpEnd, lpFunction;

    DebugMsg(DM_TRACE, TEXT("sh TR - RunDLLThread (%s)"), lpszCmdLine);

    for (lpStart=lpszCmdLine; ; )
    {
        // Skip leading blanks
        //
        while (*lpStart == TEXT(' '))
        {
            ++lpStart;
        }

                // Check if there are any switches
                //
        if (*lpStart != TEXT('/'))
        {
            break;
        }

                // Look at all the switches; ignore unknown ones
                //
        for (++lpStart; ; ++lpStart)
        {
            switch (*lpStart)
            {
                case TEXT(' '):
                case TEXT('\0'):
                    goto EndSwitches;
                    break;

                        // Put any switches we care about here
                        //

                default:
                    break;
            }
        }
EndSwitches:
        ;
    }

        // We have found the DLL,FN parameter
        //
    lpEnd = StrChr(lpStart, TEXT(' '));
    if (lpEnd)
    {
        *lpEnd++ = TEXT('\0');
    }

        // There must be a DLL name and a function name
        //
    lpFunction = StrChr(lpStart, TEXT(','));
    if (!lpFunction)
    {
        return(FALSE);
    }
    *lpFunction++ = TEXT('\0');

        // Load the library and get the procedure address
        // Note that we try to get a module handle first, so we don't need
        // to pass full file names around
        //
    pdlle->hinst = GetModuleHandle(lpStart);
    if (pdlle->hinst)
    {
        TCHAR szName[MAXPATHLEN];

        GetModuleFileName(pdlle->hinst, szName, ARRAYSIZE(szName));
        LoadLibrary(szName);
    }
    else
    {
        pdlle->hinst = LoadLibrary(lpStart);
        if (!ISVALIDHINSTANCE(pdlle->hinst))
        {
            return(FALSE);
        }
    }

#ifdef UNICODE
    {
        /*
         * Look for a 'W' tagged Unicode function.
         * If it is not there, then look for the 'A' tagged ANSI function
         * if we cant find that one either, then look for an un-tagged function
         */
        LPSTR pszFunctionName;
        UINT cchLength;

        cchLength = lstrlen(lpFunction)+1;
        pdlle->fCmdIsANSI = FALSE;

        pszFunctionName = (LPSTR)LocalAlloc(LMEM_FIXED, (cchLength+1)*2);    // +1 for "W",  *2 for DBCS

        if (pszFunctionName && (WideCharToMultiByte (CP_ACP, 0, lpFunction, cchLength,
            pszFunctionName, cchLength*2, NULL, NULL))) {

            cchLength = lstrlenA(pszFunctionName);
            pszFunctionName[cchLength] = 'W';        // convert name to Wide version
            pszFunctionName[cchLength+1] = '\0';

            pdlle->lpfn = (RUNDLLPROC)GetProcAddress(pdlle->hinst, pszFunctionName);

            if (pdlle->lpfn == NULL) {
                    // No UNICODE version, try for ANSI
                pszFunctionName[cchLength] = 'A';        // convert name to ANSI version
                pdlle->fCmdIsANSI = TRUE;

                pdlle->lpfn = (RUNDLLPROC)GetProcAddress(pdlle->hinst, pszFunctionName);

                if (pdlle->lpfn == NULL) {
                        // No ANSI version either, try for non-tagged
                    pszFunctionName[cchLength] = '\0';        // convert name to ANSI version

                    pdlle->lpfn = (RUNDLLPROC)GetProcAddress(pdlle->hinst, pszFunctionName);
                }
            }
        }
        if (pszFunctionName) {
            LocalFree((LPVOID)pszFunctionName);
        }
    }
    
#else
    {
        /*
         * Look for 'A' tagged ANSI version.
         * If it is not there, then look for a non-tagged function.
         */
        LPSTR pszFunction;
        int  cchFunction;

        pdlle->lpfn = NULL;

        cchFunction = lstrlen(lpFunction);

        pszFunction = LocalAlloc(LMEM_FIXED, cchFunction + sizeof(CHAR) * 2);  // string + 'A' + '\0'
        if (pszFunction != NULL)
        {
            CopyMemory(pszFunction, lpFunction, cchFunction);

            pszFunction[cchFunction++] = 'A';
            pszFunction[cchFunction] = '\0';

            pdlle->lpfn = (RUNDLLPROC)GetProcAddress(pdlle->hinst, pszFunction);

            LocalFree(pszFunction);
        }
    }

#endif

    if (!pdlle->lpfn)
    {
        FreeLibrary(pdlle->hinst);
        return(FALSE);
    }

        // Copy the rest of the command parameters down
        //
    if (lpEnd)
    {
        lstrcpy(lpszCmdLine, lpEnd);
    }
    else
    {
        *lpszCmdLine = TEXT('\0');
    }

    return(TRUE);
}

typedef struct tagRunThreadParam {
    int nCmdShow;
    TCHAR szCmdLine[1];
} RUNTHREADPARAM;

DWORD WINAPI _ThreadInitDLL(LPVOID pv)
{
    RUNTHREADPARAM * prtp = (RUNTHREADPARAM*)pv;
    LPTSTR pszCmdLine = (LPTSTR)&prtp->szCmdLine;
    DLLENTRY dlle;

    if (_InitializeDLLEntry(pszCmdLine, &dlle))
    {
        HWND hwndStub=_CreateStubWindow(NULL, NULL);
        if (hwndStub)
        {
            ULONG cchCmdLine = 0;
            SetForegroundWindow(hwndStub);
#ifdef UNICODE
            if (dlle.fCmdIsANSI)
            {
                //
                // If the function is an ANSI version 
                // Change the command line parameter strings to ANSI before we call the function
                // 
                int cchCmdLine = lstrlen(pszCmdLine);

                LPVOID pszCommand = LocalAlloc(LMEM_FIXED, sizeof(char) * (cchCmdLine + 1));
                if (pszCommand)
                {
                    WideCharToMultiByte(CP_ACP, 0, pszCmdLine, -1, pszCommand, cchCmdLine, NULL, NULL);
                }
                dlle.lpfn(hwndStub, g_hinst, pszCommand, prtp->nCmdShow);

            }
            else
#endif
            {
                dlle.lpfn(hwndStub, g_hinst, pszCmdLine, prtp->nCmdShow);
            }
            
            DestroyWindow(hwndStub);
        }
        FreeLibrary(dlle.hinst);
    }

    LocalFree((HLOCAL)prtp);

    return 0;
}

BOOL WINAPI SHRunDLLThread(HWND hwnd, LPCTSTR pszCmdLine, int nCmdShow)
{
    BOOL fSuccess = FALSE; // assume error

    // don't need +1 on lstrlen since szCmdLine is already of size 1 (for NULL)
    RUNTHREADPARAM * prtp = LocalAlloc(LPTR, sizeof(RUNTHREADPARAM) + (lstrlen(pszCmdLine) * sizeof(TCHAR)));

    if (prtp)
    {
        DWORD idThread;
        HANDLE hthread;

        lstrcpy(prtp->szCmdLine, pszCmdLine);

        hthread = CreateThread(NULL, 0, _ThreadInitDLL, prtp, 0, &idThread);
        if (hthread)
        {
            // We don't need to communicate with this thread any more.
            // Close the handle and let it run and terminate itself.
            //
            // Notes: In this case, prtp will be freed by the thread.
            //
            CloseHandle(hthread);
            fSuccess = TRUE;
        }
        else
        {
            // Thread creation failed, we should free the buffer.
            LocalFree((HLOCAL)prtp);
        }
    }

    return fSuccess;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\sfstorage.cpp ===
#include "shellprv.h"
#include "prop.h"

#include "../inc/sfstorage.cpp"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\sfstorage.h ===
#include "../inc/sfstorage.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\shell\shell32\sencrypt.cpp ===
#include "shellprv.h"
#include "propsht.h"
#include "sencrypt.h"
#include "datautil.h"

#define IDM_ENCRYPT 0
#define IDM_DECRYPT 1
#define BOOL_UNINIT 5

// Local fns to this .cpp file
STDAPI CEncryptionContextMenuHandler_CreateInstance(IUnknown *punk, REFIID riid, void **ppv);
BOOL InitSinglePrshtNoDlg(FILEPROPSHEETPAGE * pfpsp);
BOOL InitMultiplePrshtNoDlg(FILEPROPSHEETPAGE* pfpsp);

// Class definition
class CEncryptionContextMenu : public IShellExtInit, public IContextMenu
{
public:
    CEncryptionContextMenu();
    HRESULT Init_FolderContentsInfo();
    
    // IUnknown
    STDMETHODIMP QueryInterface(REFIID riid, void **ppv);
    STDMETHODIMP_(ULONG) AddRef(void);
    STDMETHODIMP_(ULONG) Release(void);
    
    // IContextMenu
    STDMETHODIMP QueryContextMenu(HMENU hmenu, UINT indexMenu, UINT idCmdFirst, UINT idCmdLast, UINT uFlags);
    STDMETHODIMP InvokeCommand(LPCMINVOKECOMMANDINFO pici);
    STDMETHODIMP GetCommandString(UINT_PTR idCmd, UINT uType, UINT *pRes, LPSTR pszName, UINT cchMax);
     
    // IShellExtInit
    STDMETHODIMP Initialize(LPCITEMIDLIST pidlFolder, IDataObject *pdtobj, HKEY hkeyProgID);

private:
    virtual ~CEncryptionContextMenu();
    static DWORD CALLBACK EncryptThreadProc(void *pv) { return ((CEncryptionContextMenu *) pv)->_Encrypt(); };
    DWORD _Encrypt();
    BOOL _InitPrsht(FILEPROPSHEETPAGE * pfpsp);
    BOOL _AreFilesEncryptable(IDataObject *pdtobj);

    LONG _cRef;                 // Reference count
    UINT _uFileCount;           // number of files selected
    HWND _hwnd;                 // Window that we're working over
    BOOL _fEncrypt;             // If true, do encrypt; if false, do decrypt
    FILEPROPSHEETPAGE _fpsp;    // Prop sheet page to be filled in and run through properties funcs
    BOOL _fEncryptAllowed;      // True iff we are allowed to encrypt
    IDataObject *_pdtobj;       // Our data object.  Keep in orig. thread
    TCHAR _szPath[MAX_PATH];    // Path of first thing clicked on
};


// Constructor & Destructor
CEncryptionContextMenu::CEncryptionContextMenu() : _cRef(1)
{   
    DllAddRef();

    _fEncryptAllowed = FALSE;   // compute this at ::Initialize() time

    _uFileCount = 0;
    _hwnd = 0;
    _fEncrypt = FALSE;
    _pdtobj = NULL;
    ZeroMemory(&_fpsp, sizeof(_fpsp));
}

CEncryptionContextMenu::~CEncryptionContextMenu()
{
    ATOMICRELEASE(_pdtobj);
    if (_fpsp.pfci)
    {
        Release_FolderContentsInfo(_fpsp.pfci);
    }
    DllRelease();
}

HRESULT CEncryptionContextMenu::Init_FolderContentsInfo()
{
    HRESULT hr = E_OUTOFMEMORY;
    _fpsp.pfci = Create_FolderContentsInfo();
    if (_fpsp.pfci)
    {
        hr = S_OK;
    }
    return hr;
}

// IUnknown implementation.  Standard stuff, nothing fancy.
HRESULT CEncryptionContextMenu::QueryInterface(REFIID riid, void **ppvObj)
{
    static const QITAB qit[] = {
        QITABENT(CEncryptionContextMenu, IShellExtInit),
        QITABENT(CEncryptionContextMenu, IContextMenu),
        { 0 },
    };
    return QISearch(this, qit, riid, ppvObj);
}

ULONG CEncryptionContextMenu::AddRef()
{
    return InterlockedIncrement(&_cRef);
}

ULONG CEncryptionContextMenu::Release()
{
    if (InterlockedDecrement(&_cRef))
        return _cRef;
    
    delete this;
    return 0;
}

// IShellExtInit implementation

STDMETHODIMP CEncryptionContextMenu::Initialize(LPCITEMIDLIST pidlFolder, IDataObject *pdtobj, HKEY hkeyProgID)
{   
    HRESULT hr = S_FALSE;
    
    // registry key that enables/disables this menu
    BOOL fEnableEncryptMenu = SHRegGetBoolUSValue(TEXT("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Explorer\\Advanced"), 
                TEXT("EncryptionContextMenu"), 0, 0);

    if (fEnableEncryptMenu && !SHRestricted(REST_NOENCRYPTION) && !_fEncryptAllowed)
    {
        _fEncryptAllowed = _AreFilesEncryptable(pdtobj);
        if (_fEncryptAllowed)
        {
            IUnknown_Set((IUnknown **)&_pdtobj, pdtobj);
            hr = S_OK;
        }
    }
    
    return hr;
}

// Checks the data object to see if we can encrypt here.
BOOL CEncryptionContextMenu::_AreFilesEncryptable(IDataObject *pdtobj)
{
    BOOL fSuccess = FALSE;
 
    STGMEDIUM medium;
    FORMATETC fe = {CF_HDROP, NULL, DVASPECT_CONTENT, -1, TYMED_HGLOBAL};
    if (SUCCEEDED(pdtobj->GetData(&fe, &medium)))
    {
        // Get the file name from the CF_HDROP.
        _uFileCount = DragQueryFile((HDROP)medium.hGlobal, (UINT)-1, NULL, 0);
        if (_uFileCount)
        {
            if (DragQueryFile((HDROP)medium.hGlobal, 0, _szPath, ARRAYSIZE(_szPath)))
            {
                TCHAR szFileSys[MAX_PATH];
                fSuccess = (FS_FILE_ENCRYPTION & GetVolumeFlags(_szPath, szFileSys, ARRAYSIZE(szFileSys)));
            }
        }
        ReleaseStgMedium(&medium);
    }
    return fSuccess;
}
    
// IContextMenuHandler impelementation
STDMETHODIMP CEncryptionContextMenu::QueryContextMenu(HMENU hmenu, UINT indexMenu, 
                                                      UINT idCmdFirst, UINT idCmdLast, UINT uFlags)
{
    HRESULT hr = E_FAIL;

    if ((uFlags & CMF_DEFAULTONLY) || !_fEncryptAllowed) 
    {
        hr = MAKE_HRESULT(SEVERITY_SUCCESS, 0, USHORT(1));  //this menu only allows the defaults or we can't encrypt
    }
    else
    {
        TCHAR szEncryptMsg[128], szDecryptMsg[128];

        // If only one item is selected, display enc or dec as appropriate
        if (_uFileCount == 1)
        {
            DWORD dwAttribs = GetFileAttributes(_szPath);
            if (dwAttribs != (DWORD)-1)
            {
                LoadString(HINST_THISDLL, IDS_ECM_ENCRYPT, szEncryptMsg, ARRAYSIZE(szEncryptMsg));
                if (!(dwAttribs & FILE_ATTRIBUTE_ENCRYPTED))
                {
                    if (InsertMenu(hmenu, 
                        indexMenu, 
                        MF_STRING | MF_BYPOSITION, 
                        idCmdFirst + IDM_ENCRYPT, 
                        szEncryptMsg))
                    {
                        hr = MAKE_HRESULT(SEVERITY_SUCCESS, 0, USHORT(IDM_ENCRYPT + 1));
                    }
                }
                else
                {
                    LoadString(HINST_THISDLL, IDS_ECM_DECRYPT, szDecryptMsg, ARRAYSIZE(szDecryptMsg));
                    if (InsertMenu(hmenu, 
                        inde