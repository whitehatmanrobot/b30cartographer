L,
                reserved,
                (LPSTORAGE FAR*)&lpRootStg
            );

        if (hr == NOERROR)
            return lpRootStg;     // existing file successfully opened

        OleDbgOutHResult(TEXT("StgOpenStorage returned"), hr);
    }

    if (0 == LoadString(ghInst, IDS_OLESTDNOOPENFILE, szMsg, 64))
      return NULL;

    MessageBox(NULL, (LPTSTR)szMsg, NULL,MB_ICONEXCLAMATION | MB_OK);
    return NULL;
}


/*************************************************************************
** OpenOrCreateRootStorage
**    open a root level Storage given a filename that is compatible
**    to be used by a top-level OLE container. if the filename
**    specifies an existing file, then it is open, otherwise a new file
**    with the given name is created.
**    the root storage (Docfile) that is created by this function
**    is suitable to be used to create child storages for embedings.
**    (CreateChildStorage can be used to create child storages.)
**    NOTE: the root-level storage is opened in transacted mode.
*************************************************************************/

STDAPI_(LPSTORAGE) OleStdOpenOrCreateRootStorage(LPTSTR lpszStgName, DWORD grfMode)
{
    HRESULT hrErr;
    SCODE sc;
    DWORD reserved = 0;
    LPSTORAGE lpRootStg;
    TCHAR      szMsg[64];

    if (lpszStgName) {

        hrErr = StgOpenStorageA(
                lpszStgName,
                NULL,
                grfMode | STGM_READWRITE | STGM_TRANSACTED,
                NULL,
                reserved,
                (LPSTORAGE FAR*)&lpRootStg
        );

        if (hrErr == NOERROR)
            return lpRootStg;      // existing file successfully opened

        OleDbgOutHResult(TEXT("StgOpenStorage returned"), hrErr);
        sc = GetScode(hrErr);

        if (sc!=STG_E_FILENOTFOUND && sc!=STG_E_FILEALREADYEXISTS) {
            return NULL;
        }
    }

    /* if file did not already exist, try to create a new one */
    hrErr = StgCreateDocfileA(
            lpszStgName,
            grfMode | STGM_READWRITE | STGM_TRANSACTED,
            reserved,
            (LPSTORAGE FAR*)&lpRootStg
    );

    if (hrErr == NOERROR)
        return lpRootStg;               // existing file successfully opened

    OleDbgOutHResult(TEXT("StgCreateDocfile returned"), hrErr);

    if (0 == LoadString(ghInst, IDS_OLESTDNOCREATEFILE, (LPTSTR)szMsg, 64))
      return NULL;

    MessageBox(NULL, (LPTSTR)szMsg, NULL, MB_ICONEXCLAMATION | MB_OK);
    return NULL;
}


/*
** OleStdCreateChildStorage
**    create a child Storage inside the given lpStg that is compatible
**    to be used by an embedded OLE object. the return value from this
**    function can be passed to OleCreateXXX functions.
**    NOTE: the child storage is opened in transacted mode.
*/
STDAPI_(LPSTORAGE) OleStdCreateChildStorage(LPSTORAGE lpStg, LPTSTR lpszStgName)
{
    if (lpStg != NULL) {
        LPSTORAGE lpChildStg;
        DWORD grfMode = (STGM_READWRITE | STGM_TRANSACTED |
                STGM_SHARE_EXCLUSIVE);
        DWORD reserved = 0;

        HRESULT hrErr = CallIStorageCreateStorageA(
                lpStg,
                lpszStgName,
                grfMode,
                reserved,
                reserved,
                (LPSTORAGE FAR*)&lpChildStg
            );

        if (hrErr == NOERROR)
            return lpChildStg;

        OleDbgOutHResult(TEXT("lpStg->lpVtbl->CreateStorage returned"), hrErr);
    }
    return NULL;
}


/*
** OleStdOpenChildStorage
**    open a child Storage inside the given lpStg that is compatible
**    to be used by an embedded OLE object. the return value from this
**    function can be passed to OleLoad function.
**    NOTE: the child storage is opened in transacted mode.
*/
STDAPI_(LPSTORAGE) OleStdOpenChildStorage(LPSTORAGE lpStg, LPTSTR lpszStgName, DWORD grfMode)
{
    LPSTORAGE lpChildStg;
    LPSTORAGE lpstgPriority = NULL;
    DWORD reserved = 0;
    HRESULT hrErr;

    if (lpStg  != NULL) {

        hrErr = CallIStorageOpenStorageA(
                lpStg,
                lpszStgName,
                lpstgPriority,
                grfMode | STGM_TRANSACTED | STGM_SHARE_EXCLUSIVE,
                NULL,
                reserved,
                (LPSTORAGE FAR*)&lpChildStg
            );

        if (hrErr == NOERROR)
            return lpChildStg;

        OleDbgOutHResult(TEXT("lpStg->lpVtbl->OpenStorage returned"), hrErr);
    }
    return NULL;
}


/* OleStdCommitStorage
** -------------------
**    Commit the changes to the given IStorage*. This routine can be
**    called on either a root-level storage as used by an OLE-Container
**    or by a child storage as used by an embedded object.
**
**    This routine first attempts to perform this commit in a safe
**    manner. if this fails it then attempts to do the commit in a less
**    robust manner (STGC_OVERWRITE).
*/
STDAPI_(BOOL) OleStdCommitStorage(LPSTORAGE lpStg)
{
    HRESULT hrErr;

    // make the changes permanent
    hrErr = lpStg->lpVtbl->Commit(lpStg, 0);

    if (GetScode(hrErr) == STG_E_MEDIUMFULL) {
        // try to commit changes in less robust manner.
        OleDbgOut(TEXT("Warning: commiting with STGC_OVERWRITE specified\n"));
        hrErr = lpStg->lpVtbl->Commit(lpStg, STGC_OVERWRITE);
    }

    if (hrErr != NOERROR)
    {
        TCHAR szMsg[64];

        if (0 == LoadString(ghInst, IDS_OLESTDDISKFULL, (LPTSTR)szMsg, 64))
           return FALSE;

        MessageBox(NULL, (LPTSTR)szMsg, NULL, MB_ICONEXCLAMATION | MB_OK);
        return FALSE;
    }
    else {
        return TRUE;
    }
}


/* OleStdDestroyAllElements
** ------------------------
**    Destroy all elements within an open storage. this is subject
**    to the current transaction.
*/
STDAPI OleStdDestroyAllElements(LPSTORAGE lpStg)
{
    IEnumSTATSTG FAR* lpEnum;
    STATSTG sstg;
    HRESULT hrErr;

    hrErr = lpStg->lpVtbl->EnumElements(
            lpStg, 0, NULL, 0, (IEnumSTATSTG FAR* FAR*)&lpEnum);

    if (hrErr != NOERROR)
        return hrErr;

    while (1) {
        if (lpEnum->lpVtbl->Next(lpEnum, 1, &sstg, NULL) != NOERROR)
            break;
        lpStg->lpVtbl->DestroyElement(lpStg, sstg.pwcsName);
        OleStdFree(sstg.pwcsName);
    }
    lpEnum->lpVtbl->Release(lpEnum);
    return NOERROR;
}

// returns 1 for a close match
//  (all fields match exactly except the tymed which simply overlaps)
// 0 for no match

int IsCloseFormatEtc(FORMATETC FAR* pFetcLeft, FORMATETC FAR* pFetcRight)
{
        if (pFetcLeft->cfFormat != pFetcRight->cfFormat)
                return 0;
        else if (!OleStdCompareTargetDevice (pFetcLeft->ptd, pFetcRight->ptd))
                return 0;
        if (pFetcLeft->dwAspect != pFetcRight->dwAspect)
                return 0;
        return((pFetcLeft->tymed | pFetcRight->tymed) != 0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\letest\ole2ui\olestr.c ===
void CopyAndFreeOLESTR(LPOLESTR polestr, char **ppszOut)
{
    // See if there is any work
    if (polestr == NULL)
    {
	if (ppszOut != NULL)
	{
	    // Output string requested so set it to NULL.
	    *ppszOut = NULL;
	}

	return;
    }

    // Get the public memory allocator

    if (pszOut)
    {
	// Copy of string converted to ANSI is requested
    }

    // Free the original string
}

LPOLESTR CreateOLESTR(char *pszIn)
{
    // Get the public memory allocator

    // Allocate the string

    // Convert the string
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\letest\ole2ui\olestr.h ===
#ifndef _OLESTR_H_
#define _OLESTR_H_

void CopyAndFreeOLESTR(LPOLESTR polestr, char **pszOut);

void CopyAndFreeSTR(LPSTR polestr, LPOLESTR *pszOut);

LPOLESTR CreateOLESTR(const char *pszIn);
LPSTR CreateSTR(LPCOLESTR pszIn);

#define CREATEOLESTR(x, y) LPOLESTR x = CreateOLESTR(y);

#define CREATESTR(x, y) LPSTR x = CreateSTR(y);

#define FREEOLESTR(x) CopyAndFreeOLESTR(x, NULL);

#define FREESTR(x) CopyAndFreeSTR(x, NULL);



#endif // _OLESTR_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\letest\ole2ui\olethunk.h ===
#ifndef _OLETHUNK_H_
#define _OLETHUNK_H_

//
//  String Conversion Helpers
//
STDAPI_(void) CopyAndFreeOLESTR(LPOLESTR polestr, char **pszOut);

STDAPI_(void) CopyAndFreeSTR(LPSTR polestr, LPOLESTR *pszOut);

STDAPI_(LPOLESTR) CreateOLESTR(const char *pszIn);

STDAPI_(LPSTR) CreateSTR(LPCOLESTR pszIn);

#define CREATEOLESTR(x, y) LPOLESTR x = CreateOLESTR(y);

#define CREATESTR(x, y) LPSTR x = CreateSTR(y);

#define FREEOLESTR(x) CopyAndFreeOLESTR(x, NULL);

#define FREESTR(x) CopyAndFreeSTR(x, NULL);

//
//  OLE API Thunks
//
STDAPI_(void) CLSIDFromStringA(LPSTR pszClass, LPCLSID pclsid);

STDAPI CLSIDFromProgIDA(LPCSTR lpszProgID, LPCLSID lpclsid);

STDAPI	CreateFileMonikerA(LPSTR lpszPathName, LPMONIKER FAR* ppmk);

STDAPI	CreateItemMonikerA(
    LPSTR lpszDelim,
    LPSTR lpszItem,
    LPMONIKER FAR* ppmk);

STDAPI	GetClassFileA(LPCSTR szFilename, CLSID FAR* pclsid);

STDAPI MkParseDisplayNameA(
    LPBC pbc,
    LPSTR szUserName,
    ULONG FAR * pchEaten,
    LPMONIKER FAR * ppmk);

STDAPI	OleCreateFromFileA(
    REFCLSID rclsid,
    LPCSTR lpszFileName,
    REFIID riid,
    DWORD renderopt,
    LPFORMATETC lpFormatEtc,
    LPOLECLIENTSITE pClientSite,
    LPSTORAGE pStg,
    LPVOID FAR* ppvObj);

STDAPI	OleCreateLinkToFileA(
    LPCSTR lpszFileName,
    REFIID riid,
    DWORD renderopt,
    LPFORMATETC lpFormatEtc,
    LPOLECLIENTSITE pClientSite,
    LPSTORAGE pStg,
    LPVOID FAR* ppvObj);

STDAPI_(HGLOBAL) OleGetIconOfClassA(
    REFCLSID rclsid,
    LPSTR lpszLabel,
    BOOL fUseTypeAsLabel);

STDAPI_(HGLOBAL) OleGetIconOfFileA(LPSTR lpszPath, BOOL fUseFileAsLabel);

STDAPI_(HGLOBAL) OleMetafilePictFromIconAndLabelA(
    HICON hIcon,
    LPSTR lpszLabel,
    LPSTR lpszSourceFile,
    UINT iIconIndex);

STDAPI OleRegGetUserTypeA(
    REFCLSID clsid,
    DWORD dwFormOfType,
    LPSTR FAR* pszUserType);

STDAPI ProgIDFromCLSIDA(REFCLSID clsid, LPSTR FAR* lplpszProgID);

STDAPI ReadFmtUserTypeStgA(
    LPSTORAGE pstg,
    CLIPFORMAT FAR* pcf,
    LPSTR FAR* lplpszUserType);

STDAPI StgCreateDocfileA(
    LPCSTR pwcsName,
    DWORD grfMode,
    DWORD reserved,
    IStorage FAR * FAR *ppstgOpen);

STDAPI StgOpenStorageA(
    LPCSTR pwcsName,
    IStorage FAR *pstgPriority,
    DWORD grfMode,
    SNB snbExclude,
    DWORD reserved,
    IStorage FAR * FAR *ppstgOpen);

STDAPI StgSetTimesA(
    LPSTR lpszName,
    FILETIME const FAR* pctime,
    FILETIME const FAR* patime,
    FILETIME const FAR* pmtime);


STDAPI_(void) StringFromCLSIDA(REFCLSID rclsid, LPSTR *lplpszCLSID);

STDAPI WriteFmtUserTypeStgA(
    LPSTORAGE pstg,
    CLIPFORMAT cf,
    LPSTR lpszUserType);



//
//  Method Thunks
//
STDAPI CallIMonikerGetDisplayNameA(
    LPMONIKER lpmk,
    IBindCtx *pbc,
    IMoniker *pmkToLeft,
    LPSTR *ppszDisplayName);

STDAPI CallIOleLinkGetSourceDisplayNameA(
    IOleLink FAR *polelink,
    LPSTR *ppszDisplayName);

STDAPI CallIOleLinkSetSourceDisplayNameA(
    IOleLink FAR *polelink,
    LPCSTR pszStatusText);

STDAPI CallIOleInPlaceFrameSetStatusTextA(
    IOleInPlaceFrame *poleinplc,
    LPCSTR pszStatusText);
    
STDAPI CallIOleInPlaceUIWindowSetActiveObjectA(
    IOleInPlaceUIWindow FAR *lpthis,
    IOleInPlaceActiveObject *pActiveObject,
    LPCSTR pszObjName);

STDAPI CallIOleObjectGetUserTypeA(
    LPOLEOBJECT lpOleObject,
    DWORD dwFormOfType,
    LPSTR *pszUserType);

STDAPI CallIOleObjectSetHostNamesA(
    LPOLEOBJECT lpOleObject,
    LPCSTR szContainerApp,
    LPCSTR szContainerObj);

STDAPI CallIStorageCreateStorageA(
    LPSTORAGE lpStg,
    const char *pwcsName,
    DWORD grfMode,
    DWORD dwStgFmt,
    DWORD reserved2,
    IStorage **ppstg);

STDAPI CallIStorageDestroyElementA(
    LPSTORAGE lpStg,
    LPSTR pszName);

STDAPI CallIStorageOpenStorageA(
    LPSTORAGE lpStg,
    const char *pszName,
    IStorage *pstgPriority,
    DWORD grfMode,
    SNB snbExclude,
    DWORD reserved,
    IStorage **ppstg);

STDAPI CallIStorageCreateStreamA(
    LPSTORAGE lpStg,
    LPSTR pszName,
    DWORD grfMode,
    DWORD reserved1,
    DWORD reserved2,
    IStream **ppstm);

STDAPI CallIStorageOpenStreamA(
    LPSTORAGE lpStg,
    LPSTR pszName,
    void *reserved1,
    DWORD grfMode,
    DWORD reserved2,
    IStream **ppstm);


#endif // _OLETHUNK_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\letest\ole2ui\pastespl.h ===
/*
 * PASTESPL.H
 *
 * Internal definitions, structures, and function prototypes for the
 * OLE 2.0 UI Paste Special dialog.
 *
 * Copyright (c)1992 Microsoft Corporation, All Right Reserved
 */

#ifndef _PASTESPL_H_
#define _PASTESPL_H_

#ifndef RC_INVOKED
#pragma message ("INCLUDING PASTESPL.H from " __FILE__)
#endif  /* RC_INVOKED */


// Length of buffers to hold the strings 'Unknown Type', Unknown Source'
//   and 'the application which created it'
#define PS_UNKNOWNSTRLEN               100

//Property label used to store clipboard viewer chain information
#define NEXTCBVIEWER        TEXT("NextCBViewer")

//Internally used structure
typedef struct tagPASTESPECIAL
{
    //Keep this item first as the Standard* functions depend on it here.
    LPOLEUIPASTESPECIAL  lpOPS;                //Original structure passed.

    /*
     * What we store extra in this structure besides the original caller's
     * pointer are those fields that we need to modify during the life of
     * the dialog but that we don't want to change in the original structure
     * until the user presses OK.
     */

    DWORD                dwFlags;              // Local copy of paste special flags

    int                  nPasteListCurSel;     // Save the selection the user made last
    int                  nPasteLinkListCurSel; //    in the paste and pastelink lists
    int                  nSelectedIndex;       // Index in arrPasteEntries[] corresponding to user selection
    BOOL                 fLink;                // Indicates if Paste or PasteLink was selected by user

    HGLOBAL              hBuff;                // Scratch Buffer for building up strings
    TCHAR                szUnknownType[PS_UNKNOWNSTRLEN];    // Buffer for 'Unknown Type' string
    TCHAR                szUnknownSource[PS_UNKNOWNSTRLEN];  // Buffer for 'Unknown Source' string
    TCHAR                szAppName[OLEUI_CCHKEYMAX]; // Application name of Source. Used in the result text
                                                     //   when Paste is selected. Obtained using clsidOD.

    // Information obtained from OBJECTDESCRIPTOR. This information is accessed when the Paste
    //    radio button is selected.
    CLSID                clsidOD;              // ClassID of source
    SIZEL                sizelOD;              // sizel transfered in
                                               //  ObjectDescriptor
    LPTSTR               szFullUserTypeNameOD; // Full User Type Name
    LPTSTR               szSourceOfDataOD;     // Source of Data
    BOOL                 fSrcAspectIconOD;     // Does Source specify DVASPECT_ICON?
    BOOL                 fSrcOnlyIconicOD;     // Does Source specify OLEMISC_ONLYICONIC?
    HGLOBAL              hMetaPictOD;          // Metafile containing icon and icon title
    HGLOBAL              hObjDesc;             // Handle to OBJECTDESCRIPTOR structure from which the
                                               //   above information is obtained

    // Information obtained from LINKSRCDESCRIPTOR. This infomation is accessed when the PasteLink
    //   radio button is selected.
    CLSID                clsidLSD;             // ClassID of source
    SIZEL                sizelLSD;             // sizel transfered in
                                               //  LinkSrcDescriptor
    LPTSTR               szFullUserTypeNameLSD;// Full User Type Name
    LPTSTR               szSourceOfDataLSD;    // Source of Data
    BOOL                 fSrcAspectIconLSD;    // Does Source specify DVASPECT_ICON?
    BOOL                 fSrcOnlyIconicLSD;    // Does Source specify OLEMISC_ONLYICONIC?
    HGLOBAL              hMetaPictLSD;         // Metafile containing icon and icon title
    HGLOBAL              hLinkSrcDesc;         // Handle to LINKSRCDESCRIPTOR structure from which the
                                               //   above information is obtained

    BOOL                 fClipboardChanged;    // Has clipboard content changed
                                               //   if so bring down dlg after
                                               //   ChangeIcon dlg returns.
} PASTESPECIAL, *PPASTESPECIAL, FAR *LPPASTESPECIAL;

// Data corresponding to each list item. A pointer to this structure is attached to each
//   Paste\PasteLink list box item using LB_SETITEMDATA
typedef struct tagPASTELISTITEMDATA
{
   int                   nPasteEntriesIndex;   // Index of arrPasteEntries[] corresponding to list item
   BOOL                  fCntrEnableIcon;      // Does calling application (called container here)
                                               //    specify OLEUIPASTE_ENABLEICON for this item?
} PASTELISTITEMDATA, *PPASTELISTITEMDATA, FAR *LPPASTELISTITEMDATA;


//Internal function prototypes
//PASTESPL.C
BOOL CALLBACK EXPORT PasteSpecialDialogProc(HWND, UINT, WPARAM, LPARAM);
BOOL            FPasteSpecialInit(HWND hDlg, WPARAM, LPARAM);
BOOL            FTogglePasteType(HWND, LPPASTESPECIAL, DWORD);
void            ChangeListSelection(HWND, LPPASTESPECIAL, HWND);
void            EnableDisplayAsIcon(HWND, LPPASTESPECIAL);
void            ToggleDisplayAsIcon(HWND, LPPASTESPECIAL);
void            ChangeIcon(HWND, LPPASTESPECIAL);
void            SetPasteSpecialHelpResults(HWND, LPPASTESPECIAL);
BOOL            FAddPasteListItem(HWND, BOOL, int, LPPASTESPECIAL, LPMALLOC, LPTSTR, LPTSTR);
BOOL            FFillPasteList(HWND, LPPASTESPECIAL);
BOOL            FFillPasteLinkList(HWND, LPPASTESPECIAL);
BOOL            FHasPercentS(LPCTSTR, LPPASTESPECIAL);
HGLOBAL         AllocateScratchMem(LPPASTESPECIAL);
void            FreeListData(HWND);

#endif  //_PASTESPL_H_


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\letest\ole2ui\pastespl.c ===
/*
 * PASTESPL.C
 *
 * Implements the OleUIPasteSpecial function which invokes the complete
 * Paste Special dialog.
 *
 * Copyright (c)1992 Microsoft Corporation, All Rights Reserved
 */

#define STRICT  1
#include "ole2ui.h"
#include "pastespl.h"
#include "common.h"
#include "utility.h"
#include "resimage.h"
#include "iconbox.h"
#include "geticon.h"
#include "icon.h"
#include "regdb.h"
#include <stdlib.h>

OLEDBGDATA

/*
 * OleUIPasteSpecial
 *
 * Purpose:
 *  Invokes the standard OLE Paste Special dialog box which allows the user
 *  to select the format of the clipboard object to be pasted or paste linked.
 *
 * Parameters:
 *  lpPS         LPOLEUIPasteSpecial pointing to the in-out structure
 *               for this dialog.
 *
 * Return Value:
 *  UINT        One of the following codes or one of the standard error codes (OLEUI_ERR_*)
 *              defined in OLE2UI.H, indicating success or error:
 *              OLEUI_OK                           User selected OK
 *              OLEUI_CANCEL                       User cancelled the dialog
 *              OLEUI_IOERR_SRCDATAOBJECTINVALID   lpSrcDataObject field of OLEUIPASTESPECIAL invalid
 *              OLEUI_IOERR_ARRPASTEENTRIESINVALID arrPasteEntries field of OLEUIPASTESPECIAL invalid
 *              OLEUI_IOERR_ARRLINKTYPESINVALID    arrLinkTypes field of OLEUIPASTESPECIAL invalid
 *              OLEUI_PSERR_CLIPBOARDCHANGED       Clipboard contents changed while dialog was up
 */

STDAPI_(UINT) OleUIPasteSpecial(LPOLEUIPASTESPECIAL lpPS)
{
    UINT        uRet;
    HGLOBAL     hMemDlg=NULL;

    uRet=UStandardValidation((LPOLEUISTANDARD)lpPS, sizeof(OLEUIPASTESPECIAL)
        , &hMemDlg);

    if (uRet != OLEUI_SUCCESS)
        return uRet;

    //Validate PasteSpecial specific fields
    if (NULL == lpPS->lpSrcDataObj || IsBadReadPtr(lpPS->lpSrcDataObj,  sizeof(IDataObject)))
        uRet = OLEUI_IOERR_SRCDATAOBJECTINVALID;
    if (NULL == lpPS->arrPasteEntries || IsBadReadPtr(lpPS->arrPasteEntries,  sizeof(OLEUIPASTEENTRY)))
        uRet = OLEUI_IOERR_ARRPASTEENTRIESINVALID;
    if (NULL != lpPS->arrLinkTypes && IsBadReadPtr(lpPS->arrLinkTypes,  sizeof(UINT)))
        uRet = OLEUI_IOERR_ARRLINKTYPESINVALID;

    if (0!=lpPS->cClsidExclude)
        {
        if (NULL!=lpPS->lpClsidExclude && IsBadReadPtr(lpPS->lpClsidExclude
            , lpPS->cClsidExclude*sizeof(CLSID)))
        uRet=OLEUI_IOERR_LPCLSIDEXCLUDEINVALID;
        }

    if (uRet >= OLEUI_ERR_STANDARDMIN)
    {
        if (NULL != hMemDlg)
            FreeResource(hMemDlg);
        return uRet;
    }

    //Now that we've validated everything, we can invoke the dialog.
    uRet = UStandardInvocation(PasteSpecialDialogProc, (LPOLEUISTANDARD)lpPS
        , hMemDlg, MAKEINTRESOURCE(IDD_PASTESPECIAL));

    /*
    * IF YOU ARE CREATING ANYTHING BASED ON THE RESULTS, DO IT HERE.
    */

    return uRet;
}


/*
 * PasteSpecialDialogProc
 *
 * Purpose:
 *  Implements the OLE Paste Special dialog as invoked through the
 *  OleUIPasteSpecial function.
 *
 * Parameters:
 *  Standard
 *
 * Return Value:
 *  Standard
 */

BOOL CALLBACK EXPORT PasteSpecialDialogProc(HWND hDlg, UINT iMsg, WPARAM wParam, LPARAM lParam)
{
    LPOLEUIPASTESPECIAL     lpOPS;
    LPPASTESPECIAL          lpPS;
    BOOL                    fHook=FALSE;
    HCURSOR                 hCursorOld;

    //Declare Win16/Win32 compatible WM_COMMAND parameters.
    COMMANDPARAMS(wID, wCode, hWndMsg);

    //This will fail under WM_INITDIALOG, where we allocate it.
    lpPS=(LPPASTESPECIAL)LpvStandardEntry(hDlg, iMsg, wParam, lParam, &fHook);

    //If the hook processed the message, we're done.
    if (0!=fHook)
        return fHook;

    // Process help message from Change Icon
    if (iMsg == uMsgHelp)
    {
        PostMessage(lpPS->lpOPS->hWndOwner, uMsgHelp, wParam, lParam);
        return FALSE;
    }

    //Process the temination message
    if (iMsg==uMsgEndDialog)
    {
        HWND    hwndNextViewer;

        // Free the icon/icon-title metafile corresponding to Paste/PasteList option which is not selected
        if (lpPS->fLink)
            OleUIMetafilePictIconFree(lpPS->hMetaPictOD);
        else OleUIMetafilePictIconFree(lpPS->hMetaPictLSD);

        // Free data associated with each list box entry
        FreeListData(GetDlgItem(hDlg, ID_PS_PASTELIST));
        FreeListData(GetDlgItem(hDlg, ID_PS_PASTELINKLIST));

        //Free any specific allocations before calling StandardCleanup
        if (lpPS->hObjDesc) GlobalFree(lpPS->hObjDesc);
        if (lpPS->hLinkSrcDesc) GlobalFree(lpPS->hLinkSrcDesc);
        if (lpPS->hBuff) GlobalFree(lpPS->hBuff);

        // Change the clipboard notification chain
        hwndNextViewer = GetProp(hDlg, NEXTCBVIEWER);
        if (hwndNextViewer != HWND_BROADCAST)
        {
            SetProp(hDlg, NEXTCBVIEWER, HWND_BROADCAST);
            ChangeClipboardChain(hDlg, hwndNextViewer);
        }
        RemoveProp(hDlg, NEXTCBVIEWER);

        StandardCleanup(lpPS, hDlg);
        EndDialog(hDlg, wParam);
        return TRUE;
    }

    switch (iMsg)
    {
        case WM_INITDIALOG:
            hCursorOld = HourGlassOn();
            FPasteSpecialInit(hDlg, wParam, lParam);
            HourGlassOff(hCursorOld);
            return FALSE;

        case WM_DRAWCLIPBOARD:
        {
            HWND    hwndNextViewer = GetProp(hDlg, NEXTCBVIEWER);
            HWND    hDlg_ChgIcon;

            if (hwndNextViewer == HWND_BROADCAST)
                break;

            if (hwndNextViewer)
            {
                SendMessage(hwndNextViewer, iMsg, wParam, lParam);
                // Refresh next viewer in case it got modified
                //    by the SendMessage() (likely if multiple
                //    PasteSpecial dialogs are up simultaneously)
                hwndNextViewer = GetProp(hDlg, NEXTCBVIEWER);
            }
            SetProp(hDlg, NEXTCBVIEWER, HWND_BROADCAST);
            ChangeClipboardChain(hDlg, hwndNextViewer);

            /* OLE2NOTE: if the ChangeIcon dialog is currently up, then
            **    we need to defer bringing down PasteSpecial dialog
            **    until after ChangeIcon dialog returns. if the
            **    ChangeIcon dialog is NOT up, then we can bring down
            **    the PasteSpecial dialog immediately.
            */
            if ((hDlg_ChgIcon=(HWND)GetProp(hDlg,PROP_HWND_CHGICONDLG))!=NULL)
            {
                // ChangeIcon dialog is UP
                lpPS->fClipboardChanged = TRUE;
            } else {
                // ChangeIcon dialog is NOT up

                //  Free icon and icon title metafile
                SendDlgItemMessage(
                        hDlg, ID_PS_ICONDISPLAY, IBXM_IMAGEFREE, 0, 0L);

                SendMessage(
                        hDlg, uMsgEndDialog, OLEUI_PSERR_CLIPBOARDCHANGED,0L);
            }
            break;
        }

        case WM_CHANGECBCHAIN:
        {
            HWND    hwndNextViewer = GetProp(hDlg, NEXTCBVIEWER);

            if (wParam == (WORD)hwndNextViewer)
                SetProp(hDlg, NEXTCBVIEWER, (hwndNextViewer = (HWND)LOWORD(lParam)));
            else if (hwndNextViewer && hwndNextViewer != HWND_BROADCAST)
                SendMessage(hwndNextViewer, iMsg, wParam, lParam);
            break;
        }

        case WM_COMMAND:
            switch (wID)
            {
                case ID_PS_PASTE:
                    FTogglePasteType(hDlg, lpPS, PSF_SELECTPASTE);
                    break;

                case ID_PS_PASTELINK:
                    FTogglePasteType(hDlg, lpPS, PSF_SELECTPASTELINK);
                    break;

                case ID_PS_DISPLAYLIST:
                    switch (wCode)
                    {
                        case LBN_SELCHANGE:
                            ChangeListSelection(hDlg, lpPS, hWndMsg);
                            break;

                        case LBN_DBLCLK:
                            // Same as pressing OK
                            SendCommand(hDlg, IDOK, BN_CLICKED, hWndMsg);
                            break;
                    }
                    break;

                case ID_PS_DISPLAYASICON:
                    ToggleDisplayAsIcon(hDlg, lpPS);
                    break;

                case ID_PS_CHANGEICON:
                    ChangeIcon(hDlg, lpPS);
                    if (lpPS->fClipboardChanged) {
                        // Free icon and icon title metafile
                        SendDlgItemMessage(
                                hDlg, ID_PS_ICONDISPLAY, IBXM_IMAGEFREE,0,0L);
                        SendMessage(
                                hDlg, uMsgEndDialog,
                                OLEUI_PSERR_CLIPBOARDCHANGED, 0L);
                    }
                    break;

                case IDOK:
                {
                    BOOL fDestAspectIcon =
                            ((lpPS->dwFlags & PSF_CHECKDISPLAYASICON) ?
                                    TRUE : FALSE);
                    lpOPS = lpPS->lpOPS;
                    // Return current flags
                    lpOPS->dwFlags = lpPS->dwFlags;
                    // Return index of arrPasteEntries[] corresponding to format selected by user
                    lpOPS->nSelectedIndex = lpPS->nSelectedIndex;
                    // Return if user selected Paste or PasteLink
                    lpOPS->fLink = lpPS->fLink;

                    /* if user selected same ASPECT as displayed in the
                    **    source, then sizel passed in the
                    **    ObjectDescriptor/LinkSrcDescriptor is
                    **    applicable. otherwise, the sizel does not apply.
                    */
                    if (lpPS->fLink) {
                        if (lpPS->fSrcAspectIconLSD == fDestAspectIcon)
                            lpOPS->sizel = lpPS->sizelLSD;
                        else
                            lpOPS->sizel.cx = lpOPS->sizel.cy = 0;
                    } else {
                        if (lpPS->fSrcAspectIconOD == fDestAspectIcon)
                            lpOPS->sizel = lpPS->sizelOD;
                        else
                            lpOPS->sizel.cx = lpOPS->sizel.cy = 0;
                    }
                    // Return metafile with icon and icon title that the user selected
                    lpOPS->hMetaPict=(HGLOBAL)SendDlgItemMessage(hDlg, ID_PS_ICONDISPLAY,
                                                    IBXM_IMAGEGET, 0, 0L);
                    SendMessage(hDlg, uMsgEndDialog, OLEUI_OK, 0L);
                    break;
                }
                case IDCANCEL:
                    // Free icon and icon title metafile
                    SendDlgItemMessage(
                            hDlg, ID_PS_ICONDISPLAY, IBXM_IMAGEFREE, 0, 0L);
                    SendMessage(hDlg, uMsgEndDialog, OLEUI_CANCEL, 0L);
                    break;

                case ID_OLEUIHELP:
                    PostMessage(lpPS->lpOPS->hWndOwner, uMsgHelp,
                        (WPARAM)hDlg, MAKELPARAM(IDD_PASTESPECIAL, 0));
                    break;
            }
            break;
    }
    return FALSE;
}


/*
 * FPasteSpecialInit
 *
 * Purpose:
 *  WM_INITIDIALOG handler for the Paste Special dialog box.
 *
 * Parameters:
 *  hDlg            HWND of the dialog
 *  wParam          WPARAM of the message
 *  lParam          LPARAM of the message
 *
 * Return Value:
 *  BOOL            Value to return for WM_INITDIALOG.
 */

BOOL FPasteSpecialInit(HWND hDlg, WPARAM wParam, LPARAM lParam)
{
    LPPASTESPECIAL              lpPS;
    LPOLEUIPASTESPECIAL         lpOPS;
    HFONT                       hFont;
    BOOL                        fPasteAvailable, fPasteLinkAvailable;
    STGMEDIUM                   medium;
    LPOBJECTDESCRIPTOR          lpOD;
    LPLINKSRCDESCRIPTOR         lpLSD;
    int                         n;
    CLIPFORMAT                  cfFormat;

    // Copy the structure at lParam into our instance memory.
    lpPS = (LPPASTESPECIAL)LpvStandardInit(hDlg, sizeof(PASTESPECIAL), TRUE, &hFont);

    // PvStandardInit sent a termination to us already.
    if (NULL == lpPS)
        return FALSE;

    lpOPS=(LPOLEUIPASTESPECIAL)lParam;

    // Copy other information from lpOPS that we might modify.
    lpPS->lpOPS = lpOPS;
    lpPS->dwFlags = lpOPS->dwFlags;

    // Initialize user selections in the Paste and PasteLink listboxes
    lpPS->nPasteListCurSel = 0;
    lpPS->nPasteLinkListCurSel = 0;

    // If we got a font, send it to the necessary controls.
    if (NULL!=hFont)
    {
        SendDlgItemMessage(hDlg, ID_PS_SOURCETEXT, WM_SETFONT, (WPARAM)hFont, 0L);
        SendDlgItemMessage(hDlg, ID_PS_RESULTTEXT, WM_SETFONT, (WPARAM)hFont, 0L);
    }

    // Hide the help button if required
    if (!(lpPS->lpOPS->dwFlags & PSF_SHOWHELP))
        StandardShowDlgItem(hDlg, ID_OLEUIHELP, SW_HIDE);

    // Hide all DisplayAsIcon related controls if it should be disabled
    if ( lpPS->dwFlags & PSF_DISABLEDISPLAYASICON ) {
          StandardShowDlgItem(hDlg, ID_PS_DISPLAYASICON, SW_HIDE);
          StandardShowDlgItem(hDlg, ID_PS_CHANGEICON, SW_HIDE);
          StandardShowDlgItem(hDlg, ID_PS_ICONDISPLAY, SW_HIDE);
    }

    // PSF_CHECKDISPLAYASICON is an OUT flag. Clear it if has been set on the way in.
    lpPS->dwFlags = lpPS->dwFlags & ~PSF_CHECKDISPLAYASICON;

    //  Change the caption if required
    if (NULL != lpOPS->lpszCaption)
        SetWindowText(hDlg, lpOPS->lpszCaption);

    // Load 'Unknown Source' and 'Unknown Type' strings
    n = LoadString(ghInst, IDS_PSUNKNOWNTYPE, lpPS->szUnknownType, PS_UNKNOWNSTRLEN);
    if (n)
        n = LoadString(ghInst, IDS_PSUNKNOWNSRC, lpPS->szUnknownSource, PS_UNKNOWNSTRLEN);
    if (!n)
    {
        PostMessage(hDlg, uMsgEndDialog, OLEUI_ERR_LOADSTRING, 0L);
        return FALSE;
    }
    lpPS->szAppName[0]=TEXT('\0');

    // GetData CF_OBJECTDESCRIPTOR. If the object on the clipboard in an OLE1 object (offering CF_OWNERLINK)
    // or has been copied to clipboard by FileMaager (offering CF_FILENAME), an OBJECTDESCRIPTOR will be
    // created will be created from CF_OWNERLINK or CF_FILENAME. See OBJECTDESCRIPTOR for more info.

    if (lpPS->hObjDesc = OleStdFillObjectDescriptorFromData(lpOPS->lpSrcDataObj, &medium, &cfFormat))
    {
        lpOD = GlobalLock(lpPS->hObjDesc);

        // Get FullUserTypeName, SourceOfCopy and CLSID
        if (lpOD->dwFullUserTypeName)
            lpPS->szFullUserTypeNameOD = (LPTSTR)lpOD+lpOD->dwFullUserTypeName;
        else lpPS->szFullUserTypeNameOD = lpPS->szUnknownType;

        if (lpOD->dwSrcOfCopy)
        {
            lpPS->szSourceOfDataOD = (LPTSTR)lpOD+lpOD->dwSrcOfCopy;
            // If CF_FILENAME was offered, source of copy is a path name. Fit the path to the
            // static control that will display it.
            if (cfFormat == cfFileName)
                lpPS->szSourceOfDataOD = ChopText(GetDlgItem(hDlg, ID_PS_SOURCETEXT), 0, lpPS->szSourceOfDataOD);
        }
        else lpPS->szSourceOfDataOD = lpPS->szUnknownSource;

        lpPS->clsidOD = lpOD->clsid;
        lpPS->sizelOD = lpOD->sizel;

        // Does source specify DVASPECT_ICON?
        if (lpOD->dwDrawAspect & DVASPECT_ICON)
           lpPS->fSrcAspectIconOD = TRUE;
        else lpPS->fSrcAspectIconOD = FALSE;

        // Does source specify OLEMISC_ONLYICONIC?
        if (lpOD->dwStatus & OLEMISC_ONLYICONIC)
            lpPS->fSrcOnlyIconicOD = TRUE;
        else lpPS->fSrcOnlyIconicOD = FALSE;

        // Get application name of source from auxusertype3 in the registration database
        if (0==OleStdGetAuxUserType(&lpPS->clsidOD, 3, lpPS->szAppName, OLEUI_CCHKEYMAX_SIZE, NULL))
        {
             // Use "the application which created it" as the name of the application
             if (0==LoadString(ghInst, IDS_PSUNKNOWNAPP, lpPS->szAppName, PS_UNKNOWNSTRLEN))
             {
                 PostMessage(hDlg, uMsgEndDialog, OLEUI_ERR_LOADSTRING, 0L);
                 return FALSE;
             }
        }

        // Retrieve an icon from the object
        if (lpPS->fSrcAspectIconOD)
        {
            lpPS->hMetaPictOD = OleStdGetData(
                lpOPS->lpSrcDataObj,
                (CLIPFORMAT) CF_METAFILEPICT,
                NULL,
                DVASPECT_ICON,
                &medium
            );

        }
        // If object does not offer icon, obtain it from the CLSID
        if (NULL == lpPS->hMetaPictOD)
        {
#ifdef OLE201
            lpPS->hMetaPictOD = GetIconOfClass(
                    ghInst,
                    &lpPS->clsidOD,
                    NULL,
                    TRUE);   // Use the short user type name (auxusertype3)
#endif
            lpPS->hMetaPictOD = NULL;


        }
    }

    // Does object offer CF_LINKSRCDESCRIPTOR?
    if (lpPS->hLinkSrcDesc = OleStdGetData(
            lpOPS->lpSrcDataObj,
            (CLIPFORMAT) cfLinkSrcDescriptor,
            NULL,
            DVASPECT_CONTENT,
            &medium))
    {
        // Get FullUserTypeName, SourceOfCopy and CLSID
        lpLSD = GlobalLock(lpPS->hLinkSrcDesc);
        if (lpLSD->dwFullUserTypeName)
            lpPS->szFullUserTypeNameLSD = (LPTSTR)lpLSD+lpLSD->dwFullUserTypeName;
        else lpPS->szFullUserTypeNameLSD = lpPS->szUnknownType;

        if (lpLSD->dwSrcOfCopy)
            lpPS->szSourceOfDataLSD = (LPTSTR)lpLSD+lpLSD->dwSrcOfCopy;
        else lpPS->szSourceOfDataLSD = lpPS->szUnknownSource;

        // if no ObjectDescriptor, then use LinkSourceDescriptor source string
        if (!lpPS->hObjDesc)
            lpPS->szSourceOfDataOD = lpPS->szSourceOfDataLSD;

        lpPS->clsidLSD = lpLSD->clsid;
        lpPS->sizelLSD = lpLSD->sizel;

        // Does source specify DVASPECT_ICON?
        if (lpLSD->dwDrawAspect & DVASPECT_ICON)
           lpPS->fSrcAspectIconLSD = TRUE;
        else lpPS->fSrcAspectIconLSD = FALSE;

        // Does source specify OLEMISC_ONLYICONIC?
        if (lpLSD->dwStatus & OLEMISC_ONLYICONIC)
            lpPS->fSrcOnlyIconicLSD = TRUE;
        else lpPS->fSrcOnlyIconicLSD = FALSE;

        // Retrieve an icon from the object
        if (lpPS->fSrcAspectIconLSD)
        {
            lpPS->hMetaPictLSD = OleStdGetData(
                lpOPS->lpSrcDataObj,
                CF_METAFILEPICT,
                NULL,
                DVASPECT_ICON,
                &medium
            );

        }
        // If object does not offer icon, obtain it from the CLSID
        if (NULL == lpPS->hMetaPictLSD)
        {
            TCHAR szLabel[OLEUI_CCHLABELMAX];
            HWND hIconWnd;
            RECT IconRect;
            int  nWidth;
            LPTSTR lpszLabel;

            hIconWnd = GetDlgItem(hDlg, ID_PS_ICONDISPLAY);

            GetClientRect(hIconWnd, &IconRect);

            nWidth = ((IconRect.right-IconRect.left) * 3) / 2;   // width is 1.5 times width of iconbox

            LSTRCPYN(szLabel, lpPS->szSourceOfDataLSD, OLEUI_CCHLABELMAX);
            szLabel[OLEUI_CCHLABELMAX-1] = TEXT('\0');

            lpszLabel = ChopText(hIconWnd, nWidth, (LPTSTR)szLabel);

#ifdef OLE201
            lpPS->hMetaPictLSD = GetIconOfClass(
                    ghInst,
                    &lpPS->clsidLSD,
                    lpszLabel,       /* use chopped source string as label */
                    FALSE            /* not applicable */
            );
#endif
            lpPS->hMetaPictLSD = NULL;

        }
    }
    else if (lpPS->hObjDesc)     // Does not offer CF_LINKSRCDESCRIPTOR but offers CF_OBJECTDESCRIPTOR
    {
        // Copy the values of OBJECTDESCRIPTOR
        lpPS->szFullUserTypeNameLSD = lpPS->szFullUserTypeNameOD;
        lpPS->szSourceOfDataLSD = lpPS->szSourceOfDataOD;
        lpPS->clsidLSD = lpPS->clsidOD;
        lpPS->sizelLSD = lpPS->sizelOD;
        lpPS->fSrcAspectIconLSD = lpPS->fSrcAspectIconOD;
        lpPS->fSrcOnlyIconicLSD = lpPS->fSrcOnlyIconicOD;

        // Don't copy the hMetaPict; instead get a separate copy
        if (lpPS->fSrcAspectIconLSD)
        {
            lpPS->hMetaPictLSD = OleStdGetData(
                lpOPS->lpSrcDataObj,
                CF_METAFILEPICT,
                NULL,
                DVASPECT_ICON,
                &medium
            );
        }
        if (NULL == lpPS->hMetaPictLSD)
        {
            TCHAR szLabel[OLEUI_CCHLABELMAX];
            HWND hIconWnd;
            RECT IconRect;
            int  nWidth;
            LPTSTR lpszLabel;

            hIconWnd = GetDlgItem(hDlg, ID_PS_ICONDISPLAY);

            GetClientRect(hIconWnd, &IconRect);

            nWidth = ((IconRect.right-IconRect.left) * 3) / 2;   // width is 1.5 times width of iconbox

            LSTRCPYN(szLabel, lpPS->szSourceOfDataLSD, OLEUI_CCHLABELMAX);
            szLabel[OLEUI_CCHLABELMAX-1] = TEXT('\0');

            lpszLabel = ChopText(hIconWnd, nWidth, (LPTSTR)szLabel);

#ifdef OLE201
            lpPS->hMetaPictLSD = GetIconOfClass(
                    ghInst,
                    &lpPS->clsidLSD,
					lpszLabel,   /* Use chopped source string as label */
                    FALSE        /* Not applicable */
            );
#endif
            lpPS->hMetaPictLSD = NULL;

        }
    }

    // Not an OLE object
    if (lpPS->hObjDesc == NULL && lpPS->hLinkSrcDesc == NULL)
    {
         lpPS->szFullUserTypeNameLSD = lpPS->szFullUserTypeNameOD = lpPS->szUnknownType;
         lpPS->szSourceOfDataLSD = lpPS->szSourceOfDataOD = lpPS->szUnknownSource;
         lpPS->hMetaPictLSD = lpPS->hMetaPictOD = NULL;
    }

    // Allocate scratch memory to construct item names in the paste and pastelink listboxes
    lpPS->hBuff = AllocateScratchMem(lpPS);
    if (lpPS->hBuff == NULL)
    {
       PostMessage(hDlg, uMsgEndDialog, OLEUI_ERR_GLOBALMEMALLOC, 0L);
       return FALSE;
    }

    // Select the Paste Link Button if specified. Otherwise select
    //      Paste Button by default
    if (lpPS->dwFlags & PSF_SELECTPASTELINK)
        lpPS->dwFlags = (lpPS->dwFlags & ~PSF_SELECTPASTE) | PSF_SELECTPASTELINK;
    else
        lpPS->dwFlags =(lpPS->dwFlags & ~PSF_SELECTPASTELINK) | PSF_SELECTPASTE;

    // Mark which PasteEntry formats are available from source data object
    OleStdMarkPasteEntryList(
            lpOPS->lpSrcDataObj,lpOPS->arrPasteEntries,lpOPS->cPasteEntries);

    // Check if items are available to be pasted
    fPasteAvailable = FFillPasteList(hDlg, lpPS);
    if (!fPasteAvailable)
    {
        lpPS->dwFlags &= ~PSF_SELECTPASTE;
        EnableWindow(GetDlgItem(hDlg, ID_PS_PASTE), FALSE);
    }

    // Check if items are available to be paste-linked
    fPasteLinkAvailable = FFillPasteLinkList(hDlg, lpPS);
    if (!fPasteLinkAvailable)
    {
        lpPS->dwFlags &= ~PSF_SELECTPASTELINK;
        EnableWindow(GetDlgItem(hDlg, ID_PS_PASTELINK), FALSE);
    }

    // If one of Paste or PasteLink is disabled, select the other one
    //    regardless of what the input flags say
    if (fPasteAvailable && !fPasteLinkAvailable)
        lpPS->dwFlags |= PSF_SELECTPASTE;
    if (fPasteLinkAvailable && !fPasteAvailable)
        lpPS->dwFlags |= PSF_SELECTPASTELINK;

    if (lpPS->dwFlags & PSF_SELECTPASTE)
    {
        // FTogglePaste will set the PSF_SELECTPASTE flag, so clear it.
        lpPS->dwFlags &= ~PSF_SELECTPASTE;
        CheckRadioButton(hDlg, ID_PS_PASTE, ID_PS_PASTELINK, ID_PS_PASTE);
        FTogglePasteType(hDlg, lpPS, PSF_SELECTPASTE);
    }
    else if (lpPS->dwFlags & PSF_SELECTPASTELINK)
    {
        // FTogglePaste will set the PSF_SELECTPASTELINK flag, so clear it.
        lpPS->dwFlags &= ~PSF_SELECTPASTELINK;
        CheckRadioButton(hDlg, ID_PS_PASTE, ID_PS_PASTELINK, ID_PS_PASTELINK);
        FTogglePasteType(hDlg, lpPS, PSF_SELECTPASTELINK);
    }
    else  // Items are not available to be be Pasted or Paste-Linked
    {
        // Enable or disable DisplayAsIcon and set the result text and image
        EnableDisplayAsIcon(hDlg, lpPS);
        SetPasteSpecialHelpResults(hDlg, lpPS);
    }

    // Give initial focus to the list box
    SetFocus(GetDlgItem(hDlg, ID_PS_DISPLAYLIST));

    // Set property to handle clipboard change notifications
    SetProp(hDlg, NEXTCBVIEWER, HWND_BROADCAST);
    SetProp(hDlg, NEXTCBVIEWER, SetClipboardViewer(hDlg));

    lpPS->fClipboardChanged = FALSE;

    /*
     * PERFORM OTHER INITIALIZATION HERE.
     */

    // Call the hook with lCustData in lParam
    UStandardHook(lpPS, hDlg, WM_INITDIALOG, wParam, lpOPS->lCustData);
    return TRUE;
}

/*
 * FTogglePasteType
 *
 * Purpose:
 *  Toggles between Paste and Paste Link. The Paste list and PasteLink
 *  list are always invisible. The Display List is filled from either
 *  the Paste list or the PasteLink list depending on which Paste radio
 *  button is selected.
 *
 * Parameters:
 *  hDlg            HWND of the dialog
 *  lpPS             Paste Special Dialog Structure
 *  dwOption        Paste or PasteSpecial option
 *
 * Return Value:
 *  BOOL            Returns TRUE if the option has already been selected.
 *                  Otherwise the option is selected and FALSE is returned
 */

BOOL FTogglePasteType(HWND hDlg, LPPASTESPECIAL lpPS, DWORD dwOption)
{
    DWORD dwTemp;
    HWND hList, hListDisplay;
    DWORD dwData;
    int i, nItems;
    LPTSTR lpsz;

    // Skip all this if the button is already selected
    if (lpPS->dwFlags & dwOption)
        return TRUE;

    dwTemp = PSF_SELECTPASTE | PSF_SELECTPASTELINK;
    lpPS->dwFlags = (lpPS->dwFlags & ~dwTemp) | dwOption;

    // Hide IconDisplay. This prevents flashing if the icon display is changed
    StandardShowDlgItem(hDlg, ID_PS_ICONDISPLAY, SW_HIDE);

    hListDisplay = GetDlgItem(hDlg, ID_PS_DISPLAYLIST);

    // If Paste was selected
    if (lpPS->dwFlags & PSF_SELECTPASTE)
    {
        // Set the Source of the object in the clipboard
        SetDlgItemText(hDlg, ID_PS_SOURCETEXT, lpPS->szSourceOfDataOD);

        // If an icon is available
        if (lpPS->hMetaPictOD)
            // Set the icon display
            SendDlgItemMessage(hDlg, ID_PS_ICONDISPLAY, IBXM_IMAGESET,
                  (WPARAM)lpPS->hMetaPictOD, 0L);


        hList = GetDlgItem(hDlg, ID_PS_PASTELIST);
        // We are switching from PasteLink to Paste. Remember current selection
        //    in PasteLink list so it can be restored.
        lpPS->nPasteLinkListCurSel = (int)SendMessage(hListDisplay, LB_GETCURSEL, 0, 0L);
        if (lpPS->nPasteLinkListCurSel == LB_ERR)
            lpPS->nPasteLinkListCurSel = 0;
        // Remember if user selected Paste or PasteLink
        lpPS->fLink = FALSE;
    }
    else    // If PasteLink was selected
    {
        // Set the Source of the object in the clipboard
        SetDlgItemText(hDlg, ID_PS_SOURCETEXT, lpPS->szSourceOfDataLSD);

        // If an icon is available
        if (lpPS->hMetaPictLSD)
            // Set the icon display
            SendDlgItemMessage(hDlg, ID_PS_ICONDISPLAY, IBXM_IMAGESET,
                  (WPARAM)lpPS->hMetaPictLSD, 0L);


        hList = GetDlgItem(hDlg, ID_PS_PASTELINKLIST);
        // We are switching from Paste to PasteLink. Remember current selection
        //    in Paste list so it can be restored.
        lpPS->nPasteListCurSel = (int)SendMessage(hListDisplay, LB_GETCURSEL, 0, 0L);
        if (lpPS->nPasteListCurSel == LB_ERR)
            lpPS->nPasteListCurSel = 0;
        // Remember if user selected Paste or PasteLink
        lpPS->fLink = TRUE;
    }

    // Turn drawing off while the Display List is being filled
    SendMessage(hListDisplay, WM_SETREDRAW, (WPARAM)FALSE, 0L);

    // Move data to Display list box
    SendMessage(hListDisplay, LB_RESETCONTENT, 0, 0L);
    nItems = (int) SendMessage(hList, LB_GETCOUNT, 0, 0L);
    lpsz = (LPTSTR)GlobalLock(lpPS->hBuff);
    for (i = 0; i < nItems; i++)
    {
        SendMessage(hList, LB_GETTEXT, (WPARAM)i, (LPARAM)lpsz);
        dwData = SendMessage(hList, LB_GETITEMDATA, (WPARAM)i, 0L);
        SendMessage(hListDisplay, LB_INSERTSTRING, (WPARAM)i, (LPARAM)lpsz);
        SendMessage(hListDisplay, LB_SETITEMDATA, (WPARAM)i, dwData);
    }
    GlobalUnlock(lpPS->hBuff);

    // Restore the selection in the Display List from user's last selection
    if (lpPS->dwFlags & PSF_SELECTPASTE)
        SendMessage(hListDisplay, LB_SETCURSEL, lpPS->nPasteListCurSel, 0L);
    else
        SendMessage(hListDisplay, LB_SETCURSEL, lpPS->nPasteLinkListCurSel, 0L);

    // Paint Display List
    SendMessage(hListDisplay, WM_SETREDRAW, (WPARAM)TRUE, 0L);
    InvalidateRect(hListDisplay, NULL, TRUE);
    UpdateWindow(hListDisplay);

    // Auto give the focus to the Display List
    SetFocus(hListDisplay);

    // Enable/Disable DisplayAsIcon and set the help result text and bitmap corresponding to
    //    the current selection
    ChangeListSelection(hDlg, lpPS, hListDisplay);

    return FALSE;
}


/*
 * ChangeListSelection
 *
 * Purpose:
 *  When the user changes the selection in the list, DisplayAsIcon is enabled or disabled,
 *  Result text and bitmap are updated and the index of the arrPasteEntries[] corresponding
 *  to the current format selection is saved.
 *
 * Parameters:
 *  hDlg            HWND of the dialog
 *  lpPS             Paste Special Dialog Structure
 *  hList           HWND of the List
 *
 * Return Value:
 *  No return value
 */

void ChangeListSelection(HWND hDlg, LPPASTESPECIAL lpPS, HWND hList)
{
    LPPASTELISTITEMDATA lpItemData;
    int nCurSel;

    EnableDisplayAsIcon(hDlg, lpPS);
    SetPasteSpecialHelpResults(hDlg, lpPS);

    // Remember index of arrPasteEntries[] corresponding to the current selection
    nCurSel = (int)SendMessage(hList, LB_GETCURSEL, 0, 0L);
    if (nCurSel == LB_ERR) return;
    lpItemData = (LPPASTELISTITEMDATA) SendMessage(hList, LB_GETITEMDATA,
                (WPARAM)nCurSel, 0L);
    if ((LRESULT)lpItemData == LB_ERR) return;
    lpPS->nSelectedIndex = lpItemData->nPasteEntriesIndex;
}

/*
 * EnableDisplayAsIcon
 *
 * Purpose:
 *  Enable or disable the DisplayAsIcon button depending on whether
 *  the current selection can be displayed as an icon or not. The following table describes
 *  the state of DisplayAsIcon. The calling application is termed CONTAINER, the source
 *  of data on the clipboard is termed SOURCE.
 *  Y = Yes; N = No; Blank = State does not matter;
 * =====================================================================
 * SOURCE          SOURCE             CONTAINER             DisplayAsIcon
 * specifies       specifies          specifies             Initial State
 * DVASPECT_ICON   OLEMISC_ONLYICONIC OLEUIPASTE_ENABLEICON
 *
 *                                    N                     Unchecked&Disabled
 *                 Y                  Y                     Checked&Disabled
 * Y               N                  Y                     Checked&Enabled
 * N               N                  Y                     Unchecked&Enabled
 * =====================================================================
 *
 * Parameters:
 *  hDlg            HWND of the dialog
 *  lpPS             Paste Special Dialog Structure
 *
 * Return Value:
 *  No return value
 */

void EnableDisplayAsIcon(HWND hDlg, LPPASTESPECIAL lpPS)
{
    int nIndex;
    BOOL fCntrEnableIcon;
    BOOL fSrcOnlyIconic = (lpPS->fLink) ? lpPS->fSrcOnlyIconicLSD : lpPS->fSrcOnlyIconicOD;
    BOOL fSrcAspectIcon = (lpPS->fLink) ? lpPS->fSrcAspectIconLSD : lpPS->fSrcAspectIconOD;
    HWND hList;
    LPPASTELISTITEMDATA lpItemData;
    HGLOBAL hMetaPict = (lpPS->fLink) ? lpPS->hMetaPictLSD : lpPS->hMetaPictOD;

    hList = GetDlgItem(hDlg, ID_PS_DISPLAYLIST);

    // Get data corresponding to the current selection in the listbox
    nIndex = (int)SendMessage(hList, LB_GETCURSEL, 0, 0);
    if (nIndex != LB_ERR)
    {
        lpItemData = (LPPASTELISTITEMDATA) SendMessage(hList, LB_GETITEMDATA, (WPARAM)nIndex, 0L);
        if ((LRESULT)lpItemData != LB_ERR)
            fCntrEnableIcon = lpItemData->fCntrEnableIcon;
        else fCntrEnableIcon = FALSE;
    }
    else fCntrEnableIcon = FALSE;

    // If there is an icon available
    if (hMetaPict != NULL)
    {
        if (!fCntrEnableIcon)          // Does CONTAINER specify OLEUIPASTE_ENABLEICON?
        {
            // Uncheck & Disable DisplayAsIcon
            lpPS->dwFlags &= ~PSF_CHECKDISPLAYASICON;
            CheckDlgButton(hDlg, ID_PS_DISPLAYASICON, FALSE);
            EnableWindow(GetDlgItem(hDlg, ID_PS_DISPLAYASICON), FALSE);

            // Hide IconDisplay and ChangeIcon button
            StandardShowDlgItem(hDlg, ID_PS_ICONDISPLAY, SW_HIDE);
            StandardShowDlgItem(hDlg, ID_PS_CHANGEICON, SW_HIDE);
        }
        else if (fSrcOnlyIconic)       // Does SOURCE specify OLEMISC_ONLYICONIC?
        {
            // Check & Disable DisplayAsIcon
            lpPS->dwFlags |= PSF_CHECKDISPLAYASICON;
            CheckDlgButton(hDlg, ID_PS_DISPLAYASICON, TRUE);
            EnableWindow(GetDlgItem(hDlg, ID_PS_DISPLAYASICON), FALSE);

            // Show IconDisplay and ChangeIcon button
            StandardShowDlgItem(hDlg, ID_PS_ICONDISPLAY, SW_SHOWNORMAL);
            StandardShowDlgItem(hDlg, ID_PS_CHANGEICON, SW_SHOWNORMAL);
        }
        else if (fSrcAspectIcon)       // Does SOURCE specify DVASPECT_ICON?
        {
             // Check & Enable DisplayAsIcon
             lpPS->dwFlags |= PSF_CHECKDISPLAYASICON;
             CheckDlgButton(hDlg, ID_PS_DISPLAYASICON, TRUE);
             EnableWindow(GetDlgItem(hDlg, ID_PS_DISPLAYASICON), TRUE);

             // Show IconDisplay and ChangeIcon button
             StandardShowDlgItem(hDlg, ID_PS_ICONDISPLAY, SW_SHOWNORMAL);
             StandardShowDlgItem(hDlg, ID_PS_CHANGEICON, SW_SHOWNORMAL);
        }
        else
        {
             //Uncheck and Enable DisplayAsIcon
             lpPS->dwFlags &= ~PSF_CHECKDISPLAYASICON;
             CheckDlgButton(hDlg, ID_PS_DISPLAYASICON, FALSE);
             EnableWindow(GetDlgItem(hDlg, ID_PS_DISPLAYASICON), TRUE);

             // Hide IconDisplay and ChangeIcon button
             StandardShowDlgItem(hDlg, ID_PS_ICONDISPLAY, SW_HIDE);
             StandardShowDlgItem(hDlg, ID_PS_CHANGEICON, SW_HIDE);

        }
    }
    else  // No icon available
    {
        // Unchecked & Disabled
        lpPS->dwFlags &= ~PSF_CHECKDISPLAYASICON;
        CheckDlgButton(hDlg, ID_PS_DISPLAYASICON, FALSE);
        EnableWindow(GetDlgItem(hDlg, ID_PS_DISPLAYASICON), FALSE);

        // Hide IconDisplay and ChangeIcon button
        StandardShowDlgItem(hDlg, ID_PS_ICONDISPLAY, SW_HIDE);
        StandardShowDlgItem(hDlg, ID_PS_CHANGEICON, SW_HIDE);
    }
}

/*
 * ToggleDisplayAsIcon
 *
 * Purpose:
 *  Toggles the DisplayAsIcon button. Hides or shows the Icon Display and
 *  the ChangeIcon button and changes the help result text and bitmap.
 *
 * Parameters:
 *  hDlg            HWND of the dialog
 *  lpPS             Paste Special Dialog Structure
 *
 * Return Value:
 *  None
 *
 */

void ToggleDisplayAsIcon(HWND hDlg, LPPASTESPECIAL lpPS)
{
    BOOL fCheck;
    int i;

    fCheck = IsDlgButtonChecked(hDlg, ID_PS_DISPLAYASICON);

    if (fCheck)
        lpPS->dwFlags |= PSF_CHECKDISPLAYASICON;
    else lpPS->dwFlags &= ~PSF_CHECKDISPLAYASICON;

    // Set the help result text and bitmap
    SetPasteSpecialHelpResults(hDlg, lpPS);

    // Show or hide the Icon Display and ChangeIcon button depending
    // on the check state
    i = (fCheck) ? SW_SHOWNORMAL : SW_HIDE;
    StandardShowDlgItem(hDlg, ID_PS_ICONDISPLAY, i);
    StandardShowDlgItem(hDlg, ID_PS_CHANGEICON, i);
}

/*
 * ChangeIcon
 *
 * Purpose:
 *  Brings up the ChangeIcon dialog which allows the user to change
 *  the icon and label.
 *
 * Parameters:
 *  hDlg            HWND of the dialog
 *  lpPS             Paste Special Dialog Structure
 *
 * Return Value:
 *  None
 *
 */

void ChangeIcon(HWND hDlg, LPPASTESPECIAL lpPS)
{
    OLEUICHANGEICON ci;
    UINT uRet;
    CLSID   clsid     = (lpPS->fLink) ? lpPS->clsidLSD : lpPS->clsidOD;

    //Initialize the structure
    _fmemset((LPOLEUICHANGEICON)&ci, 0, sizeof(ci));

    ci.hMetaPict = (HGLOBAL)SendDlgItemMessage(hDlg, ID_PS_ICONDISPLAY, IBXM_IMAGEGET, 0, 0L);
    ci.cbStruct = sizeof(ci);
    ci.hWndOwner = hDlg;
    ci.clsid = clsid;
    ci.dwFlags  = CIF_SELECTCURRENT;

    // Only show help in the ChangeIcon dialog if we're showing it in this dialog.
    if (lpPS->dwFlags & PSF_SHOWHELP)
        ci.dwFlags |= CIF_SHOWHELP;

    // Let the hook in to customize Change Icon if desired.
    uRet = UStandardHook(lpPS, hDlg, uMsgChangeIcon, 0, (LONG)(LPSTR)&ci);

    if (0 == uRet)
        uRet=(UINT)(OLEUI_OK==OleUIChangeIcon(&ci));

    // Update the display if necessary.
    if (0!=uRet)
    {
        /*
        * OleUIChangeIcon will have already freed our
        * current hMetaPict that we passed in when OK is
        * pressed in that dialog.  So we use 0L as lParam
        * here so the IconBox doesn't try to free the
        * metafilepict again.
        */
        SendDlgItemMessage(hDlg, ID_PS_ICONDISPLAY, IBXM_IMAGESET, (WPARAM)ci.hMetaPict, 0L);
        // Remember the new icon chosen by the user. Note that Paste and PasteLink have separate
        //    icons - changing one does not change the other.
        if (lpPS->fLink)
            lpPS->hMetaPictLSD = ci.hMetaPict;
        else lpPS->hMetaPictOD = ci.hMetaPict;
    }
}

/*
 *SetPasteSpecialHelpResults
 *
 * Purpose:
 *  Sets the help result text and bitmap according to the current
 *  list selection. The following state table indicates which ResultText
 *  and ResultImage are selected. If %s in the lpstrFormatName is present,
 *  it is assumed that an object is being pasted/paste-linked, otherwise it
 *  is assumed that data is being pasted/paste-linked.
 *  Y = Yes; N = No; Blank = State does not matter;
 *  The numbers in the the ResultText and ResultImage columns refer to the table
 *  entries that follow.
 * =====================================================================
 * Paste/       lpstrFormatName in                DisplayAsIcon Result      Result
 * PasteLink    arrPasteEntry[]contains %s        checked       Text        Image
 *              (Is Object == Y, Is Data == N)
 * Paste        N                                               1           1
 * Paste        Y                                 N             2           2
 * Paste        Y                                 Y             3           3
 * PasteLink    N                                               4           4
 * PasteLink    Y                                 N             5           4
 * PasteLink    Y                                 Y             6           5
 * =====================================================================
 * Result Text:
 *
 * 1. "Inserts the contents of the Clipboard into your document as <native type name,
 *     and optionally an additional help sentence>"
 * 2. "Inserts the contents of the Clipboard into your document so that you may
 *     activate it using <object app name>"
 * 3. "Inserts the contents of the Clipboard into your document so that you may
 *     activate it using <object app name>.  It will be displayed as an icon."
 * 4. "Inserts the contents of the Clipboard into your document as <native type name>.
 *     Paste Link creates a link to the source file so that changes to the source file
 *     will be reflected in your document."
 * 5. "Inserts a picture of the Clipboard contents into your document.  Paste Link
 *     creates a link to the source file so that changes to the source file will be
 *     reflected in your document."
 * 6. "Inserts an icon into your document which represents the Clipboard contents.
 *     Paste Link creates a link to the source file so that changes to the source file
 *     will be reflected in your document."
 * =====================================================================
 * Result Image:
 *
 * 1. Clipboard Image
 * 2. Paste image, non-iconic.
 * 3. Paste image, iconic.
 * 4. Paste Link image, non-iconic
 * 5. Paste Link image, iconic
 * ====================================================================
 *
 * Parameters:
 *  hDlg            HWND of the dialog
 *  lpPS             Paste Special Dialog Structure
 *
 * Return Value:
 *  No return value
 */
void SetPasteSpecialHelpResults(HWND hDlg, LPPASTESPECIAL lpPS)
{
    LPTSTR               psz1, psz2, psz3, psz4;
    UINT                i, iString, iImage, cch;
    int                 nPasteEntriesIndex;
    BOOL                fDisplayAsIcon;
    BOOL                fIsObject;
    HWND                hList;
    LPPASTELISTITEMDATA  lpItemData;
    LPOLEUIPASTESPECIAL lpOPS = lpPS->lpOPS;
    LPTSTR       szFullUserTypeName = (lpPS->fLink) ?
                    lpPS->szFullUserTypeNameLSD : lpPS->szFullUserTypeNameOD;
    LPTSTR       szInsert;

    hList = GetDlgItem(hDlg, ID_PS_DISPLAYLIST);

    i=(UINT)SendMessage(hList, LB_GETCURSEL, 0, 0L);
    if (i != LB_ERR)
    {
        lpItemData = (LPPASTELISTITEMDATA)SendMessage(hList, LB_GETITEMDATA, i, 0L);
        if ((LRESULT)lpItemData == LB_ERR) return;
        nPasteEntriesIndex = lpItemData->nPasteEntriesIndex;
        // Check if there is a '%s' in the lpstrFormatName, then an object is being
        //   pasted/pastelinked. Otherwise Data is being pasted-pastelinked.
        fIsObject = FHasPercentS(lpOPS->arrPasteEntries[nPasteEntriesIndex].lpstrFormatName,
                                        lpPS);
    }
    else return;

    // Is DisplayAsIcon checked?
    fDisplayAsIcon=(0L!=(lpPS->dwFlags & PSF_CHECKDISPLAYASICON));

    szInsert = szFullUserTypeName;

    if (lpPS->dwFlags & PSF_SELECTPASTE)     // If user selected Paste
    {
        if (fIsObject)
        {
            iString = fDisplayAsIcon ? IDS_PSPASTEOBJECTASICON : IDS_PSPASTEOBJECT;
            iImage  = fDisplayAsIcon ? RESULTIMAGE_EMBEDICON   : RESULTIMAGE_EMBED;
            szInsert = lpPS->szAppName;
        }
        else
        {
            iString = IDS_PSPASTEDATA;
            iImage  = RESULTIMAGE_PASTE;
        }
    }
    else if (lpPS->dwFlags & PSF_SELECTPASTELINK)   // User selected PasteLink
    {
        if (fIsObject)
        {
            iString = fDisplayAsIcon ? IDS_PSPASTELINKOBJECTASICON : IDS_PSPASTELINKOBJECT;
            iImage  = fDisplayAsIcon ? RESULTIMAGE_LINKICON : RESULTIMAGE_LINK;
        }
        else
        {
            iString = IDS_PSPASTELINKDATA;
            iImage  = RESULTIMAGE_LINK;
        }

    }
    else   // Should never occur.
    {
        iString = IDS_PSNONOLE;
        iImage = RESULTIMAGE_PASTE;
    }

    // hBuff contains enough space for the 4 buffers required to build up the help
    //   result text.
    cch = (UINT)GlobalSize(lpPS->hBuff)/4;

    psz1=(LPTSTR)GlobalLock(lpPS->hBuff);
    psz2=psz1+cch;
    psz3=psz2+cch;
    psz4=psz3+cch;

    // Default is an empty string.
    *psz1=0;

    if (0!=LoadString(ghInst, iString, psz1, cch))
    {
        // Insert the FullUserTypeName of the source object into the partial result text
        //   specified by the container.
        wsprintf(psz3, lpOPS->arrPasteEntries[nPasteEntriesIndex].lpstrResultText,
        (LPTSTR)szInsert);
        // Insert the above partial result text into the standard result text.
        wsprintf(psz4, psz1, (LPTSTR)psz3);
        psz1=psz4;
    }

    // If LoadString failed, we simply clear out the results (*psz1=0 above)
    SetDlgItemText(hDlg, ID_PS_RESULTTEXT, psz1);

    // Change the result bitmap
    SendDlgItemMessage(hDlg, ID_PS_RESULTIMAGE, RIM_IMAGESET, iImage, 0L);

    GlobalUnlock(lpPS->hBuff);
}

/*
 * FAddPasteListItem
 *
 * Purpose:
 *  Adds an item to the list box
 *
 * Parameters:
 *  hList            HWND List into which item is to be added
 *  fInsertFirst     BOOL Insert in the beginning of the list?
 *  nPasteEntriesIndex int Index of Paste Entry array this list item corresponsds to
 *  lpPS             Paste Special Dialog Structure
 *  pIMalloc         LPMALLOC  Memory Allocator
 *  lpszBuf          LPSTR Scratch buffer to build up string for list entry
 *  lpszFullUserTypeName LPSTR full user type name for object entry
 *
 * Return Value:
 *  BOOL            TRUE if sucessful.
 *                  FALSE if unsucessful.
 */
BOOL FAddPasteListItem(
        HWND hList, BOOL fInsertFirst, int nPasteEntriesIndex,
        LPPASTESPECIAL lpPS,
        LPMALLOC pIMalloc, LPTSTR lpszBuf, LPTSTR lpszFullUserTypeName)
{
    LPOLEUIPASTESPECIAL lpOPS = lpPS->lpOPS;
    LPPASTELISTITEMDATA lpItemData;
    int                 nIndex;

    // Allocate memory for each list box item
    lpItemData = (LPPASTELISTITEMDATA)pIMalloc->lpVtbl->Alloc(
            pIMalloc, (DWORD)sizeof(PASTELISTITEMDATA));
    if (NULL == lpItemData)
        return FALSE;

    // Fill data associated with each list box item
    lpItemData->nPasteEntriesIndex = nPasteEntriesIndex;
    lpItemData->fCntrEnableIcon = ((lpOPS->arrPasteEntries[nPasteEntriesIndex].dwFlags &
            OLEUIPASTE_ENABLEICON) ? TRUE : FALSE);

    // Build list box entry string, insert the string and add the data the corresponds to it
    wsprintf(
            (LPTSTR)lpszBuf,
            lpOPS->arrPasteEntries[nPasteEntriesIndex].lpstrFormatName,
            (LPTSTR)lpszFullUserTypeName
    );

    // only add to listbox if not a duplicate
    if (LB_ERR!=SendMessage(hList,LB_FINDSTRING, 0, (LPARAM)(LPTSTR)lpszBuf)) {
        // item is already in list; SKIP this one
        pIMalloc->lpVtbl->Free(pIMalloc, (LPVOID)lpItemData);
        return TRUE;    // this is NOT an error
    }

    nIndex = (int)SendMessage(
            hList,
            (fInsertFirst ? LB_INSERTSTRING : LB_ADDSTRING),
            0,
            (LPARAM)(LPTSTR)lpszBuf
    );
    SendMessage(
            hList,
            LB_SETITEMDATA,
            nIndex,
            (LPARAM)(LPPASTELISTITEMDATA)lpItemData
    );
    return TRUE;
}


/*
 * FFillPasteList
 *
 * Purpose:
 *  Fills the invisible paste list with the formats offered by the clipboard object and
 *  asked for by the container.
 *
 * Parameters:
 *  hDlg            HWND of the dialog
 *  lpPS             Paste Special Dialog Structure
 *
 * Return Value:
 *  BOOL            TRUE if sucessful and if formats could be found.
 *                  FALSE if unsucessful or if no formats could be found.
 */
BOOL FFillPasteList(HWND hDlg, LPPASTESPECIAL lpPS)
{
    LPOLEUIPASTESPECIAL lpOPS = lpPS->lpOPS;
    LPMALLOC            pIMalloc     = NULL;
    LPTSTR               lpszBuf      = (LPTSTR)GlobalLock(lpPS->hBuff);
    HWND                hList;
    int                 i, j;
    int                 nItems = 0;
    int                 nDefFormat = -1;
    BOOL                fTryObjFmt = FALSE;
    BOOL                fInsertFirst;
    BOOL                fExclude;
    HRESULT             hrErr;

    hrErr = CoGetMalloc(MEMCTX_TASK, &pIMalloc);
    if (hrErr != NOERROR)
        goto error;

    hList = GetDlgItem(hDlg, ID_PS_PASTELIST);

    // Loop over the target's priority list of formats
    for (i = 0; i < lpOPS->cPasteEntries; i++)
    {
        if (lpOPS->arrPasteEntries[i].dwFlags != OLEUIPASTE_PASTEONLY &&
                !(lpOPS->arrPasteEntries[i].dwFlags & OLEUIPASTE_PASTE))
            continue;

        fInsertFirst = FALSE;

        if (lpOPS->arrPasteEntries[i].fmtetc.cfFormat==cfFileName
                || lpOPS->arrPasteEntries[i].fmtetc.cfFormat==cfEmbeddedObject
                || lpOPS->arrPasteEntries[i].fmtetc.cfFormat==cfEmbedSource) {
            if (! fTryObjFmt) {
                fTryObjFmt = TRUE;      // only use 1st object format
                fInsertFirst = TRUE;    // OLE obj format should always be 1st

                //Check if this CLSID is in the exclusion list.
                fExclude=FALSE;

                for (j=0; j < (int)lpOPS->cClsidExclude; j++)
                {
                    if (IsEqualCLSID(&lpPS->clsidOD,
                                     (LPCLSID)(lpOPS->lpClsidExclude+j)))
                    {
                        fExclude=TRUE;
                        break;
                    }
                }

                if (fExclude)
                    continue;   // don't add the object entry to list

            } else {
                continue;   // already added an object format to list
            }
        }

        // add to list if entry is marked TRUE
        if (lpOPS->arrPasteEntries[i].dwScratchSpace) {
            if (nDefFormat < 0)
                nDefFormat = (fInsertFirst ? 0 : nItems);
            else if (fInsertFirst)
                nDefFormat++;   // adjust for obj fmt inserted 1st in list

            if (!FAddPasteListItem(hList, fInsertFirst, i, lpPS, pIMalloc,
                        lpszBuf, lpPS->szFullUserTypeNameOD))
                goto error;
            nItems++;
        }
    }

    // initialize selection to first format matched in list
    if (nDefFormat >= 0)
        lpPS->nPasteListCurSel = nDefFormat;

    // Clean up
    if (pIMalloc)
        pIMalloc->lpVtbl->Release(pIMalloc);
    if (lpszBuf)
       GlobalUnlock(lpPS->hBuff);

    // If no items have been added to the list box (none of the formats
    //   offered by the source matched those acceptable to the container),
    //   return FALSE
    if (nItems > 0)
        return TRUE;
    else
        return FALSE;

error:
    if (pIMalloc)
        pIMalloc->lpVtbl->Release(pIMalloc);
    if (lpszBuf)
       GlobalUnlock(lpPS->hBuff);
    FreeListData(hList);

    return FALSE;
}


/*
 * FFillPasteLinkList
 *
 * Purpose:
 *  Fills the invisible paste link list with the formats offered by the clipboard object and
 *  asked for by the container.
 *
 * Parameters:
 *  hDlg            HWND of the dialog
 *  lpPS             Paste Special Dialog Structure
 *
 * Return Value:
 *  BOOL            TRUE if sucessful and if formats could be found.
 *                  FALSE if unsucessful or if no formats could be found.
 */
BOOL FFillPasteLinkList(HWND hDlg, LPPASTESPECIAL lpPS)
{
    LPOLEUIPASTESPECIAL lpOPS        = lpPS->lpOPS;
    LPDATAOBJECT        lpSrcDataObj = lpOPS->lpSrcDataObj;
    LPENUMFORMATETC     lpEnumFmtEtc = NULL;
    LPMALLOC            pIMalloc     = NULL;
    LPTSTR               lpszBuf      = (LPTSTR)GlobalLock(lpPS->hBuff);
    OLEUIPASTEFLAG      pasteFlag;
    UINT arrLinkTypesSupported[PS_MAXLINKTYPES];  // Array of flags that
                                                  // indicate which link types
                                                  // are supported by source.
    FORMATETC           fmtetc;
    int                 i, j;
    int                 nItems = 0;
    BOOL                fLinkTypeSupported = FALSE;
    HWND                hList;
    int                 nDefFormat = -1;
    BOOL                fTryObjFmt = FALSE;
    BOOL                fInsertFirst;
    HRESULT             hrErr;

    hrErr = CoGetMalloc(MEMCTX_TASK, &pIMalloc);
    if (hrErr != NOERROR)
        goto error;

    // Remember which link type formats are offered by lpSrcDataObj.
    _fmemset(&fmtetc, 0, sizeof(FORMATETC));
    for (i = 0; i < lpOPS->cLinkTypes; i++)
    {
        if (lpOPS->arrLinkTypes[i] = cfLinkSource) {
            OLEDBG_BEGIN2(TEXT("OleQueryLinkFromData called\r\n"))
            hrErr = OleQueryLinkFromData(lpSrcDataObj);
            OLEDBG_END2
            if(NOERROR == hrErr)
            {
                arrLinkTypesSupported[i] = 1;
                fLinkTypeSupported = TRUE;
            }
            else arrLinkTypesSupported[i] = 0;
        }
        else {
            fmtetc.cfFormat = lpOPS->arrLinkTypes[i];
            fmtetc.dwAspect = DVASPECT_CONTENT;
            fmtetc.tymed    = 0xFFFFFFFF;       // All tymed values
            fmtetc.lindex   = -1;
            OLEDBG_BEGIN2(TEXT("IDataObject::QueryGetData called\r\n"))
            hrErr = lpSrcDataObj->lpVtbl->QueryGetData(lpSrcDataObj,&fmtetc);
            OLEDBG_END2
            if(NOERROR == hrErr)
            {
                arrLinkTypesSupported[i] = 1;
                fLinkTypeSupported = TRUE;
            }
            else arrLinkTypesSupported[i] = 0;
        }
    }
    // No link types are offered by lpSrcDataObj
    if (! fLinkTypeSupported) {
        nItems = 0;
        goto cleanup;
    }

    hList = GetDlgItem(hDlg, ID_PS_PASTELINKLIST);

    // Enumerate the formats acceptable to container
    for (i = 0; i < lpOPS->cPasteEntries; i++)
    {
        fLinkTypeSupported = FALSE;

        // If container will accept any link type offered by source object
        if (lpOPS->arrPasteEntries[i].dwFlags & OLEUIPASTE_LINKANYTYPE)
            fLinkTypeSupported = TRUE;
        else
        {
            // Check if any of the link types offered by the source
            //    object are acceptable to the container
            // This code depends on the LINKTYPE enum values being powers of 2
            for (pasteFlag = OLEUIPASTE_LINKTYPE1, j = 0;
                 j < lpOPS->cLinkTypes;
                 pasteFlag*=2, j++)
            {
                if ((lpOPS->arrPasteEntries[i].dwFlags & pasteFlag) &&
                        arrLinkTypesSupported[j])
                {
                    fLinkTypeSupported = TRUE;
                    break;
                }
            }
        }

        fInsertFirst = FALSE;

        if (lpOPS->arrPasteEntries[i].fmtetc.cfFormat==cfFileName
                || lpOPS->arrPasteEntries[i].fmtetc.cfFormat==cfLinkSource) {
            if (! fTryObjFmt) {
                fTryObjFmt = TRUE;      // only use 1st object format
                fInsertFirst = TRUE;    // OLE obj format should always be 1st
            } else {
                continue;   // already added an object format to list
            }
        }

        // add to list if entry is marked TRUE
        if (fLinkTypeSupported && lpOPS->arrPasteEntries[i].dwScratchSpace) {
            if (nDefFormat < 0)
                nDefFormat = (fInsertFirst ? 0 : nItems);
            else if (fInsertFirst)
                nDefFormat++;   // adjust for obj fmt inserted 1st in list

            if (!FAddPasteListItem(hList, fInsertFirst, i, lpPS, pIMalloc,
                        lpszBuf, lpPS->szFullUserTypeNameLSD))
                goto error;
            nItems++;
        }
    } // end FOR

    nItems = (int)SendMessage(hList, LB_GETCOUNT, 0, 0L);

    // initialize selection to first format matched in list
    if (nDefFormat >= 0)
        lpPS->nPasteLinkListCurSel = nDefFormat;

cleanup:
    // Clean up
    if (pIMalloc)
        pIMalloc->lpVtbl->Release(pIMalloc);
    if (lpszBuf)
       GlobalUnlock(lpPS->hBuff);

    // If no items have been added to the list box (none of the formats
    //   offered by the source matched those acceptable to the destination),
    //   return FALSE
    if (nItems > 0)
        return TRUE;
    else
        return FALSE;

error:
    if (pIMalloc)
        pIMalloc->lpVtbl->Release(pIMalloc);
    if (lpszBuf)
       GlobalUnlock(lpPS->hBuff);
    FreeListData(hList);

    return FALSE;
}


/*
 * FreeListData
 *
 * Purpose:
 *  Free the local memory associated with each list box item
 *
 * Parameters:
 *  hList           HWND of the list
 *
 * Return Value:
 *  None
 */
void FreeListData(HWND hList)
{
    int                nItems, i;
    LPPASTELISTITEMDATA lpItemData;
    LPMALLOC           pIMalloc;
    HRESULT            hrErr;

    hrErr = CoGetMalloc(MEMCTX_TASK, &pIMalloc);
    if (hrErr != NOERROR)
        return;

    nItems = (int) SendMessage(hList, LB_GETCOUNT, 0, 0L);
    for (i = 0; i < nItems; i++)
    {
        lpItemData = (LPPASTELISTITEMDATA)SendMessage(hList, LB_GETITEMDATA, (WPARAM)i, 0L);
        if ((LRESULT)lpItemData != LB_ERR)
            pIMalloc->lpVtbl->Free(pIMalloc, (LPVOID)lpItemData);
    }
    pIMalloc->lpVtbl->Release(pIMalloc);
}

/*
 * FHasPercentS
 *
 * Purpose:
 *  Determines if string contains %s.
 *
 * Parameters:
 *  lpsz            LPCSTR string in which occurence of '%s' is looked for
 *
 * Return Value:
 *  BOOL            TRUE if %s is found, else FALSE.
 */

BOOL FHasPercentS(LPCTSTR lpsz, LPPASTESPECIAL lpPS)
{
   int n = 0;
   LPTSTR lpszTmp;

   if (!lpsz) return FALSE;
   // Copy input string to buffer. This allows caller to pass a
   //   code-based string. Code segments may be swapped out in low memory situations
   //   and so code-based strings need to be copied before string elements can be accessed.
   lpszTmp = (LPTSTR)GlobalLock(lpPS->hBuff);
   lstrcpy(lpszTmp, lpsz);

   while (*lpszTmp)
   {
       if (*lpszTmp == TEXT('%'))
       {
#ifdef WIN32
           // AnsiNext is obsolete in Win32
           lpszTmp = CharNext(lpszTmp);
#else
           lpszTmp = AnsiNext(lpszTmp);
#endif
           if (*lpszTmp == TEXT('s'))            // If %s, return
           {
               GlobalUnlock(lpPS->hBuff);
               return TRUE;
           }
           else if (*lpszTmp == TEXT('%'))        // if %%, skip to next character
#ifdef WIN32
               // AnsiNext is obsolete in Win32
               lpszTmp = CharNext(lpszTmp);
#else
               lpszTmp = AnsiNext(lpszTmp);
#endif
       }
       else
#ifdef WIN32
          lpszTmp = CharNext(lpszTmp);
#else
          lpszTmp = AnsiNext(lpszTmp);
#endif
   }

   GlobalUnlock(lpPS->hBuff);
   return FALSE;
}

/*
 * AllocateScratchMem
 *
 * Purpose:
 *  Allocates scratch memory for use by the PasteSpecial dialog. The memory is
 *  is used as the buffer for building up strings using wsprintf. Strings are built up
 *  using the buffer while inserting items into the Paste & PasteLink lists and while
 *  setting the help result text. It must be big  enough to handle the string that results after
 *  replacing the %s in the lpstrFormatName and lpstrResultText in arrPasteEntries[]
 *  by the FullUserTypeName. It must also be big enough to build the dialog's result text
 *  after %s substitutions by the FullUserTypeName or the ApplicationName.
 *
 * Parameters:
 *  lpPS             Paste Special Dialog Structure
 *
 * Return Value:
 *  HGLOBAL         Handle to allocated global memory
 */

HGLOBAL AllocateScratchMem(LPPASTESPECIAL lpPS)
{
    LPOLEUIPASTESPECIAL lpOPS = lpPS->lpOPS;
    int nLen, i;
    int nSubstitutedText = 0;
    int nAlloc = 0;

    // Get the maximum length of the FullUserTypeNames specified by OBJECTDESCRIPTOR
    //   and the LINKSRCDESCRIPTOR and the Application Name. Any of these may be substituted
    //   for %s in the result-text/list entries.
    if (lpPS->szFullUserTypeNameOD)
        nSubstitutedText = lstrlen(lpPS->szFullUserTypeNameOD);
    if (lpPS->szFullUserTypeNameLSD)
        nSubstitutedText = __max(nSubstitutedText, lstrlen(lpPS->szFullUserTypeNameLSD));
    if (lpPS->szAppName)
        nSubstitutedText = __max(nSubstitutedText, lstrlen(lpPS->szAppName));

    // Get the maximum length of lpstrFormatNames & lpstrResultText in arrPasteEntries
    nLen = 0;
    for (i = 0; i < lpOPS->cPasteEntries; i++)
    {
       nLen = __max(nLen, lstrlen(lpOPS->arrPasteEntries[i].lpstrFormatName));
       nLen = __max(nLen, lstrlen(lpOPS->arrPasteEntries[i].lpstrResultText));
    }

    // Get the maximum length of lpstrFormatNames and lpstrResultText after %s  has
    //   been substituted (At most one %s can appear in each string).
    //   Add 1 to hold NULL terminator.
    nAlloc = (nLen+nSubstitutedText+1)*sizeof(TCHAR);

    // Allocate scratch memory to be used to build strings
    // nAlloc is big enough to hold any of the lpstrResultText or lpstrFormatName in arrPasteEntries[]
    //   after %s substitution.
    // We also need space to build up the help result text. 512 is the maximum length of the
    //   standard dialog help text before substitutions. 512+nAlloc is the maximum length
    //   after %s substition.
    // SetPasteSpecialHelpResults() requires 4 such buffers to build up the result text
    return GlobalAlloc(GHND, (DWORD)4*(512+nAlloc));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\letest\ole2ui\oleutl.c ===
/*
 * OLEUTL.C
 *
 * Miscellaneous utility functions for OLE 2.0 Applications:
 *
 *  Function                      Purpose
 *  -------------------------------------------------------------------
 *  SetDCToDrawInHimetricRect     Sets up an HIMETRIC mapping mode in a DC.
 *  ResetOrigDC                   Performs the opposite of
 *                                SetDCToDrawInHimetricRect
 *  XformWidthInPixelsToHimetric  Converts an int width into HiMetric units
 *  XformWidthInHimetricToPixels  Converts an int width from HiMetric units
 *  XformHeightInPixelsToHimetric Converts an int height into HiMetric units
 *  XformHeightInHimetricToPixels Converts an int height from HiMetric units
 *  XformRectInPixelsToHimetric   Converts a rect into HiMetric units
 *  XformRectInHimetricToPixels   Converts a rect from HiMetric units
 *  XformSizeInPixelsToHimetric   Converts a SIZEL into HiMetric units
 *  XformSizeInHimetricToPixels   Converts a SIZEL from HiMetric units
 *  AreRectsEqual                 Compares to Rect's
 *
 *  ParseCmdLine                  Determines if -Embedding exists
 *  OpenOrCreateRootStorage       Creates a root docfile for OLE storage
 *  CommitStorage                 Commits all changes in a docfile
 *  CreateChildStorage            Creates child storage in another storage
 *  OpenChildStorage              Opens child storage in another storage
 *
 *
 * Copyright (c)1992 Microsoft Corporation, All Right Reserved
 */


#define STRICT  1
#include "ole2ui.h"
#include <stdlib.h>
#include <ctype.h>

//Internal function to this module. No need for UNICODE in this function
static LPSTR GetWord(LPSTR lpszSrc, LPSTR lpszDst);


/*
 * SetDCToAnisotropic
 *
 * Purpose:
 *  Setup the correspondence between the rect in device unit (Viewport) and
 *  the rect in logical unit (Window) so that the proper scaling of
 *  coordinate systems will be calculated. set up both the Viewport and
 *  the window as follows:
 *
 *      1) ------------------ ( 2
 *      |                     |
 *      |                     |
 *      |                     |
 *      |                     |
 *      |                     |
 *      3) ------------------ ( 4
 *
 *      Origin   = P3
 *      X extent = P2x - P3x
 *      Y extent = P2y - P3y
 *
 * Parameters:
 *  hDC             HDC to affect
 *  lprcPhysical    LPRECT containing the physical (device) extents of DC
 *  lprcLogical     LPRECT containing the logical extents
 *  lprcWindowOld   LPRECT in which to preserve the window for ResetOrigDC
 *  lprcViewportOld LPRECT in which to preserver the viewport for ResetOrigDC
 *
 * Return Value:
 *  int             The original mapping mode of the DC.
 */

STDAPI_(int) SetDCToAnisotropic(
        HDC hDC,
        LPRECT lprcPhysical, LPRECT lprcLogical,
        LPRECT lprcWindowOld, LPRECT lprcViewportOld)
{
    int     nMapModeOld=SetMapMode(hDC, MM_ANISOTROPIC);

    SetWindowOrgEx(hDC, lprcLogical->left, lprcLogical->bottom, (LPPOINT)&lprcWindowOld->left);
    SetWindowExtEx(hDC, (lprcLogical->right-lprcLogical->left), (lprcLogical->top-lprcLogical->bottom), (LPSIZE)&lprcWindowOld->right);
    SetViewportOrgEx(hDC, lprcPhysical->left, lprcPhysical->bottom, (LPPOINT)&lprcViewportOld->left);
    SetViewportExtEx(hDC, (lprcPhysical->right-lprcPhysical->left), (lprcPhysical->top-lprcPhysical->bottom), (LPSIZE)&lprcViewportOld->right);

    return nMapModeOld;
}


/*
 * SetDCToDrawInHimetricRect
 *
 * Purpose:
 *  Setup the correspondence between the rect in pixels (Viewport) and
 *  the rect in HIMETRIC (Window) so that the proper scaling of
 *  coordinate systems will be calculated. set up both the Viewport and
 *  the window as follows:
 *
 *      1) ------------------ ( 2
 *      |                     |
 *      |                     |
 *      |                     |
 *      |                     |
 *      |                     |
 *      3) ------------------ ( 4
 *
 *      Origin   = P3
 *      X extent = P2x - P3x
 *      Y extent = P2y - P3y
 *
 * Parameters:
 *  hDC             HDC to affect
 *  lprcPix         LPRECT containing the pixel extents of DC
 *  lprcHiMetric    LPRECT to receive the himetric extents
 *  lprcWindowOld   LPRECT in which to preserve the window for ResetOrigDC
 *  lprcViewportOld LPRECT in which to preserver the viewport for ResetOrigDC
 *
 * Return Value:
 *  int             The original mapping mode of the DC.
 */
STDAPI_(int) SetDCToDrawInHimetricRect(
    HDC hDC,
    LPRECT lprcPix, LPRECT lprcHiMetric,
    LPRECT lprcWindowOld, LPRECT lprcViewportOld)
    {
    int     nMapModeOld=SetMapMode(hDC, MM_ANISOTROPIC);
    BOOL    fSystemDC  =FALSE;

    if (NULL==hDC)
        {
        hDC=GetDC(NULL);
        fSystemDC=TRUE;
        }

    XformRectInPixelsToHimetric(hDC, lprcPix, lprcHiMetric);

    SetWindowOrgEx(hDC, lprcHiMetric->left, lprcHiMetric->bottom, (LPPOINT)&lprcWindowOld->left);
    SetWindowExtEx(hDC, (lprcHiMetric->right-lprcHiMetric->left), (lprcHiMetric->top-lprcHiMetric->bottom), (LPSIZE)&lprcWindowOld->right);
    SetViewportOrgEx(hDC, lprcPix->left, lprcPix->bottom, (LPPOINT)&lprcViewportOld->left);
    SetViewportExtEx(hDC, (lprcPix->right-lprcPix->left), (lprcPix->top-lprcPix->bottom), (LPSIZE)&lprcViewportOld->right);

    if (fSystemDC)
        ReleaseDC(NULL, hDC);

    return nMapModeOld;
    }



/*
 * ResetOrigDC
 *
 * Purpose:
 *  Restores a DC set to draw in himetric from SetDCToDrawInHimetricRect.
 *
 * Parameters:
 *  hDC             HDC to restore
 *  nMapModeOld     int original mapping mode of hDC
 *  lprcWindowOld   LPRECT filled in SetDCToDrawInHimetricRect
 *  lprcViewportOld LPRECT filled in SetDCToDrawInHimetricRect
 *
 * Return Value:
 *  int             Same as nMapModeOld.
 */

STDAPI_(int) ResetOrigDC(
    HDC hDC, int nMapModeOld,
    LPRECT lprcWindowOld, LPRECT lprcViewportOld)
    {
    POINT     pOld;

    SetMapMode(hDC, nMapModeOld);

    SetWindowOrgEx(hDC,   lprcWindowOld->left,    lprcWindowOld->top,      (LPPOINT)&pOld);
    SetWindowExtEx(hDC,   lprcWindowOld->right,   lprcWindowOld->bottom,   (LPSIZE)&pOld);
    SetViewportOrgEx(hDC, lprcViewportOld->left,  lprcViewportOld->top,    (LPPOINT)&pOld);
    SetViewportExtEx(hDC, lprcViewportOld->right, lprcViewportOld->bottom, (LPSIZE)&pOld);

    return nMapModeOld;
    }



/*
 * XformWidthInPixelsToHimetric
 * XformWidthInHimetricToPixels
 * XformHeightInPixelsToHimetric
 * XformHeightInHimetricToPixels
 *
 * Functions to convert an int between a device coordinate system and
 * logical HiMetric units.
 *
 * Parameters:
 *  hDC             HDC providing reference to the pixel mapping.  If
 *                  NULL, a screen DC is used.
 *
 *  Size Functions:
 *  lpSizeSrc       LPSIZEL providing the structure to convert.  This
 *                  contains pixels in XformSizeInPixelsToHimetric and
 *                  logical HiMetric units in the complement function.
 *  lpSizeDst       LPSIZEL providing the structure to receive converted
 *                  units.  This contains pixels in
 *                  XformSizeInPixelsToHimetric and logical HiMetric
 *                  units in the complement function.
 *
 *  Width Functions:
 *  iWidth          int containing the value to convert.
 *
 * Return Value:
 *  Size Functions:     None
 *  Width Functions:    Converted value of the input parameters.
 *
 * NOTE:
 *  When displaying on the screen, Window apps display everything enlarged
 *  from its actual size so that it is easier to read. For example, if an
 *  app wants to display a 1in. horizontal line, that when printed is
 *  actually a 1in. line on the printed page, then it will display the line
 *  on the screen physically larger than 1in. This is described as a line
 *  that is "logically" 1in. along the display width. Windows maintains as
 *  part of the device-specific information about a given display device:
 *      LOGPIXELSX -- no. of pixels per logical in along the display width
 *      LOGPIXELSY -- no. of pixels per logical in along the display height
 *
 *  The following formula converts a distance in pixels into its equivalent
 *  logical HIMETRIC units:
 *
 *      DistInHiMetric = (HIMETRIC_PER_INCH * DistInPix)
 *                       -------------------------------
 *                           PIXELS_PER_LOGICAL_IN
 *
 */
STDAPI_(int) XformWidthInPixelsToHimetric(HDC hDC, int iWidthInPix)
    {
    int     iXppli;     //Pixels per logical inch along width
    int     iWidthInHiMetric;
    BOOL    fSystemDC=FALSE;

    if (NULL==hDC)
        {
        hDC=GetDC(NULL);
        fSystemDC=TRUE;
        }

    iXppli = GetDeviceCaps (hDC, LOGPIXELSX);

    //We got pixel units, convert them to logical HIMETRIC along the display
    iWidthInHiMetric = MAP_PIX_TO_LOGHIM(iWidthInPix, iXppli);

    if (fSystemDC)
        ReleaseDC(NULL, hDC);

    return iWidthInHiMetric;
    }


STDAPI_(int) XformWidthInHimetricToPixels(HDC hDC, int iWidthInHiMetric)
    {
    int     iXppli;     //Pixels per logical inch along width
    int     iWidthInPix;
    BOOL    fSystemDC=FALSE;

    if (NULL==hDC)
        {
        hDC=GetDC(NULL);
        fSystemDC=TRUE;
        }

    iXppli = GetDeviceCaps (hDC, LOGPIXELSX);

    //We got logical HIMETRIC along the display, convert them to pixel units
    iWidthInPix = MAP_LOGHIM_TO_PIX(iWidthInHiMetric, iXppli);

    if (fSystemDC)
        ReleaseDC(NULL, hDC);

    return iWidthInPix;
    }


STDAPI_(int) XformHeightInPixelsToHimetric(HDC hDC, int iHeightInPix)
    {
    int     iYppli;     //Pixels per logical inch along height
    int     iHeightInHiMetric;
    BOOL    fSystemDC=FALSE;

    if (NULL==hDC)
        {
        hDC=GetDC(NULL);
        fSystemDC=TRUE;
        }

    iYppli = GetDeviceCaps (hDC, LOGPIXELSY);

    //* We got pixel units, convert them to logical HIMETRIC along the display
    iHeightInHiMetric = MAP_PIX_TO_LOGHIM(iHeightInPix, iYppli);

    if (fSystemDC)
        ReleaseDC(NULL, hDC);

    return iHeightInHiMetric;
    }


STDAPI_(int) XformHeightInHimetricToPixels(HDC hDC, int iHeightInHiMetric)
    {
    int     iYppli;     //Pixels per logical inch along height
    int     iHeightInPix;
    BOOL    fSystemDC=FALSE;

    if (NULL==hDC)
        {
        hDC=GetDC(NULL);
        fSystemDC=TRUE;
        }

    iYppli = GetDeviceCaps (hDC, LOGPIXELSY);

    //* We got logical HIMETRIC along the display, convert them to pixel units
    iHeightInPix = MAP_LOGHIM_TO_PIX(iHeightInHiMetric, iYppli);

    if (fSystemDC)
        ReleaseDC(NULL, hDC);

    return iHeightInPix;
    }



/*
 * XformRectInPixelsToHimetric
 * XformRectInHimetricToPixels
 *
 * Purpose:
 *  Convert a rectangle between pixels of a given hDC and HIMETRIC units
 *  as manipulated in OLE.  If the hDC is NULL, then a screen DC is used
 *  and assumes the MM_TEXT mapping mode.
 *
 * Parameters:
 *  hDC             HDC providing reference to the pixel mapping.  If
 *                  NULL, a screen DC is used.
 *  lprcSrc         LPRECT providing the rectangle to convert.  This
 *                  contains pixels in XformRectInPixelsToHimetric and
 *                  logical HiMetric units in the complement function.
 *  lprcDst         LPRECT providing the rectangle to receive converted units.
 *                  This contains pixels in XformRectInPixelsToHimetric and
 *                  logical HiMetric units in the complement function.
 *
 * Return Value:
 *  None
 *
 * NOTE:
 *  When displaying on the screen, Window apps display everything enlarged
 *  from its actual size so that it is easier to read. For example, if an
 *  app wants to display a 1in. horizontal line, that when printed is
 *  actually a 1in. line on the printed page, then it will display the line
 *  on the screen physically larger than 1in. This is described as a line
 *  that is "logically" 1in. along the display width. Windows maintains as
 *  part of the device-specific information about a given display device:
 *      LOGPIXELSX -- no. of pixels per logical in along the display width
 *      LOGPIXELSY -- no. of pixels per logical in along the display height
 *
 *  The following formula converts a distance in pixels into its equivalent
 *  logical HIMETRIC units:
 *
 *      DistInHiMetric = (HIMETRIC_PER_INCH * DistInPix)
 *                      -------------------------------
 *                            PIXELS_PER_LOGICAL_IN
 *
 * Rect in Pixels (MM_TEXT):
 *
 *              0---------- X
 *              |
 *              |       1) ------------------ ( 2   P1 = (rc.left, rc.top)
 *              |       |                     |     P2 = (rc.right, rc.top)
 *              |       |                     |     P3 = (rc.left, rc.bottom)
 *              |       |                     |     P4 = (rc.right, rc.bottom)
 *                      |                     |
 *              Y       |                     |
 *                      3) ------------------ ( 4
 *
 *              NOTE:   Origin   = (P1x, P1y)
 *                      X extent = P4x - P1x
 *                      Y extent = P4y - P1y
 *
 *
 * Rect in Himetric (MM_HIMETRIC):
 *
 *
 *                      1) ------------------ ( 2   P1 = (rc.left, rc.top)
 *              Y       |                     |     P2 = (rc.right, rc.top)
 *                      |                     |     P3 = (rc.left, rc.bottom)
 *              |       |                     |     P4 = (rc.right, rc.bottom)
 *              |       |                     |
 *              |       |                     |
 *              |       3) ------------------ ( 4
 *              |
 *              0---------- X
 *
 *              NOTE:   Origin   = (P3x, P3y)
 *                      X extent = P2x - P3x
 *                      Y extent = P2y - P3y
 *
 *
 */

STDAPI_(void) XformRectInPixelsToHimetric(
    HDC hDC, LPRECT lprcPix, LPRECT lprcHiMetric)
    {
    int     iXppli;     //Pixels per logical inch along width
    int     iYppli;     //Pixels per logical inch along height
    int     iXextInPix=(lprcPix->right-lprcPix->left);
    int     iYextInPix=(lprcPix->bottom-lprcPix->top);
    BOOL    fSystemDC=FALSE;

    if (NULL==hDC || GetDeviceCaps(hDC, LOGPIXELSX) == 0)
        {
        hDC=GetDC(NULL);
        fSystemDC=TRUE;
        }

    iXppli = GetDeviceCaps (hDC, LOGPIXELSX);
    iYppli = GetDeviceCaps (hDC, LOGPIXELSY);

    //We got pixel units, convert them to logical HIMETRIC along the display
    lprcHiMetric->right = MAP_PIX_TO_LOGHIM(iXextInPix, iXppli);
    lprcHiMetric->top   = MAP_PIX_TO_LOGHIM(iYextInPix, iYppli);

    lprcHiMetric->left    = 0;
    lprcHiMetric->bottom  = 0;

    if (fSystemDC)
        ReleaseDC(NULL, hDC);

    return;
    }



STDAPI_(void) XformRectInHimetricToPixels(
    HDC hDC, LPRECT lprcHiMetric, LPRECT lprcPix)
    {
    int     iXppli;     //Pixels per logical inch along width
    int     iYppli;     //Pixels per logical inch along height
    int     iXextInHiMetric=(lprcHiMetric->right-lprcHiMetric->left);
    int     iYextInHiMetric=(lprcHiMetric->bottom-lprcHiMetric->top);
    BOOL    fSystemDC=FALSE;

    if (NULL==hDC || GetDeviceCaps(hDC, LOGPIXELSX) == 0)
        {
        hDC=GetDC(NULL);
        fSystemDC=TRUE;
        }

    iXppli = GetDeviceCaps (hDC, LOGPIXELSX);
    iYppli = GetDeviceCaps (hDC, LOGPIXELSY);

    //We got pixel units, convert them to logical HIMETRIC along the display
    lprcPix->right = MAP_LOGHIM_TO_PIX(iXextInHiMetric, iXppli);
    lprcPix->top   = MAP_LOGHIM_TO_PIX(iYextInHiMetric, iYppli);

    lprcPix->left  = 0;
    lprcPix->bottom= 0;

    if (fSystemDC)
        ReleaseDC(NULL, hDC);

    return;
    }




/*
 * XformSizeInPixelsToHimetric
 * XformSizeInHimetricToPixels
 *
 * Functions to convert a SIZEL structure (Size functions) or
 * an int (Width functions) between a device coordinate system and
 * logical HiMetric units.
 *
 * Parameters:
 *  hDC             HDC providing reference to the pixel mapping.  If
 *                  NULL, a screen DC is used.
 *
 *  Size Functions:
 *  lpSizeSrc       LPSIZEL providing the structure to convert.  This
 *                  contains pixels in XformSizeInPixelsToHimetric and
 *                  logical HiMetric units in the complement function.
 *  lpSizeDst       LPSIZEL providing the structure to receive converted
 *                  units.  This contains pixels in
 *                  XformSizeInPixelsToHimetric and logical HiMetric
 *                  units in the complement function.
 *
 *  Width Functions:
 *  iWidth          int containing the value to convert.
 *
 * Return Value:
 *  Size Functions:     None
 *  Width Functions:    Converted value of the input parameters.
 *
 * NOTE:
 *  When displaying on the screen, Window apps display everything enlarged
 *  from its actual size so that it is easier to read. For example, if an
 *  app wants to display a 1in. horizontal line, that when printed is
 *  actually a 1in. line on the printed page, then it will display the line
 *  on the screen physically larger than 1in. This is described as a line
 *  that is "logically" 1in. along the display width. Windows maintains as
 *  part of the device-specific information about a given display device:
 *      LOGPIXELSX -- no. of pixels per logical in along the display width
 *      LOGPIXELSY -- no. of pixels per logical in along the display height
 *
 *  The following formula converts a distance in pixels into its equivalent
 *  logical HIMETRIC units:
 *
 *      DistInHiMetric = (HIMETRIC_PER_INCH * DistInPix)
 *                       -------------------------------
 *                           PIXELS_PER_LOGICAL_IN
 *
 */

STDAPI_(void) XformSizeInPixelsToHimetric(
    HDC hDC, LPSIZEL lpSizeInPix, LPSIZEL lpSizeInHiMetric)
    {
    int     iXppli;     //Pixels per logical inch along width
    int     iYppli;     //Pixels per logical inch along height
    BOOL    fSystemDC=FALSE;

    if (NULL==hDC || GetDeviceCaps(hDC, LOGPIXELSX) == 0)
        {
        hDC=GetDC(NULL);
        fSystemDC=TRUE;
        }

    iXppli = GetDeviceCaps (hDC, LOGPIXELSX);
    iYppli = GetDeviceCaps (hDC, LOGPIXELSY);

    //We got pixel units, convert them to logical HIMETRIC along the display
    lpSizeInHiMetric->cx = (long)MAP_PIX_TO_LOGHIM((int)lpSizeInPix->cx, iXppli);
    lpSizeInHiMetric->cy = (long)MAP_PIX_TO_LOGHIM((int)lpSizeInPix->cy, iYppli);

    if (fSystemDC)
        ReleaseDC(NULL, hDC);

    return;
    }


STDAPI_(void) XformSizeInHimetricToPixels(
    HDC hDC, LPSIZEL lpSizeInHiMetric, LPSIZEL lpSizeInPix)
    {
    int     iXppli;     //Pixels per logical inch along width
    int     iYppli;     //Pixels per logical inch along height
    BOOL    fSystemDC=FALSE;

    if (NULL==hDC || GetDeviceCaps(hDC, LOGPIXELSX) == 0)
        {
        hDC=GetDC(NULL);
        fSystemDC=TRUE;
        }

    iXppli = GetDeviceCaps (hDC, LOGPIXELSX);
    iYppli = GetDeviceCaps (hDC, LOGPIXELSY);

    //We got logical HIMETRIC along the display, convert them to pixel units
    lpSizeInPix->cx = (long)MAP_LOGHIM_TO_PIX((int)lpSizeInHiMetric->cx, iXppli);
    lpSizeInPix->cy = (long)MAP_LOGHIM_TO_PIX((int)lpSizeInHiMetric->cy, iYppli);

    if (fSystemDC)
        ReleaseDC(NULL, hDC);

    return;
    }


#if defined( OBSOLETE )
// This function has been converted to a macro

/* AreRectsEqual
** -------------
*/
STDAPI_(BOOL) AreRectsEqual(LPRECT lprc1, LPRECT lprc2)
{
    if ((lprc1->top == lprc2->top) &&
        (lprc1->left == lprc2->left) &&
        (lprc1->right == lprc2->right) &&
        (lprc1->bottom == lprc2->bottom))
        return TRUE;

    return FALSE;
}
#endif  // OBSOLETE


/*
 * ParseCmdLine
 *
 * Parses the Windows command line which was passed to WinMain.
 * This function determines if the -Embedding switch has been given.
 *
 */

STDAPI_(void) ParseCmdLine(
    LPSTR lpszLine,
    BOOL FAR* lpfEmbedFlag,
    LPSTR szFileName)
{
    int i=0;
    CHAR szBuf[256];

    if(lpfEmbedFlag)
        *lpfEmbedFlag = FALSE;
    szFileName[0]='\0';             // NULL string

    // skip blanks
    while(isspace(*lpszLine)) lpszLine++;

    if(!*lpszLine)   // No filename or options, so start a fresh document.
        return;

    // Check for "-Embedding" or "/Embedding" and set fEmbedding.
    if(lpfEmbedFlag && (*lpszLine == '-' || *lpszLine == '/')) {
        lpszLine++;
        lpszLine = GetWord(lpszLine, szBuf);
        *lpfEmbedFlag = (BOOL) !strcmp(szBuf, EMBEDDINGFLAG);
    }

    // skip blanks
    while(isspace(*lpszLine)) lpszLine++;

    // set szFileName to argument
    while(lpszLine[i]) {
        szFileName[i]=lpszLine[i];
        i++;
    }
    szFileName[i]='\0';
}


/* GetWord
 * -------
 *
 * LPSTR lpszSrc - Pointer to a source string
 * LPSTR lpszDst - Pointer to destination buffer
 *
 * Will copy one space-terminated or null-terminated word from the source
 * string to the destination buffer.
 * returns: pointer to next character following the word.
 */
static LPSTR GetWord(LPSTR lpszSrc, LPSTR lpszDst)
{
    while (*lpszSrc && !isspace(*lpszSrc))
        *lpszDst++ = *lpszSrc++;

    *lpszDst = '\0';
    return lpszSrc;
}






=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\letest\ole2ui\precomp.c ===
/*
 * PRECOMP.C
 *
 * This file is used to precompile the OLE2UI.H header file
 *
 * Copyright (c)1992 Microsoft Corporation, All Right Reserved
 */

#define STRICT  1
#include "ole2ui.h"

// This dummy function is needed in order for the static link version
// of this library to work correctly.  When we include PRECOMP.OBJ
// in our library (.LIB file), it will only get linked into our
// application IFF at least one function in precomp.c is called from
// either our EXE or LIB.  Therefore, we will use a function
// here called OleUIStaticLibDummy().  You need to call it from
// your application.

void FAR PASCAL OleUIStaticLibDummy(void)
{

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\letest\ole2ui\olethunk.c ===
#include    <windows.h>
#include    <ole2.h>
#include    "olethunk.h"

STDAPI_(LPVOID) OleStdMalloc(ULONG ulSize);

STDAPI_(void) OleStdFree(LPVOID pmem);


STDAPI_(void) CopyAndFreeOLESTR(LPOLESTR polestr, LPSTR *ppszOut)
{
    // See if there is any work
    if (polestr == NULL)
    {
	if (ppszOut != NULL)
	{
	    // Output string requested so set it to NULL.
	    *ppszOut = NULL;
	}

	return;
    }

    if (ppszOut)
    {
	// Copy of string converted to ANSI is requested
	int len = wcslen(polestr) + 1;
	*ppszOut = OleStdMalloc(len);

	if (*ppszOut)
	{
	    wcstombs(*ppszOut, polestr, len);
	}
    }

    // Free the original string
    OleStdFree(polestr);
}




STDAPI_(void) CopyAndFreeSTR(LPSTR pstr, LPOLESTR *ppolestrOut)
{
    // See if there is any work
    if (pstr == NULL)
    {
	if (ppolestrOut != NULL)
	{
	    // Output string requested so set it to NULL.
	    *ppolestrOut = NULL;
	}

	return;
    }

    if (ppolestrOut)
    {
	// Copy of string converted to ANSI is requested
	int len = strlen(pstr) + 1;
	*ppolestrOut = OleStdMalloc(len * sizeof(WCHAR));

	if (*ppolestrOut)
	{
	    mbstowcs(*ppolestrOut, pstr, len);
	}
    }

    // Free the original string
    OleStdFree(pstr);
}



STDAPI_(LPOLESTR) CreateOLESTR(LPCSTR pszIn)
{
    // Return NULL if there was no string input
    LPOLESTR polestr = NULL;

    if (pszIn != NULL)
    {
        // Calculate size of string to allocate
        int len = strlen(pszIn) + 1;

        // Allocate the string
        polestr = (LPOLESTR) OleStdMalloc(len * sizeof(OLECHAR));

        // Convert the string
        if (polestr)
        {
	    mbstowcs(polestr, pszIn, len);
        }
    }

    return polestr;
}



STDAPI_(LPSTR) CreateSTR(LPCOLESTR polestrIn)
{
    // Return NULL if there was no string input
    LPSTR pstr = NULL;

    if (polestrIn != NULL)
    {
        // Calculate size of string to allocate
        int len = wcslen(polestrIn) + 1;

        // Allocate the string
        pstr = (PSTR) OleStdMalloc(len);

        // Convert the string
        if (pstr)
        {
	    wcstombs(pstr, polestrIn, len);
        }
    }

    return pstr;
}




STDAPI_(void) CLSIDFromStringA(LPSTR pszClass, LPCLSID pclsid)
{
    CREATEOLESTR(polestr, pszClass)

    CLSIDFromString(polestr, pclsid);

    FREEOLESTR(polestr)
}



STDAPI	CreateFileMonikerA(LPSTR lpszPathName, LPMONIKER FAR* ppmk)
{
    CREATEOLESTR(polestr, lpszPathName)

    HRESULT hr = CreateFileMoniker(polestr, ppmk);

    FREEOLESTR(polestr)

    return hr;
}



STDAPI	CreateItemMonikerA(
    LPSTR lpszDelim,
    LPSTR lpszItem,
    LPMONIKER FAR* ppmk)
{
    CREATEOLESTR(polestrDelim, lpszDelim)
    CREATEOLESTR(polestrItem, lpszItem)

    HRESULT hr = CreateItemMoniker(polestrDelim, polestrItem, ppmk);

    FREEOLESTR(polestrDelim)
    FREEOLESTR(polestrItem)

    return hr;
}



STDAPI_(HGLOBAL) OleGetIconOfClassA(
    REFCLSID rclsid,
    LPSTR lpszLabel,
    BOOL fUseTypeAsLabel)
{
    CREATEOLESTR(polestr, lpszLabel)

    HGLOBAL hglobal = OleGetIconOfClass(rclsid, polestr, fUseTypeAsLabel);

    FREEOLESTR(polestr)

    return hglobal;
}



STDAPI_(HGLOBAL) OleGetIconOfFileA(LPSTR lpszPath, BOOL fUseFileAsLabel)
{
    CREATEOLESTR(polestr, lpszPath)

    HGLOBAL hMetaPict = OleGetIconOfFile(polestr, fUseFileAsLabel);

    FREEOLESTR(polestr)

    return hMetaPict;
}




STDAPI_(HGLOBAL) OleMetafilePictFromIconAndLabelA(
    HICON hIcon,
    LPSTR lpszLabel,
    LPSTR lpszSourceFile,
    UINT iIconIndex)
{
    CREATEOLESTR(polestrLabel, lpszLabel)
    CREATEOLESTR(polestrSourceFile, lpszSourceFile)

    HGLOBAL hglobal = OleMetafilePictFromIconAndLabel(hIcon, polestrLabel,
	polestrSourceFile, iIconIndex);

    FREEOLESTR(polestrLabel)
    FREEOLESTR(polestrSourceFile)

    return hglobal;
}




STDAPI	GetClassFileA(LPCSTR szFilename, CLSID FAR* pclsid)
{
    CREATEOLESTR(polestr, szFilename)

    HRESULT hr = GetClassFile(polestr, pclsid);

    FREEOLESTR(polestr)

    return hr;
}



STDAPI CLSIDFromProgIDA(LPCSTR lpszProgID, LPCLSID lpclsid)
{
    CREATEOLESTR(polestr, lpszProgID)

    HRESULT hr = CLSIDFromProgID(polestr, lpclsid);

    FREEOLESTR(polestr)

    return hr;
}

STDAPI MkParseDisplayNameA(
    LPBC pbc,
    LPSTR szUserName,
    ULONG FAR * pchEaten,
    LPMONIKER FAR * ppmk)
{
    CREATEOLESTR(polestr, szUserName)

    HRESULT hr = MkParseDisplayName(pbc, polestr, pchEaten, ppmk);

    FREEOLESTR(polestr)

    return hr;
}




STDAPI	OleCreateLinkToFileA(
    LPCSTR lpszFileName,
    REFIID riid,
    DWORD renderopt,
    LPFORMATETC lpFormatEtc,
    LPOLECLIENTSITE pClientSite,
    LPSTORAGE pStg,
    LPVOID FAR* ppvObj)
{
    CREATEOLESTR(polestr, lpszFileName)

    HRESULT hr = OleCreateLinkToFile(polestr, riid, renderopt, lpFormatEtc,
	pClientSite, pStg, ppvObj);

    FREEOLESTR(polestr)

    return hr;
}


STDAPI	OleCreateFromFileA(
    REFCLSID rclsid,
    LPCSTR lpszFileName,
    REFIID riid,
    DWORD renderopt,
    LPFORMATETC lpFormatEtc,
    LPOLECLIENTSITE pClientSite,
    LPSTORAGE pStg,
    LPVOID FAR* ppvObj)
{
    CREATEOLESTR(polestr, lpszFileName)

    HRESULT hr = OleCreateFromFile(rclsid, polestr, riid, renderopt,
	lpFormatEtc, pClientSite, pStg, ppvObj);

    FREEOLESTR(polestr)

    return hr;
}



STDAPI OleRegGetUserTypeA(
    REFCLSID clsid,
    DWORD dwFormOfType,
    LPSTR FAR* ppszUserType)
{
    LPOLESTR polestr;

    HRESULT hr = OleRegGetUserType(clsid, dwFormOfType, &polestr);

    CopyAndFreeOLESTR(polestr, ppszUserType);

    return hr;
}



STDAPI ProgIDFromCLSIDA(REFCLSID clsid, LPSTR FAR* lplpszProgID)
{
    LPOLESTR polestr;

    HRESULT hr = ProgIDFromCLSID(clsid, &polestr);

    CopyAndFreeOLESTR(polestr, lplpszProgID);

    return hr;
}



STDAPI ReadFmtUserTypeStgA(
    LPSTORAGE pstg,
    CLIPFORMAT FAR* pcf,
    LPSTR FAR* lplpszUserType)
{
    LPOLESTR polestr;

    HRESULT hr = ReadFmtUserTypeStg(pstg, pcf, &polestr);

    CopyAndFreeOLESTR(polestr, lplpszUserType);

    return hr;
}






STDAPI StgCreateDocfileA(
    LPCSTR lpszName,
    DWORD grfMode,
    DWORD reserved,
    IStorage FAR * FAR *ppstgOpen)
{
    HRESULT hr;
    LPOLESTR polestr = NULL;

    if (lpszName != NULL)
    {
	polestr = CreateOLESTR(lpszName);
    }

    hr = StgCreateDocfile(polestr, grfMode, reserved, ppstgOpen);

    FREEOLESTR(polestr)

    return hr;
}




STDAPI StgOpenStorageA(
    LPCSTR lpszName,
    IStorage FAR *pstgPriority,
    DWORD grfMode,
    SNB snbExclude,
    DWORD reserved,
    IStorage FAR * FAR *ppstgOpen)
{
    CREATEOLESTR(polestr, lpszName)

    HRESULT hr = StgOpenStorage(polestr, pstgPriority, grfMode, snbExclude,
	reserved, ppstgOpen);

    FREEOLESTR(polestr)

    return hr;
}



STDAPI StgSetTimesA(
    LPSTR lpszName,
    FILETIME const FAR* pctime,
    FILETIME const FAR* patime,
    FILETIME const FAR* pmtime)
{
    CREATEOLESTR(polestr, lpszName)

    HRESULT hr = StgSetTimes(polestr, pctime, patime, pmtime);

    FREEOLESTR(polestr)

    return hr;
}




STDAPI_(void) StringFromCLSIDA(REFCLSID rclsid, LPSTR *lplpszCLSID)
{
    LPOLESTR polestr;

    StringFromCLSID(rclsid, &polestr);

    CopyAndFreeOLESTR(polestr, lplpszCLSID);
}


STDAPI WriteFmtUserTypeStgA(
    LPSTORAGE lpStg,
    CLIPFORMAT cf,
    LPSTR lpszUserType)
{
    CREATEOLESTR(polestr, lpszUserType)

    HRESULT hr = WriteFmtUserTypeStg(lpStg, cf, polestr);

    FREEOLESTR(polestr)

    return hr;
}







STDAPI CallIMonikerGetDisplayNameA(
    LPMONIKER lpmk,
    IBindCtx *pbc,
    IMoniker *pmkToLeft,
    LPSTR *ppszDisplayName)
{
    LPOLESTR polestr;

    HRESULT hr = lpmk->lpVtbl->GetDisplayName(lpmk, pbc, NULL,
	&polestr);

    CopyAndFreeOLESTR(polestr, ppszDisplayName);

    return hr;
}



STDAPI CallIOleInPlaceUIWindowSetActiveObjectA(
    IOleInPlaceUIWindow FAR *lpthis,
    IOleInPlaceActiveObject *pActiveObject,
    LPCSTR pszObjName)
{
    CREATEOLESTR(polestr, pszObjName)

    HRESULT hr = lpthis->lpVtbl->SetActiveObject(lpthis, pActiveObject,
	    polestr);

    FREEOLESTR(polestr)

    return hr;
}



STDAPI CallIOleInPlaceFrameSetStatusTextA(
    IOleInPlaceFrame *poleinplc,
    LPCSTR pszStatusText)
{
    CREATEOLESTR(polestr, pszStatusText)

    HRESULT hr = poleinplc->lpVtbl->SetStatusText(poleinplc, polestr);

    FREEOLESTR(polestr)

    return hr;
}




STDAPI CallIOleLinkGetSourceDisplayNameA(
    IOleLink FAR *polelink,
    LPSTR *ppszDisplayName)
{
    LPOLESTR polestr;

    HRESULT hr = polelink->lpVtbl->GetSourceDisplayName(polelink, &polestr);

    CopyAndFreeOLESTR(polestr, ppszDisplayName);

    return hr;
}



STDAPI CallIOleLinkSetSourceDisplayNameA(
    IOleLink FAR *polelink,
    LPCSTR pszStatusText)
{
    CREATEOLESTR(polestr, pszStatusText)

    HRESULT hr = polelink->lpVtbl->SetSourceDisplayName(polelink, polestr);

    FREEOLESTR(polestr)

    return hr;
}





STDAPI CallIOleObjectGetUserTypeA(
    LPOLEOBJECT lpOleObject,
    DWORD dwFormOfType,
    LPSTR *ppszUserType)
{
    LPOLESTR polestr;

    HRESULT hr = lpOleObject->lpVtbl->GetUserType(lpOleObject,
	dwFormOfType, &polestr);

    CopyAndFreeOLESTR(polestr, ppszUserType);

    return hr;
}



STDAPI CallIOleObjectSetHostNamesA(
    LPOLEOBJECT lpOleObject,
    LPCSTR szContainerApp,
    LPCSTR szContainerObj)
{
    CREATEOLESTR(polestrApp, szContainerApp)
    CREATEOLESTR(polestrObj, szContainerObj)

    HRESULT hr = lpOleObject->lpVtbl->SetHostNames(lpOleObject, polestrApp,
	    polestrObj);

    FREEOLESTR(polestrApp)
    FREEOLESTR(polestrObj)

    return hr;
}

STDAPI CallIStorageDestroyElementA(
    LPSTORAGE lpStg,
    LPSTR pszName)
{
    CREATEOLESTR(polestr, pszName)

    HRESULT hr =  lpStg->lpVtbl->DestroyElement(lpStg, polestr);

    FREEOLESTR(polestr)

    return hr;
}
    


STDAPI CallIStorageCreateStorageA(
    LPSTORAGE lpStg,
    const char *pszName,
    DWORD grfMode,
    DWORD dwStgFmt,
    DWORD reserved2,
    IStorage **ppstg)
{
    CREATEOLESTR(polestr, pszName)

    HRESULT hr =  lpStg->lpVtbl->CreateStorage(lpStg, polestr, grfMode,
	dwStgFmt, reserved2, ppstg);

    FREEOLESTR(polestr)

    return hr;
}



STDAPI CallIStorageOpenStorageA(
    LPSTORAGE lpStg,
    const char *pszName,
    IStorage *pstgPriority,
    DWORD grfMode,
    SNB snbExclude,
    DWORD reserved,
    IStorage **ppstg)
{
    CREATEOLESTR(polestr, pszName)

    HRESULT hr = lpStg->lpVtbl->OpenStorage(lpStg, polestr, pstgPriority,
	grfMode, snbExclude, reserved, ppstg);

    FREEOLESTR(polestr)

    return hr;
}


STDAPI CallIStorageCreateStreamA(
    LPSTORAGE lpStg,
    LPSTR pszName,
    DWORD grfMode,
    DWORD reserved1,
    DWORD reserved2,
    IStream **ppstm)
{
    CREATEOLESTR(polestr, pszName)

    HRESULT hr = lpStg->lpVtbl->CreateStream(lpStg, polestr,
	grfMode, reserved1, reserved2, ppstm);

    FREEOLESTR(polestr)

    return hr;
}

STDAPI CallIStorageOpenStreamA(
    LPSTORAGE lpStg,
    LPSTR pszName,
    void *reserved1,
    DWORD grfMode,
    DWORD reserved2,
    IStream **ppstm)
{
    CREATEOLESTR(polestr, pszName)

    HRESULT hr = lpStg->lpVtbl->OpenStream(lpStg, polestr, reserved1,
	grfMode, reserved2, ppstm);

    FREEOLESTR(polestr)

    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\letest\ole2ui\resimage.c ===
/*
 * RESIMAGE.C
 *
 * Implementation of the Results Image control for OLE 2.0 UI dialogs.
 * We need a separate control for dialogs in order to control the repaints
 * properly and to provide a clean message interface for the dialog
 * implementations.
 *
 * Copyright (c)1992 Microsoft Corporation, All Right Reserved
 */


#define STRICT  1
#include "ole2ui.h"
#include "resimage.h"

OLEDBGDATA

//Flag indicating if we've registered the class
static BOOL     fRegistered=FALSE;

//Bitmap and image dimensions for result images.
static HBITMAP  hBmpResults=NULL;
static UINT     cxBmpResult=0;
static UINT     cyBmpResult=0;

/*
 * FResultImageInitialize
 *
 * Purpose:
 *  Attempts to load result bitmaps for the current display driver
 *  for use in OLE 2.0 UI dialogs.  Also registers the ResultImage
 *  control class.
 *
 * Parameters:
 *  hInst           HINSTANCE instance of the DLL.
 *
 *  hPrevInst       HINSTANCE of the previous instance.  Used to
 *                  determine whether to register window classes or not.
 *
 *  lpszClassName   LPSTR containing the class name to register the
 *                  ResultImage control class with.
 *
 * Return Value:
 *  BOOL            TRUE if all initialization succeeded, FALSE otherwise.
 */

BOOL FResultImageInitialize(HINSTANCE hInst, HINSTANCE hPrevInst, LPTSTR lpszClassName)
    {
    int         cx, iBmp;
    HDC         hDC;
    BITMAP      bm;

    WNDCLASS        wc;


    /*
     * Determine the aspect ratio of the display we're currently
     * running on and load the appropriate bitmap into the global
     * hBmpResults (used from the ResultImage control only).
     *
     * By retrieving the logical Y extent of the display driver, you
     * only have limited possibilities:
     *      LOGPIXELSY      Display
     *      ----------------------------------------
     *         48             CGA    (unsupported)
     *         72             EGA
     *         96             VGA
     *        120             8514/a (i.e. HiRes VGA)
     */

    hDC=GetDC(NULL);

    if (NULL==hDC)
        return FALSE;

    cx=GetDeviceCaps(hDC, LOGPIXELSY);
    ReleaseDC(NULL, hDC);

    /*
     * Instead of single comparisons, check ranges instead, so in case
     * we get something funky, we'll act reasonable.
     */
    if (72 >=cx)             iBmp=IDB_RESULTSEGA;
    if (72 < cx && 120 > cx) iBmp=IDB_RESULTSVGA;
    if (120 <=cx)            iBmp=IDB_RESULTSHIRESVGA;

    hBmpResults=LoadBitmap(hInst, MAKEINTRESOURCE(iBmp));

    if (NULL==hBmpResults)
        {
        //On error, fail loading the DLL
        OleDbgOut1(TEXT("FResultImageInitialize:  Failed LoadBitmap.\r\n"));
        return FALSE;
        }

    OleDbgOut4(TEXT("FResultImageInitialize:  Loaded hBmpResults\r\n"));

    //Now that we have the bitmap, calculate image dimensions
    GetObject(hBmpResults, sizeof(BITMAP), &bm);
    cxBmpResult=bm.bmWidth;
    cyBmpResult=bm.bmHeight/CIMAGESY;


    // Only register class if we're the first instance
    if (hPrevInst)
        fRegistered = TRUE;
    else
        {
        // Static flag fRegistered guards against calling this function more
        // than once in the same instance

        if (!fRegistered)
            {
            wc.lpfnWndProc   =ResultImageWndProc;
            wc.cbClsExtra    =0;
            wc.cbWndExtra    =CBRESULTIMAGEWNDEXTRA;
            wc.hInstance     =hInst;
            wc.hIcon         =NULL;
            wc.hCursor       =LoadCursor(NULL, IDC_ARROW);
            wc.hbrBackground =NULL;
            wc.lpszMenuName  =NULL;
            wc.lpszClassName =lpszClassName;
            wc.style         =CS_GLOBALCLASS | CS_VREDRAW | CS_HREDRAW;

            fRegistered = RegisterClass(&wc);
            }
        }

    return fRegistered;
}





/*
 * ResultImageUninitialize
 *
 * Purpose:
 *  Cleans up anything done in FResultImageInitialize, such as freeing
 *  the bitmaps.  Call from WEP.
 *
 * Parameters:
 *  None
 *
 * Return Value:
 *  None
 */

void ResultImageUninitialize(void)
    {
    if (NULL!=hBmpResults)
        {
        DeleteObject(hBmpResults);
        }

    return;
    }






/*
 * ResultImageWndProc
 *
 * Purpose:
 *  Window Procedure for the ResultImage custom control.  Only handles
 *  WM_CREATE, WM_PAINT, and private messages to manipulate the bitmap.
 *
 * Parameters:
 *  Standard
 *
 * Return Value:
 *  Standard
 */

LONG CALLBACK EXPORT ResultImageWndProc(HWND hWnd, UINT iMsg
    , WPARAM wParam, LPARAM lParam)
    {
    UINT            iBmp;
    PAINTSTRUCT     ps;
    HDC             hDC;

    //Handle standard Windows messages.
    switch (iMsg)
        {
        case WM_CREATE:
            SetWindowWord(hWnd, RIWW_IMAGEINDEX, RESULTIMAGE_NONE);
            return 0L;

        case WM_PAINT:
            iBmp=GetWindowWord(hWnd, RIWW_IMAGEINDEX);

            hDC=BeginPaint(hWnd, &ps);

            if (RESULTIMAGE_NONE!=iBmp)
                {
                RECT            rc;
                UINT            x, y;
                HDC             hDCDlg;
                HBRUSH          hBr;
                LOGBRUSH        lb;
                HWND            hDlg;

                /*
                 * Our job before using TransparantBlt is to figure out
                 * where to position the result image.  We place it centered
                 * on this control, so get our rect's center and subtract
                 * half of the image dimensions.
                 */
                GetClientRect(hWnd, &rc);
                x=(rc.right+rc.left-cxBmpResult)/2;
                y=(rc.bottom+rc.top-cyBmpResult)/2;

                //Get the backgroup color the dialog is using.
                hDlg=GetParent(hWnd);
                hDCDlg=GetDC(hDlg);
#if defined( WIN32 )
                hBr = (HBRUSH)SendMessage(hDlg,
                                        WM_CTLCOLORDLG,
                                        (WPARAM)hDCDlg,
                                        (LPARAM)hDlg);
#else
                hBr = (HBRUSH)SendMessage(hDlg,
                                        WM_CTLCOLOR,
                                        (WPARAM)hDCDlg,
                                        MAKELPARAM(hDlg, CTLCOLOR_DLG));
#endif
                ReleaseDC(hDlg, hDCDlg);

                GetObject(hBr, sizeof(LOGBRUSH), &lb);
                SetBkColor(hDC, lb.lbColor);

                TransparantBlt(hDC, x, y, hBmpResults, 0, iBmp*cyBmpResult
                               , cxBmpResult, cyBmpResult, RGBTRANSPARENT);
                }

            EndPaint(hWnd, &ps);
            break;

        case RIM_IMAGESET:
            //wParam contains the new index.
            iBmp=GetWindowWord(hWnd, RIWW_IMAGEINDEX);

            //Validate the index before changing it and repainting
            if (RESULTIMAGE_NONE==wParam ||
                ((RESULTIMAGE_MIN <= wParam) && (RESULTIMAGE_MAX >= wParam)))
                {
                SetWindowWord(hWnd, RIWW_IMAGEINDEX, (WORD)wParam);
                InvalidateRect(hWnd, NULL, FALSE);
                UpdateWindow(hWnd);
                }

            //Return the previous index.
            return iBmp;

        case RIM_IMAGEGET:
            //Return the current index.
            iBmp=GetWindowWord(hWnd, RIWW_IMAGEINDEX);
            return (LONG)iBmp;

        default:
            return DefWindowProc(hWnd, iMsg, wParam, lParam);
        }

    return 0L;
    }






/*
 * TransparantBlt
 *
 * Purpose:
 *  Given a DC, a bitmap, and a color to assume as transparant in that
 *  bitmap, BitBlts the bitmap to the DC letting the existing background
 *  show in place of the transparant color.
 *
 * Parameters:
 *  hDC             HDC on which to draw.
 *  x, y            UINT location at which to draw the bitmap
 *  hBmp            HBITMIP to draw from
 *  xOrg, yOrg      UINT coordinates from which to draw the bitamp
 *  cx, cy          UINT dimensions of the bitmap to Blt.
 *  cr              COLORREF to consider as transparant.
 *
 * Return Value:
 *  None
 */

void TransparantBlt(HDC hDC, UINT x, UINT y, HBITMAP hBmp, UINT xOrg, UINT yOrg
    , UINT cx, UINT cy, COLORREF cr)
    {
    HDC         hDCSrc, hDCMid, hMemDC;
    HBITMAP     hBmpMono, hBmpT;
    HBRUSH      hBr, hBrT;
    COLORREF    crBack, crText;

    if (NULL==hBmp)
        return;

    //Get three intermediate DC's
    hDCSrc=CreateCompatibleDC(hDC);
    hDCMid=CreateCompatibleDC(hDC);
    hMemDC=CreateCompatibleDC(hDC);

    SelectObject(hDCSrc, hBmp);

    //Create a monochrome bitmap for masking
    hBmpMono=CreateCompatibleBitmap(hDCMid, cx, cy);
    SelectObject(hDCMid, hBmpMono);

    //Create a middle bitmap
    hBmpT=CreateCompatibleBitmap(hDC, cx, cy);
    SelectObject(hMemDC, hBmpT);


    //Create a monochrome mask where we have 0's in the image, 1's elsewhere.
    crBack=SetBkColor(hDCSrc, cr);
    BitBlt(hDCMid, 0, 0, cx, cy, hDCSrc, xOrg, yOrg, SRCCOPY);
    SetBkColor(hDCSrc, crBack);

    //Put the unmodified image in the temporary bitmap
    BitBlt(hMemDC, 0, 0, cx, cy, hDCSrc, xOrg, yOrg, SRCCOPY);

    //Create an select a brush of the background color
    hBr=CreateSolidBrush(GetBkColor(hDC));
    hBrT=SelectObject(hMemDC, hBr);

    //Force conversion of the monochrome to stay black and white.
    crText=SetTextColor(hMemDC, 0L);
    crBack=SetBkColor(hMemDC, RGB(255, 255, 255));

    /*
     * Where the monochrome mask is 1, Blt the brush; where the mono mask
     * is 0, leave the destination untouches.  This results in painting
     * around the image with the background brush.  We do this first
     * in the temporary bitmap, then put the whole thing to the screen.
     */
    BitBlt(hMemDC, 0, 0, cx, cy, hDCMid, 0, 0, ROP_DSPDxax);
    BitBlt(hDC,    x, y, cx, cy, hMemDC, 0, 0, SRCCOPY);


    SetTextColor(hMemDC, crText);
    SetBkColor(hMemDC, crBack);

    SelectObject(hMemDC, hBrT);
    DeleteObject(hBr);

    DeleteDC(hMemDC);
    DeleteDC(hDCSrc);
    DeleteDC(hDCMid);
    DeleteObject(hBmpT);
    DeleteObject(hBmpMono);

    return;
    }

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\letest\ole2ui\regdb.h ===
// This file is now OBSOLETE (include olestd.h instead)
/*
 *  Regdb.h  
 *
 *    (c) Copyright Microsoft Corp. 1992 All Rights Reserved
 */

// Function prototypes moved to olestd.h
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\letest\ole2ui\stdpal.c ===
/*-----------------------------------------------------------------------
|       stdpal.c
|
|       Standard App Palette useful for OLE applications.  v 1.01
|
|       NOTE:  Palette MUST be created with OleStdCreateStandardPalette
|
|   Copyright (c) 1992 - 1993 Microsoft Corporation. All rights reserved.
|
-----------------------------------------------------------------------*/

#ifndef PC_RESERVED
#ifndef INC_OLE2
   #define INC_OLE2
#endif

#undef UNICODE
#include <windows.h>
#include <ole2.h>
#endif

#include "stdpal.h"

#define cpeAppPal 256  // number of colors in our apps palette
typedef struct
	{
	WORD wVersion;
	WORD cpe;
	PALETTEENTRY rgpe[cpeAppPal];
	} LOGPAL;


/*-----------------------------------------------------------------------
|       OleStdCreateStandardPalette
|
|               Creates the standard Apps palette.  Create one of these for your
|       app, and select/realize it into each DC.
|
|       Arguments:
|               void:
|
|       Returns:
|
|       Keywords:
-----------------------------------------------------------------------*/
STDAPI_(HPALETTE) OleStdCreateStandardPalette(void)
	{
	HDC hdc;
	HPALETTE hpal;

	hpal = (HPALETTE) NULL;
	hdc = GetDC(NULL);
	if (hdc != NULL && GetDeviceCaps(hdc, RASTERCAPS) & RC_PALETTE)
		{
		int cpeSysPal;
		int cpeReserved;

		cpeSysPal = GetDeviceCaps(hdc, SIZEPALETTE);
		cpeReserved = GetDeviceCaps(hdc, NUMRESERVED);
		if (cpeSysPal > cpeReserved)
			{
			int cpeReserved2;
			unsigned char FAR* lpb;
			PALETTEENTRY FAR* ppe;
			PALETTEENTRY FAR* ppeMac;
			LOGPAL logpal;

			cpeReserved2 = cpeReserved/2;

			// Get the system palette entries at the beginning and end.
			GetSystemPaletteEntries(hdc, 0, cpeReserved2, logpal.rgpe);
			GetSystemPaletteEntries(hdc, cpeSysPal - cpeReserved2, cpeReserved2,
				&logpal.rgpe[cpeAppPal-cpeReserved2]);

			logpal.cpe = cpeAppPal;
			logpal.wVersion = 0x300;

			lpb = (BYTE FAR *) &palSVGA[10];
			ppe = (PALETTEENTRY FAR*)&logpal.rgpe[cpeReserved2];
			ppeMac = (PALETTEENTRY FAR*)&logpal.rgpe[cpeAppPal-cpeReserved2];
			while (ppe < ppeMac)
				{
				ppe->peFlags = PC_NOCOLLAPSE;
				ppe->peRed   = *lpb++;
				ppe->peGreen = *lpb++;
				ppe->peBlue  = *lpb++;
				ppe++;
				}
			hpal = CreatePalette((LOGPALETTE FAR *)&logpal);
			}
		}
	ReleaseDC(NULL, hdc);
	return hpal;
	}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\letest\ole2ui\regdb.c ===
/*
 *  REGDB.C
 *
 *  Functions to query the registration database
 *
 *  OleStdGetMiscStatusOfClass
 *  OleStdGetDefaultFileFormatOfClass
 *  OleStdGetAuxUserType
 *  OleStdGetUserTypeOfClass
 *
 *    (c) Copyright Microsoft Corp. 1992-1993 All Rights Reserved
 *
 */

#define STRICT  1
#include "ole2ui.h"
#include "common.h"
#include <ctype.h>

OLEDBGDATA

// Replacement for stdlib atol,
// which didn't work and doesn't take far pointers.
// Must be tolerant of leading spaces.
//
//
static LONG Atol(LPTSTR lpsz)
{
    signed int sign = +1;
    UINT base = 10;
    LONG l = 0;

    if (NULL==lpsz)
    {
        OleDbgAssert (0);
        return 0;
    }
    while (isspace(*lpsz))
        lpsz++;

    if (*lpsz=='-')
    {
        lpsz++;
        sign = -1;
    }
    if (lpsz[0]==TEXT('0') && lpsz[1]==TEXT('x'))
    {
        base = 16;
        lpsz+=2;
    }

    if (base==10)
    {
        while (isdigit(*lpsz))
        {
            l = l * base + *lpsz - '0';
            lpsz++;
        }
    }
    else
    {
        OleDbgAssert (base==16);
        while (isxdigit(*lpsz))
        {
            l = l * base + isdigit(*lpsz) ? *lpsz - '0' : toupper(*lpsz) - 'A' + 10;
            lpsz++;
        }
    }
    return l * sign;
}



/*
 * OleStdGetUserTypeOfClass(REFCLSID, LPSTR, UINT, HKEY)
 *
 * Purpose:
 *  Returns the user type (human readable class name) of the specified class.
 *
 * Parameters:
 *  rclsid          pointer to the clsid to retrieve user type of.
 *  lpszUserType    pointer to buffer to return user type in.
 *  cch             length of buffer pointed to by lpszUserType
 *  hKey            hKey for reg db - if this is NULL, then we
 *                   open and close the reg db within this function.  If it
 *                   is non-NULL, then we assume it's a valid key to the
 *                   \ root and use it without closing it. (useful
 *                   if you're doing lots of reg db stuff).
 *
 * Return Value:
 *  UINT            Number of characters in returned string.  0 on error.
 *
 */
STDAPI_(UINT) OleStdGetUserTypeOfClass(REFCLSID rclsid, LPTSTR lpszUserType, UINT cch, HKEY hKey)
{

   LONG     dw;
   LONG     lRet;
   LPSTR    lpszCLSID, lpszProgID;
   BOOL     fFreeProgID = FALSE;
   BOOL     bCloseRegDB = FALSE;
   TCHAR    szKey[128];
   LPMALLOC lpIMalloc;

   if (!lpszUserType)
       return 0;

   *lpszUserType = TEXT('\0');
   if (hKey == NULL)
   {

     //Open up the root key.
     lRet=RegOpenKey(HKEY_CLASSES_ROOT, NULL, &hKey);

     if ((LONG)ERROR_SUCCESS!=lRet)
       return (UINT)FALSE;

     bCloseRegDB = TRUE;
   }

   // Get a string containing the class name
   StringFromCLSIDA(rclsid, &lpszCLSID);

   wsprintf(szKey, TEXT("CLSID\\%s"), lpszCLSID);

   dw=cch;
   lRet = RegQueryValue(hKey, szKey, lpszUserType, &dw);

   if ((LONG)ERROR_SUCCESS!=lRet) {
       // Load 'Unknown Source' and 'Unknown Type' strings
       dw = (LONG)LoadString(ghInst, IDS_PSUNKNOWNTYPE, lpszUserType, cch);
   }

   if ( ((LONG)ERROR_SUCCESS!=lRet) && (CoIsOle1Class(rclsid)) )
   {
      // We've got an OLE 1.0 class, so let's try to get the user type
      // name from the ProgID entry.

      ProgIDFromCLSIDA(rclsid, &lpszProgID);
      fFreeProgID = TRUE;

      dw = cch;
      lRet = RegQueryValue(hKey, lpszProgID, lpszUserType, &dw);

      if ((LONG)ERROR_SUCCESS != lRet)
        dw = 0;
   }


   if (NOERROR == CoGetMalloc(MEMCTX_TASK, &lpIMalloc))
   {
       if (fFreeProgID)
         lpIMalloc->lpVtbl->Free(lpIMalloc, (LPVOID)lpszProgID);

       lpIMalloc->lpVtbl->Free(lpIMalloc, (LPVOID)lpszCLSID);
       lpIMalloc->lpVtbl->Release(lpIMalloc);
   }

   if (bCloseRegDB)
      RegCloseKey(hKey);

   return (UINT)dw;

}



/*
 * OleStdGetAuxUserType(RCLSID, WORD, LPSTR, int, HKEY)
 *
 * Purpose:
 *  Returns the specified AuxUserType from the reg db.
 *
 * Parameters:
 *  rclsid          pointer to the clsid to retrieve aux user type of.
 *  hKey            hKey for reg db - if this is NULL, then we
 *                   open and close the reg db within this function.  If it
 *                   is non-NULL, then we assume it's a valid key to the
 *                   \ root and use it without closing it. (useful
 *                   if you're doing lots of reg db stuff).
 *  wAuxUserType    which aux user type field to look for.  In 4/93 release
 *                  2 is short name and 3 is exe name.
 *  lpszUserType    pointer to buffer to return user type in.
 *  cch             length of buffer pointed to by lpszUserType
 *
 * Return Value:
 *  UINT            Number of characters in returned string.  0 on error.
 *
 */
STDAPI_(UINT) OleStdGetAuxUserType(REFCLSID rclsid,
                                   WORD     wAuxUserType,
                                   LPTSTR    lpszAuxUserType,
                                   int      cch,
                                   HKEY     hKey)
{
   HKEY     hThisKey;
   BOOL     fCloseRegDB = FALSE;
   LONG     dw;
   LRESULT  lRet;
   LPTSTR    lpszCLSID;
   LPMALLOC lpIMalloc;
   TCHAR     szKey[OLEUI_CCHKEYMAX];
   TCHAR    szTemp[32];

   lpszAuxUserType[0] = TEXT('\0');

   if (NULL == hKey)
   {
      lRet = RegOpenKey(HKEY_CLASSES_ROOT, NULL, &hThisKey);

      if (ERROR_SUCCESS != lRet)
          return 0;
   }
   else
      hThisKey = hKey;

   StringFromCLSIDA(rclsid, &lpszCLSID);

   lstrcpy(szKey, TEXT("CLSID\\"));
   lstrcat(szKey, lpszCLSID);
   wsprintf(szTemp, TEXT("\\AuxUserType\\%d"), wAuxUserType);
   lstrcat(szKey, szTemp);

   dw = cch;

   lRet = RegQueryValue(hThisKey, szKey, lpszAuxUserType, &dw);

   if (ERROR_SUCCESS != lRet) {
     dw = 0;
     lpszAuxUserType[0] = TEXT('\0');
   }


   if (fCloseRegDB)
      RegCloseKey(hThisKey);

   if (NOERROR == CoGetMalloc(MEMCTX_TASK, &lpIMalloc))
   {
       lpIMalloc->lpVtbl->Free(lpIMalloc, (LPVOID)lpszCLSID);
       lpIMalloc->lpVtbl->Release(lpIMalloc);
   }

   return (UINT)dw;
}



/*
 * OleStdGetMiscStatusOfClass(REFCLSID, HKEY)
 *
 * Purpose:
 *  Returns the value of the misc status for the given clsid.
 *
 * Parameters:
 *  rclsid          pointer to the clsid to retrieve user type of.
 *  hKey            hKey for reg db - if this is NULL, then we
 *                   open and close the reg db within this function.  If it
 *                   is non-NULL, then we assume it's a valid key to the
 *                   \\CLSID root and use it without closing it. (useful
 *                   if you're doing lots of reg db stuff).
 *
 * Return Value:
 *  BOOL            TRUE on success, FALSE on failure.
 *
 */
STDAPI_(BOOL) OleStdGetMiscStatusOfClass(REFCLSID rclsid, HKEY hKey, DWORD FAR * lpdwValue)
{
   DWORD dw;
   LONG  lRet;
   LPTSTR lpszCLSID;
   TCHAR  szKey[64];
   TCHAR  szMiscStatus[OLEUI_CCHKEYMAX];
   BOOL  bCloseRegDB = FALSE;

   if (hKey == NULL)
   {

     //Open up the root key.
     lRet=RegOpenKey(HKEY_CLASSES_ROOT, TEXT("CLSID"), &hKey);

     if ((LONG)ERROR_SUCCESS!=lRet)
       return FALSE;

     bCloseRegDB = TRUE;
   }

   // Get a string containing the class name
   StringFromCLSIDA(rclsid, &lpszCLSID);

   // Construct key
   lstrcpy(szKey, lpszCLSID);

   lstrcat(szKey, TEXT("\\MiscStatus"));


   dw=OLEUI_CCHKEYMAX_SIZE;
   lRet = RegQueryValue(hKey, szKey, (LPTSTR)szMiscStatus, &dw);

   if ((LONG)ERROR_SUCCESS!=lRet)
   {
       OleStdFreeString(lpszCLSID, NULL);

       if (bCloseRegDB)
          RegCloseKey(hKey);

       return FALSE;

   }

   *lpdwValue = Atol((LPTSTR)szMiscStatus);

   OleStdFreeString(lpszCLSID, NULL);

   if (bCloseRegDB)
      RegCloseKey(hKey);

   return TRUE;


}


/*
 * CLIPFORMAT OleStdGetDefaultFileFormatOfClass(REFCLSID, HKEY)
 *
 * Purpose:
 *  Returns the default file format of the specified class.
 *  this is entered in REGDB as follows:
 *      CLSID\{...}\DataFormats\DefaultFile = <cfFmt>
 *
 * Parameters:
 *  rclsid          pointer to the clsid to retrieve user type of.
 *  hKey            hKey for reg db- if this is NULL, then we
 *                   open and close the reg db within this function.  If it
 *                   is non-NULL, then we assume it's a valid key to the
 *                   \ root and use it without closing it. (useful
 *                   if you're doing lots of reg db stuff).
 *
 * Return Value:
 *  cfFmt   -- DefaultFile format
 *  NULL    -- failed to get default file format
 *
 */
STDAPI_(CLIPFORMAT) OleStdGetDefaultFileFormatOfClass(
        REFCLSID        rclsid,
        HKEY            hKey
)
{
   CLIPFORMAT cfFmt = 0;
   DWORD dw;
   LONG  lRet;
   LPTSTR lpszCLSID;
   BOOL  bCloseRegDB = FALSE;
   TCHAR  szKey[128];
   TCHAR  szDefaultFile[OLEUI_CCHKEYMAX];
   BOOL  bStatus = TRUE;


   if (hKey == NULL)
   {

     //Open up the root key.
     lRet=RegOpenKey(HKEY_CLASSES_ROOT, NULL, &hKey);

     if ((LONG)ERROR_SUCCESS!=lRet)
       return 0;

     bCloseRegDB = TRUE;
   }


   // Get a string containing the class name
   StringFromCLSIDA(rclsid, &lpszCLSID);

   // Construct key
   wsprintf(szKey, TEXT("CLSID\\%s\\DataFormats\\DefaultFile"), lpszCLSID);

   OleStdFreeString(lpszCLSID, NULL);

   dw=OLEUI_CCHKEYMAX_SIZE;
   lRet = RegQueryValue(hKey, szKey, (LPTSTR)szDefaultFile, (LONG FAR *)&dw);

   if ((LONG)ERROR_SUCCESS!=lRet)
       bStatus = FALSE;
   else {
       /* if the format is a number, then it should refer to one of the
       **    standard Windows formats.
       */
       if (isdigit(szDefaultFile[0]))
           cfFmt = (CLIPFORMAT)Atol(szDefaultFile);
       else
           cfFmt = RegisterClipboardFormat(szDefaultFile);
   }

   if (bCloseRegDB)
      RegCloseKey(hKey);

   return cfFmt;
}


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\letest\ole2ui\resimage.h ===
/*
 * RESIMAGE.H
 *
 * Structures and definitions for the ResultImage control.
 *
 * Copyright (c)1992 Microsoft Corporation, All Right Reserved
 */


#ifndef _RESIMAGE_H_
#define _RESIMAGE_H_


/*
 * Indices into the bitmaps to extract the right image.  Each bitmap
 * contains five images arranged vertically, so the offset to the correct
 * image is (iImage*cy)
 */

#define RESULTIMAGE_NONE                0xFFFF
#define RESULTIMAGE_PASTE               0
#define RESULTIMAGE_EMBED               1
#define RESULTIMAGE_EMBEDICON           2
#define RESULTIMAGE_LINK                3
#define RESULTIMAGE_LINKICON            4
#define RESULTIMAGE_LINKTOLINK          5
#define RESULTIMAGE_LINKTOLINKICON      6

#define RESULTIMAGE_MIN                 0
#define RESULTIMAGE_MAX                 6


//Total number of images in each bitmap.
#define CIMAGESY                        (RESULTIMAGE_MAX+1)

//The color to use for transparancy (cyan)
#define RGBTRANSPARENT                  RGB(0, 255, 255)


//Function prototypes
BOOL            FResultImageInitialize(HINSTANCE, HINSTANCE, LPTSTR);
void            ResultImageUninitialize(void);
LONG CALLBACK EXPORT ResultImageWndProc(HWND, UINT, WPARAM, LPARAM);
void            TransparantBlt(HDC, UINT, UINT, HBITMAP, UINT, UINT, UINT, UINT, COLORREF);


//Window extra bytes contain the bitmap index we deal with currently.
#define CBRESULTIMAGEWNDEXTRA          sizeof(UINT)
#define RIWW_IMAGEINDEX                0


//Control messages
#define RIM_IMAGESET                   (WM_USER+0)
#define RIM_IMAGEGET                   (WM_USER+1)


//Special ROP code for TransparantBlt.
#define ROP_DSPDxax  0x00E20746


#endif //_RESIMAGE_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\letest\ole2ui\suminfo.h ===
/*************************************************************************
**
**    OLE 2.0 Property Set Utilities
**
**    suminfo.h
**
**    This file contains file contains data structure defintions,
**    function prototypes, constants, etc. for OLE 2.0 Property Set
**    utilities used to manage the Summary Info property set.
**
**    (c) Copyright Microsoft Corp. 1990 - 1992 All Rights Reserved
**
*************************************************************************/

#ifndef SUMINFO_H
#define SUMINFO_H

#include <ole2.h>

/* A SUMINFO variable is an instance of an abstract data type.  Thus,
**    there can be an arbitrary number of SummaryInfo streams open
**    simultaneously (subject to available memory).  Each variable must
**    be initialized prior to use by calling Init and freed after its
**    last use by calling Free.  The param argument to Init is reserved
**    for future expansion and should be zero initially. Once a SUMINFO
**    variable is allocated (by Init), the user can call the Set
**    procedures to initialize fields.  A copy of the arguments is made
**    in every case except SetThumbnail where control of the storage
**    occupied by the METAFILEPICT is merely transferred.  When the
**    Free routine is called, all storage will be deallocated including
**    that of the thumbnail.  The arguments to SetThumbNail and the
**    return values from GetThumbNail correspond to the OLE2.0 spec.
**    Note that on input, the thumbnail is read on demand but all the
**    other properties are pre-loaded.  The thumbnail is manipulated as
**    a windows handle to a METAFILEPICT structure, which in turn
**    contains a handle to the METAFILE.  The transferClip argument on
**    GetThumbNail, when set to true, transfers responsibility for
**    storage management of the thumbnail to the caller; that is, after
**    Free has been called, the handle is still valid. Clear can be
**    used to free storage for all the properties but then you must
**    call Read to load them again.  All the code is based on FAR
**    pointers.
**    CoInitialize MUST be called PRIOR to calling OleStdInitSummaryInfo.
**    Memory is allocated using the currently active IMalloc*
**    allocator (as is returned by call CoGetMalloc(MEMCTX_TASK) ).
**
** Common scenarios:
**    Read SummaryInfo
**    ----------------
**      OleStdInitSummaryInfo()
**      OleStdReadSummaryInfo()
**      . . . . .
**      call different Get routines
**      . . . . .
**      OleStdFreeSummaryInfo()
**
**    Create SummaryInfo
**    ------------------
**      OleStdInitSummaryInfo()
**      call different Set routines
**      OleStdWriteSummaryInfo()
**      OleStdFreeSummaryInfo()
**
**    Update SummaryInfo
**    ------------------
**      OleStdInitSummaryInfo()
**      OleStdReadSummaryInfo()
**      OleStdGetThumbNailProperty(necessary only if no SetThumb)
**      call different Set routines
**      OleStdWriteSummaryInfo()
**      OleStdFreeSummaryInfo()
*/

#define WORDMAX 256             //current string max for APPS; 255 + null terminator


typedef     union {
      short        iVal;             /* VT_I2                */
      long         lVal;             /* VT_I4                */
      float        fltVal;           /* VT_R4                */
      double       dblVal;       /* VT_R8                */
      DWORD bool;                /* VT_BOOL              */
      SCODE        scodeVal;         /* VT_ERROR             */
      DWORD        systimeVal;       /* VT_SYSTIME           */
#ifdef UNICODE
      TCHAR bstrVal[WORDMAX]; /* VT_BSTR              */
#else
      unsigned char bstrVal[WORDMAX]; /* VT_BSTR              */
#endif
    } VTUNION;

#if 0
typedef struct _FMTID
	{
	DWORD dword;
	WORD words[2];
	BYTE bytes[8];
	} FMTID;
#endif

typedef struct _PROPSETLIST
	{
	FMTID formatID;
	DWORD byteOffset;
	} PROPSETLIST;
	
typedef struct _PROPIDLIST
	{
	DWORD propertyID;
	DWORD byteOffset;
	} PROPIDLIST;
	
typedef struct _PROPVALUE
	{
	DWORD vtType;
	VTUNION vtValue;
	} PROPVALUE;

typedef struct _SECTION
	{
	DWORD cBytes;
	DWORD cProperties;
	PROPIDLIST rgPropId[1/*cProperties*/];  //variable-length array
	PROPVALUE rgPropValue[1];          //CANNOT BE ACCESSED BY NAME; ONLY BY POINTER
	} SECTION;
	
typedef struct _SUMMARYINFO
	{
	WORD byteOrder;
	WORD formatVersion;
	WORD getOSVersion;
	WORD osVersion;
	CLSID classId;  //from compobj.h
	DWORD cSections;
	PROPSETLIST rgPropSet[1/*cSections*/]; //variable-length array
	SECTION rgSections[1/*cSections*/];        //CANNOT BE ACCESSED BY NAME; ONLY BY POINTER
	} SUMMARYINFO;

#define osWinOnDos 0
#define osMac 1
#define osWinNT 2

#define PID_DICTIONARY 0X00000000
#define PID_CODEPAGE 0X00000001
#define PID_TITLE 0X00000002
#define PID_SUBJECT 0X00000003
#define PID_AUTHOR 0X00000004
#define PID_KEYWORDS 0X00000005
#define PID_COMMENTS 0X00000006
#define PID_TEMPLATE 0X00000007
#define PID_LASTAUTHOR 0X00000008
#define PID_REVNUMBER 0X00000009
#define PID_EDITTIME 0X0000000A
#define PID_LASTPRINTED 0X0000000B
#define PID_CREATE_DTM_RO 0X0000000C
#define PID_LASTSAVE_DTM 0X0000000D
#define PID_PAGECOUNT 0X0000000E
#define PID_WORDCOUNT 0X0000000F
#define PID_CHARCOUNT 0X00000010
#define PID_THUMBNAIL 0X00000011
#define PID_APPNAME 0X00000012
#define PID_SECURITY 0X00000013
#define cPID_STANDARD (PID_SECURITY+1-2)

#define MAXWORD 256                     //maximum string size for APPS at present

typedef struct _STDZ
	{
	DWORD vtType;
	union {
	DWORD vtByteCount;
#ifdef UNICODE
	TCHAR fill[4];  //use last byte as byte count for stz requests
#else
	unsigned char fill[4];  //use last byte as byte count for stz requests
#endif
	};

#ifdef UNICODE
	TCHAR rgchars[MAXWORD];
#else
	unsigned char rgchars[MAXWORD];
#endif
	} STDZ;
#define VTCB fill[3]    //used to set/get the count byte when in memory

typedef struct _THUMB
	{
	DWORD vtType;
	DWORD cBytes;       //clip size in memory
	DWORD selector;         //on disk -1,win clip no.  -2,mac clip no. -3,ole FMTID  0,bytes  nameLength, format name
	DWORD clipFormat;
	char FAR *lpstzName;
	char FAR *lpByte;
	} THUMB;
	
#define VT_CF_BYTES 0   
#define VT_CF_WIN ((DWORD)(-1))
#define VT_CF_MAC ((DWORD)(-2))
#define VT_CF_FMTID ((DWORD)(-3))
#define VT_CF_NAME ((DWORD)(-4))
#define VT_CF_EMPTY ((DWORD)(-5))
#define VT_CF_OOM ((DWORD)(-6))		// Out of memory
typedef THUMB FAR *LPTHUMB;
	
typedef STDZ FAR *LPSTDZ;

typedef struct _TIME
	{
	DWORD vtType;
	FILETIME time;
	} TIME;
	
typedef struct _INTS
	{
	DWORD vtType;
	DWORD value;
	} INTS;

#define MAXTIME (PID_LASTSAVE_DTM-PID_EDITTIME+1)
#define MAXINTS (PID_CHARCOUNT-PID_PAGECOUNT+1+1)
#define MAXSTDZ (PID_REVNUMBER-PID_TITLE+1+1)

typedef struct _STANDARDSECINMEM
	{
	DWORD cBytes;
	DWORD cProperties;
	PROPIDLIST rgPropId[cPID_STANDARD/*cProperties*/];  //variable-length array
	TIME rgTime[MAXTIME];
	INTS rgInts[MAXINTS];
	LPSTDZ rglpsz[MAXSTDZ];
	THUMB thumb;                                            
	} STANDARDSECINMEM;
	

#define OFFSET_NIL 0X00000000

#define AllSecurityFlagsEqNone 0
#define fSecurityPassworded 1
#define fSecurityRORecommended 2
#define fSecurityRO 4
#define fSecurityLockedForAnnotations 8

#define PropStreamNamePrefixByte '\005'
#define PropStreamName "\005SummaryInformation"
#define cbNewSummaryInfo(nSection) (sizeof(SUMMARYINFO)-sizeof(SECTION)+sizeof(PROPSETLIST)*((nSection)-1))
#define cbNewSection(nPropIds) (sizeof(SECTION)-sizeof(PROPVALUE)+sizeof(PROPIDLIST)*((nPropIds)-1))

#define FIntelOrder(prop) ((prop)->byteOrder==0xfffe)
#define SetOs(prop, os) {(prop)->osVersion=os; (prop)->getOSVersion=LOWORD(GetVersion());}
#define SetSumInfFMTID(fmtId) {(fmtId)->Data1=0XF29F85E0; *(long FAR *)&(fmtId)->Data2=0X10684FF9;\
                                *(long FAR *)&(fmtId)->Data4[0]=0X000891AB; *(long FAR *)&(fmtId)->Data4[4]=0XD9B3272B;}
#define FEqSumInfFMTID(fmtId) ((fmtId)->Data1==0XF29F85E0&&*((long FAR *)&(fmtId)->Data2)==0X10684FF9&&\
                                *((long FAR *)&(fmtId)->Data4[0])==0X000891AB&&*((long FAR *)&(fmtId)->Data4[4])==0XD9B3272B)
#define FSzEqPropStreamName(sz) _fstricmp(sz, PropStreamName)
#define ClearSumInf(lpsuminf, cb) {_fmemset(lpsuminf,0,cb); (lpsuminf)->byteOrder=0xfffe;\
				SetOs(lpsuminf, osWinOnDos);}

typedef void FAR *LPSUMINFO;
typedef LPTSTR LPSTZR;
typedef void FAR *THUMBNAIL;  //for VT_CF_WIN this is an unlocked global handle
#define API __far __pascal


/*************************************************************************
** Public Summary Info Property Set Management API
*************************************************************************/

extern "C" {
STDAPI_(LPSUMINFO) OleStdInitSummaryInfo(int reserved);
STDAPI_(void) OleStdFreeSummaryInfo(LPSUMINFO FAR *lplp);
STDAPI_(void) OleStdClearSummaryInfo(LPSUMINFO lp);
STDAPI_(int) OleStdReadSummaryInfo(LPSTREAM lpStream, LPSUMINFO lp);
STDAPI_(int) OleStdWriteSummaryInfo(LPSTREAM lpStream, LPSUMINFO lp);
STDAPI_(DWORD) OleStdGetSecurityProperty(LPSUMINFO lp);
STDAPI_(int) OleStdSetSecurityProperty(LPSUMINFO lp, DWORD security);
STDAPI_(LPTSTR) OleStdGetStringProperty(LPSUMINFO lp, DWORD pid);
STDAPI_(int) OleStdSetStringProperty(LPSUMINFO lp, DWORD pid, LPTSTR lpsz);
STDAPI_(LPSTZR) OleStdGetStringZProperty(LPSUMINFO lp, DWORD pid);
STDAPI_(void) OleStdGetDocProperty(
	LPSUMINFO       lp,
	DWORD FAR*      nPage,
	DWORD FAR*      nWords,
	DWORD FAR*      nChars
);
STDAPI_(int) OleStdSetDocProperty(
	LPSUMINFO       lp,
	DWORD           nPage,
	DWORD           nWords,
	DWORD           nChars
);
STDAPI_(int) OleStdGetThumbNailProperty(
	LPSTREAM        lps,
	LPSUMINFO       lp,
	DWORD FAR*      clipFormatNo,
	LPTSTR FAR*      lpszName,
	THUMBNAIL FAR*  clip,
	DWORD FAR*      byteCount,
	BOOL            transferClip
);
STDAPI_(int) OleStdSetThumbNailProperty(
	LPSTREAM        lps,
	LPSUMINFO       lp,
	int             vtcfNo,
	DWORD           clipFormatNo,
	LPTSTR          lpszName,
	THUMBNAIL       clip,
	DWORD           byteCount
);
STDAPI_(void) OleStdGetDateProperty(
	LPSUMINFO       lp,
	DWORD           pid,
	int FAR*        yr,
	int FAR*        mo,
	int FAR*        dy,
	DWORD FAR*      sc
);
STDAPI_(int) OleStdSetDateProperty(
	LPSUMINFO       lp,
	DWORD           pid,
	int             yr,
	int             mo,
	int             dy,
	int             hr,
	int             mn,
	int             sc
);

} //END C

#endif  // SUMINFO_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\letest\ole2ui\stdpal.h ===
/*-----------------------------------------------------------------------
|	stdpal.h
|	
|	Standard App Palette useful for OLE applications.  v 1.01
|
|	#include this file in the same file as HpalCreateAppPalette
|	
|	NOTE:  Palette MUST be created with HpalCreateAppPalette
|
|   Copyright (c) 1992 - 1993 Microsoft Corporation. All rights reserved.
|
-----------------------------------------------------------------------*/

#include <commdlg.h>    // needed for LPPRINTDLG
#include <shellapi.h>   // needed for HKEY

#ifdef WIN32
#define _based(A)
#define _segname(A)
#endif

#ifndef CSCONST
#ifdef FLAT
#define CSCONST(type)    type const
#else
#define CSCONST(type)    type _based(_segname("_CODE")) const
#endif
#endif

CSCONST(unsigned char) palSVGA[256][3] =
	{
	// R     G     B
	{0x00, 0x00, 0x00}, // 0 Sys Black	gray 0
	{0x80, 0x00, 0x00}, // 1 Sys Dk Red
	{0x00, 0x80, 0x00}, // 2 Sys Dk Green
	{0x80, 0x80, 0x00}, // 3 Sys Dk Yellow
	{0x00, 0x00, 0x80}, // 4 Sys Dk Blue
	{0x80, 0x00, 0x80}, // 5 Sys Dk Violet
	{0x00, 0x80, 0x80}, // 6 Sys Dk Cyan
	{0xc0, 0xc0, 0xc0}, // 7 Sys Lt Grey	gray 192
	{0xc0, 0xdc, 0xc0}, // 8 Sys 8
	{0xa6, 0xca, 0xf0}, // 9 Sys 9 (the first 10 are fixed by Windows)

	{0x80, 0x00, 0x00}, // 10 Sys Dk Red repeat
	{0x00, 0x80, 0x00}, // 11 Sys Dk Green repeat
	{0x80, 0x80, 0x00}, // 12 Sys Dk Yellow repeat
	{0x00, 0x00, 0x80}, // 13 Sys Dk Blue repeat
	{0x80, 0x00, 0x80}, // 14 Sys Dk Violet repeat
	{0x00, 0x80, 0x80}, // 15 Sys Dk Cyan repeat
	{0x80, 0x80, 0x80}, // 16 Sys Dk Grey repeat	gray 128
	{0x80, 0x80, 0xff}, // 17 Excel Chart Fill 1
	{0x80, 0x20, 0x60}, // 18 Excel Chart Fill 2
	{0xff, 0xff, 0xc0}, // 19 Excel Chart Fill 3
	{0xa0, 0xe0, 0xe0}, // 20 Excel Chart Fill 4
	{0x60, 0x00, 0x80}, // 21 Excel Chart Fill 4
	{0xff, 0x80, 0x80}, // 22 Excel Chart Fill 6
	{0x00, 0x80, 0xc0}, // 23 Excel Chart Fill 7
	{0xc0, 0xc0, 0xff}, // 24 Excel Chart Fill 8
	{0x00, 0xcf, 0xff}, // 25 Excel clrt entry
	{0x69, 0xff, 0xff}, // 26 Excel clrt entry
	{0xe0, 0xff, 0xe0}, // 27 Excel clrt entry
	{0xdd, 0x9c, 0xb3}, // 28 Excel clrt entry
	{0xb3, 0x8f, 0xee}, // 29 Excel clrt entry
	{0x2a, 0x6f, 0xf9}, // 30 Excel clrt entry
	{0x3f, 0xb8, 0xcd}, // 31 Excel clrt entry
	{0x48, 0x84, 0x36}, // 32 Excel clrt entry
	{0x95, 0x8c, 0x41}, // 33 Excel clrt entry
	{0x8e, 0x5e, 0x42}, // 34 Excel clrt entry
	{0xa0, 0x62, 0x7a}, // 35 Excel clrt entry
	{0x62, 0x4f, 0xac}, // 36 Excel clrt entry
	{0x1d, 0x2f, 0xbe}, // 37 Excel clrt entry
	{0x28, 0x66, 0x76}, // 38 Excel clrt entry
	{0x00, 0x45, 0x00}, // 39 Excel clrt entry
	{0x45, 0x3e, 0x01}, // 40 Excel clrt entry
	{0x6a, 0x28, 0x13}, // 41 Excel clrt entry
	{0x85, 0x39, 0x6a}, // 42 Excel clrt entry
	{0x4a, 0x32, 0x85}, // 43 Excel clrt entry
	{0x04, 0x04, 0x04}, // 44 	gray 4
	{0x08, 0x08, 0x08}, // 45 	gray 8
	{0x0c, 0x0c, 0x0c}, // 46 	gray 12
	{0x11, 0x11, 0x11}, // 47 	gray 17
	{0x16, 0x16, 0x16}, // 48 	gray 22
	{0x1c, 0x1c, 0x1c}, // 49 	gray 28
	{0x22, 0x22, 0x22}, // 50 	gray 34
	{0x29, 0x29, 0x29}, // 51 	gray 41
	{0x30, 0x30, 0x30}, // 52 	gray 48
	{0x5f, 0x5f, 0x5f}, // 53 swapped so inversions look good	gray 95
	{0x55, 0x55, 0x55}, // 54 swapped so inversions look good	gray 85
	{0x4d, 0x4d, 0x4d}, // 55 swapped so inversions look good	gray 77
	{0x42, 0x42, 0x42}, // 56 swapped so inversions look good	gray 66
	{0x39, 0x39, 0x39}, // 57 swapped so inversions look good	gray 57
	{0x00, 0x07, 0x00}, // 58
	{0x0d, 0x00, 0x00}, // 59
	{0xb7, 0x99, 0x81}, // 60
	{0x84, 0x99, 0xb4}, // 61
	{0xbd, 0xbd, 0x90}, // 62
	{0x7f, 0x7f, 0x60}, // 63
	{0x60, 0x60, 0x7f}, // 64
	{0x00, 0x0e, 0x00}, // 65
	{0x1b, 0x00, 0x00}, // 66
	{0x28, 0x00, 0x00}, // 67
	{0x08, 0x09, 0x2b}, // 68
	{0x00, 0x1d, 0x00}, // 69
	{0x39, 0x00, 0x00}, // 70
	{0x00, 0x00, 0x9b}, // 71
	{0x00, 0x25, 0x00}, // 72
	{0x49, 0x00, 0x00}, // 73
	{0x11, 0x11, 0x3b}, // 74
	{0x00, 0x2f, 0x00}, // 75
	{0x5d, 0x00, 0x00}, // 76
	{0x17, 0x17, 0x45}, // 77
	{0x00, 0x3a, 0x00}, // 78
	{0x49, 0x11, 0x11}, // 79
	{0x1c, 0x1c, 0x53}, // 80
	{0x00, 0x16, 0xff}, // 81
	{0x2b, 0x00, 0xff}, // 82
	{0x21, 0x21, 0x6c}, // 83
	{0x59, 0x14, 0x14}, // 84
	{0x00, 0x51, 0x00}, // 85
	{0x47, 0x1a, 0x6a}, // 86
	{0x19, 0x32, 0x67}, // 87
	{0x00, 0x61, 0x00}, // 88
	{0x00, 0x31, 0xff}, // 89
	{0x61, 0x00, 0xff}, // 90
	{0x53, 0x20, 0x7b}, // 91
	{0x16, 0x43, 0x67}, // 92
	{0x2e, 0x2e, 0xe2}, // 93
	{0x26, 0x59, 0x16}, // 94
	{0x51, 0x46, 0x04}, // 95
	{0x68, 0x2e, 0x49}, // 96
	{0x07, 0x52, 0x8f}, // 97
	{0x6a, 0x18, 0xb8}, // 98
	{0x90, 0x23, 0x15}, // 99
	{0x00, 0x53, 0xff}, // 100
	{0xa3, 0x00, 0xff}, // 101
	{0x6a, 0x4a, 0x12}, // 102
	{0x75, 0x33, 0x6c}, // 103
	{0x4a, 0x41, 0x9a}, // 104
	{0x37, 0x65, 0x0b}, // 105
	{0xa4, 0x2c, 0x15}, // 106
	{0x83, 0x1f, 0xb1}, // 107
	{0x4e, 0x2c, 0xff}, // 108
	{0x20, 0x51, 0xb6}, // 109
	{0x08, 0x64, 0x92}, // 110
	{0x6f, 0x56, 0x0b}, // 111
	{0x59, 0x43, 0xad}, // 112
	{0x36, 0x72, 0x12}, // 113
	{0xb0, 0x33, 0x17}, // 114
	{0x00, 0xa1, 0x00}, // 115
	{0x77, 0x5f, 0x1f}, // 116
	{0x89, 0x47, 0x71}, // 117
	{0xb0, 0x43, 0x1c}, // 118
	{0xb7, 0x2d, 0x7d}, // 119
	{0x00, 0x86, 0x95}, // 120
	{0x7a, 0x6e, 0x23}, // 121
	{0x26, 0x9f, 0x00}, // 122
	{0x73, 0xa9, 0x01}, // 123
	{0x00, 0x00, 0x00}, // 124 free 0	gray 0
	{0x00, 0x00, 0x00}, // 125 free 2	gray 0
	{0x00, 0x00, 0x00}, // 126 free 4	gray 0
	{0x00, 0x00, 0x00}, // 127 free 6	gray 0
	{0x00, 0x00, 0x00}, // 128 free 7	gray 0
	{0x00, 0x00, 0x00}, // 129 free 5	gray 0
	{0x00, 0x00, 0x00}, // 130 free 3	gray 0
	{0x00, 0x00, 0x00}, // 131 free 1	gray 0
	{0x00, 0xca, 0x00}, // 132
	{0xac, 0x5b, 0x01}, // 133
	{0x20, 0x1d, 0xc2}, // 134
	{0x94, 0x52, 0x70}, // 135
	{0x24, 0xaa, 0x4c}, // 136
	{0x0a, 0x94, 0x89}, // 137
	{0x36, 0x6e, 0x7b}, // 138
	{0x44, 0x75, 0x90}, // 139
	{0xff, 0x00, 0xa8}, // 140
	{0x00, 0x71, 0xff}, // 141
	{0xdf, 0x00, 0xff}, // 142
	{0x56, 0x91, 0x4a}, // 143
	{0x34, 0x48, 0xf8}, // 144
	{0xcc, 0x32, 0x82}, // 145
	{0xe4, 0x41, 0x70}, // 146
	{0x68, 0xca, 0x01}, // 147
	{0x36, 0xbc, 0x42}, // 148
	{0x00, 0x9a, 0xff}, // 149
	{0x96, 0x22, 0xb7}, // 150
	{0x85, 0x7d, 0x33}, // 151
	{0x25, 0xb7, 0x8c}, // 152
	{0x36, 0x5a, 0xed}, // 153
	{0x5c, 0xff, 0x00}, // 154
	{0xff, 0x48, 0x00}, // 155
	{0x22, 0x9b, 0xa2}, // 156
	{0x42, 0xcf, 0x4d}, // 157
	{0xc2, 0x58, 0x52}, // 158
	{0x20, 0xd3, 0x95}, // 159
	{0xa5, 0x24, 0xe0}, // 160
	{0x73, 0x56, 0xb5}, // 161
	{0xa9, 0xa9, 0x00}, // 162
	{0xd0, 0x6f, 0x3c}, // 163
	{0x67, 0x9f, 0x58}, // 164
	{0x89, 0xcf, 0x0b}, // 165
	{0xff, 0xac, 0x00}, // 166
	{0xa7, 0x2e, 0xfe}, // 167
	{0xe2, 0x59, 0x7f}, // 168
	{0x4c, 0xdc, 0x67}, // 169
	{0xff, 0x18, 0xff}, // 170
	{0x3a, 0x7d, 0xff}, // 171
	{0xb1, 0xd0, 0x18}, // 172
	{0xc7, 0xff, 0x00}, // 173
	{0xff, 0xe2, 0x00}, // 174
	{0xdf, 0x9a, 0x3d}, // 175
	{0x56, 0x81, 0x9f}, // 176
	{0xc6, 0x43, 0xba}, // 177
	{0xaf, 0x71, 0x8b}, // 178
	{0x38, 0xa2, 0xc9}, // 179
	{0xd1, 0x53, 0xce}, // 180
	{0xff, 0x9a, 0x65}, // 181
	{0x46, 0xca, 0xdb}, // 182
	{0xff, 0x4d, 0xff}, // 183
	{0xc8, 0xe9, 0x6a}, // 184
	{0x4c, 0xde, 0xe0}, // 185
	{0xff, 0x98, 0xff}, // 186
	{0xdf, 0xc0, 0x82}, // 187
	{0xe9, 0xec, 0xa5}, // 188
	{0xf5, 0xf6, 0xcd}, // 189
	{0xff, 0xd0, 0xff}, // 190
	{0xb1, 0xac, 0x5a}, // 191
	{0x63, 0x91, 0xae}, // 192
	{0x22, 0x4c, 0x65}, // 193
	{0x8d, 0x4e, 0x3f}, // 194
	{0x50, 0x70, 0x70}, // 195
	{0xd0, 0xff, 0xff}, // 196
	{0xff, 0xe7, 0xff}, // 197
	{0x69, 0x69, 0x69}, // 198 	gray 105
	{0x77, 0x77, 0x77}, // 199 	gray 119
	{0x86, 0x86, 0x86}, // 200 	gray 134
	{0x96, 0x96, 0x96}, // 201 	gray 150
	{0x9d, 0x9d, 0x9d}, // 202 	gray 157
	{0xa4, 0xa4, 0xa4}, // 203 	gray 164
	{0xb2, 0xb2, 0xb2}, // 204 	gray 178
	{0xcb, 0xcb, 0xcb}, // 205 	gray 203
	{0xd7, 0xd7, 0xd7}, // 206 	gray 215
	{0xdd, 0xdd, 0xdd}, // 207 	gray 221
	{0xe3, 0xe3, 0xe3}, // 208 	gray 227
	{0xea, 0xea, 0xea}, // 209 	gray 234
	{0xf1, 0xf1, 0xf1}, // 210 	gray 241
	{0xf8, 0xf8, 0xf8}, // 211 	gray 248
	{0xb2, 0xc1, 0x66}, // 212
	{0x80, 0xbf, 0x78}, // 213
	{0xc6, 0xf0, 0xf0}, // 214
	{0xb2, 0xa4, 0xff}, // 215
	{0xff, 0xb3, 0xff}, // 216
	{0xd1, 0x8e, 0xa3}, // 217
	{0xc3, 0xdc, 0x37}, // 218
	{0xa0, 0x9e, 0x54}, // 219
	{0x76, 0xae, 0x70}, // 220
	{0x78, 0x9e, 0xc1}, // 221
	{0x83, 0x64, 0xbf}, // 222
	{0xa4, 0x83, 0xd3}, // 223
	{0xd1, 0x3f, 0x32}, // 224
	{0xff, 0x7d, 0x00}, // 225
	{0x44, 0x78, 0x23}, // 226
	{0x24, 0x5f, 0x60}, // 227
	{0x0e, 0x0e, 0x2c}, // 228
	{0xbe, 0x00, 0x00}, // 229
	{0xff, 0x1f, 0x00}, // 230
	{0x31, 0x39, 0x00}, // 231
	{0xd9, 0x85, 0x3e}, // 232
	{0x02, 0x77, 0x85}, // 233
	{0xb0, 0xd8, 0x81}, // 234
	{0x56, 0x21, 0x1d}, // 235
	{0x00, 0x00, 0x30}, // 236
	{0x88, 0xc8, 0xb3}, // 237
	{0xa0, 0x79, 0x00}, // 238
	{0xc0, 0xc0, 0xc0}, // 239 Sys Dk Grey repeat inversion	gray 192
	{0xea, 0x70, 0x81}, // 240
	{0x51, 0xf1, 0x69}, // 241
	{0xff, 0xff, 0x80}, // 242
	{0x91, 0x74, 0xcd}, // 243
	{0xff, 0x7c, 0xff}, // 244
	{0xa2, 0xff, 0xff}, // 245

	{0xff, 0xfb, 0xf0}, // 246 Sys Reserved
	{0xa0, 0xa0, 0xa4}, // 247 Sys Reserved
	{0x80, 0x80, 0x80}, // 248 Sys Lt Gray	gray 128
	{0xff, 0x00, 0x00}, // 249 Sys Red
	{0x00, 0xff, 0x00}, // 250 Sys Green
	{0xff, 0xff, 0x00}, // 251 Sys Yellow
	{0x00, 0x00, 0xff}, // 252 Sys Blue
	{0xff, 0x00, 0xff}, // 253 Sys Violet
	{0x00, 0xff, 0xff}, // 254 Sys Cyan
	{0xff, 0xff, 0xff} // 255 Sys White	gray 255
	};
	

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\letest\ole2ui\suminfo.cpp ===
/*************************************************************************
**
**    OLE 2.0 Property Set Utilities
**
**    suminfo.cpp
**
**    This file contains functions that are useful for the manipulation
**    of OLE 2.0 Property Sets particularly to manage the Summary Info
**    property set.
**
**    (c) Copyright Microsoft Corp. 1990 - 1992 All Rights Reserved
**
*************************************************************************/

// Note: this file is designed to be stand-alone; it includes a
// carefully chosen, minimal set of headers.
//
// For conditional compilation we use the ole2 conventions,
//    _MAC      = mac
//    WIN32     = Win32 (NT really)
//    <nothing> = defaults to Win16

// REVIEW: the following needs to modified to handle _MAC
#define STRICT
#ifndef INC_OLE2
   #define INC_OLE2
#endif

#include <windows.h>
#include <string.h>
#include <ole2.h>
#include "ole2ui.h"

OLEDBGDATA

/* A LPSUMINFO variable is a pointer to an instance of an abstract data
**    type.  There can be an arbitrary number of SummaryInfo streams open
**    simultaneously (subject to available memory); each must have its
**    own LPSUMINFO instance. Each LPSUMINFO instance must
**    be initialized prior to use by calling Init and freed after its
**    last use by calling Free.  The param argument to Init is reserved
**    for future expansion and should be zero initially. Once a LPSUMINFO
**    instance is allocated (by Init), the user can call the Set
**    procedures to initialize fields.  A copy of the arguments is made
**    in every case except SetThumbnail where control of the storage
**    occupied by the METAFILEPICT is merely transferred.  When the
**    Free routine is called, all storage will be deallocated including
**    that of the thumbnail.  The arguments to SetThumbNail and the
**    return values from GetThumbNail correspond to the OLE2.0 spec.
**    Note that on input, the thumbnail is read on demand but all the
**    other properties are pre-loaded.  The thumbnail is manipulated as
**    a windows handle to a METAFILEPICT structure, which in turn
**    contains a handle to the METAFILE.  The transferClip argument on
**    GetThumbNail, when set to true, transfers responsibility for
**    storage management of the thumbnail to the caller; that is, after
**    Free has been called, the handle is still valid. Clear can be
**    used to free storage for all the properties but then you must
**    call Read to load them again.  All the code is based on FAR
**    pointers.
**    CoInitialize MUST be called PRIOR to calling OleStdInitSummaryInfo.
**    Memory is allocated using the currently active IMalloc*
**    allocator (as is returned by call CoGetMalloc(MEMCTX_TASK) ).
**
** Common scenarios:
**    Read SummaryInfo
**    ----------------
**      OleStdInitSummaryInfo()
**      OleStdReadSummaryInfo()
**      . . . . .
**      call different Get routines
**      . . . . .
**      OleStdFreeSummaryInfo()
**
**    Create SummaryInfo
**    ------------------
**      OleStdInitSummaryInfo()
**      call different Set routines
**      OleStdWriteSummaryInfo()
**      OleStdFreeSummaryInfo()
**
**    Update SummaryInfo
**    ------------------
**      OleStdInitSummaryInfo()
**      OleStdReadSummaryInfo()
**      OleStdGetThumbNailProperty(necessary only if no SetThumb)
**      call different Set routines
**      OleStdWriteSummaryInfo()
**      OleStdFreeSummaryInfo()
*/

#ifdef WIN32
#define CHAR TCHAR
#else
#define CHAR unsigned char
#endif
#define fTrue 1
#define fFalse 0
#define BYTE unsigned char
#define WORD unsigned short
#define DWORD unsigned long
#define LPVOID void FAR *
#define uchar unsigned char
#define ulong unsigned long
#define BOOL unsigned char
#define BF unsigned int

#include "suminfo.h"
#include "wn_dos.h"

#if defined( _DEBUG )
   #ifndef NOASSERT
      // following is from compobj.dll (ole2)
      #ifdef UNICODE
	  #define ASSERT(x) (!(x) ? FnAssert(TEXT(#x), NULL, \
				    TEXT(__FILE__), __LINE__) : 0)
      #else
	  #define ASSERT(x) (!(x) ? \
			{    \
			  WCHAR wsz[255];    \
			  wcscpy(wsz, (#x)); \
			  FnAssert(wsz, NULL, TEXT(__FILE__), __LINE__)  \
			}    \
			: 0)
      #endif
   #else
      #define ASSERT(x)
   #endif
#else
#define ASSERT(x)
#endif


typedef struct _RSUMINFO
	{
	WORD byteOrder;
	WORD formatVersion;
	WORD getOSVersion;
	WORD osVersion;
	CLSID classId;  //from compobj.h
	DWORD cSections;
	PROPSETLIST rgPropSet[1/*cSections*/]; //one section in standard summary info
	STANDARDSECINMEM section;
	ULONG fileOffset;       //offset for thumbnail to support demand read
	} RSUMINFO;
	
typedef RSUMINFO FAR * LPRSI;

	typedef union _foo{
		ULARGE_INTEGER uli;
		struct {
			DWORD           dw;
			DWORD           dwh;
			};
		struct {
			WORD    w0;
			WORD    w1;
			WORD    w2;
			WORD    w3;
			};
		} Foo;



/* MemAlloc
** ---------
**    allocate memory using the currently active IMalloc* allocator
*/
static LPVOID MemAlloc(ULONG ulSize)
{
    LPVOID pout;
    LPMALLOC pmalloc;

    if (CoGetMalloc(MEMCTX_TASK, &pmalloc) != NOERROR) {
	OleDbgAssert(pmalloc);
	return NULL;
    }

    pout = (LPVOID)pmalloc->Alloc(ulSize);

    if (pmalloc != NULL) {
	ULONG refs = pmalloc->Release();
    }

    return pout;
}


/* MemFree
** -------
**    free memory using the currently active IMalloc* allocator
*/
static void MemFree(LPVOID pmem)
{
    LPMALLOC pmalloc;

    if (pmem == NULL)
	return;

    if (CoGetMalloc(MEMCTX_TASK, &pmalloc) != NOERROR) {
	OleDbgAssert(pmalloc);
	return;
    }

    pmalloc->Free(pmem);

    if (pmalloc != NULL) {
	ULONG refs = pmalloc->Release();
    }
}

// Replace the first argument with the product of itself and the multiplier
static void ulargeMultiply(ULARGE_INTEGER FAR *ul, USHORT m)
{
    Foo out, in;
    in.uli = *ul;
    out.dw = (ULONG)m * in.w0;          in.w0 = out.w0;
    out.dw = (ULONG)m * in.w1 + out.w1; in.w1 = out.w0;
    out.dw = (ULONG)m * in.w2 + out.w1; in.w2 = out.w0;
    out.dw = (ULONG)m * in.w3 + out.w1; in.w3 = out.w0;
    *ul = in.uli;
}
	
// Replace the first argument with the product of itself and the multiplier
static void ulargeDivide(ULARGE_INTEGER FAR *ul, USHORT m)
{
    Foo out, in;
    DWORD i;
    in.uli = *ul;
    out.dwh = in.dwh/(ULONG)m;
    i = in.dwh%(ULONG)m;
    in.w2 = in.w1;
    in.w3 = (WORD)i;
    out.w1 = (WORD)(in.dwh/(ULONG)m);
    in.w1 = (WORD)(in.dwh%(ULONG)m);
    out.w0 = (WORD)(in.dw/(ULONG)m);
    *ul = out.uli;
}


static void setStandard(LPRSI lprsi)
{
    int i;
    lprsi->cSections = 1;
    SetSumInfFMTID(&lprsi->rgPropSet[0].formatID);
    _fmemcpy(&lprsi->classId, &lprsi->rgPropSet[0].formatID, sizeof(FMTID));
    lprsi->rgPropSet[0].byteOffset = cbNewSummaryInfo(1);
    for (i=0; i<cPID_STANDARD; i++)
	lprsi->section.rgPropId[i].propertyID = PID_TITLE+i;
    lprsi->section.cProperties = cPID_STANDARD; //always; do null test to check validity
}

extern "C" {

/*************************************************************************
**
** OleStdInitSummaryInfo
**
** Purpose:
**    Initialize a Summary Info structure.
**
** Parameters:
**    int reserved             - reserverd for future use. must be 0.
**
** Return Value:
**    LPSUMINFO
**
** Comments:
**    CoInitialize MUST be called PRIOR to calling OleStdInitSummaryInfo.
**    Memory is allocated using the currently active IMalloc*
**    allocator (as is returned by call CoGetMalloc(MEMCTX_TASK) ).
**    Each LPSUMINFO instance must be initialized prior to use by
**    calling OleStdInitSummaryInfo. Once a LPSUMINFO instance is allocated
**    (by OleStdInitSummaryInfo), the user can call the Set procedures to
**    initialize fields.
*************************************************************************/

STDAPI_(LPSUMINFO) OleStdInitSummaryInfo(int reserved)
{
    LPRSI lprsi;

    if ((lprsi = (LPRSI)MemAlloc(sizeof(RSUMINFO))) != NULL)
    {
	ClearSumInf(lprsi, sizeof(RSUMINFO));
    } else return NULL;

    setStandard(lprsi);
    return (LPSUMINFO)lprsi;
}


/*************************************************************************
**
** OleStdFreeSummaryInfo
**
** Purpose:
**    Free a Summary Info structure.
**
** Parameters:
**    LPSUMINFO FAR *lp           - pointer to open Summary Info struct
**
** Return Value:
**    void
**
** Comments:
**    Memory is freed using the currently active IMalloc*
**    allocator (as is returned by call CoGetMalloc(MEMCTX_TASK) ).
**    Every LPSUMINFO struct must be freed after its last use.
**    When the OleStdFreeSummaryInfo routine is called, all storage will be
**    deallocated including that of the thumbnail (unless ownership of
**    the thumbnail has been transfered to the caller -- see
**    description of transferClip in GetThumbnail API).
**
*************************************************************************/

STDAPI_(void) OleStdFreeSummaryInfo(LPSUMINFO FAR *lplp)
{
	if (lplp==NULL||*lplp==NULL) return;
	OleStdClearSummaryInfo(*lplp);
	MemFree(*lplp);
	*lplp = NULL;
}


/*************************************************************************
**
** OleStdClearSummaryInfo
**
** Purpose:
**    Free storage (memory) for all the properties of the LPSUMINFO.
**
** Parameters:
**    LPSUMINFO FAR *lp             - pointer to open Summary Info struct
**
** Return Value:
**    void
**
** Comments:
**    After calling OleStdClearSummaryInfo you must call OleStdReadSummaryInfo to
**    load them again.
**
*************************************************************************/

STDAPI_(void) OleStdClearSummaryInfo(LPSUMINFO lp)
{
	OleStdSetStringProperty(lp, PID_TITLE, NULL);
	OleStdSetStringProperty(lp, PID_SUBJECT, NULL);
	OleStdSetStringProperty(lp, PID_AUTHOR, NULL);
	OleStdSetStringProperty(lp, PID_KEYWORDS, NULL);
	OleStdSetStringProperty(lp, PID_COMMENTS, NULL);
	OleStdSetStringProperty(lp, PID_TEMPLATE, NULL);
	OleStdSetStringProperty(lp, PID_REVNUMBER, NULL);
	OleStdSetStringProperty(lp, PID_APPNAME, NULL);
	OleStdSetThumbNailProperty(NULL, lp, VT_CF_EMPTY, 0, NULL, NULL, 0);
	ClearSumInf((LPRSI)lp, sizeof(RSUMINFO));
}


/*************************************************************************
**
** OleStdReadSummaryInfo
**
** Purpose:
**    Read all Summary Info properties into memory (except thumbnail
**    which is demand loaded).
**
** Parameters:
**    LPSTREAM lps                  - open SummaryInfo IStream*
**    LPSUMINFO FAR *lp             - pointer to open Summary Info struct
**
** Return Value:
**    int                           - 1 for success
**                                  - 0 if error occurs
** Comments:
**
*************************************************************************/

STDAPI_(int) OleStdReadSummaryInfo(LPSTREAM lpStream, LPSUMINFO lp)
{
    STANDARDSECINMEM FAR *lpSSIM=(STANDARDSECINMEM FAR*)&((LPRSI)lp)->section;
    LPRSI lpSumInfo = (LPRSI)lp;
    SCODE sc;
    ULONG cbRead,i,sectionOffset;
    LARGE_INTEGER a;
    ULARGE_INTEGER b;
    int j,k,l;
    union {
	RSUMINFO rsi;
	STDZ stdz;
    };
    OleStdClearSummaryInfo(lp);
    LISet32(a, 0);
    sc = GetScode(lpStream->Seek(a, STREAM_SEEK_SET, &b));
    if (FAILED(sc)) goto fail;
    sectionOffset = cbNewSummaryInfo(1);
    sc = GetScode(lpStream->Read(&rsi, sectionOffset, &cbRead));
    if (FAILED(sc)||cbRead<sectionOffset) goto fail;
    if (!FIntelOrder(&rsi)||rsi.formatVersion!=0) goto fail;
    j = (int)rsi.cSections;
    while (j-->0) {
	if (FEqSumInfFMTID(&rsi.rgPropSet[0].formatID)) {
	    sectionOffset = rsi.rgPropSet[0].byteOffset;
	    break;
	} else {
	    sc = GetScode(lpStream->Read(&rsi.rgPropSet[0].formatID, sizeof(PROPSETLIST), &cbRead));
	    if (FAILED(sc)||cbRead!=sizeof(PROPSETLIST)) goto fail;
	}
	if (j<=0) goto fail;
    }

    LISet32(a, sectionOffset);
    sc = GetScode(lpStream->Seek(a, STREAM_SEEK_SET, &b));
    if (FAILED(sc)) goto fail;
    sc = GetScode(lpStream->Read(&rsi.section, cbNewSection(1), &cbRead));
    if (FAILED(sc)||cbRead!=cbNewSection(1)) goto fail;
    i = rsi.section.cBytes+sectionOffset;
    j = (int)rsi.section.cProperties;
    if (j>cPID_STANDARD) goto fail;
    k = 0;
    while (j-->0) {
	k++;
	switch (l=(int)rsi.section.rgPropId[0].propertyID) {
	    case PID_PAGECOUNT:
	    case PID_WORDCOUNT:
	    case PID_CHARCOUNT:
	    case PID_SECURITY:
		if (l==PID_SECURITY) l=3; else l-=PID_PAGECOUNT;
		cbRead = sectionOffset+rsi.section.rgPropId[0].byteOffset;
		if (cbRead>=i) goto fail;
		LISet32(a, cbRead);
		sc = GetScode(lpStream->Seek(a, STREAM_SEEK_SET, &b));
		if (FAILED(sc)) goto fail;
		sc = GetScode(lpStream->Read(&lpSSIM->rgInts[l], sizeof(INTS), &cbRead));
		if (FAILED(sc)||cbRead!=sizeof(INTS)) goto fail;
		if (lpSSIM->rgInts[l].vtType==VT_EMPTY) break;
		if (lpSSIM->rgInts[l].vtType!=VT_I4) goto fail;
		break;
	    case PID_EDITTIME:
	    case PID_LASTPRINTED:
	    case PID_CREATE_DTM_RO:
	    case PID_LASTSAVE_DTM:
		l-=PID_EDITTIME;
		cbRead = sectionOffset+rsi.section.rgPropId[0].byteOffset;
		if (cbRead>=i) goto fail;
		LISet32(a, cbRead);
		sc = GetScode(lpStream->Seek(a, STREAM_SEEK_SET, &b));
		if (FAILED(sc)) goto fail;
		sc = GetScode(lpStream->Read(&lpSSIM->rgTime[l], sizeof(TIME), &cbRead));
		if (FAILED(sc)||cbRead!=sizeof(TIME)) goto fail;
		if (lpSSIM->rgTime[l].vtType==VT_EMPTY) break;
		if (lpSSIM->rgTime[l].vtType!=VT_FILETIME) goto fail;
		break;
	    case PID_TITLE:
	    case PID_SUBJECT:
	    case PID_AUTHOR:
	    case PID_KEYWORDS:
	    case PID_COMMENTS:
	    case PID_TEMPLATE:
	    case PID_LASTAUTHOR:
	    case PID_REVNUMBER:
	    case PID_APPNAME:
		cbRead = sectionOffset+rsi.section.rgPropId[0].byteOffset;
		if (cbRead>=i) goto fail;
		LISet32(a, cbRead);
		sc = GetScode(lpStream->Seek(a, STREAM_SEEK_SET, &b));
		if (FAILED(sc)) goto fail;
		sc = GetScode(lpStream->Read(&stdz, sizeof(STDZ), &cbRead));
		if (FAILED(sc)||cbRead<sizeof(DWORD)*2) goto fail;
		if (stdz.vtType==VT_EMPTY||stdz.vtByteCount<=1) break;
		if (stdz.vtType!=VT_LPSTR||stdz.vtByteCount>WORDMAX) goto fail;
		stdz.rgchars[(int)stdz.vtByteCount-1] = TEXT('\0');
		OleStdSetStringProperty(lp, (DWORD)l, (LPTSTR)&stdz.rgchars[0]);
		break;
	    case PID_THUMBNAIL:
		cbRead = sectionOffset+rsi.section.rgPropId[0].byteOffset;
		if (cbRead>=i) goto fail;
		LISet32(a, cbRead);
		sc = GetScode(lpStream->Seek(a, STREAM_SEEK_SET, &b));
		if (FAILED(sc)) goto fail;
		lpSumInfo->fileOffset = cbRead+sizeof(DWORD)*3;
		sc = GetScode(lpStream->Read(&lpSSIM->thumb, sizeof(DWORD)*4, &cbRead));
		if (FAILED(sc)||cbRead!=sizeof(DWORD)*4) {
		    lpSSIM->thumb.vtType = VT_EMPTY;
		    goto fail;
		}
		if (lpSSIM->thumb.vtType == VT_EMPTY) {
		    lpSSIM->thumb.cBytes = 0;
		    break;
		}
		if (lpSSIM->thumb.vtType != VT_CF) {
		    lpSSIM->thumb.vtType = VT_EMPTY;
		    goto fail;
		}
		lpSSIM->thumb.cBytes -= sizeof(DWORD); //for selector
		if (lpSSIM->thumb.selector==VT_CF_WIN||lpSSIM->thumb.selector==VT_CF_MAC) {
		    lpSumInfo->fileOffset += sizeof(DWORD);
		    lpSSIM->thumb.cBytes -= sizeof(DWORD); //for format val
		}
		break;
		default: ;
	}
	if (j<=0)
	{
	// We should fail if the document is password-protected.
	    if(OleStdGetSecurityProperty(lp)==fSecurityPassworded)
		goto fail;
	    return 1;
	}
	LISet32(a, sectionOffset+sizeof(DWORD)*2+k*sizeof(PROPIDLIST));
	sc = GetScode(lpStream->Seek(a, STREAM_SEEK_SET, &b));
	if (FAILED(sc)) goto fail;
	sc = GetScode(lpStream->Read(&rsi.section.rgPropId[0], sizeof(PROPIDLIST), &cbRead));
	if (FAILED(sc)||cbRead!=sizeof(PROPIDLIST)) goto fail;
    }

fail:
    OleStdClearSummaryInfo(lpSumInfo);

    return 0;
}


/*************************************************************************
**
** OleStdWriteSummaryInfo
**
** Purpose:
**    Write all Summary Info properties to a IStream*
**
** Parameters:
**    LPSTREAM lps                  - open SummaryInfo IStream*
**    LPSUMINFO FAR *lp             - pointer to open Summary Info struct
**
** Return Value:
**    int                           - 1 for success
**                                  - 0 if error occurs
** Comments:
**
*************************************************************************/

STDAPI_(int) OleStdWriteSummaryInfo(LPSTREAM lpStream, LPSUMINFO lp)
{


    STANDARDSECINMEM FAR *lpSSIM=(STANDARDSECINMEM FAR*)&((LPRSI)lp)->section;
	// REVIEW: localization issues for propert sets
	//                 do we need to include a code page and dictionary?

    LPRSI lpSumInfo = (LPRSI)lp;
    SCODE sc;
    ULONG cbWritten;
    ULONG cBytes, oBytes, k,l,m,n;
    LARGE_INTEGER a;
    ULARGE_INTEGER b;
    CHAR FAR *lps;
    LPMETAFILEPICT lpmfp;
    int i,j,s;

    setStandard(lpSumInfo);
    oBytes = cbNewSection(cPID_STANDARD);  //offsets are relative to the section
    cBytes = cbNewSection(cPID_STANDARD)+(sizeof(TIME)*MAXTIME)+(sizeof(INTS)*MAXINTS);

    lpSSIM->rgPropId[PID_EDITTIME-2].byteOffset = oBytes;
    lpSSIM->rgPropId[PID_LASTPRINTED-2].byteOffset = oBytes+sizeof(TIME);
    lpSSIM->rgPropId[PID_CREATE_DTM_RO-2].byteOffset = oBytes+sizeof(TIME)*2;
    lpSSIM->rgPropId[PID_LASTSAVE_DTM-2].byteOffset = oBytes+sizeof(TIME)*3;

    lpSSIM->rgPropId[PID_PAGECOUNT-2].byteOffset = oBytes+(sizeof(TIME)*MAXTIME);
    lpSSIM->rgPropId[PID_WORDCOUNT-2].byteOffset = oBytes+(sizeof(TIME)*MAXTIME+sizeof(INTS));
    lpSSIM->rgPropId[PID_CHARCOUNT-2].byteOffset = oBytes+(sizeof(TIME)*MAXTIME+sizeof(INTS)*2);
    lpSSIM->rgPropId[PID_SECURITY-2].byteOffset = oBytes+(sizeof(TIME)*MAXTIME+sizeof(INTS)*3);
    oBytes += sizeof(TIME)*MAXTIME + sizeof(INTS)*MAXINTS;

    lpSSIM->rgPropId[PID_THUMBNAIL-2].byteOffset = oBytes;
    l = 0;
    if (lpSSIM->thumb.vtType==VT_EMPTY) k = sizeof(DWORD);
    else {
	l = ((lpSSIM->thumb.cBytes+4-1)>>2)<<2;
	if (lpSSIM->thumb.selector==VT_CF_BYTES) k = sizeof(DWORD)*3;
	else if (lpSSIM->thumb.selector==VT_CF_FMTID) {k = sizeof(DWORD)*3; l += sizeof(FMTID); }
	else if (lpSSIM->thumb.selector==VT_CF_NAME)  {k = sizeof(DWORD)*3; l += (((*lpSSIM->thumb.lpstzName+1+3)>>2)<<2);}
	else k = sizeof(DWORD)*4;
    }
    cBytes += k+l;
    oBytes += k+l;

    for (i=0; i<MAXSTDZ; i++) {
	j = 0;
	if (lpSSIM->rglpsz[i]!=NULL) {
	    j = lpSSIM->rglpsz[i]->VTCB+1/*null*/;
	    lpSSIM->rglpsz[i]->vtByteCount = j;
	    j = (((j+4-1)>>2)<<2)+sizeof(DWORD);
	    cBytes += j;
	}
	if (i!=MAXSTDZ-1) lpSSIM->rgPropId[i].byteOffset = oBytes;
	else lpSSIM->rgPropId[PID_APPNAME-2].byteOffset = oBytes;
	oBytes += j+sizeof(DWORD);
	cBytes += sizeof(DWORD); //type
    }
    lpSSIM->cBytes = cBytes;


    LISet32(a, 0);
    sc = GetScode(lpStream->Seek(a, STREAM_SEEK_SET, &b));
    if (FAILED(sc)) return 0;
    sc = GetScode(lpStream->Write(lpSumInfo, cbNewSummaryInfo(1), &cbWritten));
    if (FAILED(sc)||cbWritten!=cbNewSummaryInfo(1)) return 0;
    sc = GetScode(lpStream->Write(lpSSIM, cbNewSection(cPID_STANDARD)+sizeof(TIME)*MAXTIME+sizeof(INTS)*MAXINTS, &cbWritten));
    if (FAILED(sc)||cbWritten!=cbNewSection(cPID_STANDARD)+sizeof(TIME)*MAXTIME+sizeof(INTS)*MAXINTS) return 0;

    m = lpSSIM->thumb.cBytes;
    if (lpSSIM->thumb.lpstzName!=NULL) s = *lpSSIM->thumb.lpstzName;
    else s = 0;
    if (m!=0) {
	lpSSIM->thumb.cBytes = (k-sizeof(DWORD)*2)+
	    (((lpSSIM->thumb.cBytes+4-1)>>2)<<2)+(((s+4-1)>>2)<<2);
	n = lpSSIM->thumb.selector;
	lps = lpSSIM->thumb.lpByte;
	OleDbgAssert(lps!=NULL);      //maybe a GetThumbNail here
	OleDbgAssert(n!=VT_CF_NAME);
	if (n==VT_CF_WIN) {     //bytes are in global memory
	    lpmfp = (LPMETAFILEPICT)GlobalLock((HANDLE)(DWORD)lps);
	    if (lpmfp==NULL) goto fail;
	    lps = (CHAR FAR*)GlobalLock(lpmfp->hMF);
	}
	if (n==VT_CF_NAME) lpSSIM->thumb.selector = *lpSSIM->thumb.lpstzName+1/*null*/;
    }
    sc = GetScode(lpStream->Write(&lpSSIM->thumb, k, &cbWritten));
    if (FAILED(sc)||cbWritten!=k) goto fail;
    if (s!=0) {
	k = ((s+1+4-1)>>2)<<2;
	sc = GetScode(lpStream->Write(lpSSIM->thumb.lpstzName+1, k, &cbWritten));
	if (FAILED(sc)||cbWritten!=k) goto fail;
    }
    if (m!=0) {
	k = ((m+3)>>2)<<2;
	if (n==VT_CF_WIN||VT_CF_NAME) { //bytes are in global memory
	    sc = GetScode(lpStream->Write(lpmfp, sizeof(METAFILEPICT), &cbWritten));
	    k -= sizeof(METAFILEPICT);
	}
	sc = GetScode(lpStream->Write(lps, k, &cbWritten));
	if (FAILED(sc)||cbWritten!=k) goto fail;
	if (n==VT_CF_WIN||VT_CF_NAME) { //bytes are in global memory
	    GlobalUnlock(lpmfp->hMF);
	    GlobalUnlock((HANDLE)(DWORD)lpSSIM->thumb.lpByte);
	}
    }
    lpSSIM->thumb.cBytes = m;   //restore in mem value
    lpSSIM->thumb.selector = n;

    k = VT_EMPTY;
    for (i=0; i<MAXSTDZ; i++) {
	if (lpSSIM->rglpsz[i]!=NULL) {
	    l = lpSSIM->rglpsz[i]->vtByteCount;
	    j = ((((int)l+4-1)/4)*4)+sizeof(DWORD)*2;
	    sc = GetScode(lpStream->Write(lpSSIM->rglpsz[i], j, &cbWritten));
	    if (FAILED(sc)||cbWritten!=(ULONG)j) return 0;
	    lpSSIM->rglpsz[i]->vtByteCount = 0; //restore stz count convention
	    lpSSIM->rglpsz[i]->VTCB = (int)l;
	} else {
	    sc = GetScode(lpStream->Write(&k, sizeof(DWORD), &cbWritten));
	    if (FAILED(sc)||cbWritten!=sizeof(DWORD)) return 0;
	}
    }
    return 1;
fail:
    lpSSIM->thumb.cBytes = m;   //restore in mem value
    lpSSIM->thumb.selector = n;
    if (m!=0&&(n==VT_CF_WIN||VT_CF_NAME)) {     //bytes are in global memory
	GlobalUnlock((HANDLE)(DWORD)lps);
    }

    return 0;
}


/*************************************************************************
**
** OleStdGetSecurityProperty
**
** Purpose:
**    Retrieve the Security Property
**
** Parameters:
**    LPSUMINFO FAR *lp           - pointer to open Summary Info struct
**
** Return Value:
**    DWORD                       - security level
**          AllSecurityFlagsEqNone 0    - no security
**          fSecurityPassworded 1       - password required
**          fSecurityRORecommended 2    - read-only is recommended
**          fSecurityRO 4               - read-only is required
**          fSecurityLockedForAnnotations 8 - locked for annotations
**
** Comments:
**    by noting the (suggested; that is, application-enforced) security
**    level on the document, an application other than the originator
**    of the document can adjust its user interface to the properties
**    appropriately. An application should not display any of the
**    information about a password protected document, and should not
**    allow modifications to enforced read-only or locked for
**    annotations documents. It should warn the user about read-only
**    recommended if the user attempts to modify properties.
**
*************************************************************************/

STDAPI_(DWORD) OleStdGetSecurityProperty(LPSUMINFO lp)
{
STANDARDSECINMEM FAR *lpSSIM=(STANDARDSECINMEM FAR*)&((LPRSI)lp)->section;
	if (lpSSIM->rgInts[3].vtType == VT_I4) return lpSSIM->rgInts[3].value;

	return 0;
}


/*************************************************************************
**
** OleStdSetSecurityProperty
**
** Purpose:
**    Set the Security Property
**
** Parameters:
**    LPSUMINFO FAR *lp           - pointer to open Summary Info struct
**    DWORD security              - security level
**          AllSecurityFlagsEqNone 0    - no security
**          fSecurityPassworded 1       - password required
**          fSecurityRORecommended 2    - read-only is recommended
**          fSecurityRO 4               - read-only is required
**          fSecurityLockedForAnnotations 8 - locked for annotations
**
** Return Value:
**    int                           - 1 for success
**                                  - 0 if error occurs
**                                    (there are no errors)
**
** Comments:
**    by noting the (suggested; that is, application-enforced) security
**    level on the document, an application other than the originator
**    of the document can adjust its user interface to the properties
**    appropriately. An application should not display any of the
**    information about a password protected document, and should not
**    allow modifications to enforced read-only or locked for
**    annotations documents. It should warn the user about read-only
**    recommended if the user attempts to modify properties.
**
*************************************************************************/

STDAPI_(int) OleStdSetSecurityProperty(LPSUMINFO lp, DWORD security)
{
    STANDARDSECINMEM FAR *lpSSIM=(STANDARDSECINMEM FAR*)&((LPRSI)lp)->section;

    // REVIEW: check valid transitions; how do we know APP called us?

	if (security==0) {
		lpSSIM->rgInts[3].vtType = VT_EMPTY;
		return 1;
	}
	lpSSIM->rgInts[3].vtType = VT_I4;
	lpSSIM->rgInts[3].value = security;
	return 1;
}


/*************************************************************************
**
** OleStdGetStringProperty
**
** Purpose:
**    Retrieve a String Propety.
**    (returns zero terminated string -- C string)
**
** Parameters:
**    LPSUMINFO FAR *lp             - pointer to open Summary Info struct
**    DWORD pid                     - ID of String Property
**
** Return Value:
**    LPTSTR                         - value of String Property
**                                      (zero terminated string--C string)
**
** Comments:
**    String should NOT be freed by caller. Memory for string will be
**    freed when OleStdFreeSummaryInfo is called.
*************************************************************************/

STDAPI_(LPTSTR) OleStdGetStringProperty(LPSUMINFO lp, DWORD pid)
{
    LPTSTR l = OleStdGetStringZProperty(lp,pid);
    if (l==NULL) return NULL; else return l+1;
}


/*************************************************************************
**
** OleStdSetStringProperty
**
** Purpose:
**    Set a String Propety
**    (takes zero terminated string -- C string)
**
** Parameters:
**    LPSUMINFO FAR *lp             - pointer to open Summary Info struct
**    DWORD pid                     - ID of String Property
**    LPTSTR lpsz                   - new value for String Property.
**                                      zero terminated string -- C string.
**                                      May be NULL, in which case the
**                                      propery is cleared.
**
** Return Value:
**    int                           - 1 if successful
**                                  - 0 invalid property id
**
** Comments:
**    The input string is copied.
**
*************************************************************************/

STDAPI_(int) OleStdSetStringProperty(LPSUMINFO lp, DWORD pid, LPTSTR lpsz)
{
    LPRSI lprsi=(LPRSI)lp;
    STANDARDSECINMEM FAR* lpSSIM=(STANDARDSECINMEM FAR*)&((LPRSI)lp)->section;
    int i;
    if (pid==PID_APPNAME) {
	pid = MAXSTDZ-1;
    } else if (pid<PID_TITLE || pid>PID_REVNUMBER) return 0; else pid -= 2;
    OleDbgAssert(lpSSIM);
    if (lpSSIM->rglpsz[pid]) MemFree(lpSSIM->rglpsz[pid]);
    if ((lpsz==NULL)||(*lpsz==0)) {
	lpSSIM->rglpsz[pid] = NULL;
	return (1);
    }
    i = _fstrlen(lpsz);
    lpSSIM->rglpsz[pid] = (STDZ FAR*)MemAlloc((i+1/*null*/)*sizeof(TCHAR)+
		sizeof(DWORD)*2);
    if (lpSSIM->rglpsz[pid]==NULL) return 0;
    _fstrcpy((LPTSTR)&lpSSIM->rglpsz[pid]->rgchars, lpsz);
    lpSSIM->rglpsz[pid]->vtType = VT_LPSTR;
    lpSSIM->rglpsz[pid]->vtByteCount = 0;
    lpSSIM->rglpsz[pid]->VTCB = i;
    return (1);
}


/*************************************************************************
**
** OleStdGetStringZProperty
**
** Purpose:
**    Retrieve a String Propety.
**    (returns zero-terminated with leading byte count string)
**
** Parameters:
**    LPSUMINFO FAR *lp             - pointer to open Summary Info struct
**    DWORD pid                     - ID of Property
**
** Return Value:
**    LPSTZR                        - value of String Property
**                                      (zero-terminated with leading
**                                      byte count)
**
** Comments:
**    String should NOT be freed by caller. Memory for string will be
**    freed when OleStdFreeSummaryInfo is called.
*************************************************************************/

STDAPI_(LPSTZR) OleStdGetStringZProperty(LPSUMINFO lp, DWORD pid)
{
    STANDARDSECINMEM FAR *lpSSIM=(STANDARDSECINMEM FAR*)&((LPRSI)lp)->section;
    if (pid==PID_APPNAME) {
	pid = MAXSTDZ-1;
    } else if (pid<PID_TITLE || pid>PID_REVNUMBER) return NULL; else pid -= 2;
    if (lpSSIM->rglpsz[pid]!=NULL) {
	return (LPTSTR)&lpSSIM->rglpsz[pid]->VTCB;
    }
    return NULL;
}


/*************************************************************************
**
** OleStdGetDocProperty
**
** Purpose:
**    Retrieve document properties (no. pages, no. words, no. characters)
**
** Parameters:
**    LPSUMINFO FAR *lp             - pointer to open Summary Info struct
**    DWORD FAR *nPage              - (OUT) number of pages in document
**    DWORD FAR *nWords             - (OUT) number of words in document
**    DWORD FAR *nChars             - (OUT) number of charactrs in doc
**
** Return Value:
**    void
**
** Comments:
**
*************************************************************************/

STDAPI_(void) OleStdGetDocProperty(
	LPSUMINFO       lp,
	DWORD FAR*      nPage,
	DWORD FAR*      nWords,
	DWORD FAR*      nChars
)
{
STANDARDSECINMEM FAR *lpSSIM=(STANDARDSECINMEM FAR*)&((LPRSI)lp)->section;
	*nPage=0; *nWords=0; *nChars=0;
	if (lpSSIM->rgInts[0].vtType == VT_I4) *nPage = lpSSIM->rgInts[0].value;
	if (lpSSIM->rgInts[1].vtType == VT_I4) *nWords = lpSSIM->rgInts[1].value;
	if (lpSSIM->rgInts[2].vtType == VT_I4) *nChars = lpSSIM->rgInts[2].value;
}


/*************************************************************************
**
** OleStdSetDocProperty
**
** Purpose:
**    Set document properties (no. pages, no. words, no. characters)
**
** Parameters:
**    LPSUMINFO FAR *lp             - pointer to open Summary Info struct
**    DWORD nPage                   - number of pages in document
**    DWORD nWords                  - number of words in document
**    DWORD nChars                  - number of charactrs in doc
**
** Return Value:
**    int                           - 1 for success
**                                  - 0 if error occurs
**                                    (there are no errors)
**
** Comments:
**
*************************************************************************/

STDAPI_(int) OleStdSetDocProperty(
	LPSUMINFO       lp,
	DWORD           nPage,
	DWORD           nWords,
	DWORD           nChars
)
{
DWORD vttype=VT_I4;
STANDARDSECINMEM FAR *lpSSIM=(STANDARDSECINMEM FAR*)&((LPRSI)lp)->section;
	if ((nPage|nWords|nChars)==0) {
		vttype = VT_EMPTY;
		nPage=0; nWords=0; nChars=0;
	}
	lpSSIM->rgInts[0].vtType = vttype;
	lpSSIM->rgInts[1].vtType = vttype;
	lpSSIM->rgInts[2].vtType = vttype;
	lpSSIM->rgInts[0].value = nPage;
	lpSSIM->rgInts[1].value = nWords;
	lpSSIM->rgInts[2].value = nChars;
	return 1;
}


/*************************************************************************
**
** OleStdGetThumbNailProperty
**
** Purpose:
**    Retrieve a Thumbnail Property
**
** Parameters:
**    LPSTREAM lps
**    LPSUMINFO FAR *lp             - pointer to open Summary Info struct
**    DWORD FAR* clipFormatNo       - clipboard format for thumbnail
**                                      (type of value depends on vtcf
**                                      return value.)
**                                      NOTE: ONLY VT_CF_WIN is
**                                      implemented, so clipFormatNo
**                                      will be CF_METAFILEPICT
**    LPTSTR FAR* lpszName           - format name if VT_CF_NAME is
**                                      returned
**                                      NOTE: NOT IMPLEMENTED
**    THUMBNAIL FAR* clip           - handle to thumbnail
**                                      for VT_CF_WIN clip will be
**                                      handle to MetafilePict
**                                      NOTE: only VT_CF_WIN IMPLEMENTED
**    DWORD FAR* byteCount          - size of thumbnail stream
**                                      for VT_CF_WIN case this should
**                                      be combined size of both the
**                                      Metafile as well as the
**                                      MetafilePict structure.
**    BOOL transferClip             - transfer ownership of thumbnail
**                                      to caller. (see comment)
**
** Return Value:
**    int vtcfNo                    - OLE thumbnail selector value
**      VT_CF_WIN                   - Windows thumbnail
**                                                                              (interpret clipFormatNo as
**                                                                              Windows clipboard format)
**      VT_CF_FMTID                             - (NOT IMPLEMENTED)
**                                      thumbnail format is specified
**                                      by ID. use clipFormatNo.
**                                      (but NOT a Windows format ID)
**
**      VT_CF_NAME                  - (NOT IMPLEMENTED)
**                                      thumbnail format is specified
**                                      by name. use lpszName.
**      VT_CF_EMPTY                 - blank thumbnail
**                                                                              (clip will be NULL)
**      VT_CF_OOM                   - Memory allocation failure
**
** Comments:
**    NOTE: Currently there is only proper support for VT_CF_WIN.
**    OleStdSetThumbNailProperty does implement VT_CF_FMTID and VT_CF_NAME,
**    however, OleStdGetThumbNailProperty, OleStdReadSummaryInfo and
**    OleStdWriteSummaryInfo only support VT_CF_WIN.
**
**    Note that on input, the thumbnail is read on demand while all the
**    other properties are pre-loaded.  The thumbnail is manipulated as
**    a windows handle to a METAFILEPICT structure, which in turn
**    contains a handle to the METAFILE.  The transferClip argument on
**    GetThumbNail, when set to true, transfers responsibility for
**    storage management of the thumbnail to the caller; that is, after
**    OleStdFreeSummaryInfo has been called, the handle is still valid.
*************************************************************************/

STDAPI_(int) OleStdGetThumbNailProperty(
	LPSTREAM        lps,
	LPSUMINFO       lp,
	DWORD FAR*      clipFormatNo,
	LPTSTR FAR*      lpszName,
	THUMBNAIL FAR*  clip,
	DWORD FAR*      byteCount,
	BOOL            transferClip
)
{
    int i;
    LPRSI lprsi=(LPRSI)lp;
    STANDARDSECINMEM FAR *lpSSIM=(STANDARDSECINMEM FAR*)&((LPRSI)lp)->section;
    ULONG cbRead, cbToRead;
    LARGE_INTEGER a;
    ULARGE_INTEGER b;
    CHAR FAR *lpst;
    LPMETAFILEPICT lpmfp;
    HANDLE hst, hmfp;
    SCODE sc;
    *byteCount = 0;
    if (lpSSIM->thumb.cBytes==0) return VT_CF_EMPTY;
    if (lpSSIM->thumb.lpByte==NULL) {
	LISet32(a, lprsi->fileOffset);
	sc = GetScode(lps->Seek(a, STREAM_SEEK_SET, &b));
	if (FAILED(sc)) return VT_CF_EMPTY;
	i = (int) lpSSIM->thumb.selector;
	if (i>0||i==VT_CF_FMTID) {
	    if (i>255) return VT_CF_EMPTY;
	    else if (i==VT_CF_FMTID) i = sizeof(FMTID);
	    else lpSSIM->thumb.selector = VT_CF_NAME;
	    cbToRead = ((i+3)>>2)<<2;
	    lpSSIM->thumb.lpstzName=(CHAR FAR*)MemAlloc(i+1/*n*/+1);
	    if (lpSSIM->thumb.lpstzName==NULL) return VT_CF_OOM;
	    sc = GetScode(lps->Read(lpSSIM->thumb.lpstzName+1, cbToRead, &cbRead));
	    if (FAILED(sc)||cbRead!=cbToRead) return VT_CF_EMPTY;
	    *lpSSIM->thumb.lpstzName = i;
	    *(lpSSIM->thumb.lpstzName+i) = 0;
	    lpSSIM->thumb.cBytes -= cbToRead+sizeof(DWORD);
	}
	i = (int) lpSSIM->thumb.selector;
	cbToRead = lpSSIM->thumb.cBytes;
	if (cbToRead>65535) return VT_CF_OOM;
	OleDbgAssert(i!=VT_CF_NAME);
	if (i==VT_CF_WIN) {
	    cbToRead -= sizeof(METAFILEPICT);
	    hmfp = GlobalAlloc(GMEM_MOVEABLE, sizeof(METAFILEPICT));
	    if (hmfp==NULL) return VT_CF_OOM;
	    hst = GlobalAlloc(GMEM_MOVEABLE, cbToRead);
	    if (hst==NULL) {
		GlobalFree(hmfp);
		return VT_CF_OOM;
	    }
	    lpmfp = (LPMETAFILEPICT)GlobalLock(hmfp);
	    sc = GetScode(lps->Read(lpmfp, sizeof(METAFILEPICT), &cbRead));
	    if (FAILED(sc)||cbRead!=sizeof(METAFILEPICT)) {
		GlobalUnlock(hmfp);
		GlobalFree(hmfp);
		GlobalFree(hst);
		return VT_CF_EMPTY;
	    }
	    lpst = (CHAR FAR*)GlobalLock(hst);
	    lpmfp->hMF = (HMETAFILE)hst;
	    lpSSIM->thumb.lpByte = (CHAR FAR*)hmfp;
	} else {
	    lpst =(CHAR FAR*)MemAlloc((int)cbToRead);
	    if (lpst==NULL) return VT_CF_OOM;
	    lpSSIM->thumb.lpByte = lpst;
	}
	sc = GetScode(lps->Read(lpst, cbToRead, &cbRead));
	if (i==VT_CF_WIN) {
	    GlobalUnlock(hst);
	    GlobalUnlock(hmfp);
	}
	if (FAILED(sc)||cbRead!=cbToRead) {
	    if (i==VT_CF_WIN) {
		GlobalFree(hst);
		GlobalFree(hmfp);
	    } else MemFree(lpst);
	    lpSSIM->thumb.lpByte = NULL;
	    if ((i==VT_CF_NAME||i==VT_CF_FMTID)&&(lpSSIM->thumb.lpstzName!=NULL))
		MemFree(lpSSIM->thumb.lpstzName);
	    return VT_CF_EMPTY;
	}
    }
    *clipFormatNo = lpSSIM->thumb.clipFormat;
    *byteCount = lpSSIM->thumb.cBytes;
    if(lpszName!=NULL)
	*lpszName = (TCHAR FAR*)lpSSIM->thumb.lpstzName+1;
    *clip = (TCHAR FAR*)lpSSIM->thumb.lpByte;
    if (transferClip) lpSSIM->thumb.lpByte=NULL;
    return (int)lpSSIM->thumb.selector;
}


/*************************************************************************
**
** OleStdSetThumbNailProperty
**
** Purpose:
**    Set a Thumbnail Property
**
** Parameters:
**    LPSTREAM lps                  - open SummaryInfo IStream*
**    LPSUMINFO FAR *lp             - pointer to open Summary Info struct
**    int vtcfNo                    - OLE thumbnail selector value
**          VT_CF_WIN                   - Windows thumbnail
**                                                                                (interpret clipFormatNo as
**                                                                                Windows clipboard format)
**          VT_CF_FMTID                                 - thumbnail format is specified
**                                        by ID. use clipFormatNo.
**                                        (but NOT a Windows format ID)
**
**          VT_CF_NAME                  - thumbnail format is specified
**                                        by name. use lpszName.
**          VT_CF_EMPTY                 - blank thumbnail
**                                                                                (clip will be NULL)
**
**    DWORD FAR* clipFormatNo       - clipboard format for thumbnail
**                                      used if vtcfNo is VT_CF_WIN or
**                                      VT_CF_FMTID. interpretation of
**                                      value depends on vtcfNo specified.
**                                      (normally vtcfNo==VT_CF_WIN and
**                                      clipFormatNo==CF_METAFILEPICT)
**    LPSTR FAR* lpszName           - format name if vtcfNo is VT_CF_NAME
**    THUMBNAIL clip                - handle to thumbnail
**                                      for VT_CF_WIN clip will be
**                                      handle to MetafilePict
**    DWORD FAR* byteCount          - size of thumbnail stream
**                                      for VT_CF_WIN case this should
**                                      be combined size of both the
**                                      Metafile as well as the
**                                      MetafilePict structure.
**
** Return Value:
**    int                           - 1 for success
**                                  - 0 if error occurs
**
** Comments:
**    NOTE: Currently there is only proper support for VT_CF_WIN.
**    OleStdSetThumbNailProperty does implement VT_CF_FMTID and VT_CF_NAME,
**    however, OleStdGetThumbNailProperty, OleStdReadSummaryInfo and
**    OleStdWriteSummaryInfo only support VT_CF_WIN.
**
**    This function copies lpszName but saves the "clip" handle passed.
**
**    NOTE: overwriting or emptying frees space for clip and name.
**    The thumbnail is manipulated as a windows handle to a
**    METAFILEPICT structure, which in turn contains a handle to the
**    METAFILE.
*************************************************************************/

STDAPI_(int) OleStdSetThumbNailProperty(
	LPSTREAM        lps,
	LPSUMINFO       lp,
	int             vtcfNo,
	DWORD           clipFormatNo,
	LPTSTR           lpszName,
	THUMBNAIL       clip,
	DWORD           byteCount
)
{
    int i;
    LPRSI lprsi=(LPRSI)lp;
    STANDARDSECINMEM FAR *lpSSIM=(STANDARDSECINMEM FAR*)&((LPRSI)lp)->section;
    LPMETAFILEPICT lpmfp;
    if (lpSSIM==NULL||vtcfNo>0||vtcfNo<VT_CF_EMPTY||(vtcfNo==VT_CF_NAME&&(lpszName==NULL||*lpszName==0))) {
	return 0;
    }
    if (vtcfNo!=VT_CF_EMPTY&&(clip==0||byteCount==0)) return 0;
    i = (int) lpSSIM->thumb.vtType;
    if (i!=VT_EMPTY) {
	i = (int) lpSSIM->thumb.selector;
	OleDbgAssert(i!=VT_CF_NAME);
	if (i==VT_CF_WIN) {
	    if (lpSSIM->thumb.lpByte!=NULL) {
		lpmfp = (LPMETAFILEPICT)GlobalLock((HANDLE)(DWORD)lpSSIM->thumb.lpByte);
		GlobalFree(lpmfp->hMF);
		GlobalUnlock((HANDLE)(DWORD)lpSSIM->thumb.lpByte);
		GlobalFree((HANDLE)(DWORD)lpSSIM->thumb.lpByte);
	    }
	} else {
	    MemFree(lpSSIM->thumb.lpByte);
	}
	if ((i==VT_CF_NAME||i==VT_CF_FMTID)&&(lpSSIM->thumb.lpstzName!=NULL))
	    MemFree(lpSSIM->thumb.lpstzName);
	lpSSIM->thumb.lpstzName = NULL;
	lpSSIM->thumb.lpByte = NULL;
    }
    if (vtcfNo==VT_CF_EMPTY) {
	lpSSIM->thumb.vtType = VT_EMPTY;
	lpSSIM->thumb.cBytes = 0;
    } else {
	lpSSIM->thumb.vtType = VT_CF;
	lpSSIM->thumb.selector = vtcfNo;
	lpSSIM->thumb.cBytes = byteCount;
	lpSSIM->thumb.clipFormat = clipFormatNo;
	lpSSIM->thumb.lpByte = (CHAR FAR*)clip; //just save the hnadle
	if (vtcfNo==VT_CF_NAME||vtcfNo==VT_CF_FMTID) {
	    i = _fstrlen(lpszName);
	    if (vtcfNo==VT_CF_FMTID) OleDbgAssert(i*sizeof(TCHAR)==sizeof(FMTID));
	    lpSSIM->thumb.lpstzName =
		(CHAR FAR*)MemAlloc((i+1/*n*/+1/*null*/)*sizeof(TCHAR));
	    if (lpSSIM->thumb.lpstzName==NULL) {
		lpSSIM->thumb.vtType = VT_EMPTY;
		return 0;
	    }
	    _fstrcpy((TCHAR FAR*)lpSSIM->thumb.lpstzName+1, lpszName);
	    *lpSSIM->thumb.lpstzName = i;
	}
    }
    return 1;
}


/*************************************************************************
**
** OleStdGetDateProperty
**
** Purpose:
**    Retrieve Data Property
**
** Parameters:
**    LPSUMINFO FAR *lp             - pointer to open Summary Info struct
**    DWORD pid                     - ID of Property
**    int FAR *yr                   - (OUT) year
**    int FAR *mo                   - (OUT) month
**    int FAR *dy                   - (OUT) day
**    DWORD FAR *sc                 - (OUT) seconds
**
** Return Value:
**    void
**
** Comments:
**
*************************************************************************/

STDAPI_(void) OleStdGetDateProperty(
	LPSUMINFO       lp,
	DWORD           pid,
	int FAR*        yr,
	int FAR*        mo,
	int FAR*        dy,
	DWORD FAR*      sc
)
{
	STANDARDSECINMEM FAR *lpSSIM=(STANDARDSECINMEM FAR*)&((LPRSI)lp)->section;
	SFFS sffs;
	pid -= PID_EDITTIME;
	*yr = 0; *mo = 0; *dy = 0; *sc = 0;
	if (pid<0||pid>=MAXTIME) return;
	if (lpSSIM->rgTime[pid].vtType == VT_FILETIME) {
		if (pid==0) {
	    //convert from 100ns to seconds
			ulargeDivide((ULARGE_INTEGER FAR*)&lpSSIM->rgTime[0].time, 10000);
			ulargeDivide((ULARGE_INTEGER FAR*)&lpSSIM->rgTime[0].time, 1000);
			pid = lpSSIM->rgTime[0].time.dwLowDateTime;
			*sc = pid%((DWORD)60*60*24);
			pid /= (DWORD)60*60*24;
			*dy = (int)(pid%(DWORD)30);
			pid /= (DWORD)30;
			*mo = (int)(pid%(DWORD)12);
			*yr = (int)(pid/(DWORD)12);
		} else {
			if (CoFileTimeToDosDateTime(&lpSSIM->rgTime[pid].time,
			&sffs.dateVariable, &sffs.timeVariable)) {
				*yr = sffs.yr+1980;
		*mo = sffs.mon;
		*dy = sffs.dom;
		*sc = (DWORD)sffs.hr*3600+sffs.mint*60+sffs.sec*2;
			}
		}
    }
    return;
}



/*************************************************************************
**
** OleStdSetDateProperty
**
** Purpose:
**    Set Data Property
**
** Parameters:
**    LPSUMINFO FAR *lp             - pointer to open Summary Info struct
**    DWORD pid                     - ID of Property
**    int yr                        - year
**    int mo                        - month
**    int dy                        - day
**    DWORD sc                      - seconds
**
** Return Value:
**    int                           - 1 for success
**                                  - 0 if error occurs
**
** Comments:
**    Use all zeros to clear.
**    The following is an example of valid input:
**          yr=1993 mo=1(Jan) dy=1(1st) hr=12(noon) mn=30 sc=23
**    for PID_EDITTIME property, the values are a zero-origin duration
**    of time.
**
*************************************************************************/

STDAPI_(int) OleStdSetDateProperty(
	LPSUMINFO       lp,
	DWORD           pid,
	int             yr,
	int             mo,
	int             dy,
	int             hr,
	int             mn,
	int             sc
)
{
	STANDARDSECINMEM FAR *lpSSIM=(STANDARDSECINMEM FAR*)&((LPRSI)lp)->section;
	SFFS sffs;
	pid -= PID_EDITTIME;
	if (pid<0||pid>=MAXTIME) return 0;
	if ((yr|mo|dy|hr|mn|sc)==0) {   //all must be zero
		lpSSIM->rgTime[pid].vtType = VT_EMPTY;
		return 1;
	}
	lpSSIM->rgTime[pid].vtType = VT_FILETIME;
	if (pid==0) {
		lpSSIM->rgTime[0].time.dwLowDateTime =
		(((((DWORD)yr*365+mo*30)+dy)*24+hr)*60+mn)*60+sc;
		lpSSIM->rgTime[0].time.dwHighDateTime = 0;
	//10^7 nanoseconds/second
		ulargeMultiply((ULARGE_INTEGER FAR*)&lpSSIM->rgTime[0].time, 10000);
	//convert to units of 100 ns
		ulargeMultiply((ULARGE_INTEGER FAR*)&lpSSIM->rgTime[0].time, 1000);
	} else {
		sffs.yr = max(yr-1980,0);
	sffs.mon = mo;
	sffs.dom = dy;
		sffs.hr = hr;
	sffs.mint= mn;
	sffs.sec = sc/2;  //dos is 2 second intervals
		if (!CoDosDateTimeToFileTime(sffs.date, sffs.time,
		&lpSSIM->rgTime[pid].time)) {
			lpSSIM->rgTime[pid].vtType = VT_EMPTY;
			return 0;
		}
	}
    return 1;
}

} //END C
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\letest\ole2ui\uiclass.h ===
#define SZCLASSICONBOX TEXT("OLE2UIIBClass")
#define SZCLASSRESULTIMAGE TEXT("OLE2UIRIClass")
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\letest\ole2ui\targtdev.c ===
/*************************************************************************
**
**    OLE 2 Standard Utilities
**
**    olestd.c
**
**    This file contains utilities that are useful for dealing with
**    target devices.
**
**    (c) Copyright Microsoft Corp. 1992 All Rights Reserved
**
*************************************************************************/

#define STRICT  1
#include "ole2ui.h"
#ifndef WIN32
#include <print.h>
#endif

/*
 * OleStdCreateDC()
 *
 * Purpose:
 *
 * Parameters:
 *
 * Return Value:
 *    SCODE  -  S_OK if successful
 */
STDAPI_(HDC) OleStdCreateDC(DVTARGETDEVICE FAR* ptd)
{
    HDC hdc=NULL;
    LPDEVNAMES lpDevNames;
    LPDEVMODE lpDevMode;
    LPTSTR lpszDriverName;
    LPTSTR lpszDeviceName;
    LPTSTR lpszPortName;

    if (ptd == NULL) {
        hdc = CreateDC(TEXT("DISPLAY"), NULL, NULL, NULL);
        goto errReturn;
    }

    lpDevNames = (LPDEVNAMES) ptd; // offset for size field

    if (ptd->tdExtDevmodeOffset == 0) {
        lpDevMode = NULL;
    }else{
        lpDevMode  = (LPDEVMODE) ((LPSTR)ptd + ptd->tdExtDevmodeOffset);
    }

    lpszDriverName = (LPTSTR) lpDevNames + ptd->tdDriverNameOffset;
    lpszDeviceName = (LPTSTR) lpDevNames + ptd->tdDeviceNameOffset;
    lpszPortName   = (LPTSTR) lpDevNames + ptd->tdPortNameOffset;

    hdc = CreateDC(lpszDriverName, lpszDeviceName, lpszPortName, lpDevMode);

errReturn:
    return hdc;
}


/*
 * OleStdCreateIC()
 *
 * Purpose: Same as OleStdCreateDC, except that information context is
 *          created, rather than a whole device context.  (CreateIC is
 *          used rather than CreateDC).
 *          OleStdDeleteDC is still used to delete the information context.
 *
 * Parameters:
 *
 * Return Value:
 *    SCODE  -  S_OK if successful
 */
STDAPI_(HDC) OleStdCreateIC(DVTARGETDEVICE FAR* ptd)
{
    HDC hdcIC=NULL;
    LPDEVNAMES lpDevNames;
    LPDEVMODE lpDevMode;
    LPTSTR lpszDriverName;
    LPTSTR lpszDeviceName;
    LPTSTR lpszPortName;

    if (ptd == NULL) {
        hdcIC = CreateIC(TEXT("DISPLAY"), NULL, NULL, NULL);
        goto errReturn;
    }

    lpDevNames = (LPDEVNAMES) ptd; // offset for size field

    lpDevMode  = (LPDEVMODE) ((LPTSTR)ptd + ptd->tdExtDevmodeOffset);

    lpszDriverName = (LPTSTR) lpDevNames + ptd->tdDriverNameOffset;
    lpszDeviceName = (LPTSTR) lpDevNames + ptd->tdDeviceNameOffset;
    lpszPortName   = (LPTSTR) lpDevNames + ptd->tdPortNameOffset;

    hdcIC = CreateIC(lpszDriverName, lpszDeviceName, lpszPortName, lpDevMode);

errReturn:
    return hdcIC;
}


#ifdef NEVER
// This code is wrong
/*
 * OleStdCreateTargetDevice()
 *
 * Purpose:
 *
 * Parameters:
 *
 * Return Value:
 *    SCODE  -  S_OK if successful
 */
STDAPI_(DVTARGETDEVICE FAR*) OleStdCreateTargetDevice(LPPRINTDLG lpPrintDlg)
{
    DVTARGETDEVICE FAR* ptd=NULL;
    LPDEVNAMES lpDevNames, pDN;
    LPDEVMODE lpDevMode, pDM;
    UINT nMaxOffset;
    LPTSTR pszName;
    DWORD dwDevNamesSize, dwDevModeSize, dwPtdSize;

    if ((pDN = (LPDEVNAMES)GlobalLock(lpPrintDlg->hDevNames)) == NULL) {
        goto errReturn;
    }

    if ((pDM = (LPDEVMODE)GlobalLock(lpPrintDlg->hDevMode)) == NULL) {
        goto errReturn;
    }

    nMaxOffset =  (pDN->wDriverOffset > pDN->wDeviceOffset) ?
        pDN->wDriverOffset : pDN->wDeviceOffset ;

    nMaxOffset =  (pDN->wOutputOffset > nMaxOffset) ?
        pDN->wOutputOffset : nMaxOffset ;

    pszName = (LPTSTR)pDN + nMaxOffset;

    dwDevNamesSize = (DWORD)((nMaxOffset+lstrlen(pszName) + 1/* NULL term */)*sizeof(TCHAR));
    dwDevModeSize = (DWORD) (pDM->dmSize + pDM->dmDriverExtra);

    dwPtdSize = sizeof(DWORD) + dwDevNamesSize + dwDevModeSize;

    if ((ptd = (DVTARGETDEVICE FAR*)OleStdMalloc(dwPtdSize)) != NULL) {

        // copy in the info
        ptd->tdSize = (UINT)dwPtdSize;

        lpDevNames = (LPDEVNAMES) &ptd->tdDriverNameOffset;
        _fmemcpy(lpDevNames, pDN, (size_t)dwDevNamesSize);

        lpDevMode=(LPDEVMODE)((LPTSTR)&ptd->tdDriverNameOffset+dwDevNamesSize);
        _fmemcpy(lpDevMode, pDM, (size_t)dwDevModeSize);

        ptd->tdDriverNameOffset += 4 ;
        ptd->tdDeviceNameOffset += 4 ;
        ptd->tdPortNameOffset   += 4 ;
        ptd->tdExtDevmodeOffset = (UINT)dwDevNamesSize + 4 ;
    }

errReturn:
    GlobalUnlock(lpPrintDlg->hDevNames);
    GlobalUnlock(lpPrintDlg->hDevMode);

    return ptd;
}
#endif // NEVER



/*
 * OleStdDeleteTargetDevice()
 *
 * Purpose:
 *
 * Parameters:
 *
 * Return Value:
 *    SCODE  -  S_OK if successful
 */
STDAPI_(BOOL) OleStdDeleteTargetDevice(DVTARGETDEVICE FAR* ptd)
{
    BOOL res=TRUE;

    if (ptd != NULL) {
        OleStdFree(ptd);
    }

    return res;
}



/*
 * OleStdCopyTargetDevice()
 *
 * Purpose:
 *  duplicate a TARGETDEVICE struct. this function allocates memory for
 *  the copy. the caller MUST free the allocated copy when done with it
 *  using the standard allocator returned from CoGetMalloc.
 *  (OleStdFree can be used to free the copy).
 *
 * Parameters:
 *  ptdSrc      pointer to source TARGETDEVICE
 *
 * Return Value:
 *    pointer to allocated copy of ptdSrc
 *    if ptdSrc==NULL then retuns NULL is returned.
 *    if ptdSrc!=NULL and memory allocation fails, then NULL is returned
 */
STDAPI_(DVTARGETDEVICE FAR*) OleStdCopyTargetDevice(DVTARGETDEVICE FAR* ptdSrc)
{
  DVTARGETDEVICE FAR* ptdDest = NULL;

  if (ptdSrc == NULL) {
    return NULL;
  }

  if ((ptdDest = (DVTARGETDEVICE FAR*)OleStdMalloc(ptdSrc->tdSize)) != NULL) {
    _fmemcpy(ptdDest, ptdSrc, (size_t)ptdSrc->tdSize);
  }

  return ptdDest;
}


/*
 * OleStdCopyFormatEtc()
 *
 * Purpose:
 *  Copies the contents of a FORMATETC structure. this function takes
 *  special care to copy correctly copying the pointer to the TARGETDEVICE
 *  contained within the source FORMATETC structure.
 *  if the source FORMATETC has a non-NULL TARGETDEVICE, then a copy
 *  of the TARGETDEVICE will be allocated for the destination of the
 *  FORMATETC (petcDest).
 *
 *  OLE2NOTE: the caller MUST free the allocated copy of the TARGETDEVICE
 *  within the destination FORMATETC when done with it
 *  using the standard allocator returned from CoGetMalloc.
 *  (OleStdFree can be used to free the copy).
 *
 * Parameters:
 *  petcDest      pointer to destination FORMATETC
 *  petcSrc       pointer to source FORMATETC
 *
 * Return Value:
 *    returns TRUE is copy is successful; retuns FALSE if not successful
 */
STDAPI_(BOOL) OleStdCopyFormatEtc(LPFORMATETC petcDest, LPFORMATETC petcSrc)
{
  if ((petcDest == NULL) || (petcSrc == NULL)) {
    return FALSE;
  }

  petcDest->cfFormat = petcSrc->cfFormat;
  petcDest->ptd      = OleStdCopyTargetDevice(petcSrc->ptd);
  petcDest->dwAspect = petcSrc->dwAspect;
  petcDest->lindex   = petcSrc->lindex;
  petcDest->tymed    = petcSrc->tymed;

  return TRUE;

}


// returns 0 for exact match, 1 for no match, -1 for partial match (which is
// defined to mean the left is a subset of the right: fewer aspects, null target
// device, fewer medium).

STDAPI_(int) OleStdCompareFormatEtc(FORMATETC FAR* pFetcLeft, FORMATETC FAR* pFetcRight)
{
	BOOL bExact = TRUE;

	if (pFetcLeft->cfFormat != pFetcRight->cfFormat)
		return 1;
	else if (!OleStdCompareTargetDevice (pFetcLeft->ptd, pFetcRight->ptd))
		return 1;
	if (pFetcLeft->dwAspect == pFetcRight->dwAspect)
		// same aspects; equal
		;
	else if ((pFetcLeft->dwAspect & ~pFetcRight->dwAspect) != 0)
		// left not subset of aspects of right; not equal
		return 1;
	else
		// left subset of right
		bExact = FALSE;

	if (pFetcLeft->tymed == pFetcRight->tymed)
		// same medium flags; equal
		;
	else if ((pFetcLeft->tymed & ~pFetcRight->tymed) != 0)
		// left not subset of medium flags of right; not equal
		return 1;
	else
		// left subset of right
		bExact = FALSE;

	return bExact ? 0 : -1;
}



STDAPI_(BOOL) OleStdCompareTargetDevice
	(DVTARGETDEVICE FAR* ptdLeft, DVTARGETDEVICE FAR* ptdRight)
{
	if (ptdLeft == ptdRight)
		// same address of td; must be same (handles NULL case)
		return TRUE;
	else if ((ptdRight == NULL) || (ptdLeft == NULL))
		return FALSE;
	else if (ptdLeft->tdSize != ptdRight->tdSize)
		// different sizes, not equal
        return FALSE;
#ifdef WIN32
    else if (memcmp(ptdLeft, ptdRight, ptdLeft->tdSize) != 0)
#else
    else if (_fmemcmp(ptdLeft, ptdRight, (int)ptdLeft->tdSize) != 0)
#endif
        // not same target device, not equal
		return FALSE;
	
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\letest\ole2ui\template.h ===
/*
 * TEMPLATE.H
 *
 * CUSTOMIZATION INSTRUCTIONS:
 *
 * Copyright (c)1992 Microsoft Corporation, All Right Reserved
 *
 *
 *  1.  Replace <FILE> with the uppercased filename for this file.
 *      Lowercase the <FILE>.h entry
 *
 *  2.  Replace <NAME> with the mixed case dialog name in one word,
 *      such as InsertObject
 *
 *  3.  Replace <FULLNAME> with the mixed case dialog name in multiple
 *      words, such as Insert Object
 *
 *  4.  Replace <ABBREV> with the suffix for pointer variables, such
 *      as the IO in InsertObject's pIO or the CI in ChangeIcon's pCI.
 *      Check the alignment of the first variable declaration in the
 *      Dialog Proc after this.  I will probably be misaligned with the
 *      rest of the variables.
 *
 *  5.  Replace <STRUCT> with the uppercase structure name for this
 *      dialog sans OLEUI, such as INSERTOBJECT.  Changes OLEUI<STRUCT>
 *      in most cases, but we also use this for IDD_<STRUCT> as the
 *      standard template resource ID.
 *
 *  6.  Find <UFILL> fields and fill them out with whatever is appropriate.
 *
 *  7.  Delete this header up to the start of the next comment.
 *
 */


/*
 * <FILE>.H
 *
 * Internal definitions, structures, and function prototypes for the
 * OLE 2.0 UI <FULLNAME> dialog.
 *
 * Copyright (c)1992 Microsoft Corporation, All Right Reserved
 */


#ifndef <UFILL>
#define <UFILL>

//UFILL>  Move from here to INTERNAL to to OLE2UI.H


typedef struct tagOLEUI<STRUCT>
    {
    //These IN fields are standard across all OLEUI dialog functions.
    DWORD           cbStruct;       //Structure Size
    DWORD           dwFlags;        //IN-OUT:  Flags
    HWND            hWndOwner;      //Owning window
    LPCTSTR         lpszCaption;    //Dialog caption bar contents
    LPFNOLEUIHOOK   lpfnHook;       //Hook callback
    LPARAM          lCustData;      //Custom data to pass to hook
    HINSTANCE       hInstance;      //Instance for customized template name
    LPCTSTR         lpszTemplate;   //Customized template name
    HRSRC           hResource;      //Customized template handle

    //Specifics for OLEUI<STRUCT>.  All are IN-OUT unless otherwise spec.
    } OLEUI<STRUCT>, *POLEUI<STRUCT>, FAR *LPOLEUI<STRUCT>;


//API Prototype
UINT FAR PASCAL OleUI<NAME>(LPOLEUI<STRUCT>);


//<FULLNAME> flags
#define <ABBREV>F_SHOWHELP                0x00000001L
<UFILL>


//<FULLNAME> specific error codes
//DEFINE AS OLEUI_<ABBREV>ERR_<ERROR>     (OLEUI_ERR_STANDARDMAX+n)
<UFILL>


//<FULLNAME> Dialog identifiers
//FILL IN DIALOG IDs HERE
<UFILL>





//INTERNAL INFORMATION STARTS HERE

//Internally used structure
typedef struct tag<STRUCT>
    {
    //Keep this item first as the Standard* functions depend on it here.
    LPOLEUI<STRUCT>     lpO<ABBREV>;       //Original structure passed.

    /*
     * What we store extra in this structure besides the original caller's
     * pointer are those fields that we need to modify during the life of
     * the dialog but that we don't want to change in the original structure
     * until the user presses OK.
     */

    <UFILL>
    } <STRUCT>, *P<STRUCT>;



//Internal function prototypes
//<FILE>.C
BOOL FAR PASCAL <NAME>DialogProc(HWND, UINT, WPARAM, LPARAM);
BOOL            F<NAME>Init(HWND hDlg, WPARAM, LPARAM);
<UFILL>



#endif //<UFILL>

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\letest\ole2ui\utility.h ===
/*
 * UTILITY.H
 *
 * Miscellaneous prototypes and definitions for OLE UI dialogs.
 *
 * Copyright (c)1992 Microsoft Corporation, All Right Reserved
 */


#ifndef _UTILITY_H_
#define _UTILITY_H_

//Function prototypes
//UTILITY.C
HCURSOR  WINAPI HourGlassOn(void);
void     WINAPI HourGlassOff(HCURSOR);

BOOL     WINAPI Browse(HWND, LPTSTR, LPTSTR, UINT, UINT, DWORD);
int      WINAPI ReplaceCharWithNull(LPTSTR, int);
int      WINAPI ErrorWithFile(HWND, HINSTANCE, UINT, LPTSTR, UINT);
HFILE WINAPI DoesFileExist(LPTSTR lpszFile, OFSTRUCT FAR* lpOpenBuf);


HICON FAR PASCAL    HIconAndSourceFromClass(REFCLSID, LPTSTR, UINT FAR *);
BOOL FAR PASCAL FIconFileFromClass(REFCLSID, LPTSTR, UINT, UINT FAR *);
LPTSTR FAR PASCAL PointerToNthField(LPTSTR, int, TCHAR);
BOOL FAR PASCAL GetAssociatedExecutable(LPTSTR, LPTSTR);
HICON    WINAPI HIconFromClass(LPTSTR);
BOOL     WINAPI FServerFromClass(LPTSTR, LPTSTR, UINT);
UINT     WINAPI UClassFromDescription(LPTSTR, LPTSTR, UINT);
UINT     WINAPI UDescriptionFromClass(LPTSTR, LPTSTR, UINT);
BOOL     WINAPI FVerbGet(LPTSTR, UINT, LPTSTR);
LPTSTR    WINAPI ChopText(HWND hwndStatic, int nWidth, LPTSTR lpch);
void     WINAPI OpenFileError(HWND hDlg, UINT nErrCode, LPTSTR lpszFile);


#endif //_UTILITY_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\letest\ole2ui\utility.c ===
/*
 * UTILITY.C
 *
 * Utility routines for functions inside OLE2UI.DLL
 *
 *  General:
 *  ----------------------
 *  HourGlassOn             Displays the hourglass
 *  HourGlassOff            Hides the hourglass
 *
 *  Misc Tools:
 *  ----------------------
 *  Browse                  Displays the "File..." or "Browse..." dialog.
 *  ReplaceCharWithNull     Used to form filter strings for Browse.
 *  ErrorWithFile           Creates an error message with embedded filename
 *  OpenFileError           Give error message for OpenFile error return
 *  ChopText                Chop a file path to fit within a specified width
 *  DoesFileExist           Checks if file is valid
 *
 *  Registration Database:
 *  ----------------------
 *  HIconFromClass          Extracts the first icon in a class's server path
 *  FServerFromClass        Retrieves the server path for a class name (fast)
 *  UClassFromDescription   Finds the classname given a description (slow)
 *  UDescriptionFromClass   Retrieves the description for a class name (fast)
 *  FGetVerb                Retrieves a specific verb for a class (fast)
 *
 *
 * Copyright (c)1992 Microsoft Corporation, All Right Reserved
 */

#define STRICT  1
#include "ole2ui.h"
#include <stdlib.h>
#include <commdlg.h>
#include <memory.h>
#include <cderr.h>
#include "common.h"
#include "utility.h"
#include "geticon.h"

OLEDBGDATA

/*
 * HourGlassOn
 *
 * Purpose:
 *  Shows the hourglass cursor returning the last cursor in use.
 *
 * Parameters:
 *  None
 *
 * Return Value:
 *  HCURSOR         Cursor in use prior to showing the hourglass.
 */

HCURSOR WINAPI HourGlassOn(void)
    {
    HCURSOR     hCur;

    hCur=SetCursor(LoadCursor(NULL, IDC_WAIT));
    ShowCursor(TRUE);

    return hCur;
    }



/*
 * HourGlassOff
 *
 * Purpose:
 *  Turns off the hourglass restoring it to a previous cursor.
 *
 * Parameters:
 *  hCur            HCURSOR as returned from HourGlassOn
 *
 * Return Value:
 *  None
 */

void WINAPI HourGlassOff(HCURSOR hCur)
    {
    ShowCursor(FALSE);
    SetCursor(hCur);
    return;
    }




/*
 * Browse
 *
 * Purpose:
 *  Displays the standard GetOpenFileName dialog with the title of
 *  "Browse."  The types listed in this dialog are controlled through
 *  iFilterString.  If it's zero, then the types are filled with "*.*"
 *  Otherwise that string is loaded from resources and used.
 *
 * Parameters:
 *  hWndOwner       HWND owning the dialog
 *  lpszFile        LPSTR specifying the initial file and the buffer in
 *                  which to return the selected file.  If there is no
 *                  initial file the first character of this string should
 *                  be NULL.
 *  lpszInitialDir  LPSTR specifying the initial directory.  If none is to
 *                  set (ie, the cwd should be used), then this parameter
 *                  should be NULL.
 *  cchFile         UINT length of pszFile
 *  iFilterString   UINT index into the stringtable for the filter string.
 *  dwOfnFlags      DWORD flags to OR with OFN_HIDEREADONLY
 *
 * Return Value:
 *  BOOL            TRUE if the user selected a file and pressed OK.
 *                  FALSE otherwise, such as on pressing Cancel.
 */

BOOL WINAPI Browse(HWND hWndOwner, LPTSTR lpszFile, LPTSTR lpszInitialDir, UINT cchFile, UINT iFilterString, DWORD dwOfnFlags)
    {
       UINT           cch;
       TCHAR           szFilters[256];
       OPENFILENAME   ofn;
       BOOL           fStatus;
       DWORD          dwError;
       TCHAR            szDlgTitle[128];  // that should be big enough

    if (NULL==lpszFile || 0==cchFile)
        return FALSE;

    /*
     * REVIEW:  Exact contents of the filter combobox is TBD.  One idea
     * is to take all the extensions in the RegDB and place them in here
     * with the descriptive class name associate with them.  This has the
     * extra step of finding all extensions of the same class handler and
     * building one extension string for all of them.  Can get messy quick.
     * UI demo has only *.* which we do for now.
     */

    if (0!=iFilterString)
        cch=LoadString(ghInst, iFilterString, (LPTSTR)szFilters, sizeof(szFilters)/sizeof(TCHAR));
    else
        {
        szFilters[0]=0;
        cch=1;
        }

    if (0==cch)
        return FALSE;

    ReplaceCharWithNull(szFilters, szFilters[cch-1]);

    //Prior string must also be initialized, if there is one.
    _fmemset((LPOPENFILENAME)&ofn, 0, sizeof(ofn));
    ofn.lStructSize =sizeof(ofn);
    ofn.hwndOwner   =hWndOwner;
    ofn.lpstrFile   =lpszFile;
    ofn.nMaxFile    =cchFile;
    ofn.lpstrFilter =(LPTSTR)szFilters;
    ofn.nFilterIndex=1;
    if (LoadString(ghInst, IDS_BROWSE, (LPTSTR)szDlgTitle, sizeof(szDlgTitle)/sizeof(TCHAR)))
        ofn.lpstrTitle  =(LPTSTR)szDlgTitle;
    ofn.hInstance = ghInst;
    ofn.lpTemplateName = MAKEINTRESOURCE(IDD_FILEOPEN);
    if (NULL != lpszInitialDir)
      ofn.lpstrInitialDir = lpszInitialDir;

    ofn.Flags= OFN_HIDEREADONLY | OFN_ENABLETEMPLATE | (dwOfnFlags) ;

    //On success, copy the chosen filename to the static display
    fStatus = GetOpenFileName((LPOPENFILENAME)&ofn);
        dwError = CommDlgExtendedError();
        return fStatus;

    }





/*
 * ReplaceCharWithNull
 *
 * Purpose:
 *  Walks a null-terminated string and replaces a given character
 *  with a zero.  Used to turn a single string for file open/save
 *  filters into the appropriate filter string as required by the
 *  common dialog API.
 *
 * Parameters:
 *  psz             LPTSTR to the string to process.
 *  ch              int character to replace.
 *
 * Return Value:
 *  int             Number of characters replaced.  -1 if psz is NULL.
 */

int WINAPI ReplaceCharWithNull(LPTSTR psz, int ch)
    {
    int             cChanged=-1;

    if (NULL!=psz)
        {
        while (0!=*psz)
            {
            if (ch==*psz)
                {
                *psz=TEXT('\0');
                cChanged++;
                }
            psz++;
            }
        }
    return cChanged;
    }






/*
 * ErrorWithFile
 *
 * Purpose:
 *  Displays a message box built from a stringtable string containing
 *  one %s as a placeholder for a filename and from a string of the
 *  filename to place there.
 *
 * Parameters:
 *  hWnd            HWND owning the message box.  The caption of this
 *                  window is the caption of the message box.
 *  hInst           HINSTANCE from which to draw the idsErr string.
 *  idsErr          UINT identifier of a stringtable string containing
 *                  the error message with a %s.
 *  lpszFile        LPSTR to the filename to include in the message.
 *  uFlags          UINT flags to pass to MessageBox, like MB_OK.
 *
 * Return Value:
 *  int             Return value from MessageBox.
 */

int WINAPI ErrorWithFile(HWND hWnd, HINSTANCE hInst, UINT idsErr
                  , LPTSTR pszFile, UINT uFlags)
    {
    int             iRet=0;
    HANDLE          hMem;
    const UINT      cb=(2*OLEUI_CCHPATHMAX_SIZE);
    LPTSTR           psz1, psz2, psz3;

    if (NULL==hInst || NULL==pszFile)
        return iRet;

    //Allocate three 2*OLEUI_CCHPATHMAX byte work buffers
    hMem=GlobalAlloc(GHND, (DWORD)(3*cb));

    if (NULL==hMem)
        return iRet;

    psz1=GlobalLock(hMem);
    psz2=psz1+cb;
    psz3=psz2+cb;

    if (0!=LoadString(hInst, idsErr, psz1, cb))
        {
        wsprintf(psz2, psz1, pszFile);

        //Steal the caption of the dialog
        GetWindowText(hWnd, psz3, cb);
        iRet=MessageBox(hWnd, psz2, psz3, uFlags);
        }

    GlobalUnlock(hMem);
    GlobalFree(hMem);
    return iRet;
    }









/*
 * HIconFromClass
 *
 * Purpose:
 *  Given an object class name, finds an associated executable in the
 *  registration database and extracts the first icon from that
 *  executable.  If none is available or the class has no associated
 *  executable, this function returns NULL.
 *
 * Parameters:
 *  pszClass        LPSTR giving the object class to look up.
 *
 * Return Value:
 *  HICON           Handle to the extracted icon if there is a module
 *                  associated to pszClass.  NULL on failure to either
 *                  find the executable or extract and icon.
 */

HICON WINAPI HIconFromClass(LPTSTR pszClass)
    {
    HICON           hIcon;
    TCHAR            szEXE[OLEUI_CCHPATHMAX];
    UINT            Index;
    CLSID           clsid;

    if (NULL==pszClass)
        return NULL;

    CLSIDFromStringA(pszClass, &clsid);

    if (!FIconFileFromClass((REFCLSID)&clsid, szEXE, OLEUI_CCHPATHMAX_SIZE, &Index))
        return NULL;

    hIcon=ExtractIcon(ghInst, szEXE, Index);

    if ((HICON)32 > hIcon)
        hIcon=NULL;

    return hIcon;
    }





/*
 * FServerFromClass
 *
 * Purpose:
 *  Looks up the classname in the registration database and retrieves
 *  the name undet protocol\StdFileEditing\server.
 *
 * Parameters:
 *  pszClass        LPSTR to the classname to look up.
 *  pszEXE          LPSTR at which to store the server name
 *  cch             UINT size of pszEXE
 *
 * Return Value:
 *  BOOL            TRUE if one or more characters were loaded into pszEXE.
 *                  FALSE otherwise.
 */

BOOL WINAPI FServerFromClass(LPTSTR pszClass, LPTSTR pszEXE, UINT cch)
{

    DWORD       dw;
    LONG        lRet;
    HKEY        hKey;

    if (NULL==pszClass || NULL==pszEXE || 0==cch)
        return FALSE;

    /*
     * We have to go walking in the registration database under the
     * classname, so we first open the classname key and then check
     * under "\\LocalServer" to get the .EXE.
     */

    //Open up the class key
    lRet=RegOpenKey(HKEY_CLASSES_ROOT, pszClass, &hKey);

    if ((LONG)ERROR_SUCCESS!=lRet)
        return FALSE;

    //Get the executable path.
    dw=(DWORD)cch;
    lRet=RegQueryValue(hKey, TEXT("LocalServer"), pszEXE, &dw);

    RegCloseKey(hKey);

    return ((ERROR_SUCCESS == lRet) && (dw > 0));
}



/*
 * UClassFromDescription
 *
 * Purpose:
 *  Looks up the actual OLE class name in the registration database
 *  for the given descriptive name chosen from a listbox.
 *
 * Parameters:
 *  psz             LPSTR to the descriptive name.
 *  pszClass        LPSTR in which to store the class name.
 *  cb              UINT maximum length of pszClass.
 *
 * Return Value:
 *  UINT            Number of characters copied to pszClass.  0 on failure.
 */

UINT WINAPI UClassFromDescription(LPTSTR psz, LPTSTR pszClass, UINT cb)
    {
    DWORD           dw;
    HKEY            hKey;
    TCHAR           szClass[OLEUI_CCHKEYMAX];
    LONG            lRet;
    UINT            i;

    //Open up the root key.
    lRet=RegOpenKey(HKEY_CLASSES_ROOT, NULL, &hKey);

    if ((LONG)ERROR_SUCCESS!=lRet)
        return 0;

    i=0;
    lRet=RegEnumKey(hKey, i++, szClass, OLEUI_CCHKEYMAX_SIZE);

    //Walk the available keys
    while ((LONG)ERROR_SUCCESS==lRet)
        {
        dw=(DWORD)cb;
        lRet=RegQueryValue(hKey, szClass, pszClass, &dw);

        //Check if the description matches the one just enumerated
        if ((LONG)ERROR_SUCCESS==lRet)
            {
            if (!lstrcmp(pszClass, psz))
                break;
            }

        //Continue with the next key.
        lRet=RegEnumKey(hKey, i++, szClass, OLEUI_CCHKEYMAX_SIZE);
        }

    //If we found it, copy to the return buffer
    if ((LONG)ERROR_SUCCESS==lRet)
        lstrcpy(pszClass, szClass);
    else
        dw=0L;

    RegCloseKey(hKey);
    return (UINT)dw;
    }








/*
 * UDescriptionFromClass
 *
 * Purpose:
 *  Looks up the actual OLE descriptive name name in the registration
 *  database for the given class name.
 *
 * Parameters:
 *  pszClass        LPSTR to the class name.
 *  psz             LPSTR in which to store the descriptive name.
 *  cb              UINT maximum length of psz.
 *
 * Return Value:
 *  UINT            Number of characters copied to pszClass.  0 on failure.
 */

UINT WINAPI UDescriptionFromClass(LPTSTR pszClass, LPTSTR psz, UINT cb)
    {
    DWORD           dw;
    HKEY            hKey;
    LONG            lRet;

    if (NULL==pszClass || NULL==psz)
        return 0;

    //Open up the root key.
    lRet=RegOpenKey(HKEY_CLASSES_ROOT, NULL, &hKey);

    if ((LONG)ERROR_SUCCESS!=lRet)
        return 0;

    //Get the descriptive name using the class name.
    dw=(DWORD)cb;
    lRet=RegQueryValue(hKey, pszClass, psz, &dw);

    RegCloseKey(hKey);

    psz+=lstrlen(psz)+1;
    *psz=0;

    if ((LONG)ERROR_SUCCESS!=lRet)
        return 0;

    return (UINT)dw;
    }



// returns width of line of text. this is a support routine for ChopText
static LONG GetTextWSize(HDC hDC, LPTSTR lpsz)
{
    SIZE size;

    if (GetTextExtentPoint(hDC, lpsz, lstrlen(lpsz), (LPSIZE)&size))
        return size.cx;
    else {
        return 0;
    }
}


/*
 * ChopText
 *
 * Purpose:
 *  Parse a string (pathname) and convert it to be within a specified
 *  length by chopping the least significant part
 *
 * Parameters:
 *  hWnd            window handle in which the string resides
 *  nWidth          max width of string in pixels
 *                  use width of hWnd if zero
 *  lpch            pointer to beginning of the string
 *
 * Return Value:
 *  pointer to the modified string
 */
LPTSTR WINAPI ChopText(HWND hWnd, int nWidth, LPTSTR lpch)
{
#define PREFIX_SIZE    7 + 1
#define PREFIX_FORMAT TEXT("%c%c%c...\\")

    TCHAR   szPrefix[PREFIX_SIZE];
    BOOL    fDone = FALSE;
    int     i;
    RECT    rc;
    HDC     hdc;
    HFONT   hfont;
    HFONT   hfontOld = NULL;

    if (!hWnd || !lpch)
        return NULL;

    /* Get length of static field. */
    if (!nWidth) {
        GetClientRect(hWnd, (LPRECT)&rc);
        nWidth = rc.right - rc.left;
    }

    /* Set up DC appropriately for the static control */
    hdc = GetDC(hWnd);
    hfont = (HFONT)SendMessage(hWnd, WM_GETFONT, 0, 0L);

   if (NULL != hfont)   // WM_GETFONT returns NULL if window uses system font
       hfontOld = SelectObject(hdc, hfont);

    /* check horizontal extent of string */
    if (GetTextWSize(hdc, lpch) > nWidth) {

        /* string is too long to fit in static control; chop it */
        /* set up new prefix & determine remaining space in control */
        wsprintf((LPTSTR) szPrefix, PREFIX_FORMAT, lpch[0], lpch[1], lpch[2]);
        nWidth -= (int)GetTextWSize(hdc, (LPTSTR) szPrefix);

        /*
        ** advance a directory at a time until the remainder of the
        ** string fits into the static control after the "x:\...\" prefix
        */
        while (!fDone) {

#ifdef DBCS
            while (*lpch && (*lpch != TEXT('\\')))
#ifdef WIN32
                lpch = CharNext(lpch);
#else
                lpch = AnsiNext(lpch);
#endif
            if (*lpch)
#ifdef WIN32
                lpch = CharNext(lpch);
#else
                lpch = AnsiNext(lpch);
#endif
#else
            while (*lpch && (*lpch++ != TEXT('\\')));
#endif

            if (!*lpch || GetTextWSize(hdc, lpch) <= nWidth) {
                if (!*lpch)
                    /*
                    ** Nothing could fit after the prefix; remove the
                    ** final "\" from the prefix
                    */
                    szPrefix[lstrlen((LPTSTR) szPrefix) - 1] = 0;

                    /* rest or string fits -- stick prefix on front */
                    for (i = lstrlen((LPTSTR) szPrefix) - 1; i >= 0; --i)
                        *--lpch = szPrefix[i];
                    fDone = TRUE;
            }
        }
    }

   if (NULL != hfont)
      SelectObject(hdc, hfontOld);
    ReleaseDC(hWnd, hdc);

    return(lpch);

#undef PREFIX_SIZE
#undef PREFIX_FORMAT
}


/*
 * OpenFileError
 *
 * Purpose:
 *  display message for error returned from OpenFile
 *
 * Parameters:
 *  hDlg            HWND of the dialog.
 *  nErrCode        UINT error code returned in OFSTRUCT passed to OpenFile
 *  lpszFile        LPSTR file name passed to OpenFile
 *
 * Return Value:
 *  None
 */
void WINAPI OpenFileError(HWND hDlg, UINT nErrCode, LPTSTR lpszFile)
{
    switch (nErrCode) {
        case 0x0005:    // Access denied
            ErrorWithFile(hDlg, ghInst, IDS_CIFILEACCESS, lpszFile, MB_OK);
            break;

        case 0x0020:    // Sharing violation
            ErrorWithFile(hDlg, ghInst, IDS_CIFILESHARE, lpszFile, MB_OK);
            break;

        case 0x0002:    // File not found
        case 0x0003:    // Path not found
            ErrorWithFile(hDlg, ghInst, IDS_CIINVALIDFILE, lpszFile, MB_OK);
            break;

        default:
            ErrorWithFile(hDlg, ghInst, IDS_CIFILEOPENFAIL, lpszFile, MB_OK);
            break;
    }
}

#define chSpace        TEXT(' ')
#define chPeriod       TEXT('.')
#define PARSE_EMPTYSTRING	-1
#define PARSE_INVALIDDRIVE	-2
#define PARSE_INVALIDPERIOD	-3
#define PARSE_INVALIDDIRCHAR	-4
#define PARSE_INVALIDCHAR	-5
#define PARSE_WILDCARDINDIR	-6
#define PARSE_INVALIDNETPATH	-7
#define PARSE_INVALIDSPACE	-8
#define PARSE_EXTENTIONTOOLONG	-9
#define PARSE_DIRECTORYNAME	-10
#define PARSE_FILETOOLONG	-11

/*---------------------------------------------------------------------------
 * ParseFile
 * Purpose:  Determine if the filename is a legal DOS name
 * Input:    Long pointer to a SINGLE file name
 *           Circumstance checked:
 *           1) Valid as directory name, but not as file name
 *           2) Empty String
 *           3) Illegal Drive label
 *           4) Period in invalid location (in extention, 1st in file name)
 *           5) Missing directory character
 *           6) Illegal character
 *           7) Wildcard in directory name
 *           8) Double slash beyond 1st 2 characters
 *           9) Space character in the middle of the name (trailing spaces OK)
 *          10) Filename greater than 8 characters
 *          11) Extention greater than 3 characters
 * Notes:
 *   Filename length is NOT checked.
 *   Valid filenames will have leading spaces, trailing spaces and
 *     terminating period stripped in place.
 *
 * Returns:  If valid, LOWORD is byte offset to filename
 *                     HIWORD is byte offset to extention
 *                            if string ends with period, 0
 *                            if no extention is given, string length
 *           If invalid, LOWORD is error code suggesting problem (< 0)
 *                       HIWORD is approximate offset where problem found
 *                       Note that this may be beyond the offending character
 *--------------------------------------------------------------------------*/

static long ParseFile(LPTSTR lpstrFileName)
{
  short nFile, nExt, nFileOffset, nExtOffset;
  BOOL bExt;
  BOOL bWildcard;
  short nNetwork = 0;
  BOOL  bUNCPath = FALSE;
  LPTSTR lpstr = lpstrFileName;

/* Strip off initial white space.  Note that TAB is not checked */
/* because it cannot be received out of a standard edit control */
/* 30 January 1991  clarkc                                      */
  while (*lpstr == chSpace)
      lpstr++;

  if (!*lpstr)
    {
      nFileOffset = PARSE_EMPTYSTRING;
      goto FAILURE;
    }

  if (lpstr != lpstrFileName)
    {
      lstrcpy(lpstrFileName, lpstr);
      lpstr = lpstrFileName;
    }

  if (

#ifdef WIN32
      *CharNext(lpstr)
#else
      *AnsiNext(lpstr)
#endif
      == TEXT(':')
     )

    {
      TCHAR cDrive = (*lpstr | (BYTE) 0x20);  /* make lowercase */

/* This does not test if the drive exists, only if it's legal */
      if ((cDrive < TEXT('a')) || (cDrive > TEXT('z')))
        {
          nFileOffset = PARSE_INVALIDDRIVE;
          goto FAILURE;
        }
#ifdef WIN32
      lpstr = CharNext(CharNext(lpstr));
#else
      lpstr = AnsiNext(AnsiNext(lpstr));
#endif
    }

  if ((*lpstr == TEXT('\\')) || (*lpstr == TEXT('/')))
    {
      if (*++lpstr == chPeriod)               /* cannot have c:\. */
        {
          if ((*++lpstr != TEXT('\\')) && (*lpstr != TEXT('/')))   
            {
              if (!*lpstr)        /* it's the root directory */
                  goto MustBeDir;

              nFileOffset = PARSE_INVALIDPERIOD;
              goto FAILURE;
            }
          else
              ++lpstr;   /* it's saying top directory (again), thus allowed */
        }
      else if ((*lpstr == TEXT('\\')) && (*(lpstr-1) == TEXT('\\')))
        {
/* It seems that for a full network path, whether a drive is declared or
 * not is insignificant, though if a drive is given, it must be valid
 * (hence the code above should remain there).
 * 13 February 1991           clarkc
 */
          ++lpstr;            /* ...since it's the first slash, 2 are allowed */
          nNetwork = -1;      /* Must receive server and share to be real     */
          bUNCPath = TRUE;    /* No wildcards allowed if UNC name             */
        }
      else if (*lpstr == TEXT('/'))
        {
          nFileOffset = PARSE_INVALIDDIRCHAR;
          goto FAILURE;
        }
    }
  else if (*lpstr == chPeriod)
    {
      if (*++lpstr == chPeriod)  /* Is this up one directory? */
          ++lpstr;
      if (!*lpstr)
          goto MustBeDir;
      if ((*lpstr != TEXT('\\')) && (*lpstr != TEXT('/')))
        {
          nFileOffset = PARSE_INVALIDPERIOD;
          goto FAILURE;
        }
      else
          ++lpstr;   /* it's saying directory, thus allowed */
    }

  if (!*lpstr)
    {
      goto MustBeDir;
    }

/* Should point to first char in 8.3 filename by now */
  nFileOffset = nExtOffset = nFile = nExt = 0;
  bWildcard = bExt = FALSE;
  while (*lpstr)
    {
/*
 *  The next comparison MUST be unsigned to allow for extended characters!
 *  21 Feb 1991   clarkc
 */
      if (*lpstr < chSpace)
        {
          nFileOffset = PARSE_INVALIDCHAR;
          goto FAILURE;
        }
      switch (*lpstr)
        {
          case TEXT('"'):             /* All invalid */
          case TEXT('+'):
          case TEXT(','):
          case TEXT(':'):
          case TEXT(';'):
          case TEXT('<'):
          case TEXT('='):
          case TEXT('>'):
          case TEXT('['):
          case TEXT(']'):
          case TEXT('|'):
            {
              nFileOffset = PARSE_INVALIDCHAR;
              goto FAILURE;
            }

          case TEXT('\\'):      /* Subdirectory indicators */
          case TEXT('/'):
            nNetwork++;
            if (bWildcard)
              {
                nFileOffset = PARSE_WILDCARDINDIR;
                goto FAILURE;
              }

            else if (nFile == 0)        /* can't have 2 in a row */
              {
                nFileOffset = PARSE_INVALIDDIRCHAR;
                goto FAILURE;
              }
            else
              {                         /* reset flags */
                ++lpstr;
                if (!nNetwork && !*lpstr)
                  {
                    nFileOffset = PARSE_INVALIDNETPATH;
                    goto FAILURE;
                  }
                nFile = nExt = 0;
                bExt = FALSE;
              }
            break;

          case chSpace:
            {
              LPTSTR lpSpace = lpstr;

              *lpSpace = TEXT('\0');
              while (*++lpSpace)
                {
                  if (*lpSpace != chSpace)
                    {
                      *lpstr = chSpace;        /* Reset string, abandon ship */
                      nFileOffset = PARSE_INVALIDSPACE;
                      goto FAILURE;
                    }
                }
            }
            break;

          case chPeriod:
            if (nFile == 0)
              {
                if (*++lpstr == chPeriod)
                    ++lpstr;
                if (!*lpstr)
                    goto MustBeDir;

                if ((*lpstr != TEXT('\\')) && (*lpstr != TEXT('/')))
                  {
                    nFileOffset = PARSE_INVALIDPERIOD;
                    goto FAILURE;
                  }

                ++lpstr;              /* Flags are already set */
              }
            else if (bExt)
              {
                nFileOffset = PARSE_INVALIDPERIOD;  /* can't have one in ext */
                goto FAILURE;
              }
            else
              {
                nExtOffset = 0;
                ++lpstr;
                bExt = TRUE;
              }
            break;

          case TEXT('*'):
          case TEXT('?'):
            if (bUNCPath)
              {
                nFileOffset = PARSE_INVALIDNETPATH;
                goto FAILURE;
              }
            bWildcard = TRUE;
/* Fall through to normal character processing */

          default:
            if (bExt)
              {
                if (++nExt == 1)
                    nExtOffset = lpstr - lpstrFileName;
                else if (nExt > 3)
                  {
                    nFileOffset = PARSE_EXTENTIONTOOLONG;
                    goto FAILURE;
                  }
                if ((nNetwork == -1) && (nFile + nExt > 11))
                  {
                    nFileOffset = PARSE_INVALIDNETPATH;
                    goto FAILURE;
                  }
              }
            else if (++nFile == 1)
                nFileOffset = lpstr - lpstrFileName;
            else if (nFile > 8)
              {
                /* If it's a server name, it can have 11 characters */
                if (nNetwork != -1)
                  {
                    nFileOffset = PARSE_FILETOOLONG;
                    goto FAILURE;
                  }
                else if (nFile > 11)
                  {
                    nFileOffset = PARSE_INVALIDNETPATH;
                    goto FAILURE;
                  }
              }

#ifdef WIN32
            lpstr = CharNext(lpstr);
#else
            lpstr = AnsiNext(lpstr);
#endif
            break;
        }
    }

/* Did we start with a double backslash but not have any more slashes? */
  if (nNetwork == -1)
    {
      nFileOffset = PARSE_INVALIDNETPATH;
      goto FAILURE;
    }

  if (!nFile)
    {
MustBeDir:
      nFileOffset = PARSE_DIRECTORYNAME;
      goto FAILURE;
    }

  if ((*(lpstr - 1) == chPeriod) &&          /* if true, no extention wanted */
              (
#ifdef WIN32
              *CharNext(lpstr-2)
#else
              *AnsiNext(lpstr-2)
#endif
               == chPeriod
              ))
      *(lpstr - 1) = TEXT('\0');               /* Remove terminating period   */
  else if (!nExt)
FAILURE:
      nExtOffset = lpstr - lpstrFileName;

  return(MAKELONG(nFileOffset, nExtOffset));
}


/*
 * DoesFileExist
 *
 * Purpose:
 *  Determines if a file path exists
 *
 * Parameters:
 *  lpszFile        LPTSTR - file name
 *  lpOpenBuf       OFSTRUCT FAR* - points to the OFSTRUCT structure that
 *                      will receive information about the file when the
 *                      file is first opened. this field is filled by the
 *                      Windows OpenFile API.
 *
 * Return Value:
 *  HFILE   HFILE_ERROR - file does NOT exist
 *          file handle (as returned from OpenFile) - file exists
 */
HFILE WINAPI DoesFileExist(LPTSTR lpszFile, OFSTRUCT FAR* lpOpenBuf)
{
    long        nRet;
    int         i;
    static TCHAR *arrIllegalNames[] = {
        TEXT("LPT1"),
        TEXT("LPT2"),
        TEXT("LPT3"),
        TEXT("COM1"),
        TEXT("COM2"),
        TEXT("COM3"),
        TEXT("COM4"),
        TEXT("CON"),
        TEXT("AUX"),
        TEXT("PRN")
    };

    // Check if file name is syntactically correct.
    //   (OpenFile sometimes crashes if path is not syntactically correct)
    nRet = ParseFile(lpszFile);
    if (LOWORD(nRet) < 0)
        goto error;

    // Check is the name is an illegal name (eg. the name of a device)
    for (i=0; i < (sizeof(arrIllegalNames)/sizeof(arrIllegalNames[0])); i++) {
        if (lstrcmpi(lpszFile, arrIllegalNames[i])==0)
            goto error; // illegal name FOUND
    }

    return OpenFile(lpszFile, lpOpenBuf, OF_EXIST);

error:
    _fmemset(lpOpenBuf, 0, sizeof(OFSTRUCT));
    lpOpenBuf->nErrCode = 0x0002;   // File not found
    return HFILE_ERROR;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\letest\ole2ui\template.c ===
/*
 * TEMPLATE.C
 *
 * Copyright (c)1992 Microsoft Corporation, All Right Reserved
 *
 *
 * CUSTOMIZATION INSTRUCTIONS:
 *
 *  1.  Replace <FILE> with the uppercased filename for this file.
 *      Lowercase the <FILE>.h entry
 *
 *  2.  Replace <NAME> with the mixed case dialog name in one word,
 *      such as InsertObject
 *
 *  3.  Replace <FULLNAME> with the mixed case dialog name in multiple
 *      words, such as Insert Object
 *
 *  4.  Replace <ABBREV> with the suffix for pointer variables, such
 *      as the IO in InsertObject's pIO or the CI in ChangeIcon's pCI.
 *      Check the alignment of the first variable declaration in the
 *      Dialog Proc after this.  I will probably be misaligned with the
 *      rest of the variables.
 *
 *  5.  Replace <STRUCT> with the uppercase structure name for this
 *      dialog sans OLEUI, such as INSERTOBJECT.  Changes OLEUI<STRUCT>
 *      in most cases, but we also use this for IDD_<STRUCT> as the
 *      standard template resource ID.
 *
 *  6.  Find <UFILL> fields and fill them out with whatever is appropriate.
 *
 *  7.  Delete this header up to the start of the next comment.
 */


/*
 * <FILE>.C
 *
 * Implements the OleUI<NAME> function which invokes the complete
 * <FULLNAME> dialog.
 *
 * Copyright (c)1992 Microsoft Corporation, All Right Reserved
 */

#define STRICT  1
#include "ole2ui.h"
#include "common.h"

#ifndef WIN32
#include "<FILE>.h"
#else
   #include "template.h"
#endif




/*
 * OleUI<NAME>
 *
 * Purpose:
 *  Invokes the standard OLE <FULLNAME> dialog box allowing the user
 *  to <UFILL>
 *
 * Parameters:
 *  lp<ABBREV>            LPOLEUI<NAME> pointing to the in-out structure
 *                  for this dialog.
 *
 * Return Value:
 *  UINT            One of the following codes, indicating success or error:
 *                      OLEUI_SUCCESS           Success
 *                      OLEUI_ERR_STRUCTSIZE    The dwStructSize value is wrong
 */

STDAPI_(UINT) OleUI<NAME>(LPOLEUI<STRUCT> lp<ABBREV>)
    {
    UINT        uRet;
    HGLOBAL     hMemDlg=NULL;

    uRet=UStandardValidation((LPOLEUISTANDARD)lp<ABBREV>, sizeof(OLEUI<STRUCT>)
                             , &hMemDlg);

    if (OLEUI_SUCCESS!=uRet)
        return uRet;

    /*
     * PERFORM ANY STRUCTURE-SPECIFIC VALIDATION HERE!
     * ON FAILURE:
     *  {
     *  if (NULL!=hMemDlg)
     *      FreeResource(hMemDlg)
     *
     *  return OLEUI_<ABBREV>ERR_<ERROR>
     *  }
     */

    //Now that we've validated everything, we can invoke the dialog.
    uRet=UStandardInvocation(<NAME>DialogProc, (LPOLEUISTANDARD)lp<ABBREV>
                             , hMemDlg, MAKEINTRESOURCE(IDD_<STRUCT>));

    /*
     * IF YOU ARE CREATING ANYTHING BASED ON THE RESULTS, DO IT HERE.
     */
    <UFILL>

    return uRet;
    }





/*
 * <NAME>DialogProc
 *
 * Purpose:
 *  Implements the OLE <FULLNAME> dialog as invoked through the
 *  OleUI<NAME> function.
 *
 * Parameters:
 *  Standard
 *
 * Return Value:
 *  Standard
 */

BOOL CALLBACK EXPORT <NAME>DialogProc(HWND hDlg, UINT iMsg, WPARAM wParam, LPARAM lParam)
    {
    P<STRUCT>               p<ABBREV>;
    BOOL                    fHook=FALSE;

    //Declare Win16/Win32 compatible WM_COMMAND parameters.
    COMMANDPARAMS(wID, wCode, hWndMsg);

    //This will fail under WM_INITDIALOG, where we allocate it.
    p<ABBREV>=(<STRUCT>)PvStandardEntry(hDlg, iMsg, wParam, lParam, &uHook);

    //If the hook processed the message, we're done.
    if (0!=uHook)
        return (BOOL)uHook;

    //Process the temination message
    if (iMsg==uMsgEndDialog)
        {
        //Free any specific allocations before calling StandardCleanup
        StandardCleanup((PVOID)p<ABBREV>, hDlg);
        EndDialog(hDlg, wParam);
        return TRUE;
        }

    switch (iMsg)
        {
        case WM_INITDIALOG:
            F<NAME>Init(hDlg, wParam, lParam);
            return TRUE;


        case WM_COMMAND:
            switch (wID)
                {
                case IDOK:
                    /*
                     * PERFORM WHATEVER FUNCTIONS ARE DEFAULT HERE.
                     */
                    SendMessage(hDlg, uMsgEndDialog, OLEUI_OK, 0L);
                    break;

                case IDCANCEL:
                    /*
                     * PERFORM ANY UNDOs HERE, BUT NOT CLEANUP THAT WILL
                     * ALWAYS HAPPEN WHICH SHOULD BE IN uMsgEndDialog.
                     */
                    SendMessage(hDlg, uMsgEndDialog, OLEUI_CANCEL, 0L);
                    break;

                case ID_OLEUIHELP:
                    PostMessage(p<ABBREV>->lpO<ABBREV>->hWndOwner, uMsgHelp
                                , (WPARAM)hDlg, MAKELPARAM(IDD_<STRUCT>, 0));
                    break;
                }
            break;
        }
    return FALSE;
    }




/*
 * F<NAME>Init
 *
 * Purpose:
 *  WM_INITIDIALOG handler for the <FULLNAME> dialog box.
 *
 * Parameters:
 *  hDlg            HWND of the dialog
 *  wParam          WPARAM of the message
 *  lParam          LPARAM of the message
 *
 * Return Value:
 *  BOOL            Value to return for WM_INITDIALOG.
 */

BOOL F<NAME>Init(HWND hDlg, WPARAM wParam, LPARAM lParam)
    {
    P<STRUCT>               p<ABBREV>;
    LPOLEUI<STRUCT>         lpO<ABBREV>;
    HFONT                   hFont;

    //1.  Copy the structure at lParam into our instance memory.
    p<ABBREV>=(PSTRUCT)PvStandardInit(hDlg, sizeof(<STRUCT>), TRUE, &hFont);

    //PvStandardInit send a termination to us already.
    if (NULL==p<ABBREV>)
        return FALSE;

    lpO<ABBREV>=(LPOLEUI<STRUCT>)lParam);

    p<ABBREV>->lpO<ABBREV>=lpO<ABBREV>;

    //Copy other information from lpO<ABBREV> that we might modify.
    <UFILL>

    //2.  If we got a font, send it to the necessary controls.
    if (NULL!=hFont)
        {
        //Do this for as many controls as you need it for.
        SendDlgItemMessage(hDlg, ID_<UFILL>, WM_SETFONT, (WPARAM)hFont, 0L);
        }


    //3.  Show or hide the help button
    if (!(p<ABBREV>->lpO<ABBREV>->dwFlags & <ABBREV>F_SHOWHELP))
        StandardShowDlgItem(hDlg, ID_OLEUIHELP, SW_HIDE);

    /*
     * PERFORM OTHER INITIALIZATION HERE.  ON ANY LoadString
     * FAILURE POST OLEUI_MSG_ENDDIALOG WITH OLEUI_ERR_LOADSTRING.
     */

    //n.  Call the hook with lCustData in lParam
    UStandardHook((PVOID)p<ABBREV>, hDlg, WM_INITDIALOG, wParam, lpO<ABBREV>->lCustData);
    return TRUE;
    }

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\letest\ole2ui\verlocal.h ===
/*
 * VERLOCAL.H
 *
 * Version resource file for the OLE 2.0 UI Support DLL.
 *
 * Copyright (c)1993 Microsoft Corporation, All Rights Reserved.
 *
 * This file contains the text that needs to be translated in the version
 * resource.  All of the following variables must be localized:
 *
 * wLanguage
 * szTranslation
 * szzCompanyName
 * szzProductName
 * szzLegalCopyright
 */

/* wLanguage comes from the table of "langID" values on page 218 of
   the Windows 3.1 SDK Programmer's Reference, Volume 4: Resources.
   This page is in Chapter 13, "Resource-Definition Statements", in the
   description of the "VERSIONINFO" statment.

   For example, 
   0x0407  German
   0x0409  U.S. English
   0x0809  U.K. English
   0x040C  French
   0x040A  Castilian Spanish
*/
#define wLanguage 0x0409           /* U.S. English */

/* The first 4 characters of szTranslation must be the same as wLanguage,
   without the "0x".  The last 4 characters of szTranslation MUST be
   04E4.  Note that any alphabetic characters in szTranslation must
   be capitalized. */
#define szTranslation "040904E4"   /* U.S. English */


/* The following szz strings must all end with the two characters "\0" */
/* Note that the "\251" in szzLegalCopyright stands for the "circle c"
   copyright symbol, and it should be left as \251 rather than
   substituting the actual ANSI copyright character in the string. */
#define szzCompanyName     "Microsoft Corporation\0"
#define szzFileDescription "Microsoft Windows(TM) OLE 2.0 User Interface Support\0"
#define szzLegalCopyright  "Copyright \251 1992-1993 Microsoft Corp.  All rights reserved.\0"

#ifdef PUBLISHER
#define szzProductName "Microsoft Publisher for Windows 2.0\0"
#else
#define szzProductName szzFileDescription
#endif


/* DO NOT CHANGE ANY LINES BELOW THIS POINT */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\letest\outline\classfac.c ===
/*************************************************************************
**
**    OLE 2 Sample Code
**
**    classfac.c
**
**    This file contains the implementation for IClassFactory for both the
**    server and the client version of the OUTLINE app.
**
**    (c) Copyright Microsoft Corp. 1992 - 1993 All Rights Reserved
**
*************************************************************************/

#include "outline.h"

OLEDBGDATA

extern LPOUTLINEAPP             g_lpApp;


/* OLE2NOTE: this object illustrates the manner in which to statically
**    (compile-time) initialize an interface VTBL.
*/
static IClassFactoryVtbl g_AppClassFactoryVtbl = {
	AppClassFactory_QueryInterface,
	AppClassFactory_AddRef,
	AppClassFactory_Release,
	AppClassFactory_CreateInstance,
	AppClassFactory_LockServer
};


/* AppClassFactory_Create
** ----------------------
**    create an instance of APPCLASSFACTORY.
**    NOTE: type of pointer returned is an IClassFactory* interface ptr.
**          the returned pointer can be directly passed to
**          CoRegisterClassObject and released later by calling the
**          Release method of the interface.
*/
LPCLASSFACTORY WINAPI AppClassFactory_Create(void)
{
	LPAPPCLASSFACTORY lpAppClassFactory;
	LPMALLOC lpMalloc;

	if (CoGetMalloc(MEMCTX_TASK, (LPMALLOC FAR*)&lpMalloc) != NOERROR)
		return NULL;

	lpAppClassFactory = (LPAPPCLASSFACTORY)lpMalloc->lpVtbl->Alloc(
			lpMalloc, (sizeof(APPCLASSFACTORY)));
	lpMalloc->lpVtbl->Release(lpMalloc);
	if (! lpAppClassFactory) return NULL;

	lpAppClassFactory->m_lpVtbl = &g_AppClassFactoryVtbl;
	lpAppClassFactory->m_cRef   = 1;
#if defined( _DEBUG )
	lpAppClassFactory->m_cSvrLock = 0;
#endif
	return (LPCLASSFACTORY)lpAppClassFactory;
}


/*************************************************************************
** OleApp::IClassFactory interface implementation
*************************************************************************/

STDMETHODIMP AppClassFactory_QueryInterface(
		LPCLASSFACTORY lpThis, REFIID riid, LPVOID FAR* ppvObj)
{
	LPAPPCLASSFACTORY lpAppClassFactory = (LPAPPCLASSFACTORY)lpThis;
	SCODE scode;

	// Two interfaces supported: IUnknown, IClassFactory

	if (IsEqualIID(riid, &IID_IClassFactory) ||
			IsEqualIID(riid, &IID_IUnknown)) {
		lpAppClassFactory->m_cRef++;   // A pointer to this object is returned
		*ppvObj = lpThis;
		scode = S_OK;
	}
	else {                 // unsupported interface
		*ppvObj = NULL;
		scode = E_NOINTERFACE;
	}

	return ResultFromScode(scode);
}


STDMETHODIMP_(ULONG) AppClassFactory_AddRef(LPCLASSFACTORY lpThis)
{
	LPAPPCLASSFACTORY lpAppClassFactory = (LPAPPCLASSFACTORY)lpThis;
	return ++lpAppClassFactory->m_cRef;
}

STDMETHODIMP_(ULONG) AppClassFactory_Release(LPCLASSFACTORY lpThis)
{
	LPAPPCLASSFACTORY lpAppClassFactory = (LPAPPCLASSFACTORY)lpThis;
	LPMALLOC lpMalloc;

	if (--lpAppClassFactory->m_cRef != 0) // Still used by others
		return lpAppClassFactory->m_cRef;

	// Free storage
	if (CoGetMalloc(MEMCTX_TASK, (LPMALLOC FAR*)&lpMalloc) != NOERROR)
		return 0;

	lpMalloc->lpVtbl->Free(lpMalloc, lpAppClassFactory);
	lpMalloc->lpVtbl->Release(lpMalloc);
	return 0;
}


STDMETHODIMP AppClassFactory_CreateInstance (
		LPCLASSFACTORY      lpThis,
		LPUNKNOWN           lpUnkOuter,
		REFIID              riid,
		LPVOID FAR*         lplpvObj
)
{
	LPOUTLINEAPP    lpOutlineApp = (LPOUTLINEAPP)g_lpApp;
	LPOLEDOC        lpOleDoc;
	HRESULT         hrErr;

	OLEDBG_BEGIN2("AppClassFactory_CreateInstance\r\n")

	/* OLE2NOTE: we must make sure to set all out parameters to NULL. */
	*lplpvObj = NULL;

	/*********************************************************************
	** OLE2NOTE: this is an SDI app; it can only create and support one
	**    instance. After the instance is created, the OLE libraries
	**    should not call CreateInstance again. it is a good practise
	**    to specifically guard against this.
	*********************************************************************/

	if (lpOutlineApp->m_lpDoc != NULL)
		return ResultFromScode(E_UNEXPECTED);

	/* OLE2NOTE: create a new document instance. by the time we return
	**    from this method the document's refcnt must be 1.
	*/
	lpOutlineApp->m_lpDoc = OutlineApp_CreateDoc(lpOutlineApp, FALSE);
	lpOleDoc = (LPOLEDOC)lpOutlineApp->m_lpDoc;
	if (! lpOleDoc) {
		OLEDBG_END2
		return ResultFromScode(E_OUTOFMEMORY);
	}

	/* OLE2NOTE: retrieve pointer to requested interface. the ref cnt
	**    of the object after OutlineApp_CreateDoc is 0. this call to
	**    QueryInterface will increment the refcnt to 1. the object
	**    returned from IClassFactory::CreateInstance should have a
	**    refcnt of 1 and be controlled by the caller. If the caller
	**    releases the document, the document should be destroyed.
	*/
	hrErr = OleDoc_QueryInterface(lpOleDoc, riid, lplpvObj);

	OLEDBG_END2
	return hrErr;
}


STDMETHODIMP AppClassFactory_LockServer (
		LPCLASSFACTORY      lpThis,
		BOOL                fLock
)
{
	LPAPPCLASSFACTORY lpAppClassFactory = (LPAPPCLASSFACTORY)lpThis;
	LPOLEAPP lpOleApp = (LPOLEAPP)g_lpApp;
	HRESULT hrErr;
	OLEDBG_BEGIN2("AppClassFactory_LockServer\r\n")

#if defined( _DEBUG )
	if (fLock) {
		++lpAppClassFactory->m_cSvrLock;
		OleDbgOutRefCnt3(
				"AppClassFactory_LockServer: cLock++\r\n",
				lpAppClassFactory, lpAppClassFactory->m_cSvrLock);
	} else {

		/* OLE2NOTE: when there are no open documents and the app is not
		**    under the control of the user and there are no outstanding
		**    locks on the app, then revoke our ClassFactory to enable the
		**    app to shut down.
		*/
		--lpAppClassFactory->m_cSvrLock;
		OleDbgAssertSz (lpAppClassFactory->m_cSvrLock >= 0,
				"AppClassFactory_LockServer(FALSE) called with cLock == 0"
		);

		if (lpAppClassFactory->m_cSvrLock == 0) {
			OleDbgOutRefCnt2(
					"AppClassFactory_LockServer: UNLOCKED\r\n",
					lpAppClassFactory, lpAppClassFactory->m_cSvrLock);
		} else {
			OleDbgOutRefCnt3(
					"AppClassFactory_LockServer: cLock--\r\n",
					lpAppClassFactory, lpAppClassFactory->m_cSvrLock);
		}
	}
#endif  // _DEBUG
	/* OLE2NOTE: in order to hold the application alive we call
	**    CoLockObjectExternal to add a strong reference to our app
	**    object. this will keep the app alive when all other external
	**    references release us. if the user issues File.Exit the
	**    application will shut down in any case ignoring any
	**    outstanding LockServer locks because CoDisconnectObject is
	**    called in OleApp_CloseAllDocsAndExitCommand. this will
	**    forceably break any existing strong reference counts
	**    including counts that we add ourselves by calling
	**    CoLockObjectExternal and guarantee that the App object gets
	**    its final release (ie. cRefs goes to 0).
	*/
	hrErr = OleApp_Lock(lpOleApp, fLock, TRUE /* fLastUnlockReleases */);

	OLEDBG_END2
	return hrErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\letest\outline\classfac.h ===
/*************************************************************************
**
**    OLE 2 Sample Code
**
**    classfac.c
**
**    This file contains the implementation for IClassFactory for both the
**    server and the client version of the OUTLINE app.
**
**    (c) Copyright Microsoft Corp. 1992 - 1993 All Rights Reserved
**
*************************************************************************/

#include "outline.h"

OLEDBGDATA

extern LPOUTLINEAPP             g_lpApp;


/* OLE2NOTE: this object illustrates the manner in which to statically
**    (compile-time) initialize an interface VTBL.
*/
static IClassFactoryVtbl g_AppClassFactoryVtbl = {
	AppClassFactory_QueryInterface,
	AppClassFactory_AddRef,
	AppClassFactory_Release,
	AppClassFactory_CreateInstance,
	AppClassFactory_LockServer
};


/* AppClassFactory_Create
** ----------------------
**    create an instance of APPCLASSFACTORY.
**    NOTE: type of pointer returned is an IClassFactory* interface ptr.
**          the returned pointer can be directly passed to
**          CoRegisterClassObject and released later by calling the
**          Release method of the interface.
*/
LPCLASSFACTORY WINAPI AppClassFactory_Create(void)
{
	LPAPPCLASSFACTORY lpAppClassFactory;
	LPMALLOC lpMalloc;

	if (CoGetMalloc(MEMCTX_TASK, (LPMALLOC FAR*)&lpMalloc) != NOERROR)
		return NULL;

	lpAppClassFactory = (LPAPPCLASSFACTORY)lpMalloc->lpVtbl->Alloc(
			lpMalloc, (sizeof(APPCLASSFACTORY)));
	lpMalloc->lpVtbl->Release(lpMalloc);
	if (! lpAppClassFactory) return NULL;

	lpAppClassFactory->m_lpVtbl = &g_AppClassFactoryVtbl;
	lpAppClassFactory->m_cRef   = 1;
#if defined( _DEBUG )
	lpAppClassFactory->m_cSvrLock = 0;
#endif
	return (LPCLASSFACTORY)lpAppClassFactory;
}


/*************************************************************************
** OleApp::IClassFactory interface implementation
*************************************************************************/

STDMETHODIMP AppClassFactory_QueryInterface(
		LPCLASSFACTORY lpThis, REFIID riid, LPVOID FAR* ppvObj)
{
	LPAPPCLASSFACTORY lpAppClassFactory = (LPAPPCLASSFACTORY)lpThis;
	SCODE scode;

	// Two interfaces supported: IUnknown, IClassFactory

	if (IsEqualIID(riid, &IID_IClassFactory) ||
			IsEqualIID(riid, &IID_IUnknown)) {
		lpAppClassFactory->m_cRef++;   // A pointer to this object is returned
		*ppvObj = lpThis;
		scode = S_OK;
	}
	else {                 // unsupported interface
		*ppvObj = NULL;
		scode = E_NOINTERFACE;
	}

	return ResultFromScode(scode);
}


STDMETHODIMP_(ULONG) AppClassFactory_AddRef(LPCLASSFACTORY lpThis)
{
	LPAPPCLASSFACTORY lpAppClassFactory = (LPAPPCLASSFACTORY)lpThis;
	return ++lpAppClassFactory->m_cRef;
}

STDMETHODIMP_(ULONG) AppClassFactory_Release(LPCLASSFACTORY lpThis)
{
	LPAPPCLASSFACTORY lpAppClassFactory = (LPAPPCLASSFACTORY)lpThis;
	LPMALLOC lpMalloc;

	if (--lpAppClassFactory->m_cRef != 0) // Still used by others
		return lpAppClassFactory->m_cRef;

	// Free storage
	if (CoGetMalloc(MEMCTX_TASK, (LPMALLOC FAR*)&lpMalloc) != NOERROR)
		return 0;

	lpMalloc->lpVtbl->Free(lpMalloc, lpAppClassFactory);
	lpMalloc->lpVtbl->Release(lpMalloc);
	return 0;
}


STDMETHODIMP AppClassFactory_CreateInstance (
		LPCLASSFACTORY      lpThis,
		LPUNKNOWN           lpUnkOuter,
		REFIID              riid,
		LPVOID FAR*         lplpvObj
)
{
	LPOUTLINEAPP    lpOutlineApp = (LPOUTLINEAPP)g_lpApp;
	LPOLEDOC        lpOleDoc;
	HRESULT         hrErr;

	OLEDBG_BEGIN2("AppClassFactory_CreateInstance\r\n")

	/* OLE2NOTE: we must make sure to set all out parameters to NULL. */
	*lplpvObj = NULL;

	/*********************************************************************
	** OLE2NOTE: this is an SDI app; it can only create and support one
	**    instance. After the instance is created, the OLE libraries
	**    should not call CreateInstance again. it is a good practise
	**    to specifically guard against this.
	*********************************************************************/

	if (lpOutlineApp->m_lpDoc != NULL)
		return ResultFromScode(E_UNEXPECTED);

	/* OLE2NOTE: create a new document instance. by the time we return
	**    from this method the document's refcnt must be 1.
	*/
	lpOutlineApp->m_lpDoc = OutlineApp_CreateDoc(lpOutlineApp, FALSE);
	lpOleDoc = (LPOLEDOC)lpOutlineApp->m_lpDoc;
	if (! lpOleDoc) {
		OLEDBG_END2
		return ResultFromScode(E_OUTOFMEMORY);
	}

	/* OLE2NOTE: retrieve pointer to requested interface. the ref cnt
	**    of the object after OutlineApp_CreateDoc is 0. this call to
	**    QueryInterface will increment the refcnt to 1. the object
	**    returned from IClassFactory::CreateInstance should have a
	**    refcnt of 1 and be controlled by the caller. If the caller
	**    releases the document, the document should be destroyed.
	*/
	hrErr = OleDoc_QueryInterface(lpOleDoc, riid, lplpvObj);

	OLEDBG_END2
	return hrErr;
}


STDMETHODIMP AppClassFactory_LockServer (
		LPCLASSFACTORY      lpThis,
		BOOL                fLock
)
{
	LPAPPCLASSFACTORY lpAppClassFactory = (LPAPPCLASSFACTORY)lpThis;
	LPOLEAPP lpOleApp = (LPOLEAPP)g_lpApp;
	HRESULT hrErr;
	OLEDBG_BEGIN2("AppClassFactory_LockServer\r\n")

#if defined( _DEBUG )
	if (fLock) {
		++lpAppClassFactory->m_cSvrLock;
		OleDbgOutRefCnt3(
				"AppClassFactory_LockServer: cLock++\r\n",
				lpAppClassFactory, lpAppClassFactory->m_cSvrLock);
	} else {

		/* OLE2NOTE: when there are no open documents and the app is not
		**    under the control of the user and there are no outstanding
		**    locks on the app, then revoke our ClassFactory to enable the
		**    app to shut down.
		*/
		--lpAppClassFactory->m_cSvrLock;
		OleDbgAssertSz (lpAppClassFactory->m_cSvrLock >= 0,
				"AppClassFactory_LockServer(FALSE) called with cLock == 0"
		);

		if (lpAppClassFactory->m_cSvrLock == 0) {
			OleDbgOutRefCnt2(
					"AppClassFactory_LockServer: UNLOCKED\r\n",
					lpAppClassFactory, lpAppClassFactory->m_cSvrLock);
		} else {
			OleDbgOutRefCnt3(
					"AppClassFactory_LockServer: cLock--\r\n",
					lpAppClassFactory, lpAppClassFactory->m_cSvrLock);
		}
	}
#endif  // _DEBUG
	/* OLE2NOTE: in order to hold the application alive we call
	**    CoLockObjectExternal to add a strong reference to our app
	**    object. this will keep the app alive when all other external
	**    references release us. if the user issues File.Exit the
	**    application will shut down in any case ignoring any
	**    outstanding LockServer locks because CoDisconnectObject is
	**    called in OleApp_CloseAllDocsAndExitCommand. this will
	**    forceably break any existing strong reference counts
	**    including counts that we add ourselves by calling
	**    CoLockObjectExternal and guarantee that the App object gets
	**    its final release (ie. cRefs goes to 0).
	*/
	hrErr = OleApp_Lock(lpOleApp, fLock, TRUE /* fLastUnlockReleases */);

	OLEDBG_END2
	return hrErr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\letest\ole2ui\wn_dos.h ===
/*************************************************************************
**
**    OLE 2.0 Property Set Utilities
**
**    wn_dos.h
**
**    This file contains file contains data structure defintions,
**    function prototypes, constants, etc. for Windows 3.x form of 
**    DOS calls. This is used by the SUMINFO OLE 2.0 Property Set
**    utilities used to manage the Summary Info property set.
**
**    (c) Copyright Microsoft Corp. 1990 - 1992 All Rights Reserved
**
*************************************************************************/

#ifndef WN_DOS_H
#define WN_DOS_H

#include <dos.h>

#define WIN 1

#define cbMaxFile 146 //from inc\path.h
#define SEEK_FROM_BEGINNING 0
#define SEEK_FROM_END 2
#define chDOSPath ('\\')		// FUTURE: not used all places it could be
#define chDOSWildAll    '*'  	/* DOS File name wild card. */
#define chDOSWildSingle '?'



// Close, seek, delete, rename, flush, get attributes, read, write
/* RPC TEMP
int  FCloseOsfnWin(WORD);
#define FCloseOsfn(osfn)	FCloseOsfnWin(osfn)
long DwSeekDwWin(WORD,LONG,WORD);
#define DwSeekDw(osfn, dwSeek, bSeekFrom)	DwSeekDwWin(osfn, dwSeek, bSeekFrom)	
EC  EcDeleteSzFfnameWin(char *);
#define EcDeleteSzFfname(szFile) EcDeleteSzFfnameWin(szFile) 
EC  EcRenameSzFfnameWin(char *,char *);
#define EcRenameSzFfname(szFileCur,szFileNew) EcRenameSzFfnameWin(szFileCur,szFileNew)
int FFlushOsfnWin(int);
#define FFlushOsfn(osfn)	FFlushOsfnWin(osfn)
WORD DaGetFileModeSzWin(char *);
#define DaGetFileModeSz(szFile)	DaGetFileModeSzWin(szFile)
int  CbReadOsfnWin(int, void far *, UINT);
int  CbWriteOsfnWin(int, void far *, UINT);
#define CbWriteOsfn(osfn,lpch,cbWrite)	CbWriteOsfnWin(osfn,lpch,cbWrite)
*/
#define WinOpenFile(sz,ofs,n)	OpenFile(sz,ofs,n)
#define SeekHfile(f,off,kind) _llseek(f,off,kind)
#define CbReadOsfn(osfn,lpch,cbRead)	CbReadOsfnWin(osfn,lpch,cbRead)
#define CbReadHfile(f,buf,n) _lread(f,buf,n)
#define CbReadOsfnWin(f,buf,n) CbReadHfile(f,buf,n)
#define EcFindFirst4dm(a,b,c) _dos_findfirst((const char *)(b),c,(struct find_t*)a)
#define EcFindNext4dm(a) _dos_findnext((struct find_t*)a)
#define FHfileToSffsDate(handle,date,time) _dos_getftime(handle, (unsigned *)(date), (unsigned *)(time))
#define SeekHfile(f, off, kind) _llseek(f,off,kind)

/* buffer structure to be used with EcFindFirst() and EcFindNext() */
typedef struct _SFFS
	{ /* Search Find File Structure */
	uchar buff[21];	// dos search info
	uchar wAttr;
	union 
		{
		unsigned short timeVariable;    /*RPC47*/
		BF time:16;
		struct 
			{
			BF sec : 5;
			BF mint: 6;
			BF hr  : 5;
			};
		};
	union 
		{
		unsigned short dateVariable;
		BF date:16;
		struct 
			{
			BF dom : 5;
			BF mon : 4;
			BF yr  : 7;
			};
		};
	ulong cbFile;
	uchar szFileName[13];
	} SFFS;

// find first file/find next file
#define PszFromPsffs(psffs)		((psffs)->szFileName)
#define CopySzFilePsffs(psffs,sz)	OemToAnsi((char HUGE *)&((psffs)->szFileName[0]),(char HUGE *)(sz))
#define CbSzFilePsffs(psffs)	CbSz((psffs)->szFileName)
#define CbFileSizePsffs(psffs)	(psffs)->cbFile
#define AttribPsffs(psffs)		(psffs)->wAttr
#define EcFindFirstCore(psffs, sz, wAttr) EcFindFirst(psffs, sz, wAttr)   /*RPC22*/
#define FDotPsffs(psffs) ((psffs)->szFileName[0]=='.')   /*RPC23*/
#define AppendSzWild(sz) {int i=_fstrlen((char FAR *)(sz)); sz[i]='*'; sz[i+1]='.'; sz[i+2]='*'; sz[i+3]='\0';}
// disk free space

unsigned long LcbDiskFreeSpaceWin(int);
#define LcbDiskFreeSpace(chDrive) LcbDiskFreeSpaceWin(chDrive)

// date and time    /*RPC39*/
/*
typedef struct _TIM {                    // Time structure returned by OsTime 
	CHAR minutes, hour, hsec, sec;
	} TIM;

typedef struct _DAT {                    // Date structure returned by OsDate 
	int  year;
	CHAR month, day, dayOfWeek;
	} DAT;
*/
#define TIM dostime_t    /*RPC39*/
#define DAT dosdate_t	
#define OsTimeWin(TIM) _dos_gettime(TIM)
#define OsDateWin(DAT) _dos_getdate(DAT)		


/* DOS File Attributes */
#define DA_NORMAL       0x00
#define DA_READONLY     0x01
#define DA_HIDDEN       0x02
#define DA_SYSTEM       0x04
#define DA_VOLUME       0x08
#define DA_SUBDIR       0x10
#define DA_ARCHIVE      0x20
#define DA_NIL          0xFFFF  /* Error DA */
#define dosxSharing     32      /* Extended error code for sharing viol. */
#define nErrNoAcc       5       /* OpenFile error code for Access Denied */
#define nErrFnf         2       /* OpenFile error code for File Not Found */

/* Components of the Open mode for OpenSzFfname (DOS FUNC 3DH) */
#define MASK_fINH       0x80
#define MASK_bSHARE     0x70
#define MASK_bACCESS    0x07

#define bSHARE_DENYRDWR 0x10
#define bSHARE_DENYWR   0x20
#define bSHARE_DENYNONE 0x40

/* Seek-from type codes passed to DOS function 42H */

#define SF_BEGINNING    0       /* Seek from beginning of file */
#define SF_CURRENT      1       /* Seek from current file pointer */
#define SF_END          2       /* Seek from end of file */


typedef struct _DOSDTTM	/* DOS DaTe TiMe */
		{
		union
			{
			long lDOSDttm;
			struct
				{
				BF day:	5;
				BF month:	4;
				BF year:	7;
				BF sec:	5;
				BF mint:	6;
				BF hours:	5;
				} S1;
			} U1;
		} DOSDTTM;

int  FOsfnIsFile(int);

void DateStamp(int, LONG *,  int);
int  DosxError(void);
int  ShellExec(int, int);

#endif //WN_DOS_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\letest\outline\clipbrd.c ===
/*************************************************************************
**
**    OLE 2 Sample Code
**
**    clipbrd.c
**
**    This file contains the major interfaces, methods and related support
**    functions for implementing clipboard data transfer. The code
**    contained in this file is used by BOTH the Container and Server
**    (Object) versions of the Outline sample code.
**    (see file dragdrop.c for Drag/Drop support implementation)
**
**    OleDoc Object
**      exposed interfaces:
**          IDataObject
**
**    (c) Copyright Microsoft Corp. 1992 - 1993 All Rights Reserved
**
*************************************************************************/

#include "outline.h"

OLEDBGDATA

extern LPOUTLINEAPP             g_lpApp;

// REVIEW: should use string resource for messages
char ErrMsgPasting[] = "Could not paste data from clipboard!";
char ErrMsgBadFmt[] = "Invalid format selected!";
char ErrMsgPasteFailed[] = "Could not paste data from clipboard!";
char ErrMsgClipboardChanged[] = "Contents of clipboard have changed!\r\nNo paste performed.";



/*************************************************************************
** OleDoc::IDataObject interface implementation
*************************************************************************/

// IDataObject::QueryInterface
STDMETHODIMP OleDoc_DataObj_QueryInterface (
		LPDATAOBJECT        lpThis,
		REFIID              riid,
		LPVOID FAR*         lplpvObj
)
{
	LPOLEDOC lpOleDoc = ((struct CDocDataObjectImpl FAR*)lpThis)->lpOleDoc;

	return OleDoc_QueryInterface((LPOLEDOC)lpOleDoc, riid, lplpvObj);
}


// IDataObject::AddRef
STDMETHODIMP_(ULONG) OleDoc_DataObj_AddRef(LPDATAOBJECT lpThis)
{
	LPOLEDOC lpOleDoc = ((struct CDocDataObjectImpl FAR*)lpThis)->lpOleDoc;

	OleDbgAddRefMethod(lpThis, "IDataObject");

	return OleDoc_AddRef((LPOLEDOC)lpOleDoc);
}


// IDataObject::Release
STDMETHODIMP_(ULONG) OleDoc_DataObj_Release (LPDATAOBJECT lpThis)
{
	LPOLEDOC lpOleDoc = ((struct CDocDataObjectImpl FAR*)lpThis)->lpOleDoc;

	OleDbgReleaseMethod(lpThis, "IDataObject");

	return OleDoc_Release((LPOLEDOC)lpOleDoc);
}


// IDataObject::GetData
STDMETHODIMP OleDoc_DataObj_GetData (
		LPDATAOBJECT        lpThis,
		LPFORMATETC         lpFormatetc,
		LPSTGMEDIUM         lpMedium
)
{
	LPOLEDOC lpOleDoc = ((struct CDocDataObjectImpl FAR*)lpThis)->lpOleDoc;
	HRESULT hrErr;

	OLEDBG_BEGIN2("OleDoc_DataObj_GetData\r\n")

#if defined( OLE_SERVER )
	// Call OLE Server specific version of this function
	hrErr = ServerDoc_GetData((LPSERVERDOC)lpOleDoc, lpFormatetc, lpMedium);
#endif
#if defined( OLE_CNTR )
	// Call OLE Container specific version of this function
	hrErr = ContainerDoc_GetData(
			(LPCONTAINERDOC)lpOleDoc,
			lpFormatetc,
			lpMedium
	);
#endif

	OLEDBG_END2
	return hrErr;
}


// IDataObject::GetDataHere
STDMETHODIMP OleDoc_DataObj_GetDataHere (
		LPDATAOBJECT        lpThis,
		LPFORMATETC         lpFormatetc,
		LPSTGMEDIUM         lpMedium
)
{
	LPOLEDOC lpOleDoc = ((struct CDocDataObjectImpl FAR*)lpThis)->lpOleDoc;
	HRESULT hrErr;

	OLEDBG_BEGIN2("OleDoc_DataObj_GetDataHere\r\n")

#if defined( OLE_SERVER )
	// Call OLE Server specific version of this function
	hrErr = ServerDoc_GetDataHere(
			(LPSERVERDOC)lpOleDoc,
			lpFormatetc,
			lpMedium
	);
#endif
#if defined( OLE_CNTR )
	// Call OLE Container specific version of this function
	hrErr = ContainerDoc_GetDataHere(
			(LPCONTAINERDOC)lpOleDoc,
			lpFormatetc,
			lpMedium
	);
#endif

	OLEDBG_END2
	return hrErr;
}


// IDataObject::QueryGetData
STDMETHODIMP OleDoc_DataObj_QueryGetData (
		LPDATAOBJECT        lpThis,
		LPFORMATETC         lpFormatetc
)
{
	LPOLEDOC lpOleDoc = ((struct CDocDataObjectImpl FAR*)lpThis)->lpOleDoc;
	HRESULT hrErr;
	OLEDBG_BEGIN2("OleDoc_DataObj_QueryGetData\r\n");

#if defined( OLE_SERVER )
	// Call OLE Server specific version of this function
	hrErr = ServerDoc_QueryGetData((LPSERVERDOC)lpOleDoc, lpFormatetc);
#endif
#if defined( OLE_CNTR )
	// Call OLE Container specific version of this function
	hrErr = ContainerDoc_QueryGetData((LPCONTAINERDOC)lpOleDoc, lpFormatetc);
#endif

	OLEDBG_END2
	return hrErr;
}


// IDataObject::GetCanonicalFormatEtc
STDMETHODIMP OleDoc_DataObj_GetCanonicalFormatEtc(
		LPDATAOBJECT        lpThis,
		LPFORMATETC         lpformatetc,
		LPFORMATETC         lpformatetcOut
)
{
	HRESULT hrErr;
	OleDbgOut2("OleDoc_DataObj_GetCanonicalFormatEtc\r\n");

	if (!lpformatetcOut)
		return ResultFromScode(E_INVALIDARG);

	/* OLE2NOTE: we must make sure to set all out parameters to NULL. */
	lpformatetcOut->ptd = NULL;

	if (!lpformatetc)
		return ResultFromScode(E_INVALIDARG);

	// OLE2NOTE: we must validate that the format requested is supported
	if ((hrErr=lpThis->lpVtbl->QueryGetData(lpThis,lpformatetc)) != NOERROR)
		return hrErr;

	/* OLE2NOTE: an app that is insensitive to target device (as the
	**    Outline Sample is) should fill in the lpformatOut parameter
	**    but NULL out the "ptd" field; it should return NOERROR if the
	**    input formatetc->ptd what non-NULL. this tells the caller
	**    that it is NOT necessary to maintain a separate screen
	**    rendering and printer rendering. if should return
	**    DATA_S_SAMEFORMATETC if the input and output formatetc's are
	**    identical.
	*/

	*lpformatetcOut = *lpformatetc;
	if (lpformatetc->ptd == NULL)
		return ResultFromScode(DATA_S_SAMEFORMATETC);
	else {
		lpformatetcOut->ptd = NULL;
		return NOERROR;
	}
}


// IDataObject::SetData
STDMETHODIMP OleDoc_DataObj_SetData (
		LPDATAOBJECT    lpThis,
		LPFORMATETC     lpFormatetc,
		LPSTGMEDIUM     lpMedium,
		BOOL            fRelease
)
{
	LPOLEDOC lpOleDoc = ((struct CDocDataObjectImpl FAR*)lpThis)->lpOleDoc;
	LPOUTLINEDOC lpOutlineDoc = (LPOUTLINEDOC)lpOleDoc;
	LPOUTLINEAPP lpOutlineApp = (LPOUTLINEAPP)g_lpApp;
	SCODE sc = S_OK;
	OLEDBG_BEGIN2("OleDoc_DataObj_SetData\r\n")

	/* OLE2NOTE: a document that is used to transfer data (either via
	**    the clipboard or drag/drop) does NOT accept SetData on ANY
	**    format!
	*/
	if (lpOutlineDoc->m_fDataTransferDoc) {
		sc = E_FAIL;
		goto error;
	}

#if defined( OLE_SERVER )
	if (lpFormatetc->cfFormat == lpOutlineApp->m_cfOutline) {
		OLEDBG_BEGIN2("ServerDoc_SetData: CF_OUTLINE\r\n")
		OutlineDoc_SetRedraw ( lpOutlineDoc, FALSE );
		OutlineDoc_ClearAllLines(lpOutlineDoc);
		OutlineDoc_PasteOutlineData(lpOutlineDoc,lpMedium->hGlobal,-1);
		OutlineDoc_SetRedraw ( lpOutlineDoc, TRUE );
		OLEDBG_END3
	} else if (lpFormatetc->cfFormat == CF_TEXT) {
		OLEDBG_BEGIN2("ServerDoc_SetData: CF_TEXT\r\n")
		OutlineDoc_SetRedraw ( lpOutlineDoc, FALSE );
		OutlineDoc_ClearAllLines(lpOutlineDoc);
		OutlineDoc_PasteTextData(lpOutlineDoc,lpMedium->hGlobal,-1);
		OutlineDoc_SetRedraw ( lpOutlineDoc, TRUE );
		OLEDBG_END3
	} else {
		sc = DV_E_FORMATETC;
	}
#endif  // OLE_SERVER
#if defined( OLE_CNTR )
	/* the Container-Only version of Outline does NOT offer
	**    IDataObject interface from its User documents. this is
	**    required by objects which can be embedded or linked. the
	**    Container-only app only allows linking to its contained
	**    objects, NOT the data of the container itself.
	*/
	OleDbgAssertSz(0, "User documents do NOT support IDataObject\r\n");
	sc = E_NOTIMPL;
#endif  // OLE_CNTR

error:

	/* OLE2NOTE: if fRelease==TRUE, then we must take
	**    responsibility to release the lpMedium. we should only do
	**    this if we are going to return NOERROR. if we do NOT
	**    accept the data, then we should NOT release the lpMedium.
	**    if fRelease==FALSE, then the caller retains ownership of
	**    the data.
	*/
	if (sc == S_OK && fRelease)
		ReleaseStgMedium(lpMedium);

	OLEDBG_END2
	return ResultFromScode(sc);

}


// IDataObject::EnumFormatEtc
STDMETHODIMP OleDoc_DataObj_EnumFormatEtc(
		LPDATAOBJECT            lpThis,
		DWORD                   dwDirection,
		LPENUMFORMATETC FAR*    lplpenumFormatEtc
)
{
	LPOLEDOC lpOleDoc=((struct CDocDataObjectImpl FAR*)lpThis)->lpOleDoc;
	HRESULT hrErr;

	OLEDBG_BEGIN2("OleDoc_DataObj_EnumFormatEtc\r\n")

	/* OLE2NOTE: we must make sure to set all out parameters to NULL. */
	*lplpenumFormatEtc = NULL;

#if defined( OLE_SERVER )
	/* OLE2NOTE: a user document only needs to enumerate the static list
	**    of formats that are registered for our app in the
	**    registration database. OLE provides a default enumerator
	**    which enumerates from the registration database. this default
	**    enumerator is requested by returning OLE_S_USEREG. it is NOT
	**    required that a user document (ie. non-DataTransferDoc)
	**    enumerate the OLE formats: CF_LINKSOURCE, CF_EMBEDSOURCE, or
	**    CF_EMBEDDEDOBJECT.
	**
	**    An object implemented as a server EXE (as this sample
	**    is) may simply return OLE_S_USEREG to instruct the OLE
	**    DefHandler to call the OleReg* helper API which uses info in
	**    the registration database. Alternatively, the OleRegEnumFormatEtc
	**    API may be called directly. Objects implemented as a server
	**    DLL may NOT return OLE_S_USEREG; they must call the OleReg*
	**    API or provide their own implementation. For EXE based
	**    objects it is more efficient to return OLE_S_USEREG, because
	**    in then the enumerator is instantiated in the callers
	**    process space and no LRPC remoting is required.
	*/
	if (! ((LPOUTLINEDOC)lpOleDoc)->m_fDataTransferDoc)
		return ResultFromScode(OLE_S_USEREG);

	// Call OLE Server specific version of this function
	hrErr = ServerDoc_EnumFormatEtc(
			(LPSERVERDOC)lpOleDoc,
			dwDirection,
			lplpenumFormatEtc
	);
#endif
#if defined( OLE_CNTR )
	// Call OLE Container specific version of this function
	hrErr = ContainerDoc_EnumFormatEtc(
			(LPCONTAINERDOC)lpOleDoc,
			dwDirection,
			lplpenumFormatEtc
	);
#endif

	OLEDBG_END2
	return hrErr;
}


// IDataObject::DAdvise
STDMETHODIMP OleDoc_DataObj_DAdvise(
		LPDATAOBJECT        lpThis,
		FORMATETC FAR*      lpFormatetc,
		DWORD               advf,
		LPADVISESINK        lpAdvSink,
		DWORD FAR*          lpdwConnection
)
{
	LPOLEDOC lpOleDoc=((struct CDocDataObjectImpl FAR*)lpThis)->lpOleDoc;
	LPOUTLINEDOC lpOutlineDoc = (LPOUTLINEDOC)lpOleDoc;
	SCODE sc;

	OLEDBG_BEGIN2("OleDoc_DataObj_DAdvise\r\n")

	/* OLE2NOTE: we must make sure to set all out parameters to NULL. */
	*lpdwConnection = 0;

	/* OLE2NOTE: a document that is used to transfer data (either via
	**    the clipboard or drag/drop) does NOT support Advise notifications.
	*/
	if (lpOutlineDoc->m_fDataTransferDoc) {
		sc = OLE_E_ADVISENOTSUPPORTED;
		goto error;
	}

#if defined( OLE_SERVER )
	{
		HRESULT hrErr;
		LPSERVERDOC lpServerDoc = (LPSERVERDOC)lpOleDoc;

		/* OLE2NOTE: we should validate if the caller is setting up an
		**    Advise for a data type that we support. we must
		**    explicitly allow an advise for the "wildcard" advise.
		*/
		if ( !( lpFormatetc->cfFormat == 0 &&
				lpFormatetc->ptd == NULL &&
				lpFormatetc->dwAspect == -1L &&
				lpFormatetc->lindex == -1L &&
				lpFormatetc->tymed == -1L) &&
			 (hrErr = OleDoc_DataObj_QueryGetData(lpThis, lpFormatetc))
																!= NOERROR) {
			sc = GetScode(hrErr);
			goto error;
		}

                if (lpServerDoc->m_OleDoc.m_fObjIsClosing)
                {
                    //  We don't accept any more Advise's once we're closing
                    sc = OLE_E_ADVISENOTSUPPORTED;
                    goto error;
                }

		if (lpServerDoc->m_lpDataAdviseHldr == NULL &&
			CreateDataAdviseHolder(&lpServerDoc->m_lpDataAdviseHldr)
																!= NOERROR) {
				sc = E_OUTOFMEMORY;
				goto error;
		}

		OLEDBG_BEGIN2("IDataAdviseHolder::Advise called\r\n");
		hrErr = lpServerDoc->m_lpDataAdviseHldr->lpVtbl->Advise(
				lpServerDoc->m_lpDataAdviseHldr,
				(LPDATAOBJECT)&lpOleDoc->m_DataObject,
				lpFormatetc,
				advf,
				lpAdvSink,
				lpdwConnection
		);
		OLEDBG_END2

		OLEDBG_END2
		return hrErr;
	}
#endif  // OLE_SVR
#if defined( OLE_CNTR )
	{
		/* the Container-Only version of Outline does NOT offer
		**    IDataObject interface from its User documents. this is
		**    required by objects which can be embedded or linked. the
		**    Container-only app only allows linking to its contained
		**    objects, NOT the data of the container itself.
		*/
		OleDbgAssertSz(0, "User documents do NOT support IDataObject\r\n");
		sc = E_NOTIMPL;
		goto error;
	}
#endif  // OLE_CNTR

error:
	OLEDBG_END2
	return ResultFromScode(sc);
}



// IDataObject::DUnadvise
STDMETHODIMP OleDoc_DataObj_DUnadvise(LPDATAOBJECT lpThis, DWORD dwConnection)
{
	LPOLEDOC lpOleDoc=((struct CDocDataObjectImpl FAR*)lpThis)->lpOleDoc;
	LPOUTLINEDOC lpOutlineDoc = (LPOUTLINEDOC)lpOleDoc;
	SCODE sc;

	OLEDBG_BEGIN2("OleDoc_DataObj_DUnadvise\r\n")

	/* OLE2NOTE: a document that is used to transfer data (either via
	**    the clipboard or drag/drop) does NOT support Advise notifications.
	*/
	if (lpOutlineDoc->m_fDataTransferDoc) {
		sc = OLE_E_ADVISENOTSUPPORTED;
		goto error;
	}

#if defined( OLE_SERVER )
	{
		LPSERVERDOC lpServerDoc = (LPSERVERDOC)lpOleDoc;
		HRESULT hrErr;

		if (lpServerDoc->m_lpDataAdviseHldr == NULL) {
			sc = E_FAIL;
			goto error;
		}

		OLEDBG_BEGIN2("IDataAdviseHolder::Unadvise called\r\n");
		hrErr = lpServerDoc->m_lpDataAdviseHldr->lpVtbl->Unadvise(
				lpServerDoc->m_lpDataAdviseHldr,
				dwConnection
		);
		OLEDBG_END2

		OLEDBG_END2
		return hrErr;
	}
#endif
#if defined( OLE_CNTR )
	{
		/* the Container-Only version of Outline does NOT offer
		**    IDataObject interface from its User documents. this is
		**    required by objects which can be embedded or linked. the
		**    Container-only app only allows linking to its contained
		**    objects, NOT the data of the container itself.
		*/
		OleDbgAssertSz(0, "User documents do NOT support IDataObject\r\n");
		sc = E_NOTIMPL;
		goto error;
	}
#endif

error:
	OLEDBG_END2
	return ResultFromScode(sc);
}


// IDataObject::EnumDAdvise
STDMETHODIMP OleDoc_DataObj_EnumDAdvise(
		LPDATAOBJECT        lpThis,
		LPENUMSTATDATA FAR* lplpenumAdvise
)
{
	LPOLEDOC lpOleDoc=((struct CDocDataObjectImpl FAR*)lpThis)->lpOleDoc;
	LPOUTLINEDOC lpOutlineDoc = (LPOUTLINEDOC)lpOleDoc;
	SCODE sc;

	OLEDBG_BEGIN2("OleDoc_DataObj_EnumDAdvise\r\n")

	/* OLE2NOTE: we must make sure to set all out parameters to NULL. */
	*lplpenumAdvise = NULL;

	/* OLE2NOTE: a document that is used to transfer data (either via
	**    the clipboard or drag/drop) does NOT support Advise notifications.
	*/
	if (lpOutlineDoc->m_fDataTransferDoc) {
		sc = OLE_E_ADVISENOTSUPPORTED;
		goto error;
	}

#if defined( OLE_SERVER )
	{
		LPSERVERDOC lpServerDoc = (LPSERVERDOC)lpOleDoc;
		HRESULT hrErr;

		if (lpServerDoc->m_lpDataAdviseHldr == NULL) {
			sc = E_FAIL;
			goto error;
		}

		OLEDBG_BEGIN2("IDataAdviseHolder::EnumAdvise called\r\n");
		hrErr = lpServerDoc->m_lpDataAdviseHldr->lpVtbl->EnumAdvise(
				lpServerDoc->m_lpDataAdviseHldr,
				lplpenumAdvise
		);
		OLEDBG_END2

		OLEDBG_END2
		return hrErr;
	}
#endif
#if defined( OLE_CNTR )
	{
		/* the Container-Only version of Outline does NOT offer
		**    IDataObject interface from its User documents. this is
		**    required by objects which can be embedded or linked. the
		**    Container-only app only allows linking to its contained
		**    objects, NOT the data of the container itself.
		*/
		OleDbgAssertSz(0, "User documents do NOT support IDataObject\r\n");
		sc = E_NOTIMPL;
		goto error;
	}
#endif

error:
	OLEDBG_END2
	return ResultFromScode(sc);
}



/*************************************************************************
** OleDoc Supprt Functions common to both Container and Server versions
*************************************************************************/


/* OleDoc_CopyCommand
 * ------------------
 *  Copy selection to clipboard.
 *  Post to the clipboard the formats that the app can render.
 *  the actual data is not rendered at this time. using the
 *  delayed rendering technique, Windows will send the clipboard
 *  owner window either a WM_RENDERALLFORMATS or a WM_RENDERFORMAT
 *  message when the actual data is requested.
 *
 *    OLE2NOTE: the normal delayed rendering technique where Windows
 *    sends the clipboard owner window either a WM_RENDERALLFORMATS or
 *    a WM_RENDERFORMAT message when the actual data is requested is
 *    NOT exposed to the app calling OleSetClipboard. OLE internally
 *    creates its own window as the clipboard owner and thus our app
 *    will NOT get these WM_RENDER messages.
 */
void OleDoc_CopyCommand(LPOLEDOC lpSrcOleDoc)
{
	LPOUTLINEDOC lpSrcOutlineDoc = (LPOUTLINEDOC)lpSrcOleDoc;
	LPOUTLINEAPP lpOutlineApp = (LPOUTLINEAPP)g_lpApp;
	LPOUTLINEDOC lpClipboardDoc;

	/* squirrel away a copy of the current selection to the ClipboardDoc */
	lpClipboardDoc = OutlineDoc_CreateDataTransferDoc(lpSrcOutlineDoc);

	if (! lpClipboardDoc)
		return;     // Error: could not create DataTransferDoc

	lpOutlineApp->m_lpClipboardDoc = (LPOUTLINEDOC)lpClipboardDoc;

	/* OLE2NOTE: initially the Doc object is created with a 0 ref
	**    count. in order to have a stable Doc object during the
	**    process of initializing the Doc instance and transfering it
	**    to the clipboard, we intially AddRef the Doc ref cnt and later
	**    Release it. This initial AddRef is artificial; it is simply
	**    done to guarantee that a harmless QueryInterface followed by
	**    a Release does not inadvertantly force our object to destroy
	**    itself prematurely.
	*/
	OleDoc_AddRef((LPOLEDOC)lpClipboardDoc);

	/* OLE2NOTE: the OLE 2.0 style to put data onto the clipboard is to
	**    give the clipboard a pointer to an IDataObject interface that
	**    is able to statisfy IDataObject::GetData calls to render
	**    data. in our case we give the pointer to the ClipboardDoc
	**    which holds a cloned copy of the current user's selection.
	*/
	OLEDBG_BEGIN2("OleSetClipboard called\r\n")
	OleSetClipboard((LPDATAOBJECT)&((LPOLEDOC)lpClipboardDoc)->m_DataObject);
	OLEDBG_END2

	OleDoc_Release((LPOLEDOC)lpClipboardDoc);   // rel artificial AddRef above
}


/* OleDoc_PasteCommand
** -------------------
**    Paste default format data from the clipboard.
**    In this function we choose the highest fidelity format that the
**    source clipboard IDataObject* offers that we understand.
**
**    OLE2NOTE: clipboard handling in an OLE 2.0 application is
**    different than normal Windows clipboard handling. Data from the
**    clipboard is retieved by getting the IDataObject* pointer
**    returned by calling OleGetClipboard.
*/
void OleDoc_PasteCommand(LPOLEDOC lpOleDoc)
{
	LPOUTLINEDOC lpOutlineDoc = (LPOUTLINEDOC)lpOleDoc;
	LPOUTLINEAPP lpOutlineApp = (LPOUTLINEAPP)g_lpApp;
	LPDATAOBJECT lpClipboardDataObj = NULL;
	BOOL fLink = FALSE;
	BOOL fLocalDataObj = FALSE;
	BOOL fStatus;
	HRESULT hrErr;

	hrErr = OleGetClipboard((LPDATAOBJECT FAR*)&lpClipboardDataObj);
	if (hrErr != NOERROR)
		return;     // Clipboard seems to be empty or can't be accessed

	OutlineDoc_SetRedraw ( lpOutlineDoc, FALSE );

	/* check if the data on the clipboard is local to our application
	**    instance.
	*/
	if (lpOutlineApp->m_lpClipboardDoc) {
		LPOLEDOC lpOleDoc = (LPOLEDOC)lpOutlineApp->m_lpClipboardDoc;
		if (lpClipboardDataObj == (LPDATAOBJECT)&lpOleDoc->m_DataObject)
			fLocalDataObj = TRUE;
	}

	fStatus = OleDoc_PasteFromData(
			lpOleDoc,
			lpClipboardDataObj,
			fLocalDataObj,
			fLink
	);

	OutlineDoc_SetRedraw ( lpOutlineDoc, TRUE );

	if (! fStatus)
		OutlineApp_ErrorMessage(g_lpApp,"Could not paste data from clipboard!");

	if (lpClipboardDataObj)
		OleStdRelease((LPUNKNOWN)lpClipboardDataObj);
}


/* OleDoc_PasteSpecialCommand
** --------------------------
**    Allow the user to paste data in a particular format from the
**    clipboard. The paste special command displays a dialog to the
**    user that allows him to choose the format to be pasted from the
**    list of formats available.
**
**    OLE2NOTE: the PasteSpecial dialog is one of the standard OLE 2.0
**    UI dialogs for which the dialog is implemented and in the OLE2UI
**    library.
**
**    OLE2NOTE: clipboard handling in an OLE 2.0 application is
**    different than normal Windows clipboard handling. Data from the
**    clipboard is retieved by getting the IDataObject* pointer
**    returned by calling OleGetClipboard.
*/
void OleDoc_PasteSpecialCommand(LPOLEDOC lpOleDoc)
{
	LPOUTLINEDOC lpOutlineDoc = (LPOUTLINEDOC)lpOleDoc;
	LPOUTLINEAPP lpOutlineApp = (LPOUTLINEAPP)g_lpApp;
	LPOLEAPP lpOleApp = (LPOLEAPP)g_lpApp;
	LPDATAOBJECT lpClipboardDataObj = NULL;
	CLIPFORMAT cfFormat;
	int nFmtEtc;
	UINT uInt;
	BOOL fLink = FALSE;
	BOOL fLocalDataObj = FALSE;
	BOOL fStatus;
	HRESULT hrErr;
	OLEUIPASTESPECIAL ouiPasteSpl;
	BOOL fDisplayAsIcon;

	hrErr = OleGetClipboard((LPDATAOBJECT FAR*)&lpClipboardDataObj);
	if (hrErr != NOERROR)
		return;     // Clipboard seems to be empty or can't be accessed

	/* check if the data on the clipboard is local to our application
	**    instance.
	*/
	if (lpOutlineApp->m_lpClipboardDoc) {
		LPOLEDOC lpOleDoc = (LPOLEDOC)lpOutlineApp->m_lpClipboardDoc;
		if (lpClipboardDataObj == (LPDATAOBJECT)&lpOleDoc->m_DataObject)
			fLocalDataObj = TRUE;
	}

	/* Display the PasteSpecial dialog and allow the user to select the
	**    format to paste.
	*/
	_fmemset((LPOLEUIPASTESPECIAL)&ouiPasteSpl, 0, sizeof(ouiPasteSpl));
	ouiPasteSpl.cbStruct = sizeof(ouiPasteSpl);       //Structure Size
	ouiPasteSpl.dwFlags =  PSF_SELECTPASTE | PSF_SHOWHELP;  //IN-OUT:  Flags
	ouiPasteSpl.hWndOwner = lpOutlineApp->m_lpDoc->m_hWndDoc; //Owning window
	ouiPasteSpl.lpszCaption = "Paste Special";    //Dialog caption bar contents
	ouiPasteSpl.lpfnHook = NULL;       //Hook callback
	ouiPasteSpl.lCustData = 0;         //Custom data to pass to hook
	ouiPasteSpl.hInstance = NULL;      //Instance for customized template name
	ouiPasteSpl.lpszTemplate = NULL;   //Customized template name
	ouiPasteSpl.hResource = NULL;      //Customized template handle

	ouiPasteSpl.arrPasteEntries = lpOleApp->m_arrPasteEntries;
	ouiPasteSpl.cPasteEntries = lpOleApp->m_nPasteEntries;
	ouiPasteSpl.lpSrcDataObj = lpClipboardDataObj;
	ouiPasteSpl.arrLinkTypes = lpOleApp->m_arrLinkTypes;
	ouiPasteSpl.cLinkTypes = lpOleApp->m_nLinkTypes;
	ouiPasteSpl.cClsidExclude = 0;

	OLEDBG_BEGIN3("OleUIPasteSpecial called\r\n")
	uInt = OleUIPasteSpecial(&ouiPasteSpl);
	OLEDBG_END3

	fDisplayAsIcon =
			(ouiPasteSpl.dwFlags & PSF_CHECKDISPLAYASICON ? TRUE : FALSE);

	if (uInt == OLEUI_OK) {
		nFmtEtc = ouiPasteSpl.nSelectedIndex;
		fLink =  ouiPasteSpl.fLink;

		if (nFmtEtc < 0 || nFmtEtc >= lpOleApp->m_nPasteEntries) {
			OutlineApp_ErrorMessage(lpOutlineApp, ErrMsgBadFmt);
			goto error;
		}

		OutlineDoc_SetRedraw ( lpOutlineDoc, FALSE );

		cfFormat = lpOleApp->m_arrPasteEntries[nFmtEtc].fmtetc.cfFormat;

		fStatus = OleDoc_PasteFormatFromData(
				lpOleDoc,
				cfFormat,
				lpClipboardDataObj,
				fLocalDataObj,
				fLink,
				fDisplayAsIcon,
				ouiPasteSpl.hMetaPict,
				(LPSIZEL)&ouiPasteSpl.sizel
		);

		OutlineDoc_SetRedraw ( lpOutlineDoc, TRUE );

		if (! fStatus) {
			OutlineApp_ErrorMessage(lpOutlineApp, ErrMsgPasteFailed);
			goto error;
		}

	} else if (uInt == OLEUI_PSERR_CLIPBOARDCHANGED) {
		/* OLE2NOTE: this error code is returned when the contents of
		**    the clipboard change while the PasteSpecial dialog is up.
		**    in this situation the PasteSpecial dialog automatically
		**    brings itself down and NO paste operation should be performed.
		*/
		OutlineApp_ErrorMessage(lpOutlineApp, ErrMsgClipboardChanged);
	}

error:

	if (lpClipboardDataObj)
		OleStdRelease((LPUNKNOWN)lpClipboardDataObj);

	if (uInt == OLEUI_OK && ouiPasteSpl.hMetaPict)
		// clean up metafile
		OleUIMetafilePictIconFree(ouiPasteSpl.hMetaPict);
}



/* OleDoc_CreateDataTransferDoc
 * ----------------------------
 *
 *      Create a document to be use to transfer data (either via a
 *  drag/drop operation of the clipboard). Copy the selection of the
 *  source doc to the data transfer document. A data transfer document is
 *  the same as a document that is created by the user except that it is
 *  NOT made visible to the user. it is specially used to hold a copy of
 *  data that the user should not be able to change.
 *
 *  OLE2NOTE: in the OLE version the data transfer document is used
 *      specifically to provide an IDataObject* that renders the data copied.
 */
LPOUTLINEDOC OleDoc_CreateDataTransferDoc(LPOLEDOC lpSrcOleDoc)
{
	LPOUTLINEDOC lpSrcOutlineDoc = (LPOUTLINEDOC)lpSrcOleDoc;
	LPOUTLINEAPP lpOutlineApp = (LPOUTLINEAPP)g_lpApp;
	LPOUTLINEDOC lpDestOutlineDoc;
	LPLINELIST lpSrcLL = &lpSrcOutlineDoc->m_LineList;
	LINERANGE lrSel;
	int nCopied;

	lpDestOutlineDoc = OutlineApp_CreateDoc(lpOutlineApp, TRUE);
	if (! lpDestOutlineDoc) return NULL;

	// set the ClipboardDoc to an (Untitled) doc.
	if (! OutlineDoc_InitNewFile(lpDestOutlineDoc))
		goto error;

	LineList_GetSel(lpSrcLL, (LPLINERANGE)&lrSel);
	nCopied = LineList_CopySelToDoc(
			lpSrcLL,
			(LPLINERANGE)&lrSel,
			lpDestOutlineDoc
	);

	if (nCopied != (lrSel.m_nEndLine - lrSel.m_nStartLine + 1)) {
		OleDbgAssertSz(FALSE,"OleDoc_CreateDataTransferDoc: entire selection NOT copied\r\n");
		goto error;     // ERROR: all lines could NOT be copied
	}

#if defined( OLE_SERVER )
	{
		LPOLEDOC lpSrcOleDoc = (LPOLEDOC)lpSrcOutlineDoc;
		LPOLEDOC lpDestOleDoc = (LPOLEDOC)lpDestOutlineDoc;
		LPSERVERDOC lpDestServerDoc = (LPSERVERDOC)lpDestOutlineDoc;
		LPMONIKER lpmkDoc = NULL;
		LPMONIKER lpmkItem = NULL;

		/* If source document is able to provide a moniker, then the
		**    destination document (lpDestOutlineDoc) should offer
		**    CF_LINKSOURCE via its IDataObject interface that it gives
		**    to the clipboard or the drag/drop operation.
		**
		**    OLE2NOTE: we want to ask the source document if it can
		**    produce a moniker, but we do NOT want to FORCE moniker
		**    assignment at this point. we only want to FORCE moniker
		**    assignment later if a Paste Link occurs (ie. GetData for
		**    CF_LINKSOURCE). if the source document is able to give
		**    a moniker, then we store a pointer to the source document
		**    so we can ask it at a later time to get the moniker. we
		**    also save the range of the current selection so we can
		**    generate a proper item name later when Paste Link occurs.
		**    Also we need to give a string which identifies the source
		**    of the copy in the CF_OBJECTDESCRIPTOR format. this
		**    string is used to display in the PasteSpecial dialog. we
		**    get and store a TEMPFORUSER moniker which identifies the
		**    source of copy.
		*/
		lpDestOleDoc->m_lpSrcDocOfCopy = lpSrcOleDoc;
		lpmkDoc = OleDoc_GetFullMoniker(lpSrcOleDoc, GETMONIKER_TEMPFORUSER);
		if (lpmkDoc != NULL) {
			lpDestOleDoc->m_fLinkSourceAvail = TRUE;
			lpDestServerDoc->m_lrSrcSelOfCopy = lrSel;
			OleStdRelease((LPUNKNOWN)lpmkDoc);
		}
	}
#endif
#if defined( OLE_CNTR )
	{
		LPOLEDOC lpSrcOleDoc = (LPOLEDOC)lpSrcOutlineDoc;
		LPOLEDOC lpDestOleDoc = (LPOLEDOC)lpDestOutlineDoc;
		LPCONTAINERDOC lpDestContainerDoc = (LPCONTAINERDOC)lpDestOutlineDoc;

		/* If one line was copied from the source document, and it was a
		**    single OLE object, then the destination document should
		**    offer additional data formats to allow the transfer of
		**    the OLE object via IDataObject::GetData. Specifically, the
		**    following additional data formats are offered if a single
		**    OLE object is copied:
		**          CF_EMBEDDEDOBJECT
		**          CF_OBJECTDESCRIPTOR     (should be given even w/o object)
		**          CF_METAFILEPICT         (note: dwAspect depends on object)
		**          CF_LINKSOURCE           -- if linking is possible
		**          CF_LINKSOURCEDESCRIPTOR -- if linking is possible
		**
		**    optionally the container may give
		**          <data format available in OLE object's cache>
		*/

		if (nCopied == 1) {
			LPOLEOBJECT lpSrcOleObj;
			LPCONTAINERLINE lpSrcContainerLine;
			DWORD dwStatus;

			lpSrcContainerLine = (LPCONTAINERLINE)LineList_GetLine(
					lpSrcLL,
					lrSel.m_nStartLine
			);

			if (! lpSrcContainerLine)
				goto error;

			lpDestOleDoc->m_lpSrcDocOfCopy = lpSrcOleDoc;

			if ((((LPLINE)lpSrcContainerLine)->m_lineType==CONTAINERLINETYPE)
					&& ((lpSrcOleObj=lpSrcContainerLine->m_lpOleObj)!=NULL)) {

				lpDestContainerDoc->m_fEmbeddedObjectAvail = TRUE;
				lpSrcOleObj->lpVtbl->GetUserClassID(
						lpSrcOleObj,
						&lpDestContainerDoc->m_clsidOleObjCopied
				);
				lpDestContainerDoc->m_dwAspectOleObjCopied =
							lpSrcContainerLine->m_dwDrawAspect;

				/* OLE2NOTE: if the object is allowed to be linked
				**    to from the inside (ie. we are allowed to
				**    give out a moniker which binds to the running
				**    OLE object), then we want to offer
				**    CF_LINKSOURCE format. if the object is an OLE
				**    2.0 embedded object then it is allowed to be
				**    linked to from the inside. if the object is
				**    either an OleLink or an OLE 1.0 embedding
				**    then it can not be linked to from the inside.
				**    if we were a container/server app then we
				**    could offer linking to the outside of the
				**    object (ie. a pseudo object within our
				**    document). we are a container only app that
				**    does not support linking to ranges of its data.
				*/

				lpSrcOleObj->lpVtbl->GetMiscStatus(
						lpSrcOleObj,
						DVASPECT_CONTENT, /* aspect is not important */
						(LPDWORD)&dwStatus
				);
				if (! (dwStatus & OLEMISC_CANTLINKINSIDE)) {
					/* Our container supports linking to an embedded
					**    object. We want the lpDestContainerDoc to
					**    offer CF_LINKSOURCE via the IDataObject
					**    interface that it gives to the clipboard or
					**    the drag/drop operation. The link source will
					**    be identified by a composite moniker
					**    comprised of the FileMoniker of the source
					**    document and an ItemMoniker which identifies
					**    the OLE object inside the container. we do
					**    NOT want to force moniker assignment to the
					**    OLE object now (at copy time); we only want
					**    to FORCE moniker assignment later if a Paste
					**    Link occurs (ie. GetData for CF_LINKSOURCE).
					**    thus we store a pointer to the source document
					**    and the source ContainerLine so we can
					**    generate a proper ItemMoniker later when
					**    Paste Link occurs.
					*/
					lpDestOleDoc->m_fLinkSourceAvail = TRUE;
					lpDestContainerDoc->m_lpSrcContainerLine =
							lpSrcContainerLine;
				}
			}
		}
	}

#endif  // OLE_CNTR

	return lpDestOutlineDoc;

error:
	if (lpDestOutlineDoc)
		OutlineDoc_Destroy(lpDestOutlineDoc);

	return NULL;
}


/* OleDoc_PasteFromData
** --------------------
**
**    Paste data from an IDataObject*. The IDataObject* may come from
**    the clipboard (GetClipboard) or from a drag/drop operation.
**    In this function we choose the best format that we prefer.
**
**    Returns TRUE if data was successfully pasted.
**            FALSE if data could not be pasted.
*/

BOOL OleDoc_PasteFromData(
		LPOLEDOC            lpOleDoc,
		LPDATAOBJECT        lpSrcDataObj,
		BOOL                fLocalDataObj,
		BOOL                fLink
)
{
	LPOLEAPP        lpOleApp = (LPOLEAPP)g_lpApp;
	CLIPFORMAT      cfFormat;
	BOOL            fDisplayAsIcon = FALSE;
	SIZEL           sizelInSrc = {0, 0};
	HGLOBAL         hMem = NULL;
	HGLOBAL         hMetaPict = NULL;
	STGMEDIUM       medium;

	if (fLink) {
#if defined( OLE_SERVER )
		return FALSE;       // server version of app does NOT support links
#endif
#if defined( OLE_CNTR )
		// container version of app only supports OLE object type links
		cfFormat = lpOleApp->m_cfLinkSource;
#endif

	} else {

		int nFmtEtc;

		nFmtEtc = OleStdGetPriorityClipboardFormat(
				lpSrcDataObj,
				lpOleApp->m_arrPasteEntries,
				lpOleApp->m_nPasteEntries
		);

		if (nFmtEtc < 0)
			return FALSE;   // there is no format we like

		cfFormat = lpOleApp->m_arrPasteEntries[nFmtEtc].fmtetc.cfFormat;
	}

	/* OLE2NOTE: we need to check what dwDrawAspect is being
	**    transfered. if the data is an object that is displayed as an
	**    icon in the source, then we want to keep it as an icon. the
	**    aspect the object is displayed in at the source is transfered
	**    via the CF_OBJECTDESCRIPTOR format for a Paste operation.
	*/
	if (hMem = OleStdGetData(
			lpSrcDataObj,
			lpOleApp->m_cfObjectDescriptor,
			NULL,
			DVASPECT_CONTENT,
			(LPSTGMEDIUM)&medium)) {
		LPOBJECTDESCRIPTOR lpOD = GlobalLock(hMem);
		fDisplayAsIcon = (lpOD->dwDrawAspect == DVASPECT_ICON ? TRUE : FALSE);
		sizelInSrc = lpOD->sizel;   // size of object/picture in source (opt.)
		GlobalUnlock(hMem);
		ReleaseStgMedium((LPSTGMEDIUM)&medium);     // equiv to GlobalFree

		if (fDisplayAsIcon) {
			hMetaPict = OleStdGetData(
					lpSrcDataObj,
					CF_METAFILEPICT,
					NULL,
					DVASPECT_ICON,
					(LPSTGMEDIUM)&medium
			);
			if (hMetaPict == NULL)
				fDisplayAsIcon = FALSE; // give up; failed to get icon MFP
		}
	}

	return OleDoc_PasteFormatFromData(
			lpOleDoc,
			cfFormat,
			lpSrcDataObj,
			fLocalDataObj,
			fLink,
			fDisplayAsIcon,
			hMetaPict,
			(LPSIZEL)&sizelInSrc
	);

	if (hMetaPict)
		ReleaseStgMedium((LPSTGMEDIUM)&medium);  // properly free METAFILEPICT
}


/* OleDoc_PasteFormatFromData
** --------------------------
**
**    Paste a particular data format from a IDataObject*. The
**    IDataObject* may come from the clipboard (GetClipboard) or from a
**    drag/drop operation.
**
**    Returns TRUE if data was successfully pasted.
**            FALSE if data could not be pasted.
*/

BOOL OleDoc_PasteFormatFromData(
		LPOLEDOC            lpOleDoc,
		CLIPFORMAT          cfFormat,
		LPDATAOBJECT        lpSrcDataObj,
		BOOL                fLocalDataObj,
		BOOL                fLink,
		BOOL                fDisplayAsIcon,
		HGLOBAL             hMetaPict,
		LPSIZEL             lpSizelInSrc
)
{
#if defined( OLE_SERVER )
	/* call server specific version of the function. */
	return ServerDoc_PasteFormatFromData(
			(LPSERVERDOC)lpOleDoc,
			cfFormat,
			lpSrcDataObj,
			fLocalDataObj,
			fLink
	);
#endif
#if defined( OLE_CNTR )

	/* call container specific version of the function. */
	return ContainerDoc_PasteFormatFromData(
			(LPCONTAINERDOC)lpOleDoc,
			cfFormat,
			lpSrcDataObj,
			fLocalDataObj,
			fLink,
			fDisplayAsIcon,
			hMetaPict,
			lpSizelInSrc
	);
#endif
}


/* OleDoc_QueryPasteFromData
** -------------------------
**
**    Check if the IDataObject* offers data in a format that we can
**    paste. The IDataObject* may come from the clipboard
**    (GetClipboard) or from a drag/drop operation.
**
**    Returns TRUE if paste can be performed
**            FALSE if paste is not possible.
*/

BOOL OleDoc_QueryPasteFromData(
		LPOLEDOC            lpOleDoc,
		LPDATAOBJECT        lpSrcDataObj,
		BOOL                fLink
)
{
#if defined( OLE_SERVER )
	return ServerDoc_QueryPasteFromData(
			(LPSERVERDOC) lpOleDoc,
			lpSrcDataObj,
			fLink
	);
#endif
#if defined( OLE_CNTR )

	return ContainerDoc_QueryPasteFromData(
			(LPCONTAINERDOC) lpOleDoc,
			lpSrcDataObj,
			fLink
	);
#endif
}


/* OleDoc_GetExtent
 * ----------------
 *
 *      Get the extent (width, height) of the entire document in Himetric.
 */
void OleDoc_GetExtent(LPOLEDOC lpOleDoc, LPSIZEL lpsizel)
{
	LPLINELIST lpLL = (LPLINELIST)&((LPOUTLINEDOC)lpOleDoc)->m_LineList;

	LineList_CalcSelExtentInHimetric(lpLL, NULL, lpsizel);
}


/* OleDoc_GetObjectDescriptorData
 * ------------------------------
 *
 * Return a handle to an object's data in CF_OBJECTDESCRIPTOR form
 *
 */
HGLOBAL OleDoc_GetObjectDescriptorData(LPOLEDOC lpOleDoc, LPLINERANGE lplrSel)
{
	LPOUTLINEDOC lpOutlineDoc = (LPOUTLINEDOC)lpOleDoc;

	/* Only our data transfer doc renders CF_OBJECTDESCRIPTOR */
	OleDbgAssert(lpOutlineDoc->m_fDataTransferDoc);

#if defined( OLE_SERVER )
	{
		LPSERVERDOC   lpServerDoc = (LPSERVERDOC)lpOleDoc;
		SIZEL         sizel;
		POINTL        pointl;
		LPSTR         lpszSrcOfCopy = NULL;
		IBindCtx  FAR *pbc = NULL;
		HGLOBAL       hObjDesc;
		DWORD         dwStatus = 0;
		LPOUTLINEDOC  lpSrcDocOfCopy=(LPOUTLINEDOC)lpOleDoc->m_lpSrcDocOfCopy;
		LPMONIKER lpSrcMonikerOfCopy = ServerDoc_GetSelFullMoniker(
				(LPSERVERDOC)lpOleDoc->m_lpSrcDocOfCopy,
				&lpServerDoc->m_lrSrcSelOfCopy,
				GETMONIKER_TEMPFORUSER
		);

		SvrDoc_OleObj_GetMiscStatus(
				(LPOLEOBJECT)&lpServerDoc->m_OleObject,
				DVASPECT_CONTENT,
				&dwStatus
		);

		OleDoc_GetExtent(lpOleDoc, &sizel);
		pointl.x = pointl.y = 0;

		if (lpSrcMonikerOfCopy) {
			CreateBindCtx(0, (LPBC FAR*)&pbc);
			CallIMonikerGetDisplayNameA(
				lpSrcMonikerOfCopy, pbc, NULL, &lpszSrcOfCopy);
			pbc->lpVtbl->Release(pbc);
			lpSrcMonikerOfCopy->lpVtbl->Release(lpSrcMonikerOfCopy);
		} else {
			/* this document has no moniker; use our FullUserTypeName
			**    as the description of the source of copy.
			*/
			lpszSrcOfCopy = FULLUSERTYPENAME;
		}

		hObjDesc =  OleStdGetObjectDescriptorData(
				CLSID_APP,
				DVASPECT_CONTENT,
				sizel,
				pointl,
				dwStatus,
				FULLUSERTYPENAME,
				lpszSrcOfCopy
		);

		if (lpSrcMonikerOfCopy && lpszSrcOfCopy)
			OleStdFreeString(lpszSrcOfCopy, NULL);
		return hObjDesc;

	}
#endif
#if defined( OLE_CNTR )
	{
		LPCONTAINERDOC lpContainerDoc = (LPCONTAINERDOC)lpOleDoc;
		LPLINELIST lpLL = (LPLINELIST)&((LPOUTLINEDOC)lpOleDoc)->m_LineList;
		LPCONTAINERLINE lpContainerLine;
		HGLOBAL hObjDesc;
		BOOL fSelIsOleObject = FALSE;
		LPOLEOBJECT lpOleObj;
		SIZEL sizel;
		POINTL pointl;

		if ( lpLL->m_nNumLines == 1 ) {
			fSelIsOleObject = ContainerDoc_IsSelAnOleObject(
					lpContainerDoc,
					&IID_IOleObject,
					(LPUNKNOWN FAR*)&lpOleObj,
					NULL,    /* we don't need the line index */
					(LPCONTAINERLINE FAR*)&lpContainerLine
			);
		}

		pointl.x = pointl.y = 0;

		if (fSelIsOleObject) {
			/* OLE2NOTE: a single OLE object is being transfered via
			**    this DataTransferDoc. we need to generate the
			**    CF_ObjectDescrioptor which describes the OLE object.
			*/

			LPOUTLINEDOC lpSrcOutlineDoc =
					(LPOUTLINEDOC)lpOleDoc->m_lpSrcDocOfCopy;
			LPSTR lpszSrcOfCopy = lpSrcOutlineDoc->m_szFileName;
			BOOL fFreeSrcOfCopy = FALSE;
			SIZEL sizelOleObject;
			LPLINE lpLine = (LPLINE)lpContainerLine;

			/* if the object copied can be linked to then get a
			**    TEMPFORUSER form of the moniker which identifies the
			**    source of copy. we do not want to force the
			**    assignment of the moniker until CF_LINKSOURCE is
			**    rendered.
			**    if the object copied can not be a link source then use
			**    the source filename to identify the source of copy.
			**    there is no need to generate a moniker for the object
			**    copied.
			*/
			if (lpOleDoc->m_fLinkSourceAvail &&
					lpContainerDoc->m_lpSrcContainerLine) {
				LPBINDCTX pbc = NULL;
				LPMONIKER lpSrcMonikerOfCopy = ContainerLine_GetFullMoniker(
						lpContainerDoc->m_lpSrcContainerLine,
						GETMONIKER_TEMPFORUSER
				);
				if (lpSrcMonikerOfCopy) {
					CreateBindCtx(0, (LPBC FAR*)&pbc);
					if (pbc != NULL) {
						CallIMonikerGetDisplayNameA(
							lpSrcMonikerOfCopy, pbc, NULL, &lpszSrcOfCopy);

						pbc->lpVtbl->Release(pbc);
						fFreeSrcOfCopy = TRUE;
					}
					lpSrcMonikerOfCopy->lpVtbl->Release(lpSrcMonikerOfCopy);
				}
			}

			/* OLE2NOTE: Get size that object is being drawn. If the
			**    object has been scaled because the user resized the
			**    object, then we want to pass the scaled size of the
			**    object in the ObjectDescriptor rather than the size
			**    that the object would return via
			**    IOleObject::GetExtent and IViewObject2::GetExtent. in
			**    this way if the object is transfered to another container
			**    (via clipboard or drag/drop), then the object will
			**    remain the scaled size.
			*/
			sizelOleObject.cx = lpLine->m_nWidthInHimetric;
			sizelOleObject.cy = lpLine->m_nHeightInHimetric;

			hObjDesc = OleStdGetObjectDescriptorDataFromOleObject(
					lpOleObj,
					lpszSrcOfCopy,
					lpContainerLine->m_dwDrawAspect,
					pointl,
					(LPSIZEL)&sizelOleObject
			);

			if (fFreeSrcOfCopy && lpszSrcOfCopy)
				OleStdFreeString(lpszSrcOfCopy, NULL);
			OleStdRelease((LPUNKNOWN)lpOleObj);
			return hObjDesc;
		} else {
			/* OLE2NOTE: the data being transfered via this
			**    DataTransferDoc is NOT a single OLE object. thus in
			**    this case the CF_ObjectDescriptor data should
			**    describe our container app itself.
			*/
			OleDoc_GetExtent(lpOleDoc, &sizel);
			return OleStdGetObjectDescriptorData(
					CLSID_NULL, /* not used if no object formats */
					DVASPECT_CONTENT,
					sizel,
					pointl,
					0,
					NULL,       /* UserTypeName not used if no obj fmt's */
					FULLUSERTYPENAME   /* string to identify source of copy */
			);

		}
	}
#endif  // OLE_CNTR
}


#if defined( OLE_SERVER )

/*************************************************************************
** ServerDoc Supprt Functions Used by Server versions
*************************************************************************/


/* ServerDoc_PasteFormatFromData
** -----------------------------
**
**    Paste a particular data format from a IDataObject*. The
**    IDataObject* may come from the clipboard (GetClipboard) or from a
**    drag/drop operation.
**
**    NOTE: fLink is specified then FALSE if returned because the
**    Server only version of the app can not support links.
**
**    Returns TRUE if data was successfully pasted.
**            FALSE if data could not be pasted.
*/
BOOL ServerDoc_PasteFormatFromData(
		LPSERVERDOC             lpServerDoc,
		CLIPFORMAT              cfFormat,
		LPDATAOBJECT            lpSrcDataObj,
		BOOL                    fLocalDataObj,
		BOOL                    fLink
)
{
	LPLINELIST   lpLL = (LPLINELIST)&((LPOUTLINEDOC)lpServerDoc)->m_LineList;
	LPOUTLINEAPP lpOutlineApp = (LPOUTLINEAPP)g_lpApp;
	LPOLEAPP     lpOleApp = (LPOLEAPP)g_lpApp;
	int          nIndex;
	int          nCount = 0;
	HGLOBAL      hData;
	STGMEDIUM    medium;
	LINERANGE    lrSel;

	if (LineList_GetCount(lpLL) == 0)
		nIndex = -1;    // pasting to empty list
	else
		nIndex=LineList_GetFocusLineIndex(lpLL);

	if (fLink) {
		/* We should paste a Link to the data, but we do not support links */
		return FALSE;

	} else {

		if (cfFormat == lpOutlineApp->m_cfOutline) {

			hData = OleStdGetData(
					lpSrcDataObj,
					lpOutlineApp->m_cfOutline,
					NULL,
					DVASPECT_CONTENT,
					(LPSTGMEDIUM)&medium
			);
			if (hData == NULL)
				return FALSE;

			nCount = OutlineDoc_PasteOutlineData(
					(LPOUTLINEDOC)lpServerDoc,
					hData,
					nIndex
			);
			// OLE2NOTE: we must free data handle by releasing the medium
			ReleaseStgMedium((LPSTGMEDIUM)&medium);

		} else if(cfFormat == CF_TEXT) {

			hData = OleStdGetData(
					lpSrcDataObj,
					CF_TEXT,
					NULL,
					DVASPECT_CONTENT,
					(LPSTGMEDIUM)&medium
			);
			if (hData == NULL)
				return FALSE;

			nCount = OutlineDoc_PasteTextData(
					(LPOUTLINEDOC)lpServerDoc,
					hData,
					nIndex
			);
			// OLE2NOTE: we must free data handle by releasing the medium
			ReleaseStgMedium((LPSTGMEDIUM)&medium);
		}
	}

	lrSel.m_nEndLine   = nIndex + 1;
	lrSel.m_nStartLine = nIndex + nCount;
	LineList_SetSel(lpLL, &lrSel);
	return TRUE;
}


/* ServerDoc_QueryPasteFromData
** ----------------------------
**
**    Check if the IDataObject* offers data in a format that we can
**    paste. The IDataObject* may come from the clipboard
**    (GetClipboard) or from a drag/drop operation.
**    In this function we look if one of the following formats is
**    offered:
**              CF_OUTLINE
**              CF_TEXT
**
**    NOTE: fLink is specified then FALSE if returned because the
**    Server only version of the app can not support links.
**
**    Returns TRUE if paste can be performed
**            FALSE if paste is not possible.
*/
BOOL ServerDoc_QueryPasteFromData(
		LPSERVERDOC             lpServerDoc,
		LPDATAOBJECT            lpSrcDataObj,
		BOOL                    fLink
)
{
	LPOLEAPP lpOleApp = (LPOLEAPP)g_lpApp;

	if (fLink) {
		/* we do not support links */
		return FALSE;

	} else {

		int nFmtEtc;

		nFmtEtc = OleStdGetPriorityClipboardFormat(
				lpSrcDataObj,
				lpOleApp->m_arrPasteEntries,
				lpOleApp->m_nPasteEntries
			);

		if (nFmtEtc < 0)
			return FALSE;   // there is no format we like
	}

	return TRUE;
}


/* ServerDoc_GetData
 * -----------------
 *
 * Render data from the document on a CALLEE allocated STGMEDIUM.
 *      This routine is called via IDataObject::GetData.
 */

HRESULT ServerDoc_GetData (
		LPSERVERDOC             lpServerDoc,
		LPFORMATETC             lpformatetc,
		LPSTGMEDIUM             lpMedium
)
{
	LPOLEDOC  lpOleDoc = (LPOLEDOC)lpServerDoc;
	LPOUTLINEDOC  lpOutlineDoc = (LPOUTLINEDOC)lpServerDoc;
	LPSERVERAPP lpServerApp = (LPSERVERAPP)g_lpApp;
	LPOLEAPP  lpOleApp = (LPOLEAPP)lpServerApp;
	LPOUTLINEAPP  lpOutlineApp = (LPOUTLINEAPP)lpServerApp;
	HRESULT hrErr;
	SCODE sc;

	// OLE2NOTE: we must set out pointer parameters to NULL
	lpMedium->pUnkForRelease = NULL;

	/* OLE2NOTE: we must make sure to set all out parameters to NULL. */
	lpMedium->tymed = TYMED_NULL;
	lpMedium->pUnkForRelease = NULL;    // we transfer ownership to caller
	lpMedium->hGlobal = NULL;

	if(lpformatetc->cfFormat == lpOutlineApp->m_cfOutline) {
		// Verify caller asked for correct medium
		if (!(lpformatetc->tymed & TYMED_HGLOBAL)) {
			sc = DV_E_FORMATETC;
			goto error;
		}
		lpMedium->hGlobal = OutlineDoc_GetOutlineData (lpOutlineDoc,NULL);
		if (! lpMedium->hGlobal) {
			sc = E_OUTOFMEMORY;
			goto error;
		}

		lpMedium->tymed = TYMED_HGLOBAL;
		OleDbgOut3("ServerDoc_GetData: rendered CF_OUTLINE\r\n");
		return NOERROR;

	} else if (lpformatetc->cfFormat == CF_METAFILEPICT &&
		(lpformatetc->dwAspect & DVASPECT_CONTENT) ) {
		// Verify caller asked for correct medium
		if (!(lpformatetc->tymed & TYMED_MFPICT)) {
			sc = DV_E_FORMATETC;
			goto error;
		}

		lpMedium->hGlobal = ServerDoc_GetMetafilePictData(lpServerDoc,NULL);
		if (! lpMedium->hGlobal) {
			sc = E_OUTOFMEMORY;
			goto error;
		}

		lpMedium->tymed = TYMED_MFPICT;
		OleDbgOut3("ServerDoc_GetData: rendered CF_METAFILEPICT\r\n");
		return NOERROR;

	} else if (lpformatetc->cfFormat == CF_METAFILEPICT &&
		(lpformatetc->dwAspect & DVASPECT_ICON) ) {
		CLSID clsid;
		// Verify caller asked for correct medium
		if (!(lpformatetc->tymed & TYMED_MFPICT)) {
			sc = DV_E_FORMATETC;
			goto error;
		}

		/* OLE2NOTE: we should return the default icon for our class.
		**    we must be carefull to use the correct CLSID here.
		**    if we are currently preforming a "TreatAs (aka. ActivateAs)"
		**    operation then we need to use the class of the object
		**    written in the storage of the object. otherwise we would
		**    use our own class id.
		*/
		if (ServerDoc_GetClassID(lpServerDoc, (LPCLSID)&clsid) != NOERROR) {
			sc = DV_E_FORMATETC;
			goto error;
		}

		lpMedium->hGlobal=GetIconOfClass(g_lpApp->m_hInst,(REFCLSID)&clsid, NULL, FALSE);
		if (! lpMedium->hGlobal) {
			sc = E_OUTOFMEMORY;
			goto error;
		}

		lpMedium->tymed = TYMED_MFPICT;
		OleDbgOut3("ServerDoc_GetData: rendered CF_METAFILEPICT (icon)\r\n");
		return NOERROR;

	} else if (lpformatetc->cfFormat == CF_TEXT) {
		// Verify caller asked for correct medium
		if (!(lpformatetc->tymed & TYMED_HGLOBAL)) {
			sc = DV_E_FORMATETC;
			goto error;
		}

		lpMedium->hGlobal = OutlineDoc_GetTextData (
				(LPOUTLINEDOC)lpServerDoc,
				NULL
		);
		if (! lpMedium->hGlobal) {
			sc = E_OUTOFMEMORY;
			goto error;
		}

		lpMedium->tymed = TYMED_HGLOBAL;
		OleDbgOut3("ServerDoc_GetData: rendered CF_TEXT\r\n");
		return NOERROR;
	}

	/* the above are the only formats supports by a user document (ie.
	**    a non-data transfer doc). if the document is used for
	**    purposes of data transfer, then additional formats are offered.
	*/
	if (! lpOutlineDoc->m_fDataTransferDoc) {
		sc = DV_E_FORMATETC;
		goto error;
	}

	/* OLE2NOTE: ObjectDescriptor and LinkSrcDescriptor will
	**    contain the same data for the pure container and pure server
	**    type applications. only a container/server application may
	**    have different content for ObjectDescriptor and
	**    LinkSrcDescriptor. if a container/server copies a link for
	**    example, then the ObjectDescriptor would give the class
	**    of the link source but the LinkSrcDescriptor would give the
	**    class of the container/server itself. in this situation if a
	**    paste operation occurs, an equivalent link is pasted, but if
	**    a pastelink operation occurs, then a link to a pseudo object
	**    in the container/server is created.
	*/
	if (lpformatetc->cfFormat == lpOleApp->m_cfObjectDescriptor ||
		(lpformatetc->cfFormat == lpOleApp->m_cfLinkSrcDescriptor &&
				lpOleDoc->m_fLinkSourceAvail)) {
		// Verify caller asked for correct medium
		if (!(lpformatetc->tymed & TYMED_HGLOBAL)) {
			sc = DV_E_FORMATETC;
			goto error;
		}

		lpMedium->hGlobal = OleDoc_GetObjectDescriptorData (
				(LPOLEDOC)lpServerDoc,
				NULL
		);
		if (! lpMedium->hGlobal) {
			sc = E_OUTOFMEMORY;
			goto error;
		}

		lpMedium->tymed = TYMED_HGLOBAL;
		OleDbgOut3("ServerDoc_GetData: rendered CF_OBJECTDESCRIPTOR\r\n");
		return NOERROR;

	} else if (lpformatetc->cfFormat == lpOleApp->m_cfEmbedSource) {
		hrErr = OleStdGetOleObjectData(
				(LPPERSISTSTORAGE)&lpServerDoc->m_PersistStorage,
				lpformatetc,
				lpMedium,
				FALSE   /* fUseMemory -- (use file-base stg) */

		);
		if (hrErr != NOERROR) {
			sc = GetScode(hrErr);
			goto error;
		}
		OleDbgOut3("ServerDoc_GetData: rendered CF_EMBEDSOURCE\r\n");
		return NOERROR;

	} else if (lpformatetc->cfFormat == lpOleApp->m_cfLinkSource) {
		if (lpOleDoc->m_fLinkSourceAvail) {
			LPMONIKER lpmk;

			lpmk = ServerDoc_GetSelFullMoniker(
					(LPSERVERDOC)lpOleDoc->m_lpSrcDocOfCopy,
					&lpServerDoc->m_lrSrcSelOfCopy,
					GETMONIKER_FORCEASSIGN
			);
			if (lpmk) {
				hrErr = OleStdGetLinkSourceData(
						lpmk,
						(LPCLSID)&CLSID_APP,
						lpformatetc,
						lpMedium
				);
				OleStdRelease((LPUNKNOWN)lpmk);
				if (hrErr != NOERROR) {
					sc = GetScode(hrErr);
					goto error;
				}
				OleDbgOut3("ServerDoc_GetData: rendered CF_LINKSOURCE\r\n");
				return NOERROR;

			} else {
				sc = E_FAIL;
				goto error;
			}
		} else {
			sc = DV_E_FORMATETC;
			goto error;
		}

	} else {
		sc = DV_E_FORMATETC;
		goto error;
	}

	return NOERROR;

error:
	return ResultFromScode(sc);
}


/* ServerDoc_GetDataHere
 * ---------------------
 *
 * Render data from the document on a CALLER allocated STGMEDIUM.
 *      This routine is called via IDataObject::GetDataHere.
 */
HRESULT ServerDoc_GetDataHere (
		LPSERVERDOC             lpServerDoc,
		LPFORMATETC             lpformatetc,
		LPSTGMEDIUM             lpMedium
)
{
	LPOLEDOC        lpOleDoc = (LPOLEDOC)lpServerDoc;
	LPOUTLINEDOC    lpOutlineDoc = (LPOUTLINEDOC)lpServerDoc;
	LPSERVERAPP     lpServerApp = (LPSERVERAPP)g_lpApp;
	LPOLEAPP        lpOleApp = (LPOLEAPP)lpServerApp;
	LPOUTLINEAPP    lpOutlineApp = (LPOUTLINEAPP)lpServerApp;
	HRESULT         hrErr;
	SCODE           sc;

	// OLE2NOTE: lpMedium is an IN parameter. we should NOT set
	//           lpMedium->pUnkForRelease to NULL

	/* our user document does not support any formats for GetDataHere.
	**    if the document is used for
	**    purposes of data transfer, then additional formats are offered.
	*/
	if (! lpOutlineDoc->m_fDataTransferDoc) {
		sc = DV_E_FORMATETC;
		goto error;
	}

	if (lpformatetc->cfFormat == lpOleApp->m_cfEmbedSource) {
		hrErr = OleStdGetOleObjectData(
				(LPPERSISTSTORAGE)&lpServerDoc->m_PersistStorage,
				lpformatetc,
				lpMedium,
				FALSE   /* fUseMemory -- (use file-base stg) */
		);
		if (hrErr != NOERROR) {
			sc = GetScode(hrErr);
			goto error;
		}
		OleDbgOut3("ServerDoc_GetDataHere: rendered CF_EMBEDSOURCE\r\n");
		return NOERROR;

	} else if (lpformatetc->cfFormat == lpOleApp->m_cfLinkSource) {
		if (lpOleDoc->m_fLinkSourceAvail) {
			LPMONIKER lpmk;

			lpmk = ServerDoc_GetSelFullMoniker(
					(LPSERVERDOC)lpOleDoc->m_lpSrcDocOfCopy,
					&lpServerDoc->m_lrSrcSelOfCopy,
					GETMONIKER_FORCEASSIGN
			);
			if (lpmk) {
				hrErr = OleStdGetLinkSourceData(
						lpmk,
						(LPCLSID)&CLSID_APP,
						lpformatetc,
						lpMedium
				);
				OleStdRelease((LPUNKNOWN)lpmk);
				if (hrErr != NOERROR) {
					sc = GetScode(hrErr);
					goto error;
				}

				OleDbgOut3("ServerDoc_GetDataHere: rendered CF_LINKSOURCE\r\n");
				return NOERROR;

			} else {
				sc = E_FAIL;
				goto error;
			}
		} else {
			sc = DV_E_FORMATETC;
			goto error;
		}
	} else {

		/* Caller is requesting data to be returned in Caller allocated
		**    medium, but we do NOT support this. we only support
		**    global memory blocks that WE allocate for the caller.
		*/
		sc = DV_E_FORMATETC;
		goto error;
	}

	return NOERROR;

error:
	return ResultFromScode(sc);
}


/* ServerDoc_QueryGetData
 * ----------------------
 *
 * Answer if a particular data format is supported via GetData/GetDataHere.
 *      This routine is called via IDataObject::QueryGetData.
 */

HRESULT ServerDoc_QueryGetData (LPSERVERDOC lpServerDoc,LPFORMATETC lpformatetc)
{
	LPOLEDOC        lpOleDoc = (LPOLEDOC)lpServerDoc;
	LPOUTLINEDOC    lpOutlineDoc = (LPOUTLINEDOC)lpServerDoc;
	LPSERVERAPP     lpServerApp = (LPSERVERAPP)g_lpApp;
	LPOLEAPP        lpOleApp = (LPOLEAPP)lpServerApp;
	LPOUTLINEAPP    lpOutlineApp = (LPOUTLINEAPP)lpServerApp;

	/* Caller is querying if we support certain format but does not
	**    want any data actually returned.
	*/
	if (lpformatetc->cfFormat == lpOutlineApp->m_cfOutline ||
			lpformatetc->cfFormat == CF_TEXT) {
		// we only support HGLOBAL
		return OleStdQueryFormatMedium(lpformatetc, TYMED_HGLOBAL);
	} else if (lpformatetc->cfFormat == CF_METAFILEPICT &&
		(lpformatetc->dwAspect &
			(DVASPECT_CONTENT | DVASPECT_ICON)) ) {
		return OleStdQueryFormatMedium(lpformatetc, TYMED_MFPICT);
	}

	/* the above are the only formats supports by a user document (ie.
	**    a non-data transfer doc). if the document is used for
	**    purposes of data transfer, then additional formats are offered.
	*/
	if (! lpOutlineDoc->m_fDataTransferDoc)
		return ResultFromScode(DV_E_FORMATETC);

	if (lpformatetc->cfFormat == lpOleApp->m_cfEmbedSource) {
		return OleStdQueryOleObjectData(lpformatetc);

	} else if (lpformatetc->cfFormat == lpOleApp->m_cfLinkSource &&
		lpOleDoc->m_fLinkSourceAvail) {
		return OleStdQueryLinkSourceData(lpformatetc);

	} else if (lpformatetc->cfFormat == lpOleApp->m_cfObjectDescriptor) {
		return OleStdQueryObjectDescriptorData(lpformatetc);

	} else if (lpformatetc->cfFormat == lpOleApp->m_cfLinkSrcDescriptor &&
				lpOleDoc->m_fLinkSourceAvail) {
		return OleStdQueryObjectDescriptorData(lpformatetc);
	}

	return ResultFromScode(DV_E_FORMATETC);
}


/* ServerDoc_EnumFormatEtc
 * -----------------------
 *
 * Return an enumerator which enumerates the data accepted/offered by
 *      the document.
 *      This routine is called via IDataObject::EnumFormatEtc.
 */
HRESULT ServerDoc_EnumFormatEtc(
		LPSERVERDOC             lpServerDoc,
		DWORD                   dwDirection,
		LPENUMFORMATETC FAR*    lplpenumFormatEtc
)
{
	LPOLEDOC lpOleDoc = (LPOLEDOC)lpServerDoc;
	LPOLEAPP  lpOleApp = (LPOLEAPP)g_lpApp;
	int nActualFmts;
	SCODE sc = S_OK;

	/* OLE2NOTE: the enumeration of formats for a data transfer
	**    document is not a static list. the list of formats offered
	**    may or may not include CF_LINKSOURCE depending on whether a
	**    moniker is available for our document. thus we can NOT use
	**    the default OLE enumerator which enumerates the formats that
	**    are registered for our app in the registration database.
	*/
	if (dwDirection == DATADIR_GET) {
		nActualFmts = lpOleApp->m_nDocGetFmts;

		/* If the document does not have a Moniker, then exclude
		**    CF_LINKSOURCE and CF_LINKSRCDESCRIPTOR from the list of
		**    formats available. these formats are deliberately listed
		**    last in the array of possible "Get" formats.
		*/
		if (! lpOleDoc->m_fLinkSourceAvail)
			nActualFmts -= 2;

		*lplpenumFormatEtc = OleStdEnumFmtEtc_Create(
				nActualFmts, lpOleApp->m_arrDocGetFmts);
		if (*lplpenumFormatEtc == NULL)
			sc = E_OUTOFMEMORY;

	} else if (dwDirection == DATADIR_SET) {
		/* OLE2NOTE: a document that is used to transfer data
		**    (either via the clipboard or drag/drop does NOT
		**    accept SetData on ANY format!
		*/
		sc = E_NOTIMPL;
		goto error;
	} else {
		sc = E_INVALIDARG;
		goto error;
	}

error:
	return ResultFromScode(sc);
}


/* ServerDoc_GetMetafilePictData
 * -----------------------------
 *
 * Return a handle to an object's picture data in metafile format.
 *
 *
 * RETURNS: A handle to the object's data in metafile format.
 *
 */
HGLOBAL ServerDoc_GetMetafilePictData(
		LPSERVERDOC         lpServerDoc,
		LPLINERANGE         lplrSel
)
{
	LPOUTLINEAPP    lpOutlineApp = (LPOUTLINEAPP)g_lpApp;
	LPOUTLINEDOC    lpOutlineDoc=(LPOUTLINEDOC)lpServerDoc;
	LPLINELIST      lpLL=(LPLINELIST)&lpOutlineDoc->m_LineList;
	LPLINE          lpLine;
	LPMETAFILEPICT  lppict = NULL;
	HGLOBAL         hMFPict = NULL;
	HMETAFILE       hMF = NULL;
	RECT            rect;
	RECT            rectWBounds;
	HDC             hDC;
	int             i;
	int             nWidth;
	int     nStart = (lplrSel ? lplrSel->m_nStartLine : 0);
	int     nEnd =(lplrSel ? lplrSel->m_nEndLine : LineList_GetCount(lpLL)-1);
	int     nLines = nEnd - nStart + 1;
	UINT    fuAlign;
	POINT point;
	SIZE  size;

	hDC = CreateMetaFile(NULL);

	rect.left = 0;
	rect.right = 0;
	rect.bottom = 0;

	if (nLines > 0) {
	// calculate the total height/width of LineList in HIMETRIC
		for(i = nStart; i <= nEnd; i++) {
			lpLine = LineList_GetLine(lpLL,i);
			if (! lpLine)
				continue;

			nWidth = Line_GetTotalWidthInHimetric(lpLine);
			rect.right = max(rect.right, nWidth);
			rect.bottom -= Line_GetHeightInHimetric(lpLine);
		}


		SetMapMode(hDC, MM_ANISOTROPIC);

		SetWindowOrgEx(hDC, 0, 0, &point);
		SetWindowExtEx(hDC, rect.right, rect.bottom, &size);
		rectWBounds = rect;

		// Set the default font size, and font face name
		SelectObject(hDC, OutlineApp_GetActiveFont(lpOutlineApp));

		FillRect(hDC, (LPRECT) &rect, GetStockObject(WHITE_BRUSH));

		rect.bottom = 0;

		fuAlign = SetTextAlign(hDC, TA_LEFT | TA_TOP | TA_NOUPDATECP);

		/* While more lines print out the text */
		for(i = nStart; i <= nEnd; i++) {
			lpLine = LineList_GetLine(lpLL,i);
			if (! lpLine)
				continue;

			rect.top = rect.bottom;
			rect.bottom -= Line_GetHeightInHimetric(lpLine);

			/* Draw the line */
			Line_Draw(lpLine, hDC, &rect, &rectWBounds, FALSE /*fHighlight*/);
		}

		SetTextAlign(hDC, fuAlign);
	}

	// Get handle to the metafile.
	if (!(hMF = CloseMetaFile (hDC)))
		return NULL;

	if (!(hMFPict = GlobalAlloc (GMEM_SHARE | GMEM_ZEROINIT,
					sizeof (METAFILEPICT)))) {
		DeleteMetaFile (hMF);
		return NULL;
	}

	if (!(lppict = (LPMETAFILEPICT)GlobalLock(hMFPict))) {
		DeleteMetaFile (hMF);
		GlobalFree (hMFPict);
		return NULL;
	}

	lppict->mm   =  MM_ANISOTROPIC;
	lppict->hMF  =  hMF;
	lppict->xExt =  rect.right;
	lppict->yExt =  - rect.bottom;  // add minus sign to make it +ve
	GlobalUnlock (hMFPict);

	return hMFPict;
}

#endif  // OLE_SERVER



#if defined( OLE_CNTR )

/*************************************************************************
** ContainerDoc Supprt Functions Used by Container versions
*************************************************************************/


/* Paste OLE Link from clipboard */
void ContainerDoc_PasteLinkCommand(LPCONTAINERDOC lpContainerDoc)
{
	LPOUTLINEAPP    lpOutlineApp = (LPOUTLINEAPP)g_lpApp;
	LPOLEAPP        lpOleApp = (LPOLEAPP)g_lpApp;
	LPDATAOBJECT    lpClipboardDataObj = NULL;
	BOOL            fLink = TRUE;
	BOOL            fLocalDataObj = FALSE;
	BOOL            fDisplayAsIcon = FALSE;
	SIZEL           sizelInSrc;
	HCURSOR         hPrevCursor;
	HGLOBAL         hMem = NULL;
	HGLOBAL         hMetaPict = NULL;
	STGMEDIUM       medium;
	BOOL            fStatus;
	HRESULT         hrErr;

	hrErr = OleGetClipboard((LPDATAOBJECT FAR*)&lpClipboardDataObj);
	if (hrErr != NOERROR)
		return;     // Clipboard seems to be empty or can't be accessed

	// this may take a while, put up hourglass cursor
	hPrevCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));

	/* check if the data on the clipboard is local to our application
	**    instance.
	*/
	if (lpOutlineApp->m_lpClipboardDoc) {
		LPOLEDOC lpOleDoc = (LPOLEDOC)lpOutlineApp->m_lpClipboardDoc;
		if (lpClipboardDataObj == (LPDATAOBJECT)&lpOleDoc->m_DataObject)
			fLocalDataObj = TRUE;
	}

	/* OLE2NOTE: we need to check what dwDrawAspect is being
	**    transfered. if the data is an object that is displayed as an
	**    icon in the source, then we want to keep it as an icon. the
	**    aspect the object is displayed in at the source is transfered
	**    via the CF_LINKSOURCEDESCRIPTOR format for a PasteLink
	**    operation.
	*/
	if (hMem = OleStdGetData(
			lpClipboardDataObj,
			lpOleApp->m_cfLinkSrcDescriptor,
			NULL,
			DVASPECT_CONTENT,
			(LPSTGMEDIUM)&medium)) {
		LPOBJECTDESCRIPTOR lpOD = GlobalLock(hMem);
		fDisplayAsIcon = (lpOD->dwDrawAspect == DVASPECT_ICON ? TRUE : FALSE);
		sizelInSrc = lpOD->sizel;   // size of object/picture in source (opt.)
		GlobalUnlock(hMem);
		ReleaseStgMedium((LPSTGMEDIUM)&medium);     // equiv to GlobalFree

		if (fDisplayAsIcon) {
			hMetaPict = OleStdGetData(
					lpClipboardDataObj,
					CF_METAFILEPICT,
					NULL,
					DVASPECT_ICON,
					(LPSTGMEDIUM)&medium
			);
			if (hMetaPict == NULL)
				fDisplayAsIcon = FALSE; // give up; failed to get icon MFP
		}
	}

	fStatus = ContainerDoc_PasteFormatFromData(
			lpContainerDoc,
			lpOleApp->m_cfLinkSource,
			lpClipboardDataObj,
			fLocalDataObj,
			fLink,
			fDisplayAsIcon,
			hMetaPict,
			(LPSIZEL)&sizelInSrc
	);

	if (!fStatus)
		OutlineApp_ErrorMessage(g_lpApp, ErrMsgPasting);

	if (hMetaPict)
		ReleaseStgMedium((LPSTGMEDIUM)&medium);  // properly free METAFILEPICT

	if (lpClipboardDataObj)
		OleStdRelease((LPUNKNOWN)lpClipboardDataObj);

	SetCursor(hPrevCursor);     // restore original cursor
}


/* ContainerDoc_PasteFormatFromData
** --------------------------------
**
**    Paste a particular data format from a IDataObject*. The
**    IDataObject* may come from the clipboard (GetClipboard) or from a
**    drag/drop operation.
**
**    Returns TRUE if data was successfully pasted.
**            FALSE if data could not be pasted.
*/
BOOL ContainerDoc_PasteFormatFromData(
		LPCONTAINERDOC          lpContainerDoc,
		CLIPFORMAT              cfFormat,
		LPDATAOBJECT            lpSrcDataObj,
		BOOL                    fLocalDataObj,
		BOOL                    fLink,
		BOOL                    fDisplayAsIcon,
		HGLOBAL                 hMetaPict,
		LPSIZEL                 lpSizelInSrc
)
{
	LPLINELIST lpLL = (LPLINELIST)&((LPOUTLINEDOC)lpContainerDoc)->m_LineList;
	LPOUTLINEAPP    lpOutlineApp = (LPOUTLINEAPP)g_lpApp;
	LPOLEAPP        lpOleApp = (LPOLEAPP)g_lpApp;
	LPCONTAINERAPP  lpContainerApp = (LPCONTAINERAPP)g_lpApp;
	int             nIndex;
	int             nCount = 0;
	HGLOBAL         hData;
	STGMEDIUM       medium;
	FORMATETC       formatetc;
	HRESULT         hrErr;
	LINERANGE       lrSel;

	if (LineList_GetCount(lpLL) == 0)
		nIndex = -1;    // pasting to empty list
	else
		nIndex=LineList_GetFocusLineIndex(lpLL);

	if (fLink) {

		/* We should paste a Link to the data */

		if (cfFormat != lpOleApp->m_cfLinkSource)
			return FALSE;   // we only support OLE object type links

		nCount = ContainerDoc_PasteOleObject(
				lpContainerDoc,
				lpSrcDataObj,
				OLECREATEFROMDATA_LINK,
				cfFormat,
				nIndex,
				fDisplayAsIcon,
				hMetaPict,
				lpSizelInSrc
			);
		return (nCount > 0 ? TRUE : FALSE);

	} else {

		if (cfFormat == lpContainerApp->m_cfCntrOutl) {
			if (fLocalDataObj) {

				/* CASE I: IDataObject* is local to our app
				**
				**    if the source of the data is local to our
				**    application instance, then we can get direct
				**    access to the original OleDoc object that
				**    corresponds to the IDataObject* given.
				**    CF_CNTROUTL data is passed through a LPSTORAGE.
				**    if we call OleGetData asking for CF_CNTROUTL, we
				**    will be returned a copy of the existing open pStg
				**    of the original source document. we can NOT open
				**    streams and sub-storages again via this pStg
				**    since it is already open within our same
				**    application instance. we must copy the data from
				**    the original OleDoc source document.
				*/
				LPLINELIST lpSrcLL;
				LPOLEDOC lpLocalSrcDoc =
					((struct CDocDataObjectImpl FAR*)lpSrcDataObj)->lpOleDoc;

				/* copy all lines from SrcDoc to DestDoc. */
				lpSrcLL = &((LPOUTLINEDOC)lpLocalSrcDoc)->m_LineList;
				nCount = LineList_CopySelToDoc(
						lpSrcLL,
						NULL,
						(LPOUTLINEDOC)lpContainerDoc
				);

			} else {

				/* CASE II: IDataObject* is NOT local to our app
				**
				**    if the source of the data comes from another
				**    application instance. we can call GetDataHere to
				**    retrieve the CF_CNTROUTL data. CF_CNTROUTL data
				**    is passed through a LPSTORAGE. we MUST use
				**    IDataObject::GetDataHere. calling
				**    IDataObject::GetData does NOT work because OLE
				**    currently does NOT support remoting of a callee
				**    allocated root storage back to the caller. this
				**    hopefully will be supported in a future version.
				**    in order to call GetDataHere we must allocate an
				**    IStorage instance for the callee to write into.
				**    we will allocate an IStorage docfile that will
				**    delete-on-release. we could use either a
				**    memory-based storage or a file-based storage.
				*/
				LPSTORAGE lpTmpStg = OleStdCreateTempStorage(
						FALSE /*fUseMemory*/,
						STGM_READWRITE | STGM_TRANSACTED |STGM_SHARE_EXCLUSIVE
				);
				if (! lpTmpStg)
					return FALSE;

				formatetc.cfFormat = cfFormat;
				formatetc.ptd = NULL;
				formatetc.dwAspect = DVASPECT_CONTENT;
				formatetc.tymed = TYMED_ISTORAGE;
				formatetc.lindex = -1;

				medium.tymed = TYMED_ISTORAGE;
				medium.pstg = lpTmpStg;
				medium.pUnkForRelease = NULL;

				OLEDBG_BEGIN2("IDataObject::GetDataHere called\r\n")
				hrErr = lpSrcDataObj->lpVtbl->GetDataHere(
						lpSrcDataObj,
						(LPFORMATETC)&formatetc,
						(LPSTGMEDIUM)&medium
				);
				OLEDBG_END2

				if (hrErr == NOERROR) {
					nCount = ContainerDoc_PasteCntrOutlData(
							lpContainerDoc,
							lpTmpStg,
							nIndex
					);
				}
				OleStdVerifyRelease(
					(LPUNKNOWN)lpTmpStg, "Temp stg NOT released!\r\n");
				return ((hrErr == NOERROR) ? TRUE : FALSE);
			}

		} else if (cfFormat == lpOutlineApp->m_cfOutline) {

			hData = OleStdGetData(
					lpSrcDataObj,
					lpOutlineApp->m_cfOutline,
					NULL,
					DVASPECT_CONTENT,
					(LPSTGMEDIUM)&medium
			);
			nCount = OutlineDoc_PasteOutlineData(
					(LPOUTLINEDOC)lpContainerDoc,
					hData,
					nIndex
				);
			// OLE2NOTE: we must free data handle by releasing the medium
			ReleaseStgMedium((LPSTGMEDIUM)&medium);

		} else if (cfFormat == lpOleApp->m_cfEmbedSource ||
			cfFormat == lpOleApp->m_cfEmbeddedObject ||
			cfFormat == lpOleApp->m_cfFileName) {
			/* OLE2NOTE: OleCreateFromData API creates an OLE object if
			**    CF_EMBEDDEDOBJECT, CF_EMBEDSOURCE, or CF_FILENAME are
			**    available from the source data object. the
			**    CF_FILENAME case arises when a file is copied to the
			**    clipboard from the FileManager. if the file has an
			**    associated class (see GetClassFile API), then an
			**    object of that class is created. otherwise an OLE 1.0
			**    Packaged object is created.
			*/
			nCount = ContainerDoc_PasteOleObject(
					lpContainerDoc,
					lpSrcDataObj,
					OLECREATEFROMDATA_OBJECT,
					0,   /* N/A -- cfFormat */
					nIndex,
					fDisplayAsIcon,
					hMetaPict,
					lpSizelInSrc
			);
			return (nCount > 0 ? TRUE : FALSE);

		} else if (cfFormat == CF_METAFILEPICT
					|| cfFormat == CF_DIB
					|| cfFormat == CF_BITMAP) {

			/* OLE2NOTE: OleCreateStaticFromData API creates an static
			**    OLE object if CF_METAFILEPICT, CF_DIB, or CF_BITMAP is
			**    CF_EMBEDDEDOBJECT, CF_EMBEDSOURCE, or CF_FILENAME are
			**    available from the source data object.
			*/
			nCount = ContainerDoc_PasteOleObject(
					lpContainerDoc,
					lpSrcDataObj,
					OLECREATEFROMDATA_STATIC,
					cfFormat,
					nIndex,
					fDisplayAsIcon,
					hMetaPict,
					lpSizelInSrc
			);
			return (nCount > 0 ? TRUE : FALSE);

		} else if(cfFormat == CF_TEXT) {

			hData = OleStdGetData(
					lpSrcDataObj,
					CF_TEXT,
					NULL,
					DVASPECT_CONTENT,
					(LPSTGMEDIUM)&medium
			);
			nCount = OutlineDoc_PasteTextData(
					(LPOUTLINEDOC)lpContainerDoc,
					hData,
					nIndex
				);
			// OLE2NOTE: we must free data handle by releasing the medium
			ReleaseStgMedium((LPSTGMEDIUM)&medium);

		} else {
			return FALSE;   // no acceptable format available to paste
		}
	}

	lrSel.m_nStartLine = nIndex + nCount;
	lrSel.m_nEndLine = nIndex + 1;
	LineList_SetSel(lpLL, &lrSel);
	return TRUE;
}


/* ContainerDoc_PasteCntrOutlData
 * -------------------------------
 *
 *      Load the lines stored in a lpSrcStg (stored in CF_CNTROUTL format)
 *  into the document.
 *
 * Return the number of items added
 */
int ContainerDoc_PasteCntrOutlData(
		LPCONTAINERDOC          lpDestContainerDoc,
		LPSTORAGE               lpSrcStg,
		int                     nStartIndex
)
{
	int nCount;
	LPOUTLINEAPP lpOutlineApp = (LPOUTLINEAPP)g_lpApp;
	LPOUTLINEDOC lpDestOutlineDoc = (LPOUTLINEDOC)lpDestContainerDoc;
	LPOUTLINEDOC lpSrcOutlineDoc;
	LPLINELIST   lpSrcLL;

	// create a temp document that will be used to load the lpSrcStg data.
	lpSrcOutlineDoc = (LPOUTLINEDOC)OutlineApp_CreateDoc(lpOutlineApp, FALSE);
	if ( ! lpSrcOutlineDoc )
		return 0;

	if (! OutlineDoc_LoadFromStg(lpSrcOutlineDoc, lpSrcStg))
		goto error;

	/* copy all lines from the SrcDoc to the DestDoc. */
	lpSrcLL = &lpSrcOutlineDoc->m_LineList;
	nCount = LineList_CopySelToDoc(lpSrcLL, NULL, lpDestOutlineDoc);

	if (lpSrcOutlineDoc)            // destroy temporary document.
		OutlineDoc_Close(lpSrcOutlineDoc, OLECLOSE_NOSAVE);

	return nCount;

error:
	if (lpSrcOutlineDoc)            // destroy temporary document.
		OutlineDoc_Close(lpSrcOutlineDoc, OLECLOSE_NOSAVE);

	return 0;
}


/* ContainerDoc_QueryPasteFromData
** -------------------------------
**
**    Check if the IDataObject* offers data in a format that we can
**    paste. The IDataObject* may come from the clipboard
**    (GetClipboard) or from a drag/drop operation.
**    In this function we look if one of the following formats is
**    offered:
**              CF_OUTLINE
**              <OLE object -- CF_EMBEDSOURCE or CF_EMBEDDEDOBJECT>
**              CF_TEXT
**
**    NOTE: fLink is specified and CF_LINKSOURCE is available then TRUE
**    is returned, else FALSE.
**
**    Returns TRUE if paste can be performed
**            FALSE if paste is not possible.
*/
BOOL ContainerDoc_QueryPasteFromData(
		LPCONTAINERDOC          lpContainerDoc,
		LPDATAOBJECT            lpSrcDataObj,
		BOOL                    fLink
)
{
	LPOLEAPP lpOleApp = (LPOLEAPP)g_lpApp;

	if (fLink) {
		/* check if we can paste a Link to the data */
		if (OleQueryLinkFromData(lpSrcDataObj) != NOERROR)
			return FALSE;   // linking is NOT possible
	} else {

		int nFmtEtc;

		nFmtEtc = OleStdGetPriorityClipboardFormat(
				lpSrcDataObj,
				lpOleApp->m_arrPasteEntries,
				lpOleApp->m_nPasteEntries
			);

		if (nFmtEtc < 0)
			return FALSE;   // there is no format we like
	}

	return TRUE;
}


/* ContainerDoc_PasteOleObject
** ---------------------------
**
**    Embed or link an OLE object. the source of the data is a pointer
**    to an IDataObject. normally this lpSrcDataObj comes from the
**    clipboard after call OleGetClipboard.
**
**    dwCreateType controls what type of object will created:
**    OLECREATEFROMDATA_LINK -- OleCreateLinkFromData will be called
**    OLECREATEFROMDATA_OBJECT -- OleCreateFromData will be called
**    OLECREATEFROMDATA_STATIC -- OleCreateStaticFromData will be called
**                                  cfFormat controls the type of static
**    a CONTAINERLINE object is created to manage the OLE object. this
**    CONTAINERLINE is added to the ContainerDoc after line nIndex.
**
*/
int ContainerDoc_PasteOleObject(
		LPCONTAINERDOC          lpContainerDoc,
		LPDATAOBJECT            lpSrcDataObj,
		DWORD                   dwCreateType,
		CLIPFORMAT              cfFormat,
		int                     nIndex,
		BOOL                    fDisplayAsIcon,
		HGLOBAL                 hMetaPict,
		LPSIZEL                 lpSizelInSrc
)
{
	LPLINELIST          lpLL = &((LPOUTLINEDOC)lpContainerDoc)->m_LineList;
	LPLINE              lpLine = NULL;
	HDC                 hDC;
	int                 nTab = 0;
	char                szStgName[CWCSTORAGENAME];
	LPCONTAINERLINE     lpContainerLine = NULL;

	ContainerDoc_GetNextStgName(lpContainerDoc, szStgName, sizeof(szStgName));

	/* default the new line to have the same indent as previous line */
	lpLine = LineList_GetLine(lpLL, nIndex);
	if (lpLine)
		nTab = Line_GetTabLevel(lpLine);

	hDC = LineList_GetDC(lpLL);

	lpContainerLine = ContainerLine_CreateFromData(
			hDC,
			nTab,
			lpContainerDoc,
			lpSrcDataObj,
			dwCreateType,
			cfFormat,
			fDisplayAsIcon,
			hMetaPict,
			szStgName
		);
	LineList_ReleaseDC(lpLL, hDC);

	if (! lpContainerLine)
		goto error;

	/* add a ContainerLine object to the document's LineList. The
	**    ContainerLine manages the rectangle on the screen occupied by
	**    the OLE object. later when the app is updated to support
	**    extended layout, there could be more than one Line associated
	**    with the OLE object.
	*/

	LineList_AddLine(lpLL, (LPLINE)lpContainerLine, nIndex);

	/* OLE2NOTE: if the source of the OLE object just pasted, passed a
	**    non-zero sizel in the ObjectDescriptor, then we will try to
	**    keep the object the same size as it is in the source. this
	**    may be a scaled size if the object had been resized in the
	**    source container. if the source did not give a valid sizel,
	**    then we will retrieve the size of the object by calling
	**    IViewObject2::GetExtent.
	*/
	if (lpSizelInSrc && (lpSizelInSrc->cx != 0 || lpSizelInSrc->cy != 0)) {
		ContainerLine_UpdateExtent(lpContainerLine, lpSizelInSrc);
	} else
		ContainerLine_UpdateExtent(lpContainerLine, NULL);

	OutlineDoc_SetModified((LPOUTLINEDOC)lpContainerDoc, TRUE, TRUE, TRUE);

	return 1;   // one line added to LineList

error:
	// NOTE: if ContainerLine_CreateFromClip failed
	OutlineApp_ErrorMessage(g_lpApp, "Paste Object failed!");
	return 0;       // no lines added to line list
}


/* ContainerDoc_GetData
 * --------------------
 *
 * Render data from the document on a CALLEE allocated STGMEDIUM.
 *      This routine is called via IDataObject::GetData.
 */
HRESULT ContainerDoc_GetData (
		LPCONTAINERDOC          lpContainerDoc,
		LPFORMATETC             lpformatetc,
		LPSTGMEDIUM             lpMedium
)
{
	LPOLEDOC  lpOleDoc = (LPOLEDOC)lpContainerDoc;
	LPOUTLINEDOC  lpOutlineDoc = (LPOUTLINEDOC)lpContainerDoc;
	LPCONTAINERAPP lpContainerApp = (LPCONTAINERAPP)g_lpApp;
	LPOLEAPP  lpOleApp = (LPOLEAPP)lpContainerApp;
	LPOUTLINEAPP  lpOutlineApp = (LPOUTLINEAPP)lpContainerApp;
	HRESULT hrErr;
	SCODE sc;

	// OLE2NOTE: we must set out pointer parameters to NULL
	lpMedium->pUnkForRelease = NULL;

	/* OLE2NOTE: we must set all out pointer parameters to NULL. */
	lpMedium->tymed = TYMED_NULL;
	lpMedium->pUnkForRelease = NULL;    // we transfer ownership to caller
	lpMedium->hGlobal = NULL;

	if (lpformatetc->cfFormat == lpContainerApp->m_cfCntrOutl) {

		/* OLE2NOTE: currently OLE does NOT support remoting a root
		**    level IStorage (either memory or file based) as an OUT
		**    parameter. thus, we can NOT support GetData for this
		**    TYMED_ISTORAGE based format. the caller MUST call GetDataHere.
		*/
		sc = DV_E_FORMATETC;
		goto error;

	} else if (!lpContainerDoc->m_fEmbeddedObjectAvail &&
			lpformatetc->cfFormat == lpOutlineApp->m_cfOutline) {
		// Verify caller asked for correct medium
		if (!(lpformatetc->tymed & TYMED_HGLOBAL)) {
			sc = DV_E_FORMATETC;
			goto error;
		}

		lpMedium->hGlobal = OutlineDoc_GetOutlineData(lpOutlineDoc, NULL);
		if (! lpMedium->hGlobal) {
			sc = E_OUTOFMEMORY;
			goto error;
		}

		lpMedium->tymed = TYMED_HGLOBAL;
		OleDbgOut3("ContainerDoc_GetData: rendered CF_OUTLINE\r\n");
		return NOERROR;

	} else if (!lpContainerDoc->m_fEmbeddedObjectAvail &&
			lpformatetc->cfFormat == CF_TEXT) {
		// Verify caller asked for correct medium
		if (!(lpformatetc->tymed & TYMED_HGLOBAL)) {
			sc = DV_E_FORMATETC;
			goto error;
		}

		lpMedium->hGlobal = OutlineDoc_GetTextData (
				(LPOUTLINEDOC)lpContainerDoc,
				NULL
		);
		if (! lpMedium->hGlobal) {
			sc = E_OUTOFMEMORY;
			goto error;
		}

		lpMedium->tymed = TYMED_HGLOBAL;
		OleDbgOut3("ContainerDoc_GetData: rendered CF_TEXT\r\n");
		return NOERROR;

	} else if ( lpformatetc->cfFormat == lpOleApp->m_cfObjectDescriptor ||
		(lpformatetc->cfFormat == lpOleApp->m_cfLinkSrcDescriptor &&
			lpOleDoc->m_fLinkSourceAvail) ) {
		// Verify caller asked for correct medium
		if (!(lpformatetc->tymed & TYMED_HGLOBAL)) {
			sc = DV_E_FORMATETC;
			goto error;
		}

		lpMedium->hGlobal = OleDoc_GetObjectDescriptorData (
				(LPOLEDOC)lpContainerDoc,
				NULL
		);
		if (! lpMedium->hGlobal) {
			sc = E_OUTOFMEMORY;
			goto error;
		}

		lpMedium->tymed = TYMED_HGLOBAL;
#if defined( _DEBUG )
		if (lpformatetc->cfFormat == lpOleApp->m_cfObjectDescriptor)
			OleDbgOut3(
				"ContainerDoc_GetData: rendered CF_OBJECTDESCRIPTOR\r\n");
		else
			OleDbgOut3(
				"ContainerDoc_GetData: rendered CF_LINKSRCDESCRIPTOR\r\n");
#endif
		return NOERROR;

	} else if (lpContainerDoc->m_fEmbeddedObjectAvail) {

		/* OLE2NOTE: if this document contains a single OLE object
		**    (ie. cfEmbeddedObject data format is available), then
		**    the formats offered via our IDataObject must include
		**    the formats available from the OLE object itself.
		**    thus, we delegate this call to the IDataObject* of the
		**    OLE object.
		*/

		if (lpformatetc->cfFormat == lpOleApp->m_cfEmbeddedObject) {
			LPPERSISTSTORAGE lpPersistStg =
					(LPPERSISTSTORAGE)ContainerDoc_GetSingleOleObject(
							lpContainerDoc,
							&IID_IPersistStorage,
							NULL
			);

			if (! lpPersistStg)
				return ResultFromScode(DV_E_FORMATETC);

			/* render CF_EMBEDDEDOBJECT by asking the object to save
			**    into a temporary, DELETEONRELEASE pStg allocated by us.
			*/

			hrErr = OleStdGetOleObjectData(
					lpPersistStg,
					lpformatetc,
					lpMedium,
					FALSE   /* fUseMemory -- (use file-base stg) */
			);
			OleStdRelease((LPUNKNOWN)lpPersistStg);
			if (hrErr != NOERROR) {
				sc = GetScode(hrErr);
				goto error;
			}
			OleDbgOut3("ContainerDoc_GetData: rendered CF_EMBEDDEDOBJECT\r\n");
			return hrErr;

		} else if (lpformatetc->cfFormat == CF_METAFILEPICT) {

			/* OLE2NOTE: as a container which draws objects, when a single
			**    OLE object is copied, we can give the Metafile picture of
			**    the object.
			*/
			LPCONTAINERLINE lpContainerLine;
			LPOLEOBJECT lpOleObj;
			SIZEL sizelOleObject;

			// Verify caller asked for correct medium
			if (!(lpformatetc->tymed & TYMED_MFPICT)) {
				sc = DV_E_FORMATETC;
				goto error;
			}

			lpOleObj = (LPOLEOBJECT)ContainerDoc_GetSingleOleObject(
					lpContainerDoc,
					&IID_IOleObject,
					(LPCONTAINERLINE FAR*)&lpContainerLine
			);

			if (! lpOleObj) {
				sc = E_OUTOFMEMORY;     // could not load object
				goto error;
			}
			if (lpformatetc->dwAspect & lpContainerLine->m_dwDrawAspect) {
				LPLINE lpLine = (LPLINE)lpContainerLine;

				/* render CF_METAFILEPICT by drawing the object into
				**    a metafile DC
				*/

				/* OLE2NOTE: Get size that object is being drawn. If the
				**    object has been scaled because the user resized the
				**    object, then we want to render a metafile with the
				**    scaled size.
				*/
				sizelOleObject.cx = lpLine->m_nWidthInHimetric;
				sizelOleObject.cy = lpLine->m_nHeightInHimetric;

				lpMedium->hGlobal = OleStdGetMetafilePictFromOleObject(
						lpOleObj,
						lpContainerLine->m_dwDrawAspect,
						(LPSIZEL)&sizelOleObject,
						lpformatetc->ptd
				);
				OleStdRelease((LPUNKNOWN)lpOleObj);
				if (! lpMedium->hGlobal) {
					sc = E_OUTOFMEMORY;
					goto error;
				}

				lpMedium->tymed = TYMED_MFPICT;
				OleDbgOut3("ContainerDoc_GetData: rendered CF_METAFILEPICT\r\n");
				return NOERROR;
			} else {
				// improper aspect requested
				OleStdRelease((LPUNKNOWN)lpOleObj);
				return ResultFromScode(DV_E_FORMATETC);
			}

		} else if (lpformatetc->cfFormat == lpOleApp->m_cfLinkSource) {
			if (lpOleDoc->m_fLinkSourceAvail) {
				LPMONIKER lpmk;

				lpmk = ContainerLine_GetFullMoniker(
						lpContainerDoc->m_lpSrcContainerLine,
						GETMONIKER_FORCEASSIGN
				);
				if (lpmk) {
					hrErr = OleStdGetLinkSourceData(
							lpmk,
							&lpContainerDoc->m_clsidOleObjCopied,
							lpformatetc,
							lpMedium
					);
					OleStdRelease((LPUNKNOWN)lpmk);
					if (hrErr != NOERROR) {
						sc = GetScode(hrErr);
						goto error;
					}
					OleDbgOut3("ContainerDoc_GetData: rendered CF_LINKSOURCE\r\n");
					return hrErr;
				} else {
					sc = DV_E_FORMATETC;
					goto error;
				}
			} else {
				sc = DV_E_FORMATETC;
				goto error;
			}

		}
#if defined( OPTIONAL_ADVANCED_DATA_TRANSFER )
		/* OLE2NOTE: optionally, a container that wants to have a
		**    potentially richer data transfer, can enumerate the data
		**    formats from the OLE object's cache and offer them too. if
		**    the object has a special handler, then it might be able to
		**    render additional data formats. in this case, the
		**    container must delegate the GetData call to the object if
		**    it does not directly support the format.
		**
		**    CNTROUTL does NOT enumerate the cache; it implements the
		**    simpler strategy of offering a static list of formats.
		**    thus the delegation is NOT required.
		*/
	  else {

			/* OLE2NOTE: we delegate this call to the IDataObject* of the
			**    OLE object.
			*/
			LPDATAOBJECT lpDataObj;

			lpDataObj = (LPDATAOBJECT)ContainerDoc_GetSingleOleObject(
					lpContainerDoc,
					&IID_IDataObject,
					NULL
			);

			if (! lpDataObj) {
				sc = DV_E_FORMATETC;
				goto error;
			}

			OLEDBG_BEGIN2("ContainerDoc_GetData: delegate to OLE obj\r\n")
			hrErr=lpDataObj->lpVtbl->GetData(lpDataObj,lpformatetc,lpMedium);
			OLEDBG_END2

			OleStdRelease((LPUNKNOWN)lpDataObj);
			return hrErr;
		}
#endif  // ! OPTIONAL_ADVANCED_DATA_TRANSFER

	}

	// if we get here then we do NOT support the requested format
	sc = DV_E_FORMATETC;

error:
	return ResultFromScode(sc);
}


/* ContainerDoc_GetDataHere
 * ------------------------
 *
 * Render data from the document on a CALLER allocated STGMEDIUM.
 *      This routine is called via IDataObject::GetDataHere.
 */
HRESULT ContainerDoc_GetDataHere (
		LPCONTAINERDOC          lpContainerDoc,
		LPFORMATETC             lpformatetc,
		LPSTGMEDIUM             lpMedium
)
{
	LPOLEDOC  lpOleDoc = (LPOLEDOC)lpContainerDoc;
	LPOUTLINEDOC  lpOutlineDoc = (LPOUTLINEDOC)lpContainerDoc;
	LPCONTAINERAPP lpContainerApp = (LPCONTAINERAPP)g_lpApp;
	LPOLEAPP  lpOleApp = (LPOLEAPP)lpContainerApp;
	LPOUTLINEAPP  lpOutlineApp = (LPOUTLINEAPP)lpContainerApp;
	HRESULT hrErr;

	// OLE2NOTE: lpMedium is an IN parameter. we should NOT set
	//           lpMedium->pUnkForRelease to NULL

	// we only support  IStorage medium
	if (lpformatetc->cfFormat == lpContainerApp->m_cfCntrOutl) {
		if (!(lpformatetc->tymed & TYMED_ISTORAGE))
			return ResultFromScode(DV_E_FORMATETC);

		if (lpMedium->tymed == TYMED_ISTORAGE) {
			/* Caller has allocated the storage. we must copy all of our
			**    data into his storage.
			*/

			/*  OLE2NOTE: we must be sure to write our class ID into our
			**    storage. this information is used by OLE to determine the
			**    class of the data stored in our storage.
			*/
			if((hrErr=WriteClassStg(lpMedium->pstg,&CLSID_APP)) != NOERROR)
				return hrErr;

			OutlineDoc_SaveSelToStg(
					(LPOUTLINEDOC)lpContainerDoc,
					NULL,   /* entire doc */
					lpContainerApp->m_cfCntrOutl,
					lpMedium->pstg,
					FALSE,  /* fSameAsLoad */
					FALSE   /* fRemember */
			);
			OleStdCommitStorage(lpMedium->pstg);

			OleDbgOut3("ContainerDoc_GetDataHere: rendered CF_CNTROUTL\r\n");
			return NOERROR;
		} else {
			// we only support IStorage medium
			return ResultFromScode(DV_E_FORMATETC);
		}

	} else if (lpContainerDoc->m_fEmbeddedObjectAvail) {

		/* OLE2NOTE: if this document contains a single OLE object
		**    (ie. cfEmbeddedObject data format is available), then
		**    the formats offered via our IDataObject must include
		**    CF_EMBEDDEDOBJECT and the formats available from the OLE
		**    object itself.
		*/

		if (lpformatetc->cfFormat == lpOleApp->m_cfEmbeddedObject) {
			LPPERSISTSTORAGE lpPersistStg =
					(LPPERSISTSTORAGE)ContainerDoc_GetSingleOleObject(
							lpContainerDoc,
							&IID_IPersistStorage,
							NULL
			);

			if (! lpPersistStg) {
				return ResultFromScode(E_OUTOFMEMORY);
			}
			/* render CF_EMBEDDEDOBJECT by asking the object to save
			**    into the IStorage allocated by the caller.
			*/

			hrErr = OleStdGetOleObjectData(
					lpPersistStg,
					lpformatetc,
					lpMedium,
					FALSE   /* fUseMemory -- N/A */
			);
			OleStdRelease((LPUNKNOWN)lpPersistStg);
			if (hrErr != NOERROR) {
				return hrErr;
			}
			OleDbgOut3("ContainerDoc_GetDataHere: rendered CF_EMBEDDEDOBJECT\r\n");
			return hrErr;

		} else if (lpformatetc->cfFormat == lpOleApp->m_cfLinkSource) {
			if (lpOleDoc->m_fLinkSourceAvail) {
				LPMONIKER lpmk;

				lpmk = ContainerLine_GetFullMoniker(
						lpContainerDoc->m_lpSrcContainerLine,
						GETMONIKER_FORCEASSIGN
				);
				if (lpmk) {
					hrErr = OleStdGetLinkSourceData(
							lpmk,
							&lpContainerDoc->m_clsidOleObjCopied,
							lpformatetc,
							lpMedium
					);
					OleStdRelease((LPUNKNOWN)lpmk);
					OleDbgOut3("ContainerDoc_GetDataHere: rendered CF_LINKSOURCE\r\n");
					return hrErr;
				} else {
					return ResultFromScode(E_FAIL);
				}
			} else {
				return ResultFromScode(DV_E_FORMATETC);
			}

		} else {
#if !defined( OPTIONAL_ADVANCED_DATA_TRANSFER )
			return ResultFromScode(DV_E_FORMATETC);
#endif
#if defined( OPTIONAL_ADVANCED_DATA_TRANSFER )
			/* OLE2NOTE: optionally, a container that wants to have a
			**    potentially richer data transfer, can enumerate the data
			**    formats from the OLE object's cache and offer them too. if
			**    the object has a special handler, then it might be able to
			**    render additional data formats. in this case, the
			**    container must delegate the GetData call to the object if
			**    it does not directly support the format.
			**
			**    CNTROUTL does NOT enumerate the cache; it implements the
			**    simpler strategy of offering a static list of formats.
			**    thus the delegation is NOT required.
			*/
			/* OLE2NOTE: we delegate this call to the IDataObject* of the
			**    OLE object.
			*/
			LPDATAOBJECT lpDataObj;

			lpDataObj = (LPDATAOBJECT)ContainerDoc_GetSingleOleObject(
					lpContainerDoc,
					&IID_IDataObject,
					NULL
			);

			if (! lpDataObj)
				return ResultFromScode(DV_E_FORMATETC);

			OLEDBG_BEGIN2("ContainerDoc_GetDataHere: delegate to OLE obj\r\n")
			hrErr = lpDataObj->lpVtbl->GetDataHere(
					lpDataObj,
					lpformatetc,
					lpMedium
			);
			OLEDBG_END2

			OleStdRelease((LPUNKNOWN)lpDataObj);
			return hrErr;
#endif  // OPTIONAL_ADVANCED_DATA_TRANSFER
		}
	} else {
		return ResultFromScode(DV_E_FORMATETC);
	}
}


/* ContainerDoc_QueryGetData
 * -------------------------
 *
 * Answer if a particular data format is supported via GetData/GetDataHere.
 *      This routine is called via IDataObject::QueryGetData.
 */
HRESULT ContainerDoc_QueryGetData (
		LPCONTAINERDOC          lpContainerDoc,
		LPFORMATETC             lpformatetc
)
{
	LPOLEDOC  lpOleDoc = (LPOLEDOC)lpContainerDoc;
	LPOUTLINEDOC  lpOutlineDoc = (LPOUTLINEDOC)lpContainerDoc;
	LPCONTAINERAPP lpContainerApp = (LPCONTAINERAPP)g_lpApp;
	LPOLEAPP  lpOleApp = (LPOLEAPP)lpContainerApp;
	LPOUTLINEAPP  lpOutlineApp = (LPOUTLINEAPP)lpContainerApp;
	LPDATAOBJECT  lpDataObj = NULL;
	LPCONTAINERLINE lpContainerLine = NULL;
	SCODE sc;
	HRESULT hrErr;

	if (lpContainerDoc->m_fEmbeddedObjectAvail) {
		lpDataObj = (LPDATAOBJECT)ContainerDoc_GetSingleOleObject(
					lpContainerDoc,
					&IID_IDataObject,
					(LPCONTAINERLINE FAR*)&lpContainerLine
		);
	}

	/* Caller is querying if we support certain format but does not
	**    want any data actually returned.
	*/
	if (lpformatetc->cfFormat == lpContainerApp->m_cfCntrOutl) {
		// we only support ISTORAGE medium
		sc = GetScode( OleStdQueryFormatMedium(lpformatetc, TYMED_ISTORAGE) );

	} else if (lpformatetc->cfFormat == lpOleApp->m_cfEmbeddedObject &&
			lpContainerDoc->m_fEmbeddedObjectAvail ) {
		sc = GetScode( OleStdQueryOleObjectData(lpformatetc) );

	} else if (lpformatetc->cfFormat == lpOleApp->m_cfLinkSource &&
			lpOleDoc->m_fLinkSourceAvail) {
		sc = GetScode( OleStdQueryLinkSourceData(lpformatetc) );

	// CF_TEXT and CF_OUTLINE are NOT supported when single object is copied
	} else if (!lpContainerDoc->m_fEmbeddedObjectAvail &&
			(lpformatetc->cfFormat == (lpOutlineApp)->m_cfOutline ||
			 lpformatetc->cfFormat == CF_TEXT) ) {
		// we only support HGLOBAL medium
		sc = GetScode( OleStdQueryFormatMedium(lpformatetc, TYMED_HGLOBAL) );

	} else if ( lpformatetc->cfFormat == lpOleApp->m_cfObjectDescriptor ||
		(lpformatetc->cfFormat == lpOleApp->m_cfLinkSrcDescriptor &&
			lpOleDoc->m_fLinkSourceAvail) ) {
		sc = GetScode( OleStdQueryObjectDescriptorData(lpformatetc) );

	} else if (lpformatetc->cfFormat == CF_METAFILEPICT &&
			lpContainerDoc->m_fEmbeddedObjectAvail && lpContainerLine &&
			(lpformatetc->dwAspect & lpContainerLine->m_dwDrawAspect)) {

		/* OLE2NOTE: as a container which draws objects, when a single
		**    OLE object is copied, we can give the Metafile picture of
		**    the object.
		*/
		// we only support MFPICT medium
		sc = GetScode( OleStdQueryFormatMedium(lpformatetc, TYMED_MFPICT) );

	} else if (lpDataObj) {

		/* OLE2NOTE: if this document contains a single OLE object
		**    (ie. cfEmbeddedObject data format is available), then
		**    the formats offered via our IDataObject must include
		**    the formats available from the OLE object itself.
		**    thus we delegate this call to the IDataObject* of the
		**    OLE object.
		*/
		OLEDBG_BEGIN2("ContainerDoc_QueryGetData: delegate to OLE obj\r\n")
		hrErr = lpDataObj->lpVtbl->QueryGetData(lpDataObj, lpformatetc);
		OLEDBG_END2

		sc = GetScode(hrErr);

	} else {
		sc = DV_E_FORMATETC;
	}

	if (lpDataObj)
		OleStdRelease((LPUNKNOWN)lpDataObj);
	return ResultFromScode(sc);
}



/* ContainerDoc_SetData
 * --------------------
 *
 * Set (modify) data of the document.
 *      This routine is called via IDataObject::SetData.
 */
HRESULT ContainerDoc_SetData (
		LPCONTAINERDOC          lpContainerDoc,
		LPFORMATETC             lpformatetc,
		LPSTGMEDIUM             lpmedium,
		BOOL                    fRelease
)
{
	/* in the container version of Outline, only DataTransferDoc's support
	**    IDataObject interface; the user documents do not support
	**    IDataObject. DataTransferDoc's do not accept SetData calls.
	*/
	return ResultFromScode(DV_E_FORMATETC);
}


/* ContainerDoc_EnumFormatEtc
 * --------------------------
 *
 * Return an enumerator which enumerates the data accepted/offered by
 *      the document.
 *      This routine is called via IDataObject::SetData.
 */
HRESULT ContainerDoc_EnumFormatEtc(
		LPCONTAINERDOC          lpContainerDoc,
		DWORD                   dwDirection,
		LPENUMFORMATETC FAR*    lplpenumFormatEtc
)
{
	LPOLEDOC lpOleDoc = (LPOLEDOC)lpContainerDoc;
	LPOUTLINEDOC lpOutlineDoc = (LPOUTLINEDOC)lpContainerDoc;
	LPOLEAPP  lpOleApp = (LPOLEAPP)g_lpApp;
	LPCONTAINERAPP lpContainerApp = (LPCONTAINERAPP)lpOleApp;
	int nActualFmts;
	int i;
	SCODE sc = S_OK;

	/* the Container-Only version of Outline does NOT offer
	**    IDataObject interface from its User documents.
	*/
	if (! lpOutlineDoc->m_fDataTransferDoc)
		return ResultFromScode(E_FAIL);

	if (dwDirection == DATADIR_GET) {
		if (lpContainerDoc->m_fEmbeddedObjectAvail) {

			/* OLE2NOTE: if this document contains a single OLE object
			**    (ie. cfEmbeddedObject data format is available), then
			**    the formats offered via our enumerator must include
			**    the formats available from the OLE object itself. we
			**    have previously set up a special array of FORMATETC's
			**    in OutlineDoc_CreateDataTransferDoc routine which includes
			**    the combination of data we offer directly and data
			**    offered by the OLE object.
			*/

			/* If the document does not have a Moniker, then exclude
			**    CF_LINKSOURCE CF_LINKSRCDESCRIPTOR from the list of
			**    formats available. these formats are deliberately
			**    listed last in the array of possible "Get" formats.
			*/
			nActualFmts = lpContainerApp->m_nSingleObjGetFmts;
			if (! lpOleDoc->m_fLinkSourceAvail)
				nActualFmts -= 2;

			// set correct dwDrawAspect for METAFILEPICT of object copied
			for (i = 0; i < nActualFmts; i++) {
				if (lpContainerApp->m_arrSingleObjGetFmts[i].cfFormat ==
															CF_METAFILEPICT) {
					lpContainerApp->m_arrSingleObjGetFmts[i].dwAspect =
							lpContainerDoc->m_dwAspectOleObjCopied;
					break;  // DONE
				}
			}
			*lplpenumFormatEtc = OleStdEnumFmtEtc_Create(
					nActualFmts, lpContainerApp->m_arrSingleObjGetFmts);
			if (*lplpenumFormatEtc == NULL)
				sc = E_OUTOFMEMORY;

		} else {

			/* This document does NOT offer cfEmbeddedObject,
			**    therefore we can simply enumerate the
			**    static list of formats that we handle directly.
			*/
			*lplpenumFormatEtc = OleStdEnumFmtEtc_Create(
					lpOleApp->m_nDocGetFmts, lpOleApp->m_arrDocGetFmts);
			if (*lplpenumFormatEtc == NULL)
				sc = E_OUTOFMEMORY;
		}
	} else if (dwDirection == DATADIR_SET) {
		/* OLE2NOTE: a document that is used to transfer data
		**    (either via the clipboard or drag/drop does NOT
		**    accept SetData on ANY format!
		*/
		sc = E_NOTIMPL;

	} else {
		sc = E_NOTIMPL;
	}

	return ResultFromScode(sc);
}


#if defined( OPTIONAL_ADVANCED_DATA_TRANSFER )
/* OLE2NOTE: optionally, a container that wants to have a
**    potentially richer data transfer, can enumerate the data
**    formats from the OLE object's cache and offer them too. if
**    the object has a special handler, then it might be able to
**    render additional data formats.
**
**    CNTROUTL does NOT enumerate the cache; it implements the simpler
**    strategy of offering a static list of formats. the following
**    function is included in order to illustrates how enumerating the
**    cache could be done. CNTROUTL does NOT call this function.
**
*/

/* ContainerDoc_SetupDocGetFmts
** ----------------------------
**    Setup the combined list of formats that this data transfer
**    ContainerDoc which contains a single OLE object should offer.
**
**    OLE2NOTE: The list of formats that should be offered when a
**    single OLE object is being transfered include the following:
**          * any formats the container app wants to give
**          * CF_EMBEDDEDOBJECT
**          * CF_METAFILEPICT
**          * any formats that the OLE object's cache can offer directly
**
**    We will offer the following formats in the order given:
**                  1. CF_CNTROUTL
**                  2. CF_EMBEDDEDOBJECT
**                  3. CF_OBJECTDESCRIPTOR
**                  4. CF_METAFILEPICT
**                  5. <data formats from OLE object's cache>
**                  6. CF_LINKSOURCE
**                  7. CF_LINKSRCDESCRIPTOR
*/
BOOL ContainerDoc_SetupDocGetFmts(
		LPCONTAINERDOC          lpContainerDoc,
		LPCONTAINERLINE         lpContainerLine
)
{
	LPOLEDOC lpOleDoc = (LPOLEDOC)lpContainerDoc;
	LPOLEAPP lpOleApp = (LPOLEAPP)g_lpApp;
	LPCONTAINERAPP lpContainerApp = (LPCONTAINERAPP)g_lpApp;
	LPOLECACHE lpOleCache;
	HRESULT hrErr;
	STATDATA        StatData;
	LPENUMSTATDATA  lpEnumStatData = NULL;
	LPFORMATETC lparrDocGetFmts = NULL;
	UINT nOleObjFmts = 0;
	UINT nTotalFmts;
	UINT i;
	UINT iFmt;

	lpOleCache = (LPOLECACHE)OleStdQueryInterface(
			(LPUNKNOWN)lpContainerLine->m_lpOleObj,
			&IID_IOleCache
	);
	if (lpOleCache) {
		OLEDBG_BEGIN2("IOleCache::EnumCache called\r\n")
		hrErr = lpOleCache->lpVtbl->EnumCache(
				lpOleCache,
				(LPENUMSTATDATA FAR*)&lpEnumStatData
		);
		OLEDBG_END2
	}

	if (lpEnumStatData) {
		/* Cache enumerator is available. count the number of
		**    formats that the OLE object's cache offers.
		*/
		while(lpEnumStatData->lpVtbl->Next(
					lpEnumStatData,
					1,
					(LPSTATDATA)&StatData,
					NULL) == NOERROR) {
			nOleObjFmts++;
			// OLE2NOTE: we MUST free the TargetDevice
			OleStdFree(StatData.formatetc.ptd);
		}
		lpEnumStatData->lpVtbl->Reset(lpEnumStatData);  // reset for next loop
	}

	/* OLE2NOTE: the maximum total number of formats that our IDataObject
	**    could offer equals the sum of the following:
	**          n offered by the OLE object's cache
	**       +  n normally offered by our app
	**       +  1 CF_EMBEDDEDOBJECT
	**       +  1 CF_METAFILEPICT
	**       +  1 CF_LINKSOURCE
	**       +  1 CF_LINKSRCDESCRIPTOR
	**    the actual number of formats that we can offer could be less
	**    than this total if there is any clash between the formats
	**    that we offer directly and those offered by the cache. if
	**    there is a clash, the container's rendering overrides that of
	**    the object. eg.: as a container transfering an OLE object we
	**    should directly offer CF_METAFILEPICT to guarantee that this
	**    format is always available. thus, if the cache offers
	**    CF_METAFILEPICT then it is skipped.
	*/
	nTotalFmts = nOleObjFmts + lpOleApp->m_nDocGetFmts + 4;
	lparrDocGetFmts = (LPFORMATETC)New (nTotalFmts * sizeof(FORMATETC));

	OleDbgAssertSz(lparrDocGetFmts != NULL,"Error allocating arrDocGetFmts");
	if (lparrDocGetFmts == NULL)
			return FALSE;

	for (i = 0, iFmt = 0; i < lpOleApp->m_nDocGetFmts; i++) {
		_fmemcpy((LPFORMATETC)&lparrDocGetFmts[iFmt++],
				(LPFORMATETC)&lpOleApp->m_arrDocGetFmts[i],
				sizeof(FORMATETC)
		);
		if (lpOleApp->m_arrDocGetFmts[i].cfFormat ==
			lpContainerApp->m_cfCntrOutl) {
			/* insert CF_EMBEDDEDOBJECT, CF_METAFILEPICT, and formats
			**    available from the OLE object's cache following
			**    CF_CNTROUTL.
			*/
			lparrDocGetFmts[iFmt].cfFormat = lpOleApp->m_cfEmbeddedObject;
			lparrDocGetFmts[iFmt].ptd      = NULL;
			lparrDocGetFmts[iFmt].dwAspect = DVASPECT_CONTENT;
			lparrDocGetFmts[iFmt].tymed    = TYMED_ISTORAGE;
			lparrDocGetFmts[iFmt].lindex   = -1;
			iFmt++;
			lparrDocGetFmts[iFmt].cfFormat = CF_METAFILEPICT;
			lparrDocGetFmts[iFmt].ptd      = NULL;
			lparrDocGetFmts[iFmt].dwAspect = lpContainerLine->m_dwDrawAspect;
			lparrDocGetFmts[iFmt].tymed    = TYMED_MFPICT;
			lparrDocGetFmts[iFmt].lindex   = -1;
			iFmt++;

			if (lpEnumStatData) {
				/* Cache enumerator is available. enumerate all of
				**    the formats that the OLE object's cache offers.
				*/
				while(lpEnumStatData->lpVtbl->Next(
						lpEnumStatData,
						1,
						(LPSTATDATA)&StatData,
						NULL) == NOERROR) {
					/* check if the format clashes with one of our fmts */
					if (StatData.formatetc.cfFormat != CF_METAFILEPICT
						&& ! OleStdIsDuplicateFormat(
								(LPFORMATETC)&StatData.formatetc,
								lpOleApp->m_arrDocGetFmts,
								lpOleApp->m_nDocGetFmts)) {
						OleStdCopyFormatEtc(
								&(lparrDocGetFmts[iFmt]),&StatData.formatetc);
						iFmt++;
					}
					// OLE2NOTE: we MUST free the TargetDevice
					OleStdFree(StatData.formatetc.ptd);
				}
			}
		}
	}

	if (lpOleCache)
		OleStdRelease((LPUNKNOWN)lpOleCache);

	/* append CF_LINKSOURCE format */
	lparrDocGetFmts[iFmt].cfFormat = lpOleApp->m_cfLinkSource;
	lparrDocGetFmts[iFmt].ptd      = NULL;
	lparrDocGetFmts[iFmt].dwAspect = DVASPECT_CONTENT;
	lparrDocGetFmts[iFmt].tymed    = TYMED_ISTREAM;
	lparrDocGetFmts[iFmt].lindex   = -1;
	iFmt++;

	/* append CF_LINKSRCDESCRIPTOR format */
	lparrDocGetFmts[iFmt].cfFormat = lpOleApp->m_cfLinkSrcDescriptor;
	lparrDocGetFmts[iFmt].ptd      = NULL;
	lparrDocGetFmts[iFmt].dwAspect = DVASPECT_CONTENT;
	lparrDocGetFmts[iFmt].tymed    = TYMED_HGLOBAL;
	lparrDocGetFmts[iFmt].lindex   = -1;
	iFmt++;

	lpContainerDoc->m_lparrDocGetFmts = lparrDocGetFmts;
	lpContainerDoc->m_nDocGetFmts = iFmt;

	if (lpEnumStatData)
		OleStdVerifyRelease(
				(LPUNKNOWN)lpEnumStatData,
				"Cache enumerator not released properly"
		);

	return TRUE;
}
#endif  // OPTIONAL_ADVANCED_DATA_TRANSFER

#endif  // OLE_CNTR
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\letest\outline\cntrinpl.c ===
/*************************************************************************
**
**    OLE 2 Container Sample Code
**
**    cntrinpl.c
**
**    This file contains all interfaces, methods and related support
**    functions for an In-Place Container application (aka. Visual
**    Editing). The in-place Container application includes the following
**    implementation objects:
**
**    ContainerApp Object
**      exposed interfaces:
**          IOleInPlaceFrame
**
**    ContainerDoc Object
**      support functions only
**      (ICntrOtl is an SDI app; it doesn't support a Doc level IOleUIWindow)
**
**    ContainerLin Object
**      exposed interfaces:
**          IOleInPlaceSite
**
**    (c) Copyright Microsoft Corp. 1992 - 1993 All Rights Reserved
**
*************************************************************************/

#include "outline.h"
#if defined( USE_STATUSBAR )
#include "status.h"
#endif

OLEDBGDATA

extern LPOUTLINEAPP g_lpApp;
extern BOOL g_fInsideOutContainer;
extern RECT g_rectNull;

/*************************************************************************
** ContainerApp::IOleInPlaceFrame interface implementation
*************************************************************************/

// IOleInPlaceFrame::QueryInterface
STDMETHODIMP CntrApp_IPFrame_QueryInterface(
		LPOLEINPLACEFRAME   lpThis,
		REFIID              riid,
		LPVOID FAR*         lplpvObj
)
{
	SCODE sc = E_NOINTERFACE;
	LPCONTAINERAPP lpContainerApp =
			((struct COleInPlaceFrameImpl FAR*)lpThis)->lpContainerApp;

	/* The object should not be able to access the other interfaces
	** of our App object by doing QI on this interface.
	*/
	*lplpvObj = NULL;
	if (IsEqualIID(riid, &IID_IUnknown) ||
		IsEqualIID(riid, &IID_IOleWindow) ||
		IsEqualIID(riid, &IID_IOleInPlaceUIWindow) ||
		IsEqualIID(riid, &IID_IOleInPlaceFrame)) {
		OleDbgOut4("CntrApp_IPFrame_QueryInterface: IOleInPlaceFrame* RETURNED\r\n");
		*lplpvObj = (LPVOID) &lpContainerApp->m_OleInPlaceFrame;
		OleApp_AddRef((LPOLEAPP)lpContainerApp);
		sc = S_OK;
	}

	OleDbgQueryInterfaceMethod(*lplpvObj);

	return ResultFromScode(sc);
}


// IOleInPlaceFrame::AddRef
STDMETHODIMP_(ULONG) CntrApp_IPFrame_AddRef(LPOLEINPLACEFRAME lpThis)
{
	OleDbgAddRefMethod(lpThis, "IOleInPlaceFrame");

	return OleApp_AddRef((LPOLEAPP)g_lpApp);
}


// IOleInPlaceFrame::Release
STDMETHODIMP_(ULONG) CntrApp_IPFrame_Release(LPOLEINPLACEFRAME lpThis)
{
	OleDbgReleaseMethod(lpThis, "IOleInPlaceFrame");

	return OleApp_Release((LPOLEAPP)g_lpApp);
}


// IOleInPlaceFrame::GetWindow
STDMETHODIMP CntrApp_IPFrame_GetWindow(
	LPOLEINPLACEFRAME   lpThis,
	HWND FAR*           lphwnd
)
{
	LPOUTLINEAPP lpOutlineApp = (LPOUTLINEAPP)g_lpApp;

	OLEDBG_BEGIN2("CntrApp_IPFrame_GetWindow\r\n")
	*lphwnd = lpOutlineApp->m_hWndApp;
	OLEDBG_END2
	return NOERROR;
}


// IOleInPlaceFrame::ContextSensitiveHelp
STDMETHODIMP CntrApp_IPFrame_ContextSensitiveHelp(
	LPOLEINPLACEFRAME   lpThis,
	BOOL                fEnterMode
)
{
	LPCONTAINERAPP lpContainerApp =
			((struct COleInPlaceFrameImpl FAR*)lpThis)->lpContainerApp;

	OleDbgOut("CntrApp_IPFrame_ContextSensitiveHelp\r\n");
	/* OLE2NOTE: see context sensitive help technote (CSHELP.DOC)
	**    This method is called when F1 is pressed when a menu item is
	**    selected. We set the frame's m_fMenuMode flag here. later,
	**    in WM_COMMAND processing in the AppWndProc, if this flag is
	**    set then the command is NOT executed and help is given
	**    instead.
	*/
	lpContainerApp->m_fMenuHelpMode = fEnterMode;

	return NOERROR;
}


// IOleInPlaceFrame::GetBorder
STDMETHODIMP CntrApp_IPFrame_GetBorder(
	LPOLEINPLACEFRAME   lpThis,
	LPRECT              lprectBorder
)
{
	LPOUTLINEAPP lpOutlineApp = (LPOUTLINEAPP)g_lpApp;

	OLEDBG_BEGIN2("CntrApp_IPFrame_GetBorder\r\n")

	OutlineApp_GetFrameRect(lpOutlineApp, lprectBorder);

	OLEDBG_END2
	return NOERROR;
}


// IOleInPlaceFrame::RequestBorderSpace
STDMETHODIMP CntrApp_IPFrame_RequestBorderSpace(
	LPOLEINPLACEFRAME   lpThis,
	LPCBORDERWIDTHS     lpWidths
)
{
#if defined( _DEBUG )
	OleDbgOut2("CntrApp_IPFrame_RequestBorderSpace\r\n");

	{
		/* FOR DEBUGING PURPOSES ONLY -- we will fail to allow to an
		**    object to get any frame border space for frame tools if
		**    our own frame tools are poped up in the tool pallet. this
		**    is NOT recommended UI behavior but it allows us to test
		**    in the condition when the frame does not give border
		**    space for the object. an object in this situation must
		**    then either popup its tools in a floating pallet, do
		**    without the tools, or fail to in-place activate.
		*/
		LPCONTAINERAPP lpContainerApp =
				((struct COleInPlaceFrameImpl FAR*)lpThis)->lpContainerApp;
		LPFRAMETOOLS lpft = OutlineApp_GetFrameTools(
				(LPOUTLINEAPP)lpContainerApp);

		if (lpft->m_ButtonBar.m_nState == BARSTATE_POPUP &&
			lpft->m_FormulaBar.m_nState == BARSTATE_POPUP) {
			OleDbgOut3(
					"CntrApp_IPFrame_RequestBorderSpace: allow NO SPACE\r\n");
			return ResultFromScode(E_FAIL);
		}
	}
#endif  // _DEBUG

	/* OLE2NOTE: we allow the object to have as much border space as it
	**    wants.
	*/
	return NOERROR;
}


// IOleInPlaceFrame::SetBorderSpace
STDMETHODIMP CntrApp_IPFrame_SetBorderSpace(
	LPOLEINPLACEFRAME   lpThis,
	LPCBORDERWIDTHS     lpWidths
)
{
	LPCONTAINERAPP lpContainerApp =
			((struct COleInPlaceFrameImpl FAR*)lpThis)->lpContainerApp;
	OLEDBG_BEGIN2("CntrApp_IPFrame_SetBorderSpace\r\n")

	/* OLE2NOTE: this fMustResizeClientArea flag is used as part of our
	**    defensive programming for frame window resizing. when the
	**    frame window is resized,IOleInPlaceActiveObject::ResizeBorder
	**    is called the object should normally call back to renegotiate
	**    for frame-level tools space. if SetBorderSpace is called then
	**    our client area windows are properly resized. if the in-place
	**    active object does NOT call SetBorderSpace, then the
	**    container must take care to resize its client area windows
	**    itself (see ContainerDoc_FrameWindowResized)
	*/
	if (lpContainerApp->m_fMustResizeClientArea)
		lpContainerApp->m_fMustResizeClientArea = FALSE;

	if (lpWidths == NULL) {

		/* OLE2NOTE: IOleInPlaceSite::SetBorderSpace(NULL) is called
		**    when the in-place active object does NOT want any tool
		**    space. in this situation the in-place container should
		**    put up its tools.
		*/
		LPOUTLINEAPP lpOutlineApp = (LPOUTLINEAPP)lpContainerApp;
		LPCONTAINERDOC lpContainerDoc;

		lpContainerDoc =(LPCONTAINERDOC)OutlineApp_GetActiveDoc(lpOutlineApp);
		ContainerDoc_AddFrameLevelTools(lpContainerDoc);
	} else {

		// OLE2NOTE: you could do validation of borderwidths here
#if defined( _DEBUG )
		/* FOR DEBUGING PURPOSES ONLY -- we will fail to allow to an
		**    object to get any frame border space for frame tools if
		**    our own frame tools are poped up in the tool pallet. this
		**    is NOT recommended UI behavior but it allows us to test
		**    in the condition when the frame does not give border
		**    space for the object. an object in this situation must
		**    then either popup its tools in a floating pallet, do
		**    without the tools, or fail to in-place activate.
		*/
		LPFRAMETOOLS lpft = OutlineApp_GetFrameTools(
				(LPOUTLINEAPP)lpContainerApp);

		if ((lpft->m_ButtonBar.m_nState == BARSTATE_POPUP &&
			lpft->m_FormulaBar.m_nState == BARSTATE_POPUP) &&
			(lpWidths->top || lpWidths->bottom ||
				lpWidths->left || lpWidths->right) ) {
			OleDbgOut3("CntrApp_IPFrame_SetBorderSpace: allow NO SPACE\r\n");
			OLEDBG_END2

			OutlineApp_SetBorderSpace(
					(LPOUTLINEAPP) lpContainerApp,
					(LPBORDERWIDTHS)&g_rectNull
			);
			OLEDBG_END2
			return ResultFromScode(E_FAIL);
		}
#endif  // _DEBUG

		OutlineApp_SetBorderSpace(
				(LPOUTLINEAPP) lpContainerApp,
				(LPBORDERWIDTHS)lpWidths
		);
	}
	OLEDBG_END2
	return NOERROR;
}


// IOleInPlaceFrame::SetActiveObject
STDMETHODIMP CntrApp_IPFrame_SetActiveObjectA(
	LPOLEINPLACEFRAME           lpThis,
	LPOLEINPLACEACTIVEOBJECT    lpActiveObject,
	LPCSTR                      lpszObjName
)
{
	LPCONTAINERAPP lpContainerApp = (LPCONTAINERAPP)g_lpApp;
	OLEDBG_BEGIN2("CntrApp_IPFrame_SetActiveObject\r\n")

	lpContainerApp->m_hWndUIActiveObj = NULL;

	if (lpContainerApp->m_lpIPActiveObj)
		lpContainerApp->m_lpIPActiveObj->lpVtbl->Release(lpContainerApp->m_lpIPActiveObj);

	if ((lpContainerApp->m_lpIPActiveObj = lpActiveObject) != NULL) {
		lpContainerApp->m_lpIPActiveObj->lpVtbl->AddRef(
				lpContainerApp->m_lpIPActiveObj);

		OLEDBG_BEGIN2("IOleInPlaceActiveObject::GetWindow called\r\n")
		lpActiveObject->lpVtbl->GetWindow(
				lpActiveObject,
				(HWND FAR*)&lpContainerApp->m_hWndUIActiveObj
		);
		OLEDBG_END2

		/* OLE2NOTE: see comment for ContainerDoc_ForwardPaletteChangedMsg */
		/* No need to do this if you don't allow object to own the palette */
		OleApp_QueryNewPalette((LPOLEAPP)lpContainerApp);
	}

	/* OLE2NOTE: the new UI Guidelines recommend that in-place
	**    containers do NOT change their window titles when an object
	**    becomes in-place (UI) active.
	*/

	OLEDBG_END2
	return NOERROR;
}


STDMETHODIMP CntrApp_IPFrame_SetActiveObject(
	LPOLEINPLACEFRAME           lpThis,
	LPOLEINPLACEACTIVEOBJECT    lpActiveObject,
	LPCOLESTR		    lpszObjName
)
{
    CREATESTR(pstr, lpszObjName)

    HRESULT hr = CntrApp_IPFrame_SetActiveObjectA(lpThis, lpActiveObject, pstr);

    FREESTR(pstr)

    return hr;
}


// IOleInPlaceFrame::InsertMenus
STDMETHODIMP CntrApp_IPFrame_InsertMenus(
	LPOLEINPLACEFRAME       lpThis,
	HMENU                   hMenu,
	LPOLEMENUGROUPWIDTHS    lpMenuWidths
)
{
	LPCONTAINERAPP lpContainerApp = (LPCONTAINERAPP)g_lpApp;
	BOOL    fNoError = TRUE;

	OLEDBG_BEGIN2("CntrApp_IPFrame_InsertMenus\r\n")

	fNoError &= AppendMenu(hMenu, MF_POPUP, (UINT)lpContainerApp->m_hMenuFile,
						"&File");
	fNoError &= AppendMenu(hMenu, MF_POPUP, (UINT)lpContainerApp->m_hMenuView,
						"O&utline");
	fNoError &= AppendMenu(hMenu, MF_POPUP,(UINT)lpContainerApp->m_hMenuDebug,
						"DbgI&Cntr");
	lpMenuWidths->width[0] = 1;
	lpMenuWidths->width[2] = 1;
	lpMenuWidths->width[4] = 1;

	OLEDBG_END2

	return (fNoError ? NOERROR : ResultFromScode(E_FAIL));
}


// IOleInPlaceFrame::SetMenu
STDMETHODIMP CntrApp_IPFrame_SetMenu(
	LPOLEINPLACEFRAME   lpThis,
	HMENU               hMenuShared,
	HOLEMENU            hOleMenu,
	HWND                hwndActiveObject
)
{
	LPCONTAINERAPP lpContainerApp = (LPCONTAINERAPP)g_lpApp;
	LPOUTLINEAPP lpOutlineApp = (LPOUTLINEAPP)g_lpApp;
	HMENU   hMenu;
	HRESULT hrErr;

	OLEDBG_BEGIN2("CntrApp_IPFrame_InsertMenus\r\n")


	/* OLE2NOTE: either put up the shared menu (combined menu from
	**    in-place server and in-place container) or our container's
	**    normal menu as directed.
	*/
	if (hOleMenu && hMenuShared)
		hMenu = hMenuShared;
	else
		hMenu = lpOutlineApp->m_hMenuApp;

	/* OLE2NOTE: SDI apps put menu on frame by calling SetMenu.
	**    MDI apps would send WM_MDISETMENU message instead.
	*/
	SetMenu (lpOutlineApp->m_hWndApp, hMenu);
	OLEDBG_BEGIN2("OleSetMenuDescriptor called\r\n")
	hrErr = OleSetMenuDescriptor (hOleMenu, lpOutlineApp->m_hWndApp,
					hwndActiveObject, NULL, NULL);
	OLEDBG_END2

	OLEDBG_END2
	return hrErr;
}


// IOleInPlaceFrame::RemoveMenus
STDMETHODIMP CntrApp_IPFrame_RemoveMenus(
	LPOLEINPLACEFRAME   lpThis,
	HMENU               hMenu
)
{
	LPCONTAINERAPP lpContainerApp = (LPCONTAINERAPP)g_lpApp;
	BOOL fNoError = TRUE;

	OLEDBG_BEGIN2("CntrApp_IPFrame_RemoveMenus\r\n")

	/* Remove container group menus */
	while (GetMenuItemCount(hMenu))
		fNoError &= RemoveMenu(hMenu, 0, MF_BYPOSITION);

	OleDbgAssert(fNoError == TRUE);

	OLEDBG_END2

	return (fNoError ? NOERROR : ResultFromScode(E_FAIL));
}


// IOleInPlaceFrame::SetStatusText
STDMETHODIMP CntrApp_IPFrame_SetStatusTextA(
	LPOLEINPLACEFRAME   lpThis,
	LPCSTR              lpszStatusText
)
{
#if defined( USE_STATUSBAR )
	LPOUTLINEAPP   lpOutlineApp = (LPOUTLINEAPP)g_lpApp;
	static char szMessageHold[128];
	OleDbgOut2("CntrApp_IPFrame_SetStatusText\r\n");

	/* OLE2NOTE: it is important to save a private copy of status text.
	**    lpszStatusText is only valid for the duration of this call.
	*/
	LSTRCPYN(szMessageHold, lpszStatusText, sizeof(szMessageHold));
	OutlineApp_SetStatusText(lpOutlineApp, (LPSTR)szMessageHold);

	return ResultFromScode(S_OK);
#else
	return ResultFromScode(E_NOTIMPL);
#endif  // USE_STATUSBAR
}


STDMETHODIMP CntrApp_IPFrame_SetStatusText(
	LPOLEINPLACEFRAME   lpThis,
	LPCOLESTR	    lpszStatusText
)
{
    CREATESTR(pstr, lpszStatusText)

    HRESULT hr = CntrApp_IPFrame_SetStatusTextA(lpThis, pstr);

    FREESTR(pstr)

    return hr;
}



// IOleInPlaceFrame::EnableModeless
STDMETHODIMP CntrApp_IPFrame_EnableModeless(
	LPOLEINPLACEFRAME   lpThis,
	BOOL                fEnable
)
{
	LPOLEAPP lpOleApp = (LPOLEAPP)
			((struct COleInPlaceFrameImpl FAR*)lpThis)->lpContainerApp;
#if defined( _DEBUG )
	if (fEnable)
		OleDbgOut2("CntrApp_IPFrame_EnableModeless(TRUE)\r\n");
	else
		OleDbgOut2("CntrApp_IPFrame_EnableModeless(FALSE)\r\n");
#endif  // _DEBUG

	/* OLE2NOTE: this method is called when an object puts up a modal
	**    dialog. it tells the top-level in-place container to disable
	**    it modeless dialogs for the duration that the object is
	**    displaying a modal dialog.
	**
	**    ICNTROTL does not use any modeless dialogs, thus we can
	**    ignore this method.
	*/
	return NOERROR;
}


// IOleInPlaceFrame::TranslateAccelerator
STDMETHODIMP CntrApp_IPFrame_TranslateAccelerator(
	LPOLEINPLACEFRAME   lpThis,
	LPMSG               lpmsg,
	WORD                wID
)
{
	LPOUTLINEAPP lpOutlineApp = (LPOUTLINEAPP)g_lpApp;
	LPCONTAINERAPP lpContainerApp = (LPCONTAINERAPP)g_lpApp;
	SCODE sc;

	if (TranslateAccelerator (lpOutlineApp->m_hWndApp,
						lpContainerApp->m_hAccelIPCntr, lpmsg))
		sc = S_OK;

#if defined (MDI_VERSION)
	else if (TranslateMDISysAccel(lpOutlineApp->m_hWndMDIClient, lpmsg))
		sc = S_OK;
#endif  // MDI_VERSION

	else
		sc = S_FALSE;

	return ResultFromScode(sc);
}



/*************************************************************************
** ContainerDoc Support Functions
*************************************************************************/


/* ContainerDoc_UpdateInPlaceObjectRects
** -------------------------------------
**    Update the PosRect and ClipRect of the currently in-place active
**    object. if there is no object active in-place, then do nothing.
**
**    OLE2NOTE: this function should be called when an action occurs
**    that changes either the position of the object in the document
**    (eg. changing document margins changes PosRect) or the clipRect
**    changes (eg. resizing the document window changes the ClipRect).
*/
void ContainerDoc_UpdateInPlaceObjectRects(LPCONTAINERDOC lpContainerDoc, int nIndex)
{
	LPLINELIST lpLL = &((LPOUTLINEDOC)lpContainerDoc)->m_LineList;
	int i;
	LPLINE lpLine;
	RECT rcClipRect;

	if (g_fInsideOutContainer) {

		if (lpContainerDoc->m_cIPActiveObjects) {

			/* OLE2NOTE: (INSIDE-OUT CONTAINER) we must update the
			**    PosRect/ClipRect for all in-place active objects
			**    starting from line "nIndex".
			*/
			ContainerDoc_GetClipRect(lpContainerDoc, (LPRECT)&rcClipRect);

#if defined( _DEBUG )
			OleDbgOutRect3(
					"ContainerDoc_UpdateInPlaceObjectRects (ClipRect)",
					(LPRECT)&rcClipRect
			);
#endif
			for (i = nIndex; i < lpLL->m_nNumLines; i++) {
				lpLine=LineList_GetLine(lpLL, i);

				if (lpLine && (Line_GetLineType(lpLine)==CONTAINERLINETYPE)) {
					LPCONTAINERLINE lpContainerLine = (LPCONTAINERLINE)lpLine;
					ContainerLine_UpdateInPlaceObjectRects(
							lpContainerLine, &rcClipRect);
				}
			}
		}
	}
	else {
		/* OLE2NOTE: (OUTSIDE-IN CONTAINER) if there is a currently
		**    UIActive object, we must inform it that the
		**    PosRect/ClipRect has now changed.
		*/
		LPCONTAINERLINE lpLastUIActiveLine =
				lpContainerDoc->m_lpLastUIActiveLine;
		if (lpLastUIActiveLine && lpLastUIActiveLine->m_fUIActive) {
			ContainerDoc_GetClipRect(lpContainerDoc, (LPRECT)&rcClipRect);

			OleDbgOutRect3("OutlineDoc_Resize (ClipRect)",(LPRECT)&rcClipRect);
			ContainerLine_UpdateInPlaceObjectRects(
					lpLastUIActiveLine, &rcClipRect);
		}
	}
}

/* ContainerDoc_IsUIDeactivateNeeded
** ---------------------------------
**    Check if it is necessary to UIDeactivate an in-place active
**    object upon a mouse LBUTTONDOWN event. The position of the button
**    down click is given by "pt".
**    If there is not currently an in-place active line, then
**    UIDeactivate is NOT needed.
**    If there is a current in-place active line, then check if the
**    point position is outside of the object extents on the screen. If
**    so, then the object should be UIDeactivated, otherwise not.
*/
BOOL ContainerDoc_IsUIDeactivateNeeded(
		LPCONTAINERDOC  lpContainerDoc,
		POINT           pt
)
{
	LPCONTAINERLINE lpUIActiveLine=lpContainerDoc->m_lpLastUIActiveLine;
	RECT rect;

	if (! lpUIActiveLine || ! lpUIActiveLine->m_fUIActive)
		return FALSE;

	ContainerLine_GetPosRect(
			lpUIActiveLine,
			(LPRECT) &rect
	);

	if (! PtInRect((LPRECT) &rect, pt))
		return TRUE;

	return FALSE;
}


/* ContainerDoc_ShutDownLastInPlaceServerIfNotNeeded
** -------------------------------------------------
**    OLE2NOTE: this function ONLY applies for OUTSIDE-IN containers
**
**    If there is a previous in-place active server still running and
**    this server will not be needed to support the next OLE object
**    about to be activated, then shut it down.
**    in this way we manage a policy of having at most one in-place
**    server running at a time. we do not imediately shut down the
**    in-place server when the object is UIDeactivated because we want
**    it to be fast if the server decides to re-activate the object
**    in-place.
**
**    shutting down the server is achieved by forcing the object to
**    transition from running to loaded by calling IOleObject::Close.
*/
void ContainerDoc_ShutDownLastInPlaceServerIfNotNeeded(
		LPCONTAINERDOC          lpContainerDoc,
		LPCONTAINERLINE         lpNextActiveLine
)
{
	LPCONTAINERLINE lpLastIpActiveLine = lpContainerDoc->m_lpLastIpActiveLine;
	BOOL fEnableServerShutDown = TRUE;
	LPMONIKER lpmkLinkSrc;
	LPMONIKER lpmkLastActiveObj;
	LPMONIKER lpmkCommonPrefix;
	LPOLELINK lpOleLink;
	HRESULT hrErr;

	/* OLE2NOTE: an inside-out style container can NOT use this scheme
	**    to shut down in-place servers. it would have to have a more
	**    sophistocated mechanism by which it keeps track of which
	**    objects are on screen and which were the last recently used.
	*/
	if (g_fInsideOutContainer)
		return;

	if (lpLastIpActiveLine != lpNextActiveLine) {
		if (lpLastIpActiveLine) {

			/* OLE2NOTE: if the object which is about to be activated is
			**    actually a link to the OLE object in last activated line,
			**    then we do NOT want to shut down the last activated
			**    server because it is about to be used. when activating a
			**    linked object, the source of the link gets activated.
			*/
			lpOleLink = (LPOLELINK)ContainerLine_GetOleObject(
					lpNextActiveLine,
					&IID_IOleLink
			);
			if (lpOleLink) {
				OLEDBG_BEGIN2("IOleObject::GetSourceMoniker called\r\n")
				lpOleLink->lpVtbl->GetSourceMoniker(
						lpOleLink,
						(LPMONIKER FAR*)&lpmkLinkSrc
				);
				OLEDBG_END2

				if (lpmkLinkSrc) {
					lpmkLastActiveObj = ContainerLine_GetFullMoniker(
							lpLastIpActiveLine,
							GETMONIKER_ONLYIFTHERE
					);
					if (lpmkLastActiveObj) {
						hrErr = lpmkLinkSrc->lpVtbl->CommonPrefixWith(
								lpmkLinkSrc,
								lpmkLastActiveObj,
								&lpmkCommonPrefix

						);
						if (GetScode(hrErr) == MK_S_HIM ||
                                hrErr == NOERROR ||
								GetScode(hrErr) == MK_S_US) {
							/* the link source IS to the object
							**    contained in the last activated
							**    line of the document; disable the
							**    attempt to shut down the last
							**    running in-place server.
							*/
							fEnableServerShutDown = FALSE;
						}
						if (lpmkCommonPrefix)
							OleStdRelease((LPUNKNOWN)lpmkCommonPrefix);
						OleStdRelease((LPUNKNOWN)lpmkLastActiveObj);
					}
					OleStdRelease((LPUNKNOWN)lpmkLinkSrc);
				}
				OleStdRelease((LPUNKNOWN)lpOleLink);
			}

			/* if it is OK to shut down the previous in-place server
			**    and one is still running, then shut it down. shutting
			**    down the server is accomplished by forcing the OLE
			**    object to close. this forces the object to transition
			**    from running to loaded. if the object is actually
			**    only loaded then this is a NOP.
			*/
			if (fEnableServerShutDown &&
					lpLastIpActiveLine->m_fIpServerRunning) {

				OleDbgOut1("@@@ previous in-place server SHUT DOWN\r\n");
				ContainerLine_CloseOleObject(
						lpLastIpActiveLine, OLECLOSE_SAVEIFDIRTY);

				// we can now forget this last in-place active line.
				lpContainerDoc->m_lpLastIpActiveLine = NULL;
			}
		}
	}
}


/* ContainerDoc_GetUIActiveWindow
** ------------------------------
**    If there is an UIActive object, then return its HWND.
*/
HWND ContainerDoc_GetUIActiveWindow(LPCONTAINERDOC lpContainerDoc)
{
	return lpContainerDoc->m_hWndUIActiveObj;
}


/* ContainerDoc_GetClipRect
** ------------------------
**    Get the ClipRect in client coordinates.
**
** OLE2NOTE: the ClipRect is defined as the maximum window rectangle
**    that the in-place active object must be clipped to. this
**    rectangle MUST be described in Client Coordinates of the window
**    that is used as the Parent of the in-place active object's
**    window. in our case, the LineList ListBox window is both the
**    parent of the in-place active object AND defines precisely the
**    clipping rectangle.
*/
void ContainerDoc_GetClipRect(
		LPCONTAINERDOC      lpContainerDoc,
		LPRECT              lprcClipRect
)
{
	/* OLE2NOTE: the ClipRect can be used to ensure that the in-place
	**    server does not overwrite areas of the window that the
	**    container paints into but which should never be overwritten
	**    (eg. if an app were to paint row and col headings directly in
	**    the same window that is the parent of the in-place window.
	**    whenever the window size changes or gets scrolled, in-place
	**    active object must be informed of the new clip rect.
	**
	**    normally an app would pass the rect returned from GetClientRect.
	**    but because CntrOutl uses separate windows for row/column
	**    headings, status line, formula/tool bars, etc. it is NOT
	**    necessary to pass a constrained clip rect. Windows standard
	**    window clipping will automatically take care of all clipping
	**    that is necessary. thus we can take a short cut of passing an
	**    "infinite" clip rect, and then we do NOT need to call
	**    IOleInPlaceObject::SetObjectRects when our document is scrolled.
	*/

	lprcClipRect->top = -32767;
	lprcClipRect->left = -32767;
	lprcClipRect->right = 32767;
	lprcClipRect->bottom = 32767;
}


/* ContainerDoc_GetTopInPlaceFrame
** -------------------------------
**    returns NON-AddRef'ed pointer to Top In-Place Frame interface
*/
LPOLEINPLACEFRAME ContainerDoc_GetTopInPlaceFrame(
		LPCONTAINERDOC      lpContainerDoc
)
{
#if defined( INPLACE_CNTRSVR )
	return lpContainerDoc->m_lpTopIPFrame;
#else
	return (LPOLEINPLACEFRAME)&((LPCONTAINERAPP)g_lpApp)->m_OleInPlaceFrame;
#endif
}

void ContainerDoc_GetSharedMenuHandles(
		LPCONTAINERDOC  lpContainerDoc,
		HMENU FAR*      lphSharedMenu,
		HOLEMENU FAR*   lphOleMenu
)
{
#if defined( INPLACE_CNTRSVR )
	if (lpContainerDoc->m_DocType == DOCTYPE_EMEBEDDEDOBJECT) {
		*lphSharedMenu = lpContainerDoc->m_hSharedMenu;
		*lphOleMenu = lpContainerDoc->m_hOleMenu;
		return;
	}
#endif

	*lphSharedMenu = NULL;
	*lphOleMenu = NULL;
}


#if defined( USE_FRAMETOOLS )
void ContainerDoc_RemoveFrameLevelTools(LPCONTAINERDOC lpContainerDoc)
{
	LPOUTLINEDOC lpOutlineDoc = (LPOUTLINEDOC)lpContainerDoc;
	OleDbgAssert(lpOutlineDoc->m_lpFrameTools != NULL);

	FrameTools_Enable(lpOutlineDoc->m_lpFrameTools, FALSE);
}
#endif


void ContainerDoc_AddFrameLevelUI(LPCONTAINERDOC lpContainerDoc)
{
	LPOUTLINEDOC lpOutlineDoc = (LPOUTLINEDOC)lpContainerDoc;
	LPOLEINPLACEFRAME lpTopIPFrame = ContainerDoc_GetTopInPlaceFrame(
			lpContainerDoc);
	HMENU           hSharedMenu;            // combined obj/cntr menu
	HOLEMENU        hOleMenu;               // returned by OleCreateMenuDesc.

	ContainerDoc_GetSharedMenuHandles(
			lpContainerDoc,
			&hSharedMenu,
			&hOleMenu
	);

	lpTopIPFrame->lpVtbl->SetMenu(
			lpTopIPFrame,
			hSharedMenu,
			hOleMenu,
			lpOutlineDoc->m_hWndDoc
	);

	/* OLE2NOTE: even if our app does NOT use FrameTools, we must still
	**    call IOleInPlaceFrame::SetBorderSpace.
	*/
	ContainerDoc_AddFrameLevelTools(lpContainerDoc);
}


void ContainerDoc_AddFrameLevelTools(LPCONTAINERDOC lpContainerDoc)
{
	LPOLEINPLACEFRAME lpTopIPFrame = ContainerDoc_GetTopInPlaceFrame(
			lpContainerDoc);
	LPCONTAINERAPP lpContainerApp = (LPCONTAINERAPP)g_lpApp;
	LPOUTLINEDOC lpOutlineDoc = (LPOUTLINEDOC)lpContainerDoc;

	OleDbgAssert(lpTopIPFrame != NULL);

#if defined( USE_FRAMETOOLS )

	FrameTools_Enable(lpOutlineDoc->m_lpFrameTools, TRUE);
	OutlineDoc_UpdateFrameToolButtons(lpOutlineDoc);

	FrameTools_NegotiateForSpaceAndShow(
			lpOutlineDoc->m_lpFrameTools,
			NULL,
			lpTopIPFrame
	);

#else   // ! USE_FRAMETOOLS

#if defined( INPLACE_CNTRSVR )
	if (lpContainerDoc->m_DocType == DOCTYPE_EMBEDDEDOBJECT) {
		/* this says i do not need space, so the top Frame should
		**    leave its tools behind
		*/
		OLEDBG_BEGIN2("IOleInPlaceFrame::SetBorderSpace(NULL) called\r\n")
		lpTopIPFrame->lpVtbl->SetBorderSpace(lpTopIPFrame, NULL);
		OLEDBG_END2
		return;
	}
#else   // INPLACE_CNTR && ! USE_FRAMETOOLS

	OLEDBG_BEGIN2("IOleInPlaceFrame::SetBorderSpace(0,0,0,0) called\r\n")
	lpTopIPFrame->lpVtbl->SetBorderSpace(
			lpTopIPFrame,
			(LPCBORDERWIDTHS)&g_rectNull
	);
	OLEDBG_END2

#endif  // INPLACE_CNTR && ! USE_FRAMETOOLS
#endif  // ! USE_FRAMETOOLS

}


void ContainerDoc_FrameWindowResized(LPCONTAINERDOC lpContainerDoc)
{
	LPCONTAINERAPP lpContainerApp = (LPCONTAINERAPP)g_lpApp;

	if (lpContainerApp->m_lpIPActiveObj) {
		RECT rcFrameRect;

		/* OLE2NOTE: this fMustResizeClientArea flag is used as part of
		**    our defensive programming for frame window resizing. when
		**    the frame window is
		**    resized, IOleInPlaceActiveObject::ResizeBorder is called
		**    the object should normally call back to renegotiate
		**    for frame-level tools space. if SetBorderSpace is called
		**    then our client area windows are properly resized.
		**    CntrApp_IPFrame_SetBorderSpace clears this flag. if the
		**    in-place active object does NOT call SetBorderSpace, then
		**    the container must take care to resize its client area
		**    windows itself.
		*/
		lpContainerApp->m_fMustResizeClientArea = TRUE;

		OutlineApp_GetFrameRect(g_lpApp, (LPRECT)&rcFrameRect);

		OLEDBG_BEGIN2("IOleInPlaceActiveObject::ResizeBorder called\r\n")
		lpContainerApp->m_lpIPActiveObj->lpVtbl->ResizeBorder(
				lpContainerApp->m_lpIPActiveObj,
				(LPCRECT)&rcFrameRect,
				(LPOLEINPLACEUIWINDOW)&lpContainerApp->m_OleInPlaceFrame,
				TRUE    /* fFrameWindow */
		);
		OLEDBG_END2

		/* the object did NOT call IOleInPlaceUIWindow::SetBorderSpace
		**    therefore we must resize our client area windows ourself.
		*/
		if (lpContainerApp->m_fMustResizeClientArea) {
			lpContainerApp->m_fMustResizeClientArea = FALSE;
			OutlineApp_ResizeClientArea(g_lpApp);
		}
	}

#if defined( USE_FRAMETOOLS )
	else {
		ContainerDoc_AddFrameLevelTools(lpContainerDoc);
	}
#endif
}


#if defined( INPLACE_CNTRSVR ) || defined( INPLACE_MDICNTR )

/* ContainerDoc_GetTopInPlaceDoc
**    returns NON-AddRef'ed pointer to Top In-Place Doc interface
*/
LPOLEINPLACEUIWINDOW ContainerDoc_GetTopInPlaceDoc(
		LPCONTAINERDOC      lpContainerDoc
)
{
#if defined( INPLACE_CNTRSVR )
	return lpContainerDoc->m_lpTopIPDoc;
#else
	return (LPOLEINPLACEUIWINDOW)&lpContainerDoc->m_OleInPlaceDoc;
#endif
}


void ContainerDoc_RemoveDocLevelTools(LPCONTAINERDOC lpContainerDoc);
{
	LPOLEINPLACEUIWINDOW lpTopIPDoc = ContainerDoc_GetTopInPlaceDoc(
			lpContainerDoc);

	if (lpTopIPDoc && lpContainerDoc->m_fMyToolsOnDoc) {
		lpContainerDoc->m_fMyToolsOnDoc = FALSE;

		// if we had doc tools we would HIDE them here;
		//   but NOT call SetBorderSpace(NULL)

	}
}

void ContainerDoc_AddDocLevelTools(LPCONTAINERDOC lpContainerDoc)
{
	LPOLEINPLACEUIWINDOW lpTopIPDoc = ContainerDoc_GetTopInPlaceDoc(
			lpContainerDoc);

	if (! lpTopIPDoc)
		return;

#if defined( USE_DOCTOOLS )
	if (lpTopIPDoc && ! lpContainerDoc->m_fMyToolsOnDoc) {

		/* if we had doc tools we would negotiate for toolbar space at
		**    doc level and SHOW them.
		*/

		/* we do NOT have doc level tools, so we just call
		**    SetBorderSpace() to indicate to the top doc that
		**    our object does not need tool space.
		*/

		lpContainerDoc->m_fMyToolsOnDoc = TRUE;
		return;
	}
#else   // ! USE_DOCTOOLS

#if defined( INPLACE_CNTRSVR )
	if (lpContainerDoc->m_DocType == DOCTYPE_EMBEDDEDOBJECT) {
		/* this says i do not need space, so the top doc should
		**    leave its tools behind
		*/
		lpTopIPDoc->lpVtbl->SetBorderSpace(lpTopIPDoc, NULL);
		return;
	}
#else
	lpTopIPDoc->lpVtbl->SetBorderSpace(
			lpTopIPDoc,
			(LPCBORDERWIDTHS)&g_rectNull
	);

#endif
#endif  // ! USE_DOCTOOLS
}

#endif  // INPLACE_CNTRSVR || INPLACE_MDICNTR


/* ContainerDoc_ContextSensitiveHelp
** ---------------------------------
**    forward the ContextSensitiveHelp mode on to any in-place objects
**    that currently have their window visible. this informs the
**    objects whether to give help or take action on subsequent mouse
**    clicks and menu commands. this function is called from our
**    IOleInPlaceSite::ContextSensitiveHelp implementation.
**
** OLE2NOTE: see context sensitive help technote (CSHELP.DOC).
**    This function is called when SHIFT-F1 context sensitive help is
**    entered. the cursor should then change to a question mark
**    cursor and the app should enter a modal state where the next
**    mouse click does not perform its normal action but rather
**    gives help corresponding to the location clicked. if the app
**    does not implement a help system, it should at least eat the
**    click and do nothing.
*/
void ContainerDoc_ContextSensitiveHelp(
		LPCONTAINERDOC  lpContainerDoc,
		BOOL            fEnterMode,
		BOOL            fInitiatedByObj
)
{
	LPOLEDOC lpOleDoc = (LPOLEDOC)lpContainerDoc;
	LPLINELIST lpLL = &((LPOUTLINEDOC)lpContainerDoc)->m_LineList;
	int i;
	LPLINE lpLine;

	lpOleDoc->m_fCSHelpMode = fEnterMode;

	if (g_fInsideOutContainer) {

		if (lpContainerDoc->m_cIPActiveObjects) {
			for (i = 0; i < lpLL->m_nNumLines; i++) {
				lpLine=LineList_GetLine(lpLL, i);

				if (lpLine && (Line_GetLineType(lpLine)==CONTAINERLINETYPE)) {
					LPCONTAINERLINE lpContainerLine = (LPCONTAINERLINE)lpLine;
					ContainerLine_ContextSensitiveHelp(
							lpContainerLine, fEnterMode);
				}
			}
		}
	}
	else if (! fInitiatedByObj) {
		/* OLE2NOTE: (OUTSIDE-IN CONTAINER) if there is a currently
		**    UIActive object (ie. its window is visible), we must
		**    forward the ContextSensitiveHelp mode on to the
		**    object--assuming it was not the object that initiated the
		**    context sensitve help mode.
		*/
		LPCONTAINERLINE lpLastUIActiveLine =
				lpContainerDoc->m_lpLastUIActiveLine;
		if (lpLastUIActiveLine && lpLastUIActiveLine->m_fUIActive) {
			ContainerLine_ContextSensitiveHelp(lpLastUIActiveLine,fEnterMode);
		}
	}
}

/* ContainerDoc_ForwardPaletteChangedMsg
** -------------------------------------
**    forward the WM_PALETTECHANGED message (via SendMessage) to any
**    in-place objects that currently have their window visible. this
**    gives these objects the chance to select their palette as a
**    BACKGROUND palette.
**
**    SEE THE TECHNOTE FOR DETAILED INFORMATION ON PALETTE COORDINATION
**
**    OLE2NOTE: For containers and objects to manage palettes properly
**    (when objects are getting inplace edited) they should follow a
**    set of rules.
**
**    Rule 1: The Container can decide if it wants to own the palette or
**    it wants to allow its UIActive object to own the palette.
**    a) If the container wants to let its UIActive object own the
**    palette then it should forward WM_QUERYNEWPALETTE to the object
**    when it is received to the top frame window. also it should send
**    WM_QUERYNEWPALETTE to the object in its
**    IOleInPlaceFrame::SetActiveObject implementation. if the object
**    is given ownership of the palette, then it owns the palette until
**    it is UIDeactivated.
**    b) If the container wants to own the palette it should NOT send
**    WM_QUERYNEWPALETTE to the UIActive object.
**
**    Rule 2: Whether the container wants to own the palette or not, it
**    should forward the WM_PALETTECHANGED to the immediate child
**    inplace active objects in its documents. if it is an inside-out
**    style container then it must forward it to ALL objects that
**    currently have their windows visible. When the object recives the
**    WM_PALETTECHANGED message it must select its color palette as the
**    background palette. When the objects are in loaded state they will be
**    drawn by (OLE) by selecting their palettes as background palettes
**    anyway.
**
**    Note: IOleObject::SetColorScheme is not related to the palette
**    issue.
*/
void ContainerDoc_ForwardPaletteChangedMsg(
		LPCONTAINERDOC  lpContainerDoc,
		HWND            hwndPalChg
)
{
	LPLINELIST lpLL;
	int i;
	LPLINE lpLine;

	if (!lpContainerDoc)
		return;

	lpLL = &((LPOUTLINEDOC)lpContainerDoc)->m_LineList;
	if (g_fInsideOutContainer) {

		if (lpContainerDoc->m_cIPActiveObjects) {
			for (i = 0; i < lpLL->m_nNumLines; i++) {
				lpLine=LineList_GetLine(lpLL, i);

				if (lpLine && (Line_GetLineType(lpLine)==CONTAINERLINETYPE)) {
					LPCONTAINERLINE lpContainerLine = (LPCONTAINERLINE)lpLine;
					ContainerLine_ForwardPaletteChangedMsg(
							lpContainerLine, hwndPalChg);
				}
			}
		}
	}
	else {
		/* OLE2NOTE: (OUTSIDE-IN CONTAINER) if there is a currently
		**    UIActive object (ie. its window is visible), we must
		**    forward it the WM_PALETTECHANGED message.
		*/
		LPCONTAINERLINE lpLastUIActiveLine =
				lpContainerDoc->m_lpLastUIActiveLine;
		if (lpLastUIActiveLine && lpLastUIActiveLine->m_fUIActive) {
			ContainerLine_ForwardPaletteChangedMsg(
					lpLastUIActiveLine, hwndPalChg);
		}
	}
}


/*************************************************************************
** ContainerLine Support Functions and Interfaces
*************************************************************************/


/* ContainerLine_UIDeactivate
** --------------------------
**    tell the OLE object associated with the ContainerLine to
**    UIDeactivate. this informs the in-place server to tear down
**    the UI and window that it put up for the object. it will remove
**    its active editor menus and any frame and object adornments
**    (eg. toolbars, rulers, etc.).
*/
void ContainerLine_UIDeactivate(LPCONTAINERLINE lpContainerLine)
{
	HRESULT hrErr;

	if (!lpContainerLine || !lpContainerLine->m_fUIActive)
		return;

	OLEDBG_BEGIN2("IOleInPlaceObject::UIDeactivate called\r\n")
	hrErr = lpContainerLine->m_lpOleIPObj->lpVtbl->UIDeactivate(
			lpContainerLine->m_lpOleIPObj);
	OLEDBG_END2

	if (hrErr != NOERROR) {
		OleDbgOutHResult("IOleInPlaceObject::UIDeactivate returned", hrErr);
		return;
	}
}



/* ContainerLine_UpdateInPlaceObjectRects
** -------------------------------------
**    Update the PosRect and ClipRect of the given line
**    currently in-place active
**    object. if there is no object active in-place, then do nothing.
**
**    OLE2NOTE: this function should be called when an action occurs
**    that changes either the position of the object in the document
**    (eg. changing document margins changes PosRect) or the clipRect
**    changes (eg. resizing the document window changes the ClipRect).
*/
void ContainerLine_UpdateInPlaceObjectRects(
		LPCONTAINERLINE lpContainerLine,
		LPRECT          lprcClipRect
)
{
	LPCONTAINERDOC lpContainerDoc = lpContainerLine->m_lpDoc;
	RECT rcClipRect;
	RECT rcPosRect;


	if (! lpContainerLine->m_fIpVisible)
		return;

	if (! lprcClipRect) {
		ContainerDoc_GetClipRect(lpContainerDoc, (LPRECT)&rcClipRect);
		lprcClipRect = (LPRECT)&rcClipRect;
	}

#if defined( _DEBUG )
	OleDbgOutRect3(
			"ContainerLine_UpdateInPlaceObjectRects (ClipRect)",
			(LPRECT)&rcClipRect
	);
#endif
	ContainerLine_GetPosRect(lpContainerLine,(LPRECT)&rcPosRect);

#if defined( _DEBUG )
	OleDbgOutRect3(
	   "ContainerLine_UpdateInPlaceObjectRects (PosRect)",(LPRECT)&rcPosRect);
#endif

	OLEDBG_BEGIN2("IOleInPlaceObject::SetObjectRects called\r\n")
	lpContainerLine->m_lpOleIPObj->lpVtbl->SetObjectRects(
			lpContainerLine->m_lpOleIPObj,
			(LPRECT)&rcPosRect,
			lprcClipRect
	);
	OLEDBG_END2
}


/* ContainerLine_ContextSensitveHelp
** ---------------------------------
**    forward the ContextSensitiveHelp mode on to the in-place object
**    if it currently has its window visible. this informs the
**    object whether to give help or take action on subsequent mouse
**    clicks and menu commands.
**
**    this function is called from ContainerDoc_ContextSensitiveHelp
**    function as a result of a call to
**    IOleInPlaceSite::ContextSensitiveHelp if the in-place container
**    is operating as an in-side out container.
*/
void ContainerLine_ContextSensitiveHelp(
		LPCONTAINERLINE lpContainerLine,
		BOOL            fEnterMode
)
{
	if (! lpContainerLine->m_fIpVisible)
		return;

	OLEDBG_BEGIN2("IOleInPlaceObject::ContextSensitiveHelp called\r\n")
	lpContainerLine->m_lpOleIPObj->lpVtbl->ContextSensitiveHelp(
			lpContainerLine->m_lpOleIPObj, fEnterMode);
	OLEDBG_END2
}


/* ContainerLine_ForwardPaletteChangedMsg
** --------------------------------------
**    forward it the WM_PALETTECHANGED message (via SendMessage) to the
**    in-place object if it currently has its window visible. this
**    gives the object the chance to select its palette as a BACKGROUND
**    palette if it doesn't own the palette--or as the
**    foreground palette if it currently DOES own the palette.
**
**    SEE THE TECHNOTE FOR DETAILED INFORMATION ON PALETTE COORDINATION
*/
void ContainerLine_ForwardPaletteChangedMsg(
		LPCONTAINERLINE lpContainerLine,
		HWND             hwndPalChg
)
{
	if (! lpContainerLine->m_fIpVisible)
		return;

	OleDbgAssert(lpContainerLine->m_hWndIpObject);
	SendMessage(
			lpContainerLine->m_hWndIpObject,
			WM_PALETTECHANGED,
			(WPARAM)hwndPalChg,
			0L
	);
}



/*************************************************************************
** ContainerLine::IOleInPlaceSite interface implementation
*************************************************************************/

STDMETHODIMP CntrLine_IPSite_QueryInterface(
		LPOLEINPLACESITE    lpThis,
		REFIID              riid,
		LPVOID FAR*         lplpvObj
)
{
	LPCONTAINERLINE lpContainerLine =
			((struct COleInPlaceSiteImpl FAR*)lpThis)->lpContainerLine;

	return ContainerLine_QueryInterface(lpContainerLine, riid, lplpvObj);
}


STDMETHODIMP_(ULONG) CntrLine_IPSite_AddRef(LPOLEINPLACESITE lpThis)
{
	LPCONTAINERLINE lpContainerLine =
			((struct COleInPlaceSiteImpl FAR*)lpThis)->lpContainerLine;

	OleDbgAddRefMethod(lpThis, "IOleInPlaceSite");

	return ContainerLine_AddRef(lpContainerLine);
}


STDMETHODIMP_(ULONG) CntrLine_IPSite_Release(LPOLEINPLACESITE lpThis)
{
	LPCONTAINERLINE lpContainerLine =
			((struct COleInPlaceSiteImpl FAR*)lpThis)->lpContainerLine;

	OleDbgReleaseMethod(lpThis, "IOleInPlaceSite");

	return ContainerLine_Release(lpContainerLine);
}


STDMETHODIMP CntrLine_IPSite_GetWindow(
	LPOLEINPLACESITE    lpThis,
	HWND FAR*           lphwnd
)
{
	LPCONTAINERLINE lpContainerLine =
			((struct COleInPlaceSiteImpl FAR*)lpThis)->lpContainerLine;
	OleDbgOut2("CntrLine_IPSite_GetWindow\r\n");

	*lphwnd = LineList_GetWindow(
			&((LPOUTLINEDOC)lpContainerLine->m_lpDoc)->m_LineList);
	return NOERROR;
}

// IOleInPlaceSite::ContextSensitiveHelp
STDMETHODIMP CntrLine_IPSite_ContextSensitiveHelp(
	LPOLEINPLACESITE    lpThis,
	BOOL                fEnterMode
)
{
	LPCONTAINERLINE lpContainerLine =
			((struct COleInPlaceSiteImpl FAR*)lpThis)->lpContainerLine;
	LPOLEDOC lpOleDoc = (LPOLEDOC)lpContainerLine->m_lpDoc;
	OleDbgOut2("CntrLine_IPSite_ContextSensitiveHelp\r\n");

	/* OLE2NOTE: see context sensitive help technote (CSHELP.DOC).
	**    This method is called when SHIFT-F1 context sensitive help is
	**    entered. the cursor should then change to a question mark
	**    cursor and the app should enter a modal state where the next
	**    mouse click does not perform its normal action but rather
	**    gives help corresponding to the location clicked. if the app
	**    does not implement a help system, it should at least eat the
	**    click and do nothing.
	**
	**    NOTE: the implementation here is specific to an SDI simple
	**    container. an MDI container or container/server application
	**    would have additional work to do (see the technote).
	**
	**    NOTE: (INSIDE-OUT CONTAINER) if there are currently
	**    any in-place objects active with their windows visible
	**    (ie. fIpVisible), we must forward the
	**    ContextSensitiveHelp mode on to these objects.
	*/
	ContainerDoc_ContextSensitiveHelp(
				lpContainerLine->m_lpDoc,fEnterMode,TRUE /*InitiatedByObj*/);

	return NOERROR;
}


STDMETHODIMP CntrLine_IPSite_CanInPlaceActivate(LPOLEINPLACESITE lpThis)
{
	LPCONTAINERLINE lpContainerLine =
			((struct COleInPlaceSiteImpl FAR*)lpThis)->lpContainerLine;
	OleDbgOut2("CntrLine_IPSite_CanInPlaceActivate\r\n");

	/* OLE2NOTE: the container can NOT allow in-place activation if it
	**    is currently displaying the object as an ICON
	**    (DVASPECT_ICON). it can ONLY do in-place activation if it is
	**    displaying the DVASPECT_CONTENT of the OLE object.
	*/
	if (lpContainerLine->m_dwDrawAspect == DVASPECT_CONTENT)
		return NOERROR;
	else
		return ResultFromScode(S_FALSE);
}

STDMETHODIMP CntrLine_IPSite_OnInPlaceActivate(LPOLEINPLACESITE lpThis)
{
	LPCONTAINERLINE lpContainerLine =
			((struct COleInPlaceSiteImpl FAR*)lpThis)->lpContainerLine;
	LPCONTAINERDOC lpContainerDoc = lpContainerLine->m_lpDoc;
	SCODE sc = S_OK;

	OLEDBG_BEGIN2("CntrLine_IPSite_OnInPlaceActivate\r\n");

	/* OLE2NOTE: (OUTSIDE-IN CONTAINER) as a policy for managing
	**    running in-place servers, we will keep only 1 inplace server
	**    active at any given time. so when we start to inp-place activate
	**    another line, then we want to shut down the previously
	**    activated server. in this way we keep at most one inplace
	**    server active at a time. this is NOT a required policy. apps
	**    may choose to have a more sophisticated strategy. inside-out
	**    containers will HAVE to have a more sophisticated strategy,
	**    because they need (at a minimum) to keep all visible object
	**    servers running.
	**
	**    if the in-place activation is the result of activating a
	**    linked object in another container, then we may arrive at
	**    this method while another object is currently active.
	**    normally, if the object is in-place activated by
	**    double-clicking or Edit.<verb> from our own container, then
	**    the previous in-place object would have been de-activated in
	**    ContainerLine_DoVerb method.
	*/
	if (!g_fInsideOutContainer) {
		if (lpContainerDoc->m_lpLastIpActiveLine) {
			ContainerDoc_ShutDownLastInPlaceServerIfNotNeeded(
					lpContainerDoc, lpContainerLine);
		}
		lpContainerDoc->m_lpLastIpActiveLine = lpContainerLine;
	}

	/* OLE2NOTE: to avoid LRPC problems it is important to cache the
	**    IOleInPlaceObject* pointer and NOT to call QueryInterface
	**    each time it is needed.
	*/
	lpContainerLine->m_lpOleIPObj = (LPOLEINPLACEOBJECT)
		   ContainerLine_GetOleObject(lpContainerLine,&IID_IOleInPlaceObject);

	if (! lpContainerLine->m_lpOleIPObj) {
#if defined( _DEBUG )
		OleDbgAssertSz(
				lpContainerLine->m_lpOleIPObj!=NULL,
				"OLE object must support IOleInPlaceObject"
		);
#endif
		return ResultFromScode(E_FAIL); // ERROR: refuse to in-place activate
	}

	lpContainerLine->m_fIpActive        = TRUE;
	lpContainerLine->m_fIpVisible       = TRUE;

	OLEDBG_BEGIN2("IOleInPlaceObject::GetWindow called\r\n")
	lpContainerLine->m_lpOleIPObj->lpVtbl->GetWindow(
			lpContainerLine->m_lpOleIPObj,
			(HWND FAR*)&lpContainerLine->m_hWndIpObject
	);
	OLEDBG_END2

	if (! lpContainerLine->m_fIpServerRunning) {
		/* OLE2NOTE: it is VERY important that an in-place container
		**    that also support linking to embeddings properly manage
		**    the running of its in-place objects. in an outside-in
		**    style in-place container, when the user clicks
		**    outside of the in-place active object, the object gets
		**    UIDeactivated and the object hides its window. in order
		**    to make the object fast to reactivate, the container
		**    deliberately does not call IOleObject::Close. the object
		**    stays running in the invisible unlocked state. the idea
		**    here is if the user simply clicks outside of the object
		**    and then wants to double click again to re-activate the
		**    object, we do not want this to be slow. if we want to
		**    keep the object running, however, we MUST Lock it
		**    running. otherwise the object will be in an unstable
		**    state where if a linking client does a "silent-update"
		**    (eg. UpdateNow from the Links dialog), then the in-place
		**    server will shut down even before the object has a chance
		**    to be saved back in its container. this saving normally
		**    occurs when the in-place container closes the object. also
		**    keeping the object in the unstable, hidden, running,
		**    not-locked state can cause problems in some scenarios.
		**    ICntrOtl keeps only one object running. if the user
		**    intiates a DoVerb on another object, then that last
		**    running in-place active object is closed. a more
		**    sophistocated in-place container may keep more object running.
		**    this lock gets unlocked in ContainerLine_CloseOleObject.
		*/
		lpContainerLine->m_fIpServerRunning = TRUE;

		OLEDBG_BEGIN2("OleLockRunning(TRUE, 0) called\r\n")
		OleLockRunning((LPUNKNOWN)lpContainerLine->m_lpOleIPObj, TRUE, 0);
		OLEDBG_END2
	}

	lpContainerLine->m_lpDoc->m_cIPActiveObjects++;

	OLEDBG_END2
	return NOERROR;
}


STDMETHODIMP CntrLine_IPSite_OnUIActivate (LPOLEINPLACESITE lpThis)
{
	LPCONTAINERLINE lpContainerLine =
			((struct COleInPlaceSiteImpl FAR*)lpThis)->lpContainerLine;
	LPCONTAINERDOC lpContainerDoc = lpContainerLine->m_lpDoc;
	LPOUTLINEDOC lpOutlineDoc = (LPOUTLINEDOC)lpContainerLine->m_lpDoc;
	LPCONTAINERLINE lpLastUIActiveLine = lpContainerDoc->m_lpLastUIActiveLine;

	OLEDBG_BEGIN2("CntrLine_IPSite_OnUIActivate\r\n");

	lpContainerLine->m_fUIActive        = TRUE;
	lpContainerDoc->m_fAddMyUI          = FALSE;
	lpContainerDoc->m_lpLastUIActiveLine = lpContainerLine;

	if (g_fInsideOutContainer) {
		/* OLE2NOTE: (INSIDE-OUT CONTAINER) an inside-out style
		**    container must UIDeactivate the previous UIActive object
		**    when a new object is going UIActive. since the inside-out
		**    objects have their own windows visible, it is possible
		**    that a click directly in an another server window will
		**    cause it to UIActivate. OnUIActivate is the containers
		**    notification that such has occured. it must then
		**    UIDeactivate the other because at most one object can be
		**    UIActive at a time.
		*/
		if (lpLastUIActiveLine && (lpLastUIActiveLine!=lpContainerLine)) {
			ContainerLine_UIDeactivate(lpLastUIActiveLine);

			// Make sure new UIActive window is on top of all others
			SetWindowPos(
					lpContainerLine->m_hWndIpObject,
					HWND_TOPMOST,
					0,0,0,0,
					SWP_NOMOVE | SWP_NOSIZE
			);

			OLEDBG_END2
			return NOERROR;
		}
	}

	lpContainerDoc->m_hWndUIActiveObj = lpContainerLine->m_hWndIpObject;

#if defined( USE_FRAMETOOLS )
	ContainerDoc_RemoveFrameLevelTools(lpContainerDoc);
#endif

#if defined( USE_DOCTOOLS )
	ContainerDoc_RemoveDocLevelTools(lpContainerDoc);
#endif

	OLEDBG_END2
	return NOERROR;
}


STDMETHODIMP CntrLine_IPSite_GetWindowContext(
	LPOLEINPLACESITE            lpThis,
	LPOLEINPLACEFRAME FAR*      lplpFrame,
	LPOLEINPLACEUIWINDOW FAR*   lplpDoc,
	LPRECT                      lprcPosRect,
	LPRECT                      lprcClipRect,
	LPOLEINPLACEFRAMEINFO       lpFrameInfo
)
{
	LPOUTLINEAPP lpOutlineApp = (LPOUTLINEAPP)g_lpApp;
	LPCONTAINERAPP lpContainerApp = (LPCONTAINERAPP)g_lpApp;
	LPCONTAINERLINE lpContainerLine =
			((struct COleInPlaceSiteImpl FAR*)lpThis)->lpContainerLine;

	OLEDBG_BEGIN2("CntrLine_IPSite_GetWindowContext\r\n")

	/* OLE2NOTE: The server should fill in the "cb" field so that the
	**    container can tell what size structure the server is
	**    expecting. this enables this structure to be easily extended
	**    in future releases of OLE. the container should check this
	**    field so that it doesn't try to use fields that do not exist
	**    since the server may be using an old structure definition.
	**    Since this is the first release of OLE2.0, the structure is
	**    guaranteed to be at least large enough for the current
	**    definition of OLEINPLACEFRAMEINFO struct. thus we do NOT need
	**    to consider this an error if the server did not fill in this
	**    field correctly. this server may have trouble in the future,
	**    however, when the structure is extended.
	*/
	*lplpFrame = (LPOLEINPLACEFRAME)&lpContainerApp->m_OleInPlaceFrame;
	(*lplpFrame)->lpVtbl->AddRef(*lplpFrame);   // must return AddRef'ed ptr

	// OLE2NOTE: an MDI app would have to provide *lplpDoc
	*lplpDoc  = NULL;

	ContainerLine_GetPosRect(lpContainerLine, lprcPosRect);
	ContainerDoc_GetClipRect(lpContainerLine->m_lpDoc, lprcClipRect);

	OleDbgOutRect3("CntrLine_IPSite_GetWindowContext (PosRect)", lprcPosRect);
	OleDbgOutRect3("CntrLine_IPSite_GetWindowContext (ClipRect)",lprcClipRect);
	lpFrameInfo->hwndFrame      = lpOutlineApp->m_hWndApp;

#if defined( MDI_VERSION )
	lpFrameInfo->fMDIApp        = TRUE;
#else
	lpFrameInfo->fMDIApp        = FALSE;
#endif

	lpFrameInfo->haccel         = lpContainerApp->m_hAccelIPCntr;
	lpFrameInfo->cAccelEntries  =
		GetAccelItemCount(lpContainerApp->m_hAccelIPCntr);

	OLEDBG_END2
	return NOERROR;
}


STDMETHODIMP CntrLine_IPSite_Scroll(
	LPOLEINPLACESITE    lpThis,
	SIZE                scrollExtent
)
{
	OleDbgOut2("CntrLine_IPSite_Scroll\r\n");
	return ResultFromScode(E_FAIL);
}


STDMETHODIMP CntrLine_IPSite_OnUIDeactivate(
	LPOLEINPLACESITE    lpThis,
	BOOL                fUndoable
)
{
	LPCONTAINERLINE lpContainerLine =
			((struct COleInPlaceSiteImpl FAR*)lpThis)->lpContainerLine;
	LPOUTLINEDOC lpOutlineDoc = (LPOUTLINEDOC)lpContainerLine->m_lpDoc;
	LPCONTAINERAPP lpContainerApp = (LPCONTAINERAPP) g_lpApp;
	LPLINELIST lpLL;
	int nIndex;
	MSG msg;
	HRESULT hrErr;
	OLEDBG_BEGIN2("CntrLine_IPSite_OnUIDeactivate\r\n")

	lpContainerLine->m_fUIActive = FALSE;
	lpContainerLine->m_fIpChangesUndoable = fUndoable;
	lpContainerLine->m_lpDoc->m_hWndUIActiveObj = NULL;

	if (lpContainerLine == lpContainerLine->m_lpDoc->m_lpLastUIActiveLine) {

		lpContainerLine->m_lpDoc->m_lpLastUIActiveLine = NULL;

		/* OLE2NOTE: here we look ahead if there is a DBLCLK sitting in our
		**    message queue. if so, it could result in in-place activating
		**    another object. we want to avoid placing our tools and
		**    repainting if immediately another object is going to do the
		**    same. SO, if there is a DBLCLK in the queue for this document
		**    we will only set the fAddMyUI flag to indicate that this work
		**    is still to be done. if another object actually in-place
		**    activates then this flag will be cleared in
		**    IOleInPlaceSite::OnUIActivate. if it does NOT get cleared,
		**    then at the end of processing the DBLCLK message in our
		**    OutlineDocWndProc we will put our tools back.
		*/
		if (! PeekMessage(&msg, lpOutlineDoc->m_hWndDoc,
				WM_LBUTTONDBLCLK, WM_LBUTTONDBLCLK,
				PM_NOREMOVE | PM_NOYIELD)) {

			/* OLE2NOTE: You need to generate QueryNewPalette only if
			**    you own the top level frame (ie. you are a top-level
			**    inplace container).
			*/

			OleApp_QueryNewPalette((LPOLEAPP)g_lpApp);

#if defined( USE_DOCTOOLS )
			ContainerDoc_AddDocLevelTools(lpContainerLine->m_lpDoc);
#endif

#if defined( USE_FRAMETOOLS )
			ContainerDoc_AddFrameLevelUI(lpContainerLine->m_lpDoc);
#endif
		} else {
			lpContainerLine->m_lpDoc->m_fAddMyUI = TRUE;
		}

		/* OLE2NOTE: we should re-take focus. the in-place server window
		**    previously had the focus; this window has just been removed.
		*/
		SetFocus(OutlineDoc_GetWindow((LPOUTLINEDOC)lpContainerLine->m_lpDoc));

		// force the line to redraw to remove in-place active hatch
		lpLL = OutlineDoc_GetLineList(lpOutlineDoc);
		nIndex = LineList_GetLineIndex(lpLL, (LPLINE)lpContainerLine);
		LineList_ForceLineRedraw(lpLL, nIndex, TRUE);
	}

#if defined( UNDOSUPPORTED )

	/* OLE2NOTE: an outside-in style container that supports UNDO would
	**    call IOleObject::DoVerb(OLEIVERB_HIDE) to make the in-place
	**    object go invisible. when it wants the in-place active object
	**    to discard its undo state, it would call
	**    IOleInPlaceObject::InPlaceDeactivate when it wants the object
	**    to discard its undo state. there is no need for an outside-in
	**    style container to call
	**    IOleObject::DoVerb(OLEIVERB_DISCARDUNDOSTATE). if either the
	**    container or the object do not support UNDO, then the
	**    container might as well immediately call InPlaceDeactivate
	**    instead of calling DoVerb(HIDE).
	**
	**    an inside-out style container that supports UNDO would simply
	**    UIDeactivate the object. it would call
	**    IOleObject::DoVerb(OLEIVERB_DISCARDUNDOSTATE) when it wants
	**    the object discard its undo state. it would call
	**    IOleInPlaceObject::InPlaceDeactivate if it wants the object
	**    to take down its window.
	*/
	if (! g_fInsideOutContainer || !lpContainerLine->m_fInsideOutObj) {

		if (lpContainerLine->m_fIpChangesUndoable) {
			ContainerLine_DoVerb(
					lpContainerLine,OLEIVERB_HIDE,NULL,FALSE,FALSE);
		} else {
			lpContainerLine->m_lpOleIPObj->lpVtbl->InPlaceDeactivate(
					lpContainerLine->m_lpOleIPObj);
		}
		lpContainerLine->m_fIpVisible = FALSE;
		lpContainerLine->m_hWndIpObject = NULL;
	}
#else

	/* OLE2NOTE: an outside-in style container that does NOT support
	**    UNDO would immediately tell the UIDeactivated server (UI
	**    removed) to IOleInPlaceObject::InPlaceDeactivate.
	**
	**    an inside-out style container that does NOT support UNDO
	**    would call IOleObject::DoVerb(OLEIVERB_DISCARDUNDOSTATE) to
	**    tell the object to discard its undo state. it would call
	**    IOleInPlaceObject::InPlaceDeactivate if it wants the object
	**    to take down its window.
	*/

	if (g_fInsideOutContainer) {

		if (lpContainerLine->m_fInsideOutObj) {

			if (lpContainerLine->m_fIpChangesUndoable) {
				OLEDBG_BEGIN3("ContainerLine_DoVerb(OLEIVERB_DISCARDUNDOSTATE) called!\r\n")
				ContainerLine_DoVerb(lpContainerLine,
					   OLEIVERB_DISCARDUNDOSTATE,NULL,FALSE,FALSE);
				OLEDBG_END3
			}

		} else {    // !fInsideOutObj

			/* OLE2NOTE: (INSIDEOUT CONTAINER) if the object is not
			**    registered OLEMISC_ACTIVATEWHENVISIBLE, then we will
			**    make the object behave in an outside-in manner. since
			**    we do NOT deal with UNDO we can simply
			**    InPlaceDeactivate the object. it should NOT be
			**    allowed to leave its window visible when
			**    UIDeactivated.
			*/
			OLEDBG_BEGIN2("IOleInPlaceObject::InPlaceDeactivate called\r\n")
			hrErr = lpContainerLine->m_lpOleIPObj->lpVtbl->InPlaceDeactivate(
						lpContainerLine->m_lpOleIPObj);
			OLEDBG_END2
			if (hrErr != NOERROR) {
				OleDbgOutHResult("IOleInPlaceObject::InPlaceDeactivate returned", hrErr);
			}
		}

	} else {

		/* OLE2NOTE: (OUTSIDE-IN CONTAINER) since we do NOT deal with
		**    UNDO we can simply InPlaceDeactivate the object. it
		**    should NOT be allowed to leave its window visible when
		**    UIDeactivated.
        **    
        **    NOTE: In-place servers must handle InPlaceDeactivate
        **    being called before its call to
        **    IOleInPlaceSite::OnUIDeactivate returns. in case there
        **    are misbehaving servers out there, one way to work around
        **    this problem is to call
        **    IOleObject::DoVerb(OLEIVERB_HIDE...) here.
		*/
		OLEDBG_BEGIN2("IOleInPlaceObject::InPlaceDeactivate called\r\n")
		hrErr = lpContainerLine->m_lpOleIPObj->lpVtbl->InPlaceDeactivate(
				lpContainerLine->m_lpOleIPObj);
		OLEDBG_END2
		if (hrErr != NOERROR) {
			OleDbgOutHResult("IOleInPlaceObject::InPlaceDeactivate returned", hrErr);
		}
	}

#endif // ! UNDOSUPPORTED

	OLEDBG_END2
	return NOERROR;
}


STDMETHODIMP CntrLine_IPSite_OnInPlaceDeactivate(LPOLEINPLACESITE lpThis)
{
	LPCONTAINERLINE lpContainerLine =
			((struct COleInPlaceSiteImpl FAR*)lpThis)->lpContainerLine;

	OLEDBG_BEGIN2("CntrLine_IPSite_OnInPlaceDeactivate\r\n");

	lpContainerLine->m_fIpActive            = FALSE;
	lpContainerLine->m_fIpVisible           = FALSE;
	lpContainerLine->m_fIpChangesUndoable   = FALSE;
	lpContainerLine->m_hWndIpObject         = NULL;

	OleStdRelease((LPUNKNOWN) lpContainerLine->m_lpOleIPObj);
	lpContainerLine->m_lpOleIPObj = NULL;
	lpContainerLine->m_lpDoc->m_cIPActiveObjects--;

	OLEDBG_END2
	return NOERROR;
}


STDMETHODIMP CntrLine_IPSite_DiscardUndoState(LPOLEINPLACESITE lpThis)
{
	OleDbgOut2("CntrLine_IPSite_DiscardUndoState\r\n");
	return NOERROR;
}


STDMETHODIMP CntrLine_IPSite_DeactivateAndUndo(LPOLEINPLACESITE lpThis)
{
	OleDbgOut2("CntrLine_IPSite_DeactivateAndUndo\r\n");
	return NOERROR;
}


STDMETHODIMP CntrLine_IPSite_OnPosRectChange(
	LPOLEINPLACESITE    lpThis,
	LPCRECT             lprcPosRect
)
{
	LPCONTAINERLINE lpContainerLine =
			((struct COleInPlaceSiteImpl FAR*)lpThis)->lpContainerLine;
	LPOUTLINEDOC lpOutlineDoc = (LPOUTLINEDOC)lpContainerLine->m_lpDoc;
	LPSCALEFACTOR lpscale = OutlineDoc_GetScaleFactor(lpOutlineDoc);
	LPLINE lpLine = (LPLINE)lpContainerLine;
	LPLINELIST lpLL;
	int nIndex;
	RECT rcClipRect;
	RECT rcNewPosRect;
	SIZEL sizelPix;
	SIZEL sizelHim;
	int nIPObjHeight = lprcPosRect->bottom - lprcPosRect->top;
	int nIPObjWidth = lprcPosRect->right - lprcPosRect->left;
	OLEDBG_BEGIN2("CntrLine_IPSite_OnPosRectChange\r\n")
	OleDbgOutRect3("CntrLine_IPSite_OnPosRectChange (PosRect --IN)", (LPRECT)lprcPosRect);

	/* OLE2NOTE: if the in-place container does NOT impose any
	**    size contraints on its in-place active objects, then it may
	**    simply grant the size requested by the object by immediately
	**    calling IOleInPlaceObject::SetObjectRects with the
	**    lprcPosRect passed by the in-place object.
	**
	**    Container Outline, however, imposes a size constraint on its
	**    embedded objects (see comment in ContainerLine_UpdateExtent),
	**    thus it is necessary to calculate the size that the in-place
	**    active object is allowed to be.
	**
	**    Here we need to know the new extents of the in-place object.
	**    We can NOT directly ask the object via IOleObject::GetExtent
	**    because this method will retreive the extents of the last
	**    cached metafile. the cache has not yet been updated by this
	**    point. We can not reliably call IOleObject::GetExtent
	**    because, despite the fact that will be delegated to the
	**    object properly, some objects may not have reformated their
	**    object and computed the new extents at the time of calling
	**    OnPosRectChange.
	**
	**    the best we can do to get the new extents of the object is
	**    to determine the scale factor that the object was operating at
	**    prior to the OnPosRect call and scale the new lprcPosRect
	**    using this scale factor back to HIMETRIC units.
	*/
	if (lpContainerLine->m_sizeInHimetric.cx > 0 &&
		lpContainerLine->m_sizeInHimetric.cy > 0) {
		sizelHim.cx = lpLine->m_nWidthInHimetric;
		sizelHim.cy = lpLine->m_nHeightInHimetric;
		XformSizeInHimetricToPixels(NULL, &sizelHim, &sizelPix);
		sizelHim.cx = lpContainerLine->m_sizeInHimetric.cx *
					nIPObjWidth / sizelPix.cx;
		sizelHim.cy = lpContainerLine->m_sizeInHimetric.cy *
					nIPObjHeight / sizelPix.cy;

		// Convert size back to 100% zoom
		sizelHim.cx = sizelHim.cx * lpscale->dwSxD / lpscale->dwSxN;
		sizelHim.cy = sizelHim.cy * lpscale->dwSyD / lpscale->dwSyN;
	} else {
		sizelHim.cx = (long)DEFOBJWIDTH;
		sizelHim.cy = (long)DEFOBJHEIGHT;
		XformSizeInHimetricToPixels(NULL, &sizelHim, &sizelPix);
		sizelHim.cx = sizelHim.cx * nIPObjWidth / sizelPix.cx;
		sizelHim.cy = sizelHim.cy * nIPObjHeight / sizelPix.cy;
	}

	ContainerLine_UpdateExtent(lpContainerLine, &sizelHim);
	ContainerLine_GetPosRect(lpContainerLine, (LPRECT)&rcNewPosRect);
	ContainerDoc_GetClipRect(lpContainerLine->m_lpDoc, (LPRECT)&rcClipRect);

#if defined( _DEBUG )
	OleDbgOutRect3("CntrLine_IPSite_OnPosRectChange (PosRect --OUT)",
			(LPRECT)&rcNewPosRect);
	OleDbgOutRect3("CntrLine_IPSite_OnPosRectChange (ClipRect--OUT)",
			(LPRECT)&rcClipRect);
#endif
	OLEDBG_BEGIN2("IOleInPlaceObject::SetObjectRects called\r\n")
	lpContainerLine->m_lpOleIPObj->lpVtbl->SetObjectRects(
			lpContainerLine->m_lpOleIPObj,
			(LPRECT)&rcNewPosRect,
			(LPRECT)&rcClipRect
	);
	OLEDBG_END2

	/* OLE2NOTE: (INSIDEOUT CONTAINER) Because this object just changed
	**    size, this may cause other in-place active objects in the
	**    document to move. in ICNTROTL's case any object below this
	**    object would be affected. in this case it would be necessary
	**    to call SetObjectRects to each affected in-place active object.
	*/
	if (g_fInsideOutContainer) {
		lpLL = OutlineDoc_GetLineList(lpOutlineDoc);
		nIndex = LineList_GetLineIndex(lpLL, (LPLINE)lpContainerLine);

		ContainerDoc_UpdateInPlaceObjectRects(
				lpContainerLine->m_lpDoc, nIndex);
	}
	OLEDBG_END2
	return NOERROR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\letest\outline\cntrline.c ===
/*************************************************************************
**
**    OLE 2 Container Sample Code
**
**    cntrline.c
**
**    This file contains ContainerLine methods.
**
**    (c) Copyright Microsoft Corp. 1992 - 1993 All Rights Reserved
**
*************************************************************************/

#include "outline.h"

OLEDBGDATA



extern LPOUTLINEAPP         g_lpApp;
extern IUnknownVtbl         g_CntrLine_UnknownVtbl;
extern IOleClientSiteVtbl   g_CntrLine_OleClientSiteVtbl;
extern IAdviseSinkVtbl      g_CntrLine_AdviseSinkVtbl;

#if defined( INPLACE_CNTR )
extern IOleInPlaceSiteVtbl  g_CntrLine_OleInPlaceSiteVtbl;
extern BOOL g_fInsideOutContainer;
#endif  // INPLACE_CNTR

// REVIEW: should use string resource for messages
char ErrMsgDoVerb[] = "OLE object action failed!";


/* prototype for static functions */
static void InvertDiffRect(LPRECT lprcPix, LPRECT lprcObj, HDC hDC);


/*************************************************************************
** ContainerLine
**    This object represents the location within the container where
**    the embedded/linked object lives. It exposes interfaces to the
**    object that allow the object to get information about its
**    embedding site and to announce notifications of important events
**    (changed, closed, saved)
**
**    The ContainerLine exposes the following interfaces:
**      IUnknown
**      IOleClientSite
**      IAdviseSink
*************************************************************************/



/*************************************************************************
** ContainerLine::IUnknown interface implementation
*************************************************************************/


// IUnknown::QueryInterface
STDMETHODIMP CntrLine_Unk_QueryInterface(
		LPUNKNOWN           lpThis,
		REFIID              riid,
		LPVOID FAR*         lplpvObj
)
{
	LPCONTAINERLINE lpContainerLine =
			((struct COleClientSiteImpl FAR*)lpThis)->lpContainerLine;

	return ContainerLine_QueryInterface(lpContainerLine, riid, lplpvObj);
}


// IUnknown::AddRef
STDMETHODIMP_(ULONG) CntrLine_Unk_AddRef(LPUNKNOWN lpThis)
{
	LPCONTAINERLINE lpContainerLine =
			((struct COleClientSiteImpl FAR*)lpThis)->lpContainerLine;

	OleDbgAddRefMethod(lpThis, "IUnknown");

	return ContainerLine_AddRef(lpContainerLine);
}


// IUnknown::Release
STDMETHODIMP_(ULONG) CntrLine_Unk_Release(LPUNKNOWN lpThis)
{
	LPCONTAINERLINE lpContainerLine =
			((struct COleClientSiteImpl FAR*)lpThis)->lpContainerLine;

	OleDbgReleaseMethod(lpThis, "IUnknown");

	return ContainerLine_Release(lpContainerLine);
}


/*************************************************************************
** ContainerLine::IOleClientSite interface implementation
*************************************************************************/

// IOleClientSite::QueryInterface
STDMETHODIMP CntrLine_CliSite_QueryInterface(
		LPOLECLIENTSITE     lpThis,
		REFIID              riid,
		LPVOID FAR*         lplpvObj
)
{
	LPCONTAINERLINE lpContainerLine =
			((struct COleClientSiteImpl FAR*)lpThis)->lpContainerLine;

	return ContainerLine_QueryInterface(lpContainerLine, riid, lplpvObj);
}


// IOleClientSite::AddRef
STDMETHODIMP_(ULONG) CntrLine_CliSite_AddRef(LPOLECLIENTSITE lpThis)
{
	LPCONTAINERLINE lpContainerLine =
			((struct COleClientSiteImpl FAR*)lpThis)->lpContainerLine;

	OleDbgAddRefMethod(lpThis, "IOleClientSite");

	return ContainerLine_AddRef(lpContainerLine);
}


// IOleClientSite::Release
STDMETHODIMP_(ULONG) CntrLine_CliSite_Release(LPOLECLIENTSITE lpThis)
{
	LPCONTAINERLINE lpContainerLine =
			((struct COleClientSiteImpl FAR*)lpThis)->lpContainerLine;

	OleDbgReleaseMethod(lpThis, "IOleClientSite");

	return ContainerLine_Release(lpContainerLine);
}


// IOleClientSite::SaveObject
STDMETHODIMP CntrLine_CliSite_SaveObject(LPOLECLIENTSITE lpThis)
{
	LPCONTAINERLINE lpContainerLine =
			((struct COleClientSiteImpl FAR*)lpThis)->lpContainerLine;
	LPPERSISTSTORAGE lpPersistStg = lpContainerLine->m_lpPersistStg;
	SCODE sc = S_OK;
	HRESULT hrErr;

	OLEDBG_BEGIN2("CntrLine_CliSite_SaveObject\r\n")

	if (! lpPersistStg) {
		/* OLE2NOTE: The object is NOT loaded. a container must be
		**    prepared for the fact that an object that it thinks it
		**    has unloaded may still call IOleClientSite::SaveObject.
		**    in this case the container should fail the save call and
		**    NOT try to reload the object. this scenario arises if you
		**    have a in-process server (DLL object) which has a
		**    connected linking client. even after the embedding
		**    container unloads the DLL object, the link connection
		**    keeps the object alive. it may then as part of its
		**    shutdown try to call IOCS::SaveObject, but then it is too
		**    late.
		*/
		OLEDBG_END2
		return ResultFromScode(E_FAIL);
	}

	// mark ContainerDoc as now dirty
	OutlineDoc_SetModified(
			(LPOUTLINEDOC)lpContainerLine->m_lpDoc, TRUE, TRUE, FALSE);

	/* Tell OLE object to save itself
	** OLE2NOTE: it is NOT sufficient to ONLY call
	**    IPersistStorage::Save method. it is also necessary to call
	**    WriteClassStg. the helper API OleSave does this automatically.
	*/
	OLEDBG_BEGIN2("OleSave called\r\n")
	hrErr=OleSave(lpPersistStg,lpContainerLine->m_lpStg, TRUE/*fSameAsLoad*/);
	OLEDBG_END2

	if (hrErr != NOERROR) {
		OleDbgOutHResult("WARNING: OleSave returned", hrErr);
		sc = GetScode(hrErr);
	}

	// OLE2NOTE: even if OleSave fails, SaveCompleted must be called.
	OLEDBG_BEGIN2("IPersistStorage::SaveCompleted called\r\n")
	hrErr = lpPersistStg->lpVtbl->SaveCompleted(lpPersistStg, NULL);
	OLEDBG_END2

	if (hrErr != NOERROR) {
		OleDbgOutHResult("WARNING: SaveCompleted returned",hrErr);
		if (sc == S_OK)
			sc = GetScode(hrErr);
	}

	OLEDBG_END2
	return ResultFromScode(sc);
}


// IOleClientSite::GetMoniker
STDMETHODIMP CntrLine_CliSite_GetMoniker(
		LPOLECLIENTSITE     lpThis,
		DWORD               dwAssign,
		DWORD               dwWhichMoniker,
		LPMONIKER FAR*      lplpmk
)
{
	LPCONTAINERLINE lpContainerLine;

	lpContainerLine=((struct COleClientSiteImpl FAR*)lpThis)->lpContainerLine;

	OLEDBG_BEGIN2("CntrLine_CliSite_GetMoniker\r\n")

	// OLE2NOTE: we must make sure to set output pointer parameters to NULL
	*lplpmk = NULL;

	switch (dwWhichMoniker) {

		case OLEWHICHMK_CONTAINER:
			/* OLE2NOTE: create a FileMoniker which identifies the
			**    entire container document.
			*/
			*lplpmk = OleDoc_GetFullMoniker(
					(LPOLEDOC)lpContainerLine->m_lpDoc,
					dwAssign
			);
			break;

		case OLEWHICHMK_OBJREL:

			/* OLE2NOTE: create an ItemMoniker which identifies the
			**    OLE object relative to the container document.
			*/
			*lplpmk = ContainerLine_GetRelMoniker(lpContainerLine, dwAssign);
			break;

		case OLEWHICHMK_OBJFULL:
		{
			/* OLE2NOTE: create an absolute moniker which identifies the
			**    OLE object in the container document. this moniker is
			**    created as a composite of the absolute moniker for the
			**    entire document appended with an item moniker which
			**    identifies the OLE object relative to the document.
			*/

			*lplpmk = ContainerLine_GetFullMoniker(lpContainerLine, dwAssign);
			break;
		}
	}

	OLEDBG_END2

	if (*lplpmk != NULL)
		return NOERROR;
	else
		return ResultFromScode(E_FAIL);
}


// IOleClientSite::GetContainer
STDMETHODIMP CntrLine_CliSite_GetContainer(
		LPOLECLIENTSITE     lpThis,
		LPOLECONTAINER FAR* lplpContainer
)
{
	LPCONTAINERLINE lpContainerLine;
	HRESULT hrErr;

	OLEDBG_BEGIN2("CntrLine_CliSite_GetContainer\r\n")

	lpContainerLine=((struct COleClientSiteImpl FAR*)lpThis)->lpContainerLine;

	hrErr = OleDoc_QueryInterface(
			(LPOLEDOC)lpContainerLine->m_lpDoc,
			&IID_IOleContainer,
			(LPVOID FAR*)lplpContainer
	);

	OLEDBG_END2
	return hrErr;
}


// IOleClientSite::ShowObject
STDMETHODIMP CntrLine_CliSite_ShowObject(LPOLECLIENTSITE lpThis)
{
	LPCONTAINERLINE lpContainerLine =
			((struct COleClientSiteImpl FAR*)lpThis)->lpContainerLine;
	LPOUTLINEDOC lpOutlineDoc = (LPOUTLINEDOC)lpContainerLine->m_lpDoc;
	LPLINELIST lpLL = OutlineDoc_GetLineList(lpOutlineDoc);
	int nIndex = LineList_GetLineIndex(lpLL, (LPLINE)lpContainerLine);
	HWND hWndFrame = OutlineApp_GetFrameWindow(g_lpApp);

	OLEDBG_BEGIN2("CntrLine_CliSite_ShowObject\r\n")

	/* make sure our doc window is visible and not minimized.
	**    the OutlineDoc_ShowWindow function will cause the app window
	**    to show itself SW_SHOWNORMAL.
	*/
	if (! IsWindowVisible(hWndFrame) || IsIconic(hWndFrame))
		OutlineDoc_ShowWindow(lpOutlineDoc);

	BringWindowToTop(hWndFrame);

	/* make sure that the OLE object is currently in view. if necessary
	**    scroll the document in order to bring it into view.
	*/
	LineList_ScrollLineIntoView(lpLL, nIndex);

#if defined( INPLACE_CNTR )
	/* after the in-place object is scrolled into view, we need to ask
	**    it to update its rect for the new clip rect coordinates
	*/
	ContainerDoc_UpdateInPlaceObjectRects((LPCONTAINERDOC)lpOutlineDoc, 0);
#endif

	OLEDBG_END2
	return NOERROR;
}


// IOleClientSite::OnShowWindow
STDMETHODIMP CntrLine_CliSite_OnShowWindow(LPOLECLIENTSITE lpThis, BOOL fShow)
{
	LPCONTAINERLINE lpContainerLine =
			((struct COleClientSiteImpl FAR*)lpThis)->lpContainerLine;
	LPOUTLINEDOC lpOutlineDoc = (LPOUTLINEDOC)lpContainerLine->m_lpDoc;
	LPLINELIST lpLL = OutlineDoc_GetLineList(lpOutlineDoc);
	int nIndex = LineList_GetLineIndex(lpLL, (LPLINE)lpContainerLine);

	if (fShow) {
		OLEDBG_BEGIN2("CntrLine_CliSite_OnShowWindow(TRUE)\r\n")

		/* OLE2NOTE: we need to hatch out the OLE object now; it has
		**    just been opened in a window elsewhere (open editing as
		**    opposed to in-place activation).
		**    force the line to re-draw with the hatch.
		*/
		lpContainerLine->m_fObjWinOpen = TRUE;
		LineList_ForceLineRedraw(lpLL, nIndex, FALSE /*fErase*/);

	} else {
		OLEDBG_BEGIN2("CntrLine_CliSite_OnShowWindow(FALSE)\r\n")

		/* OLE2NOTE: the object associated with this container site has
		**    just closed its server window. we should now remove the
		**    hatching that indicates that the object is open
		**    elsewhere. also our window should now come to the top.
		**    force the line to re-draw without the hatch.
		*/
		lpContainerLine->m_fObjWinOpen = FALSE;
		LineList_ForceLineRedraw(lpLL, nIndex, TRUE /*fErase*/);

		BringWindowToTop(lpOutlineDoc->m_hWndDoc);
		SetFocus(lpOutlineDoc->m_hWndDoc);
	}

	OLEDBG_END2
	return NOERROR;
}


// IOleClientSite::RequestNewObjectLayout
STDMETHODIMP CntrLine_CliSite_RequestNewObjectLayout(LPOLECLIENTSITE lpThis)
{
	OleDbgOut2("CntrLine_CliSite_RequestNewObjectLayout\r\n");

	/* OLE2NOTE: this method is NOT yet used. it is for future layout
	**    negotiation support.
	*/
	return ResultFromScode(E_NOTIMPL);
}


/*************************************************************************
** ContainerLine::IAdviseSink interface implementation
*************************************************************************/

// IAdviseSink::QueryInterface
STDMETHODIMP CntrLine_AdvSink_QueryInterface(
		LPADVISESINK        lpThis,
		REFIID              riid,
		LPVOID FAR*         lplpvObj
)
{
	LPCONTAINERLINE lpContainerLine =
			((struct COleClientSiteImpl FAR*)lpThis)->lpContainerLine;

	return ContainerLine_QueryInterface(lpContainerLine, riid, lplpvObj);
}


// IAdviseSink::AddRef
STDMETHODIMP_(ULONG) CntrLine_AdvSink_AddRef(LPADVISESINK lpThis)
{
	LPCONTAINERLINE lpContainerLine =
			((struct COleClientSiteImpl FAR*)lpThis)->lpContainerLine;

	OleDbgAddRefMethod(lpThis, "IAdviseSink");

	return ContainerLine_AddRef(lpContainerLine);
}


// IAdviseSink::Release
STDMETHODIMP_(ULONG) CntrLine_AdvSink_Release (LPADVISESINK lpThis)
{
	LPCONTAINERLINE lpContainerLine =
			((struct COleClientSiteImpl FAR*)lpThis)->lpContainerLine;

	OleDbgReleaseMethod(lpThis, "IAdviseSink");

	return ContainerLine_Release(lpContainerLine);
}


// IAdviseSink::OnDataChange
STDMETHODIMP_(void) CntrLine_AdvSink_OnDataChange(
		LPADVISESINK        lpThis,
		FORMATETC FAR*      lpFormatetc,
		STGMEDIUM FAR*      lpStgmed
)
{
	OleDbgOut2("CntrLine_AdvSink_OnDataChange\r\n");
	// We are not interested in data changes (only view changes)
	//      (ie. nothing to do)
}


STDMETHODIMP_(void) CntrLine_AdvSink_OnViewChange(
		LPADVISESINK        lpThis,
		DWORD               aspects,
		LONG                lindex
)
{
	LPCONTAINERLINE lpContainerLine;
	LPOUTLINEDOC lpOutlineDoc;
	HWND hWndDoc;
	LPLINELIST lpLL;
	MSG msg;
	int nIndex;

	OLEDBG_BEGIN2("CntrLine_AdvSink_OnViewChange\r\n")

	lpContainerLine = ((struct CAdviseSinkImpl FAR*)lpThis)->lpContainerLine;
	lpOutlineDoc = (LPOUTLINEDOC)lpContainerLine->m_lpDoc;

	/* OLE2NOTE: at this point we simply invalidate the rectangle of
	**    the object to force a repaint in the future, we mark
	**    that the extents of the object may have changed
	**    (m_fDoGetExtent=TRUE), and we post a message
	**    (WM_U_UPDATEOBJECTEXTENT) to our document that one or more
	**    OLE objects may need to have their extents updated. later
	**    when this message is processed, the document loops through
	**    all lines to see if any are marked as needing an extent update.
	**    if infact the extents did change. this can be done by calling
	**    IViewObject2::GetExtent to retreive the object's current
	**    extents and comparing with the last known extents for the
	**    object. if the extents changed, then relayout space for the
	**    object before drawing. we postpone the check to get
	**    the extents now because OnViewChange is an asyncronis method,
	**    and we have to careful not to call any syncronis methods back
	**    to the object. while it WOULD be OK to call the
	**    IViewObject2::GetExtent method within the asyncronis
	**    OnViewChange method (because this method is handled by the
	**    object handler and never remoted), it is good practise to not
	**    call any object methods from within an asyncronis
	**    notification method.
	**    if there is already WM_U_UPDATEOBJECTEXTENT message waiting
	**    in our message queue, there is no need to post another one.
	**    in this way, if the server is updating quicker than we can
	**    keep up, we do not make unneccsary GetExtent calls. also if
	**    drawing is disabled, we postpone updating the extents of any
	**    objects until drawing is re-enabled.
	*/
	lpContainerLine->m_fDoGetExtent = TRUE;
	hWndDoc = OutlineDoc_GetWindow((LPOUTLINEDOC)lpContainerLine->m_lpDoc);

	if (lpOutlineDoc->m_nDisableDraw == 0 &&
		! PeekMessage(&msg, hWndDoc,
			WM_U_UPDATEOBJECTEXTENT, WM_U_UPDATEOBJECTEXTENT,
			PM_NOREMOVE | PM_NOYIELD)) {
		PostMessage(hWndDoc, WM_U_UPDATEOBJECTEXTENT, 0, 0L);
	}

	// force the modified line to redraw.
	lpLL = OutlineDoc_GetLineList(lpOutlineDoc);
	nIndex = LineList_GetLineIndex(lpLL, (LPLINE)lpContainerLine);
	LineList_ForceLineRedraw(lpLL, nIndex, TRUE /*fErase*/);

	OLEDBG_END2
}


// IAdviseSink::OnRename
STDMETHODIMP_(void) CntrLine_AdvSink_OnRename(
		LPADVISESINK        lpThis,
		LPMONIKER           lpmk
)
{
	OleDbgOut2("CntrLine_AdvSink_OnRename\r\n");
	/* OLE2NOTE: the Embedding Container has nothing to do here. this
	**    notification is important for linking situations. it tells
	**    the OleLink objects to update their moniker because the
	**    source object has been renamed (track the link source).
	*/
}


// IAdviseSink::OnSave
STDMETHODIMP_(void) CntrLine_AdvSink_OnSave(LPADVISESINK lpThis)
{
	OleDbgOut2("CntrLine_AdvSink_OnSave\r\n");
	/* OLE2NOTE: the Embedding Container has nothing to do here. this
	**    notification is only useful to clients which have set up a
	**    data cache with the ADVFCACHE_ONSAVE flag.
	*/
}


// IAdviseSink::OnClose
STDMETHODIMP_(void) CntrLine_AdvSink_OnClose(LPADVISESINK lpThis)
{
	OleDbgOut2("CntrLine_AdvSink_OnClose\r\n");
	/* OLE2NOTE: the Embedding Container has nothing to do here. this
	**    notification is important for the OLE's default object handler
	**    and the OleLink object. it tells them the remote object is
	**    shutting down.
	*/
}


/*************************************************************************
** ContainerLine Support Functions
*************************************************************************/


/* ContainerLine_Init
** ------------------
**  Initialize fields in a newly constructed ContainerLine line object.
**  NOTE: ref cnt of ContainerLine initialized to 0
*/
void ContainerLine_Init(LPCONTAINERLINE lpContainerLine, int nTab, HDC hDC)
{
	Line_Init((LPLINE)lpContainerLine, nTab, hDC);  // init base class fields

	((LPLINE)lpContainerLine)->m_lineType           = CONTAINERLINETYPE;
	((LPLINE)lpContainerLine)->m_nWidthInHimetric   = DEFOBJWIDTH;
	((LPLINE)lpContainerLine)->m_nHeightInHimetric  = DEFOBJHEIGHT;
	lpContainerLine->m_cRef                         = 0;
	lpContainerLine->m_szStgName[0]                 = '\0';
	lpContainerLine->m_fObjWinOpen                  = FALSE;
	lpContainerLine->m_fMonikerAssigned             = FALSE;
	lpContainerLine->m_dwDrawAspect                 = DVASPECT_CONTENT;

	lpContainerLine->m_fGuardObj                    = FALSE;
	lpContainerLine->m_fDoGetExtent                 = FALSE;
	lpContainerLine->m_fDoSetExtent                 = FALSE;
	lpContainerLine->m_sizeInHimetric.cx            = -1;
	lpContainerLine->m_sizeInHimetric.cy            = -1;

	lpContainerLine->m_lpStg                        = NULL;
	lpContainerLine->m_lpDoc                        = NULL;
	lpContainerLine->m_lpOleObj                     = NULL;
	lpContainerLine->m_lpViewObj2                   = NULL;
	lpContainerLine->m_lpPersistStg                 = NULL;
	lpContainerLine->m_lpOleLink                    = NULL;
	lpContainerLine->m_dwLinkType                   = 0;
	lpContainerLine->m_fLinkUnavailable             = FALSE;
	lpContainerLine->m_lpszShortType                = NULL;

#if defined( INPLACE_CNTR )
	lpContainerLine->m_fIpActive                    = FALSE;
	lpContainerLine->m_fUIActive                    = FALSE;
	lpContainerLine->m_fIpVisible                   = FALSE;
	lpContainerLine->m_lpOleIPObj                   = NULL;
	lpContainerLine->m_fInsideOutObj                = FALSE;
	lpContainerLine->m_fIpChangesUndoable           = FALSE;
	lpContainerLine->m_fIpServerRunning             = FALSE;
	lpContainerLine->m_hWndIpObject                 = NULL;
	lpContainerLine->m_nHorizScrollShift            = 0;
#endif  // INPLACE_CNTR

	INIT_INTERFACEIMPL(
			&lpContainerLine->m_Unknown,
			&g_CntrLine_UnknownVtbl,
			lpContainerLine
	);

	INIT_INTERFACEIMPL(
			&lpContainerLine->m_OleClientSite,
			&g_CntrLine_OleClientSiteVtbl,
			lpContainerLine
	);

	INIT_INTERFACEIMPL(
			&lpContainerLine->m_AdviseSink,
			&g_CntrLine_AdviseSinkVtbl,
			lpContainerLine
	);

#if defined( INPLACE_CNTR )
	INIT_INTERFACEIMPL(
			&lpContainerLine->m_OleInPlaceSite,
			&g_CntrLine_OleInPlaceSiteVtbl,
			lpContainerLine
	);
#endif  // INPLACE_CNTR
}


/* Setup the OLE object associated with the ContainerLine */
BOOL ContainerLine_SetupOleObject(
		LPCONTAINERLINE         lpContainerLine,
		BOOL                    fDisplayAsIcon,
		HGLOBAL                 hMetaPict
)
{
	DWORD dwDrawAspect = (fDisplayAsIcon ? DVASPECT_ICON : DVASPECT_CONTENT);
	LPOUTLINEDOC lpOutlineDoc = (LPOUTLINEDOC)lpContainerLine->m_lpDoc;

	/* Cache a pointer to the IViewObject2* interface. *Required*
	**      we need this everytime we draw the object.
	**
	** OLE2NOTE: We require the object to support IViewObject2
	**    interface. this is an extension to the IViewObject interface
	**    that was added with the OLE 2.01 release. This interface must
	**    be supported by all object handlers and DLL-based objects.
	*/
	lpContainerLine->m_lpViewObj2 = (LPVIEWOBJECT2)OleStdQueryInterface(
			(LPUNKNOWN)lpContainerLine->m_lpOleObj, &IID_IViewObject2);
	if (! lpContainerLine->m_lpViewObj2) {
#if defined( _DEBUG )
		OleDbgAssertSz(
			lpContainerLine->m_lpViewObj2,"IViewObject2 NOT supported\r\n");
#endif
		return FALSE;
	}

	// Cache a pointer to the IPersistStorage* interface. *Required*
	//      we need this everytime we save the object.
	lpContainerLine->m_lpPersistStg = (LPPERSISTSTORAGE)OleStdQueryInterface(
			(LPUNKNOWN)lpContainerLine->m_lpOleObj, &IID_IPersistStorage);
	if (! lpContainerLine->m_lpPersistStg) {
		OleDbgAssert(lpContainerLine->m_lpPersistStg);
		return FALSE;
	}

	// Cache a pointer to the IOleLink* interface if supported. *Optional*
	//      if supported the object is a link. we need this to manage the link
	lpContainerLine->m_lpOleLink = (LPOLELINK)OleStdQueryInterface(
			(LPUNKNOWN)lpContainerLine->m_lpOleObj, &IID_IOleLink);
	if (lpContainerLine->m_lpOleLink) {
		OLEDBG_BEGIN2("IOleLink::GetUpdateOptions called\r\n")
		lpContainerLine->m_lpOleLink->lpVtbl->GetUpdateOptions(
				lpContainerLine->m_lpOleLink, &lpContainerLine->m_dwLinkType);
		OLEDBG_END2
	} else
		lpContainerLine->m_dwLinkType = 0;  // NOT a link

	/* get the short user type name of the object. this
	**    is used all the time when we have to build the object
	**    verb menu. we will cache this information to make it
	**    quicker to build the verb menu.
	*/
	OleDbgAssert(lpContainerLine->m_lpszShortType == NULL);
	OLEDBG_BEGIN2("IOleObject::GetUserType called\r\n")

	CallIOleObjectGetUserTypeA(
			lpContainerLine->m_lpOleObj,
			USERCLASSTYPE_SHORT,
			&lpContainerLine->m_lpszShortType
	);

	OLEDBG_END2

	/* Perform that standard setup for the OLE object. this includes:
	**      setup View advise
	**      Call IOleObject::SetHostNames
	**      Call OleSetContainedObject
	*/
	OleStdSetupAdvises(
			lpContainerLine->m_lpOleObj,
			dwDrawAspect,
			(LPSTR)APPNAME,
			lpOutlineDoc->m_lpszDocTitle,
			(LPADVISESINK)&lpContainerLine->m_AdviseSink,
			TRUE    /*fCreate*/
	);

#if defined( INPLACE_CNTR )
	/* OLE2NOTE: (INSIDE-OUT CONTAINER) An inside-out container should
	**    check if the object is an inside-out and prefers to be
	**    activated when visible type of object. if not the object
	**    should not be allowed to keep its window up after it gets
	**    UIDeactivated.
	*/
	if (g_fInsideOutContainer) {
		DWORD mstat;
		OLEDBG_BEGIN2("IOleObject::GetMiscStatus called\r\n")
		lpContainerLine->m_lpOleObj->lpVtbl->GetMiscStatus(
				lpContainerLine->m_lpOleObj,
				DVASPECT_CONTENT,
				(DWORD FAR*)&mstat
		);
		OLEDBG_END2

		lpContainerLine->m_fInsideOutObj = (BOOL)
				(mstat & (OLEMISC_INSIDEOUT|OLEMISC_ACTIVATEWHENVISIBLE));
	}
#endif  // INPLACE_CNTR

	if (fDisplayAsIcon) {
		/* user has requested to display icon aspect instead of content
		**    aspect.
		**    NOTE: we do not have to delete the previous aspect cache
		**    because one did not get set up.
		*/
		OleStdSwitchDisplayAspect(
				lpContainerLine->m_lpOleObj,
				&lpContainerLine->m_dwDrawAspect,
				dwDrawAspect,
				hMetaPict,
				FALSE,  /* fDeleteOldAspect */
				TRUE,   /* fSetupViewAdvise */
				(LPADVISESINK)&lpContainerLine->m_AdviseSink,
				NULL /*fMustUpdate*/        // this can be ignored; update
											// for switch to icon not req'd
		);
	}
	return TRUE;
}


/* Create an ContainerLine object and return the pointer */
LPCONTAINERLINE ContainerLine_Create(
		DWORD                   dwOleCreateType,
		HDC                     hDC,
		UINT                    nTab,
		LPCONTAINERDOC          lpContainerDoc,
		LPCLSID                 lpclsid,
		LPSTR                   lpszFileName,
		BOOL                    fDisplayAsIcon,
		HGLOBAL                 hMetaPict,
		LPSTR                   lpszStgName
)
{
	LPCONTAINERLINE lpContainerLine = NULL;
	LPOLEOBJECT     lpObj = NULL;
	LPSTORAGE       lpDocStg = ContainerDoc_GetStg(lpContainerDoc);
	DWORD           dwDrawAspect =
						(fDisplayAsIcon ? DVASPECT_ICON : DVASPECT_CONTENT);
	DWORD           dwOleRenderOpt =
						(fDisplayAsIcon ? OLERENDER_NONE : OLERENDER_DRAW);
	HRESULT         hrErr;

	OLEDBG_BEGIN3("ContainerLine_Create\r\n")

	if (lpDocStg == NULL) {
		OleDbgAssertSz(lpDocStg != NULL, "Doc storage is NULL");
		goto error;
	}

	lpContainerLine=(LPCONTAINERLINE) New((DWORD)sizeof(CONTAINERLINE));
	if (lpContainerLine == NULL) {
		OleDbgAssertSz(lpContainerLine!=NULL,"Error allocating ContainerLine");
		goto error;
	}

	ContainerLine_Init(lpContainerLine, nTab, hDC);

	/* OLE2NOTE: in order to avoid re-entrancy we will set a flag to
	**    guard our object. if this guard is set, then the object is
	**    not ready to have any OLE interface methods called. it is
	**    necessary to guard the object this way while it is being
	**    created or loaded.
	*/
	lpContainerLine->m_fGuardObj = TRUE;

	/* OLE2NOTE: In order to have a stable ContainerLine object we must
	**    AddRef the object's refcnt. this will be later released when
	**    the ContainerLine is deleted.
	*/
	ContainerLine_AddRef(lpContainerLine);

	lstrcpy(lpContainerLine->m_szStgName, lpszStgName);
	lpContainerLine->m_lpDoc = lpContainerDoc;

	/* Create a new storage for the object inside the doc's storage */
	lpContainerLine->m_lpStg = OleStdCreateChildStorage(lpDocStg,lpszStgName);
	if (lpContainerLine->m_lpStg == NULL) {
		OleDbgAssert(lpContainerLine->m_lpStg != NULL);
		goto error;
	}

	lpContainerLine->m_dwLinkType = 0;

	switch (dwOleCreateType) {

		case IOF_SELECTCREATENEW:

			OLEDBG_BEGIN2("OleCreate called\r\n")
			hrErr = OleCreate (
					lpclsid,
					&IID_IOleObject,
					dwOleRenderOpt,
					NULL,
					(LPOLECLIENTSITE)&lpContainerLine->m_OleClientSite,
					lpContainerLine->m_lpStg,
					(LPVOID FAR*)&lpContainerLine->m_lpOleObj
			);
			OLEDBG_END2

#if defined( _DEBUG )
			if (hrErr != NOERROR)
				OleDbgOutHResult("OleCreate returned", hrErr);
#endif

			break;

		case IOF_SELECTCREATEFROMFILE:

			OLEDBG_BEGIN2("OleCreateFromFile called\r\n")

			hrErr = OleCreateFromFileA(
					&CLSID_NULL,
					lpszFileName,
					&IID_IOleObject,
					dwOleRenderOpt,
					NULL,
					(LPOLECLIENTSITE)&lpContainerLine->m_OleClientSite,
					lpContainerLine->m_lpStg,
					(LPVOID FAR*)&lpContainerLine->m_lpOleObj
			);

			OLEDBG_END2

#if defined( _DEBUG )
			if (hrErr != NOERROR)
				OleDbgOutHResult("OleCreateFromFile returned", hrErr);
#endif
			break;

		case IOF_CHECKLINK:

			OLEDBG_BEGIN2("OleCreateLinkToFile called\r\n")

			hrErr = OleCreateLinkToFileA(
					lpszFileName,
					&IID_IOleObject,
					dwOleRenderOpt,
					NULL,
					(LPOLECLIENTSITE)&lpContainerLine->m_OleClientSite,
					lpContainerLine->m_lpStg,
					(LPVOID FAR*)&lpContainerLine->m_lpOleObj
			);

			OLEDBG_END2

#if defined( _DEBUG )
			if (hrErr != NOERROR)
				OleDbgOutHResult("OleCreateLinkToFile returned", hrErr);
#endif
			break;
	}
	if (hrErr != NOERROR)
		goto error;

	if (! ContainerLine_SetupOleObject(
								lpContainerLine, fDisplayAsIcon, hMetaPict)) {
		goto error;
	}

	/* OLE2NOTE: clear our re-entrancy guard. the object is now ready
	**    to have interface methods called.
	*/
	lpContainerLine->m_fGuardObj = FALSE;

	OLEDBG_END3
	return lpContainerLine;

error:
	OutlineApp_ErrorMessage(g_lpApp, "Could not create object!");

	// Destroy partially created OLE object
	if (lpContainerLine)
		ContainerLine_Delete(lpContainerLine);
	OLEDBG_END3
	return NULL;
}


LPCONTAINERLINE ContainerLine_CreateFromData(
		HDC                     hDC,
		UINT                    nTab,
		LPCONTAINERDOC          lpContainerDoc,
		LPDATAOBJECT            lpSrcDataObj,
		DWORD                   dwCreateType,
		CLIPFORMAT              cfFormat,
		BOOL                    fDisplayAsIcon,
		HGLOBAL                 hMetaPict,
		LPSTR                   lpszStgName
)
{
	HGLOBAL         hData = NULL;
	LPCONTAINERLINE lpContainerLine = NULL;
	LPOLEOBJECT     lpObj = NULL;
	LPSTORAGE       lpDocStg = ContainerDoc_GetStg(lpContainerDoc);
	DWORD           dwDrawAspect =
						(fDisplayAsIcon ? DVASPECT_ICON : DVASPECT_CONTENT);
	DWORD           dwOleRenderOpt;
	FORMATETC       renderFmtEtc;
	LPFORMATETC     lpRenderFmtEtc = NULL;
	HRESULT         hrErr;
	LPUNKNOWN       lpUnk = NULL;

	OLEDBG_BEGIN3("ContainerLine_CreateFromData\r\n")

	if (dwCreateType == OLECREATEFROMDATA_STATIC && cfFormat != 0) {
		// a particular type of static object should be created

		dwOleRenderOpt = OLERENDER_FORMAT;
		lpRenderFmtEtc = (LPFORMATETC)&renderFmtEtc;

		if (cfFormat == CF_METAFILEPICT)
			SETDEFAULTFORMATETC(renderFmtEtc, cfFormat, TYMED_MFPICT);
		else if (cfFormat == CF_BITMAP)
			SETDEFAULTFORMATETC(renderFmtEtc, cfFormat, TYMED_GDI);
		else
			SETDEFAULTFORMATETC(renderFmtEtc, cfFormat, TYMED_HGLOBAL);

	} else if (dwCreateType == OLECREATEFROMDATA_STATIC && fDisplayAsIcon) {
		// a link that currently displayed as an icon needs to be
		// converted to a STATIC picture object. this case is driven
		// from "BreakLink" in the "Links" dialog. because the current
		// data in the source object's cache is DVASPECT_ICON we need
		// to tell the OleCreateStaticFromData API to look for
		// DVASPECT_ICON data. the static object that results however,
		// is considered to be displayed in the DVASPECT_CONTENT view.

		dwOleRenderOpt = OLERENDER_DRAW;
		lpRenderFmtEtc = (LPFORMATETC)&renderFmtEtc;
		SETFORMATETC(renderFmtEtc,0,DVASPECT_ICON,NULL,TYMED_NULL,-1);
		dwDrawAspect = DVASPECT_CONTENT;   // static obj displays only CONTENT

	} else if (fDisplayAsIcon && hMetaPict) {
		// a special icon should be used. first we create the object
		// OLERENDER_NONE and then we stuff the special icon into the cache.

		dwOleRenderOpt = OLERENDER_NONE;

	} else if (fDisplayAsIcon && hMetaPict == NULL) {
		// the object's default icon should be used

		dwOleRenderOpt = OLERENDER_DRAW;
		lpRenderFmtEtc = (LPFORMATETC)&renderFmtEtc;
		SETFORMATETC(renderFmtEtc,0,DVASPECT_ICON,NULL,TYMED_NULL,-1);

	} else {
		// create standard DVASPECT_CONTENT/OLERENDER_DRAW object
		dwOleRenderOpt = OLERENDER_DRAW;
	}

	if (lpDocStg == NULL) {
		OleDbgAssertSz(lpDocStg != NULL, "Doc storage is NULL");
		goto error;
	}

	lpContainerLine=(LPCONTAINERLINE) New((DWORD)sizeof(CONTAINERLINE));
	if (lpContainerLine == NULL) {
		OleDbgAssertSz(lpContainerLine!=NULL,"Error allocating ContainerLine");
		goto error;
	}

	ContainerLine_Init(lpContainerLine, nTab, hDC);

	/* OLE2NOTE: in order to avoid re-entrancy we will set a flag to
	**    guard our object. if this guard is set, then the object is
	**    not ready to have any OLE interface methods called. it is
	**    necessary to guard the object this way while it is being
	**    created or loaded.
	*/
	lpContainerLine->m_fGuardObj = TRUE;

	/* OLE2NOTE: In order to have a stable ContainerLine object we must
	**    AddRef the object's refcnt. this will be later released when
	**    the ContainerLine is deleted.
	*/
	ContainerLine_AddRef(lpContainerLine);

	lstrcpy(lpContainerLine->m_szStgName, lpszStgName);
	lpContainerLine->m_lpDoc = lpContainerDoc;

	/* Create a new storage for the object inside the doc's storage */
	lpContainerLine->m_lpStg = OleStdCreateChildStorage(lpDocStg,lpszStgName);
	if (lpContainerLine->m_lpStg == NULL) {
		OleDbgAssert(lpContainerLine->m_lpStg != NULL);
		goto error;
	}

	switch (dwCreateType) {

		case OLECREATEFROMDATA_LINK:

			OLEDBG_BEGIN2("OleCreateLinkFromData called\r\n")
			hrErr = OleCreateLinkFromData (
					lpSrcDataObj,
					&IID_IOleObject,
					dwOleRenderOpt,
					lpRenderFmtEtc,
					(LPOLECLIENTSITE)&lpContainerLine->m_OleClientSite,
					lpContainerLine->m_lpStg,
					(LPVOID FAR*)&lpContainerLine->m_lpOleObj
			);
			OLEDBG_END2

#if defined( _DEBUG )
			if (hrErr != NOERROR)
				OleDbgOutHResult("OleCreateLinkFromData returned", hrErr);
#endif
			break;

		case OLECREATEFROMDATA_OBJECT:

			OLEDBG_BEGIN2("OleCreateFromData called\r\n")
			hrErr = OleCreateFromData (
					lpSrcDataObj,
					&IID_IOleObject,
					dwOleRenderOpt,
					lpRenderFmtEtc,
					(LPOLECLIENTSITE)&lpContainerLine->m_OleClientSite,
					lpContainerLine->m_lpStg,
					(LPVOID FAR*)&lpContainerLine->m_lpOleObj
			);
			OLEDBG_END2

#if defined( _DEBUG )
			if (hrErr != NOERROR)
				OleDbgOutHResult("OleCreateFromData returned", hrErr);
#endif
			break;

		case OLECREATEFROMDATA_STATIC:

			OLEDBG_BEGIN2("OleCreateStaticFromData called\r\n")
			hrErr = OleCreateStaticFromData (
					lpSrcDataObj,
					&IID_IOleObject,
					dwOleRenderOpt,
					lpRenderFmtEtc,
					(LPOLECLIENTSITE)&lpContainerLine->m_OleClientSite,
					lpContainerLine->m_lpStg,
					(LPVOID FAR*)&lpContainerLine->m_lpOleObj
			);
			OLEDBG_END2

#if defined( _DEBUG )
			if (hrErr != NOERROR)
				OleDbgOutHResult("OleCreateStaticFromData returned", hrErr);
#endif
			break;
	}

	if (hrErr != NOERROR)
		goto error;

	if (! ContainerLine_SetupOleObject(
								lpContainerLine, fDisplayAsIcon, hMetaPict)) {
		goto error;
	}

	/* OLE2NOTE: clear our re-entrancy guard. the object is now ready
	**    to have interface methods called.
	*/
	lpContainerLine->m_fGuardObj = FALSE;

	OLEDBG_END3
	return lpContainerLine;

error:
	OutlineApp_ErrorMessage(g_lpApp, "Could not create object!");
	// Destroy partially created OLE object
	if (lpContainerLine)
		ContainerLine_Delete(lpContainerLine);
	OLEDBG_END3
	return NULL;
}


/* ContainerLine_AddRef
** --------------------
**
**  increment the ref count of the line object.
**
**    Returns the new ref count on the object
*/
ULONG ContainerLine_AddRef(LPCONTAINERLINE lpContainerLine)
{
	++lpContainerLine->m_cRef;

#if defined( _DEBUG )
	OleDbgOutRefCnt4(
			"ContainerLine_AddRef: cRef++\r\n",
			lpContainerLine,
			lpContainerLine->m_cRef
	);
#endif
	return lpContainerLine->m_cRef;
}


/* ContainerLine_Release
** ---------------------
**
**  decrement the ref count of the line object.
**    if the ref count goes to 0, then the line is destroyed.
**
**    Returns the remaining ref count on the object
*/
ULONG ContainerLine_Release(LPCONTAINERLINE lpContainerLine)
{
	ULONG cRef;

	/*********************************************************************
	** OLE2NOTE: when the obj refcnt == 0, then destroy the object.     **
	**     otherwise the object is still in use.                        **
	*********************************************************************/

	cRef = --lpContainerLine->m_cRef;

#if defined( _DEBUG )
	OleDbgAssertSz(
			lpContainerLine->m_cRef >= 0,"Release called with cRef == 0");

	OleDbgOutRefCnt4(
			"ContainerLine_Release: cRef--\r\n",
			lpContainerLine,
			cRef
	);
#endif
	if (cRef == 0)
		ContainerLine_Destroy(lpContainerLine);

	return cRef;
}


/* ContainerLine_QueryInterface
** ----------------------------
**
** Retrieve a pointer to an interface on the ContainerLine object.
**
**    Returns NOERROR if interface is successfully retrieved.
**            E_NOINTERFACE if the interface is not supported
*/
HRESULT ContainerLine_QueryInterface(
		LPCONTAINERLINE         lpContainerLine,
		REFIID                  riid,
		LPVOID FAR*             lplpvObj
)
{
	SCODE sc = E_NOINTERFACE;

	/* OLE2NOTE: we must make sure to set all out ptr parameters to NULL. */
	*lplpvObj = NULL;

	if (IsEqualIID(riid, &IID_IUnknown)) {
		OleDbgOut4("ContainerLine_QueryInterface: IUnknown* RETURNED\r\n");

		*lplpvObj = (LPVOID) &lpContainerLine->m_Unknown;
		ContainerLine_AddRef(lpContainerLine);
		sc = S_OK;
	}
	else if (IsEqualIID(riid, &IID_IOleClientSite)) {
		OleDbgOut4("ContainerLine_QueryInterface: IOleClientSite* RETURNED\r\n");

		*lplpvObj = (LPVOID) &lpContainerLine->m_OleClientSite;
		ContainerLine_AddRef(lpContainerLine);
		sc = S_OK;
	}
	else if (IsEqualIID(riid, &IID_IAdviseSink)) {
		OleDbgOut4("ContainerLine_QueryInterface: IAdviseSink* RETURNED\r\n");

		*lplpvObj = (LPVOID) &lpContainerLine->m_AdviseSink;
		ContainerLine_AddRef(lpContainerLine);
		sc = S_OK;
	}
#if defined( INPLACE_CNTR )
	else if (IsEqualIID(riid, &IID_IOleWindow)
			 || IsEqualIID(riid, &IID_IOleInPlaceSite)) {
		OleDbgOut4("ContainerLine_QueryInterface: IOleInPlaceSite* RETURNED\r\n");

		*lplpvObj = (LPVOID) &lpContainerLine->m_OleInPlaceSite;
		ContainerLine_AddRef(lpContainerLine);
		sc = S_OK;
	}
#endif  // INPLACE_CNTR

	OleDbgQueryInterfaceMethod(*lplpvObj);

	return ResultFromScode(sc);
}


BOOL ContainerLine_LoadOleObject(LPCONTAINERLINE lpContainerLine)
{
	LPOUTLINEDOC    lpOutlineDoc = (LPOUTLINEDOC)lpContainerLine->m_lpDoc;
	LPSTORAGE       lpDocStg = ContainerDoc_GetStg(lpContainerLine->m_lpDoc);
	LPOLECLIENTSITE lpOleClientSite;
	LPMONIKER       lpmkObj;
	LPOLEAPP        lpOleApp = (LPOLEAPP)g_lpApp;
	BOOL            fPrevEnable1;
	BOOL            fPrevEnable2;
	HRESULT         hrErr;

	if (lpContainerLine->m_fGuardObj)
		return FALSE;                // object in process of creation

	if (lpContainerLine->m_lpOleObj)
		return TRUE;                // object already loaded

	OLEDBG_BEGIN3("ContainerLine_LoadOleObject\r\n")

	/* OLE2NOTE: in order to avoid re-entrancy we will set a flag to
	**    guard our object. if this guard is set, then the object is
	**    not ready to have any OLE interface methods called. it is
	**    necessary to guard the object this way while it is being
	**    created or loaded.
	*/
	lpContainerLine->m_fGuardObj = TRUE;

	/* if object storage is not already open, then open it */
	if (! lpContainerLine->m_lpStg) {
		lpContainerLine->m_lpStg = OleStdOpenChildStorage(
				lpDocStg,
				lpContainerLine->m_szStgName,
				STGM_READWRITE
		);
		if (lpContainerLine->m_lpStg == NULL) {
			OleDbgAssert(lpContainerLine->m_lpStg != NULL);
			goto error;
		}
	}

	/* OLE2NOTE: if the OLE object being loaded is in a data transfer
	**    document, then we should NOT pass a IOleClientSite* pointer
	**    to the OleLoad call. This particularly critical if the OLE
	**    object is an OleLink object. If a non-NULL client site is
	**    passed to the OleLoad function, then the link will bind to
	**    the source if its is running. in the situation that we are
	**    loading the object as part of a data transfer document we do
	**    not want this connection to be established. even worse, if
	**    the link source is currently blocked or busy, then this could
	**    hang the system. it is simplest to never pass a
	**    IOleClientSite* when loading an object in a data transfer
	**    document.
	*/
	lpOleClientSite = (lpOutlineDoc->m_fDataTransferDoc ?
			NULL : (LPOLECLIENTSITE)&lpContainerLine->m_OleClientSite);

	/* OLE2NOTE: we do not want to ever give the Busy/NotResponding
	**    dialogs when we are loading an object. if the object is a
	**    link, it will attempt to BindIfRunning to the link source. if
	**    the link source is currently busy, this could cause the Busy
	**    dialog to come up. even if the link source is busy,
	**    we do not want put up the busy dialog. thus we will disable
	**    the dialog and later re-enable them
	*/
	OleApp_DisableBusyDialogs(lpOleApp, &fPrevEnable1, &fPrevEnable2);

	OLEDBG_BEGIN2("OleLoad called\r\n")
	hrErr = OleLoad (
		   lpContainerLine->m_lpStg,
		   &IID_IOleObject,
		   lpOleClientSite,
		   (LPVOID FAR*)&lpContainerLine->m_lpOleObj
	);
	OLEDBG_END2

	// re-enable the Busy/NotResponding dialogs
	OleApp_EnableBusyDialogs(lpOleApp, fPrevEnable1, fPrevEnable2);

	if (hrErr != NOERROR) {
		OleDbgAssertSz(hrErr == NOERROR, "Could not load object!");
		OleDbgOutHResult("OleLoad returned", hrErr);
		goto error;
	}

	/* Cache a pointer to the IViewObject2* interface. *Required*
	**      we need this everytime we draw the object.
	**
	** OLE2NOTE: We require the object to support IViewObject2
	**    interface. this is an extension to the IViewObject interface
	**    that was added with the OLE 2.01 release. This interface must
	**    be supported by all object handlers and DLL-based objects.
	*/
	lpContainerLine->m_lpViewObj2 = (LPVIEWOBJECT2)OleStdQueryInterface(
			(LPUNKNOWN)lpContainerLine->m_lpOleObj, &IID_IViewObject2);
	if (! lpContainerLine->m_lpViewObj2) {
#if defined( _DEBUG )
		OleDbgAssertSz(
			lpContainerLine->m_lpViewObj2,"IViewObject2 NOT supported\r\n");
#endif
		goto error;
	}

	// Cache a pointer to the IPersistStorage* interface. *Required*
	//      we need this everytime we save the object.
	lpContainerLine->m_lpPersistStg = (LPPERSISTSTORAGE)OleStdQueryInterface(
			(LPUNKNOWN)lpContainerLine->m_lpOleObj, &IID_IPersistStorage);
	if (! lpContainerLine->m_lpPersistStg) {
		OleDbgAssert(lpContainerLine->m_lpPersistStg);
		goto error;
	}

	// Cache a pointer to the IOleLink* interface if supported. *Optional*
	//      if supported the object is a link. we need this to manage the link
	if (lpContainerLine->m_dwLinkType != 0) {
		lpContainerLine->m_lpOleLink = (LPOLELINK)OleStdQueryInterface(
				(LPUNKNOWN)lpContainerLine->m_lpOleObj, &IID_IOleLink);
		if (! lpContainerLine->m_lpOleLink) {
			OleDbgAssert(lpContainerLine->m_lpOleLink);
			goto error;
		}
	}

	/* OLE2NOTE: clear our re-entrancy guard. the object is now ready
	**    to have interface methods called.
	*/
	lpContainerLine->m_fGuardObj = FALSE;

	/* OLE2NOTE: similarly, if the OLE object being loaded is in a data
	**    transfer document, then we do NOT need to setup any advises,
	**    call SetHostNames, SetMoniker, etc.
	*/
	if (lpOleClientSite) {
		/* Setup the Advises (OLE notifications) that we are interested
		** in receiving.
		*/
		OleStdSetupAdvises(
				lpContainerLine->m_lpOleObj,
				lpContainerLine->m_dwDrawAspect,
				(LPSTR)APPNAME,
				lpOutlineDoc->m_lpszDocTitle,
				(LPADVISESINK)&lpContainerLine->m_AdviseSink,
				FALSE   /*fCreate*/
		);

		/* OLE2NOTE: if the OLE object has a moniker assigned, we need to
		**    inform the object by calling IOleObject::SetMoniker. this
		**    will force the OLE object to register in the
		**    RunningObjectTable when it enters the running state.
		*/
		if (lpContainerLine->m_fMonikerAssigned) {
			lpmkObj = ContainerLine_GetRelMoniker(
					lpContainerLine,
					GETMONIKER_ONLYIFTHERE
			);

			if (lpmkObj) {
				OLEDBG_BEGIN2("IOleObject::SetMoniker called\r\n")
				lpContainerLine->m_lpOleObj->lpVtbl->SetMoniker(
						lpContainerLine->m_lpOleObj,
						OLEWHICHMK_OBJREL,
						lpmkObj
				);
				OLEDBG_END2
				OleStdRelease((LPUNKNOWN)lpmkObj);
			}
		}

		/* get the Short form of the user type name of the object. this
		**    is used all the time when we have to build the object
		**    verb menu. we will cache this information to make it
		**    quicker to build the verb menu.
		*/
		OLEDBG_BEGIN2("IOleObject::GetUserType called\r\n")
		CallIOleObjectGetUserTypeA(
				lpContainerLine->m_lpOleObj,
				USERCLASSTYPE_SHORT,
				&lpContainerLine->m_lpszShortType
		);

		OLEDBG_END2

#if defined( INPLACE_CNTR )
		/* OLE2NOTE: an inside-out container should check if the object
		**    is an inside-out and prefers to be activated when visible
		**    type of object. if so, the object should be immediately
		**    activated in-place, BUT NOT UIActived.
		*/
		if (g_fInsideOutContainer &&
				lpContainerLine->m_dwDrawAspect == DVASPECT_CONTENT) {
			DWORD mstat;
			OLEDBG_BEGIN2("IOleObject::GetMiscStatus called\r\n")
			lpContainerLine->m_lpOleObj->lpVtbl->GetMiscStatus(
					lpContainerLine->m_lpOleObj,
					DVASPECT_CONTENT,
					(DWORD FAR*)&mstat
			);
			OLEDBG_END2

			lpContainerLine->m_fInsideOutObj = (BOOL)
				   (mstat & (OLEMISC_INSIDEOUT|OLEMISC_ACTIVATEWHENVISIBLE));

			if ( lpContainerLine->m_fInsideOutObj ) {
				HWND hWndDoc = OutlineDoc_GetWindow(lpOutlineDoc);

				ContainerLine_DoVerb(
						lpContainerLine,
						OLEIVERB_INPLACEACTIVATE,
						NULL,
						FALSE,
						FALSE
				);

				/* OLE2NOTE: following this DoVerb(INPLACEACTIVATE) the
				**    object may have taken focus. but because the
				**    object is NOT UIActive it should NOT have focus.
				**    we will make sure our document has focus.
				*/
				SetFocus(hWndDoc);
			}
		}
#endif  // INPLACE_CNTR
		OLEDBG_END2

	}

	OLEDBG_END2
	return TRUE;

error:
	OLEDBG_END2
	return FALSE;
}


/* ContainerLine_CloseOleObject
** ----------------------------
**    Close the OLE object associated with the ContainerLine.
**
**    Closing the object forces the object to transition from the
**    running state to the loaded state. if the object was not running,
**    then there is no effect. it is necessary to close the OLE object
**    before releasing the pointers to the OLE object.
**
**    Returns TRUE if successfully closed,
**            FALSE if closing was aborted.
*/
BOOL ContainerLine_CloseOleObject(
		LPCONTAINERLINE         lpContainerLine,
		DWORD                   dwSaveOption
)
{
	HRESULT hrErr;
	SCODE   sc;

	if (lpContainerLine->m_fGuardObj)
		return FALSE;                // object in process of creation

	if (! lpContainerLine->m_lpOleObj)
		return TRUE;    // object is NOT loaded

	OLEDBG_BEGIN2("IOleObject::Close called\r\n")
	hrErr = lpContainerLine->m_lpOleObj->lpVtbl->Close(
			lpContainerLine->m_lpOleObj,
			(dwSaveOption == OLECLOSE_NOSAVE ?
					OLECLOSE_NOSAVE : OLECLOSE_SAVEIFDIRTY)
	);
	OLEDBG_END2

#if defined( INPLACE_CNTR )
	if (lpContainerLine->m_fIpServerRunning) {
		/* OLE2NOTE: unlock the lock held on the in-place object.
		**    it is VERY important that an in-place container
		**    that also support linking to embeddings properly manage
		**    the running of its in-place objects. in an outside-in
		**    style in-place container, when the user clicks
		**    outside of the in-place active object, the object gets
		**    UIDeactivated and the object hides its window. in order
		**    to make the object fast to reactivate, the container
		**    deliberately does not call IOleObject::Close. the object
		**    stays running in the invisible unlocked state. the idea
		**    here is if the user simply clicks outside of the object
		**    and then wants to double click again to re-activate the
		**    object, we do not want this to be slow. if we want to
		**    keep the object running, however, we MUST Lock it
		**    running. otherwise the object will be in an unstable
		**    state where if a linking client does a "silent-update"
		**    (eg. UpdateNow from the Links dialog), then the in-place
		**    server will shut down even before the object has a chance
		**    to be saved back in its container. this saving normally
		**    occurs when the in-place container closes the object. also
		**    keeping the object in the unstable, hidden, running,
		**    not-locked state can cause problems in some scenarios.
		**    ICntrOtl keeps only one object running. if the user
		**    intiates a DoVerb on another object, then that last
		**    running in-place active object is closed. a more
		**    sophistocated in-place container may keep more object running.
		**    (see CntrLine_IPSite_OnInPlaceActivate)
		*/
		lpContainerLine->m_fIpServerRunning = FALSE;

		OLEDBG_BEGIN2("OleLockRunning(FALSE,TRUE) called\r\n")
		OleLockRunning((LPUNKNOWN)lpContainerLine->m_lpOleObj, FALSE, TRUE);
		OLEDBG_END2
	}
#endif

	if (hrErr != NOERROR) {
		OleDbgOutHResult("IOleObject::Close returned", hrErr);
		sc = GetScode(hrErr);
		if (sc == RPC_E_CALL_REJECTED || sc==OLE_E_PROMPTSAVECANCELLED)
			return FALSE;   // object aborted shutdown
	}
	return TRUE;
}


/* ContainerLine_UnloadOleObject
** -----------------------------
**    Close the OLE object associated with the ContainerLine and
**    release all pointer held to the object.
**
**    Closing the object forces the object to transition from the
**    running state to the loaded state. if the object was not running,
**    then there is no effect. it is necessary to close the OLE object
**    before releasing the pointers to the OLE object. releasing all
**    pointers to the object allows the object to transition from
**    loaded to unloaded (or passive).
*/
void ContainerLine_UnloadOleObject(
		LPCONTAINERLINE         lpContainerLine,
		DWORD                   dwSaveOption
)
{
	if (lpContainerLine->m_lpOleObj) {

		OLEDBG_BEGIN2("IOleObject::Close called\r\n")
		lpContainerLine->m_lpOleObj->lpVtbl->Close(
				lpContainerLine->m_lpOleObj, dwSaveOption);
		OLEDBG_END2

		/* OLE2NOTE: we will take our IOleClientSite* pointer away from
		**    the object before we release all pointers to the object.
		**    in the scenario where the object is implemented as an
		**    in-proc server (DLL object), then, if there are link
		**    connections to the DLL object, it is possible that the
		**    object will not be destroyed when we release our pointers
		**    to the object. the existance of the remote link
		**    connections will hold the object alive. later when these
		**    strong connections are released, then the object may
		**    attempt to call IOleClientSite::Save if we had not taken
		**    away the client site pointer.
		*/
		OLEDBG_BEGIN2("IOleObject::SetClientSite(NULL) called\r\n")
		lpContainerLine->m_lpOleObj->lpVtbl->SetClientSite(
				lpContainerLine->m_lpOleObj, NULL);
		OLEDBG_END2

		OleStdRelease((LPUNKNOWN)lpContainerLine->m_lpOleObj);
		lpContainerLine->m_lpOleObj = NULL;

		if (lpContainerLine->m_lpViewObj2) {
			OleStdRelease((LPUNKNOWN)lpContainerLine->m_lpViewObj2);
			lpContainerLine->m_lpViewObj2 = NULL;
		}
		if (lpContainerLine->m_lpPersistStg) {
			OleStdRelease((LPUNKNOWN)lpContainerLine->m_lpPersistStg);
			lpContainerLine->m_lpPersistStg = NULL;
		}

		if (lpContainerLine->m_lpOleLink) {
			OleStdRelease((LPUNKNOWN)lpContainerLine->m_lpOleLink);
			lpContainerLine->m_lpOleLink = NULL;
		}
	}

	if (lpContainerLine->m_lpszShortType) {
		OleStdFreeString(lpContainerLine->m_lpszShortType, NULL);
		lpContainerLine->m_lpszShortType = NULL;
	}
}


/* ContainerLine_Delete
** --------------------
**    Delete the ContainerLine.
**
**    NOTE: we can NOT directly destroy the memory for the
**    ContainerLine; the ContainerLine maintains a reference count. a
**    non-zero reference count indicates that the object is still
**    in-use. The OleObject keeps a reference-counted pointer to the
**    ClientLine object. we must take the actions necessary so that the
**    ContainerLine object receives Releases for outstanding
**    references. when the reference count of the ContainerLine reaches
**    zero, then the memory for the object will actually be destroyed
**    (ContainerLine_Destroy called).
**
*/
void ContainerLine_Delete(LPCONTAINERLINE lpContainerLine)
{
	OLEDBG_BEGIN2("ContainerLine_Delete\r\n")

#if defined( INPLACE_CNTR )
	if (lpContainerLine == lpContainerLine->m_lpDoc->m_lpLastIpActiveLine)
		lpContainerLine->m_lpDoc->m_lpLastIpActiveLine = NULL;
	if (lpContainerLine == lpContainerLine->m_lpDoc->m_lpLastUIActiveLine)
		lpContainerLine->m_lpDoc->m_lpLastUIActiveLine = NULL;
#endif

	/* OLE2NOTE: in order to have a stable line object during the
	**    process of deleting, we intially AddRef the line ref cnt and
	**    later Release it. This initial AddRef is artificial; it is
	**    simply done to guarantee that our object does not destroy
	**    itself until the END of this routine.
	*/
	ContainerLine_AddRef(lpContainerLine);

	// Unload the loaded OLE object
	if (lpContainerLine->m_lpOleObj)
		ContainerLine_UnloadOleObject(lpContainerLine, OLECLOSE_NOSAVE);

	/* OLE2NOTE: we can NOT directly free the memory for the ContainerLine
	**    data structure until everyone holding on to a pointer to our
	**    ClientSite interface and IAdviseSink interface has released
	**    their pointers. There is one refcnt on the ContainerLine object
	**    which is held by the container itself. we will release this
	**    refcnt here.
	*/
	ContainerLine_Release(lpContainerLine);

	/* OLE2NOTE: this call forces all external connections to our
	**    ContainerLine to close down and therefore guarantees that
	**    we receive all releases associated with those external
	**    connections. Strictly this call should NOT be necessary, but
	**    it is defensive coding to make this call.
	*/
	OLEDBG_BEGIN2("CoDisconnectObject(lpContainerLine) called\r\n")
	CoDisconnectObject((LPUNKNOWN)&lpContainerLine->m_Unknown, 0);
	OLEDBG_END2

#if defined( _DEBUG )
	/* at this point the object all references from the OLE object to
	**    our ContainerLine object should have been released. there
	**    should only be 1 remaining reference that will be released below.
	*/
	if (lpContainerLine->m_cRef != 1) {
		OleDbgOutRefCnt(
			"WARNING: ContainerLine_Delete: cRef != 1\r\n",
			lpContainerLine,
			lpContainerLine->m_cRef
		);
	}
#endif

	ContainerLine_Release(lpContainerLine); // release artificial AddRef above
	OLEDBG_END2
}


/* ContainerLine_Destroy
** ---------------------
**    Destroy (Free) the memory used by a ContainerLine structure.
**    This function is called when the ref count of the ContainerLine goes
**    to zero. the ref cnt goes to zero after ContainerLine_Delete forces
**    the OleObject to unload and release its pointers to the
**    ContainerLine IOleClientSite and IAdviseSink interfaces.
*/

void ContainerLine_Destroy(LPCONTAINERLINE lpContainerLine)
{
	LPUNKNOWN lpTmpObj;

	OLEDBG_BEGIN2("ContainerLine_Destroy\r\n")

	// Release the storage opened for the OLE object
	if (lpContainerLine->m_lpStg) {
		lpTmpObj = (LPUNKNOWN)lpContainerLine->m_lpStg;
		lpContainerLine->m_lpStg = NULL;

		OleStdRelease(lpTmpObj);
	}

	if (lpContainerLine->m_lpszShortType) {
		OleStdFreeString(lpContainerLine->m_lpszShortType, NULL);
		lpContainerLine->m_lpszShortType = NULL;
	}

	Delete(lpContainerLine);        // Free the memory for the structure itself
	OLEDBG_END2
}


/* ContainerLine_CopyToDoc
 * -----------------------
 *
 *      Copy a ContainerLine to another Document (usually ClipboardDoc)
 */
BOOL ContainerLine_CopyToDoc(
		LPCONTAINERLINE         lpSrcLine,
		LPOUTLINEDOC            lpDestDoc,
		int                     nIndex
)
{
	LPCONTAINERLINE lpDestLine = NULL;
	LPLINELIST  lpDestLL = &lpDestDoc->m_LineList;
	HDC         hDC;
	HRESULT     hrErr;
	BOOL        fStatus;
	LPSTORAGE   lpDestDocStg = ((LPOLEDOC)lpDestDoc)->m_lpStg;
	LPSTORAGE   lpDestObjStg = NULL;

	lpDestLine = (LPCONTAINERLINE) New((DWORD)sizeof(CONTAINERLINE));
	if (lpDestLine == NULL) {
		OleDbgAssertSz(lpDestLine!=NULL, "Error allocating ContainerLine");
		return FALSE;
	}

	hDC = LineList_GetDC(lpDestLL);
	ContainerLine_Init(lpDestLine, ((LPLINE)lpSrcLine)->m_nTabLevel, hDC);
	LineList_ReleaseDC(lpDestLL, hDC);

	/* OLE2NOTE: In order to have a stable ContainerLine object we must
	**    AddRef the object's refcnt. this will be later released when
	**    the ContainerLine is deleted.
	*/
	ContainerLine_AddRef(lpDestLine);

	lpDestLine->m_lpDoc = (LPCONTAINERDOC)lpDestDoc;

	// Copy data of the original source ContainerLine.
	((LPLINE)lpDestLine)->m_nWidthInHimetric =
			((LPLINE)lpSrcLine)->m_nWidthInHimetric;
	((LPLINE)lpDestLine)->m_nHeightInHimetric =
			((LPLINE)lpSrcLine)->m_nHeightInHimetric;
	lpDestLine->m_fMonikerAssigned = lpSrcLine->m_fMonikerAssigned;
	lpDestLine->m_dwDrawAspect = lpSrcLine->m_dwDrawAspect;
	lpDestLine->m_sizeInHimetric = lpSrcLine->m_sizeInHimetric;
	lpDestLine->m_dwLinkType = lpSrcLine->m_dwLinkType;


	/* We must create a new sub-storage for the embedded object within
	**    the destination document's storage. We will first attempt to
	**    use the same storage name as the source line. if this name is
	**    in use, then we will allocate a new name. in this way we try
	**    to keep the name associated with the OLE object unchanged
	**    through a Cut/Paste operation.
	*/
	lpDestObjStg = OleStdCreateChildStorage(
			lpDestDocStg,
			lpSrcLine->m_szStgName
	);
	if (lpDestObjStg) {
		lstrcpy(lpDestLine->m_szStgName, lpSrcLine->m_szStgName);
	} else {
		/* the original name was in use, make up a new name. */
		ContainerDoc_GetNextStgName(
				(LPCONTAINERDOC)lpDestDoc,
				lpDestLine->m_szStgName,
				sizeof(lpDestLine->m_szStgName)
		);
		lpDestObjStg = OleStdCreateChildStorage(
				lpDestDocStg,
				lpDestLine->m_szStgName
		);
	}
	if (lpDestObjStg == NULL) {
		OleDbgAssertSz(lpDestObjStg != NULL, "Error creating child stg");
		goto error;
	}

	// Copy over storage of the embedded object itself

	if (! lpSrcLine->m_lpOleObj) {

		/*****************************************************************
		** CASE 1: object is NOT loaded.
		**    because the object is not loaded, we can simply copy the
		**    object's current storage to the new storage.
		*****************************************************************/

		/* if current object storage is not already open, then open it */
		if (! lpSrcLine->m_lpStg) {
			LPSTORAGE lpSrcDocStg = ((LPOLEDOC)lpSrcLine->m_lpDoc)->m_lpStg;

			if (! lpSrcDocStg) goto error;

			// open object storage.
			lpSrcLine->m_lpStg = OleStdOpenChildStorage(
					lpSrcDocStg,
					lpSrcLine->m_szStgName,
					STGM_READWRITE
			);
			if (lpSrcLine->m_lpStg == NULL) {
#if defined( _DEBUG )
				OleDbgAssertSz(
						lpSrcLine->m_lpStg != NULL,
						"Error opening child stg"
				);
#endif
				goto error;
			}
		}

		hrErr = lpSrcLine->m_lpStg->lpVtbl->CopyTo(
				lpSrcLine->m_lpStg,
				0,
				NULL,
				NULL,
				lpDestObjStg
		);
		if (hrErr != NOERROR) {
			OleDbgOutHResult("WARNING: lpSrcObjStg->CopyTo returned", hrErr);
			goto error;
		}

		fStatus = OleStdCommitStorage(lpDestObjStg);

	} else {

		/*****************************************************************
		** CASE 2: object IS loaded.
		**    we must tell the object to save into the new storage.
		*****************************************************************/

		SCODE sc = S_OK;
		LPPERSISTSTORAGE lpPersistStg = lpSrcLine->m_lpPersistStg;
		OleDbgAssert(lpPersistStg);

		OLEDBG_BEGIN2("OleSave called\r\n")
		hrErr = OleSave(lpPersistStg, lpDestObjStg, FALSE /*fSameAsLoad*/);
		OLEDBG_END2

		if (hrErr != NOERROR) {
			OleDbgOutHResult("WARNING: OleSave returned", hrErr);
			sc = GetScode(hrErr);
		}

		// OLE2NOTE: even if OleSave fails, SaveCompleted must be called.
		OLEDBG_BEGIN2("IPersistStorage::SaveCompleted called\r\n")
		hrErr=lpPersistStg->lpVtbl->SaveCompleted(lpPersistStg,NULL);
		OLEDBG_END2

		if (hrErr != NOERROR) {
			OleDbgOutHResult("WARNING: SaveCompleted returned",hrErr);
			if (sc == S_OK)
				sc = GetScode(hrErr);
		}

		if (sc != S_OK)
			goto error;

	}

	OutlineDoc_AddLine(lpDestDoc, (LPLINE)lpDestLine, nIndex);
	OleStdVerifyRelease(
			(LPUNKNOWN)lpDestObjStg,
			"Copied object stg not released"
	);

	return TRUE;

error:

	// Delete any partially created storage.
	if (lpDestObjStg) {

		OleStdVerifyRelease(
				(LPUNKNOWN)lpDestObjStg,
				"Copied object stg not released"
		);

		CallIStorageDestroyElementA(
				lpDestDocStg,
				lpDestLine->m_szStgName
		);

		lpDestLine->m_szStgName[0] = '\0';
	}

	// destroy partially created ContainerLine
	if (lpDestLine)
		ContainerLine_Delete(lpDestLine);
	return FALSE;
}


/* ContainerLine_UpdateExtent
** --------------------------
**   Update the size of the ContainerLine because the extents of the
**    object may have changed.
**
**    NOTE: because we are using a Windows OwnerDraw ListBox, we must
**    constrain the maximum possible height of a line. the ListBox has
**    a limitation (unfortunately) that no line can become larger than
**    255 pixels. thus we force the object to scale maintaining its
**    aspect ratio if this maximum line height limit is reached. the
**    actual maximum size for an object at 100% Zoom is
**    255
**
**    RETURNS TRUE -- if the extents of the object changed
**            FALSE -- if the extents did NOT change
*/
BOOL ContainerLine_UpdateExtent(
		LPCONTAINERLINE     lpContainerLine,
		LPSIZEL             lpsizelHim
)
{
	LPOUTLINEDOC lpOutlineDoc = (LPOUTLINEDOC)lpContainerLine->m_lpDoc;
	LPLINELIST lpLL = OutlineDoc_GetLineList(lpOutlineDoc);
	LPLINE lpLine = (LPLINE)lpContainerLine;
	int nIndex = LineList_GetLineIndex(lpLL, lpLine);
	UINT nOrgWidthInHimetric = lpLine->m_nWidthInHimetric;
	UINT nOrgHeightInHimetric = lpLine->m_nHeightInHimetric;
	BOOL fWidthChanged = FALSE;
	BOOL fHeightChanged = FALSE;
	SIZEL sizelHim;
	HRESULT hrErr;

	if (!lpContainerLine || !lpContainerLine->m_lpOleObj)
		return FALSE;

	if (lpContainerLine->m_fGuardObj)
		return FALSE;                // object in process of creation

	OLEDBG_BEGIN3("ContainerLine_UpdateExtent\r\n");

	lpContainerLine->m_fDoGetExtent = FALSE;

	if (! lpsizelHim) {
		/* OLE2NOTE: We want to call IViewObject2::GetExtent instead of
		**    IOleObject::GetExtent. IViewObject2::GetExtent method was
		**    added in OLE 2.01 release. It always retrieves the
		**    extents of the object corresponding to that which will be
		**    drawn by calling IViewObject::Draw. Normally, this is
		**    determined by the data stored in the data cache. This
		**    call will never result in a remoted (LRPC) call.
		*/
		OLEDBG_BEGIN2("IViewObject2::GetExtent called\r\n")
		hrErr = lpContainerLine->m_lpViewObj2->lpVtbl->GetExtent(
				lpContainerLine->m_lpViewObj2,
				lpContainerLine->m_dwDrawAspect,
				-1,     /*lindex*/
				NULL,   /*ptd*/
				(LPSIZEL)&sizelHim
		);
		OLEDBG_END2
		if (hrErr != NOERROR)
			sizelHim.cx = sizelHim.cy = 0;

		lpsizelHim = (LPSIZEL)&sizelHim;
	}

	if (lpsizelHim->cx == lpContainerLine->m_sizeInHimetric.cx &&
		lpsizelHim->cy == lpContainerLine->m_sizeInHimetric.cy) {
		goto noupdate;
	}

	if (lpsizelHim->cx > 0 || lpsizelHim->cy > 0) {
		lpContainerLine->m_sizeInHimetric = *lpsizelHim;
	} else {
		/* object does not have any extents; let's use our container
		**    chosen arbitrary size for OLE objects.
		*/
		lpContainerLine->m_sizeInHimetric.cx = (long)DEFOBJWIDTH;
		lpContainerLine->m_sizeInHimetric.cy = (long)DEFOBJHEIGHT;
	}

	ContainerLine_SetLineHeightFromObjectExtent(
			lpContainerLine,
			(LPSIZEL)&lpContainerLine->m_sizeInHimetric);

	// if height of object changed, then reset the height of line in LineList
	if (nOrgHeightInHimetric != lpLine->m_nHeightInHimetric) {
		LineList_SetLineHeight(lpLL, nIndex, lpLine->m_nHeightInHimetric);
		fHeightChanged = TRUE;
	}

	fWidthChanged = LineList_RecalcMaxLineWidthInHimetric(
			lpLL,
			nOrgWidthInHimetric
	);
	fWidthChanged |= (nOrgWidthInHimetric != lpLine->m_nWidthInHimetric);

	if (fHeightChanged || fWidthChanged) {
		OutlineDoc_ForceRedraw(lpOutlineDoc, TRUE);

		// mark ContainerDoc as now dirty
		OutlineDoc_SetModified(lpOutlineDoc, TRUE, TRUE, TRUE);
	}

	OLEDBG_END3
	return TRUE;

noupdate:
	OLEDBG_END3
	return FALSE;   // No UPDATE necessary
}


/* ContainerLine_DoVerb
** --------------------
**    Activate the OLE object and perform a specific verb.
*/
BOOL ContainerLine_DoVerb(
		LPCONTAINERLINE lpContainerLine,
		LONG            iVerb,
		LPMSG           lpMsg,
		BOOL            fMessage,
		BOOL            fAction
)
{
	HRESULT hrErr;
	LPOUTLINEDOC lpOutlineDoc = (LPOUTLINEDOC)lpContainerLine->m_lpDoc;
	RECT rcPosRect;
	OLEDBG_BEGIN3("ContainerLine_DoVerb\r\n")

	if (lpContainerLine->m_fGuardObj) {
		// object in process of creation--Fail the DoVerb call
		hrErr = ResultFromScode(E_FAIL);
		goto error;
	}

	/* if object is not already loaded, then load it now. objects are
	**    loaded lazily in this manner.
	*/
	if (! lpContainerLine->m_lpOleObj)
		ContainerLine_LoadOleObject(lpContainerLine);

	if (! lpContainerLine->m_lpOleObj) {
#if defined( _DEBUG )
		OleDbgAssertSz(
				lpContainerLine->m_lpOleObj != NULL,
				"OLE object not loaded"
		);
#endif
		goto error;
	}

ExecuteDoVerb:

	ContainerLine_GetPosRect(lpContainerLine, (LPRECT)&rcPosRect);

	// run the object
	hrErr = ContainerLine_RunOleObject(lpContainerLine);
	if (hrErr != NOERROR)
		goto error;

	/* Tell object server to perform a "verb". */
	OLEDBG_BEGIN2("IOleObject::DoVerb called\r\n")
	hrErr = lpContainerLine->m_lpOleObj->lpVtbl->DoVerb (
			lpContainerLine->m_lpOleObj,
			iVerb,
			lpMsg,
			(LPOLECLIENTSITE)&lpContainerLine->m_OleClientSite,
			-1,
			OutlineDoc_GetWindow(lpOutlineDoc),
			(LPCRECT)&rcPosRect
	);
	OLEDBG_END2

	/* OLE2NOTE: IOleObject::DoVerb may return a success code
	**    OLE_S_INVALIDVERB. this SCODE should NOT be considered an
	**    error; thus it is important to use the "FAILED" macro to
	**    check for an error SCODE.
	*/
	if (FAILED(GetScode(hrErr))) {
		OleDbgOutHResult("WARNING: lpOleObj->DoVerb returned", hrErr);
		goto error;
	}

#if defined( INPLACE_CNTR )
	/* OLE2NOTE: we want to keep only 1 inplace server active at any
	**    given time. so when we start to do a DoVerb on another line,
	**    then we want to shut down the previously activated server. in
	**    this way we keep at most one inplace server active at a time.
	**    because it is possible that the object we want to do DoVerb
	**    on is handled by the same EXE as that of the previously
	**    activated server, then we do not want the EXE to be shut down
	**    only to be launched again. in order to avoid this we will do
	**    the DoVerb BEFORE trying to shutdown the previous object.
	*/
	if (!g_fInsideOutContainer) {
		ContainerDoc_ShutDownLastInPlaceServerIfNotNeeded(
				lpContainerLine->m_lpDoc, lpContainerLine);
	}
#endif  // INPLACE_CNTR

	OLEDBG_END3
	return TRUE;

error:

	if (lpContainerLine->m_dwLinkType != 0)
		lpContainerLine->m_fLinkUnavailable = TRUE;

#if defined( INPLACE_CNTR )
	/* OLE2NOTE: we want to keep only 1 inplace server active at any
	**    given time. so when we start to do a DoVerb on another line,
	**    then we want to shut down the previously activated server. in
	**    this way we keep at most one inplace server active at a time.
	**    even though the DoVerb failed, we will still shutdown the
	**    previous server. it is possible that we ran out of memory and
	**    that the DoVerb will succeed next time after shutting down
	**    the pervious server.
	*/
	if (!g_fInsideOutContainer) {
		ContainerDoc_ShutDownLastInPlaceServerIfNotNeeded(
				lpContainerLine->m_lpDoc, lpContainerLine);
	}
#endif  // INPLACE_CNTR

	/* OLE2NOTE: if an error occurs we must give the appropriate error
	**    message box. there are many potential errors that can occur.
	**    the OLE2.0 user model has specific guidelines as to the
	**    dialogs that should be displayed given the various potential
	**    errors (eg. server not registered, unavailable link source.
	**    the OLE2UI library includes support for most of the
	**    recommended message dialogs. (see OleUIPrompUser function)
	*/
	if (fMessage) {
		BOOL fReDoVerb = ContainerLine_ProcessOleRunError(
				lpContainerLine,
				hrErr,
				fAction,
				(lpMsg==NULL && iVerb>=0)   /* fMenuInvoked */
		);
		if (fReDoVerb) {
			goto ExecuteDoVerb;
		}
	}

	OLEDBG_END3
	return FALSE;
}



/* ContainerLine_ProcessOleRunError
 * --------------------------------
 *
 *  Handle the various errors possible when attempting OleRun of an object.
 *  Popup up appropriate message according to the error and/or take action
 *  specified button pressed by the user.
 *
 *  OLE2NOTE: The OLE 2.0 User Interface Guidelines specify the messages
 *            that should be given for the following situations:
 *                  1. Link Source Unavailable...goto Links dialog
 *                  2. Server Not Registered...goto Convert dialog
 *                  3. Link Type Changed
 *                  4. Server Not Found
 *
 *  Returns:    TRUE -- repeat IOleObject::DoVerb call.
 *              FALSE -- do NOT repeat IOleObject::DoVerb call.
 *
 *  Comments:
 *      (see LinkTypeChanged case)
 */
BOOL ContainerLine_ProcessOleRunError(
		LPCONTAINERLINE         lpContainerLine,
		HRESULT                 hrErr,
		BOOL                    fAction,
		BOOL                    fMenuInvoked
)
{
	LPOUTLINEDOC    lpOutlineDoc = (LPOUTLINEDOC)lpContainerLine->m_lpDoc;
	HWND            hwndParent = OutlineDoc_GetWindow(lpOutlineDoc);
	SCODE           sc = GetScode(hrErr);
	BOOL            fReDoVerb = FALSE;

	OleDbgOutHResult("ProcessError", hrErr);
	if ((sc >= MK_E_FIRST) && (sc <= MK_E_LAST))
		goto LinkSourceUnavailable;
	if (sc == OLE_E_CANT_BINDTOSOURCE)
		goto LinkSourceUnavailable;
	if (sc == STG_E_PATHNOTFOUND)
		goto LinkSourceUnavailable;
	if (sc == REGDB_E_CLASSNOTREG)
		goto ServerNotReg;
	if (sc == OLE_E_STATIC)
		goto ServerNotReg;  // user dblclk'ed a static object w/ no svr reg'd
	if (sc == OLE_E_CLASSDIFF)
		goto LinkTypeChanged;
	if (sc == CO_E_APPDIDNTREG)
		goto ServerNotFound;
	if (sc == CO_E_APPNOTFOUND)
		goto ServerNotFound;
	if (sc == E_OUTOFMEMORY)
		goto OutOfMemory;

	if (ContainerLine_IsOleLink(lpContainerLine))
		goto LinkSourceUnavailable;
	else
		goto ServerNotFound;


/*************************************************************************
** Error handling routines                                              **
*************************************************************************/
LinkSourceUnavailable:
	if (ID_PU_LINKS == OleUIPromptUser(
				(WORD)IDD_LINKSOURCEUNAVAILABLE,
				hwndParent,
				(LPSTR)APPNAME)) {
		if (fAction) {
			ContainerDoc_EditLinksCommand(lpContainerLine->m_lpDoc);
		}
	}
	return fReDoVerb;

ServerNotReg:
	{
	LPSTR lpszUserType = NULL;
	CLIPFORMAT  cfFormat;	    // not used

	hrErr = ReadFmtUserTypeStgA(
			lpContainerLine->m_lpStg, &cfFormat, &lpszUserType);

	if (ID_PU_CONVERT == OleUIPromptUser(
			(WORD)IDD_SERVERNOTREG,
			hwndParent,
			(LPSTR)APPNAME,
			(hrErr == NOERROR) ? lpszUserType : (LPSTR)"Unknown Object")) {
		if (fAction) {
			ContainerDoc_ConvertCommand(
					lpContainerLine->m_lpDoc,
					TRUE        // fMustActivate
			);
		}
	}

	if (lpszUserType)
		OleStdFreeString(lpszUserType, NULL);

	return fReDoVerb;
	}


LinkTypeChanged:
	{
	/* OLE2NOTE: If IOleObject::DoVerb is executed on a Link object and it
	**    returns OLE_E_CLASSDIFF because the link source is no longer
	**    the expected class, then if the verb is a semantically
	**    defined verb (eg. OLEIVERB_PRIMARY, OLEIVERB_SHOW,
	**    OLEIVERB_OPEN, etc.), then the link should be re-created with
	**    the new link source and the same verb executed on the new
	**    link. there is no need to give a message to the user. if the
	**    user had selected a verb from the object's verb menu
	**    (fMenuInvoked==TRUE), then we can not be certain of the
	**    semantics of the verb and whether the new link can still
	**    support the verb. in this case the user is given a prompt
	**    telling him to "choose a different command offered by the new
	**    type".
	*/

	LPSTR       lpszUserType = NULL;

	if (fMenuInvoked) {
		hrErr = CallIOleObjectGetUserTypeA(
			lpContainerLine->m_lpOleObj,USERCLASSTYPE_FULL, &lpszUserType);

		OleUIPromptUser(
				(WORD)IDD_LINKTYPECHANGED,
				hwndParent,
				(LPSTR)APPNAME,
				(hrErr == NOERROR) ? lpszUserType : (LPSTR)"Unknown Object"
		);
	} else {
		fReDoVerb = TRUE;
	}
	ContainerLine_ReCreateLinkBecauseClassDiff(lpContainerLine);

	if (lpszUserType)
		OleStdFreeString(lpszUserType, NULL);

	return fReDoVerb;
	}

ServerNotFound:

	OleUIPromptUser(
			(WORD)IDD_SERVERNOTFOUND,
			hwndParent,
			(LPSTR)APPNAME);
	return fReDoVerb;

OutOfMemory:

	OleUIPromptUser(
			(WORD)IDD_OUTOFMEMORY,
			hwndParent,
			(LPSTR)APPNAME);
	return fReDoVerb;
}


/* ContainerLine_ReCreateLinkBecauseClassDiff
** ------------------------------------------
**    Re-create the link. The existing link was created when
**    the moniker binds to a link source bound of a different class
**    than the same moniker currently binds to. the link may be a
**    special link object specifically used with the old link
**    source class. thus the link object needs to be re-created to
**    give the new link source the opportunity to create its own
**    special link object. (see description "Custom Link Source")
*/
HRESULT ContainerLine_ReCreateLinkBecauseClassDiff(
		LPCONTAINERLINE lpContainerLine
)
{
	LPOLELINK   lpOleLink = lpContainerLine->m_lpOleLink;
	HGLOBAL     hMetaPict = NULL;
	LPMONIKER   lpmkLinkSrc = NULL;
	SCODE       sc = E_FAIL;
	HRESULT     hrErr;

	if (lpOleLink &&
		lpOleLink->lpVtbl->GetSourceMoniker(
				lpOleLink, (LPMONIKER FAR*)&lpmkLinkSrc) == NOERROR) {

		BOOL            fDisplayAsIcon =
							(lpContainerLine->m_dwDrawAspect==DVASPECT_ICON);
		STGMEDIUM       medium;
		LPDATAOBJECT    lpDataObj = NULL;
		DWORD           dwOleRenderOpt;
		FORMATETC       renderFmtEtc;
		LPFORMATETC     lpRenderFmtEtc = NULL;

		// get the current icon if object is displayed as icon
		if (fDisplayAsIcon &&
			(lpDataObj = (LPDATAOBJECT)OleStdQueryInterface( (LPUNKNOWN)
					lpContainerLine->m_lpOleObj,&IID_IDataObject)) != NULL ) {
			hMetaPict = OleStdGetData(
					lpDataObj, CF_METAFILEPICT, NULL, DVASPECT_ICON, &medium);
			OleStdRelease((LPUNKNOWN)lpDataObj);
		}

		if (fDisplayAsIcon && hMetaPict) {
			// a special icon should be used. first we create the object
			// OLERENDER_NONE. then we stuff the special icon into the cache.

			dwOleRenderOpt = OLERENDER_NONE;

		} else if (fDisplayAsIcon && hMetaPict == NULL) {
			// the object's default icon should be used

			dwOleRenderOpt = OLERENDER_DRAW;
			lpRenderFmtEtc = (LPFORMATETC)&renderFmtEtc;
			SETFORMATETC(renderFmtEtc,0,DVASPECT_ICON,NULL,TYMED_NULL,-1);

		} else {
			// create standard DVASPECT_CONTENT/OLERENDER_DRAW object
			dwOleRenderOpt = OLERENDER_DRAW;
		}

		// unload original link object
		ContainerLine_UnloadOleObject(lpContainerLine, OLECLOSE_SAVEIFDIRTY);

		// delete entire contents of the current object's storage
		OleStdDestroyAllElements(lpContainerLine->m_lpStg);

		OLEDBG_BEGIN2("OleCreateLink called\r\n")
		hrErr = OleCreateLink (
				lpmkLinkSrc,
				&IID_IOleObject,
				dwOleRenderOpt,
				lpRenderFmtEtc,
				(LPOLECLIENTSITE)&lpContainerLine->m_OleClientSite,
				lpContainerLine->m_lpStg,
				(LPVOID FAR*)&lpContainerLine->m_lpOleObj
		);
		OLEDBG_END2

		if (hrErr == NOERROR) {
			if (! ContainerLine_SetupOleObject(
					lpContainerLine, fDisplayAsIcon, hMetaPict) ) {

				// ERROR: setup of the new link failed.
				// revert the storage to restore the original link.
				ContainerLine_UnloadOleObject(
						lpContainerLine, OLECLOSE_NOSAVE);
				lpContainerLine->m_lpStg->lpVtbl->Revert(
						lpContainerLine->m_lpStg);
				sc = E_FAIL;
			} else {
				sc = S_OK;  // IT WORKED!

			}
		}
		else {
			sc = GetScode(hrErr);
			OleDbgOutHResult("OleCreateLink returned", hrErr);
			// ERROR: Re-creating the link failed.
			// revert the storage to restore the original link.
			lpContainerLine->m_lpStg->lpVtbl->Revert(
					lpContainerLine->m_lpStg);
		}
	}

	if (hMetaPict)
		OleUIMetafilePictIconFree(hMetaPict); // clean up metafile
	return ResultFromScode(sc);
}

/* ContainerLine_GetOleObject
** --------------------------
**    return pointer to desired interface of embedded/linked object.
**
**    NOTE: this function causes an AddRef to the object. when the caller is
**          finished with the object, it must call Release.
**          this function does not AddRef the ContainerLine object.
*/
LPUNKNOWN ContainerLine_GetOleObject(
		LPCONTAINERLINE         lpContainerLine,
		REFIID                  riid
)
{
	/* if object is not already loaded, then load it now. objects are
	**    loaded lazily in this manner.
	*/
	if (! lpContainerLine->m_lpOleObj)
		ContainerLine_LoadOleObject(lpContainerLine);

	if (lpContainerLine->m_lpOleObj)
		return OleStdQueryInterface(
				(LPUNKNOWN)lpContainerLine->m_lpOleObj,
				riid
		);
	else
		return NULL;
}



/* ContainerLine_RunOleObject
** --------------------------
**    Load and run the object. Upon running and if size of object has changed,
**    use SetExtent to change to new size.
**
*/
HRESULT ContainerLine_RunOleObject(LPCONTAINERLINE lpContainerLine)
{
	LPLINE lpLine = (LPLINE)lpContainerLine;
	SIZEL   sizelNew;
	HRESULT hrErr;
	HCURSOR  hPrevCursor;

	if (! lpContainerLine)
		return NOERROR;

	if (lpContainerLine->m_fGuardObj) {
		// object in process of creation--Fail to Run the object
		return ResultFromScode(E_FAIL);
	}

	if (lpContainerLine->m_lpOleObj &&
		OleIsRunning(lpContainerLine->m_lpOleObj))
		return NOERROR;     // object already running

	// this may take a while, put up hourglass cursor
	hPrevCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
	OLEDBG_BEGIN3("ContainerLine_RunOleObject\r\n")

	if (! lpContainerLine->m_lpOleObj) {
		if (! ContainerLine_LoadOleObject(lpContainerLine))
			return ResultFromScode(E_OUTOFMEMORY); // Error: couldn't load obj
	}

	OLEDBG_BEGIN2("OleRun called\r\n")
	hrErr = OleRun((LPUNKNOWN)lpContainerLine->m_lpOleObj);
	OLEDBG_END2

	if (hrErr != NOERROR) {
		SetCursor(hPrevCursor);     // restore original cursor

		OleDbgOutHResult("OleRun returned", hrErr);
		OLEDBG_END3
		return hrErr;
	}

	if (lpContainerLine->m_fDoSetExtent) {
		/* OLE2NOTE: the OLE object was resized when it was not running
		**    and the object did not have the OLEMISC_RECOMPOSEONRESIZE
		**    bit set. if it had, the object would have been run
		**    immediately when it was resized. this flag indicates that
		**    the object does something other than simple scaling when
		**    it is resized. because the object is being run now, we
		**    will call IOleObject::SetExtent.
		*/
		lpContainerLine->m_fDoSetExtent = FALSE;

		// the size stored in our Line includes the border around the object.
		// we must subtract the border to get the size of the object itself.
		sizelNew.cx = lpLine->m_nWidthInHimetric;
		sizelNew.cy = lpLine->m_nHeightInHimetric;

		if ((sizelNew.cx != lpContainerLine->m_sizeInHimetric.cx) ||
			(sizelNew.cy != lpContainerLine->m_sizeInHimetric.cy)) {

			OLEDBG_BEGIN2("IOleObject::SetExtent called\r\n")
			lpContainerLine->m_lpOleObj->lpVtbl->SetExtent(
					lpContainerLine->m_lpOleObj,
					lpContainerLine->m_dwDrawAspect,
					(LPSIZEL)&sizelNew
			);
			OLEDBG_END2
		}
	}

	SetCursor(hPrevCursor);     // restore original cursor

	OLEDBG_END3
	return NOERROR;

}


/* ContainerLine_IsOleLink
** -----------------------
**
**    return TRUE if the ContainerLine has an OleLink.
**           FALSE if the ContainerLine has an embedding
*/
BOOL ContainerLine_IsOleLink(LPCONTAINERLINE lpContainerLine)
{
	if (!lpContainerLine)
		return FALSE;

	return (lpContainerLine->m_dwLinkType != 0);
}


/*  ContainerLine_Draw
**  ------------------
**
**      Draw a ContainerLine object on a DC.
**
**  Parameters:
**      hDC     - DC to which the line will be drawn
**      lpRect  - the object rect in logical coordinates
**      lpRectWBounds - bounding rect of the metafile underneath hDC
**                      (NULL if hDC is not a metafile DC)
**      fHighlight    - TRUE if line has selection highlight
*/
void ContainerLine_Draw(
		LPCONTAINERLINE         lpContainerLine,
		HDC                     hDC,
		LPRECT                  lpRect,
		LPRECT                  lpRectWBounds,
		BOOL                    fHighlight
)
{
	LPLINE  lpLine = (LPLINE) lpContainerLine;
	HRESULT hrErr = NOERROR;
	RECTL   rclHim;
	RECTL   rclHimWBounds;
	RECT    rcHim;

	if (lpContainerLine->m_fGuardObj) {
		// object in process of creation--do NOT try to draw
		return;
	}

	/* if object is not already loaded, then load it now. objects are
	**    loaded lazily in this manner.
	*/
	if (! lpContainerLine->m_lpViewObj2) {
		if (! ContainerLine_LoadOleObject(lpContainerLine))
			return;     // Error: could not load object
	}

	if (lpRectWBounds) {
		rclHimWBounds.left      = (long) lpRectWBounds->left;
		rclHimWBounds.bottom    = (long) lpRectWBounds->bottom;
		rclHimWBounds.top       = (long) lpRectWBounds->top;
		rclHimWBounds.right     = (long) lpRectWBounds->right;
	}

	/* construct bounds rectangle for the object.
	**  offset origin for object to correct tab indentation
	*/
	rclHim.left     = (long) lpRect->left;
	rclHim.bottom   = (long) lpRect->bottom;
	rclHim.top      = (long) lpRect->top;
	rclHim.right    = (long) lpRect->right;

	rclHim.left += (long) ((LPLINE)lpContainerLine)->m_nTabWidthInHimetric;
	rclHim.right += (long) ((LPLINE)lpContainerLine)->m_nTabWidthInHimetric;

#if defined( INPLACE_CNTR )
	/* OLE2NOTE: if the OLE object currently has a visible in-place
	**    window, then we do NOT want to draw on top of its window.
	**    this could interfere with the object's display.
	*/
	if ( !lpContainerLine->m_fIpVisible )
#endif
	{
	hrErr = lpContainerLine->m_lpViewObj2->lpVtbl->Draw(
			lpContainerLine->m_lpViewObj2,
			lpContainerLine->m_dwDrawAspect,
			-1,
			NULL,
			NULL,
			NULL,
			hDC,
			(LPRECTL)&rclHim,
			(lpRectWBounds ? (LPRECTL)&rclHimWBounds : NULL),
			NULL,
			0
	);
	if (hrErr != NOERROR)
		OleDbgOutHResult("IViewObject::Draw returned", hrErr);

	if (lpContainerLine->m_fObjWinOpen)
		{
		rcHim.left      = (int) rclHim.left;
		rcHim.top       = (int) rclHim.top;
		rcHim.right     = (int) rclHim.right;
		rcHim.bottom    = (int) rclHim.bottom;

		/* OLE2NOTE: if the object servers window is Open (ie. not active
		**    in-place) then we must shade the object in our document to
		**    indicate to the user that the object is open elsewhere.
		*/
		OleUIDrawShading((LPRECT)&rcHim, hDC, OLEUI_SHADE_FULLRECT, 0);
		}
	}

	/* if the object associated with the ContainerLine is an automatic
	**    link then try to connect it with its LinkSource if the
	**    LinkSource is already running. we do not want to force the
	**    LinkSource to run.
	**
	**    OLE2NOTE: a sophistocated container will want to continually
	**    attempt to connect its automatic links. OLE does NOT
	**    automatically connect links when link sources become
	**    available. some containers will want to attempt to connect
	**    its links as part of idle time processing. another strategy
	**    is to attempt to connect an automatic link every time it is
	**    drawn on the screen. (this is the strategy used by this
	**    CntrOutl sample application.)
	*/
	if (lpContainerLine->m_dwLinkType == OLEUPDATE_ALWAYS)
		ContainerLine_BindLinkIfLinkSrcIsRunning(lpContainerLine);

	return;
}


void ContainerLine_DrawSelHilight(
		LPCONTAINERLINE lpContainerLine,
		HDC             hDC,            // MM_TEXT mode
		LPRECT          lprcPix,        // listbox rect
		UINT            itemAction,
		UINT            itemState
)
{
	LPLINE  lpLine = (LPLINE)lpContainerLine;
	RECT    rcObj;
	DWORD   dwFlags = OLEUI_HANDLES_INSIDE | OLEUI_HANDLES_USEINVERSE;
	int     nHandleSize;
	LPCONTAINERDOC lpContainerDoc;

	if (!lpContainerLine || !hDC || !lprcPix)
		return;

	lpContainerDoc = lpContainerLine->m_lpDoc;

	// Get size of OLE object
	ContainerLine_GetOleObjectRectInPixels(lpContainerLine, (LPRECT)&rcObj);

	nHandleSize = GetProfileInt("windows", "oleinplaceborderwidth",
			DEFAULT_HATCHBORDER_WIDTH) + 1;

	OleUIDrawHandles((LPRECT)&rcObj, hDC, dwFlags, nHandleSize, TRUE);
}

/* InvertDiffRect
** --------------
**
**    Paint the surrounding of the Obj rect black but within lprcPix
**      (similar to the lprcPix minus lprcObj)
*/
static void InvertDiffRect(LPRECT lprcPix, LPRECT lprcObj, HDC hDC)
{
	RECT rcBlack;

	// draw black in all space outside of object's rectangle
	rcBlack.top = lprcPix->top;
	rcBlack.bottom = lprcPix->bottom;

	rcBlack.left = lprcPix->left + 1;
	rcBlack.right = lprcObj->left - 1;
	InvertRect(hDC, (LPRECT)&rcBlack);

	rcBlack.left = lprcObj->right + 1;
	rcBlack.right = lprcPix->right - 1;
	InvertRect(hDC, (LPRECT)&rcBlack);

	rcBlack.top = lprcPix->top;
	rcBlack.bottom = lprcPix->top + 1;
	rcBlack.left = lprcObj->left - 1;
	rcBlack.right = lprcObj->right + 1;
	InvertRect(hDC, (LPRECT)&rcBlack);

	rcBlack.top = lprcPix->bottom;
	rcBlack.bottom = lprcPix->bottom - 1;
	rcBlack.left = lprcObj->left - 1;
	rcBlack.right = lprcObj->right + 1;
	InvertRect(hDC, (LPRECT)&rcBlack);
}


/* Edit the ContainerLine line object.
**      returns TRUE if line was changed
**              FALSE if the line was NOT changed
*/
BOOL ContainerLine_Edit(LPCONTAINERLINE lpContainerLine, HWND hWndDoc,HDC hDC)
{
	ContainerLine_DoVerb(lpContainerLine, OLEIVERB_PRIMARY, NULL, TRUE, TRUE);

	/* assume object was NOT changed, if it was obj will send Changed
	**    or Saved notification.
	*/
	return FALSE;
}



/* ContainerLine_SetHeightInHimetric
** ---------------------------------
**
** Set the height of a ContainerLine object. The widht will be changed
** to keep the aspect ratio
*/
void ContainerLine_SetHeightInHimetric(LPCONTAINERLINE lpContainerLine, int nHeight)
{
	LPLINE  lpLine = (LPLINE)lpContainerLine;
	SIZEL   sizelOleObject;
	HRESULT hrErr;

	if (!lpContainerLine)
		return;

	if (lpContainerLine->m_fGuardObj) {
		// object in process of creation--Fail to set the Height
		return;
	}

	if (nHeight != -1) {
		BOOL    fMustClose = FALSE;
		BOOL    fMustRun   = FALSE;

		/* if object is not already loaded, then load it now. objects are
		**    loaded lazily in this manner.
		*/
		if (! lpContainerLine->m_lpOleObj)
			ContainerLine_LoadOleObject(lpContainerLine);

		// the height argument specifies the desired height for the Line.
		sizelOleObject.cy = nHeight;

		// we will calculate the corresponding width for the object by
		// maintaining the current aspect ratio of the object.
		sizelOleObject.cx = (int)(sizelOleObject.cy *
				lpContainerLine->m_sizeInHimetric.cx /
				lpContainerLine->m_sizeInHimetric.cy);

		/* OLE2NOTE: if the OLE object is already running then we can
		**    immediately call SetExtent. But, if the object is NOT
		**    currently running then we will check if the object
		**    indicates that it is normally recomposes itself on
		**    resizing. ie. that the object does not simply scale its
		**    display when it it resized. if so then we will force the
		**    object to run so that we can call IOleObject::SetExtent.
		**    SetExtent does not have any effect if the object is only
		**    loaded. if the object does NOT indicate that it
		**    recomposes on resize (OLEMISC_RECOMPOSEONRESIZE) then we
		**    will wait till the next time that the object is run to
		**    call SetExtent. we will store a flag in the ContainerLine
		**    to indicate that a SetExtent is necessary. It is
		**    necessary to persist this flag.
		*/
		if (! OleIsRunning(lpContainerLine->m_lpOleObj)) {
			DWORD dwStatus;

			OLEDBG_BEGIN2("IOleObject::GetMiscStatus called\r\n")
			hrErr = lpContainerLine->m_lpOleObj->lpVtbl->GetMiscStatus(
					lpContainerLine->m_lpOleObj,
					lpContainerLine->m_dwDrawAspect,
					(LPDWORD)&dwStatus
			);
			OLEDBG_END2
			if (hrErr == NOERROR && (dwStatus & OLEMISC_RECOMPOSEONRESIZE)) {
				// force the object to run
				ContainerLine_RunOleObject(lpContainerLine);
				fMustClose = TRUE;
			} else {
				/*  the OLE object is NOT running and does NOT
				**    recompose on resize. simply scale the object now
				**    and do the SetExtent the next time the object is
				**    run. we set the Line to the new size even though
				**    the object's extents have not been changed.
				**    this has the result of scaling the object's
				**    display to the new size.
				*/
				lpContainerLine->m_fDoSetExtent = TRUE;
				ContainerLine_SetLineHeightFromObjectExtent(
						lpContainerLine, (LPSIZEL)&sizelOleObject);
				return;
			}
		}

		OLEDBG_BEGIN2("IOleObject::SetExtent called\r\n")
		hrErr = lpContainerLine->m_lpOleObj->lpVtbl->SetExtent(
				lpContainerLine->m_lpOleObj,
				lpContainerLine->m_dwDrawAspect,
				(LPSIZEL)&sizelOleObject);
		OLEDBG_END2

		if (hrErr != NOERROR) {
			/* OLE Object refuses to take on the new extents. Set the
			**    Line to the new size even though the object refused
			**    the new extents. this has the result of scaling the
			**    object's display to the new size.
			**
			**    if the object HAD accepted the new extents, then it
			**    will send out an OnViewChange/OnDataChange
			**    notification. this results in our container receiving
			**    an OnViewChange notification; the line height will be
			**    reset when this notification is received.
			*/
			ContainerLine_SetLineHeightFromObjectExtent(
					lpContainerLine, (LPSIZEL)&sizelOleObject);
		}

		if (fMustClose)
			ContainerLine_CloseOleObject(
					lpContainerLine, OLECLOSE_SAVEIFDIRTY);
	}
	else {
		/* Set the line to default height given the natural (unscaled)
		**    extents of the OLE object.
		*/
		ContainerLine_SetLineHeightFromObjectExtent(
				lpContainerLine,(LPSIZEL)&lpContainerLine->m_sizeInHimetric);
	}

}


/*  ContainerLine_SetLineHeightFromObjectExtent
 *
 *  Purpose:
 *      Calculate the corresponding line height from the OleObject size
 *      Scale the line height to fit the limit if necessary
 *
 *  Parameters:
 *      lpsizelOleObject        pointer to size of OLE Object
 *
 *  Returns:
 *      nil
 */
void ContainerLine_SetLineHeightFromObjectExtent(
		LPCONTAINERLINE         lpContainerLine,
		LPSIZEL                 lpsizelOleObject
)
{
	LPLINE lpLine = (LPLINE)lpContainerLine;

	UINT uMaxObjectHeight = XformHeightInPixelsToHimetric(NULL,
			LISTBOX_HEIGHT_LIMIT);

	if (!lpContainerLine || !lpsizelOleObject)
		return;

	if (lpContainerLine->m_fGuardObj) {
		// object in process of creation--Fail to set the Height
		return;
	}

	lpLine->m_nWidthInHimetric = (int)lpsizelOleObject->cx;
	lpLine->m_nHeightInHimetric = (int)lpsizelOleObject->cy;

	// Rescale the object if height is greater than the limit
	if (lpLine->m_nHeightInHimetric > (UINT)uMaxObjectHeight) {

		lpLine->m_nWidthInHimetric = (UINT)
				((long)lpLine->m_nWidthInHimetric *
				(long)uMaxObjectHeight /
				(long)lpLine->m_nHeightInHimetric);

		lpLine->m_nHeightInHimetric = uMaxObjectHeight;
	}

}


/* ContainerLine_SaveToStg
** -----------------------
**    Save a given ContainerLine and associated OLE object to an IStorage*.
*/
BOOL ContainerLine_SaveToStm(
		LPCONTAINERLINE         lpContainerLine,
		LPSTREAM                lpLLStm
)
{
	CONTAINERLINERECORD_ONDISK objLineRecord;
	ULONG nWritten;
	HRESULT hrErr;

        //  Compilers should handle aligment correctly
	lstrcpy(objLineRecord.m_szStgName, lpContainerLine->m_szStgName);
	objLineRecord.m_fMonikerAssigned = (USHORT) lpContainerLine->m_fMonikerAssigned;
	objLineRecord.m_dwDrawAspect = lpContainerLine->m_dwDrawAspect;
	objLineRecord.m_sizeInHimetric = lpContainerLine->m_sizeInHimetric;
	objLineRecord.m_dwLinkType = lpContainerLine->m_dwLinkType;
	objLineRecord.m_fDoSetExtent = (USHORT) lpContainerLine->m_fDoSetExtent;

	/* write line record */
	hrErr = lpLLStm->lpVtbl->Write(
			lpLLStm,
			(LPVOID)&objLineRecord,
			sizeof(objLineRecord),
			&nWritten
	);

	if (hrErr != NOERROR) {
		OleDbgAssertSz(hrErr == NOERROR,"Could not write to LineList stream");
		return FALSE;
	}

	return TRUE;
}


/* ContainerLine_SaveOleObjectToStg
** --------------------------------
**    Save the OLE object associated with the ContainerLine to an IStorage*.
*/
BOOL ContainerLine_SaveOleObjectToStg(
		LPCONTAINERLINE         lpContainerLine,
		LPSTORAGE               lpSrcStg,
		LPSTORAGE               lpDestStg,
		BOOL                    fRemember
)
{
	HRESULT         hrErr;
	SCODE           sc = S_OK;
	BOOL            fStatus;
	BOOL            fSameAsLoad = (lpSrcStg==lpDestStg ? TRUE : FALSE);
	LPSTORAGE       lpObjDestStg;

	if (lpContainerLine->m_fGuardObj) {
		// object in process of creation--Fail to save
		return FALSE;
	}

	if (! lpContainerLine->m_lpOleObj) {

		/*****************************************************************
		** CASE 1: object is NOT loaded.
		*****************************************************************/

		if (fSameAsLoad) {
			/*************************************************************
			** CASE 1A: we are saving to the current storage. because
			**    the object is not loaded, it is up-to-date
			**    (ie. nothing to do).
			*************************************************************/

			;

		} else {
			/*************************************************************
			** CASE 1B: we are saving to a new storage. because
			**    the object is not loaded, we can simply copy the
			**    object's current storage to the new storage.
			*************************************************************/

			/* if current object storage is not already open, then open it */
			if (! lpContainerLine->m_lpStg) {
				lpContainerLine->m_lpStg = OleStdOpenChildStorage(
						lpSrcStg,
						lpContainerLine->m_szStgName,
						STGM_READWRITE
					);
				if (lpContainerLine->m_lpStg == NULL) {
#if defined( _DEBUG )
					OleDbgAssertSz(
							lpContainerLine->m_lpStg != NULL,
							"Error opening child stg"
					);
#endif
					return FALSE;
				}
			}

			/* Create a child storage inside the destination storage. */
			lpObjDestStg = OleStdCreateChildStorage(
					lpDestStg,
					lpContainerLine->m_szStgName
			);

			if (lpObjDestStg == NULL) {
#if defined( _DEBUG )
				OleDbgAssertSz(
						lpObjDestStg != NULL,
						"Could not create obj storage!"
				);
#endif
				return FALSE;
			}

			hrErr = lpContainerLine->m_lpStg->lpVtbl->CopyTo(
					lpContainerLine->m_lpStg,
					0,
					NULL,
					NULL,
					lpObjDestStg
			);
			// REVIEW: should we handle error here?
			fStatus = OleStdCommitStorage(lpObjDestStg);

			/* if we are supposed to remember this storage as the new
			**    storage for the object, then release the old one and
			**    save the new one. else, throw away the new one.
			*/
			if (fRemember) {
				OleStdVerifyRelease(
						(LPUNKNOWN)lpContainerLine->m_lpStg,
						"Original object stg not released"
				);
				lpContainerLine->m_lpStg = lpObjDestStg;
			} else {
				OleStdVerifyRelease(
						(LPUNKNOWN)lpObjDestStg,
						"Copied object stg not released"
				);
			}
		}

	} else {

		/*****************************************************************
		** CASE 2: object IS loaded.
		*****************************************************************/

		if (fSameAsLoad) {
			/*************************************************************
			** CASE 2A: we are saving to the current storage. if the object
			**    is not dirty, then the current storage is up-to-date
			**    (ie. nothing to do).
			*************************************************************/

			LPPERSISTSTORAGE lpPersistStg = lpContainerLine->m_lpPersistStg;
			OleDbgAssert(lpPersistStg);

			hrErr = lpPersistStg->lpVtbl->IsDirty(lpPersistStg);

			/* OLE2NOTE: we will only accept an explicit "no i
			**    am NOT dirty statement" (ie. S_FALSE) as an
			**    indication that the object is clean. eg. if
			**    the object returns E_NOTIMPL we must
			**    interpret it as the object IS dirty.
			*/
			if (GetScode(hrErr) != S_FALSE) {

				/* OLE object IS dirty */

				OLEDBG_BEGIN2("OleSave called\r\n")
				hrErr = OleSave(
						lpPersistStg, lpContainerLine->m_lpStg, fSameAsLoad);
				OLEDBG_END2

				if (hrErr != NOERROR) {
					OleDbgOutHResult("WARNING: OleSave returned", hrErr);
					sc = GetScode(hrErr);
				}

				// OLE2NOTE: if OleSave fails, SaveCompleted must be called.
				OLEDBG_BEGIN2("IPersistStorage::SaveCompleted called\r\n")
				hrErr=lpPersistStg->lpVtbl->SaveCompleted(lpPersistStg,NULL);
				OLEDBG_END2

				if (hrErr != NOERROR) {
					OleDbgOutHResult("WARNING: SaveCompleted returned",hrErr);
					if (sc == S_OK)
						sc = GetScode(hrErr);
				}

				if (sc != S_OK)
					return FALSE;
			}

		} else {
			/*************************************************************
			** CASE 2B: we are saving to a new storage. we must
			**    tell the object to save into the new storage.
			*************************************************************/

			LPPERSISTSTORAGE lpPersistStg = lpContainerLine->m_lpPersistStg;

			if (! lpPersistStg) return FALSE;

			/* Create a child storage inside the destination storage. */
			lpObjDestStg = OleStdCreateChildStorage(
					lpDestStg,
					lpContainerLine->m_szStgName
			);

			if (lpObjDestStg == NULL) {
#if defined( _DEBUG )
				OleDbgAssertSz(
						lpObjDestStg != NULL,
						"Could not create object storage!"
				);
#endif
				return FALSE;
			}

			OLEDBG_BEGIN2("OleSave called\r\n")
			hrErr = OleSave(lpPersistStg, lpObjDestStg, fSameAsLoad);
			OLEDBG_END2

			// OLE2NOTE: even if OleSave fails, must still call SaveCompleted
			if (hrErr != NOERROR) {
				OleDbgOutHResult("WARNING: OleSave returned", hrErr);
				sc = GetScode(hrErr);
			}

			/* OLE2NOTE: a root level container should immediately
			**    call IPersistStorage::SaveCompleted after calling
			**    OleSave. a nested level container should not call
			**    SaveCompleted now, but must wait until SaveCompleted
			**    is call on it by its container. since our container
			**    is not a container/server, then we always call
			**    SaveComplete here.
			**
			**    if this is a SaveAs operation, then we need to pass
			**    the lpStg back in SaveCompleted to inform the object
			**    of its new storage that it may hold on to. if this is
			**    a Save or a SaveCopyAs operation, then we simply pass
			**    NULL in SaveCompleted; the object can continue to hold
			**    its current storage. if an error occurs during the
			**    OleSave call we must still call SaveCompleted but we
			**    must pass NULL.
			*/
			OLEDBG_BEGIN2("IPersistStorage::SaveCompleted called\r\n")
			hrErr = lpPersistStg->lpVtbl->SaveCompleted(
					lpPersistStg,
					((FAILED(sc) || !fRemember) ? NULL : lpObjDestStg)
			);
			OLEDBG_END2

			if (hrErr != NOERROR) {
				OleDbgOutHResult("WARNING: SaveCompleted returned",hrErr);
				if (sc == S_OK)
					sc = GetScode(hrErr);
			}

			if (sc != S_OK) {
				OleStdVerifyRelease(
						(LPUNKNOWN)lpObjDestStg,
						"Copied object stg not released"
				);
				return FALSE;
			}

			/* if we are supposed to remember this storage as the new
			**    storage for the object, then release the old one and
			**    save the new one. else, throw away the new one.
			*/
			if (fRemember) {
				OleStdVerifyRelease(
						(LPUNKNOWN)lpContainerLine->m_lpStg,
						"Original object stg not released"
				);
				lpContainerLine->m_lpStg = lpObjDestStg;
			} else {
				OleStdVerifyRelease(
						(LPUNKNOWN)lpObjDestStg,
						"Copied object stg not released"
				);
			}
		}
	}

	/* OLE2NOTE: after saving an OLE object it is possible that it sent
	**    an OnViewChange notification because it had been modified. in
	**    this situation it is possible that the extents of the object
	**    have changed. if so we want to relayout the space for the
	**    object immediately so that the extent information saved with
	**    the ContainerLine match the data saved with the OLE object
	**    itself.
	*/
	if (lpContainerLine->m_fDoGetExtent) {
		BOOL fSizeChanged = ContainerLine_UpdateExtent(lpContainerLine, NULL);
#if defined( INPLACE_CNTR )
		/* if the extents of this ContainerLine have changed, then we
		**    need to reset the fDoGetExtent flag to TRUE so that later
		**    when ContainerDoc_UpdateExtentOfAllOleObjects is called
		**    (when the WM_U_UPDATEOBJECTEXTENT message is processed),
		**    it is recognized that the extents of this line have
		**    changed. if any line changes size, then any in-place
		**    active object below this line must be told to update the
		**    position of their windows (via SetObjectRects -- see
		**    ContainerDoc_UpdateInPlaceObjectRects function).
		*/
		lpContainerLine->m_fDoGetExtent = fSizeChanged;
#endif
	}

	return TRUE;
}


/* ContainerLine_LoadFromStg
** -------------------------
**    Create a ContainerLine object and initialize it with data that
**    was previously writen to an IStorage*. this function does not
**    immediately OleLoad the associated OLE object, only the data of
**    the ContainerLine object itself is loaded from the IStorage*.
*/
LPLINE ContainerLine_LoadFromStg(
		LPSTORAGE               lpSrcStg,
		LPSTREAM                lpLLStm,
		LPOUTLINEDOC            lpDestDoc
)
{
	HDC         hDC;
	LPLINELIST  lpDestLL = &lpDestDoc->m_LineList;
	ULONG nRead;
	HRESULT hrErr;
	LPCONTAINERLINE lpContainerLine;
	CONTAINERLINERECORD_ONDISK objLineRecord;

	lpContainerLine=(LPCONTAINERLINE) New((DWORD)sizeof(CONTAINERLINE));
	if (lpContainerLine == NULL) {
		OleDbgAssertSz(lpContainerLine!=NULL,"Error allocating ContainerLine");
		return NULL;
	}

	hDC = LineList_GetDC(lpDestLL);
	ContainerLine_Init(lpContainerLine, 0, hDC);
	LineList_ReleaseDC(lpDestLL, hDC);

	/* OLE2NOTE: In order to have a stable ContainerLine object we must
	**    AddRef the object's refcnt. this will be later released when
	**    the ContainerLine is deleted.
	*/
	ContainerLine_AddRef(lpContainerLine);

	lpContainerLine->m_lpDoc = (LPCONTAINERDOC) lpDestDoc;

	/* read line record */
	hrErr = lpLLStm->lpVtbl->Read(
			lpLLStm,
			(LPVOID)&objLineRecord,
			sizeof(objLineRecord),
			&nRead
	);

	if (hrErr != NOERROR) {
		OleDbgAssertSz(hrErr==NOERROR, "Could not read from LineList stream");
		goto error;
	}

        //  Compilers should handle aligment correctly
        lstrcpy(lpContainerLine->m_szStgName, objLineRecord.m_szStgName);
	lpContainerLine->m_fMonikerAssigned = (BOOL) objLineRecord.m_fMonikerAssigned;
	lpContainerLine->m_dwDrawAspect = objLineRecord.m_dwDrawAspect;
	lpContainerLine->m_sizeInHimetric = objLineRecord.m_sizeInHimetric;
	lpContainerLine->m_dwLinkType = objLineRecord.m_dwLinkType;
	lpContainerLine->m_fDoSetExtent = (BOOL) objLineRecord.m_fDoSetExtent;

	return (LPLINE)lpContainerLine;

error:
	// destroy partially created ContainerLine
	if (lpContainerLine)
		ContainerLine_Delete(lpContainerLine);
	return NULL;
}


/* ContainerLine_GetTextLen
 * ------------------------
 *
 * Return length of the string representation of the ContainerLine
 *  (not considering the tab level). we will use the following as the
 *  string representation of a ContainerLine:
 *      "<" + user type name of OLE object + ">"
 *  eg:
 *      <Microsoft Excel Worksheet>
 */
int ContainerLine_GetTextLen(LPCONTAINERLINE lpContainerLine)
{
	LPSTR   lpszUserType = NULL;
	HRESULT hrErr;
	int     nLen;
	BOOL    fIsLink = ContainerLine_IsOleLink(lpContainerLine);

	/* if object is not already loaded, then load it now. objects are
	**    loaded lazily in this manner.
	*/
	if (! lpContainerLine->m_lpOleObj)
		ContainerLine_LoadOleObject(lpContainerLine);

	OLEDBG_BEGIN2("IOleObject::GetUserType called\r\n")

	hrErr = CallIOleObjectGetUserTypeA(
			lpContainerLine->m_lpOleObj,
			USERCLASSTYPE_FULL,
			&lpszUserType
	);

	OLEDBG_END2

	if (hrErr != NOERROR)   {
		// user type is NOT available
		nLen = sizeof(UNKNOWN_OLEOBJ_TYPE) + 2; // allow space for '<' + '>'
		nLen += lstrlen((LPSTR)(fIsLink ? szOLELINK : szOLEOBJECT)) + 1;
	} else {
		nLen = lstrlen(lpszUserType) + 2;   // allow space for '<' + '>'
		nLen += lstrlen((LPSTR)(fIsLink ? szOLELINK : szOLEOBJECT)) + 1;

		/* OLE2NOTE: we must free the string that was allocated by the
		**    IOleObject::GetUserType method.
		*/
		OleStdFreeString(lpszUserType, NULL);
	}

	return nLen;
}


/* ContainerLine_GetTextData
 * -------------------------
 *
 * Return the string representation of the ContainerLine
 *  (not considering the tab level). we will use the following as the
 *  string representation of a ContainerLine:
 *      "<" + user type name of OLE object + ">"
 *  eg:
 *      <Microsoft Excel Worksheet>
 */
void ContainerLine_GetTextData(LPCONTAINERLINE lpContainerLine, LPSTR lpszBuf)
{
	LPSTR   lpszUserType = NULL;
	BOOL    fIsLink = ContainerLine_IsOleLink(lpContainerLine);
	HRESULT hrErr;

	/* if object is not already loaded, then load it now. objects are
	**    loaded lazily in this manner.
	*/
	if (! lpContainerLine->m_lpOleObj)
		ContainerLine_LoadOleObject(lpContainerLine);

	hrErr = CallIOleObjectGetUserTypeA(
			lpContainerLine->m_lpOleObj,
			USERCLASSTYPE_FULL,
			&lpszUserType
	);

	if (hrErr != NOERROR)   {
		// user type is NOT available
		wsprintf(
				lpszBuf,
				"<%s %s>",
				UNKNOWN_OLEOBJ_TYPE,
				(LPSTR)(fIsLink ? szOLELINK : szOLEOBJECT)
		);
	} else {
		wsprintf(
				lpszBuf,
				"<%s %s>",
				lpszUserType,
				(LPSTR)(fIsLink ? szOLELINK : szOLEOBJECT)
		);

		/* OLE2NOTE: we must free the string that was allocated by the
		**    IOleObject::GetUserType method.
		*/
		OleStdFreeString(lpszUserType, NULL);
	}
}


/* ContainerLine_GetOutlineData
 * ----------------------------
 *
 * Return the CF_OUTLINE format data for the ContainerLine.
 */
BOOL ContainerLine_GetOutlineData(
		LPCONTAINERLINE         lpContainerLine,
		LPTEXTLINE              lpBuf
)
{
	LPLINE      lpLine = (LPLINE)lpContainerLine;
	LPLINELIST  lpLL = &((LPOUTLINEDOC)lpContainerLine->m_lpDoc)->m_LineList;
	HDC         hDC;
	char        szTmpBuf[MAXSTRLEN+1];
	LPTEXTLINE  lpTmpTextLine;

	// Create a TextLine with the Text representation of the ContainerLine.
	ContainerLine_GetTextData(lpContainerLine, (LPSTR)szTmpBuf);

	hDC = LineList_GetDC(lpLL);
	lpTmpTextLine = TextLine_Create(hDC, lpLine->m_nTabLevel, szTmpBuf);
	LineList_ReleaseDC(lpLL, hDC);

	TextLine_Copy(lpTmpTextLine, lpBuf);

	// Delete the temporary TextLine
	TextLine_Delete(lpTmpTextLine);
	return TRUE;
}


/* ContainerLine_GetPosRect
** -----------------------
**    Get the PosRect in client coordinates for the OLE object's window.
**
** OLE2NOTE: the PosRect must take into account the scroll postion of
**    the document window.
*/
void ContainerLine_GetPosRect(
		LPCONTAINERLINE     lpContainerLine,
		LPRECT              lprcPosRect
)
{
	ContainerLine_GetOleObjectRectInPixels(lpContainerLine,lprcPosRect);

	// shift rect for left margin
	lprcPosRect->left += lpContainerLine->m_nHorizScrollShift;
	lprcPosRect->right += lpContainerLine->m_nHorizScrollShift;
}


/* ContainerLine_GetOleObjectRectInPixels
** --------------------------------------
**    Get the extent of the OLE Object contained in the given Line in
**    client coordinates after scaling.
*/
void ContainerLine_GetOleObjectRectInPixels(LPCONTAINERLINE lpContainerLine, LPRECT lprc)
{
	LPOUTLINEDOC lpOutlineDoc;
	LPSCALEFACTOR lpscale;
	LPLINELIST lpLL;
	LPLINE lpLine;
	int nIndex;
	HDC hdcLL;

	if (!lpContainerLine || !lprc)
		return;

	lpOutlineDoc = (LPOUTLINEDOC)lpContainerLine->m_lpDoc;
	lpscale = OutlineDoc_GetScaleFactor(lpOutlineDoc);
	lpLL = OutlineDoc_GetLineList(lpOutlineDoc);
	lpLine = (LPLINE)lpContainerLine;
	nIndex = LineList_GetLineIndex(lpLL, lpLine);

	LineList_GetLineRect(lpLL, nIndex, lprc);

	hdcLL = GetDC(lpLL->m_hWndListBox);

	/* lprc is set to be size of Line Object (including the boundary) */
	lprc->left += (int)(
			(long)XformWidthInHimetricToPixels(hdcLL,
					lpLine->m_nTabWidthInHimetric +
					LOWORD(OutlineDoc_GetMargin(lpOutlineDoc))) *
			lpscale->dwSxN / lpscale->dwSxD);
	lprc->right = (int)(
			lprc->left + (long)
			XformWidthInHimetricToPixels(hdcLL, lpLine->m_nWidthInHimetric) *
			lpscale->dwSxN / lpscale->dwSxD);

	ReleaseDC(lpLL->m_hWndListBox, hdcLL);
}


/* ContainerLine_GetOleObjectSizeInHimetric
** ----------------------------------------
**    Get the size of the OLE Object contained in the given Line
*/
void ContainerLine_GetOleObjectSizeInHimetric(LPCONTAINERLINE lpContainerLine, LPSIZEL lpsizel)
{
	if (!lpContainerLine || !lpsizel)
		return;

	*lpsizel = lpContainerLine->m_sizeInHimetric;
}


/* ContainerLine_BindLinkIfLinkSrcIsRunning
** ----------------------------------------
**    Try to connect the OLE link object associated with the
**    ContainerLine with its LinkSource if the LinkSource is already
**    running and the link is an automatic link. we do not want to
**    force the LinkSource to run.
**
**    OLE2NOTE: a sophistocated container will want to continually
**    attempt to connect its automatic links. OLE does NOT
**    automatically connect links when link source become available. some
**    containers will want to attempt to connect its links as part of
**    idle time processing. another strategy is to attempt to connect
**    an automatic link every time it is drawn on the screen. (this is
**    the strategy used by this CntrOutl sample application.)
*/
void ContainerLine_BindLinkIfLinkSrcIsRunning(LPCONTAINERLINE lpContainerLine)
{
	LPOLEAPP lpOleApp = (LPOLEAPP)g_lpApp;
	HRESULT hrErr;
	BOOL fPrevEnable1;
	BOOL fPrevEnable2;

	// if the link source is known to be un-bindable, then don't even try
	if (lpContainerLine->m_fLinkUnavailable)
		return;

	/* OLE2NOTE: we do not want to ever give the Busy/NotResponding
	**    dialogs when we are attempting to BindIfRunning to the link
	**    source. if the link source is currently busy, this could
	**    cause the Busy dialog to come up. even if the link source is
	**    busy, we do not want put up the busy dialog. thus we will
	**    disable the dialog and later re-enable them
	*/
	OleApp_DisableBusyDialogs(lpOleApp, &fPrevEnable1, &fPrevEnable2);

	OLEDBG_BEGIN2("IOleLink::BindIfRunning called\r\n")
	hrErr = lpContainerLine->m_lpOleLink->lpVtbl->BindIfRunning(
			lpContainerLine->m_lpOleLink);
	OLEDBG_END2

	// re-enable the Busy/NotResponding dialogs
	OleApp_EnableBusyDialogs(lpOleApp, fPrevEnable1, fPrevEnable2);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\letest\outline\cntrline.h ===
/*************************************************************************
**
**    OLE 2 Container Sample Code
**
**    cntrline.c
**
**    This file contains ContainerLine methods.
**
**    (c) Copyright Microsoft Corp. 1992 - 1993 All Rights Reserved
**
*************************************************************************/

#include "outline.h"

OLEDBGDATA



extern LPOUTLINEAPP         g_lpApp;
extern IUnknownVtbl         g_CntrLine_UnknownVtbl;
extern IOleClientSiteVtbl   g_CntrLine_OleClientSiteVtbl;
extern IAdviseSinkVtbl      g_CntrLine_AdviseSinkVtbl;

#if defined( INPLACE_CNTR )
extern IOleInPlaceSiteVtbl  g_CntrLine_OleInPlaceSiteVtbl;
extern BOOL g_fInsideOutContainer;
#endif  // INPLACE_CNTR

// REVIEW: should use string resource for messages
char ErrMsgDoVerb[] = "OLE object action failed!";


/* prototype for static functions */
static void InvertDiffRect(LPRECT lprcPix, LPRECT lprcObj, HDC hDC);


/*************************************************************************
** ContainerLine
**    This object represents the location within the container where
**    the embedded/linked object lives. It exposes interfaces to the
**    object that allow the object to get information about its
**    embedding site and to announce notifications of important events
**    (changed, closed, saved)
**
**    The ContainerLine exposes the following interfaces:
**      IUnknown
**      IOleClientSite
**      IAdviseSink
*************************************************************************/



/*************************************************************************
** ContainerLine::IUnknown interface implementation
*************************************************************************/


// IUnknown::QueryInterface
STDMETHODIMP CntrLine_Unk_QueryInterface(
		LPUNKNOWN           lpThis,
		REFIID              riid,
		LPVOID FAR*         lplpvObj
)
{
	LPCONTAINERLINE lpContainerLine =
			((struct COleClientSiteImpl FAR*)lpThis)->lpContainerLine;

	return ContainerLine_QueryInterface(lpContainerLine, riid, lplpvObj);
}


// IUnknown::AddRef
STDMETHODIMP_(ULONG) CntrLine_Unk_AddRef(LPUNKNOWN lpThis)
{
	LPCONTAINERLINE lpContainerLine =
			((struct COleClientSiteImpl FAR*)lpThis)->lpContainerLine;

	OleDbgAddRefMethod(lpThis, "IUnknown");

	return ContainerLine_AddRef(lpContainerLine);
}


// IUnknown::Release
STDMETHODIMP_(ULONG) CntrLine_Unk_Release(LPUNKNOWN lpThis)
{
	LPCONTAINERLINE lpContainerLine =
			((struct COleClientSiteImpl FAR*)lpThis)->lpContainerLine;

	OleDbgReleaseMethod(lpThis, "IUnknown");

	return ContainerLine_Release(lpContainerLine);
}


/*************************************************************************
** ContainerLine::IOleClientSite interface implementation
*************************************************************************/

// IOleClientSite::QueryInterface
STDMETHODIMP CntrLine_CliSite_QueryInterface(
		LPOLECLIENTSITE     lpThis,
		REFIID              riid,
		LPVOID FAR*         lplpvObj
)
{
	LPCONTAINERLINE lpContainerLine =
			((struct COleClientSiteImpl FAR*)lpThis)->lpContainerLine;

	return ContainerLine_QueryInterface(lpContainerLine, riid, lplpvObj);
}


// IOleClientSite::AddRef
STDMETHODIMP_(ULONG) CntrLine_CliSite_AddRef(LPOLECLIENTSITE lpThis)
{
	LPCONTAINERLINE lpContainerLine =
			((struct COleClientSiteImpl FAR*)lpThis)->lpContainerLine;

	OleDbgAddRefMethod(lpThis, "IOleClientSite");

	return ContainerLine_AddRef(lpContainerLine);
}


// IOleClientSite::Release
STDMETHODIMP_(ULONG) CntrLine_CliSite_Release(LPOLECLIENTSITE lpThis)
{
	LPCONTAINERLINE lpContainerLine =
			((struct COleClientSiteImpl FAR*)lpThis)->lpContainerLine;

	OleDbgReleaseMethod(lpThis, "IOleClientSite");

	return ContainerLine_Release(lpContainerLine);
}


// IOleClientSite::SaveObject
STDMETHODIMP CntrLine_CliSite_SaveObject(LPOLECLIENTSITE lpThis)
{
	LPCONTAINERLINE lpContainerLine =
			((struct COleClientSiteImpl FAR*)lpThis)->lpContainerLine;
	LPPERSISTSTORAGE lpPersistStg = lpContainerLine->m_lpPersistStg;
	SCODE sc = S_OK;
	HRESULT hrErr;

	OLEDBG_BEGIN2("CntrLine_CliSite_SaveObject\r\n")

	if (! lpPersistStg) {
		/* OLE2NOTE: The object is NOT loaded. a container must be
		**    prepared for the fact that an object that it thinks it
		**    has unloaded may still call IOleClientSite::SaveObject.
		**    in this case the container should fail the save call and
		**    NOT try to reload the object. this scenario arises if you
		**    have a in-process server (DLL object) which has a
		**    connected linking client. even after the embedding
		**    container unloads the DLL object, the link connection
		**    keeps the object alive. it may then as part of its
		**    shutdown try to call IOCS::SaveObject, but then it is too
		**    late.
		*/
		OLEDBG_END2
		return ResultFromScode(E_FAIL);
	}

	// mark ContainerDoc as now dirty
	OutlineDoc_SetModified(
			(LPOUTLINEDOC)lpContainerLine->m_lpDoc, TRUE, TRUE, FALSE);

	/* Tell OLE object to save itself
	** OLE2NOTE: it is NOT sufficient to ONLY call
	**    IPersistStorage::Save method. it is also necessary to call
	**    WriteClassStg. the helper API OleSave does this automatically.
	*/
	OLEDBG_BEGIN2("OleSave called\r\n")
	hrErr=OleSave(lpPersistStg,lpContainerLine->m_lpStg, TRUE/*fSameAsLoad*/);
	OLEDBG_END2

	if (hrErr != NOERROR) {
		OleDbgOutHResult("WARNING: OleSave returned", hrErr);
		sc = GetScode(hrErr);
	}

	// OLE2NOTE: even if OleSave fails, SaveCompleted must be called.
	OLEDBG_BEGIN2("IPersistStorage::SaveCompleted called\r\n")
	hrErr = lpPersistStg->lpVtbl->SaveCompleted(lpPersistStg, NULL);
	OLEDBG_END2

	if (hrErr != NOERROR) {
		OleDbgOutHResult("WARNING: SaveCompleted returned",hrErr);
		if (sc == S_OK)
			sc = GetScode(hrErr);
	}

	OLEDBG_END2
	return ResultFromScode(sc);
}


// IOleClientSite::GetMoniker
STDMETHODIMP CntrLine_CliSite_GetMoniker(
		LPOLECLIENTSITE     lpThis,
		DWORD               dwAssign,
		DWORD               dwWhichMoniker,
		LPMONIKER FAR*      lplpmk
)
{
	LPCONTAINERLINE lpContainerLine;

	lpContainerLine=((struct COleClientSiteImpl FAR*)lpThis)->lpContainerLine;

	OLEDBG_BEGIN2("CntrLine_CliSite_GetMoniker\r\n")

	// OLE2NOTE: we must make sure to set output pointer parameters to NULL
	*lplpmk = NULL;

	switch (dwWhichMoniker) {

		case OLEWHICHMK_CONTAINER:
			/* OLE2NOTE: create a FileMoniker which identifies the
			**    entire container document.
			*/
			*lplpmk = OleDoc_GetFullMoniker(
					(LPOLEDOC)lpContainerLine->m_lpDoc,
					dwAssign
			);
			break;

		case OLEWHICHMK_OBJREL:

			/* OLE2NOTE: create an ItemMoniker which identifies the
			**    OLE object relative to the container document.
			*/
			*lplpmk = ContainerLine_GetRelMoniker(lpContainerLine, dwAssign);
			break;

		case OLEWHICHMK_OBJFULL:
		{
			/* OLE2NOTE: create an absolute moniker which identifies the
			**    OLE object in the container document. this moniker is
			**    created as a composite of the absolute moniker for the
			**    entire document appended with an item moniker which
			**    identifies the OLE object relative to the document.
			*/

			*lplpmk = ContainerLine_GetFullMoniker(lpContainerLine, dwAssign);
			break;
		}
	}

	OLEDBG_END2

	if (*lplpmk != NULL)
		return NOERROR;
	else
		return ResultFromScode(E_FAIL);
}


// IOleClientSite::GetContainer
STDMETHODIMP CntrLine_CliSite_GetContainer(
		LPOLECLIENTSITE     lpThis,
		LPOLECONTAINER FAR* lplpContainer
)
{
	LPCONTAINERLINE lpContainerLine;
	HRESULT hrErr;

	OLEDBG_BEGIN2("CntrLine_CliSite_GetContainer\r\n")

	lpContainerLine=((struct COleClientSiteImpl FAR*)lpThis)->lpContainerLine;

	hrErr = OleDoc_QueryInterface(
			(LPOLEDOC)lpContainerLine->m_lpDoc,
			&IID_IOleContainer,
			(LPVOID FAR*)lplpContainer
	);

	OLEDBG_END2
	return hrErr;
}


// IOleClientSite::ShowObject
STDMETHODIMP CntrLine_CliSite_ShowObject(LPOLECLIENTSITE lpThis)
{
	LPCONTAINERLINE lpContainerLine =
			((struct COleClientSiteImpl FAR*)lpThis)->lpContainerLine;
	LPOUTLINEDOC lpOutlineDoc = (LPOUTLINEDOC)lpContainerLine->m_lpDoc;
	LPLINELIST lpLL = OutlineDoc_GetLineList(lpOutlineDoc);
	int nIndex = LineList_GetLineIndex(lpLL, (LPLINE)lpContainerLine);
	HWND hWndFrame = OutlineApp_GetFrameWindow(g_lpApp);

	OLEDBG_BEGIN2("CntrLine_CliSite_ShowObject\r\n")

	/* make sure our doc window is visible and not minimized.
	**    the OutlineDoc_ShowWindow function will cause the app window
	**    to show itself SW_SHOWNORMAL.
	*/
	if (! IsWindowVisible(hWndFrame) || IsIconic(hWndFrame))
		OutlineDoc_ShowWindow(lpOutlineDoc);

	BringWindowToTop(hWndFrame);

	/* make sure that the OLE object is currently in view. if necessary
	**    scroll the document in order to bring it into view.
	*/
	LineList_ScrollLineIntoView(lpLL, nIndex);

#if defined( INPLACE_CNTR )
	/* after the in-place object is scrolled into view, we need to ask
	**    it to update its rect for the new clip rect coordinates
	*/
	ContainerDoc_UpdateInPlaceObjectRects((LPCONTAINERDOC)lpOutlineDoc, 0);
#endif

	OLEDBG_END2
	return NOERROR;
}


// IOleClientSite::OnShowWindow
STDMETHODIMP CntrLine_CliSite_OnShowWindow(LPOLECLIENTSITE lpThis, BOOL fShow)
{
	LPCONTAINERLINE lpContainerLine =
			((struct COleClientSiteImpl FAR*)lpThis)->lpContainerLine;
	LPOUTLINEDOC lpOutlineDoc = (LPOUTLINEDOC)lpContainerLine->m_lpDoc;
	LPLINELIST lpLL = OutlineDoc_GetLineList(lpOutlineDoc);
	int nIndex = LineList_GetLineIndex(lpLL, (LPLINE)lpContainerLine);

	if (fShow) {
		OLEDBG_BEGIN2("CntrLine_CliSite_OnShowWindow(TRUE)\r\n")

		/* OLE2NOTE: we need to hatch out the OLE object now; it has
		**    just been opened in a window elsewhere (open editing as
		**    opposed to in-place activation).
		**    force the line to re-draw with the hatch.
		*/
		lpContainerLine->m_fObjWinOpen = TRUE;
		LineList_ForceLineRedraw(lpLL, nIndex, FALSE /*fErase*/);

	} else {
		OLEDBG_BEGIN2("CntrLine_CliSite_OnShowWindow(FALSE)\r\n")

		/* OLE2NOTE: the object associated with this container site has
		**    just closed its server window. we should now remove the
		**    hatching that indicates that the object is open
		**    elsewhere. also our window should now come to the top.
		**    force the line to re-draw without the hatch.
		*/
		lpContainerLine->m_fObjWinOpen = FALSE;
		LineList_ForceLineRedraw(lpLL, nIndex, TRUE /*fErase*/);

		BringWindowToTop(lpOutlineDoc->m_hWndDoc);
		SetFocus(lpOutlineDoc->m_hWndDoc);
	}

	OLEDBG_END2
	return NOERROR;
}


// IOleClientSite::RequestNewObjectLayout
STDMETHODIMP CntrLine_CliSite_RequestNewObjectLayout(LPOLECLIENTSITE lpThis)
{
	OleDbgOut2("CntrLine_CliSite_RequestNewObjectLayout\r\n");

	/* OLE2NOTE: this method is NOT yet used. it is for future layout
	**    negotiation support.
	*/
	return ResultFromScode(E_NOTIMPL);
}


/*************************************************************************
** ContainerLine::IAdviseSink interface implementation
*************************************************************************/

// IAdviseSink::QueryInterface
STDMETHODIMP CntrLine_AdvSink_QueryInterface(
		LPADVISESINK        lpThis,
		REFIID              riid,
		LPVOID FAR*         lplpvObj
)
{
	LPCONTAINERLINE lpContainerLine =
			((struct COleClientSiteImpl FAR*)lpThis)->lpContainerLine;

	return ContainerLine_QueryInterface(lpContainerLine, riid, lplpvObj);
}


// IAdviseSink::AddRef
STDMETHODIMP_(ULONG) CntrLine_AdvSink_AddRef(LPADVISESINK lpThis)
{
	LPCONTAINERLINE lpContainerLine =
			((struct COleClientSiteImpl FAR*)lpThis)->lpContainerLine;

	OleDbgAddRefMethod(lpThis, "IAdviseSink");

	return ContainerLine_AddRef(lpContainerLine);
}


// IAdviseSink::Release
STDMETHODIMP_(ULONG) CntrLine_AdvSink_Release (LPADVISESINK lpThis)
{
	LPCONTAINERLINE lpContainerLine =
			((struct COleClientSiteImpl FAR*)lpThis)->lpContainerLine;

	OleDbgReleaseMethod(lpThis, "IAdviseSink");

	return ContainerLine_Release(lpContainerLine);
}


// IAdviseSink::OnDataChange
STDMETHODIMP_(void) CntrLine_AdvSink_OnDataChange(
		LPADVISESINK        lpThis,
		FORMATETC FAR*      lpFormatetc,
		STGMEDIUM FAR*      lpStgmed
)
{
	OleDbgOut2("CntrLine_AdvSink_OnDataChange\r\n");
	// We are not interested in data changes (only view changes)
	//      (ie. nothing to do)
}


STDMETHODIMP_(void) CntrLine_AdvSink_OnViewChange(
		LPADVISESINK        lpThis,
		DWORD               aspects,
		LONG                lindex
)
{
	LPCONTAINERLINE lpContainerLine;
	LPOUTLINEDOC lpOutlineDoc;
	HWND hWndDoc;
	LPLINELIST lpLL;
	MSG msg;
	int nIndex;

	OLEDBG_BEGIN2("CntrLine_AdvSink_OnViewChange\r\n")

	lpContainerLine = ((struct CAdviseSinkImpl FAR*)lpThis)->lpContainerLine;
	lpOutlineDoc = (LPOUTLINEDOC)lpContainerLine->m_lpDoc;

	/* OLE2NOTE: at this point we simply invalidate the rectangle of
	**    the object to force a repaint in the future, we mark
	**    that the extents of the object may have changed
	**    (m_fDoGetExtent=TRUE), and we post a message
	**    (WM_U_UPDATEOBJECTEXTENT) to our document that one or more
	**    OLE objects may need to have their extents updated. later
	**    when this message is processed, the document loops through
	**    all lines to see if any are marked as needing an extent update.
	**    if infact the extents did change. this can be done by calling
	**    IViewObject2::GetExtent to retreive the object's current
	**    extents and comparing with the last known extents for the
	**    object. if the extents changed, then relayout space for the
	**    object before drawing. we postpone the check to get
	**    the extents now because OnViewChange is an asyncronis method,
	**    and we have to careful not to call any syncronis methods back
	**    to the object. while it WOULD be OK to call the
	**    IViewObject2::GetExtent method within the asyncronis
	**    OnViewChange method (because this method is handled by the
	**    object handler and never remoted), it is good practise to not
	**    call any object methods from within an asyncronis
	**    notification method.
	**    if there is already WM_U_UPDATEOBJECTEXTENT message waiting
	**    in our message queue, there is no need to post another one.
	**    in this way, if the server is updating quicker than we can
	**    keep up, we do not make unneccsary GetExtent calls. also if
	**    drawing is disabled, we postpone updating the extents of any
	**    objects until drawing is re-enabled.
	*/
	lpContainerLine->m_fDoGetExtent = TRUE;
	hWndDoc = OutlineDoc_GetWindow((LPOUTLINEDOC)lpContainerLine->m_lpDoc);

	if (lpOutlineDoc->m_nDisableDraw == 0 &&
		! PeekMessage(&msg, hWndDoc,
			WM_U_UPDATEOBJECTEXTENT, WM_U_UPDATEOBJECTEXTENT,
			PM_NOREMOVE | PM_NOYIELD)) {
		PostMessage(hWndDoc, WM_U_UPDATEOBJECTEXTENT, 0, 0L);
	}

	// force the modified line to redraw.
	lpLL = OutlineDoc_GetLineList(lpOutlineDoc);
	nIndex = LineList_GetLineIndex(lpLL, (LPLINE)lpContainerLine);
	LineList_ForceLineRedraw(lpLL, nIndex, TRUE /*fErase*/);

	OLEDBG_END2
}


// IAdviseSink::OnRename
STDMETHODIMP_(void) CntrLine_AdvSink_OnRename(
		LPADVISESINK        lpThis,
		LPMONIKER           lpmk
)
{
	OleDbgOut2("CntrLine_AdvSink_OnRename\r\n");
	/* OLE2NOTE: the Embedding Container has nothing to do here. this
	**    notification is important for linking situations. it tells
	**    the OleLink objects to update their moniker because the
	**    source object has been renamed (track the link source).
	*/
}


// IAdviseSink::OnSave
STDMETHODIMP_(void) CntrLine_AdvSink_OnSave(LPADVISESINK lpThis)
{
	OleDbgOut2("CntrLine_AdvSink_OnSave\r\n");
	/* OLE2NOTE: the Embedding Container has nothing to do here. this
	**    notification is only useful to clients which have set up a
	**    data cache with the ADVFCACHE_ONSAVE flag.
	*/
}


// IAdviseSink::OnClose
STDMETHODIMP_(void) CntrLine_AdvSink_OnClose(LPADVISESINK lpThis)
{
	OleDbgOut2("CntrLine_AdvSink_OnClose\r\n");
	/* OLE2NOTE: the Embedding Container has nothing to do here. this
	**    notification is important for the OLE's default object handler
	**    and the OleLink object. it tells them the remote object is
	**    shutting down.
	*/
}


/*************************************************************************
** ContainerLine Support Functions
*************************************************************************/


/* ContainerLine_Init
** ------------------
**  Initialize fields in a newly constructed ContainerLine line object.
**  NOTE: ref cnt of ContainerLine initialized to 0
*/
void ContainerLine_Init(LPCONTAINERLINE lpContainerLine, int nTab, HDC hDC)
{
	Line_Init((LPLINE)lpContainerLine, nTab, hDC);  // init base class fields

	((LPLINE)lpContainerLine)->m_lineType           = CONTAINERLINETYPE;
	((LPLINE)lpContainerLine)->m_nWidthInHimetric   = DEFOBJWIDTH;
	((LPLINE)lpContainerLine)->m_nHeightInHimetric  = DEFOBJHEIGHT;
	lpContainerLine->m_cRef                         = 0;
	lpContainerLine->m_szStgName[0]                 = '\0';
	lpContainerLine->m_fObjWinOpen                  = FALSE;
	lpContainerLine->m_fMonikerAssigned             = FALSE;
	lpContainerLine->m_dwDrawAspect                 = DVASPECT_CONTENT;

	lpContainerLine->m_fGuardObj                    = FALSE;
	lpContainerLine->m_fDoGetExtent                 = FALSE;
	lpContainerLine->m_fDoSetExtent                 = FALSE;
	lpContainerLine->m_sizeInHimetric.cx            = -1;
	lpContainerLine->m_sizeInHimetric.cy            = -1;

	lpContainerLine->m_lpStg                        = NULL;
	lpContainerLine->m_lpDoc                        = NULL;
	lpContainerLine->m_lpOleObj                     = NULL;
	lpContainerLine->m_lpViewObj2                   = NULL;
	lpContainerLine->m_lpPersistStg                 = NULL;
	lpContainerLine->m_lpOleLink                    = NULL;
	lpContainerLine->m_dwLinkType                   = 0;
	lpContainerLine->m_fLinkUnavailable             = FALSE;
	lpContainerLine->m_lpszShortType                = NULL;

#if defined( INPLACE_CNTR )
	lpContainerLine->m_fIpActive                    = FALSE;
	lpContainerLine->m_fUIActive                    = FALSE;
	lpContainerLine->m_fIpVisible                   = FALSE;
	lpContainerLine->m_lpOleIPObj                   = NULL;
	lpContainerLine->m_fInsideOutObj                = FALSE;
	lpContainerLine->m_fIpChangesUndoable           = FALSE;
	lpContainerLine->m_fIpServerRunning             = FALSE;
	lpContainerLine->m_hWndIpObject                 = NULL;
	lpContainerLine->m_nHorizScrollShift            = 0;
#endif  // INPLACE_CNTR

	INIT_INTERFACEIMPL(
			&lpContainerLine->m_Unknown,
			&g_CntrLine_UnknownVtbl,
			lpContainerLine
	);

	INIT_INTERFACEIMPL(
			&lpContainerLine->m_OleClientSite,
			&g_CntrLine_OleClientSiteVtbl,
			lpContainerLine
	);

	INIT_INTERFACEIMPL(
			&lpContainerLine->m_AdviseSink,
			&g_CntrLine_AdviseSinkVtbl,
			lpContainerLine
	);

#if defined( INPLACE_CNTR )
	INIT_INTERFACEIMPL(
			&lpContainerLine->m_OleInPlaceSite,
			&g_CntrLine_OleInPlaceSiteVtbl,
			lpContainerLine
	);
#endif  // INPLACE_CNTR
}


/* Setup the OLE object associated with the ContainerLine */
BOOL ContainerLine_SetupOleObject(
		LPCONTAINERLINE         lpContainerLine,
		BOOL                    fDisplayAsIcon,
		HGLOBAL                 hMetaPict
)
{
	DWORD dwDrawAspect = (fDisplayAsIcon ? DVASPECT_ICON : DVASPECT_CONTENT);
	LPOUTLINEDOC lpOutlineDoc = (LPOUTLINEDOC)lpContainerLine->m_lpDoc;

	/* Cache a pointer to the IViewObject2* interface. *Required*
	**      we need this everytime we draw the object.
	**
	** OLE2NOTE: We require the object to support IViewObject2
	**    interface. this is an extension to the IViewObject interface
	**    that was added with the OLE 2.01 release. This interface must
	**    be supported by all object handlers and DLL-based objects.
	*/
	lpContainerLine->m_lpViewObj2 = (LPVIEWOBJECT2)OleStdQueryInterface(
			(LPUNKNOWN)lpContainerLine->m_lpOleObj, &IID_IViewObject2);
	if (! lpContainerLine->m_lpViewObj2) {
#if defined( _DEBUG )
		OleDbgAssertSz(
			lpContainerLine->m_lpViewObj2,"IViewObject2 NOT supported\r\n");
#endif
		return FALSE;
	}

	// Cache a pointer to the IPersistStorage* interface. *Required*
	//      we need this everytime we save the object.
	lpContainerLine->m_lpPersistStg = (LPPERSISTSTORAGE)OleStdQueryInterface(
			(LPUNKNOWN)lpContainerLine->m_lpOleObj, &IID_IPersistStorage);
	if (! lpContainerLine->m_lpPersistStg) {
		OleDbgAssert(lpContainerLine->m_lpPersistStg);
		return FALSE;
	}

	// Cache a pointer to the IOleLink* interface if supported. *Optional*
	//      if supported the object is a link. we need this to manage the link
	lpContainerLine->m_lpOleLink = (LPOLELINK)OleStdQueryInterface(
			(LPUNKNOWN)lpContainerLine->m_lpOleObj, &IID_IOleLink);
	if (lpContainerLine->m_lpOleLink) {
		OLEDBG_BEGIN2("IOleLink::GetUpdateOptions called\r\n")
		lpContainerLine->m_lpOleLink->lpVtbl->GetUpdateOptions(
				lpContainerLine->m_lpOleLink, &lpContainerLine->m_dwLinkType);
		OLEDBG_END2
	} else
		lpContainerLine->m_dwLinkType = 0;  // NOT a link

	/* get the short user type name of the object. this
	**    is used all the time when we have to build the object
	**    verb menu. we will cache this information to make it
	**    quicker to build the verb menu.
	*/
	OleDbgAssert(lpContainerLine->m_lpszShortType == NULL);
	OLEDBG_BEGIN2("IOleObject::GetUserType called\r\n")
	{
	LPOLESTR polestr;

	lpContainerLine->m_lpOleObj->lpVtbl->GetUserType(
			lpContainerLine->m_lpOleObj,
			USERCLASSTYPE_SHORT,
			&polestr
	);
	CopyAndFreeOLESTR(polestr, &lpContainerLine->m_lpszShortType);
	}
	OLEDBG_END2

	/* Perform that standard setup for the OLE object. this includes:
	**      setup View advise
	**      Call IOleObject::SetHostNames
	**      Call OleSetContainedObject
	*/
	OleStdSetupAdvises(
			lpContainerLine->m_lpOleObj,
			dwDrawAspect,
			(LPSTR)APPNAME,
			lpOutlineDoc->m_lpszDocTitle,
			(LPADVISESINK)&lpContainerLine->m_AdviseSink,
			TRUE    /*fCreate*/
	);

#if defined( INPLACE_CNTR )
	/* OLE2NOTE: (INSIDE-OUT CONTAINER) An inside-out container should
	**    check if the object is an inside-out and prefers to be
	**    activated when visible type of object. if not the object
	**    should not be allowed to keep its window up after it gets
	**    UIDeactivated.
	*/
	if (g_fInsideOutContainer) {
		DWORD mstat;
		OLEDBG_BEGIN2("IOleObject::GetMiscStatus called\r\n")
		lpContainerLine->m_lpOleObj->lpVtbl->GetMiscStatus(
				lpContainerLine->m_lpOleObj,
				DVASPECT_CONTENT,
				(DWORD FAR*)&mstat
		);
		OLEDBG_END2

		lpContainerLine->m_fInsideOutObj = (BOOL)
				(mstat & (OLEMISC_INSIDEOUT|OLEMISC_ACTIVATEWHENVISIBLE));
	}
#endif  // INPLACE_CNTR

	if (fDisplayAsIcon) {
		/* user has requested to display icon aspect instead of content
		**    aspect.
		**    NOTE: we do not have to delete the previous aspect cache
		**    because one did not get set up.
		*/
		OleStdSwitchDisplayAspect(
				lpContainerLine->m_lpOleObj,
				&lpContainerLine->m_dwDrawAspect,
				dwDrawAspect,
				hMetaPict,
				FALSE,  /* fDeleteOldAspect */
				TRUE,   /* fSetupViewAdvise */
				(LPADVISESINK)&lpContainerLine->m_AdviseSink,
				NULL /*fMustUpdate*/        // this can be ignored; update
											// for switch to icon not req'd
		);
	}
	return TRUE;
}


/* Create an ContainerLine object and return the pointer */
LPCONTAINERLINE ContainerLine_Create(
		DWORD                   dwOleCreateType,
		HDC                     hDC,
		UINT                    nTab,
		LPCONTAINERDOC          lpContainerDoc,
		LPCLSID                 lpclsid,
		LPSTR                   lpszFileName,
		BOOL                    fDisplayAsIcon,
		HGLOBAL                 hMetaPict,
		LPSTR                   lpszStgName
)
{
	LPCONTAINERLINE lpContainerLine = NULL;
	LPOLEOBJECT     lpObj = NULL;
	LPSTORAGE       lpDocStg = ContainerDoc_GetStg(lpContainerDoc);
	DWORD           dwDrawAspect =
						(fDisplayAsIcon ? DVASPECT_ICON : DVASPECT_CONTENT);
	DWORD           dwOleRenderOpt =
						(fDisplayAsIcon ? OLERENDER_NONE : OLERENDER_DRAW);
	HRESULT         hrErr;

	OLEDBG_BEGIN3("ContainerLine_Create\r\n")

	if (lpDocStg == NULL) {
		OleDbgAssertSz(lpDocStg != NULL, "Doc storage is NULL");
		goto error;
	}

	lpContainerLine=(LPCONTAINERLINE) New((DWORD)sizeof(CONTAINERLINE));
	if (lpContainerLine == NULL) {
		OleDbgAssertSz(lpContainerLine!=NULL,"Error allocating ContainerLine");
		goto error;
	}

	ContainerLine_Init(lpContainerLine, nTab, hDC);

	/* OLE2NOTE: in order to avoid re-entrancy we will set a flag to
	**    guard our object. if this guard is set, then the object is
	**    not ready to have any OLE interface methods called. it is
	**    necessary to guard the object this way while it is being
	**    created or loaded.
	*/
	lpContainerLine->m_fGuardObj = TRUE;

	/* OLE2NOTE: In order to have a stable ContainerLine object we must
	**    AddRef the object's refcnt. this will be later released when
	**    the ContainerLine is deleted.
	*/
	ContainerLine_AddRef(lpContainerLine);

	lstrcpy(lpContainerLine->m_szStgName, lpszStgName);
	lpContainerLine->m_lpDoc = lpContainerDoc;

	/* Create a new storage for the object inside the doc's storage */
	lpContainerLine->m_lpStg = OleStdCreateChildStorage(lpDocStg,lpszStgName);
	if (lpContainerLine->m_lpStg == NULL) {
		OleDbgAssert(lpContainerLine->m_lpStg != NULL);
		goto error;
	}

	lpContainerLine->m_dwLinkType = 0;

	switch (dwOleCreateType) {

		case IOF_SELECTCREATENEW:

			OLEDBG_BEGIN2("OleCreate called\r\n")
			hrErr = OleCreate (
					lpclsid,
					&IID_IOleObject,
					dwOleRenderOpt,
					NULL,
					(LPOLECLIENTSITE)&lpContainerLine->m_OleClientSite,
					lpContainerLine->m_lpStg,
					(LPVOID FAR*)&lpContainerLine->m_lpOleObj
			);
			OLEDBG_END2

#if defined( _DEBUG )
			if (hrErr != NOERROR)
				OleDbgOutHResult("OleCreate returned", hrErr);
#endif

			break;

		case IOF_SELECTCREATEFROMFILE:

			OLEDBG_BEGIN2("OleCreateFromFile called\r\n")
			{
			CREATEOLESTR(polestr, lpszFileName)

			hrErr = OleCreateFromFile (
					&CLSID_NULL,
					polestr,
					&IID_IOleObject,
					dwOleRenderOpt,
					NULL,
					(LPOLECLIENTSITE)&lpContainerLine->m_OleClientSite,
					lpContainerLine->m_lpStg,
					(LPVOID FAR*)&lpContainerLine->m_lpOleObj
			);

			FREEOLESTR(polestr)
			}
			OLEDBG_END2

#if defined( _DEBUG )
			if (hrErr != NOERROR)
				OleDbgOutHResult("OleCreateFromFile returned", hrErr);
#endif
			break;

		case IOF_CHECKLINK:

			OLEDBG_BEGIN2("OleCreateLinkToFile called\r\n")
			{
			CREATEOLESTR(polestr, lpszFileName)

			hrErr = OleCreateLinkToFile (
					polestr,
					&IID_IOleObject,
					dwOleRenderOpt,
					NULL,
					(LPOLECLIENTSITE)&lpContainerLine->m_OleClientSite,
					lpContainerLine->m_lpStg,
					(LPVOID FAR*)&lpContainerLine->m_lpOleObj
			);

			FREEOLESTR(polestr)
			}
			OLEDBG_END2

#if defined( _DEBUG )
			if (hrErr != NOERROR)
				OleDbgOutHResult("OleCreateLinkToFile returned", hrErr);
#endif
			break;
	}
	if (hrErr != NOERROR)
		goto error;

	if (! ContainerLine_SetupOleObject(
								lpContainerLine, fDisplayAsIcon, hMetaPict)) {
		goto error;
	}

	/* OLE2NOTE: clear our re-entrancy guard. the object is now ready
	**    to have interface methods called.
	*/
	lpContainerLine->m_fGuardObj = FALSE;

	OLEDBG_END3
	return lpContainerLine;

error:
	OutlineApp_ErrorMessage(g_lpApp, "Could not create object!");

	// Destroy partially created OLE object
	if (lpContainerLine)
		ContainerLine_Delete(lpContainerLine);
	OLEDBG_END3
	return NULL;
}


LPCONTAINERLINE ContainerLine_CreateFromData(
		HDC                     hDC,
		UINT                    nTab,
		LPCONTAINERDOC          lpContainerDoc,
		LPDATAOBJECT            lpSrcDataObj,
		DWORD                   dwCreateType,
		CLIPFORMAT              cfFormat,
		BOOL                    fDisplayAsIcon,
		HGLOBAL                 hMetaPict,
		LPSTR                   lpszStgName
)
{
	HGLOBAL         hData = NULL;
	LPCONTAINERLINE lpContainerLine = NULL;
	LPOLEOBJECT     lpObj = NULL;
	LPSTORAGE       lpDocStg = ContainerDoc_GetStg(lpContainerDoc);
	DWORD           dwDrawAspect =
						(fDisplayAsIcon ? DVASPECT_ICON : DVASPECT_CONTENT);
	DWORD           dwOleRenderOpt;
	FORMATETC       renderFmtEtc;
	LPFORMATETC     lpRenderFmtEtc = NULL;
	HRESULT         hrErr;
	LPUNKNOWN       lpUnk = NULL;

	OLEDBG_BEGIN3("ContainerLine_CreateFromData\r\n")

	if (dwCreateType == OLECREATEFROMDATA_STATIC && cfFormat != 0) {
		// a particular type of static object should be created

		dwOleRenderOpt = OLERENDER_FORMAT;
		lpRenderFmtEtc = (LPFORMATETC)&renderFmtEtc;

		if (cfFormat == CF_METAFILEPICT)
			SETDEFAULTFORMATETC(renderFmtEtc, cfFormat, TYMED_MFPICT);
		else if (cfFormat == CF_BITMAP)
			SETDEFAULTFORMATETC(renderFmtEtc, cfFormat, TYMED_GDI);
		else
			SETDEFAULTFORMATETC(renderFmtEtc, cfFormat, TYMED_HGLOBAL);

	} else if (dwCreateType == OLECREATEFROMDATA_STATIC && fDisplayAsIcon) {
		// a link that currently displayed as an icon needs to be
		// converted to a STATIC picture object. this case is driven
		// from "BreakLink" in the "Links" dialog. because the current
		// data in the source object's cache is DVASPECT_ICON we need
		// to tell the OleCreateStaticFromData API to look for
		// DVASPECT_ICON data. the static object that results however,
		// is considered to be displayed in the DVASPECT_CONTENT view.

		dwOleRenderOpt = OLERENDER_DRAW;
		lpRenderFmtEtc = (LPFORMATETC)&renderFmtEtc;
		SETFORMATETC(renderFmtEtc,0,DVASPECT_ICON,NULL,TYMED_NULL,-1);
		dwDrawAspect = DVASPECT_CONTENT;   // static obj displays only CONTENT

	} else if (fDisplayAsIcon && hMetaPict) {
		// a special icon should be used. first we create the object
		// OLERENDER_NONE and then we stuff the special icon into the cache.

		dwOleRenderOpt = OLERENDER_NONE;

	} else if (fDisplayAsIcon && hMetaPict == NULL) {
		// the object's default icon should be used

		dwOleRenderOpt = OLERENDER_DRAW;
		lpRenderFmtEtc = (LPFORMATETC)&renderFmtEtc;
		SETFORMATETC(renderFmtEtc,0,DVASPECT_ICON,NULL,TYMED_NULL,-1);

	} else {
		// create standard DVASPECT_CONTENT/OLERENDER_DRAW object
		dwOleRenderOpt = OLERENDER_DRAW;
	}

	if (lpDocStg == NULL) {
		OleDbgAssertSz(lpDocStg != NULL, "Doc storage is NULL");
		goto error;
	}

	lpContainerLine=(LPCONTAINERLINE) New((DWORD)sizeof(CONTAINERLINE));
	if (lpContainerLine == NULL) {
		OleDbgAssertSz(lpContainerLine!=NULL,"Error allocating ContainerLine");
		goto error;
	}

	ContainerLine_Init(lpContainerLine, nTab, hDC);

	/* OLE2NOTE: in order to avoid re-entrancy we will set a flag to
	**    guard our object. if this guard is set, then the object is
	**    not ready to have any OLE interface methods called. it is
	**    necessary to guard the object this way while it is being
	**    created or loaded.
	*/
	lpContainerLine->m_fGuardObj = TRUE;

	/* OLE2NOTE: In order to have a stable ContainerLine object we must
	**    AddRef the object's refcnt. this will be later released when
	**    the ContainerLine is deleted.
	*/
	ContainerLine_AddRef(lpContainerLine);

	lstrcpy(lpContainerLine->m_szStgName, lpszStgName);
	lpContainerLine->m_lpDoc = lpContainerDoc;

	/* Create a new storage for the object inside the doc's storage */
	lpContainerLine->m_lpStg = OleStdCreateChildStorage(lpDocStg,lpszStgName);
	if (lpContainerLine->m_lpStg == NULL) {
		OleDbgAssert(lpContainerLine->m_lpStg != NULL);
		goto error;
	}

	switch (dwCreateType) {

		case OLECREATEFROMDATA_LINK:

			OLEDBG_BEGIN2("OleCreateLinkFromData called\r\n")
			hrErr = OleCreateLinkFromData (
					lpSrcDataObj,
					&IID_IOleObject,
					dwOleRenderOpt,
					lpRenderFmtEtc,
					(LPOLECLIENTSITE)&lpContainerLine->m_OleClientSite,
					lpContainerLine->m_lpStg,
					(LPVOID FAR*)&lpContainerLine->m_lpOleObj
			);
			OLEDBG_END2

#if defined( _DEBUG )
			if (hrErr != NOERROR)
				OleDbgOutHResult("OleCreateLinkFromData returned", hrErr);
#endif
			break;

		case OLECREATEFROMDATA_OBJECT:

			OLEDBG_BEGIN2("OleCreateFromData called\r\n")
			hrErr = OleCreateFromData (
					lpSrcDataObj,
					&IID_IOleObject,
					dwOleRenderOpt,
					lpRenderFmtEtc,
					(LPOLECLIENTSITE)&lpContainerLine->m_OleClientSite,
					lpContainerLine->m_lpStg,
					(LPVOID FAR*)&lpContainerLine->m_lpOleObj
			);
			OLEDBG_END2

#if defined( _DEBUG )
			if (hrErr != NOERROR)
				OleDbgOutHResult("OleCreateFromData returned", hrErr);
#endif
			break;

		case OLECREATEFROMDATA_STATIC:

			OLEDBG_BEGIN2("OleCreateStaticFromData called\r\n")
			hrErr = OleCreateStaticFromData (
					lpSrcDataObj,
					&IID_IOleObject,
					dwOleRenderOpt,
					lpRenderFmtEtc,
					(LPOLECLIENTSITE)&lpContainerLine->m_OleClientSite,
					lpContainerLine->m_lpStg,
					(LPVOID FAR*)&lpContainerLine->m_lpOleObj
			);
			OLEDBG_END2

#if defined( _DEBUG )
			if (hrErr != NOERROR)
				OleDbgOutHResult("OleCreateStaticFromData returned", hrErr);
#endif
			break;
	}

	if (hrErr != NOERROR)
		goto error;

	if (! ContainerLine_SetupOleObject(
								lpContainerLine, fDisplayAsIcon, hMetaPict)) {
		goto error;
	}

	/* OLE2NOTE: clear our re-entrancy guard. the object is now ready
	**    to have interface methods called.
	*/
	lpContainerLine->m_fGuardObj = FALSE;

	OLEDBG_END3
	return lpContainerLine;

error:
	OutlineApp_ErrorMessage(g_lpApp, "Could not create object!");
	// Destroy partially created OLE object
	if (lpContainerLine)
		ContainerLine_Delete(lpContainerLine);
	OLEDBG_END3
	return NULL;
}


/* ContainerLine_AddRef
** --------------------
**
**  increment the ref count of the line object.
**
**    Returns the new ref count on the object
*/
ULONG ContainerLine_AddRef(LPCONTAINERLINE lpContainerLine)
{
	++lpContainerLine->m_cRef;

#if defined( _DEBUG )
	OleDbgOutRefCnt4(
			"ContainerLine_AddRef: cRef++\r\n",
			lpContainerLine,
			lpContainerLine->m_cRef
	);
#endif
	return lpContainerLine->m_cRef;
}


/* ContainerLine_Release
** ---------------------
**
**  decrement the ref count of the line object.
**    if the ref count goes to 0, then the line is destroyed.
**
**    Returns the remaining ref count on the object
*/
ULONG ContainerLine_Release(LPCONTAINERLINE lpContainerLine)
{
	ULONG cRef;

	/*********************************************************************
	** OLE2NOTE: when the obj refcnt == 0, then destroy the object.     **
	**     otherwise the object is still in use.                        **
	*********************************************************************/

	cRef = --lpContainerLine->m_cRef;

#if defined( _DEBUG )
	OleDbgAssertSz(
			lpContainerLine->m_cRef >= 0,"Release called with cRef == 0");

	OleDbgOutRefCnt4(
			"ContainerLine_Release: cRef--\r\n",
			lpContainerLine,
			cRef
	);
#endif
	if (cRef == 0)
		ContainerLine_Destroy(lpContainerLine);

	return cRef;
}


/* ContainerLine_QueryInterface
** ----------------------------
**
** Retrieve a pointer to an interface on the ContainerLine object.
**
**    Returns NOERROR if interface is successfully retrieved.
**            E_NOINTERFACE if the interface is not supported
*/
HRESULT ContainerLine_QueryInterface(
		LPCONTAINERLINE         lpContainerLine,
		REFIID                  riid,
		LPVOID FAR*             lplpvObj
)
{
	SCODE sc = E_NOINTERFACE;

	/* OLE2NOTE: we must make sure to set all out ptr parameters to NULL. */
	*lplpvObj = NULL;

	if (IsEqualIID(riid, &IID_IUnknown)) {
		OleDbgOut4("ContainerLine_QueryInterface: IUnknown* RETURNED\r\n");

		*lplpvObj = (LPVOID) &lpContainerLine->m_Unknown;
		ContainerLine_AddRef(lpContainerLine);
		sc = S_OK;
	}
	else if (IsEqualIID(riid, &IID_IOleClientSite)) {
		OleDbgOut4("ContainerLine_QueryInterface: IOleClientSite* RETURNED\r\n");

		*lplpvObj = (LPVOID) &lpContainerLine->m_OleClientSite;
		ContainerLine_AddRef(lpContainerLine);
		sc = S_OK;
	}
	else if (IsEqualIID(riid, &IID_IAdviseSink)) {
		OleDbgOut4("ContainerLine_QueryInterface: IAdviseSink* RETURNED\r\n");

		*lplpvObj = (LPVOID) &lpContainerLine->m_AdviseSink;
		ContainerLine_AddRef(lpContainerLine);
		sc = S_OK;
	}
#if defined( INPLACE_CNTR )
	else if (IsEqualIID(riid, &IID_IOleWindow)
			 || IsEqualIID(riid, &IID_IOleInPlaceSite)) {
		OleDbgOut4("ContainerLine_QueryInterface: IOleInPlaceSite* RETURNED\r\n");

		*lplpvObj = (LPVOID) &lpContainerLine->m_OleInPlaceSite;
		ContainerLine_AddRef(lpContainerLine);
		sc = S_OK;
	}
#endif  // INPLACE_CNTR

	OleDbgQueryInterfaceMethod(*lplpvObj);

	return ResultFromScode(sc);
}


BOOL ContainerLine_LoadOleObject(LPCONTAINERLINE lpContainerLine)
{
	LPOUTLINEDOC    lpOutlineDoc = (LPOUTLINEDOC)lpContainerLine->m_lpDoc;
	LPSTORAGE       lpDocStg = ContainerDoc_GetStg(lpContainerLine->m_lpDoc);
	LPOLECLIENTSITE lpOleClientSite;
	LPMONIKER       lpmkObj;
	LPOLEAPP        lpOleApp = (LPOLEAPP)g_lpApp;
	BOOL            fPrevEnable1;
	BOOL            fPrevEnable2;
	HRESULT         hrErr;

	if (lpContainerLine->m_fGuardObj)
		return FALSE;                // object in process of creation

	if (lpContainerLine->m_lpOleObj)
		return TRUE;                // object already loaded

	OLEDBG_BEGIN3("ContainerLine_LoadOleObject\r\n")

	/* OLE2NOTE: in order to avoid re-entrancy we will set a flag to
	**    guard our object. if this guard is set, then the object is
	**    not ready to have any OLE interface methods called. it is
	**    necessary to guard the object this way while it is being
	**    created or loaded.
	*/
	lpContainerLine->m_fGuardObj = TRUE;

	/* if object storage is not already open, then open it */
	if (! lpContainerLine->m_lpStg) {
		lpContainerLine->m_lpStg = OleStdOpenChildStorage(
				lpDocStg,
				lpContainerLine->m_szStgName,
				STGM_READWRITE
		);
		if (lpContainerLine->m_lpStg == NULL) {
			OleDbgAssert(lpContainerLine->m_lpStg != NULL);
			goto error;
		}
	}

	/* OLE2NOTE: if the OLE object being loaded is in a data transfer
	**    document, then we should NOT pass a IOleClientSite* pointer
	**    to the OleLoad call. This particularly critical if the OLE
	**    object is an OleLink object. If a non-NULL client site is
	**    passed to the OleLoad function, then the link will bind to
	**    the source if its is running. in the situation that we are
	**    loading the object as part of a data transfer document we do
	**    not want this connection to be established. even worse, if
	**    the link source is currently blocked or busy, then this could
	**    hang the system. it is simplest to never pass a
	**    IOleClientSite* when loading an object in a data transfer
	**    document.
	*/
	lpOleClientSite = (lpOutlineDoc->m_fDataTransferDoc ?
			NULL : (LPOLECLIENTSITE)&lpContainerLine->m_OleClientSite);

	/* OLE2NOTE: we do not want to ever give the Busy/NotResponding
	**    dialogs when we are loading an object. if the object is a
	**    link, it will attempt to BindIfRunning to the link source. if
	**    the link source is currently busy, this could cause the Busy
	**    dialog to come up. even if the link source is busy,
	**    we do not want put up the busy dialog. thus we will disable
	**    the dialog and later re-enable them
	*/
	OleApp_DisableBusyDialogs(lpOleApp, &fPrevEnable1, &fPrevEnable2);

	OLEDBG_BEGIN2("OleLoad called\r\n")
	hrErr = OleLoad (
		   lpContainerLine->m_lpStg,
		   &IID_IOleObject,
		   lpOleClientSite,
		   (LPVOID FAR*)&lpContainerLine->m_lpOleObj
	);
	OLEDBG_END2

	// re-enable the Busy/NotResponding dialogs
	OleApp_EnableBusyDialogs(lpOleApp, fPrevEnable1, fPrevEnable2);

	if (hrErr != NOERROR) {
		OleDbgAssertSz(hrErr == NOERROR, "Could not load object!");
		OleDbgOutHResult("OleLoad returned", hrErr);
		goto error;
	}

	/* Cache a pointer to the IViewObject2* interface. *Required*
	**      we need this everytime we draw the object.
	**
	** OLE2NOTE: We require the object to support IViewObject2
	**    interface. this is an extension to the IViewObject interface
	**    that was added with the OLE 2.01 release. This interface must
	**    be supported by all object handlers and DLL-based objects.
	*/
	lpContainerLine->m_lpViewObj2 = (LPVIEWOBJECT2)OleStdQueryInterface(
			(LPUNKNOWN)lpContainerLine->m_lpOleObj, &IID_IViewObject2);
	if (! lpContainerLine->m_lpViewObj2) {
#if defined( _DEBUG )
		OleDbgAssertSz(
			lpContainerLine->m_lpViewObj2,"IViewObject2 NOT supported\r\n");
#endif
		goto error;
	}

	// Cache a pointer to the IPersistStorage* interface. *Required*
	//      we need this everytime we save the object.
	lpContainerLine->m_lpPersistStg = (LPPERSISTSTORAGE)OleStdQueryInterface(
			(LPUNKNOWN)lpContainerLine->m_lpOleObj, &IID_IPersistStorage);
	if (! lpContainerLine->m_lpPersistStg) {
		OleDbgAssert(lpContainerLine->m_lpPersistStg);
		goto error;
	}

	// Cache a pointer to the IOleLink* interface if supported. *Optional*
	//      if supported the object is a link. we need this to manage the link
	if (lpContainerLine->m_dwLinkType != 0) {
		lpContainerLine->m_lpOleLink = (LPOLELINK)OleStdQueryInterface(
				(LPUNKNOWN)lpContainerLine->m_lpOleObj, &IID_IOleLink);
		if (! lpContainerLine->m_lpOleLink) {
			OleDbgAssert(lpContainerLine->m_lpOleLink);
			goto error;
		}
	}

	/* OLE2NOTE: clear our re-entrancy guard. the object is now ready
	**    to have interface methods called.
	*/
	lpContainerLine->m_fGuardObj = FALSE;

	/* OLE2NOTE: similarly, if the OLE object being loaded is in a data
	**    transfer document, then we do NOT need to setup any advises,
	**    call SetHostNames, SetMoniker, etc.
	*/
	if (lpOleClientSite) {
		/* Setup the Advises (OLE notifications) that we are interested
		** in receiving.
		*/
		OleStdSetupAdvises(
				lpContainerLine->m_lpOleObj,
				lpContainerLine->m_dwDrawAspect,
				(LPSTR)APPNAME,
				lpOutlineDoc->m_lpszDocTitle,
				(LPADVISESINK)&lpContainerLine->m_AdviseSink,
				FALSE   /*fCreate*/
		);

		/* OLE2NOTE: if the OLE object has a moniker assigned, we need to
		**    inform the object by calling IOleObject::SetMoniker. this
		**    will force the OLE object to register in the
		**    RunningObjectTable when it enters the running state.
		*/
		if (lpContainerLine->m_fMonikerAssigned) {
			lpmkObj = ContainerLine_GetRelMoniker(
					lpContainerLine,
					GETMONIKER_ONLYIFTHERE
			);

			if (lpmkObj) {
				OLEDBG_BEGIN2("IOleObject::SetMoniker called\r\n")
				lpContainerLine->m_lpOleObj->lpVtbl->SetMoniker(
						lpContainerLine->m_lpOleObj,
						OLEWHICHMK_OBJREL,
						lpmkObj
				);
				OLEDBG_END2
				OleStdRelease((LPUNKNOWN)lpmkObj);
			}
		}

		/* get the Short form of the user type name of the object. this
		**    is used all the time when we have to build the object
		**    verb menu. we will cache this information to make it
		**    quicker to build the verb menu.
		*/
		// block is only for polestr declaration
		{
		LPOLESTR polestr;

		OLEDBG_BEGIN2("IOleObject::GetUserType called\r\n")
		lpContainerLine->m_lpOleObj->lpVtbl->GetUserType(
				lpContainerLine->m_lpOleObj,
				USERCLASSTYPE_SHORT,
				&polestr
		);

		CopyAndFreeOLESTR(polestr, &lpContainerLine->m_lpszShortType);
		}
		OLEDBG_END2

#if defined( INPLACE_CNTR )
		/* OLE2NOTE: an inside-out container should check if the object
		**    is an inside-out and prefers to be activated when visible
		**    type of object. if so, the object should be immediately
		**    activated in-place, BUT NOT UIActived.
		*/
		if (g_fInsideOutContainer &&
				lpContainerLine->m_dwDrawAspect == DVASPECT_CONTENT) {
			DWORD mstat;
			OLEDBG_BEGIN2("IOleObject::GetMiscStatus called\r\n")
			lpContainerLine->m_lpOleObj->lpVtbl->GetMiscStatus(
					lpContainerLine->m_lpOleObj,
					DVASPECT_CONTENT,
					(DWORD FAR*)&mstat
			);
			OLEDBG_END2

			lpContainerLine->m_fInsideOutObj = (BOOL)
				   (mstat & (OLEMISC_INSIDEOUT|OLEMISC_ACTIVATEWHENVISIBLE));

			if ( lpContainerLine->m_fInsideOutObj ) {
				HWND hWndDoc = OutlineDoc_GetWindow(lpOutlineDoc);

				ContainerLine_DoVerb(
						lpContainerLine,
						OLEIVERB_INPLACEACTIVATE,
						NULL,
						FALSE,
						FALSE
				);

				/* OLE2NOTE: following this DoVerb(INPLACEACTIVATE) the
				**    object may have taken focus. but because the
				**    object is NOT UIActive it should NOT have focus.
				**    we will make sure our document has focus.
				*/
				SetFocus(hWndDoc);
			}
		}
#endif  // INPLACE_CNTR
		OLEDBG_END2

	}

	OLEDBG_END2
	return TRUE;

error:
	OLEDBG_END2
	return FALSE;
}


/* ContainerLine_CloseOleObject
** ----------------------------
**    Close the OLE object associated with the ContainerLine.
**
**    Closing the object forces the object to transition from the
**    running state to the loaded state. if the object was not running,
**    then there is no effect. it is necessary to close the OLE object
**    before releasing the pointers to the OLE object.
**
**    Returns TRUE if successfully closed,
**            FALSE if closing was aborted.
*/
BOOL ContainerLine_CloseOleObject(
		LPCONTAINERLINE         lpContainerLine,
		DWORD                   dwSaveOption
)
{
	HRESULT hrErr;
	SCODE   sc;

	if (lpContainerLine->m_fGuardObj)
		return FALSE;                // object in process of creation

	if (! lpContainerLine->m_lpOleObj)
		return TRUE;    // object is NOT loaded

	OLEDBG_BEGIN2("IOleObject::Close called\r\n")
	hrErr = lpContainerLine->m_lpOleObj->lpVtbl->Close(
			lpContainerLine->m_lpOleObj,
			(dwSaveOption == OLECLOSE_NOSAVE ?
					OLECLOSE_NOSAVE : OLECLOSE_SAVEIFDIRTY)
	);
	OLEDBG_END2

#if defined( INPLACE_CNTR )
	if (lpContainerLine->m_fIpServerRunning) {
		/* OLE2NOTE: unlock the lock held on the in-place object.
		**    it is VERY important that an in-place container
		**    that also support linking to embeddings properly manage
		**    the running of its in-place objects. in an outside-in
		**    style in-place container, when the user clicks
		**    outside of the in-place active object, the object gets
		**    UIDeactivated and the object hides its window. in order
		**    to make the object fast to reactivate, the container
		**    deliberately does not call IOleObject::Close. the object
		**    stays running in the invisible unlocked state. the idea
		**    here is if the user simply clicks outside of the object
		**    and then wants to double click again to re-activate the
		**    object, we do not want this to be slow. if we want to
		**    keep the object running, however, we MUST Lock it
		**    running. otherwise the object will be in an unstable
		**    state where if a linking client does a "silent-update"
		**    (eg. UpdateNow from the Links dialog), then the in-place
		**    server will shut down even before the object has a chance
		**    to be saved back in its container. this saving normally
		**    occurs when the in-place container closes the object. also
		**    keeping the object in the unstable, hidden, running,
		**    not-locked state can cause problems in some scenarios.
		**    ICntrOtl keeps only one object running. if the user
		**    intiates a DoVerb on another object, then that last
		**    running in-place active object is closed. a more
		**    sophistocated in-place container may keep more object running.
		**    (see CntrLine_IPSite_OnInPlaceActivate)
		*/
		lpContainerLine->m_fIpServerRunning = FALSE;

		OLEDBG_BEGIN2("OleLockRunning(FALSE,TRUE) called\r\n")
		OleLockRunning((LPUNKNOWN)lpContainerLine->m_lpOleObj, FALSE, TRUE);
		OLEDBG_END2
	}
#endif

	if (hrErr != NOERROR) {
		OleDbgOutHResult("IOleObject::Close returned", hrErr);
		sc = GetScode(hrErr);
		if (sc == RPC_E_CALL_REJECTED || sc==OLE_E_PROMPTSAVECANCELLED)
			return FALSE;   // object aborted shutdown
	}
	return TRUE;
}


/* ContainerLine_UnloadOleObject
** -----------------------------
**    Close the OLE object associated with the ContainerLine and
**    release all pointer held to the object.
**
**    Closing the object forces the object to transition from the
**    running state to the loaded state. if the object was not running,
**    then there is no effect. it is necessary to close the OLE object
**    before releasing the pointers to the OLE object. releasing all
**    pointers to the object allows the object to transition from
**    loaded to unloaded (or passive).
*/
void ContainerLine_UnloadOleObject(
		LPCONTAINERLINE         lpContainerLine,
		DWORD                   dwSaveOption
)
{
	if (lpContainerLine->m_lpOleObj) {

		OLEDBG_BEGIN2("IOleObject::Close called\r\n")
		lpContainerLine->m_lpOleObj->lpVtbl->Close(
				lpContainerLine->m_lpOleObj, dwSaveOption);
		OLEDBG_END2

		/* OLE2NOTE: we will take our IOleClientSite* pointer away from
		**    the object before we release all pointers to the object.
		**    in the scenario where the object is implemented as an
		**    in-proc server (DLL object), then, if there are link
		**    connections to the DLL object, it is possible that the
		**    object will not be destroyed when we release our pointers
		**    to the object. the existance of the remote link
		**    connections will hold the object alive. later when these
		**    strong connections are released, then the object may
		**    attempt to call IOleClientSite::Save if we had not taken
		**    away the client site pointer.
		*/
		OLEDBG_BEGIN2("IOleObject::SetClientSite(NULL) called\r\n")
		lpContainerLine->m_lpOleObj->lpVtbl->SetClientSite(
				lpContainerLine->m_lpOleObj, NULL);
		OLEDBG_END2

		OleStdRelease((LPUNKNOWN)lpContainerLine->m_lpOleObj);
		lpContainerLine->m_lpOleObj = NULL;

		if (lpContainerLine->m_lpViewObj2) {
			OleStdRelease((LPUNKNOWN)lpContainerLine->m_lpViewObj2);
			lpContainerLine->m_lpViewObj2 = NULL;
		}
		if (lpContainerLine->m_lpPersistStg) {
			OleStdRelease((LPUNKNOWN)lpContainerLine->m_lpPersistStg);
			lpContainerLine->m_lpPersistStg = NULL;
		}

		if (lpContainerLine->m_lpOleLink) {
			OleStdRelease((LPUNKNOWN)lpContainerLine->m_lpOleLink);
			lpContainerLine->m_lpOleLink = NULL;
		}
	}

	if (lpContainerLine->m_lpszShortType) {
		OleStdFreeString(lpContainerLine->m_lpszShortType, NULL);
		lpContainerLine->m_lpszShortType = NULL;
	}
}


/* ContainerLine_Delete
** --------------------
**    Delete the ContainerLine.
**
**    NOTE: we can NOT directly destroy the memory for the
**    ContainerLine; the ContainerLine maintains a reference count. a
**    non-zero reference count indicates that the object is still
**    in-use. The OleObject keeps a reference-counted pointer to the
**    ClientLine object. we must take the actions necessary so that the
**    ContainerLine object receives Releases for outstanding
**    references. when the reference count of the ContainerLine reaches
**    zero, then the memory for the object will actually be destroyed
**    (ContainerLine_Destroy called).
**
*/
void ContainerLine_Delete(LPCONTAINERLINE lpContainerLine)
{
	OLEDBG_BEGIN2("ContainerLine_Delete\r\n")

#if defined( INPLACE_CNTR )
	if (lpContainerLine == lpContainerLine->m_lpDoc->m_lpLastIpActiveLine)
		lpContainerLine->m_lpDoc->m_lpLastIpActiveLine = NULL;
	if (lpContainerLine == lpContainerLine->m_lpDoc->m_lpLastUIActiveLine)
		lpContainerLine->m_lpDoc->m_lpLastUIActiveLine = NULL;
#endif

	/* OLE2NOTE: in order to have a stable line object during the
	**    process of deleting, we intially AddRef the line ref cnt and
	**    later Release it. This initial AddRef is artificial; it is
	**    simply done to guarantee that our object does not destroy
	**    itself until the END of this routine.
	*/
	ContainerLine_AddRef(lpContainerLine);

	// Unload the loaded OLE object
	if (lpContainerLine->m_lpOleObj)
		ContainerLine_UnloadOleObject(lpContainerLine, OLECLOSE_NOSAVE);

	/* OLE2NOTE: we can NOT directly free the memory for the ContainerLine
	**    data structure until everyone holding on to a pointer to our
	**    ClientSite interface and IAdviseSink interface has released
	**    their pointers. There is one refcnt on the ContainerLine object
	**    which is held by the container itself. we will release this
	**    refcnt here.
	*/
	ContainerLine_Release(lpContainerLine);

	/* OLE2NOTE: this call forces all external connections to our
	**    ContainerLine to close down and therefore guarantees that
	**    we receive all releases associated with those external
	**    connections. Strictly this call should NOT be necessary, but
	**    it is defensive coding to make this call.
	*/
	OLEDBG_BEGIN2("CoDisconnectObject(lpContainerLine) called\r\n")
	CoDisconnectObject((LPUNKNOWN)&lpContainerLine->m_Unknown, 0);
	OLEDBG_END2

#if defined( _DEBUG )
	/* at this point the object all references from the OLE object to
	**    our ContainerLine object should have been released. there
	**    should only be 1 remaining reference that will be released below.
	*/
	if (lpContainerLine->m_cRef != 1) {
		OleDbgOutRefCnt(
			"WARNING: ContainerLine_Delete: cRef != 1\r\n",
			lpContainerLine,
			lpContainerLine->m_cRef
		);
	}
#endif

	ContainerLine_Release(lpContainerLine); // release artificial AddRef above
	OLEDBG_END2
}


/* ContainerLine_Destroy
** ---------------------
**    Destroy (Free) the memory used by a ContainerLine structure.
**    This function is called when the ref count of the ContainerLine goes
**    to zero. the ref cnt goes to zero after ContainerLine_Delete forces
**    the OleObject to unload and release its pointers to the
**    ContainerLine IOleClientSite and IAdviseSink interfaces.
*/

void ContainerLine_Destroy(LPCONTAINERLINE lpContainerLine)
{
	LPUNKNOWN lpTmpObj;

	OLEDBG_BEGIN2("ContainerLine_Destroy\r\n")

	// Release the storage opened for the OLE object
	if (lpContainerLine->m_lpStg) {
		lpTmpObj = (LPUNKNOWN)lpContainerLine->m_lpStg;
		lpContainerLine->m_lpStg = NULL;

		OleStdRelease(lpTmpObj);
	}

	if (lpContainerLine->m_lpszShortType) {
		OleStdFreeString(lpContainerLine->m_lpszShortType, NULL);
		lpContainerLine->m_lpszShortType = NULL;
	}

	Delete(lpContainerLine);        // Free the memory for the structure itself
	OLEDBG_END2
}


/* ContainerLine_CopyToDoc
 * -----------------------
 *
 *      Copy a ContainerLine to another Document (usually ClipboardDoc)
 */
BOOL ContainerLine_CopyToDoc(
		LPCONTAINERLINE         lpSrcLine,
		LPOUTLINEDOC            lpDestDoc,
		int                     nIndex
)
{
	LPCONTAINERLINE lpDestLine = NULL;
	LPLINELIST  lpDestLL = &lpDestDoc->m_LineList;
	HDC         hDC;
	HRESULT     hrErr;
	BOOL        fStatus;
	LPSTORAGE   lpDestDocStg = ((LPOLEDOC)lpDestDoc)->m_lpStg;
	LPSTORAGE   lpDestObjStg = NULL;

	lpDestLine = (LPCONTAINERLINE) New((DWORD)sizeof(CONTAINERLINE));
	if (lpDestLine == NULL) {
		OleDbgAssertSz(lpDestLine!=NULL, "Error allocating ContainerLine");
		return FALSE;
	}

	hDC = LineList_GetDC(lpDestLL);
	ContainerLine_Init(lpDestLine, ((LPLINE)lpSrcLine)->m_nTabLevel, hDC);
	LineList_ReleaseDC(lpDestLL, hDC);

	/* OLE2NOTE: In order to have a stable ContainerLine object we must
	**    AddRef the object's refcnt. this will be later released when
	**    the ContainerLine is deleted.
	*/
	ContainerLine_AddRef(lpDestLine);

	lpDestLine->m_lpDoc = (LPCONTAINERDOC)lpDestDoc;

	// Copy data of the original source ContainerLine.
	((LPLINE)lpDestLine)->m_nWidthInHimetric =
			((LPLINE)lpSrcLine)->m_nWidthInHimetric;
	((LPLINE)lpDestLine)->m_nHeightInHimetric =
			((LPLINE)lpSrcLine)->m_nHeightInHimetric;
	lpDestLine->m_fMonikerAssigned = lpSrcLine->m_fMonikerAssigned;
	lpDestLine->m_dwDrawAspect = lpSrcLine->m_dwDrawAspect;
	lpDestLine->m_sizeInHimetric = lpSrcLine->m_sizeInHimetric;
	lpDestLine->m_dwLinkType = lpSrcLine->m_dwLinkType;


	/* We must create a new sub-storage for the embedded object within
	**    the destination document's storage. We will first attempt to
	**    use the same storage name as the source line. if this name is
	**    in use, then we will allocate a new name. in this way we try
	**    to keep the name associated with the OLE object unchanged
	**    through a Cut/Paste operation.
	*/
	lpDestObjStg = OleStdCreateChildStorage(
			lpDestDocStg,
			lpSrcLine->m_szStgName
	);
	if (lpDestObjStg) {
		lstrcpy(lpDestLine->m_szStgName, lpSrcLine->m_szStgName);
	} else {
		/* the original name was in use, make up a new name. */
		ContainerDoc_GetNextStgName(
				(LPCONTAINERDOC)lpDestDoc,
				lpDestLine->m_szStgName,
				sizeof(lpDestLine->m_szStgName)
		);
		lpDestObjStg = OleStdCreateChildStorage(
				lpDestDocStg,
				lpDestLine->m_szStgName
		);
	}
	if (lpDestObjStg == NULL) {
		OleDbgAssertSz(lpDestObjStg != NULL, "Error creating child stg");
		goto error;
	}

	// Copy over storage of the embedded object itself

	if (! lpSrcLine->m_lpOleObj) {

		/*****************************************************************
		** CASE 1: object is NOT loaded.
		**    because the object is not loaded, we can simply copy the
		**    object's current storage to the new storage.
		*****************************************************************/

		/* if current object storage is not already open, then open it */
		if (! lpSrcLine->m_lpStg) {
			LPSTORAGE lpSrcDocStg = ((LPOLEDOC)lpSrcLine->m_lpDoc)->m_lpStg;

			if (! lpSrcDocStg) goto error;

			// open object storage.
			lpSrcLine->m_lpStg = OleStdOpenChildStorage(
					lpSrcDocStg,
					lpSrcLine->m_szStgName,
					STGM_READWRITE
			);
			if (lpSrcLine->m_lpStg == NULL) {
#if defined( _DEBUG )
				OleDbgAssertSz(
						lpSrcLine->m_lpStg != NULL,
						"Error opening child stg"
				);
#endif
				goto error;
			}
		}

		hrErr = lpSrcLine->m_lpStg->lpVtbl->CopyTo(
				lpSrcLine->m_lpStg,
				0,
				NULL,
				NULL,
				lpDestObjStg
		);
		if (hrErr != NOERROR) {
			OleDbgOutHResult("WARNING: lpSrcObjStg->CopyTo returned", hrErr);
			goto error;
		}

		fStatus = OleStdCommitStorage(lpDestObjStg);

	} else {

		/*****************************************************************
		** CASE 2: object IS loaded.
		**    we must tell the object to save into the new storage.
		*****************************************************************/

		SCODE sc = S_OK;
		LPPERSISTSTORAGE lpPersistStg = lpSrcLine->m_lpPersistStg;
		OleDbgAssert(lpPersistStg);

		OLEDBG_BEGIN2("OleSave called\r\n")
		hrErr = OleSave(lpPersistStg, lpDestObjStg, FALSE /*fSameAsLoad*/);
		OLEDBG_END2

		if (hrErr != NOERROR) {
			OleDbgOutHResult("WARNING: OleSave returned", hrErr);
			sc = GetScode(hrErr);
		}

		// OLE2NOTE: even if OleSave fails, SaveCompleted must be called.
		OLEDBG_BEGIN2("IPersistStorage::SaveCompleted called\r\n")
		hrErr=lpPersistStg->lpVtbl->SaveCompleted(lpPersistStg,NULL);
		OLEDBG_END2

		if (hrErr != NOERROR) {
			OleDbgOutHResult("WARNING: SaveCompleted returned",hrErr);
			if (sc == S_OK)
				sc = GetScode(hrErr);
		}

		if (sc != S_OK)
			goto error;

	}

	OutlineDoc_AddLine(lpDestDoc, (LPLINE)lpDestLine, nIndex);
	OleStdVerifyRelease(
			(LPUNKNOWN)lpDestObjStg,
			"Copied object stg not released"
	);

	return TRUE;

error:

	// Delete any partially created storage.
	if (lpDestObjStg) {

		OleStdVerifyRelease(
				(LPUNKNOWN)lpDestObjStg,
				"Copied object stg not released"
		);

		{
		CREATEOLESTR(polestr, lpDestLine->m_szStgName)

		lpDestDocStg->lpVtbl->DestroyElement(
				lpDestDocStg,
				lpDestLine->m_szStgName
		);

		FREEOLESTR(polestr);
		}

		lpDestLine->m_szStgName[0] = '\0';
	}

	// destroy partially created ContainerLine
	if (lpDestLine)
		ContainerLine_Delete(lpDestLine);
	return FALSE;
}


/* ContainerLine_UpdateExtent
** --------------------------
**   Update the size of the ContainerLine because the extents of the
**    object may have changed.
**
**    NOTE: because we are using a Windows OwnerDraw ListBox, we must
**    constrain the maximum possible height of a line. the ListBox has
**    a limitation (unfortunately) that no line can become larger than
**    255 pixels. thus we force the object to scale maintaining its
**    aspect ratio if this maximum line height limit is reached. the
**    actual maximum size for an object at 100% Zoom is
**    255
**
**    RETURNS TRUE -- if the extents of the object changed
**            FALSE -- if the extents did NOT change
*/
BOOL ContainerLine_UpdateExtent(
		LPCONTAINERLINE     lpContainerLine,
		LPSIZEL             lpsizelHim
)
{
	LPOUTLINEDOC lpOutlineDoc = (LPOUTLINEDOC)lpContainerLine->m_lpDoc;
	LPLINELIST lpLL = OutlineDoc_GetLineList(lpOutlineDoc);
	LPLINE lpLine = (LPLINE)lpContainerLine;
	int nIndex = LineList_GetLineIndex(lpLL, lpLine);
	UINT nOrgWidthInHimetric = lpLine->m_nWidthInHimetric;
	UINT nOrgHeightInHimetric = lpLine->m_nHeightInHimetric;
	BOOL fWidthChanged = FALSE;
	BOOL fHeightChanged = FALSE;
	SIZEL sizelHim;
	HRESULT hrErr;

	if (!lpContainerLine || !lpContainerLine->m_lpOleObj)
		return FALSE;

	if (lpContainerLine->m_fGuardObj)
		return FALSE;                // object in process of creation

	OLEDBG_BEGIN3("ContainerLine_UpdateExtent\r\n");

	lpContainerLine->m_fDoGetExtent = FALSE;

	if (! lpsizelHim) {
		/* OLE2NOTE: We want to call IViewObject2::GetExtent instead of
		**    IOleObject::GetExtent. IViewObject2::GetExtent method was
		**    added in OLE 2.01 release. It always retrieves the
		**    extents of the object corresponding to that which will be
		**    drawn by calling IViewObject::Draw. Normally, this is
		**    determined by the data stored in the data cache. This
		**    call will never result in a remoted (LRPC) call.
		*/
		OLEDBG_BEGIN2("IViewObject2::GetExtent called\r\n")
		hrErr = lpContainerLine->m_lpViewObj2->lpVtbl->GetExtent(
				lpContainerLine->m_lpViewObj2,
				lpContainerLine->m_dwDrawAspect,
				-1,     /*lindex*/
				NULL,   /*ptd*/
				(LPSIZEL)&sizelHim
		);
		OLEDBG_END2
		if (hrErr != NOERROR)
			sizelHim.cx = sizelHim.cy = 0;

		lpsizelHim = (LPSIZEL)&sizelHim;
	}

	if (lpsizelHim->cx == lpContainerLine->m_sizeInHimetric.cx &&
		lpsizelHim->cy == lpContainerLine->m_sizeInHimetric.cy) {
		goto noupdate;
	}

	if (lpsizelHim->cx > 0 || lpsizelHim->cy > 0) {
		lpContainerLine->m_sizeInHimetric = *lpsizelHim;
	} else {
		/* object does not have any extents; let's use our container
		**    chosen arbitrary size for OLE objects.
		*/
		lpContainerLine->m_sizeInHimetric.cx = (long)DEFOBJWIDTH;
		lpContainerLine->m_sizeInHimetric.cy = (long)DEFOBJHEIGHT;
	}

	ContainerLine_SetLineHeightFromObjectExtent(
			lpContainerLine,
			(LPSIZEL)&lpContainerLine->m_sizeInHimetric);

	// if height of object changed, then reset the height of line in LineList
	if (nOrgHeightInHimetric != lpLine->m_nHeightInHimetric) {
		LineList_SetLineHeight(lpLL, nIndex, lpLine->m_nHeightInHimetric);
		fHeightChanged = TRUE;
	}

	fWidthChanged = LineList_RecalcMaxLineWidthInHimetric(
			lpLL,
			nOrgWidthInHimetric
	);
	fWidthChanged |= (nOrgWidthInHimetric != lpLine->m_nWidthInHimetric);

	if (fHeightChanged || fWidthChanged) {
		OutlineDoc_ForceRedraw(lpOutlineDoc, TRUE);

		// mark ContainerDoc as now dirty
		OutlineDoc_SetModified(lpOutlineDoc, TRUE, TRUE, TRUE);
	}

	OLEDBG_END3
	return TRUE;

noupdate:
	OLEDBG_END3
	return FALSE;   // No UPDATE necessary
}


/* ContainerLine_DoVerb
** --------------------
**    Activate the OLE object and perform a specific verb.
*/
BOOL ContainerLine_DoVerb(
		LPCONTAINERLINE lpContainerLine,
		LONG            iVerb,
		LPMSG           lpMsg,
		BOOL            fMessage,
		BOOL            fAction
)
{
	HRESULT hrErr;
	LPOUTLINEDOC lpOutlineDoc = (LPOUTLINEDOC)lpContainerLine->m_lpDoc;
	RECT rcPosRect;
	OLEDBG_BEGIN3("ContainerLine_DoVerb\r\n")

	if (lpContainerLine->m_fGuardObj) {
		// object in process of creation--Fail the DoVerb call
		hrErr = ResultFromScode(E_FAIL);
		goto error;
	}

	/* if object is not already loaded, then load it now. objects are
	**    loaded lazily in this manner.
	*/
	if (! lpContainerLine->m_lpOleObj)
		ContainerLine_LoadOleObject(lpContainerLine);

	if (! lpContainerLine->m_lpOleObj) {
#if defined( _DEBUG )
		OleDbgAssertSz(
				lpContainerLine->m_lpOleObj != NULL,
				"OLE object not loaded"
		);
#endif
		goto error;
	}

ExecuteDoVerb:

	ContainerLine_GetPosRect(lpContainerLine, (LPRECT)&rcPosRect);

	// run the object
	hrErr = ContainerLine_RunOleObject(lpContainerLine);
	if (hrErr != NOERROR)
		goto error;

	/* Tell object server to perform a "verb". */
	OLEDBG_BEGIN2("IOleObject::DoVerb called\r\n")
	hrErr = lpContainerLine->m_lpOleObj->lpVtbl->DoVerb (
			lpContainerLine->m_lpOleObj,
			iVerb,
			lpMsg,
			(LPOLECLIENTSITE)&lpContainerLine->m_OleClientSite,
			-1,
			OutlineDoc_GetWindow(lpOutlineDoc),
			(LPCRECT)&rcPosRect
	);
	OLEDBG_END2

	/* OLE2NOTE: IOleObject::DoVerb may return a success code
	**    OLE_S_INVALIDVERB. this SCODE should NOT be considered an
	**    error; thus it is important to use the "FAILED" macro to
	**    check for an error SCODE.
	*/
	if (FAILED(GetScode(hrErr))) {
		OleDbgOutHResult("WARNING: lpOleObj->DoVerb returned", hrErr);
		goto error;
	}

#if defined( INPLACE_CNTR )
	/* OLE2NOTE: we want to keep only 1 inplace server active at any
	**    given time. so when we start to do a DoVerb on another line,
	**    then we want to shut down the previously activated server. in
	**    this way we keep at most one inplace server active at a time.
	**    because it is possible that the object we want to do DoVerb
	**    on is handled by the same EXE as that of the previously
	**    activated server, then we do not want the EXE to be shut down
	**    only to be launched again. in order to avoid this we will do
	**    the DoVerb BEFORE trying to shutdown the previous object.
	*/
	if (!g_fInsideOutContainer) {
		ContainerDoc_ShutDownLastInPlaceServerIfNotNeeded(
				lpContainerLine->m_lpDoc, lpContainerLine);
	}
#endif  // INPLACE_CNTR

	OLEDBG_END3
	return TRUE;

error:

	if (lpContainerLine->m_dwLinkType != 0)
		lpContainerLine->m_fLinkUnavailable = TRUE;

#if defined( INPLACE_CNTR )
	/* OLE2NOTE: we want to keep only 1 inplace server active at any
	**    given time. so when we start to do a DoVerb on another line,
	**    then we want to shut down the previously activated server. in
	**    this way we keep at most one inplace server active at a time.
	**    even though the DoVerb failed, we will still shutdown the
	**    previous server. it is possible that we ran out of memory and
	**    that the DoVerb will succeed next time after shutting down
	**    the pervious server.
	*/
	if (!g_fInsideOutContainer) {
		ContainerDoc_ShutDownLastInPlaceServerIfNotNeeded(
				lpContainerLine->m_lpDoc, lpContainerLine);
	}
#endif  // INPLACE_CNTR

	/* OLE2NOTE: if an error occurs we must give the appropriate error
	**    message box. there are many potential errors that can occur.
	**    the OLE2.0 user model has specific guidelines as to the
	**    dialogs that should be displayed given the various potential
	**    errors (eg. server not registered, unavailable link source.
	**    the OLE2UI library includes support for most of the
	**    recommended message dialogs. (see OleUIPrompUser function)
	*/
	if (fMessage) {
		BOOL fReDoVerb = ContainerLine_ProcessOleRunError(
				lpContainerLine,
				hrErr,
				fAction,
				(lpMsg==NULL && iVerb>=0)   /* fMenuInvoked */
		);
		if (fReDoVerb) {
			goto ExecuteDoVerb;
		}
	}

	OLEDBG_END3
	return FALSE;
}



/* ContainerLine_ProcessOleRunError
 * --------------------------------
 *
 *  Handle the various errors possible when attempting OleRun of an object.
 *  Popup up appropriate message according to the error and/or take action
 *  specified button pressed by the user.
 *
 *  OLE2NOTE: The OLE 2.0 User Interface Guidelines specify the messages
 *            that should be given for the following situations:
 *                  1. Link Source Unavailable...goto Links dialog
 *                  2. Server Not Registered...goto Convert dialog
 *                  3. Link Type Changed
 *                  4. Server Not Found
 *
 *  Returns:    TRUE -- repeat IOleObject::DoVerb call.
 *              FALSE -- do NOT repeat IOleObject::DoVerb call.
 *
 *  Comments:
 *      (see LinkTypeChanged case)
 */
BOOL ContainerLine_ProcessOleRunError(
		LPCONTAINERLINE         lpContainerLine,
		HRESULT                 hrErr,
		BOOL                    fAction,
		BOOL                    fMenuInvoked
)
{
	LPOUTLINEDOC    lpOutlineDoc = (LPOUTLINEDOC)lpContainerLine->m_lpDoc;
	HWND            hwndParent = OutlineDoc_GetWindow(lpOutlineDoc);
	SCODE           sc = GetScode(hrErr);
	BOOL            fReDoVerb = FALSE;

	OleDbgOutHResult("ProcessError", hrErr);
	if ((sc >= MK_E_FIRST) && (sc <= MK_E_LAST))
		goto LinkSourceUnavailable;
	if (sc == OLE_E_CANT_BINDTOSOURCE)
		goto LinkSourceUnavailable;
	if (sc == STG_E_PATHNOTFOUND)
		goto LinkSourceUnavailable;
	if (sc == REGDB_E_CLASSNOTREG)
		goto ServerNotReg;
	if (sc == OLE_E_STATIC)
		goto ServerNotReg;  // user dblclk'ed a static object w/ no svr reg'd
	if (sc == OLE_E_CLASSDIFF)
		goto LinkTypeChanged;
	if (sc == CO_E_APPDIDNTREG)
		goto ServerNotFound;
	if (sc == CO_E_APPNOTFOUND)
		goto ServerNotFound;
	if (sc == E_OUTOFMEMORY)
		goto OutOfMemory;

	if (ContainerLine_IsOleLink(lpContainerLine))
		goto LinkSourceUnavailable;
	else
		goto ServerNotFound;


/*************************************************************************
** Error handling routines                                              **
*************************************************************************/
LinkSourceUnavailable:
	if (ID_PU_LINKS == OleUIPromptUser(
				(WORD)IDD_LINKSOURCEUNAVAILABLE,
				hwndParent,
				(LPSTR)APPNAME)) {
		if (fAction) {
			ContainerDoc_EditLinksCommand(lpContainerLine->m_lpDoc);
		}
	}
	return fReDoVerb;

ServerNotReg:
	{
	LPSTR lpszUserType = NULL;
	CLIPFORMAT  cfFormat;	    // not used
	LPOLESTR polestr;

	hrErr = ReadFmtUserTypeStg(
			lpContainerLine->m_lpStg, &cfFormat, &polestr);

	CopyAndFreeOLESTR(polestr, &lpszUserType);

	if (ID_PU_CONVERT == OleUIPromptUser(
			(WORD)IDD_SERVERNOTREG,
			hwndParent,
			(LPSTR)APPNAME,
			(hrErr == NOERROR) ? lpszUserType : (LPSTR)"Unknown Object")) {
		if (fAction) {
			ContainerDoc_ConvertCommand(
					lpContainerLine->m_lpDoc,
					TRUE        // fMustActivate
			);
		}
	}

	if (lpszUserType)
		OleStdFreeString(lpszUserType, NULL);

	return fReDoVerb;
	}


LinkTypeChanged:
	{
	/* OLE2NOTE: If IOleObject::DoVerb is executed on a Link object and it
	**    returns OLE_E_CLASSDIFF because the link source is no longer
	**    the expected class, then if the verb is a semantically
	**    defined verb (eg. OLEIVERB_PRIMARY, OLEIVERB_SHOW,
	**    OLEIVERB_OPEN, etc.), then the link should be re-created with
	**    the new link source and the same verb executed on the new
	**    link. there is no need to give a message to the user. if the
	**    user had selected a verb from the object's verb menu
	**    (fMenuInvoked==TRUE), then we can not be certain of the
	**    semantics of the verb and whether the new link can still
	**    support the verb. in this case the user is given a prompt
	**    telling him to "choose a different command offered by the new
	**    type".
	*/

	LPSTR       lpszUserType = NULL;

	if (fMenuInvoked) {
		LPOLESTR polestr;

		hrErr = lpContainerLine->m_lpOleObj->lpVtbl->GetUserType(
				lpContainerLine->m_lpOleObj,USERCLASSTYPE_FULL, polestr);

		CopyAndFreeOLESTR(polestr, &lpszUserType);

		OleUIPromptUser(
				(WORD)IDD_LINKTYPECHANGED,
				hwndParent,
				(LPSTR)APPNAME,
				(hrErr == NOERROR) ? lpszUserType : (LPSTR)"Unknown Object"
		);
	} else {
		fReDoVerb = TRUE;
	}
	ContainerLine_ReCreateLinkBecauseClassDiff(lpContainerLine);

	if (lpszUserType)
		OleStdFreeString(lpszUserType, NULL);

	return fReDoVerb;
	}

ServerNotFound:

	OleUIPromptUser(
			(WORD)IDD_SERVERNOTFOUND,
			hwndParent,
			(LPSTR)APPNAME);
	return fReDoVerb;

OutOfMemory:

	OleUIPromptUser(
			(WORD)IDD_OUTOFMEMORY,
			hwndParent,
			(LPSTR)APPNAME);
	return fReDoVerb;
}


/* ContainerLine_ReCreateLinkBecauseClassDiff
** ------------------------------------------
**    Re-create the link. The existing link was created when
**    the moniker binds to a link source bound of a different class
**    than the same moniker currently binds to. the link may be a
**    special link object specifically used with the old link
**    source class. thus the link object needs to be re-created to
**    give the new link source the opportunity to create its own
**    special link object. (see description "Custom Link Source")
*/
HRESULT ContainerLine_ReCreateLinkBecauseClassDiff(
		LPCONTAINERLINE lpContainerLine
)
{
	LPOLELINK   lpOleLink = lpContainerLine->m_lpOleLink;
	HGLOBAL     hMetaPict = NULL;
	LPMONIKER   lpmkLinkSrc = NULL;
	SCODE       sc = E_FAIL;
	HRESULT     hrErr;

	if (lpOleLink &&
		lpOleLink->lpVtbl->GetSourceMoniker(
				lpOleLink, (LPMONIKER FAR*)&lpmkLinkSrc) == NOERROR) {

		BOOL            fDisplayAsIcon =
							(lpContainerLine->m_dwDrawAspect==DVASPECT_ICON);
		STGMEDIUM       medium;
		LPDATAOBJECT    lpDataObj = NULL;
		DWORD           dwOleRenderOpt;
		FORMATETC       renderFmtEtc;
		LPFORMATETC     lpRenderFmtEtc = NULL;

		// get the current icon if object is displayed as icon
		if (fDisplayAsIcon &&
			(lpDataObj = (LPDATAOBJECT)OleStdQueryInterface( (LPUNKNOWN)
					lpContainerLine->m_lpOleObj,&IID_IDataObject)) != NULL ) {
			hMetaPict = OleStdGetData(
					lpDataObj, CF_METAFILEPICT, NULL, DVASPECT_ICON, &medium);
			OleStdRelease((LPUNKNOWN)lpDataObj);
		}

		if (fDisplayAsIcon && hMetaPict) {
			// a special icon should be used. first we create the object
			// OLERENDER_NONE. then we stuff the special icon into the cache.

			dwOleRenderOpt = OLERENDER_NONE;

		} else if (fDisplayAsIcon && hMetaPict == NULL) {
			// the object's default icon should be used

			dwOleRenderOpt = OLERENDER_DRAW;
			lpRenderFmtEtc = (LPFORMATETC)&renderFmtEtc;
			SETFORMATETC(renderFmtEtc,0,DVASPECT_ICON,NULL,TYMED_NULL,-1);

		} else {
			// create standard DVASPECT_CONTENT/OLERENDER_DRAW object
			dwOleRenderOpt = OLERENDER_DRAW;
		}

		// unload original link object
		ContainerLine_UnloadOleObject(lpContainerLine, OLECLOSE_SAVEIFDIRTY);

		// delete entire contents of the current object's storage
		OleStdDestroyAllElements(lpContainerLine->m_lpStg);

		OLEDBG_BEGIN2("OleCreateLink called\r\n")
		hrErr = OleCreateLink (
				lpmkLinkSrc,
				&IID_IOleObject,
				dwOleRenderOpt,
				lpRenderFmtEtc,
				(LPOLECLIENTSITE)&lpContainerLine->m_OleClientSite,
				lpContainerLine->m_lpStg,
				(LPVOID FAR*)&lpContainerLine->m_lpOleObj
		);
		OLEDBG_END2

		if (hrErr == NOERROR) {
			if (! ContainerLine_SetupOleObject(
					lpContainerLine, fDisplayAsIcon, hMetaPict) ) {

				// ERROR: setup of the new link failed.
				// revert the storage to restore the original link.
				ContainerLine_UnloadOleObject(
						lpContainerLine, OLECLOSE_NOSAVE);
				lpContainerLine->m_lpStg->lpVtbl->Revert(
						lpContainerLine->m_lpStg);
				sc = E_FAIL;
			} else {
				sc = S_OK;  // IT WORKED!

			}
		}
		else {
			sc = GetScode(hrErr);
			OleDbgOutHResult("OleCreateLink returned", hrErr);
			// ERROR: Re-creating the link failed.
			// revert the storage to restore the original link.
			lpContainerLine->m_lpStg->lpVtbl->Revert(
					lpContainerLine->m_lpStg);
		}
	}

	if (hMetaPict)
		OleUIMetafilePictIconFree(hMetaPict); // clean up metafile
	return ResultFromScode(sc);
}

/* ContainerLine_GetOleObject
** --------------------------
**    return pointer to desired interface of embedded/linked object.
**
**    NOTE: this function causes an AddRef to the object. when the caller is
**          finished with the object, it must call Release.
**          this function does not AddRef the ContainerLine object.
*/
LPUNKNOWN ContainerLine_GetOleObject(
		LPCONTAINERLINE         lpContainerLine,
		REFIID                  riid
)
{
	/* if object is not already loaded, then load it now. objects are
	**    loaded lazily in this manner.
	*/
	if (! lpContainerLine->m_lpOleObj)
		ContainerLine_LoadOleObject(lpContainerLine);

	if (lpContainerLine->m_lpOleObj)
		return OleStdQueryInterface(
				(LPUNKNOWN)lpContainerLine->m_lpOleObj,
				riid
		);
	else
		return NULL;
}



/* ContainerLine_RunOleObject
** --------------------------
**    Load and run the object. Upon running and if size of object has changed,
**    use SetExtent to change to new size.
**
*/
HRESULT ContainerLine_RunOleObject(LPCONTAINERLINE lpContainerLine)
{
	LPLINE lpLine = (LPLINE)lpContainerLine;
	SIZEL   sizelNew;
	HRESULT hrErr;
	HCURSOR  hPrevCursor;

	if (! lpContainerLine)
		return NOERROR;

	if (lpContainerLine->m_fGuardObj) {
		// object in process of creation--Fail to Run the object
		return ResultFromScode(E_FAIL);
	}

	if (lpContainerLine->m_lpOleObj &&
		OleIsRunning(lpContainerLine->m_lpOleObj))
		return NOERROR;     // object already running

	// this may take a while, put up hourglass cursor
	hPrevCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
	OLEDBG_BEGIN3("ContainerLine_RunOleObject\r\n")

	if (! lpContainerLine->m_lpOleObj) {
		if (! ContainerLine_LoadOleObject(lpContainerLine))
			return ResultFromScode(E_OUTOFMEMORY); // Error: couldn't load obj
	}

	OLEDBG_BEGIN2("OleRun called\r\n")
	hrErr = OleRun((LPUNKNOWN)lpContainerLine->m_lpOleObj);
	OLEDBG_END2

	if (hrErr != NOERROR) {
		SetCursor(hPrevCursor);     // restore original cursor

		OleDbgOutHResult("OleRun returned", hrErr);
		OLEDBG_END3
		return hrErr;
	}

	if (lpContainerLine->m_fDoSetExtent) {
		/* OLE2NOTE: the OLE object was resized when it was not running
		**    and the object did not have the OLEMISC_RECOMPOSEONRESIZE
		**    bit set. if it had, the object would have been run
		**    immediately when it was resized. this flag indicates that
		**    the object does something other than simple scaling when
		**    it is resized. because the object is being run now, we
		**    will call IOleObject::SetExtent.
		*/
		lpContainerLine->m_fDoSetExtent = FALSE;

		// the size stored in our Line includes the border around the object.
		// we must subtract the border to get the size of the object itself.
		sizelNew.cx = lpLine->m_nWidthInHimetric;
		sizelNew.cy = lpLine->m_nHeightInHimetric;

		if ((sizelNew.cx != lpContainerLine->m_sizeInHimetric.cx) ||
			(sizelNew.cy != lpContainerLine->m_sizeInHimetric.cy)) {

			OLEDBG_BEGIN2("IOleObject::SetExtent called\r\n")
			lpContainerLine->m_lpOleObj->lpVtbl->SetExtent(
					lpContainerLine->m_lpOleObj,
					lpContainerLine->m_dwDrawAspect,
					(LPSIZEL)&sizelNew
			);
			OLEDBG_END2
		}
	}

	SetCursor(hPrevCursor);     // restore original cursor

	OLEDBG_END3
	return NOERROR;

}


/* ContainerLine_IsOleLink
** -----------------------
**
**    return TRUE if the ContainerLine has an OleLink.
**           FALSE if the ContainerLine has an embedding
*/
BOOL ContainerLine_IsOleLink(LPCONTAINERLINE lpContainerLine)
{
	if (!lpContainerLine)
		return FALSE;

	return (lpContainerLine->m_dwLinkType != 0);
}


/*  ContainerLine_Draw
**  ------------------
**
**      Draw a ContainerLine object on a DC.
**
**  Parameters:
**      hDC     - DC to which the line will be drawn
**      lpRect  - the object rect in logical coordinates
**      lpRectWBounds - bounding rect of the metafile underneath hDC
**                      (NULL if hDC is not a metafile DC)
**      fHighlight    - TRUE if line has selection highlight
*/
void ContainerLine_Draw(
		LPCONTAINERLINE         lpContainerLine,
		HDC                     hDC,
		LPRECT                  lpRect,
		LPRECT                  lpRectWBounds,
		BOOL                    fHighlight
)
{
	LPLINE  lpLine = (LPLINE) lpContainerLine;
	HRESULT hrErr = NOERROR;
	RECTL   rclHim;
	RECTL   rclHimWBounds;
	RECT    rcHim;

	if (lpContainerLine->m_fGuardObj) {
		// object in process of creation--do NOT try to draw
		return;
	}

	/* if object is not already loaded, then load it now. objects are
	**    loaded lazily in this manner.
	*/
	if (! lpContainerLine->m_lpViewObj2) {
		if (! ContainerLine_LoadOleObject(lpContainerLine))
			return;     // Error: could not load object
	}

	if (lpRectWBounds) {
		rclHimWBounds.left      = (long) lpRectWBounds->left;
		rclHimWBounds.bottom    = (long) lpRectWBounds->bottom;
		rclHimWBounds.top       = (long) lpRectWBounds->top;
		rclHimWBounds.right     = (long) lpRectWBounds->right;
	}

	/* construct bounds rectangle for the object.
	**  offset origin for object to correct tab indentation
	*/
	rclHim.left     = (long) lpRect->left;
	rclHim.bottom   = (long) lpRect->bottom;
	rclHim.top      = (long) lpRect->top;
	rclHim.right    = (long) lpRect->right;

	rclHim.left += (long) ((LPLINE)lpContainerLine)->m_nTabWidthInHimetric;
	rclHim.right += (long) ((LPLINE)lpContainerLine)->m_nTabWidthInHimetric;

#if defined( INPLACE_CNTR )
	/* OLE2NOTE: if the OLE object currently has a visible in-place
	**    window, then we do NOT want to draw on top of its window.
	**    this could interfere with the object's display.
	*/
	if ( !lpContainerLine->m_fIpVisible )
#endif
	{
	hrErr = lpContainerLine->m_lpViewObj2->lpVtbl->Draw(
			lpContainerLine->m_lpViewObj2,
			lpContainerLine->m_dwDrawAspect,
			-1,
			NULL,
			NULL,
			NULL,
			hDC,
			(LPRECTL)&rclHim,
			(lpRectWBounds ? (LPRECTL)&rclHimWBounds : NULL),
			NULL,
			0
	);
	if (hrErr != NOERROR)
		OleDbgOutHResult("IViewObject::Draw returned", hrErr);

	if (lpContainerLine->m_fObjWinOpen)
		{
		rcHim.left      = (int) rclHim.left;
		rcHim.top       = (int) rclHim.top;
		rcHim.right     = (int) rclHim.right;
		rcHim.bottom    = (int) rclHim.bottom;

		/* OLE2NOTE: if the object servers window is Open (ie. not active
		**    in-place) then we must shade the object in our document to
		**    indicate to the user that the object is open elsewhere.
		*/
		OleUIDrawShading((LPRECT)&rcHim, hDC, OLEUI_SHADE_FULLRECT, 0);
		}
	}

	/* if the object associated with the ContainerLine is an automatic
	**    link then try to connect it with its LinkSource if the
	**    LinkSource is already running. we do not want to force the
	**    LinkSource to run.
	**
	**    OLE2NOTE: a sophistocated container will want to continually
	**    attempt to connect its automatic links. OLE does NOT
	**    automatically connect links when link sources become
	**    available. some containers will want to attempt to connect
	**    its links as part of idle time processing. another strategy
	**    is to attempt to connect an automatic link every time it is
	**    drawn on the screen. (this is the strategy used by this
	**    CntrOutl sample application.)
	*/
	if (lpContainerLine->m_dwLinkType == OLEUPDATE_ALWAYS)
		ContainerLine_BindLinkIfLinkSrcIsRunning(lpContainerLine);

	return;
}


void ContainerLine_DrawSelHilight(
		LPCONTAINERLINE lpContainerLine,
		HDC             hDC,            // MM_TEXT mode
		LPRECT          lprcPix,        // listbox rect
		UINT            itemAction,
		UINT            itemState
)
{
	LPLINE  lpLine = (LPLINE)lpContainerLine;
	RECT    rcObj;
	DWORD   dwFlags = OLEUI_HANDLES_INSIDE | OLEUI_HANDLES_USEINVERSE;
	int     nHandleSize;
	LPCONTAINERDOC lpContainerDoc;

	if (!lpContainerLine || !hDC || !lprcPix)
		return;

	lpContainerDoc = lpContainerLine->m_lpDoc;

	// Get size of OLE object
	ContainerLine_GetOleObjectRectInPixels(lpContainerLine, (LPRECT)&rcObj);

	nHandleSize = GetProfileInt("windows", "oleinplaceborderwidth",
			DEFAULT_HATCHBORDER_WIDTH) + 1;

	OleUIDrawHandles((LPRECT)&rcObj, hDC, dwFlags, nHandleSize, TRUE);
}

/* InvertDiffRect
** --------------
**
**    Paint the surrounding of the Obj rect black but within lprcPix
**      (similar to the lprcPix minus lprcObj)
*/
static void InvertDiffRect(LPRECT lprcPix, LPRECT lprcObj, HDC hDC)
{
	RECT rcBlack;

	// draw black in all space outside of object's rectangle
	rcBlack.top = lprcPix->top;
	rcBlack.bottom = lprcPix->bottom;

	rcBlack.left = lprcPix->left + 1;
	rcBlack.right = lprcObj->left - 1;
	InvertRect(hDC, (LPRECT)&rcBlack);

	rcBlack.left = lprcObj->right + 1;
	rcBlack.right = lprcPix->right - 1;
	InvertRect(hDC, (LPRECT)&rcBlack);

	rcBlack.top = lprcPix->top;
	rcBlack.bottom = lprcPix->top + 1;
	rcBlack.left = lprcObj->left - 1;
	rcBlack.right = lprcObj->right + 1;
	InvertRect(hDC, (LPRECT)&rcBlack);

	rcBlack.top = lprcPix->bottom;
	rcBlack.bottom = lprcPix->bottom - 1;
	rcBlack.left = lprcObj->left - 1;
	rcBlack.right = lprcObj->right + 1;
	InvertRect(hDC, (LPRECT)&rcBlack);
}


/* Edit the ContainerLine line object.
**      returns TRUE if line was changed
**              FALSE if the line was NOT changed
*/
BOOL ContainerLine_Edit(LPCONTAINERLINE lpContainerLine, HWND hWndDoc,HDC hDC)
{
	ContainerLine_DoVerb(lpContainerLine, OLEIVERB_PRIMARY, NULL, TRUE, TRUE);

	/* assume object was NOT changed, if it was obj will send Changed
	**    or Saved notification.
	*/
	return FALSE;
}



/* ContainerLine_SetHeightInHimetric
** ---------------------------------
**
** Set the height of a ContainerLine object. The widht will be changed
** to keep the aspect ratio
*/
void ContainerLine_SetHeightInHimetric(LPCONTAINERLINE lpContainerLine, int nHeight)
{
	LPLINE  lpLine = (LPLINE)lpContainerLine;
	SIZEL   sizelOleObject;
	HRESULT hrErr;

	if (!lpContainerLine)
		return;

	if (lpContainerLine->m_fGuardObj) {
		// object in process of creation--Fail to set the Height
		return;
	}

	if (nHeight != -1) {
		BOOL    fMustClose = FALSE;
		BOOL    fMustRun   = FALSE;

		/* if object is not already loaded, then load it now. objects are
		**    loaded lazily in this manner.
		*/
		if (! lpContainerLine->m_lpOleObj)
			ContainerLine_LoadOleObject(lpContainerLine);

		// the height argument specifies the desired height for the Line.
		sizelOleObject.cy = nHeight;

		// we will calculate the corresponding width for the object by
		// maintaining the current aspect ratio of the object.
		sizelOleObject.cx = (int)(sizelOleObject.cy *
				lpContainerLine->m_sizeInHimetric.cx /
				lpContainerLine->m_sizeInHimetric.cy);

		/* OLE2NOTE: if the OLE object is already running then we can
		**    immediately call SetExtent. But, if the object is NOT
		**    currently running then we will check if the object
		**    indicates that it is normally recomposes itself on
		**    resizing. ie. that the object does not simply scale its
		**    display when it it resized. if so then we will force the
		**    object to run so that we can call IOleObject::SetExtent.
		**    SetExtent does not have any effect if the object is only
		**    loaded. if the object does NOT indicate that it
		**    recomposes on resize (OLEMISC_RECOMPOSEONRESIZE) then we
		**    will wait till the next time that the object is run to
		**    call SetExtent. we will store a flag in the ContainerLine
		**    to indicate that a SetExtent is necessary. It is
		**    necessary to persist this flag.
		*/
		if (! OleIsRunning(lpContainerLine->m_lpOleObj)) {
			DWORD dwStatus;

			OLEDBG_BEGIN2("IOleObject::GetMiscStatus called\r\n")
			hrErr = lpContainerLine->m_lpOleObj->lpVtbl->GetMiscStatus(
					lpContainerLine->m_lpOleObj,
					lpContainerLine->m_dwDrawAspect,
					(LPDWORD)&dwStatus
			);
			OLEDBG_END2
			if (hrErr == NOERROR && (dwStatus & OLEMISC_RECOMPOSEONRESIZE)) {
				// force the object to run
				ContainerLine_RunOleObject(lpContainerLine);
				fMustClose = TRUE;
			} else {
				/*  the OLE object is NOT running and does NOT
				**    recompose on resize. simply scale the object now
				**    and do the SetExtent the next time the object is
				**    run. we set the Line to the new size even though
				**    the object's extents have not been changed.
				**    this has the result of scaling the object's
				**    display to the new size.
				*/
				lpContainerLine->m_fDoSetExtent = TRUE;
				ContainerLine_SetLineHeightFromObjectExtent(
						lpContainerLine, (LPSIZEL)&sizelOleObject);
				return;
			}
		}

		OLEDBG_BEGIN2("IOleObject::SetExtent called\r\n")
		hrErr = lpContainerLine->m_lpOleObj->lpVtbl->SetExtent(
				lpContainerLine->m_lpOleObj,
				lpContainerLine->m_dwDrawAspect,
				(LPSIZEL)&sizelOleObject);
		OLEDBG_END2

		if (hrErr != NOERROR) {
			/* OLE Object refuses to take on the new extents. Set the
			**    Line to the new size even though the object refused
			**    the new extents. this has the result of scaling the
			**    object's display to the new size.
			**
			**    if the object HAD accepted the new extents, then it
			**    will send out an OnViewChange/OnDataChange
			**    notification. this results in our container receiving
			**    an OnViewChange notification; the line height will be
			**    reset when this notification is received.
			*/
			ContainerLine_SetLineHeightFromObjectExtent(
					lpContainerLine, (LPSIZEL)&sizelOleObject);
		}

		if (fMustClose)
			ContainerLine_CloseOleObject(
					lpContainerLine, OLECLOSE_SAVEIFDIRTY);
	}
	else {
		/* Set the line to default height given the natural (unscaled)
		**    extents of the OLE object.
		*/
		ContainerLine_SetLineHeightFromObjectExtent(
				lpContainerLine,(LPSIZEL)&lpContainerLine->m_sizeInHimetric);
	}

}


/*  ContainerLine_SetLineHeightFromObjectExtent
 *
 *  Purpose:
 *      Calculate the corresponding line height from the OleObject size
 *      Scale the line height to fit the limit if necessary
 *
 *  Parameters:
 *      lpsizelOleObject        pointer to size of OLE Object
 *
 *  Returns:
 *      nil
 */
void ContainerLine_SetLineHeightFromObjectExtent(
		LPCONTAINERLINE         lpContainerLine,
		LPSIZEL                 lpsizelOleObject
)
{
	LPLINE lpLine = (LPLINE)lpContainerLine;

	UINT uMaxObjectHeight = XformHeightInPixelsToHimetric(NULL,
			LISTBOX_HEIGHT_LIMIT);

	if (!lpContainerLine || !lpsizelOleObject)
		return;

	if (lpContainerLine->m_fGuardObj) {
		// object in process of creation--Fail to set the Height
		return;
	}

	lpLine->m_nWidthInHimetric = (int)lpsizelOleObject->cx;
	lpLine->m_nHeightInHimetric = (int)lpsizelOleObject->cy;

	// Rescale the object if height is greater than the limit
	if (lpLine->m_nHeightInHimetric > (UINT)uMaxObjectHeight) {

		lpLine->m_nWidthInHimetric = (UINT)
				((long)lpLine->m_nWidthInHimetric *
				(long)uMaxObjectHeight /
				(long)lpLine->m_nHeightInHimetric);

		lpLine->m_nHeightInHimetric = uMaxObjectHeight;
	}

}


/* ContainerLine_SaveToStg
** -----------------------
**    Save a given ContainerLine and associated OLE object to an IStorage*.
*/
BOOL ContainerLine_SaveToStm(
		LPCONTAINERLINE         lpContainerLine,
		LPSTREAM                lpLLStm
)
{
	CONTAINERLINERECORD objLineRecord;
	ULONG nWritten;
	HRESULT hrErr;

	lstrcpy(objLineRecord.m_szStgName, lpContainerLine->m_szStgName);
	objLineRecord.m_fMonikerAssigned = lpContainerLine->m_fMonikerAssigned;
	objLineRecord.m_dwDrawAspect = lpContainerLine->m_dwDrawAspect;
	objLineRecord.m_sizeInHimetric = lpContainerLine->m_sizeInHimetric;
	objLineRecord.m_dwLinkType = lpContainerLine->m_dwLinkType;
	objLineRecord.m_fDoSetExtent = lpContainerLine->m_fDoSetExtent;

	/* write line record */
	hrErr = lpLLStm->lpVtbl->Write(
			lpLLStm,
			(LPVOID)&objLineRecord,
			sizeof(CONTAINERLINERECORD),
			&nWritten
	);

	if (hrErr != NOERROR) {
		OleDbgAssertSz(hrErr == NOERROR,"Could not write to LineList stream");
		return FALSE;
	}

	return TRUE;
}


/* ContainerLine_SaveOleObjectToStg
** --------------------------------
**    Save the OLE object associated with the ContainerLine to an IStorage*.
*/
BOOL ContainerLine_SaveOleObjectToStg(
		LPCONTAINERLINE         lpContainerLine,
		LPSTORAGE               lpSrcStg,
		LPSTORAGE               lpDestStg,
		BOOL                    fRemember
)
{
	HRESULT         hrErr;
	SCODE           sc = S_OK;
	BOOL            fStatus;
	BOOL            fSameAsLoad = (lpSrcStg==lpDestStg ? TRUE : FALSE);
	LPSTORAGE       lpObjDestStg;

	if (lpContainerLine->m_fGuardObj) {
		// object in process of creation--Fail to save
		return FALSE;
	}

	if (! lpContainerLine->m_lpOleObj) {

		/*****************************************************************
		** CASE 1: object is NOT loaded.
		*****************************************************************/

		if (fSameAsLoad) {
			/*************************************************************
			** CASE 1A: we are saving to the current storage. because
			**    the object is not loaded, it is up-to-date
			**    (ie. nothing to do).
			*************************************************************/

			;

		} else {
			/*************************************************************
			** CASE 1B: we are saving to a new storage. because
			**    the object is not loaded, we can simply copy the
			**    object's current storage to the new storage.
			*************************************************************/

			/* if current object storage is not already open, then open it */
			if (! lpContainerLine->m_lpStg) {
				lpContainerLine->m_lpStg = OleStdOpenChildStorage(
						lpSrcStg,
						lpContainerLine->m_szStgName,
						STGM_READWRITE
					);
				if (lpContainerLine->m_lpStg == NULL) {
#if defined( _DEBUG )
					OleDbgAssertSz(
							lpContainerLine->m_lpStg != NULL,
							"Error opening child stg"
					);
#endif
					return FALSE;
				}
			}

			/* Create a child storage inside the destination storage. */
			lpObjDestStg = OleStdCreateChildStorage(
					lpDestStg,
					lpContainerLine->m_szStgName
			);

			if (lpObjDestStg == NULL) {
#if defined( _DEBUG )
				OleDbgAssertSz(
						lpObjDestStg != NULL,
						"Could not create obj storage!"
				);
#endif
				return FALSE;
			}

			hrErr = lpContainerLine->m_lpStg->lpVtbl->CopyTo(
					lpContainerLine->m_lpStg,
					0,
					NULL,
					NULL,
					lpObjDestStg
			);
			// REVIEW: should we handle error here?
			fStatus = OleStdCommitStorage(lpObjDestStg);

			/* if we are supposed to remember this storage as the new
			**    storage for the object, then release the old one and
			**    save the new one. else, throw away the new one.
			*/
			if (fRemember) {
				OleStdVerifyRelease(
						(LPUNKNOWN)lpContainerLine->m_lpStg,
						"Original object stg not released"
				);
				lpContainerLine->m_lpStg = lpObjDestStg;
			} else {
				OleStdVerifyRelease(
						(LPUNKNOWN)lpObjDestStg,
						"Copied object stg not released"
				);
			}
		}

	} else {

		/*****************************************************************
		** CASE 2: object IS loaded.
		*****************************************************************/

		if (fSameAsLoad) {
			/*************************************************************
			** CASE 2A: we are saving to the current storage. if the object
			**    is not dirty, then the current storage is up-to-date
			**    (ie. nothing to do).
			*************************************************************/

			LPPERSISTSTORAGE lpPersistStg = lpContainerLine->m_lpPersistStg;
			OleDbgAssert(lpPersistStg);

			hrErr = lpPersistStg->lpVtbl->IsDirty(lpPersistStg);

			/* OLE2NOTE: we will only accept an explicit "no i
			**    am NOT dirty statement" (ie. S_FALSE) as an
			**    indication that the object is clean. eg. if
			**    the object returns E_NOTIMPL we must
			**    interpret it as the object IS dirty.
			*/
			if (GetScode(hrErr) != S_FALSE) {

				/* OLE object IS dirty */

				OLEDBG_BEGIN2("OleSave called\r\n")
				hrErr = OleSave(
						lpPersistStg, lpContainerLine->m_lpStg, fSameAsLoad);
				OLEDBG_END2

				if (hrErr != NOERROR) {
					OleDbgOutHResult("WARNING: OleSave returned", hrErr);
					sc = GetScode(hrErr);
				}

				// OLE2NOTE: if OleSave fails, SaveCompleted must be called.
				OLEDBG_BEGIN2("IPersistStorage::SaveCompleted called\r\n")
				hrErr=lpPersistStg->lpVtbl->SaveCompleted(lpPersistStg,NULL);
				OLEDBG_END2

				if (hrErr != NOERROR) {
					OleDbgOutHResult("WARNING: SaveCompleted returned",hrErr);
					if (sc == S_OK)
						sc = GetScode(hrErr);
				}

				if (sc != S_OK)
					return FALSE;
			}

		} else {
			/*************************************************************
			** CASE 2B: we are saving to a new storage. we must
			**    tell the object to save into the new storage.
			*************************************************************/

			LPPERSISTSTORAGE lpPersistStg = lpContainerLine->m_lpPersistStg;

			if (! lpPersistStg) return FALSE;

			/* Create a child storage inside the destination storage. */
			lpObjDestStg = OleStdCreateChildStorage(
					lpDestStg,
					lpContainerLine->m_szStgName
			);

			if (lpObjDestStg == NULL) {
#if defined( _DEBUG )
				OleDbgAssertSz(
						lpObjDestStg != NULL,
						"Could not create object storage!"
				);
#endif
				return FALSE;
			}

			OLEDBG_BEGIN2("OleSave called\r\n")
			hrErr = OleSave(lpPersistStg, lpObjDestStg, fSameAsLoad);
			OLEDBG_END2

			// OLE2NOTE: even if OleSave fails, must still call SaveCompleted
			if (hrErr != NOERROR) {
				OleDbgOutHResult("WARNING: OleSave returned", hrErr);
				sc = GetScode(hrErr);
			}

			/* OLE2NOTE: a root level container should immediately
			**    call IPersistStorage::SaveCompleted after calling
			**    OleSave. a nested level container should not call
			**    SaveCompleted now, but must wait until SaveCompleted
			**    is call on it by its container. since our container
			**    is not a container/server, then we always call
			**    SaveComplete here.
			**
			**    if this is a SaveAs operation, then we need to pass
			**    the lpStg back in SaveCompleted to inform the object
			**    of its new storage that it may hold on to. if this is
			**    a Save or a SaveCopyAs operation, then we simply pass
			**    NULL in SaveCompleted; the object can continue to hold
			**    its current storage. if an error occurs during the
			**    OleSave call we must still call SaveCompleted but we
			**    must pass NULL.
			*/
			OLEDBG_BEGIN2("IPersistStorage::SaveCompleted called\r\n")
			hrErr = lpPersistStg->lpVtbl->SaveCompleted(
					lpPersistStg,
					((FAILED(sc) || !fRemember) ? NULL : lpObjDestStg)
			);
			OLEDBG_END2

			if (hrErr != NOERROR) {
				OleDbgOutHResult("WARNING: SaveCompleted returned",hrErr);
				if (sc == S_OK)
					sc = GetScode(hrErr);
			}

			if (sc != S_OK) {
				OleStdVerifyRelease(
						(LPUNKNOWN)lpObjDestStg,
						"Copied object stg not released"
				);
				return FALSE;
			}

			/* if we are supposed to remember this storage as the new
			**    storage for the object, then release the old one and
			**    save the new one. else, throw away the new one.
			*/
			if (fRemember) {
				OleStdVerifyRelease(
						(LPUNKNOWN)lpContainerLine->m_lpStg,
						"Original object stg not released"
				);
				lpContainerLine->m_lpStg = lpObjDestStg;
			} else {
				OleStdVerifyRelease(
						(LPUNKNOWN)lpObjDestStg,
						"Copied object stg not released"
				);
			}
		}
	}

	/* OLE2NOTE: after saving an OLE object it is possible that it sent
	**    an OnViewChange notification because it had been modified. in
	**    this situation it is possible that the extents of the object
	**    have changed. if so we want to relayout the space for the
	**    object immediately so that the extent information saved with
	**    the ContainerLine match the data saved with the OLE object
	**    itself.
	*/
	if (lpContainerLine->m_fDoGetExtent) {
		BOOL fSizeChanged = ContainerLine_UpdateExtent(lpContainerLine, NULL);
#if defined( INPLACE_CNTR )
		/* if the extents of this ContainerLine have changed, then we
		**    need to reset the fDoGetExtent flag to TRUE so that later
		**    when ContainerDoc_UpdateExtentOfAllOleObjects is called
		**    (when the WM_U_UPDATEOBJECTEXTENT message is processed),
		**    it is recognized that the extents of this line have
		**    changed. if any line changes size, then any in-place
		**    active object below this line must be told to update the
		**    position of their windows (via SetObjectRects -- see
		**    ContainerDoc_UpdateInPlaceObjectRects function).
		*/
		lpContainerLine->m_fDoGetExtent = fSizeChanged;
#endif
	}

	return TRUE;
}


/* ContainerLine_LoadFromStg
** -------------------------
**    Create a ContainerLine object and initialize it with data that
**    was previously writen to an IStorage*. this function does not
**    immediately OleLoad the associated OLE object, only the data of
**    the ContainerLine object itself is loaded from the IStorage*.
*/
LPLINE ContainerLine_LoadFromStg(
		LPSTORAGE               lpSrcStg,
		LPSTREAM                lpLLStm,
		LPOUTLINEDOC            lpDestDoc
)
{
	HDC         hDC;
	LPLINELIST  lpDestLL = &lpDestDoc->m_LineList;
	ULONG nRead;
	HRESULT hrErr;
	LPCONTAINERLINE lpContainerLine;
	CONTAINERLINERECORD objLineRecord;

	lpContainerLine=(LPCONTAINERLINE) New((DWORD)sizeof(CONTAINERLINE));
	if (lpContainerLine == NULL) {
		OleDbgAssertSz(lpContainerLine!=NULL,"Error allocating ContainerLine");
		return NULL;
	}

	hDC = LineList_GetDC(lpDestLL);
	ContainerLine_Init(lpContainerLine, 0, hDC);
	LineList_ReleaseDC(lpDestLL, hDC);

	/* OLE2NOTE: In order to have a stable ContainerLine object we must
	**    AddRef the object's refcnt. this will be later released when
	**    the ContainerLine is deleted.
	*/
	ContainerLine_AddRef(lpContainerLine);

	lpContainerLine->m_lpDoc = (LPCONTAINERDOC) lpDestDoc;

	/* read line record */
	hrErr = lpLLStm->lpVtbl->Read(
			lpLLStm,
			(LPVOID)&objLineRecord,
			sizeof(CONTAINERLINERECORD),
			&nRead
	);

	if (hrErr != NOERROR) {
		OleDbgAssertSz(hrErr==NOERROR, "Could not read from LineList stream");
		goto error;
	}

	lstrcpy(lpContainerLine->m_szStgName, objLineRecord.m_szStgName);
	lpContainerLine->m_fMonikerAssigned = objLineRecord.m_fMonikerAssigned;
	lpContainerLine->m_dwDrawAspect = objLineRecord.m_dwDrawAspect;
	lpContainerLine->m_sizeInHimetric = objLineRecord.m_sizeInHimetric;
	lpContainerLine->m_dwLinkType = objLineRecord.m_dwLinkType;
	lpContainerLine->m_fDoSetExtent = objLineRecord.m_fDoSetExtent;

	return (LPLINE)lpContainerLine;

error:
	// destroy partially created ContainerLine
	if (lpContainerLine)
		ContainerLine_Delete(lpContainerLine);
	return NULL;
}


/* ContainerLine_GetTextLen
 * ------------------------
 *
 * Return length of the string representation of the ContainerLine
 *  (not considering the tab level). we will use the following as the
 *  string representation of a ContainerLine:
 *      "<" + user type name of OLE object + ">"
 *  eg:
 *      <Microsoft Excel Worksheet>
 */
int ContainerLine_GetTextLen(LPCONTAINERLINE lpContainerLine)
{
	LPSTR   lpszUserType = NULL;
	HRESULT hrErr;
	int     nLen;
	BOOL    fIsLink = ContainerLine_IsOleLink(lpContainerLine);

	/* if object is not already loaded, then load it now. objects are
	**    loaded lazily in this manner.
	*/
	if (! lpContainerLine->m_lpOleObj)
		ContainerLine_LoadOleObject(lpContainerLine);

	OLEDBG_BEGIN2("IOleObject::GetUserType called\r\n")

	{
	LPOLESTR polestr;

	hrErr = lpContainerLine->m_lpOleObj->lpVtbl->GetUserType(
			lpContainerLine->m_lpOleObj,
			USERCLASSTYPE_FULL,
			&polestr
	);

	CopyAndFreeOLESTR(polestr, &lpszUserType);
	}

	OLEDBG_END2

	if (hrErr != NOERROR)   {
		// user type is NOT available
		nLen = sizeof(UNKNOWN_OLEOBJ_TYPE) + 2; // allow space for '<' + '>'
		nLen += lstrlen((LPSTR)(fIsLink ? szOLELINK : szOLEOBJECT)) + 1;
	} else {
		nLen = lstrlen(lpszUserType) + 2;   // allow space for '<' + '>'
		nLen += lstrlen((LPSTR)(fIsLink ? szOLELINK : szOLEOBJECT)) + 1;

		/* OLE2NOTE: we must free the string that was allocated by the
		**    IOleObject::GetUserType method.
		*/
		OleStdFreeString(lpszUserType, NULL);
	}

	return nLen;
}


/* ContainerLine_GetTextData
 * -------------------------
 *
 * Return the string representation of the ContainerLine
 *  (not considering the tab level). we will use the following as the
 *  string representation of a ContainerLine:
 *      "<" + user type name of OLE object + ">"
 *  eg:
 *      <Microsoft Excel Worksheet>
 */
void ContainerLine_GetTextData(LPCONTAINERLINE lpContainerLine, LPSTR lpszBuf)
{
	LPSTR   lpszUserType = NULL;
	BOOL    fIsLink = ContainerLine_IsOleLink(lpContainerLine);
	HRESULT hrErr;
	LPOLESTR polestr;

	/* if object is not already loaded, then load it now. objects are
	**    loaded lazily in this manner.
	*/
	if (! lpContainerLine->m_lpOleObj)
		ContainerLine_LoadOleObject(lpContainerLine);

	{
	LPOLESTR polestr;

	hrErr = lpContainerLine->m_lpOleObj->lpVtbl->GetUserType(
			lpContainerLine->m_lpOleObj,
			USERCLASSTYPE_FULL,
			&lpszUserType
	);

	CopyAndFree(polestr, &lpszUserType);
	}

	// Convert output to mbs
	CopyAndFree(polestr, &lpszUserType);

	if (hrErr != NOERROR)   {
		// user type is NOT available
		wsprintf(
				lpszBuf,
				"<%s %s>",
				UNKNOWN_OLEOBJ_TYPE,
				(LPSTR)(fIsLink ? szOLELINK : szOLEOBJECT)
		);
	} else {
		wsprintf(
				lpszBuf,
				"<%s %s>",
				lpszUserType,
				(LPSTR)(fIsLink ? szOLELINK : szOLEOBJECT)
		);

		/* OLE2NOTE: we must free the string that was allocated by the
		**    IOleObject::GetUserType method.
		*/
		OleStdFreeString(lpszUserType, NULL);
	}
}


/* ContainerLine_GetOutlineData
 * ----------------------------
 *
 * Return the CF_OUTLINE format data for the ContainerLine.
 */
BOOL ContainerLine_GetOutlineData(
		LPCONTAINERLINE         lpContainerLine,
		LPTEXTLINE              lpBuf
)
{
	LPLINE      lpLine = (LPLINE)lpContainerLine;
	LPLINELIST  lpLL = &((LPOUTLINEDOC)lpContainerLine->m_lpDoc)->m_LineList;
	HDC         hDC;
	char        szTmpBuf[MAXSTRLEN+1];
	LPTEXTLINE  lpTmpTextLine;

	// Create a TextLine with the Text representation of the ContainerLine.
	ContainerLine_GetTextData(lpContainerLine, (LPSTR)szTmpBuf);

	hDC = LineList_GetDC(lpLL);
	lpTmpTextLine = TextLine_Create(hDC, lpLine->m_nTabLevel, szTmpBuf);
	LineList_ReleaseDC(lpLL, hDC);

	TextLine_Copy(lpTmpTextLine, lpBuf);

	// Delete the temporary TextLine
	TextLine_Delete(lpTmpTextLine);
	return TRUE;
}


/* ContainerLine_GetPosRect
** -----------------------
**    Get the PosRect in client coordinates for the OLE object's window.
**
** OLE2NOTE: the PosRect must take into account the scroll postion of
**    the document window.
*/
void ContainerLine_GetPosRect(
		LPCONTAINERLINE     lpContainerLine,
		LPRECT              lprcPosRect
)
{
	ContainerLine_GetOleObjectRectInPixels(lpContainerLine,lprcPosRect);

	// shift rect for left margin
	lprcPosRect->left += lpContainerLine->m_nHorizScrollShift;
	lprcPosRect->right += lpContainerLine->m_nHorizScrollShift;
}


/* ContainerLine_GetOleObjectRectInPixels
** --------------------------------------
**    Get the extent of the OLE Object contained in the given Line in
**    client coordinates after scaling.
*/
void ContainerLine_GetOleObjectRectInPixels(LPCONTAINERLINE lpContainerLine, LPRECT lprc)
{
	LPOUTLINEDOC lpOutlineDoc;
	LPSCALEFACTOR lpscale;
	LPLINELIST lpLL;
	LPLINE lpLine;
	int nIndex;
	HDC hdcLL;

	if (!lpContainerLine || !lprc)
		return;

	lpOutlineDoc = (LPOUTLINEDOC)lpContainerLine->m_lpDoc;
	lpscale = OutlineDoc_GetScaleFactor(lpOutlineDoc);
	lpLL = OutlineDoc_GetLineList(lpOutlineDoc);
	lpLine = (LPLINE)lpContainerLine;
	nIndex = LineList_GetLineIndex(lpLL, lpLine);

	LineList_GetLineRect(lpLL, nIndex, lprc);

	hdcLL = GetDC(lpLL->m_hWndListBox);

	/* lprc is set to be size of Line Object (including the boundary) */
	lprc->left += (int)(
			(long)XformWidthInHimetricToPixels(hdcLL,
					lpLine->m_nTabWidthInHimetric +
					LOWORD(OutlineDoc_GetMargin(lpOutlineDoc))) *
			lpscale->dwSxN / lpscale->dwSxD);
	lprc->right = (int)(
			lprc->left + (long)
			XformWidthInHimetricToPixels(hdcLL, lpLine->m_nWidthInHimetric) *
			lpscale->dwSxN / lpscale->dwSxD);

	ReleaseDC(lpLL->m_hWndListBox, hdcLL);
}


/* ContainerLine_GetOleObjectSizeInHimetric
** ----------------------------------------
**    Get the size of the OLE Object contained in the given Line
*/
void ContainerLine_GetOleObjectSizeInHimetric(LPCONTAINERLINE lpContainerLine, LPSIZEL lpsizel)
{
	if (!lpContainerLine || !lpsizel)
		return;

	*lpsizel = lpContainerLine->m_sizeInHimetric;
}


/* ContainerLine_BindLinkIfLinkSrcIsRunning
** ----------------------------------------
**    Try to connect the OLE link object associated with the
**    ContainerLine with its LinkSource if the LinkSource is already
**    running and the link is an automatic link. we do not want to
**    force the LinkSource to run.
**
**    OLE2NOTE: a sophistocated container will want to continually
**    attempt to connect its automatic links. OLE does NOT
**    automatically connect links when link source become available. some
**    containers will want to attempt to connect its links as part of
**    idle time processing. another strategy is to attempt to connect
**    an automatic link every time it is drawn on the screen. (this is
**    the strategy used by this CntrOutl sample application.)
*/
void ContainerLine_BindLinkIfLinkSrcIsRunning(LPCONTAINERLINE lpContainerLine)
{
	LPOLEAPP lpOleApp = (LPOLEAPP)g_lpApp;
	HRESULT hrErr;
	BOOL fPrevEnable1;
	BOOL fPrevEnable2;

	// if the link source is known to be un-bindable, then don't even try
	if (lpContainerLine->m_fLinkUnavailable)
		return;

	/* OLE2NOTE: we do not want to ever give the Busy/NotResponding
	**    dialogs when we are attempting to BindIfRunning to the link
	**    source. if the link source is currently busy, this could
	**    cause the Busy dialog to come up. even if the link source is
	**    busy, we do not want put up the busy dialog. thus we will
	**    disable the dialog and later re-enable them
	*/
	OleApp_DisableBusyDialogs(lpOleApp, &fPrevEnable1, &fPrevEnable2);

	OLEDBG_BEGIN2("IOleLink::BindIfRunning called\r\n")
	hrErr = lpContainerLine->m_lpOleLink->lpVtbl->BindIfRunning(
			lpContainerLine->m_lpOleLink);
	OLEDBG_END2

	// re-enable the Busy/NotResponding dialogs
	OleApp_EnableBusyDialogs(lpOleApp, fPrevEnable1, fPrevEnable2);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\letest\outline\cntrbase.c ===
/*************************************************************************
**
**    OLE 2 Container Sample Code
**
**    cntrbase.c
**
**    This file contains all interfaces, methods and related support
**    functions for the basic OLE Container application. The
**    basic OLE Container application supports being a container for
**    embedded and linked objects.
**    The basic Container application includes the following
**    implementation objects:
**
**    ContainerDoc Object
**      no required interfaces for basic functionality
**      (see linking.c for linking related support)
**      (see clipbrd.c for clipboard related support)
**      (see dragdrop.c for drag/drop related support)
**
**    ContainerLine Object
**    (see cntrline.c for all ContainerLine functions and interfaces)
**      exposed interfaces:
**          IOleClientSite
**          IAdviseSink
**
**    (c) Copyright Microsoft Corp. 1992 - 1993 All Rights Reserved
**
*************************************************************************/

#include "outline.h"
#include <olethunk.h>


OLEDBGDATA


extern LPOUTLINEAPP             g_lpApp;
extern IOleUILinkContainerVtbl  g_CntrDoc_OleUILinkContainerVtbl;

#if defined( INPLACE_CNTR )
extern BOOL g_fInsideOutContainer;
#endif  // INPLACE_CNTR

// REVIEW: should use string resource for messages
char ErrMsgShowObj[] = "Could not show object server!";
char ErrMsgInsertObj[] = "Insert Object failed!";
char ErrMsgConvertObj[] = "Convert Object failed!";
char ErrMsgCantConvert[] = "Unable to convert the selection!";
char ErrMsgActivateAsObj[] = "Activate As Object failed!";

extern char ErrMsgSaving[];
extern char ErrMsgOpening[];


/* ContainerDoc_Init
 * -----------------
 *
 *  Initialize the fields of a new ContainerDoc object. The doc is initially
 *  not associated with a file or an (Untitled) document. This function sets
 *  the docInitType to DOCTYPE_UNKNOWN. After calling this function the
 *  caller should call:
 *      1.) Doc_InitNewFile to set the ContainerDoc to (Untitled)
 *      2.) Doc_LoadFromFile to associate the ContainerDoc with a file.
 *  This function creates a new window for the document.
 *
 *  NOTE: the window is initially created with a NIL size. it must be
 *        sized and positioned by the caller. also the document is initially
 *        created invisible. the caller must call Doc_ShowWindow
 *        after sizing it to make the document window visible.
 */
BOOL ContainerDoc_Init(LPCONTAINERDOC lpContainerDoc, BOOL fDataTransferDoc)
{
	LPCONTAINERAPP lpContainerApp = (LPCONTAINERAPP)g_lpApp;
	LPOUTLINEDOC lpOutlineDoc = (LPOUTLINEDOC)lpContainerDoc;

	lpOutlineDoc->m_cfSaveFormat             = lpContainerApp->m_cfCntrOutl;
	lpContainerDoc->m_nNextObjNo            = 0L;
	lpContainerDoc->m_lpNewStg              = NULL;
	lpContainerDoc->m_fEmbeddedObjectAvail  = FALSE;
	lpContainerDoc->m_clsidOleObjCopied     = CLSID_NULL;
	lpContainerDoc->m_dwAspectOleObjCopied  = DVASPECT_CONTENT;
	lpContainerDoc->m_lpSrcContainerLine    = NULL;
	lpContainerDoc->m_fShowObject           = TRUE;

#if defined( INPLACE_CNTR )
	lpContainerDoc->m_lpLastIpActiveLine    = NULL;
	lpContainerDoc->m_lpLastUIActiveLine    = NULL;
	lpContainerDoc->m_hWndUIActiveObj       = NULL;
	lpContainerDoc->m_fAddMyUI              = TRUE; // UI needs to be added
	lpContainerDoc->m_cIPActiveObjects      = 0;
	lpContainerApp->m_fMenuHelpMode         = FALSE; // F1 pressed in menu

#if defined( INPLACE_CNTRSVR )
	lpContainerDoc->m_lpTopIPFrame          =
					(LPOLEINPLACEUIWINDOW)&lpContainerDoc->m_OleInPlaceFrame;
	lpContainerDoc->m_lpTopIPDoc            =
					(LPOLEINPLACEUIWINDOW)&lpContainerDoc->m_OleInPlaceDoc;
	lpContainerDoc->m_hSharedMenu           = NULL;
	lpContainerDoc->m_hOleMenu              = NULL;

#endif  // INPLACE_CNTRSVR
#endif  // INPLACE_CNTR

	INIT_INTERFACEIMPL(
			&lpContainerDoc->m_OleUILinkContainer,
			&g_CntrDoc_OleUILinkContainerVtbl,
			lpContainerDoc
	);

	return TRUE;
}


/* ContainerDoc_GetNextLink
 * ------------------------
 *
 *  Update all links in the document. A dialog box will be popped up showing
 *  the progress of the update and allow the user to quit by pushing the
 *  stop button
 */
LPCONTAINERLINE ContainerDoc_GetNextLink(
		LPCONTAINERDOC lpContainerDoc,
		LPCONTAINERLINE lpContainerLine
)
{
	LPLINELIST lpLL = &((LPOUTLINEDOC)lpContainerDoc)->m_LineList;
	DWORD dwNextLink = 0;
	LPLINE lpLine;
	static int nIndex = 0;

	if (lpContainerLine==NULL)
		nIndex = 0;

	for ( ; nIndex < lpLL->m_nNumLines; nIndex++) {
		lpLine = LineList_GetLine(lpLL, nIndex);

		if (lpLine
			&& (Line_GetLineType(lpLine) == CONTAINERLINETYPE)
			&& ContainerLine_IsOleLink((LPCONTAINERLINE)lpLine)) {

			nIndex++;
			ContainerLine_LoadOleObject((LPCONTAINERLINE)lpLine);
			return (LPCONTAINERLINE)lpLine;
		}
	}

	return NULL;
}



/* ContainerDoc_UpdateLinks
 * ------------------------
 *
 *  Update all links in the document. A dialog box will be popped up showing
 *  the progress of the update and allow the user to quit by pushing the
 *  stop button
 */
void ContainerDoc_UpdateLinks(LPCONTAINERDOC lpContainerDoc)
{
	int             cLinks;
	BOOL            fAllLinksUpToDate = TRUE;
	HWND            hwndDoc = ((LPOUTLINEDOC)lpContainerDoc)->m_hWndDoc;
	HCURSOR         hCursor;
	LPCONTAINERLINE lpContainerLine = NULL;
	HRESULT         hrErr;
	DWORD           dwUpdateOpt;
	LPOLEAPP        lpOleApp = (LPOLEAPP)g_lpApp;
	BOOL            fPrevEnable1;
	BOOL            fPrevEnable2;

	hCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));

	/* OLE2NOTE: we do not want to ever give the Busy/NotResponding
	**    dialogs when we are updating automatic links as part of
	**    opening a document.  even if the link source of data is busy,
	**    we do not want put up the busy dialog. thus we will disable
	**    the dialog and later re-enable them
	*/
	OleApp_DisableBusyDialogs(lpOleApp, &fPrevEnable1, &fPrevEnable2);

	/* get total number of automatic links */
	cLinks = 0;
	while (lpContainerLine = ContainerDoc_GetNextLink(
									lpContainerDoc,
									lpContainerLine)) {
		hrErr = CntrDoc_LinkCont_GetLinkUpdateOptions(
				(LPOLEUILINKCONTAINER)&lpContainerDoc->m_OleUILinkContainer,
				(DWORD)lpContainerLine,
				(LPDWORD)&dwUpdateOpt
		);
		if (hrErr == NOERROR) {
			if (dwUpdateOpt==OLEUPDATE_ALWAYS) {
				cLinks++;
				if (fAllLinksUpToDate) {
					OLEDBG_BEGIN2("IOleObject::IsUpToDate called\r\n")
					hrErr = lpContainerLine->m_lpOleObj->lpVtbl->IsUpToDate(
							lpContainerLine->m_lpOleObj);
					OLEDBG_END2
					if (hrErr != NOERROR)
						fAllLinksUpToDate = FALSE;
				}
			}
		}
#if defined( _DEBUG )
		else
			OleDbgOutHResult("IOleUILinkContainer::GetLinkUpdateOptions returned",hrErr);
#endif

	}

	if (fAllLinksUpToDate)
		goto done; // don't bother user if all links are up-to-date

	SetCursor(hCursor);

	if ((cLinks > 0) && !OleUIUpdateLinks(
			(LPOLEUILINKCONTAINER)&lpContainerDoc->m_OleUILinkContainer,
			hwndDoc,
			(LPSTR)APPNAME,
			cLinks)) {
		if (ID_PU_LINKS == OleUIPromptUser(
				(WORD)IDD_CANNOTUPDATELINK,
				hwndDoc,
				(LPSTR)APPNAME)) {
			ContainerDoc_EditLinksCommand(lpContainerDoc);
		}
	}

done:
	// re-enable the Busy/NotResponding dialogs
	OleApp_EnableBusyDialogs(lpOleApp, fPrevEnable1, fPrevEnable2);
}



/* ContainerDoc_SetShowObjectFlag
 * ------------------------------
 *
 *  Set/Clear the ShowObject flag of ContainerDoc
 */
void ContainerDoc_SetShowObjectFlag(LPCONTAINERDOC lpContainerDoc, BOOL fShow)
{
	if (!lpContainerDoc)
		return;

	lpContainerDoc->m_fShowObject = fShow;
}


/* ContainerDoc_GetShowObjectFlag
 * ------------------------------
 *
 *  Get the ShowObject flag of ContainerDoc
 */
BOOL ContainerDoc_GetShowObjectFlag(LPCONTAINERDOC lpContainerDoc)
{
	if (!lpContainerDoc)
		return FALSE;

	return lpContainerDoc->m_fShowObject;
}


/* ContainerDoc_InsertOleObjectCommand
 * -----------------------------------
 *
 * Insert a new OLE object in the ContainerDoc.
 */
void ContainerDoc_InsertOleObjectCommand(LPCONTAINERDOC lpContainerDoc)
{
	LPLINELIST              lpLL =&((LPOUTLINEDOC)lpContainerDoc)->m_LineList;
	LPLINE                  lpLine = NULL;
	HDC                     hDC;
	int                     nTab = 0;
	int                     nIndex = LineList_GetFocusLineIndex(lpLL);
	LPCONTAINERLINE         lpContainerLine=NULL;
	char                    szStgName[CWCSTORAGENAME];
	UINT                    uRet;
	OLEUIINSERTOBJECT       io;
	char                    szFile[OLEUI_CCHPATHMAX];
	DWORD                   dwOleCreateType;
	BOOL                    fDisplayAsIcon;
	HCURSOR                 hPrevCursor;

	_fmemset((LPOLEUIINSERTOBJECT)&io, 0, sizeof(io));
	io.cbStruct=sizeof(io);
	io.dwFlags=IOF_SELECTCREATENEW | IOF_SHOWHELP;
	io.hWndOwner=((LPOUTLINEDOC)lpContainerDoc)->m_hWndDoc;
	io.lpszFile=(LPSTR)szFile;
	io.cchFile=sizeof(szFile);
	_fmemset((LPSTR)szFile, 0, OLEUI_CCHPATHMAX);

#if defined( OLE_VERSION )
	OleApp_PreModalDialog((LPOLEAPP)g_lpApp, (LPOLEDOC)lpContainerDoc);
#endif

	OLEDBG_BEGIN3("OleUIInsertObject called\r\n")
	uRet=OleUIInsertObject((LPOLEUIINSERTOBJECT)&io);
	OLEDBG_END3

#if defined( OLE_VERSION )
	OleApp_PostModalDialog((LPOLEAPP)g_lpApp, (LPOLEDOC)lpContainerDoc);
#endif

	if (OLEUI_OK != uRet)
		return;     // user canceled dialog

	// this may take a while, put up hourglass cursor
	hPrevCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));

	fDisplayAsIcon = (io.dwFlags & IOF_CHECKDISPLAYASICON ? TRUE : FALSE);

	// make up a storage name for the OLE object
	ContainerDoc_GetNextStgName(lpContainerDoc, szStgName, sizeof(szStgName));

	/* default the new line to have the same indent as previous line */
	lpLine = LineList_GetLine(lpLL, nIndex);
	if (lpLine)
		nTab = Line_GetTabLevel(lpLine);

	hDC = LineList_GetDC(lpLL);

	if ((io.dwFlags & IOF_SELECTCREATENEW))
		dwOleCreateType = IOF_SELECTCREATENEW;
	else if ((io.dwFlags & IOF_CHECKLINK))
		dwOleCreateType = IOF_CHECKLINK;
	else
		dwOleCreateType = IOF_SELECTCREATEFROMFILE;

	lpContainerLine = ContainerLine_Create(
			dwOleCreateType,
			hDC,
			nTab,
			lpContainerDoc,
			&io.clsid,
			(LPSTR)szFile,
			fDisplayAsIcon,
			io.hMetaPict,
			szStgName
	);

	if (!lpContainerLine)
		goto error;         // creation of OLE object FAILED

	if (io.hMetaPict) {
		OleUIMetafilePictIconFree(io.hMetaPict);    // clean up metafile
	}

	/* add a ContainerLine object to the document's LineList. The
	**    ContainerLine manages the rectangle on the screen occupied by
	**    the OLE object.
	*/

	LineList_AddLine(lpLL, (LPLINE)lpContainerLine, nIndex);

	/* before calling DoVerb(OLEIVERB_SHOW), check to see if the object
	**    has any initial extents.
	*/
	ContainerLine_UpdateExtent(lpContainerLine, NULL);

	/* If a new embedded object was created, tell the object server to
	**    make itself visible (show itself).
	**    OLE2NOTE: the standard OLE 2 User Model is to only call
	**    IOleObject::DoVerb(OLEIVERB_SHOW...) if a new object is
	**    created. specifically, it should NOT be calld if the object
	**    is created from file or link to file.
	*/
	if (dwOleCreateType == IOF_SELECTCREATENEW) {
		if (! ContainerLine_DoVerb(
				lpContainerLine, OLEIVERB_SHOW, NULL, TRUE, TRUE)) {
			OutlineApp_ErrorMessage(g_lpApp, ErrMsgShowObj);
		}

		/* OLE2NOTE: we will immediately force a save of the object
		**    to guarantee that a valid initial object is saved
		**    with our document. if the object is a OLE 1.0 object,
		**    then it may exit without update. by forcing this
		**    initial save we consistently always have a valid
		**    object even if it is a OLE 1.0 object that exited
		**    without saving. if we did NOT do this save here, then
		**    we would have to worry about deleting the object if
		**    it was a OLE 1.0 object that closed without saving.
		**    the OLE 2.0 User Model dictates that the object
		**    should always be valid after CreateNew performed. the
		**    user must explicitly delete it.
		*/
		ContainerLine_SaveOleObjectToStg(
				lpContainerLine,
				lpContainerLine->m_lpStg,
				lpContainerLine->m_lpStg,
				TRUE    /* fRemember */
		);
	}
#if defined( INPLACE_CNTR )
	else if (dwOleCreateType == IOF_SELECTCREATEFROMFILE) {
		/* OLE2NOTE: an inside-out container should check if the object
		**    created from file is an inside-out and prefers to be
		**    activated when visible type of object. if so, the object
		**    should be immediately activated in-place, BUT NOT UIActived.
		*/
		if (g_fInsideOutContainer &&
				lpContainerLine->m_dwDrawAspect == DVASPECT_CONTENT &&
				lpContainerLine->m_fInsideOutObj ) {
			HWND hWndDoc = OutlineDoc_GetWindow((LPOUTLINEDOC)lpContainerDoc);

			ContainerLine_DoVerb(
				   lpContainerLine,OLEIVERB_INPLACEACTIVATE,NULL,FALSE,FALSE);

			/* OLE2NOTE: following this DoVerb(INPLACEACTIVATE) the
			**    object may have taken focus. but because the
			**    object is NOT UIActive it should NOT have focus.
			**    we will make sure our document has focus.
			*/
			SetFocus(hWndDoc);
		}
	}
#endif  // INPLACE_CNTR

	OutlineDoc_SetModified((LPOUTLINEDOC)lpContainerDoc, TRUE, TRUE, TRUE);

	LineList_ReleaseDC(lpLL, hDC);

	SetCursor(hPrevCursor);     // restore original cursor

	return;

error:
	// NOTE: if ContainerLine_Create failed
	LineList_ReleaseDC(lpLL, hDC);

	if (OLEUI_OK == uRet && io.hMetaPict)
		OleUIMetafilePictIconFree(io.hMetaPict);    // clean up metafile

	SetCursor(hPrevCursor);     // restore original cursor
	OutlineApp_ErrorMessage(g_lpApp, ErrMsgInsertObj);
}



void ContainerDoc_EditLinksCommand(LPCONTAINERDOC lpContainerDoc)
{
	UINT        uRet;
	OLEUIEDITLINKS      el;
	LPCONTAINERLINE lpContainerLine = NULL;
	LPLINELIST lpLL = &((LPOUTLINEDOC)lpContainerDoc)->m_LineList;

	_fmemset((LPOLEUIEDITLINKS)&el,0,sizeof(el));
	el.cbStruct=sizeof(el);
	el.dwFlags=ELF_SHOWHELP;
	el.hWndOwner=((LPOUTLINEDOC)lpContainerDoc)->m_hWndDoc;
	el.lpOleUILinkContainer =
			(LPOLEUILINKCONTAINER)&lpContainerDoc->m_OleUILinkContainer;

#if defined( OLE_VERSION )
	OleApp_PreModalDialog((LPOLEAPP)g_lpApp, (LPOLEDOC)lpContainerDoc);
#endif

	OLEDBG_BEGIN3("OleUIEditLinks called\r\n")
	uRet=OleUIEditLinks((LPOLEUIEDITLINKS)&el);
	OLEDBG_END3

#if defined( OLE_VERSION )
	OleApp_PostModalDialog((LPOLEAPP)g_lpApp, (LPOLEDOC)lpContainerDoc);
#endif

	OleDbgAssert((uRet==1) || (uRet==OLEUI_CANCEL));

}


/* Convert command - brings up the "Convert" dialog
 */
void ContainerDoc_ConvertCommand(
		LPCONTAINERDOC      lpContainerDoc,
		BOOL                fServerNotRegistered
)
{
	LPOUTLINEDOC lpOutlineDoc = (LPOUTLINEDOC)lpContainerDoc;
	OLEUICONVERT ct;
	UINT         uRet;
	LPDATAOBJECT  lpDataObj;
	LPLINELIST lpLL = &((LPOUTLINEDOC)lpContainerDoc)->m_LineList;
	LPCONTAINERLINE lpContainerLine = NULL;
	BOOL         fSelIsOleObject;
	int          nIndex;
	STGMEDIUM    medium;
	LPSTR        lpErrMsg = NULL;
	HRESULT      hrErr;
	HCURSOR      hPrevCursor;
	BOOL         fMustRun = FALSE;
	BOOL         fMustClose = FALSE;
	BOOL         fObjConverted = FALSE;
	BOOL         fDisplayChanged = FALSE;
	BOOL         fHaveCLSID = FALSE;
	BOOL         fHaveFmtUserType = FALSE;
	char         szUserType[128];
	BOOL         fMustActivate;

	/* OLE2NOTE: if we came to the Convert dialog because the user
	**    activated a non-registered object, then we should activate
	**    the object after the user has converted it or setup an
	**    ActivateAs server.
	*/
	fMustActivate = fServerNotRegistered;

	_fmemset((LPOLEUICONVERT)&ct,0,sizeof(ct));

	fSelIsOleObject = ContainerDoc_IsSelAnOleObject(
			(LPCONTAINERDOC)lpContainerDoc,
			&IID_IDataObject,
			(LPUNKNOWN FAR*)&lpDataObj,
			&nIndex,
			(LPCONTAINERLINE FAR*)&lpContainerLine
	);

	lpErrMsg = ErrMsgCantConvert;

	if (! fSelIsOleObject)
		goto error;     // can NOT do Convert.

	if (! lpContainerLine) {
		OleStdRelease((LPUNKNOWN)lpDataObj);
		goto error;     // can NOT do Convert.
	}

	ct.cbStruct  = sizeof(OLEUICONVERT);
	ct.dwFlags   = CF_SHOWHELPBUTTON;
	ct.hWndOwner = lpContainerDoc->m_OleDoc.m_OutlineDoc.m_hWndDoc;
	ct.lpszCaption = (LPSTR)NULL;
	ct.lpfnHook  = NULL;
	ct.lCustData = 0;
	ct.hInstance = NULL;
	ct.lpszTemplate = NULL;
	ct.hResource = 0;
	ct.fIsLinkedObject = ContainerLine_IsOleLink(lpContainerLine);
	ct.dvAspect = lpContainerLine->m_dwDrawAspect;
	ct.cClsidExclude = 0;
	ct.lpClsidExclude = NULL;

	if (! ct.fIsLinkedObject || !lpContainerLine->m_lpOleLink) {
		/* OLE2NOTE: the object is an embedded object. we should first
		**    attempt to read the actual object CLSID, file data
		**    format, and full user type name that is written inside of
		**    the object's storage as this should be the most
		**    definitive information. if this fails we will ask the
		**    object what its class is and attempt to get the rest of
		**    the information out of the REGDB.
		*/
		hrErr=ReadClassStg(lpContainerLine->m_lpStg,(CLSID FAR*)&(ct.clsid));
		if (hrErr == NOERROR)
			fHaveCLSID = TRUE;
		else {
			OleDbgOutHResult("ReadClassStg returned", hrErr);
		}

		hrErr = ReadFmtUserTypeStgA(
				lpContainerLine->m_lpStg,
				(CLIPFORMAT FAR*)&ct.wFormat,
				&ct.lpszUserType);

		if (hrErr == NOERROR)
			fHaveFmtUserType = TRUE;
		else {
			OleDbgOutHResult("ReadFmtUserTypeStg returned", hrErr);
		}
	} else {
		/* OLE2NOTE: the object is a linked object. we should give the
		**    DisplayName of the link source as the default icon label.
		*/
		OLEDBG_BEGIN2("IOleLink::GetSourceDisplayName called\r\n")

		hrErr = CallIOleLinkGetSourceDisplayNameA(
				lpContainerLine->m_lpOleLink, &ct.lpszDefLabel);

		OLEDBG_END2
	}

	if (! fHaveCLSID) {
		hrErr = lpContainerLine->m_lpOleObj->lpVtbl->GetUserClassID(
				lpContainerLine->m_lpOleObj,
				(CLSID FAR*)&ct.clsid
		);
		if (hrErr != NOERROR)
			ct.clsid = CLSID_NULL;
	}
	if (! fHaveFmtUserType) {
		ct.wFormat = 0;
		if (OleStdGetUserTypeOfClass(
				(CLSID FAR*)&ct.clsid,szUserType,sizeof(szUserType),NULL)) {
			ct.lpszUserType = OleStdCopyString(szUserType, NULL);
		} else {
			ct.lpszUserType = NULL;
		}
	}

	if (lpContainerLine->m_dwDrawAspect == DVASPECT_ICON) {
		ct.hMetaPict = OleStdGetData(
				lpDataObj,
				CF_METAFILEPICT,
				NULL,
				DVASPECT_ICON,
				(LPSTGMEDIUM)&medium
		);
	} else {
		ct.hMetaPict = NULL;
	}
	OleStdRelease((LPUNKNOWN)lpDataObj);

#if defined( OLE_VERSION )
	OleApp_PreModalDialog((LPOLEAPP)g_lpApp, (LPOLEDOC)lpContainerDoc);
#endif

	OLEDBG_BEGIN3("OleUIConvert called\r\n")
	uRet = OleUIConvert(&ct);
	OLEDBG_END3

#if defined( OLE_VERSION )
	OleApp_PostModalDialog((LPOLEAPP)g_lpApp, (LPOLEDOC)lpContainerDoc);
#endif

	// this may take a while, put up hourglass cursor
	hPrevCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));

	if (uRet == OLEUI_OK) {

		/*****************************************************************
		**  OLE2NOTE: the convert dialog actually allows the user to
		**    change two orthogonal properties of the object: the
		**    object's type/server and the object's display aspect.
		**    first we will execute the ConvertTo/ActivateAs action and
		**    then we will deal with any display aspect change. we want
		**    to be careful to only call IOleObject::Update once
		**    because this is an expensive operation; it results in
		**    launching the object's server.
		*****************************************************************/

		if (ct.dwFlags & CF_SELECTCONVERTTO &&
				! IsEqualCLSID(&ct.clsid, &ct.clsidNew)) {

			/* user selected CONVERT.
			**
			** OLE2NOTE: to achieve the "Convert To" at this point we
			**    need to take the following steps:
			**    1. unload the object.
			**    2. write the NEW CLSID and NEW user type name
			**       string into the storage of the object,
			**       BUT write the OLD format tag.
			**    3. force an update to force the actual conversion of
			**       the data bits.
			*/
			lpErrMsg = ErrMsgConvertObj; // setup correct msg in case of error

			ContainerLine_UnloadOleObject(lpContainerLine, OLECLOSE_SAVEIFDIRTY);

			OLEDBG_BEGIN2("OleStdDoConvert called \r\n")
			hrErr = OleStdDoConvert(
					lpContainerLine->m_lpStg, (REFCLSID)&ct.clsidNew);
			OLEDBG_END2
			if (hrErr != NOERROR)
				goto error;

			// Reload the object
			ContainerLine_LoadOleObject(lpContainerLine);

			/* we need to force the object to run to complete the
			**    conversion. set flag to force OleRun to be called at
			**    end of function.
			*/
			fMustRun = TRUE;
			fObjConverted = TRUE;

		} else if (ct.dwFlags & CF_SELECTACTIVATEAS) {
			/* user selected ACTIVATE AS.
			**
			** OLE2NOTE: to achieve the "Activate As" at this point we
			**    need to take the following steps:
			**    1. unload ALL objects of the OLD class that app knows about
			**    2. add the TreatAs tag in the registration database
			**    by calling CoTreatAsClass().
			**    3. lazily it can reload the objects; when the objects
			**    are reloaded the TreatAs will take effect.
			*/
			lpErrMsg = ErrMsgActivateAsObj; // setup msg in case of error

			ContainerDoc_UnloadAllOleObjectsOfClass(
					lpContainerDoc,
					(REFCLSID)&ct.clsid,
					OLECLOSE_SAVEIFDIRTY
			);

			OLEDBG_BEGIN2("OleStdDoTreatAsClass called \r\n")
			hrErr = OleStdDoTreatAsClass(ct.lpszUserType, (REFCLSID)&ct.clsid,
					(REFCLSID)&ct.clsidNew);
			OLEDBG_END2

			// Reload the object
			ContainerLine_LoadOleObject(lpContainerLine);

			fMustActivate = TRUE;   // we should activate this object
		}

		/*****************************************************************
		**  OLE2NOTE: now we will try to change the display if
		**    necessary.
		*****************************************************************/

		if (lpContainerLine->m_lpOleObj &&
				ct.dvAspect != lpContainerLine->m_dwDrawAspect) {
			/* user has selected to change display aspect between icon
			**    aspect and content aspect.
			**
			** OLE2NOTE: if we got here because the server was not
			**    registered, then we will NOT delete the object's
			**    original display aspect. because we do not have the
			**    original server, we can NEVER get it back. this is a
			**    safety precaution.
			*/

			hrErr = OleStdSwitchDisplayAspect(
					lpContainerLine->m_lpOleObj,
					&lpContainerLine->m_dwDrawAspect,
					ct.dvAspect,
					ct.hMetaPict,
					!fServerNotRegistered,   /* fDeleteOldAspect */
					TRUE,                    /* fSetupViewAdvise */
					(LPADVISESINK)&lpContainerLine->m_AdviseSink,
					(BOOL FAR*)&fMustRun
			);

			if (hrErr == NOERROR)
				fDisplayChanged = TRUE;

#if defined( INPLACE_CNTR )
				ContainerDoc_UpdateInPlaceObjectRects(
						lpContainerLine->m_lpDoc, nIndex);
#endif

		} else if (ct.dvAspect == DVASPECT_ICON && ct.fObjectsIconChanged) {
			hrErr = OleStdSetIconInCache(
					lpContainerLine->m_lpOleObj,
					ct.hMetaPict
			);

			if (hrErr == NOERROR)
				fDisplayChanged = TRUE;
		}

		/* we deliberately run the object so that the update won't shut
		** the server down.
		*/
		if (fMustActivate || fMustRun) {

			/* if we force the object to run, then shut it down after
			**    the update. do NOT force the object to close if we
			**    want to activate the object or if the object was
			**    already running.
			*/
			if (!fMustActivate && !OleIsRunning(lpContainerLine->m_lpOleObj))
				fMustClose = TRUE;  // shutdown after update

			hrErr = ContainerLine_RunOleObject(lpContainerLine);

			if (fObjConverted &&
				FAILED(hrErr) && GetScode(hrErr)!=OLE_E_STATIC) {

				// ERROR: convert of the object failed.
				// revert the storage to restore the original link.
				// (OLE2NOTE: static object always return OLE_E_STATIC
				//        when told to run; this is NOT an error here.
				//        the OLE2 libraries have built in handlers for
				//        the static objects that do the conversion.
				ContainerLine_UnloadOleObject(
						lpContainerLine, OLECLOSE_NOSAVE);
				lpContainerLine->m_lpStg->lpVtbl->Revert(
						lpContainerLine->m_lpStg);
				goto error;

			} else if (fObjConverted) {
				FORMATETC  FmtEtc;
				DWORD      dwNewConnection;
				LPOLECACHE lpOleCache = (LPOLECACHE)OleStdQueryInterface
					  ((LPUNKNOWN)lpContainerLine->m_lpOleObj,&IID_IOleCache);

				/* OLE2NOTE: we need to force the converted object to
				**    setup a new OLERENDER_DRAW cache. it is possible
				**    that the new object needs to cache different data
				**    in order to support drawing than the old object.
				*/
				if (lpOleCache &&
						lpContainerLine->m_dwDrawAspect == DVASPECT_CONTENT) {
					FmtEtc.cfFormat = 0; // whatever is needed for Draw
					FmtEtc.ptd      = NULL;
					FmtEtc.dwAspect = DVASPECT_CONTENT;
					FmtEtc.lindex   = -1;
					FmtEtc.tymed    = TYMED_NULL;

					OLEDBG_BEGIN2("IOleCache::Cache called\r\n")
					hrErr = lpOleCache->lpVtbl->Cache(
							lpOleCache,
							(LPFORMATETC)&FmtEtc,
							ADVF_PRIMEFIRST,
							(LPDWORD)&dwNewConnection
					);
					OLEDBG_END2
#if defined( _DEBUG )
					if (! SUCCEEDED(hrErr))
						OleDbgOutHResult("IOleCache::Cache returned", hrErr);
#endif
					OleStdRelease((LPUNKNOWN)lpOleCache);
				}

				// Close and force object to save; this will commit the stg
				ContainerLine_CloseOleObject(
					lpContainerLine, OLECLOSE_SAVEIFDIRTY);
				fMustClose = FALSE;     // we already closed the object
			}
			if (fMustClose)
				ContainerLine_CloseOleObject(lpContainerLine,OLECLOSE_NOSAVE);
		}

		if (fDisplayChanged) {
			/* the Object's display was changed, force a repaint of
			**    the line. note the extents of the object may have
			**    changed.
			*/
			ContainerLine_UpdateExtent(lpContainerLine, NULL);
			LineList_ForceLineRedraw(lpLL, nIndex, TRUE);
		}

		if (fDisplayChanged || fObjConverted) {
			/* mark ContainerDoc as now dirty. if display changed, then
			**    the extents of the object may have changed.
			*/
			OutlineDoc_SetModified(lpOutlineDoc, TRUE, TRUE, fDisplayChanged);
		}

		if (fMustActivate) {
			ContainerLine_DoVerb(
					lpContainerLine, OLEIVERB_PRIMARY, NULL, FALSE,FALSE);
		}
	}


	if (ct.lpszUserType)
		OleStdFreeString(ct.lpszUserType, NULL);

	if (ct.lpszDefLabel)
		OleStdFreeString(ct.lpszDefLabel, NULL);

	if (ct.hMetaPict)
		OleUIMetafilePictIconFree(ct.hMetaPict);    // clean up metafile

	SetCursor(hPrevCursor);     // restore original cursor

	return;

error:
	if (ct.lpszUserType)
		OleStdFreeString(ct.lpszUserType, NULL);

	if (ct.hMetaPict)
		OleUIMetafilePictIconFree(ct.hMetaPict);    // clean up metafile

	SetCursor(hPrevCursor);     // restore original cursor
	if (lpErrMsg)
		OutlineApp_ErrorMessage(g_lpApp, lpErrMsg);

}


/* ContainerDoc_CloseAllOleObjects
** -------------------------------
**    Close all OLE objects. This forces all OLE objects to transition
**    from the running state to the loaded state.
**
**    Returns TRUE if all objects closed successfully
**            FALSE if any object could not be closed.
*/
BOOL ContainerDoc_CloseAllOleObjects(
		LPCONTAINERDOC          lpContainerDoc,
		DWORD                   dwSaveOption
)
{
	LPLINELIST  lpLL = &((LPOUTLINEDOC)lpContainerDoc)->m_LineList;
	int         i;
	LPLINE      lpLine;
	BOOL        fStatus = TRUE;

	for (i = 0; i < lpLL->m_nNumLines; i++) {
		lpLine=LineList_GetLine(lpLL, i);

		if (lpLine && (Line_GetLineType(lpLine)==CONTAINERLINETYPE))
			if (! ContainerLine_CloseOleObject(
										(LPCONTAINERLINE)lpLine,dwSaveOption))
				fStatus = FALSE;
	}

	return fStatus;
}


/* ContainerDoc_UnloadAllOleObjectsOfClass
** ---------------------------------------
**    Unload all OLE objects of a particular class. this is necessary
**    when a class level "ActivateAs" (aka. TreatAs) is setup. the user
**    can do this with the Convert dialog. for the TreatAs to take
**    effect, all objects of the class have to loaded and reloaded.
*/
void ContainerDoc_UnloadAllOleObjectsOfClass(
		LPCONTAINERDOC      lpContainerDoc,
		REFCLSID            rClsid,
		DWORD               dwSaveOption
)
{
	LPLINELIST  lpLL = &((LPOUTLINEDOC)lpContainerDoc)->m_LineList;
	int         i;
	LPLINE      lpLine;
	CLSID       clsid;
	HRESULT     hrErr;

	for (i = 0; i < lpLL->m_nNumLines; i++) {
		lpLine=LineList_GetLine(lpLL, i);

		if (lpLine && (Line_GetLineType(lpLine)==CONTAINERLINETYPE)) {
			LPCONTAINERLINE lpContainerLine = (LPCONTAINERLINE)lpLine;

			if (! lpContainerLine->m_lpOleObj)
				continue;       // this object is NOT loaded

			hrErr = lpContainerLine->m_lpOleObj->lpVtbl->GetUserClassID(
					lpContainerLine->m_lpOleObj,
					(CLSID FAR*)&clsid
			);
			if (hrErr == NOERROR &&
					( IsEqualCLSID((CLSID FAR*)&clsid,rClsid)
					  || IsEqualCLSID(rClsid,&CLSID_NULL) ) ) {
				ContainerLine_UnloadOleObject(lpContainerLine, dwSaveOption);
			}
		}
	}
}


/* ContainerDoc_UpdateExtentOfAllOleObjects
** ----------------------------------------
**    Update the extents of any OLE object that is marked that its size
**    may  have changed. when an IAdviseSink::OnViewChange notification
**    is received, the corresponding ContainerLine is marked
**    (m_fDoGetExtent==TRUE) and a message (WM_U_UPDATEOBJECTEXTENT) is
**    posted to the document indicating that there are dirty objects.
**    when this message is received, this function is called.
*/
void ContainerDoc_UpdateExtentOfAllOleObjects(LPCONTAINERDOC lpContainerDoc)
{
	LPLINELIST  lpLL = &((LPOUTLINEDOC)lpContainerDoc)->m_LineList;
	int         i;
	LPLINE      lpLine;
	BOOL        fStatus = TRUE;
#if defined( INPLACE_CNTR )
	int         nFirstUpdate = -1;
#endif

	for (i = 0; i < lpLL->m_nNumLines; i++) {
		lpLine=LineList_GetLine(lpLL, i);

		if (lpLine && (Line_GetLineType(lpLine)==CONTAINERLINETYPE)) {
			LPCONTAINERLINE lpContainerLine = (LPCONTAINERLINE)lpLine;

			if (lpContainerLine->m_fDoGetExtent) {
				ContainerLine_UpdateExtent(lpContainerLine, NULL);
#if defined( INPLACE_CNTR )
				if (nFirstUpdate == -1)
					nFirstUpdate = i;
#endif
			}
		}
	}

#if defined( INPLACE_CNTR )
	/* OLE2NOTE: after changing the extents of any line, we need to
	**    update the PosRect of the In-Place active
	**    objects (if any) that follow the first modified line.
	*/
	if (nFirstUpdate != -1)
		ContainerDoc_UpdateInPlaceObjectRects(lpContainerDoc, nFirstUpdate+1);
#endif
}


BOOL ContainerDoc_SaveToFile(
		LPCONTAINERDOC          lpContainerDoc,
		LPCSTR                  lpszFileName,
		UINT                    uFormat,
		BOOL                    fRemember
)
{
	LPOLEAPP lpOleApp = (LPOLEAPP)g_lpApp;
	LPOUTLINEDOC lpOutlineDoc = (LPOUTLINEDOC)lpContainerDoc;
	LPOLEDOC lpOleDoc = (LPOLEDOC)lpContainerDoc;
	LPSTORAGE lpDestStg;
	BOOL fStatus;
	BOOL fMustRelDestStg = FALSE;
	HRESULT hrErr;
#if defined( OPTIONAL )
	FILETIME filetimeBeforeSave;
#endif

	if (fRemember) {
		if (lpszFileName) {
			fStatus = OutlineDoc_SetFileName(
					lpOutlineDoc, (LPSTR)lpszFileName, NULL);
			if (! fStatus) goto error;
		}

		/* The ContainerDoc keeps its storage open at all times. it is not
		**    necessary to reopen the file.
		** if SaveAs is pending, then lpNewStg is the new destination for
		**    the save operation, else the existing storage is the dest.
		*/
		lpDestStg = (lpContainerDoc->m_lpNewStg ?
						lpContainerDoc->m_lpNewStg : lpOleDoc->m_lpStg);

#if defined( OPTIONAL )
		/* OLE2NOTE: an automatic link to an embedded object within the
		**    same container document (that uses ItemMonikers) will
		**    always be considered "out-of-date' by OLE. if a container
		**    application REALLY wants to fix this it can do one of the
		**    following:
		**      1. implement a new moniker better than ItemMonikers
		**    that look into the objects storage to find the real last
		**    change time (rather then defaulting to that of the outer
		**    container file).
		** or   2. using item monikers it is possible to fix the case
		**    where the container document is saved while the embedded
		**    object is running but it will NOT fix the case when the
		**    document is saved when the embedded object was only
		**    loaded. the fix is to:
		**      a. remember the time (T) before the save operation starts
		**      b. call IRunningObjectTable::NoteChangeTime(lpDoc, T)
		**      c. do the saving and commit the file
		**      d. call StgSetTimes to reset the file time to T
		**      e. remember time T in document structure and when the
		**         root storage is finally released reset the file time
		**         again to T (closing the file on DOS sets the time).
		*/
		CoFileTimeNow( &filetimeBeforeSave );
		if (lpOleDoc->m_dwRegROT != 0) {
			LPRUNNINGOBJECTTABLE lprot;

			if (GetRunningObjectTable(0,&lprot) == NOERROR)
			{
				OleDbgOut2("IRunningObjectTable::NoteChangeTime called\r\n");
				lprot->lpVtbl->NoteChangeTime(
						lprot, lpOleDoc->m_dwRegROT, &filetimeBeforeSave );
				lprot->lpVtbl->Release(lprot);
			}
		}
#endif
	} else {
		if (! lpszFileName)
			goto error;

		/* OLE2NOTE: since we are preforming a SaveCopyAs operation, we
		**    do not need to have the DocFile open in STGM_TRANSACTED mode.
		**    there is less overhead to use STGM_DIRECT mode.
		*/
		hrErr = StgCreateDocfileA(
				lpszFileName,
				STGM_READWRITE|STGM_DIRECT|STGM_SHARE_EXCLUSIVE|STGM_CREATE,
				0,
				&lpDestStg
		);

		OleDbgAssertSz(hrErr == NOERROR, "Could not create Docfile");
		if (hrErr != NOERROR) {
            OleDbgOutHResult("StgCreateDocfile returned", hrErr);
			goto error;
        }
		fMustRelDestStg = TRUE;
	}

	/*  OLE2NOTE: we must be sure to write our class ID into our
	**    storage. this information is used by OLE to determine the
	**    class of the data stored in our storage. Even for top
	**    "file-level" objects this information should be written to
	**    the file.
	*/
	hrErr = WriteClassStg(lpDestStg, &CLSID_APP);
	if(hrErr != NOERROR) goto error;

	fStatus = OutlineDoc_SaveSelToStg(
			lpOutlineDoc,
			NULL,           // save all lines
			uFormat,
			lpDestStg,
			FALSE,          // fSameAsLoad
			TRUE            // remember this stg
		);

	if (fStatus)
		fStatus = OleStdCommitStorage(lpDestStg);

	if (fRemember) {
		/* if SaveAs was pending, then release the old storage and remember
		**    the new storage as the active current storage. all data from
		**    the old storage has been copied into the new storage.
		*/
		if (lpContainerDoc->m_lpNewStg) {
			OleStdRelease((LPUNKNOWN)lpOleDoc->m_lpStg);  // free old stg
			lpOleDoc->m_lpStg = lpContainerDoc->m_lpNewStg;   // save new stg
			lpContainerDoc->m_lpNewStg = NULL;
		}
		if (! fStatus) goto error;

		OutlineDoc_SetModified(lpOutlineDoc, FALSE, FALSE, FALSE);

#if defined( OPTIONAL )
		/* reset time of file on disk to be time just prior to saving.
		** NOTE: it would also be necessary to remember
		**    filetimeBeforeSave in the document structure and when the
		**    root storage is finally released reset the file time
		**    again to this value (closing the file on DOS sets the time).
		*/
		StgSetTimesA(lpOutlineDoc->m_szFileName,
			NULL, NULL, &filetimeBeforeSave);
#endif
	}

	if (fMustRelDestStg)
		OleStdRelease((LPUNKNOWN)lpDestStg);
	return TRUE;

error:
	if (fMustRelDestStg)
		OleStdRelease((LPUNKNOWN)lpDestStg);
	OutlineApp_ErrorMessage(g_lpApp, ErrMsgSaving);
	return FALSE;
}


/* ContainerDoc_ContainerLineDoVerbCommand
** ---------------------------------------
**    Execute a verb of the OLE object in the current focus line.
*/
void ContainerDoc_ContainerLineDoVerbCommand(
		LPCONTAINERDOC          lpContainerDoc,
		LONG                    iVerb
)
{
	LPLINELIST lpLL = &((LPOUTLINEDOC)lpContainerDoc)->m_LineList;
	int nIndex = LineList_GetFocusLineIndex(lpLL);
	LPLINE lpLine = LineList_GetLine(lpLL, nIndex);
	HCURSOR                 hPrevCursor;

	if (! lpLine || (Line_GetLineType(lpLine) != CONTAINERLINETYPE) ) return;

	// this may take a while, put up hourglass cursor
	hPrevCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));

	ContainerLine_DoVerb((LPCONTAINERLINE) lpLine, iVerb, NULL, TRUE, TRUE);

	SetCursor(hPrevCursor);     // restore original cursor
}


/* ContainerDoc_GetNextStgName
** ---------------------------
**    Generate the next unused name for a sub-storage to be used by an
**    OLE object. The ContainerDoc keeps a counter. The storages for
**    OLE objects are simply numbered (eg. Obj 0, Obj 1). A "long"
**    integer worth of storage names should be more than enough than we
**    will ever need.
**
**    NOTE: when an OLE object is transfered via drag/drop or the
**    clipboard, we attempt to keep the currently assigned name for the
**    object (if not currently in use). thus it is possible that an
**    object with a the next default name (eg. "Obj 5") already exists
**    in the current document if an object with this name was privously
**    transfered (pasted or dropped). we therefore loop until we find
**    the next lowest unused name.
*/
void ContainerDoc_GetNextStgName(
		LPCONTAINERDOC          lpContainerDoc,
		LPSTR                   lpszStgName,
		int                     nLen
)
{
	wsprintf(lpszStgName, "%s %ld",
			(LPSTR)DEFOBJNAMEPREFIX,
			++(lpContainerDoc->m_nNextObjNo)
	);

	while (ContainerDoc_IsStgNameUsed(lpContainerDoc, lpszStgName) == TRUE) {
		wsprintf(lpszStgName, "%s %ld",
				(LPSTR)DEFOBJNAMEPREFIX,
				++(lpContainerDoc->m_nNextObjNo)
		);
	}
}


/* ContainerDoc_IsStgNameUsed
** --------------------------
**    Check if a given StgName is already in use.
*/
BOOL ContainerDoc_IsStgNameUsed(
		LPCONTAINERDOC          lpContainerDoc,
		LPSTR                   lpszStgName
)
{
	LPLINELIST lpLL = &((LPOUTLINEDOC)lpContainerDoc)->m_LineList;
	int i;
	LPLINE lpLine;

	for (i = 0; i < lpLL->m_nNumLines; i++) {
		lpLine=LineList_GetLine(lpLL, i);

		if (lpLine && (Line_GetLineType(lpLine)==CONTAINERLINETYPE)) {
			if (lstrcmp(lpszStgName,
					((LPCONTAINERLINE)lpLine)->m_szStgName) == 0) {
				return TRUE;    // Match FOUND!
			}
		}
	}
	return FALSE;   // if we get here, then NO match was found.
}


LPSTORAGE ContainerDoc_GetStg(LPCONTAINERDOC lpContainerDoc)
{
	return ((LPOLEDOC)lpContainerDoc)->m_lpStg;
}


/* ContainerDoc_GetSingleOleObject
** -------------------------------
**    If the entire document contains a single OLE object, then
**    return the desired interface of the object.
**
**    Returns NULL if there is are multiple lines in the document or
**    the single line is not a ContainerLine.
*/
LPUNKNOWN ContainerDoc_GetSingleOleObject(
		LPCONTAINERDOC          lpContainerDoc,
		REFIID                  riid,
		LPCONTAINERLINE FAR*    lplpContainerLine
)
{
	LPLINELIST lpLL = &((LPOUTLINEDOC)lpContainerDoc)->m_LineList;
	LPLINE lpLine;
	LPUNKNOWN lpObj = NULL;

	if (lplpContainerLine)
		*lplpContainerLine = NULL;

	if (lpLL->m_nNumLines != 1)
		return NULL;    // doc does NOT contain a single line

	lpLine=LineList_GetLine(lpLL, 0);

	if (lpLine && (Line_GetLineType(lpLine)==CONTAINERLINETYPE))
		lpObj = ContainerLine_GetOleObject((LPCONTAINERLINE)lpLine, riid);

	if (lplpContainerLine)
		*lplpContainerLine = (LPCONTAINERLINE)lpLine;

	return lpObj;
}


/* ContainerDoc_IsSelAnOleObject
** -----------------------------
**    Check if the selection is a single selection of an OLE object.
**    if so, then optionally return the desired interface of the object
**    and/or index of the ContainerLine containing the OLE object.
**
**    Returns FALSE if there is a multiple selection or the single
**    selection is not a ContainerLine.
*/
BOOL ContainerDoc_IsSelAnOleObject(
		LPCONTAINERDOC          lpContainerDoc,
		REFIID                  riid,
		LPUNKNOWN FAR*          lplpvObj,
		int FAR*                lpnIndex,
		LPCONTAINERLINE FAR*    lplpContainerLine
)
{
	LPLINELIST lpLL = &((LPOUTLINEDOC)lpContainerDoc)->m_LineList;
	LINERANGE lrSel;
	int nNumSel;
	LPLINE lpLine;

	if (lplpvObj) *lplpvObj = NULL;
	if (lpnIndex) *lpnIndex = -1;
	if (lplpContainerLine) *lplpContainerLine = NULL;

	nNumSel = LineList_GetSel(lpLL, (LPLINERANGE)&lrSel);
	if (nNumSel != 1)
		return FALSE;   // selection is not a single line

	lpLine = LineList_GetLine(lpLL, lrSel.m_nStartLine);

	if (lpLine && (Line_GetLineType(lpLine)==CONTAINERLINETYPE)) {
		if (lpnIndex)
			*lpnIndex = lrSel.m_nStartLine;
		if (lplpContainerLine)
			*lplpContainerLine = (LPCONTAINERLINE)lpLine;
		if (riid) {
			*lplpvObj = ContainerLine_GetOleObject(
					(LPCONTAINERLINE)lpLine,
					riid
			);
		}

		return (*lplpvObj ? TRUE : FALSE);
	}

	return FALSE;
}


/*************************************************************************
** ContainerDoc::IOleUILinkContainer interface implementation
*************************************************************************/

STDMETHODIMP CntrDoc_LinkCont_QueryInterface(
		LPOLEUILINKCONTAINER    lpThis,
		REFIID                  riid,
		LPVOID FAR*             lplpvObj
)
{
	LPOLEDOC lpOleDoc = (LPOLEDOC)
			((struct CDocOleUILinkContainerImpl FAR*)lpThis)->lpContainerDoc;

	return OleDoc_QueryInterface(lpOleDoc, riid, lplpvObj);
}


STDMETHODIMP_(ULONG) CntrDoc_LinkCont_AddRef(LPOLEUILINKCONTAINER lpThis)
{
	LPOLEDOC lpOleDoc = (LPOLEDOC)
			((struct CDocOleUILinkContainerImpl FAR*)lpThis)->lpContainerDoc;

	OleDbgAddRefMethod(lpThis, "IOleUILinkContainer");

	return OleDoc_AddRef(lpOleDoc);
}


STDMETHODIMP_(ULONG) CntrDoc_LinkCont_Release(LPOLEUILINKCONTAINER lpThis)
{
	LPOLEDOC lpOleDoc = (LPOLEDOC)
			((struct CDocOleUILinkContainerImpl FAR*)lpThis)->lpContainerDoc;

	OleDbgReleaseMethod(lpThis, "IOleUILinkContainer");

	return OleDoc_Release(lpOleDoc);
}


STDMETHODIMP_(DWORD) CntrDoc_LinkCont_GetNextLink(
		LPOLEUILINKCONTAINER    lpThis,
		DWORD                   dwLink
)
{
	LPCONTAINERDOC lpContainerDoc =
			((struct CDocOleUILinkContainerImpl FAR*)lpThis)->lpContainerDoc;
	LPCONTAINERLINE lpContainerLine = NULL;

	OLEDBG_BEGIN2("CntrDoc_LinkCont_GetNextLink\r\n")

	lpContainerLine = ContainerDoc_GetNextLink(
			lpContainerDoc,
			(LPCONTAINERLINE)dwLink
	);

	OLEDBG_END2
	return (DWORD)lpContainerLine;
}


STDMETHODIMP CntrDoc_LinkCont_SetLinkUpdateOptions(
		LPOLEUILINKCONTAINER    lpThis,
		DWORD                   dwLink,
		DWORD                   dwUpdateOpt
)
{
	LPCONTAINERDOC lpContainerDoc =
			((struct CDocOleUILinkContainerImpl FAR*)lpThis)->lpContainerDoc;
	LPCONTAINERLINE lpContainerLine = (LPCONTAINERLINE)dwLink;
	LPOLELINK lpOleLink = lpContainerLine->m_lpOleLink;
	SCODE sc = S_OK;
	HRESULT hrErr;

	OLEDBG_BEGIN2("CntrDoc_LinkCont_SetLinkUpdateOptions\r\n")

	OleDbgAssert(lpContainerLine);

	if (! lpOleLink) {
		sc = E_FAIL;
		goto error;
	}

	OLEDBG_BEGIN2("IOleLink::SetUpdateOptions called\r\n")
	hrErr = lpOleLink->lpVtbl->SetUpdateOptions(
			lpOleLink,
			dwUpdateOpt
	);
	OLEDBG_END2

	// save new link type update option
	lpContainerLine->m_dwLinkType = dwUpdateOpt;

	if (hrErr != NOERROR) {
		OleDbgOutHResult("IOleLink::SetUpdateOptions returned", hrErr);
		sc = GetScode(hrErr);
		goto error;
	}

	OLEDBG_END2
	return ResultFromScode(sc);

error:
	OLEDBG_END2
	return ResultFromScode(sc);
}


STDMETHODIMP CntrDoc_LinkCont_GetLinkUpdateOptions(
		LPOLEUILINKCONTAINER    lpThis,
		DWORD                   dwLink,
		DWORD FAR*              lpdwUpdateOpt
)
{
	LPCONTAINERDOC lpContainerDoc =
			((struct CDocOleUILinkContainerImpl FAR*)lpThis)->lpContainerDoc;
	LPCONTAINERLINE lpContainerLine = (LPCONTAINERLINE)dwLink;
	LPOLELINK lpOleLink = lpContainerLine->m_lpOleLink;
	SCODE sc = S_OK;
	HRESULT hrErr;

	OLEDBG_BEGIN2("CntrDoc_LinkCont_GetLinkUpdateOptions\r\n")

	OleDbgAssert(lpContainerLine);

	if (! lpOleLink) {
		sc = E_FAIL;
		goto error;
	}

	OLEDBG_BEGIN2("IOleLink::GetUpdateOptions called\r\n")
	hrErr = lpOleLink->lpVtbl->GetUpdateOptions(
			lpOleLink,
			lpdwUpdateOpt
	);
	OLEDBG_END2

	// reset saved link type to ensure it is correct
	lpContainerLine->m_dwLinkType = *lpdwUpdateOpt;

	if (hrErr != NOERROR) {
		OleDbgOutHResult("IOleLink::GetUpdateOptions returned", hrErr);
		sc = GetScode(hrErr);
		goto error;
	}

	OLEDBG_END2
	return ResultFromScode(sc);

error:
	OLEDBG_END2
	return ResultFromScode(sc);
}


STDMETHODIMP CntrDoc_LinkCont_SetLinkSource(
		LPOLEUILINKCONTAINER    lpThis,
		DWORD                   dwLink,
		LPSTR                   lpszDisplayName,
		ULONG                   lenFileName,
		ULONG FAR*              lpchEaten,
		BOOL                    fValidateSource
)
{
	LPCONTAINERDOC lpContainerDoc =
			((struct CDocOleUILinkContainerImpl FAR*)lpThis)->lpContainerDoc;
	LPCONTAINERLINE lpContainerLine = (LPCONTAINERLINE)dwLink;
	SCODE       sc = S_OK;
	HRESULT     hrErr;
	LPOLELINK   lpOleLink = lpContainerLine->m_lpOleLink;
	LPBC        lpbc = NULL;
	LPMONIKER   lpmk = NULL;
	LPOLEOBJECT lpLinkSrcOleObj = NULL;
	CLSID       clsid = CLSID_NULL;
	CLSID       clsidOld = CLSID_NULL;


	OLEDBG_BEGIN2("CntrDoc_LinkCont_SetLinkSource\r\n")

	OleDbgAssert(lpContainerLine);

	lpContainerLine->m_fLinkUnavailable = TRUE;

	if (fValidateSource) {

		/* OLE2NOTE: validate the link source by parsing the string
		**    into a Moniker. if this is successful, then the string is
		**    valid.
		*/
		hrErr = CreateBindCtx(0, (LPBC FAR*)&lpbc);
		if (hrErr != NOERROR) {
			sc = GetScode(hrErr);   // ERROR: OOM
			goto cleanup;
		}

		// Get class of orignial link source if it is available
		if (lpContainerLine->m_lpOleObj) {

			OLEDBG_BEGIN2("IOleObject::GetUserClassID called\r\n")
			hrErr = lpContainerLine->m_lpOleObj->lpVtbl->GetUserClassID(
					lpContainerLine->m_lpOleObj, (CLSID FAR*)&clsidOld);
			OLEDBG_END2
			if (hrErr != NOERROR) clsidOld = CLSID_NULL;
		}

		hrErr = OleStdMkParseDisplayName(
			  &clsidOld,lpbc,lpszDisplayName,lpchEaten,(LPMONIKER FAR*)&lpmk);

		if (hrErr != NOERROR) {
			sc = GetScode(hrErr);   // ERROR in parsing moniker!
			goto cleanup;
		}
		/* OLE2NOTE: the link source was validated; it successfully
		**    parsed into a Moniker. we can set the source of the link
		**    directly with this Moniker. if we want the link to be
		**    able to know the correct class for the new link source,
		**    we must bind to the moniker and get the CLSID. if we do
		**    not do this then methods like IOleObject::GetUserType
		**    will return nothing (NULL strings).
		*/

		hrErr = lpmk->lpVtbl->BindToObject(
				lpmk,lpbc,NULL,&IID_IOleObject,(LPVOID FAR*)&lpLinkSrcOleObj);
		if (hrErr == NOERROR) {
			OLEDBG_BEGIN2("IOleObject::GetUserClassID called\r\n")
			hrErr = lpLinkSrcOleObj->lpVtbl->GetUserClassID(
							lpLinkSrcOleObj, (CLSID FAR*)&clsid);
			OLEDBG_END2
			lpContainerLine->m_fLinkUnavailable = FALSE;

			/* get the short user type name of the link because it may
			**    have changed. we cache this name and must update our
			**    cache. this name is used all the time when we have to
			**    build the object verb menu. we cache this information
			**    to make it quicker to build the verb menu.
			*/
			if (lpContainerLine->m_lpszShortType) {
				OleStdFree(lpContainerLine->m_lpszShortType);
				lpContainerLine->m_lpszShortType = NULL;
			}
			OLEDBG_BEGIN2("IOleObject::GetUserType called\r\n")

			CallIOleObjectGetUserTypeA(
					lpContainerLine->m_lpOleObj,
					USERCLASSTYPE_SHORT,
					(LPSTR FAR*)&lpContainerLine->m_lpszShortType
			);

			OLEDBG_END2
		}
		else
			lpContainerLine->m_fLinkUnavailable = TRUE;
	}
	else {
		LPMONIKER   lpmkFile = NULL;
		LPMONIKER   lpmkItem = NULL;
		char        szDelim[2];
		LPSTR       lpszName;

		szDelim[0] = lpszDisplayName[(int)lenFileName];
		szDelim[1] = '\0';
		lpszDisplayName[(int)lenFileName] = '\0';

		OLEDBG_BEGIN2("CreateFileMoniker called\r\n")

		CreateFileMonikerA(lpszDisplayName, (LPMONIKER FAR*)&lpmkFile);

		OLEDBG_END2

		lpszDisplayName[(int)lenFileName] = szDelim[0];

		if (!lpmkFile)
			goto cleanup;

		if (lstrlen(lpszDisplayName) > (int)lenFileName) {  // have item name
			lpszName = lpszDisplayName + lenFileName + 1;

			OLEDBG_BEGIN2("CreateItemMoniker called\r\n")

			CreateItemMonikerA(
				szDelim, lpszName, (LPMONIKER FAR*)&lpmkItem);

			OLEDBG_END2

			if (!lpmkItem) {
				OleStdRelease((LPUNKNOWN)lpmkFile);
				goto cleanup;
			}

			OLEDBG_BEGIN2("CreateGenericComposite called\r\n")
			CreateGenericComposite(lpmkFile, lpmkItem, (LPMONIKER FAR*)&lpmk);
			OLEDBG_END2

			if (lpmkFile)
				OleStdRelease((LPUNKNOWN)lpmkFile);
			if (lpmkItem)
				OleStdRelease((LPUNKNOWN)lpmkItem);

			if (!lpmk)
				goto cleanup;
		}
		else
			lpmk = lpmkFile;
	}

	if (! lpOleLink) {
		OleDbgAssert(lpOleLink != NULL);
		sc = E_FAIL;
		goto cleanup;
	}

	if (lpmk) {

		OLEDBG_BEGIN2("IOleLink::SetSourceMoniker called\r\n")
		hrErr = lpOleLink->lpVtbl->SetSourceMoniker(
				lpOleLink, lpmk, (REFCLSID)&clsid);
		OLEDBG_END2

		if (FAILED(GetScode(hrErr))) {
			OleDbgOutHResult("IOleLink::SetSourceMoniker returned",hrErr);
			sc = GetScode(hrErr);
			goto cleanup;
		}

		/* OLE2NOTE: above we forced the link source moniker to bind.
		**    because we deliberately hold on to the bind context
		**    (lpbc) the link source object will not shut down. during
		**    the call to IOleLink::SetSourceMoniker, the link will
		**    connect to the running link source (the link internally
		**    calls BindIfRunning). it is important to initially allow
		**    the link to bind to the running object so that it can get
		**    an update of the presentation for its cache. we do not
		**    want the connection from our link to the link source be
		**    the only reason the link source stays running. thus we
		**    deliberately for the link to release (unbind) the source
		**    object, we then release the bind context, and then we
		**    allow the link to rebind to the link source if it is
		**    running anyway.
		*/
		if (lpbc && lpmk->lpVtbl->IsRunning(lpmk,lpbc,NULL,NULL) == NOERROR) {

			OLEDBG_BEGIN2("IOleLink::Update called\r\n")
			hrErr = lpOleLink->lpVtbl->Update(lpOleLink, NULL);
			OLEDBG_END2

#if defined( _DEBUG )
			if (FAILED(GetScode(hrErr)))
				OleDbgOutHResult("IOleLink::Update returned",hrErr);
#endif

			OLEDBG_BEGIN2("IOleLink::UnbindSource called\r\n")
			hrErr = lpOleLink->lpVtbl->UnbindSource(lpOleLink);
			OLEDBG_END2

#if defined( _DEBUG )
			if (FAILED(GetScode(hrErr)))
				OleDbgOutHResult("IOleLink::UnbindSource returned",hrErr);
#endif

			if (lpLinkSrcOleObj) {
				OleStdRelease((LPUNKNOWN)lpLinkSrcOleObj);
				lpLinkSrcOleObj = NULL;
			}

			if (lpbc) {
				OleStdRelease((LPUNKNOWN)lpbc);
				lpbc = NULL;
			}

			OLEDBG_BEGIN2("IOleLink::BindIfRunning called\r\n")
			hrErr = lpOleLink->lpVtbl->BindIfRunning(lpOleLink);
			OLEDBG_END2

#if defined( _DEBUG )
			if (FAILED(GetScode(hrErr)))
				OleDbgOutHResult("IOleLink::BindIfRunning returned",hrErr);
#endif
		}
	} else {
		/* OLE2NOTE: the link source was NOT validated; it was NOT
		**    successfully parsed into a Moniker. we can only set the
		**    display name string as the source of the link. this link
		**    is not able to bind.
		*/
		OLEDBG_BEGIN2("IOleLink::SetSourceDisplayName called\r\n")

		hrErr = CallIOleLinkSetSourceDisplayNameA(
				lpOleLink, lpszDisplayName);

		OLEDBG_END2

		if (hrErr != NOERROR) {
			OleDbgOutHResult("IOleLink::SetSourceDisplayName returned",hrErr);
			sc = GetScode(hrErr);
			goto cleanup;
		}
	}

cleanup:
	if (lpLinkSrcOleObj)
		OleStdRelease((LPUNKNOWN)lpLinkSrcOleObj);
	if (lpmk)
		OleStdRelease((LPUNKNOWN)lpmk);
	if (lpbc)
		OleStdRelease((LPUNKNOWN)lpbc);

	OLEDBG_END2
	return ResultFromScode(sc);
}


STDMETHODIMP CntrDoc_LinkCont_GetLinkSource(
		LPOLEUILINKCONTAINER    lpThis,
		DWORD                   dwLink,
		LPSTR FAR*              lplpszDisplayName,
		ULONG FAR*              lplenFileName,
		LPSTR FAR*              lplpszFullLinkType,
		LPSTR FAR*              lplpszShortLinkType,
		BOOL FAR*               lpfSourceAvailable,
		BOOL FAR*               lpfIsSelected
)
{
	LPCONTAINERDOC lpContainerDoc =
			((struct CDocOleUILinkContainerImpl FAR*)lpThis)->lpContainerDoc;
	LPCONTAINERLINE lpContainerLine = (LPCONTAINERLINE)dwLink;
	LPOLELINK       lpOleLink = lpContainerLine->m_lpOleLink;
	LPOLEOBJECT     lpOleObj = NULL;
	LPMONIKER       lpmk = NULL;
	LPMONIKER       lpmkFirst = NULL;
	LPBC            lpbc = NULL;
	SCODE           sc = S_OK;
	HRESULT         hrErr;

	OLEDBG_BEGIN2("CntrDoc_LinkCont_GetLinkSource\r\n")

	/* OLE2NOTE: we must make sure to set all out parameters to NULL. */
	*lplpszDisplayName  = NULL;
	*lplpszFullLinkType = NULL;
	*lplpszShortLinkType= NULL;
	*lplenFileName      = 0;
	*lpfSourceAvailable = !lpContainerLine->m_fLinkUnavailable;

	OleDbgAssert(lpContainerLine);

	if (! lpOleLink) {
		OLEDBG_END2
		return ResultFromScode(E_FAIL);
	}

	OLEDBG_BEGIN2("IOleLink::GetSourceMoniker called\r\n")
	hrErr = lpOleLink->lpVtbl->GetSourceMoniker(
			lpOleLink,
			(LPMONIKER FAR*)&lpmk
	);
	OLEDBG_END2

	if (hrErr == NOERROR) {
		/* OLE2NOTE: the link has the Moniker form of the link source;
		**    this is therefore a validated link source. if the first
		**    part of the Moniker is a FileMoniker, then we need to
		**    return the length of the filename string. we need to
		**    return the ProgID associated with the link source as the
		**    "lpszShortLinkType". we need to return the
		**    FullUserTypeName associated with the link source as the
		**    "lpszFullLinkType".
		*/

		lpOleObj = (LPOLEOBJECT)OleStdQueryInterface(
				(LPUNKNOWN)lpOleLink, &IID_IOleObject);
		if (lpOleObj) {
			CallIOleObjectGetUserTypeA(
					lpOleObj,
					USERCLASSTYPE_FULL,
					lplpszFullLinkType
			);

			CallIOleObjectGetUserTypeA(
					lpOleObj,
					USERCLASSTYPE_SHORT,
					lplpszShortLinkType
			);

			OleStdRelease((LPUNKNOWN)lpOleObj);
		}
		*lplenFileName = OleStdGetLenFilePrefixOfMoniker(lpmk);
		lpmk->lpVtbl->Release(lpmk);
	}

	OLEDBG_BEGIN2("IOleLink::GetSourceDisplayName called\r\n")

	hrErr = CallIOleLinkGetSourceDisplayNameA(
			lpOleLink,
			lplpszDisplayName
	);

	OLEDBG_END2

	if (hrErr != NOERROR) {
		OleDbgOutHResult("IOleLink::GetSourceDisplayName returned", hrErr);
		OLEDBG_END2
		return hrErr;
	}

	OLEDBG_END2

	if (lpfIsSelected)
		*lpfIsSelected = Line_IsSelected((LPLINE)lpContainerLine);

	return NOERROR;
}


STDMETHODIMP CntrDoc_LinkCont_OpenLinkSource(
		LPOLEUILINKCONTAINER    lpThis,
		DWORD                   dwLink
)
{
	LPCONTAINERDOC lpContainerDoc =
			((struct CDocOleUILinkContainerImpl FAR*)lpThis)->lpContainerDoc;
	LPCONTAINERLINE lpContainerLine = (LPCONTAINERLINE)dwLink;
	SCODE sc = S_OK;

	OLEDBG_BEGIN2("CntrDoc_LinkCont_OpenLinkSource\r\n")

	OleDbgAssert(lpContainerLine);

	if (! ContainerLine_DoVerb(
			lpContainerLine, OLEIVERB_SHOW, NULL, TRUE, FALSE)) {
		sc = E_FAIL;
	}

	lpContainerLine->m_fLinkUnavailable = (sc != S_OK);

	OLEDBG_END2
	return ResultFromScode(sc);
}


STDMETHODIMP CntrDoc_LinkCont_UpdateLink(
		LPOLEUILINKCONTAINER    lpThis,
		DWORD                   dwLink,
		BOOL                    fErrorMessage,
		BOOL                    fErrorAction        // ignore if fErrorMessage
													//      is FALSE
)
{
	LPCONTAINERDOC lpContainerDoc =
			((struct CDocOleUILinkContainerImpl FAR*)lpThis)->lpContainerDoc;
	LPCONTAINERLINE lpContainerLine = (LPCONTAINERLINE)dwLink;
	SCODE sc = S_OK;
        /* Default to update of the link */
	HRESULT hrErr = S_FALSE;

	OLEDBG_BEGIN2("CntrDoc_LinkCont_UpdateLink\r\n")

	OleDbgAssert(lpContainerLine);

	if (! lpContainerLine->m_lpOleObj)
		ContainerLine_LoadOleObject(lpContainerLine);

	if (!fErrorMessage) {
		OLEDBG_BEGIN2("IOleObject::IsUpToDate called\r\n")
		hrErr = lpContainerLine->m_lpOleObj->lpVtbl->IsUpToDate(
				lpContainerLine->m_lpOleObj
		);
		OLEDBG_END2
	}

	if (hrErr != NOERROR) {
		OLEDBG_BEGIN2("IOleObject::Update called\r\n")
		hrErr = lpContainerLine->m_lpOleObj->lpVtbl->Update(
				lpContainerLine->m_lpOleObj
		);
		OLEDBG_END2
	}

	/* OLE2NOTE: If IOleObject::Update on the Link object returned
	**    OLE_E_CLASSDIFF because the link source is no longer
	**    the expected class, then the link should be re-created with
	**    the new link source. thus the link will be updated with the
	**    new link source.
	*/
	if (GetScode(hrErr) == OLE_E_CLASSDIFF)
		hrErr = ContainerLine_ReCreateLinkBecauseClassDiff(lpContainerLine);

	lpContainerLine->m_fLinkUnavailable = (hrErr != NOERROR);

	if (hrErr != NOERROR) {
		OleDbgOutHResult("IOleObject::Update returned", hrErr);
		sc = GetScode(hrErr);
		if (fErrorMessage) {
			ContainerLine_ProcessOleRunError(
					lpContainerLine,hrErr,fErrorAction,FALSE/*fMenuInvoked*/);
		}
	}
	/* OLE2NOTE: if the update of the object requires us to update our
	**    display, then we will automatically be sent a OnViewChange
	**    advise. thus we do not need to take any action here to force
	**    a repaint.
	*/

	OLEDBG_END2
	return ResultFromScode(sc);
}


/* CntrDoc_LinkCont_CancelLink
** ---------------------------
**    Convert the link to a static picture.
**
**    OLE2NOTE: OleCreateStaticFromData can be used to create a static
**    picture object.
*/
STDMETHODIMP CntrDoc_LinkCont_CancelLink(
		LPOLEUILINKCONTAINER    lpThis,
		DWORD                   dwLink
)
{
	LPCONTAINERDOC lpContainerDoc =
			((struct CDocOleUILinkContainerImpl FAR*)lpThis)->lpContainerDoc;
	LPCONTAINERLINE lpContainerLine = (LPCONTAINERLINE)dwLink;
	LPLINELIST          lpLL = &((LPOUTLINEDOC)lpContainerDoc)->m_LineList;
	LPLINE              lpLine = NULL;
	HDC                 hDC;
	int                 nTab = 0;
	char                szStgName[CWCSTORAGENAME];
	LPCONTAINERLINE     lpNewContainerLine = NULL;
	LPDATAOBJECT        lpSrcDataObj;
	LPOLELINK           lpOleLink = lpContainerLine->m_lpOleLink;
	int nIndex = LineList_GetLineIndex(lpLL, (LPLINE)lpContainerLine);

	OLEDBG_BEGIN2("CntrDoc_LinkCont_CancelLink\r\n")

	/* we will first break the connection of the link to its source. */
	if (lpOleLink) {
		lpContainerLine->m_dwLinkType = 0;
		OLEDBG_BEGIN2("IOleLink::SetSourceMoniker called\r\n")
		lpOleLink->lpVtbl->SetSourceMoniker(
				lpOleLink, NULL, (REFCLSID)&CLSID_NULL);
		OLEDBG_END2
	}

	lpSrcDataObj = (LPDATAOBJECT)ContainerLine_GetOleObject(
			lpContainerLine,&IID_IDataObject);
	if (! lpSrcDataObj)
		goto error;

	ContainerDoc_GetNextStgName(lpContainerDoc, szStgName, sizeof(szStgName));
	nTab = Line_GetTabLevel((LPLINE)lpContainerLine);
	hDC = LineList_GetDC(lpLL);

	lpNewContainerLine = ContainerLine_CreateFromData(
			hDC,
			nTab,
			lpContainerDoc,
			lpSrcDataObj,
			OLECREATEFROMDATA_STATIC,
			0,   /* no special cfFormat required */
			(lpContainerLine->m_dwDrawAspect == DVASPECT_ICON),
			NULL,   /* hMetaPict */
			szStgName
	);
	LineList_ReleaseDC(lpLL, hDC);

	OleStdRelease((LPUNKNOWN)lpSrcDataObj);

	if (! lpNewContainerLine)
		goto error;

	OutlineDoc_SetModified((LPOUTLINEDOC)lpContainerDoc, TRUE, TRUE, FALSE);

	LineList_ReplaceLine(lpLL, (LPLINE)lpNewContainerLine, nIndex);

	OLEDBG_END2
	return ResultFromScode(NOERROR);

error:
	OutlineApp_ErrorMessage(g_lpApp, "Could not break the link.");
	OLEDBG_END2
	return ResultFromScode(E_FAIL);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\letest\outline\cntrrc.h ===
/*************************************************************************
**
**    OLE 2.0 Container Sample Code
**
**    cntrrc.h
**
**    This file contains constants used in rc file for CNTROUTL.EXE
**
**    (c) Copyright Microsoft Corp. 1992 - 1993 All Rights Reserved
**
*************************************************************************/

#if !defined( _CNTRRC_H_ )
#define _CNTRRC_H_

#ifndef RC_INVOKED
#pragma message ("INCLUDING CNTRRC.H from " __FILE__)
#endif  /* RC_INVOKED */

#define IDM_E_INSERTOBJECT          2700
#define IDM_E_EDITLINKS             3300
#define IDM_E_PASTELINK             2750
#define IDM_E_CONVERTVERB           9000
#define IDM_E_OBJECTVERBMIN         10000

#define IDM_D_INSIDEOUT             2755

#define WM_U_UPDATEOBJECTEXTENT     WM_USER+1

#endif // _CNTRRC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\letest\outline\cntroutl.h ===
/*************************************************************************
**
**    OLE 2.0 Container Sample Code
**
**    cntroutl.h
**
**    This file contains file contains data structure defintions,
**    function prototypes, constants, etc. used by the OLE 2.0 container
**    app version of the Outline series of sample applications:
**          Outline -- base version of the app (without OLE functionality)
**          SvrOutl -- OLE 2.0 Server sample app
**          CntrOutl -- OLE 2.0 Containter (Container) sample app
**
**    (c) Copyright Microsoft Corp. 1992 - 1993 All Rights Reserved
**
*************************************************************************/

#if !defined( _CNTROUTL_H_ )
#define _CNTROUTL_H_

#ifndef RC_INVOKED
#pragma message ("INCLUDING CNTROUTL.H from " __FILE__)
#endif  /* RC_INVOKED */

#include "oleoutl.h"
#include "cntrrc.h"

// REVIEW: should load from string resource
#define DEFOBJNAMEPREFIX    "Obj"   // Prefix for auto-generated stg names
#define DEFOBJWIDTH         5000    // default size for embedded obj.
#define DEFOBJHEIGHT        5000    // default size for embedded obj.
#define UNKNOWN_OLEOBJ_TYPE "Unknown OLE Object Type"
#define szOLEOBJECT "Object"
#define szOLELINK   "Link"

#define CONTAINERDOCFORMAT  "CntrOutl"      // CF_CntrOutl format name

/* Forward definition of types */
typedef struct tagCONTAINERDOC FAR* LPCONTAINERDOC;
typedef struct tagCONTAINERLINE FAR* LPCONTAINERLINE;


// Flags to specify type of OLECREATE???FROMDATA call required
typedef enum tagOLECREATEFROMDATATYPE {
	OLECREATEFROMDATA_LINK    = 1,
	OLECREATEFROMDATA_OBJECT  = 2,
	OLECREATEFROMDATA_STATIC  = 3
} OLECREATEFROMDATATYPE;

/*************************************************************************
** class CONTAINERLINE : LINE
**    The class CONTAINERLINE is a concrete subclass of the abstract base
**    class LINE. The CONTAINERLINE maintains all information about the
**    place within the CONTAINERDOC that an OLE object is embedded. This
**    object implements the following OLE 2.0 interfaces:
**          IOleClientSite
**          IAdviseSink
**    In the CntrOutl client app either CONTAINERLINE objects or TEXTLINE
**    objects can be created. The CONTAINERLINE class inherits all fields
**    from the LINE class. This inheritance is achieved by including a
**    member variable of type LINE as the first field in the CONTAINERLINE
**    structure. Thus a pointer to a CONTAINERLINE object can be cast to be
**    a pointer to a LINE object.
**    Each CONTAINERLINE object that is created in added to the LINELIST of
**    the associated OUTLINEDOC document.
*************************************************************************/

typedef struct tagCONTAINERLINE {
	LINE            m_Line;         // ContainerLine inherits fields of Line
	ULONG           m_cRef;         // total ref count for line
	char            m_szStgName[CWCSTORAGENAME]; // stg name w/i cntr stg
	BOOL            m_fObjWinOpen;  // is obj window open? if so, shade obj.
	BOOL            m_fMonikerAssigned; // has a moniker been assigned to obj
	DWORD           m_dwDrawAspect; // current display aspect for obj
									//      (either DVASPECT_CONTENT or
									//      DVASPECT_ICON)
	BOOL            m_fGuardObj;    // Guard against re-entrancy while
									//  loading or creating an OLE object
	BOOL            m_fDoGetExtent; // indicates extents may have changed
	BOOL            m_fDoSetExtent; // obj was resized when not running
									//  IOO::SetExtent needed on next run
	SIZEL           m_sizeInHimetric; // extents of obj in himetric units
	LPSTORAGE       m_lpStg;        // open pstg when obj is loaded
	LPCONTAINERDOC  m_lpDoc;        // ptr to associated client doc
	LPOLEOBJECT     m_lpOleObj;     // ptr to IOleObject* when obj is loaded
	LPVIEWOBJECT2   m_lpViewObj2;   // ptr to IViewObject2* when obj is loaded
	LPPERSISTSTORAGE m_lpPersistStg;// ptr to IPersistStorage* when obj loaded
	LPOLELINK       m_lpOleLink;    // ptr to IOleLink* if link is loaded
	DWORD           m_dwLinkType;   // is it a linked object?
									//   0 -- NOT a link
									//   OLEUPDATE_ALWAYS (1) -- auto link
									//   OLEUPDATE_ONCALL (3) -- man. link
	BOOL            m_fLinkUnavailable;     // is the link unavailable?
	LPSTR           m_lpszShortType;// short type name of OLE object needed
									//  to make the Edit.Object.Verb menu
	int             m_nHorizScrollShift;    // horiz scroll shift required
									// for object's inplace window.
									// (note: this is ICNTROTL specific)

#if defined( INPLACE_CNTR )
	BOOL            m_fIpActive;    // is object in-place active (undo valid)
	BOOL            m_fUIActive;    // is object UIActive
	BOOL            m_fIpVisible;   // is object's in-place window visible
	BOOL            m_fInsideOutObj;// is obj inside-out (visible when loaded)
	LPOLEINPLACEOBJECT m_lpOleIPObj; // IOleInPlaceObject* of in-place obj
	BOOL            m_fIpChangesUndoable;   // can in-place object do undo
	BOOL            m_fIpServerRunning; // is in-place server running
	HWND            m_hWndIpObject;

	struct COleInPlaceSiteImpl {
		IOleInPlaceSiteVtbl FAR* lpVtbl;
		LPCONTAINERLINE         lpContainerLine;
		int                     cRef;   // interface specific ref count.
	} m_OleInPlaceSite;
#endif  // INPLACE_CNTR

	struct CUnknownImpl {
		IUnknownVtbl FAR*       lpVtbl;
		LPCONTAINERLINE         lpContainerLine;
		int                     cRef;   // interface specific ref count.
	} m_Unknown;

	struct COleClientSiteImpl {
		IOleClientSiteVtbl FAR* lpVtbl;
		LPCONTAINERLINE         lpContainerLine;
		int                 cRef;   // interface specific ref count.
	} m_OleClientSite;

	struct CAdviseSinkImpl {
		IAdviseSinkVtbl FAR*    lpVtbl;
		LPCONTAINERLINE         lpContainerLine;
		int                     cRef;   // interface specific ref count.
	} m_AdviseSink;

} CONTAINERLINE;


/* ContainerLine methods (functions) */
void ContainerLine_Init(LPCONTAINERLINE lpContainerLine, int nTab, HDC hDC);
BOOL ContainerLine_SetupOleObject(
		LPCONTAINERLINE         lpContainerLine,
		BOOL                    fDisplayAsIcon,
		HGLOBAL                 hMetaPict
);
LPCONTAINERLINE ContainerLine_Create(
		DWORD                   dwOleCreateType,
		HDC                     hDC,
		UINT                    nTab,
		LPCONTAINERDOC          lpContainerDoc,
		LPCLSID                 lpclsid,
		LPSTR                   lpszFileName,
		BOOL                    fDisplayAsIcon,
		HGLOBAL                 hMetaPict,
		LPSTR                   lpszStgName
);
LPCONTAINERLINE ContainerLine_CreateFromData(
		HDC                     hDC,
		UINT                    nTab,
		LPCONTAINERDOC          lpContainerDoc,
		LPDATAOBJECT            lpSrcDataObj,
		DWORD                   dwCreateType,
		CLIPFORMAT              cfFormat,
		BOOL                    fDisplayAsIcon,
		HGLOBAL                 hMetaPict,
		LPSTR                   lpszStgName
);
ULONG ContainerLine_AddRef(LPCONTAINERLINE lpContainerLine);
ULONG ContainerLine_Release(LPCONTAINERLINE lpContainerLine);
HRESULT ContainerLine_QueryInterface(
		LPCONTAINERLINE         lpContainerLine,
		REFIID                  riid,
		LPVOID FAR*             lplpUnk
);
BOOL ContainerLine_CloseOleObject(
		LPCONTAINERLINE         lpContainerLine,
		DWORD                   dwSaveOption
);
void ContainerLine_UnloadOleObject(
		LPCONTAINERLINE         lpContainerLine,
		DWORD                   dwSaveOption
);
void ContainerLine_Delete(LPCONTAINERLINE lpContainerLine);
void ContainerLine_Destroy(LPCONTAINERLINE lpContainerLine);
BOOL ContainerLine_CopyToDoc(
		LPCONTAINERLINE         lpSrcLine,
		LPOUTLINEDOC            lpDestDoc,
		int                     nIndex
);
BOOL ContainerLine_LoadOleObject(LPCONTAINERLINE lpContainerLine);
BOOL ContainerLine_UpdateExtent(
		LPCONTAINERLINE     lpContainerLine,
		LPSIZEL             lpsizelHim
);
BOOL ContainerLine_DoVerb(
		LPCONTAINERLINE lpContainerLine,
		LONG iVerb,
		LPMSG lpMsg,
		BOOL fMessage,
		BOOL fAction
);
LPUNKNOWN ContainerLine_GetOleObject(
		LPCONTAINERLINE         lpContainerLine,
		REFIID                  riid
);
HRESULT ContainerLine_RunOleObject(LPCONTAINERLINE lpContainerLine);
BOOL ContainerLine_ProcessOleRunError(
		LPCONTAINERLINE         lpContainerLine,
		HRESULT                 hrErr,
		BOOL                    fAction,
		BOOL                    fMenuInvoked
);
HRESULT ContainerLine_ReCreateLinkBecauseClassDiff(
		LPCONTAINERLINE lpContainerLine
);
BOOL ContainerLine_IsOleLink(LPCONTAINERLINE lpContainerLine);
void ContainerLine_BindLinkIfLinkSrcIsRunning(LPCONTAINERLINE lpContainerLine);
void ContainerLine_Draw(
		LPCONTAINERLINE         lpContainerLine,
		HDC                     hDC,
		LPRECT                  lpRect,
		LPRECT                  lpRectWBounds,
		BOOL                    fHighlight

);
void ContainerLine_DrawSelHilight(
		LPCONTAINERLINE lpContainerLine,
		HDC             hDC,
		LPRECT          lpRect,
		UINT            itemAction,
		UINT            itemState
);
BOOL ContainerLine_Edit(LPCONTAINERLINE lpContainerLine,HWND hWndDoc,HDC hDC);
void ContainerLine_SetHeightInHimetric(LPCONTAINERLINE lpContainerLine, int nHeight);
void ContainerLine_SetLineHeightFromObjectExtent(
		LPCONTAINERLINE         lpContainerLine,
		LPSIZEL                 lpsizelOleObject
);
BOOL ContainerLine_SaveToStm(
		LPCONTAINERLINE         lpContainerLine,
		LPSTREAM                lpLLStm
);
BOOL ContainerLine_SaveOleObjectToStg(
		LPCONTAINERLINE         lpContainerLine,
		LPSTORAGE               lpSrcStg,
		LPSTORAGE               lpDestStg,
		BOOL                    fRemember
);
LPLINE ContainerLine_LoadFromStg(
		LPSTORAGE               lpSrcStg,
		LPSTREAM                lpLLStm,
		LPOUTLINEDOC            lpDestDoc
);
LPMONIKER ContainerLine_GetRelMoniker(
		LPCONTAINERLINE         lpContainerLine,
		DWORD                   dwAssign
);
LPMONIKER ContainerLine_GetFullMoniker(
		LPCONTAINERLINE         lpContainerLine,
		DWORD                   dwAssign
);
int ContainerLine_GetTextLen(LPCONTAINERLINE lpContainerLine);
void ContainerLine_GetTextData(LPCONTAINERLINE lpContainerLine,LPSTR lpszBuf);
BOOL ContainerLine_GetOutlineData(
		LPCONTAINERLINE         lpContainerLine,
		LPTEXTLINE              lpBuf
);
void ContainerLine_GetOleObjectRectInPixels(
		LPCONTAINERLINE lpContainerLine,
		LPRECT lprc
);
void ContainerLine_GetPosRect(
		LPCONTAINERLINE     lpContainerLine,
		LPRECT              lprcPosRect
);
void ContainerLine_GetOleObjectSizeInHimetric(
		LPCONTAINERLINE lpContainerLine,
		LPSIZEL lpsizel
);

#if defined( INPLACE_CNTR )
void ContainerLine_UIDeactivate(LPCONTAINERLINE lpContainerLine);
void ContainerLine_InPlaceDeactivate(LPCONTAINERLINE lpContainerLine);
void ContainerLine_UpdateInPlaceObjectRects(
	LPCONTAINERLINE lpContainerLine,
	LPRECT          lprcClipRect
);
void ContainerLine_ContextSensitiveHelp(
		LPCONTAINERLINE lpContainerLine,
		BOOL            fEnterMode
);
void ContainerLine_ForwardPaletteChangedMsg(
		LPCONTAINERLINE lpContainerLine,
		HWND             hwndPalChg
);
void ContainerDoc_ContextSensitiveHelp(
		LPCONTAINERDOC  lpContainerDoc,
		BOOL            fEnterMode,
		BOOL            fInitiatedByObj
);
void ContainerDoc_ForwardPaletteChangedMsg(
		LPCONTAINERDOC  lpContainerDoc,
		HWND            hwndPalChg
);
#endif  // INPLACE_CNTR

/* ContainerLine::IUnknown methods (functions) */
STDMETHODIMP CntrLine_Unk_QueryInterface(
		LPUNKNOWN           lpThis,
		REFIID              riid,
		LPVOID FAR*         lplpvObj
);
STDMETHODIMP_(ULONG) CntrLine_Unk_AddRef(LPUNKNOWN lpThis);
STDMETHODIMP_(ULONG) CntrLine_Unk_Release(LPUNKNOWN lpThis);

/* ContainerLine::IOleClientSite methods (functions) */
STDMETHODIMP CntrLine_CliSite_QueryInterface(
		LPOLECLIENTSITE     lpThis,
		REFIID              riid,
		LPVOID FAR*         lplpvObj
);
STDMETHODIMP_(ULONG) CntrLine_CliSite_AddRef(LPOLECLIENTSITE lpThis);
STDMETHODIMP_(ULONG) CntrLine_CliSite_Release(LPOLECLIENTSITE lpThis);
STDMETHODIMP CntrLine_CliSite_SaveObject(LPOLECLIENTSITE lpThis);
STDMETHODIMP CntrLine_CliSite_GetMoniker(
		LPOLECLIENTSITE     lpThis,
		DWORD               dwAssign,
		DWORD               dwWhichMoniker,
		LPMONIKER FAR*      lplpmk
);
STDMETHODIMP CntrLine_CliSite_GetContainer(
		LPOLECLIENTSITE     lpThis,
		LPOLECONTAINER FAR* lplpContainer
);
STDMETHODIMP CntrLine_CliSite_ShowObject(LPOLECLIENTSITE lpThis);
STDMETHODIMP CntrLine_CliSite_OnShowWindow(LPOLECLIENTSITE lpThis,BOOL fShow);
STDMETHODIMP CntrLine_CliSite_RequestNewObjectLayout(LPOLECLIENTSITE lpThis);

/* ContainerLine::IAdviseSink methods (functions) */
STDMETHODIMP CntrLine_AdvSink_QueryInterface(
		LPADVISESINK        lpThis,
		REFIID              riid,
		LPVOID FAR*         lplpvObj
);
STDMETHODIMP_(ULONG) CntrLine_AdvSink_AddRef(LPADVISESINK lpThis);
STDMETHODIMP_(ULONG) CntrLine_AdvSink_Release (LPADVISESINK lpThis);
STDMETHODIMP_(void) CntrLine_AdvSink_OnDataChange(
		LPADVISESINK        lpThis,
		FORMATETC FAR*      lpFormatetc,
		STGMEDIUM FAR*      lpStgmed
);
STDMETHODIMP_(void) CntrLine_AdvSink_OnViewChange(
		LPADVISESINK        lpThis,
		DWORD               aspects,
		LONG                lindex
);
STDMETHODIMP_(void) CntrLine_AdvSink_OnRename(
		LPADVISESINK        lpThis,
		LPMONIKER           lpmk
);
STDMETHODIMP_(void) CntrLine_AdvSink_OnSave(LPADVISESINK lpThis);
STDMETHODIMP_(void) CntrLine_AdvSink_OnClose(LPADVISESINK lpThis);

#if defined( INPLACE_CNTR )
/* ContainerLine::IOleInPlaceSite methods (functions) */

STDMETHODIMP CntrLine_IPSite_QueryInterface(
		LPOLEINPLACESITE    lpThis,
		REFIID              riid,
		LPVOID FAR*         lplpvObj
);
STDMETHODIMP_(ULONG) CntrLine_IPSite_AddRef(LPOLEINPLACESITE lpThis);
STDMETHODIMP_(ULONG) CntrLine_IPSite_Release(LPOLEINPLACESITE lpThis);
STDMETHODIMP CntrLine_IPSite_GetWindow(
		LPOLEINPLACESITE    lpThis,
		HWND FAR*           lphwnd
);
STDMETHODIMP CntrLine_IPSite_ContextSensitiveHelp(
	LPOLEINPLACESITE    lpThis,
	BOOL                fEnterMode
);
STDMETHODIMP CntrLine_IPSite_CanInPlaceActivate(LPOLEINPLACESITE lpThis);
STDMETHODIMP CntrLine_IPSite_OnInPlaceActivate(LPOLEINPLACESITE lpThis);
STDMETHODIMP CntrLine_IPSite_OnUIActivate (LPOLEINPLACESITE lpThis);
STDMETHODIMP CntrLine_IPSite_GetWindowContext(
	LPOLEINPLACESITE            lpThis,
	LPOLEINPLACEFRAME FAR*      lplpFrame,
	LPOLEINPLACEUIWINDOW FAR*   lplpDoc,
	LPRECT                      lprcPosRect,
	LPRECT                      lprcClipRect,
	LPOLEINPLACEFRAMEINFO       lpFrameInfo
);
STDMETHODIMP CntrLine_IPSite_Scroll(
	LPOLEINPLACESITE    lpThis,
	SIZE                scrollExtent
);
STDMETHODIMP CntrLine_IPSite_OnUIDeactivate(
	LPOLEINPLACESITE    lpThis,
	BOOL                fUndoable
);
STDMETHODIMP CntrLine_IPSite_OnInPlaceDeactivate(LPOLEINPLACESITE lpThis);
STDMETHODIMP CntrLine_IPSite_DiscardUndoState(LPOLEINPLACESITE lpThis);
STDMETHODIMP CntrLine_IPSite_DeactivateAndUndo(LPOLEINPLACESITE lpThis);
STDMETHODIMP CntrLine_IPSite_OnPosRectChange(
	LPOLEINPLACESITE    lpThis,
	LPCRECT             lprcPosRect
);
#endif  // INPLACE_CNTR


/* struct definition for persistant data storage of ContainerLine */

#pragma pack(push, 2)
typedef struct tagCONTAINERLINERECORD_ONDISK
{
    	char    m_szStgName[CWCSTORAGENAME]; // stg name w/i cntr stg
	USHORT  m_fMonikerAssigned;          // has a moniker been assigned to obj
	DWORD   m_dwDrawAspect;              // current display aspect for obj
										 //     (either DVASPECT_CONTENT or
										 //     DVASPECT_ICON)
	SIZEL   m_sizeInHimetric;            // extents of obj in himetric units
	DWORD   m_dwLinkType;                // is it a linked object?
										 //  0 -- NOT a link
										 //  OLEUPDATE_ALWAYS (1) -- auto link
										 //  OLEUPDATE_ONCALL (3) -- man. link
	USHORT  m_fDoSetExtent;              // obj was resized when not running
										 //  IOO::SetExtent needed on next run
} CONTAINERLINERECORD_ONDISK, FAR* LPCONTAINERLINERECORD_ONDISK;
#pragma pack(pop)

typedef struct tagCONTAINERLINERECORD {
	char    m_szStgName[CWCSTORAGENAME]; // stg name w/i cntr stg
	BOOL    m_fMonikerAssigned;          // has a moniker been assigned to obj
	DWORD   m_dwDrawAspect;              // current display aspect for obj
										 //     (either DVASPECT_CONTENT or
										 //     DVASPECT_ICON)
	SIZEL   m_sizeInHimetric;            // extents of obj in himetric units
	DWORD   m_dwLinkType;                // is it a linked object?
										 //  0 -- NOT a link
										 //  OLEUPDATE_ALWAYS (1) -- auto link
										 //  OLEUPDATE_ONCALL (3) -- man. link
	BOOL    m_fDoSetExtent;              // obj was resized when not running
										 //  IOO::SetExtent needed on next run
} CONTAINERLINERECORD, FAR* LPCONTAINERLINERECORD;


/*************************************************************************
** class CONTAINERDOC : OUTLINEDOC
**    CONTAINERDOC is an extention to the base OUTLINEDOC object (structure)
**    that adds OLE 2.0 Container functionality. There is one instance of
**    CONTAINERDOC object created per document open in the app. The SDI
**    version of the app supports one CONTAINERDOC at a time. The MDI
**    version of the app can manage multiple documents at one time.
**    The CONTAINERDOC class inherits all fields
**    from the OUTLINEDOC class. This inheritance is achieved by including a
**    member variable of type OUTLINEDOC as the first field in the
**    CONTAINERDOC structure. Thus a pointer to a CONTAINERDOC object
**    can be cast to be a pointer to a OUTLINEDOC object.
*************************************************************************/

typedef struct tagCONTAINERDOC {
	OLEDOC      m_OleDoc;       // ContainerDoc inherits all fields of OleDoc
	ULONG       m_nNextObjNo;   // next available obj no. for stg name
	LPSTORAGE   m_lpNewStg;     // holds new pStg when SaveAs is pending
	BOOL        m_fEmbeddedObjectAvail; // is single OLE embed copied to doc
	CLSID       m_clsidOleObjCopied;    // if obj copied, CLSID of obj
	DWORD       m_dwAspectOleObjCopied; // if obj copied, draw aspect of obj
	LPCONTAINERLINE m_lpSrcContainerLine;  // src line if doc created for copy
	BOOL        m_fShowObject;          // show object flag

#if defined( INPLACE_CNTR )
	LPCONTAINERLINE m_lpLastIpActiveLine;   // last in-place active line
	LPCONTAINERLINE m_lpLastUIActiveLine;   // last UIActive line
	HWND            m_hWndUIActiveObj;      // HWND of UIActive obj.
	BOOL            m_fAddMyUI;             // if adding tools/menu postponed
	int             m_cIPActiveObjects;

#if defined( INPLACE_CNTRSVR )
	LPOLEINPLACEFRAME m_lpTopIPFrame;       // ptr to Top In-place frame.
	LPOLEINPLACEFRAME m_lpTopIPDoc;         // ptr to Top In-place Doc window.
	HMENU             m_hSharedMenu;        // combined obj/cntr menu
											// NULL if we are top container
	HOLEMENU        m_hOleMenu;             // returned by OleCreateMenuDesc.
											// NULL if we are top container
#endif  // INPLACE_CNTRSVR
#endif  // INPLACE_CNTR

	struct CDocOleUILinkContainerImpl {
		IOleUILinkContainerVtbl FAR*  lpVtbl;
		LPCONTAINERDOC                lpContainerDoc;
		int                           cRef;   // interface specific ref count.
	} m_OleUILinkContainer;

} CONTAINERDOC;

/* ContainerDoc methods (functions) */
BOOL ContainerDoc_Init(LPCONTAINERDOC lpContainerDoc, BOOL fDataTransferDoc);
LPCONTAINERLINE ContainerDoc_GetNextLink(
		LPCONTAINERDOC lpContainerDoc,
		LPCONTAINERLINE lpContainerLine
);
void ContainerDoc_UpdateLinks(LPCONTAINERDOC lpContainerDoc);
void ContainerDoc_SetShowObjectFlag(LPCONTAINERDOC lpContainerDoc, BOOL fShow);
BOOL ContainerDoc_GetShowObjectFlag(LPCONTAINERDOC lpContainerDoc);
void ContainerDoc_InsertOleObjectCommand(LPCONTAINERDOC lpContainerDoc);
void ContainerDoc_EditLinksCommand(LPCONTAINERDOC lpContainerDoc);
void ContainerDoc_PasteLinkCommand(LPCONTAINERDOC lpContainerDoc);
void ContainerDoc_ConvertCommand(
		LPCONTAINERDOC      lpContainerDoc,
		BOOL                fServerNotRegistered
);
BOOL ContainerDoc_PasteFormatFromData(
		LPCONTAINERDOC          lpContainerDoc,
		CLIPFORMAT              cfFormat,
		LPDATAOBJECT            lpSrcDataObj,
		BOOL                    fLocalDataObj,
		BOOL                    fLink,
		BOOL                    fDisplayAsIcon,
		HGLOBAL                 hMetaPict,
		LPSIZEL                 lpSizelInSrc
);
int ContainerDoc_PasteCntrOutlData(
		LPCONTAINERDOC          lpDestContainerDoc,
		LPSTORAGE               lpSrcStg,
		int                     nStartIndex
);
BOOL ContainerDoc_QueryPasteFromData(
		LPCONTAINERDOC          lpContainerDoc,
		LPDATAOBJECT            lpSrcDataObj,
		BOOL                    fLink
);
int ContainerDoc_PasteOleObject(
		LPCONTAINERDOC          lpContainerDoc,
		LPDATAOBJECT            lpSrcDataObj,
		DWORD                   dwCreateType,
		CLIPFORMAT              cfFormat,
		int                     nIndex,
		BOOL                    fDisplayAsIcon,
		HGLOBAL                 hMetaPict,
		LPSIZEL                 lpSizelInSrc
);
BOOL ContainerDoc_CloseAllOleObjects(
		LPCONTAINERDOC          lpContainerDoc,
		DWORD                   dwSaveOption
);
void ContainerDoc_UnloadAllOleObjectsOfClass(
		LPCONTAINERDOC      lpContainerDoc,
		REFCLSID            rClsid,
		DWORD               dwSaveOption
);
void ContainerDoc_InformAllOleObjectsDocRenamed(
		LPCONTAINERDOC          lpContainerDoc,
		LPMONIKER               lpmkDoc
);
void ContainerDoc_UpdateExtentOfAllOleObjects(LPCONTAINERDOC lpContainerDoc);
BOOL ContainerDoc_SaveToFile(
		LPCONTAINERDOC          lpContainerDoc,
		LPCSTR                  lpszFileName,
		UINT                    uFormat,
		BOOL                    fRemember
);
void ContainerDoc_ContainerLineDoVerbCommand(
		LPCONTAINERDOC          lpContainerDoc,
		LONG                    iVerb
);
void ContainerDoc_GetNextStgName(
		LPCONTAINERDOC          lpContainerDoc,
		LPSTR                   lpszStgName,
		int                     nLen
);
BOOL ContainerDoc_IsStgNameUsed(
		LPCONTAINERDOC          lpContainerDoc,
		LPSTR                   lpszStgName
);
LPSTORAGE ContainerDoc_GetStg(LPCONTAINERDOC lpContainerDoc);
HRESULT ContainerDoc_GetObject(
		LPCONTAINERDOC          lpContainerDoc,
		LPOLESTR		lpszItem,
		DWORD                   dwSpeedNeeded,
		REFIID                  riid,
		LPVOID FAR*             lplpvObject
);
HRESULT ContainerDoc_GetObjectStorage(
		LPCONTAINERDOC          lpContainerDoc,
		LPOLESTR		lpszItem,
		LPSTORAGE FAR*          lplpStg
);
HRESULT ContainerDoc_IsRunning(LPCONTAINERDOC	lpContainerDoc, LPOLESTR lpszItem);
LPUNKNOWN ContainerDoc_GetSingleOleObject(
		LPCONTAINERDOC          lpContainerDoc,
		REFIID                  riid,
		LPCONTAINERLINE FAR*    lplpContainerLine
);
BOOL ContainerDoc_IsSelAnOleObject(
		LPCONTAINERDOC          lpContainerDoc,
		REFIID                  riid,
		LPUNKNOWN FAR*          lplpvObj,
		int FAR*                lpnIndex,
		LPCONTAINERLINE FAR*    lplpContainerLine
);
HRESULT ContainerDoc_GetData (
		LPCONTAINERDOC          lpContainerDoc,
		LPFORMATETC             lpformatetc,
		LPSTGMEDIUM             lpMedium
);
HRESULT ContainerDoc_GetDataHere (
		LPCONTAINERDOC          lpContainerDoc,
		LPFORMATETC             lpformatetc,
		LPSTGMEDIUM             lpMedium
);
HRESULT ContainerDoc_QueryGetData (
		LPCONTAINERDOC          lpContainerDoc,
		LPFORMATETC             lpformatetc
);
HRESULT ContainerDoc_SetData (
		LPCONTAINERDOC          lpContainerDoc,
		LPFORMATETC             lpformatetc,
		LPSTGMEDIUM             lpmedium,
		BOOL                    fRelease
);
HRESULT ContainerDoc_EnumFormatEtc(
		LPCONTAINERDOC          lpContainerDoc,
		DWORD                   dwDirection,
		LPENUMFORMATETC FAR*    lplpenumFormatEtc
);
BOOL ContainerDoc_SetupDocGetFmts(
		LPCONTAINERDOC          lpContainerDoc,
		LPCONTAINERLINE         lpContainerLine
);

#if defined( INPLACE_CNTR )

void ContainerDoc_ShutDownLastInPlaceServerIfNotNeeded(
		LPCONTAINERDOC          lpContainerDoc,
		LPCONTAINERLINE         lpNextActiveLine
);
BOOL ContainerDoc_IsUIDeactivateNeeded(
		LPCONTAINERDOC  lpContainerDoc,
		POINT           pt
);
HWND ContainerDoc_GetUIActiveWindow(LPCONTAINERDOC lpContainerDoc);
void ContainerDoc_UpdateInPlaceObjectRects(LPCONTAINERDOC lpContainerDoc, int nIndex);
void ContainerDoc_GetClipRect(
		LPCONTAINERDOC      lpContainerDoc,
		LPRECT              lprcClipRect
);
void ContainerDoc_FrameWindowResized(LPCONTAINERDOC lpContainerDoc);
LPOLEINPLACEFRAME ContainerDoc_GetTopInPlaceFrame(
		LPCONTAINERDOC      lpContainerDoc
);
void ContainerDoc_GetSharedMenuHandles(
		LPCONTAINERDOC  lpContainerDoc,
		HMENU FAR*      lphSharedMenu,
		HOLEMENU FAR*   lphOleMenu
);
void ContainerDoc_RemoveFrameLevelTools(LPCONTAINERDOC lpContainerDoc);
void ContainerDoc_AddFrameLevelUI(LPCONTAINERDOC lpContainerDoc);
void ContainerDoc_AddFrameLevelTools(LPCONTAINERDOC lpContainerDoc);

#if defined( INPLACE_CNTRSVR ) || defined( INPLACE_MDICNTR )

LPOLEINPLACEUIWINDOW ContainerDoc_GetTopInPlaceDoc(
		LPCONTAINERDOC      lpContainerDoc
);
void ContainerDoc_RemoveDocLevelTools(LPCONTAINERDOC lpContainerDoc);
void ContainerDoc_AddDocLevelTools(LPCONTAINERDOC lpContainerDoc);

#endif  // INPLACE_CNTRSVR || INPLACE_MDICNTR
#endif  // INPLACE_CNTR

/* ContainerDoc::IOleUILinkContainer methods (functions) */
STDMETHODIMP CntrDoc_LinkCont_QueryInterface(
		LPOLEUILINKCONTAINER    lpThis,
		REFIID                  riid,
		LPVOID FAR*             lplpvObj
);
STDMETHODIMP_(ULONG) CntrDoc_LinkCont_AddRef(LPOLEUILINKCONTAINER lpThis);
STDMETHODIMP_(ULONG) CntrDoc_LinkCont_Release(LPOLEUILINKCONTAINER lpThis);
STDMETHODIMP_(DWORD) CntrDoc_LinkCont_GetNextLink(
		LPOLEUILINKCONTAINER    lpThis,
		DWORD                   dwLink
);
STDMETHODIMP CntrDoc_LinkCont_SetLinkUpdateOptions(
		LPOLEUILINKCONTAINER    lpThis,
		DWORD                   dwLink,
		DWORD                   dwUpdateOpt
);
STDMETHODIMP CntrDoc_LinkCont_GetLinkUpdateOptions(
		LPOLEUILINKCONTAINER    lpThis,
		DWORD                   dwLink,
		DWORD FAR*              dwUpdateOpt
);

STDMETHODIMP CntrDoc_LinkCont_SetLinkSource(
		LPOLEUILINKCONTAINER    lpThis,
		DWORD                   dwLink,
		LPSTR                   lpszDisplayName,
		ULONG                   clenFileName,
		ULONG FAR*              lpchEaten,
		BOOL                    fValidateSource
);
STDMETHODIMP CntrDoc_LinkCont_GetLinkSource(
		LPOLEUILINKCONTAINER    lpThis,
		DWORD                   dwLink,
		LPSTR FAR*              lplpszDisplayName,
		ULONG FAR*              lplenFileName,
		LPSTR FAR*              lplpszFullLinkType,
		LPSTR FAR*              lplpszShortLinkType,
		BOOL FAR*               lpfSourceAvailable,
		BOOL FAR*               lpfIsSelected
);
STDMETHODIMP CntrDoc_LinkCont_OpenLinkSource(
		LPOLEUILINKCONTAINER    lpThis,
		DWORD                   dwLink
);
STDMETHODIMP CntrDoc_LinkCont_UpdateLink(
		LPOLEUILINKCONTAINER    lpThis,
		DWORD                   dwLink,
		BOOL                    fErrorMessage,
		BOOL                    fErrorAction
);
STDMETHODIMP CntrDoc_LinkCont_CancelLink(
		LPOLEUILINKCONTAINER    lpThis,
		DWORD                   dwLink
);



/*************************************************************************
** class CONTAINERAPP : OLEAPP
**    CONTAINERAPP is an extention to the base OLEAPP object (structure)
**    that adds special Container functionality. There is one instance of
**    CONTAINERApp object created per running application instance. This
**    object holds many fields that could otherwise be organized as
**    global variables. The CONTAINERAPP class inherits all fields
**    from the OLEAPP class. This inheritance is achieved by including a
**    member variable of type OLEAPP as the first field in the CONTAINERAPP
**    structure. OLEAPP inherits from OUTLINEAPP. This inheritance is
**    achieved in the same manner. Thus a pointer to a CONTAINERAPP object
**    can be cast to be a pointer to an OLEAPP or an OUTLINEAPP object
*************************************************************************/

/* Forward definition of types */
typedef struct tagCONTAINERAPP FAR* LPCONTAINERAPP;

typedef struct tagCONTAINERAPP {
	OLEAPP  m_OleApp;       // ContainerApp inherits all fields of OleApp
	UINT    m_cfCntrOutl;   // clipboard format for CntrOutl (client ver) data
	int     m_nSingleObjGetFmts; // no. formats avail when single obj copied
	FORMATETC m_arrSingleObjGetFmts[MAXNOFMTS];
										// array of FormatEtc's available via
										// IDataObject::GetData when a single
										// OLE object is copied.

#if defined( INPLACE_CNTR )
	HACCEL  m_hAccelIPCntr; // accelerators for container's workspace commands
	HMENU   m_hMenuFile;    // handle to File menu of container app
	HMENU   m_hMenuView;    // handle to View menu of container app
	HMENU   m_hMenuDebug;   // handle to Debug menu of container app
	LPOLEINPLACEACTIVEOBJECT m_lpIPActiveObj; // ptr to inplace active OLE obj
	HWND    m_hWndUIActiveObj;      // HWND of UIActive obj.
	BOOL    m_fPendingUIDeactivate; // should app UIDeactivate on LBUTTONUP
	BOOL    m_fMustResizeClientArea;// if client area resize pending
									//  (see Doc_FrameWindowResized)
	BOOL    m_fMenuHelpMode;// is F1 pressed in menu, if so give help
#ifdef _DEBUG
	BOOL    m_fOutSideIn;
#endif

	struct COleInPlaceFrameImpl {
		IOleInPlaceFrameVtbl FAR* lpVtbl;
		LPCONTAINERAPP          lpContainerApp;
		int                     cRef;   // interface specific ref count.
	} m_OleInPlaceFrame;

#endif  // INPLACE_CNTR

} CONTAINERAPP;

/* ContainerApp methods (functions) */
BOOL ContainerApp_InitInstance(
		LPCONTAINERAPP          lpContainerApp,
		HINSTANCE               hInst,
		int                     nCmdShow
);
BOOL ContainerApp_InitVtbls(LPCONTAINERAPP lpApp);

#if defined( INPLACE_CNTR )

/* ContainerApp::IOleInPlaceFrame methods (functions) */

STDMETHODIMP CntrApp_IPFrame_QueryInterface(
		LPOLEINPLACEFRAME   lpThis,
		REFIID              riid,
		LPVOID FAR*         lplpvObj
);
STDMETHODIMP_(ULONG) CntrApp_IPFrame_AddRef(LPOLEINPLACEFRAME lpThis);
STDMETHODIMP_(ULONG) CntrApp_IPFrame_Release(LPOLEINPLACEFRAME lpThis);
STDMETHODIMP CntrApp_IPFrame_GetWindow(
	LPOLEINPLACEFRAME   lpThis,
	HWND FAR*           lphwnd
);
STDMETHODIMP CntrApp_IPFrame_ContextSensitiveHelp(
	LPOLEINPLACEFRAME   lpThis,
	BOOL                fEnterMode
);
STDMETHODIMP CntrApp_IPFrame_GetBorder(
	LPOLEINPLACEFRAME   lpThis,
	LPRECT              lprectBorder
);
STDMETHODIMP CntrApp_IPFrame_RequestBorderSpace(
	LPOLEINPLACEFRAME   lpThis,
	LPCBORDERWIDTHS     lpWidths
);
STDMETHODIMP CntrApp_IPFrame_SetBorderSpace(
	LPOLEINPLACEFRAME   lpThis,
	LPCBORDERWIDTHS     lpWidths
);
STDMETHODIMP CntrApp_IPFrame_SetActiveObject(
	LPOLEINPLACEFRAME           lpThis,
	LPOLEINPLACEACTIVEOBJECT    lpActiveObject,
	LPCOLESTR		    lpszObjName
);
STDMETHODIMP CntrApp_IPFrame_InsertMenus(
	LPOLEINPLACEFRAME       lpThis,
	HMENU                   hmenu,
	LPOLEMENUGROUPWIDTHS    lpMenuWidths
);
STDMETHODIMP CntrApp_IPFrame_SetMenu(
	LPOLEINPLACEFRAME   lpThis,
	HMENU               hmenuShared,
	HOLEMENU            holemenu,
	HWND                hwndActiveObject
);
STDMETHODIMP CntrApp_IPFrame_RemoveMenus(
	LPOLEINPLACEFRAME   lpThis,
	HMENU               hmenu
);
STDMETHODIMP CntrApp_IPFrame_SetStatusText(
	LPOLEINPLACEFRAME   lpThis,
	LPCOLESTR	    lpszStatusText
);
STDMETHODIMP CntrApp_IPFrame_EnableModeless(
	LPOLEINPLACEFRAME   lpThis,
	BOOL                fEnable
);
STDMETHODIMP CntrApp_IPFrame_TranslateAccelerator(
	LPOLEINPLACEFRAME   lpThis,
	LPMSG               lpmsg,
	WORD                wID
);

#endif  // INPLACE_CNTR


#endif // _CNTROUTL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\letest\outline\debug.c ===
/*************************************************************************
**
**    OLE 2 Sample Code
**
**    debug.c
**
**    This file contains some functions for debugging support
**
**    (c) Copyright Microsoft Corp. 1992 - 1993 All Rights Reserved
**
*************************************************************************/

#include "outline.h"

OLEDBGDATA

extern LPOUTLINEAPP g_lpApp;

void SetDebugLevelCommand(void)
{
	char szBuf[80];
	HWND hWndFrame = OutlineApp_GetFrameWindow(g_lpApp);

	wsprintf(szBuf, "%d", OleDbgGetDbgLevel());

	if (InputTextDlg(hWndFrame, szBuf, "Debug Level [0-4]")) {
		switch (szBuf[0]) {
			case '0':
				OleDbgSetDbgLevel(0);
				break;
			case '1':
				OleDbgSetDbgLevel(1);
				break;
			case '2':
				OleDbgSetDbgLevel(2);
				break;
			case '3':
				OleDbgSetDbgLevel(3);
				break;
			case '4':
				OleDbgSetDbgLevel(4);
				break;
			default:
				OutlineApp_ErrorMessage(g_lpApp, "Valid Debug Level Range: 0-4");
				break;
		}
	}
}


#if defined( OLE_VERSION )

/* InstallMessageFilterCommand
 * ---------------------------
 *
 * Handles the "Install Message Filter" menu item.  If a message filter is
 * already installed, this function de-installs it.  If there is not one
 * already installed, this function installs one.
 *
 */

void InstallMessageFilterCommand(void)
{
	LPOLEAPP lpOleApp = (LPOLEAPP)g_lpApp;

	/*
	** Check to see if we've already installed a MessageFilter.
	** If so, uninstall it.
	*/
	if (lpOleApp->m_lpMsgFilter != NULL)
		OleApp_RevokeMessageFilter(lpOleApp);
	else
		OleApp_RegisterMessageFilter(lpOleApp);
}


/* RejectIncomingCommand
 * ---------------------
 *
 * Toggles between rejecting and not-handling in coming LRPC calls
 *
 */

void RejectIncomingCommand(void)
{
	DWORD dwOldStatus;
	DWORD dwNewStatus;
	LPOLEAPP lpOleApp = (LPOLEAPP)g_lpApp;

	dwOldStatus = OleStdMsgFilter_GetInComingCallStatus(lpOleApp->m_lpMsgFilter);

	if (dwOldStatus == SERVERCALL_RETRYLATER)
		dwNewStatus = SERVERCALL_ISHANDLED;
	else
		dwNewStatus = SERVERCALL_RETRYLATER;

	OleStdMsgFilter_SetInComingCallStatus(lpOleApp->m_lpMsgFilter, dwNewStatus);
}

#endif  // OLE_VERSION
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\letest\outline\debug2.c ===
/*************************************************************************
**
**    OLE 2 Sample Code
**
**    debug2.c
**
**    This file contains various debug / subclass routines for the
**    ABOUT dialog
**
**    (c) Copyright Microsoft Corp. 1992 - 1993 All Rights Reserved
**
*************************************************************************/

#include "outline.h"
#include <stdlib.h>
#include <time.h>

extern LPOUTLINEAPP g_lpApp;

LONG CALLBACK EXPORT DebugAbout(HWND hWnd, unsigned uMsg, WORD wParam, LONG lParam);
void RandomizeStars(HDC hDC);
BOOL InitStrings(void);
BOOL DrawString(int iCount, HDC hDC, LPRECT rcDrawIn);

static FARPROC lpRealAboutProc = 0L;
static int width, height;
static RECT rc;
static HANDLE hStrBlock = NULL;
static LPSTR lpStrings = NULL;
static WORD       wLineHeight;


/* TraceDebug
 * ----------
 *
 * Called once when our About Box's gets the INITDIALOG message.  Subclasses
 * dialog.
 */

void TraceDebug(HWND hDlg, int iControl)
{

	// Load strings, if the strings aren't there, then don't subclass
	// the dialog
	if (InitStrings() != TRUE)
		return;

	// Subclass the dialog
	lpRealAboutProc = (FARPROC)(LONG_PTR)GetWindowLongPtr(hDlg, GWLP_WNDPROC);
	SetWindowLongPtr(hDlg, GWLP_WNDPROC, (LONG_PTR)(FARPROC)DebugAbout);

	// Get rect of control in screen coords, and translate to our dialog
	// box's coordinates
	GetWindowRect(GetDlgItem(hDlg, iControl), &rc);
	MapWindowPoints(NULL, hDlg, (LPPOINT)&rc, 2);

	width  = rc.right - rc.left;
	height = rc.bottom - rc.top;
}

/* DebugAbout
 * ----------
 *
 * The subclassed About dialog's main window proc.
 */

LONG CALLBACK EXPORT DebugAbout(HWND hWnd, unsigned uMsg, WORD wParam, LONG lParam)
{
	RECT              rcOut;
	static BOOL       bTimerStarted = FALSE;
	static int        iTopLocation;
	HDC               hDCScr;
	static HDC        hDCMem;
	static HBITMAP    hBitmap;
	static HBITMAP    hBitmapOld;
	static RECT       rcMem;
	static HFONT      hFont;

	switch (uMsg)
	{

	/*
	 * If we get a LBUTTONDBLCLICK in the upper left of
	 * the dialog, fire off the about box effects
	 */

	case WM_LBUTTONDBLCLK:
		if ((wParam & MK_CONTROL) && (wParam & MK_SHIFT)
			&& LOWORD(lParam) < 10 && HIWORD(lParam) < 10 &&
			bTimerStarted == FALSE)
			{
			if (SetTimer ( hWnd, 1, 10, NULL ))
				{
				LOGFONT lf;
				int i;

				bTimerStarted = TRUE;

				// "Open up" the window
				hDCScr = GetDC ( hWnd );
				hDCMem = CreateCompatibleDC     ( hDCScr );

				hBitmap = CreateCompatibleBitmap(hDCScr, width, height);
				hBitmapOld = SelectObject(hDCMem, hBitmap);

				// Blt from dialog to memDC
				BitBlt(hDCMem, 0, 0, width, height,
				hDCScr, rc.left, rc.top, SRCCOPY);

				for (i=0;i<height;i+=1)
				{
					BitBlt(hDCScr, rc.left, rc.top + i + 1, width, height-i-1, hDCMem, 0, 0, SRCCOPY);
					PatBlt(hDCScr, rc.left, rc.top + i, width, 1, BLACKNESS);
				}

				SelectObject(hDCMem, hBitmapOld);
				DeleteObject(hBitmap);

				// Set up memory DC with default attributes
				hBitmap   = CreateCompatibleBitmap(hDCScr, width, height);
				ReleaseDC(hWnd, hDCScr);

				hBitmapOld = SelectObject(hDCMem, hBitmap);

				SetBkMode(hDCMem, TRANSPARENT);
				SetBkColor(hDCMem, RGB(0,0,0));

				// Create font
				memset(&lf, 0, sizeof(LOGFONT));
				lf.lfHeight = -(height / 7); // Fit 7 lines of text in box
				lf.lfWeight = FW_BOLD;
				strcpy(lf.lfFaceName, "Arial");
				hFont = CreateFontIndirect(&lf);

				// If we can't create the font, revert and use the standard
				// system font.
				if (!hFont)
					GetObject(GetStockObject(SYSTEM_FONT), sizeof(LOGFONT), &lf);

				wLineHeight = abs(lf.lfHeight) + 5; // 5 pixels between lines

				// Set location of top of banner at bottom of the window
				iTopLocation = height + 50;

				SetRect(&rcMem, 0, 0, width, height);
				}
			}
			// Call our real window procedure in case they want to
			// handle LBUTTONDOWN messages also
			goto Default;

	case WM_TIMER:
		{
		int iCount;
		HFONT hfold;

		/*
		 * On each timer message, we are going to construct the next image
		 * in the animation sequence, then bitblt this to our dialog.
		 */

		// Clear out old bitmap and place random star image on background
		PatBlt(hDCMem, rcMem.left, rcMem.top, rcMem.right, rcMem.bottom, BLACKNESS);
		RandomizeStars(hDCMem);

		// Set initial location to draw text
		rcOut = rcMem;
		rcOut.top = 0 + iTopLocation;
		rcOut.bottom = rcOut.top + wLineHeight;

		iCount = 0;
		if (hFont) hfold = SelectObject(hDCMem, hFont);

		SetTextColor(hDCMem, RGB(0,255,0));
		while (DrawString(iCount, hDCMem, &rcOut) == TRUE)
			{
			rcOut.top    += wLineHeight;
			rcOut.bottom += wLineHeight;
			iCount++;
			}
		if (hFont) SelectObject(hDCMem, hfold);

		// Now blt the memory dc that we have just constructed
		// to the screen
		hDCScr = GetDC(hWnd);
		BitBlt(hDCScr, rc.left, rc.top, rc.right, rc.bottom,
			hDCMem, 0, 0, SRCCOPY);
		ReleaseDC(hWnd, hDCScr);

		// For the next animation sequence, we want to move the
		// whole thing up, so decrement the location of the top
		// of the banner

		iTopLocation -= 2;

		// If we've gone through the banner once, reset it
		if (iTopLocation < -(int)(wLineHeight * iCount))
			iTopLocation = height + 50;
		}
		// Goto default
		goto Default;

	case WM_NCDESTROY:
		{
		LONG defReturn;

		/*
		 * We're being destroyed.  Clean up what we created.
		 */

		if (bTimerStarted)
		{
			KillTimer(hWnd, 1);
			SelectObject (hDCMem, hBitmapOld);
			DeleteObject (hBitmap);
			DeleteDC (hDCMem);
			if (hFont) DeleteObject(hFont);
			bTimerStarted = FALSE;
		}

		if (lpStrings)
			UnlockResource(hStrBlock), lpStrings = NULL;
		if (hStrBlock)
			FreeResource(hStrBlock), hStrBlock = NULL;

		// Pass the NCDESTROY on to our real window procedure.  Since
		// this is the last message that we are going to be getting,
		// we can go ahead and free the proc instance here.

		defReturn = CallWindowProc((WNDPROC)lpRealAboutProc, hWnd,
					   uMsg, wParam, lParam);
		return defReturn;
		}

	Default:
	default:
		return CallWindowProc(
				(WNDPROC)lpRealAboutProc, hWnd, uMsg, wParam, lParam);
	}
	return 0L;
}


/* RandomizeStars
 * --------------
 *
 * Paints random stars on the specified hDC
 *
 */

void RandomizeStars(HDC hDC)
{
	int             i;

	// Seed the random number generator with current time.  This will,
	// in effect, only change the seed every second, so our
	// starfield will change only every second.
	srand((unsigned)time(NULL));

	// Generate random white stars
	for (i=0;i<20;i++)
		PatBlt(hDC, getrandom(0,width), getrandom(0,height), 2, 2, WHITENESS);
}

/* InitStrings
 * --------------
 *
 * Reads strings from stringtable.  Returns TRUE if it worked OK.
 *
 */

BOOL InitStrings()
{
	HRSRC hResStrings;
	LPSTR lpWalk;

	// Load the block of strings
	if ((hResStrings = FindResource(
			g_lpApp->m_hInst,
			MAKEINTRESOURCE(9999),
			RT_RCDATA)) == NULL)
		return FALSE;
	if ((hStrBlock = LoadResource(g_lpApp->m_hInst, hResStrings)) == NULL)
		return FALSE;
	if ((lpStrings = LockResource(hStrBlock)) == NULL)
		return FALSE;

	if (lpStrings && *(lpStrings+2)!=0x45)
		{
		lpWalk = lpStrings;
		while (*(LPWORD)lpWalk != (WORD)0x0000)
			{
			if (*lpWalk != (char)0x00)
				*lpWalk ^= 0x98;
			lpWalk++;
			}
		}
	return TRUE;
}

/* DrawString
 * ----------
 *
 * Draws the next string on the specified hDC using the
 * output rectangle.  If iCount == 0, reset to start of list.
 *
 * Returns: TRUE to contine, FALSE if we're done
 */

BOOL DrawString(int iCount, HDC hDC, LPRECT rcDrawIn)
{
	static LPSTR lpPtr = NULL;

	if (iCount == 0)
		// First time, reset pointer
		lpPtr = lpStrings;

	if (*lpPtr == '\0') // If we've hit a NULL string, we're done
		return FALSE;

	// If we're drawing outside of visible box, don't call DrawText
	if ((rcDrawIn->bottom > 0) && (rcDrawIn->top < height))
		DrawText(hDC, lpPtr, -1, rcDrawIn, DT_CENTER);

	// Advance pointer to next string
	lpPtr += lstrlen(lpPtr) + 1;

	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\letest\outline\defguid.h ===
/*************************************************************************
**
**    OLE 2.0 Sample Code
**
**    clsid.h
**
**    This file contains file contains GUID definitions used for the
**    OLE versions of OUTLINE.
**
**    (c) Copyright Microsoft Corp. 1992 - 1993 All Rights Reserved
**
*************************************************************************/

#if defined( OLE_SERVER ) || defined( OLE_CNTR )
// OLE2NOTE: We need access to these GUIDs in modules other than
//  where they are defined (MAIN.C).  Even though the values of the
//  GUIDs are duplicated here, they are not used.  Refer to MAIN.C
//  for the definition of these GUIDs.

/* CLASS ID CONSTANTS (GUID's)
**    OLE2NOTE: these class id values are allocated out of a private pool
**    of GUID's allocated to the OLE 2.0 development team. GUID's of
**    the following range have been allocated to OLE 2.0 sample code:
**         00000400-0000-0000-C000-000000000046
**         000004FF-0000-0000-C000-000000000046
**
**    values reserved thus far:
**          00000400                -- Ole 2.0 Server Sample Outline
**          00000401                -- Ole 2.0 Container Sample Outline
**          00000402                -- Ole 2.0 In-Place Server Outline
**          00000403                -- Ole 2.0 In-Place Container Outline
**          00000404 : 000004FE     -- reserved for OLE Sample code
**          000004FF                -- IID_IOleUILinkContainer
*/

DEFINE_GUID(CLSID_SvrOutl, 0x00000400, 0x0000, 0x0000, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46);
DEFINE_GUID(CLSID_CntrOutl, 0x00000401, 0x0000, 0x0000, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46);
DEFINE_GUID(CLSID_ISvrOtl, 0x00000402, 0x0000, 0x0000, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46);
DEFINE_GUID(CLSID_ICntrOtl, 0x00000403, 0x0000, 0x0000, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46);

#if defined( OLE_CNTR )
DEFINE_GUID(IID_IOleUILinkContainer, 0x000004FF, 0x0000, 0x0000, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x46);
#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\letest\outline\frametls.h ===
/*************************************************************************
**
**    OLE 2 Sample Code
**
**    frametls.h
**
**    This file contains file contains data structure defintions,
**    function prototypes, constants, etc. used by the frame level
**    tools used by the Outline series of sample applications. The
**    frame level tools include a formula bar and a button bar (toolbar)
**
**    (c) Copyright Microsoft Corp. 1992 - 1993 All Rights Reserved
**
*************************************************************************/

#if !defined( _FRAMETLS_H_ )
#define _FRAMETLS_H_

#ifndef RC_INVOKED
#pragma message ("INCLUDING FRAMETLS.H from " __FILE__)
#endif  /* RC_INVOKED */

#include "bttncur.h"
#include "gizmobar.h"

#define SPACE   5
#define POPUPSTUB_HEIGHT    5


/* forward type references */
typedef struct tagOUTLINEDOC FAR* LPOUTLINEDOC;

#define IDC_GIZMOBAR    1000
#define IDC_FORMULABAR  1001

#define IDB_CANCEL          0
#define IDB_EDITLINE        1
#define IDB_ADDLINE         2
#define IDB_UNINDENTLINE    3
#define IDB_INDENTLINE      4

#define BARSTATE_TOP        1
#define BARSTATE_BOTTOM     2
#define BARSTATE_POPUP      3
#define BARSTATE_HIDE       4

#define CLASS_PALETTE   "Tool Palette"

typedef struct tagBAR{
	UINT        m_uHeight;
	HWND        m_hWnd;
	int         m_nState;
} BAR, FAR* LPBAR;

typedef struct tagFRAMETOOLS {
	HWND        m_hWndPopupPalette;     // Popup Tool Palette window
	HWND        m_hWndApp;              // App Frame window
	UINT        m_uPopupWidth;          // Width of the popup palette
	HBITMAP     m_hBmp;                 // Image bitmaps
	BOOL        m_fInFormulaBar;        // does formula bar have edit focus
	BOOL        m_fToolsDisabled;       // when TRUE all tools are hidden

	BAR         m_ButtonBar;            // Button Bar
	BAR         m_FormulaBar;           // Formula Bar

	TOOLDISPLAYDATA m_tdd;      // from UIToolConfigureForDisplay
} FRAMETOOLS, FAR* LPFRAMETOOLS;


BOOL FrameToolsRegisterClass(HINSTANCE hInst);
BOOL FrameTools_Init(LPFRAMETOOLS lpft, HWND hWndParent, HINSTANCE hInst);
void FrameTools_AttachToFrame(LPFRAMETOOLS lpft, HWND hWndFrame);
void FrameTools_AssociateDoc(LPFRAMETOOLS lpft, LPOUTLINEDOC lpOutlineDoc);
void FrameTools_Destroy(LPFRAMETOOLS lpft);
void FrameTools_Move(LPFRAMETOOLS lpft, LPRECT lprcClient);
void FrameTools_PopupTools(LPFRAMETOOLS lpft);
void FrameTools_Enable(LPFRAMETOOLS lpft, BOOL fEnable);
void FrameTools_EnableWindow(LPFRAMETOOLS lpft, BOOL fEnable);

#if defined( INPLACE_CNTR ) || defined( INPLACE_SVR )
void FrameTools_NegotiateForSpaceAndShow(
		LPFRAMETOOLS            lpft,
		LPRECT                  lprcFrameRect,
		LPOLEINPLACEFRAME       lpTopIPFrame
);
#endif  // INPLACE_CNTR || INPLACE_SVR

void FrameTools_GetRequiredBorderSpace(LPFRAMETOOLS lpft, LPBORDERWIDTHS lpBorderWidths);

void FrameTools_UpdateButtons(LPFRAMETOOLS lpft, LPOUTLINEDOC lpOutlineDoc);
void FrameTools_FB_SetEditText(LPFRAMETOOLS lpft, LPSTR lpsz);
void FrameTools_FB_GetEditText(LPFRAMETOOLS lpft, LPSTR lpsz, UINT cch);
void FrameTools_FB_FocusEdit(LPFRAMETOOLS lpft);
void FrameTools_FB_SendMessage(LPFRAMETOOLS lpft, UINT uID, UINT msg, WPARAM wParam, LPARAM lParam);
void FrameTools_ForceRedraw(LPFRAMETOOLS lpft);
void FrameTools_BB_SetState(LPFRAMETOOLS lpft, int nState);
void FrameTools_FB_SetState(LPFRAMETOOLS lpft, int nState);
int FrameTools_BB_GetState(LPFRAMETOOLS lpft);
int FrameTools_FB_GetState(LPFRAMETOOLS lpft);
LRESULT FAR PASCAL FrameToolsWndProc(HWND hWnd, UINT Message, WPARAM wParam, LPARAM lParam);

#endif // _FRAMETLS_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\letest\outline\dialogs.c ===
/*************************************************************************
**
**    OLE 2 Sample Code
**
**    dialogs.c
**
**    This file contains dialog functions and support function
**
**    (c) Copyright Microsoft Corp. 1992 - 1993 All Rights Reserved
**
*************************************************************************/

#include "outline.h"

OLEDBGDATA

extern LPOUTLINEAPP g_lpApp;

static char g_szBuf[MAXSTRLEN+1];
static LPSTR g_lpszDlgTitle;

// REVIEW: should use string resource for messages
static char ErrMsgInvalidRange[] = "Invalid Range entered!";
static char ErrMsgInvalidValue[] = "Invalid Value entered!";
static char ErrMsgInvalidName[] = "Invalid Name entered!";
static char ErrMsgNullName[] = "NULL string disallowed!";
static char ErrMsgNameNotFound[] = "Name doesn't exist!";

/* InputTextDlg
 * ------------
 *
 *      Put up a dialog box to allow the user to edit text
 */
BOOL InputTextDlg(HWND hWnd, LPSTR lpszText, LPSTR lpszDlgTitle)
{
	int nResult;

	g_lpszDlgTitle = lpszDlgTitle;
	lstrcpy((LPSTR)g_szBuf, lpszText);  // preload dialog with input text

	nResult = DialogBox(g_lpApp->m_hInst, (LPSTR)"AddEditLine", hWnd,
						(DLGPROC)AddEditDlgProc);
	if (nResult) {
		lstrcpy(lpszText, (LPSTR)g_szBuf);
		return TRUE;
	} else {
		return FALSE;
	}
}



/* AddEditDlgProc
 * --------------
 *
 * This procedure is associated with the dialog box that is included in
 * the function name of the procedure. It provides the service routines
 * for the events (messages) that occur because the end user operates
 * one of the dialog box's buttons, entry fields, or controls.
 */
BOOL CALLBACK EXPORT AddEditDlgProc(HWND hDlg, UINT Message, WPARAM wParam, LPARAM lParam)
{
	HWND hEdit;

	switch(Message) {
		case WM_INITDIALOG:
			/* initialize working variables */
			hEdit=GetDlgItem(hDlg,IDD_EDIT);
			SendMessage(hEdit,EM_LIMITTEXT,(WPARAM)MAXSTRLEN,0L);
			SetWindowText(hDlg, g_lpszDlgTitle);
			SetDlgItemText(hDlg,IDD_EDIT, g_szBuf);
			break; /* End of WM_INITDIALOG */

		case WM_CLOSE:
			/* Closing the Dialog behaves the same as Cancel */
			PostMessage(hDlg, WM_COMMAND, IDCANCEL, 0L);
			break; /* End of WM_CLOSE */

		case WM_COMMAND:
			switch (wParam) {
				case IDOK:
					/* save data values entered into the controls
					** and dismiss the dialog box returning TRUE
					*/
					GetDlgItemText(hDlg,IDD_EDIT,(LPSTR)g_szBuf,MAXSTRLEN+1);
					EndDialog(hDlg, TRUE);
					break;

				case IDCANCEL:
					/* ignore data values entered into the controls
					** and dismiss the dialog box returning FALSE
					*/
					EndDialog(hDlg, FALSE);
					break;
			}
			break;    /* End of WM_COMMAND */

		default:
			return FALSE;
	}

	return TRUE;
} /* End of AddEditDlgProc */


/* SetLineHeightDlgProc
 * --------------------
 *
 *      Dialog procedure for set line height
 */
BOOL CALLBACK EXPORT SetLineHeightDlgProc(HWND hDlg, UINT Message, WPARAM wParam, LPARAM lParam)
{
	BOOL    fTranslated;
	BOOL    fEnable;
	static LPINT    lpint;
	int     nHeight;
	static int nMaxHeight;

	switch (Message) {
		case WM_INITDIALOG:
		{
			char cBuf[80];

			nMaxHeight = XformHeightInPixelsToHimetric(NULL,
								LISTBOX_HEIGHT_LIMIT);
			lpint = (LPINT)lParam;
			SetDlgItemInt(hDlg, IDD_EDIT, *lpint, FALSE);
			wsprintf(cBuf, "Maximum value is %d units", nMaxHeight);
			SetDlgItemText(hDlg, IDD_LIMIT, (LPSTR)cBuf);
			break;
		}

		case WM_COMMAND:
			switch (wParam) {
				case IDOK:
					if (IsDlgButtonChecked(hDlg, IDD_CHECK)) {
						*lpint = -1;
					}
					else {
						/* save the value in the edit control */
						nHeight = GetDlgItemInt(hDlg, IDD_EDIT,
								(BOOL FAR*)&fTranslated, FALSE);
						if (!fTranslated || !nHeight || (nHeight>nMaxHeight)){
							OutlineApp_ErrorMessage(g_lpApp,
									ErrMsgInvalidValue);
							break;
						}
						*lpint = nHeight;
					}
					EndDialog(hDlg, TRUE);
					break;

				case IDCANCEL:
					*lpint = 0;
					EndDialog(hDlg, FALSE);
					break;


				case IDD_CHECK:
					fEnable = !IsDlgButtonChecked(hDlg, IDD_CHECK);
					EnableWindow(GetDlgItem(hDlg, IDD_EDIT), fEnable);
					EnableWindow(GetDlgItem(hDlg, IDD_TEXT), fEnable);
					break;
			}
			break;  /* WM_COMMAND */

		case WM_CLOSE:  /* Closing the Dialog behaves the same as Cancel */
			PostMessage(hDlg, WM_COMMAND, IDCANCEL, 0L);
			break; /* End of WM_CLOSE */

		default:
			return FALSE;
	}

	return TRUE;

} /* end of SetLineHeightProc */





/* DefineNameDlgProc
 * -----------------
 *
 *      Dialog procedure for define name
 */
BOOL CALLBACK EXPORT DefineNameDlgProc(HWND hDlg, UINT Message, WPARAM wParam, LPARAM lParam)
{
	static HWND hCombo;
	static LPOUTLINEDOC lpOutlineDoc = NULL;
	static LPOUTLINENAMETABLE lpOutlineNameTable = NULL;
	LPOUTLINENAME lpOutlineName = NULL;
	UINT nIndex;
	LINERANGE lrSel;
	BOOL fTranslated;

	switch(Message) {
		case WM_INITDIALOG:
		/* initialize working variables */
			hCombo=GetDlgItem(hDlg,IDD_COMBO);
			lpOutlineDoc = (LPOUTLINEDOC) lParam;
			lpOutlineNameTable = OutlineDoc_GetNameTable(lpOutlineDoc);

			SendMessage(hCombo,CB_LIMITTEXT,(WPARAM)MAXNAMESIZE,0L);
			NameDlg_LoadComboBox(lpOutlineNameTable, hCombo);

			OutlineDoc_GetSel(lpOutlineDoc, (LPLINERANGE)&lrSel);
			lpOutlineName = OutlineNameTable_FindNamedRange(
					lpOutlineNameTable,
					&lrSel
			);

			/* if current selection already has a name, hilight it */
			if (lpOutlineName) {
				nIndex = (int) SendMessage(
						hCombo,
						CB_FINDSTRINGEXACT,
						(WPARAM)0xffff,
						(LPARAM)(LPCSTR)lpOutlineName->m_szName
				);
				if (nIndex != CB_ERR) {
					SendMessage(hCombo, CB_SETCURSEL, (WPARAM)nIndex, 0L);
				}
			}

			SetDlgItemInt(hDlg, IDD_FROM, (UINT)lrSel.m_nStartLine+1,FALSE);
			SetDlgItemInt(hDlg, IDD_TO, (UINT)lrSel.m_nEndLine+1, FALSE);

			break; /* End of WM_INITDIALOG */

		case WM_CLOSE:
		/* Closing the Dialog behaves the same as Cancel */
			PostMessage(hDlg, WM_COMMAND, IDD_CLOSE, 0L);
			break; /* End of WM_CLOSE */

		case WM_COMMAND:
			switch(wParam) {
				case IDOK:
					GetDlgItemText(hDlg,IDD_COMBO,(LPSTR)g_szBuf,MAXNAMESIZE);
					if(! SendMessage(hCombo,WM_GETTEXTLENGTH,0,0L)) {
						MessageBox(
								hDlg,
								ErrMsgNullName,
								NULL,
								MB_ICONEXCLAMATION
						);
						break;
					} else if(SendMessage(hCombo,CB_GETCURSEL,0,0L)==CB_ERR &&
							_fstrchr(g_szBuf, ' ')) {
						MessageBox(
								hDlg,
								ErrMsgInvalidName,
								NULL,
								MB_ICONEXCLAMATION
						);
						break;
					} else {
						nIndex = (int) SendMessage(hCombo,CB_FINDSTRINGEXACT,
							(WPARAM)0xffff,(LPARAM)(LPCSTR)g_szBuf);

						/* Line indices are 1 less than the number in
						**    the row heading
						*/
						lrSel.m_nStartLine = GetDlgItemInt(hDlg, IDD_FROM,
								(BOOL FAR*)&fTranslated, FALSE) - 1;
						if(! fTranslated) {
							OutlineApp_ErrorMessage(g_lpApp,
									ErrMsgInvalidRange);
							break;
						}
						lrSel.m_nEndLine = GetDlgItemInt(hDlg, IDD_TO,
								(BOOL FAR*)&fTranslated, FALSE) - 1;
						if (!fTranslated ||
							(lrSel.m_nStartLine < 0) ||
							(lrSel.m_nEndLine < lrSel.m_nStartLine) ||
							(lrSel.m_nEndLine >= OutlineDoc_GetLineCount(
									lpOutlineDoc))) {
							OutlineApp_ErrorMessage(g_lpApp,
									ErrMsgInvalidRange);
							break;
						}

						if(nIndex != CB_ERR) {
							NameDlg_UpdateName(
									hCombo,
									lpOutlineDoc,
									nIndex,
									g_szBuf,
									&lrSel
							);
						} else {
							NameDlg_AddName(
									hCombo,
									lpOutlineDoc,
									g_szBuf,
									&lrSel
							);
						}
					}
					// fall through

				case IDD_CLOSE:
					/* Ignore data values entered into the controls */
					/* and dismiss the dialog window returning FALSE */
					EndDialog(hDlg,0);
					break;

				case IDD_DELETE:
					GetDlgItemText(hDlg,IDD_COMBO,(LPSTR)g_szBuf,MAXNAMESIZE);
					if((nIndex=(int)SendMessage(hCombo,CB_FINDSTRINGEXACT,
					(WPARAM)0xffff,(LPARAM)(LPCSTR)g_szBuf))==CB_ERR)
						MessageBox(hDlg, ErrMsgNameNotFound, NULL, MB_ICONEXCLAMATION);
					else {
						NameDlg_DeleteName(hCombo, lpOutlineDoc, nIndex);
					}
					break;

				case IDD_COMBO:
					if(HIWORD(lParam) == CBN_SELCHANGE) {
						nIndex=(int)SendMessage(hCombo, CB_GETCURSEL, 0, 0L);
						lpOutlineName = (LPOUTLINENAME)SendMessage(
								hCombo,
								CB_GETITEMDATA,
								(WPARAM)nIndex,
								0L
						);
						SetDlgItemInt(
								hDlg,
								IDD_FROM,
								(UINT) lpOutlineName->m_nStartLine + 1,
								FALSE
						);
						SetDlgItemInt(
								hDlg,
								IDD_TO,
								(UINT) lpOutlineName->m_nEndLine + 1,
								FALSE
						);
					}
			}
			break;    /* End of WM_COMMAND */

		default:
			return FALSE;
	}

	return TRUE;
} /* End of DefineNameDlgProc */


/* GotoNameDlgProc
 * ---------------
 *
 *      Dialog procedure for goto name
 */
BOOL CALLBACK EXPORT GotoNameDlgProc(HWND hDlg, UINT Message, WPARAM wParam, LPARAM lParam)
{
	static HWND hLBName;
	static LPOUTLINEDOC lpOutlineDoc = NULL;
	static LPOUTLINENAMETABLE lpOutlineNameTable = NULL;
	UINT nIndex;
	LINERANGE lrLineRange;
	LPOUTLINENAME lpOutlineName;

	switch(Message) {
		case WM_INITDIALOG:
		/* initialize working variables */
			lpOutlineDoc = (LPOUTLINEDOC) lParam;
			lpOutlineNameTable = OutlineDoc_GetNameTable(lpOutlineDoc);

			hLBName=GetDlgItem(hDlg,IDD_LINELISTBOX);
			NameDlg_LoadListBox(lpOutlineNameTable, hLBName);

			// highlight 1st item
			SendMessage(hLBName, LB_SETCURSEL, 0, 0L);
			// trigger to initialize edit control
			SendMessage(hDlg, WM_COMMAND, (WPARAM)IDD_LINELISTBOX,
				MAKELONG(hLBName, LBN_SELCHANGE));

			break; /* End of WM_INITDIALOG */

		case WM_CLOSE:
		/* Closing the Dialog behaves the same as Cancel */
			PostMessage(hDlg, WM_COMMAND, IDCANCEL, 0L);
			break; /* End of WM_CLOSE */

		case WM_COMMAND:
			switch(wParam) {
				case IDD_LINELISTBOX:
					if(HIWORD(lParam) == LBN_SELCHANGE) {
						// update the line range display
						nIndex=(int)SendMessage(hLBName, LB_GETCURSEL, 0, 0L);
						lpOutlineName = (LPOUTLINENAME)SendMessage(hLBName, LB_GETITEMDATA,
											(WPARAM)nIndex,0L);
						if (lpOutlineName) {
							SetDlgItemInt(
									hDlg,
									IDD_FROM,
									(UINT) lpOutlineName->m_nStartLine + 1,
									FALSE
							);
							SetDlgItemInt(
									hDlg,
									IDD_TO,
									(UINT) lpOutlineName->m_nEndLine + 1,
									FALSE
							);
						}
						break;
					}
					// double click will fall through
					else if(HIWORD(lParam) != LBN_DBLCLK)
						break;

				case IDOK:
					nIndex=(int)SendMessage(hLBName,LB_GETCURSEL,0,0L);
					if(nIndex!=LB_ERR) {
						lpOutlineName = (LPOUTLINENAME)SendMessage(hLBName,
								LB_GETITEMDATA, (WPARAM)nIndex, 0L);
						lrLineRange.m_nStartLine=lpOutlineName->m_nStartLine;
						lrLineRange.m_nEndLine = lpOutlineName->m_nEndLine;
						OutlineDoc_SetSel(lpOutlineDoc, &lrLineRange);
					}   // fall through

				case IDCANCEL:
				/* Ignore data values entered into the controls */
				/* and dismiss the dialog window returning FALSE */
					EndDialog(hDlg,0);
					break;

			}
			break;    /* End of WM_COMMAND */

		default:
			return FALSE;
	}

	return TRUE;
} /* End of GotoNameDlgProc */



/* NameDlg_LoadComboBox
 * --------------------
 *
 *      Load defined names into combo box
 */
void NameDlg_LoadComboBox(LPOUTLINENAMETABLE lpOutlineNameTable,HWND hCombo)
{
	LPOUTLINENAME lpOutlineName;
	int i, nIndex;
	int nCount;

	nCount=OutlineNameTable_GetCount((LPOUTLINENAMETABLE)lpOutlineNameTable);
	if(!nCount) return;

	SendMessage(hCombo,WM_SETREDRAW,(WPARAM)FALSE,0L);
	for(i=0; i<nCount; i++) {
		lpOutlineName=OutlineNameTable_GetName((LPOUTLINENAMETABLE)lpOutlineNameTable,i);
		nIndex = (int)SendMessage(
				hCombo,
				CB_ADDSTRING,
				0,
				(LPARAM)(LPCSTR)lpOutlineName->m_szName
		);
		SendMessage(hCombo,CB_SETITEMDATA,(WPARAM)nIndex,(LPARAM)lpOutlineName);
	}
	SendMessage(hCombo,WM_SETREDRAW,(WPARAM)TRUE,0L);
}


/* NameDlg_LoadListBox
 * -------------------
 *
 *      Load defined names into list box
 */
void NameDlg_LoadListBox(LPOUTLINENAMETABLE lpOutlineNameTable,HWND hListBox)
{
	int i;
	int nCount;
	int nIndex;
	LPOUTLINENAME lpOutlineName;

	nCount=OutlineNameTable_GetCount((LPOUTLINENAMETABLE)lpOutlineNameTable);

	SendMessage(hListBox,WM_SETREDRAW,(WPARAM)FALSE,0L);
	for(i=0; i<nCount; i++) {
		lpOutlineName=OutlineNameTable_GetName((LPOUTLINENAMETABLE)lpOutlineNameTable,i);
		nIndex = (int)SendMessage(
				hListBox,
				LB_ADDSTRING,
				0,
				(LPARAM)(LPCSTR)lpOutlineName->m_szName
		);
		SendMessage(hListBox,LB_SETITEMDATA,(WPARAM)nIndex,(LPARAM)lpOutlineName);
	}
	SendMessage(hListBox,WM_SETREDRAW,(WPARAM)TRUE,0L);
}


/* NameDlg_AddName
 * ---------------
 *
 *      Add a name to the name table corresponding to the name dialog
 *      combo box.
 */
void NameDlg_AddName(HWND hCombo, LPOUTLINEDOC lpOutlineDoc, LPSTR lpszName, LPLINERANGE lplrSel)
{
	LPOUTLINEAPP lpOutlineApp = (LPOUTLINEAPP)g_lpApp;
	LPOUTLINENAME lpOutlineName;

	lpOutlineName = OutlineApp_CreateName(lpOutlineApp);

	if (lpOutlineName) {
		lstrcpy(lpOutlineName->m_szName, lpszName);
		lpOutlineName->m_nStartLine = lplrSel->m_nStartLine;
		lpOutlineName->m_nEndLine = lplrSel->m_nEndLine;
		OutlineDoc_AddName(lpOutlineDoc, lpOutlineName);
	} else {
		// REVIEW: do we need error message here?
	}
}


/* NameDlg_UpdateName
 * ------------------
 *
 *      Update a name in the name table corresponding to a name in
 *      the name dialog combo box.
 */
void NameDlg_UpdateName(HWND hCombo, LPOUTLINEDOC lpOutlineDoc, int nIndex, LPSTR lpszName, LPLINERANGE lplrSel)
{
	LPOUTLINENAME lpOutlineName;

	lpOutlineName = (LPOUTLINENAME)SendMessage(
			hCombo,
			CB_GETITEMDATA,
			(WPARAM)nIndex,
			0L
	);

	OutlineName_SetName(lpOutlineName, lpszName);
	OutlineName_SetSel(lpOutlineName, lplrSel, TRUE /* name modified */);
	OutlineDoc_SetModified(lpOutlineDoc, TRUE, FALSE, FALSE);
}


/* NameDlg_DeleteName
 * ------------------
 *
 *      Delete a name from the name dialog combo box and corresponding
 *      name table.
 */
void NameDlg_DeleteName(HWND hCombo, LPOUTLINEDOC lpOutlineDoc, UINT nIndex)
{
	SendMessage(hCombo,CB_DELETESTRING,(WPARAM)nIndex,0L);
	OutlineDoc_DeleteName(lpOutlineDoc, nIndex);
}

/* PlaceBitmap
 * -----------
 *
 *      Places a bitmap centered in the specified control in the dialog on the
 *      specified DC.
 *
 */

PlaceBitmap(HWND hDlg, int control, HDC hDC, HBITMAP hBitmap)
{
	BITMAP bm;
	HDC hdcmem;
	HBITMAP hbmOld;
	RECT rcControl;     // Rect of dialog control
	int width, height;

	GetObject(hBitmap, sizeof(BITMAP), &bm);

	hdcmem= CreateCompatibleDC(hDC);
	hbmOld = SelectObject(hdcmem, hBitmap);

	// Get rect of control in screen coords, and translate to our dialog
	// box's coordinates
	GetWindowRect(GetDlgItem(hDlg, control), &rcControl);
	MapWindowPoints(NULL, hDlg, (LPPOINT)&rcControl, 2);

	width  = rcControl.right - rcControl.left;
	height = rcControl.bottom - rcControl.top;

	BitBlt(hDC, rcControl.left + (width - bm.bmWidth) / 2,
				rcControl.top + (height - bm.bmHeight) /2,
				bm.bmWidth, bm.bmHeight,
				hdcmem, 0, 0, SRCCOPY);

	SelectObject(hdcmem, hbmOld);
	DeleteDC(hdcmem);
	return 1;
}



/* AboutDlgProc
 * ------------
 *
 *      Dialog procedure for the About function
 */
BOOL CALLBACK EXPORT AboutDlgProc(HWND hDlg, UINT Message, WPARAM wParam, LPARAM lParam)
{
	int  narrVersion[2];
	static HBITMAP hbmLogo;

	switch(Message) {

		case WM_INITDIALOG:
			// get version number of app
			wsprintf(g_szBuf, "About %s", (LPCSTR)APPNAME);
			SetWindowText(hDlg, (LPCSTR)g_szBuf);
			OutlineApp_GetAppVersionNo(g_lpApp, narrVersion);
			wsprintf(g_szBuf, "%s version %d.%d", (LPSTR) APPDESC,
				narrVersion[0], narrVersion[1]);
			SetDlgItemText(hDlg, IDD_APPTEXT, (LPCSTR)g_szBuf);

			// Load bitmap for displaying later
			hbmLogo = LoadBitmap(g_lpApp->m_hInst, "LogoBitmap");
			TraceDebug(hDlg, IDD_BITMAPLOCATION);
			ShowWindow(GetDlgItem(hDlg, IDD_BITMAPLOCATION), SW_HIDE);
			break;

		case WM_PAINT:
			{
			PAINTSTRUCT ps;
			BeginPaint(hDlg, &ps);

			// Display bitmap in IDD_BITMAPLOCATION control area
			PlaceBitmap(hDlg, IDD_BITMAPLOCATION, ps.hdc, hbmLogo);
			EndPaint(hDlg, &ps);
			}
			break;

		case WM_CLOSE :
			PostMessage(hDlg, WM_COMMAND, IDOK, 0L);
			break;

		case WM_COMMAND :
			switch(wParam) {
				case IDOK:
				case IDCANCEL:
					if (hbmLogo) DeleteObject(hbmLogo);
					EndDialog(hDlg,0);
					break;
			}
			break;

		default :
			return FALSE;

	}
	return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\letest\outline\heading.c ===
/*************************************************************************
**
**    OLE 2 Sample Code
**
**    heading.c
**
**    This file contains functions and support for OutlineDoc's row and
**    column headings.
**
**    (c) Copyright Microsoft Corp. 1992 - 1993 All Rights Reserved
**
*************************************************************************/

#include "outline.h"

extern LPOUTLINEAPP g_lpApp;


BOOL Heading_Create(LPHEADING lphead, HWND hWndParent, HINSTANCE hInst)
{
	HDC         hDC;
	TEXTMETRIC  tm;

	if (!lphead || !hWndParent || !hInst)
		return FALSE;

	hDC = GetDC(hWndParent);
	if (!hDC)
		return FALSE;

	if (!GetTextMetrics(hDC, (TEXTMETRIC FAR*)&tm))
		return FALSE;
	lphead->m_colhead.m_uHeight = tm.tmHeight;
	lphead->m_rowhead.m_uWidth = 4 * tm.tmAveCharWidth;
	lphead->m_fShow = TRUE;

	ReleaseDC(hWndParent, hDC);

	lphead->m_hfont = CreateFont(
			tm.tmHeight,
			0,0,0,0,0,0,0,0,
			OUT_TT_PRECIS,      // use TrueType
			CLIP_DEFAULT_PRECIS,
			DEFAULT_QUALITY,
			DEFAULT_PITCH | FF_DONTCARE,
			HEADING_FONT
	);

	if (!lphead->m_hfont)
		return FALSE;

	lphead->m_colhead.m_hWnd = CreateWindow(
			"listbox",
			"Column Heading",
			WS_VISIBLE | WS_CHILD | WS_DISABLED | LBS_OWNERDRAWVARIABLE |
					LBS_NOINTEGRALHEIGHT,
			0,0,0,0,        // any values
			hWndParent,
			(HMENU)IDC_COLHEADING,
			hInst,
			NULL);

	if (!lphead->m_colhead.m_hWnd)
		return FALSE;

	// add a dummy line to get WM_DRAWITEM message
	SendMessage(lphead->m_colhead.m_hWnd, LB_ADDSTRING, 0,
			MAKELPARAM(lphead->m_colhead.m_uHeight,0));

	lphead->m_rowhead.m_hWnd = CreateWindow(
			"listbox",
			"Row Heading",
			WS_VISIBLE | WS_CHILD | WS_DISABLED | LBS_OWNERDRAWVARIABLE,
			0,0,0,0,        // any values
			hWndParent,
			(HMENU)IDC_ROWHEADING,
			hInst,
			NULL);

	if (!lphead->m_rowhead.m_hWnd)
		return FALSE;

	SendMessage(lphead->m_rowhead.m_hWnd, LB_ADDSTRING, 0,
			MAKELPARAM(lphead->m_colhead.m_uHeight,0));

	lphead->m_rowhead.m_WndProc =
			(FARPROC) GetWindowLongPtr(lphead->m_rowhead.m_hWnd, GWLP_WNDPROC );
	SetWindowLongPtr(lphead->m_rowhead.m_hWnd, GWLP_WNDPROC,
			(LONG_PTR) RowHeadWndProc);

	lphead->m_hwndButton = CreateWindow(
			"button",
			NULL,
			WS_VISIBLE | WS_CHILD,
			0,0,0,0,        // any values
			hWndParent,
			(HMENU)IDC_BUTTON,
			hInst,
			NULL);

	if (!lphead->m_hwndButton)
		return FALSE;

	return TRUE;
}


void Heading_Destroy(LPHEADING lphead)
{
	if (!lphead)
		return;

	if (IsWindow(lphead->m_colhead.m_hWnd)) {
		DestroyWindow(lphead->m_colhead.m_hWnd);
		lphead->m_colhead.m_hWnd = NULL;
	}
	if (IsWindow(lphead->m_rowhead.m_hWnd)) {
		DestroyWindow(lphead->m_rowhead.m_hWnd);
		lphead->m_rowhead.m_hWnd = NULL;
	}
	if (IsWindow(lphead->m_hwndButton)) {
		DestroyWindow(lphead->m_hwndButton);
		lphead->m_hwndButton = NULL;
	}
#ifdef WIN32
	if (GetObjectType(lphead->m_hfont)) {
#else
	if (IsGDIObject(lphead->m_hfont)) {
#endif
		DeleteObject(lphead->m_hfont);
		lphead->m_hfont = NULL;
	}

}


void Heading_Move(LPHEADING lphead, HWND hwndDoc, LPSCALEFACTOR lpscale)
{
	int nOffsetX;
	int nOffsetY;
	RECT rcDoc;

	if (!lphead || !hwndDoc || !lpscale)
		return;

	if (!lphead->m_fShow)
		return;

	nOffsetX = (int) Heading_RH_GetWidth(lphead, lpscale);
	nOffsetY = (int) Heading_CH_GetHeight(lphead, lpscale);
	GetClientRect(hwndDoc, (LPRECT)&rcDoc);

	MoveWindow(lphead->m_hwndButton, 0, 0, nOffsetX, nOffsetY, TRUE);

	MoveWindow(
			lphead->m_colhead.m_hWnd,
			nOffsetX, 0,
			rcDoc.right-rcDoc.left-nOffsetX, nOffsetY,
			TRUE
	);

	MoveWindow(lphead->m_rowhead.m_hWnd, 0, nOffsetY, nOffsetX,
			rcDoc.bottom-rcDoc.top-nOffsetY, TRUE);
}


void Heading_Show(LPHEADING lphead, BOOL fShow)
{
	int nCmdShow;

	if (!lphead)
		return;

	lphead->m_fShow = fShow;
	nCmdShow = fShow ? SW_SHOW : SW_HIDE;

	ShowWindow(lphead->m_hwndButton, nCmdShow);
	ShowWindow(lphead->m_colhead.m_hWnd, nCmdShow);
	ShowWindow(lphead->m_rowhead.m_hWnd, nCmdShow);
}


void Heading_ReScale(LPHEADING lphead, LPSCALEFACTOR lpscale)
{
	UINT uHeight;

	if (!lphead || !lpscale)
		return;

	// Row heading is scaled with the LineList_Rescale. So, only
	// Column heading needed to be scaled here.
	uHeight = (UINT)(lphead->m_colhead.m_uHeight * lpscale->dwSyN /
			lpscale->dwSyD);
	SendMessage(lphead->m_colhead.m_hWnd, LB_SETITEMHEIGHT, 0,
			MAKELPARAM(uHeight, 0));
}


void Heading_CH_Draw(LPHEADING lphead, LPDRAWITEMSTRUCT lpdis, LPRECT lprcScreen, LPRECT lprcObject)
{
	HPEN        hpenOld;
	HPEN        hpen;
	HBRUSH      hbr;
	HFONT       hfOld;
	int         nTabInPix;
	char        letter;
	int         i;
	int         nOldMapMode;
	RECT        rcWindowOld;
	RECT        rcViewportOld;
	POINT    point;

	if (!lpdis || !lphead)
		return;

	hbr = GetStockObject(LTGRAY_BRUSH);
	FillRect(lpdis->hDC, (LPRECT)&lpdis->rcItem, hbr);

	nOldMapMode = SetDCToAnisotropic(lpdis->hDC, lprcScreen, lprcObject,
			(LPRECT)&rcWindowOld, (LPRECT)&rcViewportOld);

	hfOld = SelectObject(lpdis->hDC, lphead->m_hfont);
	hpen = GetStockObject(BLACK_PEN);
	hpenOld = SelectObject(lpdis->hDC, hpen);

	nTabInPix = XformWidthInHimetricToPixels(lpdis->hDC, TABWIDTH);
	SetBkMode(lpdis->hDC, TRANSPARENT);

	letter = COLUMN_LETTER;
	MoveToEx(lpdis->hDC, lprcObject->left, lprcObject->bottom,&point);
	LineTo(lpdis->hDC, lprcObject->left, lprcObject->top);

	for (i = 0; i < COLUMN; i++) {
		lprcObject->right = lprcObject->left + nTabInPix;
		DrawText(lpdis->hDC, (LPCSTR)&letter, 1, lprcObject,
				DT_SINGLELINE | DT_CENTER | DT_VCENTER);
		MoveToEx(lpdis->hDC, lprcObject->right, lprcObject->bottom, &point);
		LineTo(lpdis->hDC, lprcObject->right, lprcObject->top);

		letter++;
		lprcObject->left += nTabInPix;
	}

	SelectObject(lpdis->hDC, hpenOld);
	SelectObject(lpdis->hDC, hfOld);

	ResetOrigDC(lpdis->hDC, nOldMapMode, (LPRECT)&rcWindowOld,
			(LPRECT)&rcViewportOld);
}


void Heading_CH_SetHorizontalExtent(LPHEADING lphead, HWND hwndListBox)
{
	RECT rcLL;
	RECT rcCH;
	int  nLLWidth;
	int  nCHWidth;
	int  nHorizExtent;

	if (!lphead || !hwndListBox)
		return;

	nHorizExtent=(int)SendMessage(hwndListBox, LB_GETHORIZONTALEXTENT, 0, 0L);
	GetClientRect(hwndListBox, (LPRECT)&rcLL);
	GetClientRect(lphead->m_colhead.m_hWnd, (LPRECT)&rcCH);

	nLLWidth = rcLL.right - rcLL.left;
	nCHWidth = rcCH.right - rcCH.left;
	nHorizExtent += nCHWidth - nLLWidth;

	SendMessage(lphead->m_colhead.m_hWnd, LB_SETHORIZONTALEXTENT,
			nHorizExtent, 0L);
}


UINT Heading_CH_GetHeight(LPHEADING lphead, LPSCALEFACTOR lpscale)
{
	if (!lphead || !lpscale)
		return 0;

	if (lphead->m_fShow)
		return (UINT)(lphead->m_colhead.m_uHeight * lpscale->dwSyN /
				lpscale->dwSyD);
	else
		return 0;
}


LRESULT Heading_CH_SendMessage(LPHEADING lphead, UINT msg, WPARAM wParam, LPARAM lParam)
{
	if (!lphead)
		return 0;

	if (lphead->m_colhead.m_hWnd)
		return SendMessage(lphead->m_colhead.m_hWnd, msg, wParam, lParam);
}


void Heading_CH_ForceRedraw(LPHEADING lphead, BOOL fErase)
{
	if (!lphead)
		return;

	InvalidateRect(lphead->m_colhead.m_hWnd, NULL, fErase);
}

void Heading_RH_ForceRedraw(LPHEADING lphead, BOOL fErase)
{
	if (!lphead)
		return;

	InvalidateRect(lphead->m_rowhead.m_hWnd, NULL, fErase);
}

void Heading_RH_Draw(LPHEADING lphead, LPDRAWITEMSTRUCT lpdis)
{
	char        cBuf[5];
	HPEN        hpenOld;
	HPEN        hpen;
	HBRUSH      hbrOld;
	HBRUSH      hbr;
	HFONT       hfOld;
	RECT        rc;
	RECT        rcWindowOld;
	RECT        rcViewportOld;
	int         nMapModeOld;

	if (!lpdis || !lphead)
		return;

	lpdis->rcItem;

	rc.left = 0;
	rc.bottom = 0;
	rc.top = (int)lpdis->itemData;
	rc.right = lphead->m_rowhead.m_uWidth;

	nMapModeOld = SetDCToAnisotropic(lpdis->hDC, &lpdis->rcItem, &rc,
			(LPRECT)&rcWindowOld, (LPRECT)&rcViewportOld);

	hpen = GetStockObject(BLACK_PEN);
	hpenOld = SelectObject(lpdis->hDC, hpen);
	hbr = GetStockObject(LTGRAY_BRUSH);
	hbrOld = SelectObject(lpdis->hDC, hbr);

	Rectangle(lpdis->hDC, rc.left, rc.top, rc.right,
			rc.bottom);

	hfOld = SelectObject(lpdis->hDC, lphead->m_hfont);

	SetBkMode(lpdis->hDC, TRANSPARENT);

	wsprintf(cBuf, "%d", lpdis->itemID + 1);

	DrawText(lpdis->hDC, (LPSTR)cBuf, lstrlen(cBuf), (LPRECT)&rc,
			DT_SINGLELINE | DT_CENTER | DT_VCENTER);

	SelectObject(lpdis->hDC, hfOld);

	SelectObject(lpdis->hDC, hpenOld);
	SelectObject(lpdis->hDC, hbrOld);

	ResetOrigDC(lpdis->hDC, nMapModeOld, (LPRECT)&rcWindowOld,
			(LPRECT)&rcViewportOld);
}

LRESULT Heading_RH_SendMessage(LPHEADING lphead, UINT msg, WPARAM wParam, LPARAM lParam)
{
	if (!lphead)
		return 0;

	if (lphead->m_rowhead.m_hWnd)
		return SendMessage(lphead->m_rowhead.m_hWnd, msg, wParam, lParam);
}


UINT Heading_RH_GetWidth(LPHEADING lphead, LPSCALEFACTOR lpscale)
{
	if (!lphead || !lpscale)
		return 0;

	if (lphead->m_fShow)
		return (UINT)(lphead->m_rowhead.m_uWidth * lpscale->dwSxN /
				lpscale->dwSxD);
	else
		return 0;
}


void Heading_RH_Scroll(LPHEADING lphead, HWND hwndListBox)
{
	int nTopLL;
	int nTopRH;

	if (!lphead || !hwndListBox)
		return;

	nTopLL = (int)SendMessage(hwndListBox, LB_GETTOPINDEX, 0, 0L);
	nTopRH = (int)SendMessage(
			lphead->m_rowhead.m_hWnd, LB_GETTOPINDEX, 0, 0L);

	if (nTopLL != nTopRH)
		SendMessage(
				lphead->m_rowhead.m_hWnd,LB_SETTOPINDEX,(WPARAM)nTopLL,0L);
}


LRESULT FAR PASCAL RowHeadWndProc(HWND hWnd, UINT Message, WPARAM wParam, LPARAM lParam)
{
	HWND     hwndParent = GetParent (hWnd);
	LPOUTLINEDOC lpDoc = (LPOUTLINEDOC)GetWindowLongPtr(hwndParent, 0);
	LPHEADING lphead = OutlineDoc_GetHeading(lpDoc);

	switch (Message) {
		case WM_PAINT:
		{
			LPLINELIST lpLL = OutlineDoc_GetLineList(lpDoc);
			PAINTSTRUCT ps;

			// If there is no line in listbox, trap the message and draw the
			// background gray. Without this, the background will be painted
			// as default color.
			if (!LineList_GetCount(lpLL)) {
				BeginPaint(hWnd, &ps);
				EndPaint(hWnd, &ps);
				return 0;
			}

			break;
		}

		case WM_ERASEBKGND:
		{
			HDC hDC = (HDC)wParam;
			RECT rc;

			GetClientRect(hWnd, (LPRECT)&rc);
			FillRect(hDC, (LPRECT)&rc, GetStockObject(GRAY_BRUSH));

			return 1;
		}
	}

	return CallWindowProc(
			(WNDPROC)lphead->m_rowhead.m_WndProc,
			hWnd,
			Message,
			wParam,
			lParam
	);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\letest\outline\dragdrop.c ===
/*************************************************************************
**
**    OLE 2 Sample Code
**
**    dragdrop.c
**
**    This file contains the major interfaces, methods and related support
**    functions for implementing Drag/Drop. The code contained in this
**    file is used by BOTH the Container and Server (Object) versions
**    of the Outline sample code.
**    The Drag/Drop support includes the following implementation objects:
**
**    OleDoc Object
**      exposed interfaces:
**          IDropSource
**          IDropTarget
**
**    (c) Copyright Microsoft Corp. 1992 - 1993 All Rights Reserved
**
*************************************************************************/

#include "outline.h"

OLEDBGDATA

extern LPOUTLINEAPP             g_lpApp;


#if defined( USE_DRAGDROP )

/* OleDoc_QueryDrag
 * ----------------
 * Check to see if Drag operation should be initiated. A Drag operation
 * should be initiated when the mouse in either the top 10 pixels of the
 * selected list box entry or in the bottom 10 pixels of the last selected
 * item.
 */

BOOL OleDoc_QueryDrag(LPOLEDOC lpOleDoc, int y)
{
	LPLINELIST lpLL = (LPLINELIST)&((LPOUTLINEDOC)lpOleDoc)->m_LineList;
	LINERANGE LineRange;

	if ( LineList_GetSel( lpLL,  (LPLINERANGE)&LineRange) ) {
		RECT rect;

		if (!LineList_GetLineRect(lpLL,LineRange.m_nStartLine,(LPRECT)&rect))
			return FALSE ;

		if ( rect.top <= y && y <= rect.top + DD_SEL_THRESH )
			return TRUE;

		LineList_GetLineRect( lpLL, LineRange.m_nEndLine, (LPRECT)&rect );
		if ( rect.bottom >= y && y >= rect.bottom - DD_SEL_THRESH )
			return TRUE;

	}

	return FALSE;
}

/* OleDoc_DoDragScroll
 * -------------------
 * Check to see if Drag scroll operation should be initiated. A Drag scroll
 * operation should be initiated when the mouse has remained in the active
 * scroll area (11 pixels frame around border of window) for a specified
 * amount of time (50ms).
 */

BOOL OleDoc_DoDragScroll(LPOLEDOC lpOleDoc, POINTL pointl)
{
	LPOLEAPP lpOleApp = (LPOLEAPP)g_lpApp;
	LPLINELIST lpLL = (LPLINELIST)&((LPOUTLINEDOC)lpOleDoc)->m_LineList;
	HWND hWndListBox = LineList_GetWindow(lpLL);
	DWORD dwScrollDir = SCROLLDIR_NULL;
	DWORD dwTime = GetCurrentTime();
	int nScrollInset = lpOleApp->m_nScrollInset;
	int nScrollDelay = lpOleApp->m_nScrollDelay;
	int nScrollInterval = lpOleApp->m_nScrollInterval;
	POINT point;
	RECT rect;

	if ( lpLL->m_nNumLines == 0 )
		return FALSE;

	point.x = (int)pointl.x;
	point.y = (int)pointl.y;

	ScreenToClient( hWndListBox, &point);
	GetClientRect ( hWndListBox, (LPRECT) &rect );

	if (rect.top <= point.y && point.y<=(rect.top+nScrollInset))
		dwScrollDir = SCROLLDIR_UP;
	else if ((rect.bottom-nScrollInset) <= point.y && point.y <= rect.bottom)
		dwScrollDir = SCROLLDIR_DOWN;

	if (lpOleDoc->m_dwTimeEnterScrollArea) {

		/* cursor was already in Scroll Area */

		if (! dwScrollDir) {
			/* cusor moved OUT of scroll area.
			**      clear "EnterScrollArea" time.
			*/
			lpOleDoc->m_dwTimeEnterScrollArea = 0L;
			lpOleDoc->m_dwNextScrollTime = 0L;
			lpOleDoc->m_dwLastScrollDir = SCROLLDIR_NULL;
		} else if (dwScrollDir != lpOleDoc->m_dwLastScrollDir) {
			/* cusor moved into a different direction scroll area.
			**      reset "EnterScrollArea" time to start a new 50ms delay.
			*/
			lpOleDoc->m_dwTimeEnterScrollArea = dwTime;
			lpOleDoc->m_dwNextScrollTime = dwTime + (DWORD)nScrollDelay;
			lpOleDoc->m_dwLastScrollDir = dwScrollDir;
		} else if (dwTime  && dwTime >= lpOleDoc->m_dwNextScrollTime) {
			LineList_Scroll ( lpLL, dwScrollDir );  // Scroll doc NOW
			lpOleDoc->m_dwNextScrollTime = dwTime + (DWORD)nScrollInterval;
		}
	} else {
		if (dwScrollDir) {
			/* cusor moved INTO a scroll area.
			**      reset "EnterScrollArea" time to start a new 50ms delay.
			*/
			lpOleDoc->m_dwTimeEnterScrollArea = dwTime;
			lpOleDoc->m_dwNextScrollTime = dwTime + (DWORD)nScrollDelay;
			lpOleDoc->m_dwLastScrollDir = dwScrollDir;
		}
	}

	return (dwScrollDir ? TRUE : FALSE);
}


/* OleDoc_QueryDrop
** ----------------
**    Check if the desired drop operation (identified by the given key
**    state) is possible at the current mouse position (pointl).
*/
BOOL OleDoc_QueryDrop (
	LPOLEDOC        lpOleDoc,
	DWORD           grfKeyState,
	POINTL          pointl,
	BOOL            fDragScroll,
	LPDWORD         lpdwEffect
)
{
	LPLINELIST lpLL   = (LPLINELIST)&((LPOUTLINEDOC)lpOleDoc)->m_LineList;
	LINERANGE  linerange;
	short      nIndex = LineList_GetLineIndexFromPointl( lpLL, pointl );
	DWORD      dwScrollEffect = 0L;
	DWORD      dwOKEffects = *lpdwEffect;

	/* check if the cursor is in the active scroll area, if so need the
	**    special scroll cursor.
	*/
	if (fDragScroll)
		dwScrollEffect = DROPEFFECT_SCROLL;

	/* if we have already determined that the source does NOT have any
	**    acceptable data for us, the return NO-DROP
	*/
	if (! lpOleDoc->m_fCanDropCopy && ! lpOleDoc->m_fCanDropLink)
		goto dropeffect_none;

	/* if the Drag/Drop is local to our document, we can NOT accept a
	**    drop in the middle of the current selection (which is the exact
	**    data that is being dragged!).
	*/
	if (lpOleDoc->m_fLocalDrag) {
		LineList_GetSel( lpLL, (LPLINERANGE)&linerange );

		if (linerange.m_nStartLine <= nIndex && nIndex<linerange.m_nEndLine)
			goto dropeffect_none;
	}

	/* OLE2NOTE: determine what type of drop should be performed given
	**    the current modifier key state. we rely on the standard
	**    interpretation of the modifier keys:
	**          no modifier -- DROPEFFECT_MOVE or whatever is allowed by src
	**          SHIFT       -- DROPEFFECT_MOVE
	**          CTRL        -- DROPEFFECT_COPY
	**          CTRL-SHIFT  -- DROPEFFECT_LINK
	*/

	*lpdwEffect = OleStdGetDropEffect(grfKeyState);
	if (*lpdwEffect == 0) {
		// No modifier keys given. Try in order MOVE, COPY, LINK.
		if ((DROPEFFECT_MOVE & dwOKEffects) && lpOleDoc->m_fCanDropCopy)
			*lpdwEffect = DROPEFFECT_MOVE;
		else if ((DROPEFFECT_COPY & dwOKEffects) && lpOleDoc->m_fCanDropCopy)
			*lpdwEffect = DROPEFFECT_COPY;
		else if ((DROPEFFECT_LINK & dwOKEffects) && lpOleDoc->m_fCanDropLink)
			*lpdwEffect = DROPEFFECT_LINK;
		else
			goto dropeffect_none;
	} else {
		/* OLE2NOTE: we should check if the drag source application allows
		**    the desired drop effect.
		*/
		if (!(*lpdwEffect & dwOKEffects))
			goto dropeffect_none;

		if ((*lpdwEffect == DROPEFFECT_COPY || *lpdwEffect == DROPEFFECT_MOVE)
				&& ! lpOleDoc->m_fCanDropCopy)
			goto dropeffect_none;

		if (*lpdwEffect == DROPEFFECT_LINK && ! lpOleDoc->m_fCanDropLink)
			goto dropeffect_none;
	}

	*lpdwEffect |= dwScrollEffect;
	return TRUE;

dropeffect_none:

	*lpdwEffect = DROPEFFECT_NONE;
	return FALSE;
}

/* OleDoc_DoDragDrop
 * -----------------
 *  Actually perform a drag/drop operation with the current selection in
 *      the source document (lpSrcOleDoc).
 *
 *  returns the result effect of the drag/drop operation:
 *      DROPEFFECT_NONE,
 *      DROPEFFECT_COPY,
 *      DROPEFFECT_MOVE, or
 *      DROPEFFECT_LINK
 */

DWORD OleDoc_DoDragDrop (LPOLEDOC lpSrcOleDoc)
{
	LPOUTLINEAPP lpOutlineApp = (LPOUTLINEAPP)g_lpApp;
	LPOLEAPP     lpOleApp = (LPOLEAPP)g_lpApp;
	LPOUTLINEDOC lpSrcOutlineDoc = (LPOUTLINEDOC)lpSrcOleDoc;
	LPOLEDOC lpDragDoc;
	LPLINELIST  lpSrcLL =
					(LPLINELIST)&((LPOUTLINEDOC)lpSrcOleDoc)->m_LineList;
	DWORD       dwEffect     = 0;
	LPLINE      lplineStart, lplineEnd;
	LINERANGE   linerange;
	BOOL        fPrevEnable1;
	BOOL        fPrevEnable2;
	HRESULT     hrErr;

	OLEDBG_BEGIN3("OleDoc_DoDragDrop\r\n")

	/* squirrel away a copy of the current selection to the ClipboardDoc */
	lpDragDoc = (LPOLEDOC)OutlineDoc_CreateDataTransferDoc(lpSrcOutlineDoc);
	if ( ! lpDragDoc) {
		dwEffect = DROPEFFECT_NONE;
		goto error;
	}

	/* OLE2NOTE: initially the DataTransferDoc is created with a 0 ref
	**    count. in order to have a stable Doc object during the drag/
	**    drop operation, we intially AddRef the Doc ref cnt and later
	**    Release it. This AddRef is artificial; it is simply
	**    done to guarantee that a harmless QueryInterface followed by
	**    a Release does not inadvertantly force our object to destroy
	**    itself prematurely.
	*/
	OleDoc_AddRef(lpDragDoc);

	//NOTE: we need to keep the LPLINE pointers
	//      rather than the indexes because the
	//      indexes will not be the same after the
	//      drop occurs  -- the drop adds new
	//      entries to the list thereby shifting
	//      the whole list.
	LineList_GetSel( lpSrcLL, (LPLINERANGE)&linerange );
	lplineStart = LineList_GetLine ( lpSrcLL, linerange.m_nStartLine );
	lplineEnd   = LineList_GetLine ( lpSrcLL, linerange.m_nEndLine );

	if (! lplineStart || ! lplineEnd) {
		dwEffect = DROPEFFECT_NONE;
		goto error;
	}

	lpSrcOleDoc->m_fLocalDrop     = FALSE;
	lpSrcOleDoc->m_fLocalDrag     = TRUE;

	/* OLE2NOTE: it is VERY important to DISABLE the Busy/NotResponding
	**    dialogs BEFORE calling DoDragDrop. The DoDragDrop API starts
	**    a mouse capture modal loop. if the Busy/NotResponding comes
	**    up in the middle of this loop (eg. if one of the remoted
	**    calls like IDropTarget::DragOver call takes a long time, then
	**    the NotResponding dialog may want to come up), then the mouse
	**    capture is lost by OLE and things can get messed up.
	*/
	OleApp_DisableBusyDialogs(lpOleApp, &fPrevEnable1, &fPrevEnable2);

	OLEDBG_BEGIN2("DoDragDrop called\r\n")
	hrErr = DoDragDrop ( (LPDATAOBJECT) &lpDragDoc->m_DataObject,
				 (LPDROPSOURCE) &lpSrcOleDoc->m_DropSource,
				 DROPEFFECT_MOVE | DROPEFFECT_COPY | DROPEFFECT_LINK,
				 (LPDWORD) &dwEffect
	);
	OLEDBG_END2

	// re-enable the Busy/NotResponding dialogs
	OleApp_EnableBusyDialogs(lpOleApp, fPrevEnable1, fPrevEnable2);

#if defined( _DEBUG )
	if (FAILED(hrErr))
		OleDbgOutHResult("DoDragDrop returned", hrErr);
#endif
	lpSrcOleDoc->m_fLocalDrag     = FALSE;

	/* OLE2NOTE: we need to guard the lifetime of our lpSrcOleDoc
	**    object while we are deleting the lines that were drag
	**    moved. it is possible that deleting these lines could
	**    cause the deletion of a PseudoObj. the deletion of a
	**    PseudoObj will cause the Doc to be unlock
	**    (CoLockObjectExternal(FALSE,TRUE) called). each PseudoObj
	**    holds a strong lock on the Doc. It is always best to have
	**    a memory guard around such critical sections of code. in
	**    this case, it is particularly important if we were an
	**    in-place active server and this drag ended up in a drop
	**    in our outer container. this scenario will lead to a
	**    crash if we do not hold this memory guard.
	*/
	OleDoc_Lock(lpSrcOleDoc, TRUE, 0);

	/* if after the Drag/Drop modal (mouse capture) loop is finished
	**    and a drag MOVE operation was performed, then we must delete
	**    the lines that were dragged.
	*/
	if ( GetScode(hrErr) == DRAGDROP_S_DROP
			&& (dwEffect & DROPEFFECT_MOVE) != 0 ) {

		int i,j,iEnd;
		LPLINE lplineFocusLine;

		/* disable repainting and sending data changed notifications
		**    until after all lines have been deleted.
		*/
		OutlineDoc_SetRedraw ( (LPOUTLINEDOC)lpSrcOleDoc, FALSE );

		/* if the drop was local to our document, then we must take
		**    into account that the line indices of the original source
		**    of the drag could have shifted because the dropped lines
		**    have been inserted into our document. thus we will
		**    re-determine the source line indices.
		*/
		if (lpSrcOleDoc->m_fLocalDrop) {
			i = LineList_GetFocusLineIndex ( lpSrcLL );
			lplineFocusLine = LineList_GetLine ( lpSrcLL, i );
		}

		for ( i = j = LineList_GetLineIndex(lpSrcLL,lplineStart ) ,
			  iEnd  = LineList_GetLineIndex(lpSrcLL,lplineEnd ) ;
			  i <= iEnd ;
			  i++
		) OutlineDoc_DeleteLine ((LPOUTLINEDOC)lpSrcOleDoc, j );

		LineList_RecalcMaxLineWidthInHimetric(lpSrcLL, 0);

		if (lpSrcOleDoc->m_fLocalDrop) {
			i = LineList_GetLineIndex ( lpSrcLL, lplineFocusLine );
			LineList_SetFocusLine ( lpSrcLL, (WORD)i );
		}

		OutlineDoc_SetRedraw ( (LPOUTLINEDOC)lpSrcOleDoc, TRUE );

		/* if it is a local Drag/Drop move, we need to balance the
		**    SetRedraw(FALSE) call that was made in the implementation
		**    of IDropTarget::Drop.
		*/
		if (lpSrcOleDoc->m_fLocalDrop)
			OutlineDoc_SetRedraw ( (LPOUTLINEDOC)lpSrcOleDoc, TRUE );

		LineList_ForceRedraw ( lpSrcLL, FALSE );
	}

	OleDoc_Release(lpDragDoc);  // rel artificial AddRef above
	OleDoc_Lock(lpSrcOleDoc, FALSE, FALSE);  // unlock artificial lock guard

	OLEDBG_END3
	return dwEffect;

error:
	OLEDBG_END3
	return dwEffect;
}



/*************************************************************************
** OleDoc::IDropSource interface implementation
*************************************************************************/

STDMETHODIMP OleDoc_DropSource_QueryInterface(
	LPDROPSOURCE            lpThis,
	REFIID                  riid,
	LPVOID FAR*             lplpvObj
)
{
	LPOLEDOC lpOleDoc = ((struct CDocDropSourceImpl FAR*)lpThis)->lpOleDoc;

	return OleDoc_QueryInterface(lpOleDoc, riid, lplpvObj);
}


STDMETHODIMP_(ULONG) OleDoc_DropSource_AddRef( LPDROPSOURCE lpThis )
{
	LPOLEDOC lpOleDoc = ((struct CDocDropSourceImpl FAR*)lpThis)->lpOleDoc;

	OleDbgAddRefMethod(lpThis, "IDropSource");

	return OleDoc_AddRef(lpOleDoc);
}


STDMETHODIMP_(ULONG) OleDoc_DropSource_Release ( LPDROPSOURCE lpThis)
{
	LPOLEDOC lpOleDoc = ((struct CDocDropSourceImpl FAR*)lpThis)->lpOleDoc;

	OleDbgReleaseMethod(lpThis, "IDropSource");

	return OleDoc_Release(lpOleDoc);
}


STDMETHODIMP    OleDoc_DropSource_QueryContinueDrag (
	LPDROPSOURCE            lpThis,
	BOOL                    fEscapePressed,
	DWORD                   grfKeyState
){
	if (fEscapePressed)
		return ResultFromScode(DRAGDROP_S_CANCEL);
	else if (!(grfKeyState & MK_LBUTTON))
		return ResultFromScode(DRAGDROP_S_DROP);
	else
		return NOERROR;
}


STDMETHODIMP    OleDoc_DropSource_GiveFeedback (
	LPDROPSOURCE            lpThis,
	DWORD                   dwEffect
)
{
	// Tell OLE to use the standard drag/drop feedback cursors
	return ResultFromScode(DRAGDROP_S_USEDEFAULTCURSORS);

#if defined( IF_SPECIAL_DD_CURSORS_NEEDED )
	switch (dwEffect) {

		case DROPEFFECT_NONE:
			SetCursor ( ((LPOLEAPP)g_lpApp)->m_hcursorDragNone );
			break;

		case DROPEFFECT_COPY:
			SetCursor ( ((LPOLEAPP)g_lpApp)->m_hcursorDragCopy );
			break;

		case DROPEFFECT_MOVE:
			SetCursor ( ((LPOLEAPP)g_lpApp)->m_hcursorDragMove );
			break;

		case DROPEFFECT_LINK:
			SetCursor ( ((LPOLEAPP)g_lpApp)->m_hcursorDragLink );
			break;

	}

	return NOERROR;
#endif

}

/*************************************************************************
** OleDoc::IDropTarget interface implementation
*************************************************************************/

STDMETHODIMP OleDoc_DropTarget_QueryInterface(
		LPDROPTARGET        lpThis,
		REFIID              riid,
		LPVOID FAR*         lplpvObj
)
{
	LPOLEDOC lpOleDoc = ((struct CDocDropTargetImpl FAR*)lpThis)->lpOleDoc;

	return OleDoc_QueryInterface(lpOleDoc, riid, lplpvObj);
}


STDMETHODIMP_(ULONG) OleDoc_DropTarget_AddRef(LPDROPTARGET lpThis)
{
	LPOLEDOC lpOleDoc = ((struct CDocDropTargetImpl FAR*)lpThis)->lpOleDoc;

	OleDbgAddRefMethod(lpThis, "IDropTarget");

	return OleDoc_AddRef(lpOleDoc);
}


STDMETHODIMP_(ULONG) OleDoc_DropTarget_Release ( LPDROPTARGET lpThis)
{
	LPOLEDOC lpOleDoc = ((struct CDocDropTargetImpl FAR*)lpThis)->lpOleDoc;

	OleDbgReleaseMethod(lpThis, "IDropTarget");

	return OleDoc_Release(lpOleDoc);
}


STDMETHODIMP    OleDoc_DropTarget_DragEnter (
	LPDROPTARGET            lpThis,
	LPDATAOBJECT            lpDataObj,
	DWORD                   grfKeyState,
	POINTL                  pointl,
	LPDWORD                 lpdwEffect
)
{
	LPOLEAPP   lpOleApp = (LPOLEAPP)g_lpApp;
	LPOLEDOC   lpOleDoc = ((struct CDocDropTargetImpl FAR*)lpThis)->lpOleDoc;
	LPLINELIST lpLL     = (LPLINELIST)&((LPOUTLINEDOC)lpOleDoc)->m_LineList;
	BOOL       fDragScroll;

	OLEDBG_BEGIN2("OleDoc_DropTarget_DragEnter\r\n")

	lpOleDoc->m_fDragLeave              = FALSE;
	lpOleDoc->m_dwTimeEnterScrollArea   = 0;
	lpOleDoc->m_dwLastScrollDir         = SCROLLDIR_NULL;


	/* Determine if the drag source data object offers a data format
	**    that we can copy and/or link to.
	*/

	lpOleDoc->m_fCanDropCopy = OleDoc_QueryPasteFromData(
			lpOleDoc,
			lpDataObj,
			FALSE   /* fLink */
	);

	lpOleDoc->m_fCanDropLink = OleDoc_QueryPasteFromData(
			lpOleDoc,
			lpDataObj,
			TRUE   /* fLink */
	);

	fDragScroll = OleDoc_DoDragScroll ( lpOleDoc, pointl );

	if (OleDoc_QueryDrop(lpOleDoc,grfKeyState,pointl,fDragScroll,lpdwEffect))
		LineList_SetDragOverLineFromPointl( lpLL, pointl );

	OLEDBG_END2
	return NOERROR;

}

STDMETHODIMP OleDoc_DropTarget_DragOver (
	LPDROPTARGET            lpThis,
	DWORD                   grfKeyState,
	POINTL                  pointl,
	LPDWORD                 lpdwEffect
)
{
	LPOLEAPP   lpOleApp = (LPOLEAPP)g_lpApp;
	LPOLEDOC   lpOleDoc = ((struct CDocDropTargetImpl FAR*)lpThis)->lpOleDoc;
	LPLINELIST lpLL   = (LPLINELIST)&((LPOUTLINEDOC)lpOleDoc)->m_LineList;
	BOOL       fDragScroll;

	fDragScroll = OleDoc_DoDragScroll ( lpOleDoc, pointl );

	if (OleDoc_QueryDrop(lpOleDoc,grfKeyState, pointl,fDragScroll,lpdwEffect))
		LineList_SetDragOverLineFromPointl( lpLL, pointl );
	else
		LineList_RestoreDragFeedback( lpLL );

	return NOERROR;
}


STDMETHODIMP    OleDoc_DropTarget_DragLeave ( LPDROPTARGET lpThis)
{
	LPOLEDOC   lpOleDoc = ((struct CDocDropTargetImpl FAR*)lpThis)->lpOleDoc;
	LPLINELIST lpLL     = (LPLINELIST)&((LPOUTLINEDOC)lpOleDoc)->m_LineList;

	OLEDBG_BEGIN2("OleDoc_DropTarget_DragLeave\r\n")

	lpOleDoc->m_fDragLeave = TRUE;

	LineList_RestoreDragFeedback( lpLL );

	OLEDBG_END2
	return NOERROR;

}

STDMETHODIMP    OleDoc_DropTarget_Drop (
	LPDROPTARGET            lpThis,
	LPDATAOBJECT            lpDataObj,
	DWORD                   grfKeyState,
	POINTL                  pointl,
	LPDWORD                 lpdwEffect
)
{
	LPOLEDOC   lpOleDoc = ((struct CDocDropTargetImpl FAR*)lpThis)->lpOleDoc;
	LPLINELIST lpLL     = (LPLINELIST)&((LPOUTLINEDOC)lpOleDoc)->m_LineList;

	OLEDBG_BEGIN2("OleDoc_DropTarget_Drop\r\n")

	lpOleDoc->m_fDragLeave = TRUE;
	lpOleDoc->m_fLocalDrop = TRUE;

	LineList_RestoreDragFeedback( lpLL );
	SetFocus( LineList_GetWindow( lpLL) );

	if (OleDoc_QueryDrop(lpOleDoc, grfKeyState, pointl, FALSE, lpdwEffect)) {
		BOOL fLink     = (*lpdwEffect == DROPEFFECT_LINK);
		int iFocusLine = LineList_GetFocusLineIndex( lpLL );
		BOOL fStatus;

		OutlineDoc_SetRedraw ( (LPOUTLINEDOC)lpOleDoc, FALSE );
		LineList_SetFocusLineFromPointl ( lpLL, pointl );

		fStatus = OleDoc_PasteFromData(
				lpOleDoc,
				lpDataObj,
				lpOleDoc->m_fLocalDrag, /* data source is local to app */
				fLink
		);

		// if drop was unsuccessfull, restore the original focus line
		if (! fStatus)
			LineList_SetFocusLine( lpLL, (WORD)iFocusLine );

#if defined( INPLACE_CNTR )
		{
			LPCONTAINERDOC lpContainerDoc = (LPCONTAINERDOC)lpOleDoc;

			/* OLE2NOTE: if there is currently a UIActive OLE object,
			**    then we must tell it to UIDeactivate after
			**    the drop has completed.
			*/
			if (lpContainerDoc->m_lpLastUIActiveLine) {
				ContainerLine_UIDeactivate(
						lpContainerDoc->m_lpLastUIActiveLine);
			}
		}
#endif

#if defined( INPLACE_SVR )
		{
			/* OLE2NOTE: if the drop was into a in-place visible
			**    (in-place active but NOT UIActive object), then we
			**    want to UIActivate the object after the drop is
			**    complete.
			*/
			ServerDoc_UIActivate((LPSERVERDOC) lpOleDoc);
		}
#endif


		/* if it is a local Drag/Drop move, don't enable redraw.
		**    after the source is done deleting the moved lines, it
		**    will re-enable redraw
		*/
		if (! (lpOleDoc->m_fLocalDrag
			&& (*lpdwEffect & DROPEFFECT_MOVE) != 0 ))
			OutlineDoc_SetRedraw ( (LPOUTLINEDOC)lpOleDoc, TRUE );
	}

	OLEDBG_END2
	return NOERROR;
}


#endif  // USE_DRAGDROP
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\letest\outline\heading.h ===
/*************************************************************************
**
**    OLE 2 Sample Code
**
**    heading.c
**
**    This file contains definitions used by OutlineDoc's row and
**    column headings.
**
**    (c) Copyright Microsoft Corp. 1992 - 1993 All Rights Reserved
**
*************************************************************************/

#define COLUMN  10

#define IDC_ROWHEADING  2000
#define IDC_COLHEADING  2001
#define IDC_BUTTON      2002

#define HEADING_FONT    "Arial"

#define COLUMN_LETTER   'A'


typedef struct tagCOLHEADING {
	HWND m_hWnd;
	UINT m_uHeight;
} COLHEADING, FAR* LPCOLHEADING;

typedef struct tagROWHEADING {
	HWND m_hWnd;
	UINT m_uWidth;
	FARPROC    m_WndProc;
} ROWHEADING, FAR* LPROWHEADING;

typedef struct tagHEADING {
	COLHEADING m_colhead;
	ROWHEADING m_rowhead;
	HWND       m_hwndButton;
	BOOL       m_fShow;
	HFONT      m_hfont;
} HEADING, FAR* LPHEADING;

BOOL Heading_Create(LPHEADING lphead, HWND hWndParent, HINSTANCE hInst);
void Heading_Destroy(LPHEADING lphead);
void Heading_Move(LPHEADING lphead, HWND hwndListBox, LPSCALEFACTOR lpscale);
void Heading_Show(LPHEADING lphead, BOOL fShow);
void Heading_ReScale(LPHEADING lphead, LPSCALEFACTOR lpscale);
void Heading_CH_Draw(LPHEADING lphead, LPDRAWITEMSTRUCT lpdis, LPRECT lprcScreen, LPRECT lprcObject);
void Heading_CH_SetHorizontalExtent(LPHEADING lphead, HWND hwndListBox);
UINT Heading_CH_GetHeight(LPHEADING lphead, LPSCALEFACTOR lpscale);
LRESULT Heading_CH_SendMessage(LPHEADING lphead, UINT msg, WPARAM wParam, LPARAM lParam);
void Heading_CH_ForceRedraw(LPHEADING lphead, BOOL fErase);
void Heading_RH_ForceRedraw(LPHEADING lphead, BOOL fErase);
void Heading_RH_Draw(LPHEADING lphead, LPDRAWITEMSTRUCT lpdis);
LRESULT Heading_RH_SendMessage(LPHEADING lphead, UINT msg, WPARAM wParam, LPARAM lParam);
UINT Heading_RH_GetWidth(LPHEADING lphead, LPSCALEFACTOR lpscale);
void Heading_RH_Scroll(LPHEADING lphead, HWND hwndListBox);
LRESULT FAR PASCAL RowHeadWndProc(HWND hWnd, UINT Message, WPARAM wParam, LPARAM lParam);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\letest\outline\frametls.c ===
/*************************************************************************
**
**    OLE 2 Server Sample Code
**
**    frametls.c
**
**    This file contains all FrameTools methods and related support
**    functions. The FrameTools object is an encapsulation of the apps
**    formula bar and button bar.
**
**    (c) Copyright Microsoft Corp. 1992 - 1993 All Rights Reserved
**
*************************************************************************/

#include "outline.h"

OLEDBGDATA

/* private function prototype */
static void Bar_Move(LPBAR lpbar, LPRECT lprcClient, LPRECT lprcPopup);
static void FB_ResizeEdit(LPBAR lpbar);

extern LPOUTLINEAPP g_lpApp;
extern RECT g_rectNull;

/*
 * FrameToolsRegisterClass
 *
 * Purpose:
 *  Register the popup toolbar window class
 *
 * Parameters:
 *  hInst           Process instance
 *
 * Return Value:
 *  TRUE            if successful
 *  FALSE           if failed
 *
 */
BOOL FrameToolsRegisterClass(HINSTANCE hInst)
{
	WNDCLASS wc;

	// Register Tool Palette Class
	wc.style = CS_BYTEALIGNWINDOW;
	wc.lpfnWndProc = FrameToolsWndProc;
	wc.cbClsExtra = 0;
	wc.cbWndExtra = 4;
	wc.hInstance = hInst;
	wc.hIcon = NULL;
	wc.hCursor = LoadCursor(NULL, IDC_ARROW);
	wc.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);
	wc.lpszMenuName = NULL;
	wc.lpszClassName = CLASS_PALETTE;

	if (!RegisterClass(&wc))
		return FALSE;
	else
		return TRUE;
}


static BOOL FrameTools_CreatePopupPalette(LPFRAMETOOLS lpft, HWND hWndFrame)
{
	if (lpft->m_hWndPopupPalette)
		DestroyWindow(lpft->m_hWndPopupPalette);

	lpft->m_hWndPopupPalette = CreateWindow(
		CLASS_PALETTE,
		"Tool Palette",
		WS_POPUP | WS_CAPTION | WS_CLIPCHILDREN,
		CW_USEDEFAULT, 0, 0, 0,
		hWndFrame,
		(HMENU)NULL,
		g_lpApp->m_hInst,
		0L
	);

	if (!lpft->m_hWndPopupPalette)
		return FALSE;

	SetWindowLong(lpft->m_hWndPopupPalette, 0, (LONG)lpft);
	return TRUE;
}


/*
 * FrameTools_Init
 *
 * Purpose:
 *  Init and create the toolbar
 *
 * Parameters:
 *  lpft            FrameTools object
 *  hWndParent      The window which owns the toolbar
 *  hInst           Process instance
 *
 * Return Value:
 *  TRUE            if successful
 *  FALSE           if failed
 *
 */
BOOL FrameTools_Init(LPFRAMETOOLS lpft, HWND hWndParent, HINSTANCE hInst)
{
	RECT        rc;
	UINT        uPos;
	UINT        dx;
	UINT        dy;

	if (!lpft || !hWndParent || !hInst)
		return FALSE;

	//Get BTTNCUR's display information
	UIToolConfigureForDisplay(&lpft->m_tdd);

	dx=lpft->m_tdd.cxButton;
	dy=lpft->m_tdd.cyButton;

	// 15 is calculated from the total number of buttons and separators
	lpft->m_uPopupWidth = dx * 15;

	lpft->m_hWndApp = hWndParent;
	lpft->m_ButtonBar.m_nState = BARSTATE_TOP;
	lpft->m_FormulaBar.m_nState = BARSTATE_TOP;
	lpft->m_fInFormulaBar = FALSE;

	lpft->m_fToolsDisabled = FALSE;

	lpft->m_ButtonBar.m_uHeight = lpft->m_tdd.cyBar;
	lpft->m_FormulaBar.m_uHeight = lpft->m_tdd.cyBar;


	//Get our image bitmaps for the display type we're on
	if (72 == lpft->m_tdd.uDPI)
		lpft->m_hBmp = LoadBitmap(hInst, (LPCSTR)"Image72");
	if (96 == lpft->m_tdd.uDPI)
		lpft->m_hBmp = LoadBitmap(hInst, (LPCSTR)"Image96");
	if (120 == lpft->m_tdd.uDPI)
		lpft->m_hBmp = LoadBitmap(hInst, (LPCSTR)"Image120");

	if (!lpft->m_hBmp)
		return FALSE;

	/* Create Popup Tool Palette window */
	lpft->m_hWndPopupPalette = NULL;
	if (! FrameTools_CreatePopupPalette(lpft, hWndParent))
		return FALSE;

	uPos = 0;
	//Create the GizmoBar and the client area window
	GetClientRect(hWndParent, &rc);
	lpft->m_ButtonBar.m_hWnd = CreateWindow(
		CLASS_GIZMOBAR,
		"ButtonBar",
		WS_CHILD | WS_VISIBLE,
		0, 0, rc.right-rc.left, lpft->m_tdd.cyBar,
		hWndParent,
		(HMENU)IDC_GIZMOBAR,
		hInst,
		0L
	);

	if (!lpft->m_ButtonBar.m_hWnd)
		return FALSE;


	SendMessage(lpft->m_ButtonBar.m_hWnd, WM_SETREDRAW, FALSE, 0L);

	//File new, open, save, print
	GBGizmoAdd(lpft->m_ButtonBar.m_hWnd, GIZMOTYPE_BUTTONCOMMAND, uPos++, IDM_F_NEW, dx, dy, NULL, NULL, TOOLIMAGE_FILENEW, GIZMO_NORMAL);
	GBGizmoAdd(lpft->m_ButtonBar.m_hWnd, GIZMOTYPE_BUTTONCOMMAND, uPos++, IDM_F_OPEN, dx, dy, NULL, NULL, TOOLIMAGE_FILEOPEN, GIZMO_NORMAL);
	GBGizmoAdd(lpft->m_ButtonBar.m_hWnd, GIZMOTYPE_BUTTONCOMMAND, uPos++, IDM_F_SAVE, dx, dy, NULL, NULL, TOOLIMAGE_FILESAVE, GIZMO_NORMAL);
	GBGizmoAdd(lpft->m_ButtonBar.m_hWnd, GIZMOTYPE_BUTTONCOMMAND, uPos++, IDM_F_PRINT, dx, dy, NULL, NULL, TOOLIMAGE_FILEPRINT, GIZMO_NORMAL);

	// separator
	GBGizmoAdd(lpft->m_ButtonBar.m_hWnd, GIZMOTYPE_SEPARATOR, uPos++, 0, dx/2, dy, NULL, NULL, 0, GIZMO_NORMAL);

	// Edit cut, copy, paste
	GBGizmoAdd(lpft->m_ButtonBar.m_hWnd, GIZMOTYPE_BUTTONCOMMAND, uPos++, IDM_E_CUT, dx, dy, NULL, NULL, TOOLIMAGE_EDITCUT, GIZMO_NORMAL);
	GBGizmoAdd(lpft->m_ButtonBar.m_hWnd, GIZMOTYPE_BUTTONCOMMAND, uPos++, IDM_E_COPY, dx, dy, NULL, NULL, TOOLIMAGE_EDITCOPY, GIZMO_NORMAL);
	GBGizmoAdd(lpft->m_ButtonBar.m_hWnd, GIZMOTYPE_BUTTONCOMMAND, uPos++, IDM_E_PASTE, dx, dy, NULL, NULL, TOOLIMAGE_EDITPASTE, GIZMO_NORMAL);

	// separator
	GBGizmoAdd(lpft->m_ButtonBar.m_hWnd, GIZMOTYPE_SEPARATOR, uPos++, 0, dx/2, dy, NULL, NULL, 0, GIZMO_NORMAL);

	// Line indent, unindent
	GBGizmoAdd(lpft->m_ButtonBar.m_hWnd, GIZMOTYPE_BUTTONCOMMAND, uPos++, IDM_L_UNINDENTLINE, dx, dy, NULL, lpft->m_hBmp, IDB_UNINDENTLINE, GIZMO_NORMAL);
	GBGizmoAdd(lpft->m_ButtonBar.m_hWnd, GIZMOTYPE_BUTTONCOMMAND, uPos++, IDM_L_INDENTLINE, dx, dy, NULL, lpft->m_hBmp, IDB_INDENTLINE, GIZMO_NORMAL);

	// separator
	GBGizmoAdd(lpft->m_ButtonBar.m_hWnd, GIZMOTYPE_SEPARATOR, uPos++, 0, dx/2, dy, NULL, NULL, 0, GIZMO_NORMAL);

	// Help
	GBGizmoAdd(lpft->m_ButtonBar.m_hWnd, GIZMOTYPE_BUTTONCOMMAND, uPos++, IDM_H_ABOUT, dx, dy, NULL, NULL, TOOLIMAGE_HELP, GIZMO_NORMAL);

	SendMessage(lpft->m_ButtonBar.m_hWnd, WM_SETREDRAW, TRUE, 0L);


	uPos = 0;
	lpft->m_FormulaBar.m_hWnd = CreateWindow(
		CLASS_GIZMOBAR,
		"FormulaBar",
		WS_CHILD | WS_VISIBLE | WS_CLIPSIBLINGS,
		0, lpft->m_tdd.cyBar, rc.right-rc.left, lpft->m_tdd.cyBar,
		hWndParent,
		(HMENU)IDC_FORMULABAR,
		hInst,
		0L
	);

	if (!lpft->m_FormulaBar.m_hWnd)
		return FALSE;

	SendMessage(lpft->m_FormulaBar.m_hWnd, WM_SETREDRAW, FALSE, 0L);

	// Line add line
	GBGizmoAdd(lpft->m_FormulaBar.m_hWnd, GIZMOTYPE_BUTTONCOMMAND, uPos++, IDM_L_ADDLINE, dx, dy, NULL, lpft->m_hBmp, IDB_ADDLINE, GIZMO_NORMAL);

	// separator
	GBGizmoAdd(lpft->m_FormulaBar.m_hWnd, GIZMOTYPE_SEPARATOR, uPos++, 0, dx/2, dy, NULL, NULL, 0, GIZMO_NORMAL);

	// Line edit line, Cancel
	GBGizmoAdd(lpft->m_FormulaBar.m_hWnd, GIZMOTYPE_BUTTONCOMMAND, uPos++, IDM_L_EDITLINE, dx, dy, NULL, lpft->m_hBmp, IDB_EDITLINE, GIZMO_NORMAL);
	GBGizmoAdd(lpft->m_FormulaBar.m_hWnd, GIZMOTYPE_BUTTONCOMMAND, uPos++, IDM_FB_CANCEL, dx, dy, NULL, lpft->m_hBmp, IDB_CANCEL, GIZMO_NORMAL);

	// separator
	GBGizmoAdd(lpft->m_FormulaBar.m_hWnd, GIZMOTYPE_SEPARATOR, uPos++, 0, dx/2, dy, NULL, NULL, 0, GIZMO_NORMAL);

	// Edit control for line input
	GBGizmoAdd(lpft->m_FormulaBar.m_hWnd, GIZMOTYPE_EDIT, uPos++, IDM_FB_EDIT, dx*10, lpft->m_tdd.cyBar-5, NULL, NULL, 0, GIZMO_NORMAL);


	SendMessage(lpft->m_FormulaBar.m_hWnd, WM_SETREDRAW, TRUE, 0L);

	// Limit the text lenght of edit control
	GBGizmoSendMessage(lpft->m_FormulaBar.m_hWnd, IDM_FB_EDIT, EM_LIMITTEXT,
		(WPARAM)MAXSTRLEN, 0L);

	//Set the GizmoBar's associate to be this client window
	GBHwndAssociateSet(lpft->m_ButtonBar.m_hWnd, hWndParent);

	//Set the FormulaBar's associate to be this client window
	GBHwndAssociateSet(lpft->m_FormulaBar.m_hWnd, hWndParent);

	return TRUE;
}


void FrameTools_AttachToFrame(LPFRAMETOOLS lpft, HWND hWndFrame)
{
	if (! lpft)
		return;

	if (hWndFrame == NULL)
		hWndFrame = OutlineApp_GetFrameWindow((LPOUTLINEAPP)g_lpApp);

	if (lpft->m_hWndApp == hWndFrame)
		return;     // already have this parent frame

	lpft->m_hWndApp = hWndFrame;

	/* parent the tool bars to the frame so we can safely
	**    destroy/recreate the palette window.
	*/
	SetParent(lpft->m_ButtonBar.m_hWnd, hWndFrame);
	SetParent(lpft->m_FormulaBar.m_hWnd, hWndFrame);

	// recreate popup palette so that it is owned by the hWndFrame
	FrameTools_CreatePopupPalette(lpft, hWndFrame);

	// restore the correct parent for the tool bars
	FrameTools_BB_SetState(lpft, lpft->m_ButtonBar.m_nState);
	FrameTools_FB_SetState(lpft, lpft->m_FormulaBar.m_nState);
}


void FrameTools_AssociateDoc(LPFRAMETOOLS lpft, LPOUTLINEDOC lpOutlineDoc)
{
	HWND hWnd = OutlineDoc_GetWindow(lpOutlineDoc);

	if (! lpft)
		return;

	// if no Doc is given, then associate with the App's frame window.
	if (lpOutlineDoc)
		hWnd = OutlineDoc_GetWindow(lpOutlineDoc);
	else
		hWnd = OutlineApp_GetWindow((LPOUTLINEAPP)g_lpApp);

	//Set the GizmoBar's associate to be this client window
	GBHwndAssociateSet(lpft->m_ButtonBar.m_hWnd, hWnd);

	//Set the FormulaBar's associate to be this client window
	GBHwndAssociateSet(lpft->m_FormulaBar.m_hWnd, hWnd);
}


/*
 * FrameTools_Destroy
 *
 * Purpose:
 *  Destroy the toolbar
 *
 * Parameters:
 *  lpft            FrameTools object
 *
 * Return Value:
 *  nil
 */
void FrameTools_Destroy(LPFRAMETOOLS lpft)
{
	if (!lpft)
		return;

	if (IsWindow(lpft->m_ButtonBar.m_hWnd))
		DestroyWindow(lpft->m_ButtonBar.m_hWnd);
	if (IsWindow(lpft->m_FormulaBar.m_hWnd))
		DestroyWindow(lpft->m_FormulaBar.m_hWnd);
	if (IsWindow(lpft->m_hWndPopupPalette))
		DestroyWindow(lpft->m_hWndPopupPalette);

	if (lpft->m_hBmp)
		DeleteObject(lpft->m_hBmp);
}


/*
 * FrameTools_Move
 *
 * Purpose:
 *  Move and resize the toolbar
 *
 * Parameters:
 *  lpft            FrameTools object
 *  lprc            Pointer to client rectangle
 *
 * Return Value:
 *  nil
 */
void FrameTools_Move(LPFRAMETOOLS lpft, LPRECT lprcClient)
{
	RECT rcPopup;
	LPRECT lprcPopup = (LPRECT)&rcPopup;
	int nCmdShow = SW_HIDE;

	if (!lpft || lpft->m_fToolsDisabled)
		return;

	lprcPopup->left = 0;
	lprcPopup->top = 0;
	lprcPopup->right = lpft->m_uPopupWidth;
	lprcPopup->bottom = lpft->m_ButtonBar.m_uHeight +
			lpft->m_FormulaBar.m_uHeight;

	switch (lpft->m_ButtonBar.m_nState) {
		case BARSTATE_HIDE:
		case BARSTATE_POPUP:
		case BARSTATE_TOP:
			Bar_Move(&lpft->m_ButtonBar, lprcClient, lprcPopup);
			Bar_Move(&lpft->m_FormulaBar, lprcClient, lprcPopup);
			break;

		case BARSTATE_BOTTOM:
			Bar_Move(&lpft->m_FormulaBar, lprcClient, lprcPopup);
			Bar_Move(&lpft->m_ButtonBar, lprcClient, lprcPopup);
			break;
	}

	if (lprcPopup->top) {
		SetWindowPos(lpft->m_hWndPopupPalette, NULL, 0, 0, lprcPopup->right,
				lprcPopup->top + GetSystemMetrics(SM_CYCAPTION),
				SWP_NOMOVE | SWP_NOZORDER | SWP_NOACTIVATE | SWP_SHOWWINDOW);
	}
	else
		ShowWindow(lpft->m_hWndPopupPalette, SW_HIDE);

	FB_ResizeEdit(&lpft->m_FormulaBar);

	InvalidateRect(lpft->m_ButtonBar.m_hWnd, NULL, TRUE);
	InvalidateRect(lpft->m_FormulaBar.m_hWnd, NULL, TRUE);
}


/*
 * FrameTools_PopupTools
 *
 * Purpose:
 *  Put both formula bar and button bar in Popup Window.
 *
 * Parameters:
 *  lpft            FrameTools object
 *
 * Return Value:
 *  nil
 */
void FrameTools_PopupTools(LPFRAMETOOLS lpft)
{
	if (! lpft)
		return;

	FrameTools_BB_SetState(lpft, BARSTATE_POPUP);
	FrameTools_FB_SetState(lpft, BARSTATE_POPUP);
	FrameTools_Move(lpft, NULL);
}


/*
 * FrameTools_Enable
 *
 * Purpose:
 *  Enable/Disable(hide) all the tools of the toolbar.
 *  this will hide both the buttonbar and the
 *  formulabar independent of whether they are floating or anchored.
 *
 * Parameters:
 *  lpft            FrameTools object
 *  fEnable
 *
 * Return Value:
 *  nil
 */
void FrameTools_Enable(LPFRAMETOOLS lpft, BOOL fEnable)
{
	lpft->m_fToolsDisabled = !fEnable;
	if (lpft->m_fToolsDisabled) {
		ShowWindow(lpft->m_hWndPopupPalette, SW_HIDE);
		ShowWindow(lpft->m_ButtonBar.m_hWnd, SW_HIDE);
		ShowWindow(lpft->m_FormulaBar.m_hWnd, SW_HIDE);
	}
}


/*
 * FrameTools_EnableWindow
 *
 * Purpose:
 *  EnableWindow for all the tools of the toolbar.
 *  this enables/disables mouse and keyboard input to the tools.
 *  while a modal dialog is up, it is inportant to disable the
 *  floating tool windows.
 *  this will NOT hide any windows; it will only call EnableWindow.
 *
 * Parameters:
 *  lpft            FrameTools object
 *  fEnable
 *
 * Return Value:
 *  nil
 */
void FrameTools_EnableWindow(LPFRAMETOOLS lpft, BOOL fEnable)
{
	EnableWindow(lpft->m_hWndPopupPalette, fEnable);
	EnableWindow(lpft->m_ButtonBar.m_hWnd, fEnable);
	EnableWindow(lpft->m_FormulaBar.m_hWnd, fEnable);
}


#if defined( INPLACE_CNTR ) || defined( INPLACE_SVR )

/*
 * FrameTools_NegotiateForSpaceAndShow
 *
 * Purpose:
 *  Negotiate for space for the toolbar tools with the given frame window.
 *  and make them visible.
 *  Negotiation steps:
 *     1. try to get enough space at top/bottom of window
 *     2. float the tools as a palette if space not available
 *
 * Parameters:
 *  lpft            FrameTools object
 *
 * Return Value:
 *  none
 */
void FrameTools_NegotiateForSpaceAndShow(
		LPFRAMETOOLS            lpft,
		LPRECT                  lprcFrameRect,
		LPOLEINPLACEFRAME       lpTopIPFrame
)
{
	BORDERWIDTHS    borderwidths;
	RECT            rectBorder;
	HRESULT         hrErr;

	if (lprcFrameRect)
		rectBorder = *lprcFrameRect;
	else {
		/* OLE2NOTE: by calling GetBorder, the server can find out the
		**    size of the frame window. it can use this information to
		**    make decisions about how to orient/organize it tools (eg.
		**    if window is taller than wide put tools vertically at
		**    left edge).
		*/
		OLEDBG_BEGIN2("IOleInPlaceFrame::GetBorder called\r\n")
		hrErr = lpTopIPFrame->lpVtbl->GetBorder(
				lpTopIPFrame,
				(LPRECT)&rectBorder
		);
		OLEDBG_END2
	}

	/* Try SetBorderSpace() with the space that you need. If it fails then
	** you can negotiate for space and then do the SetBorderSpace().
	*/
	FrameTools_GetRequiredBorderSpace(lpft,(LPBORDERWIDTHS)&borderwidths);
	OLEDBG_BEGIN2("IOleInPlaceFrame::SetBorderSpace called\r\n")
	hrErr = lpTopIPFrame->lpVtbl->SetBorderSpace(
			lpTopIPFrame,
			(LPCBORDERWIDTHS)&borderwidths
	);
	OLEDBG_END2

#if defined( LATER )
	if (hrErr != NOERROR) {
		/* Frame did not give the toolsspace that we want. So negotiate */

		// REVIEW: try a different placement of the tools here

		OLEDBG_BEGIN2("IOleInPlaceFrame::RequestBorderSpace called\r\n")
		hrErr = lpTopIPFrame->lpVtbl->RequestBorderSpace(
				lpTopIPFrame,
				(LPCBORDERWIDTHS)&borderwidths
		);
		OLEDBG_END2

		if (hrErr == NOERROR) {
			OLEDBG_BEGIN2("IOleInPlaceFrame::SetBorderSpace called\r\n")
			hrErr = lpTopIPFrame->lpVtbl->SetBorderSpace(
					lpTopIPFrame,
					(LPCBORDERWIDTHS)&borderwidths
			);
			OLEDBG_END2
		}
	}
#endif

	if (hrErr == NOERROR) {
		FrameTools_Move(lpft, (LPRECT)&rectBorder);   // we got what we wanted
	} else {
		/* We did not get tool space, so POP them up.
		/* OLE2NOTE: since we are poping up our tools, we MUST inform
		**    the top in-place frame window that we need NO tool space
		**    BUT that it should NOT put its own tools up. if we were
		**    to pass NULL instead of (0,0,0,0), then the container
		**    would have the option to leave its own tools up.
		*/
		OLEDBG_BEGIN2("IOleInPlaceFrame::SetBorderSpace(NULL) called\r\n")
		hrErr = lpTopIPFrame->lpVtbl->SetBorderSpace(
				lpTopIPFrame,
				(LPCBORDERWIDTHS)&g_rectNull
		);
		OLEDBG_END2
		FrameTools_PopupTools(lpft);
	}
}

#endif  // INPLACE_CNTR || INPLACE_SVR


/*
 * FrameTools_GetRequiredBorderSpace
 *
 * Purpose:
 *  Calculate the desired space for the toolbar tools.
 *
 * Parameters:
 *  lpft            FrameTools object
 *  lpBorderWidths  Widths required at top,bottom,left,right
 *
 * Return Value:
 *  nil
 */
void FrameTools_GetRequiredBorderSpace(LPFRAMETOOLS lpft, LPBORDERWIDTHS lpBorderWidths)
{
	*lpBorderWidths = g_rectNull;

	switch (lpft->m_ButtonBar.m_nState) {
		case BARSTATE_TOP:
			lpBorderWidths->top += lpft->m_ButtonBar.m_uHeight;
			break;

		case BARSTATE_BOTTOM:
			lpBorderWidths->bottom += lpft->m_ButtonBar.m_uHeight;
			break;
	}

	switch (lpft->m_FormulaBar.m_nState) {
		case BARSTATE_TOP:
			lpBorderWidths->top += lpft->m_FormulaBar.m_uHeight;
			break;

		case BARSTATE_BOTTOM:
			lpBorderWidths->bottom += lpft->m_FormulaBar.m_uHeight;
			break;
	}
}



/*
 * FrameTools_UpdateButtons
 *
 * Purpose:
 *  Enable/disable individual buttons of the toolbar according to the
 *  state of the app
 *
 * Parameters:
 *  lpft            FrameTools object
 *
 * Return Value:
 *  nil
 */
void FrameTools_UpdateButtons(LPFRAMETOOLS lpft, LPOUTLINEDOC lpOutlineDoc)
{
	BOOL            fEnable;

#if defined( OLE_VERSION )
	LPDATAOBJECT    lpClipboardDataObj;
	HRESULT         hrErr;
	LPOLEAPP        lpOleApp = (LPOLEAPP)g_lpApp;
	BOOL            fPrevEnable1;
	BOOL            fPrevEnable2;
#endif

	if (!lpft)
		return;

#if defined( INPLACE_CNTR )
	{
		LPCONTAINERDOC lpContainerDoc = (LPCONTAINERDOC)lpOutlineDoc;
		if (lpContainerDoc->m_lpLastUIActiveLine &&
			lpContainerDoc->m_lpLastUIActiveLine->m_fUIActive) {

			/* if there is a UIActive object, then we should disable
			**    all of our "active editor" commands. we should enable
			**    only those commands that are "workspace" commands.
			*/
			if (lpft->m_FormulaBar.m_nState != BARSTATE_HIDE) {

				GBGizmoEnable(lpft->m_FormulaBar.m_hWnd,IDM_L_EDITLINE,FALSE);
				GBGizmoEnable(lpft->m_FormulaBar.m_hWnd,IDM_L_ADDLINE,FALSE);
				GBGizmoEnable(lpft->m_FormulaBar.m_hWnd,IDM_FB_CANCEL,FALSE);
				GBGizmoEnable(lpft->m_FormulaBar.m_hWnd,IDM_L_EDITLINE,FALSE);
			}

			if (lpft->m_ButtonBar.m_nState != BARSTATE_HIDE)
			{
				GBGizmoEnable(lpft->m_ButtonBar.m_hWnd, IDM_E_CUT, FALSE);
				GBGizmoEnable(lpft->m_ButtonBar.m_hWnd, IDM_E_COPY, FALSE);
				GBGizmoEnable(lpft->m_ButtonBar.m_hWnd, IDM_E_PASTE, FALSE);
				GBGizmoEnable(lpft->m_ButtonBar.m_hWnd,IDM_L_INDENTLINE,FALSE);
				GBGizmoEnable(lpft->m_ButtonBar.m_hWnd, IDM_L_UNINDENTLINE, FALSE);
				GBGizmoEnable(lpft->m_ButtonBar.m_hWnd, IDM_H_ABOUT, FALSE);
				GBGizmoEnable(lpft->m_ButtonBar.m_hWnd, IDM_FB_EDIT, FALSE);
				GBGizmoEnable(lpft->m_ButtonBar.m_hWnd, IDM_F_NEW, TRUE);
				GBGizmoEnable(lpft->m_ButtonBar.m_hWnd, IDM_F_OPEN, TRUE);
				GBGizmoEnable(lpft->m_ButtonBar.m_hWnd, IDM_F_SAVE, TRUE);
			}
			return;
		}
	}
#endif    // INPLACE_CNTR

	fEnable = (BOOL)OutlineDoc_GetLineCount(lpOutlineDoc);

	if (lpft->m_FormulaBar.m_nState != BARSTATE_HIDE) {

		GBGizmoEnable(lpft->m_FormulaBar.m_hWnd, IDM_L_EDITLINE, fEnable);

		if (! lpft->m_fInFormulaBar) {
			GBGizmoEnable(lpft->m_FormulaBar.m_hWnd, IDM_L_ADDLINE, FALSE);
			GBGizmoEnable(lpft->m_FormulaBar.m_hWnd, IDM_FB_CANCEL, FALSE);
			GBGizmoEnable(lpft->m_FormulaBar.m_hWnd, IDM_L_EDITLINE, FALSE);
			if (!fEnable) {
				GBGizmoTextSet(lpft->m_FormulaBar.m_hWnd, IDM_FB_EDIT, "");
			}
		} else {
			GBGizmoEnable(lpft->m_FormulaBar.m_hWnd, IDM_L_ADDLINE, TRUE);
			GBGizmoEnable(lpft->m_FormulaBar.m_hWnd, IDM_FB_CANCEL, TRUE);
		}
	}

	if (lpft->m_ButtonBar.m_nState != BARSTATE_HIDE)
	{
		GBGizmoEnable(lpft->m_ButtonBar.m_hWnd, IDM_E_CUT, fEnable);
		GBGizmoEnable(lpft->m_ButtonBar.m_hWnd, IDM_E_COPY, fEnable);
		GBGizmoEnable(lpft->m_ButtonBar.m_hWnd, IDM_L_INDENTLINE, fEnable);
		GBGizmoEnable(lpft->m_ButtonBar.m_hWnd, IDM_L_UNINDENTLINE, fEnable);

#if defined( OLE_SERVER )

		{
			LPSERVERDOC lpServerDoc = (LPSERVERDOC)lpOutlineDoc;

#if defined( INPLACE_SVR )
			fEnable = ((lpServerDoc->m_fUIActive) ? FALSE : TRUE);
#else
			fEnable = (lpOutlineDoc->m_docInitType != DOCTYPE_EMBEDDED);
#endif  // INPLACE_SVR

			GBGizmoEnable(lpft->m_ButtonBar.m_hWnd, IDM_F_NEW, fEnable);
			GBGizmoEnable(lpft->m_ButtonBar.m_hWnd, IDM_F_OPEN, fEnable);
			GBGizmoEnable(lpft->m_ButtonBar.m_hWnd, IDM_F_SAVE, fEnable);
		}

#endif  // OLE_SERVER

#if defined( OLE_VERSION )

		/* OLE2NOTE: we do not want to ever give the busy dialog when we
		**    are trying to enable or disable our tool bar buttons eg.
		**    even if the source of data on the clipboard is busy, we do
		**    not want put up the busy dialog. thus we will disable the
		**    dialog and at the end re-enable it.
		*/
		OleApp_DisableBusyDialogs(lpOleApp, &fPrevEnable1, &fPrevEnable2);

		/* OLE2NOTE: perform OLE specific menu initialization.
		**    the OLE versions use the OleGetClipboard mechanism for
		**    clipboard handling. thus, they determine if the Paste
		**    command should be enabled in an OLE specific manner.
		*/
		fEnable = FALSE;
		hrErr = OleGetClipboard((LPDATAOBJECT FAR*)&lpClipboardDataObj);

		if (hrErr == NOERROR) {
			int nFmtEtc;

			nFmtEtc = OleStdGetPriorityClipboardFormat(
					lpClipboardDataObj,
					lpOleApp->m_arrPasteEntries,
					lpOleApp->m_nPasteEntries
			);

			fEnable = (nFmtEtc >= 0);  // there IS a format we like

			OleStdRelease((LPUNKNOWN)lpClipboardDataObj);
		}

		// re-enable the busy dialog
		OleApp_EnableBusyDialogs(lpOleApp, fPrevEnable1, fPrevEnable2);

		GBGizmoEnable(lpft->m_ButtonBar.m_hWnd, IDM_E_PASTE, fEnable);

#else

		// Base Outline version uses standard Windows clipboard handling
		if(IsClipboardFormatAvailable(g_lpApp->m_cfOutline) ||
				IsClipboardFormatAvailable(CF_TEXT))
			GBGizmoEnable(lpft->m_ButtonBar.m_hWnd, IDM_E_PASTE, TRUE);
		else
			GBGizmoEnable(lpft->m_ButtonBar.m_hWnd, IDM_E_PASTE, FALSE);

#endif  // OLE_VERSION

	}
}

/*
 * FrameTools_FB_SetEditText
 *
 * Purpose:
 *  Set text in the edit control in FormulaBar
 *
 * Parameters:
 *  lpft            FrameTools object
 *  lpsz            pointer to string to be set
 *
 * Return Value:
 *  nil
 */
void FrameTools_FB_SetEditText(LPFRAMETOOLS lpft, LPSTR lpsz)
{
	GBGizmoTextSet(lpft->m_FormulaBar.m_hWnd, IDM_FB_EDIT, lpsz);
}


/*
 * FrameTools_FB_GetEditText
 *
 * Purpose:
 *  Get text from the edit control in FormulaBar
 *
 * Parameters:
 *  lpft            FrameTools object
 *  lpsz            pointer to buffer to receive the text
 *  cch             buffer size
 *
 * Return Value:
 *  nil
 */
void FrameTools_FB_GetEditText(LPFRAMETOOLS lpft, LPSTR lpsz, UINT cch)
{
	GBGizmoTextGet(lpft->m_FormulaBar.m_hWnd, IDM_FB_EDIT, lpsz, cch);
}


/*
 * FrameTools_FB_FocusEdit
 *
 * Purpose:
 *  Set the focus in the edit control of FormulaBar
 *
 * Parameters:
 *  lpft            FrameTools object
 *
 * Return Value:
 *  nil
 */
void FrameTools_FB_FocusEdit(LPFRAMETOOLS lpft)
{
	GBGizmoFocusSet(lpft->m_FormulaBar.m_hWnd, IDM_FB_EDIT);

	// select the whole text in the edit control
	GBGizmoSendMessage(lpft->m_FormulaBar.m_hWnd, IDM_FB_EDIT, EM_SETSEL,
			(WPARAM)TRUE, MAKELPARAM(0, -1));
}


/*
 * FrameTools_FB_SendMessage
 *
 * Purpose:
 *  Send a message to the FormulaBar window gizmo
 *
 * Parameters:
 *  lpft            FrameTools object
 *  uID             gizmo ID
 *  msg
 *  wParam
 *  lParam
 *
 * Return Value:
 *  nil
 */
void FrameTools_FB_SendMessage(LPFRAMETOOLS lpft, UINT uID, UINT msg, WPARAM wParam, LPARAM lParam)
{
	GBGizmoSendMessage(lpft->m_FormulaBar.m_hWnd, uID, msg, wParam, lParam);
}


/*
 * FrameTools_FB_ForceRedraw
 *
 * Purpose:
 *  Force the toolbar to draw itself
 *
 * Parameters:
 *  lpft            FrameTools object
 *
 * Return Value:
 *  nil
 */
void FrameTools_ForceRedraw(LPFRAMETOOLS lpft)
{
	InvalidateRect(lpft->m_ButtonBar.m_hWnd, NULL, TRUE);
	InvalidateRect(lpft->m_FormulaBar.m_hWnd, NULL, TRUE);
	InvalidateRect(lpft->m_hWndPopupPalette, NULL, TRUE);
}


/*
 * FrameTools_BB_SetState
 *
 * Purpose:
 *  Set display state of ButtonBar
 *
 * Parameters:
 *  lpft            FrameTools object
 *  nState          new display state
 *
 * Return Value:
 *  nil
 */
void FrameTools_BB_SetState(LPFRAMETOOLS lpft, int nState)
{
	if (!lpft) {
		return;
	}

	lpft->m_ButtonBar.m_nState = nState;

	if (nState == BARSTATE_POPUP)
		SetParent(lpft->m_ButtonBar.m_hWnd, lpft->m_hWndPopupPalette);
	else
		SetParent(lpft->m_ButtonBar.m_hWnd, lpft->m_hWndApp);
}


/*
 * FrameTools_BB_GetState
 *
 * Purpose:
 *  Get display state of ButtonBar
 *
 * Parameters:
 *  lpft            FrameTools object
 *
 * Return Value:
 *  nState          current display state
 */
int FrameTools_BB_GetState(LPFRAMETOOLS lpft)
{
	return lpft->m_ButtonBar.m_nState;
}


/*
 * FrameTools_FB_SetState
 *
 * Purpose:
 *  Set display state of FormulaBar
 *
 * Parameters:
 *  lpft            FrameTools object
 *  nState          new display state
 *
 * Return Value:
4 *  nil
 */
void FrameTools_FB_SetState(LPFRAMETOOLS lpft, int nState)
{
	if (!lpft) {
		return;
	}

	lpft->m_FormulaBar.m_nState = nState;

	if (nState == BARSTATE_POPUP)
		SetParent(lpft->m_FormulaBar.m_hWnd, lpft->m_hWndPopupPalette);

#if defined( INPLACE_SVR )
	/* OLE2NOTE: it is dangerous for an in-place server to hide its
	**    toolbar window and leave it parented to the hWndFrame of the
	**    in-place container. if the in-place container call
	**    ShowOwnedPopups, then it could inadvertantly be made visible.
	**    to avoid this we will parent the toolbar window back to our
	**    own application main window. if we are not in-place active
	**    then this is the same as lpft->m_hWndApp.
	*/
	else if (nState == BARSTATE_HIDE)
		SetParent(lpft->m_FormulaBar.m_hWnd, g_lpApp->m_hWndApp);
#endif

	else
		SetParent(lpft->m_FormulaBar.m_hWnd, lpft->m_hWndApp);
}


/*
 * FrameTools_FB_GetState
 *
 * Purpose:
 *  Get display state of FormulaBar
 *
 * Parameters:
 *  lpft            FrameTools object
 *
 * Return Value:
 *  nState          current display state
 */
int FrameTools_FB_GetState(LPFRAMETOOLS lpft)
{
	return lpft->m_FormulaBar.m_nState;
}


/*
 * FrameToolsWndProc
 *
 * Purpose:
 *  WndProc for toolbar window
 *
 * Parameters:
 *  hWnd
 *  Message
 *  wParam
 *  lParam
 *
 * Return Value:
 *  message dependent
 */
LRESULT FAR PASCAL FrameToolsWndProc(HWND hWnd, UINT Message, WPARAM wParam, LPARAM lParam)
{
	LPFRAMETOOLS lpft = (LPFRAMETOOLS)GetWindowLong(hWnd, 0);

	switch (Message) {

		case WM_MOUSEACTIVATE:
			return MA_NOACTIVATE;

		default:
			return DefWindowProc(hWnd, Message, wParam, lParam);
	}

	return 0L;
}


/*
 * Bar_Move
 *
 * Purpose:
 *  Resize and reposition a bar
 *
 * Parameters:
 *  lpbar           Bar object
 *  lprcClient      pointer to Client rect
 *  lprcPopup       pointer to Popup rect
 *
 * Return Value:
 *  nil
 */
static void Bar_Move(LPBAR lpbar, LPRECT lprcClient, LPRECT lprcPopup)
{
	if (lpbar->m_nState == BARSTATE_HIDE) {
		ShowWindow(lpbar->m_hWnd, SW_HIDE);
	}
	else {
		ShowWindow(lpbar->m_hWnd, SW_SHOW);
		switch (lpbar->m_nState) {
			case BARSTATE_POPUP:
				MoveWindow(lpbar->m_hWnd, lprcPopup->left, lprcPopup->top,
						lprcPopup->right - lprcPopup->left, lpbar->m_uHeight,
						TRUE);
				lprcPopup->top += lpbar->m_uHeight;
				break;

			case BARSTATE_TOP:
				MoveWindow(lpbar->m_hWnd, lprcClient->left, lprcClient->top,
						lprcClient->right - lprcClient->left,
						lpbar->m_uHeight, TRUE);
				lprcClient->top += lpbar->m_uHeight;
				break;

			case BARSTATE_BOTTOM:
				MoveWindow(lpbar->m_hWnd, lprcClient->left,
						lprcClient->bottom - lpbar->m_uHeight,
						lprcClient->right - lprcClient->left,
						lpbar->m_uHeight, TRUE);
				lprcClient->bottom -= lpbar->m_uHeight;
				break;
		}
	}
}


/*
 * FB_ResizeEdit
 *
 * Purpose:
 *  Resize the edit control in FormulaBar
 *
 * Parameters:
 *  lpft            Bar object
 *
 * Return Value:
 *  nil
 */
static void FB_ResizeEdit(LPBAR lpbar)
{
	RECT rcClient;
	RECT rcEdit;
	HWND hwndEdit;

	GetClientRect(lpbar->m_hWnd, (LPRECT)&rcClient);
	hwndEdit = GetDlgItem(lpbar->m_hWnd, IDM_FB_EDIT);
	GetWindowRect(hwndEdit, (LPRECT)&rcEdit);
	ScreenToClient(lpbar->m_hWnd, (LPPOINT)&rcEdit.left);
	ScreenToClient(lpbar->m_hWnd, (LPPOINT)&rcEdit.right);

	SetWindowPos(hwndEdit, NULL, 0, 0, rcClient.right - rcEdit.left - SPACE,
			rcEdit.bottom - rcEdit.top, SWP_NOMOVE | SWP_NOZORDER);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\letest\outline\main.c ===
/*************************************************************************
**
**    OLE 2 Sample Code
**
**    main.c
**
**    This file contains initialization functions which are WinMain,
**    WndProc, and OutlineApp_InitalizeMenu.
**
**    (c) Copyright Microsoft Corp. 1992 - 1993 All Rights Reserved
**
*************************************************************************/

#include "outline.h"
#if defined( USE_STATUSBAR )
#include "status.h"
#endif

#if !defined( WIN32 )
#if defined( USE_CTL3D )
#include "ctl3d.h"
#endif  // USE_CTL3D
#endif  // !WIN32

#include "initguid.h"           // forces our GUIDs to be initialized
#include "defguid.h"

// OLETEST driver window handler
HWND g_hwndDriver;

#if defined( OLE_CNTR )
//*************************************************************************

#if defined( INPLACE_CNTR )
OLEDBGDATA_MAIN("ICNTR")
#else
OLEDBGDATA_MAIN("CNTR")
#endif


CONTAINERAPP g_OutlineApp;  // Global App object maintains app instance state

/* Global interface Vtbl's
 * OLE2NOTE: we only need one copy of each Vtbl. When an object which
 *      exposes an interface is instantiated, its lpVtbl is intialized
 *      to point to one of these global Vtbl's.
 */
IUnknownVtbl            g_OleApp_UnknownVtbl;
IClassFactoryVtbl       g_OleApp_ClassFactoryVtbl;
IMessageFilterVtbl      g_OleApp_MessageFilterVtbl;

IUnknownVtbl            g_OleDoc_UnknownVtbl;
IPersistFileVtbl        g_OleDoc_PersistFileVtbl;
IOleItemContainerVtbl   g_OleDoc_OleItemContainerVtbl;
IExternalConnectionVtbl g_OleDoc_ExternalConnectionVtbl;
IDataObjectVtbl         g_OleDoc_DataObjectVtbl;

#if defined( USE_DRAGDROP )
IDropSourceVtbl         g_OleDoc_DropSourceVtbl;
IDropTargetVtbl         g_OleDoc_DropTargetVtbl;
#endif  // USE_DRAGDROP

IOleUILinkContainerVtbl g_CntrDoc_OleUILinkContainerVtbl;

IOleClientSiteVtbl      g_CntrLine_UnknownVtbl;
IOleClientSiteVtbl      g_CntrLine_OleClientSiteVtbl;
IAdviseSinkVtbl         g_CntrLine_AdviseSinkVtbl;

#if defined( INPLACE_CNTR )
IOleInPlaceSiteVtbl     g_CntrLine_OleInPlaceSiteVtbl;
IOleInPlaceFrameVtbl    g_CntrApp_OleInPlaceFrameVtbl;
BOOL g_fInsideOutContainer = FALSE;     // default to outside-in activation
#endif  // INPLACE_CNTR

//*************************************************************************
#endif  // OLE_CNTR

#if defined( OLE_SERVER )
//*************************************************************************

#if defined( INPLACE_SVR )
OLEDBGDATA_MAIN("ISVR")
#else
OLEDBGDATA_MAIN("SVR")
#endif

SERVERAPP g_OutlineApp; // Global App object maintains app instance state

/* Global interface Vtbl's
 * OLE2NOTE: we only need one copy of each Vtbl. When an object which
 *      exposes an interface is instantiated, its lpVtbl is intialized
 *      to point to one of these global Vtbl's.
 */
IUnknownVtbl            g_OleApp_UnknownVtbl;
IClassFactoryVtbl       g_OleApp_ClassFactoryVtbl;
IMessageFilterVtbl      g_OleApp_MessageFilterVtbl;

IUnknownVtbl            g_OleDoc_UnknownVtbl;
IPersistFileVtbl        g_OleDoc_PersistFileVtbl;
IOleItemContainerVtbl   g_OleDoc_OleItemContainerVtbl;
IExternalConnectionVtbl g_OleDoc_ExternalConnectionVtbl;
IDataObjectVtbl         g_OleDoc_DataObjectVtbl;

#if defined( USE_DRAGDROP )
IDropSourceVtbl         g_OleDoc_DropSourceVtbl;
IDropTargetVtbl         g_OleDoc_DropTargetVtbl;
#endif  // USE_DRAGDROP

IOleObjectVtbl          g_SvrDoc_OleObjectVtbl;
IPersistStorageVtbl     g_SvrDoc_PersistStorageVtbl;

#if defined( SVR_TREATAS )
IStdMarshalInfoVtbl     g_SvrDoc_StdMarshalInfoVtbl;
#endif  // SVR_TREATAS

#if defined( INPLACE_SVR )
IOleInPlaceObjectVtbl       g_SvrDoc_OleInPlaceObjectVtbl;
IOleInPlaceActiveObjectVtbl g_SvrDoc_OleInPlaceActiveObjectVtbl;
#endif // INPLACE_SVR

IUnknownVtbl            g_PseudoObj_UnknownVtbl;
IOleObjectVtbl          g_PseudoObj_OleObjectVtbl;
IDataObjectVtbl         g_PseudoObj_DataObjectVtbl;

//*************************************************************************
#endif  // OLE_SVR

#if !defined( OLE_VERSION )
OLEDBGDATA_MAIN("OUTL")
OUTLINEAPP g_OutlineApp;    // Global App object maintains app instance state
#endif

LPOUTLINEAPP g_lpApp=(LPOUTLINEAPP)&g_OutlineApp;   // ptr to global app obj
RECT        g_rectNull = {0, 0, 0, 0};
UINT        g_uMsgHelp = 0;  // help msg from ole2ui dialogs
BOOL        g_fAppActive = FALSE;

/* WinMain
** -------
**    Main routine for the Windows application.
*/
int PASCAL WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,
						LPSTR lpszCmdLine, int nCmdShow)
{
	LPOUTLINEAPP lpOutlineApp = (LPOUTLINEAPP)g_lpApp;
	MSG         msg;            /* MSG structure to store your messages */
	LPSTR pszTemp;

#if defined( OLE_VERSION )
	/* OLE2NOTE: it is recommended that all OLE applications to set
	**    their message queue size to 96. this improves the capacity
	**    and performance of OLE's LRPC mechanism.
	*/
	int cMsg = 96;   // recommend msg queue size for OLE
	while (cMsg && ! SetMessageQueue(cMsg))  // take largest size we can get.
		cMsg -= 8;
	if (! cMsg)
		return -1;  // ERROR: we got no message queue
#endif

#if defined( USE_CTL3D )
   Ctl3dRegister(hInstance);
   Ctl3dAutoSubclass(hInstance);
#endif

	if(! hPrevInstance) {
		/* register window classes if first instance of application */
		if(! OutlineApp_InitApplication(lpOutlineApp, hInstance))
			return 0;
	}

	/* Create App Frame window */
	if (! OutlineApp_InitInstance(lpOutlineApp, hInstance, nCmdShow))
		return 0;

	if( (pszTemp = strstr(lpszCmdLine, "-driver")) )
	{
		//we were launched by the test driver
		g_hwndDriver = (HWND)strtoul(pszTemp+8, &lpszCmdLine, 10);
	}
	else
	{
		g_hwndDriver = NULL;
	}

	if (! OutlineApp_ParseCmdLine(lpOutlineApp, lpszCmdLine, nCmdShow))
		return 0;

	lpOutlineApp->m_hAccelApp = LoadAccelerators(hInstance, APPACCEL);
	lpOutlineApp->m_hAccelFocusEdit = LoadAccelerators(hInstance,
			FB_EDIT_ACCEL);
	lpOutlineApp->m_hAccel = lpOutlineApp->m_hAccelApp;
	lpOutlineApp->m_hWndAccelTarget = lpOutlineApp->m_hWndApp;

	if( g_hwndDriver )
	{
		PostMessage(g_hwndDriver, WM_TESTREG,
			(WPARAM)lpOutlineApp->m_hWndApp, 0);
	}

	// Main message loop
	while(GetMessage(&msg, NULL, 0, 0)) {        /* Until WM_QUIT message */
		if(!MyTranslateAccelerator(&msg)) {
			TranslateMessage(&msg);
			DispatchMessage(&msg);
		}
	}

#if defined( OLE_VERSION )
	OleApp_TerminateApplication((LPOLEAPP)lpOutlineApp);
#else
	/* OLE2NOTE: CoInitialize() is called in OutlineApp_InitInstance
	**    and therefore we need to uninitialize it when exit.
	*/
	CoUninitialize();
#endif

#if defined( USE_CTL3D )
   Ctl3dUnregister(hInstance);
#endif

	return msg.wParam;

} /*  End of WinMain */

BOOL MyTranslateAccelerator(LPMSG lpmsg)
{
	// if it's not a keystroke it can not be an accelerator
	if (lpmsg->message < WM_KEYFIRST || lpmsg->message > WM_KEYLAST)
		return FALSE;

	if (g_lpApp->m_hWndAccelTarget &&
		TranslateAccelerator(g_lpApp->m_hWndAccelTarget,
													g_lpApp->m_hAccel,lpmsg))
		return TRUE;

#if defined( INPLACE_SVR )
	/* OLE2NOTE: if we are in-place active and we did not translate the
	**    accelerator, we need to give the top-level (frame) in-place
	**    container a chance to translate the accelerator.
	**    we ONLY need to call OleTranslateAccelerator API if the
	**    message is a keyboard message. otherwise it is harmless but
	**    unnecessary.
	**
	**    NOTE: even a in-place server that does NOT have any
	**    Accelerators must still call OleTranslateAccelerator for all
	**    keyboard messages so that the server's OWN menu mneumonics
	**    (eg. &Edit -- Alt-e) function properly.
	**
	**    NOTE: an in-place server MUST check that the accelerator is
	**    NOT one of its own accelerators BEFORE calling
	**    OleTranslateAccelerator which tries to see if it is a
	**    container accelerator. if this is a server accelerator that
	**    was not translateed because the associated menu command was
	**    disabled, we MUST NOT call OleTranslateAccelerator. The
	**    IsAccelerator helper API has been added to assist with this
	**    check.
	*/
	if (g_OutlineApp.m_lpIPData &&
		!IsAccelerator(g_lpApp->m_hAccel,
			GetAccelItemCount(g_lpApp->m_hAccel), lpmsg,NULL) &&
		OleTranslateAccelerator(g_OutlineApp.m_lpIPData->lpFrame,
				(LPOLEINPLACEFRAMEINFO)&g_OutlineApp.m_lpIPData->frameInfo,
				lpmsg) == NOERROR) {
		return TRUE;
	}
#endif

	return FALSE;
}


/************************************************************************/
/*                                                                      */
/* Main Window Procedure                                                */
/*                                                                      */
/* This procedure provides service routines for the Windows events      */
/* (messages) that Windows sends to the window, as well as the user     */
/* initiated events (messages) that are generated when the user selects */
/* the action bar and pulldown menu controls or the corresponding       */
/* keyboard accelerators.                                               */
/*                                                                      */
/************************************************************************/

LRESULT FAR PASCAL AppWndProc(HWND hWnd, UINT Message, WPARAM wParam, LPARAM lParam)
{
	LPOUTLINEAPP lpOutlineApp = (LPOUTLINEAPP)GetWindowLong(hWnd, 0);
	LPOUTLINEDOC lpOutlineDoc = NULL;
#if defined( OLE_VERSION )
	LPOLEAPP lpOleApp = (LPOLEAPP)lpOutlineApp;
#endif
#if defined( OLE_CNTR )
	LPCONTAINERAPP lpContainerApp = (LPCONTAINERAPP)lpOutlineApp;
#endif
	HWND         hWndDoc = NULL;

#if defined( USE_FRAMETOOLS )
	LPFRAMETOOLS lptb = OutlineApp_GetFrameTools(lpOutlineApp);
#endif

	if (lpOutlineApp) {
		lpOutlineDoc = OutlineApp_GetActiveDoc(lpOutlineApp);

		if (lpOutlineDoc)
			hWndDoc = OutlineDoc_GetWindow(lpOutlineDoc);
	}

	switch (Message) {
		case WM_TEST1:
			StartClipboardTest1(lpOutlineApp);
			break;
		case WM_TEST2:
			ContinueClipboardTest1(lpOutlineApp);
			break;
		case WM_COMMAND:
		{
#ifdef WIN32
			WORD wID    = LOWORD(wParam);
#else
			WORD wID    = wParam;
#endif

#if defined( INPLACE_CNTR )
			LPCONTAINERDOC lpContainerDoc = (LPCONTAINERDOC)lpOutlineDoc;
			LPOLEDOC lpOleDoc = (LPOLEDOC)lpOutlineDoc;

			/* OLE2NOTE: see context sensitive help technote (CSHELP.DOC)
			**    m_fMenuHelpMode flag is set when F1 is pressed when a
			**    menu item is selected. this flag is set in
			**    IOleInPlaceFrame::ContextSensitveHelp method.
			**    m_fCSHelpMode flag is set when SHIFT-F1 context
			**    sensitive help is entered. this flag is set in
			**    IOleInPlaceSite::ContextSensitiveHelp method.
			**    if either of these flags are set then the WM_COMMAND
			**    message is received then, the corresponding command
			**    should NOT executed; help can be given (if desired).
			**    also the context sensitve help mode should be exited.
			**    the two different cases have their own way to exit
			**    the mode (please refer to the technote).
			*/
			if (lpOleDoc &&
				(lpContainerApp->m_fMenuHelpMode||lpOleDoc->m_fCSHelpMode) &&
				(wID > IDM_FILE)   /* min wID for app command */ &&
				(wID!=IDM_FB_EDIT) /* special wID to control FormulaBar */ ) {

				if ((lpContainerApp->m_fMenuHelpMode)) {
					LPOLEINPLACEACTIVEOBJECT lpIPActiveObj =
							lpContainerApp->m_lpIPActiveObj;

					lpContainerApp->m_fMenuHelpMode = FALSE;

					// inform the in-place active object that we handled the
					//   menu help mode (F1) selection.
					if (lpIPActiveObj) {
						OLEDBG_BEGIN2("IOleInPlaceActiveObject::ContextSensitiveHelp(FALSE) called\r\n")
						lpIPActiveObj->lpVtbl->ContextSensitiveHelp(
								lpIPActiveObj, FALSE);
						OLEDBG_END2
					}
				}

				if ((lpOleDoc->m_fCSHelpMode)) {
					LPOLEINPLACEOBJECT lpIPObj;
					LPCONTAINERLINE lpLastIpActiveLine =
							lpContainerDoc->m_lpLastIpActiveLine;

					lpOleDoc->m_fCSHelpMode = FALSE;

					/* inform immediate in-place container parent and,
					**    if we were a container/server, immediate
					**    in-place object children that we handled the
					**    context sensitive help mode.
					*/
					if (lpLastIpActiveLine &&
							(lpIPObj=lpLastIpActiveLine->m_lpOleIPObj)!=NULL){
						OLEDBG_BEGIN2("IOleInPlaceObject::ContextSensitiveHelp(FALSE) called\r\n")
						lpIPObj->lpVtbl->ContextSensitiveHelp(lpIPObj, FALSE);
						OLEDBG_END2
					}
				}

				// if we provided help, we would do it here...

				// remove context sensitive help cursor
				SetCursor(LoadCursor(NULL,IDC_ARROW));
				return 0L;
			}
#endif  // INPLACE_CNTR

			switch (wID) {

				case IDM_F_NEW:
					OleDbgIndent(-2);   // Reset debug output indent level
					OleDbgOutNoPrefix2("\r\n");

					OLEDBG_BEGIN3("OutlineApp_NewCommand\r\n")
					OutlineApp_NewCommand(lpOutlineApp);
					OLEDBG_END3

#if defined( OLE_CNTR )
					/* OLE2NOTE: this call will attempt to recover
					**    resources by unloading DLL's that were loaded
					**    by OLE and are no longer being used. it is a
					**    good idea to call this API now and then if
					**    your app tends to run for a long time.
					**    otherwise these DLL's will be unloaded when
					**    the app exits. some apps may want to call
					**    this as part of idle-time processing. this
					**    call is optional.
					*/
					OLEDBG_BEGIN2("CoFreeUnusedLibraries called\r\n")
					CoFreeUnusedLibraries();
					OLEDBG_END2
#endif

#if defined( USE_FRAMETOOLS )
					OutlineDoc_UpdateFrameToolButtons(
							OutlineApp_GetActiveDoc(lpOutlineApp));
#endif
					break;

				case IDM_F_OPEN:
					OleDbgOutNoPrefix2("\r\n");

					OLEDBG_BEGIN3("OutlineApp_OpenCommand\r\n")
					OutlineApp_OpenCommand(lpOutlineApp);
					OLEDBG_END3

#if defined( OLE_CNTR )
					/* OLE2NOTE: this call will attempt to recover
					**    resources by unloading DLL's that were loaded
					**    by OLE and are no longer being used. it is a
					**    good idea to call this API now and then if
					**    your app tends to run for a long time.
					**    otherwise these DLL's will be unloaded when
					**    the app exits. some apps may want to call
					**    this as part of idle-time processing. this
					**    call is optional.
					*/
					OLEDBG_BEGIN2("CoFreeUnusedLibraries called\r\n")
					CoFreeUnusedLibraries();
					OLEDBG_END2
#endif

#if defined( USE_FRAMETOOLS )
					OutlineDoc_UpdateFrameToolButtons(
							OutlineApp_GetActiveDoc(lpOutlineApp));
#endif
					break;

				case IDM_F_SAVE:
					OleDbgOutNoPrefix2("\r\n");

					OLEDBG_BEGIN3("OutlineApp_SaveCommand\r\n")
					OutlineApp_SaveCommand(lpOutlineApp);
					OLEDBG_END3
					break;

				case IDM_F_SAVEAS:
					OleDbgOutNoPrefix2("\r\n");

					OLEDBG_BEGIN3("OutlineApp_SaveAsCommand\r\n")
					OutlineApp_SaveAsCommand(lpOutlineApp);
					OLEDBG_END3
					break;

				case IDM_F_PRINT:
					OleDbgOutNoPrefix2("\r\n");

					OLEDBG_BEGIN3("OutlineApp_PrintCommand\r\n")
					OutlineApp_PrintCommand(lpOutlineApp);
					OLEDBG_END3
					break;

				case IDM_F_PRINTERSETUP:
					OleDbgOutNoPrefix2("\r\n");

					OLEDBG_BEGIN3("OutlineApp_PrinterSetupCommand\r\n")
					OutlineApp_PrinterSetupCommand(lpOutlineApp);
					OLEDBG_END3
					break;

				case IDM_F_EXIT:
					SendMessage(hWnd, WM_CLOSE, 0, 0L);
					break;

				case IDM_H_ABOUT:
					OutlineApp_AboutCommand(lpOutlineApp);
					break;

#if defined( INPLACE_CNTR )
				case IDM_ESCAPE:
				{
					/* ESCAPE key pressed */
					LPCONTAINERDOC lpContainerDoc =
								(LPCONTAINERDOC)lpOutlineDoc;

					/* OLE2NOTE: The standard OLE 2.0 UI convention
					**    is to have ESCAPE key exit in-place
					**    activation (ie. UIDeactivate). If
					**    possible it is recommended for both
					**    in-place servers AND in-place containers
					**    to take responsibility to handle the
					**    ESCAPE key accelerator. The server has
					**    the first crack at handling accelerator
					**    keys and normally the server should do
					**    the UIDeactivation. It is a good idea for
					**    in-place containers, in order to
					**    guarantee consistent behavior, to also
					**    handle the ESCAPE key and UIDeactivate
					**    the object in case the object does not do
					**    it itself. normally this should be
					**    unnecessary.
					*/
					if (lpContainerDoc->m_lpLastUIActiveLine &&
						lpContainerDoc->m_lpLastUIActiveLine->m_fUIActive)
					{
						ContainerLine_UIDeactivate(
								lpContainerDoc->m_lpLastUIActiveLine);
					}
					break;
				}
#endif  // INPLACE_CNTR


				default:
					// forward message to document window
					if (hWndDoc) {
						return DocWndProc(hWndDoc, Message,wParam,lParam);
					}
			}

			break;  /* End of WM_COMMAND */
		}

		case WM_INITMENU:
			OutlineApp_InitMenu(lpOutlineApp, lpOutlineDoc, (HMENU)wParam);
			break;

#if defined( OLE_VERSION )

		/* OLE2NOTE: WM_INITMENUPOPUP is trapped primarily for the Edit
		**    menu. We didn't update the Edit menu until it is popped
		**    up to avoid the overheads of the OLE calls which are
		**    required to initialize some Edit menu items.
		*/
		case WM_INITMENUPOPUP:
		{
			HMENU hMenuEdit = GetSubMenu(lpOutlineApp->m_hMenuApp, 1);
#if defined( INPLACE_CNTR )
			LPCONTAINERDOC lpContainerDoc = (LPCONTAINERDOC)lpOutlineDoc;

			/* OLE2NOTE: we must check if there is an object currently
			**    in-place UIActive. if so, then our edit menu is not
			**    on the menu; we do not want to bother updating the
			**    edit menu when it is not even there.
			*/
			if (lpContainerDoc && lpContainerDoc->m_lpLastUIActiveLine &&
				lpContainerDoc->m_lpLastUIActiveLine->m_fUIActive)
				break;  // an object is in-place UI active
#endif
			if ((HMENU)wParam == hMenuEdit &&
				(LOWORD(lParam) == POS_EDITMENU) &&
				OleDoc_GetUpdateEditMenuFlag((LPOLEDOC)lpOutlineDoc)) {
				OleApp_UpdateEditMenu(lpOleApp, lpOutlineDoc, hMenuEdit);
			}
			break;
		}
#endif      // OLE_VERSION

		case WM_SIZE:
			if (wParam != SIZE_MINIMIZED)
				OutlineApp_ResizeWindows(lpOutlineApp);
			break;


		case WM_ACTIVATEAPP:
#if defined (OLE_CNTR)
			if (g_fAppActive = (BOOL) wParam)
				OleApp_QueryNewPalette(lpOleApp);
#endif

#if defined( INPLACE_CNTR )
			{
				BOOL fActivate = (BOOL)wParam;
				LPOLEINPLACEACTIVEOBJECT lpIPActiveObj =
						lpContainerApp->m_lpIPActiveObj;

				/* OLE2NOTE: the in-place container MUST inform the
				**    inner most in-place active object (this is NOT
				**    necessarily our immediate child if there are
				**    nested levels of embedding) of the WM_ACTIVATEAPP
				**    status.
				*/
				if (lpIPActiveObj) {
#if defined( _DEBUG )
					OLEDBG_BEGIN2((fActivate ?
						"IOleInPlaceActiveObject::OnFrameWindowActivate(TRUE) called\r\n" :
						"IOleInPlaceActiveObject::OnFrameWindowActivate(FALSE) called\r\n"))
#endif  // _DEUBG
					lpIPActiveObj->lpVtbl->OnFrameWindowActivate(
						lpIPActiveObj, fActivate);
					OLEDBG_END2
				}
			}

#endif  // INPLACE_CNTR

			// OLE2NOTE: We can't call OutlineDoc_UpdateFrameToolButtons
			//           right away which
			//           would generate some OLE calls and eventually
			//           WM_ACTIVATEAPP and a loop was formed. Therefore, we
			//           should delay the frame tool initialization until
			//           WM_ACTIVATEAPP is finished by posting a message
			//           to ourselves.
			//           we want to ignore the WM_ACTIVATEAPP that comes
			//           as we bring up a modal dialog.

			/* Update enable/disable state of buttons in toolbar */
			if (wParam
#if defined( OLE_VERSION )
					&& lpOleApp->m_cModalDlgActive == 0
#endif
			) {
				PostMessage(hWnd, WM_U_INITFRAMETOOLS, 0, 0L);
			}
			return 0L;

		case WM_SETFOCUS:
			SetFocus(hWndDoc);
			break;


#if defined( OLE_CNTR )
		case WM_QUERYNEWPALETTE:
			if (!g_fAppActive)
				return 0L;

			return OleApp_QueryNewPalette(lpOleApp);

		case WM_PALETTECHANGED:
		{
			HWND hWndPalChg = (HWND) wParam;
			static BOOL fInPaletteChanged = FALSE;

			if (fInPaletteChanged)  // Guard against recursion
				return 0L;

			fInPaletteChanged = TRUE;

			if (hWnd != hWndPalChg)
				wSelectPalette(hWnd, lpOleApp->m_hStdPal,TRUE/*fBackground*/);

#if defined( INPLACE_CNTR )
			/* OLE2NOTE: always forward the WM_PALETTECHANGED message (via
			**    SendMessage) to any in-place objects that currently have
			**    their window visible. this gives these objects the chance
			**    to select their palettes. this is
			**    REQUIRED by all in-place containers independent of
			**    whether they use color palettes themselves--their objects
			**    may use color palettes.
			**    (see ContainerDoc_ForwardPaletteChangedMsg for more info)
			*/
			if (lpOutlineDoc){
				ContainerDoc_ForwardPaletteChangedMsg(
						(LPCONTAINERDOC)lpOutlineDoc, hWndPalChg);
			}
#endif  // INPLACE_CNTR

			fInPaletteChanged = FALSE;
			return 0L;
		}
#endif  // OLE_CNTR

		case WM_DESTROY:
			PostQuitMessage(0);
			break;

		case WM_CLOSE:  /* close the window */

			/* Close all active documents. if successful, then exit */
			OleDbgOutNoPrefix2("\r\n");

			OutlineApp_CloseAllDocsAndExitCommand(lpOutlineApp, FALSE);
			break;

		case WM_QUERYENDSESSION:
		{
#if defined( OLE_CNTR )
			/* OLE2NOTE: we are not able to make OLE LRPC calls when
			**    WM_QUERYENDSESSION is recieved (this is a
			**    SendMessage). this means, for example, that we are
			**    NOT able to ask objects to save. thus the most we can
			**    do is ask the user if he wants to exit with
			**    discarding changes or else abort shutting down.
			*/

			int nResponse = MessageBox(
					hWnd,
					"Discard changes?",
					APPNAME,
					MB_ICONQUESTION | MB_OKCANCEL
			);
			if(nResponse == IDOK)
				return 1L;      /* can terminate */

#endif
#if defined( OLE_SERVER )
			/* OLE2NOTE: an embedded object should never prompt whether
			**    it should be saved (according the OLE 2.0 User
			**    Model). therefore, an embedded object will never
			**    complain that it needs to be saved. it will always
			**    allow the QueryEndSession to proceed.
			*/
			if (lpOutlineApp->m_lpDoc->m_docInitType == DOCTYPE_EMBEDDED)
				return 1L;      /* can terminate */
			else
#endif
			{
				/* this is not an embedded object; it is a user
				**    document. we will prompt if the user wants to
				**    save the document now in WM_QUERYENDSESSION. if
				**    the user cancels then that would abort the
				**    shutdown. if the user does not abort, then later
				**    in WM_ENDSESSION the document will be actually
				**    closed.
				**
				**    Because this is an SDI app, there is only one
				**    document. An MDI would need to loop through all
				**    open documents.
				*/
				DWORD dwSaveOption = OLECLOSE_PROMPTSAVE;
				if (OutlineDoc_CheckSaveChanges(
						lpOutlineApp->m_lpDoc, &dwSaveOption))
					return 1L;      /* can terminate */
			}

			/* else: can't terminate now */

			break;
		}

#if defined( OLE_VERSION)
		case WM_ENDSESSION:
		{
			BOOL fEndSession = (BOOL)wParam;

			if (fEndSession) {
				OutlineApp_CloseAllDocsAndExitCommand(lpOutlineApp, TRUE);
				return 0L;
			}
		}
		break;
#endif  // OLE_VERSION


#if defined( USE_STATUSBAR )
		case WM_MENUSELECT:
		{
			LPSTR lpszMessage;
#ifdef WIN32
			UINT fuFlags    = (UINT)HIWORD(wParam);
			UINT uItem      = (UINT)LOWORD(wParam);
#else
			UINT fuFlags    = (UINT)LOWORD(lParam);
			UINT uItem      = (UINT)wParam;
#endif

			if (uItem == 0 && fuFlags == (UINT)-1) {
				GetControlMessage(STATUS_READY, &lpszMessage);
				OutlineApp_SetStatusText(lpOutlineApp, lpszMessage);
			}
			else if (fuFlags & MF_POPUP) {
#ifdef WIN32
				HMENU hMainMenu = (HMENU)lParam;
				HMENU hPopupMenu = GetSubMenu(hMainMenu,uItem);
#else
				HMENU hPopupMenu = (HMENU)wParam;
#endif
				GetPopupMessage(hPopupMenu, &lpszMessage);
				OutlineApp_SetStatusText(lpOutlineApp, lpszMessage);
			}
			else if (fuFlags & MF_SYSMENU) {
				GetSysMenuMessage(uItem, &lpszMessage);
				OutlineApp_SetStatusText(lpOutlineApp, lpszMessage);
			}
			else if (uItem != 0) {  // Command Item
				GetItemMessage(uItem, &lpszMessage);
				OutlineApp_SetStatusText(lpOutlineApp, lpszMessage);
			}
			else {
				GetControlMessage(STATUS_BLANK, &lpszMessage);
				OutlineApp_SetStatusText(lpOutlineApp, lpszMessage);
			}
			break;
		}
#endif  // USE_STATUSBAR


#if defined( USE_FRAMETOOLS )
		case WM_U_INITFRAMETOOLS:
			OutlineDoc_UpdateFrameToolButtons(lpOutlineDoc);
			break;
#endif

		default:
			/* For any message for which you don't specifically provide a  */
			/* service routine, you should return the message to Windows   */
			/* for default message processing.                             */

			return DefWindowProc(hWnd, Message, wParam, lParam);
	}

	return (LRESULT)0;
}     /* End of AppWndProc                                         */


/************************************************************************/
/*                                                                      */
/* Document Window Procedure                                            */
/*                                                                      */
/*   The Document Window is the parent of the OwnerDraw Listbox which   */
/* maintains the list of lines in the current document. This window     */
/* receives the ownerdraw callback messages from the list box.          */
/************************************************************************/

LRESULT FAR PASCAL DocWndProc(HWND hWnd, UINT Message, WPARAM wParam, LPARAM lParam)
{
	LPOUTLINEAPP    lpOutlineApp = (LPOUTLINEAPP)g_lpApp;
	LPOUTLINEDOC    lpOutlineDoc = (LPOUTLINEDOC)GetWindowLong(hWnd, 0);
	LPLINELIST      lpLL = OutlineDoc_GetLineList(lpOutlineDoc);
	LPSCALEFACTOR   lpscale = OutlineDoc_GetScaleFactor(lpOutlineDoc);

#if defined( OLE_VERSION )
	LPOLEAPP lpOleApp = (LPOLEAPP)lpOutlineApp;
	LPOLEDOC lpOleDoc = (LPOLEDOC)lpOutlineDoc;
#if defined( OLE_CNTR )
	LPCONTAINERDOC lpContainerDoc = (LPCONTAINERDOC)lpOutlineDoc;
#endif
#if defined( OLE_SERVER )
	LPSERVERDOC lpServerDoc = (LPSERVERDOC)lpOutlineDoc;
#endif
#if defined( INPLACE_CNTR )
	LPCONTAINERAPP lpContainerApp = (LPCONTAINERAPP)lpOutlineApp;
#endif
#endif  // OLE_VERSION

	switch(Message) {

#if defined( INPLACE_SVR )

		/* OLE2NOTE: ISVROTL doesn't use color palettes. The inplace objects
		**    that use color palettes must implement the following
		**    lines of code.
		**
			case WM_QUERYNEWPALETTE:
				return wSelectPalette(hWnd, hPal, FALSE); // foreground

			case WM_PALETTECHANGED:
				if (hWnd != (HWND) wParam)
					wSelectPalette(hWnd, hPal, TRUE);     // background
			break;
		**
		**
		**
		*/
#endif

		case WM_MEASUREITEM:
		{
			LPMEASUREITEMSTRUCT lpmis = ((LPMEASUREITEMSTRUCT)lParam);

			switch (wParam) {
				case IDC_LINELIST:
				{
					HDC hDC = LineList_GetDC(lpLL);
					UINT uHeight;

					uHeight=Line_GetHeightInHimetric((LPLINE)lpmis->itemData);
					uHeight = XformHeightInHimetricToPixels(hDC, uHeight);
					uHeight = (UINT) (uHeight * lpscale->dwSyN /
							lpscale->dwSyD);

					if (uHeight >LISTBOX_HEIGHT_LIMIT)
						uHeight = LISTBOX_HEIGHT_LIMIT;

					lpmis->itemHeight = uHeight;
					LineList_ReleaseDC(lpLL, hDC);
					break;
				}

				case IDC_NAMETABLE:
				{
					// NOTE: NameTable is never made visible. do nothing.
					break;
				}

#if defined( USE_HEADING )
				case IDC_ROWHEADING:
				{
					UINT uHeight;

					uHeight = LOWORD(lpmis->itemData);
					uHeight = (UINT) (uHeight * lpscale->dwSyN /
							lpscale->dwSyD);
					if (uHeight >LISTBOX_HEIGHT_LIMIT)
						uHeight = LISTBOX_HEIGHT_LIMIT;
					lpmis->itemHeight = uHeight;
					break;
				}

				case IDC_COLHEADING:
				{
					UINT uHeight;

					uHeight = LOWORD(lpmis->itemData);
					uHeight = (UINT) (uHeight * lpscale->dwSyN /
							lpscale->dwSyD);
					if (uHeight > LISTBOX_HEIGHT_LIMIT)
						uHeight = LISTBOX_HEIGHT_LIMIT;
					lpmis->itemHeight = uHeight;
					break;
				}
#endif  // USE_HEADING

			}
			return (LRESULT)TRUE;
		}

		case WM_DRAWITEM:
		{
			LPDRAWITEMSTRUCT lpdis = ((LPDRAWITEMSTRUCT)lParam);

			switch (lpdis->CtlID) {

				case IDC_LINELIST:
				{
					RECT   rcClient;
					RECT   rcDevice;
					HWND   hWndLL = LineList_GetWindow(lpLL);
					LPLINE lpLine = (LPLINE)lpdis->itemData;

					// NOTE: When itemID == -1, the listbox is empty.
					//       We are supposed to draw focus rect only
					//       But it is not done in this app. If this line is
					//       removed, the app will crash in Line_DrawToScreen
					//       because of invalid lpLine.
					if (lpdis->itemID == -1)
						break;

					GetClientRect(hWndLL, &rcClient);

					rcDevice = lpdis->rcItem;

					// shift the item rect to account for horizontal scrolling

					rcDevice.left += rcClient.right - lpdis->rcItem.right;

#if defined( OLE_CNTR )
					/* we need to remember the horizontal scroll offset
					**    needed for the in-place object's window.
					**    (this is specific to ICNTROTL)
					*/
					if(lpdis->itemAction & ODA_DRAWENTIRE) {
						if (Line_GetLineType(lpLine) == CONTAINERLINETYPE)
							((LPCONTAINERLINE)lpLine)->m_nHorizScrollShift =
								rcDevice.left;
					}
#endif  // OLE_CNTR

					// shift rect for left margin
					rcDevice.left += (int)(XformWidthInHimetricToPixels(NULL,
							LOWORD(OutlineDoc_GetMargin(lpOutlineDoc))) *
							lpscale->dwSxN / lpscale->dwSxD);

					rcDevice.right = rcDevice.left +
							(int)(XformWidthInHimetricToPixels(lpdis->hDC,
									Line_GetWidthInHimetric(lpLine)) *
							lpscale->dwSxN / lpscale->dwSxD);

					Line_DrawToScreen(
							lpLine,
							lpdis->hDC,
							&lpdis->rcItem,
							lpdis->itemAction,
							lpdis->itemState,
							&rcDevice
					);

#if defined( USE_FRAMETOOLS )
					if (lpdis->itemState & ODS_FOCUS)
						OutlineDoc_SetFormulaBarEditText(lpOutlineDoc,lpLine);
#endif
					break;
				}
				case IDC_NAMETABLE:
				{
					// NOTE: NameTable is never made visible. do nothing
					break;
				}

#if defined( USE_HEADING )
				case IDC_ROWHEADING:
				{
					LPHEADING lphead;

					// Last dummy item shouldn't be drawn
					if (lpdis->itemID == (UINT)LineList_GetCount(lpLL))
						break;

					// only DrawEntire need be trapped as window is disabled
					if (lpdis->itemAction == ODA_DRAWENTIRE) {
						lphead = OutlineDoc_GetHeading(lpOutlineDoc);
						Heading_RH_Draw(lphead, lpdis);
					}
					break;
				}

				case IDC_COLHEADING:
				{
					RECT   rect;
					RECT   rcDevice;
					RECT   rcLogical;
					LPHEADING lphead;

					// only DrawEntire need be trapped as window is disabled
					if (lpdis->itemAction == ODA_DRAWENTIRE) {
						lphead = OutlineDoc_GetHeading(lpOutlineDoc);
						GetClientRect(lpdis->hwndItem, &rect);

						rcDevice = lpdis->rcItem;

						// shift the item rect to account for
						// horizontal scrolling
						rcDevice.left = -(rcDevice.right - rect.right);

						// shift rect for left margin
						rcDevice.left += (int)(XformWidthInHimetricToPixels(
								NULL,
								LOWORD(OutlineDoc_GetMargin(lpOutlineDoc))) *
							lpscale->dwSxN / lpscale->dwSxD);

						rcDevice.right = rcDevice.left + (int)lpscale->dwSxN;
						rcLogical.left = 0;
						rcLogical.bottom = 0;
						rcLogical.right = (int)lpscale->dwSxD;
						rcLogical.top = LOWORD(lpdis->itemData);

						Heading_CH_Draw(lphead, lpdis, &rcDevice, &rcLogical);
					}
					break;
				}
#endif  // USE_HEADING

			}
			return (LRESULT)TRUE;
		}

		case WM_SETFOCUS:
			if (lpLL)
				SetFocus(LineList_GetWindow(lpLL));
			break;

#if !defined( OLE_VERSION )
		case WM_RENDERFORMAT:
		{
			LPOUTLINEDOC lpClipboardDoc = lpOutlineApp->m_lpClipboardDoc;
			if (lpClipboardDoc)
				OutlineDoc_RenderFormat(lpClipboardDoc, wParam);

			break;
		}
		case WM_RENDERALLFORMATS:
		{
			LPOUTLINEDOC lpClipboardDoc = lpOutlineApp->m_lpClipboardDoc;
			if (lpClipboardDoc)
				OutlineDoc_RenderAllFormats(lpClipboardDoc);

			break;
		}
		case WM_DESTROYCLIPBOARD:
			if (g_lpApp->m_lpClipboardDoc) {
				OutlineDoc_Destroy(g_lpApp->m_lpClipboardDoc);
				g_lpApp->m_lpClipboardDoc = NULL;
			}
			break;

#endif   // OLE_VERSION

#if defined( OLE_CNTR )
		case WM_U_UPDATEOBJECTEXTENT:
		{
			/* Update the extents of any OLE object that is marked that
			**    its size may  have changed. when an
			**    IAdviseSink::OnViewChange notification is received,
			**    the corresponding ContainerLine is marked
			**    (m_fDoGetExtent==TRUE) and a message
			**    (WM_U_UPDATEOBJECTEXTENT) is posted to the document
			**    indicating that there are dirty objects.
			*/
			ContainerDoc_UpdateExtentOfAllOleObjects(lpContainerDoc);
			break;
		}
#endif  // OLE_CNTR

#if defined( INPLACE_SVR ) || defined( INPLACE_CNTR )
		/* OLE2NOTE: Any window that is used during in-place activation
		**    must handle the WM_SETCURSOR message or else the cursor
		**    of the in-place parent will be used. if WM_SETCURSOR is
		**    not handled, then DefWindowProc sends the message to the
		**    window's parent.
		**
		**    see context sensitive help technote (CSHELP.DOC).
		**    m_fCSHelpMode flag is set when SHIFT-F1 context
		**    sensitive help is entered.
		**    if this flag is set then the context sensitive help
		**    cursor should be shown.
		*/
		case WM_SETCURSOR:
			if (lpOleDoc->m_fCSHelpMode)
				SetCursor(UICursorLoad(IDC_CONTEXTHELP));
			else
				SetCursor(LoadCursor(NULL, IDC_ARROW) );
			return (LRESULT)TRUE;
#endif  // INPLACE_SVR || INPLACE_CNTR

#if defined( INPLACE_SVR )
		/* OLE2NOTE: when the in-place active, our in-place server
		**    document window (passed to IOleInPlaceFrame::SetMenu)
		**    will receive the WM_INITMENU and WM_INITMENUPOPUP messages.
		*/
		case WM_INITMENU:
			OutlineApp_InitMenu(lpOutlineApp, lpOutlineDoc, (HMENU)wParam);
			break;

		/* OLE2NOTE: WM_INITMENUPOPUP is trapped primarily for the Edit
		**    menu. We didn't update the Edit menu until it is popped
		**    up to avoid the overheads of the OLE calls which are
		**    required to initialize some Edit menu items.
		*/
		case WM_INITMENUPOPUP:
		{
			HMENU hMenuEdit = GetSubMenu(lpOutlineApp->m_hMenuApp, 1);
			if ((HMENU)wParam == hMenuEdit &&
				(LOWORD(lParam) == POS_EDITMENU) &&
				OleDoc_GetUpdateEditMenuFlag((LPOLEDOC)lpOutlineDoc)) {
				OleApp_UpdateEditMenu(
						(LPOLEAPP)lpOutlineApp, lpOutlineDoc, hMenuEdit);
			}
			break;
		}
#endif      // INPLACE_SVR

#if defined( INPLACE_SVR ) && defined( USE_STATUSBAR )
		/* OLE2NOTE: when the server is in-place active the
		**    WM_MENUSELECT message is sent to the object's window and
		**    not the server app's frame window. processing this
		**    message allows there in-place server to give status bar
		**    help text for menu commands.
		*/
		case WM_MENUSELECT:
		{
			LPSERVERDOC lpServerDoc = (LPSERVERDOC)lpOleDoc;
			LPSTR lpszMessage;
#ifdef WIN32
			UINT fuFlags    = (UINT)HIWORD(wParam);
			UINT uItem      = (UINT)LOWORD(wParam);
#else
			UINT fuFlags    = (UINT)LOWORD(lParam);
			UINT uItem      = (UINT)wParam;
#endif

			if (uItem == 0 && fuFlags == (UINT)-1) {
				GetControlMessage(STATUS_READY, &lpszMessage);
				ServerDoc_SetStatusText(lpServerDoc, lpszMessage);
			}
			else if (fuFlags & MF_POPUP) {
#ifdef WIN32
				HMENU hMainMenu = (HMENU)lParam;
				HMENU hPopupMenu = GetSubMenu(hMainMenu,uItem);
#else
				HMENU hPopupMenu = (HMENU)wParam;
#endif
				GetPopupMessage(hPopupMenu, &lpszMessage);
				ServerDoc_SetStatusText(lpServerDoc, lpszMessage);
			}
			else if (uItem != 0) {  // Command Item
				GetItemMessage(uItem, &lpszMessage);
				ServerDoc_SetStatusText(lpServerDoc, lpszMessage);
			}
			else {
				GetControlMessage(STATUS_BLANK, &lpszMessage);
				ServerDoc_SetStatusText(lpServerDoc, lpszMessage);
			}
			break;
		}
#endif  // INPLACE_SVR && USE_STATUSBAR
#if defined( INPLACE_SVR ) && defined( USE_FRAMETOOLS )

		case WM_U_INITFRAMETOOLS:
			OutlineDoc_UpdateFrameToolButtons(lpOutlineDoc);
			break;
#endif      // INPLACE_SVR && USE_FRAMETOOLS


		case WM_COMMAND:
		{
#ifdef WIN32
			WORD wNotifyCode = HIWORD(wParam);
			WORD wID          = LOWORD(wParam);
			HWND hwndCtl     = (HWND) lParam;
#else
			WORD wNotifyCode = HIWORD(lParam);
			WORD wID             = wParam;
			HWND hwndCtl     = (HWND) LOWORD(lParam);
#endif

#if defined( INPLACE_SVR )
			/* OLE2NOTE: see context sensitive help technote (CSHELP.DOC)
			**    m_fMenuHelpMode flag is set when F1 is pressed when a
			**    menu item is selected. this flag is set in
			**    IOleInPlaceActiveObject::ContextSensitveHelp method.
			**    m_fCSHelpMode flag is set when SHIFT-F1 context
			**    sensitive help is entered. this flag is set in
			**    IOleInPlaceObject::ContextSensitiveHelp method.
			**    if either of these flags are set then the WM_COMMAND
			**    message is received then, the corresponding command
			**    should NOT executed; help can be given (if desired).
			**    also the context sensitve help mode should be exited.
			**    the two different cases have their own way to exit
			**    the mode (please refer to the technote).
			*/
			if (lpOleDoc &&
				(lpServerDoc->m_fMenuHelpMode||lpOleDoc->m_fCSHelpMode) &&
				(wID > IDM_FILE)   /* min wID for app command */ &&
				(wID!=IDM_FB_EDIT) /* special wID to control FormulaBar */ ) {

				if ((lpServerDoc->m_fMenuHelpMode)) {
					LPOLEINPLACEFRAME lpFrame;

					lpServerDoc->m_fMenuHelpMode = FALSE;

					// inform top-level frame that we handled the
					//   menu help mode (F1) selection.
					if (lpServerDoc->m_lpIPData &&
							(lpFrame=lpServerDoc->m_lpIPData->lpFrame)!=NULL){
						OLEDBG_BEGIN2("IOleInPlaceFrame::ContextSensitiveHelp(FALSE) called\r\n")
						lpFrame->lpVtbl->ContextSensitiveHelp(lpFrame, FALSE);
						OLEDBG_END2
					}
				}

				if ((lpOleDoc->m_fCSHelpMode)) {
					LPOLEINPLACESITE lpSite;

					lpOleDoc->m_fCSHelpMode = FALSE;

					/* inform immediate in-place container parent and,
					**    if we were a container/server, immediate
					**    in-place object children that we handled the
					**    context sensitive help mode.
					*/
					if (lpServerDoc->m_lpIPData &&
							(lpSite=lpServerDoc->m_lpIPData->lpSite) !=NULL) {
						OLEDBG_BEGIN2("IOleInPlaceSite::ContextSensitiveHelp(FALSE) called\r\n")
						lpSite->lpVtbl->ContextSensitiveHelp(lpSite, FALSE);
						OLEDBG_END2
					}
				}

				// if we provided help, we would do it here...

				// remove context sensitive help cursor
				SetCursor(LoadCursor(NULL,IDC_ARROW));
				return 0L;
			}
#endif  // INPLACE_SVR
#if defined( INPLACE_CNTR )

			/* OLE2NOTE: see context sensitive help technote (CSHELP.DOC)
			**    m_fMenuHelpMode flag is set when F1 is pressed when a
			**    menu item is selected. this flag is set in
			**    IOleInPlaceFrame::ContextSensitveHelp method.
			**    m_fCSHelpMode flag is set when SHIFT-F1 context
			**    sensitive help is entered. this flag is set in
			**    IOleInPlaceSite::ContextSensitiveHelp method.
			**    if either of these flags are set then the WM_COMMAND
			**    message is received then, the corresponding command
			**    should NOT executed; help can be given (if desired).
			**    also the context sensitve help mode should be exited.
			**    the two different cases have their own way to exit
			**    the mode (please refer to the technote).
			*/
			if (lpOleDoc &&
				(lpContainerApp->m_fMenuHelpMode||lpOleDoc->m_fCSHelpMode) &&
				(wID > IDM_FILE)   /* min wID for app command */ &&
				(wID!=IDM_FB_EDIT) /* special wID to control FormulaBar */ ) {

				if ((lpContainerApp->m_fMenuHelpMode)) {
					LPOLEINPLACEACTIVEOBJECT lpIPActiveObj =
							lpContainerApp->m_lpIPActiveObj;

					lpContainerApp->m_fMenuHelpMode = FALSE;

					// inform the in-place active object that we handled the
					//   menu help mode (F1) selection.
					if (lpIPActiveObj) {
						OLEDBG_BEGIN2("IOleInPlaceActiveObject::ContextSensitiveHelp(FALSE) called\r\n")
						lpIPActiveObj->lpVtbl->ContextSensitiveHelp(
								lpIPActiveObj, FALSE);
						OLEDBG_END2
					}
				}

				if ((lpOleDoc->m_fCSHelpMode)) {
					LPOLEINPLACEOBJECT lpIPObj;
					LPCONTAINERLINE lpLastIpActiveLine =
							lpContainerDoc->m_lpLastIpActiveLine;

					lpOleDoc->m_fCSHelpMode = FALSE;

					/* inform immediate in-place container parent and,
					**    if we were a container/server, immediate
					**    in-place object children that we handled the
					**    context sensitive help mode.
					*/
					if (lpLastIpActiveLine &&
							(lpIPObj=lpLastIpActiveLine->m_lpOleIPObj)!=NULL){
						OLEDBG_BEGIN2("IOleInPlaceObject::ContextSensitiveHelp(FALSE) called\r\n")
						lpIPObj->lpVtbl->ContextSensitiveHelp(lpIPObj, FALSE);
						OLEDBG_END2
					}
				}

				// if we provided help, we would do it here...

				// remove context sensitive help cursor
				SetCursor(LoadCursor(NULL,IDC_ARROW));
				return 0L;
			}
#endif  // INPLACE_CNTR

			switch (wID) {

				/*********************************************************
				** File new, open, save and print as well as Help about
				**    are duplicated in this switch statement and they are
				**    used to trap the message from the toolbar
				**
				*********************************************************/

				case IDM_F_NEW:
					OleDbgIndent(-2);   // Reset debug output indent level
					OleDbgOutNoPrefix2("\r\n");

					OLEDBG_BEGIN3("OutlineApp_NewCommand\r\n")
					OutlineApp_NewCommand(lpOutlineApp);
					OLEDBG_END3

#if defined( OLE_CNTR )
					/* OLE2NOTE: this call will attempt to recover
					**    resources by unloading DLL's that were loaded
					**    by OLE and are no longer being used. it is a
					**    good idea to call this API now and then if
					**    your app tends to run for a long time.
					**    otherwise these DLL's will be unloaded when
					**    the app exits. some apps may want to call
					**    this as part of idle-time processing. this
					**    call is optional.
					*/
					OLEDBG_BEGIN2("CoFreeUnusedLibraries called\r\n")
					CoFreeUnusedLibraries();
					OLEDBG_END2
#endif

#if defined( USE_FRAMETOOLS )
					OutlineDoc_UpdateFrameToolButtons(
							OutlineApp_GetActiveDoc(lpOutlineApp));
#endif
					break;

				case IDM_F_OPEN:
					OleDbgOutNoPrefix2("\r\n");

					OLEDBG_BEGIN3("OutlineApp_OpenCommand\r\n")
					OutlineApp_OpenCommand(lpOutlineApp);
					OLEDBG_END3

#if defined( OLE_CNTR )
					/* OLE2NOTE: this call will attempt to recover
					**    resources by unloading DLL's that were loaded
					**    by OLE and are no longer being used. it is a
					**    good idea to call this API now and then if
					**    your app tends to run for a long time.
					**    otherwise these DLL's will be unloaded when
					**    the app exits. some apps may want to call
					**    this as part of idle-time processing. this
					**    call is optional.
					*/
					OLEDBG_BEGIN2("CoFreeUnusedLibraries called\r\n")
					CoFreeUnusedLibraries();
					OLEDBG_END2
#endif

#if defined( USE_FRAMETOOLS )
					OutlineDoc_UpdateFrameToolButtons(
							OutlineApp_GetActiveDoc(lpOutlineApp));
#endif
					break;

				case IDM_F_SAVE:
					OleDbgOutNoPrefix2("\r\n");

					OLEDBG_BEGIN3("OutlineApp_SaveCommand\r\n")
					OutlineApp_SaveCommand(lpOutlineApp);
					OLEDBG_END3
					break;

				case IDM_F_PRINT:
					OleDbgOutNoPrefix2("\r\n");

					OLEDBG_BEGIN3("OutlineApp_PrintCommand\r\n")
					OutlineApp_PrintCommand(lpOutlineApp);
					OLEDBG_END3
					break;


				case IDM_E_UNDO:
					// SORRY. NOT IMPLEMENTED
					break;

				case IDM_E_CUT:
					OleDbgOutNoPrefix2("\r\n");

					OLEDBG_BEGIN3("OutlineDoc_CutCommand\r\n")
					OutlineDoc_CutCommand(lpOutlineDoc);
					OLEDBG_END3

#if defined( USE_FRAMETOOLS )
					OutlineDoc_UpdateFrameToolButtons(lpOutlineDoc);
#endif
					break;

				case IDM_E_COPY:
					OleDbgOutNoPrefix2("\r\n");

					OLEDBG_BEGIN3("OutlineDoc_CopyCommand\r\n")
					OutlineDoc_CopyCommand(lpOutlineDoc);
					OLEDBG_END3

#if defined( USE_FRAMETOOLS )
					OutlineDoc_UpdateFrameToolButtons(lpOutlineDoc);
#endif
					break;

				case IDM_E_PASTE:
					OleDbgOutNoPrefix2("\r\n");

					OLEDBG_BEGIN3("OutlineDoc_PasteCommand\r\n")
					OutlineDoc_PasteCommand(lpOutlineDoc);
					OLEDBG_END3

#if defined( USE_FRAMETOOLS )
					OutlineDoc_UpdateFrameToolButtons(lpOutlineDoc);
#endif
					break;

#if defined( OLE_VERSION )
				case IDM_E_PASTESPECIAL:
					OleDbgOutNoPrefix2("\r\n");

					OLEDBG_BEGIN3("OleDoc_PasteSpecialCommand\r\n")
					OleDoc_PasteSpecialCommand((LPOLEDOC)lpOutlineDoc);
					OLEDBG_END3

#if defined( USE_FRAMETOOLS )
					OutlineDoc_UpdateFrameToolButtons(lpOutlineDoc);
#endif
					break;

#endif  // OLE_VERSION

				case IDM_E_CLEAR:
					OleDbgOutNoPrefix2("\r\n");

					OLEDBG_BEGIN3("OutlineDoc_ClearCommand\r\n")
					OutlineDoc_ClearCommand(lpOutlineDoc);
					OLEDBG_END3

#if defined( OLE_CNTR )
					/* OLE2NOTE: this call will attempt to recover
					**    resources by unloading DLL's that were loaded
					**    by OLE and are no longer being used. it is a
					**    good idea to call this API now and then if
					**    your app tends to run for a long time.
					**    otherwise these DLL's will be unloaded when
					**    the app exits. some apps may want to call
					**    this as part of idle-time processing. this
					**    call is optional.
					*/
					OLEDBG_BEGIN2("CoFreeUnusedLibraries called\r\n")
					CoFreeUnusedLibraries();
					OLEDBG_END2
#endif

#if defined( USE_FRAMETOOLS )
					OutlineDoc_UpdateFrameToolButtons(lpOutlineDoc);
#endif
					break;

				case IDM_L_ADDLINE:
					OleDbgOutNoPrefix2("\r\n");

					OLEDBG_BEGIN3("OutlineDoc_AddTextLineCommand\r\n")
					OutlineDoc_AddTextLineCommand(lpOutlineDoc);
					OLEDBG_END3

#if defined( USE_FRAMETOOLS )
					OutlineDoc_UpdateFrameToolButtons(lpOutlineDoc);
					SetFocus(LineList_GetWindow(lpLL));
#endif
					break;

				case IDM_L_EDITLINE:
					OleDbgOutNoPrefix2("\r\n");

					OLEDBG_BEGIN3("OutlineDoc_EditLineCommand\r\n")
					OutlineDoc_EditLineCommand(lpOutlineDoc);
					OLEDBG_END3
					SetFocus(LineList_GetWindow(lpLL));
					break;

				case IDM_L_INDENTLINE:
					OleDbgOutNoPrefix2("\r\n");

					OLEDBG_BEGIN3("OutlineDoc_IndentCommand\r\n")
					OutlineDoc_IndentCommand(lpOutlineDoc);
					OLEDBG_END3
					break;

				case IDM_L_UNINDENTLINE:
					OleDbgOutNoPrefix2("\r\n");

					OLEDBG_BEGIN3("OutlineDoc_UnindentCommand\r\n")
					OutlineDoc_UnindentCommand(lpOutlineDoc);
					OLEDBG_END3
					break;

				case IDM_L_SETLINEHEIGHT:
					OleDbgOutNoPrefix2("\r\n");

					OLEDBG_BEGIN3("OutlineDoc_SetLineHeight\r\n")
					OutlineDoc_SetLineHeightCommand(lpOutlineDoc);
					OLEDBG_END3
					break;

				case IDM_E_SELECTALL:
					OleDbgOutNoPrefix2("\r\n");

					OLEDBG_BEGIN3("OutlineDoc_SelectAllCommand\r\n")
					OutlineDoc_SelectAllCommand(lpOutlineDoc);
					OLEDBG_END3
					break;

#if defined( OLE_CNTR )
				case IDM_E_INSERTOBJECT:
					OleDbgOutNoPrefix2("\r\n");

					OLEDBG_BEGIN3("ContainerDoc_InsertOleObjectCommand\r\n")
					ContainerDoc_InsertOleObjectCommand(lpContainerDoc);
					OLEDBG_END3

#if defined( USE_FRAMETOOLS )
					OutlineDoc_UpdateFrameToolButtons(lpOutlineDoc);
#endif
					break;

				case IDM_E_EDITLINKS:
					OleDbgOutNoPrefix2("\r\n");

					OLEDBG_BEGIN3("ContainerDoc_EditLinksCommand\r\n")
					ContainerDoc_EditLinksCommand(lpContainerDoc);
					OLEDBG_END3
					break;

				case IDM_E_CONVERTVERB:
					OleDbgOutNoPrefix2("\r\n");

					OLEDBG_BEGIN3("ContainerDoc_ConvertCommand\r\n")
					ContainerDoc_ConvertCommand(
							lpContainerDoc, FALSE /*fMustActivate*/);
					OLEDBG_END3
					break;


				case IDM_E_PASTELINK:
					OleDbgOutNoPrefix2("\r\n");

					OLEDBG_BEGIN3("ContainerDoc_PasteLinkCommand\r\n")
					ContainerDoc_PasteLinkCommand(lpContainerDoc);
					OLEDBG_END3

#if defined( USE_FRAMETOOLS )
					OutlineDoc_UpdateFrameToolButtons(lpOutlineDoc);
#endif
					break;

#endif  // OLE_CNTR

				case IDM_N_DEFINENAME:
					OleDbgOutNoPrefix2("\r\n");

					OLEDBG_BEGIN3("OutlineDoc_DefineNameCommand\r\n")
					OutlineDoc_DefineNameCommand(lpOutlineDoc);
					OLEDBG_END3
					break;

				case IDM_N_GOTONAME:
					OleDbgOutNoPrefix2("\r\n");

					OLEDBG_BEGIN3("OutlineDoc_GotoNameCommand\r\n")
					OutlineDoc_GotoNameCommand(lpOutlineDoc);
					OLEDBG_END3
					break;

#if defined( USE_FRAMETOOLS )
				case IDM_O_BB_TOP:
					FrameTools_BB_SetState(
							lpOutlineDoc->m_lpFrameTools, BARSTATE_TOP);
					OutlineDoc_AddFrameLevelTools(lpOutlineDoc);
					break;

				case IDM_O_BB_BOTTOM:
					FrameTools_BB_SetState(
							lpOutlineDoc->m_lpFrameTools, BARSTATE_BOTTOM);
					OutlineDoc_AddFrameLevelTools(lpOutlineDoc);
					break;

				case IDM_O_BB_POPUP:
					FrameTools_BB_SetState(
							lpOutlineDoc->m_lpFrameTools, BARSTATE_POPUP);
					OutlineDoc_AddFrameLevelTools(lpOutlineDoc);
					break;

				case IDM_O_BB_HIDE:
					FrameTools_BB_SetState(
							lpOutlineDoc->m_lpFrameTools, BARSTATE_HIDE);
					OutlineDoc_AddFrameLevelTools(lpOutlineDoc);
					break;

				case IDM_O_FB_TOP:
					FrameTools_FB_SetState(
							lpOutlineDoc->m_lpFrameTools, BARSTATE_TOP);
					OutlineDoc_AddFrameLevelTools(lpOutlineDoc);
					break;

				case IDM_O_FB_BOTTOM:
					FrameTools_FB_SetState(
							lpOutlineDoc->m_lpFrameTools, BARSTATE_BOTTOM);
					OutlineDoc_AddFrameLevelTools(lpOutlineDoc);
					break;

				case IDM_O_FB_POPUP:
					FrameTools_FB_SetState(
							lpOutlineDoc->m_lpFrameTools, BARSTATE_POPUP);
					OutlineDoc_AddFrameLevelTools(lpOutlineDoc);
					break;

				case IDM_FB_EDIT:

					switch (wNotifyCode) {
						case EN_SETFOCUS:
							OutlineDoc_SetFormulaBarEditFocus(
									lpOutlineDoc, TRUE);
							OutlineDoc_UpdateFrameToolButtons(lpOutlineDoc);
							break;

						case EN_KILLFOCUS:
							OutlineDoc_SetFormulaBarEditFocus(
									lpOutlineDoc, FALSE);
							OutlineDoc_UpdateFrameToolButtons(lpOutlineDoc);
							break;
					}
					break;

				case IDM_FB_CANCEL:

					SetFocus(hWnd);
					break;


				case IDM_F2:
					SendMessage(hWnd, WM_COMMAND, (WPARAM)IDM_FB_EDIT,
							MAKELONG(0, EN_SETFOCUS));
					break;
#endif  // USE_FRAMETOOLS

				case IDM_ESCAPE:
					/* ESCAPE key pressed */

#if defined( USE_FRAMETOOLS )
					if (OutlineDoc_IsEditFocusInFormulaBar(lpOutlineDoc))
						SendMessage(
							hWnd, WM_COMMAND,(WPARAM)IDM_FB_CANCEL,(LPARAM)0);
#endif  // USE_FRAMETOOLS

#if defined( INPLACE_SVR )
					else {
						LPSERVERDOC lpServerDoc = (LPSERVERDOC)lpOutlineDoc;

						/* OLE2NOTE: The standard OLE 2.0 UI convention
						**    is to have ESCAPE key exit in-place
						**    activation (ie. UIDeactivate). If
						**    possible it is recommended for both
						**    in-place servers AND in-place containers
						**    to take responsibility to handle the
						**    ESCAPE key accelerator. The server has
						**    the first crack at handling accelerator
						**    keys and normally the server should do
						**    the UIDeactivation.
						*/
						if (lpServerDoc->m_fUIActive) {
							SvrDoc_IPObj_UIDeactivate( (LPOLEINPLACEOBJECT)&
									lpServerDoc->m_OleInPlaceObject);
						}
					}
#endif  // INPLACE_SVR

					break;


#if defined( USE_HEADING )
				case IDC_BUTTON:
					if (wNotifyCode == BN_CLICKED) {
						SendMessage(hWnd, WM_COMMAND, IDM_E_SELECTALL, 0L);
						SetFocus(hWnd);
					}
					break;

				case IDM_O_HEAD_SHOW:
					OutlineDoc_ShowHeading(lpOutlineDoc, TRUE);
					break;

				case IDM_O_HEAD_HIDE:
					OutlineDoc_ShowHeading(lpOutlineDoc, FALSE);
					break;
#endif  // USE_HEADING


#if defined( OLE_CNTR )
				case IDM_O_SHOWOBJECT:
				{
					LPCONTAINERDOC lpContainerDoc =
								(LPCONTAINERDOC)lpOutlineDoc;
					BOOL        fShowObject;

					fShowObject = !ContainerDoc_GetShowObjectFlag(
							lpContainerDoc);
					ContainerDoc_SetShowObjectFlag(
							lpContainerDoc, fShowObject);
					LineList_ForceRedraw(lpLL, TRUE);

					break;
				}
#endif  // OLE_CNTR

#if !defined( OLE_CNTR )
				// Container does not allow zoom factors > 100%
				case IDM_V_ZOOM_400:
				case IDM_V_ZOOM_300:
				case IDM_V_ZOOM_200:
#endif      // !OLE_CNTR

				case IDM_V_ZOOM_100:
				case IDM_V_ZOOM_75:
				case IDM_V_ZOOM_50:
				case IDM_V_ZOOM_25:
					OutlineDoc_SetCurrentZoomCommand(lpOutlineDoc, wID);
					break;

				case IDM_V_SETMARGIN_0:
				case IDM_V_SETMARGIN_1:
				case IDM_V_SETMARGIN_2:
				case IDM_V_SETMARGIN_3:
				case IDM_V_SETMARGIN_4:
					OutlineDoc_SetCurrentMarginCommand(lpOutlineDoc, wID);
					break;

				case IDM_V_ADDTOP_1:
				case IDM_V_ADDTOP_2:
				case IDM_V_ADDTOP_3:
				case IDM_V_ADDTOP_4:
				{
					UINT nHeightInHimetric;

					switch (wID) {
						case IDM_V_ADDTOP_1:
							nHeightInHimetric = 1000;
							break;

						case IDM_V_ADDTOP_2:
							nHeightInHimetric = 2000;
							break;

						case IDM_V_ADDTOP_3:
							nHeightInHimetric = 3000;
							break;

						case IDM_V_ADDTOP_4:
							nHeightInHimetric = 4000;
							break;
					}

					OutlineDoc_AddTopLineCommand(
							lpOutlineDoc, nHeightInHimetric);
					break;
				}


				case IDM_H_ABOUT:
					OutlineApp_AboutCommand(lpOutlineApp);
					break;

				case IDM_D_DEBUGLEVEL:
					SetDebugLevelCommand();
					break;

#if defined( OLE_VERSION )
				case IDM_D_INSTALLMSGFILTER:
					InstallMessageFilterCommand();
					break;

				case IDM_D_REJECTINCOMING:
					RejectIncomingCommand();
					break;
#endif  // OLE_VERSION

#if defined( INPLACE_CNTR )
				case IDM_D_INSIDEOUT:
					g_fInsideOutContainer = !g_fInsideOutContainer;

					// force all object to unload so they can start new
					// activation behavior.
					ContainerDoc_UnloadAllOleObjectsOfClass(
							(LPCONTAINERDOC)lpOutlineDoc,
							&CLSID_NULL,
							OLECLOSE_SAVEIFDIRTY
					);
					OutlineDoc_ForceRedraw(lpOutlineDoc, TRUE);
					break;
#endif  // INPLACE_CNTR


#if defined( OLE_CNTR )
				case IDC_LINELIST: {

					if (wNotifyCode == LBN_DBLCLK) {

						/* OLE2NOTE: a container should execute the
						**    OLEIVERB_PRIMARY verb on an OLE object
						**    when the user DBLCLK's the object.
						*/
						int nIndex = LineList_GetFocusLineIndex(lpLL);
						LPLINE lpLine = LineList_GetLine(lpLL, nIndex);

						if (lpLine &&
								Line_GetLineType(lpLine)==CONTAINERLINETYPE) {
							MSG msg;

							_fmemset((LPMSG)&msg,0,sizeof(msg));
							msg.hwnd = hWnd;
							msg.message = Message;
							msg.wParam = wParam;
							msg.lParam = lParam;

							ContainerLine_DoVerb(
									(LPCONTAINERLINE)lpLine,
									OLEIVERB_PRIMARY,
									(LPMSG)&msg,
									TRUE,
									TRUE
							);
						}

#if defined( INPLACE_CNTR )
						{ // BEGIN BLOCK
							LPCONTAINERDOC lpContainerDoc =
									(LPCONTAINERDOC) lpOutlineDoc;
							if (lpContainerDoc->m_fAddMyUI) {
								/* OLE2NOTE: fAddMyUI is TRUE when
								**    there was previously an in-place
								**    active object which got
								**    UIDeactivated as a result of this
								**    DBLCLK AND the DBLCLK did NOT
								**    result in in-place activating
								**    another object.
								**    (see IOleInPlaceSite::OnUIActivate and
								**    IOleInPlaceSite::OnUIDeactivate
								**    methods).
								*/

								/* OLE2NOTE: You need to generate
								**    QueryNewPalette only if you own
								**    the top level frame (ie. you are
								**    a top-level inplace container).
								*/


								OleApp_QueryNewPalette((LPOLEAPP)g_lpApp);

#if defined( USE_DOCTOOLS )
								ContainerDoc_AddDocLevelTools(lpContainerDoc);
#endif

#if defined( USE_FRAMETOOLS )
								ContainerDoc_AddFrameLevelUI(lpContainerDoc);
#endif
								lpContainerDoc->m_fAddMyUI = FALSE;
							}
						} // END BLOCK
#endif // INPLACE_CNTR
					}
					break;
				}
#endif  // OLE_CNTR


				default:

#if defined( OLE_CNTR )
					if (wID >= IDM_E_OBJECTVERBMIN) {

						OleDbgOutNoPrefix2("\r\n");
						OLEDBG_BEGIN3("ContainerDoc_ContainerLineDoVerbCommand\r\n")
						ContainerDoc_ContainerLineDoVerbCommand(
								(LPCONTAINERDOC)lpOutlineDoc,
								(LONG)(wID-IDM_E_OBJECTVERBMIN)
						);
						OLEDBG_END3
						break;
					}
#endif  // OLE_CNTR
					return DefWindowProc(hWnd, Message, wParam, lParam);
			}

			break;  /* End of WM_COMMAND */
		}
		default:

			if (Message == g_uMsgHelp) {
				/* Handle OLE2UI dialog's help messages.
				** We get the hDlg of the dialog that called us in the wParam
				** and the dialog type in the LOWORD of the lParam,
				** so we pass this along to our help function.
				*/
				OutlineDoc_DialogHelp((HWND)wParam, LOWORD(lParam));
				break;
			}

			/* For any message for which you don't specifically provide a  */
			/* service routine, you should return the message to Windows   */
			/* for default message processing.                             */
			return DefWindowProc(hWnd, Message, wParam, lParam);
	}

	return (LRESULT)0;

} /* End of DocWndProc */



//***********************************************************************
//*
//* LineListWndProc()  Drag and Drop Listbox Window Proc Sub-Class
//*
//* Sub Class the Ownerdraw list box in order to activate the drag drop.
//***********************************************************************

LRESULT FAR PASCAL LineListWndProc(
	HWND   hWnd,
	UINT   Message,
	WPARAM wParam,
	LPARAM lParam
)
{
	HWND         hwndParent = GetParent ( hWnd );
	LPOUTLINEAPP lpOutlineApp = (LPOUTLINEAPP)g_lpApp;
	LPOUTLINEDOC lpOutlineDoc = (LPOUTLINEDOC) GetWindowLong( hwndParent, 0 );
	LPLINELIST   lpLL = OutlineDoc_GetLineList(lpOutlineDoc);

#if defined( OLE_VERSION )
	LPOLEAPP     lpOleApp = (LPOLEAPP)lpOutlineApp;
	LPOLEDOC     lpOleDoc = (LPOLEDOC)lpOutlineDoc;
#endif  // OLE_VERSION

#if defined( INPLACE_SVR )
	LPSERVERDOC  lpServerDoc = (LPSERVERDOC)lpOutlineDoc;
	static BOOL  fUIActivateClick = FALSE;
	static BOOL  fInWinPosChged = FALSE;
#endif  // INPLACE_SVR

#if defined( INPLACE_CNTR )
	LPCONTAINERAPP lpContainerApp=(LPCONTAINERAPP)lpOutlineApp;
	LPCONTAINERDOC lpContainerDoc=(LPCONTAINERDOC)lpOutlineDoc;
#endif  // INPLACE_CNTR

	switch (Message) {

		case WM_KILLFOCUS:
			/* OLE2NOTE: when our window looses focus we
			**    should not display any active selection
			*/
#if defined( INPLACE_CNTR )
			if (! lpContainerApp->m_fPendingUIDeactivate)
#endif  // INPLACE_CNTR
				LineList_RemoveSel(lpLL);
			break;

		case WM_SETFOCUS:

#if defined( INPLACE_CNTR )
			{
				HWND hWndObj=ContainerDoc_GetUIActiveWindow(lpContainerDoc);

				/* OLE2NOTE: if there is a UIActive in-place object, we must
				**    forward focus to its window as long as there is
				**    not a pending UIDeactivate. if the mouse is
				**    clicked outside of the object and the object is
				**    about to be deactivated then we do NOT want to
				**    forward focus to the object. we do NOT want it to
				**    restore its selection feedback.
				*/
				if (lpContainerApp->m_fPendingUIDeactivate)
					break;
				else if (hWndObj) {
					SetFocus(hWndObj);
					break;      // do not restore containers selection state
				}
			}
#endif  // INPLACE_CNTR

			/* OLE2NOTE: when our window gains focus we
			**    should restore the previous selection
			*/
			LineList_RestoreSel(lpLL);

			break;

#if defined( INPLACE_SVR )
		case WM_MOUSEACTIVATE:
		{
			if (lpServerDoc->m_fInPlaceActive && !lpServerDoc->m_fUIActive) {
				fUIActivateClick = TRUE;
			};
			break;
		}

#endif  // INPLACE_SVR


#if defined( USE_FRAMETOOLS )
		case WM_CHAR:
		{
			OutlineDoc_SetFormulaBarEditFocus(lpOutlineDoc, TRUE);
			FrameTools_FB_SetEditText(lpOutlineDoc->m_lpFrameTools, NULL);
			FrameTools_FB_SendMessage(
					lpOutlineDoc->m_lpFrameTools,
					IDM_FB_EDIT,
					Message,
					wParam,
					lParam
			);

			return (LRESULT)0;   // don't do default listbox processing
		}
#endif  // USE_FRAMETOOLS

#if defined( INPLACE_CNTR )
		case WM_VSCROLL:
		{
			if (wParam == SB_ENDSCROLL) {
				/* OLE2NOTE: after scrolling finishes, update position of
				**    in-place visible windows.
				**    (ICNTROTL specific) we first let the ListBox
				**    perform it normal processing with the EndScroll
				**    message. also we let the ListBox handle all other
				**    scroll messages.
				*/
				LRESULT lResult =  CallWindowProc(
						(WNDPROC)lpOutlineApp->m_ListBoxWndProc,
						hWnd,
						Message,
						wParam,
						lParam
				);
				ContainerDoc_UpdateInPlaceObjectRects(lpContainerDoc, 0);
				return lResult;
			}

			break;
		}
#endif  // INPLACR_CNTR

#if defined( USE_HEADING )
		case WM_HSCROLL:
		{
			LPHEADING lphead = OutlineDoc_GetHeading(lpOutlineDoc);

			Heading_CH_SendMessage(lphead, Message, wParam, lParam);

			break;
		}

		/* NOTE: WM_PAINT trapped in order to track vertical scrolling
		**    that has taken place so the row headings can be
		**    coordinated with the LineList. we wanted to trap instead
		**    but it is not generated from scrolling without using
		**    scroll bar (e.g. use keyboard).
		*/
		case WM_PAINT:
		{
			Heading_RH_Scroll(OutlineDoc_GetHeading(lpOutlineDoc), hWnd);
			break;
		}

#endif  // USE_HEADING

		case WM_LBUTTONUP:
		{

#if defined( USE_DRAGDROP )
			if (lpOleDoc->m_fPendingDrag) {
				/* ButtonUP came BEFORE distance/time threshholds were
				**    exceeded. clear fPendingDrag state.
				*/
				ReleaseCapture();
				KillTimer(hWnd, 1);
				lpOleDoc->m_fPendingDrag = FALSE;
			}
#endif  // USE_DRAGDROP

#if defined( INPLACE_SVR )
			if (fUIActivateClick) {
				fUIActivateClick = FALSE;
				ServerDoc_UIActivate((LPSERVERDOC) lpOleDoc);
			}
#endif  // INPLACE_SVR

#if defined( INPLACE_CNTR )
			{
				/* check if a UIDeactivate is pending.
				**      (see comment in WM_LBUTTONDOWN)
				*/
				if ( lpContainerApp->m_fPendingUIDeactivate ) {
					ContainerLine_UIDeactivate(
							lpContainerDoc->m_lpLastUIActiveLine);

					lpContainerApp->m_fPendingUIDeactivate = FALSE;
				}
			}
#endif  // INPLACE_CNTR

			break;
		}

		case WM_LBUTTONDOWN:
		{
			POINT pt;

			pt.x = (int)(short)LOWORD (lParam );
			pt.y = (int)(short)HIWORD (lParam );

#if defined( INPLACE_SVR ) || defined( INPLACE_CNTR )
			/* OLE2NOTE: see context sensitive help technote (CSHELP.DOC)
			**    m_fCSHelpMode flag is set when SHIFT-F1 context
			**    sensitive help is entered.
			**    if this flag is set then the button click should not
			**    cause any action. if the application implements a
			**    help system, then context sensitive help should be
			**    given for the location clicked by the user.
			*/
			if (lpOleDoc->m_fCSHelpMode) {
				return (LRESULT)0;   // eat the button click because we do
									 // not give any help.
			}
#endif  // INPLACE_SVR || INPLACE_CNTR

#if defined( INPLACE_CNTR )
			{
				/* OLE2NOTE: both inside-out and outside-in style
				**    containers must check if the mouse click is
				**    outside of the current UIActive object (if
				**    any). If so, then set the flag indicating that
				**    there is a pending UIDeactivate needed. We do NOT
				**    want to do it now,
				**    because that would result in un-wanted movement of
				**    the data on the screen as frame adornments (eg.
				**    toolbar) and/or object adornments (eg. ruler) would
				**    be removed from the screen. we want to defer the
				**    UIDeactivate till the mouse up event. The listbox's
				**    default processing captures the mouse on button down
				**    so that it is sure to get the button up message.
				**
				**    SPECIAL NOTE: there is potential interaction here
				**    with Drag/Drop. if this button down event actually
				**    starts a Drag/Drop operation, then OLE does the mouse
				**    capture. in this situation we will NOT get our button
				**    up event. we must instead perform the UIDeactivate
				**    when the drop operation finishes
				*/
				lpContainerApp->m_fPendingUIDeactivate =
						ContainerDoc_IsUIDeactivateNeeded(lpContainerDoc, pt);
			}
#endif  // INPLACE_CNTR

#if defined( USE_DRAGDROP )

			/* OLE2NOTE: check if this is a button down on the region
			**    that is a handle to start a drag operation. for us,
			**    this this the top/bottom border of the selection.
			**    do NOT want to start a drag immediately; we want to
			**    wait until the mouse moves a certain threshold. if
			**    LButtonUp comes before mouse move to start drag, then
			**    the fPendingDrag state is cleared. we must capture
			**    the mouse to ensure the modal state is handled
			**    properly.
			*/
			if ( OleDoc_QueryDrag(lpOleDoc, pt.y) ) {
				lpOleDoc->m_fPendingDrag = TRUE;
				lpOleDoc->m_ptButDown = pt;
				SetTimer(hWnd, 1, lpOleApp->m_nDragDelay, NULL);
				SetCapture(hWnd);

				/* We do NOT want to do the listbox's default
				**    processing which would be to capture the mouse
				**    and enter a modal multiple selection state until
				**    a mouse up occurs. we have just finished a modal
				**    drag/drop operation where OLE has captured the
				**    mouse. thus by now the mouse up has already occured.
				*/

				return (LRESULT)0;   // don't do default listbox processing
			}
#endif  // USE_DRAGDROP

			break;
		}


		case WM_MOUSEMOVE: {

#if defined( USE_DRAGDROP )

			int  x = (int)(short)LOWORD (lParam );
			int  y = (int)(short)HIWORD (lParam );
			POINT pt = lpOleDoc->m_ptButDown;
			int nDragMinDist = lpOleApp->m_nDragMinDist;

			if (lpOleDoc->m_fPendingDrag) {

				if (! ( ((pt.x - nDragMinDist) <= x)
						&& (x <= (pt.x + nDragMinDist))
						&& ((pt.y - nDragMinDist) <= y)
						&& (y <= (pt.y + nDragMinDist)) ) ) {

					DWORD dwEffect;

					// mouse moved beyond threshhold to start drag
					ReleaseCapture();
					KillTimer(hWnd, 1);
					lpOleDoc->m_fPendingDrag = FALSE;

					// perform the modal drag/drop operation.
					dwEffect = OleDoc_DoDragDrop( lpOleDoc );

#if defined( INPLACE_CNTR )
					{
						/* if necessary UIDeactive the in-place object.
						**    this applies to outside-in style
						**    container only.
						**    (see comment above)
						*/
						if (lpContainerApp->m_fPendingUIDeactivate) {
							lpContainerApp->m_fPendingUIDeactivate = FALSE;

							// do not UIDeactivate if drag/drop was canceled
							if (dwEffect != DROPEFFECT_NONE)
								ContainerLine_UIDeactivate(
										lpContainerDoc->m_lpLastUIActiveLine
								);
						}
					}
#endif  // INPLACE_CNTR

					return (LRESULT)0; // don't do default listbox process
				}
				else {
					/* cursor did not move from initial mouse down
					**    (pending drag) point.
					*/
					return (LRESULT)0; // don't do default listbox process
				}
			}

#endif  // USE_DRAGDROP

#if defined( INPLACE_CNTR )
			{ // BEGIN BLOCK
				if (lpContainerDoc->m_fAddMyUI) {
					/* OLE2NOTE: fAddMyUI is TRUE when
					**    there was previously an in-place
					**    active object which got
					**    UIDeactivated as a result of a
					**    DBLCLK AND the DBLCLK did NOT
					**    result in in-place activating
					**    another object.
					**    (see IOleInPlaceSite::OnUIActivate and
					**    IOleInPlaceSite::OnUIDeactivate
					**    methods).
					*/
#if defined( USE_DOCTOOLS )
					ContainerDoc_AddDocLevelTools(lpContainerDoc);
#endif

#if defined( USE_FRAMETOOLS )
					ContainerDoc_AddFrameLevelUI(lpContainerDoc);
#endif
					lpContainerDoc->m_fAddMyUI = FALSE;
				}
			} // END BLOCK
#endif // INPLACE_CNTR

			break;
		}


#if defined( USE_DRAGDROP )
		case WM_TIMER:
		{
			DWORD dwEffect;

			// drag time delay threshhold exceeded -- start drag
			ReleaseCapture();
			KillTimer(hWnd, 1);
			lpOleDoc->m_fPendingDrag = FALSE;

			// perform the modal drag/drop operation.
			dwEffect = OleDoc_DoDragDrop( lpOleDoc );

#if defined( INPLACE_CNTR )
			/* if necessary UIDeactive the in-place object.
			**    this applies to outside-in style
			**    container only.
			**    (see comment above)
			*/
			if (lpContainerApp->m_fPendingUIDeactivate) {
				lpContainerApp->m_fPendingUIDeactivate = FALSE;

				// do not UIDeactivate if drag/drop was canceled
				if (dwEffect != DROPEFFECT_NONE)
					ContainerLine_UIDeactivate(
							lpContainerDoc->m_lpLastUIActiveLine);
			}
#endif  // INPLACE_CNTR
			break;
		}
#endif  // USE_DRAGDROP

		case WM_SETCURSOR:
		{
			RECT rc;
			POINT ptCursor;
#if defined( INPLACE_SVR ) || defined( INPLACE_CNTR )
			/* OLE2NOTE: see context sensitive help technote (CSHELP.DOC)
			**    m_fCSHelpMode flag is set when SHIFT-F1 context
			**    sensitive help is entered.
			**    if this flag is set then the context sensitive help
			**    cursor should be shown.
			*/
			if (lpOleDoc->m_fCSHelpMode) {
				SetCursor(UICursorLoad(IDC_CONTEXTHELP));
				return (LRESULT)TRUE;
			}
#endif  // INPLACE_SVR || INPLACE_CNTR

			GetCursorPos((POINT FAR*)&ptCursor);
			ScreenToClient(hWnd, (POINT FAR*)&ptCursor);
			GetClientRect(hWnd, (LPRECT)&rc);

			// use arrow cursor if in scroll bar
			if (! PtInRect((LPRECT)&rc, ptCursor) )
				SetCursor(LoadCursor(NULL, IDC_ARROW) );

#if defined( USE_DRAGDROP )
			// use arrow cursor if on drag handle (top/bottom of selection)
			else if ( OleDoc_QueryDrag ( lpOleDoc, ptCursor.y) )
				SetCursor(LoadCursor(NULL, IDC_ARROW) );
#endif  // USE_DRAGDROP

			else
				SetCursor(lpOutlineApp->m_hcursorSelCur);

			return (LRESULT)TRUE;
		}

#if defined( INPLACE_SVR )

		/* The handling of WM_WINDOWPOSCHANGED message is ISVROTL
		**    application specific. The nature of the owner-draw list
		**    box used by the ISVROTL application causes a recursive
		**    call to this message in some situations when in-place
		**    active. in order not to crash this recursive call must be
		**    guarded.
		*/
		case WM_WINDOWPOSCHANGED:
		{
			WINDOWPOS FAR* lpWinPos = (WINDOWPOS FAR*) lParam;
			LRESULT lResult;

			// guard against recursive call
			if (fInWinPosChged)
				return (LRESULT)0;

			fInWinPosChged = TRUE;
			lResult = CallWindowProc(
					(WNDPROC)lpOutlineApp->m_ListBoxWndProc,
					hWnd,
					Message,
					wParam,
					lParam
			);
			fInWinPosChged = FALSE;

			return lResult;
		}
#endif  // INPLACE_SVR

	}

	return CallWindowProc(
			(WNDPROC)lpOutlineApp->m_ListBoxWndProc,
			hWnd,
			Message,
			wParam,
			lParam
	);

}

// Utility function to count the number of accelerator items in an
//  accelerator table.  A number of OLE APIs need this count, so
//  this can be quite handy.
// (code shamelessly stolen from the Microsoft Foundation Classes)

int GetAccelItemCount(HACCEL hAccel)
{
#if defined( WIN32 )
    return CopyAcceleratorTable(hAccel, NULL, 0);
#else
	#pragma pack(1)
	typedef struct tagACCELERATOR
	{
		BYTE    fFlags;
		WORD    wEvent;
		WORD    wID;
	} ACCELERATOR;
	#pragma pack()

	// attempt to lock down the accelerator resource
	ACCELERATOR FAR* pAccel;
	int cAccelItems = 1;
	if (hAccel == NULL ||
		(pAccel = (ACCELERATOR FAR*)LockResource((HGLOBAL)hAccel)) == NULL)
	{
		// NULL accerator table or LockResource failed on the HACCEL,
		//  no accelerators
		return 0;
	}
	// otherwise, count them -- last entry in accel table has 0x80 bit set
	while ((pAccel->fFlags & 0x80) == 0)
	{
		++cAccelItems;
		++pAccel;
	}
	UnlockResource((HGLOBAL)hAccel);
	return cAccelItems;
#endif
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\letest\outline\linking.c ===
/*************************************************************************
**
**    OLE 2 Sample Code
**
**    linking.c
**
**    This file contains the major interfaces, methods and related support
**    functions for implementing linking to items. The code
**    contained in this file is used by BOTH the Container and Server
**    (Object) versions of the Outline sample code.
**
**    As a server SVROUTL supports linking to the whole document object
**    (either a file-based document or as an embedded object). It also
**    supports linking to ranges (or PseudoObjects).
**
**    As a container CNTROUTL supports linking to embedded objects.
**    (see file svrpsobj.c for Pseudo Object implementation)
**
**    OleDoc Object
**      exposed interfaces:
**          IPersistFile
**          IOleItemContainer
**          IExternalConnection
**
**    (c) Copyright Microsoft Corp. 1992 - 1993 All Rights Reserved
**
*************************************************************************/

#include "outline.h"

OLEDBGDATA

extern LPOUTLINEAPP		g_lpApp;



STDMETHODIMP OleDoc_ItemCont_GetObjectA(
    LPOLEITEMCONTAINER	lpThis,
    LPSTR lpszItem,
    DWORD dwSpeedNeeded,
    LPBINDCTX lpbc,
    REFIID riid,
    LPVOID FAR*lplpvObject
);

STDMETHODIMP OleDoc_ItemCont_GetObjectStorageA(
    LPOLEITEMCONTAINER lpThis,
    LPSTR lpszItem,
    LPBINDCTX lpbc,
    REFIID riid,
    LPVOID FAR*lplpvStorage
);

#if defined(OLE_CNTR)

STDMETHODIMP OleDoc_ItemCont_IsRunningA(
    LPOLEITEMCONTAINER lpThis,
    LPSTR lpszItem
);

HRESULT ContainerDoc_IsRunningA(
    LPCONTAINERDOC lpContainerDoc,
    LPSTR lpszItem);

HRESULT ContainerDoc_GetObjectA(
    LPCONTAINERDOC lpContainerDoc,
    LPSTR lpszItem,
    DWORD dwSpeedNeeded,
    REFIID riid,
    LPVOID FAR*lplpvObject
);

HRESULT ContainerDoc_GetObjectStorageA(
    LPCONTAINERDOC lpContainerDoc,
    LPSTR lpszItem,
    LPSTORAGE FAR*lplpStg);

#endif // OLE_CNTR

#if defined(OLE_SERVER)

HRESULT ServerDoc_IsRunningA(LPSERVERDOC lpServerDoc, LPSTR lpszItem);

HRESULT ServerDoc_GetObjectA(
    LPSERVERDOC lpServerDoc,
    LPSTR lpszItem,
    REFIID riid,
    LPVOID FAR*lplpvObject);

#endif // OLE_SERVER






/*************************************************************************
** OleDoc::IPersistFile interface implementation
*************************************************************************/

// IPersistFile::QueryInterface
STDMETHODIMP OleDoc_PFile_QueryInterface(
		LPPERSISTFILE       lpThis,
		REFIID              riid,
		LPVOID FAR*         lplpvObj
)
{
	LPOLEDOC lpOleDoc = ((struct CDocPersistFileImpl FAR*)lpThis)->lpOleDoc;

	return OleDoc_QueryInterface(lpOleDoc, riid, lplpvObj);
}


// IPersistFile::AddRef
STDMETHODIMP_(ULONG) OleDoc_PFile_AddRef(LPPERSISTFILE lpThis)
{
	LPOLEDOC lpOleDoc = ((struct CDocPersistFileImpl FAR*)lpThis)->lpOleDoc;

	OleDbgAddRefMethod(lpThis, "IPersistFile");

	return OleDoc_AddRef(lpOleDoc);
}


// IPersistFile::Release
STDMETHODIMP_(ULONG) OleDoc_PFile_Release (LPPERSISTFILE lpThis)
{
	LPOLEDOC lpOleDoc = ((struct CDocPersistFileImpl FAR*)lpThis)->lpOleDoc;

	OleDbgReleaseMethod(lpThis, "IPersistFile");

	return OleDoc_Release(lpOleDoc);
}


// IPersistFile::GetClassID
STDMETHODIMP OleDoc_PFile_GetClassID (
		LPPERSISTFILE       lpThis,
		CLSID FAR*          lpclsid
)
{
	LPOLEDOC lpOleDoc = ((struct CDocPersistFileImpl FAR*)lpThis)->lpOleDoc;
	LPOLEAPP lpOleApp = (LPOLEAPP)g_lpApp;
	OleDbgOut2("OleDoc_PFile_GetClassID\r\n");

#if defined( OLE_SERVER ) && defined( SVR_TREATAS )

	/* OLE2NOTE: we must be carefull to return the correct CLSID here.
	**    if we are currently preforming a "TreatAs (aka. ActivateAs)"
	**    operation then we need to return the class of the object
	**    written in the storage of the object. otherwise we would
	**    return our own class id.
	*/
	return ServerDoc_GetClassID((LPSERVERDOC)lpOleDoc, lpclsid);
#else
	*lpclsid = CLSID_APP;
#endif
	return NOERROR;
}


// IPersistFile::IsDirty
STDMETHODIMP  OleDoc_PFile_IsDirty(LPPERSISTFILE lpThis)
{
	LPOLEDOC lpOleDoc = ((struct CDocPersistFileImpl FAR*)lpThis)->lpOleDoc;
	OleDbgOut2("OleDoc_PFile_IsDirty\r\n");

	if (OutlineDoc_IsModified((LPOUTLINEDOC)lpOleDoc))
		return NOERROR;
	else
		return ResultFromScode(S_FALSE);
}


// IPersistFile::Load
STDMETHODIMP OleDoc_PFile_LoadA(
		LPPERSISTFILE       lpThis,
		LPCSTR              lpszFileName,
		DWORD               grfMode
)
{
	LPOLEDOC lpOleDoc = ((struct CDocPersistFileImpl FAR*)lpThis)->lpOleDoc;
	SCODE sc;

	OLEDBG_BEGIN2("OleDoc_PFile_Load\r\n")

	/* OLE2NOTE: grfMode passed from the caller indicates if the caller
	**    needs Read or ReadWrite permissions. if appropriate the
	**    callee should open the file with the requested permissions.
	**    the caller will normally not impose sharing permissions.
	**
	**    the sample code currently always opens its file ReadWrite.
	*/

	if (OutlineDoc_LoadFromFile((LPOUTLINEDOC)lpOleDoc, (LPSTR)lpszFileName))
		sc = S_OK;
	else
		sc = E_FAIL;

	OLEDBG_END2
	return ResultFromScode(sc);
}



// IPersistFile::Load
STDMETHODIMP OleDoc_PFile_Load (
		LPPERSISTFILE       lpThis,
		LPCOLESTR	    lpszFileName,
		DWORD               grfMode
)
{
    CREATESTR(lpsz, lpszFileName)

    HRESULT hr = OleDoc_PFile_LoadA(lpThis, lpsz, grfMode);

    FREESTR(lpsz)

    return hr;
}



// IPersistFile::Save
STDMETHODIMP OleDoc_PFile_SaveA (
		LPPERSISTFILE       lpThis,
		LPCSTR              lpszFileName,
		BOOL                fRemember
)
{
	LPOLEDOC lpOleDoc = ((struct CDocPersistFileImpl FAR*)lpThis)->lpOleDoc;
	LPOUTLINEDOC lpOutlineDoc = (LPOUTLINEDOC)lpOleDoc;
	SCODE sc;

	OLEDBG_BEGIN2("OleDoc_PFile_Save\r\n")

	/* OLE2NOTE: it is only legal to perform a Save or SaveAs operation
	**    on a file-based document. if the document is an embedded
	**    object then we can not be changed to a file-base object.
	**
	**      fRemember   lpszFileName     Type of Save
	**    ----------------------------------------------
	**        TRUE        NULL           SAVE
	**        TRUE        ! NULL         SAVE AS
	**        FALSE       ! NULL         SAVE COPY AS
	**        FALSE       NULL           ***error***
	*/
	if ( (lpszFileName==NULL || (lpszFileName != NULL && fRemember))
			&& ((lpOutlineDoc->m_docInitType != DOCTYPE_FROMFILE
				&& lpOutlineDoc->m_docInitType != DOCTYPE_NEW)) ) {
		OLEDBG_END2
		return ResultFromScode(E_INVALIDARG);
	}

	if (OutlineDoc_SaveToFile(
			(LPOUTLINEDOC)lpOleDoc,
			lpszFileName,
			lpOutlineDoc->m_cfSaveFormat,
			fRemember)) {
		sc = S_OK;
	} else
		sc = E_FAIL;

	OLEDBG_END2
	return ResultFromScode(sc);
}



// IPersistFile::Save
STDMETHODIMP OleDoc_PFile_Save(
		LPPERSISTFILE       lpThis,
		LPCOLESTR	    lpszFileName,
		BOOL                fRemember
)
{
    CREATESTR(lpsz, lpszFileName)

    HRESULT hr = OleDoc_PFile_SaveA(lpThis, lpsz, fRemember);

    FREESTR(lpsz)

    return hr;
}




// IPersistFile::SaveCompleted
STDMETHODIMP OleDoc_PFile_SaveCompletedA (
		LPPERSISTFILE       lpThis,
		LPCSTR              lpszFileName
)
{
	LPOLEDOC lpOleDoc = ((struct CDocPersistFileImpl FAR*)lpThis)->lpOleDoc;
	LPOUTLINEDOC lpOutlineDoc = (LPOUTLINEDOC)lpOleDoc;

	OleDbgOut2("OleDoc_PFile_SaveCompleted\r\n");

	/* This method is called after IPersistFile::Save is called. during
	**    the period between Save and SaveCompleted the object must
	**    consider itself in NOSCRIBBLE mode (ie. it is NOT allowed to
	**    write to its file. here the object can clear its NOSCRIBBLE
	**    mode flag. the outline app never scribbles to its storage, so
	**    we have nothing to do.
	*/
	return NOERROR;
}



STDMETHODIMP OleDoc_PFile_SaveCompleted (
		LPPERSISTFILE       lpThis,
		LPCOLESTR	    lpszFileName
)
{
    CREATESTR(lpsz, lpszFileName)

    HRESULT hr = OleDoc_PFile_SaveCompletedA(lpThis, lpsz);

    FREESTR(lpsz)

    return hr;
}



// IPersistFile::GetCurFile
STDMETHODIMP OleDoc_PFile_GetCurFileA (
		LPPERSISTFILE   lpThis,
		LPSTR FAR*      lplpszFileName
)
{
	LPOLEDOC lpOleDoc = ((struct CDocPersistFileImpl FAR*)lpThis)->lpOleDoc;
	LPOUTLINEDOC lpOutlineDoc = (LPOUTLINEDOC)lpOleDoc;
	LPMALLOC lpMalloc;
	LPSTR lpsz;
	SCODE sc;
	OleDbgOut2("OleDoc_PFile_GetCurFile\r\n");

	/* OLE2NOTE: we must make sure to set all out ptr parameters to NULL. */
	*lplpszFileName = NULL;

	/*********************************************************************
	** OLE2NOTE: memory returned for the lplpszFileName must be
	**    allocated appropriately using the current registered IMalloc
	**    interface. the allows the ownership of the memory to be
	**    passed to the caller (even if in another process).
	*********************************************************************/

	CoGetMalloc(MEMCTX_TASK, &lpMalloc);
	if (! lpMalloc) {
		return ResultFromScode(E_FAIL);
	}

	if (lpOutlineDoc->m_docInitType == DOCTYPE_FROMFILE) {
		/* valid filename associated; return file name */
		lpsz = (LPSTR)lpMalloc->lpVtbl->Alloc(
				lpMalloc,
				lstrlen((LPSTR)lpOutlineDoc->m_szFileName)+1
		);
		if (! lpsz) {
			sc = E_OUTOFMEMORY;
			goto error;
		}

		lstrcpy(lpsz, (LPSTR)lpOutlineDoc->m_szFileName);
		sc = S_OK;
	} else {
		/* no file associated; return default file name prompt */
		lpsz=(LPSTR)lpMalloc->lpVtbl->Alloc(lpMalloc, sizeof(DEFEXTENSION)+3);
		wsprintf(lpsz, "*.%s", DEFEXTENSION);
		sc = S_FALSE;
	}

error:
	OleStdRelease((LPUNKNOWN)lpMalloc);
	*lplpszFileName = lpsz;
	return ResultFromScode(sc);
}

STDMETHODIMP OleDoc_PFile_GetCurFile (
		LPPERSISTFILE   lpThis,
		LPOLESTR FAR*	 lplpszFileName
)
{
    LPSTR lpsz;

    HRESULT hr = OleDoc_PFile_GetCurFileA(lpThis, &lpsz);

    CopyAndFreeSTR(lpsz, lplpszFileName);

    return hr;
}

/*************************************************************************
** OleDoc::IOleItemContainer interface implementation
*************************************************************************/

// IOleItemContainer::QueryInterface
STDMETHODIMP OleDoc_ItemCont_QueryInterface(
		LPOLEITEMCONTAINER  lpThis,
		REFIID              riid,
		LPVOID FAR*         lplpvObj
)
{
	LPOLEDOC lpOleDoc =
			((struct CDocOleItemContainerImpl FAR*)lpThis)->lpOleDoc;

	return OleDoc_QueryInterface(lpOleDoc, riid, lplpvObj);
}


// IOleItemContainer::AddRef
STDMETHODIMP_(ULONG) OleDoc_ItemCont_AddRef(LPOLEITEMCONTAINER lpThis)
{
	LPOLEDOC lpOleDoc =
			((struct CDocOleItemContainerImpl FAR*)lpThis)->lpOleDoc;

	OleDbgAddRefMethod(lpThis, "IOleItemContainer");

	return OleDoc_AddRef((LPOLEDOC)lpOleDoc);
}


// IOleItemContainer::Release
STDMETHODIMP_(ULONG) OleDoc_ItemCont_Release(LPOLEITEMCONTAINER lpThis)
{
	LPOLEDOC lpOleDoc =
			((struct CDocOleItemContainerImpl FAR*)lpThis)->lpOleDoc;

	OleDbgReleaseMethod(lpThis, "IOleItemContainer");

	return OleDoc_Release((LPOLEDOC)lpOleDoc);
}


// IOleItemContainer::ParseDisplayName
STDMETHODIMP OleDoc_ItemCont_ParseDisplayNameA(
		LPOLEITEMCONTAINER  lpThis,
		LPBC                lpbc,
		LPSTR               lpszDisplayName,
		ULONG FAR*          lpchEaten,
		LPMONIKER FAR*      lplpmkOut
)
{
	LPOLEDOC lpOleDoc =
			((struct CDocOleItemContainerImpl FAR*)lpThis)->lpOleDoc;
	char szItemName[MAXNAMESIZE];
	LPUNKNOWN lpUnk;
	HRESULT hrErr;
	OleDbgOut2("OleDoc_ItemCont_ParseDisplayName\r\n");

	/* OLE2NOTE: we must make sure to set all out ptr parameters to NULL. */
	*lplpmkOut = NULL;

	*lpchEaten = OleStdGetItemToken(
			lpszDisplayName,
			szItemName,
			sizeof(szItemName)
	);

	/* OLE2NOTE: get a pointer to a running instance of the object. we
	**    should force the object to go running if necessary (even if
	**    this means launching its server EXE). this is the meaining of
	**    BINDSPEED_INDEFINITE. Parsing a Moniker is known to be an
	**    "EXPENSIVE" operation.
	*/
	hrErr = OleDoc_ItemCont_GetObjectA(
			lpThis,
			szItemName,
			BINDSPEED_INDEFINITE,
			lpbc,
			&IID_IUnknown,
			(LPVOID FAR*)&lpUnk
	);

	if (hrErr == NOERROR) {
		OleStdRelease(lpUnk);   // item name FOUND; don't need obj ptr.

		CreateItemMonikerA(OLESTDDELIM, szItemName, lplpmkOut);

	} else
		*lpchEaten = 0;     // item name is NOT valid

	return hrErr;
}

STDMETHODIMP OleDoc_ItemCont_ParseDisplayName(
		LPOLEITEMCONTAINER  lpThis,
		LPBC                lpbc,
		LPOLESTR	    lpszDisplayName,
		ULONG FAR*          lpchEaten,
		LPMONIKER FAR*      lplpmkOut
)
{
    CREATESTR(lpsz, lpszDisplayName)

    HRESULT hr = OleDoc_ItemCont_ParseDisplayNameA(lpThis, lpbc,
	    lpsz, lpchEaten, lplpmkOut);

    FREESTR(lpsz);

    return hr;
}


// IOleItemContainer::EnumObjects
STDMETHODIMP OleDoc_ItemCont_EnumObjects(
		LPOLEITEMCONTAINER  lpThis,
		DWORD               grfFlags,
		LPENUMUNKNOWN FAR*  lplpenumUnknown
)
{
	LPOLEDOC lpOleDoc =
			((struct CDocOleItemContainerImpl FAR*)lpThis)->lpOleDoc;

	OLEDBG_BEGIN2("OleDoc_ItemCont_EnumObjects\r\n")

	/* OLE2NOTE: we must make sure to set all out ptr parameters to NULL. */
	*lplpenumUnknown = NULL;

	/* OLE2NOTE: this method should be implemented to allow programatic
	**    clients the ability to what elements the container holds.
	**    this method is NOT called in the standard linking scenarios.
	**
	**    grfFlags can be one of the following:
	**        OLECONTF_EMBEDDINGS   -- enumerate embedded objects
	**        OLECONTF_LINKS        -- enumerate linked objects
	**        OLECONTF_OTHERS       -- enumerate non-OLE compound doc objs
	**        OLECONTF_ONLYUSER     -- enumerate only objs named by user
	**        OLECONTF_ONLYIFRUNNING-- enumerate only objs in running state
	*/

	OleDbgAssertSz(0, "NOT YET IMPLEMENTED!");

	OLEDBG_END2
	return ResultFromScode(E_NOTIMPL);
}


// IOleItemContainer::LockContainer
STDMETHODIMP OleDoc_ItemCont_LockContainer(
		LPOLEITEMCONTAINER  lpThis,
		BOOL                fLock
)
{
	LPOLEDOC lpOleDoc =
			((struct CDocOleItemContainerImpl FAR*)lpThis)->lpOleDoc;
	HRESULT hrErr;
	OLEDBG_BEGIN2("OleDoc_ItemCont_LockContainer\r\n")

#if defined( _DEBUG )
	if (fLock) {
		++lpOleDoc->m_cCntrLock;
		OleDbgOutRefCnt3(
				"OleDoc_ItemCont_LockContainer: cLock++\r\n",
				lpOleDoc,
				lpOleDoc->m_cCntrLock
		);
	} else {
		/* OLE2NOTE: when there are no open documents and the app is not
		**    under the control of the user and there are no outstanding
		**    locks on the app, then revoke our ClassFactory to enable the
		**    app to shut down.
		*/
		--lpOleDoc->m_cCntrLock;
		OleDbgAssertSz (
				lpOleDoc->m_cCntrLock >= 0,
				"OleDoc_ItemCont_LockContainer(FALSE) called with cLock == 0"
		);

		if (lpOleDoc->m_cCntrLock == 0) {
			OleDbgOutRefCnt2(
					"OleDoc_ItemCont_LockContainer: UNLOCKED\r\n",
					lpOleDoc, lpOleDoc->m_cCntrLock);
		} else {
			OleDbgOutRefCnt3(
					"OleDoc_ItemCont_LockContainer: cLock--\r\n",
					lpOleDoc, lpOleDoc->m_cCntrLock);
		}
	}
#endif  // _DEBUG

	/* OLE2NOTE: in order to hold the document alive we call
	**    CoLockObjectExternal to add a strong reference to our Doc
	**    object. this will keep the Doc alive when all other external
	**    references release us. whenever an embedded object goes
	**    running a LockContainer(TRUE) is called. when the embedded
	**    object shuts down (ie. transitions from running to loaded)
	**    LockContainer(FALSE) is called. if the user issues File.Close
	**    the document will shut down in any case ignoring any
	**    outstanding LockContainer locks because CoDisconnectObject is
	**    called in OleDoc_Close. this will forceably break any
	**    existing strong reference counts including counts that we add
	**    ourselves by calling CoLockObjectExternal and guarantee that
	**    the Doc object gets its final release (ie. cRefs goes to 0).
	*/
	hrErr = OleDoc_Lock(lpOleDoc, fLock, TRUE /* fLastUnlockReleases */);

	OLEDBG_END2
	return hrErr;
}


// IOleItemContainer::GetObject
STDMETHODIMP OleDoc_ItemCont_GetObjectA(
		LPOLEITEMCONTAINER  lpThis,
		LPSTR               lpszItem,
		DWORD               dwSpeedNeeded,
		LPBINDCTX           lpbc,
		REFIID              riid,
		LPVOID FAR*         lplpvObject
)
{
	LPOLEDOC lpOleDoc =
			((struct CDocOleItemContainerImpl FAR*)lpThis)->lpOleDoc;
	HRESULT hrErr;

	OLEDBG_BEGIN2("OleDoc_ItemCont_GetObject\r\n")

	/* OLE2NOTE: we must make sure to set all out ptr parameters to NULL. */
	*lplpvObject = NULL;

#if defined( OLE_SERVER )

	/* OLE2NOTE: SERVER ONLY version should return PseudoObjects with
	**    BINDSPEED_IMMEDIATE, thus the dwSpeedNeeded is not important
	**    in the case of a pure server.
	*/
	hrErr = ServerDoc_GetObjectA(
			(LPSERVERDOC)lpOleDoc, lpszItem,riid,lplpvObject);
#endif
#if defined( OLE_CNTR )

	/* OLE2NOTE: dwSpeedNeeded indicates how long the caller is willing
	**    to wait for us to get the object:
	**      BINDSPEED_IMMEDIATE -- only if obj already loaded && IsRunning
	**      BINDSPEED_MODERATE  -- load obj if necessary && if IsRunning
	**      BINDSPEED_INDEFINITE-- force obj to load and run if necessary
	*/
	hrErr = ContainerDoc_GetObjectA(
		(LPCONTAINERDOC)lpOleDoc,lpszItem,dwSpeedNeeded,riid,lplpvObject);
#endif

	OLEDBG_END2
	return hrErr;
}




STDMETHODIMP OleDoc_ItemCont_GetObject(
		LPOLEITEMCONTAINER  lpThis,
		LPOLESTR	    lpszItem,
		DWORD               dwSpeedNeeded,
		LPBINDCTX           lpbc,
		REFIID              riid,
		LPVOID FAR*         lplpvObject
)
{
    CREATESTR(lpsz, lpszItem)

    HRESULT hr = OleDoc_ItemCont_GetObjectA(lpThis, lpsz, dwSpeedNeeded, lpbc,
	riid, lplpvObject);

    FREESTR(lpsz)

    return hr;
}


// IOleItemContainer::GetObjectStorage
STDMETHODIMP OleDoc_ItemCont_GetObjectStorageA(
		LPOLEITEMCONTAINER  lpThis,
		LPSTR               lpszItem,
		LPBINDCTX           lpbc,
		REFIID              riid,
		LPVOID FAR*         lplpvStorage
)
{
	LPOLEDOC lpOleDoc =
			((struct CDocOleItemContainerImpl FAR*)lpThis)->lpOleDoc;
	OleDbgOut2("OleDoc_ItemCont_GetObjectStorage\r\n");

	/* OLE2NOTE: we must make sure to set all out ptr parameters to NULL. */
	*lplpvStorage = NULL;

#if defined( OLE_SERVER )
	/* OLE2NOTE: in the SERVER ONLY version, item names identify pseudo
	**    objects. pseudo objects, do NOT have identifiable storage.
	*/
	return ResultFromScode(E_FAIL);
#endif
#if defined( OLE_CNTR )
	// We can only return an IStorage* type pointer
	if (! IsEqualIID(riid, &IID_IStorage))
		return ResultFromScode(E_FAIL);

	return ContainerDoc_GetObjectStorageA(
			(LPCONTAINERDOC)lpOleDoc,
			lpszItem,
			(LPSTORAGE FAR*)lplpvStorage
	);
#endif
}

STDMETHODIMP OleDoc_ItemCont_GetObjectStorage(
		LPOLEITEMCONTAINER  lpThis,
		LPOLESTR	    lpszItem,
		LPBINDCTX           lpbc,
		REFIID              riid,
		LPVOID FAR*         lplpvStorage
)
{
    CREATESTR(lpsz, lpszItem)

    HRESULT hr = OleDoc_ItemCont_GetObjectStorageA(lpThis, lpsz, lpbc,
	    riid, lplpvStorage);

    FREESTR(lpsz)

    return hr;
}

// IOleItemContainer::IsRunning
STDMETHODIMP OleDoc_ItemCont_IsRunningA(
		LPOLEITEMCONTAINER  lpThis,
		LPSTR               lpszItem
)
{
	LPOLEDOC lpOleDoc =
			((struct CDocOleItemContainerImpl FAR*)lpThis)->lpOleDoc;
	HRESULT hrErr;

	OLEDBG_BEGIN2("OleDoc_ItemCont_IsRunning\r\n")

	/* OLE2NOTE: Check if item name is valid. if so then return if
	**    Object is running. PseudoObjects in the Server version are
	**    always considered running. Ole objects in the container must
	**    be checked if they are running.
	*/

#if defined( OLE_SERVER )
	hrErr = ServerDoc_IsRunningA((LPSERVERDOC)lpOleDoc, lpszItem);
#endif
#if defined( OLE_CNTR )
	hrErr = ContainerDoc_IsRunningA((LPCONTAINERDOC)lpOleDoc, lpszItem);
#endif

	OLEDBG_END2
	return hrErr;
}

STDMETHODIMP OleDoc_ItemCont_IsRunning(
		LPOLEITEMCONTAINER  lpThis,
		LPOLESTR	    lpszItem
)
{
    CREATESTR(lpsz, lpszItem)

    HRESULT hr = OleDoc_ItemCont_IsRunningA(lpThis,lpsz);

    FREESTR(lpsz)

    return hr;
}

/*************************************************************************
** OleDoc::IExternalConnection interface implementation
*************************************************************************/

// IExternalConnection::QueryInterface
STDMETHODIMP OleDoc_ExtConn_QueryInterface(
		LPEXTERNALCONNECTION    lpThis,
		REFIID                  riid,
		LPVOID FAR*             lplpvObj
)
{
	LPOLEDOC lpOleDoc =
			((struct CDocExternalConnectionImpl FAR*)lpThis)->lpOleDoc;

	return OleDoc_QueryInterface(lpOleDoc, riid, lplpvObj);
}


// IExternalConnection::AddRef
STDMETHODIMP_(ULONG) OleDoc_ExtConn_AddRef(LPEXTERNALCONNECTION lpThis)
{
	LPOLEDOC lpOleDoc =
			((struct CDocExternalConnectionImpl FAR*)lpThis)->lpOleDoc;

	OleDbgAddRefMethod(lpThis, "IExternalConnection");

	return OleDoc_AddRef(lpOleDoc);
}


// IExternalConnection::Release
STDMETHODIMP_(ULONG) OleDoc_ExtConn_Release (LPEXTERNALCONNECTION lpThis)
{
	LPOLEDOC lpOleDoc =
			((struct CDocExternalConnectionImpl FAR*)lpThis)->lpOleDoc;

	OleDbgReleaseMethod(lpThis, "IExternalConnection");

	return OleDoc_Release(lpOleDoc);
}


// IExternalConnection::AddConnection
STDMETHODIMP_(DWORD) OleDoc_ExtConn_AddConnection(
		LPEXTERNALCONNECTION    lpThis,
		DWORD                   extconn,
		DWORD                   reserved
)
{
	LPOLEDOC lpOleDoc =
			((struct CDocExternalConnectionImpl FAR*)lpThis)->lpOleDoc;

	if( extconn & EXTCONN_STRONG ) {

#if defined( _DEBUG )
		OleDbgOutRefCnt3(
				"OleDoc_ExtConn_AddConnection: dwStrongExtConn++\r\n",
				lpOleDoc,
				lpOleDoc->m_dwStrongExtConn + 1
		);
#endif
		return ++(lpOleDoc->m_dwStrongExtConn);
	} else
		return 0;
}


// IExternalConnection::ReleaseConnection
STDMETHODIMP_(DWORD) OleDoc_ExtConn_ReleaseConnection(
		LPEXTERNALCONNECTION    lpThis,
		DWORD                   extconn,
		DWORD                   reserved,
		BOOL                    fLastReleaseCloses
)
{
	LPOLEDOC lpOleDoc =
			((struct CDocExternalConnectionImpl FAR*)lpThis)->lpOleDoc;

	if( extconn & EXTCONN_STRONG ){
		DWORD dwSave = --(lpOleDoc->m_dwStrongExtConn);
#if defined( _DEBUG )
		OLEDBG_BEGIN2( (fLastReleaseCloses ?
						"OleDoc_ExtConn_ReleaseConnection(TRUE)\r\n" :
						"OleDoc_ExtConn_ReleaseConnection(FALSE)\r\n") )
		OleDbgOutRefCnt3(
				"OleDoc_ExtConn_ReleaseConnection: dwStrongExtConn--\r\n",
				lpOleDoc,
				lpOleDoc->m_dwStrongExtConn
		);
		OleDbgAssertSz (
				lpOleDoc->m_dwStrongExtConn >= 0,
				"OleDoc_ExtConn_ReleaseConnection called with dwStrong == 0"
		);
#endif  // _DEBUG

		if( lpOleDoc->m_dwStrongExtConn == 0 && fLastReleaseCloses )
			OleDoc_Close(lpOleDoc, OLECLOSE_SAVEIFDIRTY);

		OLEDBG_END2
		return dwSave;
	} else
		return 0;
}


/*************************************************************************
** OleDoc Common Support Functions
*************************************************************************/


/* OleDoc_GetFullMoniker
** ---------------------
**    Return the full, absolute moniker of the document.
**
**    NOTE: the caller must release the pointer returned when done.
*/
LPMONIKER OleDoc_GetFullMoniker(LPOLEDOC lpOleDoc, DWORD dwAssign)
{
	LPMONIKER lpMoniker = NULL;

	OLEDBG_BEGIN3("OleDoc_GetFullMoniker\r\n")

	if (lpOleDoc->m_lpSrcDocOfCopy) {
		/* CASE I: this document was created for a copy or drag/drop
		**    operation. generate the moniker which identifies the
		**    source document of the original copy.
		*/
		if (! lpOleDoc->m_fLinkSourceAvail)
			goto done;        // we already know a moniker is not available

		lpMoniker=OleDoc_GetFullMoniker(lpOleDoc->m_lpSrcDocOfCopy, dwAssign);
	}
	else if (lpOleDoc->m_lpFileMoniker) {

		/* CASE II: this document is a top-level user document (either
		**    file-based or untitled). return the FileMoniker stored
		**    with the document; it uniquely identifies the document.
		*/
		// we must AddRef the moniker to pass out a ptr
		lpOleDoc->m_lpFileMoniker->lpVtbl->AddRef(lpOleDoc->m_lpFileMoniker);

		lpMoniker = lpOleDoc->m_lpFileMoniker;
	}

#if defined( OLE_SERVER )

	else if (((LPSERVERDOC)lpOleDoc)->m_lpOleClientSite) {

		/* CASE III: this document is an embedded object, ask our
		**    container for our moniker.
		*/
		OLEDBG_BEGIN2("IOleClientSite::GetMoniker called\r\n");
		((LPSERVERDOC)lpOleDoc)->m_lpOleClientSite->lpVtbl->GetMoniker(
				((LPSERVERDOC)lpOleDoc)->m_lpOleClientSite,
				dwAssign,
				OLEWHICHMK_OBJFULL,
				&lpMoniker
		);
		OLEDBG_END2
	}

#endif

	else {
		lpMoniker = NULL;
	}

done:
	OLEDBG_END3
	return lpMoniker;
}


/* OleDoc_DocRenamedUpdate
** -----------------------
**    Update the documents registration in the running object table (ROT).
**    Also inform all embedded OLE objects (container only) and/or psedudo
**    objects (server only) that the name of the document has changed.
*/
void OleDoc_DocRenamedUpdate(LPOLEDOC lpOleDoc, LPMONIKER lpmkDoc)
{
	OLEDBG_BEGIN3("OleDoc_DocRenamedUpdate\r\n")

	OleDoc_AddRef(lpOleDoc);

	/* OLE2NOTE: we must re-register ourselves as running when we
	**    get a new moniker assigned (ie. when we are renamed).
	*/
	OLEDBG_BEGIN3("OleStdRegisterAsRunning called\r\n")
	OleStdRegisterAsRunning(
			(LPUNKNOWN)&lpOleDoc->m_Unknown,
			lpmkDoc,
			&lpOleDoc->m_dwRegROT
	);
	OLEDBG_END3

#if defined( OLE_SERVER )
	{
		LPSERVERDOC lpServerDoc = (LPSERVERDOC)lpOleDoc;
		LPOUTLINEDOC lpOutlineDoc = (LPOUTLINEDOC)lpOleDoc;

		/* OLE2NOTE: inform any linking clients that the document has been
		**    renamed.
		*/
		ServerDoc_SendAdvise (
				lpServerDoc,
				OLE_ONRENAME,
				lpmkDoc,
				0        /* advf -- not relevant here */
		);

		/* OLE2NOTE: inform any clients of pseudo objects
		**    within our document, that our document's
		**    Moniker has changed.
		*/
		ServerNameTable_InformAllPseudoObjectsDocRenamed(
				(LPSERVERNAMETABLE)lpOutlineDoc->m_lpNameTable, lpmkDoc);
	}
#endif
#if defined( OLE_CNTR )
	{
		LPCONTAINERDOC lpContainerDoc = (LPCONTAINERDOC)lpOleDoc;

		/* OLE2NOTE: must tell all OLE objects that our container
		**    moniker changed.
		*/
		ContainerDoc_InformAllOleObjectsDocRenamed(
				lpContainerDoc,
				lpmkDoc
		);
	}
#endif

	OleDoc_Release(lpOleDoc);       // release artificial AddRef above
	OLEDBG_END3
}



#if defined( OLE_SERVER )

/*************************************************************************
** ServerDoc Supprt Functions Used by Server versions
*************************************************************************/


/* ServerDoc_PseudoObjLockDoc
** --------------------------
**    Add a lock on the Doc on behalf of the PseudoObject. the Doc may not
**    close while the Doc exists.
**
**    when a pseudo object is first created, it calls this method to
**    guarantee that the document stays alive (PseudoObj_Init).
**    when a pseudo object is destroyed, it call
**    ServerDoc_PseudoObjUnlockDoc to release this hold on the document.
*/
void ServerDoc_PseudoObjLockDoc(LPSERVERDOC lpServerDoc)
{
	LPOLEDOC lpOleDoc = (LPOLEDOC)lpServerDoc;
	ULONG cPseudoObj;

	cPseudoObj = ++lpServerDoc->m_cPseudoObj;

#if defined( _DEBUG )
	OleDbgOutRefCnt3(
			"ServerDoc_PseudoObjLockDoc: cPseudoObj++\r\n",
			lpServerDoc,
			cPseudoObj
	);
#endif
	OleDoc_Lock(lpOleDoc, TRUE /* fLock */, 0 /* not applicable */);
	return;
}


/* ServerDoc_PseudoObjUnlockDoc
** ----------------------------
**    Release the lock on the Doc on behalf of the PseudoObject. if this was
**    the last lock on the Doc, then it will shutdown.
*/
void ServerDoc_PseudoObjUnlockDoc(
		LPSERVERDOC         lpServerDoc,
		LPPSEUDOOBJ         lpPseudoObj
)
{
	ULONG cPseudoObj;
	LPOLEDOC lpOleDoc = (LPOLEDOC)lpServerDoc;
	OLEDBG_BEGIN3("ServerDoc_PseudoObjUnlockDoc\r\n")

	/* OLE2NOTE: when there are no active pseudo objects in the Doc and
	**    the Doc is not visible, and if there are no outstanding locks
	**    on the Doc, then this is a "silent update"
	**    situation. our Doc is being used programatically by some
	**    client; it is NOT accessible to the user because it is
	**    NOT visible. thus since all Locks have been released, we
	**    will close the document. if the app is only running due
	**    to the presence of this document, then the app will now
	**    also shut down.
	*/
	cPseudoObj = --lpServerDoc->m_cPseudoObj;

#if defined( _DEBUG )
	OleDbgAssertSz (
			lpServerDoc->m_cPseudoObj >= 0,
			"PseudoObjUnlockDoc called with cPseudoObj == 0"
	);

	OleDbgOutRefCnt3(
			"ServerDoc_PseudoObjUnlockDoc: cPseudoObj--\r\n",
			lpServerDoc,
			cPseudoObj
	);
#endif
	OleDoc_Lock(lpOleDoc, FALSE /* fLock */, TRUE /* fLastUnlockReleases */);

	OLEDBG_END3
	return;
}


/* ServerDoc_GetObject
** -------------------
**
**    Return a pointer to an object identified by an item string
**    (lpszItem). For a server-only app, the object returned will be a
**    pseudo object.
*/
HRESULT ServerDoc_GetObjectA(
		LPSERVERDOC             lpServerDoc,
		LPSTR                   lpszItem,
		REFIID                  riid,
		LPVOID FAR*             lplpvObject
)
{
	LPPSEUDOOBJ lpPseudoObj;
	LPSERVERNAMETABLE lpServerNameTable =
			(LPSERVERNAMETABLE)((LPOUTLINEDOC)lpServerDoc)->m_lpNameTable;

	*lplpvObject = NULL;

	/* Get the PseudoObj which corresponds to an item name. if the item
	**    name does NOT exist in the name table then NO object is
	**    returned. the ServerNameTable_GetPseudoObj routine finds a
	**    name entry corresponding to the item name, it then checks if
	**    a PseudoObj has already been allocated. if so, it returns the
	**    existing object, otherwise it allocates a new PseudoObj.
	*/
	lpPseudoObj = ServerNameTable_GetPseudoObj(
			lpServerNameTable,
			lpszItem,
			lpServerDoc
	);

	if (! lpPseudoObj) {
		*lplpvObject = NULL;
		return ResultFromScode(MK_E_NOOBJECT);
	}

	// return the desired interface pointer of the pseudo object.
	return PseudoObj_QueryInterface(lpPseudoObj, riid, lplpvObject);
}



HRESULT ServerDoc_GetObject(
		LPSERVERDOC             lpServerDoc,
		LPOLESTR		lpszItem,
		REFIID                  riid,
		LPVOID FAR*             lplpvObject
)
{
    CREATESTR(pstr, lpszItem)

    HRESULT hr = ServerDoc_GetObjectA(lpServerDoc, pstr, riid, lplpvObject);

    FREESTR(pstr)

    return hr;
}



/* ServerDoc_IsRunning
** -------------------
**
**    Check if the object identified by an item string (lpszItem) is in
**    the running state. For a server-only app, if the item name exists in
**    in the NameTable then the item name is considered running.
**    IOleItemContainer::GetObject would succeed.
*/

HRESULT ServerDoc_IsRunningA(LPSERVERDOC lpServerDoc, LPSTR lpszItem)
{
	LPOUTLINENAMETABLE lpOutlineNameTable =
			((LPOUTLINEDOC)lpServerDoc)->m_lpNameTable;
	LPSERVERNAME lpServerName;

	lpServerName = (LPSERVERNAME)OutlineNameTable_FindName(
			lpOutlineNameTable,
			lpszItem
	);

	if (lpServerName)
		return NOERROR;
	else
		return ResultFromScode(MK_E_NOOBJECT);
}


/* ServerDoc_GetSelRelMoniker
** --------------------------
**    Retrieve the relative item moniker which identifies the given
**    selection (lplrSel).
**
**    Returns NULL if a moniker can NOT be created.
*/

LPMONIKER ServerDoc_GetSelRelMoniker(
		LPSERVERDOC             lpServerDoc,
		LPLINERANGE             lplrSel,
		DWORD                   dwAssign
)
{
	LPOUTLINEAPP lpOutlineApp = (LPOUTLINEAPP)g_lpApp;
	LPOUTLINEDOC lpOutlineDoc = (LPOUTLINEDOC)lpServerDoc;
	LPSERVERNAMETABLE lpServerNameTable =
			(LPSERVERNAMETABLE)lpOutlineDoc->m_lpNameTable;
	LPOUTLINENAMETABLE lpOutlineNameTable =
			(LPOUTLINENAMETABLE)lpServerNameTable;
	LPOUTLINENAME lpOutlineName;
	LPMONIKER lpmk;

	lpOutlineName=OutlineNameTable_FindNamedRange(lpOutlineNameTable,lplrSel);

	if (lpOutlineName) {
		/* the selection range already has a name assigned */
		CreateItemMonikerA(OLESTDDELIM, lpOutlineName->m_szName, &lpmk);
	} else {
		char szbuf[MAXNAMESIZE];

		switch (dwAssign) {

			case GETMONIKER_FORCEASSIGN:

				/* Force the assignment of the name. This is called when a
				**    Paste Link actually occurs. At this point we want to
				**    create a Name and add it to the NameTable in order to
				**    track the source of the link. This name (as all
				**    names) will be updated upon editing of the document.
				*/
				wsprintf(
						szbuf,
						"%s %ld",
						(LPSTR)DEFRANGENAMEPREFIX,
						++(lpServerDoc->m_nNextRangeNo)
				);

				lpOutlineName = OutlineApp_CreateName(lpOutlineApp);

				if (lpOutlineName) {
					lstrcpy(lpOutlineName->m_szName, szbuf);
					lpOutlineName->m_nStartLine = lplrSel->m_nStartLine;
					lpOutlineName->m_nEndLine = lplrSel->m_nEndLine;
					OutlineDoc_AddName(lpOutlineDoc, lpOutlineName);
				} else {
					// REVIEW: do we need "Out-of-Memory" error message here?
				}
				break;

			case GETMONIKER_TEMPFORUSER:

				/* Create a name to show to the user in the Paste
				**    Special dialog but do NOT yet incur the overhead
				**    of adding a Name to the NameTable. The Moniker
				**    generated should be useful to display to the user
				**    to indicate the source of the copy, but will NOT
				**    be used to create a link directly (the caller
				**    should ask again for a moniker specifying FORCEASSIGN).
				**    we will generate the name that would be the next
				**    auto-generated range name, BUT will NOT actually
				**    increment the range counter.
				*/
				wsprintf(
						szbuf,
						"%s %ld",
						(LPSTR)DEFRANGENAMEPREFIX,
						(lpServerDoc->m_nNextRangeNo)+1
				);
				break;

			case GETMONIKER_ONLYIFTHERE:

				/* the caller only wants a name if one has already been
				**    assigned. we have already above checked if the
				**    current selection has a name, so we will simply
				**    return NULL here.
				*/
				return NULL;    // no moniker is assigned

			default:
				return NULL;    // unknown flag given
		}

		CreateItemMonikerA(OLESTDDELIM, szbuf, &lpmk);
	}
	return lpmk;
}


/* ServerDoc_GetSelFullMoniker
** ---------------------------
**    Retrieve the full absolute moniker which identifies the given
**    selection (lplrSel).
**    this moniker is created as a composite of the absolute moniker for
**    the entire document appended with an item moniker which identifies
**    the selection relative to the document.
**    Returns NULL if a moniker can NOT be created.
*/
LPMONIKER ServerDoc_GetSelFullMoniker(
		LPSERVERDOC             lpServerDoc,
		LPLINERANGE             lplrSel,
		DWORD                   dwAssign
)
{
	LPMONIKER lpmkDoc = NULL;
	LPMONIKER lpmkItem = NULL;
	LPMONIKER lpmkFull = NULL;

	lpmkDoc = OleDoc_GetFullMoniker(
			(LPOLEDOC)lpServerDoc,
			dwAssign
	);
	if (! lpmkDoc) return NULL;

	lpmkItem = ServerDoc_GetSelRelMoniker(
			lpServerDoc,
			lplrSel,
			dwAssign
	);
	if (lpmkItem) {
		CreateGenericComposite(lpmkDoc, lpmkItem, (LPMONIKER FAR*)&lpmkFull);
		OleStdRelease((LPUNKNOWN)lpmkItem);
	}

	if (lpmkDoc)
		OleStdRelease((LPUNKNOWN)lpmkDoc);

	return lpmkFull;
}


/* ServerNameTable_EditLineUpdate
 * -------------------------------
 *
 *      Update the table when a line at nEditIndex is edited.
 */
void ServerNameTable_EditLineUpdate(
		LPSERVERNAMETABLE       lpServerNameTable,
		int                     nEditIndex
)
{
	LPOUTLINENAMETABLE lpOutlineNameTable =
										(LPOUTLINENAMETABLE)lpServerNameTable;
	LPOUTLINENAME lpOutlineName;
	LINERANGE lrSel;
	LPPSEUDOOBJ lpPseudoObj;
	int i;

	for(i = 0; i < lpOutlineNameTable->m_nCount; i++) {
		lpOutlineName=OutlineNameTable_GetName(lpOutlineNameTable, i);

		lpPseudoObj = ((LPSERVERNAME)lpOutlineName)->m_lpPseudoObj;

		/* if there is a pseudo object associated with this name, then
		**    check if the line that was modified is included within
		**    the named range.
		*/
		if (lpPseudoObj) {
			OutlineName_GetSel(lpOutlineName, &lrSel);

			if(((int)lrSel.m_nStartLine <= nEditIndex) &&
				((int)lrSel.m_nEndLine >= nEditIndex)) {

				// inform linking clients data has changed
				PseudoObj_SendAdvise(
						lpPseudoObj,
						OLE_ONDATACHANGE,
						NULL,   /* lpmkDoc -- not relevant here */
						0       /* advf -- no flags necessary */
				);
			}

		}
	}
}


/* ServerNameTable_InformAllPseudoObjectsDocRenamed
 * ------------------------------------------------
 *
 *      Inform all pseudo object clients that the name of the pseudo
 *      object has changed.
 */
void ServerNameTable_InformAllPseudoObjectsDocRenamed(
		LPSERVERNAMETABLE       lpServerNameTable,
		LPMONIKER               lpmkDoc
)
{
	LPOUTLINENAMETABLE lpOutlineNameTable =
										(LPOUTLINENAMETABLE)lpServerNameTable;
	LPOUTLINENAME lpOutlineName;
	LPPSEUDOOBJ lpPseudoObj;
	LPMONIKER lpmkObj;
	int i;

	OLEDBG_BEGIN2("ServerNameTable_InformAllPseudoObjectsDocRenamed\r\n");

	for(i = 0; i < lpOutlineNameTable->m_nCount; i++) {
		lpOutlineName=OutlineNameTable_GetName(lpOutlineNameTable, i);

		lpPseudoObj = ((LPSERVERNAME)lpOutlineName)->m_lpPseudoObj;

		/* if there is a pseudo object associated with this name, then
		**    send OnRename advise to its linking clients.
		*/
		if (lpPseudoObj &&
			((lpmkObj=PseudoObj_GetFullMoniker(lpPseudoObj,lpmkDoc))!=NULL)) {

			// inform the clients that the name has changed
			PseudoObj_SendAdvise (
					lpPseudoObj,
					OLE_ONRENAME,
					lpmkObj,
					0           /* advf -- not relevant here */
			);
		}
	}
	OLEDBG_END2
}


/* ServerNameTable_InformAllPseudoObjectsDocSaved
 * ------------------------------------------------
 *
 *      Inform all pseudo object clients that the name of the pseudo
 *      object has changed.
 */
void ServerNameTable_InformAllPseudoObjectsDocSaved(
		LPSERVERNAMETABLE       lpServerNameTable,
		LPMONIKER               lpmkDoc
)
{
	LPOUTLINENAMETABLE lpOutlineNameTable =
										(LPOUTLINENAMETABLE)lpServerNameTable;
	LPOUTLINENAME lpOutlineName;
	LPPSEUDOOBJ lpPseudoObj;
	LPMONIKER lpmkObj;
	int i;

	OLEDBG_BEGIN2("ServerNameTable_InformAllPseudoObjectsDocSaved\r\n");

	for(i = 0; i < lpOutlineNameTable->m_nCount; i++) {
		lpOutlineName=OutlineNameTable_GetName(lpOutlineNameTable, i);

		lpPseudoObj = ((LPSERVERNAME)lpOutlineName)->m_lpPseudoObj;

		/* if there is a pseudo object associated with this name, then
		**    send OnSave advise to its linking clients.
		*/
		if (lpPseudoObj &&
			((lpmkObj=PseudoObj_GetFullMoniker(lpPseudoObj,lpmkDoc))!=NULL)) {

			// inform the clients that the name has been saved
			PseudoObj_SendAdvise (
					lpPseudoObj,
					OLE_ONSAVE,
					NULL,   /* lpmkDoc -- not relevant here */
					0       /* advf -- not relevant here */
			);
		}
	}
	OLEDBG_END2
}


/* ServerNameTable_SendPendingAdvises
 * ----------------------------------
 *
 *      Send any pending change notifications for pseudo objects.
 *  while ReDraw is diabled on the ServerDoc, then change advise
 *  notifications are not sent to pseudo object clients.
 */
void ServerNameTable_SendPendingAdvises(LPSERVERNAMETABLE lpServerNameTable)
{
	LPOUTLINENAMETABLE lpOutlineNameTable =
										(LPOUTLINENAMETABLE)lpServerNameTable;
	LPSERVERNAME lpServerName;
	int i;

	for(i = 0; i < lpOutlineNameTable->m_nCount; i++) {
		lpServerName = (LPSERVERNAME)OutlineNameTable_GetName(
				lpOutlineNameTable,
				i
		);
		ServerName_SendPendingAdvises(lpServerName);
	}
}


/* ServerNameTable_GetPseudoObj
** ----------------------------
**
**    Return a pointer to a pseudo object identified by an item string
**    (lpszItem). if the pseudo object already exists, then return the
**    existing object, otherwise allocate a new pseudo object.
*/
LPPSEUDOOBJ ServerNameTable_GetPseudoObj(
		LPSERVERNAMETABLE       lpServerNameTable,
		LPSTR                   lpszItem,
		LPSERVERDOC             lpServerDoc
)
{
	LPSERVERNAME lpServerName;

	lpServerName = (LPSERVERNAME)OutlineNameTable_FindName(
			(LPOUTLINENAMETABLE)lpServerNameTable,
			lpszItem
	);

	if (lpServerName)
		return ServerName_GetPseudoObj(lpServerName, lpServerDoc);
	else
		return NULL;
}


/* ServerNameTable_CloseAllPseudoObjs
 * ----------------------------------
 *
 *  Force all pseudo objects to close. this results in sending OnClose
 *  notification to each pseudo object's linking clients.
 */
void ServerNameTable_CloseAllPseudoObjs(LPSERVERNAMETABLE lpServerNameTable)
{
	LPOUTLINENAMETABLE lpOutlineNameTable =
										(LPOUTLINENAMETABLE)lpServerNameTable;
	LPSERVERNAME lpServerName;
	int i;

	OLEDBG_BEGIN3("ServerNameTable_CloseAllPseudoObjs\r\n")

	for(i = 0; i < lpOutlineNameTable->m_nCount; i++) {
		lpServerName = (LPSERVERNAME)OutlineNameTable_GetName(
				lpOutlineNameTable,
				i
		);
        ServerName_ClosePseudoObj(lpServerName);
	}

	OLEDBG_END3
}



/* ServerName_SetSel
 * -----------------
 *
 *      Change the line range of a  name.
 */
void ServerName_SetSel(
		LPSERVERNAME            lpServerName,
		LPLINERANGE             lplrSel,
		BOOL                    fRangeModified
)
{
	LPOUTLINENAME lpOutlineName = (LPOUTLINENAME)lpServerName;
	BOOL fPseudoObjChanged = fRangeModified;

	if (lpOutlineName->m_nStartLine != lplrSel->m_nStartLine) {
		lpOutlineName->m_nStartLine = lplrSel->m_nStartLine;
		fPseudoObjChanged = TRUE;
	}

	if (lpOutlineName->m_nEndLine != lplrSel->m_nEndLine) {
		lpOutlineName->m_nEndLine = lplrSel->m_nEndLine;
		fPseudoObjChanged = TRUE;
	}

	/* OLE2NOTE: if the range of an active pseudo object has
	**    changed, then inform any linking clients that the object
	**    has changed.
	*/
	if (lpServerName->m_lpPseudoObj && fPseudoObjChanged) {
		PseudoObj_SendAdvise(
				lpServerName->m_lpPseudoObj,
				OLE_ONDATACHANGE,
				NULL,   /* lpmkDoc -- not relevant here */
				0       /* advf -- no flags necessary */
		);
	}
}


/* ServerName_SendPendingAdvises
 * -----------------------------
 *
 *      Send any pending change notifications for the associated
 *  pseudo objects for this name (if one exists).
 *  while ReDraw is diabled on the ServerDoc, then change advise
 *  notifications are not sent to pseudo object clients.
 */
void ServerName_SendPendingAdvises(LPSERVERNAME lpServerName)
{
	if (! lpServerName->m_lpPseudoObj)
		return;     // no associated pseudo object

	if (lpServerName->m_lpPseudoObj->m_fDataChanged)
		PseudoObj_SendAdvise(
				lpServerName->m_lpPseudoObj,
				OLE_ONDATACHANGE,
				NULL,   /* lpmkDoc -- not relevant here */
				0       /* advf -- no flags necessary */
		);
}


/* ServerName_GetPseudoObj
** -----------------------
**
**    Return a pointer to a pseudo object associated to a ServerName.
**    if the pseudo object already exists, then return the
**    existing object, otherwise allocate a new pseudo object.
**
**    NOTE: the PseudoObj is returned with a 0 refcnt if first created,
**    else the existing refcnt is unchanged.
*/
LPPSEUDOOBJ ServerName_GetPseudoObj(
		LPSERVERNAME            lpServerName,
		LPSERVERDOC             lpServerDoc
)
{
	// Check if a PseudoObj already exists
	if (lpServerName->m_lpPseudoObj)
		return lpServerName->m_lpPseudoObj;

	// A PseudoObj does NOT already exist, allocate a new one.
	lpServerName->m_lpPseudoObj=(LPPSEUDOOBJ) New((DWORD)sizeof(PSEUDOOBJ));
	if (lpServerName->m_lpPseudoObj == NULL) {
		OleDbgAssertSz(lpServerName->m_lpPseudoObj != NULL,	"Error allocating PseudoObj");
		return NULL;
	}

	PseudoObj_Init(lpServerName->m_lpPseudoObj, lpServerName, lpServerDoc);
	return lpServerName->m_lpPseudoObj;
}


/* ServerName_ClosePseudoObj
 * -------------------------
 *
 *      if there is an associated pseudo objects for this name (if one
 *  exists), then close it. this results in sending OnClose
 *  notification to the pseudo object's linking clients.
 */
void ServerName_ClosePseudoObj(LPSERVERNAME lpServerName)
{
	if (!lpServerName || !lpServerName->m_lpPseudoObj)
		return;     // no associated pseudo object

	PseudoObj_Close(lpServerName->m_lpPseudoObj);
}


#endif  // OLE_SERVER


#if defined( OLE_CNTR )


/*************************************************************************
** ContainerDoc Supprt Functions Used by Container versions
*************************************************************************/


/* ContainerLine_GetRelMoniker
** ---------------------------
**    Retrieve the relative item moniker which identifies the OLE object
**    relative to the container document.
**
**    Returns NULL if a moniker can NOT be created.
*/
LPMONIKER ContainerLine_GetRelMoniker(
		LPCONTAINERLINE         lpContainerLine,
		DWORD                   dwAssign
)
{
	LPMONIKER lpmk = NULL;

	/* OLE2NOTE: we should only give out a moniker for the OLE object
	**    if the object is allowed to be linked to from the inside. if
	**    so we are allowed to give out a moniker which binds to the
	**    running OLE object). if the object is an OLE 2.0 embedded
	**    object then it is allowed to be linked to from the inside. if
	**    the object is either an OleLink or an OLE 1.0 embedding
	**    then it can not be linked to from the inside.
	**    if we were a container/server app then we could offer linking
	**    to the outside of the object (ie. a pseudo object within our
	**    document). we are a container only app that does not support
	**    linking to ranges of its data.
	*/

	switch (dwAssign) {

		case GETMONIKER_FORCEASSIGN:

				/* Force the assignment of the name. This is called when a
				**    Paste Link actually occurs. From now on we want
				**    to inform the OLE object that its moniker is
				**    assigned and is thus necessary to register itself
				**    in the RunningObjectTable.
				*/
				CreateItemMonikerA(
					OLESTDDELIM, lpContainerLine->m_szStgName, &lpmk);

				/* OLE2NOTE: if the OLE object is already loaded and it
				**    is being assigned a moniker for the first time,
				**    then we need to inform it that it now has a moniker
				**    assigned by calling IOleObject::SetMoniker. this
				**    will force the OLE object to register in the
				**    RunningObjectTable when it enters the running
				**    state. if the object is not currently loaded,
				**    SetMoniker will be called automatically later when
				**    the object is loaded by the function
				**    ContainerLine_LoadOleObject.
				*/
				if (! lpContainerLine->m_fMonikerAssigned) {

					/* we must remember forever more that this object has a
					**    moniker assigned.
					*/
					lpContainerLine->m_fMonikerAssigned = TRUE;

					// we are now dirty and must be saved
					OutlineDoc_SetModified(
							(LPOUTLINEDOC)lpContainerLine->m_lpDoc,
							TRUE,   /* fModified */
							FALSE,  /* fDataChanged--N/A for container ver. */
							FALSE   /* fSizeChanged--N/A for container ver. */
					);

					if (lpContainerLine->m_lpOleObj) {
						OLEDBG_BEGIN2("IOleObject::SetMoniker called\r\n")
						lpContainerLine->m_lpOleObj->lpVtbl->SetMoniker(
								lpContainerLine->m_lpOleObj,
								OLEWHICHMK_OBJREL,
								lpmk
						);
						OLEDBG_END2
					}
				}
				break;

		case GETMONIKER_ONLYIFTHERE:

				/* If the OLE object currently has a moniker assigned,
				**    then return it.
				*/
				if (lpContainerLine->m_fMonikerAssigned) {

					CreateItemMonikerA(
							OLESTDDELIM,
							lpContainerLine->m_szStgName,
							&lpmk
					);

				}
				break;

		case GETMONIKER_TEMPFORUSER:

				/* Return the moniker that would be used for the OLE
				**    object but do NOT force moniker assignment at
				**    this point. Since our strategy is to use the
				**    storage name of the object as its item name, we
				**    can simply create the corresponding ItemMoniker
				**    (indepenedent of whether the moniker is currently
				**    assigned or not).
				*/
				CreateItemMonikerA(
						OLESTDDELIM,
						lpContainerLine->m_szStgName,
						&lpmk
				);

				break;

		case GETMONIKER_UNASSIGN:

				lpContainerLine->m_fMonikerAssigned = FALSE;
				break;

	}

	return lpmk;
}


/* ContainerLine_GetFullMoniker
** ----------------------------
**    Retrieve the full absolute moniker which identifies the OLE object
**    in the container document.
**    this moniker is created as a composite of the absolute moniker for
**    the entire document appended with an item moniker which identifies
**    the OLE object relative to the document.
**    Returns NULL if a moniker can NOT be created.
*/
LPMONIKER ContainerLine_GetFullMoniker(
		LPCONTAINERLINE         lpContainerLine,
		DWORD                   dwAssign
)
{
	LPMONIKER lpmkDoc = NULL;
	LPMONIKER lpmkItem = NULL;
	LPMONIKER lpmkFull = NULL;

	lpmkDoc = OleDoc_GetFullMoniker(
			(LPOLEDOC)lpContainerLine->m_lpDoc,
			dwAssign
	);
	if (! lpmkDoc) return NULL;

	lpmkItem = ContainerLine_GetRelMoniker(lpContainerLine, dwAssign);

	if (lpmkItem) {
		CreateGenericComposite(lpmkDoc, lpmkItem, (LPMONIKER FAR*)&lpmkFull);
		OleStdRelease((LPUNKNOWN)lpmkItem);
	}

	if (lpmkDoc)
		OleStdRelease((LPUNKNOWN)lpmkDoc);

	return lpmkFull;
}


/* ContainerDoc_InformAllOleObjectsDocRenamed
** ------------------------------------------
**    Inform all OLE objects that the name of the ContainerDoc has changed.
*/
void ContainerDoc_InformAllOleObjectsDocRenamed(
		LPCONTAINERDOC          lpContainerDoc,
		LPMONIKER               lpmkDoc
)
{
	LPLINELIST lpLL = &((LPOUTLINEDOC)lpContainerDoc)->m_LineList;
	int i;
	LPLINE lpLine;

	for (i = 0; i < lpLL->m_nNumLines; i++) {
		lpLine=LineList_GetLine(lpLL, i);

		if (lpLine && (Line_GetLineType(lpLine)==CONTAINERLINETYPE)) {
			LPCONTAINERLINE lpContainerLine = (LPCONTAINERLINE)lpLine;

			/* OLE2NOTE: if the OLE object is already loaded AND the
			**    object already has a moniker assigned, then we need
			**    to inform it that the moniker of the ContainerDoc has
			**    changed. of course, this means the full moniker of
			**    the object has changed. to do this we call
			**    IOleObject::SetMoniker. this will force the OLE
			**    object to re-register in the RunningObjectTable if it
			**    is currently in the running state. it is not in the
			**    running state, the object handler can make not that
			**    the object has a new moniker. if the object is not
			**    currently loaded, SetMoniker will be called
			**    automatically later when the object is loaded by the
			**    function ContainerLine_LoadOleObject.
			**    also if the object is a linked object, we always want
			**    to call SetMoniker on the link so that in case the
			**    link source is contained within our same container,
			**    the link source will be tracked. the link rebuilds
			**    its absolute moniker if it has a relative moniker.
			*/
			if (lpContainerLine->m_lpOleObj) {
				if (lpContainerLine->m_fMonikerAssigned ||
					lpContainerLine->m_dwLinkType != 0) {
					OLEDBG_BEGIN2("IOleObject::SetMoniker called\r\n")
					lpContainerLine->m_lpOleObj->lpVtbl->SetMoniker(
							lpContainerLine->m_lpOleObj,
							OLEWHICHMK_CONTAINER,
							lpmkDoc
					);
					OLEDBG_END2
				}

				/* OLE2NOTE: we must call IOleObject::SetHostNames so
				**    any open objects can update their window titles.
				*/
				OLEDBG_BEGIN2("IOleObject::SetHostNames called\r\n")

				CallIOleObjectSetHostNamesA(
						lpContainerLine->m_lpOleObj,
						APPNAME,
						((LPOUTLINEDOC)lpContainerDoc)->m_lpszDocTitle
				);

				OLEDBG_END2
			}
		}
	}
}


/* ContainerDoc_GetObject
** ----------------------
**    Return a pointer to the desired interface of an object identified
**    by an item string (lpszItem). the object returned will be an OLE
**    object (either link or embedding).
**
**      OLE2NOTE: we must force the object to run because we are
**          REQUIRED to return a pointer the OLE object in the
**          RUNNING state.
**
**    dwSpeedNeeded indicates how long the caller is willing
**    to wait for us to get the object:
**      BINDSPEED_IMMEDIATE -- only if obj already loaded && IsRunning
**      BINDSPEED_MODERATE  -- load obj if necessary && if IsRunning
**      BINDSPEED_INDEFINITE-- force obj to load and run if necessary
*/
HRESULT ContainerDoc_GetObjectA(
		LPCONTAINERDOC          lpContainerDoc,
		LPSTR                   lpszItem,
		DWORD                   dwSpeedNeeded,
		REFIID                  riid,
		LPVOID FAR*             lplpvObject
)
{
	LPLINELIST  lpLL = &((LPOUTLINEDOC)lpContainerDoc)->m_LineList;
	int         i;
	LPLINE      lpLine;
	BOOL        fMatchFound = FALSE;
	DWORD       dwStatus;
	HRESULT     hrErr;

	*lplpvObject = NULL;

	for (i = 0; i < lpLL->m_nNumLines; i++) {
		lpLine=LineList_GetLine(lpLL, i);

		if (lpLine && (Line_GetLineType(lpLine)==CONTAINERLINETYPE)) {
			LPCONTAINERLINE lpContainerLine = (LPCONTAINERLINE)lpLine;

			if (lstrcmp(lpContainerLine->m_szStgName, lpszItem) == 0) {

				fMatchFound = TRUE;     // valid item name

				// check if object is loaded.
				if (lpContainerLine->m_lpOleObj == NULL) {

					// if BINDSPEED_IMMEDIATE is requested, object must
					// ALREADY be loadded.
					if (dwSpeedNeeded == BINDSPEED_IMMEDIATE)
						return ResultFromScode(MK_E_EXCEEDEDDEADLINE);

					ContainerLine_LoadOleObject(lpContainerLine);
					if (! lpContainerLine->m_lpOleObj)
						return ResultFromScode(E_OUTOFMEMORY);
				}

				/* OLE2NOTE: check if the object is allowed to be linked
				**    to from the inside (ie. we are allowed to
				**    give out a moniker which binds to the running
				**    OLE object). if the object is an OLE
				**    2.0 embedded object then it is allowed to be
				**    linked to from the inside. if the object is
				**    either an OleLink or an OLE 1.0 embedding
				**    then it can not be linked to from the inside.
				**    if we were a container/server app then we
				**    could offer linking to the outside of the
				**    object (ie. a pseudo object within our
				**    document). we are a container only app that
				**    does not support linking to ranges of its data.
				*/
				OLEDBG_BEGIN2("IOleObject::GetMiscStatus called\r\n");
				lpContainerLine->m_lpOleObj->lpVtbl->GetMiscStatus(
						lpContainerLine->m_lpOleObj,
						DVASPECT_CONTENT, /* aspect is not important */
						(LPDWORD)&dwStatus
				);
				OLEDBG_END2
				if (dwStatus & OLEMISC_CANTLINKINSIDE)
					return ResultFromScode(MK_E_NOOBJECT);

				// check if object is running.
				if (! OleIsRunning(lpContainerLine->m_lpOleObj)) {

					// if BINDSPEED_MODERATE is requested, object must
					// ALREADY be running.
					if (dwSpeedNeeded == BINDSPEED_MODERATE)
						return ResultFromScode(MK_E_EXCEEDEDDEADLINE);

					/* OLE2NOTE: we have found a match for the item name.
					**    now we must return a pointer to the desired
					**    interface on the RUNNING object. we must
					**    carefully load the object and initially ask for
					**    an interface that we are sure the loaded form of
					**    the object supports. if we immediately ask the
					**    loaded object for the desired interface, the
					**    QueryInterface call might fail if it is an
					**    interface that is supported only when the object
					**    is running. thus we force the object to load and
					**    return its IUnknown*. then we force the object to
					**    run, and then finally, we can ask for the
					**    actually requested interface.
					*/
					hrErr = ContainerLine_RunOleObject(lpContainerLine);
					if (hrErr != NOERROR) {
						return hrErr;
					}
				}

				// Retrieve the requested interface
				*lplpvObject = OleStdQueryInterface(
						(LPUNKNOWN)lpContainerLine->m_lpOleObj, riid);

				break;  // Match FOUND!
			}
		}
	}

	if (*lplpvObject != NULL) {
		return NOERROR;
	} else
		return (fMatchFound ? ResultFromScode(E_NOINTERFACE)
							: ResultFromScode(MK_E_NOOBJECT));
}


HRESULT ContainerDoc_GetObject(
		LPCONTAINERDOC          lpContainerDoc,
		LPOLESTR		lpszItem,
		DWORD                   dwSpeedNeeded,
		REFIID                  riid,
		LPVOID FAR*             lplpvObject
)
{
    CREATESTR(lpsz, lpszItem)

    HRESULT hr = ContainerDoc_GetObjectA(lpContainerDoc, lpsz, dwSpeedNeeded,
	riid, lplpvObject);

    FREESTR(lpsz)

    return hr;
}

/* ContainerDoc_GetObjectStorage
** -----------------------------
**    Return a pointer to the IStorage* used by the object identified
**    by an item string (lpszItem). the object identified could be either
**    an OLE object (either link or embedding).
*/
HRESULT ContainerDoc_GetObjectStorageA(
		LPCONTAINERDOC          lpContainerDoc,
		LPSTR                   lpszItem,
		LPSTORAGE FAR*          lplpStg
)
{
	LPLINELIST lpLL = &((LPOUTLINEDOC)lpContainerDoc)->m_LineList;
	int i;
	LPLINE lpLine;

	*lplpStg = NULL;

	for (i = 0; i < lpLL->m_nNumLines; i++) {
		lpLine=LineList_GetLine(lpLL, i);

		if (lpLine && (Line_GetLineType(lpLine)==CONTAINERLINETYPE)) {
			LPCONTAINERLINE lpContainerLine = (LPCONTAINERLINE)lpLine;

			if (lstrcmp(lpContainerLine->m_szStgName, lpszItem) == 0) {

				*lplpStg = lpContainerLine->m_lpStg;
				break;  // Match FOUND!
			}
		}
	}

	if (*lplpStg != NULL) {
		return NOERROR;
	} else
		return ResultFromScode(MK_E_NOOBJECT);
}

HRESULT ContainerDoc_GetObjectStorage(
		LPCONTAINERDOC          lpContainerDoc,
		LPOLESTR		lpszItem,
		LPSTORAGE FAR*          lplpStg
)
{
    CREATESTR(lpsz, lpszItem)

    HRESULT hr = ContainerDoc_GetObjectStorageA(lpContainerDoc, lpsz, lplpStg);

    FREESTR(lpsz)

    return hr;
}

/* ContainerDoc_IsRunning
** ----------------------
**    Check if the object identified by an item string (lpszItem) is in
**    the running state.
**    For a container-only app, a check is made if the OLE object
**    associated with the item name is running.
*/
HRESULT ContainerDoc_IsRunningA(LPCONTAINERDOC lpContainerDoc, LPSTR lpszItem)
{
	LPLINELIST  lpLL = &((LPOUTLINEDOC)lpContainerDoc)->m_LineList;
	int         i;
	LPLINE      lpLine;
	DWORD       dwStatus;

	for (i = 0; i < lpLL->m_nNumLines; i++) {
		lpLine=LineList_GetLine(lpLL, i);

		if (lpLine && (Line_GetLineType(lpLine)==CONTAINERLINETYPE)) {
			LPCONTAINERLINE lpContainerLine = (LPCONTAINERLINE)lpLine;

			if (lstrcmp(lpContainerLine->m_szStgName, lpszItem) == 0) {

				/* OLE2NOTE: we have found a match for the item name.
				**    now we must check if the OLE object is running.
				**    we will load the object if not already loaded.
				*/
				if (! lpContainerLine->m_lpOleObj) {
					ContainerLine_LoadOleObject(lpContainerLine);
					if (! lpContainerLine->m_lpOleObj)
						return ResultFromScode(E_OUTOFMEMORY);
				}

				/* OLE2NOTE: check if the object is allowed to be linked
				**    to from the inside (ie. we are allowed to
				**    give out a moniker which binds to the running
				**    OLE object). if the object is an OLE
				**    2.0 embedded object then it is allowed to be
				**    linked to from the inside. if the object is
				**    either an OleLink or an OLE 1.0 embedding
				**    then it can not be linked to from the inside.
				**    if we were a container/server app then we
				**    could offer linking to the outside of the
				**    object (ie. a pseudo object within our
				**    document). we are a container only app that
				**    does not support linking to ranges of its data.
				*/
				OLEDBG_BEGIN2("IOleObject::GetMiscStatus called\r\n")
				lpContainerLine->m_lpOleObj->lpVtbl->GetMiscStatus(
						lpContainerLine->m_lpOleObj,
						DVASPECT_CONTENT, /* aspect is not important */
						(LPDWORD)&dwStatus
				);
				OLEDBG_END2
				if (dwStatus & OLEMISC_CANTLINKINSIDE)
					return ResultFromScode(MK_E_NOOBJECT);

				if (OleIsRunning(lpContainerLine->m_lpOleObj))
					return NOERROR;
				else
					return ResultFromScode(S_FALSE);
			}
		}
	}

	// no object was found corresponding to the item name
	return ResultFromScode(MK_E_NOOBJECT);
}

HRESULT ContainerDoc_IsRunning(LPCONTAINERDOC lpContainerDoc, LPOLESTR lpszItem)
{
    CREATESTR(lpsz, lpszItem)

    HRESULT hr = ContainerDoc_IsRunningA(lpContainerDoc, lpsz);

    FREESTR(lpsz)

    return hr;
}

#endif  // OLE_CNTR
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\letest\outline\message.h ===
/*************************************************************************
**
**    OLE 2.0 Server Sample Code
**
**    message.h
**
**    This file is a user customizable list of status messages associated
**    with menu items.
**
**    (c) Copyright Microsoft Corp. 1992 - 1993 All Rights Reserved
**
*************************************************************************/

// Status bar messages and associated data.

// Message type for status bar messages.
typedef struct {
	UINT wIDItem;
	char *string;
} STATMESG;

/*
 * CUSTOMIZATION NOTE:  Be sure to change NUM_POPUP if you
 *                      change the number of popup messages.
 */

// REVIEW: these messages should be loaded from a string resource

// List of all menu item messages.
STATMESG MesgList[] =
{
	{ IDM_F_NEW,        "Creates a new outline" },
	{ IDM_F_OPEN,       "Opens an existing outline file"    },
	{ IDM_F_SAVE,       "Saves the outline" },
	{ IDM_F_SAVEAS,     "Saves the outline with a new name" },
	{ IDM_F_PRINT,      "Prints the outline" },
	{ IDM_F_PRINTERSETUP, "Changes the printer and the printing options" },
	{ IDM_F_EXIT,       "Quits the application, prompting to save changes" },

	{ IDM_E_UNDO,       "Undo not yet implemented" },
	{ IDM_E_CUT,        "Cuts the selection and puts it on the Clipboard" },
	{ IDM_E_COPY,       "Copies the selection and puts it on the Clipboard" },
	{ IDM_E_PASTE,      "Inserts the Clipboard contents after current line" },
	{ IDM_E_PASTESPECIAL,"Allows pasting Clipboard data using a special format" },
	{ IDM_E_CLEAR,      "Clears the selection" },
	{ IDM_E_SELECTALL,  "Selects the entire outline" },
#if defined( OLE_CNTR )
	{ IDM_E_INSERTOBJECT, "Inserts new object after current line" },
	{ IDM_E_EDITLINKS, "Edit and view links contained in the document" },
   { IDM_E_CONVERTVERB, "Converts or activates an object as another type" },
	{ IDM_E_OBJECTVERBMIN, "Opens, edits or interacts with an object" },
	{ IDM_E_OBJECTVERBMIN+1, "Opens, edits or interacts with an object1" },
	{ IDM_E_OBJECTVERBMIN+2, "Opens, edits or interacts with an object2" },
	{ IDM_E_OBJECTVERBMIN+3, "Opens, edits or interacts with an object3" },
	{ IDM_E_OBJECTVERBMIN+4, "Opens, edits or interacts with an object4" },
	{ IDM_E_OBJECTVERBMIN+5, "Opens, edits or interacts with an object5" },
#endif

	{ IDM_L_ADDLINE,    "Adds a new line after current line" },
	{ IDM_L_EDITLINE,   "Edits the current line" },
	{ IDM_L_INDENTLINE, "Indents the selection" },
	{ IDM_L_UNINDENTLINE, "Unindents the selection" },
	{ IDM_L_SETLINEHEIGHT, "Modify the height of a line" },

	{ IDM_N_DEFINENAME, "Assigns a name to the selection" },
	{ IDM_N_GOTONAME,   "Jumps to a specified place in the outline" },

	{ IDM_H_ABOUT,      "Displays program info, version no., and copyright" },

	{ IDM_D_DEBUGLEVEL,     "Set debug level (0-4)" },
	{ IDM_D_INSTALLMSGFILTER,"Install/deinstall the IMessageFilter" },
	{ IDM_D_REJECTINCOMING, "Return RETRYLATER to incoming method calls" },

	{ IDM_O_BB_TOP, "Position ButtonBar at top of window" },
	{ IDM_O_BB_BOTTOM, "Position ButtonBar at botttom of window" },
	{ IDM_O_BB_POPUP, "Put ButtonBar in popup pallet" },
	{ IDM_O_BB_HIDE, "Hide ButtonBar" },

	{ IDM_O_FB_TOP, "Position FormulaBar at top of window" },
	{ IDM_O_FB_BOTTOM, "Position FormulaBar at botttom of window" },
	{ IDM_O_FB_POPUP, "Put FormulaBar in popup pallet" },

	{ IDM_O_HEAD_SHOW, "Show row/column headings" },
	{ IDM_O_HEAD_HIDE, "Hide row/column headings" },
	{ IDM_O_SHOWOBJECT, "Show border around objects/links" },

	{ IDM_V_ZOOM_400, "Set document zoom level" },
	{ IDM_V_ZOOM_300, "Set document zoom level" },
	{ IDM_V_ZOOM_200, "Set document zoom level" },
	{ IDM_V_ZOOM_100, "Set document zoom level" },
	{ IDM_V_ZOOM_75, "Set document zoom level" },
	{ IDM_V_ZOOM_50, "Set document zoom level" },
	{ IDM_V_ZOOM_25, "Set document zoom level" },

	{ IDM_V_SETMARGIN_0, "Remove left/right document margins" },
	{ IDM_V_SETMARGIN_1, "Set left/right document margins" },
	{ IDM_V_SETMARGIN_2, "Set left/right document margins" },
	{ IDM_V_SETMARGIN_3, "Set left/right document margins" },
	{ IDM_V_SETMARGIN_4, "Set left/right document margins" },

	{ IDM_V_ADDTOP_1, "Add top line" },
	{ IDM_V_ADDTOP_2, "Add top line" },
	{ IDM_V_ADDTOP_3, "Add top line" },
	{ IDM_V_ADDTOP_4, "Add top line" }
};

#define NUM_STATS   sizeof(MesgList)/sizeof(MesgList[0])
#define NUM_POPUP   10  // Maximum number of popup messages.
#define MAX_MESSAGE 100 // Maximum characters in a popup message.
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\letest\outline\memmgr.c ===
/*************************************************************************
**
**    OLE 2 Sample Code
**
**    memmgr.c
**
**    This file contains memory management functions.
**
**    (c) Copyright Microsoft Corp. 1992 - 1993 All Rights Reserved
**
*************************************************************************/


#include "outline.h"


/* New
 * ---
 *
 *      Allocate memory for a new structure
 */
LPVOID New(DWORD lSize)
{
	LPVOID lp = OleStdMalloc((ULONG)lSize);

	return lp;
}


/* Delete
 * ------
 *
 *      Free memory allocated for a structure
 */
void Delete(LPVOID lp)
{
	OleStdFree(lp);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\letest\outline\oleapp.c ===
/*************************************************************************
**
**    OLE 2 Sample Code
**
**    oleapp.c
**
**    This file contains functions and methods that are common to
**    server and the client version of the app. This includes the class
**    factory methods and all OleApp functions.
**
**    (c) Copyright Microsoft Corp. 1992 - 1993 All Rights Reserved
**
*************************************************************************/

#include "outline.h"
#include <ole2ver.h>

OLEDBGDATA

extern LPOUTLINEAPP             g_lpApp;

extern IUnknownVtbl             g_OleApp_UnknownVtbl;

extern IUnknownVtbl             g_OleDoc_UnknownVtbl;
extern IPersistFileVtbl         g_OleDoc_PersistFileVtbl;
extern IOleItemContainerVtbl    g_OleDoc_OleItemContainerVtbl;
extern IExternalConnectionVtbl  g_OleDoc_ExternalConnectionVtbl;
extern IDataObjectVtbl          g_OleDoc_DataObjectVtbl;

#if defined( USE_DRAGDROP )
extern IDropTargetVtbl          g_OleDoc_DropTargetVtbl;
extern IDropSourceVtbl          g_OleDoc_DropSourceVtbl;
#endif  // USE_DRAGDROP

#if defined( OLE_SERVER )
extern IOleObjectVtbl       g_SvrDoc_OleObjectVtbl;
extern IPersistStorageVtbl  g_SvrDoc_PersistStorageVtbl;

#if defined( SVR_TREATAS )
extern IStdMarshalInfoVtbl  g_SvrDoc_StdMarshalInfoVtbl;
#endif  // SVR_TREATAS

extern IUnknownVtbl         g_PseudoObj_UnknownVtbl;
extern IOleObjectVtbl       g_PseudoObj_OleObjectVtbl;
extern IDataObjectVtbl      g_PseudoObj_DataObjectVtbl;

#if defined( INPLACE_SVR )
extern IOleInPlaceObjectVtbl        g_SvrDoc_OleInPlaceObjectVtbl;
extern IOleInPlaceActiveObjectVtbl  g_SvrDoc_OleInPlaceActiveObjectVtbl;
#endif  // INPLACE_SVR

#endif  // OLE_SERVER

#if defined( OLE_CNTR )

extern IOleUILinkContainerVtbl  g_CntrDoc_OleUILinkContainerVtbl;
extern IUnknownVtbl             g_CntrLine_UnknownVtbl;
extern IOleClientSiteVtbl       g_CntrLine_OleClientSiteVtbl;
extern IAdviseSinkVtbl          g_CntrLine_AdviseSinkVtbl;

#if defined( INPLACE_CNTR )
extern IOleInPlaceSiteVtbl      g_CntrLine_OleInPlaceSiteVtbl;
extern IOleInPlaceFrameVtbl     g_CntrApp_OleInPlaceFrameVtbl;
extern BOOL g_fInsideOutContainer;
#endif  // INPLACE_CNTR

#endif  // OLE_CNTR

// REVIEW: these are NOT useful end-user messages
static char ErrMsgCreateCF[] = "Can't create Class Factory!";
static char ErrMsgRegCF[] = "Can't register Class Factory!";
static char ErrMsgRegMF[] = "Can't register Message Filter!";

extern UINT g_uMsgHelp;


/* OleApp_InitInstance
 * -------------------
 *
 * Initialize the app instance by creating the main frame window and
 * performing app instance specific initializations
 *  (eg. initializing interface Vtbls).
 *
 * RETURNS: TRUE if the memory could be allocated, and the server app
 *               was properly initialized.
 *          FALSE otherwise
 *
 */
BOOL OleApp_InitInstance(LPOLEAPP lpOleApp, HINSTANCE hInst, int nCmdShow)
{
	LPOUTLINEAPP lpOutlineApp = (LPOUTLINEAPP)lpOleApp;
	HRESULT hrErr;
	DWORD   dwBuildVersion = OleBuildVersion();
	LPMALLOC lpMalloc = NULL;

	OLEDBG_BEGIN3("OleApp_InitInstance\r\n")

	lpOleApp->m_fOleInitialized = FALSE;

	/* OLE2NOTE: check if the build version of the OLE2 DLL's match
	**    what our application is expecting.
	*/
	if (HIWORD(dwBuildVersion) != rmm || LOWORD(dwBuildVersion) < rup) {
		OleDbgAssertSz(0, "ERROR: OLE 2.0 DLL's are NOT compatible!");

#if !defined( _DEBUG )
		return FALSE;   // Wrong version of DLL's
#endif
	}

#if defined( _DEBUG )
	/* OLE2NOTE: Use a special debug allocator to help track down
	**    memory leaks.
	*/
	OleStdCreateDbAlloc(0, &lpMalloc);
#endif
	/* OLE2NOTE: the OLE libraries must be properly initialized before
	**    making any calls. OleInitialize automatically calls
	**    CoInitialize. we will use the default task memory allocator
	**    therefore we pass NULL to OleInitialize.
	*/
	OLEDBG_BEGIN2("OleInitialize called\r\n")
        hrErr = OleInitialize(lpMalloc);

        if (FAILED(hrErr))
        {
            //  Replacing the allocator may not be legal - try initializing
            //  without overriding the allocator
            hrErr = OleInitialize(NULL);
        }

	OLEDBG_END2

#if defined( _DEBUG )
	/* OLE2NOTE: release the special debug allocator so that only OLE is
	**    holding on to it. later when OleUninitialize is called, then
	**    the debug allocator object will be destroyed. when the debug
	**    allocator object is destoyed, it will report (to the Output
	**    Debug Terminal) whether there are any memory leaks.
	*/
	if (lpMalloc) lpMalloc->lpVtbl->Release(lpMalloc);
#endif

	if (hrErr != NOERROR) {
		OutlineApp_ErrorMessage(lpOutlineApp,"OLE initialization failed!");
		goto error;
	}

	/*****************************************************************
	** OLE2NOTE: we must remember the fact that OleInitialize has
	**    been call successfully. the very last thing an app must
	**    be do is properly shut down OLE by calling
	**    OleUninitialize. This call MUST be guarded! it is only
	**    allowable to call OleUninitialize if OleInitialize has
	**    been called SUCCESSFULLY.
	*****************************************************************/

	lpOleApp->m_fOleInitialized = TRUE;

	// Initialize the OLE 2.0 interface method tables.
	if (! OleApp_InitVtbls(lpOleApp))
		goto error;

	// Register OLE 2.0 clipboard formats.
	lpOleApp->m_cfEmbedSource = RegisterClipboardFormat(CF_EMBEDSOURCE);
	lpOleApp->m_cfEmbeddedObject = RegisterClipboardFormat(
			CF_EMBEDDEDOBJECT
	);
	lpOleApp->m_cfLinkSource = RegisterClipboardFormat(CF_LINKSOURCE);
	lpOleApp->m_cfFileName = RegisterClipboardFormat(CF_FILENAME);
	lpOleApp->m_cfObjectDescriptor =
			RegisterClipboardFormat(CF_OBJECTDESCRIPTOR);
	lpOleApp->m_cfLinkSrcDescriptor =
			RegisterClipboardFormat(CF_LINKSRCDESCRIPTOR);

	lpOleApp->m_cRef                    = 0;
	lpOleApp->m_cDoc                    = 0;
	lpOleApp->m_fUserCtrl               = FALSE;
	lpOleApp->m_dwRegClassFac           = 0;
	lpOleApp->m_lpClassFactory          = NULL;
	lpOleApp->m_cModalDlgActive         = 0;

	INIT_INTERFACEIMPL(
			&lpOleApp->m_Unknown,
			&g_OleApp_UnknownVtbl,
			lpOleApp
	);

#if defined( USE_DRAGDROP )

	// delay before dragging should start, in milliseconds
	lpOleApp->m_nDragDelay = GetProfileInt(
			"windows",
			"DragDelay",
			DD_DEFDRAGDELAY
	);

	// minimum distance (radius) before drag should start, in pixels
	lpOleApp->m_nDragMinDist = GetProfileInt(
			"windows",
			"DragMinDist",
			DD_DEFDRAGMINDIST
	);

	// delay before scrolling, in milliseconds
	lpOleApp->m_nScrollDelay = GetProfileInt(
			"windows",
			"DragScrollDelay",
			DD_DEFSCROLLDELAY
	);

	// inset-width of the hot zone, in pixels
	lpOleApp->m_nScrollInset = GetProfileInt(
			"windows",
			"DragScrollInset",
			DD_DEFSCROLLINSET
	);

	// scroll interval, in milliseconds
	lpOleApp->m_nScrollInterval = GetProfileInt(
			"windows",
			"DragScrollInterval",
			DD_DEFSCROLLINTERVAL
	);

#if defined( IF_SPECIAL_DD_CURSORS_NEEDED )
	// This would be used if the app wanted to have custom drag/drop cursors
	lpOleApp->m_hcursorDragNone  = LoadCursor ( hInst, "DragNoneCur" );
	lpOleApp->m_hcursorDragCopy  = LoadCursor ( hInst, "DragCopyCur" );
	lpOleApp->m_hcursorDragMove  = LoadCursor ( hInst, "DragMoveCur" );
	lpOleApp->m_hcursorDragLink  = LoadCursor ( hInst, "DragLinkCur" );
#endif  // IF_SPECIAL_DD_CURSORS_NEEDED

#endif  // USE_DRAGDROP

	lpOleApp->m_lpMsgFilter = NULL;

#if defined( USE_MSGFILTER )
	/* OLE2NOTE: Register our message filter upon app startup. the
	**    message filter is used to handle concurrency.
	**    we will use a standard implementation of IMessageFilter that
	**    is included as part of the OLE2UI library.
	*/
	lpOleApp->m_lpMsgFilter = NULL;
	if (! OleApp_RegisterMessageFilter(lpOleApp))
		goto error;

	/* OLE2NOTE: because our app is initially INVISIBLE, we must
	**    DISABLE the busy dialog. we should NOT put up any dialogs if
	**    our app is invisible. when our app window is made visible,
	**    then the busy dialog will be enabled.
	*/
	OleStdMsgFilter_EnableBusyDialog(lpOleApp->m_lpMsgFilter, FALSE);
#endif  // USE_MSGFILTER

#if defined( OLE_SERVER )
	/* OLE2NOTE: perform initialization specific for an OLE server */
	if (! ServerApp_InitInstance((LPSERVERAPP)lpOutlineApp, hInst, nCmdShow))
		goto error;
#endif
#if defined( OLE_CNTR )
	/* OLE2NOTE: perform initialization specific for an OLE container */

	// Register help message
	g_uMsgHelp = RegisterWindowMessage(SZOLEUI_MSG_HELP);

	if (! ContainerApp_InitInstance((LPCONTAINERAPP)lpOutlineApp, hInst, nCmdShow))
		goto error;
#endif

#if defined( OLE_CNTR )
	lpOleApp->m_hStdPal = OleStdCreateStandardPalette();
#endif

	OLEDBG_END3
	return TRUE;

error:
	OLEDBG_END3
	return FALSE;
}


/*
 * OleApp_TerminateApplication
 * ---------------------------
 *  Perform proper OLE application cleanup before shutting down
 */
void OleApp_TerminateApplication(LPOLEAPP lpOleApp)
{
	OLEDBG_BEGIN3("OleApp_TerminateApplication\r\n")

	/* OLE2NOTE: perform a clean shut down for OLE. at this point our
	**    App refcnt should be 0, or else we should never have reached
	**    this point!
	*/
	OleDbgAssertSz(lpOleApp->m_cRef == 0, "App NOT shut down properly");

	if(lpOleApp->m_fOleInitialized) {
		OLEDBG_BEGIN2("OleUninitialize called\r\n")
		OleUninitialize();
		OLEDBG_END2
	}
	OLEDBG_END3
}


/* OleApp_ParseCmdLine
 * -------------------
 *
 * Parse the command line for any execution flags/arguments.
 *      OLE2NOTE: check if "-Embedding" switch is given.
 */
BOOL OleApp_ParseCmdLine(LPOLEAPP lpOleApp, LPSTR lpszCmdLine, int nCmdShow)
{
	LPOUTLINEAPP lpOutlineApp = (LPOUTLINEAPP)lpOleApp;
	char szFileName[256];   /* buffer for filename in command line */
	BOOL fStatus = TRUE;
	BOOL fEmbedding = FALSE;

	OLEDBG_BEGIN3("OleApp_ParseCmdLine\r\n")

	szFileName[0] = '\0';
	ParseCmdLine(lpszCmdLine, &fEmbedding, (LPSTR)szFileName);

#if defined( MDI_VERSION )
	/* OLE2NOTE: an MDI app would ALWAYS register its ClassFactory. it
	**    can handle multiple objects at the same time, while an SDI
	**    application can only handle a single embedded or file-based
	**    object at a time.
	*/
	fStatus = OleApp_RegisterClassFactory(lpOleApp);
#endif

	if(fEmbedding) {

		if (szFileName[0] == '\0') {

			/*****************************************************************
			** App was launched with /Embedding.
			**    We must register our ClassFactory with OLE, remain hidden
			**    (the app window is initially created not visible), and
			**    wait for OLE to call IClassFactory::CreateInstance
			**    method. We do not automatically create a document as we
			**    do when the app is launched by the user from the
			**    FileManager. We must NOT make our app window visible
			**    until told to do so by our container.
			**
			** OLE2NOTE: Because we are an SDI app, we only register our
			**    ClassFactory if we are launched with the /Embedding
			**    flag WITHOUT a filename. an MDI app would ALWAYS
			**    register its ClassFactory. it can handle multiple
			**    objects at the same time, while an SDI application
			**    can only handle a single embedded or file-based
			**    object at a time.
			*****************************************************************/

#if defined( SDI_VERSION )
			fStatus = OleApp_RegisterClassFactory(lpOleApp);
#endif
		} else {

			/*****************************************************************
			** App was launched with /Embedding <Filename>.
			**    We must create a document and load the file and
			**    register it in the RunningObjectTable BEFORE we
			**    enter our GetMessage loop (ie. before we yield).
			**    One way to perform these tasks is to call the same
			**    interface methods that OLE 2.0 calls for linking to a
			**    file:
			**          IClassFactory::CreateInstance
			**          IPersistFile::Load
			**
			**    We must NOT make our app window visible until told to
			**    do so by our container. An application will be
			**    launched in this manner by an OLE 1.0 application
			**    link situation (eg. double clicking a linked object
			**    or OleCreateLinkFromFile called).
			**
			** OLE2NOTE: Because we are an SDI app, we should NOT
			**    register our ClassFactory when we are launched with the
			**    /Embedding <Filename> flag. our SDI instance can only
			**    handle a single embedded or file-based object.
			**    an MDI app WOULD register its ClassFactory at all
			**    times because it can handle multiple objects.
			*****************************************************************/

			// allocate a new document object
			lpOutlineApp->m_lpDoc = OutlineApp_CreateDoc(lpOutlineApp, FALSE);
			if (! lpOutlineApp->m_lpDoc) {
				OLEDBG_END3
				return FALSE;
			}

			/* OLE2NOTE: initially the Doc object is created with a 0 ref
			**    count. in order to have a stable Doc object during the
			**    process of initializing the new Doc instance,
			**    we intially AddRef the Doc ref cnt and later
			**    Release it. This initial AddRef is artificial; it is simply
			**    done to guarantee that a harmless QueryInterface followed by
			**    a Release does not inadvertantly force our object to destroy
			**    itself prematurely.
			*/
			OleDoc_AddRef((LPOLEDOC)lpOutlineApp->m_lpDoc);

			/* OLE2NOTE: OutlineDoc_LoadFromFile will register our document
			**    in the RunningObjectTable. this registration will
			**    AddRef our document. therefore our document will not
			**    be destroyed when we release the artificial AddRef
			*/
			fStatus = OutlineDoc_LoadFromFile(
					lpOutlineApp->m_lpDoc, (LPSTR)szFileName);

			OleDoc_Release((LPOLEDOC)lpOutlineApp->m_lpDoc); // rel AddRef

			OLEDBG_END3
			return fStatus;
		}
	} else {

		/*****************************************************************
		** App was launched by the user (without /Embedding) and
		**    therefore is marked to be under user control.
		**    In this case, because we are an SDI app, we do NOT
		**    register our ClassFactory with OLE. This app instance can
		**    only manage one document at a time (either a user
		**    document or an embedded object document). An MDI app
		**    would register its ClassFactory here.
		**
		**    We must create a document for the user (either
		**    initialized from a file given on the command line or
		**    initialized as an untitled document. We must also make
		**    our app window visible to the user.
		*****************************************************************/

		// allocate a new document object
		lpOutlineApp->m_lpDoc = OutlineApp_CreateDoc(lpOutlineApp, FALSE);
		if (! lpOutlineApp->m_lpDoc) goto error;

		/* OLE2NOTE: initially the Doc object is created with a 0 ref
		**    count. in order to have a stable Doc object during the
		**    process of initializing the new Doc instance,
		**    we intially AddRef the Doc ref cnt and later
		**    Release it. This initial AddRef is artificial; it is simply
		**    done to guarantee that a harmless QueryInterface followed by
		**    a Release does not inadvertantly force our object to destroy
		**    itself prematurely.
		*/
		OleDoc_AddRef((LPOLEDOC)lpOutlineApp->m_lpDoc);

		if(*szFileName) {
			// initialize the document from the specified file
			if (! OutlineDoc_LoadFromFile(lpOutlineApp->m_lpDoc, szFileName))
				goto error;
		} else {
			// set the doc to an (Untitled) doc.
			if (! OutlineDoc_InitNewFile(lpOutlineApp->m_lpDoc))
				goto error;
		}

		// position and size the new doc window
		OutlineApp_ResizeWindows(lpOutlineApp);
		OutlineDoc_ShowWindow(lpOutlineApp->m_lpDoc); // calls OleDoc_Lock
		OleDoc_Release((LPOLEDOC)lpOutlineApp->m_lpDoc);// rel AddRef above

		// show main app window
		ShowWindow(lpOutlineApp->m_hWndApp, nCmdShow);
		UpdateWindow(lpOutlineApp->m_hWndApp);

#if defined( OLE_CNTR )
		ContainerDoc_UpdateLinks((LPCONTAINERDOC)lpOutlineApp->m_lpDoc);
#endif

	}

	OLEDBG_END3
	return fStatus;

error:
	// REVIEW: should load string from string resource
	OutlineApp_ErrorMessage(
			lpOutlineApp,
			"Could not create document--Out of Memory"
	);
	if (lpOutlineApp->m_lpDoc)      // rel artificial AddRef above
		OleDoc_Release((LPOLEDOC)lpOutlineApp->m_lpDoc);

	OLEDBG_END3
	return FALSE;
}


/* OleApp_CloseAllDocsAndExitCommand
 * ---------------------------------
 *
 *  Close all active documents and exit the app.
 *  Because this is an SDI, there is only one document
 *  If the doc was modified, prompt the user if he wants to save it.
 *
 *  Returns:
 *      TRUE if the app is successfully closed
 *      FALSE if failed or aborted
 *
 * OLE2NOTE: in the OLE version, we can NOT directly
 *     destroy the App object. we can only take all
 *     necessary actions to ensure that our object receives
 *     all of its Releases from clients holding onto
 *     pointers (eg. closing all docs and flushing the
 *     clipboard) and then we must hide our window and wait
 *     actually for our refcnt to reach 0. when it reaches 0,
 *     our destructor (OutlineApp_Destroy) will be called.
 *     each document addref's the app object in order to
 *     guarentee that the app does not shut down while the doc
 *     is still open. closing all docs, will release these
 *     refcnt's. if there are now more open documents AND the
 *     app is not under the control of the user (ie. launched by
 *     OLE) then the app will now shut down. the OleApp_Release
 *     function executes this shut down procedure. after closing
 *     all docs, then releasing the user refcnt will force the
 *     app to shut down.
 */
BOOL OleApp_CloseAllDocsAndExitCommand(
		LPOLEAPP            lpOleApp,
		BOOL                fForceEndSession
)
{
	LPOUTLINEAPP lpOutlineApp = (LPOUTLINEAPP)lpOleApp;
	DWORD dwSaveOption = (fForceEndSession ?
									OLECLOSE_NOSAVE : OLECLOSE_PROMPTSAVE);

	/* OLE2NOTE: in order to have a stable App object during the
	**    process of closing, we intially AddRef the App ref cnt and
	**    later Release it. This initial AddRef is artificial; it is
	**    simply done to guarantee that our App object does not
	**    destroy itself until the end of this routine.
	*/
	OleApp_AddRef(lpOleApp);

	/* Because this is an SDI app, there is only one document.
	** Close the doc. if it is successfully closed and the app will
	** not automatically exit, then also exit the app.
	** if this were an MDI app, we would loop through and close all
	** open MDI child documents.
	*/

#if defined( OLE_SERVER )
	if (!fForceEndSession &&
			lpOutlineApp->m_lpDoc->m_docInitType == DOCTYPE_EMBEDDED)
		dwSaveOption = OLECLOSE_SAVEIFDIRTY;
#endif

	if (! OutlineDoc_Close(lpOutlineApp->m_lpDoc, dwSaveOption)) {
		OleApp_Release(lpOleApp);
		return FALSE;     // User Aborted shutdown
	}
#if defined( _DEBUG )
	OleDbgAssertSz(
			lpOutlineApp->m_lpDoc==NULL,
			"Closed doc NOT properly destroyed"
	);
#endif

#if defined( OLE_CNTR )
	/* if we currently have data on the clipboard then we must tell
	**    the clipboard to release our clipboard data object
	**    (document)
	*/
	if (lpOutlineApp->m_lpClipboardDoc)
		OleApp_FlushClipboard(lpOleApp);
#endif

	OleApp_HideWindow(lpOleApp);

	/* OLE2NOTE: this call forces all external connections to our
	**    object to close down and therefore guarantees that we receive
	**    all releases associated with those external connections.
	*/
	OLEDBG_BEGIN2("CoDisconnectObject(lpApp) called\r\n")
	CoDisconnectObject((LPUNKNOWN)&lpOleApp->m_Unknown, 0);
	OLEDBG_END2

	OleApp_Release(lpOleApp);       // release artificial AddRef above

	return TRUE;
}


/* OleApp_ShowWindow
 * -----------------
 *
 *      Show the window of the app to the user.
 *      make sure app window is visible and bring the app to the top.
 *      IF fGiveUserCtrl == TRUE
 *          THEN give the user the control over the life-time of the app.
 */
void OleApp_ShowWindow(LPOLEAPP lpOleApp, BOOL fGiveUserCtrl)
{
	LPOUTLINEAPP    lpOutlineApp = (LPOUTLINEAPP)lpOleApp;

	OLEDBG_BEGIN3("OleApp_ShowWindow\r\n")

	/* OLE2NOTE: while the application is visible and under user
	**    control, we do NOT want it to be prematurely destroyed when
	**    the user closes a document. thus we must inform OLE to hold
	**    an external lock on our application on behalf of the user.
	**    this arranges that OLE holds at least 1 reference to our
	**    application that will NOT be released until we release this
	**    external lock. later, when the application window is hidden, we
	**    will release this external lock.
	*/
	if (fGiveUserCtrl && ! lpOleApp->m_fUserCtrl) {
		lpOleApp->m_fUserCtrl = TRUE;
		OleApp_Lock(lpOleApp, TRUE /* fLock */, 0 /* not applicable */);
	}

	// we must show our App window and force it to have input focus
	ShowWindow(lpOutlineApp->m_hWndApp, SW_SHOWNORMAL);
	SetFocus(lpOutlineApp->m_hWndApp);

	/* OLE2NOTE: because our app is now visible, we can enable the busy
	**    dialog. we should NOT put up any dialogs if our app is
	**    invisible.
	*/
	OleApp_EnableBusyDialogs(lpOleApp, TRUE, TRUE);

	OLEDBG_END3
}


/* OleApp_HideWindow
 * -----------------
 *
 *      Hide the window of the app from the user.
 *      take away the control of the app by the user.
 */
void OleApp_HideWindow(LPOLEAPP lpOleApp)
{
	LPOUTLINEAPP lpOutlineApp = (LPOUTLINEAPP)lpOleApp;

	OLEDBG_BEGIN3("OleApp_HideWindow\r\n")

	/* OLE2NOTE: the application is now being hidden, so we must release
	**    the external lock that was made on behalf of the user.
	**    if this is that last external lock on our application, thus
	**    enabling our application to complete its shutdown operation.
	*/
	if (lpOleApp->m_fUserCtrl) {
		lpOleApp->m_fUserCtrl = FALSE;
		OleApp_Lock(lpOleApp, FALSE /*fLock*/, TRUE /*fLastUnlockReleases*/);
	}

	ShowWindow(lpOutlineApp->m_hWndApp, SW_HIDE);

	/* OLE2NOTE: because our app is now INVISIBLE, we must DISABLE the busy
	**    dialog. we should NOT put up any dialogs if our app is
	**    invisible.
	*/
	OleApp_EnableBusyDialogs(lpOleApp, FALSE, FALSE);
	OLEDBG_END3
}


/* OleApp_Lock
** -----------
**    Lock/Unlock the App object. if the last lock is unlocked and
**    fLastUnlockReleases == TRUE, then the app object will shut down
**    (ie. it will recieve its final release and its refcnt will go to 0).
*/
HRESULT OleApp_Lock(LPOLEAPP lpOleApp, BOOL fLock, BOOL fLastUnlockReleases)
{
	HRESULT hrErr;

#if defined( _DEBUG )
	if (fLock) {
		OLEDBG_BEGIN2("CoLockObjectExternal(lpApp,TRUE) called\r\n")
	} else {
		if (fLastUnlockReleases)
			OLEDBG_BEGIN2("CoLockObjectExternal(lpApp,FALSE,TRUE) called\r\n")
		else
			OLEDBG_BEGIN2("CoLockObjectExternal(lpApp,FALSE,FALSE) called\r\n")
	}
#endif  // _DEBUG

	OleApp_AddRef(lpOleApp);       // artificial AddRef to make object stable

	hrErr = CoLockObjectExternal(
			(LPUNKNOWN)&lpOleApp->m_Unknown, fLock, fLastUnlockReleases);

	OleApp_Release(lpOleApp);       // release artificial AddRef above

	OLEDBG_END2
	return hrErr;
}


/* OleApp_Destroy
 * --------------
 *
 *  Free all OLE related resources that had been allocated for the app.
 */
void OleApp_Destroy(LPOLEAPP lpOleApp)
{
	// OLE2NOTE: Revoke our message filter upon app shutdown.
	OleApp_RevokeMessageFilter(lpOleApp);

	// OLE2NOTE: Revoke our ClassFactory upon app shutdown.
	OleApp_RevokeClassFactory(lpOleApp);

#if defined( IF_SPECIAL_DD_CURSORS_NEEDED )
	// This would be used if the app wanted to have custom drag/drop cursors
	DestroyCursor(lpOleApp->m_hcursorDragNone);
	DestroyCursor(lpOleApp->m_hcursorDragCopy);
	DestroyCursor(lpOleApp->m_hcursorDragLink);
	DestroyCursor(lpOleApp->m_hcursorDragMove);
#endif  // IF_SPECIAL_DD_CURSORS_NEEDED

#if defined( OLE_CNTR )
	if (lpOleApp->m_hStdPal) {
		DeleteObject(lpOleApp->m_hStdPal);
		lpOleApp->m_hStdPal = NULL;
	}
#endif
}


/* OleApp_DocLockApp
** -----------------
**    Add a lock on the App on behalf of the Doc. the App may not close
**    while the Doc exists.
**
**    when a document is first created, it calls this method to
**    guarantee that the application stays alive (OleDoc_Init).
**    when a document is destroyed, it calls
**    OleApp_DocUnlockApp to release this hold on the app.
*/
void OleApp_DocLockApp(LPOLEAPP lpOleApp)
{
	ULONG cDoc;

	OLEDBG_BEGIN3("OleApp_DocLockApp\r\n")

	cDoc = ++lpOleApp->m_cDoc;

	OleDbgOutRefCnt3("OleApp_DocLockApp: cDoc++\r\n", lpOleApp, cDoc);

	OleApp_Lock(lpOleApp, TRUE /* fLock */, 0 /* not applicable */);

	OLEDBG_END3
	return;
}


/* OleApp_DocUnlockApp
** -------------------
**    Forget all references to a closed document.
**    Release the lock on the App on behalf of the Doc. if this was the
**    last lock on the app, then it will shutdown.
*/
void OleApp_DocUnlockApp(LPOLEAPP lpOleApp, LPOUTLINEDOC lpOutlineDoc)
{
	ULONG cDoc;

	OLEDBG_BEGIN3("OleApp_DocUnlockApp\r\n")

	/* OLE2NOTE: when there are no open documents and the app is not
	**    under the control of the user then revoke our ClassFactory to
	**    enable the app to shut down.
	*/
	cDoc = --lpOleApp->m_cDoc;

#if defined( _DEBUG )
	OleDbgAssertSz (
			lpOleApp->m_cDoc >= 0, "DocUnlockApp called with cDoc == 0");

	OleDbgOutRefCnt3(
			"OleApp_DocUnlockApp: cDoc--\r\n", lpOleApp, cDoc);
#endif

	OleApp_Lock(lpOleApp, FALSE /* fLock */, TRUE /* fLastUnlockReleases */);

	OLEDBG_END3
	return;
}


/* OleApp_HideIfNoReasonToStayVisible
** ----------------------------------
**
** if there are no more documents visible to the user and the app
**    itself is not under user control, then it has no reason to stay
**    visible. we thus should hide the app. we can not directly destroy
**    the app, because it may be validly being used programatically by
**    another client application and should remain running. the app
**    should simply be hidden from the user.
*/
void OleApp_HideIfNoReasonToStayVisible(LPOLEAPP lpOleApp)
{
	LPOUTLINEAPP lpOutlineApp = (LPOUTLINEAPP)lpOleApp;
	LPOUTLINEDOC lpOutlineDoc;

	OLEDBG_BEGIN3("OleApp_HideIfNoReasonToStayVisible\r\n")

	if (lpOleApp->m_fUserCtrl) {
		OLEDBG_END3
		return;     // remain visible; user in control of app
	}

	/* Because this is an SDI app, there is only one user document.
	** check if it is visible to the user. an MDI app would loop over
	** all open MDI child documents to see if any are visible.
	*/
	lpOutlineDoc = (LPOUTLINEDOC)lpOutlineApp->m_lpDoc;
	if (lpOutlineDoc && IsWindowVisible(lpOutlineDoc->m_hWndDoc))
		return;     // remain visible; the doc is visible to the user

	// if we reached here, the app should be hidden
	OleApp_HideWindow(lpOleApp);

	OLEDBG_END3
}


/* OleApp_AddRef
** -------------
**
**  increment the ref count of the App object.
**
**    Returns the new ref count on the object
*/
ULONG OleApp_AddRef(LPOLEAPP lpOleApp)
{
	++lpOleApp->m_cRef;

#if defined( _DEBUG )
	OleDbgOutRefCnt4(
			"OleApp_AddRef: cRef++\r\n",
			lpOleApp,
			lpOleApp->m_cRef
	);
#endif
	return lpOleApp->m_cRef;
}


/* OleApp_Release
** --------------
**
**  decrement the ref count of the App object.
**    if the ref count goes to 0, then the app object is destroyed.
**
**    Returns the remaining ref count on the object
*/
ULONG OleApp_Release (LPOLEAPP lpOleApp)
{
	ULONG cRef;

	cRef = --lpOleApp->m_cRef;

#if defined( _DEBUG )
	OleDbgAssertSz (lpOleApp->m_cRef >= 0, "Release called with cRef == 0");

	OleDbgOutRefCnt4(
			"OleApp_AddRef: cRef--\r\n", lpOleApp, cRef);
#endif  // _DEBUG
	/*********************************************************************
	** OLE2NOTE: when the ClassFactory refcnt == 0, then destroy it.    **
	**    otherwise the ClassFactory is still in use.                   **
	*********************************************************************/

	if(cRef == 0)
		OutlineApp_Destroy((LPOUTLINEAPP)lpOleApp);

	return cRef;
}



/* OleApp_QueryInterface
** ---------------------
**
** Retrieve a pointer to an interface on the app object.
**
**    OLE2NOTE: this function will AddRef the ref cnt of the object.
**
**    Returns NOERROR if interface is successfully retrieved.
**            E_NOINTERFACE if the interface is not supported
*/
HRESULT OleApp_QueryInterface (
		LPOLEAPP                lpOleApp,
		REFIID                  riid,
		LPVOID FAR*             lplpvObj
)
{
	SCODE sc;

	/* OLE2NOTE: we must make sure to set all out ptr parameters to NULL. */
	*lplpvObj = NULL;

	if (IsEqualIID(riid, &IID_IUnknown)) {
		OleDbgOut4("OleApp_QueryInterface: IUnknown* RETURNED\r\n");

		*lplpvObj = (LPVOID) &lpOleApp->m_Unknown;
		OleApp_AddRef(lpOleApp);
		sc = S_OK;
	}
	else {
		sc = E_NOINTERFACE;
	}

	OleDbgQueryInterfaceMethod(*lplpvObj);
	return ResultFromScode(sc);
}


/* OleApp_RejectInComingCalls
** -------------------------
**    Reject/Handle in coming OLE (LRPC) calls.
**
**    OLE2NOTE: if the app is in a state when it can NOT handle in
**    coming OLE method calls from an external process (eg. the app has
**    an application modal dialog up), then it should call
**    OleApp_RejectInComingCalls(TRUE). in this state the
**    IMessageFilter::HandleInComingCall method will return
**    SERVERCALL_RETRYLATER. this tells the caller to try again in a
**    little while. normally the calling app will put up a dialog (see
**    OleUIBusy dialog) in this situation informing the user of the
**    situation. the user then is normally given the option to
**    "Switch To..." the busy application, retry, or cancel the
**    operation. when the app is ready to continue processing such
**    calls, it should call OleApp_RejectInComingCalls(FALSE). in this
**    state, SERVERCALL_ISHANDLED is returned by
**    IMessageFilter::HandleInComingCall.
*/
void OleApp_RejectInComingCalls(LPOLEAPP lpOleApp, BOOL fReject)
{
#if defined( _DEBUG )
	if (fReject)
		OleDbgOut3("OleApp_RejectInComingCalls(TRUE)\r\n");
	else
		OleDbgOut3("OleApp_RejectInComingCalls(FALSE)\r\n");
#endif  // _DEBUG

	OleDbgAssert(lpOleApp->m_lpMsgFilter != NULL);
	if (! lpOleApp->m_lpMsgFilter)
		return;

	OleStdMsgFilter_SetInComingCallStatus(
			lpOleApp->m_lpMsgFilter,
			(fReject ? SERVERCALL_RETRYLATER : SERVERCALL_ISHANDLED)
	);
}


/* OleApp_DisableBusyDialogs
** -------------------------
**    Disable the Busy and NotResponding dialogs.
**
**    Returns previous enable state so that it can be restored by
**    calling OleApp_ReEnableBusyDialogs.
*/
void OleApp_DisableBusyDialogs(
		LPOLEAPP        lpOleApp,
		BOOL FAR*       lpfPrevBusyEnable,
		BOOL FAR*       lpfPrevNREnable
)
{
	if (lpOleApp->m_lpMsgFilter) {
		*lpfPrevNREnable = OleStdMsgFilter_EnableNotRespondingDialog(
				lpOleApp->m_lpMsgFilter, FALSE);
		*lpfPrevBusyEnable = OleStdMsgFilter_EnableBusyDialog(
				lpOleApp->m_lpMsgFilter, FALSE);
	}
}


/* OleApp_EnableBusyDialogs
** ------------------------
**    Set the enable state of the Busy and NotResponding dialogs.
**
**    This function is typically used after a call to
**    OleApp_DisableBusyDialogs in order to restore the previous enable
**    state of the dialogs.
*/
void OleApp_EnableBusyDialogs(
		LPOLEAPP        lpOleApp,
		BOOL            fPrevBusyEnable,
		BOOL            fPrevNREnable
)
{
	if (lpOleApp->m_lpMsgFilter) {
		OleStdMsgFilter_EnableNotRespondingDialog(
				lpOleApp->m_lpMsgFilter, fPrevNREnable);
		OleStdMsgFilter_EnableBusyDialog(
				lpOleApp->m_lpMsgFilter, fPrevBusyEnable);
	}
}


/* OleApp_PreModalDialog
** ---------------------
**    Keep track that a modal dialog is about to be brought up.
**
**    while a modal dialog is up we need to take special actions:
**    1. we do NOT want to initialize our tool bar buttons on
**    WM_ACTIVATEAPP. the tool bar is not accessible.
**    2. we want to reject new top-level, incoming LRPC calls
**       (return SERVERCALL_RETRYLATER from IMessageFilter::
**        HandleInComingCall).
**    3. (IN-PLACE SERVER) tell our in-place container to disable
**    modeless dialogs by calling IOleInPlaceFrame::
**    EnableModeless(FALSE).
**    4. (IN-PLACE CONTAINER) tell our UIActive in-place object to
**    disable modeless dialogs by calling IOleInPlaceActiveObject::
**    EnableModeless(FALSE).
*/
void OleApp_PreModalDialog(LPOLEAPP lpOleApp, LPOLEDOC lpOleDoc)
{
	if (lpOleApp->m_cModalDlgActive == 0) {
		// top-level modal dialog is being brought up

#if defined( USE_FRAMETOOLS )
		LPFRAMETOOLS lptb;

		if (lpOleDoc)
			lptb = ((LPOUTLINEDOC)lpOleDoc)->m_lpFrameTools;
		else
			lptb = OutlineApp_GetFrameTools((LPOUTLINEAPP)lpOleApp);
		if (lptb)
			FrameTools_EnableWindow(lptb, FALSE);
#endif  // USE_FRAMETOOLS

		OleApp_RejectInComingCalls(lpOleApp, TRUE);

#if defined( INPLACE_SVR )
		{
			LPSERVERDOC  lpServerDoc = (LPSERVERDOC)lpOleDoc;

			/* if the document bringing up the modal dialog is
			**    currently a UIActive in-place object, then tell the
			**    top-level in-place frame to disable its modeless
			**    dialogs.
			*/
			if (lpServerDoc && lpServerDoc->m_fUIActive &&
					lpServerDoc->m_lpIPData &&
					lpServerDoc->m_lpIPData->lpFrame) {
				OLEDBG_BEGIN2("IOleInPlaceFrame::EnableModless(FALSE) called\r\n");
				lpServerDoc->m_lpIPData->lpFrame->lpVtbl->EnableModeless(
						lpServerDoc->m_lpIPData->lpFrame, FALSE);
				OLEDBG_END2
			}
		}
#endif  // INPLACE_SVR
#if defined( INPLACE_CNTR )
		{
			LPCONTAINERAPP lpContainerApp = (LPCONTAINERAPP)lpOleApp;

			/* if the document bringing up the modal dialog is an
			**    in-place container that has a UIActive object, then
			**    tell the UIActive object to disable its modeless
			**    dialogs.
			*/
			if (lpContainerApp->m_lpIPActiveObj) {
				OLEDBG_BEGIN2("IOleInPlaceActiveObject::EnableModless(FALSE) called\r\n");
				lpContainerApp->m_lpIPActiveObj->lpVtbl->EnableModeless(
						lpContainerApp->m_lpIPActiveObj, FALSE);
				OLEDBG_END2
			}
		}
#endif  // INPLACE_CNTR
	}

	lpOleApp->m_cModalDlgActive++;
}


/* OleApp_PostModalDialog
** ----------------------
**    Keep track that a modal dialog is being brought down. this call
**    balances the OleApp_PreModalDialog call.
*/
void OleApp_PostModalDialog(LPOLEAPP lpOleApp, LPOLEDOC lpOleDoc)
{
	lpOleApp->m_cModalDlgActive--;

	if (lpOleApp->m_cModalDlgActive == 0) {
		// last modal dialog is being brought down

#if defined( USE_FRAMETOOLS )
		LPFRAMETOOLS lptb;

		if (lpOleDoc)
			lptb = ((LPOUTLINEDOC)lpOleDoc)->m_lpFrameTools;
		else
			lptb = OutlineApp_GetFrameTools((LPOUTLINEAPP)lpOleApp);
		if (lptb) {
			FrameTools_EnableWindow(lptb, TRUE);
			FrameTools_UpdateButtons(lptb, (LPOUTLINEDOC)lpOleDoc);
		}
#endif  // USE_FRAMETOOLS

		OleApp_RejectInComingCalls(lpOleApp, FALSE);

#if defined( INPLACE_SVR )
		{
			LPSERVERDOC  lpServerDoc = (LPSERVERDOC)lpOleDoc;

			/* if the document bringing down the modal dialog is
			**    currently a UIActive in-place object, then tell the
			**    top-level in-place frame it can re-enable its
			**    modeless dialogs.
			*/
			if (lpServerDoc && lpServerDoc->m_fUIActive &&
					lpServerDoc->m_lpIPData &&
					lpServerDoc->m_lpIPData->lpFrame) {
				OLEDBG_BEGIN2("IOleInPlaceFrame::EnableModless(TRUE) called\r\n");
				lpServerDoc->m_lpIPData->lpFrame->lpVtbl->EnableModeless(
						lpServerDoc->m_lpIPData->lpFrame, TRUE);
				OLEDBG_END2
			}
		}
#endif  // INPLACE_SVR
#if defined( INPLACE_CNTR )
		{
			LPCONTAINERAPP lpContainerApp = (LPCONTAINERAPP)lpOleApp;

			/* if the document bringing down the modal dialog is an
			**    in-place container that has a UIActive object, then
			**    tell the UIActive object it can re-enable its
			**    modeless dialogs.
			*/
			if (lpContainerApp->m_lpIPActiveObj) {
				OLEDBG_BEGIN2("IOleInPlaceActiveObject::EnableModless(TRUE) called\r\n");
				lpContainerApp->m_lpIPActiveObj->lpVtbl->EnableModeless(
						lpContainerApp->m_lpIPActiveObj, TRUE);
				OLEDBG_END2
			}
		}
#endif  // INPLACE_CNTR
	}
}


/* OleApp_InitVtbls
 * ----------------
 *
 * initialize the methods in all of the interface Vtbl's
 *
 * OLE2NOTE: we only need one copy of each Vtbl. When an object which
 *      exposes an interface is instantiated, its lpVtbl is intialized
 *      to point to the single copy of the Vtbl.
 *
 */
BOOL OleApp_InitVtbls (LPOLEAPP lpOleApp)
{
	BOOL fStatus;

	// OleApp::IUnknown method table
	OleStdInitVtbl(&g_OleApp_UnknownVtbl, sizeof(IUnknownVtbl));
	g_OleApp_UnknownVtbl.QueryInterface = OleApp_Unk_QueryInterface;
	g_OleApp_UnknownVtbl.AddRef         = OleApp_Unk_AddRef;
	g_OleApp_UnknownVtbl.Release        = OleApp_Unk_Release;
	fStatus = OleStdCheckVtbl(
			&g_OleApp_UnknownVtbl,
			sizeof(IUnknownVtbl),
			"IUnknown"
		);
	if (! fStatus) return FALSE;

	// OleDoc::IUnknown method table
	OleStdInitVtbl(&g_OleDoc_UnknownVtbl, sizeof(IUnknownVtbl));
	g_OleDoc_UnknownVtbl.QueryInterface = OleDoc_Unk_QueryInterface;
	g_OleDoc_UnknownVtbl.AddRef         = OleDoc_Unk_AddRef;
	g_OleDoc_UnknownVtbl.Release        = OleDoc_Unk_Release;
	fStatus = OleStdCheckVtbl(
			&g_OleDoc_UnknownVtbl,
			sizeof(IUnknownVtbl),
			"IUnknown"
		);
	if (! fStatus) return FALSE;

	// OleDoc::IPersistFile method table
	OleStdInitVtbl(&g_OleDoc_PersistFileVtbl, sizeof(IPersistFileVtbl));
	g_OleDoc_PersistFileVtbl.QueryInterface = OleDoc_PFile_QueryInterface;
	g_OleDoc_PersistFileVtbl.AddRef         = OleDoc_PFile_AddRef;
	g_OleDoc_PersistFileVtbl.Release        = OleDoc_PFile_Release;
	g_OleDoc_PersistFileVtbl.GetClassID     = OleDoc_PFile_GetClassID;
	g_OleDoc_PersistFileVtbl.IsDirty        = OleDoc_PFile_IsDirty;
	g_OleDoc_PersistFileVtbl.Load           = OleDoc_PFile_Load;
	g_OleDoc_PersistFileVtbl.Save           = OleDoc_PFile_Save;
	g_OleDoc_PersistFileVtbl.SaveCompleted  = OleDoc_PFile_SaveCompleted;
	g_OleDoc_PersistFileVtbl.GetCurFile     = OleDoc_PFile_GetCurFile;
	fStatus = OleStdCheckVtbl(
			&g_OleDoc_PersistFileVtbl,
			sizeof(IPersistFileVtbl),
			"IPersistFile"
		);
	if (! fStatus) return FALSE;

	// OleDoc::IOleItemContainer method table
	OleStdInitVtbl(&g_OleDoc_OleItemContainerVtbl, sizeof(IOleItemContainerVtbl));
	g_OleDoc_OleItemContainerVtbl.QueryInterface =
											OleDoc_ItemCont_QueryInterface;
	g_OleDoc_OleItemContainerVtbl.AddRef    = OleDoc_ItemCont_AddRef;
	g_OleDoc_OleItemContainerVtbl.Release   = OleDoc_ItemCont_Release;
	g_OleDoc_OleItemContainerVtbl.ParseDisplayName  =
		OleDoc_ItemCont_ParseDisplayName;
	g_OleDoc_OleItemContainerVtbl.EnumObjects= OleDoc_ItemCont_EnumObjects;
	g_OleDoc_OleItemContainerVtbl.LockContainer =
											OleDoc_ItemCont_LockContainer;
	g_OleDoc_OleItemContainerVtbl.GetObject = OleDoc_ItemCont_GetObject;
	g_OleDoc_OleItemContainerVtbl.GetObjectStorage =
		OleDoc_ItemCont_GetObjectStorage;
	g_OleDoc_OleItemContainerVtbl.IsRunning = OleDoc_ItemCont_IsRunning;
	fStatus = OleStdCheckVtbl(
			&g_OleDoc_OleItemContainerVtbl,
			sizeof(IOleItemContainerVtbl),
			"IOleItemContainer"
		);
	if (! fStatus) return FALSE;

	// OleDoc::IExternalConnection method table
	OleStdInitVtbl(
			&g_OleDoc_ExternalConnectionVtbl,sizeof(IExternalConnectionVtbl));
	g_OleDoc_ExternalConnectionVtbl.QueryInterface =
											OleDoc_ExtConn_QueryInterface;
	g_OleDoc_ExternalConnectionVtbl.AddRef         = OleDoc_ExtConn_AddRef;
	g_OleDoc_ExternalConnectionVtbl.Release        = OleDoc_ExtConn_Release;
	g_OleDoc_ExternalConnectionVtbl.AddConnection  =
											OleDoc_ExtConn_AddConnection;
	g_OleDoc_ExternalConnectionVtbl.ReleaseConnection =
											OleDoc_ExtConn_ReleaseConnection;
	fStatus = OleStdCheckVtbl(
			&g_OleDoc_ExternalConnectionVtbl,
			sizeof(IExternalConnectionVtbl),
			"IExternalConnection"
		);
	if (! fStatus) return FALSE;

	// OleDoc::IDataObject method table
	OleStdInitVtbl(&g_OleDoc_DataObjectVtbl, sizeof(IDataObjectVtbl));
	g_OleDoc_DataObjectVtbl.QueryInterface  = OleDoc_DataObj_QueryInterface;
	g_OleDoc_DataObjectVtbl.AddRef          = OleDoc_DataObj_AddRef;
	g_OleDoc_DataObjectVtbl.Release         = OleDoc_DataObj_Release;
	g_OleDoc_DataObjectVtbl.GetData         = OleDoc_DataObj_GetData;
	g_OleDoc_DataObjectVtbl.GetDataHere     = OleDoc_DataObj_GetDataHere;
	g_OleDoc_DataObjectVtbl.QueryGetData    = OleDoc_DataObj_QueryGetData;
	g_OleDoc_DataObjectVtbl.GetCanonicalFormatEtc =
										OleDoc_DataObj_GetCanonicalFormatEtc;
	g_OleDoc_DataObjectVtbl.SetData         = OleDoc_DataObj_SetData;
	g_OleDoc_DataObjectVtbl.EnumFormatEtc   = OleDoc_DataObj_EnumFormatEtc;
	g_OleDoc_DataObjectVtbl.DAdvise          = OleDoc_DataObj_DAdvise;
	g_OleDoc_DataObjectVtbl.DUnadvise        = OleDoc_DataObj_DUnadvise;
	g_OleDoc_DataObjectVtbl.EnumDAdvise      = OleDoc_DataObj_EnumDAdvise;

	fStatus = OleStdCheckVtbl(
			&g_OleDoc_DataObjectVtbl,
			sizeof(IDataObjectVtbl),
			"IDataObject"
		);
	if (! fStatus) return FALSE;

#if defined( USE_DRAGDROP )

	// OleDoc::IDropTarget method table
	OleStdInitVtbl(&g_OleDoc_DropTargetVtbl, sizeof(IDropTargetVtbl));
	g_OleDoc_DropTargetVtbl.QueryInterface= OleDoc_DropTarget_QueryInterface;
	g_OleDoc_DropTargetVtbl.AddRef      = OleDoc_DropTarget_AddRef;
	g_OleDoc_DropTargetVtbl.Release     = OleDoc_DropTarget_Release;

	g_OleDoc_DropTargetVtbl.DragEnter   = OleDoc_DropTarget_DragEnter;
	g_OleDoc_DropTargetVtbl.DragOver    = OleDoc_DropTarget_DragOver;
	g_OleDoc_DropTargetVtbl.DragLeave   = OleDoc_DropTarget_DragLeave;
	g_OleDoc_DropTargetVtbl.Drop        = OleDoc_DropTarget_Drop;

	fStatus = OleStdCheckVtbl(
			&g_OleDoc_DropTargetVtbl,
			sizeof(IDropTargetVtbl),
			"IDropTarget"
	);
	if (! fStatus)
		return FALSE;

	// OleDoc::IDropSource method table
	OleStdInitVtbl(&g_OleDoc_DropSourceVtbl, sizeof(IDropSourceVtbl));
	g_OleDoc_DropSourceVtbl.QueryInterface  =
										OleDoc_DropSource_QueryInterface;
	g_OleDoc_DropSourceVtbl.AddRef          = OleDoc_DropSource_AddRef;
	g_OleDoc_DropSourceVtbl.Release         = OleDoc_DropSource_Release;

	g_OleDoc_DropSourceVtbl.QueryContinueDrag =
										OleDoc_DropSource_QueryContinueDrag;
	g_OleDoc_DropSourceVtbl.GiveFeedback    = OleDoc_DropSource_GiveFeedback;

	fStatus = OleStdCheckVtbl(
			&g_OleDoc_DropSourceVtbl,
			sizeof(IDropSourceVtbl),
			"IDropSource"
	);
	if (! fStatus) return FALSE;
#endif  // USE_DRAGDROP

#if defined( OLE_SERVER )

	// Initialize the server specific interface method tables.
	if (! ServerApp_InitVtbls((LPSERVERAPP)lpOleApp))
		return FALSE;
#endif
#if defined( OLE_CNTR )

	// Initialize the container specific interface method tables.
	if (! ContainerApp_InitVtbls((LPCONTAINERAPP)lpOleApp))
		return FALSE;
#endif
	return TRUE;
};



/* OleApp_InitMenu
 * ---------------
 *
 *      Enable or Disable menu items depending on the state of
 * the appliation.
 * The OLE versions of the Outline sample app add a PasteSpecial command.
 * Also, the container version add InsertObject and ObjectVerb menu items.
 */
void OleApp_InitMenu(
		LPOLEAPP                lpOleApp,
		LPOLEDOC                lpOleDoc,
		HMENU                   hMenu
)
{
	BOOL bMsgFilterInstalled = FALSE;
	BOOL bRejecting = FALSE;

	if (!lpOleApp || !hMenu)
		return;

	OLEDBG_BEGIN3("OleApp_InitMenu\r\n")

	/*
	** Enable/disable menu items for Message Filter
	*/
	bMsgFilterInstalled = (lpOleApp->m_lpMsgFilter != NULL);
	bRejecting = bMsgFilterInstalled &&
		OleStdMsgFilter_GetInComingCallStatus(lpOleApp->m_lpMsgFilter) != SERVERCALL_ISHANDLED;

	CheckMenuItem(hMenu,
		IDM_D_INSTALLMSGFILTER,
		bMsgFilterInstalled ? MF_CHECKED : MF_UNCHECKED);

	EnableMenuItem(hMenu,
		IDM_D_REJECTINCOMING,
		bMsgFilterInstalled ? MF_ENABLED : MF_GRAYED);

	CheckMenuItem(hMenu,
		IDM_D_REJECTINCOMING,
		bRejecting ? MF_CHECKED : MF_UNCHECKED);

#if defined( OLE_CNTR )
	{
		LPCONTAINERDOC lpContainerDoc = (LPCONTAINERDOC)lpOleDoc;
		BOOL fShowObject;

		fShowObject = ContainerDoc_GetShowObjectFlag(lpContainerDoc);
		CheckMenuItem(
				hMenu,
				IDM_O_SHOWOBJECT,
				(fShowObject ? MF_CHECKED : MF_UNCHECKED)
		);

#if defined( INPLACE_CNTR ) && defined( _DEBUG )
		CheckMenuItem(
				hMenu,
				IDM_D_INSIDEOUT,
				g_fInsideOutContainer ? MF_CHECKED:MF_UNCHECKED);
#endif  // INPLACE_CNTR && _DEBUG

	}
#endif  // OLE_CNTR

	OLEDBG_END3
}



/* OleApp_UpdateEditMenu
 * ---------------------
 *
 *  Purpose:
 *      Update the Edit menuitems of the App according to the state of
 *      OutlineDoc
 *
 *  Parameter:
 *      lpOutlineDoc        pointer to the document
 *      hMenuEdit           edit menu handle
 */
void OleApp_UpdateEditMenu(
		LPOLEAPP                lpOleApp,
		LPOUTLINEDOC            lpOutlineDoc,
		HMENU                   hMenuEdit
)
{
	int             nFmtEtc;
	UINT            uEnablePaste = MF_GRAYED;
	UINT            uEnablePasteLink = MF_GRAYED;
	LPDATAOBJECT    lpClipboardDataObj;
	LPOLEDOC        lpOleDoc = (LPOLEDOC)lpOutlineDoc;
	HRESULT         hrErr;
	BOOL            fPrevEnable1;
	BOOL            fPrevEnable2;

	if (!lpOleApp || !lpOutlineDoc || !hMenuEdit)
		return;

	if (!OleDoc_GetUpdateEditMenuFlag(lpOleDoc))
		/* OLE2NOTE: if the flag is not set, we don't have to update
		**    the edit menu again. This blocks repetitive updating when
		**    the user move the mouse across Edit menu while holding
		**    down the button
		*/
		return;

	OLEDBG_BEGIN3("OleApp_InitEditMenu\r\n")

	/* OLE2NOTE: we do not want to ever give the busy dialog when we
	**    are trying to put up our menus. eg. even if the source of
	**    data on the clipboard is busy, we do not want put up the busy
	**    dialog. thus we will disable the dialog and at the end
	**    re-enable it.
	*/
	OleApp_DisableBusyDialogs(lpOleApp, &fPrevEnable1, &fPrevEnable2);

	// check if there is data on the clipboard that we can paste/paste link

	OLEDBG_BEGIN2("OleGetClipboard called\r\n")
	hrErr = OleGetClipboard((LPDATAOBJECT FAR*)&lpClipboardDataObj);
	OLEDBG_END2

	if (hrErr == NOERROR) {
		nFmtEtc = OleStdGetPriorityClipboardFormat(
				lpClipboardDataObj,
				lpOleApp->m_arrPasteEntries,
				lpOleApp->m_nPasteEntries
		);

		if (nFmtEtc >= 0)
			uEnablePaste = MF_ENABLED;  // there IS a format we like

		OLEDBG_BEGIN2("OleQueryLinkFromData called\r\n")
		hrErr = OleQueryLinkFromData(lpClipboardDataObj);
		OLEDBG_END2

		if(hrErr == NOERROR)
			uEnablePasteLink = MF_ENABLED;

		OleStdRelease((LPUNKNOWN)lpClipboardDataObj);
	}

	EnableMenuItem(hMenuEdit, IDM_E_PASTE, uEnablePaste);
	EnableMenuItem(hMenuEdit, IDM_E_PASTESPECIAL, uEnablePaste);


#if defined( OLE_CNTR )
	if (ContainerDoc_GetNextLink((LPCONTAINERDOC)lpOutlineDoc, NULL))
		EnableMenuItem(hMenuEdit, IDM_E_EDITLINKS, MF_ENABLED);
	else
		EnableMenuItem(hMenuEdit, IDM_E_EDITLINKS, MF_GRAYED);


	{
		LPCONTAINERAPP  lpContainerApp = (LPCONTAINERAPP)lpOleApp;
		HMENU           hMenuVerb = NULL;
		LPOLEOBJECT     lpOleObj = NULL;
		LPCONTAINERLINE lpContainerLine = NULL;
		BOOL            fSelIsOleObject;

		EnableMenuItem(hMenuEdit, IDM_E_PASTELINK, uEnablePasteLink);

		/* check if selection is a single line that contains an OleObject */

		fSelIsOleObject = ContainerDoc_IsSelAnOleObject(
				(LPCONTAINERDOC)lpOutlineDoc,
				&IID_IOleObject,
				(LPUNKNOWN FAR*)&lpOleObj,
				NULL,    /* we don't need the line index */
				(LPCONTAINERLINE FAR*)&lpContainerLine
		);

		if (hMenuEdit != NULL) {

			/* If the current line is an ContainerLine, add the object
			**    verb sub menu to the Edit menu. if the line is not an
			**    ContainerLine, (lpOleObj==NULL) then disable the
			**    Edit.Object command. this helper API takes care of
			**    building the verb menu as appropriate.
			*/
			OleUIAddVerbMenu(
					(LPOLEOBJECT)lpOleObj,
					(lpContainerLine ? lpContainerLine->m_lpszShortType:NULL),
					hMenuEdit,
					POS_OBJECT,
					IDM_E_OBJECTVERBMIN,
					0,                     // no uIDVerbMax enforced
					TRUE,                  // Add Convert menu item
					IDM_E_CONVERTVERB,     // ID for Convert menu item
					(HMENU FAR*) &hMenuVerb
			);

#if defined( USE_STATUSBAR_LATER )
			/* setup status messages for the object verb menu */
			if (hMenuVerb) {
				// REVIEW: this string should come from a string resource.
				// REVIEW: this doesn't work for dynamically created menus
				AssignPopupMessage(
						hMenuVerb,
						"Open, edit or interact with an object"
				);
			}
#endif  // USE_STATUSBAR_LATER
		}

		if (lpOleObj)
			OleStdRelease((LPUNKNOWN)lpOleObj);
	}

#endif  // OLE_CNTR

	// re-enable the Busy/NotResponding dialogs
	OleApp_EnableBusyDialogs(lpOleApp, fPrevEnable1, fPrevEnable2);

	OleDoc_SetUpdateEditMenuFlag(lpOleDoc, FALSE);

	OLEDBG_END3
}


/* OleApp_RegisterClassFactory
 * ---------------------------
 *
 * Register our app's ClassFactory with OLE.
 *
 */
BOOL OleApp_RegisterClassFactory(LPOLEAPP lpOleApp)
{
	HRESULT hrErr;

	if (lpOleApp->m_lpClassFactory)
		return TRUE;    // already registered

	OLEDBG_BEGIN3("OleApp_RegisterClassFactory\r\n")

	/******************************************************************
	** An SDI app must register its ClassFactory if it is launched
	**    for embedding (/Embedding command line option specified).
	** An MDI app must register its ClassFactory in all cases,
	******************************************************************/

	lpOleApp->m_lpClassFactory = AppClassFactory_Create();
	if (! lpOleApp->m_lpClassFactory) {
		OutlineApp_ErrorMessage(g_lpApp, ErrMsgCreateCF);
		goto error;
	}

	OLEDBG_BEGIN2("CoRegisterClassObject called\r\n")
	hrErr = CoRegisterClassObject(
				&CLSID_APP,
				(LPUNKNOWN)lpOleApp->m_lpClassFactory,
				CLSCTX_LOCAL_SERVER,
				REGCLS_SINGLEUSE,
				&lpOleApp->m_dwRegClassFac
	);
	OLEDBG_END2

	if(hrErr != NOERROR) {
		OleDbgOutHResult("CoRegisterClassObject returned", hrErr);
		OutlineApp_ErrorMessage(g_lpApp, ErrMsgRegCF);
		goto error;
	}

	OLEDBG_END3
	return TRUE;

error:

	if (lpOleApp->m_lpClassFactory) {
		OleStdRelease((LPUNKNOWN)lpOleApp->m_lpClassFactory);
		lpOleApp->m_lpClassFactory = NULL;
	}
	OLEDBG_END3
	return FALSE;
}


/* OleApp_RevokeClassFactory
 * -------------------------
 *
 * Revoke our app's ClassFactory.
 *
 */
void OleApp_RevokeClassFactory(LPOLEAPP lpOleApp)
{
	HRESULT hrErr;

	if (lpOleApp->m_lpClassFactory) {

		OLEDBG_BEGIN2("CoRevokeClassObject called\r\n")
		hrErr = CoRevokeClassObject(lpOleApp->m_dwRegClassFac);
		OLEDBG_END2

#if defined( _DEBUG )
		if (hrErr != NOERROR) {
			OleDbgOutHResult("CoRevokeClassObject returned", hrErr);
		}
#endif

		// we just release here; other folks may still have
		// a pointer to our class factory, so we can't
		// do any checks on the reference count.
		OleStdRelease((LPUNKNOWN)lpOleApp->m_lpClassFactory);
		lpOleApp->m_lpClassFactory = NULL;
	}
}


#if defined( USE_MSGFILTER )

/* OleApp_RegisterMessageFilter
 * ----------------------------
 *  Register our IMessageFilter*. the message filter is used to handle
 *  concurrency. we will use a standard implementation of IMessageFilter
 *  that is included as part of the OLE2UI library.
 */
BOOL OleApp_RegisterMessageFilter(LPOLEAPP lpOleApp)
{
	HRESULT hrErr;
	LPOUTLINEAPP lpOutlineApp = (LPOUTLINEAPP)lpOleApp;

	if (lpOleApp->m_lpMsgFilter == NULL) {
		// Register our message filter.
		lpOleApp->m_lpfnMsgPending = (MSGPENDINGPROC)MessagePendingProc;
		lpOleApp->m_lpMsgFilter = OleStdMsgFilter_Create(
				g_lpApp->m_hWndApp,
				(LPSTR)APPNAME,
				lpOleApp->m_lpfnMsgPending,
				NULL    /* Busy dialog callback hook function */
		);

		OLEDBG_BEGIN2("CoRegisterMessageFilter called\r\n")
		hrErr = CoRegisterMessageFilter(
					lpOleApp->m_lpMsgFilter,
					NULL    /* don't need previous message filter */
		);
		OLEDBG_END2

		if(hrErr != NOERROR) {
			OutlineApp_ErrorMessage(lpOutlineApp, ErrMsgRegMF);
			return FALSE;
		}
	}
	return TRUE;
}


/* OleApp_RevokeMessageFilter
 * --------------------------
 *  Revoke our IMessageFilter*. the message filter is used to handle
 *  concurrency. we will use a standard implementation of IMessageFilter
 *  that is included as part of the OLE2UI library.
 */
void OleApp_RevokeMessageFilter(LPOLEAPP lpOleApp)
{
	LPOUTLINEAPP lpOutlineApp = (LPOUTLINEAPP)g_lpApp;

	if (lpOleApp->m_lpMsgFilter != NULL) {
		// Revoke our message filter
		OLEDBG_BEGIN2("CoRegisterMessageFilter(NULL) called\r\n")
		CoRegisterMessageFilter(NULL, NULL);
		OLEDBG_END2

		if (lpOleApp->m_lpfnMsgPending) {
			lpOleApp->m_lpfnMsgPending = NULL;
		}

		OleStdVerifyRelease(
				(LPUNKNOWN)lpOleApp->m_lpMsgFilter,
				"Release MessageFilter FAILED!"
		);
		lpOleApp->m_lpMsgFilter = NULL;
	}
}


/* MessagePendingProc
 * ------------------
 *
 * Callback function for the IMessageFilter::MessagePending procedure.  This
 * function is called when a message is received by our application while
 * we are waiting for an OLE call to complete.  We are essentially
 * blocked at this point, waiting for a response from the other OLE application.
 * We should not process any messages which might cause another OLE call
 * to become blocked, or any other call which might cause re-entrancy problems.
 *
 * For this application, only process WM_PAINT messages.  A more sophisticated
 * application might allow certain menu messages and menu items to be processed
 * also.
 *
 * RETURNS: TRUE if we processed the message, FALSE if we did not.
 */

BOOL FAR PASCAL EXPORT MessagePendingProc(MSG FAR *lpMsg)
{
	// Our application is only handling WM_PAINT messages when we are blocked
	switch (lpMsg->message) {
		case WM_PAINT:
			OleDbgOut2("WM_PAINT dispatched while blocked\r\n");

			DispatchMessage(lpMsg);
			break;
	}

	return FALSE;   // return PENDINGMSG_WAITDEFPROCESS from MessagePending
}
#endif  // USE_MSGFILTER


/* OleApp_FlushClipboard
 * ---------------------
 *
 *  Force the Windows clipboard to release our clipboard DataObject.
 */
void OleApp_FlushClipboard(LPOLEAPP lpOleApp)
{
	LPOUTLINEAPP lpOutlineApp = (LPOUTLINEAPP)lpOleApp;
	LPOLEDOC lpClipboardDoc = (LPOLEDOC)lpOutlineApp->m_lpClipboardDoc;
	OLEDBG_BEGIN3("OleApp_FlushClipboard\r\n")

	/* OLE2NOTE: if for some reason our clipboard data transfer
	**    document is still held on to by an external client, we want
	**    to forceably break all external connections.
	*/
	OLEDBG_BEGIN2("CoDisconnectObject called\r\n")
	CoDisconnectObject((LPUNKNOWN)&lpClipboardDoc->m_Unknown, 0);
	OLEDBG_END2

	OLEDBG_BEGIN2("OleFlushClipboard called\r\n")
	OleFlushClipboard();
	OLEDBG_END2

	lpOutlineApp->m_lpClipboardDoc = NULL;

	OLEDBG_END3
}


/* OleApp_NewCommand
 * -----------------
 *
 *  Start a new untitled document (File.New command).
 */
void OleApp_NewCommand(LPOLEAPP lpOleApp)
{
	LPOUTLINEAPP lpOutlineApp = (LPOUTLINEAPP)lpOleApp;
	LPOUTLINEDOC lpOutlineDoc = lpOutlineApp->m_lpDoc;

	if (! OutlineDoc_Close(lpOutlineDoc, OLECLOSE_PROMPTSAVE))
		return;

	OleDbgAssertSz(lpOutlineApp->m_lpDoc==NULL,"Closed doc NOT properly destroyed");
	lpOutlineApp->m_lpDoc = OutlineApp_CreateDoc(lpOutlineApp, FALSE);
	if (! lpOutlineApp->m_lpDoc) goto error;

	/* OLE2NOTE: initially the Doc object is created with a 0 ref
	**    count. in order to have a stable Doc object during the
	**    process of initializing the new Doc instance,
	**    we intially AddRef the Doc ref cnt and later
	**    Release it. This initial AddRef is artificial; it is simply
	**    done to guarantee that a harmless QueryInterface followed by
	**    a Release does not inadvertantly force our object to destroy
	**    itself prematurely.
	*/
	OleDoc_AddRef((LPOLEDOC)lpOutlineApp->m_lpDoc);

	// set the doc to an (Untitled) doc.
	if (! OutlineDoc_InitNewFile(lpOutlineApp->m_lpDoc))
		goto error;

	// position and size the new doc window
	OutlineApp_ResizeWindows(lpOutlineApp);
	OutlineDoc_ShowWindow(lpOutlineApp->m_lpDoc); // calls OleDoc_Lock

	OleDoc_Release((LPOLEDOC)lpOutlineApp->m_lpDoc);  // rel artificial AddRef

	return;

error:
	// REVIEW: should load string from string resource
	OutlineApp_ErrorMessage(lpOutlineApp, "Could not create new document");

	if (lpOutlineApp->m_lpDoc) {
		// releasing the artificial AddRef above will destroy the document
		OleDoc_Release((LPOLEDOC)lpOutlineApp->m_lpDoc);
		lpOutlineApp->m_lpDoc = NULL;
	}

	return;
}


/* OleApp_OpenCommand
 * ------------------
 *
 *  Load a document from file (File.Open command).
 */
void OleApp_OpenCommand(LPOLEAPP lpOleApp)
{
	LPOUTLINEAPP lpOutlineApp = (LPOUTLINEAPP)lpOleApp;
	LPOUTLINEDOC lpOutlineDoc = lpOutlineApp->m_lpDoc;
	OPENFILENAME ofn;
	char szFilter[]=APPFILENAMEFILTER;
	char szFileName[256];
	UINT i;
	DWORD dwSaveOption = OLECLOSE_PROMPTSAVE;
	BOOL fStatus = TRUE;

	if (! OutlineDoc_CheckSaveChanges(lpOutlineDoc, &dwSaveOption))
		return;           // abort opening new doc

	for(i=0; szFilter[i]; i++)
		if(szFilter[i]=='|') szFilter[i]='\0';

	_fmemset((LPOPENFILENAME)&ofn,0,sizeof(OPENFILENAME));

	szFileName[0]='\0';

	ofn.lStructSize=sizeof(OPENFILENAME);
	ofn.hwndOwner=lpOutlineApp->m_hWndApp;
	ofn.lpstrFilter=(LPSTR)szFilter;
	ofn.lpstrFile=(LPSTR)szFileName;
	ofn.nMaxFile=sizeof(szFileName);
	ofn.Flags=OFN_FILEMUSTEXIST | OFN_HIDEREADONLY;
	ofn.lpstrDefExt=DEFEXTENSION;

	OleApp_PreModalDialog(lpOleApp, (LPOLEDOC)lpOutlineApp->m_lpDoc);

	fStatus = GetOpenFileName((LPOPENFILENAME)&ofn);

	OleApp_PostModalDialog(lpOleApp, (LPOLEDOC)lpOutlineApp->m_lpDoc);

	if(! fStatus)
		return;         // user canceled file open dialog

	OutlineDoc_Close(lpOutlineDoc, OLECLOSE_NOSAVE);
	OleDbgAssertSz(lpOutlineApp->m_lpDoc==NULL,"Closed doc NOT properly destroyed");

	lpOutlineApp->m_lpDoc = OutlineApp_CreateDoc(lpOutlineApp, FALSE);
	if (! lpOutlineApp->m_lpDoc) goto error;

	/* OLE2NOTE: initially the Doc object is created with a 0 ref
	**    count. in order to have a stable Doc object during the
	**    process of initializing the new Doc instance,
	**    we intially AddRef the Doc ref cnt and later
	**    Release it. This initial AddRef is artificial; it is simply
	**    done to guarantee that a harmless QueryInterface followed by
	**    a Release does not inadvertantly force our object to destroy
	**    itself prematurely.
	*/
	OleDoc_AddRef((LPOLEDOC)lpOutlineApp->m_lpDoc);

	fStatus=OutlineDoc_LoadFromFile(lpOutlineApp->m_lpDoc, (LPSTR)szFileName);

	if (! fStatus) {
		// loading the doc failed; create an untitled instead

		// releasing the artificial AddRef above will destroy the document
		OleDoc_Release((LPOLEDOC)lpOutlineApp->m_lpDoc);

		lpOutlineApp->m_lpDoc = OutlineApp_CreateDoc(lpOutlineApp, FALSE);
		if (! lpOutlineApp->m_lpDoc) goto error;
		OleDoc_AddRef((LPOLEDOC)lpOutlineApp->m_lpDoc);

		if (! OutlineDoc_InitNewFile(lpOutlineApp->m_lpDoc))
			goto error;
	}

	// position and size the new doc window
	OutlineApp_ResizeWindows(lpOutlineApp);
	OutlineDoc_ShowWindow(lpOutlineApp->m_lpDoc);

#if defined( OLE_CNTR )
	UpdateWindow(lpOutlineApp->m_hWndApp);
	ContainerDoc_UpdateLinks((LPCONTAINERDOC)lpOutlineApp->m_lpDoc);
#endif

	OleDoc_Release((LPOLEDOC)lpOutlineApp->m_lpDoc);  // rel artificial AddRef

	return;

error:
	// REVIEW: should load string from string resource
	OutlineApp_ErrorMessage(lpOutlineApp, "Could not create new document");

	if (lpOutlineApp->m_lpDoc) {
		// releasing the artificial AddRef above will destroy the document
		OleDoc_Release((LPOLEDOC)lpOutlineApp->m_lpDoc);
		lpOutlineApp->m_lpDoc = NULL;
	}

	return;
}



#if defined( OLE_CNTR )

/* OLE2NOTE: forward the WM_QUERYNEWPALETTE message (via
**    SendMessage) to UIActive in-place object if there is one.
**    this gives the UIActive object the opportunity to select
**    and realize its color palette as the FOREGROUND palette.
**    this is optional for in-place containers. if a container
**    prefers to force its color palette as the foreground
**    palette then it should NOT forward the this message. or
**    the container can give the UIActive object priority; if
**    the UIActive object returns 0 from the WM_QUERYNEWPALETTE
**    message (ie. it did not realize its own palette), then
**    the container can realize its palette.
**    (see ContainerDoc_ForwardPaletteChangedMsg for more info)
**
**    (It is a good idea for containers to use the standard
**    palette even if they do not use colors themselves. this
**    will allow embedded object to get a good distribution of
**    colors when they are being drawn by the container)
**
*/

LRESULT OleApp_QueryNewPalette(LPOLEAPP lpOleApp)
{
#if defined( INPLACE_CNTR )
	LPCONTAINERAPP lpContainerApp = (LPCONTAINERAPP)lpOleApp;

	if (lpContainerApp && lpContainerApp->m_hWndUIActiveObj) {
		if (SendMessage(lpContainerApp->m_hWndUIActiveObj, WM_QUERYNEWPALETTE,
				(WPARAM)0, (LPARAM)0)) {
			/* Object selected its palette as foreground palette */
			return (LRESULT)1;
		}
	}
#endif  // INPLACE_CNTR


	return wSelectPalette(((LPOUTLINEAPP)lpOleApp)->m_hWndApp,
		lpOleApp->m_hStdPal, FALSE/*fBackground*/);
}

#endif // OLE_CNTR



/* This is just a helper routine */

LRESULT wSelectPalette(HWND hWnd, HPALETTE hPal, BOOL fBackground)
{
	HDC hdc;
	HPALETTE hOldPal;
	UINT iPalChg = 0;

	if (hPal == 0)
		return (LRESULT)0;

	hdc = GetDC(hWnd);
	hOldPal = SelectPalette(hdc, hPal, fBackground);
	iPalChg = RealizePalette(hdc);
	SelectPalette(hdc, hOldPal, TRUE /*fBackground*/);
	ReleaseDC(hWnd, hdc);

	if (iPalChg > 0)
		InvalidateRect(hWnd, NULL, TRUE);

	return (LRESULT)1;
}




/*************************************************************************
** OleApp::IUnknown interface implementation
*************************************************************************/

STDMETHODIMP OleApp_Unk_QueryInterface(
		LPUNKNOWN           lpThis,
		REFIID              riid,
		LPVOID FAR*         lplpvObj
)
{
	LPOLEAPP lpOleApp = ((struct CAppUnknownImpl FAR*)lpThis)->lpOleApp;

	return OleApp_QueryInterface(lpOleApp, riid, lplpvObj);
}


STDMETHODIMP_(ULONG) OleApp_Unk_AddRef(LPUNKNOWN lpThis)
{
	LPOLEAPP lpOleApp = ((struct CAppUnknownImpl FAR*)lpThis)->lpOleApp;

	OleDbgAddRefMethod(lpThis, "IUnknown");

	return OleApp_AddRef(lpOleApp);
}


STDMETHODIMP_(ULONG) OleApp_Unk_Release (LPUNKNOWN lpThis)
{
	LPOLEAPP lpOleApp = ((struct CAppUnknownImpl FAR*)lpThis)->lpOleApp;

	OleDbgReleaseMethod(lpThis, "IUnknown");

	return OleApp_Release(lpOleApp);
}




#if defined( OLE_SERVER )

/*************************************************************************
** ServerDoc Supprt Functions Used by Server versions
*************************************************************************/

/* ServerApp_InitInstance
 * ----------------------
 *
 * Initialize the app instance by creating the main frame window and
 * performing app instance specific initializations
 *  (eg. initializing interface Vtbls).
 *
 * RETURNS: TRUE if the memory could be allocated, and the server app
 *               was properly initialized.
 *          FALSE otherwise
 *
 */

BOOL ServerApp_InitInstance(
		LPSERVERAPP             lpServerApp,
		HINSTANCE               hInst,
		int                     nCmdShow
)
{
	LPOLEAPP lpOleApp = (LPOLEAPP)lpServerApp;
	LPOUTLINEAPP lpOutlineApp = (LPOUTLINEAPP)lpServerApp;

	/* Setup arrays used by IDataObject::EnumFormatEtc.
	**
	** OLE2NOTE: The order that the formats are listed for GetData is very
	**    significant. It should be listed in order of highest fidelity
	**    formats to least fidelity formats. A common ordering will be:
	**                  1. private app formats
	**                  2. EmbedSource
	**                  3. lower fidelity interchange formats
	**                  4. pictures (metafile, dib, etc.)
	**                      (graphic-related apps offer pictures 1st!)
	**                  5. LinkSource
	*/

	/* m_arrDocGetFmts array enumerates the formats that a ServerDoc
	**    DataTransferDoc object can offer (give) through a
	**    IDataObject::GetData call. a ServerDoc DataTransferDoc offers
	**    data formats in the following order:
	**                  1. CF_OUTLINE
	**                  2. CF_EMBEDSOURCE
	**                  3. CF_OBJECTDESCRIPTOR
	**                  4. CF_TEXT
	**                  5. CF_METAFILEPICT
	**                  6. CF_LINKSOURCE *
	**                  7. CF_LINKSRCDESCRIPTOR *
	**
	**    * NOTE: CF_LINKSOURCE and CF_LINKSRCDESCRIPTOR is only
	**    offered if the doc is able to give
	**    a Moniker which references the data. CF_LINKSOURCE is
	**    deliberately listed last in this array of possible formats.
	**    if the doc does not have a Moniker then the last element of
	**    this array is not used. (see SvrDoc_DataObj_EnumFormatEtc).
	**
	**    NOTE: The list of formats that a USER ServerDoc document can
	**    offer is a static list and is registered in the registration
	**    database for the SVROUTL class. The
	**    IDataObject::EnumFormatEtc method returns OLE_S_USEREG in the
	**    case the document is a user docuemt (ie. created via
	**    File.New, File.Open, InsertObject in a container, or
	**    IPersistFile::Load during binding a link source). this tells
	**    OLE to enumerate the formats automatically using the data the
	**    the REGDB.
	*/

	lpOleApp->m_arrDocGetFmts[0].cfFormat   = lpOutlineApp->m_cfOutline;
	lpOleApp->m_arrDocGetFmts[0].ptd        = NULL;
	lpOleApp->m_arrDocGetFmts[0].dwAspect   = DVASPECT_CONTENT;
	lpOleApp->m_arrDocGetFmts[0].tymed      = TYMED_HGLOBAL;
	lpOleApp->m_arrDocGetFmts[0].lindex     = -1;

	lpOleApp->m_arrDocGetFmts[1].cfFormat   = lpOleApp->m_cfEmbedSource;
	lpOleApp->m_arrDocGetFmts[1].ptd        = NULL;
	lpOleApp->m_arrDocGetFmts[1].dwAspect   = DVASPECT_CONTENT;
	lpOleApp->m_arrDocGetFmts[1].tymed      = TYMED_ISTORAGE;
	lpOleApp->m_arrDocGetFmts[1].lindex     = -1;

	lpOleApp->m_arrDocGetFmts[2].cfFormat   = CF_TEXT;
	lpOleApp->m_arrDocGetFmts[2].ptd        = NULL;
	lpOleApp->m_arrDocGetFmts[2].dwAspect   = DVASPECT_CONTENT;
	lpOleApp->m_arrDocGetFmts[2].tymed      = TYMED_HGLOBAL;
	lpOleApp->m_arrDocGetFmts[2].lindex     = -1;

	lpOleApp->m_arrDocGetFmts[3].cfFormat   = CF_METAFILEPICT;
	lpOleApp->m_arrDocGetFmts[3].ptd        = NULL;
	lpOleApp->m_arrDocGetFmts[3].dwAspect   = DVASPECT_CONTENT;
	lpOleApp->m_arrDocGetFmts[3].tymed      = TYMED_MFPICT;
	lpOleApp->m_arrDocGetFmts[3].lindex     = -1;

	lpOleApp->m_arrDocGetFmts[4].cfFormat   = lpOleApp->m_cfObjectDescriptor;
	lpOleApp->m_arrDocGetFmts[4].ptd        = NULL;
	lpOleApp->m_arrDocGetFmts[4].dwAspect   = DVASPECT_CONTENT;
	lpOleApp->m_arrDocGetFmts[4].tymed      = TYMED_HGLOBAL;
	lpOleApp->m_arrDocGetFmts[4].lindex     = -1;

	lpOleApp->m_arrDocGetFmts[5].cfFormat   = lpOleApp->m_cfLinkSource;
	lpOleApp->m_arrDocGetFmts[5].ptd        = NULL;
	lpOleApp->m_arrDocGetFmts[5].dwAspect   = DVASPECT_CONTENT;
	lpOleApp->m_arrDocGetFmts[5].tymed      = TYMED_ISTREAM;
	lpOleApp->m_arrDocGetFmts[5].lindex     = -1;

	lpOleApp->m_arrDocGetFmts[6].cfFormat   = lpOleApp->m_cfLinkSrcDescriptor;
	lpOleApp->m_arrDocGetFmts[6].ptd        = NULL;
	lpOleApp->m_arrDocGetFmts[6].dwAspect   = DVASPECT_CONTENT;
	lpOleApp->m_arrDocGetFmts[6].tymed      = TYMED_HGLOBAL;
	lpOleApp->m_arrDocGetFmts[6].lindex     = -1;

	lpOleApp->m_nDocGetFmts = 7;

	/* m_arrPasteEntries array enumerates the formats that a ServerDoc
	**    object can accept (get) from the clipboard.
	**    The formats are listed in priority order.
	**    ServerDoc accept data formats in the following order:
	**                  1. CF_OUTLINE
	**                  2. CF_TEXT
	*/
	// REVIEW: strings should be loaded from string resource
	lpOleApp->m_arrPasteEntries[0].fmtetc.cfFormat =lpOutlineApp->m_cfOutline;
	lpOleApp->m_arrPasteEntries[0].fmtetc.ptd      = NULL;
	lpOleApp->m_arrPasteEntries[0].fmtetc.dwAspect = DVASPECT_CONTENT;
	lpOleApp->m_arrPasteEntries[0].fmtetc.tymed    = TYMED_HGLOBAL;
	lpOleApp->m_arrPasteEntries[0].fmtetc.lindex   = -1;
	lpOleApp->m_arrPasteEntries[0].lpstrFormatName = "Outline Data";
	lpOleApp->m_arrPasteEntries[0].lpstrResultText = "Outline Data";
	lpOleApp->m_arrPasteEntries[0].dwFlags         = OLEUIPASTE_PASTEONLY;

	lpOleApp->m_arrPasteEntries[1].fmtetc.cfFormat = CF_TEXT;
	lpOleApp->m_arrPasteEntries[1].fmtetc.ptd      = NULL;
	lpOleApp->m_arrPasteEntries[1].fmtetc.dwAspect = DVASPECT_CONTENT;
	lpOleApp->m_arrPasteEntries[1].fmtetc.tymed    = TYMED_HGLOBAL;
	lpOleApp->m_arrPasteEntries[1].fmtetc.lindex   = -1;
	lpOleApp->m_arrPasteEntries[1].lpstrFormatName = "Text";
	lpOleApp->m_arrPasteEntries[1].lpstrResultText = "text";
	lpOleApp->m_arrPasteEntries[1].dwFlags         = OLEUIPASTE_PASTEONLY;

	lpOleApp->m_nPasteEntries = 2;

   /**    m_arrLinkTypes array enumerates the link types that a ServerDoc
	**    object can accept from the clipboard. ServerDoc does NOT
	**    accept any type of link from the clipboard. ServerDoc can
	**    only be the source of a link. it can not contain links.
	*/

	lpOleApp->m_nLinkTypes = 0;

#if defined( INPLACE_SVR )

	lpServerApp->m_hAccelBaseApp = NULL;
	lpServerApp->m_hAccelIPSvr = LoadAccelerators(
			hInst,
			"InPlaceSvrOutlAccel"
	);

	lpServerApp->m_lpIPData = NULL;

	lpServerApp->m_hMenuEdit = GetSubMenu (
			lpOutlineApp->m_hMenuApp,
			POS_EDITMENU
	);
	lpServerApp->m_hMenuLine = GetSubMenu (
			lpOutlineApp->m_hMenuApp,
			POS_LINEMENU
	);
	lpServerApp->m_hMenuName = GetSubMenu (
			lpOutlineApp->m_hMenuApp,
			POS_NAMEMENU
	);
	lpServerApp->m_hMenuOptions = GetSubMenu (
			lpOutlineApp->m_hMenuApp,
			POS_OPTIONSMENU
	);
	lpServerApp->m_hMenuDebug = GetSubMenu (
			lpOutlineApp->m_hMenuApp,
			POS_DEBUGMENU
	);
	lpServerApp->m_hMenuHelp = GetSubMenu (
			lpOutlineApp->m_hMenuApp,
			POS_HELPMENU
	);

#endif  // INPLACE_SVR

	return TRUE;
}


/* ServerApp_InitVtbls
 * -------------------
 *
 * initialize the methods in all of the interface Vtbl's
 *
 * OLE2NOTE: we only need one copy of each Vtbl. When an object which
 *      exposes an interface is instantiated, its lpVtbl is intialized
 *      to point to the single copy of the Vtbl.
 *
 */
BOOL ServerApp_InitVtbls (LPSERVERAPP lpServerApp)
{
	BOOL fStatus;

	// ServerDoc::IOleObject method table
	OleStdInitVtbl(&g_SvrDoc_OleObjectVtbl, sizeof(IOleObjectVtbl));
	g_SvrDoc_OleObjectVtbl.QueryInterface   = SvrDoc_OleObj_QueryInterface;
	g_SvrDoc_OleObjectVtbl.AddRef           = SvrDoc_OleObj_AddRef;
	g_SvrDoc_OleObjectVtbl.Release          = SvrDoc_OleObj_Release;
	g_SvrDoc_OleObjectVtbl.SetClientSite    = SvrDoc_OleObj_SetClientSite;
	g_SvrDoc_OleObjectVtbl.GetClientSite    = SvrDoc_OleObj_GetClientSite;
	g_SvrDoc_OleObjectVtbl.SetHostNames     = SvrDoc_OleObj_SetHostNames;
	g_SvrDoc_OleObjectVtbl.Close            = SvrDoc_OleObj_Close;
	g_SvrDoc_OleObjectVtbl.SetMoniker       = SvrDoc_OleObj_SetMoniker;
	g_SvrDoc_OleObjectVtbl.GetMoniker       = SvrDoc_OleObj_GetMoniker;
	g_SvrDoc_OleObjectVtbl.InitFromData     = SvrDoc_OleObj_InitFromData;
	g_SvrDoc_OleObjectVtbl.GetClipboardData = SvrDoc_OleObj_GetClipboardData;
	g_SvrDoc_OleObjectVtbl.DoVerb           = SvrDoc_OleObj_DoVerb;
	g_SvrDoc_OleObjectVtbl.EnumVerbs        = SvrDoc_OleObj_EnumVerbs;
	g_SvrDoc_OleObjectVtbl.Update           = SvrDoc_OleObj_Update;
	g_SvrDoc_OleObjectVtbl.IsUpToDate       = SvrDoc_OleObj_IsUpToDate;
	g_SvrDoc_OleObjectVtbl.GetUserClassID   = SvrDoc_OleObj_GetUserClassID;
	g_SvrDoc_OleObjectVtbl.GetUserType      = SvrDoc_OleObj_GetUserType;
	g_SvrDoc_OleObjectVtbl.SetExtent        = SvrDoc_OleObj_SetExtent;
	g_SvrDoc_OleObjectVtbl.GetExtent        = SvrDoc_OleObj_GetExtent;
	g_SvrDoc_OleObjectVtbl.Advise           = SvrDoc_OleObj_Advise;
	g_SvrDoc_OleObjectVtbl.Unadvise         = SvrDoc_OleObj_Unadvise;
	g_SvrDoc_OleObjectVtbl.EnumAdvise       = SvrDoc_OleObj_EnumAdvise;
	g_SvrDoc_OleObjectVtbl.GetMiscStatus    = SvrDoc_OleObj_GetMiscStatus;
	g_SvrDoc_OleObjectVtbl.SetColorScheme   = SvrDoc_OleObj_SetColorScheme;
	fStatus = OleStdCheckVtbl(
			&g_SvrDoc_OleObjectVtbl,
			sizeof(IOleObjectVtbl),
			"IOleObject"
		);
	if (! fStatus) return FALSE;

	// ServerDoc::IPersistStorage method table
	OleStdInitVtbl(&g_SvrDoc_PersistStorageVtbl, sizeof(IPersistStorageVtbl));
	g_SvrDoc_PersistStorageVtbl.QueryInterface  = SvrDoc_PStg_QueryInterface;
	g_SvrDoc_PersistStorageVtbl.AddRef          = SvrDoc_PStg_AddRef;
	g_SvrDoc_PersistStorageVtbl.Release         = SvrDoc_PStg_Release;
	g_SvrDoc_PersistStorageVtbl.GetClassID      = SvrDoc_PStg_GetClassID;
	g_SvrDoc_PersistStorageVtbl.IsDirty         = SvrDoc_PStg_IsDirty;
	g_SvrDoc_PersistStorageVtbl.InitNew         = SvrDoc_PStg_InitNew;
	g_SvrDoc_PersistStorageVtbl.Load            = SvrDoc_PStg_Load;
	g_SvrDoc_PersistStorageVtbl.Save            = SvrDoc_PStg_Save;
	g_SvrDoc_PersistStorageVtbl.SaveCompleted   = SvrDoc_PStg_SaveCompleted;
	g_SvrDoc_PersistStorageVtbl.HandsOffStorage = SvrDoc_PStg_HandsOffStorage;
	fStatus = OleStdCheckVtbl(
			&g_SvrDoc_PersistStorageVtbl,
			sizeof(IPersistStorageVtbl),
			"IPersistStorage"
		);
	if (! fStatus) return FALSE;

#if defined( SVR_TREATAS )
	// ServerDoc::IStdMarshalInfo method table
	OleStdInitVtbl(
			&g_SvrDoc_StdMarshalInfoVtbl, sizeof(IStdMarshalInfoVtbl));
	g_SvrDoc_StdMarshalInfoVtbl.QueryInterface  =
											SvrDoc_StdMshl_QueryInterface;
	g_SvrDoc_StdMarshalInfoVtbl.AddRef          = SvrDoc_StdMshl_AddRef;
	g_SvrDoc_StdMarshalInfoVtbl.Release         = SvrDoc_StdMshl_Release;
	g_SvrDoc_StdMarshalInfoVtbl.GetClassForHandler =
											SvrDoc_StdMshl_GetClassForHandler;
	fStatus = OleStdCheckVtbl(
			&g_SvrDoc_StdMarshalInfoVtbl,
			sizeof(IStdMarshalInfoVtbl),
			"IStdMarshalInfo"
		);
	if (! fStatus) return FALSE;
#endif  // SVR_TREATAS

#if defined( INPLACE_SVR )
	// ServerDoc::IOleInPlaceObject method table
	OleStdInitVtbl(
		&g_SvrDoc_OleInPlaceObjectVtbl,
		sizeof(IOleInPlaceObjectVtbl)
	);
	g_SvrDoc_OleInPlaceObjectVtbl.QueryInterface
						= SvrDoc_IPObj_QueryInterface;
	g_SvrDoc_OleInPlaceObjectVtbl.AddRef
						= SvrDoc_IPObj_AddRef;
	g_SvrDoc_OleInPlaceObjectVtbl.Release
						= SvrDoc_IPObj_Release;
	g_SvrDoc_OleInPlaceObjectVtbl.GetWindow
						= SvrDoc_IPObj_GetWindow;
	g_SvrDoc_OleInPlaceObjectVtbl.ContextSensitiveHelp
						= SvrDoc_IPObj_ContextSensitiveHelp;
	g_SvrDoc_OleInPlaceObjectVtbl.InPlaceDeactivate
						= SvrDoc_IPObj_InPlaceDeactivate;
	g_SvrDoc_OleInPlaceObjectVtbl.UIDeactivate
						= SvrDoc_IPObj_UIDeactivate;
	g_SvrDoc_OleInPlaceObjectVtbl.SetObjectRects
						= SvrDoc_IPObj_SetObjectRects;
	g_SvrDoc_OleInPlaceObjectVtbl.ReactivateAndUndo
						= SvrDoc_IPObj_ReactivateAndUndo;
	fStatus = OleStdCheckVtbl(
			&g_SvrDoc_OleInPlaceObjectVtbl,
			sizeof(IOleInPlaceObjectVtbl),
			"IOleInPlaceObject"
		);
	if (! fStatus) return FALSE;

	// ServerDoc::IOleInPlaceActiveObject method table
	OleStdInitVtbl(
		&g_SvrDoc_OleInPlaceActiveObjectVtbl,
		sizeof(IOleInPlaceActiveObjectVtbl)
	);
	g_SvrDoc_OleInPlaceActiveObjectVtbl.QueryInterface
						= SvrDoc_IPActiveObj_QueryInterface;
	g_SvrDoc_OleInPlaceActiveObjectVtbl.AddRef
						= SvrDoc_IPActiveObj_AddRef;
	g_SvrDoc_OleInPlaceActiveObjectVtbl.Release
						= SvrDoc_IPActiveObj_Release;
	g_SvrDoc_OleInPlaceActiveObjectVtbl.GetWindow
						= SvrDoc_IPActiveObj_GetWindow;
	g_SvrDoc_OleInPlaceActiveObjectVtbl.ContextSensitiveHelp
						= SvrDoc_IPActiveObj_ContextSensitiveHelp;
	g_SvrDoc_OleInPlaceActiveObjectVtbl.TranslateAccelerator
						= SvrDoc_IPActiveObj_TranslateAccelerator;
	g_SvrDoc_OleInPlaceActiveObjectVtbl.OnFrameWindowActivate
						= SvrDoc_IPActiveObj_OnFrameWindowActivate;
	g_SvrDoc_OleInPlaceActiveObjectVtbl.OnDocWindowActivate
						= SvrDoc_IPActiveObj_OnDocWindowActivate;
	g_SvrDoc_OleInPlaceActiveObjectVtbl.ResizeBorder
						= SvrDoc_IPActiveObj_ResizeBorder;
	g_SvrDoc_OleInPlaceActiveObjectVtbl.EnableModeless
						= SvrDoc_IPActiveObj_EnableModeless;
	fStatus = OleStdCheckVtbl(
			&g_SvrDoc_OleInPlaceActiveObjectVtbl,
			sizeof(IOleInPlaceActiveObjectVtbl),
			"IOleInPlaceActiveObject"
		);
	if (! fStatus) return FALSE;

#endif


	// PseudoObj::IUnknown method table
	OleStdInitVtbl(&g_PseudoObj_UnknownVtbl, sizeof(IUnknownVtbl));
	g_PseudoObj_UnknownVtbl.QueryInterface  = PseudoObj_Unk_QueryInterface;
	g_PseudoObj_UnknownVtbl.AddRef          = PseudoObj_Unk_AddRef;
	g_PseudoObj_UnknownVtbl.Release         = PseudoObj_Unk_Release;
	fStatus = OleStdCheckVtbl(
			&g_PseudoObj_UnknownVtbl,
			sizeof(IUnknownVtbl),
			"IUnknown"
		);
	if (! fStatus) return FALSE;

	// PseudoObj::IOleObject method table
	OleStdInitVtbl(&g_PseudoObj_OleObjectVtbl, sizeof(IOleObjectVtbl));
	g_PseudoObj_OleObjectVtbl.QueryInterface= PseudoObj_OleObj_QueryInterface;
	g_PseudoObj_OleObjectVtbl.AddRef        = PseudoObj_OleObj_AddRef;
	g_PseudoObj_OleObjectVtbl.Release       = PseudoObj_OleObj_Release;
	g_PseudoObj_OleObjectVtbl.SetClientSite = PseudoObj_OleObj_SetClientSite;
	g_PseudoObj_OleObjectVtbl.GetClientSite = PseudoObj_OleObj_GetClientSite;
	g_PseudoObj_OleObjectVtbl.SetHostNames  = PseudoObj_OleObj_SetHostNames;
	g_PseudoObj_OleObjectVtbl.Close         = PseudoObj_OleObj_Close;
	g_PseudoObj_OleObjectVtbl.SetMoniker    = PseudoObj_OleObj_SetMoniker;
	g_PseudoObj_OleObjectVtbl.GetMoniker    = PseudoObj_OleObj_GetMoniker;
	g_PseudoObj_OleObjectVtbl.InitFromData  = PseudoObj_OleObj_InitFromData;
	g_PseudoObj_OleObjectVtbl.GetClipboardData =
											PseudoObj_OleObj_GetClipboardData;
	g_PseudoObj_OleObjectVtbl.DoVerb        = PseudoObj_OleObj_DoVerb;
	g_PseudoObj_OleObjectVtbl.EnumVerbs     = PseudoObj_OleObj_EnumVerbs;
	g_PseudoObj_OleObjectVtbl.Update        = PseudoObj_OleObj_Update;
	g_PseudoObj_OleObjectVtbl.IsUpToDate    = PseudoObj_OleObj_IsUpToDate;
	g_PseudoObj_OleObjectVtbl.GetUserType   = PseudoObj_OleObj_GetUserType;
	g_PseudoObj_OleObjectVtbl.GetUserClassID= PseudoObj_OleObj_GetUserClassID;
	g_PseudoObj_OleObjectVtbl.SetExtent     = PseudoObj_OleObj_SetExtent;
	g_PseudoObj_OleObjectVtbl.GetExtent     = PseudoObj_OleObj_GetExtent;
	g_PseudoObj_OleObjectVtbl.Advise        = PseudoObj_OleObj_Advise;
	g_PseudoObj_OleObjectVtbl.Unadvise      = PseudoObj_OleObj_Unadvise;
	g_PseudoObj_OleObjectVtbl.EnumAdvise    = PseudoObj_OleObj_EnumAdvise;
	g_PseudoObj_OleObjectVtbl.GetMiscStatus = PseudoObj_OleObj_GetMiscStatus;
	g_PseudoObj_OleObjectVtbl.SetColorScheme= PseudoObj_OleObj_SetColorScheme;
	fStatus = OleStdCheckVtbl(
			&g_PseudoObj_OleObjectVtbl,
			sizeof(IOleObjectVtbl),
			"IOleObject"
		);
	if (! fStatus) return FALSE;

	// ServerDoc::IDataObject method table
	OleStdInitVtbl(&g_PseudoObj_DataObjectVtbl, sizeof(IDataObjectVtbl));
	g_PseudoObj_DataObjectVtbl.QueryInterface =
									PseudoObj_DataObj_QueryInterface;
	g_PseudoObj_DataObjectVtbl.AddRef       = PseudoObj_DataObj_AddRef;
	g_PseudoObj_DataObjectVtbl.Release      = PseudoObj_DataObj_Release;
	g_PseudoObj_DataObjectVtbl.GetData      = PseudoObj_DataObj_GetData;
	g_PseudoObj_DataObjectVtbl.GetDataHere  = PseudoObj_DataObj_GetDataHere;
	g_PseudoObj_DataObjectVtbl.QueryGetData = PseudoObj_DataObj_QueryGetData;
	g_PseudoObj_DataObjectVtbl.GetCanonicalFormatEtc =
									PseudoObj_DataObj_GetCanonicalFormatEtc;
	g_PseudoObj_DataObjectVtbl.SetData      = PseudoObj_DataObj_SetData;
	g_PseudoObj_DataObjectVtbl.EnumFormatEtc= PseudoObj_DataObj_EnumFormatEtc;
	g_PseudoObj_DataObjectVtbl.DAdvise       = PseudoObj_DataObj_DAdvise;
	g_PseudoObj_DataObjectVtbl.DUnadvise     = PseudoObj_DataObj_DUnadvise;
	g_PseudoObj_DataObjectVtbl.EnumDAdvise   = PseudoObj_DataObj_EnumAdvise;

	fStatus = OleStdCheckVtbl(
			&g_PseudoObj_DataObjectVtbl,
			sizeof(IDataObjectVtbl),
			"IDataObject"
		);
	if (! fStatus) return FALSE;

	return TRUE;
}

#endif  // OLE_SERVER



#if defined( OLE_CNTR )

/*************************************************************************
** ContainerDoc Supprt Functions Used by Container versions
*************************************************************************/


/* ContainerApp_InitInstance
 * -------------------------
 *
 * Initialize the app instance by creating the main frame window and
 * performing app instance specific initializations
 *  (eg. initializing interface Vtbls).
 *
 * RETURNS: TRUE if the memory could be allocated, and the server app
 *               was properly initialized.
 *          FALSE otherwise
 *
 */

BOOL ContainerApp_InitInstance(
		LPCONTAINERAPP          lpContainerApp,
		HINSTANCE               hInst,
		int                     nCmdShow
)
{
	LPOLEAPP lpOleApp = (LPOLEAPP)lpContainerApp;
	LPOUTLINEAPP lpOutlineApp = (LPOUTLINEAPP)lpContainerApp;

	lpContainerApp->m_cfCntrOutl=RegisterClipboardFormat(CONTAINERDOCFORMAT);
	if(! lpContainerApp->m_cfCntrOutl) {
		// REVIEW: should load string from string resource
		OutlineApp_ErrorMessage(lpOutlineApp, "Can't register clipboard format!");
		return FALSE;
	}

#if defined( INPLACE_CNTR )

	lpContainerApp->m_fPendingUIDeactivate  = FALSE;
	lpContainerApp->m_fMustResizeClientArea = FALSE;
	lpContainerApp->m_lpIPActiveObj         = NULL;
	lpContainerApp->m_hWndUIActiveObj       = NULL;
	lpContainerApp->m_hAccelIPCntr = LoadAccelerators(
			hInst,
			"InPlaceCntrOutlAccel"
	);
	lpContainerApp->m_hMenuFile = GetSubMenu (
			lpOutlineApp->m_hMenuApp,
			POS_FILEMENU
	);
	lpContainerApp->m_hMenuView = GetSubMenu (
			lpOutlineApp->m_hMenuApp,
			POS_VIEWMENU
	);
	lpContainerApp->m_hMenuDebug = GetSubMenu (
			lpOutlineApp->m_hMenuApp,
			POS_DEBUGMENU
	);

	INIT_INTERFACEIMPL(
			&lpContainerApp->m_OleInPlaceFrame,
			&g_CntrApp_OleInPlaceFrameVtbl,
			lpContainerApp
	);

#endif

	/* Setup arrays used by IDataObject::EnumFormatEtc. This is used to
	**    support copy/paste and drag/drop operations.
	**
	** OLE2NOTE: The order that the formats are listed for GetData is very
	**    significant. It should be listed in order of highest fidelity
	**    formats to least fidelity formats. A common ordering will be:
	**                  1. private app formats
	**                  2. CF_EMBEDSOURCE or CF_EMBEDOBJECT (as appropriate)
	**                  3. lower fidelity interchange formats
	**                  4. CF_METAFILEPICT
	**                      (graphic-related apps might offer picture 1st!)
	**                  5. CF_OBJECTDESCRIPTOR
	**                  6. CF_LINKSOURCE
	**                  6. CF_LINKSRCDESCRIPTOR
	*/

	/* m_arrDocGetFmts array enumerates the formats that a ContainerDoc
	**    object can offer (give) through a IDataObject::GetData call
	**    when the selection copied is NOT a single embedded object.
	**    when a single embedded object this list of formats available
	**    is built dynamically depending on the object copied. (see
	**    ContainerDoc_SetupDocGetFmts).
	**    The formats are listed in priority order.
	**    ContainerDoc objects accept data formats in the following order:
	**                  1. CF_CNTROUTL
	**                  2. CF_OUTLINE
	**                  3. CF_TEXT
	**                  4. CF_OBJECTDESCRIPTOR
	**
	**    OLE2NOTE: CF_OBJECTDESCRIPTOR format is used to describe the
	**    data on the clipboard. this information is intended to be
	**    used, for example, to drive the PasteSpecial dialog. it is
	**    useful to render CF_OBJECTDESCRIPTOR format even when the
	**    data on the clipboard does NOT include CF_EMBEDDEDOBJECT
	**    format or CF_EMBEDSOURCE format as when a selection that is
	**    not a single OLE object is copied from the container only
	**    version CNTROUTL. by rendering CF_OBJECTDESCRIPTOR format the
	**    app can indicate a useful string to identifiy the source of
	**    the copy to the user.
	*/

	lpOleApp->m_arrDocGetFmts[0].cfFormat = lpContainerApp->m_cfCntrOutl;
	lpOleApp->m_arrDocGetFmts[0].ptd      = NULL;
	lpOleApp->m_arrDocGetFmts[0].dwAspect = DVASPECT_CONTENT;
	lpOleApp->m_arrDocGetFmts[0].tymed    = TYMED_ISTORAGE;
	lpOleApp->m_arrDocGetFmts[0].lindex   = -1;

	lpOleApp->m_arrDocGetFmts[1].cfFormat = lpOutlineApp->m_cfOutline;
	lpOleApp->m_arrDocGetFmts[1].ptd      = NULL;
	lpOleApp->m_arrDocGetFmts[1].dwAspect = DVASPECT_CONTENT;
	lpOleApp->m_arrDocGetFmts[1].tymed    = TYMED_HGLOBAL;
	lpOleApp->m_arrDocGetFmts[1].lindex   = -1;

	lpOleApp->m_arrDocGetFmts[2].cfFormat = CF_TEXT;
	lpOleApp->m_arrDocGetFmts[2].ptd      = NULL;
	lpOleApp->m_arrDocGetFmts[2].dwAspect = DVASPECT_CONTENT;
	lpOleApp->m_arrDocGetFmts[2].tymed    = TYMED_HGLOBAL;
	lpOleApp->m_arrDocGetFmts[2].lindex   = -1;

	lpOleApp->m_arrDocGetFmts[3].cfFormat = lpOleApp->m_cfObjectDescriptor;
	lpOleApp->m_arrDocGetFmts[3].ptd      = NULL;
	lpOleApp->m_arrDocGetFmts[3].dwAspect = DVASPECT_CONTENT;
	lpOleApp->m_arrDocGetFmts[3].tymed    = TYMED_HGLOBAL;
	lpOleApp->m_arrDocGetFmts[3].lindex   = -1;

	lpOleApp->m_nDocGetFmts = 4;

	/* m_arrSingleObjGetFmts array enumerates the formats that a
	**    ContainerDoc object can offer (give) through a
	**    IDataObject::GetData call when the selection copied IS a
	**    single OLE object.
	**    ContainerDoc objects accept data formats in the following order:
	**                  1. CF_CNTROUTL
	**                  2. CF_EMBEDDEDOBJECT
	**                  3. CF_OBJECTDESCRIPTOR
	**                  4. CF_METAFILEPICT  (note DVASPECT will vary)
	**                  5. CF_LINKSOURCE *
	**                  6. CF_LINKSRCDESCRIPTOR *
	**
	**    * OLE2NOTE: CF_LINKSOURCE and CF_LINKSRCDESCRIPTOR is only
	**    offered if the OLE object is allowed to be linked to from the
	**    inside (ie. we are allowed to give out a moniker which binds
	**    to the running OLE object), then we want to offer
	**    CF_LINKSOURCE format. if the object is an OLE 2.0 embedded
	**    object then it is allowed to be linked to from the inside. if
	**    the object is either an OleLink or an OLE 1.0 embedding then
	**    it can not be linked to from the inside. if we were a
	**    container/server app then we could offer linking to the
	**    outside of the object (ie. a pseudo object within our
	**    document). we are a container only app that does not support
	**    linking to ranges of its data.
	**    the simplest way to determine if an object can be linked to
	**    on the inside is to call IOleObject::GetMiscStatus and test
	**    to see if the OLEMISC_CANTLINKINSIDE bit is NOT set.
	**
	**    OLE2NOTE: optionally, a container that wants to have a
	**    potentially richer data transfer, can enumerate the data
	**    formats from the OLE object's cache and offer them too. if
	**    the object has a special handler, then it might be able to
	**    render additional data formats.
	*/
	lpContainerApp->m_arrSingleObjGetFmts[0].cfFormat =
												lpContainerApp->m_cfCntrOutl;
	lpContainerApp->m_arrSingleObjGetFmts[0].ptd      = NULL;
	lpContainerApp->m_arrSingleObjGetFmts[0].dwAspect = DVASPECT_CONTENT;
	lpContainerApp->m_arrSingleObjGetFmts[0].tymed    = TYMED_ISTORAGE;
	lpContainerApp->m_arrSingleObjGetFmts[0].lindex   = -1;

	lpContainerApp->m_arrSingleObjGetFmts[1].cfFormat =
												lpOleApp->m_cfEmbeddedObject;
	lpContainerApp->m_arrSingleObjGetFmts[1].ptd      = NULL;
	lpContainerApp->m_arrSingleObjGetFmts[1].dwAspect = DVASPECT_CONTENT;
	lpContainerApp->m_arrSingleObjGetFmts[1].tymed    = TYMED_ISTORAGE;
	lpContainerApp->m_arrSingleObjGetFmts[1].lindex   = -1;

	lpContainerApp->m_arrSingleObjGetFmts[2].cfFormat =
											   lpOleApp->m_cfObjectDescriptor;
	lpContainerApp->m_arrSingleObjGetFmts[2].ptd      = NULL;
	lpContainerApp->m_arrSingleObjGetFmts[2].dwAspect = DVASPECT_CONTENT;
	lpContainerApp->m_arrSingleObjGetFmts[2].tymed    = TYMED_HGLOBAL;
	lpContainerApp->m_arrSingleObjGetFmts[2].lindex   = -1;

	lpContainerApp->m_arrSingleObjGetFmts[3].cfFormat = CF_METAFILEPICT;
	lpContainerApp->m_arrSingleObjGetFmts[3].ptd      = NULL;
	lpContainerApp->m_arrSingleObjGetFmts[3].dwAspect = DVASPECT_CONTENT;
	lpContainerApp->m_arrSingleObjGetFmts[3].tymed    = TYMED_MFPICT;
	lpContainerApp->m_arrSingleObjGetFmts[3].lindex   = -1;

	lpContainerApp->m_arrSingleObjGetFmts[4].cfFormat =
													lpOleApp->m_cfLinkSource;
	lpContainerApp->m_arrSingleObjGetFmts[4].ptd      = NULL;
	lpContainerApp->m_arrSingleObjGetFmts[4].dwAspect = DVASPECT_CONTENT;
	lpContainerApp->m_arrSingleObjGetFmts[4].tymed    = TYMED_ISTREAM;
	lpContainerApp->m_arrSingleObjGetFmts[4].lindex   = -1;

	lpContainerApp->m_arrSingleObjGetFmts[5].cfFormat =
											  lpOleApp->m_cfLinkSrcDescriptor;
	lpContainerApp->m_arrSingleObjGetFmts[5].ptd      = NULL;
	lpContainerApp->m_arrSingleObjGetFmts[5].dwAspect = DVASPECT_CONTENT;
	lpContainerApp->m_arrSingleObjGetFmts[5].tymed    = TYMED_HGLOBAL;
	lpContainerApp->m_arrSingleObjGetFmts[5].lindex   = -1;

	lpContainerApp->m_nSingleObjGetFmts = 6;

	/* NOTE: the Container-Only version of Outline does NOT offer
	**    IDataObject interface from its User documents and the
	**    IDataObject interface available from DataTransferDoc's do NOT
	**    support SetData. IDataObject interface is required by objects
	**    which can be embedded or linked. the Container-only app only
	**    allows linking to its contained objects, NOT the data of the
	**    container itself.
	*/

	/*    m_arrPasteEntries array enumerates the formats that a ContainerDoc
	**    object can accept from the clipboard. this array is used to
	**    support the PasteSpecial dialog.
	**    The formats are listed in priority order.
	**    ContainerDoc objects accept data formats in the following order:
	**                  1. CF_CNTROUTL
	**                  2. CF_OUTLINE
	**                  3. CF_EMBEDDEDOBJECT
	**                  4. CF_TEXT
	**                  5. CF_METAFILEPICT
	**                  6. CF_DIB
	**                  7. CF_BITMAP
	**                  8. CF_LINKSOURCE
	**
	**    NOTE: specifying CF_EMBEDDEDOBJECT in the PasteEntry array
	**    indicates that the caller is interested in pasting OLE
	**    objects (ie. the caller calls OleCreateFromData). the
	**    OleUIPasteSpecial dialog and OleStdGetPriorityClipboardFormat
	**    call OleQueryCreateFromData to see if an OLE object format is
	**    available. thus, in fact if CF_EMBEDSOURCE or CF_FILENAME are
	**    available from the data source then and OLE object can be
	**    created and this entry will be matched. the caller should
	**    only specify one object type format.
	**    CF_FILENAME format (as generated by copying a file to
	**    the clipboard from the FileManager) is considered an object
	**    format; OleCreatFromData creates an object if the file has an
	**    associated class (see GetClassFile API) or if no class it
	**    creates an OLE 1.0 Package object. this format can also be
	**    paste linked by calling OleCreateLinkFromData.
	*/
	// REVIEW: strings should be loaded from string resource

	lpOleApp->m_arrPasteEntries[0].fmtetc.cfFormat =
									lpContainerApp->m_cfCntrOutl;
	lpOleApp->m_arrPasteEntries[0].fmtetc.ptd      = NULL;
	lpOleApp->m_arrPasteEntries[0].fmtetc.dwAspect = DVASPECT_CONTENT;
	lpOleApp->m_arrPasteEntries[0].fmtetc.tymed    = TYMED_ISTORAGE;
	lpOleApp->m_arrPasteEntries[0].fmtetc.lindex   = -1;
	lpOleApp->m_arrPasteEntries[0].lpstrFormatName = "Container Outline Data";
	lpOleApp->m_arrPasteEntries[0].lpstrResultText =
												"Container Outline Data";
	lpOleApp->m_arrPasteEntries[0].dwFlags         = OLEUIPASTE_PASTEONLY;

	lpOleApp->m_arrPasteEntries[1].fmtetc.cfFormat =lpOutlineApp->m_cfOutline;
	lpOleApp->m_arrPasteEntries[1].fmtetc.ptd      = NULL;
	lpOleApp->m_arrPasteEntries[1].fmtetc.dwAspect = DVASPECT_CONTENT;
	lpOleApp->m_arrPasteEntries[1].fmtetc.tymed    = TYMED_HGLOBAL;
	lpOleApp->m_arrPasteEntries[1].fmtetc.lindex   = -1;
	lpOleApp->m_arrPasteEntries[1].lpstrFormatName = "Outline Data";
	lpOleApp->m_arrPasteEntries[1].lpstrResultText = "Outline Data";
	lpOleApp->m_arrPasteEntries[1].dwFlags         = OLEUIPASTE_PASTEONLY;

	lpOleApp->m_arrPasteEntries[2].fmtetc.cfFormat =
									lpOleApp->m_cfEmbeddedObject;
	lpOleApp->m_arrPasteEntries[2].fmtetc.ptd      = NULL;
	lpOleApp->m_arrPasteEntries[2].fmtetc.dwAspect = DVASPECT_CONTENT;
	lpOleApp->m_arrPasteEntries[2].fmtetc.tymed    = TYMED_ISTORAGE;
	lpOleApp->m_arrPasteEntries[2].fmtetc.lindex   = -1;
	lpOleApp->m_arrPasteEntries[2].lpstrFormatName = "%s";
	lpOleApp->m_arrPasteEntries[2].lpstrResultText = "%s";
	lpOleApp->m_arrPasteEntries[2].dwFlags         =
									OLEUIPASTE_PASTE | OLEUIPASTE_ENABLEICON;

	lpOleApp->m_arrPasteEntries[3].fmtetc.cfFormat = CF_TEXT;
	lpOleApp->m_arrPasteEntries[3].fmtetc.ptd      = NULL;
	lpOleApp->m_arrPasteEntries[3].fmtetc.dwAspect = DVASPECT_CONTENT;
	lpOleApp->m_arrPasteEntries[3].fmtetc.tymed    = TYMED_HGLOBAL;
	lpOleApp->m_arrPasteEntries[3].fmtetc.lindex   = -1;
	lpOleApp->m_arrPasteEntries[3].lpstrFormatName = "Text";
	lpOleApp->m_arrPasteEntries[3].lpstrResultText = "text";
	lpOleApp->m_arrPasteEntries[3].dwFlags         = OLEUIPASTE_PASTEONLY;

	lpOleApp->m_arrPasteEntries[4].fmtetc.cfFormat = CF_METAFILEPICT;
	lpOleApp->m_arrPasteEntries[4].fmtetc.ptd      = NULL;
	lpOleApp->m_arrPasteEntries[4].fmtetc.dwAspect = DVASPECT_CONTENT;
	lpOleApp->m_arrPasteEntries[4].fmtetc.tymed    = TYMED_MFPICT;
	lpOleApp->m_arrPasteEntries[4].fmtetc.lindex   = -1;
	lpOleApp->m_arrPasteEntries[4].lpstrFormatName = "Picture (Metafile)";
	lpOleApp->m_arrPasteEntries[4].lpstrResultText = "a static picture";
	lpOleApp->m_arrPasteEntries[4].dwFlags         = OLEUIPASTE_PASTEONLY;

	lpOleApp->m_arrPasteEntries[5].fmtetc.cfFormat = CF_DIB;
	lpOleApp->m_arrPasteEntries[5].fmtetc.ptd      = NULL;
	lpOleApp->m_arrPasteEntries[5].fmtetc.dwAspect = DVASPECT_CONTENT;
	lpOleApp->m_arrPasteEntries[5].fmtetc.tymed    = TYMED_HGLOBAL;
	lpOleApp->m_arrPasteEntries[5].fmtetc.lindex   = -1;
	lpOleApp->m_arrPasteEntries[5].lpstrFormatName = "Picture (DIB)";
	lpOleApp->m_arrPasteEntries[5].lpstrResultText = "a static picture";
	lpOleApp->m_arrPasteEntries[5].dwFlags         = OLEUIPASTE_PASTEONLY;

	lpOleApp->m_arrPasteEntries[6].fmtetc.cfFormat = CF_BITMAP;
	lpOleApp->m_arrPasteEntries[6].fmtetc.ptd      = NULL;
	lpOleApp->m_arrPasteEntries[6].fmtetc.dwAspect = DVASPECT_CONTENT;
	lpOleApp->m_arrPasteEntries[6].fmtetc.tymed    = TYMED_GDI;
	lpOleApp->m_arrPasteEntries[6].fmtetc.lindex   = -1;
	lpOleApp->m_arrPasteEntries[6].lpstrFormatName = "Picture (Bitmap)";
	lpOleApp->m_arrPasteEntries[6].lpstrResultText = "a static picture";
	lpOleApp->m_arrPasteEntries[6].dwFlags         = OLEUIPASTE_PASTEONLY;

	lpOleApp->m_arrPasteEntries[7].fmtetc.cfFormat = lpOleApp->m_cfLinkSource;
	lpOleApp->m_arrPasteEntries[7].fmtetc.ptd      = NULL;
	lpOleApp->m_arrPasteEntries[7].fmtetc.dwAspect = DVASPECT_CONTENT;
	lpOleApp->m_arrPasteEntries[7].fmtetc.tymed    = TYMED_ISTREAM;
	lpOleApp->m_arrPasteEntries[7].fmtetc.lindex   = -1;
	lpOleApp->m_arrPasteEntries[7].lpstrFormatName = "%s";
	lpOleApp->m_arrPasteEntries[7].lpstrResultText = "%s";
	lpOleApp->m_arrPasteEntries[7].dwFlags         =
								OLEUIPASTE_LINKTYPE1 | OLEUIPASTE_ENABLEICON;

	lpOleApp->m_nPasteEntries = 8;

	/*    m_arrLinkTypes array enumerates the link types that a ContainerDoc
	**    object can accept from the clipboard
	*/

	lpOleApp->m_arrLinkTypes[0] = lpOleApp->m_cfLinkSource;
	lpOleApp->m_nLinkTypes = 1;

	return TRUE;
}


/* ContainerApp_InitVtbls
** ----------------------
**
**    initialize the interface Vtbl's used to support the OLE 2.0
**    Container functionality.
*/

BOOL ContainerApp_InitVtbls(LPCONTAINERAPP lpApp)
{
	BOOL fStatus;

	// ContainerDoc::IOleUILinkContainer method table
	OleStdInitVtbl(
			&g_CntrDoc_OleUILinkContainerVtbl,
			sizeof(IOleUILinkContainerVtbl)
	);
	g_CntrDoc_OleUILinkContainerVtbl.QueryInterface =
											CntrDoc_LinkCont_QueryInterface;
	g_CntrDoc_OleUILinkContainerVtbl.AddRef    = CntrDoc_LinkCont_AddRef;
	g_CntrDoc_OleUILinkContainerVtbl.Release   = CntrDoc_LinkCont_Release;
	g_CntrDoc_OleUILinkContainerVtbl.GetNextLink =
										CntrDoc_LinkCont_GetNextLink;
	g_CntrDoc_OleUILinkContainerVtbl.SetLinkUpdateOptions =
										CntrDoc_LinkCont_SetLinkUpdateOptions;
	g_CntrDoc_OleUILinkContainerVtbl.GetLinkUpdateOptions =
										CntrDoc_LinkCont_GetLinkUpdateOptions;
	g_CntrDoc_OleUILinkContainerVtbl.SetLinkSource =
										CntrDoc_LinkCont_SetLinkSource;
	g_CntrDoc_OleUILinkContainerVtbl.GetLinkSource =
										CntrDoc_LinkCont_GetLinkSource;
	g_CntrDoc_OleUILinkContainerVtbl.OpenLinkSource =
										CntrDoc_LinkCont_OpenLinkSource;
	g_CntrDoc_OleUILinkContainerVtbl.UpdateLink =
										CntrDoc_LinkCont_UpdateLink;
	g_CntrDoc_OleUILinkContainerVtbl.CancelLink =
										CntrDoc_LinkCont_CancelLink;
	fStatus = OleStdCheckVtbl(
			&g_CntrDoc_OleUILinkContainerVtbl,
			sizeof(IOleUILinkContainerVtbl),
			"IOleUILinkContainer"
		);
	if (! fStatus) return FALSE;

#if defined( INPLACE_CNTR )

	// ContainerApp::IOleInPlaceFrame interface method table
	OleStdInitVtbl(
			&g_CntrApp_OleInPlaceFrameVtbl,
			sizeof(g_CntrApp_OleInPlaceFrameVtbl)
	);

	g_CntrApp_OleInPlaceFrameVtbl.QueryInterface
						= CntrApp_IPFrame_QueryInterface;
	g_CntrApp_OleInPlaceFrameVtbl.AddRef
						= CntrApp_IPFrame_AddRef;
	g_CntrApp_OleInPlaceFrameVtbl.Release
						= CntrApp_IPFrame_Release;
	g_CntrApp_OleInPlaceFrameVtbl.GetWindow
						= CntrApp_IPFrame_GetWindow;
	g_CntrApp_OleInPlaceFrameVtbl.ContextSensitiveHelp
						= CntrApp_IPFrame_ContextSensitiveHelp;

	g_CntrApp_OleInPlaceFrameVtbl.GetBorder
						= CntrApp_IPFrame_GetBorder;
	g_CntrApp_OleInPlaceFrameVtbl.RequestBorderSpace
						= CntrApp_IPFrame_RequestBorderSpace;
	g_CntrApp_OleInPlaceFrameVtbl.SetBorderSpace
						= CntrApp_IPFrame_SetBorderSpace;
	g_CntrApp_OleInPlaceFrameVtbl.SetActiveObject
						= CntrApp_IPFrame_SetActiveObject;
	g_CntrApp_OleInPlaceFrameVtbl.InsertMenus
						= CntrApp_IPFrame_InsertMenus;
	g_CntrApp_OleInPlaceFrameVtbl.SetMenu
						= CntrApp_IPFrame_SetMenu;
	g_CntrApp_OleInPlaceFrameVtbl.RemoveMenus
						= CntrApp_IPFrame_RemoveMenus;
	g_CntrApp_OleInPlaceFrameVtbl.SetStatusText
						= CntrApp_IPFrame_SetStatusText;
	g_CntrApp_OleInPlaceFrameVtbl.EnableModeless
						= CntrApp_IPFrame_EnableModeless;
	g_CntrApp_OleInPlaceFrameVtbl.TranslateAccelerator
						= CntrApp_IPFrame_TranslateAccelerator;

	fStatus = OleStdCheckVtbl(
			&g_CntrApp_OleInPlaceFrameVtbl,
			sizeof(g_CntrApp_OleInPlaceFrameVtbl),
			"IOleInPlaceFrame"
		);
	if (! fStatus) return FALSE;

#endif  // INPLACE_CNTR


	// ContainerLine::IUnknown interface method table
	OleStdInitVtbl(
			&g_CntrLine_UnknownVtbl,
			sizeof(g_CntrLine_UnknownVtbl)
		);
	g_CntrLine_UnknownVtbl.QueryInterface   = CntrLine_Unk_QueryInterface;
	g_CntrLine_UnknownVtbl.AddRef           = CntrLine_Unk_AddRef;
	g_CntrLine_UnknownVtbl.Release          = CntrLine_Unk_Release;
	fStatus = OleStdCheckVtbl(
			&g_CntrLine_UnknownVtbl,
			sizeof(g_CntrLine_UnknownVtbl),
			"IUnknown"
		);
	if (! fStatus) return FALSE;

	// ContainerLine::IOleClientSite interface method table
	OleStdInitVtbl(
			&g_CntrLine_OleClientSiteVtbl,
			sizeof(g_CntrLine_OleClientSiteVtbl)
		);
	g_CntrLine_OleClientSiteVtbl.QueryInterface =
											CntrLine_CliSite_QueryInterface;
	g_CntrLine_OleClientSiteVtbl.AddRef       = CntrLine_CliSite_AddRef;
	g_CntrLine_OleClientSiteVtbl.Release      = CntrLine_CliSite_Release;
	g_CntrLine_OleClientSiteVtbl.SaveObject   = CntrLine_CliSite_SaveObject;
	g_CntrLine_OleClientSiteVtbl.GetMoniker   = CntrLine_CliSite_GetMoniker;
	g_CntrLine_OleClientSiteVtbl.GetContainer = CntrLine_CliSite_GetContainer;
	g_CntrLine_OleClientSiteVtbl.ShowObject   = CntrLine_CliSite_ShowObject;
	g_CntrLine_OleClientSiteVtbl.OnShowWindow = CntrLine_CliSite_OnShowWindow;
	g_CntrLine_OleClientSiteVtbl.RequestNewObjectLayout =
									CntrLine_CliSite_RequestNewObjectLayout;
	fStatus = OleStdCheckVtbl(
			&g_CntrLine_OleClientSiteVtbl,
			sizeof(g_CntrLine_OleClientSiteVtbl),
			"IOleClientSite"
		);
	if (! fStatus) return FALSE;

	// ContainerLine::IAdviseSink interface method table
	OleStdInitVtbl(
			&g_CntrLine_AdviseSinkVtbl,
			sizeof(g_CntrLine_AdviseSinkVtbl)
	);
	g_CntrLine_AdviseSinkVtbl.QueryInterface= CntrLine_AdvSink_QueryInterface;
	g_CntrLine_AdviseSinkVtbl.AddRef        = CntrLine_AdvSink_AddRef;
	g_CntrLine_AdviseSinkVtbl.Release       = CntrLine_AdvSink_Release;
	g_CntrLine_AdviseSinkVtbl.OnDataChange  = CntrLine_AdvSink_OnDataChange;
	g_CntrLine_AdviseSinkVtbl.OnViewChange  = CntrLine_AdvSink_OnViewChange;
	g_CntrLine_AdviseSinkVtbl.OnRename      = CntrLine_AdvSink_OnRename;
	g_CntrLine_AdviseSinkVtbl.OnSave        = CntrLine_AdvSink_OnSave;
	g_CntrLine_AdviseSinkVtbl.OnClose       = CntrLine_AdvSink_OnClose;
	fStatus = OleStdCheckVtbl(
			&g_CntrLine_AdviseSinkVtbl,
			sizeof(g_CntrLine_AdviseSinkVtbl),
			"IAdviseSink"
		);
	if (! fStatus) return FALSE;


#if defined( INPLACE_CNTR )

	// ContainerLine::IOleInPlaceSite interface method table
	OleStdInitVtbl(
			&g_CntrLine_OleInPlaceSiteVtbl,
			sizeof(g_CntrLine_OleInPlaceSiteVtbl)
	);

	g_CntrLine_OleInPlaceSiteVtbl.QueryInterface
						= CntrLine_IPSite_QueryInterface;
	g_CntrLine_OleInPlaceSiteVtbl.AddRef
						= CntrLine_IPSite_AddRef;
	g_CntrLine_OleInPlaceSiteVtbl.Release
						= CntrLine_IPSite_Release;
	g_CntrLine_OleInPlaceSiteVtbl.GetWindow
						= CntrLine_IPSite_GetWindow;
	g_CntrLine_OleInPlaceSiteVtbl.ContextSensitiveHelp
						= CntrLine_IPSite_ContextSensitiveHelp;
	g_CntrLine_OleInPlaceSiteVtbl.CanInPlaceActivate
						= CntrLine_IPSite_CanInPlaceActivate;
	g_CntrLine_OleInPlaceSiteVtbl.OnInPlaceActivate
						= CntrLine_IPSite_OnInPlaceActivate;
	g_CntrLine_OleInPlaceSiteVtbl.OnUIActivate
						= CntrLine_IPSite_OnUIActivate;
	g_CntrLine_OleInPlaceSiteVtbl.GetWindowContext
						= CntrLine_IPSite_GetWindowContext;
	g_CntrLine_OleInPlaceSiteVtbl.Scroll
						= CntrLine_IPSite_Scroll;
	g_CntrLine_OleInPlaceSiteVtbl.OnUIDeactivate
						= CntrLine_IPSite_OnUIDeactivate;

	g_CntrLine_OleInPlaceSiteVtbl.OnInPlaceDeactivate
						= CntrLine_IPSite_OnInPlaceDeactivate;
	g_CntrLine_OleInPlaceSiteVtbl.DiscardUndoState
						= CntrLine_IPSite_DiscardUndoState;
	g_CntrLine_OleInPlaceSiteVtbl.DeactivateAndUndo
						= CntrLine_IPSite_DeactivateAndUndo;
	g_CntrLine_OleInPlaceSiteVtbl.OnPosRectChange
						= CntrLine_IPSite_OnPosRectChange;

	fStatus = OleStdCheckVtbl(
			&g_CntrLine_OleInPlaceSiteVtbl,
			sizeof(g_CntrLine_OleInPlaceSiteVtbl),
			"IOleInPlaceSite"
		);
	if (! fStatus) return FALSE;

#endif  // INPLACE_CNTR

	return TRUE;
}


#endif  // OLE_CNTR
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\letest\outline\oledoc.c ===
/*************************************************************************
**
**    OLE 2 Server Sample Code
**
**    oledoc.c
**
**    This file contains general OleDoc methods and related support
**    functions. OleDoc implementation is used by both the Container
**    versions and the Server (Object) versions of the Outline Sample.
**
**    This file includes general support for the following:
**    1. show/hide doc window
**    2. QueryInterface, AddRef, Release
**    3. document locking (calls CoLockObjectExternal)
**    4. document shutdown (Close, Destroy)
**    5. clipboard support
**
**    OleDoc Object
**      exposed interfaces:
**          IUnknown
**          IPersistFile
**          IOleItemContainer
**          IDataObject
**
**    (c) Copyright Microsoft Corp. 1992 - 1993 All Rights Reserved
**
*************************************************************************/


#include "outline.h"

OLEDBGDATA

extern LPOUTLINEAPP             g_lpApp;

extern IUnknownVtbl             g_OleDoc_UnknownVtbl;
extern IPersistFileVtbl         g_OleDoc_PersistFileVtbl;
extern IOleItemContainerVtbl    g_OleDoc_OleItemContainerVtbl;
extern IExternalConnectionVtbl  g_OleDoc_ExternalConnectionVtbl;
extern IDataObjectVtbl          g_OleDoc_DataObjectVtbl;

#if defined( USE_DRAGDROP )
extern IDropTargetVtbl          g_OleDoc_DropTargetVtbl;
extern IDropSourceVtbl          g_OleDoc_DropSourceVtbl;
#endif  // USE_DRAGDROP

#if defined( INPLACE_CNTR )
extern BOOL g_fInsideOutContainer;
#endif


/* OleDoc_Init
 * -----------
 *
 *  Initialize the fields of a new OleDoc object. The object is initially
 *  not associated with a file or an (Untitled) document. This function sets
 *  the docInitType to DOCTYPE_UNKNOWN. After calling this function the
 *  caller should call:
 *      1.) Doc_InitNewFile to set the OleDoc to (Untitled)
 *      2.) Doc_LoadFromFile to associate the OleDoc with a file.
 *  This function creates a new window for the document.
 *
 *  NOTE: the window is initially created with a NIL size. it must be
 *        sized and positioned by the caller. also the document is initially
 *        created invisible. the caller must call OutlineDoc_ShowWindow
 *        after sizing it to make the document window visible.
 */
BOOL OleDoc_Init(LPOLEDOC lpOleDoc, BOOL fDataTransferDoc)
{
	LPOLEAPP   lpOleApp = (LPOLEAPP)g_lpApp;
	LPLINELIST lpLL     = (LPLINELIST)&((LPOUTLINEDOC)lpOleDoc)->m_LineList;

	lpOleDoc->m_cRef                        = 0;
	lpOleDoc->m_dwStrongExtConn             = 0;
#if defined( _DEBUG )
	lpOleDoc->m_cCntrLock                   = 0;
#endif
	lpOleDoc->m_lpStg                       = NULL;
	lpOleDoc->m_lpLLStm                     = NULL;
	lpOleDoc->m_lpNTStm                     = NULL;
	lpOleDoc->m_dwRegROT                    = 0;
	lpOleDoc->m_lpFileMoniker               = NULL;
	lpOleDoc->m_fLinkSourceAvail            = FALSE;
	lpOleDoc->m_lpSrcDocOfCopy              = NULL;
	lpOleDoc->m_fObjIsClosing               = FALSE;
	lpOleDoc->m_fObjIsDestroying            = FALSE;
	lpOleDoc->m_fUpdateEditMenu             = FALSE;

#if defined( USE_DRAGDROP )
	lpOleDoc->m_dwTimeEnterScrollArea       = 0L;
	lpOleDoc->m_dwNextScrollTime            = 0L;
	lpOleDoc->m_dwLastScrollDir             = SCROLLDIR_NULL;
	lpOleDoc->m_fRegDragDrop                = FALSE;
	lpOleDoc->m_fLocalDrag                  = FALSE;
	lpOleDoc->m_fCanDropCopy                = FALSE;
	lpOleDoc->m_fCanDropLink                = FALSE;
	lpOleDoc->m_fLocalDrop                  = FALSE;
	lpOleDoc->m_fDragLeave                  = FALSE;
	lpOleDoc->m_fPendingDrag                = FALSE;
#endif
#if defined( INPLACE_SVR ) || defined( INPLACE_CNTR )
	lpOleDoc->m_fCSHelpMode                 = FALSE;    // Shift-F1 context
														// sensitive help mode
#endif

	INIT_INTERFACEIMPL(
			&lpOleDoc->m_Unknown,
			&g_OleDoc_UnknownVtbl,
			lpOleDoc
	);

	INIT_INTERFACEIMPL(
			&lpOleDoc->m_PersistFile,
			&g_OleDoc_PersistFileVtbl,
			lpOleDoc
	);

	INIT_INTERFACEIMPL(
			&lpOleDoc->m_OleItemContainer,
			&g_OleDoc_OleItemContainerVtbl,
			lpOleDoc
	);

	INIT_INTERFACEIMPL(
			&lpOleDoc->m_ExternalConnection,
			&g_OleDoc_ExternalConnectionVtbl,
			lpOleDoc
	);

	INIT_INTERFACEIMPL(
			&lpOleDoc->m_DataObject,
			&g_OleDoc_DataObjectVtbl,
			lpOleDoc
	);

#if defined( USE_DRAGDROP )
	INIT_INTERFACEIMPL(
			&lpOleDoc->m_DropSource,
			&g_OleDoc_DropSourceVtbl,
			lpOleDoc
	);

	INIT_INTERFACEIMPL(
			&lpOleDoc->m_DropTarget,
			&g_OleDoc_DropTargetVtbl,
			lpOleDoc
	);
#endif  // USE_DRAGDROP

	/*
	** OLE2NOTE: each user level document addref's the app object in
	**    order to guarentee that the app does not shut down while the
	**    doc is still open.
	*/

	// OLE2NOTE: data transfer documents should not hold the app alive
	if (! fDataTransferDoc)
		OleApp_DocLockApp(lpOleApp);

#if defined( OLE_SERVER )
	/* OLE2NOTE: perform initialization specific for an OLE server */
	if (! ServerDoc_Init((LPSERVERDOC)lpOleDoc, fDataTransferDoc))
		return FALSE;
#endif
#if defined( OLE_CNTR )

	/* OLE2NOTE: perform initialization specific for an OLE container */
	if (! ContainerDoc_Init((LPCONTAINERDOC)lpOleDoc, fDataTransferDoc))
		return FALSE;
#endif

	return TRUE;
}



/* OleDoc_InitNewFile
 * ------------------
 *
 *  Initialize the document to be a new (Untitled) document.
 *  This function sets the docInitType to DOCTYPE_NEW.
 *
 *  OLE2NOTE: if this is a visible user document then generate a unique
 *  untitled name that we can use to register in the RunningObjectTable.
 *  We need a unique name so that clients can link to data in this document
 *  even when the document is in the un-saved (untitled) state. it would be
 *  ambiguous to register two documents titled "Outline1" in the ROT. we
 *  thus generate the lowest numbered document that is not already
 *  registered in the ROT.
 */
BOOL OleDoc_InitNewFile(LPOLEDOC lpOleDoc)
{
	LPOUTLINEDOC lpOutlineDoc = (LPOUTLINEDOC)lpOleDoc;

	static UINT uUnique = 1;

	OleDbgAssert(lpOutlineDoc->m_docInitType == DOCTYPE_UNKNOWN);

#if defined( OLE_CNTR )
	{
		LPCONTAINERDOC lpContainerDoc = (LPCONTAINERDOC)lpOleDoc;
#if defined( _DEBUG )
		OleDbgAssertSz(lpOleDoc->m_lpStg == NULL,
				"Setting to untitled with current file open"
		);
#endif

		/* Create a temp, (delete-on-release) file base storage
		**  for the untitled document.
		*/
		lpOleDoc->m_lpStg = OleStdCreateRootStorage(
				NULL,
				STGM_SHARE_EXCLUSIVE
		);
		if (! lpOleDoc->m_lpStg) return FALSE;
	}
#endif

	lpOutlineDoc->m_docInitType = DOCTYPE_NEW;

	if (! lpOutlineDoc->m_fDataTransferDoc) {
		/* OLE2NOTE: choose a unique name for a Moniker so that
		**    potential clients can link to our new, untitled document.
		**    if links are established (and currently are connected),
		**    then they will be notified that we have been renamed when
		**    this document is saved to a file.
		*/

		lpOleDoc->m_fLinkSourceAvail = TRUE;

		// REVIEW: should load UNTITLED string from string resource
		OleStdCreateTempFileMoniker(
				UNTITLED,
				(UINT FAR*)&uUnique,
				lpOutlineDoc->m_szFileName,
				&lpOleDoc->m_lpFileMoniker
		);

		OLEDBG_BEGIN3("OleStdRegisterAsRunning called\r\n")
		OleStdRegisterAsRunning(
				(LPUNKNOWN)&lpOleDoc->m_PersistFile,
				(LPMONIKER)lpOleDoc->m_lpFileMoniker,
				&lpOleDoc->m_dwRegROT
		);
		OLEDBG_END3

		lpOutlineDoc->m_lpszDocTitle = lpOutlineDoc->m_szFileName;
		OutlineDoc_SetTitle(lpOutlineDoc, FALSE /*fMakeUpperCase*/);
	} else {
		lstrcpy(lpOutlineDoc->m_szFileName, UNTITLED);
		lpOutlineDoc->m_lpszDocTitle = lpOutlineDoc->m_szFileName;
	}

	return TRUE;
}


/* OleDoc_ShowWindow
 * -----------------
 *
 *      Show the window of the document to the user.
 *      make sure app window is visible and bring the document to the top.
 *      if the document is a file-based document or a new untitled
 *      document, give the user the control over the life-time of the doc.
 */
void OleDoc_ShowWindow(LPOLEDOC lpOleDoc)
{
	LPOUTLINEAPP lpOutlineApp = (LPOUTLINEAPP)g_lpApp;
	LPOLEAPP lpOleApp = (LPOLEAPP)g_lpApp;
	LPOUTLINEDOC lpOutlineDoc = (LPOUTLINEDOC)lpOleDoc;
	LPLINELIST lpLL     = (LPLINELIST)&((LPOUTLINEDOC)lpOleDoc)->m_LineList;
#if defined( OLE_SERVER )
	LPSERVERDOC lpServerDoc = (LPSERVERDOC)lpOleDoc;
#endif // OLE_SERVER

	OLEDBG_BEGIN3("OleDoc_ShowWindow\r\n")

	/* OLE2NOTE: while the document is visible, we do NOT want it to be
	**    prematurely destroyed when a linking client disconnects. thus
	**    we must inform OLE to hold an external lock on our document.
	**    this arranges that OLE holds at least 1 reference to our
	**    document that will NOT be released until we release this
	**    external lock. later, when the document window is hidden, we
	**    will release this external lock.
	*/
	if (! IsWindowVisible(lpOutlineDoc->m_hWndDoc))
		OleDoc_Lock(lpOleDoc, TRUE /* fLock */, 0 /* not applicable */);

#if defined( USE_DRAGDROP )
	/* OLE2NOTE: since our window is now being made visible, we will
	**    register our window as a potential drop target. when the
	**    window is hidden there is no reason to be registered as a
	**    drop target.
	*/
	if (! lpOleDoc->m_fRegDragDrop) {
		OLEDBG_BEGIN2("RegisterDragDrop called\r\n")
		RegisterDragDrop(
				LineList_GetWindow(lpLL),
				(LPDROPTARGET)&lpOleDoc->m_DropTarget
		);
		OLEDBG_END2
		lpOleDoc->m_fRegDragDrop = TRUE;
	}
#endif  // USE_DRAGDROP

#if defined( USE_FRAMETOOLS )
	{
		/* OLE2NOTE: we need to enable our frame level tools
		*/
		FrameTools_Enable(lpOutlineDoc->m_lpFrameTools, TRUE);
	}
#endif // USE_FRAMETOOLS

#if defined( OLE_SERVER )

	if (lpOutlineDoc->m_docInitType == DOCTYPE_EMBEDDED &&
			lpServerDoc->m_lpOleClientSite != NULL) {

		/* OLE2NOTE: we must also ask our container to show itself if
		**    it is not already visible and to scroll us into view. we
		**    must make sure to call this BEFORE showing our server's
		**    window and taking focus. we do not want our container's
		**    window to end up on top.
		*/
		OLEDBG_BEGIN2("IOleClientSite::ShowObject called\r\n");
		lpServerDoc->m_lpOleClientSite->lpVtbl->ShowObject(
				lpServerDoc->m_lpOleClientSite
		);
		OLEDBG_END2

		/* OLE2NOTE: if we are an embedded object and we are not
		**    in-place active in our containers window, we must inform our
		**    embedding container that our window is opening.
		**    the container must now hatch our object.
		*/

#if defined( INPLACE_SVR )
		if (! lpServerDoc->m_fInPlaceActive)
#endif
		{
			OLEDBG_BEGIN2("IOleClientSite::OnShowWindow(TRUE) called\r\n");
			lpServerDoc->m_lpOleClientSite->lpVtbl->OnShowWindow(
					lpServerDoc->m_lpOleClientSite,
					TRUE
			);
			OLEDBG_END2
		}

		/* OLE2NOTE: the life-time of our document is controlled by our
		**    client and NOT by the user. we are not an independent
		**    file-level object. we simply want to show our window here.
		**
		**    if we are not in-place active (ie. we are opening
		**    our own window), we must make sure our main app window is
		**    visible. we do not, however, want to give the user
		**    control of the App window; we do not want OleApp_ShowWindow
		**    to call OleApp_Lock on behalf of the user.
		*/
		if (! IsWindowVisible(lpOutlineApp->m_hWndApp) ||
				IsIconic(lpOutlineApp->m_hWndApp)) {
#if defined( INPLACE_SVR )
			if (! ((LPSERVERDOC)lpOleDoc)->m_fInPlaceActive)
#endif
				OleApp_ShowWindow(lpOleApp, FALSE /* fGiveUserCtrl */);
			SetFocus(lpOutlineDoc->m_hWndDoc);
		}

	} else
#endif  // OLE_SERVER

	{    // DOCTYPE_NEW || DOCTYPE_FROMFILE

		// we must make sure our app window is visible
		OleApp_ShowWindow(lpOleApp, TRUE /* fGiveUserCtrl */);
	}

	// make document window visible and make sure it is not minimized
	ShowWindow(lpOutlineDoc->m_hWndDoc, SW_SHOWNORMAL);
	SetFocus(lpOutlineDoc->m_hWndDoc);

	OLEDBG_END3
}


/* OleDoc_HideWindow
 * -----------------
 *
 *      Hide the window of the document from the user.
 *      take away the control of the document by the user.
 */
void OleDoc_HideWindow(LPOLEDOC lpOleDoc, BOOL fShutdown)
{
	LPOLEAPP lpOleApp = (LPOLEAPP)g_lpApp;
	LPOUTLINEDOC lpOutlineDoc = (LPOUTLINEDOC)lpOleDoc;
	LPLINELIST lpLL     = (LPLINELIST)&((LPOUTLINEDOC)lpOleDoc)->m_LineList;

	if (! IsWindowVisible(lpOutlineDoc->m_hWndDoc))
		return;     // already visible

	OLEDBG_BEGIN3("OleDoc_HideWindow\r\n")

#if defined( USE_DRAGDROP )
	// The document's window is being hidden, revoke it as a DropTarget
	if (lpOleDoc->m_fRegDragDrop) {
		OLEDBG_BEGIN2("RevokeDragDrop called\r\n");
		RevokeDragDrop(LineList_GetWindow(lpLL));
		OLEDBG_END2

		lpOleDoc->m_fRegDragDrop = FALSE ;
	}
#endif  // USE_DRAGDROP

	/* OLE2NOTE: the document is now being hidden, so we must release
	**    the external lock made when the document was made visible.
	**    if this is a shutdown situation (fShutdown==TRUE), then OLE
	**    is instructed to release our document. if this is that last
	**    external lock on our document, thus enabling our document to
	**    complete its shutdown operation. If This is not a shutdown
	**    situation (eg. in-place server hiding its window when
	**    UIDeactivating or IOleObject::DoVerb(OLEVERB_HIDE) is called),
	**    then OLE is told to NOT immediately release the document.
	**    this leaves the document in an unstable state where the next
	**    Lock/Unlock sequence will shut the document down (eg. a
	**    linking client connecting and disconnecting).
	*/
	if (IsWindowVisible(lpOutlineDoc->m_hWndDoc))
		OleDoc_Lock(lpOleDoc, FALSE /* fLock */, fShutdown);

	ShowWindow(((LPOUTLINEDOC)lpOleDoc)->m_hWndDoc, SW_HIDE);

#if defined( OLE_SERVER )
	{
		LPSERVERDOC lpServerDoc = (LPSERVERDOC)lpOleDoc;

		/* OLE2NOTE: if we are an embedded object and we are not
		**    in-place active, we must inform our
		**    embedding container that our window is hiding (closing
		**    from the user's perspective). the container must now
		**    un-hatch our object.
		*/
		if (lpServerDoc->m_lpOleClientSite != NULL
#if defined( INPLACE_SVR )
			&& !lpServerDoc->m_fInPlaceVisible
#endif
		) {
			OLEDBG_BEGIN2("IOleClientSite::OnShowWindow(FALSE) called\r\n");
			lpServerDoc->m_lpOleClientSite->lpVtbl->OnShowWindow(
					lpServerDoc->m_lpOleClientSite,
					FALSE
			);
			OLEDBG_END2
		}
	}
#endif

	/* OLE2NOTE: if there are no more documents visible to the user.
	**    and the app itself is not under user control, then
	**    it has no reason to stay visible. we thus should hide the
	**    app. we can not directly destroy the app, because it may be
	**    validly being used programatically by another client
	**    application and should remain running. it should simply be
	**    hidded from the user.
	*/
	OleApp_HideIfNoReasonToStayVisible(lpOleApp);
	OLEDBG_END3
}


/* OleDoc_Lock
** -----------
**    Lock/Unlock the Doc object. if the last lock is unlocked and
**    fLastUnlockReleases == TRUE, then the Doc object will shut down
**    (ie. it will recieve its final release and its refcnt will go to 0).
*/
HRESULT OleDoc_Lock(LPOLEDOC lpOleDoc, BOOL fLock, BOOL fLastUnlockReleases)
{
	HRESULT hrErr;

#if defined( _DEBUG )
	if (fLock) {
		OLEDBG_BEGIN2("CoLockObjectExternal(lpDoc,TRUE) called\r\n")
	} else {
		if (fLastUnlockReleases)
			OLEDBG_BEGIN2("CoLockObjectExternal(lpDoc,FALSE,TRUE) called\r\n")
		else
			OLEDBG_BEGIN2("CoLockObjectExternal(lpDoc,FALSE,FALSE) called\r\n")
	}
#endif  // _DEBUG

	hrErr = CoLockObjectExternal(
			(LPUNKNOWN)&lpOleDoc->m_Unknown, fLock, fLastUnlockReleases);

	OLEDBG_END2
	return hrErr;
}


/* OleDoc_AddRef
** -------------
**
**  increment the ref count of the document object.
**
**    Returns the new ref count on the object
*/
ULONG OleDoc_AddRef(LPOLEDOC lpOleDoc)
{
	++lpOleDoc->m_cRef;

#if defined( _DEBUG )
	OleDbgOutRefCnt4(
			"OleDoc_AddRef: cRef++\r\n",
			lpOleDoc,
			lpOleDoc->m_cRef
	);
#endif
	return lpOleDoc->m_cRef;
}


/* OleDoc_Release
** --------------
**
**  decrement the ref count of the document object.
**    if the ref count goes to 0, then the document is destroyed.
**
**    Returns the remaining ref count on the object
*/
ULONG OleDoc_Release (LPOLEDOC lpOleDoc)
{
	ULONG cRef;
	LPOUTLINEAPP lpOutlineApp = (LPOUTLINEAPP)g_lpApp;
	LPOLEAPP lpOleApp = (LPOLEAPP)g_lpApp;

	/*********************************************************************
	** OLE2NOTE: when the obj refcnt == 0, then destroy the object.     **
	**     otherwise the object is still in use.                        **
	*********************************************************************/

	cRef = --lpOleDoc->m_cRef;

#if defined( _DEBUG )
	OleDbgAssertSz (lpOleDoc->m_cRef >= 0, "Release called with cRef == 0");

	OleDbgOutRefCnt4(
			"OleDoc_Release: cRef--\r\n", lpOleDoc, cRef);
#endif
	if (cRef == 0)
		OutlineDoc_Destroy((LPOUTLINEDOC)lpOleDoc);

	return cRef;
}


/* OleDoc_QueryInterface
** ---------------------
**
** Retrieve a pointer to an interface on the document object.
**
**    OLE2NOTE: this function will AddRef the ref cnt of the object.
**
**    Returns S_OK if interface is successfully retrieved.
**            E_NOINTERFACE if the interface is not supported
*/
HRESULT OleDoc_QueryInterface(
		LPOLEDOC          lpOleDoc,
		REFIID            riid,
		LPVOID FAR*       lplpvObj
)
{
	LPOUTLINEDOC lpOutlineDoc = (LPOUTLINEDOC)lpOleDoc;
	SCODE sc = E_NOINTERFACE;

	/* OLE2NOTE: we must make sure to set all out ptr parameters to NULL. */
	*lplpvObj = NULL;

	if (IsEqualIID(riid, &IID_IUnknown)) {
		OleDbgOut4("OleDoc_QueryInterface: IUnknown* RETURNED\r\n");

		*lplpvObj = (LPVOID) &lpOleDoc->m_Unknown;
		OleDoc_AddRef(lpOleDoc);
		sc = S_OK;
	}
	else if(lpOutlineDoc->m_fDataTransferDoc
			&& IsEqualIID(riid, &IID_IDataObject)) {
		OleDbgOut4("OleDoc_QueryInterface: IDataObject* RETURNED\r\n");

		*lplpvObj = (LPVOID) &lpOleDoc->m_DataObject;
		OleDoc_AddRef(lpOleDoc);
		sc = S_OK;
	}

	/* OLE2NOTE: if this document is a DataTransferDocument used to
	**    support a clipboard or drag/drop operation, then it should
	**    only expose IUnknown, IDataObject, and IDropSource
	**    interfaces. if the document is a normal user document, then
	**    we will also continue to consider our other interfaces.
	*/
	if (lpOutlineDoc->m_fDataTransferDoc)
		goto done;

	if(IsEqualIID(riid,&IID_IPersist) || IsEqualIID(riid,&IID_IPersistFile)) {
		OleDbgOut4("OleDoc_QueryInterface: IPersistFile* RETURNED\r\n");

		*lplpvObj = (LPVOID) &lpOleDoc->m_PersistFile;
		OleDoc_AddRef(lpOleDoc);
		sc = S_OK;
	}
	else if(IsEqualIID(riid, &IID_IOleItemContainer) ||
			IsEqualIID(riid, &IID_IOleContainer) ||
			IsEqualIID(riid, &IID_IParseDisplayName) ) {
		OleDbgOut4("OleDoc_QueryInterface: IOleItemContainer* RETURNED\r\n");

		*lplpvObj = (LPVOID) &lpOleDoc->m_OleItemContainer;
		OleDoc_AddRef(lpOleDoc);
		sc = S_OK;
	}
	else if(IsEqualIID(riid, &IID_IExternalConnection)) {
		OleDbgOut4("OleDoc_QueryInterface: IExternalConnection* RETURNED\r\n");

		*lplpvObj = (LPVOID) &lpOleDoc->m_ExternalConnection;
		OleDoc_AddRef(lpOleDoc);
		sc = S_OK;
	}

#if defined( USE_DRAGDROP )
	else if(IsEqualIID(riid, &IID_IDropTarget)) {
		OleDbgOut4("OleDoc_QueryInterface: IDropTarget* RETURNED\r\n");

		*lplpvObj = (LPVOID) &lpOleDoc->m_DropTarget;
		OleDoc_AddRef(lpOleDoc);
		sc = S_OK;
	}
	else if(IsEqualIID(riid, &IID_IDropSource)) {
		OleDbgOut4("OleDoc_QueryInterface: IDropSource* RETURNED\r\n");

		*lplpvObj = (LPVOID) &lpOleDoc->m_DropSource;
		OleDoc_AddRef(lpOleDoc);
		sc = S_OK;
	}
#endif

#if defined( OLE_CNTR )
	else if (IsEqualIID(riid, &IID_IOleUILinkContainer)) {
		OleDbgOut4("OleDoc_QueryInterface: IOleUILinkContainer* RETURNED\r\n");

		*lplpvObj=(LPVOID)&((LPCONTAINERDOC)lpOleDoc)->m_OleUILinkContainer;
		OleDoc_AddRef(lpOleDoc);
		sc = S_OK;
	}
#endif

#if defined( OLE_SERVER )

	/* OLE2NOTE: if OLE server version, than also offer the server
	**    specific interfaces: IOleObject and IPersistStorage.
	*/
	else if (IsEqualIID(riid, &IID_IOleObject)) {
		OleDbgOut4("OleDoc_QueryInterface: IOleObject* RETURNED\r\n");

		*lplpvObj = (LPVOID) &((LPSERVERDOC)lpOleDoc)->m_OleObject;
		OleDoc_AddRef(lpOleDoc);
		sc = S_OK;
	}
	else if(IsEqualIID(riid, &IID_IPersistStorage)) {
		OleDbgOut4("OleDoc_QueryInterface: IPersistStorage* RETURNED\r\n");

		*lplpvObj = (LPVOID) &((LPSERVERDOC)lpOleDoc)->m_PersistStorage;
		OleDoc_AddRef(lpOleDoc);
		sc = S_OK;
	}
	else if(IsEqualIID(riid, &IID_IDataObject)) {
		OleDbgOut4("OleDoc_QueryInterface: IDataObject* RETURNED\r\n");

		*lplpvObj = (LPVOID) &lpOleDoc->m_DataObject;
		OleDoc_AddRef(lpOleDoc);
		sc = S_OK;
	}

#if defined( SVR_TREATAS )
	else if(IsEqualIID(riid, &IID_IStdMarshalInfo)) {
		OleDbgOut4("OleDoc_QueryInterface: IStdMarshalInfo* RETURNED\r\n");

		*lplpvObj = (LPVOID) &((LPSERVERDOC)lpOleDoc)->m_StdMarshalInfo;
		OleDoc_AddRef(lpOleDoc);
		sc = S_OK;
	}
#endif  // SVR_TREATAS

#if defined( INPLACE_SVR )
	else if (IsEqualIID(riid, &IID_IOleWindow) ||
			 IsEqualIID(riid, &IID_IOleInPlaceObject)) {
		OleDbgOut4("OleDoc_QueryInterface: IOleInPlaceObject* RETURNED\r\n");

		*lplpvObj = (LPVOID) &((LPSERVERDOC)lpOleDoc)->m_OleInPlaceObject;
		OleDoc_AddRef(lpOleDoc);
		sc = S_OK;
	}
#endif // INPLACE_SVR
#endif // OLE_SERVER

done:
	OleDbgQueryInterfaceMethod(*lplpvObj);

	return ResultFromScode(sc);
}


/* OleDoc_Close
 * ------------
 *
 *  Close the document.
 *      This functions performs the actions that are in common to all
 *      document types which derive from OleDoc (eg. ContainerDoc and
 *      ServerDoc) which are required to close a document.
 *
 *  Returns:
 *      FALSE -- user canceled the closing of the doc.
 *      TRUE -- the doc was successfully closed
 */

BOOL OleDoc_Close(LPOLEDOC lpOleDoc, DWORD dwSaveOption)
{
	LPOLEAPP lpOleApp = (LPOLEAPP)g_lpApp;
	LPOUTLINEAPP lpOutlineApp = (LPOUTLINEAPP)g_lpApp;
	LPOLEDOC lpClipboardDoc;
	LPLINELIST lpLL     = (LPLINELIST)&((LPOUTLINEDOC)lpOleDoc)->m_LineList;
	BOOL fAbortIfSaveCanceled = (dwSaveOption == OLECLOSE_PROMPTSAVE);

	if (! lpOleDoc)
		return TRUE;    // active doc's are already destroyed

	if (lpOleDoc->m_fObjIsClosing)
		return TRUE;    // Closing is already in progress

	OLEDBG_BEGIN3("OleDoc_Close\r\n")

	if (! OutlineDoc_CheckSaveChanges((LPOUTLINEDOC)lpOleDoc,&dwSaveOption)
			&& fAbortIfSaveCanceled) {
		OLEDBG_END3
		return FALSE;           // cancel closing the doc
	}

	lpOleDoc->m_fObjIsClosing = TRUE;   // guard against recursive call

	/* OLE2NOTE: in order to have a stable app and doc during the
	**    process of closing, we intially AddRef the App and Doc ref
	**    cnts and later Release them. These initial AddRefs are
	**    artificial; they simply guarantee that these objects do not
	**    get destroyed until the end of this routine.
	*/
	OleApp_AddRef(lpOleApp);
	OleDoc_AddRef(lpOleDoc);

#if defined( OLE_CNTR )
	{
		LPCONTAINERDOC lpContainerDoc = (LPCONTAINERDOC)lpOleDoc;

		/* OLE2NOTE: force all OLE objects to close. this forces all
		**    OLE object to transition from running to loaded. we can
		**    NOT exit if any embeddings are still running.
		**    if an object can't be closed and this close operation was
		**    started by the user, then we will abort closing our document.
		*/
		if (! ContainerDoc_CloseAllOleObjects(lpContainerDoc, OLECLOSE_NOSAVE)
				&& fAbortIfSaveCanceled) {
			OleDoc_Release(lpOleDoc);       // release artificial AddRef above
			OleApp_Release(lpOleApp);       // release artificial AddRef above
			lpOleDoc->m_fObjIsClosing = FALSE; // clear recursion guard

			OLEDBG_END3
			return FALSE;   // Closing is aborted
		}
	}
#endif

#if defined( INPLACE_SVR )
	/* OLE2NOTE: if the server is currently in-place active we must
	**    deactivate it now before closing
	*/
	ServerDoc_DoInPlaceDeactivate((LPSERVERDOC)lpOleDoc);
#endif

	/* OLE2NOTE: if this document is the source of data for the
	**    clipboard, then flush the clipboard. it is important to flush
	**    the clipboard BEFORE calling sending any notifications to
	**    clients (eg. IOleClientSite::OnShowWindow(FALSE)) which could
	**    give them a chance to run and try to get our clipboard data
	**    object that we want to destroy. (eg. our app tries to
	**    update the paste button of the toolbar when
	**    WM_ACTIVATEAPP is received.)
	*/
	lpClipboardDoc = (LPOLEDOC)lpOutlineApp->m_lpClipboardDoc;
	if (lpClipboardDoc &&
		lpClipboardDoc->m_lpSrcDocOfCopy == lpOleDoc) {
		OleApp_FlushClipboard(lpOleApp);
	}

	/* OLE2NOTE: Revoke the object from the Running Object Table. it is
	**    best if the object is revoke prior to calling
	**    COLockObjectExternal(FALSE,TRUE) which is called when the
	**    document window is hidden from the user.
	*/
	OLEDBG_BEGIN3("OleStdRevokeAsRunning called\r\n")
	OleStdRevokeAsRunning(&lpOleDoc->m_dwRegROT);
	OLEDBG_END3

	/* OLE2NOTE: if the user is in control of the document, the user
	**    accounts for one refcnt on the document. Closing the
	**    document is achieved by releasing the object on behalf of
	**    the user. if the document is not referenced by any other
	**    clients, then the document will also be destroyed. if it
	**    is referenced by other clients, then it will remain until
	**    they release it. it is important to hide the window and call
	**    IOleClientSite::OnShowWindow(FALSE) BEFORE sending OnClose
	**    notification.
	*/
	OleDoc_HideWindow(lpOleDoc, TRUE);

#if defined( OLE_SERVER )
	{
		LPSERVERDOC lpServerDoc = (LPSERVERDOC)lpOleDoc;
		LPSERVERNAMETABLE lpServerNameTable =
			(LPSERVERNAMETABLE)((LPOUTLINEDOC)lpOleDoc)->m_lpNameTable;

		/* OLE2NOTE: force all pseudo objects to close. this informs all
		**    linking clients of pseudo objects to release their PseudoObj.
		*/
		ServerNameTable_CloseAllPseudoObjs(lpServerNameTable);

		/* OLE2NOTE: send last OnDataChange notification to clients
		**    that have registered for data notifications when object
		**    stops running (ADVF_DATAONSTOP), if the data in our
		**    object has ever changed. it is best to only send this
		**    notification if necessary.
		*/
		if (lpServerDoc->m_lpDataAdviseHldr) {
			if (lpServerDoc->m_fSendDataOnStop) {
				ServerDoc_SendAdvise(
						(LPSERVERDOC)lpOleDoc,
						OLE_ONDATACHANGE,
						NULL,   /* lpmkDoc -- not relevant here */
						ADVF_DATAONSTOP
				);
			}
			/* OLE2NOTE: we just sent the last data notification that we
			**    need to send; release our DataAdviseHolder. we SHOULD be
			**    the only one using it.
			*/

			OleStdVerifyRelease(
					(LPUNKNOWN)lpServerDoc->m_lpDataAdviseHldr,
					"DataAdviseHldr not released properly"
			);
			lpServerDoc->m_lpDataAdviseHldr = NULL;
		}

		// OLE2NOTE: inform all of our linking clients that we are closing.


		if (lpServerDoc->m_lpOleAdviseHldr) {
			ServerDoc_SendAdvise(
					(LPSERVERDOC)lpOleDoc,
					OLE_ONCLOSE,
					NULL,   /* lpmkDoc -- not relevant here */
					0       /* advf -- not relevant here */
			);

			/* OLE2NOTE: OnClose is the last notification that we need to
			**    send; release our OleAdviseHolder. we SHOULD be the only
			**    one using it. this will make our destructor realize that
			**    OnClose notification has already been sent.
			*/
			OleStdVerifyRelease(
					(LPUNKNOWN)lpServerDoc->m_lpOleAdviseHldr,
					"OleAdviseHldr not released properly"
			);
			lpServerDoc->m_lpOleAdviseHldr = NULL;
		}

		/* release our Container's ClientSite. */
		if(lpServerDoc->m_lpOleClientSite) {
			OleStdRelease((LPUNKNOWN)lpServerDoc->m_lpOleClientSite);
			lpServerDoc->m_lpOleClientSite = NULL;
		}
	}
#endif

	if (lpOleDoc->m_lpLLStm) {
		/* release our LineList stream. */
		OleStdRelease((LPUNKNOWN)lpOleDoc->m_lpLLStm);
		lpOleDoc->m_lpLLStm = NULL;
	}

	if (lpOleDoc->m_lpNTStm) {
		/* release our NameTable stream. */
		OleStdRelease((LPUNKNOWN)lpOleDoc->m_lpNTStm);
		lpOleDoc->m_lpNTStm = NULL;
	}

	if (lpOleDoc->m_lpStg) {
		/* release our doc storage. */
		OleStdRelease((LPUNKNOWN)lpOleDoc->m_lpStg);
		lpOleDoc->m_lpStg = NULL;
	}

	if (lpOleDoc->m_lpFileMoniker) {
		OleStdRelease((LPUNKNOWN)lpOleDoc->m_lpFileMoniker);
		lpOleDoc->m_lpFileMoniker = NULL;
	}

	/* OLE2NOTE: this call forces all external connections to our
	**    object to close down and therefore guarantees that we receive
	**    all releases associated with those external connections.
	*/
	OLEDBG_BEGIN2("CoDisconnectObject(lpDoc) called\r\n")
	CoDisconnectObject((LPUNKNOWN)&lpOleDoc->m_Unknown, 0);
	OLEDBG_END2

	OleDoc_Release(lpOleDoc);       // release artificial AddRef above
	OleApp_Release(lpOleApp);       // release artificial AddRef above

	OLEDBG_END3
	return TRUE;
}


/* OleDoc_Destroy
 * --------------
 *
 *  Free all OLE related resources that had been allocated for a document.
 */
void OleDoc_Destroy(LPOLEDOC lpOleDoc)
{
	LPOUTLINEAPP lpOutlineApp = (LPOUTLINEAPP)g_lpApp;
	LPOUTLINEDOC lpOutlineDoc = (LPOUTLINEDOC)lpOleDoc;

	if (lpOleDoc->m_fObjIsDestroying)
		return;     // Doc destruction is already in progress

	lpOleDoc->m_fObjIsDestroying = TRUE;    // guard against recursive call

#if defined( OLE_SERVER )

	/* OLE2NOTE: it is ALWAYS necessary to make sure that the work we
	**    do in our OleDoc_Close function is performed before we
	**    destroy our document object. this includes revoking from the
	**    Running Object Table (ROT), sending OnClose notification,
	**    revoking from Drag/Drop, closing all pseudo objects, etc.
	**    There are some tricky scenarios involving linking and
	**    when IOleObject::Close is called versus when we get our
	**    final release causing us to call our OleDoc_Destroy
	**    (destructor) function.
	**
	**    SCENARIO 1 -- closing from server (File.Exit or File.Close)
	**                  OleDoc_Close function is called directly by the
	**                  server in response to the menu command
	**                  (WM_COMMAND processing).
	**
	**    SCENARIO 2 -- closed by embedding container
	**                  our embedding container calls IOleObject::Close
	**                  directly.
	**
	**    SCENARIO 3 -- silent-update final release
	**                  THIS IS THE TRICKY ONE!!!
	**                  in the case that our object is launched because
	**                  a linking client calls IOleObject::Update on
	**                  its link, then our object will be run
	**                  invisibly, typically GetData will be called,
	**                  and then the connection from the linking client
	**                  will be released. the release of this last
	**                  linking connection should cause our object to
	**                  shut down.
	**                  there are 2 strategies to deal with this scenario:
	**
	**                  STRATEGY 1 -- implement IExternalConnection.
	**                  IExternalConnection::AddConnection will be
	**                  called (by the StubManager) every time that an
	**                  external (linking) connection is created or
	**                  CoLockObjectExternal is called. the object
	**                  should maintain a count of strong connections
	**                  (m_dwStrongExtConn). IExternalConnection::
	**                  ReleaseConnection will be called when these
	**                  connections are released. when the
	**                  m_dwStrongExtConn transistions to 0, the object
	**                  should call its IOleObject::Close function.
	**                  this assumes that CoLockObjectExternal is used
	**                  to manage locks by the object itself (eg. when
	**                  the object is visible to the user--fUserCtrl,
	**                  and when PseudoObjects are created, etc.)
	**                  this is the strategy implemented by SVROUTL.
	**
	**                  STRATEGY 2 -- guard both the destructor
	**                  function and the Close function. if the
	**                  destructor is called directly without Close
	**                  first being called, then call Close before
	**                  proceeding with the destruction code.
	**                  previously SVROUTL was organized in this
	**                  manner. that old code is conditionaly compiled
	**                  away with "#ifdef OBSOLETE" below. this
	**                  method has the disadvantage that external
	**                  remoting is no longer possible by the time the
	**                  Close is called making it impossible for
	**                  the object to ask its container to save the
	**                  object if the object is dirty. this can result
	**                  in data loss. thus STRATEGY 1 is safer.
	**                  consider the scenario where an in-place
	**                  container UIDeactivates an object but does NOT
	**                  keep the object locked running (this is
	**                  required--see CntrLine_IPSite_OnInPlaceActivate
	**                  in cntrline.c), then, if a linking client binds
	**                  and unbinds from the object, the object will be
	**                  destroyed and will NOT have an opportunity to
	**                  be saved. by implementing IExternalConnection,
	**                  a server can insulate itself from a poorly
	**                  written container.
	*/
#if defined( _DEBUG )

#ifndef WIN32
	// this is not a valid assert in Ole32; if file moniker binding
	// fails, for example, we will only get releases coming in
	// (no external connections are involved because OLE32 does a
	// private rpc to the server (us) where the IPersistFile::Load is
	// done.

	OleDbgAssertSz(
			(lpOutlineDoc->m_fDataTransferDoc || lpOleDoc->m_fObjIsClosing),
			"Destroy called without Close being called\r\n"
	);
#endif //!WIN32

#endif  // _DEBUG
#if defined( OBSOLETE )
	/* OLE2NOTE: if the document destructor is called directly because
	**    the object's refcnt went to 0 (ie. without OleDoc_Close first
	**    being called), then we need to make sure that the document is
	**    properly closed before destroying the object. this scenario
	**    could arise during a silent-update of a link. calling
	**    OleDoc_Close here guarantees that the clipboard will be
	**    properly flushed, the doc's moniker will be properly revoked,
	**    the document will be saved if necessary, etc.
	*/
	if (!lpOutlineDoc->m_fDataTransferDoc && !lpOleDoc->m_fObjIsClosing)
		OleDoc_Close(lpOleDoc, OLECLOSE_NOSAVE);
#endif

	{
		LPSERVERDOC lpServerDoc = (LPSERVERDOC)lpOleDoc;
		/* OLE2NOTE: perform processing specific for an OLE server */

#if defined( SVR_TREATAS )
		if (lpServerDoc->m_lpszTreatAsType) {
			OleStdFreeString(lpServerDoc->m_lpszTreatAsType, NULL);
			lpServerDoc->m_lpszTreatAsType = NULL;
		}
#endif  // SVR_TREATAS

#if defined( INPLACE_SVR )
		if (IsWindow(lpServerDoc->m_hWndHatch))
			DestroyWindow(lpServerDoc->m_hWndHatch);
#endif  // INPLACE_SVR
	}
#endif  // OLE_SERVER

	if (lpOleDoc->m_lpLLStm) {
		/* release our LineList stream. */
		OleStdRelease((LPUNKNOWN)lpOleDoc->m_lpLLStm);
		lpOleDoc->m_lpLLStm = NULL;
	}

	if (lpOleDoc->m_lpNTStm) {
		/* release our NameTable stream. */
		OleStdRelease((LPUNKNOWN)lpOleDoc->m_lpNTStm);
		lpOleDoc->m_lpNTStm = NULL;
	}

	if (lpOleDoc->m_lpStg) {
		/* release our doc storage. */
		OleStdRelease((LPUNKNOWN)lpOleDoc->m_lpStg);
		lpOleDoc->m_lpStg = NULL;
	}

	if (lpOleDoc->m_lpFileMoniker) {
		OleStdRelease((LPUNKNOWN)lpOleDoc->m_lpFileMoniker);
		lpOleDoc->m_lpFileMoniker = NULL;
	}

	/*****************************************************************
	** OLE2NOTE: each document addref's the app object in order to  **
	**    guarentee that the app does not shut down while the doc   **
	**    is still open. since this doc is now destroyed, we will   **
	**    release this refcnt now. if there are now more open       **
	**    documents AND the app is not under the control of the     **
	**    user (ie. launched by OLE) then the app will revoke its   **
	**    ClassFactory. if there are no more references to the      **
	**    ClassFactory after it is revoked, then the app will shut  **
	**    down. this whole procedure is triggered by calling        **
	**    OutlineApp_DocUnlockApp.                                  **
	*****************************************************************/

	OutlineApp_DocUnlockApp(lpOutlineApp, lpOutlineDoc);
}


/* OleDoc_SetUpdateEditMenuFlag
 * ----------------------------
 *
 *  Purpose:
 *      Set/clear the UpdateEditMenuFlag in OleDoc.
 *
 *  Parameters:
 *      fUpdate     new value of the flag
 *
 *  Returns:
 */
void OleDoc_SetUpdateEditMenuFlag(LPOLEDOC lpOleDoc, BOOL fUpdate)
{
	if (!lpOleDoc)
		return;

	lpOleDoc->m_fUpdateEditMenu = fUpdate;
}


/* OleDoc_GetUpdateEditMenuFlag
 * ----------------------------
 *
 *  Purpose:
 *      Get the value of the UpdateEditMenuFlag in OleDoc
 *
 *  Parameters:
 *
 *  Returns:
 *      value of the flag
 */
BOOL OleDoc_GetUpdateEditMenuFlag(LPOLEDOC lpOleDoc)
{
	if (!lpOleDoc)
		return FALSE;

	return lpOleDoc->m_fUpdateEditMenu;
}



/*************************************************************************
** OleDoc::IUnknown interface implementation
*************************************************************************/

STDMETHODIMP OleDoc_Unk_QueryInterface(
		LPUNKNOWN           lpThis,
		REFIID              riid,
		LPVOID FAR*         lplpvObj
)
{
	LPOLEDOC lpOleDoc = ((struct CDocUnknownImpl FAR*)lpThis)->lpOleDoc;

	return OleDoc_QueryInterface(lpOleDoc, riid, lplpvObj);
}


STDMETHODIMP_(ULONG) OleDoc_Unk_AddRef(LPUNKNOWN lpThis)
{
	LPOLEDOC lpOleDoc = ((struct CDocUnknownImpl FAR*)lpThis)->lpOleDoc;

	OleDbgAddRefMethod(lpThis, "IUnknown");

	return OleDoc_AddRef(lpOleDoc);
}


STDMETHODIMP_(ULONG) OleDoc_Unk_Release (LPUNKNOWN lpThis)
{
	LPOLEDOC lpOleDoc = ((struct CDocUnknownImpl FAR*)lpThis)->lpOleDoc;

	OleDbgReleaseMethod(lpThis, "IUnknown");

	return OleDoc_Release(lpOleDoc);
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\letest\outline\oleoutl.h ===
/*************************************************************************
**
**    OLE 2.0 Sample Code
**
**    oleoutl.h
**
**    This file contains file contains data structure defintions,
**    function prototypes, constants, etc. which are common to the
**    server version and the container version of the app.
**    app version of the Outline series of sample applications:
**          Outline -- base version of the app (without OLE functionality)
**          SvrOutl -- OLE 2.0 Server sample app
**          CntrOutl -- OLE 2.0 Containter sample app
**
**    (c) Copyright Microsoft Corp. 1992 - 1993 All Rights Reserved
**
*************************************************************************/

#if !defined( _OLEOUTL_H_ )
#define _OLEOUTL_H_

#ifndef RC_INVOKED
#pragma message ("INCLUDING OLEOUTL.H from " __FILE__)
// make 'different levels of inderection' considered an error
#pragma warning (error:4047)
#endif  /* RC_INVOKED */

#if defined( USE_MSGFILTER )
#include "msgfiltr.h"
#endif  // USE_MSGFILTER

#include "defguid.h"

/* Defines */

/* OLE2NOTE: these strings should correspond to the strings registered
**    in the registration database.
*/
// REVIEW: should load strings from resource file
#if defined( INPLACE_SVR )
#define CLSID_APP   CLSID_ISvrOtl
#define FULLUSERTYPENAME    "Ole 2.0 In-Place Server Outline"
#define SHORTUSERTYPENAME   "Outline"   // max 15 chars
#undef  APPFILENAMEFILTER
#define APPFILENAMEFILTER   "Outline Files (*.OLN)|*.oln|All files (*.*)|*.*|"
#undef  DEFEXTENSION
#define DEFEXTENSION    "oln"           // Default file extension
#endif  // INPLACE_SVR

#if defined( INPLACE_CNTR )
#define CLSID_APP   CLSID_ICntrOtl
#define FULLUSERTYPENAME    "Ole 2.0 In-Place Container Outline"
// #define SHORTUSERTYPENAME    "Outline"   // max 15 chars
#undef  APPFILENAMEFILTER
#define APPFILENAMEFILTER   "CntrOutl Files (*.OLC)|*.olc|Outline Files (*.OLN)|*.oln|All files (*.*)|*.*|"
#undef  DEFEXTENSION
#define DEFEXTENSION    "olc"           // Default file extension
#endif  // INPLACE_CNTR

#if defined( OLE_SERVER ) && !defined( INPLACE_SVR )
#define CLSID_APP   CLSID_SvrOutl
#define FULLUSERTYPENAME    "Ole 2.0 Server Sample Outline"
#define SHORTUSERTYPENAME   "Outline"
#undef  APPFILENAMEFILTER
#define APPFILENAMEFILTER   "Outline Files (*.OLN)|*.oln|All files (*.*)|*.*|"
#undef  DEFEXTENSION
#define DEFEXTENSION    "oln"           // Default file extension
#endif  // OLE_SERVER && ! INPLACE_SVR

#if defined( OLE_CNTR ) && !defined( INPLACE_CNTR )
#define CLSID_APP   CLSID_CntrOutl
#define FULLUSERTYPENAME    "Ole 2.0 Container Sample Outline"
// #define SHORTUSERTYPENAME    "Outline"  // max 15 chars
#undef  APPFILENAMEFILTER
#define APPFILENAMEFILTER   "CntrOutl Files (*.OLC)|*.olc|Outline Files (*.OLN)|*.oln|All files (*.*)|*.*|"
#undef  DEFEXTENSION
#define DEFEXTENSION    "olc"           // Default file extension
#endif  // OLE_CNTR && ! INPLACE_CNTR

// Maximum number of formats offered by IDataObject::GetData/SetData
#define MAXNOFMTS       10
#define MAXNOLINKTYPES   3

#if defined( USE_DRAGDROP )
#define DD_SEL_THRESH       HITTESTDELTA    // Border threshold to start drag
#define MAX_SEL_ITEMS       0x0080
#endif  // USE_DRAGDROP

/* Positions of the various menus */
#define POS_FILEMENU        0
#define POS_EDITMENU        1
#define POS_VIEWMENU        2
#define POS_LINEMENU        3
#define POS_NAMEMENU        4
#define POS_OPTIONSMENU     5
#define POS_DEBUGMENU       6
#define POS_HELPMENU        7


#define POS_OBJECT      11


/* Types */

// Document initialization type
#define DOCTYPE_EMBEDDED    3   // init from an IStorage* of an embedded obj
#define DOCTYPE_FROMSTG     4   // init from an IStorage* with doc bit set

/* Forward type definitions */
typedef struct tagOLEAPP FAR* LPOLEAPP;
typedef struct tagOLEDOC FAR* LPOLEDOC;

/* Flags to control Moniker assignment for OleDoc_GetFullMoniker */
// REVIEW: should use official OLEGETMONIKER type for final version
typedef enum tagGETMONIKERTYPE {
	GETMONIKER_ONLYIFTHERE  = 1,
	GETMONIKER_FORCEASSIGN  = 2,
	GETMONIKER_UNASSIGN     = 3,
	GETMONIKER_TEMPFORUSER  = 4
} GETMONIKERTYPE;

/* Flags to control direction for drag scrolling */
typedef enum tagSCROLLDIR {
	SCROLLDIR_NULL          = 0,
	SCROLLDIR_UP            = 1,
	SCROLLDIR_DOWN          = 2,
	SCROLLDIR_RIGHT         = 3,    // currently not used
	SCROLLDIR_LEFT          = 4     // currently not used
} SCROLLDIR;


/*************************************************************************
** class OLEDOC : OUTLINEDOC
**    OLEDOC is an extention to the base OUTLINEDOC object (structure)
**    that adds common OLE 2.0 functionality used by both the server
**    and container versions. This is an abstract class. You do not
**    instantiate an instance of OLEDOC directly but instead
**    instantiate one of its concrete subclasses: SERVERDOC or
**    CONTAINERDOC. There is one instance of an document
**    object created per document open in the app. The SDI
**    version of the app supports one ServerDoc at a time. The MDI
**    version of the app can manage multiple documents at one time.
**    The OLEDOC class inherits all fields from the OUTLINEDOC class.
**    This inheritance is achieved by including a member variable of
**    type OUTLINEDOC as the first field in the OLEDOC
**    structure. Thus a pointer to an OLEDOC object can be cast to be
**    a pointer to a OUTLINEDOC object.
*************************************************************************/

typedef struct tagOLEDOC {
	OUTLINEDOC      m_OutlineDoc;       // ServerDoc inherits from OutlineDoc
	ULONG           m_cRef;             // total ref count for document
	ULONG           m_dwStrongExtConn;  // total strong connection count
					    //	(from IExternalConnection)
					    //	when this count transitions to 0
					    //	and fLastUnlockCloses==TRUE, then
					    //	IOleObject::Close is called to
					    //	close the document.
#if defined( _DEBUG )
	ULONG           m_cCntrLock;        // total count of LockContainer locks
										//  (for debugging purposes only)
#endif
	LPSTORAGE       m_lpStg;            // OleDoc must keep its stg open
										//  even in-memory server doc should
										//  keep Stg open for low memory save
	LPSTREAM        m_lpLLStm;          // Hold LineList IStream* open for
										//  low memory save
	LPSTREAM        m_lpNTStm;          // Hold NameTable IStream* open for
										//  low memory save
	BOOL            m_fObjIsClosing;    // flag to guard recursive close call
	BOOL            m_fObjIsDestroying; // flag to guard recursiv destroy call
	DWORD           m_dwRegROT;         // key if doc registered as running
	LPMONIKER       m_lpFileMoniker;    // moniker if file-based/untitled doc
	BOOL            m_fLinkSourceAvail; // can doc offer CF_LINKSOURCE
	LPOLEDOC        m_lpSrcDocOfCopy;   // src doc if doc created for copy
	BOOL            m_fUpdateEditMenu;  // need to update edit menu??

#if defined( USE_DRAGDROP )
	DWORD           m_dwTimeEnterScrollArea;  // time entering scroll region
	DWORD           m_dwLastScrollDir;  // current dir for drag scroll
	DWORD           m_dwNextScrollTime; // time for next scroll
	BOOL            m_fRegDragDrop;     // is doc registered as drop target?
	BOOL            m_fLocalDrag;       // is doc source of the drag
	BOOL            m_fLocalDrop;       // was doc target of the drop
	BOOL            m_fCanDropCopy;     // is Drag/Drop copy/move possible?
	BOOL            m_fCanDropLink;     // is Drag/Drop link possible?
	BOOL            m_fDragLeave;       // has drag left
	BOOL            m_fPendingDrag;     // LButtonDown--possible drag pending
	POINT           m_ptButDown;        // LButtonDown coordinates
#endif  // USE_DRAGDROP

#if defined( INPLACE_SVR ) || defined( INPLACE_CNTR )
	BOOL            m_fCSHelpMode;      // Shift-F1 context help mode
#endif

	struct CDocUnknownImpl {
		IUnknownVtbl FAR*       lpVtbl;
		LPOLEDOC                lpOleDoc;
		int                     cRef;   // interface specific ref count.
	} m_Unknown;

	struct CDocPersistFileImpl {
		IPersistFileVtbl FAR*   lpVtbl;
		LPOLEDOC                lpOleDoc;
		int                     cRef;   // interface specific ref count.
	} m_PersistFile;

	struct CDocOleItemContainerImpl {
		IOleItemContainerVtbl FAR*  lpVtbl;
		LPOLEDOC                    lpOleDoc;
		int                         cRef;   // interface specific ref count.
	} m_OleItemContainer;

	struct CDocExternalConnectionImpl {
		IExternalConnectionVtbl FAR* lpVtbl;
		LPOLEDOC                lpOleDoc;
		int                     cRef;   // interface specific ref count.
	} m_ExternalConnection;

	struct CDocDataObjectImpl {
		IDataObjectVtbl FAR*        lpVtbl;
		LPOLEDOC                    lpOleDoc;
		int                         cRef;   // interface specific ref count.
	} m_DataObject;

#ifdef USE_DRAGDROP
	struct CDocDropSourceImpl {
		IDropSourceVtbl FAR*    lpVtbl;
		LPOLEDOC                lpOleDoc;
		int                     cRef;   // interface specific ref count.
	} m_DropSource;

	struct CDocDropTargetImpl {
		IDropTargetVtbl FAR*    lpVtbl;
		LPOLEDOC                lpOleDoc;
		int                     cRef;   // interface specific ref count.
	} m_DropTarget;
#endif  // USE_DRAGDROP

} OLEDOC;

/* OleDoc methods (functions) */
BOOL OleDoc_Init(LPOLEDOC lpOleDoc, BOOL fDataTransferDoc);
BOOL OleDoc_InitNewFile(LPOLEDOC lpOleDoc);
void OleDoc_ShowWindow(LPOLEDOC lpOleDoc);
void OleDoc_HideWindow(LPOLEDOC lpOleDoc, BOOL fShutDown);
HRESULT OleDoc_Lock(LPOLEDOC lpOleDoc, BOOL fLock, BOOL fLastUnlockReleases);
ULONG OleDoc_AddRef(LPOLEDOC lpOleDoc);
ULONG OleDoc_Release (LPOLEDOC lpOleDoc);
HRESULT OleDoc_QueryInterface(
		LPOLEDOC          lpOleDoc,
		REFIID            riid,
		LPVOID FAR*       lplpUnk
);
BOOL OleDoc_Close(LPOLEDOC lpOleDoc, DWORD dwSaveOption);
void OleDoc_Destroy(LPOLEDOC lpOleDoc);
void OleDoc_SetUpdateEditMenuFlag(LPOLEDOC lpOleDoc, BOOL fUpdate);
BOOL OleDoc_GetUpdateEditMenuFlag(LPOLEDOC lpOleDoc);
void OleDoc_GetExtent(LPOLEDOC lpOleDoc, LPSIZEL lpsizel);
HGLOBAL OleDoc_GetObjectDescriptorData(
		LPOLEDOC            lpOleDoc,
		LPLINERANGE         lplrSel
);
LPMONIKER OleDoc_GetFullMoniker(LPOLEDOC lpOleDoc, DWORD dwAssign);
void OleDoc_GetExtent(LPOLEDOC lpOleDoc, LPSIZEL lpsizel);
void OleDoc_DocRenamedUpdate(LPOLEDOC lpOleDoc, LPMONIKER lpmkDoc);
void OleDoc_CopyCommand(LPOLEDOC lpSrcOleDoc);
void OleDoc_PasteCommand(LPOLEDOC lpOleDoc);
void OleDoc_PasteSpecialCommand(LPOLEDOC lpOleDoc);
LPOUTLINEDOC OleDoc_CreateDataTransferDoc(LPOLEDOC lpSrcOleDoc);
BOOL OleDoc_PasteFromData(
		LPOLEDOC            lpOleDoc,
		LPDATAOBJECT        lpSrcDataObj,
		BOOL                fLocalDataObj,
		BOOL                fLink
);
BOOL OleDoc_PasteFormatFromData(
		LPOLEDOC            lpOleDoc,
		CLIPFORMAT          cfFormat,
		LPDATAOBJECT        lpSrcDataObj,
		BOOL                fLocalDataObj,
		BOOL                fLink,
		BOOL                fDisplayAsIcon,
		HGLOBAL             hMetaPict,
		LPSIZEL             lpSizelInSrc
);
BOOL OleDoc_QueryPasteFromData(
		LPOLEDOC            lpOleDoc,
		LPDATAOBJECT        lpSrcDataObj,
		BOOL                fLink
);

#if defined( USE_DRAGDROP )

BOOL OleDoc_QueryDrag( LPOLEDOC lpOleDoc, int y );
BOOL OleDoc_QueryDrop (
	LPOLEDOC        lpOleDoc,
	DWORD           grfKeyState,
	POINTL          pointl,
	BOOL            fDragScroll,
	LPDWORD         lpdwEffect
);
DWORD OleDoc_DoDragDrop (LPOLEDOC lpSrcOleDoc);
BOOL OleDoc_DoDragScroll(LPOLEDOC lpOleDoc, POINTL pointl);

#endif  // USE_DRAGDROP

/* OleDoc::IUnknown methods (functions) */
STDMETHODIMP OleDoc_Unk_QueryInterface(
		LPUNKNOWN           lpThis,
		REFIID              riid,
		LPVOID FAR*         lplpvObj
);
STDMETHODIMP_(ULONG) OleDoc_Unk_AddRef(LPUNKNOWN lpThis);
STDMETHODIMP_(ULONG) OleDoc_Unk_Release (LPUNKNOWN lpThis);

/* OleDoc::IPersistFile methods (functions) */
STDMETHODIMP OleDoc_PFile_QueryInterface(
		LPPERSISTFILE       lpThis,
		REFIID              riid,
		LPVOID FAR*         lplpvObj
);
STDMETHODIMP_(ULONG) OleDoc_PFile_AddRef(LPPERSISTFILE lpThis);
STDMETHODIMP_(ULONG) OleDoc_PFile_Release (LPPERSISTFILE lpThis);
STDMETHODIMP OleDoc_PFile_GetClassID (
		LPPERSISTFILE       lpThis,
		CLSID FAR*          lpclsid
);
STDMETHODIMP  OleDoc_PFile_IsDirty(LPPERSISTFILE lpThis);
STDMETHODIMP OleDoc_PFile_Load (
		LPPERSISTFILE       lpThis,
		LPCOLESTR	    lpszFileName,
		DWORD               grfMode
);
STDMETHODIMP OleDoc_PFile_Save (
		LPPERSISTFILE       lpThis,
		LPCOLESTR	    lpszFileName,
		BOOL                fRemember
);
STDMETHODIMP OleDoc_PFile_SaveCompleted (
		LPPERSISTFILE       lpThis,
		LPCOLESTR	    lpszFileName
);
STDMETHODIMP OleDoc_PFile_GetCurFile (
		LPPERSISTFILE   lpThis,
		LPOLESTR FAR*	lplpszFileName
);

/* OleDoc::IOleItemContainer methods (functions) */
STDMETHODIMP OleDoc_ItemCont_QueryInterface(
		LPOLEITEMCONTAINER  lpThis,
		REFIID              riid,
		LPVOID FAR*         lplpvObj
);
STDMETHODIMP_(ULONG) OleDoc_ItemCont_AddRef(LPOLEITEMCONTAINER lpThis);
STDMETHODIMP_(ULONG) OleDoc_ItemCont_Release(LPOLEITEMCONTAINER lpThis);
STDMETHODIMP OleDoc_ItemCont_ParseDisplayName(
		LPOLEITEMCONTAINER  lpThis,
		LPBC                lpbc,
		LPOLESTR	    lpszDisplayName,
		ULONG FAR*          lpchEaten,
		LPMONIKER FAR*      lplpmkOut
);

STDMETHODIMP OleDoc_ItemCont_EnumObjects(
		LPOLEITEMCONTAINER  lpThis,
		DWORD               grfFlags,
		LPENUMUNKNOWN FAR*  lplpenumUnknown
);
STDMETHODIMP OleDoc_ItemCont_LockContainer(
		LPOLEITEMCONTAINER  lpThis,
		BOOL                fLock
);
STDMETHODIMP OleDoc_ItemCont_GetObject(
		LPOLEITEMCONTAINER  lpThis,
		LPOLESTR	    lpszItem,
		DWORD               dwSpeedNeeded,
		LPBINDCTX           lpbc,
		REFIID              riid,
		LPVOID FAR*         lplpvObject
);
STDMETHODIMP OleDoc_ItemCont_GetObjectStorage(
		LPOLEITEMCONTAINER  lpThis,
		LPOLESTR	    lpszItem,
		LPBINDCTX           lpbc,
		REFIID              riid,
		LPVOID FAR*         lplpvStorage
);
STDMETHODIMP OleDoc_ItemCont_IsRunning(
		LPOLEITEMCONTAINER  lpThis,
		LPOLESTR	    lpszItem
);

/* OleDoc::IPersistFile methods (functions) */
STDMETHODIMP OleDoc_ExtConn_QueryInterface(
		LPEXTERNALCONNECTION    lpThis,
		REFIID                  riid,
		LPVOID FAR*             lplpvObj
);
STDMETHODIMP_(ULONG) OleDoc_ExtConn_AddRef(LPEXTERNALCONNECTION lpThis);
STDMETHODIMP_(ULONG) OleDoc_ExtConn_Release (LPEXTERNALCONNECTION lpThis);
STDMETHODIMP_(DWORD) OleDoc_ExtConn_AddConnection(
		LPEXTERNALCONNECTION    lpThis,
		DWORD                   extconn,
		DWORD                   reserved
);
STDMETHODIMP_(DWORD) OleDoc_ExtConn_ReleaseConnection(
		LPEXTERNALCONNECTION    lpThis,
		DWORD                   extconn,
		DWORD                   reserved,
		BOOL                    fLastReleaseCloses
);

/* OleDoc::IDataObject methods (functions) */
STDMETHODIMP OleDoc_DataObj_QueryInterface (
		LPDATAOBJECT        lpThis,
		REFIID              riid,
		LPVOID FAR*         lplpvObj
);
STDMETHODIMP_(ULONG) OleDoc_DataObj_AddRef(LPDATAOBJECT lpThis);
STDMETHODIMP_(ULONG) OleDoc_DataObj_Release (LPDATAOBJECT lpThis);
STDMETHODIMP OleDoc_DataObj_GetData (
		LPDATAOBJECT        lpThis,
		LPFORMATETC         lpFormatetc,
		LPSTGMEDIUM         lpMedium
);
STDMETHODIMP OleDoc_DataObj_GetDataHere (
		LPDATAOBJECT        lpThis,
		LPFORMATETC         lpFormatetc,
		LPSTGMEDIUM         lpMedium
);
STDMETHODIMP OleDoc_DataObj_QueryGetData (
		LPDATAOBJECT        lpThis,
		LPFORMATETC         lpFormatetc
);
STDMETHODIMP OleDoc_DataObj_GetCanonicalFormatEtc(
		LPDATAOBJECT        lpThis,
		LPFORMATETC         lpformatetc,
		LPFORMATETC         lpformatetcOut
);
STDMETHODIMP OleDoc_DataObj_SetData (
		LPDATAOBJECT    lpThis,
		LPFORMATETC     lpFormatetc,
		LPSTGMEDIUM     lpMedium,
		BOOL            fRelease
);
STDMETHODIMP OleDoc_DataObj_EnumFormatEtc(
		LPDATAOBJECT            lpThis,
		DWORD                   dwDirection,
		LPENUMFORMATETC FAR*    lplpenumFormatEtc
);
STDMETHODIMP OleDoc_DataObj_DAdvise(
		LPDATAOBJECT        lpThis,
		FORMATETC FAR*      lpFormatetc,
		DWORD               advf,
		LPADVISESINK        lpAdvSink,
		DWORD FAR*          lpdwConnection
);
STDMETHODIMP OleDoc_DataObj_DUnadvise(LPDATAOBJECT lpThis,DWORD dwConnection);
STDMETHODIMP OleDoc_DataObj_EnumDAdvise(
		LPDATAOBJECT        lpThis,
		LPENUMSTATDATA FAR* lplpenumAdvise
);


#ifdef USE_DRAGDROP

/* OleDoc::IDropSource methods (functions) */
STDMETHODIMP OleDoc_DropSource_QueryInterface(
	LPDROPSOURCE            lpThis,
	REFIID                  riid,
	LPVOID FAR*             lplpvObj
);
STDMETHODIMP_(ULONG) OleDoc_DropSource_AddRef( LPDROPSOURCE lpThis );
STDMETHODIMP_(ULONG) OleDoc_DropSource_Release ( LPDROPSOURCE lpThis);
STDMETHODIMP    OleDoc_DropSource_QueryContinueDrag (
	LPDROPSOURCE            lpThis,
	BOOL                    fEscapePressed,
	DWORD                   grfKeyState
);
STDMETHODIMP    OleDoc_DropSource_GiveFeedback (
	LPDROPSOURCE            lpThis,
	DWORD                   dwEffect
);

/* OleDoc::IDropTarget methods (functions) */
STDMETHODIMP OleDoc_DropTarget_QueryInterface(
		LPDROPTARGET        lpThis,
		REFIID              riid,
		LPVOID FAR*         lplpvObj
);
STDMETHODIMP_(ULONG) OleDoc_DropTarget_AddRef(LPDROPTARGET lpThis);
STDMETHODIMP_(ULONG) OleDoc_DropTarget_Release ( LPDROPTARGET lpThis);
STDMETHODIMP    OleDoc_DropTarget_DragEnter (
	LPDROPTARGET            lpThis,
	LPDATAOBJECT            lpDataObj,
	DWORD                   grfKeyState,
	POINTL                  pointl,
	LPDWORD                 lpdwEffect
);
STDMETHODIMP    OleDoc_DropTarget_DragOver (
	LPDROPTARGET            lpThis,
	DWORD                   grfKeyState,
	POINTL                  pointl,
	LPDWORD                 lpdwEffect
);
STDMETHODIMP    OleDoc_DropTarget_DragLeave ( LPDROPTARGET lpThis);
STDMETHODIMP    OleDoc_DropTarget_Drop (
	LPDROPTARGET            lpThis,
	LPDATAOBJECT            lpDataObj,
	DWORD                   grfKeyState,
	POINTL                  pointl,
	LPDWORD                 lpdwEffect
);

#endif  // USE_DRAGDROP


/*************************************************************************
** class APPCLASSFACTORY
**  APPCLASSFACTORY implements the IClassFactory interface. it
**    instantiates document instances of the correct type depending on
**    how the application is compiled (either ServerDoc or ContainerDoc
**    instances). by implementing this
**    interface in a seperate interface from the App object itself, it
**    is easier to manage when the IClassFactory should be
**    registered/revoked. when the OleApp object is first initialized
**    in OleApp_InitInstance an instance of APPCLASSFACTORY is created
**    and registered (CoRegisterClassObject called). when the App
**    object gets destroyed (in OleApp_Destroy) this APPCLASSFACTORY is
**    revoked (CoRevokeClassObject called) and released. the simple
**    fact that the IClassFactory is registered does not on its own keep
**    the application alive.
*************************************************************************/

typedef struct tagAPPCLASSFACTORY {
	IClassFactoryVtbl FAR*  m_lpVtbl;
	UINT                    m_cRef;
#if defined( _DEBUG )
	LONG                    m_cSvrLock; // total count of LockServer locks
										//  (for debugging purposes only)
#endif
 } APPCLASSFACTORY, FAR* LPAPPCLASSFACTORY;

/* PUBLIC FUNCTIONS */
LPCLASSFACTORY WINAPI AppClassFactory_Create(void);

/* interface IClassFactory implementation */
STDMETHODIMP AppClassFactory_QueryInterface(
		LPCLASSFACTORY lpThis, REFIID riid, LPVOID FAR* ppvObj);
STDMETHODIMP_(ULONG) AppClassFactory_AddRef(LPCLASSFACTORY lpThis);
STDMETHODIMP_(ULONG) AppClassFactory_Release(LPCLASSFACTORY lpThis);
STDMETHODIMP AppClassFactory_CreateInstance (
		LPCLASSFACTORY      lpThis,
		LPUNKNOWN           lpUnkOuter,
		REFIID              riid,
		LPVOID FAR*         lplpvObj
);
STDMETHODIMP AppClassFactory_LockServer (
		LPCLASSFACTORY      lpThis,
		BOOL                fLock
);


/*************************************************************************
** class OLEAPP : OUTLINEAPP
**    OLEAPP is an extention to the base OUTLINEAPP object (structure)
**    that adds common OLE 2.0 functionality used by both the server
**    and container versions. This is an abstract class. You do not
**    instantiate an instance of OLEAPP directly but instead
**    instantiate one of its concrete subclasses: SERVERAPP or
**    CONTAINERAPP. There is one instance of an document application
**    object created per running application instance. This
**    object holds many fields that could otherwise be organized as
**    global variables. The OLEAPP class inherits all fields
**    from the OUTLINEAPP class. This inheritance is achieved by including a
**    member variable of type OUTLINEAPP as the first field in the OLEAPP
**    structure. Thus a pointer to a OLEAPP object can be cast to be
**    a pointer to a OUTLINEAPP object.
*************************************************************************/

typedef struct tagOLEAPP {
	OUTLINEAPP  m_OutlineApp;       // inherits all fields of OutlineApp
	ULONG       m_cRef;             // total ref count for app
	ULONG       m_cDoc;             // total count of open documents
	BOOL        m_fUserCtrl;        // does user control life-time of app?
	DWORD       m_dwRegClassFac;    // value returned by CoRegisterClassObject
	LPCLASSFACTORY m_lpClassFactory;// ptr to allocated ClassFactory instance
#if defined( USE_MSGFILTER )
	LPMESSAGEFILTER m_lpMsgFilter;  // ptr to allocated MsgFilter instance
	MSGPENDINGPROC m_lpfnMsgPending;// ptr to msg pending callback function
#endif  // USE_MSGFILTER
	BOOL        m_fOleInitialized;  // was OleInitialize called
	UINT        m_cModalDlgActive;  // count of modal dialogs up; 0 = no dlg.
	UINT        m_cfEmbedSource;    // OLE 2.0 clipboard format
	UINT        m_cfEmbeddedObject; // OLE 2.0 clipboard format
	UINT        m_cfLinkSource;     // OLE 2.0 clipboard format
	UINT        m_cfObjectDescriptor; // OLE 2.0 clipboard format
	UINT        m_cfLinkSrcDescriptor; // OLE 2.0 clipboard format
	UINT        m_cfFileName;       // std Windows clipboard format
	FORMATETC   m_arrDocGetFmts[MAXNOFMTS];  // fmts offered by copy & GetData
	UINT        m_nDocGetFmts;      // no of fmtetc's for GetData

	OLEUIPASTEENTRY m_arrPasteEntries[MAXNOFMTS];   // input for PasteSpl.
	int         m_nPasteEntries;                    // input for PasteSpl.
	UINT        m_arrLinkTypes[MAXNOLINKTYPES];     // input for PasteSpl.
	int         m_nLinkTypes;                       // input for PasteSpl.

#if defined( USE_DRAGDROP )
	int m_nDragDelay;       // time delay (in msec) before drag should start
	int m_nDragMinDist;     // min. distance (radius) before drag should start
	int m_nScrollDelay;     // time delay (in msec) before scroll should start
	int m_nScrollInset;     // Border inset distance to start drag scroll
	int m_nScrollInterval;  // scroll interval time (in msec)

#if defined( IF_SPECIAL_DD_CURSORS_NEEDED )
	// This would be used if the app wanted to have custom drag/drop cursors
	HCURSOR     m_hcursorDragNone;
	HCURSOR     m_hcursorDragCopy;
	HCURSOR     m_hcursorDragLink;
#endif  // IF_SPECIAL_DD_CURSORS_NEEDED
#endif  // USE_DRAGDROP


#if defined( OLE_CNTR )
	HPALETTE    m_hStdPal;        // standard color palette for OLE
									  //  it is a good idea for containers
									  //  to use this standard palette
									  //  even if they do not use colors
									  //  themselves. this will allow
									  //  embedded object to get a good
									  //  distribution of colors when they
									  //  are being drawn by the container.
									  //
#endif

	struct CAppUnknownImpl {
		IUnknownVtbl FAR*       lpVtbl;
		LPOLEAPP                lpOleApp;
		int                     cRef;   // interface specific ref count.
	} m_Unknown;

} OLEAPP;

/* ServerApp methods (functions) */
BOOL OleApp_InitInstance(LPOLEAPP lpOleApp, HINSTANCE hInst, int nCmdShow);
void OleApp_TerminateApplication(LPOLEAPP lpOleApp);
BOOL OleApp_ParseCmdLine(LPOLEAPP lpOleApp, LPSTR lpszCmdLine, int nCmdShow);
void OleApp_Destroy(LPOLEAPP lpOleApp);
BOOL OleApp_CloseAllDocsAndExitCommand(
		LPOLEAPP            lpOleApp,
		BOOL                fForceEndSession
);
void OleApp_ShowWindow(LPOLEAPP lpOleApp, BOOL fGiveUserCtrl);
void OleApp_HideWindow(LPOLEAPP lpOleApp);
void OleApp_HideIfNoReasonToStayVisible(LPOLEAPP lpOleApp);
void OleApp_DocLockApp(LPOLEAPP lpOleApp);
void OleApp_DocUnlockApp(LPOLEAPP lpOleApp, LPOUTLINEDOC lpOutlineDoc);
HRESULT OleApp_Lock(LPOLEAPP lpOleApp, BOOL fLock, BOOL fLastUnlockReleases);
ULONG OleApp_AddRef(LPOLEAPP lpOleApp);
ULONG OleApp_Release (LPOLEAPP lpOleApp);
HRESULT OleApp_QueryInterface (
		LPOLEAPP                lpOleApp,
		REFIID                  riid,
		LPVOID FAR*             lplpUnk
);
void OleApp_RejectInComingCalls(LPOLEAPP lpOleApp, BOOL fReject);
void OleApp_DisableBusyDialogs(
		LPOLEAPP        lpOleApp,
		BOOL FAR*       lpfPrevBusyEnable,
		BOOL FAR*       lpfPrevNREnable
);
void OleApp_EnableBusyDialogs(
		LPOLEAPP        lpOleApp,
		BOOL            fPrevBusyEnable,
		BOOL            fPrevNREnable
);
void OleApp_PreModalDialog(LPOLEAPP lpOleApp, LPOLEDOC lpActiveOleDoc);
void OleApp_PostModalDialog(LPOLEAPP lpOleApp, LPOLEDOC lpActiveOleDoc);
BOOL OleApp_InitVtbls (LPOLEAPP lpOleApp);
void OleApp_InitMenu(
		LPOLEAPP                lpOleApp,
		LPOLEDOC                lpOleDoc,
		HMENU                   hMenu
);
void OleApp_UpdateEditMenu(
		LPOLEAPP                lpOleApp,
		LPOUTLINEDOC            lpOutlineDoc,
		HMENU                   hMenuEdit
);
BOOL OleApp_RegisterClassFactory(LPOLEAPP lpOleApp);
void OleApp_RevokeClassFactory(LPOLEAPP lpOleApp);

#if defined( USE_MSGFILTER )
BOOL OleApp_RegisterMessageFilter(LPOLEAPP lpOleApp);
void OleApp_RevokeMessageFilter(LPOLEAPP lpOleApp);
BOOL FAR PASCAL EXPORT MessagePendingProc(MSG FAR *lpMsg);
#endif  // USE_MSGFILTER

void OleApp_FlushClipboard(LPOLEAPP lpOleApp);
void OleApp_NewCommand(LPOLEAPP lpOleApp);
void OleApp_OpenCommand(LPOLEAPP lpOleApp);

#if defined( OLE_CNTR )
LRESULT OleApp_QueryNewPalette(LPOLEAPP lpOleApp);
#endif // OLE_CNTR

LRESULT wSelectPalette(HWND hWnd, HPALETTE hPal, BOOL fBackground);


/* OleApp::IUnknown methods (functions) */
STDMETHODIMP OleApp_Unk_QueryInterface(
		LPUNKNOWN           lpThis,
		REFIID              riid,
		LPVOID FAR*         lplpvObj
);
STDMETHODIMP_(ULONG) OleApp_Unk_AddRef(LPUNKNOWN lpThis);
STDMETHODIMP_(ULONG) OleApp_Unk_Release (LPUNKNOWN lpThis);


/* Function prototypes in debug.c */
void InstallMessageFilterCommand(void);
void RejectIncomingCommand(void);


#if defined( OLE_SERVER )
#include "svroutl.h"
#endif
#if defined( OLE_CNTR )
#include "cntroutl.h"
#endif

#endif // _OLEOUTL_H_

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\letest\outline\outlapp.c ===
/*************************************************************************
**
**    OLE 2 Sample Code
**
**    outlapp.c
**
**    This file contains OutlineApp functions.
**
**    (c) Copyright Microsoft Corp. 1992 - 1993 All Rights Reserved
**
*************************************************************************/

#include "outline.h"

#if defined( USE_STATUSBAR )
#include "status.h"
#endif

#if !defined( WIN32 )
#include <print.h>
#endif

OLEDBGDATA

extern LPOUTLINEAPP g_lpApp;
extern RECT g_rectNull;


// REVIEW: should use string resource for messages
char ErrMsgClass[] = "Can't register window classes!";
char ErrMsgFrame[] = "Can't create Frame Window!";
char ErrMsgPrinting[] = "Can't access printer!";


/* OutlineApp_InitApplication
** --------------------------
** Sets up the class data structures and does a one-time
**      initialization of the app by registering the window classes.
**      Returns TRUE if initialization is successful
**              FALSE otherwise
*/

BOOL OutlineApp_InitApplication(LPOUTLINEAPP lpOutlineApp, HINSTANCE hInst)
{
	WNDCLASS    wndclass;

	// REVIEW: should load msg strings from string resource

	/* Register the app frame class */
	wndclass.style = CS_HREDRAW | CS_VREDRAW | CS_BYTEALIGNWINDOW;
	wndclass.lpfnWndProc = AppWndProc;
	/* Extra storage for Class and Window objects */
	wndclass.cbClsExtra = 0;
	wndclass.cbWndExtra = sizeof(LPOUTLINEAPP); /* to store lpApp */
	wndclass.hInstance = hInst;
	wndclass.hIcon = LoadIcon(hInst, APPICON);
	wndclass.hCursor = LoadCursor(NULL, IDC_ARROW);
	/* Create brush for erasing background */
	wndclass.hbrBackground = (HBRUSH)(COLOR_WINDOW+1);
	wndclass.lpszMenuName = APPMENU;     /* Menu Name is App Name */
	wndclass.lpszClassName = APPWNDCLASS; /* Class Name is App Name */

	if(! RegisterClass(&wndclass)) {
		OutlineApp_ErrorMessage(lpOutlineApp, ErrMsgFrame);
		return FALSE;
	}

	/* Register the document window class */
	wndclass.style = CS_BYTEALIGNWINDOW;
	wndclass.lpfnWndProc = DocWndProc;
	wndclass.hIcon = NULL;
	wndclass.hbrBackground = (HBRUSH)(COLOR_WINDOW+1);
	wndclass.lpszMenuName = NULL;
	wndclass.lpszClassName = DOCWNDCLASS;
	wndclass.cbWndExtra = sizeof(LPOUTLINEDOC); /* to store lpDoc */
	if(! RegisterClass(&wndclass)) {
		OutlineApp_ErrorMessage(lpOutlineApp, ErrMsgClass);
		return FALSE;
	}

#if defined( USE_STATUSBAR )
	if (! RegisterStatusClass(hInst))
		return FALSE;
#endif

#if defined( USE_FRAMETOOLS )
	if (! FrameToolsRegisterClass(hInst)) {
		return FALSE;
	}
#endif

#if defined( INPLACE_SVR )
	// We should only register the hatch window class
	// in the UI Library once per application.
	RegisterHatchWindowClass(hInst);

#endif

	return TRUE;
}


/* OutlineApp_InitInstance
 * -----------------------
 *
 *  Performs a per-instance initialization of app.
 *  This method creates the frame window.
 *
 *  RETURNS    : TRUE  - If initialization was successful.
 *               FALSE - otherwise.
 */

BOOL OutlineApp_InitInstance(LPOUTLINEAPP lpOutlineApp, HINSTANCE hInst, int nCmdShow)
{
	lpOutlineApp->m_hInst = hInst;

	/* create application's Frame window */
	lpOutlineApp->m_hWndApp = CreateWindow(
			APPWNDCLASS,             /* Window class name */
			APPNAME,                 /* initial Window title */
			WS_OVERLAPPEDWINDOW|
			WS_CLIPCHILDREN,
			CW_USEDEFAULT, 0,        /* Use default X, Y            */
			CW_USEDEFAULT, 0,        /* Use default X, Y            */
			HWND_DESKTOP,            /* Parent window's handle      */
			NULL,                    /* Default to Class Menu       */
			hInst,                   /* Instance of window          */
			NULL                     /* Create struct for WM_CREATE */
	);

	if(! lpOutlineApp->m_hWndApp) {
		// REVIEW: should load string from string resource
		OutlineApp_ErrorMessage(lpOutlineApp, ErrMsgFrame);
		return FALSE;
	}

	SetWindowLong(lpOutlineApp->m_hWndApp, 0, (LONG) lpOutlineApp);

	/* defer creating the user's SDI document until we parse the cmd line. */
	lpOutlineApp->m_lpDoc = NULL;

	/* Initialize clipboard.
	*/
	lpOutlineApp->m_lpClipboardDoc = NULL;
	if(!(lpOutlineApp->m_cfOutline = RegisterClipboardFormat(OUTLINEDOCFORMAT))) {
		// REVIEW: should load string from string resource
		OutlineApp_ErrorMessage(lpOutlineApp, "Can't register clipboard format!");
		return FALSE;
	}

	/* init the standard font to be used for drawing/printing text
	*       request a Roman style True Type font of the desired size
	*/
	lpOutlineApp->m_hStdFont = CreateFont(
			-DEFFONTSIZE,
			0,0,0,0,0,0,0,0,
			OUT_TT_PRECIS,      // use TrueType
			CLIP_DEFAULT_PRECIS,
			DEFAULT_QUALITY,
			VARIABLE_PITCH | FF_ROMAN,
			DEFFONTFACE
	);

	// Load special cursor for selection of Lines in ListBox.
	lpOutlineApp->m_hcursorSelCur = LoadCursor ( hInst, "SelCur" );

	/* init the Print Dialog structure */
	_fmemset((LPVOID)&lpOutlineApp->m_PrintDlg,0,sizeof(PRINTDLG));
	lpOutlineApp->m_PrintDlg.lStructSize = sizeof(PRINTDLG);
	lpOutlineApp->m_PrintDlg.hDevMode = NULL;
	lpOutlineApp->m_PrintDlg.hDevNames = NULL;
	lpOutlineApp->m_PrintDlg.Flags = PD_RETURNDC | PD_NOSELECTION | PD_NOPAGENUMS |
					PD_HIDEPRINTTOFILE;
	lpOutlineApp->m_PrintDlg.nCopies = 1;
	lpOutlineApp->m_PrintDlg.hwndOwner = lpOutlineApp->m_hWndApp;

#if defined( USE_STATUSBAR )
	lpOutlineApp->m_hWndStatusBar = CreateStatusWindow(lpOutlineApp->m_hWndApp, hInst);
	if (! lpOutlineApp->m_hWndStatusBar)
		return FALSE;

	lpOutlineApp->m_hMenuApp = GetMenu(lpOutlineApp->m_hWndApp);

	/* setup status messages for the application menus */
	{
		HMENU hMenuFile = GetSubMenu(lpOutlineApp->m_hMenuApp, 0);
		HMENU hMenuEdit = GetSubMenu(lpOutlineApp->m_hMenuApp, 1);
		HMENU hMenuOutline = GetSubMenu(lpOutlineApp->m_hMenuApp, 2);
		HMENU hMenuLine = GetSubMenu(lpOutlineApp->m_hMenuApp, 3);
		HMENU hMenuName = GetSubMenu(lpOutlineApp->m_hMenuApp, 4);
		HMENU hMenuOptions = GetSubMenu(lpOutlineApp->m_hMenuApp, 5);
		HMENU hMenuDebug = GetSubMenu(lpOutlineApp->m_hMenuApp, 6);
		HMENU hMenuHelp = GetSubMenu(lpOutlineApp->m_hMenuApp, 7);
		HMENU hMenuSys = GetSystemMenu(lpOutlineApp->m_hWndApp, FALSE);

		AssignPopupMessage(hMenuFile, "Create, open, save, print outlines or quit application");
		AssignPopupMessage(hMenuEdit, "Cut, copy, paste or clear selection");
		AssignPopupMessage(hMenuOutline, "Set zoom and margins");
		AssignPopupMessage(hMenuLine, "Create, edit, and indent lines");
		AssignPopupMessage(hMenuName, "Create, edit, delete and goto names");
		AssignPopupMessage(hMenuOptions, "Modify tools, row/col headings, display options");
		AssignPopupMessage(hMenuDebug, "Set debug trace level and other debug options");
		AssignPopupMessage(hMenuHelp, "Get help on using the application");
		AssignPopupMessage(hMenuSys,"Move, size or close application window");
	}
#endif

#if defined ( USE_FRAMETOOLS ) || defined ( INPLACE_CNTR )
	lpOutlineApp->m_FrameToolWidths = g_rectNull;
#endif  // USE_FRAMETOOLS || INPLACE_CNTR

#if defined( USE_FRAMETOOLS )
	if (! FrameTools_Init(&lpOutlineApp->m_frametools,
			lpOutlineApp->m_hWndApp, lpOutlineApp->m_hInst))
		return FALSE;
#endif

#if defined( OLE_VERSION )

	/* OLE2NOTE: perform initialization required for OLE */
	if (! OleApp_InitInstance((LPOLEAPP)lpOutlineApp, hInst, nCmdShow))
		return FALSE;
#else
	/* OLE2NOTE: Although no OLE call is made in the base outline,
	**    OLE memory allocator is used and thus CoInitialize() needs to
	**    be called.
	*/
	{
		HRESULT hrErr;

		hrErr = CoInitialize(NULL);
		if (hrErr != NOERROR) {
			OutlineApp_ErrorMessage(lpOutlineApp,
					"CoInitialize initialization failed!");
			return FALSE;
		}
	}
#endif

	return TRUE;
}


/* OutlineApp_ParseCmdLine
 * -----------------------
 *
 * Parse the command line for any execution flags/arguments.
 */
BOOL OutlineApp_ParseCmdLine(LPOUTLINEAPP lpOutlineApp, LPSTR lpszCmdLine, int nCmdShow)
{

#if defined( OLE_VERSION )
	// Call OLE version of this function instead
	return OleApp_ParseCmdLine((LPOLEAPP)lpOutlineApp,lpszCmdLine,nCmdShow);

#else

	BOOL fStatus = TRUE;
	char szFileName[256];   /* buffer for filename in command line */

	szFileName[0] = '\0';
	ParseCmdLine(lpszCmdLine, NULL, (LPSTR)szFileName);

	if(*szFileName) {
		// allocate a new document
		lpOutlineApp->m_lpDoc = OutlineApp_CreateDoc(lpOutlineApp, FALSE);
		if (! lpOutlineApp->m_lpDoc) goto error;

		// open the specified file
		if (! OutlineDoc_LoadFromFile(lpOutlineApp->m_lpDoc, szFileName))
			goto error;
	} else {
		// create a new document
		lpOutlineApp->m_lpDoc = OutlineApp_CreateDoc(lpOutlineApp, FALSE);
		if (! lpOutlineApp->m_lpDoc) goto error;

		// set the doc to an (Untitled) doc.
		if (! OutlineDoc_InitNewFile(lpOutlineApp->m_lpDoc))
			goto error;
	}

	// position and size the new doc window
	OutlineApp_ResizeWindows(lpOutlineApp);
	OutlineDoc_ShowWindow(lpOutlineApp->m_lpDoc);

	// show main app window
	ShowWindow(lpOutlineApp->m_hWndApp, nCmdShow);
	UpdateWindow(lpOutlineApp->m_hWndApp);

	return TRUE;

error:
	// REVIEW: should load string from string resource
	OutlineApp_ErrorMessage(lpOutlineApp, "Could not create new document");

	if (lpOutlineApp->m_lpDoc) {
		OutlineDoc_Destroy(lpOutlineApp->m_lpDoc);
		lpOutlineApp->m_lpDoc = NULL;
	}

	return FALSE;

#endif
}


/* OutlineApp_InitMenu
 * -------------------
 *
 *      Enable or Disable menu items depending on the state of
 * the appliation
 */
void OutlineApp_InitMenu(LPOUTLINEAPP lpOutlineApp, LPOUTLINEDOC lpOutlineDoc, HMENU hMenu)
{
	WORD status;
	static UINT     uCurrentZoom = (UINT)-1;
	static UINT     uCurrentMargin = (UINT)-1;
	static UINT     uBBState = (UINT)-1;
	static UINT     uFBState = (UINT)-1;

	if (!lpOutlineApp || !lpOutlineDoc || !hMenu)
		return;

	EnableMenuItem(lpOutlineApp->m_hMenuApp, IDM_E_UNDO, MF_GRAYED);

	status = (WORD)(OutlineDoc_GetLineCount(lpOutlineDoc) ? MF_ENABLED : MF_GRAYED);

	EnableMenuItem(lpOutlineApp->m_hMenuApp, IDM_E_CUT ,status);
	EnableMenuItem(lpOutlineApp->m_hMenuApp, IDM_E_COPY ,status);
	EnableMenuItem(lpOutlineApp->m_hMenuApp, IDM_E_CLEAR ,status);
	EnableMenuItem(lpOutlineApp->m_hMenuApp, IDM_E_SELECTALL ,status);

	EnableMenuItem(lpOutlineApp->m_hMenuApp, IDM_L_EDITLINE ,status);
	EnableMenuItem(lpOutlineApp->m_hMenuApp, IDM_L_INDENTLINE ,status);
	EnableMenuItem(lpOutlineApp->m_hMenuApp, IDM_L_UNINDENTLINE ,status);
	EnableMenuItem(lpOutlineApp->m_hMenuApp, IDM_L_SETLINEHEIGHT ,status);

	EnableMenuItem(lpOutlineApp->m_hMenuApp, IDM_N_DEFINENAME ,status);

	status = (WORD)(OutlineDoc_GetNameCount(lpOutlineDoc) ? MF_ENABLED : MF_GRAYED);

	EnableMenuItem(lpOutlineApp->m_hMenuApp, IDM_N_GOTONAME, status);

	if (uCurrentZoom != (UINT)-1)
		CheckMenuItem(lpOutlineApp->m_hMenuApp, uCurrentZoom, MF_UNCHECKED);
	uCurrentZoom = OutlineDoc_GetCurrentZoomMenuCheck(lpOutlineDoc);
	CheckMenuItem(lpOutlineApp->m_hMenuApp, uCurrentZoom, MF_CHECKED);

	if (uCurrentMargin != (UINT)-1)
		CheckMenuItem(lpOutlineApp->m_hMenuApp, uCurrentMargin, MF_UNCHECKED);
	uCurrentMargin = OutlineDoc_GetCurrentMarginMenuCheck(lpOutlineDoc);
	CheckMenuItem(lpOutlineApp->m_hMenuApp, uCurrentMargin, MF_CHECKED);

#if defined( USE_FRAMETOOLS )
	if (uBBState != (UINT)-1)
		CheckMenuItem(lpOutlineApp->m_hMenuApp, uBBState, MF_UNCHECKED);
	if (lpOutlineDoc->m_lpFrameTools) {
		switch (FrameTools_BB_GetState(lpOutlineDoc->m_lpFrameTools)) {
			case BARSTATE_TOP:
				uBBState = IDM_O_BB_TOP;
				break;
			case BARSTATE_BOTTOM:
				uBBState = IDM_O_BB_BOTTOM;
				break;
			case BARSTATE_POPUP:
				uBBState = IDM_O_BB_POPUP;
				break;
			case BARSTATE_HIDE:
				uBBState = IDM_O_BB_HIDE;
				break;
		}
		CheckMenuItem(lpOutlineApp->m_hMenuApp, uBBState, MF_CHECKED);
	}

	if (uFBState != (UINT)-1)
		CheckMenuItem(lpOutlineApp->m_hMenuApp, uFBState, MF_UNCHECKED);
	if (lpOutlineDoc->m_lpFrameTools) {
		switch (FrameTools_FB_GetState(lpOutlineDoc->m_lpFrameTools)) {
			case BARSTATE_TOP:
				uFBState = IDM_O_FB_TOP;
				break;
			case BARSTATE_BOTTOM:
				uFBState = IDM_O_FB_BOTTOM;
				break;
			case BARSTATE_POPUP:
				uFBState = IDM_O_FB_POPUP;
				break;
		}
		CheckMenuItem(lpOutlineApp->m_hMenuApp, uFBState, MF_CHECKED);
	}
#endif  // USE_FRAMETOOLS

#if defined( OLE_VERSION )
	/* OLE2NOTE: perform OLE specific menu initialization.
	**    the OLE versions use the OleGetClipboard mechanism for
	**    clipboard handling. thus, they determine if the Paste and
	**    PasteSpecial commands should be enabled in an OLE specific
	**    manner.
	**    (Container only) build the OLE object verb menu if necessary.
	*/
	OleApp_InitMenu(
			(LPOLEAPP)lpOutlineApp,
			(LPOLEDOC)lpOutlineDoc,
			lpOutlineApp->m_hMenuApp
	);

	/* OLE2NOTE: To avoid the overhead of initializing the Edit menu,
	**    we do it only when it is popped up. Thus we just set a flag
	**    in the OleDoc saying that the Edit menu needs to be updated
	**    but we don't do it immediately
	*/
	OleDoc_SetUpdateEditMenuFlag((LPOLEDOC)lpOutlineDoc, TRUE);

#else
	// Base Outline version uses standard Windows clipboard handling
	if(IsClipboardFormatAvailable(lpOutlineApp->m_cfOutline) ||
	   IsClipboardFormatAvailable(CF_TEXT))
		status = MF_ENABLED;
	else
		status = MF_GRAYED;
	EnableMenuItem(lpOutlineApp->m_hMenuApp, IDM_E_PASTE, status);

#endif

#if defined( USE_FRAMETOOLS )
	if (! OutlineDoc_IsEditFocusInFormulaBar(lpOutlineDoc)) {
		EnableMenuItem(lpOutlineApp->m_hMenuApp, IDM_L_ADDLINE, MF_GRAYED);
		EnableMenuItem(lpOutlineApp->m_hMenuApp, IDM_L_EDITLINE, MF_GRAYED);
	}
	else
		EnableMenuItem(lpOutlineApp->m_hMenuApp, IDM_L_ADDLINE, MF_ENABLED);

#endif      // USE_FRAMETOOLS

}


/* OutlineApp_GetWindow
 * --------------------
 *
 *      Get the window handle of the application frame.
 */
HWND OutlineApp_GetWindow(LPOUTLINEAPP lpOutlineApp)
{
	if (!lpOutlineApp)
		return NULL;

	return lpOutlineApp->m_hWndApp;
}


/* OutlineApp_GetFrameWindow
** -------------------------
**    Gets the current frame window to use as a parent to any dialogs
**    this app uses.
**
**    OLE2NOTE: normally this is simply the main hWnd of the app. but,
**    if the app is currently supporting an in-place server document,
**    then the frame window of the top in-place container must be used.
*/
HWND OutlineApp_GetFrameWindow(LPOUTLINEAPP lpOutlineApp)
{
	HWND hWndApp = OutlineApp_GetWindow(lpOutlineApp);

#if defined( INPLACE_SVR )
	LPSERVERDOC lpServerDoc =
			(LPSERVERDOC)OutlineApp_GetActiveDoc(lpOutlineApp);
	if (lpServerDoc && lpServerDoc->m_fUIActive)
		return lpServerDoc->m_lpIPData->frameInfo.hwndFrame;
#endif

	return hWndApp;
}


/* OutlineApp_GetInstance
 * ----------------------
 *
 *      Get the process instance of the application.
 */
HINSTANCE OutlineApp_GetInstance(LPOUTLINEAPP lpOutlineApp)
{
	if (!lpOutlineApp)
		return NULL;

	return lpOutlineApp->m_hInst;
}


/* OutlineApp_CreateDoc
 * --------------------
 *
 * Allocate a new document of the appropriate type.
 *  OutlineApp  --> creates OutlineDoc type documents
 *
 *      Returns lpOutlineDoc for successful, NULL if error.
 */
LPOUTLINEDOC OutlineApp_CreateDoc(
		LPOUTLINEAPP    lpOutlineApp,
		BOOL            fDataTransferDoc
)
{
	LPOUTLINEDOC lpOutlineDoc;

	OLEDBG_BEGIN3("OutlineApp_CreateDoc\r\n")

#if defined( OLE_SERVER )
	lpOutlineDoc = (LPOUTLINEDOC)New((DWORD)sizeof(SERVERDOC));
	_fmemset(lpOutlineDoc, 0, sizeof(SERVERDOC));
#endif
#if defined( OLE_CNTR )
	lpOutlineDoc = (LPOUTLINEDOC)New((DWORD)sizeof(CONTAINERDOC));
	_fmemset(lpOutlineDoc, 0, sizeof(CONTAINERDOC));
#endif
#if !defined( OLE_VERSION )
	lpOutlineDoc = (LPOUTLINEDOC)New((DWORD)sizeof(OUTLINEDOC));
	_fmemset(lpOutlineDoc, 0, sizeof(OUTLINEDOC));
#endif

	OleDbgAssertSz(lpOutlineDoc != NULL, "Error allocating OutlineDoc");
	if (lpOutlineDoc == NULL) 
		return NULL;

	// initialize new document
	if (! OutlineDoc_Init(lpOutlineDoc, fDataTransferDoc))
		goto error;

	OLEDBG_END3
	return lpOutlineDoc;

error:
	if (lpOutlineDoc)
		Delete(lpOutlineDoc);

	OLEDBG_END3
	return NULL;
}


/* OutlineApp_CreateName
 * ---------------------
 *
 * Allocate a new Name of the appropriate type.
 *  OutlineApp --> creates standard OutlineName type names.
 *  ServerApp  --> creates enhanced SeverName type names.
 *
 *      Returns lpOutlineName for successful, NULL if error.
 */
LPOUTLINENAME OutlineApp_CreateName(LPOUTLINEAPP lpOutlineApp)
{
	LPOUTLINENAME lpOutlineName;

#if defined( OLE_SERVER )
	lpOutlineName = (LPOUTLINENAME)New((DWORD)sizeof(SERVERNAME));
#else
	lpOutlineName = (LPOUTLINENAME)New((DWORD)sizeof(OUTLINENAME));
#endif

	OleDbgAssertSz(lpOutlineName != NULL, "Error allocating Name");
	if (lpOutlineName == NULL)
		return NULL;

#if defined( OLE_SERVER )
	_fmemset((LPVOID)lpOutlineName,0,sizeof(SERVERNAME));
#else
	_fmemset((LPVOID)lpOutlineName,0,sizeof(OUTLINENAME));
#endif

	return lpOutlineName;
}


/* OutlineApp_DocUnlockApp
** -----------------------
**    Forget all references to a closed document.
*/
void OutlineApp_DocUnlockApp(LPOUTLINEAPP lpOutlineApp, LPOUTLINEDOC lpOutlineDoc)
{
	/* forget pointers to destroyed document */
	if (lpOutlineApp->m_lpDoc == lpOutlineDoc)
		lpOutlineApp->m_lpDoc = NULL;
	else if (lpOutlineApp->m_lpClipboardDoc == lpOutlineDoc)
		lpOutlineApp->m_lpClipboardDoc = NULL;

#if defined( OLE_VERSION )
	/* OLE2NOTE: when there are no open documents and the app is not
	**    under the control of the user then revoke our ClassFactory to
	**    enable the app to shut down.
	**
	**    NOTE: data transfer documents (non-user documents) do NOT
	**    hold the app alive. therefore they do not Lock the app.
	*/
	if (! lpOutlineDoc->m_fDataTransferDoc)
		OleApp_DocUnlockApp((LPOLEAPP)lpOutlineApp, lpOutlineDoc);
#endif
}


/* OutlineApp_NewCommand
 * ---------------------
 *
 *  Start a new untitled document (File.New command).
 */
void OutlineApp_NewCommand(LPOUTLINEAPP lpOutlineApp)
{
#if defined( OLE_VERSION )
	// Call OLE version of this function instead
	OleApp_NewCommand((LPOLEAPP)lpOutlineApp);

#else

	LPOUTLINEDOC lpOutlineDoc = lpOutlineApp->m_lpDoc;

	if (! OutlineDoc_Close(lpOutlineDoc, OLECLOSE_PROMPTSAVE))
		return;

	OleDbgAssertSz(lpOutlineApp->m_lpDoc==NULL,"Closed doc NOT properly destroyed");

	lpOutlineApp->m_lpDoc = OutlineApp_CreateDoc(lpOutlineApp, FALSE);
	if (! lpOutlineApp->m_lpDoc) goto error;

	// set the doc to an (Untitled) doc.
	if (! OutlineDoc_InitNewFile(lpOutlineApp->m_lpDoc))
		goto error;

	// position and size the new doc window
	OutlineApp_ResizeWindows(lpOutlineApp);
	OutlineDoc_ShowWindow(lpOutlineApp->m_lpDoc); // calls OleDoc_Lock

	return;

error:
	// REVIEW: should load string from string resource
	OutlineApp_ErrorMessage(lpOutlineApp, "Could not create new document");

	if (lpOutlineApp->m_lpDoc) {
		OutlineDoc_Destroy(lpOutlineApp->m_lpDoc);
		lpOutlineApp->m_lpDoc = NULL;
	}

	return;

#endif
}


/* OutlineApp_OpenCommand
 * ----------------------
 *
 *  Load a document from file (File.Open command).
 */
void OutlineApp_OpenCommand(LPOUTLINEAPP lpOutlineApp)
{
#if defined( OLE_VERSION )
	// Call OLE version of this function instead
	OleApp_OpenCommand((LPOLEAPP)lpOutlineApp);

#else

	OPENFILENAME ofn;
	char szFilter[]=APPFILENAMEFILTER;
	char szFileName[256];
	UINT i;
	DWORD dwSaveOption = OLECLOSE_PROMPTSAVE;
	BOOL fStatus = TRUE;

	if (! OutlineDoc_CheckSaveChanges(lpOutlineApp->m_lpDoc, &dwSaveOption))
		return;           // abort opening new doc

	for(i=0; szFilter[i]; i++)
		if(szFilter[i]=='|') szFilter[i]='\0';

	_fmemset((LPOPENFILENAME)&ofn,0,sizeof(OPENFILENAME));

	szFileName[0]='\0';

	ofn.lStructSize=sizeof(OPENFILENAME);
	ofn.hwndOwner=lpOutlineApp->m_hWndApp;
	ofn.lpstrFilter=(LPSTR)szFilter;
	ofn.lpstrFile=(LPSTR)szFileName;
	ofn.nMaxFile=sizeof(szFileName);
	ofn.Flags=OFN_FILEMUSTEXIST | OFN_HIDEREADONLY;
	ofn.lpstrDefExt=DEFEXTENSION;

	if(! GetOpenFileName((LPOPENFILENAME)&ofn))
		return;         // user canceled file open dialog

	OutlineDoc_Close(lpOutlineApp->m_lpDoc, OLECLOSE_NOSAVE);
	OleDbgAssertSz(lpOutlineApp->m_lpDoc==NULL,"Closed doc NOT properly destroyed");

	lpOutlineApp->m_lpDoc = OutlineApp_CreateDoc(lpOutlineApp, FALSE);
	if (! lpOutlineApp->m_lpDoc) goto error;

	fStatus=OutlineDoc_LoadFromFile(lpOutlineApp->m_lpDoc, (LPSTR)szFileName);

	if (! fStatus) {
		// loading the doc failed; create an untitled instead
		OutlineDoc_Destroy(lpOutlineApp->m_lpDoc);  // destroy unused doc
		lpOutlineApp->m_lpDoc = OutlineApp_CreateDoc(lpOutlineApp, FALSE);
		if (! lpOutlineApp->m_lpDoc) goto error;
		if (! OutlineDoc_InitNewFile(lpOutlineApp->m_lpDoc))
			goto error;
	}

	// position and size the new doc window
	OutlineApp_ResizeWindows(lpOutlineApp);
	OutlineDoc_ShowWindow(lpOutlineApp->m_lpDoc);

	return;

error:
	// REVIEW: should load string from string resource
	OutlineApp_ErrorMessage(lpOutlineApp, "Could not create new document");

	if (lpOutlineApp->m_lpDoc) {
		OutlineDoc_Destroy(lpOutlineApp->m_lpDoc);
		lpOutlineApp->m_lpDoc = NULL;
	}

	return;

#endif
}


/* OutlineApp_PrintCommand
 * -----------------------
 *
 *      Print the document
 */
void OutlineApp_PrintCommand(LPOUTLINEAPP lpOutlineApp)
{
	LPOUTLINEDOC    lpOutlineDoc = lpOutlineApp->m_lpDoc;
	HDC             hDC=NULL;
	BOOL            fMustDeleteDC = FALSE;
	BOOL            fStatus;

#if defined( OLE_VERSION )
	OleApp_PreModalDialog(
			(LPOLEAPP)lpOutlineApp, (LPOLEDOC)lpOutlineApp->m_lpDoc);
#endif

	fStatus = PrintDlg((LPPRINTDLG)&lpOutlineApp->m_PrintDlg);

#if defined( OLE_VERSION )
	OleApp_PostModalDialog(
			(LPOLEAPP)lpOutlineApp, (LPOLEDOC)lpOutlineApp->m_lpDoc);
#endif

	if (!fStatus) {
		if (!CommDlgExtendedError()) {      // Cancel button pressed
			return;
		}
	}
	else {
		hDC = OutlineApp_GetPrinterDC(lpOutlineApp);
		if (hDC) {

#if defined( OLE_VERSION )
			/* OLE2NOTE: while we are printing we do NOT want to
			**    receive any OnDataChange notifications or other OLE
			**    interface calls which could disturb the printing of
			**    the document. we will temporarily reply
			**    SERVERCALL_RETRYLATER
			*/
			OleApp_RejectInComingCalls((LPOLEAPP)lpOutlineApp, TRUE);
#endif

			OutlineDoc_Print(lpOutlineDoc, hDC);
			DeleteDC(hDC);

#if defined( OLE_VERSION )
			// re-enable LRPC calls
			OleApp_RejectInComingCalls((LPOLEAPP)lpOutlineApp, FALSE);
#endif

			return;                         // Printing completed
		}
	}

	// REVIEW: should load string from string resource
	OutlineApp_ErrorMessage(lpOutlineApp, ErrMsgPrinting);
}


/* OutlineApp_PrinterSetupCommand
 * ------------------------------
 *
 *      Setup a different printer for printing
 */
void OutlineApp_PrinterSetupCommand(LPOUTLINEAPP lpOutlineApp)
{
	DWORD FlagSave;

	FlagSave = lpOutlineApp->m_PrintDlg.Flags;
	lpOutlineApp->m_PrintDlg.Flags |= PD_PRINTSETUP;

#if defined( OLE_VERSION )
	OleApp_PreModalDialog(
			(LPOLEAPP)lpOutlineApp, (LPOLEDOC)lpOutlineApp->m_lpDoc);
#endif

	PrintDlg((LPPRINTDLG)&lpOutlineApp->m_PrintDlg);

#if defined( OLE_VERSION )
	OleApp_PostModalDialog(
			(LPOLEAPP)lpOutlineApp, (LPOLEDOC)lpOutlineApp->m_lpDoc);
#endif

	lpOutlineApp->m_PrintDlg.Flags = FlagSave;
}

/*
 *  FUNCTION   : OutlineApp_GetPrinterDC ()
 *
 *  PURPOSE    : Creates a printer display context for the printer
 *
 *  RETURNS    : HDC   - A handle to printer DC.
 */
HDC OutlineApp_GetPrinterDC(LPOUTLINEAPP lpApp)
{

	HDC         hDC;
	LPDEVMODE   lpDevMode = NULL;
	LPDEVNAMES  lpDevNames;
	LPSTR       lpszDriverName;
	LPSTR       lpszDeviceName;
	LPSTR       lpszPortName;

	if(lpApp->m_PrintDlg.hDC) {
		hDC = lpApp->m_PrintDlg.hDC;
	} else {
		if(! lpApp->m_PrintDlg.hDevNames)
			return(NULL);
		lpDevNames = (LPDEVNAMES)GlobalLock(lpApp->m_PrintDlg.hDevNames);
		lpszDriverName = (LPSTR)lpDevNames + lpDevNames->wDriverOffset;
		lpszDeviceName = (LPSTR)lpDevNames + lpDevNames->wDeviceOffset;
		lpszPortName   = (LPSTR)lpDevNames + lpDevNames->wOutputOffset;
		GlobalUnlock(lpApp->m_PrintDlg.hDevNames);

		if(lpApp->m_PrintDlg.hDevMode)
			lpDevMode = (LPDEVMODE)GlobalLock(lpApp->m_PrintDlg.hDevMode);
#if defined( WIN32 )
		hDC = CreateDC(
				lpszDriverName,
				lpszDeviceName,
				lpszPortName,
				(CONST DEVMODE FAR*)lpDevMode);
#else
		hDC = CreateDC(
				lpszDriverName,
				lpszDeviceName,
				lpszPortName,
				(LPSTR)lpDevMode);
#endif

		if(lpApp->m_PrintDlg.hDevMode && lpDevMode)
			GlobalUnlock(lpApp->m_PrintDlg.hDevMode);
	}

	return(hDC);
}


/* OutlineApp_SaveCommand
 * ----------------------
 *
 *      Save the document with same name. If no name exists, prompt the user
 *      for a name (via SaveAsCommand)
 *
 *  Parameters:
 *
 *  Returns:
 *      TRUE    if succesfully
 *      FALSE   if failed or aborted
 */
BOOL OutlineApp_SaveCommand(LPOUTLINEAPP lpOutlineApp)
{
	LPOUTLINEDOC lpOutlineDoc = OutlineApp_GetActiveDoc(lpOutlineApp);

	if(lpOutlineDoc->m_docInitType == DOCTYPE_NEW)  /* file with no name */
		return OutlineApp_SaveAsCommand(lpOutlineApp);


	if(OutlineDoc_IsModified(lpOutlineDoc)) {

#if defined( OLE_SERVER )

		if (lpOutlineDoc->m_docInitType == DOCTYPE_EMBEDDED) {
			LPSERVERDOC lpServerDoc = (LPSERVERDOC)lpOutlineDoc;
			HRESULT hrErr;

			/* OLE2NOTE: if the document is an embedded object, then
			**    the "File.Save" command is changed to "File.Update".
			**    in order to update our container, we must ask our
			**    container to save us.
			*/
			OleDbgAssert(lpServerDoc->m_lpOleClientSite != NULL);
			OLEDBG_BEGIN2("IOleClientSite::SaveObject called\r\n")
			hrErr = lpServerDoc->m_lpOleClientSite->lpVtbl->SaveObject(
					lpServerDoc->m_lpOleClientSite
			);
			OLEDBG_END2

			if (hrErr != NOERROR) {
				OleDbgOutHResult("IOleClientSite::SaveObject returned",hrErr);
				return FALSE;
			}
		} else
			// document is file-base user document, save it to its file.

#endif      // OLE_SERVER

		(void)OutlineDoc_SaveToFile(
				lpOutlineDoc,
				NULL,
				lpOutlineDoc->m_cfSaveFormat,
				TRUE
		);
	}

	return TRUE;
}


/* OutlineApp_SaveAsCommand
 * ------------------------
 *
 *      Save the document as another name
 *
 *  Parameters:
 *
 *  Returns:
 *      TRUE    if saved successful
 *      FALSE   if failed or aborted
 */
BOOL OutlineApp_SaveAsCommand(LPOUTLINEAPP lpOutlineApp)
{
	LPOUTLINEDOC lpOutlineDoc = lpOutlineApp->m_lpDoc;
	OPENFILENAME ofn;
	char szFilter[]=APPFILENAMEFILTER;
	char szFileName[256]="";
	int i;
	UINT uFormat;
	BOOL fNoError = TRUE;
	BOOL fRemember = TRUE;
	BOOL fStatus;

	for(i=0; szFilter[i]; i++)
		if(szFilter[i]=='|') szFilter[i]='\0';

	_fmemset((LPOPENFILENAME)&ofn,0,sizeof(OPENFILENAME));

	ofn.lStructSize=sizeof(OPENFILENAME);
	ofn.hwndOwner=lpOutlineDoc->m_hWndDoc;
	ofn.lpstrFilter=(LPSTR)szFilter;
	ofn.lpstrFile=(LPSTR)szFileName;
	ofn.nMaxFile=sizeof(szFileName);

	ofn.Flags=OFN_PATHMUSTEXIST | OFN_OVERWRITEPROMPT | OFN_HIDEREADONLY;
	ofn.lpstrDefExt=DEFEXTENSION;

#if defined( OLE_VERSION )
	OleApp_PreModalDialog(
			(LPOLEAPP)lpOutlineApp, (LPOLEDOC)lpOutlineApp->m_lpDoc);
#endif

	fStatus = GetSaveFileName((LPOPENFILENAME)&ofn);

#if defined( OLE_VERSION )
	OleApp_PostModalDialog(
			(LPOLEAPP)lpOutlineApp, (LPOLEDOC)lpOutlineApp->m_lpDoc);
#endif

	if (fStatus) {

#if defined( OLE_CNTR )
		// determine which file type the user selected.
		switch (ofn.nFilterIndex) {
			case 1:
				uFormat = ((LPCONTAINERAPP)lpOutlineApp)->m_cfCntrOutl;
				break;
			case 2:
				uFormat = lpOutlineApp->m_cfOutline;
				break;
			default:
				uFormat = ((LPCONTAINERAPP)lpOutlineApp)->m_cfCntrOutl;
				break;
		}
#else
		uFormat = lpOutlineApp->m_cfOutline;
#endif

#if defined( OLE_SERVER )
		/* OLE2NOTE: if the document is an embedded object, then the
		**    File.SaveAs command is changed to File.SaveCopyAs. with the
		**    Save Copy As operation, the document does NOT remember the
		**    saved file as the associated file for the document.
		*/
		if (lpOutlineDoc->m_docInitType == DOCTYPE_EMBEDDED)
			fRemember = FALSE;
#endif

		(void)OutlineDoc_SaveToFile(
				lpOutlineDoc,
				szFileName,
				uFormat,
				fRemember
		);

	}
	else
		fNoError = FALSE;

	return fNoError;

}


/* OutlineApp_AboutCommand
 * -----------------------
 *
 *      Show the About dialog box
 */
void OutlineApp_AboutCommand(LPOUTLINEAPP lpOutlineApp)
{
#if defined( OLE_VERSION )
	OleApp_PreModalDialog(
			(LPOLEAPP)lpOutlineApp, (LPOLEDOC)lpOutlineApp->m_lpDoc);
#endif

	DialogBox(
			lpOutlineApp->m_hInst,
			(LPSTR)"About",
			OutlineApp_GetFrameWindow(lpOutlineApp),
			(DLGPROC)AboutDlgProc
	);

#if defined( OLE_VERSION )
	OleApp_PostModalDialog(
			(LPOLEAPP)lpOutlineApp, (LPOLEDOC)lpOutlineApp->m_lpDoc);
#endif
}


/* OutlineApp_CloseAllDocsAndExitCommand
 * -------------------------------------
 *
 *  Close all active documents and exit the app.
 *  Because this is an SDI, there is only one document
 *  If the doc was modified, prompt the user if he wants to save it.
 *
 *  Returns:
 *      TRUE if the app is successfully closed
 *      FALSE if failed or aborted
 */
BOOL OutlineApp_CloseAllDocsAndExitCommand(
		LPOUTLINEAPP        lpOutlineApp,
		BOOL                fForceEndSession
)
{
	BOOL fResult;

	OLEDBG_BEGIN2("OutlineApp_CloseAllDocsAndExitCommand\r\n")

#if defined( OLE_VERSION )
	// Call OLE specific version of this function
	fResult = OleApp_CloseAllDocsAndExitCommand(
			(LPOLEAPP)lpOutlineApp, fForceEndSession);

#else

	/* Because this is an SDI app, there is only one document.
	** Close the doc. if it is successfully closed and the app will
	** not automatically exit, then also exit the app.
	** if this were an MDI app, we would loop through and close all
	** open MDI child documents.
	*/
	if (OutlineDoc_Close(lpOutlineApp->m_lpDoc, OLECLOSE_PROMPTSAVE)) {

#if defined( _DEBUG )
		OleDbgAssertSz(
				lpOutlineApp->m_lpDoc==NULL,
				"Closed doc NOT properly destroyed"
		);
#endif

		OutlineApp_Destroy(lpOutlineApp);
		fResult = TRUE;

	} // else User Canceled shutdown
	else
		fResult = FALSE;

#endif

	OLEDBG_END2

	return fResult;
}


/* OutlineApp_Destroy
 * ------------------
 *
 *      Destroy all data structures used by the app and force the
 * app to shut down. This should be called after all documents have
 * been closed.
 */
void OutlineApp_Destroy(LPOUTLINEAPP lpOutlineApp)
{
	OLEDBG_BEGIN3("OutlineApp_Destroy\r\n");

#if defined( OLE_VERSION )
	/* OLE2NOTE: perform processing required for OLE */
	OleApp_Destroy((LPOLEAPP)lpOutlineApp);
#endif

	SetCursor(LoadCursor(NULL, MAKEINTRESOURCE(IDC_ARROW)));
	DestroyCursor(lpOutlineApp->m_hcursorSelCur);

#if defined( USE_FRAMETOOLS )
	FrameTools_Destroy(&lpOutlineApp->m_frametools);
#endif

	if (lpOutlineApp->m_hStdFont)
		DeleteObject(lpOutlineApp->m_hStdFont);

	if(lpOutlineApp->m_PrintDlg.hDevMode)
		GlobalFree(lpOutlineApp->m_PrintDlg.hDevMode);
	if(lpOutlineApp->m_PrintDlg.hDevNames)
		GlobalFree(lpOutlineApp->m_PrintDlg.hDevNames);

#if defined( USE_STATUSBAR )
	if(lpOutlineApp->m_hWndStatusBar) {
		DestroyStatusWindow(lpOutlineApp->m_hWndStatusBar);
		lpOutlineApp->m_hWndStatusBar = NULL;
	}
#endif

	OutlineApp_DestroyWindow(lpOutlineApp);
	OleDbgOut1("@@@@ APP DESTROYED\r\n");

	OLEDBG_END3
}


/* OutlineApp_DestroyWindow
 * ------------------------
 *
 *  Destroy all windows created by the App.
 */
void OutlineApp_DestroyWindow(LPOUTLINEAPP lpOutlineApp)
{
	HWND hWndApp = lpOutlineApp->m_hWndApp;

	if(hWndApp) {
		lpOutlineApp->m_hWndApp = NULL;
		lpOutlineApp->m_hWndAccelTarget = NULL;
		DestroyWindow(hWndApp);  /* Quit the app */
	}
}


/* OutlineApp_GetFrameRect
** -----------------------
**    Get the rectangle of the app frame window EXCLUDING space for the
**    status line.
**
**    OLE2NOTE: this is the rectangle that an in-place container can
**    offer to an in-place active object from which to get frame tool
**    space.
*/
void OutlineApp_GetFrameRect(LPOUTLINEAPP lpOutlineApp, LPRECT lprcFrameRect)
{
	GetClientRect(lpOutlineApp->m_hWndApp, lprcFrameRect);

#if defined( USE_STATUSBAR )
	lprcFrameRect->bottom -= STATUS_HEIGHT;
#endif

}


/* OutlineApp_GetClientAreaRect
** ----------------------------
**    Get the rectangle of the app frame window EXCLUDING space for the
**    status line AND EXCLUDING space for any frame-level tools.
**
**    OLE2NOTE: this is the rectangle that an in-place container gives
**    to its in-place active object as the lpClipRect in
**    IOleInPlaceSite::GetWindowContext.
*/
void OutlineApp_GetClientAreaRect(
		LPOUTLINEAPP        lpOutlineApp,
		LPRECT              lprcClientAreaRect
)
{
	OutlineApp_GetFrameRect(lpOutlineApp, lprcClientAreaRect);

	/* if the app either uses frame-level tools itself or, as in-place
	**    container, is prepared to allow an in-place active object to
	**    have space for tools, then it must subtract away the space
	**    required for the tools.
	*/
#if defined ( USE_FRAMETOOLS ) || defined ( INPLACE_CNTR )

	lprcClientAreaRect->top    += lpOutlineApp->m_FrameToolWidths.top;
	lprcClientAreaRect->left   += lpOutlineApp->m_FrameToolWidths.left;
	lprcClientAreaRect->right  -= lpOutlineApp->m_FrameToolWidths.right;
	lprcClientAreaRect->bottom -= lpOutlineApp->m_FrameToolWidths.bottom;
#endif  // USE_FRAMETOOLS || INPLACE_CNTR

}


/* OutlineApp_GetStatusLineRect
** ----------------------------
**    Get the rectangle required for the status line.
**
**    OLE2NOTE: the top frame-level in-place container displays its
**    status line even when an object is active in-place.
*/
void OutlineApp_GetStatusLineRect(
		LPOUTLINEAPP        lpOutlineApp,
		LPRECT              lprcStatusLineRect
)
{
	RECT rcFrameRect;
	GetClientRect(lpOutlineApp->m_hWndApp, (LPRECT)&rcFrameRect);
	lprcStatusLineRect->left    = rcFrameRect.left;
	lprcStatusLineRect->top     = rcFrameRect.bottom - STATUS_HEIGHT;
	lprcStatusLineRect->right   = rcFrameRect.right;
	lprcStatusLineRect->bottom  = rcFrameRect.bottom;
}


/* OutlineApp_ResizeWindows
 * ------------------------
 *
 * Changes the size and position of the SDI document and tool windows.
 * Normally called on a WM_SIZE message.
 *
 * Currently the app supports a status bar and a single SDI document window.
 * In the future it will have a formula bar and possibly multiple MDI
 * document windows.
 *
 * CUSTOMIZATION: Change positions of windows.
 */
void OutlineApp_ResizeWindows(LPOUTLINEAPP lpOutlineApp)
{
	LPOUTLINEDOC lpOutlineDoc = OutlineApp_GetActiveDoc(lpOutlineApp);
	RECT rcStatusLineRect;

	if (! lpOutlineApp)
		return;

#if defined( INPLACE_CNTR )
	if (lpOutlineDoc)
		ContainerDoc_FrameWindowResized((LPCONTAINERDOC)lpOutlineDoc);
#else
#if defined( USE_FRAMETOOLS )
	if (lpOutlineDoc)
		OutlineDoc_AddFrameLevelTools(lpOutlineDoc);
#else
	OutlineApp_ResizeClientArea(lpOutlineApp);
#endif  // ! USE_FRAMETOOLS
#endif  // ! INPLACE_CNTR

#if defined( USE_STATUSBAR )
	if (lpOutlineApp->m_hWndStatusBar) {
		OutlineApp_GetStatusLineRect(lpOutlineApp, (LPRECT)&rcStatusLineRect);
		MoveWindow(
				lpOutlineApp->m_hWndStatusBar,
				rcStatusLineRect.left,
				rcStatusLineRect.top,
				rcStatusLineRect.right - rcStatusLineRect.left,
				rcStatusLineRect.bottom - rcStatusLineRect.top,
				TRUE    /* fRepaint */
			);
	}
#endif  // USE_STATUSBAR
}


#if defined( USE_FRAMETOOLS ) || defined( INPLACE_CNTR )

void OutlineApp_SetBorderSpace(
		LPOUTLINEAPP        lpOutlineApp,
		LPBORDERWIDTHS      lpBorderWidths
)
{
	lpOutlineApp->m_FrameToolWidths = *lpBorderWidths;
	OutlineApp_ResizeClientArea(lpOutlineApp);
}
#endif  // USE_FRAMETOOLS || INPLACE_CNTR


void OutlineApp_ResizeClientArea(LPOUTLINEAPP lpOutlineApp)
{
	RECT rcClientAreaRect;

#if defined( MDI_VERSION )

	// Resize MDI Client Area Window here

#else

	if (lpOutlineApp->m_lpDoc) {
			OutlineApp_GetClientAreaRect(
					lpOutlineApp, (LPRECT)&rcClientAreaRect);
			OutlineDoc_Resize(lpOutlineApp->m_lpDoc,
					(LPRECT)&rcClientAreaRect);
	}

#endif

}


/* OutlineApp_GetActiveDoc
 * -----------------------
 *
 * Return the document in focus. For SDI, the same (only one) document is
 * always returned.
 */
LPOUTLINEDOC OutlineApp_GetActiveDoc(LPOUTLINEAPP lpOutlineApp)
{
	return lpOutlineApp->m_lpDoc;
}

/* OutlineApp_GetMenu
 * ------------------
 *
 * Return the menu handle of the app
 */
HMENU OutlineApp_GetMenu(LPOUTLINEAPP lpOutlineApp)
{
	if (!lpOutlineApp) {
		return NULL;
	}

	return lpOutlineApp->m_hMenuApp;
}


#if defined( USE_FRAMETOOLS )

/* OutlineApp_GetFrameTools
 * ---------------------
 *
 * Return the pointer to the toolbar object
 */
LPFRAMETOOLS OutlineApp_GetFrameTools(LPOUTLINEAPP lpOutlineApp)
{
	return (LPFRAMETOOLS)&lpOutlineApp->m_frametools;
}
#endif


/* OutlineApp_SetStatusText
 * ------------------------
 *
 * Show the given string in the status line
 */
void OutlineApp_SetStatusText(LPOUTLINEAPP lpOutlineApp, LPSTR lpszMessage)
{
	SetStatusText(lpOutlineApp->m_hWndStatusBar, lpszMessage);
}


/* OutlineApp_GetActiveFont
 * ------------------------
 *
 *      Return the font used by the application
 */
HFONT OutlineApp_GetActiveFont(LPOUTLINEAPP lpOutlineApp)
{
	return lpOutlineApp->m_hStdFont;
}


/* OutlineApp_GetAppName
 * ---------------------
 *
 *      Retrieve the application name
 */
void OutlineApp_GetAppName(LPOUTLINEAPP lpOutlineApp, LPSTR lpszAppName)
{
	lstrcpy(lpszAppName, APPNAME);
}


/* OutlineApp_GetAppVersionNo
 * --------------------------
 *
 *      Get the version number (major and minor) of the application
 */
void OutlineApp_GetAppVersionNo(LPOUTLINEAPP lpOutlineApp, int narrAppVersionNo[])
{
	narrAppVersionNo[0] = APPMAJORVERSIONNO;
	narrAppVersionNo[1] = APPMINORVERSIONNO;
}


/* OutlineApp_VersionNoCheck
 * -------------------------
 *
 *      Check if the version stamp read from a file is compatible
 *      with the current instance of the application.
 *      returns TRUE if the file can be read, else FALSE.
 */
BOOL OutlineApp_VersionNoCheck(LPOUTLINEAPP lpOutlineApp, LPSTR lpszFormatName, int narrAppVersionNo[])
{
#if defined( OLE_CNTR )

	/* ContainerApp accepts both CF_OUTLINE and CF_CONTAINEROUTLINE formats */
	if (lstrcmp(lpszFormatName, CONTAINERDOCFORMAT) != 0 &&
		lstrcmp(lpszFormatName, OUTLINEDOCFORMAT) != 0) {
		// REVIEW: should load string from string resource
		OutlineApp_ErrorMessage(
				lpOutlineApp,
				"File is either corrupted or not of proper type."
			);
		return FALSE;
	}

#else

	/* OutlineApp accepts CF_OUTLINE format only */
	if (lstrcmp(lpszFormatName, OUTLINEDOCFORMAT) != 0) {
		// REVIEW: should load string from string resource
		OutlineApp_ErrorMessage(
				lpOutlineApp,
				"File is either corrupted or not of proper type."
			);
		return FALSE;
	}
#endif

	if (narrAppVersionNo[0] < APPMAJORVERSIONNO) {
		// REVIEW: should load string from string resource
		OutlineApp_ErrorMessage(
				lpOutlineApp,
				"File was created by an older version; it can not be read."
			);
		return FALSE;
	}

	return TRUE;
}


/* OutlineApp_ErrorMessage
 * -----------------------
 *
 *      Display an error message box
 */
void OutlineApp_ErrorMessage(LPOUTLINEAPP lpOutlineApp, LPSTR lpszErrMsg)
{
	HWND hWndFrame = OutlineApp_GetFrameWindow(lpOutlineApp);

	// OLE2NOTE: only put up user message boxes if app is visible
	if (IsWindowVisible(hWndFrame)) {
#if defined( OLE_VERSION )
		OleApp_PreModalDialog(
				(LPOLEAPP)lpOutlineApp, (LPOLEDOC)lpOutlineApp->m_lpDoc);
#endif

		MessageBox(hWndFrame, lpszErrMsg, NULL, MB_ICONEXCLAMATION | MB_OK);

#if defined( OLE_VERSION )
		OleApp_PostModalDialog(
				(LPOLEAPP)lpOutlineApp, (LPOLEDOC)lpOutlineApp->m_lpDoc);
#endif
	}
}


#if defined( USE_FRAMETOOLS )

/* OutlineApp_SetFormulaBarAccel
 * -----------------------------
 *
 *  Set accelerator table based on state of formula bar.
 */
void OutlineApp_SetFormulaBarAccel(
		LPOUTLINEAPP            lpOutlineApp,
		BOOL                    fEditFocus
)
{
	if (fEditFocus)
		lpOutlineApp->m_hAccel = lpOutlineApp->m_hAccelFocusEdit;
	else
		lpOutlineApp->m_hAccel = lpOutlineApp->m_hAccelApp;
}

#endif  // USE_FRAMETOOLS




/* OutlineApp_ForceRedraw
 * ----------------------
 *
 *      Force the Application window to repaint.
 */
void OutlineApp_ForceRedraw(LPOUTLINEAPP lpOutlineApp, BOOL fErase)
{
	if (!lpOutlineApp)
		return;

	InvalidateRect(lpOutlineApp->m_hWndApp, NULL, fErase);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\letest\outline\outline.h ===
/*************************************************************************
**
**    OLE 2 Sample Code
**
**    outline.h
**
**    This file contains file contains data structure defintions,
**    function prototypes, constants, etc. used by the Outline series
**    of sample applications:
**          Outline  -- base version of the app (without OLE functionality)
**          SvrOutl  -- OLE 2.0 Server sample app
**          CntrOutl -- OLE 2.0 Containter (Container) sample app
**          ISvrOtl  -- OLE 2.0 Server sample app
**          CntrOutl -- OLE 2.0 Containter (Container) sample app
**
**    (c) Copyright Microsoft Corp. 1992 - 1993 All Rights Reserved
**
**    For structures which we read from and write to disk we define shadow
**    structures (with the _ONDISK suffix) that allow us to maintain
**    16-bit Windows and Macintosh compatibility.
**
*************************************************************************/

#if !defined( _OUTLINE_H_ )
#define _OUTLINE_H_

#include <testmess.h>


#if !defined( RC_INVOKED )
#pragma message ("INCLUDING OUTLINE.H from " __FILE__)
#endif  /* RC_INVOKED */

// use strict ANSI standard (for DVOBJ.H)
//#define NONAMELESSUNION

// use system defined bitmap, this line must go before windows.h
#define OEMRESOURCE

#ifdef WIN32
#define _INC_OLE
// #define __RPC_H__
#define EXPORT

#define _fstrchr strchr

#else
#define EXPORT _export
#endif

#define SDI_VERSION         1   // ONLY SDI version is currently supported

#if defined( OLE_SERVER ) || defined( OLE_CNTR )
#define OLE_VERSION         1
#define USE_DRAGDROP        1   // enable drag/drop code in OLE versions
#define USE_MSGFILTER       1   // enable IMessageFilter implementation
#endif

#define USE_HEADING         1   // enable the row/col headings
#define USE_STATUSBAR       1   // enable status bar window
#define USE_FRAMETOOLS      1   // enable the toolbar
#ifndef WIN32   //BUGBUG32
#define USE_CTL3D           1   // enable 3D looking dialogs
#endif

#define STRICT	1
#undef UNICODE
#include <windows.h>
#include <string.h>
#include <commdlg.h>
#include <ole2.h>
#include <ole2ui.h>
#include <olestr.h>
#include "outlrc.h"


#define APPMAJORVERSIONNO   3   // major no. incremented for major releases
								//  (eg. when an incompatible change is made
								//  to the storage format)
#define APPMINORVERSIONNO   5   // minor no. incremented for minor releases


/* Definition of SCALEFACTOR */
typedef struct tagSCALEFACTOR {
	ULONG       dwSxN;      // numerator in x direction
	ULONG       dwSxD;      // denominator in x direction
	ULONG       dwSyN;      // numerator in y direction
	ULONG       dwSyD;      // denominator in y direction
} SCALEFACTOR, FAR* LPSCALEFACTOR;


#if defined( USE_FRAMETOOLS )
#include "frametls.h"
#endif

#if defined( USE_HEADING )
#include "heading.h"
#endif

/* max line height (in pixels) allowed in a listbox */
#define LISTBOX_HEIGHT_LIMIT    255


#define MAXSTRLEN   80      // max string len in bytes
#define MAXNAMESIZE 30      // max length of names
#define MAXFORMATSIZE   10  // max length of DEFDOCFORMAT (actually size is 5)
#define TABWIDTH        2000 // 2000 in Himetric units, i.e. 2cm
#define DEFFONTPTSIZE   12
#define DEFFONTSIZE     ((DEFFONTPTSIZE*HIMETRIC_PER_INCH)/PTS_PER_INCH)
#define DEFFONTFACE     "Times New Roman"

#define OUTLINEDOCFORMAT    "Outline"       // CF_Outline format name
#define IS_FILENAME_DELIM(c)    ( (c) == '\\' || (c) == '/' || (c) == ':' )
// REVIEW: some of these strings should be loaded from a resource file
#define UNTITLED    "Outline"   // title used for untitled document
#define HITTESTDELTA    5

/* Macro to get a random integer within a specified range */
#define getrandom( min, max ) ((rand() % (int)(((max)+1) - (min))) + (min))


// REVIEW: should load strings from string resource file

#define APPFILENAMEFILTER   "Outline Files (*.OLN)|*.oln|All files (*.*)|*.*|"
#define DEFEXTENSION    "oln"           // Default file extension


/* forward type references */
typedef struct tagOUTLINEDOC FAR* LPOUTLINEDOC;
typedef struct tagTEXTLINE FAR* LPTEXTLINE;


typedef enum tagLINETYPE {
	UNKNOWNLINETYPE,
	TEXTLINETYPE,
	CONTAINERLINETYPE
} LINETYPE;


/*************************************************************************
** class LINE
**    The class LINE is an abstract base class. Instances of class LINE
**    are NOT created; only instances of the concrete subclasses of
**    LINE can be created. In the base app version and the OLE 2.0
**    server-only version only TEXTLINE objects can be created. In the
**    OLE 2.0 client app version either TEXTLINE objects or CONTAINERLINE
**    objects can be created. The LINE class has all fields and methods
**    that are common independent of which subclass of LINE is used.
**    Each LINE object that is created in added to the LINELIST of the
**    OUTLINEDOC document.
*************************************************************************/

typedef struct tagLINE {
	LINETYPE    m_lineType;
	UINT        m_nTabLevel;
	UINT        m_nTabWidthInHimetric;
	UINT        m_nWidthInHimetric;
	UINT        m_nHeightInHimetric;
	BOOL        m_fSelected;        // does line have selection feedback

#if defined( USE_DRAGDROP )
	BOOL        m_fDragOverLine;    // does line have drop target feedback
#endif
} LINE, FAR* LPLINE;

/* Line methods (functions) */
void Line_Init(LPLINE lpLine, int nTab, HDC hDC);
void Line_Delete(LPLINE lpLine);
BOOL Line_CopyToDoc(LPLINE lpSrcLine, LPOUTLINEDOC lpDestDoc, int nIndex);
BOOL Line_Edit(LPLINE lpLine, HWND hWndDoc, HDC hDC);
void Line_Draw(
		LPLINE      lpLine,
		HDC         hDC,
		LPRECT      lpRect,
		LPRECT      lpRectWBounds,
		BOOL        fHighlight
);
void Line_DrawToScreen(
		LPLINE      lpLine,
		HDC         hDC,
		LPRECT      lprcPix,
		UINT        itemAction,
		UINT        itemState,
		LPRECT      lprcDevice
);
void Line_DrawSelHilight(LPLINE lpLine, HDC hDC, LPRECT lpRect, UINT itemAction, UINT itemState);
void Line_DrawFocusRect(LPLINE lpLine, HDC hDC, LPRECT lpRect, UINT itemAction, UINT itemState);
void Line_Unindent(LPLINE lpLine, HDC hDC);
void Line_Indent(LPLINE lpLine, HDC hDC);
LINETYPE Line_GetLineType(LPLINE lpLine);
UINT Line_GetTotalWidthInHimetric(LPLINE lpLine);
void Line_SetWidthInHimetric(LPLINE lpLine, int nWidth);
UINT Line_GetWidthInHimetric(LPLINE lpLine);
UINT Line_GetHeightInHimetric(LPLINE lpLine);
void Line_SetHeightInHimetric(LPLINE lpLine, int nHeight);
UINT Line_GetTabLevel(LPLINE lpLine);
int Line_GetTextLen(LPLINE lpLine);
void Line_GetTextData(LPLINE lpLine, LPSTR lpszBuf);
BOOL Line_GetOutlineData(LPLINE lpLine, LPTEXTLINE lpBuf);
int Line_CalcTabWidthInHimetric(LPLINE lpLine, HDC hDC);
BOOL Line_SaveToStg(LPLINE lpLine, UINT uFormat, LPSTORAGE lpSrcStg, LPSTORAGE lpDestStg, LPSTREAM lpLLStm, BOOL fRemember);
LPLINE Line_LoadFromStg(LPSTORAGE lpSrcStg, LPSTREAM lpLLStm, LPOUTLINEDOC lpDestDoc);
void Line_DrawDragFeedback(LPLINE lpLine, HDC hDC, LPRECT lpRect, UINT itemState );
BOOL Line_IsSelected(LPLINE lpLine);


/*************************************************************************
** class TEXTLINE : LINE
**    The class TEXTLINE is a concrete subclass of the abstract base
**    class LINE. The TEXTLINE class holds a string that can be edited
**    by the user. In the base app version and the OLE 2.0
**    server-only version only TEXTLINE objects can be created. In the
**    OLE 2.0 client app version either TEXTLINE objects or CONTAINERLINE
**    objects can be created. The TEXTLINE class inherits all fields
**    from the LINE class. This inheritance is achieved by including a
**    member variable of type LINE as the first field in the TEXTLINE
**    structure. Thus a pointer to a TEXTLINE object can be cast to be
**    a pointer to a LINE object.
**    Each TEXTLINE object that is created in added to the LINELIST of
**    the associated OUTLINEDOC document.
*************************************************************************/

typedef struct tagTEXTLINE {
	LINE m_Line;        // TextLine inherits all fields of Line

	UINT m_nLength;
	char m_szText[MAXSTRLEN+1];
} TEXTLINE;

LPTEXTLINE TextLine_Create(HDC hDC, UINT nTab, LPSTR szText);
void TextLine_Init(LPTEXTLINE lpTextLine, int nTab, HDC hDC);
void TextLine_CalcExtents(LPTEXTLINE lpLine, HDC hDC);
void TextLine_SetHeightInHimetric(LPTEXTLINE lpTextLine, int nHeight);
void TextLine_Delete(LPTEXTLINE lpLine);
BOOL TextLine_Edit(LPTEXTLINE lpLine, HWND hWndDoc, HDC hDC);
void TextLine_Draw(
		LPTEXTLINE  lpTextLine,
		HDC         hDC,
		LPRECT      lpRect,
		LPRECT      lpRectWBounds,
		BOOL        fHighlight
);
void TextLine_DrawSelHilight(LPTEXTLINE lpTextLine, HDC hDC, LPRECT lpRect, UINT itemAction, UINT itemState);
BOOL TextLine_Copy(LPTEXTLINE lpSrcLine, LPTEXTLINE lpDestLine);
BOOL TextLine_CopyToDoc(LPTEXTLINE lpSrcLine, LPOUTLINEDOC lpDestDoc, int nIndex);
int TextLine_GetTextLen(LPTEXTLINE lpTextLine);
void TextLine_GetTextData(LPTEXTLINE lpTextLine, LPSTR lpszBuf);
BOOL TextLine_GetOutlineData(LPTEXTLINE lpTextLine, LPTEXTLINE lpBuf);
BOOL TextLine_SaveToStm(LPTEXTLINE lpLine, LPSTREAM lpLLStm);
LPLINE TextLine_LoadFromStg(LPSTORAGE lpSrcStg, LPSTREAM lpLLStm, LPOUTLINEDOC lpDestDoc);



/*************************************************************************
** class LINERANGE
**    The class LINERANGE is a supporting object used to describe a
**    particular range in an OUTLINEDOC. A range is defined by a starting
**    line index and an ending line index.
*************************************************************************/

typedef struct tagLINERANGE {
	signed short    m_nStartLine;
	signed short    m_nEndLine;
} LINERANGE, FAR* LPLINERANGE;


/*************************************************************************
** class OUTLINENAME
**    The class OUTLINENAME stores a particular named selection in the
**    OUTLINEDOC document. The NAMETABLE class holds all of the names
**    defined in a particular OUTLINEDOC document. Each OUTLINENAME
**    object has a string as its key and a starting line index and an
**    ending line index for the named range.
*************************************************************************/

#pragma pack(push, 2)
typedef struct tagOUTLINENAME {
	char            m_szName[MAXNAMESIZE+1];
	signed short    m_nStartLine;  // must be signed for table update
	signed short    m_nEndLine;    // functions to work
} OUTLINENAME, FAR* LPOUTLINENAME;
#pragma pack(pop)

void OutlineName_SetName(LPOUTLINENAME lpOutlineName, LPSTR lpszName);
void OutlineName_SetSel(LPOUTLINENAME lpOutlineName, LPLINERANGE lplrSel, BOOL fRangeModified);
void OutlineName_GetSel(LPOUTLINENAME lpOutlineName, LPLINERANGE lplrSel);
BOOL OutlineName_SaveToStg(LPOUTLINENAME lpOutlineName, LPLINERANGE lplrSel, UINT uFormat, LPSTREAM lpNTStm, BOOL FAR* lpfNameSaved);

BOOL OutlineName_SaveToStg(LPOUTLINENAME lpOutlineName, LPLINERANGE lplrSel, UINT uFormat, LPSTREAM lpNTStm, BOOL FAR* lpfNameSaved);
BOOL OutlineName_LoadFromStg(LPOUTLINENAME lpOutlineName, LPSTREAM lpNTStm);


/*************************************************************************
** class OUTLINENAMETABLE
**    OUTLINENAMETABLE manages the table of named selections in the
**    OUTLINEDOC document. Each OUTLINENAMETABLE entry has a string as its key
**    and a starting line index and an ending line index for the
**    named range. There is always one instance of OUTLINENAMETABLE for each
**    OUTLINEDOC created.
*************************************************************************/

typedef struct tagOUTLINENAMETABLE {
	HWND        m_hWndListBox;
	int         m_nCount;
} OUTLINENAMETABLE, FAR* LPOUTLINENAMETABLE;

/* OutlineNameTable methods (functions) */
BOOL OutlineNameTable_Init(LPOUTLINENAMETABLE lpOutlineNameTable, LPOUTLINEDOC lpOutlineDoc);
void OutlineNameTable_Destroy(LPOUTLINENAMETABLE lpOutlineNameTable);
void OutlineNameTable_ClearAll(LPOUTLINENAMETABLE lpOutlineNameTable);
LPOUTLINENAME OutlineNameTable_CreateName(LPOUTLINENAMETABLE lpOutlineNameTable);
void OutlineNameTable_AddName(LPOUTLINENAMETABLE lpOutlineNameTable, LPOUTLINENAME lpOutlineName);
void OutlineNameTable_DeleteName(LPOUTLINENAMETABLE lpOutlineNameTable, int nIndex);
int OutlineNameTable_GetNameIndex(LPOUTLINENAMETABLE lpOutlineNameTable, LPOUTLINENAME lpOutlineName);
LPOUTLINENAME OutlineNameTable_GetName(LPOUTLINENAMETABLE lpOutlineNameTable, int nIndex);
LPOUTLINENAME OutlineNameTable_FindName(LPOUTLINENAMETABLE lpOutlineNameTable, LPSTR lpszName);
LPOUTLINENAME OutlineNameTable_FindNamedRange(LPOUTLINENAMETABLE lpOutlineNameTable, LPLINERANGE lplrSel);
int OutlineNameTable_GetCount(LPOUTLINENAMETABLE lpOutlineNameTable);
void OutlineNameTable_AddLineUpdate(LPOUTLINENAMETABLE lpOutlineNameTable, int nAddIndex);
void OutlineNameTable_DeleteLineUpdate(LPOUTLINENAMETABLE lpOutlineNameTable, int nDeleteIndex);
BOOL OutlineNameTable_LoadFromStg(LPOUTLINENAMETABLE lpOutlineNameTable, LPSTORAGE lpSrcStg);
BOOL OutlineNameTable_SaveSelToStg(
		LPOUTLINENAMETABLE      lpOutlineNameTable,
		LPLINERANGE             lplrSel,
		UINT                    uFormat,
		LPSTREAM                lpNTStm
);


/*************************************************************************
** class LINELIST
**    The class LINELIST manages the list of Line objects in the
**    OUTLINEDOC document. This class uses a Window's Owner-draw ListBox
**    to hold the list of LINE objects. There is always one instance of
**    LINELIST for each OUTLINEDOC created.
*************************************************************************/

typedef struct tagLINELIST {
	HWND            m_hWndListBox;  // hWnd of OwnerDraw listbox
	int             m_nNumLines;        // number of lines in LineList
	int             m_nMaxLineWidthInHimetric;  // max width of listbox
	LPOUTLINEDOC    m_lpDoc;        // ptr to associated OutlineDoc
	LINERANGE       m_lrSaveSel;    // selection saved on WM_KILLFOCUS

#if defined( USE_DRAGDROP )
	int             m_iDragOverLine;    // line index w/ drop target feedback
#endif
} LINELIST, FAR* LPLINELIST;

/* LineList methods (functions) */
BOOL LineList_Init(LPLINELIST lpLL, LPOUTLINEDOC lpOutlineDoc);
void LineList_Destroy(LPLINELIST lpLL);
void LineList_AddLine(LPLINELIST lpLL, LPLINE lpLine, int nIndex);
void LineList_DeleteLine(LPLINELIST lpLL, int nIndex);
void LineList_ReplaceLine(LPLINELIST lpLL, LPLINE lpLine, int nIndex);
int LineList_GetLineIndex(LPLINELIST lpLL, LPLINE lpLine);
LPLINE LineList_GetLine(LPLINELIST lpLL, int nIndex);
void LineList_SetFocusLine ( LPLINELIST lpLL, WORD wIndex );
BOOL LineList_GetLineRect(LPLINELIST lpLL, int nIndex, LPRECT lpRect);
int LineList_GetFocusLineIndex(LPLINELIST lpLL);
int LineList_GetCount(LPLINELIST lpLL);
BOOL LineList_SetMaxLineWidthInHimetric(
		LPLINELIST lpLL,
		int nWidthInHimetric
);
void LineList_ScrollLineIntoView(LPLINELIST lpLL, int nIndex);
int LineList_GetMaxLineWidthInHimetric(LPLINELIST lpLL);
BOOL LineList_RecalcMaxLineWidthInHimetric(
		LPLINELIST          lpLL,
		int                 nWidthInHimetric
);
void LineList_CalcSelExtentInHimetric(
		LPLINELIST          lpLL,
		LPLINERANGE         lplrSel,
		LPSIZEL             lpsizel
);
HWND LineList_GetWindow(LPLINELIST lpLL);
HDC LineList_GetDC(LPLINELIST lpLL);
void LineList_ReleaseDC(LPLINELIST lpLL, HDC hDC);
void LineList_SetLineHeight(LPLINELIST lpLL,int nIndex,int nHeightInHimetric);
void LineList_ReScale(LPLINELIST lpLL, LPSCALEFACTOR lpscale);
void LineList_SetSel(LPLINELIST lpLL, LPLINERANGE lplrSel);
int LineList_GetSel(LPLINELIST lpLL, LPLINERANGE lplrSel);
void LineList_RemoveSel(LPLINELIST lpLL);
void LineList_RestoreSel(LPLINELIST lpLL);
void LineList_SetRedraw(LPLINELIST lpLL, BOOL fEnableDraw);
void LineList_ForceRedraw(LPLINELIST lpLL, BOOL fErase);
void LineList_ForceLineRedraw(LPLINELIST lpLL, int nIndex, BOOL fErase);
int LineList_CopySelToDoc(
		LPLINELIST              lpSrcLL,
		LPLINERANGE             lplrSel,
		LPOUTLINEDOC            lpDestDoc
);
BOOL LineList_SaveSelToStg(
		LPLINELIST              lpLL,
		LPLINERANGE             lplrSel,
		UINT                    uFormat,
		LPSTORAGE               lpSrcStg,
		LPSTORAGE               lpDestStg,
		LPSTREAM                lpLLStm,
		BOOL                    fRemember
);
BOOL LineList_LoadFromStg(
		LPLINELIST              lpLL,
		LPSTORAGE               lpSrcStg,
		LPSTREAM                lpLLStm
);

#if defined( USE_DRAGDROP )
void LineList_SetFocusLineFromPointl( LPLINELIST lpLL, POINTL pointl );
void LineList_SetDragOverLineFromPointl ( LPLINELIST lpLL, POINTL pointl );
void LineList_Scroll(LPLINELIST lpLL, DWORD dwScrollDir);
int LineList_GetLineIndexFromPointl(LPLINELIST lpLL, POINTL pointl);
void LineList_RestoreDragFeedback(LPLINELIST lpLL);
#endif

LRESULT FAR PASCAL LineListWndProc(
	HWND   hWnd,
	UINT   Message,
	WPARAM wParam,
	LPARAM lParam
);


// Document initialization type
#define DOCTYPE_UNKNOWN     0   // new doc created but not yet initialized
#define DOCTYPE_NEW         1   // init from scratch (new doc)
#define DOCTYPE_FROMFILE    2   // init from a file (open doc)



/*************************************************************************
** class OUTLINEDOC
**    There is one instance of the OutlineDoc class created per
**    document open in the app. The SDI version of the app supports one
**    OUTLINEDOC at a time. The MDI version of the app can manage
**    multiple documents at one time.
*************************************************************************/

/* Definition of OUTLINEDOC */
typedef struct tagOUTLINEDOC {
	LINELIST    m_LineList;         // list of lines in the doc
	LPOUTLINENAMETABLE m_lpNameTable;   // table of names in the doc
	HWND        m_hWndDoc;          // client area window for the Doc
	int         m_docInitType;      // is doc new or loaded from a file?
	BOOL        m_fDataTransferDoc; // is doc created for copy | drag/drop
	CLIPFORMAT  m_cfSaveFormat;      // format used to save the doc
	char        m_szFileName[256];  // associated file; "(Untitled)" if none
	LPSTR       m_lpszDocTitle;     // name of doc to appear in window title
	BOOL        m_fModified;        // is the doc dirty (needs to be saved)?
	UINT        m_nDisableDraw;     // enable/disable updating the display
	SCALEFACTOR m_scale;            // current scale factor of the doc
	int         m_nLeftMargin;      // left margin in Himetric
	int         m_nRightMargin;     // right margin in Himetric
	UINT        m_uCurrentZoom;     // cur. zoom (used for menu checking)
	UINT        m_uCurrentMargin;   // cur. margin (used for menu checking)
#if defined( USE_HEADING )
	HEADING     m_heading;
#endif

#if defined( USE_FRAMETOOLS )
	LPFRAMETOOLS m_lpFrameTools;    // ptr to frame tools used by this doc
#endif

} OUTLINEDOC;

/* OutlineDoc methods (functions) */

BOOL OutlineDoc_Init(LPOUTLINEDOC lpOutlineDoc, BOOL fDataTransferDoc);
BOOL OutlineDoc_InitNewFile(LPOUTLINEDOC lpOutlineDoc);
LPOUTLINENAMETABLE OutlineDoc_CreateNameTable(LPOUTLINEDOC lpOutlineDoc);
void OutlineDoc_Destroy(LPOUTLINEDOC lpOutlineDoc);
BOOL OutlineDoc_Close(LPOUTLINEDOC lpOutlineDoc, DWORD dwSaveOption);
void OutlineDoc_ShowWindow(LPOUTLINEDOC lpOutlineDoc);
void OutlineDoc_FrameWindowResized(
		LPOUTLINEDOC        lpOutlineDoc,
		LPRECT              lprcFrameRect,
		LPBORDERWIDTHS      lpFrameToolWidths
);

void OutlineDoc_ClearCommand(LPOUTLINEDOC lpOutlineDoc);
void OutlineDoc_CutCommand(LPOUTLINEDOC lpOutlineDoc);
void OutlineDoc_CopyCommand(LPOUTLINEDOC lpOutlineDoc);
void OutlineDoc_ClearAllLines(LPOUTLINEDOC lpOutlineDoc);
LPOUTLINEDOC OutlineDoc_CreateDataTransferDoc(LPOUTLINEDOC lpSrcOutlineDoc);
void OutlineDoc_PasteCommand(LPOUTLINEDOC lpOutlineDoc);
int OutlineDoc_PasteOutlineData(LPOUTLINEDOC lpOutlineDoc, HGLOBAL hOutline, int nStartIndex);
int OutlineDoc_PasteTextData(LPOUTLINEDOC lpOutlineDoc, HGLOBAL hText, int nStartIndex);
void OutlineDoc_AddTextLineCommand(LPOUTLINEDOC lpOutlineDoc);
void OutlineDoc_AddTopLineCommand(
		LPOUTLINEDOC        lpOutlineDoc,
		UINT                nHeightInHimetric
);
void OutlineDoc_EditLineCommand(LPOUTLINEDOC lpOutlineDoc);
void OutlineDoc_IndentCommand(LPOUTLINEDOC lpOutlineDoc);
void OutlineDoc_UnindentCommand(LPOUTLINEDOC lpOutlineDoc);
void OutlineDoc_SetLineHeightCommand(LPOUTLINEDOC lpDoc);
void OutlineDoc_SelectAllCommand(LPOUTLINEDOC lpOutlineDoc);
void OutlineDoc_DefineNameCommand(LPOUTLINEDOC lpOutlineDoc);
void OutlineDoc_GotoNameCommand(LPOUTLINEDOC lpOutlineDoc);

void OutlineDoc_Print(LPOUTLINEDOC lpOutlineDoc, HDC hDC);
BOOL OutlineDoc_SaveToFile(LPOUTLINEDOC lpOutlineDoc, LPCSTR lpszFileName, UINT uFormat, BOOL fRemember);
void OutlineDoc_AddLine(LPOUTLINEDOC lpOutlineDoc, LPLINE lpLine, int nIndex);
void OutlineDoc_DeleteLine(LPOUTLINEDOC lpOutlineDoc, int nIndex);
void OutlineDoc_AddName(LPOUTLINEDOC lpOutlineDoc, LPOUTLINENAME lpOutlineName);
void OutlineDoc_DeleteName(LPOUTLINEDOC lpOutlineDoc, int nIndex);
void OutlineDoc_Resize(LPOUTLINEDOC lpDoc, LPRECT lpRect);
LPOUTLINENAMETABLE OutlineDoc_GetNameTable(LPOUTLINEDOC lpOutlineDoc);
LPLINELIST OutlineDoc_GetLineList(LPOUTLINEDOC lpOutlineDoc);
int OutlineDoc_GetNameCount(LPOUTLINEDOC lpOutlineDoc);
int OutlineDoc_GetLineCount(LPOUTLINEDOC lpOutlineDoc);
void OutlineDoc_SetTitle(LPOUTLINEDOC lpOutlineDoc, BOOL fMakeUpperCase);
BOOL OutlineDoc_CheckSaveChanges(
		LPOUTLINEDOC        lpOutlineDoc,
		LPDWORD             lpdwSaveOption
);
BOOL OutlineDoc_IsModified(LPOUTLINEDOC lpOutlineDoc);
void OutlineDoc_SetModified(LPOUTLINEDOC lpOutlineDoc, BOOL fModified, BOOL fDataChanged, BOOL fSizeChanged);
void OutlineDoc_SetRedraw(LPOUTLINEDOC lpOutlineDoc, BOOL fEnableDraw);
BOOL OutlineDoc_LoadFromFile(LPOUTLINEDOC lpOutlineDoc, LPSTR szFileName);
BOOL OutlineDoc_SaveSelToStg(
		LPOUTLINEDOC        lpOutlineDoc,
		LPLINERANGE         lplrSel,
		UINT                uFormat,
		LPSTORAGE           lpDestStg,
		BOOL                fSameAsLoad,
		BOOL                fRemember
);
BOOL OutlineDoc_LoadFromStg(LPOUTLINEDOC lpOutlineDoc, LPSTORAGE lpSrcStg);
BOOL OutlineDoc_SetFileName(LPOUTLINEDOC lpOutlineDoc, LPSTR lpszFileName, LPSTORAGE lpNewStg);
HWND OutlineDoc_GetWindow(LPOUTLINEDOC lpOutlineDoc);
void OutlineDoc_SetSel(LPOUTLINEDOC lpOutlineDoc, LPLINERANGE lplrSel);
int OutlineDoc_GetSel(LPOUTLINEDOC lpOutlineDoc, LPLINERANGE lplrSel);
void OutlineDoc_ForceRedraw(LPOUTLINEDOC lpOutlineDoc, BOOL fErase);
void OutlineDoc_RenderFormat(LPOUTLINEDOC lpOutlineDoc, UINT uFormat);
void OutlineDoc_RenderAllFormats(LPOUTLINEDOC lpOutlineDoc);
HGLOBAL OutlineDoc_GetOutlineData(LPOUTLINEDOC lpOutlineDoc, LPLINERANGE lplrSel);
HGLOBAL OutlineDoc_GetTextData(LPOUTLINEDOC lpOutlineDoc, LPLINERANGE lplrSel);
void OutlineDoc_DialogHelp(HWND hDlg, WPARAM wDlgID);
void OutlineDoc_SetCurrentZoomCommand(
		LPOUTLINEDOC        lpOutlineDoc,
		UINT                uCurrentZoom
);
UINT OutlineDoc_GetCurrentZoomMenuCheck(LPOUTLINEDOC lpOutlineDoc);
void OutlineDoc_SetScaleFactor(
		LPOUTLINEDOC        lpOutlineDoc,
		LPSCALEFACTOR       lpscale,
		LPRECT              lprcDoc
);
LPSCALEFACTOR OutlineDoc_GetScaleFactor(LPOUTLINEDOC lpDoc);
void OutlineDoc_SetCurrentMarginCommand(
		LPOUTLINEDOC        lpOutlineDoc,
		UINT                uCurrentMargin
);
UINT OutlineDoc_GetCurrentMarginMenuCheck(LPOUTLINEDOC lpOutlineDoc);
void OutlineDoc_SetMargin(LPOUTLINEDOC lpDoc, int nLeftMargin, int nRightMargin);
LONG OutlineDoc_GetMargin(LPOUTLINEDOC lpDoc);


#if defined( USE_FRAMETOOLS )
void OutlineDoc_AddFrameLevelTools(LPOUTLINEDOC lpOutlineDoc);
void OutlineDoc_SetFormulaBarEditText(
		LPOUTLINEDOC            lpOutlineDoc,
		LPLINE                  lpLine
);
void OutlineDoc_SetFormulaBarEditFocus(
		LPOUTLINEDOC            lpOutlineDoc,
		BOOL                    fEditFocus
);
BOOL OutlineDoc_IsEditFocusInFormulaBar(LPOUTLINEDOC lpOutlineDoc);
void OutlineDoc_UpdateFrameToolButtons(LPOUTLINEDOC lpOutlineDoc);
#endif  // USE_FRAMETOOLS

#if defined( USE_HEADING )
LPHEADING OutlineDoc_GetHeading(LPOUTLINEDOC lpOutlineDoc);
void OutlineDoc_ShowHeading(LPOUTLINEDOC lpOutlineDoc, BOOL fShow);
#endif  // USE_HEADING

/*************************************************************************
** class OUTLINEAPP
**    There is one instance of the OUTLINEAPP class created per running
**    application instance. This object holds many fields that could
**    otherwise be organized as global variables.
*************************************************************************/

/* Definition of OUTLINEAPP */
typedef struct tagOUTLINEAPP {
	HWND            m_hWndApp;        // top-level frame window for the App
	HMENU           m_hMenuApp;       // handle to frame level menu for App
	HACCEL          m_hAccelApp;
	HACCEL          m_hAccelFocusEdit;// Accelerator when Edit in Focus
	LPOUTLINEDOC    m_lpDoc;          // main SDI document visible to user
	LPOUTLINEDOC    m_lpClipboardDoc; // hidden doc for snapshot of copied sel
	HWND            m_hWndStatusBar;  // window for the status bar
	HCURSOR         m_hcursorSelCur;  // cursor used to select lines
	HINSTANCE       m_hInst;
	PRINTDLG        m_PrintDlg;
	HFONT           m_hStdFont;       // font used for TextLines
	UINT            m_cfOutline;      // clipboard format for Outline data
	HACCEL          m_hAccel;
	HWND            m_hWndAccelTarget;
	FARPROC         m_ListBoxWndProc; // orig listbox WndProc for subclassing

#if defined ( USE_FRAMETOOLS ) || defined ( INPLACE_CNTR )
	BORDERWIDTHS    m_FrameToolWidths;  // space required by frame-level tools
#endif  // USE_FRAMETOOLS || INPLACE_CNTR

#if defined( USE_FRAMETOOLS )
	FRAMETOOLS      m_frametools;     // frame tools (button & formula bars)
#endif  // USE_FRAMETOOLS

} OUTLINEAPP, FAR* LPOUTLINEAPP;

/* OutlineApp methods (functions) */
BOOL OutlineApp_InitApplication(LPOUTLINEAPP lpOutlineApp, HINSTANCE hInst);
BOOL OutlineApp_InitInstance(LPOUTLINEAPP lpOutlineApp, HINSTANCE hInst, int nCmdShow);
BOOL OutlineApp_ParseCmdLine(LPOUTLINEAPP lpOutlineApp, LPSTR lpszCmdLine, int nCmdShow);
void OutlineApp_Destroy(LPOUTLINEAPP lpOutlineApp);
LPOUTLINEDOC OutlineApp_CreateDoc(
		LPOUTLINEAPP    lpOutlineApp,
		BOOL            fDataTransferDoc
);
HWND OutlineApp_GetWindow(LPOUTLINEAPP lpOutlineApp);
HWND OutlineApp_GetFrameWindow(LPOUTLINEAPP lpOutlineApp);
HINSTANCE OutlineApp_GetInstance(LPOUTLINEAPP lpOutlineApp);
LPOUTLINENAME OutlineApp_CreateName(LPOUTLINEAPP lpOutlineApp);
void OutlineApp_DocUnlockApp(LPOUTLINEAPP lpOutlineApp, LPOUTLINEDOC lpOutlineDoc);
void OutlineApp_InitMenu(LPOUTLINEAPP lpOutlineApp, LPOUTLINEDOC lpDoc, HMENU hMenu);
void OutlineApp_GetFrameRect(LPOUTLINEAPP lpOutlineApp, LPRECT lprcFrameRect);
void OutlineApp_GetClientAreaRect(
		LPOUTLINEAPP        lpOutlineApp,
		LPRECT              lprcClientAreaRect
);
void OutlineApp_GetStatusLineRect(
		LPOUTLINEAPP        lpOutlineApp,
		LPRECT              lprcStatusLineRect
);
void OutlineApp_ResizeWindows(LPOUTLINEAPP lpOutlineApp);
void OutlineApp_ResizeClientArea(LPOUTLINEAPP lpOutlineApp);
void OutlineApp_AboutCommand(LPOUTLINEAPP lpOutlineApp);
void OutlineApp_NewCommand(LPOUTLINEAPP lpOutlineApp);
void OutlineApp_OpenCommand(LPOUTLINEAPP lpOutlineApp);
void OutlineApp_PrintCommand(LPOUTLINEAPP lpOutlineApp);
BOOL OutlineApp_SaveCommand(LPOUTLINEAPP lpOutlineApp);
BOOL OutlineApp_SaveAsCommand(LPOUTLINEAPP lpOutlineApp);
BOOL OutlineApp_CloseAllDocsAndExitCommand(
		LPOUTLINEAPP        lpOutlineApp,
		BOOL                fForceEndSession
);
void OutlineApp_DestroyWindow(LPOUTLINEAPP lpOutlineApp);

#if defined( USE_FRAMETOOLS )
void OutlineApp_SetBorderSpace(
		LPOUTLINEAPP        lpOutlineApp,
		LPBORDERWIDTHS      lpBorderWidths
);
LPFRAMETOOLS OutlineApp_GetFrameTools(LPOUTLINEAPP lpOutlineApp);
void OutlineApp_SetFormulaBarAccel(
		LPOUTLINEAPP            lpOutlineApp,
		BOOL                    fEditFocus
);
#endif  // USE_FRAMETOOLS

void OutlineApp_SetStatusText(LPOUTLINEAPP lpOutlineApp, LPSTR lpszMessage);
LPOUTLINEDOC OutlineApp_GetActiveDoc(LPOUTLINEAPP lpOutlineApp);
HMENU OutlineApp_GetMenu(LPOUTLINEAPP lpOutlineApp);
HFONT OutlineApp_GetActiveFont(LPOUTLINEAPP lpOutlineApp);
HDC OutlineApp_GetPrinterDC(LPOUTLINEAPP lpApp);
void OutlineApp_PrinterSetupCommand(LPOUTLINEAPP lpOutlineApp);
void OutlineApp_ErrorMessage(LPOUTLINEAPP lpOutlineApp, LPSTR lpszMsg);
void OutlineApp_GetAppVersionNo(LPOUTLINEAPP lpOutlineApp, int narrAppVersionNo[]);
void OutlineApp_GetAppName(LPOUTLINEAPP lpOutlineApp, LPSTR lpszAppName);
BOOL OutlineApp_VersionNoCheck(LPOUTLINEAPP lpOutlineApp, LPSTR lpszAppName, int narrAppVersionNo[]);
void OutlineApp_SetEditText(LPOUTLINEAPP lpApp);
void OutlineApp_SetFocusEdit(LPOUTLINEAPP lpApp, BOOL bFocusEdit);
BOOL OutlineApp_GetFocusEdit(LPOUTLINEAPP lpApp);
void OutlineApp_ForceRedraw(LPOUTLINEAPP lpOutlineApp, BOOL fErase);

/* struct definition for persistant data storage of OutlineDoc data */

#pragma pack(push, 2)
typedef struct tagOUTLINEDOCHEADER_ONDISK {
	char        m_szFormatName[32];
	short       m_narrAppVersionNo[2];
	USHORT      m_fShowHeading;
	DWORD       m_reserved1;            // space reserved for future use
	DWORD       m_reserved2;            // space reserved for future use
	DWORD       m_reserved3;            // space reserved for future use
	DWORD       m_reserved4;            // space reserved for future use
} OUTLINEDOCHEADER_ONDISK, FAR* LPOUTLINEDOCHEADER_ONDISK;
#pragma pack(pop)

typedef struct tagOUTLINEDOCHEADER {
	char        m_szFormatName[32];
	int         m_narrAppVersionNo[2];
	BOOL        m_fShowHeading;
	DWORD       m_reserved1;            // space reserved for future use
	DWORD       m_reserved2;            // space reserved for future use
	DWORD       m_reserved3;            // space reserved for future use
	DWORD       m_reserved4;            // space reserved for future use
} OUTLINEDOCHEADER, FAR* LPOUTLINEDOCHEADER;

#pragma pack(push,2)
typedef struct tagLINELISTHEADER_ONDISK {
	USHORT      m_nNumLines;
	DWORD       m_reserved1;            // space reserved for future use
	DWORD       m_reserved2;            // space reserved for future use
} LINELISTHEADER_ONDISK, FAR* LPLINELISTHEADER_ONDISK;
#pragma pack(pop)

typedef struct tagLINELISTHEADER {
	int         m_nNumLines;
	DWORD       m_reserved1;            // space reserved for future use
	DWORD       m_reserved2;            // space reserved for future use
} LINELISTHEADER, FAR* LPLINELISTHEADER;

#pragma pack(push,2)
typedef struct tagLINERECORD_ONDISK {
	USHORT      m_lineType;
	USHORT      m_nTabLevel;
	USHORT      m_nTabWidthInHimetric;
	USHORT      m_nWidthInHimetric;
	USHORT      m_nHeightInHimetric;
	DWORD       m_reserved;         // space reserved for future use
} LINERECORD_ONDISK, FAR* LPLINERECORD_ONDISK;
#pragma pack(pop)

typedef struct tagLINERECORD {
	LINETYPE    m_lineType;
	UINT        m_nTabLevel;
	UINT        m_nTabWidthInHimetric;
	UINT        m_nWidthInHimetric;
	UINT        m_nHeightInHimetric;
	DWORD       m_reserved;         // space reserved for future use
} LINERECORD, FAR* LPLINERECORD;


/* Function prototypes in main.c */
int PASCAL WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance,
						LPSTR lpszCmdLine, int nCmdShow);
BOOL MyTranslateAccelerator(LPMSG lpmsg);
int GetAccelItemCount(HACCEL hAccel);

LRESULT CALLBACK EXPORT AppWndProc(HWND hWnd, UINT Message, WPARAM wParam,
						LPARAM lParam);
LRESULT CALLBACK EXPORT DocWndProc(HWND hWnd, UINT Message, WPARAM wParam,
						LPARAM lParam);

/* Function prototypes in outldlgs.c */
BOOL InputTextDlg(HWND hWnd, LPSTR lpszText, LPSTR lpszDlgTitle);
BOOL CALLBACK EXPORT AddEditDlgProc(HWND, UINT, WPARAM, LPARAM);
BOOL CALLBACK EXPORT SetLineHeightDlgProc(HWND hDlg, UINT Message, WPARAM wParam, LPARAM lParam);
BOOL CALLBACK EXPORT DefineNameDlgProc(HWND, UINT, WPARAM, LPARAM);
BOOL CALLBACK EXPORT GotoNameDlgProc(HWND, UINT, WPARAM, LPARAM);
void NameDlg_LoadComboBox(LPOUTLINENAMETABLE lpOutlineNameTable,HWND hCombo);
void NameDlg_LoadListBox(LPOUTLINENAMETABLE lpOutlineNameTable,HWND hListBox);
void NameDlg_AddName(HWND hCombo, LPOUTLINEDOC lpOutlineDoc, LPSTR lpszName, LPLINERANGE lplrSel);
void NameDlg_UpdateName(HWND hCombo, LPOUTLINEDOC lpOutlineDoc, int nIndex, LPSTR lpszName, LPLINERANGE lplrSel);
void NameDlg_DeleteName(HWND hCombo, LPOUTLINEDOC lpOutlineDoc, UINT nIndex);
BOOL CALLBACK EXPORT AboutDlgProc(HWND hDlg, UINT Message, WPARAM wParam, LPARAM lParam);

/* Function prototypes in outldata.c */
LPVOID New(DWORD lSize);
void Delete(LPVOID p);

/* Function prototypes in outlprnt.c */
BOOL CALLBACK EXPORT AbortProc (HDC hdc, WORD reserved);
BOOL CALLBACK EXPORT PrintDlgProc(HWND hwnd, WORD msg, WORD wParam, LONG lParam);

/* Function prototypes in debug.c */
void SetDebugLevelCommand(void);
void TraceDebug(HWND, int);


// now declare test functions

extern HWND g_hwndDriver;

void StartClipboardTest1( LPOUTLINEAPP lpOutlineApp );
void ContinueClipboardTest1( LPOUTLINEAPP lpOutlineApp );

#if defined( OLE_VERSION )
#include "oleoutl.h"

#endif  // OLE_VERSION


#endif // _OUTLINE_H_


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\letest\outline\outlline.c ===
/*************************************************************************
**
**    OLE 2 Sample Code
**
**    outlline.c
**
**    This file contains Line functions.
**
**    (c) Copyright Microsoft Corp. 1992 - 1993 All Rights Reserved
**
*************************************************************************/


#include "outline.h"


OLEDBGDATA

extern LPOUTLINEAPP g_lpApp;


/* Line_Init
 * ---------
 *
 *      Init the calculated data of a line object
 */
void Line_Init(LPLINE lpLine, int nTab, HDC hDC)
{
	lpLine->m_lineType              = UNKNOWNLINETYPE;
	lpLine->m_nTabLevel             = nTab;
	lpLine->m_nTabWidthInHimetric   = Line_CalcTabWidthInHimetric(lpLine,hDC);
	lpLine->m_nWidthInHimetric      = 0;
	lpLine->m_nHeightInHimetric     = 0;
	lpLine->m_fSelected             = FALSE;

#if defined( USE_DRAGDROP )
	lpLine->m_fDragOverLine         = FALSE;
#endif
}


/* Line_Edit
 * ---------
 *
 *      Edit the line object.
 *
 *      Returns TRUE if line was changed
 *              FALSE if the line was NOT changed
 */
BOOL Line_Edit(LPLINE lpLine, HWND hWndDoc, HDC hDC)
{
	switch (lpLine->m_lineType) {
		case TEXTLINETYPE:
			return TextLine_Edit((LPTEXTLINE)lpLine, hWndDoc, hDC);

#if defined( OLE_CNTR )
		case CONTAINERLINETYPE:
			ContainerLine_Edit((LPCONTAINERLINE)lpLine, hWndDoc, hDC);
			break;
#endif

		default:
			return FALSE;       // unknown line type
	}
}


/* Line_GetLineType
 * ----------------
 *
 * Return type of the line
 */
LINETYPE Line_GetLineType(LPLINE lpLine)
{
	if (! lpLine) return 0;

	return lpLine->m_lineType;
}


/* Line_GetTextLen
 * ---------------
 *
 * Return length of string representation of the Line
 *  (not considering the tab level).
 */
int Line_GetTextLen(LPLINE lpLine)
{
	switch (lpLine->m_lineType) {
		case TEXTLINETYPE:
			return TextLine_GetTextLen((LPTEXTLINE)lpLine);

#if defined( OLE_CNTR )
		case CONTAINERLINETYPE:
			return ContainerLine_GetTextLen((LPCONTAINERLINE)lpLine);
#endif

		default:
			return 0;       // unknown line type
	}
}


/* Line_GetTextData
 * ----------------
 *
 * Return the string representation of the Line.
 *  (not considering the tab level).
 */
void Line_GetTextData(LPLINE lpLine, LPSTR lpszBuf)
{
	switch (lpLine->m_lineType) {
		case TEXTLINETYPE:
			TextLine_GetTextData((LPTEXTLINE)lpLine, lpszBuf);
			break;

#if defined( OLE_CNTR )
		case CONTAINERLINETYPE:
			ContainerLine_GetTextData((LPCONTAINERLINE)lpLine, lpszBuf);
			break;
#endif

		default:
			*lpszBuf = '\0';
			return;     // unknown line type
	}
}


/* Line_GetOutlineData
 * -------------------
 *
 * Return the CF_OUTLINE format representation of the Line.
 */
BOOL Line_GetOutlineData(LPLINE lpLine, LPTEXTLINE lpBuf)
{
	switch (lpLine->m_lineType) {
		case TEXTLINETYPE:
			return TextLine_GetOutlineData((LPTEXTLINE)lpLine, lpBuf);

#if defined( OLE_CNTR )
		case CONTAINERLINETYPE:
			return ContainerLine_GetOutlineData(
					(LPCONTAINERLINE)lpLine,
					lpBuf
			);
#endif

		default:
			return FALSE;       // unknown line type
	}
}


/* Line_CalcTabWidthInHimetric
 * ---------------------------
 *
 *      Recalculate the width for the line's current tab level
 */
static int Line_CalcTabWidthInHimetric(LPLINE lpLine, HDC hDC)
{
	int nTabWidthInHimetric;

	nTabWidthInHimetric=lpLine->m_nTabLevel * TABWIDTH;
	return nTabWidthInHimetric;
}


/* Line_Indent
 * -----------
 *
 *      Increment the tab level for the line
 */
void Line_Indent(LPLINE lpLine, HDC hDC)
{
	lpLine->m_nTabLevel++;
	lpLine->m_nTabWidthInHimetric = Line_CalcTabWidthInHimetric(lpLine, hDC);

#if defined( INPLACE_CNTR )
	if (Line_GetLineType(lpLine) == CONTAINERLINETYPE)
		ContainerLine_UpdateInPlaceObjectRects((LPCONTAINERLINE)lpLine, NULL);
#endif
}


/* Line_Unindent
 * -------------
 *
 * Decrement the tab level for the line
 */
void Line_Unindent(LPLINE lpLine, HDC hDC)
{
	if(lpLine->m_nTabLevel > 0) {
		lpLine->m_nTabLevel--;
		lpLine->m_nTabWidthInHimetric = Line_CalcTabWidthInHimetric(lpLine, hDC);
	}

#if defined( INPLACE_CNTR )
	if (Line_GetLineType(lpLine) == CONTAINERLINETYPE)
		ContainerLine_UpdateInPlaceObjectRects((LPCONTAINERLINE)lpLine, NULL);
#endif
}


/* Line_GetTotalWidthInHimetric
 * ----------------------------
 *
 *      Calculate the total width of the line
 */
UINT Line_GetTotalWidthInHimetric(LPLINE lpLine)
{
	return lpLine->m_nWidthInHimetric + lpLine->m_nTabWidthInHimetric;
}


/* Line_SetWidthInHimetric
 * -----------------------
 *
 *      Set the width of the line
 */
void Line_SetWidthInHimetric(LPLINE lpLine, int nWidth)
{
	if (!lpLine)
		return;

	lpLine->m_nWidthInHimetric = nWidth;
}


/* Line_GetWidthInHimetric
 * -----------------------
 *
 *      Return the width of the line
 */
UINT Line_GetWidthInHimetric(LPLINE lpLine)
{
	if (!lpLine)
		return 0;

	return lpLine->m_nWidthInHimetric;
}





/* Line_GetTabLevel
 * ----------------
 *
 * Return the tab level of a line object.
 */
UINT Line_GetTabLevel(LPLINE lpLine)
{
	return lpLine->m_nTabLevel;
}


/* Line_DrawToScreen
 * -----------------
 *
 *      Draw the item in the owner-draw listbox
 */
void Line_DrawToScreen(
		LPLINE      lpLine,
		HDC         hDC,
		LPRECT      lprcPix,
		UINT        itemAction,
		UINT        itemState,
		LPRECT      lprcDevice
)
{
	if (!lpLine || !hDC || !lprcPix || !lprcDevice)
		return;

	/* Draw a list box item in its normal drawing action.
	 * Then check if it is selected or has the focus state, and call
	 * functions to handle drawing for these states if necessary.
	 */
	if(itemAction & (ODA_SELECT | ODA_DRAWENTIRE)) {
		HFONT hfontOld;
		int nMapModeOld;
		RECT rcWindowOld;
		RECT rcViewportOld;
		RECT rcLogical;

		// NOTE: we have to set the device context to HIMETRIC in order
		// draw the line; however, we have to restore the HDC before
		// we draw focus or dragfeedback...

		rcLogical.left = 0;
		rcLogical.bottom = 0;
		rcLogical.right = lpLine->m_nWidthInHimetric;
		rcLogical.top = lpLine->m_nHeightInHimetric;

		{
			HBRUSH hbr;
			RECT    rcDraw;

			lpLine->m_fSelected = (BOOL)(itemState & ODS_SELECTED);

			if (ODS_SELECTED & itemState) {
				/*Get proper txt colors */
				hbr = CreateSolidBrush(GetSysColor(COLOR_HIGHLIGHT));
			}
			else {
				hbr = CreateSolidBrush(GetSysColor(COLOR_WINDOW));
			}

			rcDraw = *lprcPix;
			rcDraw.right = lprcDevice->left;
			FillRect(hDC, lprcPix, hbr);

			rcDraw = *lprcPix;
			rcDraw.left = lprcDevice->right;
			FillRect(hDC, lprcPix, hbr);

			DeleteObject(hbr);
		}

		nMapModeOld=SetDCToAnisotropic(hDC, lprcDevice, &rcLogical,
							(LPRECT)&rcWindowOld, (LPRECT)&rcViewportOld);

		// Set the default font size, and font face name
		hfontOld = SelectObject(hDC, OutlineApp_GetActiveFont(g_lpApp));

		Line_Draw(lpLine, hDC, &rcLogical, NULL, (ODS_SELECTED & itemState));

		SelectObject(hDC, hfontOld);

		ResetOrigDC(hDC, nMapModeOld, (LPRECT)&rcWindowOld,
				(LPRECT)&rcViewportOld);

#if defined( OLE_CNTR )
		if ((itemState & ODS_SELECTED) &&
			(Line_GetLineType(lpLine)==CONTAINERLINETYPE))
			ContainerLine_DrawSelHilight(
					(LPCONTAINERLINE)lpLine,
					hDC,
					lprcPix,
					ODA_SELECT,
					ODS_SELECTED
			);
#endif

	}

	/* If a list box item just gained or lost the focus,
	* call function (which could check if ODS_FOCUS bit is set)
	* and draws item in focus or non-focus state.
	*/
	if(itemAction & ODA_FOCUS )
		Line_DrawFocusRect(lpLine, hDC, lprcPix, itemAction, itemState);


#if defined( OLE_CNTR )
	if (Line_GetLineType(lpLine) == CONTAINERLINETYPE) {
		LPCONTAINERLINE lpContainerLine = (LPCONTAINERLINE)lpLine;
		LPCONTAINERDOC lpDoc = lpContainerLine->m_lpDoc;
		BOOL fIsLink;
		RECT rcObj;

		if (ContainerDoc_GetShowObjectFlag(lpDoc)) {
			ContainerLine_GetOleObjectRectInPixels(lpContainerLine, &rcObj);
			fIsLink = ContainerLine_IsOleLink(lpContainerLine);
			OleUIShowObject(&rcObj, hDC, fIsLink);
		}
	}
#endif

#if defined( USE_DRAGDROP )
	if (lpLine->m_fDragOverLine)
		Line_DrawDragFeedback(lpLine, hDC, lprcPix, itemState );
#endif

}


/* Line_Draw
 * ---------
 *
 *  Draw a line on a DC.
 *
 * Parameters:
 *      hDC     - DC to which the line will be drawn
 *      lpRect  - the object rect in logical coordinates
 */
void Line_Draw(
		LPLINE      lpLine,
		HDC         hDC,
		LPRECT      lpRect,
		LPRECT      lpRectWBounds,
		BOOL        fHighlight
)
{
	switch (lpLine->m_lineType) {
		case TEXTLINETYPE:
			TextLine_Draw(
				 (LPTEXTLINE)lpLine, hDC, lpRect,lpRectWBounds,fHighlight);
			break;

#if defined( OLE_CNTR )
		case CONTAINERLINETYPE:
			ContainerLine_Draw(
				 (LPCONTAINERLINE)lpLine,hDC,lpRect,lpRectWBounds,fHighlight);
			break;
#endif

		default:
			return;     // unknown line type
	}
	return;
}


/* Line_DrawSelHilight
 * -------------------
 *
 *      Handles selection of list box item
 */
void Line_DrawSelHilight(LPLINE lpLine, HDC hDC, LPRECT lpRect, UINT itemAction, UINT itemState)
{
	switch (lpLine->m_lineType) {
		case TEXTLINETYPE:
			TextLine_DrawSelHilight((LPTEXTLINE)lpLine, hDC, lpRect,
				itemAction, itemState);
			break;

#if defined( OLE_CNTR )
		case CONTAINERLINETYPE:
			ContainerLine_DrawSelHilight((LPCONTAINERLINE)lpLine, hDC, lpRect,
				itemAction, itemState);
			break;
#endif

		default:
			return;     // unknown line type
	}
	return;

}

/* Line_DrawFocusRect
 * ------------------
 *
 *      Handles focus state of list box item
 */
void Line_DrawFocusRect(LPLINE lpLine, HDC hDC, LPRECT lpRect, UINT itemAction, UINT itemState)
{
	if(lpLine)
		DrawFocusRect(hDC, lpRect);
}

#if defined( USE_DRAGDROP )

/* Line_DrawDragFeedback
 * ---------------------
 *
 *      Handles focus state of list box item
 */
void Line_DrawDragFeedback(LPLINE lpLine, HDC hDC, LPRECT lpRect, UINT itemState )
{
	if(lpLine)
		DrawFocusRect(hDC, lpRect);
}

#endif  // USE_DRAGDROP


/* Line_GetHeightInHimetric
 * ------------------------
 *
 *      Return the height of the item in HIMETRIC units
 */
UINT Line_GetHeightInHimetric(LPLINE lpLine)
{
	if (!lpLine)
		return 0;

	return (UINT)lpLine->m_nHeightInHimetric;
}


/* Line_SetHeightInHimetric
 * ------------------------
 *
 *      Set the height of the item in HIMETRIC units.
 */
void Line_SetHeightInHimetric(LPLINE lpLine, int nHeight)
{
	if (!lpLine)
		return;

	switch (lpLine->m_lineType) {
		case TEXTLINETYPE:
			TextLine_SetHeightInHimetric((LPTEXTLINE)lpLine, nHeight);
			break;

#if defined( OLE_CNTR )
		case CONTAINERLINETYPE:
			ContainerLine_SetHeightInHimetric((LPCONTAINERLINE)lpLine,
					nHeight);
			break;
#endif

	}
}


/* Line_Delete
 * -----------
 *
 *      Delete the Line structure
 */
void Line_Delete(LPLINE lpLine)
{
	switch (lpLine->m_lineType) {
		case TEXTLINETYPE:
			TextLine_Delete((LPTEXTLINE)lpLine);
			break;

#if defined( OLE_CNTR )
		case CONTAINERLINETYPE:
			ContainerLine_Delete((LPCONTAINERLINE)lpLine);
			break;
#endif

		default:
			break;      // unknown line type
	}
}


/* Line_CopyToDoc
 * --------------
 *
 *      Copy a line to another Document (usually ClipboardDoc)
 */
BOOL Line_CopyToDoc(LPLINE lpSrcLine, LPOUTLINEDOC lpDestDoc, int nIndex)
{
	switch (lpSrcLine->m_lineType) {
		case TEXTLINETYPE:
			return TextLine_CopyToDoc((LPTEXTLINE)lpSrcLine,lpDestDoc,nIndex);
			break;

#if defined( OLE_CNTR )
		case CONTAINERLINETYPE:
			return ContainerLine_CopyToDoc(
					(LPCONTAINERLINE)lpSrcLine,
					lpDestDoc,
					nIndex
			);
			break;
#endif

		default:
			return FALSE;       // unknown line type
	}
}


/* Line_SaveToStg
 * --------------
 *
 *      Save a single line object to a storage
 *
 *      Return TRUE if successful, FALSE otherwise
 */
BOOL Line_SaveToStg(LPLINE lpLine, UINT uFormat, LPSTORAGE lpSrcStg, LPSTORAGE lpDestStg, LPSTREAM lpLLStm, BOOL fRemember)
{
	LINERECORD_ONDISK lineRecord;
	ULONG nWritten;
	HRESULT hrErr;
	BOOL fStatus;
	LARGE_INTEGER dlibSavePos;
	LARGE_INTEGER dlibZeroOffset;
	LISet32( dlibZeroOffset, 0 );

	/* save seek position before line record is written in case of error */
	hrErr = lpLLStm->lpVtbl->Seek(
			lpLLStm,
			dlibZeroOffset,
			STREAM_SEEK_CUR,
			(ULARGE_INTEGER FAR*)&dlibSavePos
	);
	if (hrErr != NOERROR) return FALSE;

#if defined( OLE_CNTR )
	if (lpLine->m_lineType == CONTAINERLINETYPE) {
		/* OLE2NOTE: asking an OLE object to save may cause the
		**    object to send an OnViewChange notification if there are any
		**    outstanding changes to the object. this is particularly true
		**    for objects with coarse update granularity like OLE 1.0
		**    objects. if an OnViewChange notification is received then the
		**    object's presentation cache will be updated BEFORE it is
		**    saved. It is important that the extents stored as part of
		**    the ContainerLine/Line record associated with the OLE object
		**    are updated before the Line data is saved to the storage. it
		**    is important that this extent information matches the data
		**    saved with the OLE object. the Line extent information is
		**    updated in the IAdviseSink::OnViewChange method implementation.
		*/
		// only save the OLE object if format is compatible.
		if (uFormat != ((LPCONTAINERAPP)g_lpApp)->m_cfCntrOutl)
			goto error;

		fStatus = ContainerLine_SaveOleObjectToStg(
				(LPCONTAINERLINE)lpLine,
				lpSrcStg,
				lpDestStg,
				fRemember
		);
		if (! fStatus) goto error;
	}
#endif

        //  Compilers should handle aligment correctly
	lineRecord.m_lineType = (USHORT) lpLine->m_lineType;
	lineRecord.m_nTabLevel = (USHORT) lpLine->m_nTabLevel;
	lineRecord.m_nTabWidthInHimetric = (USHORT) lpLine->m_nTabWidthInHimetric;
	lineRecord.m_nWidthInHimetric = (USHORT) lpLine->m_nWidthInHimetric;
	lineRecord.m_nHeightInHimetric = (USHORT) lpLine->m_nHeightInHimetric;
        lineRecord.m_reserved = 0;

	/* write line record header */
	hrErr = lpLLStm->lpVtbl->Write(
			lpLLStm,
			(LPVOID)&lineRecord,
			sizeof(lineRecord),
			&nWritten
	);

	if (hrErr != NOERROR) {
		OleDbgOutHResult("Write Line header returned", hrErr);
		goto error;
    }

	switch (lpLine->m_lineType) {
		case TEXTLINETYPE:
			fStatus = TextLine_SaveToStm((LPTEXTLINE)lpLine, lpLLStm);
			if (! fStatus) goto error;
			break;

#if defined( OLE_CNTR )
		case CONTAINERLINETYPE:
			fStatus=ContainerLine_SaveToStm((LPCONTAINERLINE)lpLine,lpLLStm);
			if (! fStatus) goto error;
			break;
#endif

		default:
			goto error;       // unknown line type
	}

	return TRUE;

error:

	/* retore seek position prior to writing Line record */
	lpLLStm->lpVtbl->Seek(
			lpLLStm,
			dlibSavePos,
			STREAM_SEEK_SET,
			NULL
	);

	return FALSE;
}


/* Line_LoadFromStg
 * ----------------
 *
 *      Load a single line object from storage
 */
LPLINE Line_LoadFromStg(LPSTORAGE lpSrcStg, LPSTREAM lpLLStm, LPOUTLINEDOC lpDestDoc)
{
	LINERECORD_ONDISK lineRecord;
	LPLINE lpLine = NULL;
	ULONG nRead;
	HRESULT hrErr;

	/* read line record header */
	hrErr = lpLLStm->lpVtbl->Read(
			lpLLStm,
			(LPVOID)&lineRecord,
			sizeof(lineRecord),
			&nRead
	);

	if (hrErr != NOERROR) {
		OleDbgOutHResult("Read Line header returned", hrErr);
		return NULL;
    }

	switch ((LINETYPE) lineRecord.m_lineType) {
		case TEXTLINETYPE:
			lpLine = TextLine_LoadFromStg(lpSrcStg, lpLLStm, lpDestDoc);
			break;

#if defined( OLE_CNTR )
		case CONTAINERLINETYPE:
			lpLine = ContainerLine_LoadFromStg(lpSrcStg, lpLLStm, lpDestDoc);
			break;
#endif

		default:
			return NULL;        // unknown line type
	}

	lpLine->m_lineType = (LINETYPE) lineRecord.m_lineType;
	lpLine->m_nTabLevel = (UINT) lineRecord.m_nTabLevel;
	lpLine->m_nTabWidthInHimetric = (UINT) lineRecord.m_nTabWidthInHimetric;
	lpLine->m_nWidthInHimetric = (UINT) lineRecord.m_nWidthInHimetric;
	lpLine->m_nHeightInHimetric = (UINT) lineRecord.m_nHeightInHimetric;

	return lpLine;
}


/* Line_IsSelected
 * ---------------
 *
 *      Return the selection state of the line
 */
BOOL Line_IsSelected(LPLINE lpLine)
{
	if (!lpLine)
		return FALSE;

	return lpLine->m_fSelected;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\letest\outline\outllist.c ===
/*************************************************************************
**
**    OLE 2 Sample Code
**
**    outldata.c
**
**    This file contains LineList and NameTable functions
**    and related support functions.
**
**    (c) Copyright Microsoft Corp. 1992 - 1993 All Rights Reserved
**
*************************************************************************/


#include "outline.h"

OLEDBGDATA

extern LPOUTLINEAPP g_lpApp;

char ErrMsgListBox[] = "Can't create ListBox!";

static int g_iMapMode;

/* LineList_Init
 * -------------
 *
 *      Create and Initialize the LineList (owner-drawn listbox)
 */
BOOL LineList_Init(LPLINELIST lpLL, LPOUTLINEDOC lpOutlineDoc)
{
	LPOUTLINEAPP lpOutlineApp = (LPOUTLINEAPP)g_lpApp;

#if defined( INPLACE_CNTR )
	lpLL->m_hWndListBox = CreateWindow(
					"listbox",              /* Window class name           */
					NULL,                   /* Window's title              */

					/* OLE2NOTE: an in-place contanier MUST use
					**    WS_CLIPCHILDREN window style for the window
					**    that it uses as the parent for the server's
					**    in-place active window so that its
					**    painting does NOT interfere with the painting
					**    of the server's in-place active child window.
					*/

					WS_CLIPCHILDREN |
					WS_CHILDWINDOW |
					WS_VISIBLE |
					WS_VSCROLL |
					WS_HSCROLL |
					LBS_EXTENDEDSEL |
					LBS_NOTIFY |
					LBS_OWNERDRAWVARIABLE |
					LBS_NOINTEGRALHEIGHT |
					LBS_USETABSTOPS,
					0, 0,                   /* Use default X, Y            */
					0, 0,                   /* Use default X, Y            */
					lpOutlineDoc->m_hWndDoc,/* Parent window's handle      */
					(HMENU)IDC_LINELIST,    /* Child Window ID             */
					lpOutlineApp->m_hInst,  /* Instance of window          */
					NULL);                  /* Create struct for WM_CREATE */
#else
	lpLL->m_hWndListBox = CreateWindow(
					"listbox",              /* Window class name           */
					NULL,                   /* Window's title              */
					WS_CHILDWINDOW |
					WS_VISIBLE |
					WS_VSCROLL |
					WS_HSCROLL |
					LBS_EXTENDEDSEL |
					LBS_NOTIFY |
					LBS_OWNERDRAWVARIABLE |
					LBS_NOINTEGRALHEIGHT |
					LBS_USETABSTOPS,
					0, 0,                   /* Use default X, Y            */
					0, 0,                   /* Use default X, Y            */
					lpOutlineDoc->m_hWndDoc,/* Parent window's handle      */
					(HMENU)IDC_LINELIST,    /* Child Window ID             */
					lpOutlineApp->m_hInst,  /* Instance of window          */
					NULL);                  /* Create struct for WM_CREATE */

#endif


	if(! lpLL->m_hWndListBox) {
		OutlineApp_ErrorMessage(g_lpApp, ErrMsgListBox);
		return FALSE;
	}

	lpOutlineApp->m_ListBoxWndProc =
			(FARPROC) GetWindowLongPtr ( lpLL->m_hWndListBox, GWLP_WNDPROC );
	SetWindowLongPtr (lpLL->m_hWndListBox, GWLP_WNDPROC, (LONG_PTR) LineListWndProc);

#if defined ( USE_DRAGDROP )
	/* m_iDragOverLine saves index of line that has drag/drop target
	**    feedback. we currently use our focus rectangle feedback for
	**    this. it would be better to have a different visual feedback
	**    for potential target of the pending drop.
	*/
	lpLL->m_iDragOverLine = -1;
#endif

	lpLL->m_nNumLines = 0;
	lpLL->m_nMaxLineWidthInHimetric = 0;
	lpLL->m_lpDoc = lpOutlineDoc;
	_fmemset(&lpLL->m_lrSaveSel, 0, sizeof(LINERANGE));

	return TRUE;
}


/* LineList_Destroy
 * ----------------
 *
 *      Clear (delete) all Line objects from the list and free supporting
 *      memory (ListBox Window) used by the LineList object itself.
 */
void LineList_Destroy(LPLINELIST lpLL)
{
	int i;
	int linesTotal = lpLL->m_nNumLines;

	// Delete all Line objects
	for (i = 0; i < linesTotal; i++)
		LineList_DeleteLine(lpLL, 0);   // NOTE: always delete line 0

	// Remove all Lines from the ListBox
	SendMessage(lpLL->m_hWndListBox,LB_RESETCONTENT,0,0L);

	lpLL->m_nNumLines=0;
	DestroyWindow(lpLL->m_hWndListBox);
	lpLL->m_hWndListBox = NULL;
}


/* LineList_AddLine
 * ----------------
 *
 *      Add one line to the list box. The line is added following the
 * line with index "nIndex". If nIndex is larger than the number of lines
 * in the ListBox, then the line is appended to the end. The selection
 * is set to the newly added line.
 */
void LineList_AddLine(LPLINELIST lpLL, LPLINE lpLine, int nIndex)
{
	int nAddIndex = (lpLL->m_nNumLines == 0 ?
			0 :
			(nIndex >= lpLL->m_nNumLines ? lpLL->m_nNumLines : nIndex+1));
	LINERANGE lrSel;

#if defined( USE_HEADING )
	int nHeight = Line_GetHeightInHimetric(lpLine);

	nHeight = XformHeightInHimetricToPixels(NULL, nHeight);

	// Add a dummy string to the row heading
	Heading_RH_SendMessage(OutlineDoc_GetHeading(lpLL->m_lpDoc),
			LB_INSERTSTRING, (WPARAM)nAddIndex, MAKELPARAM(nHeight, 0));
#endif


	lrSel.m_nStartLine = nAddIndex;
	lrSel.m_nEndLine =   nAddIndex;

	if (!lpLine) {
		OutlineApp_ErrorMessage(g_lpApp, "Could not create line.");
		return;
	}

	SendMessage(lpLL->m_hWndListBox, LB_INSERTSTRING, (WPARAM)nAddIndex,
			(DWORD)lpLine);

	LineList_SetMaxLineWidthInHimetric(
			lpLL,
			Line_GetTotalWidthInHimetric(lpLine)
	);

	lpLL->m_nNumLines++;

	LineList_SetSel(lpLL, &lrSel);
}


/* LineList_DeleteLine
 * -------------------
 *
 *      Delete one line from listbox and memory
 */
void LineList_DeleteLine(LPLINELIST lpLL, int nIndex)
{
	LPLINE lpLine = LineList_GetLine(lpLL, nIndex);
	BOOL fResetSel;

	fResetSel = (BOOL)SendMessage(lpLL->m_hWndListBox, LB_GETSEL, (WPARAM)nIndex, 0L);

	if (lpLine)
		Line_Delete(lpLine);    // free memory of Line

	// Remove the Line from the ListBox
	SendMessage(lpLL->m_hWndListBox, LB_DELETESTRING, (WPARAM)nIndex, 0L);
	lpLL->m_nNumLines--;

	if (fResetSel) {
		if (nIndex > 0) {
#if defined( WIN32 )
			SendMessage(
					lpLL->m_hWndListBox,
					LB_SETSEL,
					(WPARAM)TRUE,
					(LPARAM)nIndex-1
			);
#else
			SendMessage(
					lpLL->m_hWndListBox,
					LB_SETSEL,
					(WPARAM)TRUE,
					MAKELPARAM(nIndex-1,0)
			);
#endif
		} else {
			if (lpLL->m_nNumLines > 0) {
#if defined( WIN32 )
				SendMessage(
						lpLL->m_hWndListBox,
						LB_SETSEL,
						(WPARAM)TRUE,
						(LPARAM)0
				);
#else
				SendMessage(
						lpLL->m_hWndListBox,
						LB_SETSEL,
						(WPARAM)TRUE,
						MAKELPARAM(0,0)
				);
#endif
			}
		}
	}

#if defined( USE_HEADING )
	// Remove the dummy string from the row heading
	Heading_RH_SendMessage(OutlineDoc_GetHeading(lpLL->m_lpDoc),
			LB_DELETESTRING, (WPARAM)nIndex, 0L);
#endif

}


/* LineList_ReplaceLine
 * --------------------
 *
 *      Replace the line at a given index in the list box with a new
 * line.
 */
void LineList_ReplaceLine(LPLINELIST lpLL, LPLINE lpLine, int nIndex)
{
	LPLINE lpOldLine = LineList_GetLine(lpLL, nIndex);

	if (lpOldLine)
		Line_Delete(lpOldLine);    // free memory of Line
	else
		return;     // if no previous line then invalid index

	SendMessage(
			lpLL->m_hWndListBox,
			LB_SETITEMDATA,
			(WPARAM)nIndex,
			(LPARAM)lpLine
	);
}


/* LineList_GetLineIndex
 * ---------------------
 *
 *      Return the index of the Line given a pointer to the line.
 *      Return -1 if the line is not found.
 */
int LineList_GetLineIndex(LPLINELIST lpLL, LPLINE lpLine)
{
	LRESULT lRet;

	if (! lpLine) return -1;

	lRet = SendMessage(
			lpLL->m_hWndListBox,
			LB_FINDSTRING,
			(WPARAM)-1,
			(LPARAM)(LPCSTR)lpLine
		);

	return ((lRet == LB_ERR) ? -1 : (int)lRet);
}


/* LineList_GetLine
 * ----------------
 *
 *      Retrieve the pointer to the Line given its index in the LineList
 */
LPLINE LineList_GetLine(LPLINELIST lpLL, int nIndex)
{
	DWORD dWord;
	LRESULT lRet;

	if (lpLL->m_nNumLines == 0 || nIndex > lpLL->m_nNumLines || nIndex < 0)
		return NULL;

	lRet = SendMessage(
			lpLL->m_hWndListBox,LB_GETTEXT,nIndex,(LPARAM)(LPCSTR)&dWord);

	return ((lRet == LB_ERR || lRet == 0) ? NULL : (LPLINE)dWord);
}


/* LineList_SetFocusLine
 * ---------------------
 *
 */

void LineList_SetFocusLine ( LPLINELIST lpLL, WORD wIndex )
{

	SendMessage(lpLL->m_hWndListBox, LB_SETCARETINDEX, (WPARAM)wIndex, 0L );

}


/* LineList_GetLineRect
 * --------------------
 *
 * Retrieve the rectangle of a Line given its index in the LineList
 */
BOOL LineList_GetLineRect(LPLINELIST lpLL, int nIndex, LPRECT lpRect)
{
	DWORD iReturn = (DWORD)LB_ERR;

	if ( !(lpLL->m_nNumLines == 0 || nIndex > lpLL->m_nNumLines || nIndex < 0) )
		iReturn = SendMessage(lpLL->m_hWndListBox,LB_GETITEMRECT,nIndex,(LPARAM)lpRect);

	return (iReturn == LB_ERR ? FALSE : TRUE );
}


/* LineList_GetFocusLineIndex
 * --------------------------
 *
 * Get the index of the line that currently has focus (the active line).
 */
int LineList_GetFocusLineIndex(LPLINELIST lpLL)
{
	return (int)SendMessage(lpLL->m_hWndListBox,LB_GETCARETINDEX,0,0L);
}


/* LineList_GetCount
 * -----------------
 *
 *      Return number of line objects
 */
int LineList_GetCount(LPLINELIST lpLL)
{
	if (lpLL)
		return lpLL->m_nNumLines;
	else {
		OleDbgAssert(lpLL!=NULL);
		return 0;
	}
}


/* LineList_SetMaxLineWidthInHimetric
 * ----------------------------------
 *
 *  Adjust the maximum line width for the listbox. The max line width is
 *  used to determine if a horizontal scroll bar is needed.
 *
 *  Parameters:
 *      nWidthInHimetric - if +ve, width of an additional line
 *                       - if -ve, reset Max to be the value
 *
 *  Returns:
 *      TRUE is max line width of LineList changed
 *      FALSE if no change
 */
BOOL LineList_SetMaxLineWidthInHimetric(LPLINELIST lpLL, int nWidthInHimetric)
{
	int nWidthInPix;
	BOOL fSizeChanged = FALSE;
	LPSCALEFACTOR lpscale;

	if (!lpLL)
		return FALSE;

	lpscale = OutlineDoc_GetScaleFactor(lpLL->m_lpDoc);

	if (nWidthInHimetric < 0) {
		lpLL->m_nMaxLineWidthInHimetric = -1;
		nWidthInHimetric *= -1;
	}

	if (nWidthInHimetric > lpLL->m_nMaxLineWidthInHimetric) {
		lpLL->m_nMaxLineWidthInHimetric = nWidthInHimetric;
		nWidthInPix = XformWidthInHimetricToPixels(NULL, nWidthInHimetric +
				LOWORD(OutlineDoc_GetMargin(lpLL->m_lpDoc)) +
				HIWORD(OutlineDoc_GetMargin(lpLL->m_lpDoc)));

		nWidthInPix = (int)(nWidthInPix * lpscale->dwSxN / lpscale->dwSxD);
		SendMessage(
				lpLL->m_hWndListBox,
				LB_SETHORIZONTALEXTENT,
				nWidthInPix,
				0L
		);
		fSizeChanged = TRUE;

#if defined( USE_HEADING )
		Heading_CH_SetHorizontalExtent(
				OutlineDoc_GetHeading(lpLL->m_lpDoc), lpLL->m_hWndListBox);
#endif

	}
	return fSizeChanged;
}


/* LineList_GetMaxLineWidthInHimetric
 * ----------------------------------
 *
 *      Return the width of the widest line
 */
int LineList_GetMaxLineWidthInHimetric(LPLINELIST lpLL)
{
	return lpLL->m_nMaxLineWidthInHimetric;
}


/* LineList_RecalcMaxLineWidthInHimetric
 * -------------------------------------
 *
 *  Recalculate the maximum line width in the entire list.
 *
 *  Parameters:
 *      nWidthInHimetric should be set to the width of line being removed.
 *      nWidthInHimetric == 0 forces list to recalculate in all cases.
 *      nWidthInHimetric == current max width => forces recalc.
 *
 *  Returns:
 *      TRUE is max line width of LineList changed
 *      FALSE if no change
 */
BOOL LineList_RecalcMaxLineWidthInHimetric(
		LPLINELIST          lpLL,
	int                 nWidthInHimetric
)
{
	int i;
	LPLINE lpLine;
	BOOL fSizeChanged = FALSE;
	int nOrgMaxLineWidthInHimetric = lpLL->m_nMaxLineWidthInHimetric;

	if (nWidthInHimetric == 0 ||
		nWidthInHimetric == lpLL->m_nMaxLineWidthInHimetric) {

		lpLL->m_nMaxLineWidthInHimetric = -1;

		LineList_SetMaxLineWidthInHimetric(lpLL, 0);

		for(i = 0; i < lpLL->m_nNumLines; i++) {
			lpLine=LineList_GetLine(lpLL, i);
			LineList_SetMaxLineWidthInHimetric(
					lpLL,
					Line_GetTotalWidthInHimetric(lpLine)
			);
		}
	}

	if (nOrgMaxLineWidthInHimetric != lpLL->m_nMaxLineWidthInHimetric)
		fSizeChanged = TRUE;

	return fSizeChanged;
}


/* LineList_CalcSelExtentInHimetric
 * --------------------------------
 *
 *      Calculate the extents (widht and height) of a selection of lines.
 *
 * if lplrSel == NULL, calculate extent of all lines.
 */
void LineList_CalcSelExtentInHimetric(
		LPLINELIST          lpLL,
		LPLINERANGE         lplrSel,
		LPSIZEL             lpsizel
)
{
	int i;
	int nEndLine;
	int nStartLine;
	LPLINE lpLine;
	long lWidth;

	if (lplrSel) {
		nEndLine = lplrSel->m_nEndLine;
		nStartLine = lplrSel->m_nStartLine;
	} else {
		nEndLine = LineList_GetCount(lpLL) - 1;
		nStartLine = 0;
	}

	lpsizel->cx = 0;
	lpsizel->cy = 0;

	for(i = nStartLine; i <= nEndLine; i++) {
		lpLine=LineList_GetLine(lpLL,i);
		if (lpLine) {
			lWidth = (long)Line_GetTotalWidthInHimetric(lpLine);
			lpsizel->cx = max(lpsizel->cx, lWidth);
			lpsizel->cy += lpLine->m_nHeightInHimetric;
		}
	}
}


/* LineList_GetWindow
 * ------------------
 *
 * Return handle of list box
 */
HWND LineList_GetWindow(LPLINELIST lpLL)
{
	return lpLL->m_hWndListBox;
}


/* LineList_GetDC
 * --------------
 *
 * Return DC handle of list box
 */
HDC LineList_GetDC(LPLINELIST lpLL)
{
	HFONT hfontOld;
	HDC hDC = GetDC(lpLL->m_hWndListBox);
	int     iXppli;     //* pixels per logical inch along width
	int     iYppli;     //* pixels per logical inch along height
	SIZE    size;

	// Setup a mapping mode for the DC which maps physical pixel
	// coordinates to HIMETRIC units. The standard MM_HIMETRIC mapping
	// mode does not work correctly because it does not take into
	// account that a logical inch on the display screen is drawn
	// physically larger than 1 inch. We will setup an anisotropic
	// mapping mode which will perform the transformation properly.

	g_iMapMode = SetMapMode(hDC, MM_ANISOTROPIC);
	iXppli = GetDeviceCaps (hDC, LOGPIXELSX);
	iYppli = GetDeviceCaps (hDC, LOGPIXELSY);
	SetViewportExtEx(hDC, iXppli, iYppli, &size);
	SetWindowExtEx(hDC, HIMETRIC_PER_INCH, HIMETRIC_PER_INCH, &size);

	// Set the default font size, and font face name
	hfontOld = SelectObject(hDC, OutlineApp_GetActiveFont(g_lpApp));

	return hDC;
}


/* LineList_ReleaseDC
 * ------------------
 *
 *      Release DC of list box returned from previous LineList_GetDC call.
 */
void LineList_ReleaseDC(LPLINELIST lpLL, HDC hDC)
{
	SetMapMode(hDC, g_iMapMode);
	ReleaseDC(lpLL->m_hWndListBox, hDC);
}


/* LineList_SetLineHeight
 * ----------------------
 *
 *      Set the height of a line in the LineList list box
 */
void LineList_SetLineHeight(LPLINELIST lpLL,int nIndex,int nHeightInHimetric)
{
	LPARAM          lParam;
	LPOUTLINEDOC    lpDoc;
	LPSCALEFACTOR   lpscale;
	UINT            uHeightInPix;
	LPHEADING       lphead;

	if (!lpLL)
		return;

	lpDoc = lpLL->m_lpDoc;
	lphead = OutlineDoc_GetHeading(lpDoc);
	lpscale = OutlineDoc_GetScaleFactor(lpDoc);

	uHeightInPix = XformHeightInHimetricToPixels(NULL, nHeightInHimetric);

	Heading_RH_SendMessage(lphead, LB_SETITEMDATA, (WPARAM)nIndex,
			MAKELPARAM(uHeightInPix, 0));

	uHeightInPix = (UINT)(uHeightInPix * lpscale->dwSyN / lpscale->dwSyD);

	if (uHeightInPix > LISTBOX_HEIGHT_LIMIT)
		uHeightInPix = LISTBOX_HEIGHT_LIMIT;


	lParam = MAKELPARAM(uHeightInPix, 0);
	SendMessage(lpLL->m_hWndListBox,LB_SETITEMHEIGHT,(WPARAM)nIndex, lParam);
	Heading_RH_SendMessage(lphead, LB_SETITEMHEIGHT, (WPARAM)nIndex, lParam);
	Heading_RH_ForceRedraw(lphead, TRUE);
}


/* LineList_ReScale
 * ----------------
 *
 *      Re-scale the LineList list box
 */
void LineList_ReScale(LPLINELIST lpLL, LPSCALEFACTOR lpscale)
{
	int nIndex;
	LPLINE lpLine;
	UINT uWidthInHim;

	if (!lpLL)
		return;

	for (nIndex = 0; nIndex < lpLL->m_nNumLines; nIndex++) {
		lpLine = LineList_GetLine(lpLL, nIndex);
		if (lpLine) {
			LineList_SetLineHeight(
					lpLL,
					nIndex,
					Line_GetHeightInHimetric(lpLine)
			);
		}
	}

	uWidthInHim = LineList_GetMaxLineWidthInHimetric(lpLL);
	LineList_SetMaxLineWidthInHimetric(lpLL, -(int)uWidthInHim);
}

/* LineList_SetSel
 * ---------------
 *
 *      Set the selection in list box
 */
void LineList_SetSel(LPLINELIST lpLL, LPLINERANGE lplrSel)
{
	DWORD dwSel;

	if (lpLL->m_nNumLines <= 0 || lplrSel->m_nStartLine < 0)
		return;     // no lines in list; can't set a selection

	dwSel = MAKELPARAM(lplrSel->m_nStartLine, lplrSel->m_nEndLine);

	lpLL->m_lrSaveSel = *lplrSel;

	/* remove previous selection */
#if defined( WIN32 )
	SendMessage(
			lpLL->m_hWndListBox,
			LB_SETSEL,
			(WPARAM)FALSE,
			(LPARAM)-1
	);
#else
	SendMessage(
			lpLL->m_hWndListBox,
			LB_SETSEL,
			(WPARAM)FALSE,
			MAKELPARAM(-1,0)
	);
#endif

	/* mark selection */
	SendMessage(lpLL->m_hWndListBox,LB_SELITEMRANGE, (WPARAM)TRUE, (LPARAM)dwSel);
	/* set focus line (caret) */
	LineList_SetFocusLine ( lpLL, (WORD)lplrSel->m_nStartLine );

}


/* LineList_GetSel
 * ---------------
 *
 * Get the selection in list box.
 *
 * Returns the count of items selected
 */
int LineList_GetSel(LPLINELIST lpLL, LPLINERANGE lplrSel)
{
	int nNumSel=(int)SendMessage(lpLL->m_hWndListBox,LB_GETSELCOUNT,0,0L);

	if (nNumSel) {
		SendMessage(lpLL->m_hWndListBox,LB_GETSELITEMS,
			(WPARAM)1,(LPARAM)(int FAR*)&(lplrSel->m_nStartLine));
		lplrSel->m_nEndLine = lplrSel->m_nStartLine + nNumSel - 1;
	} else {
		_fmemset(lplrSel, 0, sizeof(LINERANGE));
	}
	return nNumSel;
}


/* LineList_RemoveSel
 * ------------------
 *
 * Remove the selection in list box but save the selection state so that
 * it can be restored by calling LineList_RestoreSel
 * LineList_RemoveSel is called when the LineList window looses focus.
 */
void LineList_RemoveSel(LPLINELIST lpLL)
{
	LINERANGE lrSel;
	if (LineList_GetSel(lpLL, &lrSel) > 0) {
		lpLL->m_lrSaveSel = lrSel;
#if defined( WIN32 )
		SendMessage(
				lpLL->m_hWndListBox,
				LB_SETSEL,
				(WPARAM)FALSE,
				(LPARAM)-1
		);
#else
		SendMessage(
				lpLL->m_hWndListBox,
				LB_SETSEL,
				(WPARAM)FALSE,
				MAKELPARAM(-1,0)
		);
#endif
	}
}


/* LineList_RestoreSel
 * ------------------
 *
 * Restore the selection in list box that was previously saved by a call to
 * LineList_RemoveSel.
 * LineList_RestoreSel is called when the LineList window gains focus.
 */
void LineList_RestoreSel(LPLINELIST lpLL)
{
	LineList_SetSel(lpLL, &lpLL->m_lrSaveSel);
}


/* LineList_SetRedraw
 * ------------------
 *
 *      Enable/Disable the redraw of the linelist (listbox) on screen
 *
 *  fEnbaleDraw = TRUE      - enable redraw
 *                FALSE     - disable redraw
 */
void LineList_SetRedraw(LPLINELIST lpLL, BOOL fEnableDraw)
{
	SendMessage(lpLL->m_hWndListBox,WM_SETREDRAW,(WPARAM)fEnableDraw,0L);
}


/* LineList_ForceRedraw
 * --------------------
 *
 *      Force redraw of the linelist (listbox) on screen
 */
void LineList_ForceRedraw(LPLINELIST lpLL, BOOL fErase)
{
	InvalidateRect(lpLL->m_hWndListBox, NULL, fErase);
}


/* LineList_ForceLineRedraw
 * ------------------------
 *
 *      Force a particular line of the linelist (listbox) to redraw.
 */
void LineList_ForceLineRedraw(LPLINELIST lpLL, int nIndex, BOOL fErase)
{
	RECT   rect;

	LineList_GetLineRect( lpLL, nIndex, (LPRECT)&rect );
	InvalidateRect( lpLL->m_hWndListBox, (LPRECT)&rect, fErase );
}


/* LineList_ScrollLineIntoView
 * ---------------------------
 *  Make sure that the specified line is in view; if necessary scroll
 *      the listbox. if any portion of the line is visible, then no
 *      scrolling will occur.
 */
void LineList_ScrollLineIntoView(LPLINELIST lpLL, int nIndex)
{
	RECT rcWindow;
	RECT rcLine;
	RECT rcInt;

	if ( lpLL->m_nNumLines == 0 )
		return;

	if (! LineList_GetLineRect( lpLL, nIndex, (LPRECT)&rcLine ) )
		return;

	GetClientRect( lpLL->m_hWndListBox, (LPRECT) &rcWindow );

	if (! IntersectRect((LPRECT)&rcInt, (LPRECT)&rcWindow, (LPRECT)&rcLine))
		SendMessage(
				lpLL->m_hWndListBox,
				LB_SETTOPINDEX,
				(WPARAM)nIndex,
				(LPARAM)NULL
		);
}


/* LineList_CopySelToDoc
 * ---------------------
 *
 *      Copy the selection of the linelist to another document
 *
 *  RETURNS: number of lines copied.
 */
int LineList_CopySelToDoc(
		LPLINELIST              lpSrcLL,
		LPLINERANGE             lplrSel,
		LPOUTLINEDOC            lpDestDoc
)
{
	int             nEndLine;
	int             nStartLine;
	LPLINELIST      lpDestLL = &lpDestDoc->m_LineList;
	signed short    nDestIndex = LineList_GetFocusLineIndex(lpDestLL);
	LPLINE          lpSrcLine;
	int             nCopied = 0;
	int             i;

	if (lplrSel) {
		nEndLine = lplrSel->m_nEndLine;
		nStartLine = lplrSel->m_nStartLine;
	} else {
		nEndLine = LineList_GetCount(lpSrcLL) - 1;
		nStartLine = 0;
	}

	for(i = nStartLine; i <= nEndLine; i++) {
		lpSrcLine = LineList_GetLine(lpSrcLL, i);
		if (lpSrcLine && Line_CopyToDoc(lpSrcLine, lpDestDoc, nDestIndex)) {
			nDestIndex++;
			nCopied++;
		}
	}

	return nCopied;
}


/* LineList_SaveSelToStg
 * ---------------------
 *
 *      Save lines in selection into lpDestStg.
 *
 *      Return TRUE if ok, FALSE if error
 */
BOOL LineList_SaveSelToStg(
		LPLINELIST              lpLL,
		LPLINERANGE             lplrSel,
		UINT                    uFormat,
		LPSTORAGE               lpSrcStg,
		LPSTORAGE               lpDestStg,
		LPSTREAM                lpLLStm,
		BOOL                    fRemember
)
{
	int nEndLine;
	int nStartLine;
	int nNumLinesWritten = 0;
	HRESULT hrErr = NOERROR;
	ULONG nWritten;
	LPLINE lpLine;
	LINELISTHEADER_ONDISK llhRecord;
	int i;
	LARGE_INTEGER dlibSaveHeaderPos;
	LARGE_INTEGER dlibZeroOffset;
	LISet32( dlibZeroOffset, 0 );

	if (lplrSel) {
		nEndLine = lplrSel->m_nEndLine;
		nStartLine = lplrSel->m_nStartLine;
	} else {
		nEndLine = LineList_GetCount(lpLL) - 1;
		nStartLine = 0;
	}

	_fmemset(&llhRecord,0,sizeof(llhRecord));

	/* save seek position for LineList header record */
	hrErr = lpLLStm->lpVtbl->Seek(
			lpLLStm,
			dlibZeroOffset,
			STREAM_SEEK_CUR,
			(ULARGE_INTEGER FAR*)&dlibSaveHeaderPos
	);
	if (hrErr != NOERROR) goto error;

	/* write LineList header record */
	hrErr = lpLLStm->lpVtbl->Write(
			lpLLStm,
			(LPVOID)&llhRecord,
			sizeof(llhRecord),
			&nWritten
    );
	if (hrErr != NOERROR) {
		OleDbgOutHResult("Write LineList header returned", hrErr);
		goto error;
    }

	for(i = nStartLine; i <= nEndLine; i++) {
		lpLine = LineList_GetLine(lpLL, i);
		if(lpLine &&
			Line_SaveToStg(lpLine, uFormat, lpSrcStg, lpDestStg, lpLLStm,
																fRemember))
			llhRecord.m_nNumLines++;
	}

	/* retore seek position for LineList header record */
	hrErr = lpLLStm->lpVtbl->Seek(
			lpLLStm,
			dlibSaveHeaderPos,
			STREAM_SEEK_SET,
			NULL
	);
	if (hrErr != NOERROR) goto error;

	/* write LineList header record */
	hrErr = lpLLStm->lpVtbl->Write(
			lpLLStm,
			(LPVOID)&llhRecord,
			sizeof(llhRecord),
			&nWritten
	);
	if (hrErr != NOERROR) goto error;

	/* reset seek position to end of stream */
	hrErr = lpLLStm->lpVtbl->Seek(
			lpLLStm,
			dlibZeroOffset,
			STREAM_SEEK_END,
			NULL
	);
	if (hrErr != NOERROR) goto error;

	return TRUE;

error:
#if defined( _DEBUG )
	OleDbgAssertSz(
			hrErr == NOERROR,
			"Could not write LineList header to LineList stream"
	);
#endif
	return FALSE;
}


/* LineList_LoadFromStg
 * --------------------
 *
 *      Load lines into linelist from storage.
 *
 *      Return TRUE if ok, FALSE if error
 */
BOOL LineList_LoadFromStg(
		LPLINELIST              lpLL,
		LPSTORAGE               lpSrcStg,
		LPSTREAM                lpLLStm
)
{
	HRESULT hrErr;
	ULONG nRead;
	LPLINE lpLine;
	int i;
	int nNumLines;
	LINELISTHEADER_ONDISK llineRecord;

	/* write LineList header record */
	hrErr = lpLLStm->lpVtbl->Read(
			lpLLStm,
			(LPVOID)&llineRecord,
			sizeof(llineRecord),
			&nRead
	);

	if (hrErr != NOERROR) {
		OleDbgOutHResult("Read LineList header returned", hrErr);
		goto error;
    }

	nNumLines = (int) llineRecord.m_nNumLines;

	for(i = 0; i < nNumLines; i++) {
		lpLine = Line_LoadFromStg(lpSrcStg, lpLLStm, lpLL->m_lpDoc);
		if (! lpLine)
			goto error;

		// Directly add lines to LineList without trying to update a NameTbl
		LineList_AddLine(lpLL, lpLine, i-1);
	}

	return TRUE;

error:
	// Delete any Line objects that were created
	if (lpLL->m_nNumLines > 0) {
		int nNumLines = lpLL->m_nNumLines;
		for (i = 0; i < nNumLines; i++)
			LineList_DeleteLine(lpLL, i);
	}

	return FALSE;
}


#if defined( USE_DRAGDROP )


/* LineList_SetFocusLineFromPointl
 * -------------------------------
 *
 */

void LineList_SetFocusLineFromPointl( LPLINELIST lpLL, POINTL pointl )
{
	int i = LineList_GetLineIndexFromPointl( lpLL, pointl );

	if ( i == (int)-1)
		return ;
	else
		LineList_SetFocusLine( lpLL, (WORD)i );
}


/* LineList_SetDragOverLineFromPointl
 * ----------------------------------
 *
 */

void LineList_SetDragOverLineFromPointl ( LPLINELIST lpLL, POINTL pointl )
{
	int    nIndex = LineList_GetLineIndexFromPointl( lpLL, pointl );
	LPLINE lpline = LineList_GetLine( lpLL, nIndex );

	if (!lpline)
		return;

	if (! lpline->m_fDragOverLine) {
		/* user has dragged over a new line. force new drop target line
		**    to repaint so that drop feedback will be drawn.
		*/
		lpline->m_fDragOverLine = TRUE;
		LineList_ForceLineRedraw( lpLL, nIndex, TRUE /*fErase*/);

		if (lpLL->m_iDragOverLine!= -1 && lpLL->m_iDragOverLine!=nIndex) {

			/* force previous drop target line to repaint so that drop
			**    feedback will be undrawn
			*/
			lpline = LineList_GetLine( lpLL, lpLL->m_iDragOverLine );
			if (lpline)
				lpline->m_fDragOverLine = FALSE;

			LineList_ForceLineRedraw(
					lpLL,lpLL->m_iDragOverLine,TRUE /*fErase*/);
		}

		lpLL->m_iDragOverLine = nIndex;

		// Force repaint immediately
		UpdateWindow(lpLL->m_hWndListBox);
	}
}


/* LineList_Scroll
 * ---------------
 *
 * Scroll the LineList list box in the desired direction by one line.
 *
 *      this function is called during a drag operation.
 */

void LineList_Scroll(LPLINELIST lpLL, DWORD dwScrollDir)
{
	switch (dwScrollDir) {
		case SCROLLDIR_UP:
			SendMessage( lpLL->m_hWndListBox, WM_VSCROLL, SB_LINEUP, 0L );
			break;

		case SCROLLDIR_DOWN:
			SendMessage( lpLL->m_hWndListBox, WM_VSCROLL, SB_LINEDOWN, 0L );
			break;
	}
}


/* LineList_GetLineIndexFromPointl
 * -------------------------------
 *   do hit test to get index of line corresponding to pointl
 */
int LineList_GetLineIndexFromPointl(LPLINELIST lpLL, POINTL pointl)
{
	RECT  rect;
	POINT point;
	DWORD i;

	point.x = (int)pointl.x;
	point.y = (int)pointl.y;

	ScreenToClient( lpLL->m_hWndListBox, &point);

	if ( lpLL->m_nNumLines == 0 )
		return -1;

	GetClientRect( lpLL->m_hWndListBox, (LPRECT) &rect );

	i = SendMessage( lpLL->m_hWndListBox, LB_GETTOPINDEX, (WPARAM)NULL, (LPARAM)NULL );

	for ( ;; i++){

		RECT rectItem;

		if (!LineList_GetLineRect( lpLL, (int)i, (LPRECT)&rectItem ) )
			return -1;

		if ( rectItem.top > rect.bottom )
			return -1;

		if ( rectItem.top <= point.y && point.y <= rectItem.bottom)
			return (int)i;

	}

}


/* LineList_RestoreDragFeedback
 * ----------------------------
 *
 * Retore the index of the line that currently has focus (the active line).
 */
void LineList_RestoreDragFeedback(LPLINELIST lpLL)
{
	LPLINE lpLine;

	if (lpLL->m_iDragOverLine < 0 )
	   return;

	lpLine = LineList_GetLine( lpLL, lpLL->m_iDragOverLine);

	if (lpLine) {

		lpLine->m_fDragOverLine = FALSE;
		LineList_ForceLineRedraw( lpLL,lpLL->m_iDragOverLine,TRUE /*fErase*/);

		// Force repaint immediately
		UpdateWindow(lpLL->m_hWndListBox);
	}

	lpLL->m_iDragOverLine = -1;

}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\letest\outline\outldoc.c ===
/*************************************************************************
**
**    OLE 2 Sample Code
**
**    outldoc.c
**
**    This file contains OutlineDoc functions.
**
**    (c) Copyright Microsoft Corp. 1992 - 1993 All Rights Reserved
**
*************************************************************************/

#include "outline.h"

#if !defined( OLE_VERSION )
#include <commdlg.h>
#endif


OLEDBGDATA

extern LPOUTLINEAPP g_lpApp;

// REVIEW: should use string resource for messages
char ErrMsgDocWnd[] = "Can't create Document Window!";
char ErrMsgFormatNotSupported[] = "Clipboard format not supported!";
char MsgSaveFile[] = "Save existing file ?";
char ErrMsgSaving[] = "Error in saving file!";
char ErrMsgOpening[] = "Error in opening file!";
char ErrMsgFormat[] = "Improper file format!";
char ErrOutOfMemory[] = "Error: out of memory!";
static char ErrMsgPrint[] = "Printing Error!";

static BOOL fCancelPrint;    // TRUE if the user has canceled the print job
static HWND hWndPDlg;       // Handle to the cancel print dialog


/* OutlineDoc_Init
 * ---------------
 *
 *  Initialize the fields of a new OutlineDoc object. The object is initially
 *  not associated with a file or an (Untitled) document. This function sets
 *  the docInitType to DOCTYPE_UNKNOWN. After calling this function the
 *  caller should call:
 *      1. OutlineDoc_InitNewFile to set the OutlineDoc to (Untitled)
 *      2. OutlineDoc_LoadFromFile to associate the OutlineDoc with a file.
 *  This function creates a new window for the document.
 *
 *  NOTE: the window is initially created with a NIL size. it must be
 *        sized and positioned by the caller. also the document is initially
 *        created invisible. the caller must call OutlineDoc_ShowWindow
 *        after sizing it to make the document window visible.
 */
BOOL OutlineDoc_Init(LPOUTLINEDOC lpOutlineDoc, BOOL fDataTransferDoc)
{
	LPOUTLINEAPP lpOutlineApp = (LPOUTLINEAPP)g_lpApp;

#if defined( INPLACE_CNTR )
	lpOutlineDoc->m_hWndDoc = CreateWindow(
					DOCWNDCLASS,            // Window class name
					NULL,                   // Window's title

					/* OLE2NOTE: an in-place contanier MUST use
					**    WS_CLIPCHILDREN window style for the window
					**    that it uses as the parent for the server's
					**    in-place active window so that its
					**    painting does NOT interfere with the painting
					**    of the server's in-place active child window.
					*/

					WS_CLIPCHILDREN | WS_CLIPSIBLINGS |
					WS_CHILDWINDOW,
					0, 0,
					0, 0,
					lpOutlineApp->m_hWndApp,// Parent window's handle
					(HMENU)1,               // child window id
					lpOutlineApp->m_hInst,  // Instance of window
					NULL);                  // Create struct for WM_CREATE

#else

	lpOutlineDoc->m_hWndDoc = CreateWindow(
					DOCWNDCLASS,            // Window class name
					NULL,                   // Window's title
					WS_CHILDWINDOW,
					0, 0,
					0, 0,
					lpOutlineApp->m_hWndApp,// Parent window's handle
					(HMENU)1,               // child window id
					lpOutlineApp->m_hInst,  // Instance of window
					NULL);                  // Create struct for WM_CREATE
#endif

	if(! lpOutlineDoc->m_hWndDoc) {
		OutlineApp_ErrorMessage(lpOutlineApp, ErrMsgDocWnd);
		return FALSE;
	}

	SetWindowLong(lpOutlineDoc->m_hWndDoc, 0, (LONG) lpOutlineDoc);

	if (! LineList_Init(&lpOutlineDoc->m_LineList, lpOutlineDoc))
		return FALSE;

	lpOutlineDoc->m_lpNameTable = OutlineDoc_CreateNameTable(lpOutlineDoc);
	if (! lpOutlineDoc->m_lpNameTable )
		return FALSE;

	lpOutlineDoc->m_docInitType = DOCTYPE_UNKNOWN;
	lpOutlineDoc->m_cfSaveFormat = lpOutlineApp->m_cfOutline;
	lpOutlineDoc->m_szFileName[0] = '\0';
	lpOutlineDoc->m_lpszDocTitle = lpOutlineDoc->m_szFileName;
	lpOutlineDoc->m_fDataTransferDoc = fDataTransferDoc;
	lpOutlineDoc->m_uCurrentZoom = IDM_V_ZOOM_100;
	lpOutlineDoc->m_scale.dwSxN  = (DWORD) 1;
	lpOutlineDoc->m_scale.dwSxD  = (DWORD) 1;
	lpOutlineDoc->m_scale.dwSyN  = (DWORD) 1;
	lpOutlineDoc->m_scale.dwSyD  = (DWORD) 1;
	lpOutlineDoc->m_uCurrentMargin = IDM_V_SETMARGIN_0;
	lpOutlineDoc->m_nLeftMargin  = 0;
	lpOutlineDoc->m_nRightMargin = 0;
	lpOutlineDoc->m_nDisableDraw = 0;
	OutlineDoc_SetModified(lpOutlineDoc, FALSE, FALSE, FALSE);

#if defined( USE_HEADING )
	if (! fDataTransferDoc) {
		if (!Heading_Create((LPHEADING)&lpOutlineDoc->m_heading,
				lpOutlineDoc->m_hWndDoc, lpOutlineApp->m_hInst)) {
			return FALSE;

		}
	}
#endif  // USE_HEADING

#if defined( USE_FRAMETOOLS )
	if (! fDataTransferDoc) {
		lpOutlineDoc->m_lpFrameTools = OutlineApp_GetFrameTools(lpOutlineApp);
		FrameTools_AssociateDoc(
				lpOutlineDoc->m_lpFrameTools,
				lpOutlineDoc
		);
	}
#endif  // USE_FRAMETOOLS

#if defined( OLE_VERSION )
	/* OLE2NOTE: perform initialization required for OLE */
	if (! OleDoc_Init((LPOLEDOC)lpOutlineDoc, fDataTransferDoc))
		return FALSE;
#endif  // OLE_VERSION

	return TRUE;
}


/* OutlineDoc_InitNewFile
 * ----------------------
 *
 *  Initialize the OutlineDoc object to be a new (Untitled) document.
 *  This function sets the docInitType to DOCTYPE_NEW.
 */
BOOL OutlineDoc_InitNewFile(LPOUTLINEDOC lpOutlineDoc)
{
#if defined( OLE_VERSION )
	// OLE2NOTE: call OLE version of this function instead
	return OleDoc_InitNewFile((LPOLEDOC)lpOutlineDoc);

#else

	OleDbgAssert(lpOutlineDoc->m_docInitType == DOCTYPE_UNKNOWN);

	// set file name to untitled
	// REVIEW: should load from string resource
	lstrcpy(lpOutlineDoc->m_szFileName, UNTITLED);
	lpOutlineDoc->m_lpszDocTitle = lpOutlineDoc->m_szFileName;
	lpOutlineDoc->m_docInitType = DOCTYPE_NEW;

	if (! lpOutlineDoc->m_fDataTransferDoc)
		OutlineDoc_SetTitle(lpOutlineDoc, FALSE /*fMakeUpperCase*/);

	return TRUE;

#endif      // BASE OUTLINE VERSION
}


/* OutlineDoc_CreateNameTable
 * --------------------------
 *
 * Allocate a new NameTable of the appropriate type. Each document has
 * a NameTable and a LineList.
 *  OutlineDoc --> creates standard OutlineNameTable type name tables.
 *  ServerDoc  --> creates enhanced SeverNameTable type name tables.
 *
 *      Returns lpNameTable for successful, NULL if error.
 */
LPOUTLINENAMETABLE OutlineDoc_CreateNameTable(LPOUTLINEDOC lpOutlineDoc)
{
	LPOUTLINENAMETABLE lpOutlineNameTable;

	lpOutlineNameTable = (LPOUTLINENAMETABLE)New(
			(DWORD)sizeof(OUTLINENAMETABLE)
	);

	OleDbgAssertSz(lpOutlineNameTable != NULL,"Error allocating NameTable");
	if (lpOutlineNameTable == NULL)
		return NULL;

	// initialize new NameTable
	if (! OutlineNameTable_Init(lpOutlineNameTable, lpOutlineDoc) )
		goto error;

	return lpOutlineNameTable;

error:
	if (lpOutlineNameTable)
		Delete(lpOutlineNameTable);
	return NULL;
}


/* OutlineDoc_ClearCommand
 * -----------------------
 *
 *      Delete selection in list box by calling OutlineDoc_Delete
 */
void OutlineDoc_ClearCommand(LPOUTLINEDOC lpOutlineDoc)
{
	LPLINELIST lpLL = &lpOutlineDoc->m_LineList;
	int i;
	int nNumSel;
	LINERANGE lrSel;

	nNumSel=LineList_GetSel(lpLL, (LPLINERANGE)&lrSel);

	OutlineDoc_SetRedraw ( lpOutlineDoc, FALSE );
	for(i = 0; i < nNumSel; i++)
		OutlineDoc_DeleteLine(lpOutlineDoc, lrSel.m_nStartLine);

	OutlineDoc_SetRedraw ( lpOutlineDoc, TRUE );

	LineList_RecalcMaxLineWidthInHimetric(lpLL, 0);
}


/* OutlineDoc_CutCommand
 * ---------------------
 *
 * Cut selection to clipboard
 */
void OutlineDoc_CutCommand(LPOUTLINEDOC lpOutlineDoc)
{
	OutlineDoc_CopyCommand(lpOutlineDoc);
	OutlineDoc_ClearCommand(lpOutlineDoc);
}


/* OutlineDoc_CopyCommand
 * ----------------------
 *  Copy selection to clipboard.
 *  Post to the clipboard the formats that the app can render.
 *  the actual data is not rendered at this time. using the
 *  delayed rendering technique, Windows will send the clipboard
 *  owner window either a WM_RENDERALLFORMATS or a WM_RENDERFORMAT
 *  message when the actual data is requested.
 *
 *    OLE2NOTE: the normal delayed rendering technique where Windows
 *    sends the clipboard owner window either a WM_RENDERALLFORMATS or
 *    a WM_RENDERFORMAT message when the actual data is requested is
 *    NOT exposed to the app calling OleSetClipboard. OLE internally
 *    creates its own window as the clipboard owner and thus our app
 *    will NOT get these WM_RENDER messages.
 */
void OutlineDoc_CopyCommand(LPOUTLINEDOC lpSrcOutlineDoc)
{
#if defined( OLE_VERSION )
	// Call OLE version of this function instead
	OleDoc_CopyCommand((LPOLEDOC)lpSrcOutlineDoc);

#else
	LPOUTLINEAPP lpOutlineApp = (LPOUTLINEAPP)g_lpApp;
	LPOUTLINEDOC lpClipboardDoc;

	OpenClipboard(lpSrcOutlineDoc->m_hWndDoc);
	EmptyClipboard();

	/* squirrel away a copy of the current selection to the ClipboardDoc */
	lpClipboardDoc = OutlineDoc_CreateDataTransferDoc(lpSrcOutlineDoc);

	if (! lpClipboardDoc)
		return;     // Error: could not create DataTransferDoc

	lpOutlineApp->m_lpClipboardDoc = (LPOUTLINEDOC)lpClipboardDoc;

	SetClipboardData(lpOutlineApp->m_cfOutline, NULL);
	SetClipboardData(CF_TEXT, NULL);

	CloseClipboard();

#endif  // ! OLE_VERSION
}


/* OutlineDoc_ClearAllLines
 * ------------------------
 *
 *      Delete all lines in the document.
 */
void OutlineDoc_ClearAllLines(LPOUTLINEDOC lpOutlineDoc)
{
	LPLINELIST lpLL = &lpOutlineDoc->m_LineList;
	int i;

	for(i = 0; i < lpLL->m_nNumLines; i++)
		OutlineDoc_DeleteLine(lpOutlineDoc, 0);

	LineList_RecalcMaxLineWidthInHimetric(lpLL, 0);
}


/* OutlineDoc_CreateDataTransferDoc
 * --------------------------------
 *
 *      Create a document to be use to transfer data (either via a
 *  drag/drop operation of the clipboard). Copy the selection of the
 *  source doc to the data transfer document. A data transfer document is
 *  the same as a document that is created by the user except that it is
 *  NOT made visible to the user. it is specially used to hold a copy of
 *  data that the user should not be able to change.
 *
 *  OLE2NOTE: in the OLE version the data transfer document is used
 *      specifically to provide an IDataObject* that renders the data copied.
 */
LPOUTLINEDOC OutlineDoc_CreateDataTransferDoc(LPOUTLINEDOC lpSrcOutlineDoc)
{
#if defined( OLE_VERSION )
	// Call OLE version of this function instead
	return OleDoc_CreateDataTransferDoc((LPOLEDOC)lpSrcOutlineDoc);

#else
	LPOUTLINEAPP lpOutlineApp = (LPOUTLINEAPP)g_lpApp;
	LPOUTLINEDOC lpDestOutlineDoc;
	LPLINELIST lpSrcLL = &lpSrcOutlineDoc->m_LineList;
	LINERANGE lrSel;
	int nCopied;

	lpDestOutlineDoc = OutlineApp_CreateDoc(lpOutlineApp, TRUE);
	if (! lpDestOutlineDoc) return NULL;

	// set the ClipboardDoc to an (Untitled) doc.
	if (! OutlineDoc_InitNewFile(lpDestOutlineDoc))
		goto error;

	LineList_GetSel(lpSrcLL, (LPLINERANGE)&lrSel);
	nCopied = LineList_CopySelToDoc(
			lpSrcLL,
			(LPLINERANGE)&lrSel,
			lpDestOutlineDoc
	);

	return lpDestOutlineDoc;

error:
	if (lpDestOutlineDoc)
		OutlineDoc_Destroy(lpDestOutlineDoc);

	return NULL;

#endif  // ! OLE_VERSION
}


/* OutlineDoc_PasteCommand
 * -----------------------
 *
 * Paste lines from clipboard
 */
void OutlineDoc_PasteCommand(LPOUTLINEDOC lpOutlineDoc)
{
#if defined( OLE_VERSION )
	// Call OLE version of this function instead
	OleDoc_PasteCommand((LPOLEDOC)lpOutlineDoc);

#else

	LPOUTLINEAPP lpOutlineApp = (LPOUTLINEAPP)g_lpApp;
	LPLINELIST lpLL = (LPLINELIST)&lpOutlineDoc->m_LineList;
	int nIndex;
	int nCount;
	HGLOBAL hData;
	LINERANGE lrSel;
	UINT uFormat;

	if (LineList_GetCount(lpLL) == 0)
		nIndex = -1;    // pasting to empty list
	else
		nIndex=LineList_GetFocusLineIndex(lpLL);

	OutlineDoc_SetRedraw ( lpOutlineDoc, FALSE );

	OpenClipboard(lpOutlineDoc->m_hWndDoc);

	uFormat = 0;
	while(uFormat = EnumClipboardFormats(uFormat)) {
		if(uFormat == lpOutlineApp->m_cfOutline) {
			hData = GetClipboardData(lpOutlineApp->m_cfOutline);
			nCount = OutlineDoc_PasteOutlineData(lpOutlineDoc, hData, nIndex);
			break;
		}
		if(uFormat == CF_TEXT) {
			hData = GetClipboardData(CF_TEXT);
			nCount = OutlineDoc_PasteTextData(lpOutlineDoc, hData, nIndex);
			break;
		}
	}

	lrSel.m_nStartLine = nIndex + nCount;
	lrSel.m_nEndLine = nIndex + 1;
	LineList_SetSel(lpLL, &lrSel);
	OutlineDoc_SetRedraw ( lpOutlineDoc, TRUE );

	CloseClipboard();

#endif      // ! OLE_VERSION
}


/* OutlineDoc_PasteOutlineData
 * ---------------------------
 *
 *      Put an array of Line Objects (stored in hOutline) into the document
 *
 * Return the number of items added
 */
int OutlineDoc_PasteOutlineData(LPOUTLINEDOC lpOutlineDoc, HGLOBAL hOutline, int nStartIndex)
{
	int nCount;
	int i;
	LPTEXTLINE arrLine;

	nCount = (int) GlobalSize(hOutline) / sizeof(TEXTLINE);
	arrLine = (LPTEXTLINE)GlobalLock(hOutline);
	if (!arrLine)
		return 0;

	for(i = 0; i < nCount; i++)
		Line_CopyToDoc((LPLINE)&arrLine[i], lpOutlineDoc, nStartIndex+i);

	GlobalUnlock(hOutline);

	return nCount;
}


/* OutlineDoc_PasteTextData
 * ------------------------
 *
 *      Build Line Objects from the strings (separated by '\n') in hText
 * and put them into the document
 */
int OutlineDoc_PasteTextData(LPOUTLINEDOC lpOutlineDoc, HGLOBAL hText, int nStartIndex)
{
	LPLINELIST  lpLL = (LPLINELIST)&lpOutlineDoc->m_LineList;
	HDC         hDC;
	LPSTR       lpszText;
	LPSTR       lpszEnd;
	LPTEXTLINE  lpLine;
	int         nLineCount;
	int         i;
	UINT        nTab;
	char        szBuf[MAXSTRLEN+1];

	lpszText=(LPSTR)GlobalLock(hText);
	if(!lpszText)
		return 0;

	lpszEnd = lpszText + lstrlen(lpszText);
	nLineCount=0;

	while(*lpszText && (lpszText<lpszEnd)) {

		// count the tab level
		nTab = 0;
		while((*lpszText == '\t') && (lpszText<lpszEnd)) {
			nTab++;
			lpszText++;
		}

		// collect the text string character by character
		for(i=0; (i<MAXSTRLEN) && (lpszText<lpszEnd); i++) {
			if ((! *lpszText) || (*lpszText == '\n'))
				break;
			szBuf[i] = *lpszText++;
		}
		szBuf[i] = 0;
		lpszText++;
		if ((i > 0) && (szBuf[i-1] == '\r'))
			szBuf[i-1] = 0;     // remove carriage return at the end

		hDC = LineList_GetDC(lpLL);
		lpLine = TextLine_Create(hDC, nTab, szBuf);
		LineList_ReleaseDC(lpLL, hDC);

		OutlineDoc_AddLine(
				lpOutlineDoc,
				(LPLINE)lpLine,
				nStartIndex + nLineCount
		);
		nLineCount++;

	}

	GlobalUnlock(hText);

	return nLineCount;
}


/* OutlineDoc_AddTextLineCommand
 * -----------------------------
 *
 *      Add a new text line following the current focus line.
 */
void OutlineDoc_AddTextLineCommand(LPOUTLINEDOC lpOutlineDoc)
{
	LPOUTLINEAPP lpOutlineApp = (LPOUTLINEAPP)g_lpApp;
	LPLINELIST lpLL = &lpOutlineDoc->m_LineList;
	HDC hDC;
	int nIndex = LineList_GetFocusLineIndex(lpLL);
	char szBuf[MAXSTRLEN+1];
	UINT nTab = 0;
	LPLINE lpLine;
	LPTEXTLINE lpTextLine;

	szBuf[0] = '\0';

#if defined( USE_FRAMETOOLS )
	FrameTools_FB_GetEditText(
			lpOutlineDoc->m_lpFrameTools, szBuf, sizeof(szBuf));
#else
	if (! InputTextDlg(lpOutlineDoc->m_hWndDoc, szBuf, "Add Line"))
		return;
#endif

	hDC = LineList_GetDC(lpLL);
	lpLine = LineList_GetLine(lpLL, nIndex);
	if (lpLine)
		nTab = Line_GetTabLevel(lpLine);

	lpTextLine=TextLine_Create(hDC, nTab, szBuf);
	LineList_ReleaseDC(lpLL, hDC);

	if (! lpTextLine) {
		OutlineApp_ErrorMessage(lpOutlineApp, ErrOutOfMemory);
		return;
	}
	OutlineDoc_AddLine(lpOutlineDoc, (LPLINE)lpTextLine, nIndex);
}


/* OutlineDoc_AddTopLineCommand
 * ----------------------------
 *
 *      Add a top (margin) line as the first line in the LineList.
 *      (do not change the current selection)
 */
void OutlineDoc_AddTopLineCommand(
		LPOUTLINEDOC        lpOutlineDoc,
		UINT                nHeightInHimetric
)
{
	LPOUTLINEAPP lpOutlineApp = (LPOUTLINEAPP)g_lpApp;
	LPLINELIST  lpLL = &lpOutlineDoc->m_LineList;
	HDC         hDC = LineList_GetDC(lpLL);
	LPTEXTLINE  lpTextLine = TextLine_Create(hDC, 0, NULL);
	LPLINE      lpLine = (LPLINE)lpTextLine;
	LINERANGE   lrSel;
	int         nNumSel;

	LineList_ReleaseDC(lpLL, hDC);

	if (! lpTextLine) {
		OutlineApp_ErrorMessage(lpOutlineApp, ErrOutOfMemory);
		return;
	}

	Line_SetHeightInHimetric(lpLine, nHeightInHimetric);

	nNumSel=LineList_GetSel(lpLL, (LPLINERANGE)&lrSel);
	if (nNumSel > 0) {
		// adjust current selection to keep equivalent selection
		lrSel.m_nStartLine += 1;
		lrSel.m_nEndLine += 1;
	}
	OutlineDoc_AddLine(lpOutlineDoc, lpLine, -1);
	if (nNumSel > 0)
		LineList_SetSel(lpLL, (LPLINERANGE)&lrSel);
}


#if defined( USE_FRAMETOOLS )


/* OutlineDoc_SetFormulaBarEditText
 * --------------------------------
 *
 *      Fill the edit control in the formula with the text string from a
 * TextLine in focus.
 */
void OutlineDoc_SetFormulaBarEditText(
		LPOUTLINEDOC            lpOutlineDoc,
		LPLINE                  lpLine
)
{
	LPLINELIST lpLL = &lpOutlineDoc->m_LineList;
	char cBuf[MAXSTRLEN+1];

	if (! lpOutlineDoc || ! lpOutlineDoc->m_lpFrameTools)
		return;

	if (Line_GetLineType(lpLine) != TEXTLINETYPE) {
		FrameTools_FB_SetEditText(lpOutlineDoc->m_lpFrameTools, NULL);
	} else {
		TextLine_GetTextData((LPTEXTLINE)lpLine, (LPSTR)cBuf);
		FrameTools_FB_SetEditText(lpOutlineDoc->m_lpFrameTools, (LPSTR)cBuf);
	}
}


/* OutlineDoc_SetFormulaBarEditFocus
 * ---------------------------------
 *
 *  Setup for formula bar to gain or loose edit focus.
 *  if gaining focus, setup up special accelerator table and scroll line
 *      into view.
 *  else restore normal accelerator table.
 */
void OutlineDoc_SetFormulaBarEditFocus(
		LPOUTLINEDOC            lpOutlineDoc,
		BOOL                    fEditFocus
)
{
	LPOUTLINEAPP lpOutlineApp = (LPOUTLINEAPP)g_lpApp;
	LPLINELIST lpLL;
	int nFocusIndex;

	if (! lpOutlineDoc || ! lpOutlineDoc->m_lpFrameTools)
		return;

	lpOutlineDoc->m_lpFrameTools->m_fInFormulaBar = fEditFocus;

	if (fEditFocus && lpOutlineDoc->m_lpFrameTools) {
		lpLL = OutlineDoc_GetLineList(lpOutlineDoc);

		nFocusIndex = LineList_GetFocusLineIndex(lpLL);
		LineList_ScrollLineIntoView(lpLL, nFocusIndex);
		FrameTools_FB_FocusEdit(lpOutlineDoc->m_lpFrameTools);
	}

	OutlineApp_SetFormulaBarAccel(lpOutlineApp, fEditFocus);
}


/* OutlineDoc_IsEditFocusInFormulaBar
** ----------------------------------
**    Returns TRUE if edit focus is currently in the formula bar
**    else FALSE if not.
*/
BOOL OutlineDoc_IsEditFocusInFormulaBar(LPOUTLINEDOC lpOutlineDoc)
{
	if (! lpOutlineDoc || ! lpOutlineDoc->m_lpFrameTools)
		return FALSE;

	return lpOutlineDoc->m_lpFrameTools->m_fInFormulaBar;
}


/* OutlineDoc_UpdateFrameToolButtons
** ---------------------------------
**    Update the Enable/Disable states of the buttons in the formula
**    bar and button bar.
*/
void OutlineDoc_UpdateFrameToolButtons(LPOUTLINEDOC lpOutlineDoc)
{
	if (! lpOutlineDoc || ! lpOutlineDoc->m_lpFrameTools)
		return;
	FrameTools_UpdateButtons(lpOutlineDoc->m_lpFrameTools, lpOutlineDoc);
}
#endif  // USE_FRAMETOOLS


/* OutlineDoc_EditLineCommand
 * --------------------------
 *
 *      Edit the current focus line.
 */
void OutlineDoc_EditLineCommand(LPOUTLINEDOC lpOutlineDoc)
{
	LPLINELIST lpLL = &lpOutlineDoc->m_LineList;
	HDC hDC = LineList_GetDC(lpLL);
	int nIndex = LineList_GetFocusLineIndex(lpLL);
	LPLINE lpLine = LineList_GetLine(lpLL, nIndex);
	int nOrgLineWidthInHimetric;
	int nNewLineWidthInHimetric;
	BOOL fSizeChanged;

	if (!lpLine)
		return;

	nOrgLineWidthInHimetric = Line_GetTotalWidthInHimetric(lpLine);
	if (Line_Edit(lpLine, lpOutlineDoc->m_hWndDoc, hDC)) {
		nNewLineWidthInHimetric = Line_GetTotalWidthInHimetric(lpLine);

		if (nNewLineWidthInHimetric > nOrgLineWidthInHimetric) {
			fSizeChanged = LineList_SetMaxLineWidthInHimetric(
					lpLL,
					nNewLineWidthInHimetric
				);
		} else {
			fSizeChanged = LineList_RecalcMaxLineWidthInHimetric(
					lpLL,
					nOrgLineWidthInHimetric
				);
		}

#if defined( OLE_SERVER )
		/* Update Name Table */
		ServerNameTable_EditLineUpdate(
				(LPSERVERNAMETABLE)lpOutlineDoc->m_lpNameTable,
				nIndex
		);
#endif

		OutlineDoc_SetModified(lpOutlineDoc, TRUE, TRUE, fSizeChanged);

		LineList_ForceLineRedraw(lpLL, nIndex, TRUE);
	}
	LineList_ReleaseDC(lpLL, hDC);
}


/* OutlineDoc_IndentCommand
 * ------------------------
 *
 *      Indent selection of lines
 */
void OutlineDoc_IndentCommand(LPOUTLINEDOC lpOutlineDoc)
{
	LPLINELIST  lpLL = &lpOutlineDoc->m_LineList;
	LPLINE      lpLine;
	HDC         hDC = LineList_GetDC(lpLL);
	int         i;
	int         nIndex;
	int         nNumSel;
	LINERANGE   lrSel;
	BOOL        fSizeChanged = FALSE;

	nNumSel=LineList_GetSel(lpLL, (LPLINERANGE)&lrSel);

	OutlineDoc_SetRedraw ( lpOutlineDoc, FALSE );

	for(i = 0; i < nNumSel; i++) {
		nIndex = lrSel.m_nStartLine + i;
		lpLine=LineList_GetLine(lpLL, nIndex);
		if (! lpLine)
			continue;

		Line_Indent(lpLine, hDC);
		if (LineList_SetMaxLineWidthInHimetric(lpLL,
			Line_GetTotalWidthInHimetric(lpLine))) {
			fSizeChanged = TRUE;
		}
		LineList_ForceLineRedraw(lpLL, nIndex, TRUE);

#if defined( OLE_SERVER )
		/* Update Name Table */
		ServerNameTable_EditLineUpdate(
				(LPSERVERNAMETABLE)lpOutlineDoc->m_lpNameTable,
				nIndex
		);
#endif

	}

	LineList_ReleaseDC(lpLL, hDC);

	OutlineDoc_SetModified(lpOutlineDoc, TRUE, TRUE, fSizeChanged);
	OutlineDoc_SetRedraw ( lpOutlineDoc, TRUE );
}


/* OutlineDoc_UnindentCommand
 * --------------------------
 *
 *      Unindent selection of lines
 */
void OutlineDoc_UnindentCommand(LPOUTLINEDOC lpOutlineDoc)
{
	LPLINELIST  lpLL = &lpOutlineDoc->m_LineList;
	LPLINE      lpLine;
	HDC         hDC = LineList_GetDC(lpLL);
	int         nOrgLineWidthInHimetric;
	int         nOrgMaxLineWidthInHimetric = 0;
	int         i;
	int         nIndex;
	int         nNumSel;
	LINERANGE   lrSel;
	BOOL        fSizeChanged;

	nNumSel=LineList_GetSel(lpLL, (LPLINERANGE)&lrSel);

	OutlineDoc_SetRedraw ( lpOutlineDoc, FALSE );

	for(i = 0; i < nNumSel; i++) {
		nIndex = lrSel.m_nStartLine + i;
		lpLine=LineList_GetLine(lpLL, nIndex);
		if (!lpLine)
			continue;

		nOrgLineWidthInHimetric = Line_GetTotalWidthInHimetric(lpLine);
		nOrgMaxLineWidthInHimetric =
				(nOrgLineWidthInHimetric > nOrgMaxLineWidthInHimetric ?
					nOrgLineWidthInHimetric : nOrgMaxLineWidthInHimetric);
		Line_Unindent(lpLine, hDC);
		LineList_ForceLineRedraw(lpLL, nIndex, TRUE);

#if defined( OLE_SERVER )
		/* Update Name Table */
		ServerNameTable_EditLineUpdate(
				(LPSERVERNAMETABLE)lpOutlineDoc->m_lpNameTable,
				nIndex
		);
#endif

	}

	LineList_ReleaseDC(lpLL, hDC);

	fSizeChanged = LineList_RecalcMaxLineWidthInHimetric(
			lpLL,
			nOrgMaxLineWidthInHimetric
		);

	OutlineDoc_SetModified(lpOutlineDoc, TRUE, TRUE, fSizeChanged);
	OutlineDoc_SetRedraw ( lpOutlineDoc, TRUE );
}


/* OutlineDoc_SetLineHeightCommand
 * -------------------------------
 *
 *      Set height of the selection of lines
 */
void OutlineDoc_SetLineHeightCommand(LPOUTLINEDOC lpOutlineDoc)
{
	LPOUTLINEAPP lpOutlineApp = (LPOUTLINEAPP)g_lpApp;
	LPLINELIST  lpLL;
	HDC         hDC;
	LPLINE      lpLine;
	int         nNewHeight;
	int         i;
	int         nIndex;
	int         nNumSel;
	LINERANGE   lrSel;

	if (!lpOutlineDoc)
		return;

	lpLL = &lpOutlineDoc->m_LineList;
	nNumSel=LineList_GetSel(lpLL, (LPLINERANGE)&lrSel);
	lpLine = LineList_GetLine(lpLL, lrSel.m_nStartLine);
	if (!lpLine)
		return;

	nNewHeight = Line_GetHeightInHimetric(lpLine);

#if defined( OLE_VERSION )
	OleApp_PreModalDialog((LPOLEAPP)lpOutlineApp, (LPOLEDOC)lpOutlineDoc);
#endif

	DialogBoxParam(
			lpOutlineApp->m_hInst,
			(LPSTR)"SetLineHeight",
			lpOutlineDoc->m_hWndDoc,
			(DLGPROC)SetLineHeightDlgProc,
			(LPARAM)(LPINT)&nNewHeight
	);

#if defined( OLE_VERSION )
	OleApp_PostModalDialog((LPOLEAPP)lpOutlineApp, (LPOLEDOC)lpOutlineDoc);
#endif

	if (nNewHeight == 0)
		return;     /* user hit cancel */

	hDC = LineList_GetDC(lpLL);

	for (i = 0; i < nNumSel; i++) {
		nIndex = lrSel.m_nStartLine + i;
		lpLine=LineList_GetLine(lpLL, nIndex);
		if (nNewHeight == -1) {
			switch (Line_GetLineType(lpLine)) {

				case TEXTLINETYPE:

					TextLine_CalcExtents((LPTEXTLINE)lpLine, hDC);
					break;

#if defined( OLE_CNTR )
				case CONTAINERLINETYPE:

					ContainerLine_SetHeightInHimetric(
							(LPCONTAINERLINE)lpLine, -1);
					break;
#endif

			}
		}
		else
			Line_SetHeightInHimetric(lpLine, nNewHeight);


		LineList_SetLineHeight(lpLL, nIndex,
				Line_GetHeightInHimetric(lpLine));
	}

	LineList_ReleaseDC(lpLL, hDC);

	OutlineDoc_SetModified(lpOutlineDoc, TRUE, TRUE, TRUE);
	LineList_ForceRedraw(lpLL, TRUE);
}



/* OutlineDoc_SelectAllCommand
 * ---------------------------
 *
 *      Select all the lines in the document.
 */
void OutlineDoc_SelectAllCommand(LPOUTLINEDOC lpOutlineDoc)
{
	LPLINELIST lpLL = &lpOutlineDoc->m_LineList;
	LINERANGE lrSel;

	lrSel.m_nStartLine = 0;
	lrSel.m_nEndLine = LineList_GetCount(lpLL) - 1;
	LineList_SetSel(lpLL, &lrSel);
}


/* OutlineDoc_DefineNameCommand
 * ----------------------------
 *
 *      Define a name in the document
 */
void OutlineDoc_DefineNameCommand(LPOUTLINEDOC lpOutlineDoc)
{
	LPOUTLINEAPP lpOutlineApp = (LPOUTLINEAPP)g_lpApp;

#if defined( OLE_VERSION )
	OleApp_PreModalDialog((LPOLEAPP)lpOutlineApp, (LPOLEDOC)lpOutlineDoc);
#endif

	DialogBoxParam(
			lpOutlineApp->m_hInst,
			(LPSTR)"DefineName",
			lpOutlineDoc->m_hWndDoc,
			(DLGPROC)DefineNameDlgProc,
			(LPARAM) lpOutlineDoc
	);

#if defined( OLE_VERSION )
	OleApp_PostModalDialog((LPOLEAPP)lpOutlineApp, (LPOLEDOC)lpOutlineDoc);
#endif
}


/* OutlineDoc_GotoNameCommand
 * --------------------------
 *
 *      Goto a predefined name in the document
 */
void OutlineDoc_GotoNameCommand(LPOUTLINEDOC lpOutlineDoc)
{
	LPOUTLINEAPP lpOutlineApp = (LPOUTLINEAPP)g_lpApp;

#if defined( OLE_VERSION )
	OleApp_PreModalDialog((LPOLEAPP)lpOutlineApp, (LPOLEDOC)lpOutlineDoc);
#endif

	DialogBoxParam(
			lpOutlineApp->m_hInst,
			(LPSTR)"GotoName",
			lpOutlineDoc->m_hWndDoc,
			(DLGPROC)GotoNameDlgProc,
			(LPARAM)lpOutlineDoc
	);

#if defined( OLE_VERSION )
	OleApp_PostModalDialog((LPOLEAPP)lpOutlineApp, (LPOLEDOC)lpOutlineDoc);
#endif
}


/* OutlineDoc_ShowWindow
 * ---------------------
 *
 *      Show the window of the document to the user.
 */
void OutlineDoc_ShowWindow(LPOUTLINEDOC lpOutlineDoc)
{
#if defined( _DEBUG )
	OleDbgAssertSz(lpOutlineDoc->m_docInitType != DOCTYPE_UNKNOWN,
            "OutlineDoc_ShowWindow: can't show unitialized document\r\n");
#endif
	if (lpOutlineDoc->m_docInitType == DOCTYPE_UNKNOWN)
		return;

#if defined( OLE_VERSION )
	// Call OLE version of this function instead
	OleDoc_ShowWindow((LPOLEDOC)lpOutlineDoc);
#else
	ShowWindow(lpOutlineDoc->m_hWndDoc, SW_SHOWNORMAL);
	SetFocus(lpOutlineDoc->m_hWndDoc);
#endif
}


#if defined( USE_FRAMETOOLS )

void OutlineDoc_AddFrameLevelTools(LPOUTLINEDOC lpOutlineDoc)
{
	LPOUTLINEAPP lpOutlineApp = (LPOUTLINEAPP)g_lpApp;
#if defined( INPLACE_CNTR )
	// Call OLE In-Place Container version of this function instead
	ContainerDoc_AddFrameLevelTools((LPCONTAINERDOC)lpOutlineDoc);

#else   // ! INPLACE_CNTR
	RECT rcFrameRect;
	BORDERWIDTHS frameToolWidths;

#if defined( INPLACE_SVR )
	LPSERVERDOC lpServerDoc = (LPSERVERDOC)lpOutlineDoc;
	LPOLEINPLACEFRAME lpTopIPFrame=ServerDoc_GetTopInPlaceFrame(lpServerDoc);

	// if in-place active, add our tools to our in-place container's frame.
	if (lpTopIPFrame) {
		ServerDoc_AddFrameLevelTools(lpServerDoc);
		return;
	}
#endif  // INPLACE_SVR

	OutlineApp_GetFrameRect(g_lpApp, (LPRECT)&rcFrameRect);
	FrameTools_GetRequiredBorderSpace(
			lpOutlineDoc->m_lpFrameTools,
			(LPBORDERWIDTHS)&frameToolWidths
	);
	OutlineApp_SetBorderSpace(g_lpApp, (LPBORDERWIDTHS)&frameToolWidths);
	FrameTools_AttachToFrame(
			lpOutlineDoc->m_lpFrameTools, OutlineApp_GetWindow(lpOutlineApp));
	FrameTools_Move(lpOutlineDoc->m_lpFrameTools, (LPRECT)&rcFrameRect);
#endif  // ! INPLACE_CNTR

}

#endif  // USE_FRAMETOOLS


/* OutlineDoc_GetWindow
 * --------------------
 *
 *      Get the window handle of the document.
 */
HWND OutlineDoc_GetWindow(LPOUTLINEDOC lpOutlineDoc)
{
	if(! lpOutlineDoc) return NULL;
	return lpOutlineDoc->m_hWndDoc;
}


/* OutlineDoc_AddLine
 * ------------------
 *
 *      Add one line to the Document's LineList
 */
void OutlineDoc_AddLine(LPOUTLINEDOC lpOutlineDoc, LPLINE lpLine, int nIndex)
{
	LPLINELIST lpLL = &lpOutlineDoc->m_LineList;

	LineList_AddLine(lpLL, lpLine, nIndex);

	/* Update Name Table */
	OutlineNameTable_AddLineUpdate(lpOutlineDoc->m_lpNameTable, nIndex);

#if defined( INPLACE_CNTR )
	{
		LPCONTAINERDOC lpContainerDoc = (LPCONTAINERDOC)lpOutlineDoc;
		/* OLE2NOTE: after adding a line we need to
		**    update the PosRect of the In-Place active
		**    objects (if any) that follow the added line.
		**    NOTE: nIndex is index of line before new line.
		**          nIndex+1 is index of new line
		**          nIndex+2 is index of line after new line.
		*/
		ContainerDoc_UpdateInPlaceObjectRects(lpContainerDoc, nIndex+2);
	}
#endif

	OutlineDoc_SetModified(lpOutlineDoc, TRUE, TRUE, TRUE);
}


/* OutlineDoc_DeleteLine
 * ---------------------
 *
 *
 *      Delete one line from the document's LineList
 */
void OutlineDoc_DeleteLine(LPOUTLINEDOC lpOutlineDoc, int nIndex)
{
	LPLINELIST lpLL = &lpOutlineDoc->m_LineList;

#if defined( OLE_CNTR )
	LPLINE lpLine = LineList_GetLine(lpLL, nIndex);
	LPSTORAGE lpStgDoc = NULL;
	char szSaveStgName[CWCSTORAGENAME];
	BOOL fDeleteChildStg = FALSE;

	if (lpLine && (Line_GetLineType(lpLine) == CONTAINERLINETYPE) ) {

		/* OLE2NOTE: when a ContainerLine is being deleted by the user,
		**    it is important to delete the object's sub-storage
		**    otherwise it wastes space in the ContainerDoc's file.
		**    this function is called when lines are deleted by the
		**    Clear command and when lines are deleted by a DRAGMOVE
		**    operation.
		*/
		LPCONTAINERLINE lpContainerLine = (LPCONTAINERLINE)lpLine;

		// save name of child storage
		LSTRCPYN(szSaveStgName, lpContainerLine->m_szStgName,
				sizeof(szSaveStgName));
		lpStgDoc = ((LPOLEDOC)lpContainerLine->m_lpDoc)->m_lpStg;
		fDeleteChildStg = TRUE;
	}
#endif  // OLE_CNTR

	LineList_DeleteLine(lpLL, nIndex);

#if defined( OLE_CNTR )
	if (fDeleteChildStg && lpStgDoc) {
		HRESULT hrErr;

		// delete the obsolete child storage. it is NOT fatal if this fails

		hrErr = CallIStorageDestroyElementA(lpStgDoc, szSaveStgName);

#if defined( _DEBUG )
		if (hrErr != NOERROR) {
			OleDbgOutHResult("IStorage::DestroyElement return", hrErr);
		}
#endif
	}
#endif  // OLE_CNTR

	/* Update Name Table */
	OutlineNameTable_DeleteLineUpdate(lpOutlineDoc->m_lpNameTable, nIndex);

#if defined( INPLACE_CNTR )
	{
		LPCONTAINERDOC lpContainerDoc = (LPCONTAINERDOC)lpOutlineDoc;
		/* OLE2NOTE: after deleting a line we need to
		**    update the PosRect of the In-Place active
		**    objects (if any).
		*/
		ContainerDoc_UpdateInPlaceObjectRects(lpContainerDoc, nIndex);
	}
#endif

	OutlineDoc_SetModified(lpOutlineDoc, TRUE, TRUE, TRUE);

#if defined( OLE_VERSION )
	{
		LPOUTLINEAPP lpOutlineApp = (LPOUTLINEAPP)g_lpApp;
		LPOLEDOC    lpClipboardDoc = (LPOLEDOC)lpOutlineApp->m_lpClipboardDoc;

		/* OLE2NOTE: if the document that is the source of data on the
		**    clipborad has just had lines deleted, then the copied data
		**    is no longer considered a valid potential link source.
		**    disable the offering of CF_LINKSOURCE from the clipboard
		**    document. this avoids problems that arise when the
		**    editing operation changes or deletes the original data
		**    copied. we will not go to the trouble of determining if
		**    the deleted line actually is part of the link source.
		*/
		if (lpClipboardDoc
			&& lpClipboardDoc->m_fLinkSourceAvail
			&& lpClipboardDoc->m_lpSrcDocOfCopy == (LPOLEDOC)lpOutlineDoc) {
			lpClipboardDoc->m_fLinkSourceAvail = FALSE;

			/* OLE2NOTE: since we are changing the list of formats on
			**    the clipboard (ie. removing CF_LINKSOURCE), we must
			**    call OleSetClipboard again. to be sure that the
			**    clipboard datatransfer document object does not get
			**    destroyed we will guard the call to OleSetClipboard
			**    within a pair of AddRef/Release.
			*/
			OleDoc_AddRef((LPOLEDOC)lpClipboardDoc);    // guard obj life-time

			OLEDBG_BEGIN2("OleSetClipboard called\r\n")
			OleSetClipboard(
					(LPDATAOBJECT)&((LPOLEDOC)lpClipboardDoc)->m_DataObject);
			OLEDBG_END2

			OleDoc_Release((LPOLEDOC)lpClipboardDoc);    // rel. AddRef above
		}
	}
#endif  // OLE_VERSION
}


/* OutlineDoc_AddName
 * ------------------
 *
 *      Add a Name to the Document's NameTable
 */
void OutlineDoc_AddName(LPOUTLINEDOC lpOutlineDoc, LPOUTLINENAME lpOutlineName)
{
	LPOUTLINENAMETABLE lpOutlineNameTable = lpOutlineDoc->m_lpNameTable;

	OutlineNameTable_AddName(lpOutlineNameTable, lpOutlineName);

	OutlineDoc_SetModified(lpOutlineDoc, TRUE, FALSE, FALSE);
}


/* OutlineDoc_DeleteName
 * ---------------------
 *
 *
 *      Delete Name from the document's NameTable
 */
void OutlineDoc_DeleteName(LPOUTLINEDOC lpOutlineDoc, int nIndex)
{
	LPOUTLINENAMETABLE lpOutlineNameTable = lpOutlineDoc->m_lpNameTable;

	OutlineNameTable_DeleteName(lpOutlineNameTable, nIndex);

	OutlineDoc_SetModified(lpOutlineDoc, TRUE, FALSE, FALSE);
}


/* OutlineDoc_Destroy
 * ------------------
 *
 *  Free all memory that had been allocated for a document.
 *      this destroys the LineList & NameTable of the document.
 */
void OutlineDoc_Destroy(LPOUTLINEDOC lpOutlineDoc)
{
	LPLINELIST lpLL = &lpOutlineDoc->m_LineList;
#if defined( OLE_VERSION )
	LPOLEAPP lpOleApp = (LPOLEAPP)g_lpApp;
	LPOLEDOC lpOleDoc = (LPOLEDOC)lpOutlineDoc;

	if (lpOleDoc->m_fObjIsDestroying)
		return;     // doc destruction is in progress
#endif  // OLE_VERSION

	OLEDBG_BEGIN3("OutlineDoc_Destroy\r\n");

#if defined( OLE_VERSION )

	/* OLE2NOTE: in order to guarantee that the application does not
	**    prematurely exit before the destruction of the document is
	**    complete, we intially AddRef the App refcnt later Release it.
	**    This initial AddRef is artificial; it simply guarantees that
	**    the app object does not get destroyed until the end of this
	**    routine.
	*/
	OleApp_AddRef(lpOleApp);

	/* OLE2NOTE: perform processing required for OLE */
	OleDoc_Destroy(lpOleDoc);
#endif

	LineList_Destroy(lpLL);
	OutlineNameTable_Destroy(lpOutlineDoc->m_lpNameTable);

#if defined( USE_HEADING )
	if (! lpOutlineDoc->m_fDataTransferDoc)
		Heading_Destroy((LPHEADING)&lpOutlineDoc->m_heading);
#endif

#if defined( USE_FRAMETOOLS )
	if (! lpOutlineDoc->m_fDataTransferDoc)
		FrameTools_AssociateDoc(lpOutlineDoc->m_lpFrameTools, NULL);
#endif  // USE_FRAMETOOLS

	DestroyWindow(lpOutlineDoc->m_hWndDoc);
	Delete(lpOutlineDoc);   // free memory for doc itself
	OleDbgOut1("@@@@ DOC DESTROYED\r\n");

#if defined( OLE_VERSION )
	OleApp_Release(lpOleApp);       // release artificial AddRef above
#endif

	OLEDBG_END3
}


/* OutlineDoc_ReSize
 * -----------------
 *
 *  Resize the document and its components
 *
 * Parameter:
 *      lpRect  the new size of the document. Use current size if NULL
 */
void OutlineDoc_Resize(LPOUTLINEDOC lpOutlineDoc, LPRECT lpRect)
{
	RECT            rect;
	LPLINELIST      lpLL;

#if defined( USE_HEADING )
	LPHEADING       lphead;
#endif  // USE_HEADING

	LPSCALEFACTOR   lpscale;
	HWND            hWndLL;

	if (!lpOutlineDoc)
		return;

	lpLL = (LPLINELIST)&lpOutlineDoc->m_LineList;
	lpscale = (LPSCALEFACTOR)&lpOutlineDoc->m_scale;
	hWndLL = LineList_GetWindow(lpLL);

	if (lpRect) {
		CopyRect((LPRECT)&rect, lpRect);
		MoveWindow(lpOutlineDoc->m_hWndDoc, rect.left, rect.top,
				rect.right-rect.left, rect.bottom-rect.top, TRUE);
	}

	GetClientRect(lpOutlineDoc->m_hWndDoc, (LPRECT)&rect);

#if defined( USE_HEADING )
	lphead = OutlineDoc_GetHeading(lpOutlineDoc);
	rect.left += Heading_RH_GetWidth(lphead, lpscale);
	rect.top += Heading_CH_GetHeight(lphead, lpscale);
#endif  // USE_HEADING

	if (lpLL) {
		MoveWindow(hWndLL, rect.left, rect.top,
				rect.right-rect.left, rect.bottom-rect.top, TRUE);
	}

#if defined( USE_HEADING )
	if (lphead)
		Heading_Move(lphead, lpOutlineDoc->m_hWndDoc, lpscale);
#endif  // USE_HEADING

#if defined( INPLACE_CNTR )
	ContainerDoc_UpdateInPlaceObjectRects((LPCONTAINERDOC)lpOutlineDoc, 0);
#endif
}


/* OutlineDoc_GetNameTable
 * -----------------------
 *
 *      Get nametable associated with the line list
 */
LPOUTLINENAMETABLE OutlineDoc_GetNameTable(LPOUTLINEDOC lpOutlineDoc)
{
	if (!lpOutlineDoc)
		return NULL;
	else
		return lpOutlineDoc->m_lpNameTable;
}


/* OutlineDoc_GetLineList
 * ----------------------
 *
 *      Get listlist associated with the OutlineDoc
 */
LPLINELIST OutlineDoc_GetLineList(LPOUTLINEDOC lpOutlineDoc)
{
	if (!lpOutlineDoc)
		return NULL;
	else
		return (LPLINELIST)&lpOutlineDoc->m_LineList;
}


/* OutlineDoc_GetNameCount
 * -----------------------
 *
 * Return number of names in table
 */
int OutlineDoc_GetNameCount(LPOUTLINEDOC lpOutlineDoc)
{
	return OutlineNameTable_GetCount(lpOutlineDoc->m_lpNameTable);
}


/* OutlineDoc_GetLineCount
 * -----------------------
 *
 * Return number of lines in the LineList
 */
int OutlineDoc_GetLineCount(LPOUTLINEDOC lpOutlineDoc)
{
	return LineList_GetCount(&lpOutlineDoc->m_LineList);
}


/* OutlineDoc_SetFileName
 * ----------------------
 *
 *      Set the filename of a document.
 *
 *  OLE2NOTE: If the ServerDoc has a valid filename then, the object is
 *  registered in the running object table (ROT). if the name of the doc
 *  changes (eg. via SaveAs) then the previous registration must be revoked
 *  and the document re-registered under the new name.
 */
BOOL OutlineDoc_SetFileName(LPOUTLINEDOC lpOutlineDoc, LPSTR lpszNewFileName, LPSTORAGE lpNewStg)
{
	OleDbgAssertSz(lpszNewFileName != NULL,	"Can't reset doc to Untitled!");
	if (lpszNewFileName == NULL)
		return FALSE;

	AnsiLowerBuff(lpszNewFileName, (UINT)lstrlen(lpszNewFileName));

#if defined( OLE_CNTR )
	{
		LPCONTAINERDOC lpContainerDoc = (LPCONTAINERDOC)lpOutlineDoc;
		LPOLEDOC lpOleDoc = (LPOLEDOC)lpOutlineDoc;

		/* OLE2NOTE: the container version of the application keeps its
		**    storage open at all times. if the document's storage is not
		**    open, then open it.
		*/

		if (lpNewStg) {

			/* CASE 1 -- document is being loaded from a file. lpNewStg is
			**    still open from the OutlineDoc_LoadFromFile function.
			*/

			lpOutlineDoc->m_docInitType = DOCTYPE_FROMFILE;

		} else {

			/* CASE 2 -- document is being associated with a valid file
			**    that is not yet open. thus we must now open the file.
			*/

			if (lpOutlineDoc->m_docInitType == DOCTYPE_FROMFILE &&
					lstrcmp(lpOutlineDoc->m_szFileName,lpszNewFileName)==0) {

				/* CASE 2a -- new filename is same as current file. if the
				**    stg is already open, then the lpStg is still valid.
				**    if it is not open, then open it.
				*/
				if (! lpOleDoc->m_lpStg) {
					lpOleDoc->m_lpStg = OleStdOpenRootStorage(
							lpszNewFileName,
							STGM_READWRITE | STGM_SHARE_DENY_WRITE
					);
					if (! lpOleDoc->m_lpStg) return FALSE;
				}

			} else {

				/* CASE 2b -- new filename is NOT same as current file.
				**    a SaveAs operation is pending. open the new file and
				**    hold the storage pointer in m_lpNewStg. the
				**    subsequent call to Doc_SaveToFile will save the
				**    document into the new storage pointer and release the
				**    old storage pointer.
				*/

				lpOutlineDoc->m_docInitType = DOCTYPE_FROMFILE;

				lpContainerDoc->m_lpNewStg = OleStdCreateRootStorage(
						lpszNewFileName,
						STGM_READWRITE | STGM_SHARE_DENY_WRITE | STGM_CREATE
				);
				if (! lpContainerDoc->m_lpNewStg) return FALSE;
			}
		}
	}
#endif      // OLE_CNTR

	if (lpOutlineDoc->m_docInitType != DOCTYPE_FROMFILE ||
		lstrcmp(lpOutlineDoc->m_szFileName, lpszNewFileName) != 0) {

		/* A new valid file name is being associated with the document */

		lstrcpy(lpOutlineDoc->m_szFileName, lpszNewFileName);
		lpOutlineDoc->m_docInitType = DOCTYPE_FROMFILE;

		// set lpszDocTitle to point to filename without path
		lpOutlineDoc->m_lpszDocTitle = lpOutlineDoc->m_szFileName +
			lstrlen(lpOutlineDoc->m_szFileName) - 1;
		while (lpOutlineDoc->m_lpszDocTitle > lpOutlineDoc->m_szFileName
			&& ! IS_FILENAME_DELIM(lpOutlineDoc->m_lpszDocTitle[-1])) {
			lpOutlineDoc->m_lpszDocTitle--;
		}

		OutlineDoc_SetTitle(lpOutlineDoc, TRUE /*fMakeUpperCase*/);

#if defined( OLE_VERSION )
		{
			/* OLE2NOTE: both containers and servers must properly
			**    register in the RunningObjectTable. if the document
			**    is performing a SaveAs operation, then it must
			**    re-register in the ROT with the new moniker. in
			**    addition any embedded object, pseudo objects, and/or
			**    linking clients must be informed that the document's
			**    moniker has changed.
			*/

			LPOLEDOC lpOleDoc = (LPOLEDOC)lpOutlineDoc;

			if (lpOleDoc->m_lpFileMoniker) {
				OleStdRelease((LPUNKNOWN)lpOleDoc->m_lpFileMoniker);
				lpOleDoc->m_lpFileMoniker = NULL;
			}

			CreateFileMonikerA(lpszNewFileName,
				&lpOleDoc->m_lpFileMoniker);

			OleDoc_DocRenamedUpdate(lpOleDoc, lpOleDoc->m_lpFileMoniker);
		}
#endif      // OLE_VERSION

	}

	return TRUE;
}


/* OutlineDoc_SetTitle
 * -------------------
 *
 * Set window text to be current filename.
 * The following window hierarchy exits:
 *      hWndApp
 *          hWndDoc
 *              hWndListBox
 *  The frame window is the window which gets the title.
 */
void OutlineDoc_SetTitle(LPOUTLINEDOC lpOutlineDoc, BOOL fMakeUpperCase)
{
	HWND hWnd;
	LPSTR lpszText;

	if (!lpOutlineDoc->m_hWndDoc) return;
	if ((hWnd = GetParent(lpOutlineDoc->m_hWndDoc)) == NULL) return;

	lpszText = OleStdMalloc((UINT)(lstrlen(APPNAME) + 4 +
								   lstrlen(lpOutlineDoc->m_lpszDocTitle)));
	if (!lpszText) return;

	lstrcpy(lpszText, APPNAME);
	lstrcat(lpszText," - ");
	lstrcat(lpszText, (LPSTR)lpOutlineDoc->m_lpszDocTitle);

	if (fMakeUpperCase)
		AnsiUpperBuff(lpszText, (UINT)lstrlen(lpszText));

	SetWindowText(hWnd,lpszText);
	OleStdFree(lpszText);
}


/* OutlineDoc_Close
 * ----------------
 *
 * Close active document. If modified, prompt the user if
 * he wants to save.
 *
 *  Returns:
 *      FALSE -- user canceled the closing of the doc.
 *      TRUE -- the doc was successfully closed
 */
BOOL OutlineDoc_Close(LPOUTLINEDOC lpOutlineDoc, DWORD dwSaveOption)
{
	LPOUTLINEAPP lpOutlineApp = (LPOUTLINEAPP)g_lpApp;

#if defined( OLE_VERSION )
	/* OLE2NOTE: call OLE specific function instead */
	return OleDoc_Close((LPOLEDOC)lpOutlineDoc, dwSaveOption);

#else

	if (! lpOutlineDoc)
		return TRUE;            // active doc's are already destroyed

	if (! OutlineDoc_CheckSaveChanges(lpOutlineDoc, &dwSaveOption))
		return FALSE;           // abort closing the doc

	OutlineDoc_Destroy(lpOutlineDoc);

	OutlineApp_DocUnlockApp(lpOutlineApp, lpOutlineDoc);

	return TRUE;

#endif      // ! OLE_VERSION
}


/* OutlineDoc_CheckSaveChanges
 * ---------------------------
 *
 * Check if the document has been modified. if so, prompt the user if
 *      the changes should be saved. if yes save them.
 * Returns TRUE if the doc is safe to close (user answered Yes or No)
 *         FALSE if the user canceled the save changes option.
 */
BOOL OutlineDoc_CheckSaveChanges(
		LPOUTLINEDOC        lpOutlineDoc,
		LPDWORD             lpdwSaveOption
)
{
	LPOUTLINEAPP lpOutlineApp = (LPOUTLINEAPP)g_lpApp;
	int nResponse;

	if (*lpdwSaveOption == OLECLOSE_NOSAVE)
		return TRUE;

	if(! OutlineDoc_IsModified(lpOutlineDoc))
		return TRUE;    // saving is not necessary

	/* OLE2NOTE: our document is dirty so it needs to be saved. if
	**    OLECLOSE_PROMPTSAVE the user should be prompted to see if the
	**    document should be saved. is specified but the document is NOT
	**    visible to the user, then the user can NOT be prompted. in
	**    the situation the document should be saved without prompting.
	**    if OLECLOSE_SAVEIFDIRTY is specified then, the document
	**    should also be saved without prompting.
	*/
	if (*lpdwSaveOption == OLECLOSE_PROMPTSAVE &&
			IsWindowVisible(lpOutlineDoc->m_hWndDoc)) {

		// prompt the user to see if changes should be saved.
#if defined( OLE_VERSION )
		OleApp_PreModalDialog(
				(LPOLEAPP)lpOutlineApp, (LPOLEDOC)lpOutlineApp->m_lpDoc);
#endif
		nResponse = MessageBox(
				lpOutlineApp->m_hWndApp,
				MsgSaveFile,
				APPNAME,
				MB_ICONQUESTION | MB_YESNOCANCEL
		);
#if defined( OLE_VERSION )
		OleApp_PostModalDialog(
				(LPOLEAPP)lpOutlineApp, (LPOLEDOC)lpOutlineApp->m_lpDoc);
#endif
		if(nResponse==IDCANCEL)
			return FALSE;   // close is canceled
		if(nResponse==IDNO) {
			// Reset the save option to NOSAVE per user choice
			*lpdwSaveOption = OLECLOSE_NOSAVE;
			return TRUE;    // don't save, but is ok to close
		}
	} else if (*lpdwSaveOption != OLECLOSE_SAVEIFDIRTY) {
		OleDbgAssertSz(FALSE, "Invalid dwSaveOption\r\n");
		*lpdwSaveOption = OLECLOSE_NOSAVE;
		return TRUE;        // unknown *lpdwSaveOption; close w/o saving
	}

#if defined( OLE_SERVER )
	if (lpOutlineDoc->m_docInitType == DOCTYPE_EMBEDDED) {
		LPSERVERDOC lpServerDoc = (LPSERVERDOC)lpOutlineDoc;
		HRESULT hrErr;

		/* OLE2NOTE: Update the container before closing without prompting
		**    the user. To update the container, we must ask our container
		**    to save us.
		*/
		OleDbgAssert(lpServerDoc->m_lpOleClientSite != NULL);
		OLEDBG_BEGIN2("IOleClientSite::SaveObject called\r\n")
		hrErr = lpServerDoc->m_lpOleClientSite->lpVtbl->SaveObject(
				lpServerDoc->m_lpOleClientSite
		);
		OLEDBG_END2

		if (hrErr != NOERROR) {
			OleDbgOutHResult("IOleClientSite::SaveObject returned", hrErr);
			return FALSE;
		}

		return TRUE;    // doc is safe to be closed

	} else
#endif      // OLE_SERVER
	{
		return OutlineApp_SaveCommand(lpOutlineApp);
	}
}


/* OutlineDoc_IsModified
 * ---------------------
 *
 * Return modify flag of OUTLINEDOC
 */
BOOL OutlineDoc_IsModified(LPOUTLINEDOC lpOutlineDoc)
{
	if (lpOutlineDoc->m_fModified)
		return lpOutlineDoc->m_fModified;

#if defined( OLE_CNTR )
	{
		/* OLE2NOTE: if there are OLE objects, then we must ask if any of
		**    them are dirty. if so we must consider our document
		**    as modified.
		*/
		LPCONTAINERDOC lpContainerDoc = (LPCONTAINERDOC)lpOutlineDoc;
		LPLINELIST  lpLL;
		int         nLines;
		int         nIndex;
		LPLINE      lpLine;
		HRESULT     hrErr;

		lpLL = (LPLINELIST)&((LPOUTLINEDOC)lpContainerDoc)->m_LineList;
		nLines = LineList_GetCount(lpLL);

		for (nIndex = 0; nIndex < nLines; nIndex++) {
			lpLine = LineList_GetLine(lpLL, nIndex);
			if (!lpLine)
				break;
			if (Line_GetLineType(lpLine) == CONTAINERLINETYPE) {
				LPCONTAINERLINE lpContainerLine = (LPCONTAINERLINE)lpLine;
				if (lpContainerLine->m_lpPersistStg) {
					hrErr = lpContainerLine->m_lpPersistStg->lpVtbl->IsDirty(
							lpContainerLine->m_lpPersistStg);
					/* OLE2NOTE: we will only accept an explicit "no i
					**    am NOT dirty statement" (ie. S_FALSE) as an
					**    indication that the object is clean. eg. if
					**    the object returns E_NOTIMPL we must
					**    interpret it as the object IS dirty.
					*/
					if (GetScode(hrErr) != S_FALSE)
						return TRUE;
				}
			}
		}
	}
#endif
	return FALSE;
}


/* OutlineDoc_SetModified
 * ----------------------
 *
 *  Set the modified flag of the document
 *
 */
void OutlineDoc_SetModified(LPOUTLINEDOC lpOutlineDoc, BOOL fModified, BOOL fDataChanged, BOOL fSizeChanged)
{
	lpOutlineDoc->m_fModified = fModified;

#if defined( OLE_SERVER )
	if (! lpOutlineDoc->m_fDataTransferDoc) {
		LPSERVERDOC lpServerDoc = (LPSERVERDOC)lpOutlineDoc;

		/* OLE2NOTE: if the document has changed, then broadcast the change
		**    to all clients who have set up Advise connections. notify
		**    them that our data (and possibly also our extents) have
		**    changed.
		*/
		if (fDataChanged) {
			lpServerDoc->m_fDataChanged     = TRUE;
			lpServerDoc->m_fSizeChanged     = fSizeChanged;
			lpServerDoc->m_fSendDataOnStop  = TRUE;

			ServerDoc_SendAdvise(
					lpServerDoc,
					OLE_ONDATACHANGE,
					NULL,   /* lpmkDoc -- not relevant here */
					0       /* advf -- no flags necessary */
			);
		}
	}
#endif  // OLE_SERVER
}


/* OutlineDoc_SetRedraw
 * --------------------
 *
 *  Enable/Disable the redraw of the document on screen.
 *  The calls to SetRedraw counted so that nested calls can be handled
 *  properly. calls to SetRedraw must be balanced.
 *
 *  fEnbaleDraw = TRUE      - enable redraw
 *                FALSE     - disable redraw
 */
void OutlineDoc_SetRedraw(LPOUTLINEDOC lpOutlineDoc, BOOL fEnableDraw)
{
	static HCURSOR hPrevCursor = NULL;

	if (fEnableDraw) {
		if (lpOutlineDoc->m_nDisableDraw == 0)
			return;     // already enabled; no state transition

		if (--lpOutlineDoc->m_nDisableDraw > 0)
			return;     // drawing should still be disabled
	} else {
		if (lpOutlineDoc->m_nDisableDraw++ > 0)
			return;     // already disabled; no state transition
	}

	if (lpOutlineDoc->m_nDisableDraw > 0) {
		// this may take a while, put up hourglass cursor
		hPrevCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));
	} else {
		if (hPrevCursor) {
			SetCursor(hPrevCursor);     // restore original cursor
			hPrevCursor = NULL;
		}
	}

#if defined( OLE_SERVER )
	/* OLE2NOTE: for the Server version, while Redraw is disabled
	**    postpone sending advise notifications until Redraw is re-enabled.
	*/
	{
		LPSERVERDOC lpServerDoc = (LPSERVERDOC)lpOutlineDoc;
		LPSERVERNAMETABLE lpServerNameTable =
				(LPSERVERNAMETABLE)lpOutlineDoc->m_lpNameTable;

		if (lpOutlineDoc->m_nDisableDraw == 0) {
			/* drawing is being Enabled. if changes occurred while drawing
			**    was disabled, then notify clients now.
			*/
			if (lpServerDoc->m_fDataChanged)
				ServerDoc_SendAdvise(
						lpServerDoc,
						OLE_ONDATACHANGE,
						NULL,   /* lpmkDoc -- not relevant here */
						0       /* advf -- no flags necessary */
				);

			/* OLE2NOTE: send pending change notifications for pseudo objs. */
			ServerNameTable_SendPendingAdvises(lpServerNameTable);

		}
	}
#endif      // OLE_SERVER

#if defined( OLE_CNTR )
	/* OLE2NOTE: for the Container version, while Redraw is disabled
	**    postpone updating the extents of OLE objects until Redraw is
	**    re-enabled.
	*/
	{
		LPCONTAINERDOC lpContainerDoc = (LPCONTAINERDOC)lpOutlineDoc;

		/* Update the extents of any OLE object that is marked that
		**    its size may  have changed. when an
		**    IAdviseSink::OnViewChange notification is received,
		**    the corresponding ContainerLine is marked
		**    (m_fDoGetExtent==TRUE) and a message
		**    (WM_U_UPDATEOBJECTEXTENT) is posted to the document
		**    indicating that there are dirty objects.
		*/
		if (lpOutlineDoc->m_nDisableDraw == 0)
			ContainerDoc_UpdateExtentOfAllOleObjects(lpContainerDoc);
	}
#endif      // OLE_CNTR

	// enable/disable redraw of the LineList listbox
	LineList_SetRedraw(&lpOutlineDoc->m_LineList, fEnableDraw);
}


/* OutlineDoc_SetSel
 * -----------------
 *
 *      Set the selection in the documents's LineList
 */
void OutlineDoc_SetSel(LPOUTLINEDOC lpOutlineDoc, LPLINERANGE lplrSel)
{
	LineList_SetSel(&lpOutlineDoc->m_LineList, lplrSel);
}


/* OutlineDoc_GetSel
 * -----------------
 *
 *      Get the selection in the documents's LineList.
 *
 *      Returns the count of items selected
 */
int OutlineDoc_GetSel(LPOUTLINEDOC lpOutlineDoc, LPLINERANGE lplrSel)
{
	return LineList_GetSel(&lpOutlineDoc->m_LineList, lplrSel);
}


/* OutlineDoc_ForceRedraw
 * ----------------------
 *
 *      Force the document window to repaint.
 */
void OutlineDoc_ForceRedraw(LPOUTLINEDOC lpOutlineDoc, BOOL fErase)
{
	if (!lpOutlineDoc)
		return;

	LineList_ForceRedraw(&lpOutlineDoc->m_LineList, fErase);
	Heading_CH_ForceRedraw(&lpOutlineDoc->m_heading, fErase);
	Heading_RH_ForceRedraw(&lpOutlineDoc->m_heading, fErase);
}


/* OutlineDoc_RenderFormat
 * -----------------------
 *
 *      Render a clipboard format supported by ClipboardDoc
 */
void OutlineDoc_RenderFormat(LPOUTLINEDOC lpOutlineDoc, UINT uFormat)
{
	LPOUTLINEAPP lpOutlineApp = (LPOUTLINEAPP)g_lpApp;
	HGLOBAL      hData = NULL;

	if (uFormat == lpOutlineApp->m_cfOutline)
		hData = OutlineDoc_GetOutlineData(lpOutlineDoc, NULL);

	else if (uFormat == CF_TEXT)
		hData = OutlineDoc_GetTextData(lpOutlineDoc, NULL);

	else {
		OutlineApp_ErrorMessage(lpOutlineApp, ErrMsgFormatNotSupported);
		return;
	}

	SetClipboardData(uFormat, hData);
}


/* OutlineDoc_RenderAllFormats
 * ---------------------------
 *
 *      Render all formats supported by ClipboardDoc
 */
void OutlineDoc_RenderAllFormats(LPOUTLINEDOC lpOutlineDoc)
{
	LPOUTLINEAPP lpOutlineApp = (LPOUTLINEAPP)g_lpApp;
	HGLOBAL      hData = NULL;

	OpenClipboard(lpOutlineDoc->m_hWndDoc);

	hData = OutlineDoc_GetOutlineData(lpOutlineDoc, NULL);
	SetClipboardData(lpOutlineApp->m_cfOutline, hData);

	hData = OutlineDoc_GetTextData(lpOutlineDoc, NULL);
	SetClipboardData(CF_TEXT, hData);

	CloseClipboard();
}



/* OutlineDoc_GetOutlineData
 * -------------------------
 *
 * Return a handle to an array of TextLine objects for the desired line
 *      range.
 *  NOTE: if lplrSel == NULL, then all lines are returned
 *
 */
HGLOBAL OutlineDoc_GetOutlineData(LPOUTLINEDOC lpOutlineDoc, LPLINERANGE lplrSel)
{
	HGLOBAL     hOutline  = NULL;
	LPLINELIST  lpLL=(LPLINELIST)&lpOutlineDoc->m_LineList;
	LPLINE      lpLine;
	LPTEXTLINE  arrLine;
	int     i;
	int     nStart = (lplrSel ? lplrSel->m_nStartLine : 0);
	int     nEnd =(lplrSel ? lplrSel->m_nEndLine : LineList_GetCount(lpLL)-1);
	int     nLines = nEnd - nStart + 1;
	int     nCopied = 0;

	hOutline=GlobalAlloc(GMEM_SHARE | GMEM_ZEROINIT,sizeof(TEXTLINE)*nLines);

	if (! hOutline) return NULL;

	arrLine=(LPTEXTLINE)GlobalLock(hOutline);

	for (i = nStart; i <= nEnd; i++) {
		lpLine=LineList_GetLine(lpLL, i);
		if (lpLine && Line_GetOutlineData(lpLine, &arrLine[nCopied]))
			nCopied++;
	}

	GlobalUnlock(hOutline);

	return hOutline;
}



/* OutlineDoc_GetTextData
 * ----------------------
 *
 * Return a handle to an object's data in text form for the desired line
 *      range.
 *  NOTE: if lplrSel == NULL, then all lines are returned
 *
 */
HGLOBAL OutlineDoc_GetTextData(LPOUTLINEDOC lpOutlineDoc, LPLINERANGE lplrSel)
{
	LPLINELIST  lpLL=(LPLINELIST)&lpOutlineDoc->m_LineList;
	LPLINE  lpLine;
	HGLOBAL hText = NULL;
	LPSTR   lpszText = NULL;
	DWORD   dwMemSize=0;
	int     i,j;
	int     nStart = (lplrSel ? lplrSel->m_nStartLine : 0);
	int     nEnd =(lplrSel ? lplrSel->m_nEndLine : LineList_GetCount(lpLL)-1);
	int     nTabLevel;

	// calculate memory size required
	for(i = nStart; i <= nEnd; i++) {
		lpLine=LineList_GetLine(lpLL, i);
		if (! lpLine)
			continue;

		dwMemSize += Line_GetTabLevel(lpLine);
		dwMemSize += Line_GetTextLen(lpLine);

		dwMemSize += 2; // add 1 for '\r\n' at the end of each line
	}
	dwMemSize++;        // add 1 for '\0' at the end of string

	if(!(hText = GlobalAlloc(GMEM_SHARE | GMEM_ZEROINIT, dwMemSize)))
		return NULL;

	if(!(lpszText = (LPSTR)GlobalLock(hText)))
		return NULL;

	// put line text to memory
	for(i = nStart; i <= nEnd; i++) {
		lpLine=LineList_GetLine(lpLL, i);
		if (! lpLine)
			continue;

		nTabLevel=Line_GetTabLevel(lpLine);
		for(j = 0; j < nTabLevel; j++)
			*lpszText++='\t';

		Line_GetTextData(lpLine, lpszText);
		while(*lpszText)
			lpszText++;     // advance to end of string

		*lpszText++ = '\r';
		*lpszText++ = '\n';
	}

	GlobalUnlock (hText);

	return hText;
}


/* OutlineDoc_SaveToFile
 * ---------------------
 *
 *      Save the document to a file with the same name as stored in the
 * document
 */
BOOL OutlineDoc_SaveToFile(LPOUTLINEDOC lpOutlineDoc, LPCSTR lpszFileName, UINT uFormat, BOOL fRemember)
{
#if defined( OLE_CNTR )
	// Call OLE container specific function instead
	return ContainerDoc_SaveToFile(
			(LPCONTAINERDOC)lpOutlineDoc,
			lpszFileName,
			uFormat,
			fRemember
	);

#else

	LPSTORAGE lpDestStg = NULL;
	HRESULT hrErr;
	BOOL fStatus;
	LPOUTLINEAPP lpOutlineApp = (LPOUTLINEAPP)g_lpApp;

	if (fRemember) {
		if (lpszFileName) {
			fStatus = OutlineDoc_SetFileName(
					lpOutlineDoc,
					(LPSTR)lpszFileName,
					NULL
			);
			if (! fStatus) goto error;
		} else
			lpszFileName = lpOutlineDoc->m_szFileName; // use cur. file name
	} else if (! lpszFileName) {
		goto error;
	}

	hrErr = StgCreateDocfileA(
			lpszFileName,
			STGM_READWRITE|STGM_DIRECT|STGM_SHARE_EXCLUSIVE|STGM_CREATE,
			0,
			&lpDestStg
	);

	OleDbgAssertSz(hrErr == NOERROR, "Could not create Docfile");
	if (hrErr != NOERROR)
		goto error;

#if defined( OLE_SERVER )

	/*  OLE2NOTE: we must be sure to write our class ID into our
	**    storage. this information is used by OLE to determine the
	**    class of the data stored in our storage. Even for top
	**    "file-level" objects this information should be written to
	**    the file.
	*/
	if(WriteClassStg(lpDestStg, &CLSID_APP) != NOERROR)
		goto error;
#endif

	fStatus = OutlineDoc_SaveSelToStg(
			lpOutlineDoc,
			NULL,
			uFormat,
			lpDestStg,
			FALSE,      /* fSameAsLoad */
			fRemember
	);
	if (! fStatus) goto error;

	OleStdRelease((LPUNKNOWN)lpDestStg);

	if (fRemember)
		OutlineDoc_SetModified(lpOutlineDoc, FALSE, FALSE, FALSE);

#if defined( OLE_SERVER )

	/* OLE2NOTE: (SERVER-ONLY) inform any linking clients that the
	**    document has been saved. in addition, any currently active
	**    pseudo objects should also inform their clients.
	*/
	ServerDoc_SendAdvise (
			(LPSERVERDOC)lpOutlineDoc,
			OLE_ONSAVE,
			NULL,   /* lpmkDoc -- not relevant here */
			0       /* advf -- not relevant here */
	);

#endif

	return TRUE;

error:
	if (lpDestStg)
		OleStdRelease((LPUNKNOWN)lpDestStg);

	OutlineApp_ErrorMessage(lpOutlineApp, ErrMsgSaving);
	return FALSE;

#endif  // ! OLE_CNTR
}


/* OutlineDoc_LoadFromFile
 * -----------------------
 *
 *      Load a document from a file
 */
BOOL OutlineDoc_LoadFromFile(LPOUTLINEDOC lpOutlineDoc, LPSTR lpszFileName)
{
	LPOUTLINEAPP    lpOutlineApp = (LPOUTLINEAPP)g_lpApp;
	LPLINELIST      lpLL = &lpOutlineDoc->m_LineList;
	HRESULT         hrErr;
	SCODE           sc;
	LPSTORAGE       lpSrcStg;
	BOOL            fStatus;

	hrErr = StgOpenStorageA(lpszFileName,
			NULL,
#if defined( OLE_CNTR )
			STGM_READWRITE | STGM_TRANSACTED | STGM_SHARE_DENY_WRITE,
#else
			STGM_READ | STGM_SHARE_DENY_WRITE,
#endif
			NULL,
			0,
			&lpSrcStg
	);

	if ((sc = GetScode(hrErr)) == STG_E_FILENOTFOUND) {
		OutlineApp_ErrorMessage(lpOutlineApp, "File not found");
		return FALSE;
	} else if (sc == STG_E_FILEALREADYEXISTS) {
		OutlineApp_ErrorMessage(lpOutlineApp, ErrMsgFormat);
		return FALSE;
	} else if (sc != S_OK) {
		OleDbgOutScode("StgOpenStorage returned", sc);
		OutlineApp_ErrorMessage(
				lpOutlineApp,
				"File already in use--could not be opened"
		);
		return FALSE;
	}

	if(! OutlineDoc_LoadFromStg(lpOutlineDoc, lpSrcStg)) goto error;

	fStatus = OutlineDoc_SetFileName(lpOutlineDoc, lpszFileName, lpSrcStg);
	if (! fStatus) goto error;

	OleStdRelease((LPUNKNOWN)lpSrcStg);

	return TRUE;

error:
	OleStdRelease((LPUNKNOWN)lpSrcStg);
	OutlineApp_ErrorMessage(lpOutlineApp, ErrMsgOpening);
	return FALSE;
}



/* OutlineDoc_LoadFromStg
 * ----------------------
 *
 *  Load entire document from an open IStorage pointer (lpSrcStg)
 *      Return TRUE if ok, FALSE if error.
 */
BOOL OutlineDoc_LoadFromStg(LPOUTLINEDOC lpOutlineDoc, LPSTORAGE lpSrcStg)
{
	LPOUTLINEAPP lpOutlineApp = (LPOUTLINEAPP)g_lpApp;
	HRESULT hrErr;
	BOOL fStatus;
	ULONG nRead;
	LINERANGE lrSel = { 0, 0 };
	LPSTREAM lpLLStm;
        OUTLINEDOCHEADER_ONDISK docRecordOnDisk;
	OUTLINEDOCHEADER docRecord;

	hrErr = CallIStorageOpenStreamA(
			lpSrcStg,
			"LineList",
			NULL,
			STGM_READ | STGM_SHARE_EXCLUSIVE,
			0,
			&lpLLStm
	);

	if (hrErr != NOERROR) {
		OleDbgOutHResult("Open LineList Stream returned", hrErr);
		goto error;
	}

	/* read OutlineDoc header record */
	hrErr = lpLLStm->lpVtbl->Read(
			lpLLStm,
			(LPVOID)&docRecordOnDisk,
			sizeof(docRecordOnDisk),
			&nRead
	);

	if (hrErr != NOERROR) {
		OleDbgOutHResult("Read OutlineDoc header returned", hrErr);
		goto error;
    }

        //  Transform docRecordOnDisk into docRecord
        //  Compilers should handle aligment correctly
        strcpy(docRecord.m_szFormatName, docRecordOnDisk.m_szFormatName);
        docRecord.m_narrAppVersionNo[0] = (int) docRecordOnDisk.m_narrAppVersionNo[0];
        docRecord.m_narrAppVersionNo[1] = (int) docRecordOnDisk.m_narrAppVersionNo[1];
        docRecord.m_fShowHeading = (BOOL) docRecordOnDisk.m_fShowHeading;
        docRecord.m_reserved1 = docRecordOnDisk.m_reserved1;
        docRecord.m_reserved2 = docRecordOnDisk.m_reserved2;
        docRecord.m_reserved3 = docRecordOnDisk.m_reserved3;
        docRecord.m_reserved4 = docRecordOnDisk.m_reserved4;

	fStatus = OutlineApp_VersionNoCheck(
			lpOutlineApp,
			docRecord.m_szFormatName,
			docRecord.m_narrAppVersionNo
	);

	/* storage is an incompatible version; file can not be read */
	if (! fStatus)
		goto error;

	lpOutlineDoc->m_heading.m_fShow = docRecord.m_fShowHeading;

#if defined( OLE_SERVER )
	{
		// Load ServerDoc specific data
		LPSERVERDOC lpServerDoc = (LPSERVERDOC)lpOutlineDoc;
#if defined( SVR_TREATAS )
		LPOUTLINEAPP lpOutlineApp = (LPOUTLINEAPP)g_lpApp;
		CLSID       clsid;
		CLIPFORMAT  cfFmt;
		LPSTR       lpszType;
#endif  // SVR_TREATAS

		lpServerDoc->m_nNextRangeNo = (ULONG)docRecord.m_reserved1;

#if defined( SVR_TREATAS )
		/* OLE2NOTE: if the Server is capable of supporting "TreatAs"
		**    (aka. ActivateAs), it must read the class that is written
		**    into the storage. if this class is NOT the app's own
		**    class ID, then this is a TreatAs operation. the server
		**    then must faithfully pretend to be the class that is
		**    written into the storage. it must also faithfully write
		**    the data back to the storage in the SAME format as is
		**    written in the storage.
		**
		**    SVROUTL and ISVROTL can emulate each other. they have the
		**    simplification that they both read/write the identical
		**    format. thus for these apps no actual conversion of the
		**    native bits is actually required.
		*/
		lpServerDoc->m_clsidTreatAs = CLSID_NULL;
		if (OleStdGetTreatAsFmtUserType(&CLSID_APP, lpSrcStg, &clsid,
							(CLIPFORMAT FAR*)&cfFmt, (LPSTR FAR*)&lpszType)) {

			if (cfFmt == lpOutlineApp->m_cfOutline) {
				// We should perform TreatAs operation
				if (lpServerDoc->m_lpszTreatAsType)
					OleStdFreeString(lpServerDoc->m_lpszTreatAsType, NULL);

				lpServerDoc->m_clsidTreatAs = clsid;
				((LPOUTLINEDOC)lpServerDoc)->m_cfSaveFormat = cfFmt;
				lpServerDoc->m_lpszTreatAsType = lpszType;

				OleDbgOut3("OutlineDoc_LoadFromStg: TreateAs ==> '");
				OleDbgOutNoPrefix3(lpServerDoc->m_lpszTreatAsType);
				OleDbgOutNoPrefix3("'\r\n");
			} else {
				// ERROR: we ONLY support TreatAs for CF_OUTLINE format
				OleDbgOut("SvrDoc_PStg_InitNew: INVALID TreatAs Format\r\n");
				OleStdFreeString(lpszType, NULL);
			}
		}
#endif  // SVR_TREATAS
	}
#endif  // OLE_SVR
#if defined( OLE_CNTR )
	{
		// Load ContainerDoc specific data
		LPCONTAINERDOC lpContainerDoc = (LPCONTAINERDOC)lpOutlineDoc;

		lpContainerDoc->m_nNextObjNo = (ULONG)docRecord.m_reserved2;
	}
#endif  // OLE_CNTR

	OutlineDoc_SetRedraw ( lpOutlineDoc, FALSE );

	if(! LineList_LoadFromStg(&lpOutlineDoc->m_LineList, lpSrcStg, lpLLStm))
		goto error;
	if(! OutlineNameTable_LoadFromStg(lpOutlineDoc->m_lpNameTable, lpSrcStg))
		goto error;

	OutlineDoc_SetModified(lpOutlineDoc, FALSE, FALSE, FALSE);
	OutlineDoc_SetSel(lpOutlineDoc, &lrSel);

	OutlineDoc_SetRedraw ( lpOutlineDoc, TRUE );

	OleStdRelease((LPUNKNOWN)lpLLStm);

#if defined( OLE_CNTR )
	{
		LPOLEDOC lpOleDoc = (LPOLEDOC)lpOutlineDoc;

		/* A ContainerDoc keeps its storage open at all times. it is necessary
		*   to AddRef the lpSrcStg in order to hang on to it.
		*/
		if (lpOleDoc->m_lpStg) {
			OleStdVerifyRelease((LPUNKNOWN)lpOleDoc->m_lpStg,
					"Doc Storage not released properly");
		}
		lpSrcStg->lpVtbl->AddRef(lpSrcStg);
		lpOleDoc->m_lpStg = lpSrcStg;
	}
#endif      // OLE_CNTR

	return TRUE;

error:
	OutlineDoc_SetRedraw ( lpOutlineDoc, TRUE );
	if (lpLLStm)
		OleStdRelease((LPUNKNOWN)lpLLStm);
	return FALSE;
}

BOOL Booga(void)
{
    return FALSE;
}


/* OutlineDoc_SaveSelToStg
 * -----------------------
 *
 *      Save the specified selection of document into an IStorage*. All lines
 * within the selection along with any names completely contained within the
 * selection will be written
 *
 *      Return TRUE if ok, FALSE if error
 */
BOOL OutlineDoc_SaveSelToStg(
		LPOUTLINEDOC        lpOutlineDoc,
		LPLINERANGE         lplrSel,
		UINT                uFormat,
		LPSTORAGE           lpDestStg,
		BOOL                fSameAsLoad,
		BOOL                fRemember
)
{
	LPOUTLINEAPP lpOutlineApp = (LPOUTLINEAPP)g_lpApp;
	HRESULT hrErr = NOERROR;
	LPSTREAM lpLLStm = NULL;
	LPSTREAM lpNTStm = NULL;
	ULONG nWritten;
	BOOL fStatus;
	OUTLINEDOCHEADER docRecord;
        OUTLINEDOCHEADER_ONDISK docRecordOnDisk;
	HCURSOR  hPrevCursor;

#if defined( OLE_VERSION )
	LPSTR lpszUserType;
	LPOLEDOC lpOleDoc = (LPOLEDOC)lpOutlineDoc;

	/*  OLE2NOTE: we must be sure to write the information required for
	**    OLE into our docfile. this includes user type
	**    name, data format, etc. Even for top "file-level" objects
	**    this information should be written to the file. Both
	**    containters and servers should write this information.
	*/

#if defined( OLE_SERVER ) && defined( SVR_TREATAS )
	LPSERVERDOC lpServerDoc = (LPSERVERDOC)lpOutlineDoc;

	/* OLE2NOTE: if the Server is emulating another class (ie.
	**    "TreatAs" aka. ActivateAs), it must write the same user type
	**    name and format that was was originally written into the
	**    storage rather than its own user type name.
	**
	**    SVROUTL and ISVROTL can emulate each other. they have the
	**    simplification that they both read/write the identical
	**    format. thus for these apps no actual conversion of the
	**    native bits is actually required.
	*/
	if (! IsEqualCLSID(&lpServerDoc->m_clsidTreatAs, &CLSID_NULL))
		lpszUserType = lpServerDoc->m_lpszTreatAsType;
	else
#endif  // OLE_SERVER && SVR_TREATAS

		lpszUserType = (LPSTR)FULLUSERTYPENAME;

	hrErr = WriteFmtUserTypeStgA(lpDestStg, (CLIPFORMAT) uFormat,
                                     lpszUserType);

	if(hrErr != NOERROR) goto error;

	if (fSameAsLoad) {
		/* OLE2NOTE: we are saving into to same storage that we were
		**    passed an load time. we deliberatly opened the streams we
		**    need (lpLLStm and lpNTStm) at load time, so that we can
		**    robustly save at save time in a low-memory situation.
		**    this is particulary important the embedded objects do NOT
		**    consume additional memory when
		**    IPersistStorage::Save(fSameAsLoad==TRUE) is called.
		*/
		LARGE_INTEGER libZero;
		ULARGE_INTEGER ulibZero;
		LISet32( libZero, 0 );
		LISet32( ulibZero, 0 );
		lpLLStm = lpOleDoc->m_lpLLStm;

		/*  because this is the fSameAsLoad==TRUE case, we will save
		**    into the streams that we hold open. we will AddRef the
		**    stream here so that the release below will NOT close the
		**    stream.
		*/
		lpLLStm->lpVtbl->AddRef(lpLLStm);

		// truncate the current stream and seek to beginning
		lpLLStm->lpVtbl->SetSize(lpLLStm, ulibZero);
		lpLLStm->lpVtbl->Seek(
				lpLLStm, libZero, STREAM_SEEK_SET, NULL);

		lpNTStm = lpOleDoc->m_lpNTStm;
		lpNTStm->lpVtbl->AddRef(lpNTStm);   // (see comment above)

		// truncate the current stream and seek to beginning
		lpNTStm->lpVtbl->SetSize(lpNTStm, ulibZero);
		lpNTStm->lpVtbl->Seek(
				lpNTStm, libZero, STREAM_SEEK_SET, NULL);
	} else
#endif  // OLE_VERSION
	{
		hrErr = CallIStorageCreateStreamA(
				lpDestStg,
				"LineList",
				STGM_WRITE | STGM_SHARE_EXCLUSIVE | STGM_CREATE,
				0,
				0,
				&lpLLStm
		);

		if (hrErr != NOERROR) {
			OleDbgAssertSz(hrErr==NOERROR,"Could not create LineList stream");
			OleDbgOutHResult("LineList CreateStream returned", hrErr);
			goto error;
		}

		hrErr = CallIStorageCreateStreamA(
				lpDestStg,
				"NameTable",
				STGM_WRITE | STGM_SHARE_EXCLUSIVE | STGM_CREATE,
				0,
				0,
				&lpNTStm
		);

		if (hrErr != NOERROR) {
			OleDbgAssertSz(hrErr==NOERROR,"Could not create NameTable stream");
			OleDbgOutHResult("NameTable CreateStream returned", hrErr);
			goto error;
		}
	}

	// this may take a while, put up hourglass cursor
	hPrevCursor = SetCursor(LoadCursor(NULL, IDC_WAIT));

	_fmemset((LPOUTLINEDOCHEADER)&docRecord,0,sizeof(OUTLINEDOCHEADER));
	GetClipboardFormatName(
			uFormat,
			docRecord.m_szFormatName,
			sizeof(docRecord.m_szFormatName)
	);
	OutlineApp_GetAppVersionNo(lpOutlineApp, docRecord.m_narrAppVersionNo);

	docRecord.m_fShowHeading = lpOutlineDoc->m_heading.m_fShow;

#if defined( OLE_SERVER )
	{
		// Store ServerDoc specific data
		LPSERVERDOC lpServerDoc = (LPSERVERDOC)lpOutlineDoc;

		docRecord.m_reserved1 = (DWORD)lpServerDoc->m_nNextRangeNo;
	}
#endif
#if defined( OLE_CNTR )
	{
		// Store ContainerDoc specific data
		LPCONTAINERDOC lpContainerDoc = (LPCONTAINERDOC)lpOutlineDoc;

		docRecord.m_reserved2 = (DWORD)lpContainerDoc->m_nNextObjNo;
	}
#endif

	/* write OutlineDoc header record */

        //  Transform docRecord into docRecordOnDisk
        //  Compilers should handle aligment correctly
        strcpy(docRecordOnDisk.m_szFormatName, docRecord.m_szFormatName);
        docRecordOnDisk.m_narrAppVersionNo[0] = (short) docRecord.m_narrAppVersionNo[0];
        docRecordOnDisk.m_narrAppVersionNo[1] = (short) docRecord.m_narrAppVersionNo[1];
        docRecordOnDisk.m_fShowHeading = (USHORT) docRecord.m_fShowHeading;
        docRecordOnDisk.m_reserved1 = docRecord.m_reserved1;
        docRecordOnDisk.m_reserved2 = docRecord.m_reserved2;
        docRecordOnDisk.m_reserved3 = docRecord.m_reserved3;
        docRecordOnDisk.m_reserved4 = docRecord.m_reserved4;

	hrErr = lpLLStm->lpVtbl->Write(
			lpLLStm,
			(LPVOID)&docRecordOnDisk,
			sizeof(docRecordOnDisk),
			&nWritten
		);

	if (hrErr != NOERROR) {
		OleDbgOutHResult("Write OutlineDoc header returned", hrErr);
		goto error;
    }

	// Save LineList
	/* OLE2NOTE: A ContainerDoc keeps its storage open at all times. It is
	**    necessary to pass the current open storage (lpOleDoc->m_lpStg)
	**    to the LineList_SaveSelToStg method so that currently written data
	**    for any embeddings is also saved to the new destination
	**    storage. The data required by a contained object is both the
	**    ContainerLine information and the associated sub-storage that is
	**    written directly by the embedded object.
	*/
	fStatus = LineList_SaveSelToStg(
		&lpOutlineDoc->m_LineList,
			lplrSel,
			uFormat,
#if defined( OLE_CNTR )
			lpOleDoc->m_lpStg,
#else
			NULL,
#endif
			lpDestStg,
			lpLLStm,
			fRemember
	);
	if (! fStatus) goto error;

	// Save associated NameTable
	fStatus = OutlineNameTable_SaveSelToStg(
			lpOutlineDoc->m_lpNameTable,
			lplrSel,
			uFormat,
			lpNTStm
	);

	if (! fStatus) goto error;

	OleStdRelease((LPUNKNOWN)lpLLStm);
	lpOutlineDoc->m_cfSaveFormat = uFormat;  // remember format used to save

	SetCursor(hPrevCursor);     // restore original cursor
	return TRUE;

error:
	if (lpLLStm)
		OleStdRelease((LPUNKNOWN)lpLLStm);

	SetCursor(hPrevCursor);     // restore original cursor
	return FALSE;
}


/* OutlineDoc_Print
 * ----------------
 *  Prints the contents of the list box in HIMETRIC mapping mode. Origin
 *  remains to be the upper left corner and the print proceeds down the
 *  page using a negative y-cordinate.
 *
 */
void OutlineDoc_Print(LPOUTLINEDOC lpOutlineDoc, HDC hDC)
{
	LPLINELIST lpLL = &lpOutlineDoc->m_LineList;
	LPOUTLINEAPP lpOutlineApp = (LPOUTLINEAPP)g_lpApp;
	WORD    nIndex;
	WORD    nTotal;
	int     dy;
	BOOL    fError = FALSE;
	LPLINE  lpLine;
	RECT    rcLine;
	RECT    rcPix;
	RECT    rcHim;
	RECT    rcWindowOld;
	RECT    rcViewportOld;
	HFONT   hOldFont;
	DOCINFO di;         /* Document information for StartDoc function */

	/* Get dimension of page */
	rcPix.left = 0;
	rcPix.top = 0;
	rcPix.right = GetDeviceCaps(hDC, HORZRES);
	rcPix.bottom = GetDeviceCaps(hDC, VERTRES);

	SetDCToDrawInHimetricRect(hDC, (LPRECT)&rcPix, (LPRECT)&rcHim,
			(LPRECT)&rcWindowOld, (LPRECT)&rcViewportOld);

	// Set the default font size, and font face name
	hOldFont = SelectObject(hDC, lpOutlineApp->m_hStdFont);

	/* Get the lines in document */
	nIndex     = 0;
	nTotal  = LineList_GetCount(lpLL);

	/* Create the Cancel dialog */
	// REVIEW: should load dialog title from string resource file
	hWndPDlg = CreateDialog (
			lpOutlineApp->m_hInst,
			"Print",
			lpOutlineApp->m_hWndApp,
			(DLGPROC)PrintDlgProc
	);

	if(!hWndPDlg)
		goto getout;

	/* Allow the app. to inform GDI of the abort function to call */
	if(SetAbortProc(hDC, (ABORTPROC)AbortProc) < 0) {
		fError = TRUE;
		goto getout3;
	}

	/* Disable the main application window */
	EnableWindow (lpOutlineApp->m_hWndApp, FALSE);

	// initialize the rectangle for the first line
	rcLine.left = rcHim.left;
	rcLine.bottom = rcHim.top;

	/* Initialize the document */
	fCancelPrint = FALSE;

	di.cbSize = sizeof(di);
	di.lpszDocName = lpOutlineDoc->m_lpszDocTitle;
	di.lpszOutput = NULL;

	if(StartDoc(hDC, (DOCINFO FAR*)&di) <= 0) {
		fError = TRUE;
		OleDbgOut2("StartDoc error\n");
		goto getout5;
	}

	if(StartPage(hDC) <= 0) {       // start first page
		fError = TRUE;
		OleDbgOut2("StartPage error\n");
		goto getout2;
	}

	/* While more lines print out the text */
	while(nIndex < nTotal) {
		lpLine = LineList_GetLine(lpLL, nIndex);
		if (! lpLine)
			continue;

		dy = Line_GetHeightInHimetric(lpLine);

		/* Reached end of page. Tell the device driver to eject a page */
		if(rcLine.bottom - dy < rcHim.bottom) {
			if (EndPage(hDC) < 0) {
				fError=TRUE;
				OleDbgOut2("EndPage error\n");
				goto getout2;
			}

			// NOTE: Reset the Mapping mode of DC
			SetDCToDrawInHimetricRect(hDC, (LPRECT)&rcPix, (LPRECT)&rcHim,
					(LPRECT)&rcWindowOld, (LPRECT)&rcViewportOld);

			// Set the default font size, and font face name
			SelectObject(hDC, lpOutlineApp->m_hStdFont);

			if (StartPage(hDC) <= 0) {
				fError=TRUE;
				OleDbgOut2("StartPage error\n");
				goto getout2;
			}

			rcLine.bottom = rcHim.top;
		}

		rcLine.top = rcLine.bottom;
		rcLine.bottom -= dy;
		rcLine.right = rcLine.left + Line_GetWidthInHimetric(lpLine);

		/* Print the line */
		Line_Draw(lpLine, hDC, &rcLine, NULL, FALSE /*fHighlight*/);

		OleDbgOut2("a line is drawn\n");

		/* Test and see if the Abort flag has been set. If yes, exit. */
		if (fCancelPrint)
			goto getout2;

		/* Move down the page */
		nIndex++;
	}

	{
		int nCode;

		/* Eject the last page. */
		if((nCode = EndPage(hDC)) < 0) {
#if defined( _DEBUG )
			char szBuf[255];
			wsprintf(szBuf, "EndPage error code is %d\n", nCode);
			OleDbgOut2(szBuf);
#endif
			fError=TRUE;
			goto getout2;
		}
	}


	/* Complete the document. */
	if(EndDoc(hDC) < 0) {
		fError=TRUE;
		OleDbgOut2("EndDoc error\n");

getout2:
		/* Ran into a problem before NEWFRAME? Abort the document */
		AbortDoc(hDC);
	}

getout5:
	/* Re-enable main app. window */
	EnableWindow (lpOutlineApp->m_hWndApp, TRUE);

getout3:
	/* Close the cancel dialog */
	DestroyWindow (hWndPDlg);

getout:

	/* Error? make sure the user knows... */
	if(fError || CommDlgExtendedError())
		OutlineApp_ErrorMessage(lpOutlineApp, ErrMsgPrint);

	SelectObject(hDC, hOldFont);
}





/* OutlineDoc_DialogHelp
 * ---------------------
 *
 *  Show help message for ole2ui dialogs.
 *
 * Parameters:
 *
 *   hDlg      HWND to the dialog the help message came from - use
 *             this in the call to WinHelp/MessageBox so that
 *             activation/focus goes back to the dialog, and not the
 *             main window.
 *
 *   wParam    ID of the dialog (so we know what type of dialog it is).
 */
void OutlineDoc_DialogHelp(HWND hDlg, WPARAM wDlgID)
{

   char szMessageBoxText[64];

   if (!IsWindow(hDlg))  // don't do anything if we've got a bogus hDlg.
	 return;

   lstrcpy(szMessageBoxText, "Help Message for ");

   switch (wDlgID)
   {

	case IDD_CONVERT:
	   lstrcat(szMessageBoxText, "Convert");
	   break;

	case IDD_CHANGEICON:
	   lstrcat(szMessageBoxText, "Change Icon");
	   break;

	case IDD_INSERTOBJECT:
	   lstrcat(szMessageBoxText, "Insert Object");
	   break;

	case IDD_PASTESPECIAL:
	   lstrcat(szMessageBoxText, "Paste Special");
	   break;

	case IDD_EDITLINKS:
	   lstrcat(szMessageBoxText, "Edit Links");
	   break;

	case IDD_CHANGESOURCE:
	   lstrcat(szMessageBoxText, "Change Source");
	   break;

	case IDD_INSERTFILEBROWSE:
	   lstrcat(szMessageBoxText, "Insert From File Browse");
	   break;

	case IDD_CHANGEICONBROWSE:
	   lstrcat(szMessageBoxText, "Change Icon Browse");
	   break;

	default:
	   lstrcat(szMessageBoxText, "Unknown");
	   break;
	}

	lstrcat(szMessageBoxText, " Dialog.");

	// You'd probably really a call to WinHelp here.
	MessageBox(hDlg, szMessageBoxText, "Help", MB_OK);

	return;
}


/* OutlineDoc_SetCurrentZoomCommand
 * --------------------------------
 *
 *  Set current zoom level to be checked in the menu.
 *  Set the corresponding scalefactor for the document.
 */
void OutlineDoc_SetCurrentZoomCommand(
		LPOUTLINEDOC        lpOutlineDoc,
		UINT                uCurrentZoom
)
{
	SCALEFACTOR scale;

	if (!lpOutlineDoc)
		return;

	lpOutlineDoc->m_uCurrentZoom = uCurrentZoom;

	switch (uCurrentZoom) {

#if !defined( OLE_CNTR )
			case IDM_V_ZOOM_400:
				scale.dwSxN = (DWORD) 4;
				scale.dwSxD = (DWORD) 1;
				scale.dwSyN = (DWORD) 4;
				scale.dwSyD = (DWORD) 1;
				break;

			case IDM_V_ZOOM_300:
				scale.dwSxN = (DWORD) 3;
				scale.dwSxD = (DWORD) 1;
				scale.dwSyN = (DWORD) 3;
				scale.dwSyD = (DWORD) 1;
				break;

			case IDM_V_ZOOM_200:
				scale.dwSxN = (DWORD) 2;
				scale.dwSxD = (DWORD) 1;
				scale.dwSyN = (DWORD) 2;
				scale.dwSyD = (DWORD) 1;
				break;
#endif      // !OLE_CNTR

			case IDM_V_ZOOM_100:
				scale.dwSxN = (DWORD) 1;
				scale.dwSxD = (DWORD) 1;
				scale.dwSyN = (DWORD) 1;
				scale.dwSyD = (DWORD) 1;
				break;

			case IDM_V_ZOOM_75:
				scale.dwSxN = (DWORD) 3;
				scale.dwSxD = (DWORD) 4;
				scale.dwSyN = (DWORD) 3;
				scale.dwSyD = (DWORD) 4;
				break;

			case IDM_V_ZOOM_50:
				scale.dwSxN = (DWORD) 1;
				scale.dwSxD = (DWORD) 2;
				scale.dwSyN = (DWORD) 1;
				scale.dwSyD = (DWORD) 2;
				break;

			case IDM_V_ZOOM_25:
				scale.dwSxN = (DWORD) 1;
				scale.dwSxD = (DWORD) 4;
				scale.dwSyN = (DWORD) 1;
				scale.dwSyD = (DWORD) 4;
				break;
	}

	OutlineDoc_SetScaleFactor(lpOutlineDoc, (LPSCALEFACTOR)&scale, NULL);
}


/* OutlineDoc_GetCurrentZoomMenuCheck
 * ----------------------------------
 *
 *  Get current zoom level to be checked in the menu.
 */
UINT OutlineDoc_GetCurrentZoomMenuCheck(LPOUTLINEDOC lpOutlineDoc)
{
	return lpOutlineDoc->m_uCurrentZoom;
}


/* OutlineDoc_SetScaleFactor
 * -------------------------
 *
 *  Set the scale factor of the document which will affect the
 *      size of the document on the screen
 *
 * Parameters:
 *
 *   scale      structure containing x and y scales
 */
void OutlineDoc_SetScaleFactor(
		LPOUTLINEDOC        lpOutlineDoc,
		LPSCALEFACTOR       lpscale,
		LPRECT              lprcDoc
)
{
	LPLINELIST      lpLL = OutlineDoc_GetLineList(lpOutlineDoc);
	HWND            hWndLL = LineList_GetWindow(lpLL);

	if (!lpOutlineDoc || !lpscale)
		return;

	InvalidateRect(hWndLL, NULL, TRUE);

	lpOutlineDoc->m_scale = *lpscale;
	LineList_ReScale((LPLINELIST)&lpOutlineDoc->m_LineList, lpscale);

#if defined( USE_HEADING )
	Heading_ReScale((LPHEADING)&lpOutlineDoc->m_heading, lpscale);
#endif

	OutlineDoc_Resize(lpOutlineDoc, lprcDoc);
}


/* OutlineDoc_GetScaleFactor
 * -------------------------
 *
 *  Retrieve the scale factor of the document
 *
 * Parameters:
 *
 */
LPSCALEFACTOR OutlineDoc_GetScaleFactor(LPOUTLINEDOC lpOutlineDoc)
{
	if (!lpOutlineDoc)
		return NULL;

	return (LPSCALEFACTOR)&lpOutlineDoc->m_scale;
}


/* OutlineDoc_SetCurrentMarginCommand
 * ----------------------------------
 *
 *  Set current Margin level to be checked in the menu.
 */
void OutlineDoc_SetCurrentMarginCommand(
		LPOUTLINEDOC        lpOutlineDoc,
		UINT                uCurrentMargin
)
{
	if (!lpOutlineDoc)
		return;

	lpOutlineDoc->m_uCurrentMargin = uCurrentMargin;

	switch (uCurrentMargin) {
		case IDM_V_SETMARGIN_0:
			OutlineDoc_SetMargin(lpOutlineDoc, 0, 0);
			break;

		case IDM_V_SETMARGIN_1:
			OutlineDoc_SetMargin(lpOutlineDoc, 1000, 1000);
			break;

		case IDM_V_SETMARGIN_2:
			OutlineDoc_SetMargin(lpOutlineDoc, 2000, 2000);
			break;

		case IDM_V_SETMARGIN_3:
			OutlineDoc_SetMargin(lpOutlineDoc, 3000, 3000);
			break;

		case IDM_V_SETMARGIN_4:
			OutlineDoc_SetMargin(lpOutlineDoc, 4000, 4000);
			break;
	}
}


/* OutlineDoc_GetCurrentMarginMenuCheck
 * ------------------------------------
 *
 *  Get current Margin level to be checked in the menu.
 */
UINT OutlineDoc_GetCurrentMarginMenuCheck(LPOUTLINEDOC lpOutlineDoc)
{
	return lpOutlineDoc->m_uCurrentMargin;
}


/* OutlineDoc_SetMargin
 * --------------------
 *
 *  Set the left and right margin of the document
 *
 * Parameters:
 *      nLeftMargin  - left margin in Himetric values
 *      nRightMargin - right margin in Himetric values
 */
void OutlineDoc_SetMargin(LPOUTLINEDOC lpOutlineDoc, int nLeftMargin, int nRightMargin)
{
	LPLINELIST lpLL;
	int        nMaxWidthInHim;

	if (!lpOutlineDoc)
		return;

	lpOutlineDoc->m_nLeftMargin = nLeftMargin;
	lpOutlineDoc->m_nRightMargin = nRightMargin;
	lpLL = OutlineDoc_GetLineList(lpOutlineDoc);

	// Force recalculation of Horizontal extent
	nMaxWidthInHim = LineList_GetMaxLineWidthInHimetric(lpLL);
	LineList_SetMaxLineWidthInHimetric(lpLL, -nMaxWidthInHim);

#if defined( INPLACE_CNTR )
	ContainerDoc_UpdateInPlaceObjectRects((LPCONTAINERDOC)lpOutlineDoc, 0);
#endif

	OutlineDoc_ForceRedraw(lpOutlineDoc, TRUE);
}


/* OutlineDoc_GetMargin
 * --------------------
 *
 *  Get the left and right margin of the document
 *
 *  Parameters:
 *      nLeftMargin  - left margin in Himetric values
 *      nRightMargin - right margin in Himetric values
 *
 *  Returns:
 *      low order word  - left margin
 *      high order word - right margin
 */
LONG OutlineDoc_GetMargin(LPOUTLINEDOC lpOutlineDoc)
{
	if (!lpOutlineDoc)
		return 0;

	return MAKELONG(lpOutlineDoc->m_nLeftMargin, lpOutlineDoc->m_nRightMargin);
}

#if defined( USE_HEADING )

/* OutlineDoc_GetHeading
 * ---------------------
 *
 *      Get Heading Object in OutlineDoc
 */
LPHEADING OutlineDoc_GetHeading(LPOUTLINEDOC lpOutlineDoc)
{
	if (!lpOutlineDoc || lpOutlineDoc->m_fDataTransferDoc)
		return NULL;
	else
		return (LPHEADING)&lpOutlineDoc->m_heading;
}


/* OutlineDoc_ShowHeading
 * ----------------------
 *
 *  Show/Hide document row/column headings.
 */
void OutlineDoc_ShowHeading(LPOUTLINEDOC lpOutlineDoc, BOOL fShow)
{
	LPHEADING   lphead = OutlineDoc_GetHeading(lpOutlineDoc);
#if defined( INPLACE_SVR )
	LPSERVERDOC lpServerDoc = (LPSERVERDOC)lpOutlineDoc;
#endif

	if (! lphead)
		return;

	Heading_Show(lphead, fShow);

#if defined( INPLACE_SVR )
	if (lpServerDoc->m_fUIActive) {
		LPINPLACEDATA lpIPData = lpServerDoc->m_lpIPData;

		/* OLE2NOTE: our extents have NOT changed; only our the size of
		**    our object-frame adornments is changing. we can use the
		**    current PosRect and ClipRect and simply resize our
		**    windows WITHOUT informing our in-place container.
		*/
		ServerDoc_ResizeInPlaceWindow(
				lpServerDoc,
				(LPRECT)&(lpIPData->rcPosRect),
				(LPRECT)&(lpIPData->rcClipRect)
		);
	} else
#else   // !INPLACE_SVR

	OutlineDoc_Resize(lpOutlineDoc, NULL);

#if defined( INPLACE_CNTR )
	ContainerDoc_UpdateInPlaceObjectRects((LPCONTAINERDOC)lpOutlineDoc, 0);
#endif  // INPLACE_CNTR

#endif  // INPLACE_SVR

	OutlineDoc_ForceRedraw(lpOutlineDoc, TRUE);
}

#endif  // USE_HEADING


/* AbortProc
 * ---------
 *  AborProc is called by GDI print code to check for user abort.
 */
BOOL FAR PASCAL EXPORT AbortProc (HDC hdc, WORD reserved)
{
	MSG msg;

	/* Allow other apps to run, or get abort messages */
	while(! fCancelPrint && PeekMessage (&msg, NULL, 0, 0, PM_REMOVE)) {
		if(!hWndPDlg || !IsDialogMessage (hWndPDlg, &msg)) {
			TranslateMessage (&msg);
			DispatchMessage  (&msg);
		}
	}
	return !fCancelPrint;
}


/* PrintDlgProc
 * ------------
 *  Dialog function for the print cancel dialog box.
 *
 *  RETURNS    : TRUE  - OK to abort/ not OK to abort
 *               FALSE - otherwise.
 */
BOOL FAR PASCAL EXPORT PrintDlgProc(
		HWND hwnd,
		WORD msg,
		WORD wParam,
		LONG lParam
)
{
	switch (msg) {
		case WM_COMMAND:
		/* abort printing if the only button gets hit */
			fCancelPrint = TRUE;
			return TRUE;
	}

	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\letest\outline\outlname.c ===
/*************************************************************************
**
**    OLE 2 Sample Code
**
**    outlname.c
**
**    This file contains OutlineName functions.
**
**    (c) Copyright Microsoft Corp. 1992 - 1993 All Rights Reserved
**
*************************************************************************/


#include "outline.h"

OLEDBGDATA


/* OutlineName_SetName
 * -------------------
 *
 *      Change the string of a name.
 */
void OutlineName_SetName(LPOUTLINENAME lpOutlineName, LPSTR lpszName)
{
	lstrcpy(lpOutlineName->m_szName, lpszName);
}


/* OutlineName_SetSel
 * ------------------
 *
 *      Change the line range of a  name.
 */
void OutlineName_SetSel(LPOUTLINENAME lpOutlineName, LPLINERANGE lplrSel, BOOL fRangeModified)
{
#if defined( OLE_SERVER )
	// Call OLE server specific function instead
	ServerName_SetSel((LPSERVERNAME)lpOutlineName, lplrSel, fRangeModified);
#else

	lpOutlineName->m_nStartLine = lplrSel->m_nStartLine;
	lpOutlineName->m_nEndLine = lplrSel->m_nEndLine;
#endif
}


/* OutlineName_GetSel
 * ------------------
 *
 *      Retrieve the line range of a name.
 */
void OutlineName_GetSel(LPOUTLINENAME lpOutlineName, LPLINERANGE lplrSel)
{
	lplrSel->m_nStartLine = lpOutlineName->m_nStartLine;
	lplrSel->m_nEndLine = lpOutlineName->m_nEndLine;
}


/* OutlineName_SaveToStg
 * ---------------------
 *
 *      Save a name into a storage
 */
BOOL OutlineName_SaveToStg(LPOUTLINENAME lpOutlineName, LPLINERANGE lplrSel, UINT uFormat, LPSTREAM lpNTStm, BOOL FAR* lpfNameSaved)
{
	HRESULT hrErr = NOERROR;
	ULONG nWritten;

	*lpfNameSaved = FALSE;

	/* if no range given or if the name is completely within the range,
	**      write it out.
	*/
	if (!lplrSel ||
		((lplrSel->m_nStartLine <= lpOutlineName->m_nStartLine) &&
		(lplrSel->m_nEndLine >= lpOutlineName->m_nEndLine))) {

		hrErr = lpNTStm->lpVtbl->Write(
				lpNTStm,
				lpOutlineName,
				sizeof(OUTLINENAME),
				&nWritten
		);
		*lpfNameSaved = TRUE;
	}
	return ((hrErr == NOERROR) ? TRUE : FALSE);
}


/* OutlineName_LoadFromStg
 * -----------------------
 *
 *      Load names from an open stream of a storage. if the name already
 * exits in the OutlineNameTable, it is NOT modified.
 *
 *      Returns TRUE is all ok, else FALSE.
 */
BOOL OutlineName_LoadFromStg(LPOUTLINENAME lpOutlineName, LPSTREAM lpNTStm)
{
	HRESULT hrErr = NOERROR;
	ULONG nRead;

	hrErr = lpNTStm->lpVtbl->Read(
			lpNTStm,
			lpOutlineName,
			sizeof(OUTLINENAME),
			&nRead
	);

	return ((hrErr == NOERROR) ? TRUE : FALSE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\letest\outline\outlntbl.c ===
/*************************************************************************
**
**    OLE 2 Sample Code
**
**    outlntbl.c
**
**    This file contains OutlineNameTable functions.
**
**    (c) Copyright Microsoft Corp. 1992 - 1993 All Rights Reserved
**
*************************************************************************/


#include "outline.h"

OLEDBGDATA

extern LPOUTLINEAPP g_lpApp;

char ErrMsgNameTable[] = "Can't create NameTable!";


/* OutlineNameTable_Init
 * ---------------------
 *
 *      initialize a name table.
 */
BOOL OutlineNameTable_Init(LPOUTLINENAMETABLE lpOutlineNameTable, LPOUTLINEDOC lpOutlineDoc)
{
	HWND lpParent = OutlineDoc_GetWindow(lpOutlineDoc);

	lpOutlineNameTable->m_nCount = 0;

	/* We will use an OwnerDraw listbox as our data structure to
	**    maintain the table of Names. this listbox will never be made
	**    visible. the listbox is just a convenient data structure to
	**    manage a collection.
	*/
	lpOutlineNameTable->m_hWndListBox = CreateWindow(
					"listbox",              /* Window class name           */
					NULL,                   /* Window's title              */
					WS_CHILDWINDOW |
					LBS_OWNERDRAWFIXED,
					0, 0,                   /* Use default X, Y            */
					0, 0,                   /* Use default X, Y            */
					lpParent,               /* Parent window's handle      */
					(HMENU)IDC_NAMETABLE,   /* Child Window ID             */
					g_lpApp->m_hInst,       /* Instance of window          */
					NULL);                  /* Create struct for WM_CREATE */

	if (! lpOutlineNameTable->m_hWndListBox) {
		OutlineApp_ErrorMessage(g_lpApp, ErrMsgNameTable);
		return FALSE;
	}

	return TRUE;
}


/* OutlineNameTable_Destroy
 * ------------------------
 *
 *      Free memory used by the name table.
 */
void OutlineNameTable_Destroy(LPOUTLINENAMETABLE lpOutlineNameTable)
{
	// Delete all names
	OutlineNameTable_ClearAll(lpOutlineNameTable);

	DestroyWindow(lpOutlineNameTable->m_hWndListBox);
	Delete(lpOutlineNameTable);
}


/* OutlineNameTable_AddName
 * ------------------------
 *
 *      Add a name to the table
 */
void OutlineNameTable_AddName(LPOUTLINENAMETABLE lpOutlineNameTable, LPOUTLINENAME lpOutlineName)
{
	SendMessage(
			lpOutlineNameTable->m_hWndListBox,
			LB_ADDSTRING,
			0,
			(DWORD)lpOutlineName
	);
	lpOutlineNameTable->m_nCount++;
}


/* OutlineNameTable_DeleteName
 * ---------------------------
 *
 *      Delete a name from table
 */
void OutlineNameTable_DeleteName(LPOUTLINENAMETABLE lpOutlineNameTable,int nIndex)
{
	LPOUTLINENAME lpOutlineName = OutlineNameTable_GetName(lpOutlineNameTable, nIndex);

#if defined( OLE_SERVER )
	/* OLE2NOTE: if there is a pseudo object attached to this name, it
	**    must first be closed before deleting the Name. this will
	**    cause OnClose notification to be sent to all linking clients.
	*/
	ServerName_ClosePseudoObj((LPSERVERNAME)lpOutlineName);
#endif

	if (lpOutlineName)
		Delete(lpOutlineName);      // free memory for name

	SendMessage(
			lpOutlineNameTable->m_hWndListBox,
			LB_DELETESTRING,
			(WPARAM)nIndex,
			0L
	);
	lpOutlineNameTable->m_nCount--;
}


/* OutlineNameTable_GetNameIndex
 * -----------------------------
 *
 *      Return the index of the Name given a pointer to the Name.
 *      Return -1 if the Name is not found.
 */
int OutlineNameTable_GetNameIndex(LPOUTLINENAMETABLE lpOutlineNameTable, LPOUTLINENAME lpOutlineName)
{
	LRESULT lReturn;

	if (! lpOutlineName) return -1;

	lReturn = SendMessage(
			lpOutlineNameTable->m_hWndListBox,
			LB_FINDSTRING,
			(WPARAM)-1,
			(LPARAM)(LPCSTR)lpOutlineName
		);

	return ((lReturn == LB_ERR) ? -1 : (int)lReturn);
}


/* OutlineNameTable_GetName
 * ------------------------
 *
 *      Retrieve the pointer to the Name given its index in the NameTable
 */
LPOUTLINENAME OutlineNameTable_GetName(LPOUTLINENAMETABLE lpOutlineNameTable, int nIndex)
{
	LPOUTLINENAME lpOutlineName = NULL;
    LRESULT lResult;

	if (lpOutlineNameTable->m_nCount == 0 ||
		nIndex > lpOutlineNameTable->m_nCount ||
		nIndex < 0) {
		return NULL;
	}

	lResult = SendMessage(
			lpOutlineNameTable->m_hWndListBox,
			LB_GETTEXT,
			nIndex,
			(LPARAM)(LPCSTR)&lpOutlineName
	);
    OleDbgAssert(lResult != LB_ERR);
	return lpOutlineName;
}


/* OutlineNameTable_FindName
 * -------------------------
 *
 *      Find a name in the name table given a string.
 */
LPOUTLINENAME OutlineNameTable_FindName(LPOUTLINENAMETABLE lpOutlineNameTable, LPSTR lpszName)
{
	LPOUTLINENAME lpOutlineName;
	BOOL fFound = FALSE;
	int i;

	for (i = 0; i < lpOutlineNameTable->m_nCount; i++) {
		lpOutlineName = OutlineNameTable_GetName(lpOutlineNameTable, i);
		if (lstrcmp(lpOutlineName->m_szName, lpszName) == 0) {
			fFound = TRUE;
			break;      // FOUND MATCH!
		}
	}

	return (fFound ? lpOutlineName : NULL);
}


/* OutlineNameTable_FindNamedRange
 * -------------------------------
 *
 *      Find a name in the name table which matches a given line range.
 */
LPOUTLINENAME OutlineNameTable_FindNamedRange(LPOUTLINENAMETABLE lpOutlineNameTable, LPLINERANGE lplrSel)
{
	LPOUTLINENAME lpOutlineName;
	BOOL fFound = FALSE;
	int i;

	for (i = 0; i < lpOutlineNameTable->m_nCount; i++) {
		lpOutlineName = OutlineNameTable_GetName(lpOutlineNameTable, i);
		if ((lpOutlineName->m_nStartLine == lplrSel->m_nStartLine) &&
			(lpOutlineName->m_nEndLine == lplrSel->m_nEndLine) ) {
			fFound = TRUE;
			break;      // FOUND MATCH!
		}
	}

	return (fFound ? lpOutlineName : NULL);
}


/* OutlineNameTable_GetCount
 * -------------------------
 *
 * Return number of names in nametable
 */
int OutlineNameTable_GetCount(LPOUTLINENAMETABLE lpOutlineNameTable)
{
	if (!lpOutlineNameTable)
		return 0;

	return lpOutlineNameTable->m_nCount;
}


/* OutlineNameTable_ClearAll
 * -------------------------
 *
 *      Remove all names from table
 */
void OutlineNameTable_ClearAll(LPOUTLINENAMETABLE lpOutlineNameTable)
{
	LPOUTLINENAME lpOutlineName;
	int i;
	int nCount = lpOutlineNameTable->m_nCount;

	for (i = 0; i < nCount; i++) {
		lpOutlineName = OutlineNameTable_GetName(lpOutlineNameTable, i);
		Delete(lpOutlineName);      // free memory for name
	}

	lpOutlineNameTable->m_nCount = 0;
	SendMessage(lpOutlineNameTable->m_hWndListBox,LB_RESETCONTENT,0,0L);
}


/* OutlineNameTable_AddLineUpdate
 * ------------------------------
 *
 *      Update table when a new line is added at nAddIndex
 * The line used to be at nAddIndex is pushed down
 */
void OutlineNameTable_AddLineUpdate(LPOUTLINENAMETABLE lpOutlineNameTable, int nAddIndex)
{
	LPOUTLINENAME lpOutlineName;
	LINERANGE lrSel;
	int i;
	BOOL fRangeModified = FALSE;

	for(i = 0; i < lpOutlineNameTable->m_nCount; i++) {
		lpOutlineName=OutlineNameTable_GetName(lpOutlineNameTable, i);
		OutlineName_GetSel(lpOutlineName, &lrSel);

		if((int)lrSel.m_nStartLine > nAddIndex) {
			lrSel.m_nStartLine++;
			fRangeModified = !fRangeModified;
		}
		if((int)lrSel.m_nEndLine > nAddIndex) {
			lrSel.m_nEndLine++;
			fRangeModified = !fRangeModified;
		}

		OutlineName_SetSel(lpOutlineName, &lrSel, fRangeModified);
	}
}


/* OutlineNameTable_DeleteLineUpdate
 * ---------------------------------
 *
 *      Update the table when a line at nDeleteIndex is removed
 */
void OutlineNameTable_DeleteLineUpdate(LPOUTLINENAMETABLE lpOutlineNameTable, int nDeleteIndex)
{
	LPOUTLINENAME lpOutlineName;
	LINERANGE lrSel;
	int i;
	BOOL fRangeModified = FALSE;

	for(i = 0; i < lpOutlineNameTable->m_nCount; i++) {
		lpOutlineName=OutlineNameTable_GetName(lpOutlineNameTable, i);
		OutlineName_GetSel(lpOutlineName, &lrSel);

		if((int)lrSel.m_nStartLine > nDeleteIndex) {
			lrSel.m_nStartLine--;
			fRangeModified = !fRangeModified;
		}
		if((int)lrSel.m_nEndLine >= nDeleteIndex) {
			lrSel.m_nEndLine--;
			fRangeModified = !fRangeModified;
		}

		// delete the name if its entire range is deleted
		if(lrSel.m_nStartLine > lrSel.m_nEndLine) {
			OutlineNameTable_DeleteName(lpOutlineNameTable, i);
			i--;  // re-examine this name
		} else {
			OutlineName_SetSel(lpOutlineName, &lrSel, fRangeModified);
		}
	}
}


/* OutlineNameTable_SaveSelToStg
 * -----------------------------
 *
 *      Save only the names that refer to lines completely contained in the
 * specified selection range.
 */
BOOL OutlineNameTable_SaveSelToStg(
		LPOUTLINENAMETABLE      lpOutlineNameTable,
		LPLINERANGE             lplrSel,
		UINT                    uFormat,
		LPSTREAM                lpNTStm
)
{
	HRESULT hrErr;
	ULONG nWritten;
	LPOUTLINENAME lpOutlineName;
	short nNameCount = 0;
	BOOL fNameSaved;
	BOOL fStatus;
	int i;
	LARGE_INTEGER dlibZeroOffset;
	LISet32( dlibZeroOffset, 0 );

	/* initially write 0 for count of names. the correct count will be
	**    written at the end when we know how many names qualified to
	**    be written (within the selection).
	*/
	hrErr = lpNTStm->lpVtbl->Write(
			lpNTStm,
			(short FAR*)&nNameCount,
			sizeof(nNameCount),
			&nWritten
	);
	if (hrErr != NOERROR) {
		OleDbgOutHResult("Write NameTable header returned", hrErr);
		goto error;
    }

	for(i = 0; i < lpOutlineNameTable->m_nCount; i++) {
		lpOutlineName=OutlineNameTable_GetName(lpOutlineNameTable, i);
		fStatus = OutlineName_SaveToStg(
				lpOutlineName,
				lplrSel,
				uFormat,
				lpNTStm,
				(BOOL FAR*)&fNameSaved
		);
		if (! fStatus) goto error;
		if (fNameSaved) nNameCount++;
	}

	/* write the final count of names written. */
	hrErr = lpNTStm->lpVtbl->Seek(
			lpNTStm,
			dlibZeroOffset,
			STREAM_SEEK_SET,
			NULL
	);
	if (hrErr != NOERROR) {
		OleDbgOutHResult("Seek to NameTable header returned", hrErr);
		goto error;
    }

	hrErr = lpNTStm->lpVtbl->Write(
			lpNTStm,
			(short FAR*)&nNameCount,
			sizeof(nNameCount),
			&nWritten
	);
	if (hrErr != NOERROR) {
		OleDbgOutHResult("Write NameTable count in header returned", hrErr);
		goto error;
    }

	OleStdRelease((LPUNKNOWN)lpNTStm);
	return TRUE;

error:
	if (lpNTStm)
		OleStdRelease((LPUNKNOWN)lpNTStm);

	return FALSE;
}


/* OutlineNameTable_LoadFromStg
 * ----------------------------
 *
 *      Load Name Table from file
 *
 *      Return TRUE if ok, FALSE if error
 */
BOOL OutlineNameTable_LoadFromStg(LPOUTLINENAMETABLE lpOutlineNameTable, LPSTORAGE lpSrcStg)
{
	LPOUTLINEAPP lpOutlineApp = (LPOUTLINEAPP)g_lpApp;
	HRESULT hrErr;
	IStream FAR* lpNTStm;
	ULONG nRead;
	short nCount;
	LPOUTLINENAME lpOutlineName;
	BOOL fStatus;
	short i;

	hrErr = CallIStorageOpenStreamA(
			lpSrcStg,
			"NameTable",
			NULL,
			STGM_READ | STGM_SHARE_EXCLUSIVE,
			0,
			&lpNTStm
	);

	if (hrErr != NOERROR) {
		OleDbgOutHResult("OpenStream NameTable returned", hrErr);
		goto error;
    }

	hrErr = lpNTStm->lpVtbl->Read(lpNTStm,&nCount,sizeof(nCount),&nRead);
	if (hrErr != NOERROR) {
		OleDbgOutHResult("Read NameTable header returned", hrErr);
		goto error;
    }

	for (i = 0; i < nCount; i++) {
		lpOutlineName = OutlineApp_CreateName(lpOutlineApp);
		if (! lpOutlineName) goto error;
		fStatus = OutlineName_LoadFromStg(lpOutlineName, lpNTStm);
		if (! fStatus) goto error;
		OutlineNameTable_AddName(lpOutlineNameTable, lpOutlineName);
	}

	OleStdRelease((LPUNKNOWN)lpNTStm);
	return TRUE;

error:
	if (lpNTStm)
		OleStdRelease((LPUNKNOWN)lpNTStm);

	return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\letest\outline\precomp.c ===
/*************************************************************************
**
**    OLE 2.0 Sample Code
**
**    precomp.c
**
**    This file is used to precompile the OUTLINE.H header file
**
**    (c) Copyright Microsoft Corp. 1992 - 1993 All Rights Reserved
**
*************************************************************************/

#include "outline.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\letest\outline\outltxtl.c ===
/*************************************************************************
**
**    OLE 2 Sample Code
**
**    outltxtl.c
**
**    This file contains TextLine methods and related support functions.
**
**    (c) Copyright Microsoft Corp. 1992 - 1993 All Rights Reserved
**
*************************************************************************/


#include "outline.h"

OLEDBGDATA

extern LPOUTLINEAPP g_lpApp;


/* TextLine_Create
 * ---------------
 *
 *      Create a text line object and return the pointer
 */
LPTEXTLINE TextLine_Create(HDC hDC, UINT nTab, LPSTR lpszText)
{
	LPTEXTLINE lpTextLine;

	lpTextLine=(LPTEXTLINE) New((DWORD)sizeof(TEXTLINE));
	if (lpTextLine == NULL) {
		OleDbgAssertSz(lpTextLine!=NULL,"Error allocating TextLine");
		return NULL;
	}

	TextLine_Init(lpTextLine, nTab, hDC);

	if (lpszText) {
		lpTextLine->m_nLength = lstrlen(lpszText);
		lstrcpy((LPSTR)lpTextLine->m_szText, lpszText);
	} else {
		lpTextLine->m_nLength = 0;
		lpTextLine->m_szText[0] = '\0';
	}

	TextLine_CalcExtents(lpTextLine, hDC);

	return(lpTextLine);
}


/* TextLine_Init
 * -------------
 *
 *      Calculate the width/height of a text line object.
 */
void TextLine_Init(LPTEXTLINE lpTextLine, int nTab, HDC hDC)
{
	Line_Init((LPLINE)lpTextLine, nTab, hDC);   // init the base class fields

	((LPLINE)lpTextLine)->m_lineType = TEXTLINETYPE;
	lpTextLine->m_nLength = 0;
	lpTextLine->m_szText[0] = '\0';
}


/* TextLine_Delete
 * ---------------
 *
 *      Delete the TextLine structure
 */
void TextLine_Delete(LPTEXTLINE lpTextLine)
{
	Delete((LPVOID)lpTextLine);
}


/* TextLine_Edit
 * -------------
 *
 *      Edit the text line object.
 *
 *      Returns TRUE if line was changed
 *              FALSE if the line was NOT changed
 */
BOOL TextLine_Edit(LPTEXTLINE lpLine, HWND hWndDoc, HDC hDC)
{
#if defined( USE_FRAMETOOLS )
	LPFRAMETOOLS lptb = OutlineApp_GetFrameTools(g_lpApp);
#endif
	BOOL fStatus = FALSE;

#if defined( USE_FRAMETOOLS )
	FrameTools_FB_GetEditText(lptb, lpLine->m_szText, sizeof(lpLine->m_szText));
#else
	if (! InputTextDlg(hWndDoc, lpLine->m_szText, "Edit Line"))
		return FALSE;
#endif

	lpLine->m_nLength = lstrlen(lpLine->m_szText);
	TextLine_CalcExtents(lpLine, hDC);
	fStatus = TRUE;

	return fStatus;
}


/* TextLine_CalcExtents
 * --------------------
 *
 *      Calculate the width/height of a text line object.
 */
void TextLine_CalcExtents(LPTEXTLINE lpTextLine, HDC hDC)
{
	SIZE size;
	LPLINE lpLine = (LPLINE)lpTextLine;

	if (lpTextLine->m_nLength) {
		GetTextExtentPoint(hDC, lpTextLine->m_szText,
							lpTextLine->m_nLength, &size);
		lpLine->m_nWidthInHimetric=size.cx;
		lpLine->m_nHeightInHimetric=size.cy;
	} else {
		// we still need to calculate proper height even for NULL string
		TEXTMETRIC tm;
		GetTextMetrics(hDC, &tm);

		// required to set height
		lpLine->m_nHeightInHimetric = tm.tmHeight;
		lpLine->m_nWidthInHimetric = 0;
	}

#if defined( _DEBUG )
	{
		RECT rc;
		rc.left = 0;
		rc.top = 0;
		rc.right = XformWidthInHimetricToPixels(hDC,
				lpLine->m_nWidthInHimetric);
		rc.bottom = XformHeightInHimetricToPixels(hDC,
				lpLine->m_nHeightInHimetric);

		OleDbgOutRect3("TextLine_CalcExtents", (LPRECT)&rc);
	}
#endif
}



/* TextLine_SetHeightInHimetric
 * ----------------------------
 *
 *      Set the height of a textline object.
 */
void TextLine_SetHeightInHimetric(LPTEXTLINE lpTextLine, int nHeight)
{
	if (!lpTextLine)
		return;

	((LPLINE)lpTextLine)->m_nHeightInHimetric = nHeight;
}



/* TextLine_GetTextLen
 * -------------------
 *
 * Return length of string of the TextLine (not considering the tab level).
 */
int TextLine_GetTextLen(LPTEXTLINE lpTextLine)
{
	return lstrlen((LPSTR)lpTextLine->m_szText);
}


/* TextLine_GetTextData
 * --------------------
 *
 * Return the string of the TextLine (not considering the tab level).
 */
void TextLine_GetTextData(LPTEXTLINE lpTextLine, LPSTR lpszBuf)
{
	lstrcpy(lpszBuf, (LPSTR)lpTextLine->m_szText);
}


/* TextLine_GetOutlineData
 * -----------------------
 *
 * Return the CF_OUTLINE format data for the TextLine.
 */
BOOL TextLine_GetOutlineData(LPTEXTLINE lpTextLine, LPTEXTLINE lpBuf)
{
	TextLine_Copy((LPTEXTLINE)lpTextLine, lpBuf);
	return TRUE;
}


/* TextLine_Draw
 * -------------
 *
 *      Draw a text line object on a DC.
 * Parameters:
 *      hDC     - DC to which the line will be drawn
 *      lpRect  - the object rectangle in logical coordinates
 *      lpRectWBounds - bounding rect of the metafile underneath hDC
 *                      (NULL if hDC is not a metafile DC)
 *                      this is used by ContainerLine_Draw to draw the OLE obj
 *      fHighlight    - TRUE use selection highlight text color
 */
void TextLine_Draw(
		LPTEXTLINE  lpTextLine,
		HDC         hDC,
		LPRECT      lpRect,
		LPRECT      lpRectWBounds,
		BOOL        fHighlight
)
{
	RECT rc;
	int nBkMode;
	COLORREF clrefOld;

	if (!lpTextLine)
		return;

	rc = *lpRect;
	rc.left += ((LPLINE)lpTextLine)->m_nTabWidthInHimetric;
	rc.right += ((LPLINE)lpTextLine)->m_nTabWidthInHimetric;

	nBkMode = SetBkMode(hDC, TRANSPARENT);

	if (fHighlight) {
		/*Get proper txt colors */
		clrefOld = SetTextColor(hDC,GetSysColor(COLOR_HIGHLIGHTTEXT));
	}
	else {
		clrefOld = SetTextColor(hDC, GetSysColor(COLOR_WINDOWTEXT));
	}

	ExtTextOut(
			hDC,
			rc.left,
			rc.top,
			ETO_CLIPPED,
			(LPRECT)&rc,
			lpTextLine->m_szText,
			lpTextLine->m_nLength,
			(LPINT) NULL /* default char spacing */
	);

	SetTextColor(hDC, clrefOld);
	SetBkMode(hDC, nBkMode);
}

/* TextLine_DrawSelHilight
 * -----------------------
 *
 *      Handles selection of textline
 */
void TextLine_DrawSelHilight(LPTEXTLINE lpTextLine, HDC hDC, LPRECT lpRect, UINT itemAction, UINT itemState)
{
	if (itemAction & ODA_SELECT) {
		// check if there is a selection state change, ==> invert rect
		if (itemState & ODS_SELECTED) {
			if (!((LPLINE)lpTextLine)->m_fSelected) {
				((LPLINE)lpTextLine)->m_fSelected = TRUE;
				InvertRect(hDC, (LPRECT)lpRect);
			}
		} else {
			if (((LPLINE)lpTextLine)->m_fSelected) {
				((LPLINE)lpTextLine)->m_fSelected = FALSE;
				InvertRect(hDC, lpRect);
			}
		}
	} else if (itemAction & ODA_DRAWENTIRE) {
		((LPLINE)lpTextLine)->m_fSelected=((itemState & ODS_SELECTED) ? TRUE : FALSE);
		InvertRect(hDC, lpRect);
	}
}

/* TextLine_Copy
 * -------------
 *
 *      Duplicate a textline
 */
BOOL TextLine_Copy(LPTEXTLINE lpSrcLine, LPTEXTLINE lpDestLine)
{
	_fmemcpy(lpDestLine, lpSrcLine, sizeof(TEXTLINE));
	return TRUE;
}


/* TextLine_CopyToDoc
 * ------------------
 *
 *      Copy a textline to another Document (usually ClipboardDoc)
 */
BOOL TextLine_CopyToDoc(LPTEXTLINE lpSrcLine, LPOUTLINEDOC lpDestDoc, int nIndex)
{
	LPTEXTLINE  lpDestLine;
	BOOL        fStatus = FALSE;

	lpDestLine = (LPTEXTLINE) New((DWORD)sizeof(TEXTLINE));
	if (lpDestLine == NULL) {
		OleDbgAssertSz(lpDestLine!=NULL,"Error allocating TextLine");
		return FALSE;
	}

	if (TextLine_Copy(lpSrcLine, lpDestLine)) {
		OutlineDoc_AddLine(lpDestDoc, (LPLINE)lpDestLine, nIndex);
		fStatus = TRUE;
	}

	return fStatus;
}


/* TextLine_SaveToStg
 * ------------------
 *
 *      Save a textline into a storage
 *
 *      Return TRUE if successful, FALSE otherwise
 */
BOOL TextLine_SaveToStm(LPTEXTLINE lpTextLine, LPSTREAM lpLLStm)
{
	HRESULT hrErr;
	ULONG nWritten;
        USHORT nLengthOnDisk;

        nLengthOnDisk = (USHORT) lpTextLine->m_nLength;

	hrErr = lpLLStm->lpVtbl->Write(
			lpLLStm,
			(LPVOID)&nLengthOnDisk,
			sizeof(nLengthOnDisk),
			&nWritten
	);
	if (hrErr != NOERROR) {
		OleDbgOutHResult("Write TextLine data (1) returned", hrErr);
		return FALSE;
    }

	hrErr = lpLLStm->lpVtbl->Write(
			lpLLStm,
			(LPVOID)lpTextLine->m_szText,
			lpTextLine->m_nLength,
			&nWritten
	);
	if (hrErr != NOERROR) {
		OleDbgOutHResult("Write TextLine data (2) returned", hrErr);
		return FALSE;
    }

	return TRUE;
}


/* TextLine_LoadFromStg
 * --------------------
 *
 *      Load a textline from storage
 */
LPLINE TextLine_LoadFromStg(LPSTORAGE lpSrcStg, LPSTREAM lpLLStm, LPOUTLINEDOC lpDestDoc)
{
	HRESULT hrErr;
	ULONG nRead;
	LPTEXTLINE lpTextLine;
        USHORT nLengthOnDisk;

	lpTextLine=(LPTEXTLINE) New((DWORD)sizeof(TEXTLINE));
	if (lpTextLine == NULL) {
		OleDbgAssertSz(lpTextLine!=NULL,"Error allocating TextLine");
		return NULL;
	}

	TextLine_Init(lpTextLine, 0, NULL);

	hrErr = lpLLStm->lpVtbl->Read(
			lpLLStm,
			(LPVOID)&nLengthOnDisk,
                        sizeof(nLengthOnDisk),
			&nRead
        );
	if (hrErr != NOERROR) {
		OleDbgOutHResult("Read TextLine data (1) returned", hrErr);
		return NULL;
    }

        lpTextLine->m_nLength = (UINT) nLengthOnDisk;

	OleDbgAssert(lpTextLine->m_nLength < sizeof(lpTextLine->m_szText));

	hrErr = lpLLStm->lpVtbl->Read(
			lpLLStm,
			(LPVOID)&lpTextLine->m_szText,
			lpTextLine->m_nLength,
			&nRead
	);
	if (hrErr != NOERROR) {
		OleDbgOutHResult("Read TextLine data (1) returned", hrErr);
		return NULL;
    }

	lpTextLine->m_szText[lpTextLine->m_nLength] = '\0'; // add str terminator

	return (LPLINE)lpTextLine;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\letest\outline\outlrc.h ===
/*************************************************************************
**
**    OLE 2.0 Sample Code
**
**    outlrc.h
**
**    This file containes constants used in rc file for Outline.exe
**
**    (c) Copyright Microsoft Corp. 1992 - 1993 All Rights Reserved
**
*************************************************************************/

#if !defined( _OUTLRC_H_ )
#define _OUTLRC_H_

#ifndef RC_INVOKED
#pragma message ("INCLUDING OUTLRC.H from " __FILE__)
#endif  /* RC_INVOKED */

#if defined( OLE_SERVER ) && ! defined( INPLACE_SVR )
#define APPNAME                 "SvrOutl"
#define APPMENU                 "SvrOutlMenu"
#define APPACCEL                "SvrOutlAccel"
#define FB_EDIT_ACCEL           "SvrOutlAccelFocusEdit"
#define APPICON                 "SvrOutlIcon"
#define APPWNDCLASS             "SvrOutlApp"
#define DOCWNDCLASS             "SvrOutlDoc"
#define APPDESC                 "OLE 2.0 Server Sample Code"
#endif  // OLE_SERVER && ! INPLACE_SVR

#if defined( INPLACE_SVR )
#define APPNAME                 "ISvrOtl"
#define APPMENU                 "SvrOutlMenu"
#define APPACCEL                "SvrOutlAccel"
#define FB_EDIT_ACCEL           "SvrOutlAccelFocusEdit"
#define APPICON                 "SvrOutlIcon"
#define APPWNDCLASS             "SvrOutlApp"
#define DOCWNDCLASS             "SvrOutlDoc"
#define APPDESC                 "OLE 2.0 In-Place Server Sample Code"
#endif  // INPLACE_SVR

#if defined( OLE_CNTR ) && ! defined( INPLACE_CNTR )
#define APPNAME                 "CntrOutl"
#define APPMENU                 "CntrOutlMenu"
#define APPACCEL                "CntrOutlAccel"
#define FB_EDIT_ACCEL           "CntrOutlAccelFocusEdit"
#define APPICON                 "CntrOutlIcon"
#define APPWNDCLASS             "CntrOutlApp"
#define DOCWNDCLASS             "CntrOutlDoc"
#define APPDESC                 "OLE 2.0 Container Sample Code"
#endif  // OLE_CNTR && ! INPLACE_CNTR

#if defined( INPLACE_CNTR )
#define APPNAME                 "ICntrOtl"
#define APPMENU                 "CntrOutlMenu"
#define APPACCEL                "CntrOutlAccel"
#define FB_EDIT_ACCEL           "CntrOutlAccelFocusEdit"
#define APPICON                 "CntrOutlIcon"
#define APPWNDCLASS             "CntrOutlApp"
#define DOCWNDCLASS             "CntrOutlDoc"
#define APPDESC                 "OLE 2.0 In-Place Container Sample Code"
#endif  // INPLACE_CNTR

#if !defined( OLE_VERSION )
#define APPNAME                 "Outline"
#define APPMENU                 "OutlineMenu"
#define APPACCEL                "OutlineAccel"
#define FB_EDIT_ACCEL           "OutlineAccelFocusEdit"
#define APPICON                 "OutlineIcon"
#define APPWNDCLASS             "OutlineApp"
#define DOCWNDCLASS             "OutlineDoc"
#define APPDESC                 "OLE 2.0 Sample Code"
#endif  // OLE_VERSION

#define IDM_FILE                       1000
#define IDM_F_NEW                      1050
#define IDM_F_OPEN                     1100
#define IDM_F_SAVE                     1150
#define IDM_F_SAVEAS                   1200
#define IDM_F_PRINT                    1300
#define IDM_F_PRINTERSETUP             1350
#define IDM_F_EXIT                     1450
#define IDM_EDIT                       2000
#define IDM_E_UNDO                     2050
#define IDM_E_CUT                      2150
#define IDM_E_COPY                     2200
#define IDM_E_PASTE                    2250
#define IDM_E_PASTESPECIAL             2255
#define IDM_E_CLEAR                    2300
#define IDM_E_SELECTALL                2560
#define IDM_LINE                       3000
#define IDM_L_ADDLINE                  3400
#define IDM_L_EDITLINE                 3450
#define IDM_L_INDENTLINE               3500
#define IDM_L_UNINDENTLINE             3550
#define IDM_L_SETLINEHEIGHT            3560
#define IDM_NAME                       4000
#define IDM_N_DEFINENAME               4050
#define IDM_N_GOTONAME                 4100
#define IDM_HELP                       5000
#define IDM_H_ABOUT                    5050
#define IDM_DEBUG                      6000
#define IDM_D_DEBUGLEVEL               6050
#define IDM_D_INSTALLMSGFILTER         6060
#define IDM_D_REJECTINCOMING            6070
#define IDM_O_BB_TOP                   6100
#define IDM_O_BB_BOTTOM                6150
#define IDM_O_BB_POPUP                 6200
#define IDM_O_BB_HIDE                  6210
#define IDM_O_FB_TOP                   6250
#define IDM_O_FB_BOTTOM                6300
#define IDM_O_FB_POPUP                 6350
#define IDM_O_HEAD_SHOW                6400
#define IDM_O_HEAD_HIDE                6450
#define IDM_O_SHOWOBJECT               6460
#define IDM_V_ZOOM_400                 6500
#define IDM_V_ZOOM_300                 6510
#define IDM_V_ZOOM_200                 6520
#define IDM_V_ZOOM_100                 6550
#define IDM_V_ZOOM_75                  6600
#define IDM_V_ZOOM_50                  6650
#define IDM_V_ZOOM_25                  6700
#define IDM_V_SETMARGIN_0              6750
#define IDM_V_SETMARGIN_1              6800
#define IDM_V_SETMARGIN_2              6850
#define IDM_V_SETMARGIN_3              6860
#define IDM_V_SETMARGIN_4              6870
#define IDM_V_ADDTOP_1                 6900
#define IDM_V_ADDTOP_2                 6910
#define IDM_V_ADDTOP_3                 6920
#define IDM_V_ADDTOP_4                 6930


#define IDM_FB_EDIT                    7000
#define IDM_FB_CANCEL                  7005
#define IDM_F2                         7010
#define IDM_ESCAPE                     7015


#define IDD_LINELISTBOX                101
#define IDD_EDIT                       102
#define IDD_COMBO                      103
#define IDD_DELETE                     104
#define IDD_CLOSE                      105
#define IDD_APPTEXT                    106
#define IDD_FROM                       107
#define IDD_TO                         108
#define IDD_BITMAPLOCATION             109
#define IDD_CHECK                      110
#define IDD_TEXT                       111
#define IDD_LIMIT                      112


#define IDC_LINELIST                   201
#define IDC_NAMETABLE                  202


#define WM_U_INITFRAMETOOLS            WM_USER

#ifdef RC_INVOKED
#include "debug.rc"
#endif  /* RC_INVOKED */

#endif // _OUTLRC_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\letest\outline\status.h ===
/*************************************************************************
**
**    OLE 2.0 Sample Code
**
**    status.h
**
**    This file contains typedefs, defines, global variable declarations,
**    and function prototypes for the status bar window.
**
**    (c) Copyright Microsoft Corp. 1992 - 1993 All Rights Reserved
**
*************************************************************************/

// Sizes of statusbar items
#if defined( USE_STATUSBAR )
	#define STATUS_HEIGHT   23
#else
	#define STATUS_HEIGHT   0
#endif
#define STATUS_RLEFT    8
#define STATUS_RRIGHT   400
#define STATUS_RTOP     3
#define STATUS_RBOTTOM  20
#define STATUS_TTOP     4
#define STATUS_TLEFT    11
#define STATUS_THEIGHT  18


typedef enum {
	STATUS_READY,
	STATUS_BLANK
} STATCONTROL;

// Window for status bar.
extern HWND hwndStatusbar;

BOOL RegisterStatusClass(HINSTANCE hInstance);
HWND CreateStatusWindow(HWND hWndApp, HINSTANCE hInst);
void DestroyStatusWindow(HWND hWndStatusBar);

void AssignPopupMessage(HMENU hmenuPopup, char *szMessage);

void SetStatusText(HWND hWndStatusBar, LPSTR lpszMessage);
void GetItemMessage(UINT wIDItem, LPSTR FAR* lplpszMessage);
void GetPopupMessage(HMENU hmenuPopup, LPSTR FAR* lplpszMessage);
void GetSysMenuMessage(UINT wIDItem, LPSTR FAR* lplpszMessage);
void GetControlMessage(STATCONTROL scCommand, LPSTR FAR* lplpszMessage);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\letest\outline\svrinpl.c ===
/*************************************************************************
**
**    OLE 2 Server Sample Code
**
**    svrinpl.c
**
**    This file contains all interfaces, methods and related support
**    functions for an In-Place Object (Server) application (aka. Visual
**    Editing). The in-place Object application includes the following
**    implementation objects:
**
**    ServerDoc Object
**      exposed interfaces:
**          IOleInPlaceObject
**          IOleInPlaceActiveObject
**
**    ServerApp Object
**      exposed interfaces:
**          IUnknown
**
**    (c) Copyright Microsoft Corp. 1992 - 1993 All Rights Reserved
**
*************************************************************************/


#include "outline.h"

OLEDBGDATA

extern LPOUTLINEAPP             g_lpApp;


/* OLE2NOTE: the object should compose a string that is used by
**    in-place containers to be used for the window titles. this string
**    is passed to the container application via
**    IOleInPlaceUIWindow::SetActiveObject. the string should have the
**    following form:
**          <application name> - <object short type name>
**    SDI containers can use the string directly to display in the
**    frame window title. the container would concatenate the string
**    " in <container doc name>".
**    an MDI container with the MDI child window maximized can do the
**    same as the SDI container. an MDI container with the MDI child
**    windows NOT maximized can look for the " - " in the string from
**    the object. the first part of the string (app name) would be put
**    as the frame window title; the second part would be composed with
**    " in <container doc name>" and used as the MDI child window
**    title.
*/

// REVIEW: should use string resource for messages
char g_szIPObjectTitle[] = APPNAME " - " SHORTUSERTYPENAME;

extern RECT g_rectNull;



/*************************************************************************
** ServerDoc::IOleInPlaceObject interface implementation
*************************************************************************/

// IOleInPlaceObject::QueryInterface method

STDMETHODIMP SvrDoc_IPObj_QueryInterface(
		LPOLEINPLACEOBJECT  lpThis,
		REFIID              riid,
		LPVOID FAR *        lplpvObj
)
{
	LPSERVERDOC lpServerDoc =
			((struct CDocOleObjectImpl FAR*)lpThis)->lpServerDoc;

	return OleDoc_QueryInterface((LPOLEDOC)lpServerDoc, riid, lplpvObj);
}


// IOleInPlaceObject::AddRef method

STDMETHODIMP_(ULONG) SvrDoc_IPObj_AddRef(LPOLEINPLACEOBJECT lpThis)
{
	LPSERVERDOC lpServerDoc =
			((struct CDocOleObjectImpl FAR*)lpThis)->lpServerDoc;

	OleDbgAddRefMethod(lpThis, "IOleInPlaceObject");

	return OleDoc_AddRef((LPOLEDOC)lpServerDoc);
}


// IOleInPlaceObject::Release method

STDMETHODIMP_(ULONG) SvrDoc_IPObj_Release(LPOLEINPLACEOBJECT lpThis)
{
	LPSERVERDOC lpServerDoc =
			((struct CDocOleObjectImpl FAR*)lpThis)->lpServerDoc;

	OleDbgReleaseMethod(lpThis, "IOleInPlaceObject");

	return OleDoc_Release((LPOLEDOC)lpServerDoc);
}


// IOleInPlaceObject::GetWindow method

STDMETHODIMP SvrDoc_IPObj_GetWindow(
		LPOLEINPLACEOBJECT  lpThis,
		HWND FAR*           lphwnd
)
{
	LPSERVERDOC lpServerDoc =
			((struct CDocOleObjectImpl FAR*)lpThis)->lpServerDoc;

	OLEDBG_BEGIN2("SvrDoc_IPObj_GetWindow\r\n")

	*lphwnd = ((LPOUTLINEDOC)lpServerDoc)->m_hWndDoc;

	OLEDBG_END2
	return S_OK;
}


// IOleInPlaceObject::ContextSensitiveHelp method

STDMETHODIMP SvrDoc_IPObj_ContextSensitiveHelp(
		LPOLEINPLACEOBJECT  lpThis,
		BOOL                fEnable
)
{
	LPOLEDOC lpOleDoc =
			(LPOLEDOC)((struct CDocOleObjectImpl FAR*)lpThis)->lpServerDoc;
	OleDbgOut2("SvrDoc_IPObj_ContextSensitiveHelp\r\n");

	/* OLE2NOTE: see context sensitive help technote (CSHELP.DOC).
	**    This method is called when SHIFT-F1 context sensitive help is
	**    entered. the cursor should then change to a question mark
	**    cursor and the app should enter a modal state where the next
	**    mouse click does not perform its normal action but rather
	**    gives help corresponding to the location clicked. if the app
	**    does not implement a help system, it should at least eat the
	**    click and do nothing.
	*/
	lpOleDoc->m_fCSHelpMode = fEnable;

	return S_OK;
}


// IOleInPlaceObject::InPlaceDeactivate method

STDMETHODIMP SvrDoc_IPObj_InPlaceDeactivate(LPOLEINPLACEOBJECT lpThis)
{
	LPSERVERDOC lpServerDoc =
			((struct CDocOleObjectImpl FAR*)lpThis)->lpServerDoc;
	HRESULT hrErr;

	OLEDBG_BEGIN2("SvrDoc_IPObj_InPlaceDeactivate\r\n")

	hrErr = ServerDoc_DoInPlaceDeactivate(lpServerDoc);

	OLEDBG_END2
	return hrErr;
}


// IOleInPlaceObject::UIDeactivate method

STDMETHODIMP SvrDoc_IPObj_UIDeactivate(LPOLEINPLACEOBJECT lpThis)
{
	LPSERVERDOC     lpServerDoc =
						((struct CDocOleObjectImpl FAR*)lpThis)->lpServerDoc;
	LPSERVERAPP     lpServerApp = (LPSERVERAPP)g_lpApp;
	LPOUTLINEDOC    lpOutlineDoc = (LPOUTLINEDOC)lpServerDoc;
	LPINPLACEDATA   lpIPData = lpServerDoc->m_lpIPData;
	LPLINELIST      lpLL = (LPLINELIST)&((LPOUTLINEDOC)lpServerDoc)->m_LineList;
	HWND            hWndApp = OutlineApp_GetWindow(g_lpApp);

	OLEDBG_BEGIN2("SvrDoc_IPObj_UIDeactivate\r\n");

	if (!lpServerDoc->m_fUIActive) {
		OLEDBG_END2
		return NOERROR;
	}

	lpServerDoc->m_fUIActive = FALSE;

	// Clip the hatch window to the size of pos rect so, that the object
	// adornments and hatch border will not be visible.
	ServerDoc_ResizeInPlaceWindow(lpServerDoc,
			(LPRECT)&(lpServerDoc->m_lpIPData->rcPosRect),
			(LPRECT)&(lpServerDoc->m_lpIPData->rcPosRect)
	);

	if (lpIPData->lpDoc)
		lpIPData->lpDoc->lpVtbl->SetActiveObject(lpIPData->lpDoc, NULL, NULL);

	if (lpIPData->lpFrame) {
		lpIPData->lpFrame->lpVtbl->SetActiveObject(
			lpIPData->lpFrame,
			NULL,
			NULL
		);
	}

#if defined( USE_FRAMETOOLS )
	/* OLE2NOTE: we must hide our frame tools here but NOT call
	**    IOleInPlaceFrame::SetBorderSpace(NULL) or SetMenu(NULL).
	**    we must hide our tools BEFORE calling
	**    IOleInPlaceSite::OnUIDeactivate. the container will put
	**    his menus and tools back when OnUIDeactivate is called.
	*/
	ServerDoc_RemoveFrameLevelTools(lpServerDoc);
#endif

	OLEDBG_BEGIN2("IOleInPlaceSite::OnUIDeactivate called\r\n");
	lpIPData->lpSite->lpVtbl->OnUIDeactivate(lpIPData->lpSite, FALSE);
	OLEDBG_END2

	/* Reset to use our normal app's accelerator table */
	g_lpApp->m_hAccelApp = lpServerApp->m_hAccelBaseApp;
	g_lpApp->m_hAccel = lpServerApp->m_hAccelBaseApp;
	g_lpApp->m_hWndAccelTarget = hWndApp;

	OLEDBG_END2

#if !defined( SVR_INSIDEOUT )
	/* OLE2NOTE: an "outside-in" style in-place server would hide its
	**    window here. an "inside-out" style server leaves its window
	**    visible when it is UIDeactivated. it would only hide its
	**    window when InPlaceDeactivated. this app is an "inside-out"
	**    style server. it is recommended for most server to support
	**    inside-out behavior if possible.
	*/
	ServerDoc_DoInPlaceHide(lpServerDoc);
#endif // INSIEDOUT

	return NOERROR;
}


// IOleInPlaceObject::SetObjectRects method

STDMETHODIMP SvrDoc_IPObj_SetObjectRects(
		LPOLEINPLACEOBJECT  lpThis,
		LPCRECT             lprcPosRect,
		LPCRECT             lprcClipRect
)
{
	LPSERVERDOC  lpServerDoc =
					((struct CDocOleObjectImpl FAR*)lpThis)->lpServerDoc;
	LPINPLACEDATA lpIPData = lpServerDoc->m_lpIPData;
	LPLINELIST   lpLL = OutlineDoc_GetLineList((LPOUTLINEDOC)lpServerDoc);
	OLEDBG_BEGIN2("SvrDoc_IPObj_SetObjectRects\r\n")

#if defined( _DEBUG )
	OleDbgOutRect3("SvrDoc_IPObj_SetObjectRects (PosRect)",
			(LPRECT)lprcPosRect);
	OleDbgOutRect3("SvrDoc_IPObj_SetObjectRects (ClipRect)",
			(LPRECT)lprcClipRect);
#endif
	// save the current PosRect and ClipRect
	lpIPData->rcPosRect = *lprcPosRect;
	lpIPData->rcClipRect = *lprcClipRect;

	if (! lpServerDoc->m_fUIActive) // hatch and adornaments must not be drawn
		lprcClipRect = lprcPosRect;

	ServerDoc_ResizeInPlaceWindow(
			lpServerDoc, (LPRECT)lprcPosRect, (LPRECT)lprcClipRect);

	OLEDBG_END2
	return NOERROR;
}


// IOleInPlaceObject::ReactivateAndUndo method

STDMETHODIMP SvrDoc_IPObj_ReactivateAndUndo(LPOLEINPLACEOBJECT lpThis)
{
	OLEDBG_BEGIN2("SvrDoc_IPObj_ReactivateAndUndo\r\n")

	// We do not support support UNDO.

	/* REVIEW: for debugging purposes it would be useful to give a
	**    message box indicating that this method has been called.
	*/

	OLEDBG_END2
	return NOERROR;
}


/*************************************************************************
** ServerDoc::IOleInPlaceActiveObject interface implementation
*************************************************************************/

// IOleInPlaceActiveObject::QueryInterface method

STDMETHODIMP SvrDoc_IPActiveObj_QueryInterface(
		LPOLEINPLACEACTIVEOBJECT    lpThis,
		REFIID                      riid,
		LPVOID FAR *                lplpvObj
)
{
	SCODE sc = E_NOINTERFACE;
	LPSERVERDOC lpServerDoc =
			((struct CDocOleObjectImpl FAR*)lpThis)->lpServerDoc;

	/* The container should not be able to access the other interfaces
	** of our object by doing QI on this interface.
	*/

	*lplpvObj = NULL;
	if (IsEqualIID(riid, &IID_IUnknown) ||
		IsEqualIID(riid, &IID_IOleWindow) ||
		IsEqualIID(riid, &IID_IOleInPlaceActiveObject)) {
		OleDbgOut4("OleDoc_QueryInterface: IOleInPlaceActiveObject* RETURNED\r\n");

		*lplpvObj = lpThis;
		OleDoc_AddRef((LPOLEDOC)lpServerDoc);
		sc = NOERROR;
	}

	OleDbgQueryInterfaceMethod(*lplpvObj);

	return ResultFromScode(sc);
}


// IOleInPlaceActiveObject::AddRef method

STDMETHODIMP_(ULONG) SvrDoc_IPActiveObj_AddRef(
		LPOLEINPLACEACTIVEOBJECT lpThis
)
{
	LPSERVERDOC lpServerDoc =
			((struct CDocOleObjectImpl FAR*)lpThis)->lpServerDoc;

	OleDbgAddRefMethod(lpThis, "IOleInPlaceActiveObject");

	return OleDoc_AddRef((LPOLEDOC)lpServerDoc);
}


// IOleInPlaceActiveObject::Release method

STDMETHODIMP_(ULONG) SvrDoc_IPActiveObj_Release(
		LPOLEINPLACEACTIVEOBJECT lpThis
)
{
	LPSERVERDOC lpServerDoc =
			((struct CDocOleObjectImpl FAR*)lpThis)->lpServerDoc;

	OleDbgReleaseMethod(lpThis, "IOleInPlaceActiveObject");

	return OleDoc_Release((LPOLEDOC)lpServerDoc);
}


// IOleInPlaceActiveObject::GetWindow method

STDMETHODIMP SvrDoc_IPActiveObj_GetWindow(
		LPOLEINPLACEACTIVEOBJECT    lpThis,
		HWND FAR*                   lphwnd
)
{
	LPSERVERDOC lpServerDoc =
			((struct CDocOleObjectImpl FAR*)lpThis)->lpServerDoc;

	OLEDBG_BEGIN2("SvrDoc_IPActiveObj_GetWindow\r\n")

	*lphwnd = ((LPOUTLINEDOC)lpServerDoc)->m_hWndDoc;

	OLEDBG_END2
	return NOERROR;
}


// IOleInPlaceActiveObject::ContextSensitiveHelp method

STDMETHODIMP SvrDoc_IPActiveObj_ContextSensitiveHelp(
		LPOLEINPLACEACTIVEOBJECT    lpThis,
		BOOL                        fEnterMode
)
{
	LPSERVERDOC lpServerDoc =
			((struct CDocOleObjectImpl FAR*)lpThis)->lpServerDoc;
	OleDbgOut2("SvrDoc_IPActiveObj_ContextSensitiveHelp\r\n");

	/* OLE2NOTE: see context sensitive help technote (CSHELP.DOC)
	**    This method is called when F1 is pressed when a menu item is
	**    selected. this tells the in-place server application to give
	**    help rather than execute the next menu command. at a minimum,
	**    even if the in-place server application does not implement a
	**    help system, it should NOT execute the next command when
	**    fEnable==TRUE. We set the active object's m_fMenuMode flag here.
	**    later, in WM_COMMAND processing in the DocWndProc, if this
	**    flag is set then the command is NOT executed (and help could
	**    be given if we had a help system....but we don't.)
	*/
	lpServerDoc->m_fMenuHelpMode = fEnterMode;

#if !defined( HACK )
	((LPOLEDOC)lpServerDoc)->m_fCSHelpMode = fEnterMode;
#endif
	return NOERROR;
}


// IOleInPlaceActiveObject::TranslateAccelerator method

STDMETHODIMP SvrDoc_IPActiveObj_TranslateAccelerator(
		LPOLEINPLACEACTIVEOBJECT    lpThis,
		LPMSG                       lpmsg
)
{
	// This will never be called because this server is implemented as an EXE
	return NOERROR;
}


// IOleInPlaceActiveObject::OnFrameWindowActivate method

STDMETHODIMP SvrDoc_IPActiveObj_OnFrameWindowActivate(
		LPOLEINPLACEACTIVEOBJECT    lpThis,
		BOOL                        fActivate
)
{
	LPOUTLINEDOC lpOutlineDoc = (LPOUTLINEDOC)
			((struct CDocOleObjectImpl FAR*)lpThis)->lpServerDoc;
	HWND hWndDoc = OutlineDoc_GetWindow(lpOutlineDoc);
#if defined( _DEBUG )
	if (fActivate)
		OleDbgOut2("SvrDoc_IPActiveObj_OnFrameWindowActivate(TRUE)\r\n");
	else
		OleDbgOut2("SvrDoc_IPActiveObj_OnFrameWindowActivate(FALSE)\r\n");
#endif  // _DEBUG

	/* OLE2NOTE: this is a notification of the container application's
	**    WM_ACTIVATEAPP status. some applications may find this
	**    important. we need to update the enable/disable status of our
	**    tool bar buttons.
	*/

	// OLE2NOTE: We can't call OutlineDoc_UpdateFrameToolButtons
	//           right away which
	//           would generate some OLE calls and eventually
	//           WM_ACTIVATEAPP and a loop was formed. Therefore, we
	//           should delay the frame tool initialization until
	//           WM_ACTIVATEAPP is finished by posting a message
	//           to ourselves.

	/* Update enable/disable state of buttons in toolbar */
	if (fActivate)
		PostMessage(hWndDoc, WM_U_INITFRAMETOOLS, 0, 0L);

	return NOERROR;
}


// IOleInPlaceActiveObject::OnDocWindowActivate method

STDMETHODIMP SvrDoc_IPActiveObj_OnDocWindowActivate(
		LPOLEINPLACEACTIVEOBJECT    lpThis,
		BOOL                        fActivate
)
{
	LPSERVERDOC     lpServerDoc =
						((struct CDocOleObjectImpl FAR*)lpThis)->lpServerDoc;
	LPINPLACEDATA   lpIPData = lpServerDoc->m_lpIPData;
#if defined( _DEBUG )
	if (fActivate)
		OleDbgOut2("SvrDoc_IPActiveObj_OnDocWindowActivate(TRUE)\r\n");
	else
		OleDbgOut2("SvrDoc_IPActiveObj_OnDocWindowActivate(FALSE)\r\n");
#endif

	if (fActivate) {
		ServerDoc_AddFrameLevelUI(lpServerDoc);
	}
	else {
#if defined( USE_FRAMETOOLS )
		/* OLE2NOTE: we must NOT call IOleInPlaceFrame::SetBorderSpace(NULL)
		**    or SetMenu(NULL) here. we should simply hide our tools.
		*/
		ServerDoc_RemoveFrameLevelTools(lpServerDoc);
#endif
	}

	OLEDBG_END2
	return NOERROR;
}


// IOleInPlaceActiveObject::ResizeBorder method

STDMETHODIMP SvrDoc_IPActiveObj_ResizeBorder(
		LPOLEINPLACEACTIVEOBJECT    lpThis,
		LPCRECT                     lprectBorder,
		LPOLEINPLACEUIWINDOW        lpIPUiWnd,
		BOOL                        fFrameWindow
)
{
	LPSERVERDOC lpServerDoc =
					((struct CDocOleObjectImpl FAR*)lpThis)->lpServerDoc;
	LPOUTLINEDOC lpOutlineDoc = (LPOUTLINEDOC)lpServerDoc;

	OLEDBG_BEGIN2("SvrDoc_IPActiveObj_ResizeBorder\r\n")


#if defined( USE_FRAMETOOLS )

	if (fFrameWindow) {
		FrameTools_NegotiateForSpaceAndShow(
				lpOutlineDoc->m_lpFrameTools,
				(LPRECT)lprectBorder,
				(LPOLEINPLACEFRAME)lpIPUiWnd
		);
	}

#endif

	OLEDBG_END2
	return NOERROR;
}


// IOleInPlaceActiveObject::EnableModeless method

STDMETHODIMP SvrDoc_IPActiveObj_EnableModeless(
		LPOLEINPLACEACTIVEOBJECT    lpThis,
		BOOL                        fEnable
)
{
#if defined( USE_FRAMETOOLS )
	LPSERVERDOC lpServerDoc =
				((struct CDocOleObjectImpl FAR*)lpThis)->lpServerDoc;
	LPOUTLINEDOC lpOutlineDoc = (LPOUTLINEDOC)lpServerDoc;
	LPFRAMETOOLS lptb;

	/* OLE2NOTE: we must enable/disable mouse and keyboard input to our
	**    floating tool palette
	*/
	if (lpOutlineDoc) {
		lptb = lpOutlineDoc->m_lpFrameTools;
		if (lptb)
			FrameTools_EnableWindow(lptb, fEnable);
	}
#endif  // USE_FRAMETOOLS

#if defined( _DEBUG )
	if (fEnable)
		OleDbgOut2("SvrDoc_IPActiveObj_EnableModeless(TRUE)\r\n");
	else
		OleDbgOut2("SvrDoc_IPActiveObj_EnableModeless(FALSE)\r\n");
#endif  // _DEBUG

	/* OLE2NOTE: this method is called when the top-level, in-place
	**    container puts up a modal dialog. it tells the UIActive
	**    object to disable it modeless dialogs for the duration that
	**    the container is displaying a modal dialog.
	**
	**    ISVROTL does not use any modeless dialogs, thus we can
	**    ignore this method.
	*/
	return NOERROR;
}


/*************************************************************************
** Support Functions
*************************************************************************/


HRESULT ServerDoc_DoInPlaceActivate(
		LPSERVERDOC     lpServerDoc,
		LONG            lVerb,
		LPMSG           lpmsg,
		LPOLECLIENTSITE lpActiveSite
)
{
	LPOUTLINEAPP            lpOutlineApp = (LPOUTLINEAPP)g_lpApp;
	LPSERVERAPP             lpServerApp = (LPSERVERAPP)g_lpApp;
	LPOLEAPP                lpOleApp = (LPOLEAPP)g_lpApp;
	SCODE                   sc = E_FAIL;
	RECT                    rcPos;
	RECT                    rcClip;
	LPINPLACEDATA           lpIPData = lpServerDoc->m_lpIPData;
	LPOUTLINEDOC            lpOutlineDoc=(LPOUTLINEDOC)lpServerDoc;
	HWND                    hWndDoc = lpOutlineDoc->m_hWndDoc;
	HWND                    hWndHatch = lpServerDoc->m_hWndHatch;
	HRESULT                 hrErr;
	LPLINELIST              lpLL=(LPLINELIST)&lpOutlineDoc->m_LineList;
	LPOLEINPLACESITE    lpIPSite = NULL;

	/* OLE2NOTE: lpActiveSite should be used only for InPlace PLAYing.
	**    This app does not do inplace PLAYing, so it never uses
	**    lpActiveSite.
	*/

	/* InPlace activation can only be done if the ClientSite is non-NULL. */
	if (! lpServerDoc->m_lpOleClientSite)
		return NOERROR;

	if (! lpServerDoc->m_fInPlaceActive) {

		// if the object is in open mode then we do not want to do inplace
		// activation.
		if (IsWindowVisible(lpOutlineDoc->m_hWndDoc))
			return NOERROR;

		lpIPSite = (LPOLEINPLACESITE)OleStdQueryInterface(
				(LPUNKNOWN)lpServerDoc->m_lpOleClientSite,
				&IID_IOleInPlaceSite
		);

		if (! lpIPSite)
			goto errActivate;

		OLEDBG_BEGIN2("IOleInPlaceSite::CanInPlaceActivate called\r\n");
		hrErr = lpIPSite->lpVtbl->CanInPlaceActivate(lpIPSite);
		OLEDBG_END2
		if (hrErr != NOERROR)
			goto errActivate;

		lpServerDoc->m_fInPlaceActive = TRUE;
		OLEDBG_BEGIN2("IOleInPlaceSite::OnInPlaceActivate called\r\n");
		hrErr = lpIPSite->lpVtbl->OnInPlaceActivate(lpIPSite);
		OLEDBG_END2
		if (hrErr != NOERROR)
			goto errActivate;

		if (! ServerDoc_AllocInPlaceData(lpServerDoc)) {
			sc = E_OUTOFMEMORY;
			OLEDBG_BEGIN2("IOleInPlaceSite::OnInPlaceDeactivate called\r\n");
			lpIPSite->lpVtbl->OnInPlaceDeactivate(lpIPSite);
			OLEDBG_END2
			goto errActivate;
		}

		(lpIPData = lpServerDoc->m_lpIPData)->lpSite = lpIPSite;
		goto InPlaceActive;

	errActivate:
		lpServerDoc->m_fInPlaceActive = FALSE;
		if (lpIPSite)
			OleStdRelease((LPUNKNOWN)lpIPSite);
		return ResultFromScode(sc);
	}


InPlaceActive:

	if (! lpServerDoc->m_fInPlaceVisible) {
		lpServerDoc->m_fInPlaceVisible = TRUE;

		OLEDBG_BEGIN2("IOleInPlaceSite::GetWindow called\r\n");
		hrErr = lpIPData->lpSite->lpVtbl->GetWindow(
					lpIPData->lpSite, &lpServerDoc->m_hWndParent);
		OLEDBG_END2
		if (hrErr != NOERROR) {
			sc = GetScode(hrErr);
			goto errRtn;
		}

		if (! lpServerDoc->m_hWndParent)
			goto errRtn;

		/* OLE2NOTE: The server should fill in the "cb" field so that the
		**    container can tell what size structure the server is
		**    expecting. this enables this structure to be easily extended
		**    in future releases of OLE. the container should check this
		**    field so that it doesn't try to use fields that do not exist
		**    since the server may be using an old structure definition.
		*/
		_fmemset(
			(LPOLEINPLACEFRAMEINFO)&lpIPData->frameInfo,
			0,
			sizeof(OLEINPLACEFRAMEINFO)
		);
		lpIPData->frameInfo.cb = sizeof(OLEINPLACEFRAMEINFO);

		OLEDBG_BEGIN2("IOleInPlaceSite::GetWindowContext called\r\n");
		hrErr = lpIPData->lpSite->lpVtbl->GetWindowContext(lpIPData->lpSite,
					(LPOLEINPLACEFRAME FAR*) &lpIPData->lpFrame,
					(LPOLEINPLACEUIWINDOW FAR*)&lpIPData->lpDoc,
					(LPRECT)&rcPos,
					(LPRECT)&rcClip,
					(LPOLEINPLACEFRAMEINFO)&lpIPData->frameInfo);
		OLEDBG_END2

		if (hrErr != NOERROR) {
			sc = GetScode(hrErr);
			goto errRtn;
		}

		lpServerApp->m_lpIPData = lpIPData;
		ShowWindow(hWndDoc, SW_HIDE);   // make sure we are hidden

		/* OLE2NOTE: reparent in-place server document's window to the
		**    special in-place hatch border window. set the in-place site's
		**    window as the parent of the hatch window. position the
		**    in-place and hatch border windows using the PosRect and
		**    ClipRect.
		**    it is important to properly parent and position the in-place
		**    server window BEFORE calling IOleInPlaceFrame::SetMenu and
		**    SetBorderSpace.
		*/
		ShowWindow(lpServerDoc->m_hWndHatch, SW_SHOW);
		// make sure App busy/blocked dialogs are parented to our
		// new hWndFrame
		OleStdMsgFilter_SetParentWindow(
			lpOleApp->m_lpMsgFilter,lpIPData->frameInfo.hwndFrame);
		SetParent(lpServerDoc->m_hWndHatch, lpServerDoc->m_hWndParent);
		SetParent(hWndDoc, lpServerDoc->m_hWndHatch);

#if defined( _DEBUG )
		OleDbgOutRect3("IOleInPlaceSite::GetWindowContext (PosRect)",
				(LPRECT)&rcPos);
		OleDbgOutRect3("IOleInPlaceSite::GetWindowContext (ClipRect)",
				(LPRECT)&rcClip);
#endif
		// save the current PosRect and ClipRect
		lpIPData->rcPosRect  = rcPos;
		lpIPData->rcClipRect = rcClip;

		/* OLE2NOTE: build the shared menu for the in-place container and
		**    the server.
		*/
		if (ServerDoc_AssembleMenus (lpServerDoc) != NOERROR)
			goto errRtn;

#if defined( SVR_INSIDEOUT )
		if (lVerb == OLEIVERB_INPLACEACTIVATE) {
			// Clip the hatch window to the size of pos rect so, that
			// hatch and object adornments  will not be visible.
			ServerDoc_ResizeInPlaceWindow(lpServerDoc,
				(LPRECT)&(lpServerDoc->m_lpIPData->rcPosRect),
				(LPRECT)&(lpServerDoc->m_lpIPData->rcPosRect)
			);
		}
#endif  // SVR_INSIDEOUT
	}

#if defined( SVR_INSIDEOUT )
	// OLE2NOTE: if verb is OLEIVERB_INPLACEACTIVATE we do NOT want to
	// show our UI
	if (lVerb == OLEIVERB_INPLACEACTIVATE) {
		return NOERROR;
	}
#endif  // SVR_INSIDEOUT

	if (! lpServerDoc->m_fUIActive) {
		lpServerDoc->m_fUIActive = TRUE;
		OLEDBG_BEGIN2("IOleInPlaceSite::OnUIActivate called\r\n");
		hrErr = lpIPData->lpSite->lpVtbl->OnUIActivate(lpIPData->lpSite);
		OLEDBG_END2
		if (hrErr != NOERROR) {
			lpServerDoc->m_fUIActive = FALSE;
			goto errRtn;
		}

		SetFocus(hWndDoc);

		// Show the object adornments and hacth border around them.
		ServerDoc_ResizeInPlaceWindow(lpServerDoc,
					(LPRECT)&lpIPData->rcPosRect,
					(LPRECT)&lpIPData->rcClipRect
		);

		/* OLE2NOTE: IOleInPlaceFrame::SetActiveObject must be called BEFORE
		**    IOleInPlaceFrame::SetMenu.
		*/
		OLEDBG_BEGIN2("IOleInPlaceSite::SetActiveObject called\r\n");
		CallIOleInPlaceUIWindowSetActiveObjectA(
			(struct IOleInPlaceUIWindow *) lpIPData->lpFrame,
			(LPOLEINPLACEACTIVEOBJECT) &lpServerDoc->m_OleInPlaceActiveObject,
			(LPSTR)g_szIPObjectTitle
		);
		OLEDBG_END2

		/* OLE2NOTE: If the container wants to give ownership of the
		**    palette then he would sendmessage WM_QUEYNEWPALETTE to
		**    the object window proc, before returning from
		**    IOleInPlaceFrame::SetActiveObject. Those objects which
		**    want to be edited inplace only if they have the ownership of
		**    the palette, can check at this point in the code whether
		**    they got WM_QUERYNEWPALETTE or not. If they didn't get
		**    the message, then they can inplace deactivate and do open
		**    editing instead.
		*/



		if (lpIPData->lpDoc) {
			CallIOleInPlaceUIWindowSetActiveObjectA(
				lpIPData->lpDoc,
				(LPOLEINPLACEACTIVEOBJECT)&lpServerDoc->m_OleInPlaceActiveObject,
				(LPSTR)g_szIPObjectTitle
			);
		}

		/* OLE2NOTE: install the menu and frame-level tools on the in-place
		**    frame.
		*/
		ServerDoc_AddFrameLevelUI(lpServerDoc);
	}

	return NOERROR;

errRtn:
	ServerDoc_DoInPlaceDeactivate(lpServerDoc);
	return ResultFromScode(sc);
}



HRESULT ServerDoc_DoInPlaceDeactivate(LPSERVERDOC lpServerDoc)
{
	LPINPLACEDATA   lpIPData = lpServerDoc->m_lpIPData;
	LPOUTLINEDOC    lpOutlineDoc = (LPOUTLINEDOC)lpServerDoc;

	if (!lpServerDoc->m_fInPlaceActive)
		return S_OK;

	lpServerDoc->m_fInPlaceActive = FALSE;

	SvrDoc_IPObj_UIDeactivate(
			(LPOLEINPLACEOBJECT)&lpServerDoc->m_OleInPlaceObject);

	/* OLE2NOTE: an inside-out style in-place server will
	**    NOT hide its window in UIDeactive (an outside-in
	**    style object will hide its window in UIDeactivate).
	**    thus, an inside-out server must explicitly hide
	**    its window in InPlaceDeactivate. it is ALSO important for an
	**    outside-in style object to call ServerDoc_DoInPlaceHide here
	**    BEFORE freeing the InPlaceData structure. it will be common
	**    for in-place containers to call IOleInPlaceObject::
	**    InPlaceDeactivate in their IOleInPlaceSite::OnUIDeactiate
	**    implementation.
	*/
	ServerDoc_DoInPlaceHide(lpServerDoc);

	OLEDBG_BEGIN2("IOleInPlaceSite::OnInPlaceDeactivate called\r\n");
	lpIPData->lpSite->lpVtbl->OnInPlaceDeactivate(lpIPData->lpSite);
	OLEDBG_END2

	OleStdRelease((LPUNKNOWN)lpIPData->lpSite);
	lpIPData->lpSite = NULL;

	ServerDoc_FreeInPlaceData(lpServerDoc);

	return NOERROR;
}


HRESULT ServerDoc_DoInPlaceHide(LPSERVERDOC lpServerDoc)
{
	LPINPLACEDATA   lpIPData = lpServerDoc->m_lpIPData;
	LPOUTLINEDOC    lpOutlineDoc = (LPOUTLINEDOC)lpServerDoc;
	LPOLEAPP        lpOleApp = (LPOLEAPP)g_lpApp;
	HWND            hWndApp = OutlineApp_GetWindow(g_lpApp);

	if (! lpServerDoc->m_fInPlaceVisible)
		return NOERROR;

	// Set the parent back to server app's window
	OleDoc_HideWindow((LPOLEDOC)lpServerDoc, FALSE /* fShutdown */);

	/* we need to enusure that our window is set to normal 100% zoom.
	**    if the window is next shown in open mode it should start out
	**    at normal zoom factor. our window may have been set to a
	**    different zoom factor while it was in-place active.
	*/
	OutlineDoc_SetCurrentZoomCommand(lpOutlineDoc,IDM_V_ZOOM_100);

	lpServerDoc->m_fInPlaceVisible = FALSE;

	lpServerDoc->m_hWndParent = hWndApp;
	SetParent(
		lpOutlineDoc->m_hWndDoc,
		lpServerDoc->m_hWndParent
	);

	// make sure App busy/blocked dialogs are parented to our own hWndApp
	OleStdMsgFilter_SetParentWindow(lpOleApp->m_lpMsgFilter, hWndApp);

	// Hide the in-place hatch border window.
	ShowWindow(lpServerDoc->m_hWndHatch, SW_HIDE);

	ServerDoc_DisassembleMenus(lpServerDoc);

	/* we no longer need the IOleInPlaceFrame* or the doc's
	**    IOleInPlaceWindow* interface pointers.
	*/
	if (lpIPData->lpDoc) {
		OleStdRelease((LPUNKNOWN)lpIPData->lpDoc);
		lpIPData->lpDoc = NULL;
	}

	if (lpIPData->lpFrame) {
		OleStdRelease((LPUNKNOWN)lpIPData->lpFrame);
		lpIPData->lpFrame = NULL;
	}

	((LPSERVERAPP)g_lpApp)->m_lpIPData = NULL;

	return NOERROR;
}


BOOL ServerDoc_AllocInPlaceData(LPSERVERDOC lpServerDoc)
{
	LPINPLACEDATA   lpIPData;

	if (!(lpIPData = (LPINPLACEDATA) New(sizeof(INPLACEDATA))))
		return FALSE;

	lpIPData->lpFrame       = NULL;
	lpIPData->lpDoc         = NULL;
	lpIPData->lpSite        = NULL;
	lpIPData->hOlemenu      = NULL;
	lpIPData->hMenuShared   = NULL;

	lpServerDoc->m_lpIPData = lpIPData;
	return TRUE;
}


void ServerDoc_FreeInPlaceData(LPSERVERDOC lpServerDoc)
{
	Delete(lpServerDoc->m_lpIPData);
	lpServerDoc->m_lpIPData = NULL;
}


HRESULT ServerDoc_AssembleMenus(LPSERVERDOC lpServerDoc)
{
	HMENU           hMenuShared;
	LONG FAR*       lpWidths;
	UINT            uPosition;
	UINT            uPositionStart;
	LPSERVERAPP     lpServerApp = (LPSERVERAPP) g_lpApp;
	LPINPLACEDATA   lpIPData = lpServerDoc->m_lpIPData;
	HRESULT         hresult;
	BOOL            fNoError = TRUE;

	lpWidths = lpIPData->menuGroupWidths.width;
	hMenuShared = CreateMenu();

	if (hMenuShared &&
		(hresult = lpIPData->lpFrame->lpVtbl->InsertMenus(
			lpIPData->lpFrame, hMenuShared,
			&lpIPData->menuGroupWidths)) == NOERROR) {

	   /* Insert EDIT group menus */

	   uPosition = (UINT)lpWidths[0]; /* # of menus in the FILE group */
	   uPositionStart = uPosition;

	   fNoError &= InsertMenu(
			   hMenuShared,
			   (UINT)uPosition,
			   (UINT)(MF_BYPOSITION | MF_POPUP),
			   (UINT)lpServerApp->m_hMenuEdit,
			   (LPCSTR)"&Edit"
	   );
	   uPosition++;

	   lpWidths[1] = uPosition - uPositionStart;

	   /* Insert OBJECT group menus */

	   uPosition += (UINT)lpWidths[2];
	   uPositionStart = uPosition;

	   fNoError &= InsertMenu(
			   hMenuShared,
			   (UINT)uPosition,
			   (UINT)(MF_BYPOSITION | MF_POPUP),
			   (UINT)lpServerApp->m_hMenuLine,
			   (LPCSTR)"&Line"
	   );
	   uPosition++;

	   fNoError &= InsertMenu(
			   hMenuShared,
			   (UINT)uPosition,
			   (UINT)(MF_BYPOSITION | MF_POPUP),
			   (UINT)lpServerApp->m_hMenuName,
			   (LPCSTR)"&Name"
	   );
	   uPosition++;

	   fNoError &= InsertMenu(
			   hMenuShared,
			   (UINT)uPosition,
			   (UINT)(MF_BYPOSITION | MF_POPUP),
			   (UINT)lpServerApp->m_hMenuOptions,
			   (LPCSTR)"&Options"
	   );
	   uPosition++;

	   fNoError &= InsertMenu(
			   hMenuShared,
			   (UINT)uPosition,
			   (UINT)(MF_BYPOSITION | MF_POPUP),
			   (UINT)lpServerApp->m_hMenuDebug,
			   (LPCSTR)"DbgI&Svr"
		);
		uPosition++;

		lpWidths[3] = uPosition - uPositionStart;

		/* Insert HELP group menus */

		uPosition += (UINT) lpWidths[4]; /* # of menus in WINDOW group */
		uPositionStart = uPosition;

		fNoError &= InsertMenu(
				hMenuShared,
				(UINT)uPosition,
				(UINT)(MF_BYPOSITION | MF_POPUP),
				(UINT)lpServerApp->m_hMenuHelp,
				(LPCSTR)"&Help"
		);
		uPosition++;

		lpWidths[5] = uPosition - uPositionStart;

		OleDbgAssert(fNoError == TRUE);

	} else {
		/* In-place container does not allow us to add menus to the
		**    frame.
		** OLE2NOTE: even when the in-place container does NOT allow
		**    the building of a merged menu bar, it is CRITICAL that
		**    the in-place server still call OleCreateMenuDescriptor
		**    passing NULL for hMenuShared.
		*/
		if (hMenuShared) {
			DestroyMenu(hMenuShared);
			hMenuShared = NULL;
		}
	}

	lpIPData->hMenuShared = hMenuShared;

	if (!(lpIPData->hOlemenu = OleCreateMenuDescriptor(hMenuShared,
											&lpIPData->menuGroupWidths)))
		return ResultFromScode(E_OUTOFMEMORY);

	return NOERROR;
}


void ServerDoc_DisassembleMenus(LPSERVERDOC lpServerDoc)
{
	UINT             uCount;
	UINT            uGroup;
	UINT            uDeleteAt;
	LPINPLACEDATA   lpIPData = lpServerDoc->m_lpIPData;
	LONG FAR*       lpWidths = lpIPData->menuGroupWidths.width;
	BOOL            fNoError = TRUE;

	/* OLE2NOTE: even when hMenuShared is NULL (ie. the server has no
	**    Menu), there is still an hOleMenu created that must be destroyed.
	*/
	if (lpIPData->hOlemenu) {
		OleDestroyMenuDescriptor (lpIPData->hOlemenu);
		lpIPData->hOlemenu = NULL;
	}

	if (! lpIPData->hMenuShared)
		return;     // no menus to be destroyed

	/* Remove server group menus. */
	uDeleteAt = 0;
	for (uGroup = 0; uGroup < 6; uGroup++) {
		uDeleteAt += (UINT)lpWidths[uGroup++];
		for (uCount = 0; uCount < (UINT)lpWidths[uGroup]; uCount++)
			fNoError &= RemoveMenu(lpIPData->hMenuShared, uDeleteAt,
								MF_BYPOSITION);
	}

	/* Remove container group menus */
	fNoError &= (lpIPData->lpFrame->lpVtbl->RemoveMenus(
		lpIPData->lpFrame,
		lpIPData->hMenuShared) == NOERROR);

	OleDbgAssert(fNoError == TRUE);

	DestroyMenu(lpIPData->hMenuShared);
	lpIPData->hMenuShared = NULL;
}


/* ServerDoc_UpdateInPlaceWindowOnExtentChange
** -------------------------------------------
**    The size of the in-place window needs to be changed.
**    calculate the size required in Client coordinates (taking into
**    account the current scale factor imposed by the in-place
**    container) and ask our in-place container to allow us to resize.
**    our container must call us back via
**    IOleInPlaceObject::SetObjectRects for the actual sizing to take
**    place.
**
**    OLE2NOTE: the rectangle that we ask for from our in-place
**    container is always the rectangle required for the object display
**    itself (in our case the size of the LineList contents). it does
**    NOT include the space we require for object frame adornments.
*/
void ServerDoc_UpdateInPlaceWindowOnExtentChange(LPSERVERDOC lpServerDoc)
{
	SIZEL       sizelHim;
	SIZEL       sizelPix;
	RECT        rcPosRect;
	LPOUTLINEDOC lpOutlineDoc = (LPOUTLINEDOC)lpServerDoc;
	LPLINELIST  lpLL=(LPLINELIST)&lpOutlineDoc->m_LineList;
	HWND        hWndLL = lpLL->m_hWndListBox;
	LPSCALEFACTOR lpscale = (LPSCALEFACTOR)&lpOutlineDoc->m_scale;

	if (!lpServerDoc->m_fInPlaceActive)
		return;

	OleDoc_GetExtent((LPOLEDOC)lpServerDoc, (LPSIZEL)&sizelHim);

	// apply current scale factor
	sizelHim.cx = sizelHim.cx * lpscale->dwSxN / lpscale->dwSxD;
	sizelHim.cy = sizelHim.cy * lpscale->dwSxN / lpscale->dwSxD;
	XformSizeInHimetricToPixels(NULL, (LPSIZEL)&sizelHim, (LPSIZEL)&sizelPix);

	GetWindowRect(hWndLL, (LPRECT)&rcPosRect);
	ScreenToClient(lpServerDoc->m_hWndParent, (POINT FAR *)&rcPosRect);

	rcPosRect.right = rcPosRect.left + (int) sizelPix.cx;
	rcPosRect.bottom = rcPosRect.top + (int) sizelPix.cy;
	OleDbgOutRect3("ServerDoc_UpdateInPlaceWindowOnExtentChange: (PosRect)", (LPRECT)&rcPosRect);

	OLEDBG_BEGIN2("IOleInPlaceSite::OnPosRectChange called\r\n");
	lpServerDoc->m_lpIPData->lpSite->lpVtbl->OnPosRectChange(
			lpServerDoc->m_lpIPData->lpSite,
			(LPRECT) &rcPosRect
	);
	OLEDBG_END2
}


/* ServerDoc_CalcInPlaceWindowPos
 * ------------------------------
 *
 *  Move (and re-scale) the ServerDoc to the specified rectangle.
 *
 *  Parameters:
 *      lprcListBox - rect in client coordinate in which the listbox will fit
 *      lprcDoc     - corresponding size of the Doc in client coordinate
 *
 */
void ServerDoc_CalcInPlaceWindowPos(
		LPSERVERDOC         lpServerDoc,
		LPRECT              lprcListBox,
		LPRECT              lprcDoc,
		LPSCALEFACTOR       lpscale
)
{
	SIZEL sizelHim;
	SIZEL sizelPix;
	LPLINELIST lpLL;
	LPOUTLINEDOC lpOutlineDoc = (LPOUTLINEDOC)lpServerDoc;
	LPHEADING lphead;

	if (!lpServerDoc || !lprcListBox || !lprcDoc)
		return;

	lphead = (LPHEADING)&lpOutlineDoc->m_heading;

	lpLL = OutlineDoc_GetLineList(lpOutlineDoc);
	OleDoc_GetExtent((LPOLEDOC)lpServerDoc, (LPSIZEL)&sizelHim);
	XformSizeInHimetricToPixels(NULL, &sizelHim, &sizelPix);

	if (sizelHim.cx == 0 || sizelPix.cx == 0) {
		lpscale->dwSxN = 1;
		lpscale->dwSxD = 1;
	} else {
		lpscale->dwSxN = lprcListBox->right - lprcListBox->left;
		lpscale->dwSxD = sizelPix.cx;
	}

	if (sizelHim.cy == 0 || sizelPix.cy == 0) {
		lpscale->dwSyN = 1;
		lpscale->dwSyD = 1;
	} else {
		lpscale->dwSyN = lprcListBox->bottom - lprcListBox->top;
		lpscale->dwSyD = sizelPix.cy;
	}

	lprcDoc->left = lprcListBox->left - Heading_RH_GetWidth(lphead,lpscale);
	lprcDoc->right = lprcListBox->right;
	lprcDoc->top = lprcListBox->top - Heading_CH_GetHeight(lphead,lpscale);
	lprcDoc->bottom = lprcListBox->bottom;
}


/* ServerDoc_ResizeInPlaceWindow
** -----------------------------
**    Actually resize the in-place ServerDoc windows according to the
**    PosRect and ClipRect allowed by our in-place container.
**
**    OLE2NOTE: the PosRect rectangle that our in-place container tells
**    us is always the rectangle required for the object display
**    itself (in our case the size of the LineList contents). it does
**    NOT include the space we require for object frame adornments.
*/
void ServerDoc_ResizeInPlaceWindow(
		LPSERVERDOC         lpServerDoc,
		LPCRECT             lprcPosRect,
		LPCRECT             lprcClipRect
)
{
	LPOUTLINEDOC lpOutlineDoc = (LPOUTLINEDOC)lpServerDoc;
	LPLINELIST   lpLL = (LPLINELIST)&lpOutlineDoc->m_LineList;
	SCALEFACTOR  scale;
	RECT         rcDoc;
	POINT        ptOffset;

	/* OLE2NOTE: calculate the space needed for our object frame
	**    adornments. our in-place container tells us the size that our
	**    object should take in window client coordinates
	**    (lprcPosRect). the rectangle cooresponds to the size that our
	**    LineList ListBox should be. our Doc window must the correct
	**    amount larger to accomodate our row/column headings.
	**    then move all windows into position.
	*/
	ServerDoc_CalcInPlaceWindowPos(
			lpServerDoc,
			(LPRECT)lprcPosRect,
			(LPRECT)&rcDoc,
			(LPSCALEFACTOR)&scale
	);

	/* OLE2NOTE: we need to honor the lprcClipRect specified by our
	**    in-place container. we must NOT draw outside of the ClipRect.
	**    in order to achieve this, we will size the hatch window to be
	**    exactly the size that should be visible (rcVisRect). the
	**    rcVisRect is defined as the intersection of the full size of
	**    the in-place server window and the lprcClipRect.
	**    the ClipRect could infact clip the HatchRect on the
	**    right/bottom and/or on the top/left. if it is clipped on the
	**    right/bottom then it is sufficient to simply resize the hatch
	**    window. but if the HatchRect is clipped on the top/left then
	**    we must "move" the ServerDoc window (child of HatchWindow) by
	**    the delta that was clipped. the window origin of the
	**    ServerDoc window will then have negative coordinates relative
	**    to its parent HatchWindow.
	*/
	SetHatchWindowSize(
			lpServerDoc->m_hWndHatch,
			(LPRECT)&rcDoc,
			(LPRECT)lprcClipRect,
			(LPPOINT)&ptOffset
	);

	// shift Doc window to account for hatch frame being drawn
	OffsetRect((LPRECT)&rcDoc, ptOffset.x, ptOffset.y);

	// move/size/set scale factor of ServerDoc window.
	OutlineDoc_SetScaleFactor(
			lpOutlineDoc, (LPSCALEFACTOR)&scale, (LPRECT)&rcDoc);

	/* reset the horizontal extent of the listbox. this makes
	**    the listbox realize that a scroll bar is not needed.
	*/
	SendMessage(
			lpLL->m_hWndListBox,
			LB_SETHORIZONTALEXTENT,
			(int) 0,
			0L
	);
	SendMessage(
			lpLL->m_hWndListBox,
			LB_SETHORIZONTALEXTENT,
			(int) (lprcPosRect->right - lprcPosRect->left),
			0L
	);
}


/* ServerDoc_SetStatusText
**    Tell the active in-place frame to display a status message.
*/
void ServerDoc_SetStatusText(LPSERVERDOC lpServerDoc, LPSTR lpszMessage)
{
	if (lpServerDoc && lpServerDoc->m_fUIActive &&
		lpServerDoc->m_lpIPData != NULL) {

		OLEDBG_BEGIN2("IOleInPlaceFrame::SetStatusText called\r\n")
		CallIOleInPlaceFrameSetStatusTextA
			(lpServerDoc->m_lpIPData->lpFrame, lpszMessage);
		OLEDBG_END2
	}
}


/* ServerDoc_GetTopInPlaceFrame
** ----------------------------
**    returns NON-AddRef'ed pointer to Top In-Place Frame interface
*/
LPOLEINPLACEFRAME ServerDoc_GetTopInPlaceFrame(LPSERVERDOC lpServerDoc)
{
	if (lpServerDoc->m_lpIPData)
		return lpServerDoc->m_lpIPData->lpFrame;
	else
		return NULL;
}

void ServerDoc_GetSharedMenuHandles(
		LPSERVERDOC lpServerDoc,
		HMENU FAR*      lphSharedMenu,
		HOLEMENU FAR*   lphOleMenu
)
{
	if (lpServerDoc->m_lpIPData) {
		*lphSharedMenu = lpServerDoc->m_lpIPData->hMenuShared;
		*lphOleMenu = lpServerDoc->m_lpIPData->hOlemenu;
	} else {
		*lphSharedMenu = NULL;
		*lphOleMenu = NULL;
	}
}


void ServerDoc_AddFrameLevelUI(LPSERVERDOC lpServerDoc)
{
	LPOUTLINEAPP lpOutlineApp = (LPOUTLINEAPP)g_lpApp;
	LPSERVERAPP lpServerApp = (LPSERVERAPP)g_lpApp;
	LPOUTLINEDOC lpOutlineDoc = (LPOUTLINEDOC)lpServerDoc;
	LPOLEINPLACEFRAME lpTopIPFrame=ServerDoc_GetTopInPlaceFrame(lpServerDoc);
	HMENU           hSharedMenu;            // combined obj/cntr menu
	HOLEMENU        hOleMenu;               // returned by OleCreateMenuDesc.

	ServerDoc_GetSharedMenuHandles(
			lpServerDoc,
			&hSharedMenu,
			&hOleMenu
	);

	lpTopIPFrame->lpVtbl->SetMenu(
			lpTopIPFrame,
			hSharedMenu,
			hOleMenu,
			lpOutlineDoc->m_hWndDoc
	);

	// save normal accelerator table
	lpServerApp->m_hAccelBaseApp = lpOutlineApp->m_hAccelApp;

	// install accelerator table for UIActive server (w/ active editor cmds)
	lpOutlineApp->m_hAccel = lpServerApp->m_hAccelIPSvr;
	lpOutlineApp->m_hAccelApp = lpServerApp->m_hAccelIPSvr;
	lpOutlineApp->m_hWndAccelTarget = lpOutlineDoc->m_hWndDoc;

#if defined( USE_FRAMETOOLS )
	ServerDoc_AddFrameLevelTools(lpServerDoc);

	// update toolbar button enable states
	OutlineDoc_UpdateFrameToolButtons(lpOutlineDoc);
#endif
}


void ServerDoc_AddFrameLevelTools(LPSERVERDOC lpServerDoc)
{
	LPOUTLINEAPP    lpOutlineApp = (LPOUTLINEAPP)g_lpApp;
	LPSERVERAPP     lpServerApp = (LPSERVERAPP)g_lpApp;
	LPOUTLINEDOC    lpOutlineDoc = (LPOUTLINEDOC)lpServerDoc;
	LPOLEINPLACEFRAME lpTopIPFrame=ServerDoc_GetTopInPlaceFrame(lpServerDoc);

#if defined( USE_FRAMETOOLS )
	HWND            hWndFrame;

	FrameTools_Enable(lpOutlineDoc->m_lpFrameTools, TRUE);

	// if not in-place UI active, add our tools to our own frame.
	if (! lpServerDoc->m_fUIActive) {
		OutlineDoc_AddFrameLevelTools(lpOutlineDoc);
		return;
	}

	if ((hWndFrame = OutlineApp_GetFrameWindow(lpOutlineApp)) == NULL) {
		/* we could NOT get a valid frame window, so POP our tools up. */

		/* OLE2NOTE: since we are poping up our tools, we MUST inform
		**    the top in-place frame window that we need NO tool space
		**    BUT that it should NOT put its own tools up. if we were
		**    to pass NULL instead of (0,0,0,0), then the container
		**    would have the option to leave its own tools up.
		*/
		lpTopIPFrame->lpVtbl->SetBorderSpace(
				lpTopIPFrame,
				(LPCBORDERWIDTHS)&g_rectNull
		);
		FrameTools_PopupTools(lpOutlineDoc->m_lpFrameTools);
	} else {

		/* OLE2NOTE: we need to negotiate for space and attach our frame
		**    level tools to the top-level in-place container's frame window.
		*/
		FrameTools_AttachToFrame(lpOutlineDoc->m_lpFrameTools, hWndFrame);

		FrameTools_NegotiateForSpaceAndShow(
				lpOutlineDoc->m_lpFrameTools,
				NULL,
				lpTopIPFrame
		);
	}

#else   // ! USE_FRAMETOOLS
	/* OLE2NOTE: if you do NOT use frame tools, you MUST inform the top
	**    in-place frame window so that it can put back its own tools.
	*/
	lpTopIPFrame->lpVtbl->SetBorderSpace(lpIPData->lpFrame, NULL);
#endif  // ! USE_FRAMETOOLS
}


#if defined( USE_FRAMETOOLS )

void ServerDoc_RemoveFrameLevelTools(LPSERVERDOC lpServerDoc)
{
	LPOUTLINEDOC lpOutlineDoc = (LPOUTLINEDOC)lpServerDoc;
	OleDbgAssert(lpOutlineDoc->m_lpFrameTools != NULL);

    // Reparent our tools back to one of our own windows
    FrameTools_AttachToFrame(lpOutlineDoc->m_lpFrameTools,g_lpApp->m_hWndApp);

	FrameTools_Enable(lpOutlineDoc->m_lpFrameTools, FALSE);
}
#endif  // USE_FRAMETOOLS



void ServerDoc_UIActivate (LPSERVERDOC lpServerDoc)
{
	if (lpServerDoc->m_fInPlaceActive && !lpServerDoc->m_fUIActive) {
		ServerDoc_DoInPlaceActivate(lpServerDoc,
				OLEIVERB_UIACTIVATE,
				NULL /*lpmsg*/,
				lpServerDoc->m_lpOleClientSite
		);
		OutlineDoc_ShowWindow((LPOUTLINEDOC)lpServerDoc);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\letest\outline\cntroutl\chicago\makefile.inc ===
copyfiles:
    xcopy ..\..\*.c . /D
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\letest\outline\status.c ===
/*************************************************************************
**
**    OLE 2.0 Sample Code
**
**    status.c
**
**    This file contains the window handlers, and various initialization
**    and utility functions for an application status bar.
**
**    (c) Copyright Microsoft Corp. 1992 - 1993 All Rights Reserved
**
*************************************************************************/

// Application specific include files
#include "outline.h"
#include "message.h"
#include "status.h"

// Current status message.
static LPSTR lpszStatusMessage = NULL;

// Window proc for status window.
LRESULT FAR PASCAL StatusWndProc
   (HWND hwnd, unsigned message, WPARAM wParam, LPARAM lParam);

// List of all constant messages.
static STATMESG ControlList[2] =
{
	{   STATUS_READY,   "Ready."    },
	{   STATUS_BLANK,   " "         }
};

// List of all system menu messages.
static STATMESG SysMenuList[16] =
{
	{   SC_SIZE,        "Change the size of the window."            },
	{   SC_MOVE,        "Move the window."                          },
	{   SC_MINIMIZE,    "Make the window iconic."                   },
	{   SC_MAXIMIZE,    "Make the window the size of the screen."   },
	{   SC_NEXTWINDOW,  "Activate the next window."                 },
	{   SC_PREVWINDOW,  "Activate the previous window."             },
	{   SC_CLOSE,       "Close this window."                        },
	{   SC_VSCROLL,     "Vertical scroll?"                          },
	{   SC_HSCROLL,     "Horizontal scroll?"                        },
	{   SC_MOUSEMENU,   "A menu for mice."                          },
	{   SC_KEYMENU,     "A menu for keys (I guess)."                },
	{   SC_ARRANGE,     "Arrange something."                        },
	{   SC_RESTORE,     "Make the window noramally sized."          },
	{   SC_TASKLIST,    "Put up the task list dialog."              },
	{   SC_SCREENSAVE,  "Save the screen!  Run for your life!"      },
	{   SC_HOTKEY,      "Boy, is this key hot!"                     }
};

// Message type for popup messages.
typedef struct {
	HMENU hmenu;
	char string[MAX_MESSAGE];
} STATPOPUP;

// List of all popup messages.
static STATPOPUP PopupList[NUM_POPUP];

static UINT nCurrentPopup = 0;



/* RegisterStatusClass
 * -------------------
 *
 * Creates classes for status window.
 *
 * HINSTANCE hInstance
 *
 * RETURNS: TRUE if class successfully registered.
 *          FALSE otherwise.
 *
 * CUSTOMIZATION: Change class name.
 *
 */
BOOL RegisterStatusClass(HINSTANCE hInstance)
{
	WNDCLASS  wc;

	wc.lpszClassName = "ObjStatus";
	wc.lpfnWndProc   = StatusWndProc;
	wc.style         = 0;
	wc.hInstance     = hInstance;
	wc.hIcon         = NULL;
	wc.cbClsExtra    = 4;
	wc.cbWndExtra    = 0;
	wc.lpszMenuName  = NULL;
	wc.hCursor       = LoadCursor(NULL, IDC_ARROW);
	wc.hbrBackground = GetStockObject(LTGRAY_BRUSH);

	if (!RegisterClass(&wc))
		return FALSE;

	return TRUE;
}


/* CreateStatusWindow
 * ------------------
 *
 * Creates status window.
 *
 * HWND hwndMain
 *
 * RETURNS: HWND of status window if creation is successful.
 *          NULL otherwise.
 *
 * CUSTOMIZATION: Change class name.
 *
 */
HWND CreateStatusWindow(HWND hWndApp, HINSTANCE hInst)
{
	RECT rect;
	int width, height;
	HWND hWndStatusBar;

	lpszStatusMessage = ControlList[0].string;
	GetClientRect(hWndApp, &rect);
	width = rect.right - rect.left;
	height = rect.bottom - rect.top;

	hWndStatusBar = CreateWindow (
		"ObjStatus",
		"SvrStatus",
		WS_CHILD |
		WS_CLIPSIBLINGS |
		WS_VISIBLE,
		0, height - STATUS_HEIGHT,
		width,
		STATUS_HEIGHT,
		hWndApp,
		NULL,
		hInst,
		NULL
	);

	return hWndStatusBar;
}


/* DestroyStatusWindow
 * -------------------
 *
 * Destroys status window.
 *
 * CUSTOMIZATION: None.
 *
 */
void DestroyStatusWindow(HWND hWndStatusBar)
{
	DestroyWindow(hWndStatusBar);
}


/* AssignPopupMessage
 * ------------------
 *
 * Associates a string with a popup menu handle.
 *
 * HMENU hmenuPopup
 * char *szMessage
 *
 * CUSTOMIZATION: None.
 *
 */
void AssignPopupMessage(HMENU hmenuPopup, char *szMessage)
{
	if (nCurrentPopup < NUM_POPUP) {
		PopupList[nCurrentPopup].hmenu = hmenuPopup;
		lstrcpy(PopupList[nCurrentPopup].string, szMessage);
		++nCurrentPopup;
	}
}


/* SetStatusText
 * -------------
 *
 * Show the message in the status line.
 */
void SetStatusText(HWND hWndStatusBar, LPSTR lpszMessage)
{
	lpszStatusMessage = lpszMessage;
	InvalidateRect (hWndStatusBar, (LPRECT)NULL,  TRUE);
	UpdateWindow (hWndStatusBar);
}


/* GetItemMessage
 * --------------
 *
 * Retrieve the message associated with the given menu command item number.
 *
 * UINT wIDItem
 * LPVOID lpDoc
 *
 * CUSTOMIZATION: None.
 *
 */
void GetItemMessage(UINT wIDItem, LPSTR FAR* lplpszMessage)
{
	UINT i;

	*lplpszMessage = ControlList[1].string;
	for (i = 0; i < NUM_STATS; ++i) {
		if (wIDItem == MesgList[i].wIDItem) {
			*lplpszMessage = MesgList[i].string;
			break;
		}
	}
}


/* GetPopupMessage
 * ---------------
 *
 * Retrieve the message associated with the given popup menu.
 *
 * HMENU hmenuPopup
 * LPVOID lpDoc
 *
 * CUSTOMIZATION: None.
 *
 */
void GetPopupMessage(HMENU hmenuPopup, LPSTR FAR* lplpszMessage)
{
	UINT i;

	*lplpszMessage = ControlList[1].string;
	for (i = 0; i < nCurrentPopup; ++i) {
		if (hmenuPopup == PopupList[i].hmenu) {
			*lplpszMessage = PopupList[i].string;
			break;
		}
	}
}


/* GetSysMenuMessage
 * -----------------
 *
 * Retrieves the messages to correspond to items on the system menu.
 *
 *
 * UINT wIDItem
 * LPVOID lpDoc
 *
 * CUSTOMIZATION: None.
 *
 */
void GetSysMenuMessage(UINT wIDItem, LPSTR FAR* lplpszMessage)
{
	UINT i;

	*lplpszMessage = ControlList[1].string;
	for (i = 0; i < 16; ++i) {
		if (wIDItem == SysMenuList[i].wIDItem) {
			*lplpszMessage = SysMenuList[i].string;
			break;
		}
	}
}


/* GetControlMessage
 * -----------------
 *
 * Retrieves the general system messages.
 *
 *
 * STATCONTROL scCommand
 * LPVOID lpDoc
 *
 * CUSTOMIZATION: Add new messages.
 *
 */
void GetControlMessage(STATCONTROL scCommand, LPSTR FAR* lplpszMessage)
{
	UINT i;

	*lplpszMessage = ControlList[1].string;
	for (i = 0; i < 2; ++i) {
		if ((UINT)scCommand == ControlList[i].wIDItem) {
			*lplpszMessage = ControlList[i].string;
			break;
		}
	}
}



/* StatusWndProc
 * -------------
 *
 * Message handler for the statusbar window.
 *
 *
 * CUSTOMIZATION: None
 *
 */
LRESULT FAR PASCAL StatusWndProc
   (HWND hwnd, unsigned message, WPARAM wParam, LPARAM lParam)
{
	if (message == WM_PAINT) {
		RECT        rc;
		HDC         hdc;
		PAINTSTRUCT paintstruct;
		HPEN        hpenOld;
		HPEN        hpen;
		HFONT       hfontOld;
		HFONT       hfont;
		HPALETTE    hpalOld = NULL;
		POINT       point;

		BeginPaint (hwnd, &paintstruct);
		hdc = GetDC (hwnd);

		GetClientRect (hwnd, (LPRECT) &rc);

		hpenOld = SelectObject (hdc, GetStockObject (BLACK_PEN));

		MoveToEx (hdc, 0, 0, &point);
		LineTo (hdc, rc.right, 0);

		SelectObject (hdc, GetStockObject (WHITE_PEN));

		MoveToEx (hdc, STATUS_RRIGHT, STATUS_RTOP, &point);
		LineTo (hdc, STATUS_RRIGHT, STATUS_RBOTTOM);
		LineTo (hdc, STATUS_RLEFT-1, STATUS_RBOTTOM);

		hpen = CreatePen (PS_SOLID, 1, /* DKGRAY */ 0x00808080);
		SelectObject (hdc, hpen);

		MoveToEx (hdc, STATUS_RLEFT, STATUS_RBOTTOM-1, &point);
		LineTo (hdc, STATUS_RLEFT, STATUS_RTOP);
		LineTo (hdc, STATUS_RRIGHT, STATUS_RTOP);

		SetBkMode (hdc, TRANSPARENT);
		SetTextAlign (hdc, TA_LEFT | TA_TOP);
		hfont = CreateFont (STATUS_THEIGHT, 0, 0, 0, FW_NORMAL, FALSE, FALSE,
							FALSE, ANSI_CHARSET, OUT_DEFAULT_PRECIS,
							CLIP_DEFAULT_PRECIS, DEFAULT_QUALITY,
							DEFAULT_PITCH | FF_DONTCARE, "MS Sans Serif");

		hfontOld = SelectObject(hdc, hfont);

		TextOut (hdc, STATUS_TLEFT, STATUS_TTOP,
				 lpszStatusMessage,
				 lstrlen(lpszStatusMessage));

		// Restore original objects
		SelectObject (hdc, hfontOld);
		SelectObject (hdc, hpenOld);
		DeleteObject (hpen);
		DeleteObject (hfont);

		ReleaseDC (hwnd, hdc);
		EndPaint (hwnd, &paintstruct);

		return 0;
	}
	else {
		return DefWindowProc(hwnd, message, wParam, lParam);
	}
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\letest\outline\cntroutl\daytona\makefile.inc ===
copyfiles:
    xcopy ..\..\*.c . /D
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\letest\outline\icntrotl\daytona\makefile.inc ===
copyfiles:
    xcopy ..\..\*.c . /D
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\letest\outline\icntrotl\chicago\makefile.inc ===
copyfiles:
    xcopy ..\..\*.c . /D
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\letest\outline\svrpsobj.c ===
/*************************************************************************
**
**    OLE 2 Server Sample Code
**
**    svrpsobj.c
**
**    This file contains all PseudoObj methods and related support
**    functions.
**
**    (c) Copyright Microsoft Corp. 1992 - 1993 All Rights Reserved
**
*************************************************************************/


#include "outline.h"

OLEDBGDATA

extern LPOUTLINEAPP             g_lpApp;
extern IUnknownVtbl             g_PseudoObj_UnknownVtbl;
extern IOleObjectVtbl           g_PseudoObj_OleObjectVtbl;
extern IDataObjectVtbl          g_PseudoObj_DataObjectVtbl;


/* PseudoObj_Init
** --------------
**  Initialize fields in a newly constructed PseudoObj.
**  NOTE: ref cnt of PseudoObj initialized to 0
*/
void PseudoObj_Init(
		LPPSEUDOOBJ             lpPseudoObj,
		LPSERVERNAME            lpServerName,
		LPSERVERDOC             lpServerDoc
)
{
	OleDbgOut2("++PseudoObj Created\r\n");

	lpPseudoObj->m_cRef             = 0;
	lpPseudoObj->m_lpName           = lpServerName;
	lpPseudoObj->m_lpDoc            = lpServerDoc;
	lpPseudoObj->m_lpOleAdviseHldr  = NULL;
	lpPseudoObj->m_lpDataAdviseHldr = NULL;
	lpPseudoObj->m_fObjIsClosing    = FALSE;

	INIT_INTERFACEIMPL(
			&lpPseudoObj->m_Unknown,
			&g_PseudoObj_UnknownVtbl,
			lpPseudoObj
	);

	INIT_INTERFACEIMPL(
			&lpPseudoObj->m_OleObject,
			&g_PseudoObj_OleObjectVtbl,
			lpPseudoObj
	);

	INIT_INTERFACEIMPL(
			&lpPseudoObj->m_DataObject,
			&g_PseudoObj_DataObjectVtbl,
			lpPseudoObj
	);

	/* OLE2NOTE: Increment the refcnt of the Doc on behalf of the
	**    PseudoObj. the Document should not shut down unless all
	**    pseudo objects are closed. when a pseudo object is destroyed,
	**    it calls ServerDoc_PseudoObjUnlockDoc to release this hold on
	**    the document.
	*/
	ServerDoc_PseudoObjLockDoc(lpServerDoc);
}



/* PseudoObj_AddRef
** ----------------
**
**  increment the ref count of the PseudoObj object.
**
**    Returns the new ref count on the object
*/
ULONG PseudoObj_AddRef(LPPSEUDOOBJ lpPseudoObj)
{
	++lpPseudoObj->m_cRef;

#if defined( _DEBUG )
	OleDbgOutRefCnt4(
			"PseudoObj_AddRef: cRef++\r\n",
			lpPseudoObj,
			lpPseudoObj->m_cRef
	);
#endif
	return lpPseudoObj->m_cRef;
}


/* PseudoObj_Release
** -----------------
**
**  decrement the ref count of the PseudoObj object.
**    if the ref count goes to 0, then the PseudoObj is destroyed.
**
**    Returns the remaining ref count on the object
*/
ULONG PseudoObj_Release(LPPSEUDOOBJ lpPseudoObj)
{
	ULONG cRef;

	/*********************************************************************
	** OLE2NOTE: when the obj refcnt == 0, then destroy the object.     **
	**     otherwise the object is still in use.                        **
	*********************************************************************/

	cRef = --lpPseudoObj->m_cRef;

#if defined( _DEBUG )
	OleDbgAssertSz(lpPseudoObj->m_cRef >= 0,"Release called with cRef == 0");

	OleDbgOutRefCnt4(
			"PseudoObj_Release: cRef--\r\n", lpPseudoObj,cRef);
#endif

	if (cRef == 0)
		PseudoObj_Destroy(lpPseudoObj);

	return cRef;
}


/* PseudoObj_QueryInterface
** ------------------------
**
** Retrieve a pointer to an interface on the PseudoObj object.
**
**    Returns S_OK if interface is successfully retrieved.
**            E_NOINTERFACE if the interface is not supported
*/
HRESULT PseudoObj_QueryInterface(
		LPPSEUDOOBJ         lpPseudoObj,
		REFIID              riid,
		LPVOID FAR*         lplpvObj
)
{
	SCODE sc = E_NOINTERFACE;

	/* OLE2NOTE: we must make sure to set all out ptr parameters to NULL. */
	*lplpvObj = NULL;

	if (IsEqualIID(riid, &IID_IUnknown)) {
		OleDbgOut4("PseudoObj_QueryInterface: IUnknown* RETURNED\r\n");

		*lplpvObj = (LPVOID) &lpPseudoObj->m_Unknown;
		PseudoObj_AddRef(lpPseudoObj);
		sc = S_OK;
	}
	else if (IsEqualIID(riid, &IID_IOleObject)) {
		OleDbgOut4("PseudoObj_QueryInterface: IOleObject* RETURNED\r\n");

		*lplpvObj = (LPVOID) &lpPseudoObj->m_OleObject;
		PseudoObj_AddRef(lpPseudoObj);
		sc = S_OK;
	}
	else if (IsEqualIID(riid, &IID_IDataObject)) {
		OleDbgOut4("PseudoObj_QueryInterface: IDataObject* RETURNED\r\n");

		*lplpvObj = (LPVOID) &lpPseudoObj->m_DataObject;
		PseudoObj_AddRef(lpPseudoObj);
		sc = S_OK;
	}

	OleDbgQueryInterfaceMethod(*lplpvObj);

	return ResultFromScode(sc);
}


/* PseudoObj_Close
 * ---------------
 *
 *  Close the pseudo object. Force all external connections to close
 *      down. This causes link clients to release this PseudoObj. when
 *      the refcount actually reaches 0, then the PseudoObj will be
 *      destroyed.
 *
 *  Returns:
 *      FALSE -- user canceled the closing of the doc.
 *      TRUE -- the doc was successfully closed
 */

BOOL PseudoObj_Close(LPPSEUDOOBJ lpPseudoObj)
{
	LPSERVERDOC lpServerDoc = (LPSERVERDOC)lpPseudoObj->m_lpDoc;
	LPSERVERNAME lpServerName = (LPSERVERNAME)lpPseudoObj->m_lpName;
	LPOLEAPP lpOleApp = (LPOLEAPP)g_lpApp;
	LPOLEDOC lpOleDoc = (LPOLEDOC)lpServerDoc;
	BOOL fStatus = TRUE;

	if (lpPseudoObj->m_fObjIsClosing)
		return TRUE;    // Closing is already in progress

	lpPseudoObj->m_fObjIsClosing = TRUE;   // guard against recursive call

	OLEDBG_BEGIN3("PseudoObj_Close\r\n")

	/* OLE2NOTE: in order to have a stable App, Doc, AND pseudo object
	**    during the process of closing, we intially AddRef the App,
	**    Doc, and PseudoObj ref counts and later Release them. These
	**    initial AddRefs are artificial; they are simply done to
	**    guarantee that these objects do not get destroyed until the
	**    end of this routine.
	*/
	OleApp_AddRef(lpOleApp);
	OleDoc_AddRef(lpOleDoc);
	PseudoObj_AddRef(lpPseudoObj);

	if (lpPseudoObj->m_lpDataAdviseHldr) {
		/* OLE2NOTE: send last OnDataChange notification to clients
		**    that have registered for data notifications when object
		**    stops running (ADVF_DATAONSTOP)
		*/
		PseudoObj_SendAdvise(
				lpPseudoObj,
				OLE_ONDATACHANGE,
				NULL,   /* lpmkObj -- not relevant here */
				ADVF_DATAONSTOP
		);

		/* OLE2NOTE: we just sent the last data notification that we
		**    need to send; release our DataAdviseHolder. we SHOULD be
		**    the only one using it.
		*/
		OleStdVerifyRelease(
				(LPUNKNOWN)lpPseudoObj->m_lpDataAdviseHldr,
				"DataAdviseHldr not released properly"
		);
		lpPseudoObj->m_lpDataAdviseHldr = NULL;
	}

	if (lpPseudoObj->m_lpOleAdviseHldr) {
		// OLE2NOTE: inform all of our linking clients that we are closing.
		PseudoObj_SendAdvise(
				lpPseudoObj,
				OLE_ONCLOSE,
				NULL,   /* lpmkObj -- not relevant here */
				0       /* advf -- not relevant here */
		);

		/* OLE2NOTE: OnClose is the last notification that we need to
		**    send; release our OleAdviseHolder. we SHOULD be the only
		**    one using it. this will make our destructor realize that
		**    OnClose notification has already been sent.
		*/
		OleStdVerifyRelease(
				(LPUNKNOWN)lpPseudoObj->m_lpOleAdviseHldr,
				"OleAdviseHldr not released properly"
		);
		lpPseudoObj->m_lpOleAdviseHldr = NULL;
	}

	/* OLE2NOTE: this call forces all external connections to our
	**    object to close down and therefore guarantees that we receive
	**    all releases associated with those external connections.
	*/
	OLEDBG_BEGIN2("CoDisconnectObject called\r\n")
	CoDisconnectObject((LPUNKNOWN)&lpPseudoObj->m_Unknown, 0);
	OLEDBG_END2

	PseudoObj_Release(lpPseudoObj);     // release artificial AddRef above
	OleDoc_Release(lpOleDoc);           // release artificial AddRef above
	OleApp_Release(lpOleApp);           // release artificial AddRef above

	OLEDBG_END3
	return fStatus;
}


/* PseudoObj_Destroy
** -----------------
**    Destroy (Free) the memory used by a PseudoObj structure.
**    This function is called when the ref count of the PseudoObj goes
**    to zero. the ref cnt goes to zero after PseudoObj_Delete forces
**    the OleObject to unload and release its pointers to the
**    PseudoObj IOleClientSite and IAdviseSink interfaces.
*/

void PseudoObj_Destroy(LPPSEUDOOBJ lpPseudoObj)
{
	LPSERVERDOC lpServerDoc = lpPseudoObj->m_lpDoc;
	LPOLEAPP    lpOleApp = (LPOLEAPP)g_lpApp;
	LPOLEDOC    lpOleDoc = (LPOLEDOC)lpServerDoc;

	OLEDBG_BEGIN3("PseudoObj_Destroy\r\n")

	/* OLE2NOTE: in order to have a stable App, Doc, AND pseudo object
	**    during the process of closing, we intially AddRef the App,
	**    Doc ref counts and later Release them. These
	**    initial AddRefs are artificial; they are simply done to
	**    guarantee that these objects do not get destroyed until the
	**    end of this routine.
	*/
	OleApp_AddRef(lpOleApp);
	OleDoc_AddRef(lpOleDoc);

	/******************************************************************
	** OLE2NOTE: we no longer need the advise and enum holder objects,
	**    so release them.
	******************************************************************/

	if (lpPseudoObj->m_lpDataAdviseHldr) {
		/* release DataAdviseHldr; we SHOULD be the only one using it. */
		OleStdVerifyRelease(
				(LPUNKNOWN)lpPseudoObj->m_lpDataAdviseHldr,
				"DataAdviseHldr not released properly"
			);
		lpPseudoObj->m_lpDataAdviseHldr = NULL;
	}

	if (lpPseudoObj->m_lpOleAdviseHldr) {
		/* release OleAdviseHldr; we SHOULD be the only one using it. */
		OleStdVerifyRelease(
				(LPUNKNOWN)lpPseudoObj->m_lpOleAdviseHldr,
				"OleAdviseHldr not released properly"
			);
		lpPseudoObj->m_lpOleAdviseHldr = NULL;
	}

	/* forget the pointer to destroyed PseudoObj in NameTable */
	if (lpPseudoObj->m_lpName)
		lpPseudoObj->m_lpName->m_lpPseudoObj = NULL;

	/* OLE2NOTE: release the lock on the Doc held on behalf of the
	**    PseudoObj. the Document should not shut down unless all
	**    pseudo objects are closed. when a pseudo object is first
	**    created, it calls ServerDoc_PseudoObjLockDoc to guarantee
	**    that the document stays alive (called from PseudoObj_Init).
	*/
	ServerDoc_PseudoObjUnlockDoc(lpServerDoc, lpPseudoObj);

	Delete(lpPseudoObj);        // Free the memory for the structure itself

	OleDoc_Release(lpOleDoc);       // release artificial AddRef above
	OleApp_Release(lpOleApp);       // release artificial AddRef above

	OLEDBG_END3
}


/* PseudoObj_GetSel
** ----------------
**    Return the line range for the pseudo object
*/
void PseudoObj_GetSel(LPPSEUDOOBJ lpPseudoObj, LPLINERANGE lplrSel)
{
	LPOUTLINENAME lpOutlineName = (LPOUTLINENAME)lpPseudoObj->m_lpName;
	lplrSel->m_nStartLine = lpOutlineName->m_nStartLine;
	lplrSel->m_nEndLine = lpOutlineName->m_nEndLine;
}


/* PseudoObj_GetExtent
 * -------------------
 *
 *      Get the extent (width, height) of the entire document.
 */
void PseudoObj_GetExtent(LPPSEUDOOBJ lpPseudoObj, LPSIZEL lpsizel)
{
	LPOLEDOC lpOleDoc = (LPOLEDOC)lpPseudoObj->m_lpDoc;
	LPLINELIST lpLL = (LPLINELIST)&((LPOUTLINEDOC)lpOleDoc)->m_LineList;
	LINERANGE lrSel;

	PseudoObj_GetSel(lpPseudoObj, (LPLINERANGE)&lrSel);

	LineList_CalcSelExtentInHimetric(lpLL, (LPLINERANGE)&lrSel, lpsizel);
}


/* PseudoObj_SendAdvise
 * --------------------
 *
 * This function sends an advise notification on behalf of a specific
 *  doc object to all its clients.
 */
void PseudoObj_SendAdvise(
		LPPSEUDOOBJ lpPseudoObj,
		WORD        wAdvise,
		LPMONIKER   lpmkObj,
		DWORD       dwAdvf
)
{
	LPOUTLINEDOC lpOutlineDoc = (LPOUTLINEDOC)lpPseudoObj->m_lpDoc;

	switch (wAdvise) {

		case OLE_ONDATACHANGE:

			// inform clients that the data of the object has changed

			if (lpOutlineDoc->m_nDisableDraw == 0) {
				/* drawing is currently enabled. inform clients that
				**    the data of the object has changed
				*/

				lpPseudoObj->m_fDataChanged = FALSE;
				if (lpPseudoObj->m_lpDataAdviseHldr) {

					OLEDBG_BEGIN2("IDataAdviseHolder::SendOnDataChange called\r\n");
					lpPseudoObj->m_lpDataAdviseHldr->lpVtbl->SendOnDataChange(
							lpPseudoObj->m_lpDataAdviseHldr,
							(LPDATAOBJECT)&lpPseudoObj->m_DataObject,
							0,
							dwAdvf
					);
					OLEDBG_END2
				}

			} else {
				/* drawing is currently disabled. do not send
				**    notifications until drawing is re-enabled.
				*/
				lpPseudoObj->m_fDataChanged = TRUE;
			}
			break;

		case OLE_ONCLOSE:

			// inform clients that the object is shutting down

			if (lpPseudoObj->m_lpOleAdviseHldr) {

				OLEDBG_BEGIN2("IOleAdviseHolder::SendOnClose called\r\n");
				lpPseudoObj->m_lpOleAdviseHldr->lpVtbl->SendOnClose(
						lpPseudoObj->m_lpOleAdviseHldr
				);
				OLEDBG_END2
			}
			break;

		case OLE_ONSAVE:

			// inform clients that the object has been saved

			if (lpPseudoObj->m_lpOleAdviseHldr) {

				OLEDBG_BEGIN2("IOleAdviseHolder::SendOnClose called\r\n");
				lpPseudoObj->m_lpOleAdviseHldr->lpVtbl->SendOnSave(
						lpPseudoObj->m_lpOleAdviseHldr
				);
				OLEDBG_END2
			}
			break;

		case OLE_ONRENAME:

			// inform clients that the object's name has changed
			if (lpmkObj && lpPseudoObj->m_lpOleAdviseHldr) {

				OLEDBG_BEGIN2("IOleAdviseHolder::SendOnRename called\r\n");
				if (lpPseudoObj->m_lpOleAdviseHldr)
					lpPseudoObj->m_lpOleAdviseHldr->lpVtbl->SendOnRename(
							lpPseudoObj->m_lpOleAdviseHldr,
							lpmkObj
					);
				OLEDBG_END2
			}
			break;
	}
}


/* PseudoObj_GetFullMoniker
 * ------------------------
 *
 * Returns the Full, absolute Moniker which identifies this pseudo object.
 */
LPMONIKER PseudoObj_GetFullMoniker(LPPSEUDOOBJ lpPseudoObj, LPMONIKER lpmkDoc)
{
	LPOUTLINENAME lpOutlineName = (LPOUTLINENAME)lpPseudoObj->m_lpName;
	LPMONIKER lpmkItem = NULL;
	LPMONIKER lpmkPseudoObj = NULL;

	if (lpmkDoc != NULL) {
		CreateItemMonikerA(OLESTDDELIM,lpOutlineName->m_szName,&lpmkItem);

		/* OLE2NOTE: create an absolute moniker which identifies the
		**    pseudo object. this moniker is created as a composite of
		**    the absolute moniker for the entire document appended
		**    with an item moniker which identifies the selection of
		**    the pseudo object relative to the document.
		*/
		CreateGenericComposite(lpmkDoc, lpmkItem, &lpmkPseudoObj);

		if (lpmkItem)
			OleStdRelease((LPUNKNOWN)lpmkItem);

		return lpmkPseudoObj;
	} else {
		return NULL;
	}
}


/*************************************************************************
** PseudoObj::IUnknown interface implementation
*************************************************************************/

STDMETHODIMP PseudoObj_Unk_QueryInterface(
		LPUNKNOWN         lpThis,
		REFIID            riid,
		LPVOID FAR*       lplpvObj
)
{
	LPPSEUDOOBJ lpPseudoObj =
			((struct CPseudoObjUnknownImpl FAR*)lpThis)->lpPseudoObj;

	return PseudoObj_QueryInterface(lpPseudoObj, riid, lplpvObj);
}


STDMETHODIMP_(ULONG) PseudoObj_Unk_AddRef(LPUNKNOWN lpThis)
{
	LPPSEUDOOBJ lpPseudoObj =
			((struct CPseudoObjUnknownImpl FAR*)lpThis)->lpPseudoObj;

	OleDbgAddRefMethod(lpThis, "IUnknown");

	return PseudoObj_AddRef(lpPseudoObj);
}


STDMETHODIMP_(ULONG) PseudoObj_Unk_Release (LPUNKNOWN lpThis)
{
	LPPSEUDOOBJ lpPseudoObj =
			((struct CPseudoObjUnknownImpl FAR*)lpThis)->lpPseudoObj;

	OleDbgReleaseMethod(lpThis, "IUnknown");

	return PseudoObj_Release(lpPseudoObj);
}


/*************************************************************************
** PseudoObj::IOleObject interface implementation
*************************************************************************/

STDMETHODIMP PseudoObj_OleObj_QueryInterface(
		LPOLEOBJECT     lpThis,
		REFIID          riid,
		LPVOID FAR*     lplpvObj
)
{
	LPPSEUDOOBJ lpPseudoObj =
			((struct CPseudoObjOleObjectImpl FAR*)lpThis)->lpPseudoObj;

	return PseudoObj_QueryInterface(lpPseudoObj, riid, lplpvObj);
}


STDMETHODIMP_(ULONG) PseudoObj_OleObj_AddRef(LPOLEOBJECT lpThis)
{
	LPPSEUDOOBJ lpPseudoObj =
			((struct CPseudoObjOleObjectImpl FAR*)lpThis)->lpPseudoObj;

	OleDbgAddRefMethod(lpThis, "IOleObject");

	return PseudoObj_AddRef((LPPSEUDOOBJ)lpPseudoObj);
}


STDMETHODIMP_(ULONG) PseudoObj_OleObj_Release(LPOLEOBJECT lpThis)
{
	LPPSEUDOOBJ lpPseudoObj =
			((struct CPseudoObjOleObjectImpl FAR*)lpThis)->lpPseudoObj;

	OleDbgReleaseMethod(lpThis, "IOleObject");

	return PseudoObj_Release((LPPSEUDOOBJ)lpPseudoObj);
}


STDMETHODIMP PseudoObj_OleObj_SetClientSite(
		LPOLEOBJECT         lpThis,
		LPOLECLIENTSITE     lpClientSite
)
{
	OleDbgOut2("PseudoObj_OleObj_SetClientSite\r\n");

	// OLE2NOTE: a pseudo object does NOT support SetExtent

	return ResultFromScode(E_FAIL);
}


STDMETHODIMP PseudoObj_OleObj_GetClientSite(
		LPOLEOBJECT             lpThis,
		LPOLECLIENTSITE FAR*    lplpClientSite
)
{
	OleDbgOut2("PseudoObj_OleObj_GetClientSite\r\n");

	*lplpClientSite = NULL;

	// OLE2NOTE: a pseudo object does NOT support SetExtent

	return ResultFromScode(E_FAIL);
}



STDMETHODIMP PseudoObj_OleObj_SetHostNamesA(
		LPOLEOBJECT             lpThis,
		LPCSTR                  szContainerApp,
		LPCSTR                  szContainerObj
)
{
	OleDbgOut2("PseudoObj_OleObj_SetHostNamesA\r\n");

	// OLE2NOTE: a pseudo object does NOT support SetExtent

	return ResultFromScode(E_FAIL);
}


STDMETHODIMP PseudoObj_OleObj_SetHostNames(
		LPOLEOBJECT             lpThis,
		LPCOLESTR		szContainerApp,
		LPCOLESTR		szContainerObj
)
{
	OleDbgOut2("PseudoObj_OleObj_SetHostNames\r\n");

	// OLE2NOTE: a pseudo object does NOT support SetExtent

	return ResultFromScode(E_FAIL);
}


STDMETHODIMP PseudoObj_OleObj_Close(
		LPOLEOBJECT             lpThis,
		DWORD                   dwSaveOption
)
{
	LPPSEUDOOBJ lpPseudoObj =
			((struct CPseudoObjOleObjectImpl FAR*)lpThis)->lpPseudoObj;
	BOOL fStatus;

	OLEDBG_BEGIN2("PseudoObj_OleObj_Close\r\n")

	/* OLE2NOTE: a pseudo object's implementation of IOleObject::Close
	**    should ignore the dwSaveOption parameter. it is NOT
	**    applicable to pseudo objects.
	*/

	fStatus = PseudoObj_Close(lpPseudoObj);
	OleDbgAssertSz(fStatus == TRUE, "PseudoObj_OleObj_Close failed\r\n");

	OLEDBG_END2
	return NOERROR;
}


STDMETHODIMP PseudoObj_OleObj_SetMoniker(
		LPOLEOBJECT lpThis,
		DWORD       dwWhichMoniker,
		LPMONIKER   lpmk
)
{
	OleDbgOut2("PseudoObj_OleObj_SetMoniker\r\n");

	// OLE2NOTE: a pseudo object does NOT support SetMoniker

	return ResultFromScode(E_FAIL);
}


STDMETHODIMP PseudoObj_OleObj_GetMoniker(
		LPOLEOBJECT     lpThis,
		DWORD           dwAssign,
		DWORD           dwWhichMoniker,
		LPMONIKER FAR*  lplpmk
)
{
	LPPSEUDOOBJ lpPseudoObj =
			((struct CPseudoObjOleObjectImpl FAR*)lpThis)->lpPseudoObj;
	LPOLEDOC lpOleDoc = (LPOLEDOC)lpPseudoObj->m_lpDoc;
	LPMONIKER lpmkDoc;

	OLEDBG_BEGIN2("PseudoObj_OleObj_GetMoniker\r\n")

	lpmkDoc = OleDoc_GetFullMoniker(lpOleDoc, GETMONIKER_ONLYIFTHERE);
	*lplpmk = PseudoObj_GetFullMoniker(lpPseudoObj, lpmkDoc);

	OLEDBG_END2

	if (*lplpmk != NULL)
		return NOERROR;
	else
		return ResultFromScode(E_FAIL);
}


STDMETHODIMP PseudoObj_OleObj_InitFromData(
		LPOLEOBJECT             lpThis,
		LPDATAOBJECT            lpDataObject,
		BOOL                    fCreation,
		DWORD                   reserved
)
{
	LPPSEUDOOBJ lpPseudoObj =
			((struct CPseudoObjOleObjectImpl FAR*)lpThis)->lpPseudoObj;
	OleDbgOut2("PseudoObj_OleObj_InitFromData\r\n");

	// REVIEW: NOT YET IMPLEMENTED

	return ResultFromScode(E_NOTIMPL);
}


STDMETHODIMP PseudoObj_OleObj_GetClipboardData(
		LPOLEOBJECT             lpThis,
		DWORD                   reserved,
		LPDATAOBJECT FAR*       lplpDataObject
)
{
	LPPSEUDOOBJ lpPseudoObj =
			((struct CPseudoObjOleObjectImpl FAR*)lpThis)->lpPseudoObj;
	OleDbgOut2("PseudoObj_OleObj_GetClipboardData\r\n");

	// REVIEW: NOT YET IMPLEMENTED

	return ResultFromScode(E_NOTIMPL);
}


STDMETHODIMP PseudoObj_OleObj_DoVerb(
		LPOLEOBJECT             lpThis,
		LONG                    lVerb,
		LPMSG                   lpmsg,
		LPOLECLIENTSITE         lpActiveSite,
		LONG                    lindex,
		HWND                    hwndParent,
		LPCRECT                 lprcPosRect
)
{
	LPPSEUDOOBJ lpPseudoObj =
			((struct CPseudoObjOleObjectImpl FAR*)lpThis)->lpPseudoObj;
	LPOUTLINEDOC lpOutlineDoc = (LPOUTLINEDOC)lpPseudoObj->m_lpDoc;
	LPSERVERDOC lpServerDoc = lpPseudoObj->m_lpDoc;
	LINERANGE lrSel;
	HRESULT hrErr;

	OLEDBG_BEGIN2("PseudoObj_OleObj_DoVerb\r\n");

	/* OLE2NOTE: we must first ask our Document to perform the same
	**    verb. then if the verb is NOT OLEIVERB_HIDE we should also
	**    select the range of our pseudo object.
	**    however, we must give our document its own embedding site as
	**    its active site.
	*/
	hrErr = SvrDoc_OleObj_DoVerb(
			(LPOLEOBJECT)&lpServerDoc->m_OleObject,
			lVerb,
			lpmsg,
			lpServerDoc->m_lpOleClientSite,
			lindex,
			NULL,   /* we have no hwndParent to give */
			NULL    /* we have no lprcPosRect to give */
	);
	if (FAILED(hrErr)) {
		OLEDBG_END2
		return hrErr;
	}

	if (lVerb != OLEIVERB_HIDE) {
		PseudoObj_GetSel(lpPseudoObj, &lrSel);
		OutlineDoc_SetSel(lpOutlineDoc, &lrSel);
	}

	OLEDBG_END2
	return NOERROR;
}



STDMETHODIMP PseudoObj_OleObj_EnumVerbs(
		LPOLEOBJECT         lpThis,
		LPENUMOLEVERB FAR*  lplpenumOleVerb
)
{
	OleDbgOut2("PseudoObj_OleObj_EnumVerbs\r\n");

	/* OLE2NOTE: we must make sure to set all out parameters to NULL. */
	*lplpenumOleVerb = NULL;

	/* A pseudo object may NOT return OLE_S_USEREG; they must call the
	**    OleReg* API or provide their own implementation. Because this
	**    pseudo object does NOT implement IPersist, simply a low-level
	**    remoting handler (ProxyManager) object as opposed to a
	**    DefHandler object is used as the handler for the pseudo
	**    object in a clients process space. The ProxyManager does NOT
	**    handle the OLE_S_USEREG return values.
	*/
	return OleRegEnumVerbs((REFCLSID)&CLSID_APP, lplpenumOleVerb);
}


STDMETHODIMP PseudoObj_OleObj_Update(LPOLEOBJECT lpThis)
{
	OleDbgOut2("PseudoObj_OleObj_Update\r\n");

	/* OLE2NOTE: a server-only app is always "up-to-date".
	**    a container-app which contains links where the link source
	**    has changed since the last update of the link would be
	**    considered "out-of-date". the "Update" method instructs the
	**    object to get an update from any out-of-date links.
	*/

	return NOERROR;
}


STDMETHODIMP PseudoObj_OleObj_IsUpToDate(LPOLEOBJECT lpThis)
{
	LPPSEUDOOBJ lpPseudoObj =
			((struct CPseudoObjOleObjectImpl FAR*)lpThis)->lpPseudoObj;
	OleDbgOut2("PseudoObj_OleObj_IsUpToDate\r\n");

	/* OLE2NOTE: a server-only app is always "up-to-date".
	**    a container-app which contains links where the link source
	**    has changed since the last update of the link would be
	**    considered "out-of-date".
	*/
	return NOERROR;
}


STDMETHODIMP PseudoObj_OleObj_GetUserClassID(
		LPOLEOBJECT             lpThis,
		LPCLSID                 lpclsid
)
{
	LPPSEUDOOBJ lpPseudoObj =
			((struct CPseudoObjOleObjectImpl FAR*)lpThis)->lpPseudoObj;
	LPSERVERDOC lpServerDoc = (LPSERVERDOC)lpPseudoObj->m_lpDoc;
	OleDbgOut2("PseudoObj_OleObj_GetUserClassID\r\n");

	/* OLE2NOTE: we must be carefull to return the correct CLSID here.
	**    if we are currently preforming a "TreatAs (aka. ActivateAs)"
	**    operation then we need to return the class of the object
	**    written in the storage of the object. otherwise we would
	**    return our own class id.
	*/
	return ServerDoc_GetClassID(lpServerDoc, lpclsid);
}


STDMETHODIMP PseudoObj_OleObj_GetUserTypeA(
		LPOLEOBJECT             lpThis,
		DWORD                   dwFormOfType,
		LPSTR FAR*              lpszUserType
)
{
	LPPSEUDOOBJ lpPseudoObj =
			((struct CPseudoObjOleObjectImpl FAR*)lpThis)->lpPseudoObj;
	LPSERVERDOC lpServerDoc = (LPSERVERDOC)lpPseudoObj->m_lpDoc;
	OleDbgOut2("PseudoObj_OleObj_GetUserType\r\n");

	/* OLE2NOTE: we must make sure to set all out parameters to NULL. */
	*lpszUserType = NULL;

	/* OLE2NOTE: we must be carefull to return the correct user type here.
	**    if we are currently preforming a "TreatAs (aka. ActivateAs)"
	**    operation then we need to return the user type name that
	**    corresponds to the class of the object we are currently
	**    emmulating. otherwise we should return our normal user type
	**    name corresponding to our own class. This routine determines
	**    the current clsid in effect.
	**
	**    A pseudo object may NOT return OLE_S_USEREG; they must call the
	**    OleReg* API or provide their own implementation. Because this
	**    pseudo object does NOT implement IPersist, simply a low-level
	**    remoting handler (ProxyManager) object as opposed to a
	**    DefHandler object is used as the handler for the pseudo
	**    object in a clients process space. The ProxyManager does NOT
	**    handle the OLE_S_USEREG return values.
	*/
#if defined( SVR_TREATAS )
	if (! IsEqualCLSID(&lpServerDoc->m_clsidTreatAs, &CLSID_NULL) )
		return OleRegGetUserTypeA(
			&lpServerDoc->m_clsidTreatAs,dwFormOfType,lpszUserType);
	else
#endif  // SVR_TREATAS

	return OleRegGetUserTypeA(&CLSID_APP, dwFormOfType, lpszUserType);
}

STDMETHODIMP PseudoObj_OleObj_GetUserType(
		LPOLEOBJECT             lpThis,
		DWORD                   dwFormOfType,
		LPOLESTR FAR*		lpszUserType
)
{
    LPSTR pstr;

    HRESULT hr = PseudoObj_OleObj_GetUserTypeA(lpThis, dwFormOfType, &pstr);

    CopyAndFreeSTR(pstr, lpszUserType);

    return hr;
}



STDMETHODIMP PseudoObj_OleObj_SetExtent(
		LPOLEOBJECT             lpThis,
		DWORD                   dwDrawAspect,
		LPSIZEL                 lplgrc
)
{
	OleDbgOut2("PseudoObj_OleObj_SetExtent\r\n");

	// OLE2NOTE: a pseudo object does NOT support SetExtent

	return ResultFromScode(E_FAIL);
}


STDMETHODIMP PseudoObj_OleObj_GetExtent(
		LPOLEOBJECT             lpThis,
		DWORD                   dwDrawAspect,
		LPSIZEL                 lpsizel
)
{
	LPPSEUDOOBJ lpPseudoObj =
			((struct CPseudoObjOleObjectImpl FAR*)lpThis)->lpPseudoObj;
	OleDbgOut2("PseudoObj_OleObj_GetExtent\r\n");

	/* OLE2NOTE: it is VERY important to check which aspect the caller
	**    is asking about. an object implemented by a server EXE MAY
	**    fail to return extents when asked for DVASPECT_ICON.
	*/
	if (dwDrawAspect == DVASPECT_CONTENT) {
		PseudoObj_GetExtent(lpPseudoObj, lpsizel);
		return NOERROR;
	}
	else
	{
		return ResultFromScode(E_FAIL);
	}
}


STDMETHODIMP PseudoObj_OleObj_Advise(
		LPOLEOBJECT lpThis,
		LPADVISESINK lpAdvSink,
		LPDWORD lpdwConnection
)
{
	LPPSEUDOOBJ lpPseudoObj =
			((struct CPseudoObjOleObjectImpl FAR*)lpThis)->lpPseudoObj;
	HRESULT hrErr;
	SCODE   sc;
	OLEDBG_BEGIN2("PseudoObj_OleObj_Advise\r\n");

	if (lpPseudoObj->m_lpOleAdviseHldr == NULL &&
		CreateOleAdviseHolder(&lpPseudoObj->m_lpOleAdviseHldr) != NOERROR) {
		sc = E_OUTOFMEMORY;
		goto error;
	}

	OLEDBG_BEGIN2("IOleAdviseHolder::Advise called\r\n")
	hrErr = lpPseudoObj->m_lpOleAdviseHldr->lpVtbl->Advise(
			lpPseudoObj->m_lpOleAdviseHldr,
			lpAdvSink,
			lpdwConnection
	);
	OLEDBG_END2

	OLEDBG_END2
	return hrErr;

error:
	OLEDBG_END2
	return ResultFromScode(sc);
}


STDMETHODIMP PseudoObj_OleObj_Unadvise(LPOLEOBJECT lpThis, DWORD dwConnection)
{
	LPPSEUDOOBJ lpPseudoObj =
			((struct CPseudoObjOleObjectImpl FAR*)lpThis)->lpPseudoObj;
	HRESULT hrErr;
	SCODE   sc;

	OLEDBG_BEGIN2("PseudoObj_OleObj_Unadvise\r\n");

	if (lpPseudoObj->m_lpOleAdviseHldr == NULL) {
		sc = E_FAIL;
		goto error;
	}

	OLEDBG_BEGIN2("IOleAdviseHolder::Unadvise called\r\n")
	hrErr = lpPseudoObj->m_lpOleAdviseHldr->lpVtbl->Unadvise(
			lpPseudoObj->m_lpOleAdviseHldr,
			dwConnection
	);
	OLEDBG_END2

	OLEDBG_END2
	return hrErr;

error:
	OLEDBG_END2
	return ResultFromScode(sc);
}


STDMETHODIMP PseudoObj_OleObj_EnumAdvise(
		LPOLEOBJECT lpThis,
		LPENUMSTATDATA FAR* lplpenumAdvise
)
{
	LPPSEUDOOBJ lpPseudoObj =
			((struct CPseudoObjOleObjectImpl FAR*)lpThis)->lpPseudoObj;
	HRESULT hrErr;
	SCODE   sc;

	OLEDBG_BEGIN2("PseudoObj_OleObj_EnumAdvise\r\n");

	/* OLE2NOTE: we must make sure to set all out parameters to NULL. */
	*lplpenumAdvise = NULL;

	if (lpPseudoObj->m_lpOleAdviseHldr == NULL) {
		sc = E_FAIL;
		goto error;
	}

	OLEDBG_BEGIN2("IOleAdviseHolder::EnumAdvise called\r\n")
	hrErr = lpPseudoObj->m_lpOleAdviseHldr->lpVtbl->EnumAdvise(
			lpPseudoObj->m_lpOleAdviseHldr,
			lplpenumAdvise
	);
	OLEDBG_END2

	OLEDBG_END2
	return hrErr;

error:
	OLEDBG_END2
	return ResultFromScode(sc);
}


STDMETHODIMP PseudoObj_OleObj_GetMiscStatus(
		LPOLEOBJECT             lpThis,
		DWORD                   dwAspect,
		DWORD FAR*              lpdwStatus
)
{
	LPPSEUDOOBJ lpPseudoObj =
			((struct CPseudoObjOleObjectImpl FAR*)lpThis)->lpPseudoObj;
	LPOUTLINEDOC  lpOutlineDoc = (LPOUTLINEDOC)lpPseudoObj->m_lpDoc;
	OleDbgOut2("PseudoObj_OleObj_GetMiscStatus\r\n");

	/* Get our default MiscStatus for the given Aspect. this
	**    information is registered in the RegDB. We query the RegDB
	**    here to guarantee that the value returned from this method
	**    agrees with the values in RegDB. in this way we only have to
	**    maintain the info in one place (in the RegDB). Alternatively
	**    we could have the values hard coded here.
	**
	** OLE2NOTE: A pseudo object may NOT return OLE_S_USEREG; they must
	**    call the
	**    OleReg* API or provide their own implementation. Because this
	**    pseudo object does NOT implement IPersist, simply a low-level
	**    remoting handler (ProxyManager) object as opposed to a
	**    DefHandler object is used as the handler for the pseudo
	**    object in a clients process space. The ProxyManager does NOT
	**    handle the OLE_S_USEREG return values.
	*/
	OleRegGetMiscStatus((REFCLSID)&CLSID_APP, dwAspect, lpdwStatus);

	/* OLE2NOTE: check if the pseudo object is compatible to be
	**    linked by an OLE 1.0 container. it is compatible if
	**    either the pseudo object is an untitled document or a
	**    file-based document. if the pseudo object is part of
	**    an embedded object, then it is NOT compatible to be
	**    linked by an OLE 1.0 container. if it is compatible then
	**    we should include OLEMISC_CANLINKBYOLE1 as part of the
	**    dwStatus flags.
	*/
	if (lpOutlineDoc->m_docInitType == DOCTYPE_NEW ||
		lpOutlineDoc->m_docInitType == DOCTYPE_FROMFILE)
		*lpdwStatus |= OLEMISC_CANLINKBYOLE1;

	return NOERROR;
}


STDMETHODIMP PseudoObj_OleObj_SetColorScheme(
		LPOLEOBJECT             lpThis,
		LPLOGPALETTE            lpLogpal
)
{
	OleDbgOut2("PseudoObj_OleObj_SetColorScheme\r\n");

	// REVIEW: NOT YET IMPLEMENTED

	return ResultFromScode(E_NOTIMPL);
}


/*************************************************************************
** PseudoObj::IDataObject interface implementation
*************************************************************************/

STDMETHODIMP PseudoObj_DataObj_QueryInterface (
		LPDATAOBJECT      lpThis,
		REFIID            riid,
		LPVOID FAR*       lplpvObj
)
{
	LPPSEUDOOBJ lpPseudoObj =
			((struct CPseudoObjDataObjectImpl FAR*)lpThis)->lpPseudoObj;

	return PseudoObj_QueryInterface(lpPseudoObj, riid, lplpvObj);
}


STDMETHODIMP_(ULONG) PseudoObj_DataObj_AddRef(LPDATAOBJECT lpThis)
{
	LPPSEUDOOBJ lpPseudoObj =
			((struct CPseudoObjDataObjectImpl FAR*)lpThis)->lpPseudoObj;

	OleDbgAddRefMethod(lpThis, "IDataObject");

	return PseudoObj_AddRef((LPPSEUDOOBJ)lpPseudoObj);
}


STDMETHODIMP_(ULONG) PseudoObj_DataObj_Release (LPDATAOBJECT lpThis)
{
	LPPSEUDOOBJ lpPseudoObj =
			((struct CPseudoObjDataObjectImpl FAR*)lpThis)->lpPseudoObj;

	OleDbgReleaseMethod(lpThis, "IDataObject");

	return PseudoObj_Release((LPPSEUDOOBJ)lpPseudoObj);
}


STDMETHODIMP PseudoObj_DataObj_GetData (
		LPDATAOBJECT    lpThis,
		LPFORMATETC     lpformatetc,
		LPSTGMEDIUM     lpMedium
)
{
	LPPSEUDOOBJ lpPseudoObj =
			((struct CPseudoObjDataObjectImpl FAR*)lpThis)->lpPseudoObj;
	LPSERVERDOC  lpServerDoc = lpPseudoObj->m_lpDoc;
	LPOUTLINEDOC  lpOutlineDoc = (LPOUTLINEDOC)lpServerDoc;
	LPSERVERAPP lpServerApp = (LPSERVERAPP)g_lpApp;
	LPOLEAPP  lpOleApp = (LPOLEAPP)lpServerApp;
	LPOUTLINEAPP  lpOutlineApp = (LPOUTLINEAPP)lpServerApp;
	LINERANGE lrSel;
	SCODE sc = S_OK;
	OLEDBG_BEGIN2("PseudoObj_DataObj_GetData\r\n")

	PseudoObj_GetSel(lpPseudoObj, &lrSel);

	/* OLE2NOTE: we must make sure to set all out parameters to NULL. */
	lpMedium->tymed = TYMED_NULL;
	lpMedium->pUnkForRelease = NULL;    // we transfer ownership to caller
	lpMedium->hGlobal = NULL;

	if (lpformatetc->cfFormat == lpOutlineApp->m_cfOutline) {
		// Verify caller asked for correct medium
		if (!(lpformatetc->tymed & TYMED_HGLOBAL)) {
			sc = DATA_E_FORMATETC;
			goto error;
		}

		lpMedium->hGlobal = OutlineDoc_GetOutlineData (lpOutlineDoc,&lrSel);
		if (! lpMedium->hGlobal) return ResultFromScode(E_OUTOFMEMORY);
		lpMedium->tymed = TYMED_HGLOBAL;
		OleDbgOut3("PseudoObj_DataObj_GetData: rendered CF_OUTLINE\r\n");

	} else if(lpformatetc->cfFormat == CF_METAFILEPICT &&
		(lpformatetc->dwAspect & DVASPECT_CONTENT) ) {
		// Verify caller asked for correct medium
		if (!(lpformatetc->tymed & TYMED_MFPICT)) {
			sc = DATA_E_FORMATETC;
			goto error;
		}

		lpMedium->hGlobal=ServerDoc_GetMetafilePictData(lpServerDoc,&lrSel);
		if (! lpMedium->hGlobal) {
			sc = E_OUTOFMEMORY;
			goto error;
		}
		lpMedium->tymed = TYMED_MFPICT;
		OleDbgOut3("PseudoObj_DataObj_GetData: rendered CF_METAFILEPICT\r\n");

	} else if (lpformatetc->cfFormat == CF_METAFILEPICT &&
		(lpformatetc->dwAspect & DVASPECT_ICON) ) {
		CLSID clsid;
		// Verify caller asked for correct medium
		if (!(lpformatetc->tymed & TYMED_MFPICT)) {
			sc = DATA_E_FORMATETC;
			goto error;
		}

		/* OLE2NOTE: we should return the default icon for our class.
		**    we must be carefull to use the correct CLSID here.
		**    if we are currently preforming a "TreatAs (aka. ActivateAs)"
		**    operation then we need to use the class of the object
		**    written in the storage of the object. otherwise we would
		**    use our own class id.
		*/
		if (ServerDoc_GetClassID(lpServerDoc, (LPCLSID)&clsid) != NOERROR) {
			sc = DATA_E_FORMATETC;
			goto error;
		}

		lpMedium->hGlobal=GetIconOfClass(
				g_lpApp->m_hInst,(REFCLSID)&clsid, NULL, FALSE);
		if (! lpMedium->hGlobal) {
			sc = E_OUTOFMEMORY;
			goto error;
		}

		lpMedium->tymed = TYMED_MFPICT;
		OleDbgOut3("PseudoObj_DataObj_GetData: rendered CF_METAFILEPICT (icon)\r\n");
		return NOERROR;

	} else if (lpformatetc->cfFormat == CF_TEXT) {
		// Verify caller asked for correct medium
		if (!(lpformatetc->tymed & TYMED_HGLOBAL)) {
			sc = DATA_E_FORMATETC;
			goto error;
		}

		lpMedium->hGlobal = OutlineDoc_GetTextData (lpOutlineDoc, &lrSel);
		if (! lpMedium->hGlobal) {
			sc = E_OUTOFMEMORY;
			goto error;
		}
		lpMedium->tymed = TYMED_HGLOBAL;
		OleDbgOut3("PseudoObj_DataObj_GetData: rendered CF_TEXT\r\n");

	} else {
		sc = DATA_E_FORMATETC;
		goto error;
	}

	OLEDBG_END2
	return NOERROR;

error:
	OLEDBG_END2
	return ResultFromScode(sc);
}


STDMETHODIMP PseudoObj_DataObj_GetDataHere (
		LPDATAOBJECT    lpThis,
		LPFORMATETC     lpformatetc,
		LPSTGMEDIUM     lpMedium
)
{
	LPPSEUDOOBJ lpPseudoObj =
			((struct CPseudoObjDataObjectImpl FAR*)lpThis)->lpPseudoObj;
	LPSERVERDOC  lpServerDoc = lpPseudoObj->m_lpDoc;
	LPOUTLINEDOC  lpOutlineDoc = (LPOUTLINEDOC)lpServerDoc;
	LPSERVERAPP lpServerApp = (LPSERVERAPP)g_lpApp;
	LPOLEAPP  lpOleApp = (LPOLEAPP)lpServerApp;
	LPOUTLINEAPP  lpOutlineApp = (LPOUTLINEAPP)lpServerApp;
	OleDbgOut("PseudoObj_DataObj_GetDataHere\r\n");

	/* Caller is requesting data to be returned in Caller allocated
	**    medium, but we do NOT support this. we only support
	**    global memory blocks that WE allocate for the caller.
	*/
	return ResultFromScode(DATA_E_FORMATETC);
}


STDMETHODIMP PseudoObj_DataObj_QueryGetData (
		LPDATAOBJECT    lpThis,
		LPFORMATETC     lpformatetc
)
{
	LPPSEUDOOBJ lpPseudoObj =
			((struct CPseudoObjDataObjectImpl FAR*)lpThis)->lpPseudoObj;
	LPSERVERDOC  lpServerDoc = lpPseudoObj->m_lpDoc;
	LPOUTLINEDOC  lpOutlineDoc = (LPOUTLINEDOC)lpServerDoc;
	LPSERVERAPP lpServerApp = (LPSERVERAPP)g_lpApp;
	LPOLEAPP  lpOleApp = (LPOLEAPP)lpServerApp;
	LPOUTLINEAPP  lpOutlineApp = (LPOUTLINEAPP)lpServerApp;
	OleDbgOut2("PseudoObj_DataObj_QueryGetData\r\n");

	/* Caller is querying if we support certain format but does not
	**    want any data actually returned.
	*/
	if (lpformatetc->cfFormat == CF_METAFILEPICT &&
		(lpformatetc->dwAspect & (DVASPECT_CONTENT | DVASPECT_ICON)) ) {
		return OleStdQueryFormatMedium(lpformatetc, TYMED_MFPICT);

	} else if (lpformatetc->cfFormat == (lpOutlineApp)->m_cfOutline ||
			lpformatetc->cfFormat == CF_TEXT) {
		return OleStdQueryFormatMedium(lpformatetc, TYMED_HGLOBAL);
	}

	return ResultFromScode(DATA_E_FORMATETC);
}


STDMETHODIMP PseudoObj_DataObj_GetCanonicalFormatEtc(
		LPDATAOBJECT    lpThis,
		LPFORMATETC     lpformatetc,
		LPFORMATETC     lpformatetcOut
)
{
	HRESULT hrErr;
	OleDbgOut2("PseudoObj_DataObj_GetCanonicalFormatEtc\r\n");

	if (!lpformatetcOut)
		return ResultFromScode(E_INVALIDARG);

	/* OLE2NOTE: we must make sure to set all out parameters to NULL. */
	lpformatetcOut->ptd = NULL;

	if (!lpformatetc)
		return ResultFromScode(E_INVALIDARG);

	// OLE2NOTE: we must validate that the format requested is supported
	if ((hrErr=lpThis->lpVtbl->QueryGetData(lpThis,lpformatetc)) != NOERROR)
		return hrErr;

	/* OLE2NOTE: an app that is insensitive to target device (as the
	**    Outline Sample is) should fill in the lpformatOut parameter
	**    but NULL out the "ptd" field; it should return NOERROR if the
	**    input formatetc->ptd what non-NULL. this tells the caller
	**    that it is NOT necessary to maintain a separate screen
	**    rendering and printer rendering. if should return
	**    DATA_S_SAMEFORMATETC if the input and output formatetc's are
	**    identical.
	*/

	*lpformatetcOut = *lpformatetc;
	if (lpformatetc->ptd == NULL)
		return ResultFromScode(DATA_S_SAMEFORMATETC);
	else {
		lpformatetcOut->ptd = NULL;
		return NOERROR;
	}
}


STDMETHODIMP PseudoObj_DataObj_SetData (
		LPDATAOBJECT    lpThis,
		LPFORMATETC     lpformatetc,
		LPSTGMEDIUM     lpmedium,
		BOOL            fRelease
)
{
	LPPSEUDOOBJ lpPseudoObj =
			((struct CPseudoObjDataObjectImpl FAR*)lpThis)->lpPseudoObj;
	LPSERVERDOC  lpServerDoc = lpPseudoObj->m_lpDoc;
	LPOUTLINEDOC  lpOutlineDoc = (LPOUTLINEDOC)lpServerDoc;
	LPSERVERAPP lpServerApp = (LPSERVERAPP)g_lpApp;

	OleDbgOut2("PseudoObj_DataObj_SetData\r\n");

	// REVIEW: NOT-YET-IMPLEMENTED
	return ResultFromScode(E_NOTIMPL);
}


STDMETHODIMP PseudoObj_DataObj_EnumFormatEtc(
		LPDATAOBJECT            lpThis,
		DWORD                   dwDirection,
		LPENUMFORMATETC FAR*    lplpenumFormatEtc
)
{
	SCODE sc;
	OleDbgOut2("PseudoObj_DataObj_EnumFormatEtc\r\n");

	/* OLE2NOTE: a pseudo object only needs to enumerate the static list
	**    of formats that are registered for our app in the
	**    registration database. it is NOT
	**    required that a pseudo object (ie. non-DataTransferDoc)
	**    enumerate the OLE formats: CF_LINKSOURCE, CF_EMBEDSOURCE, or
	**    CF_EMBEDDEDOBJECT. we do NOT use pseudo objects for data
	**    transfers.
	**
	**    A pseudo object may NOT return OLE_S_USEREG; they must call the
	**    OleReg* API or provide their own implementation. Because this
	**    pseudo object does NOT implement IPersist, simply a low-level
	**    remoting handler (ProxyManager) object as opposed to a
	**    DefHandler object is used as the handler for the pseudo
	**    object in a clients process space. The ProxyManager does NOT
	**    handle the OLE_S_USEREG return values.
	*/
	if (dwDirection == DATADIR_GET)
		return OleRegEnumFormatEtc(
				(REFCLSID)&CLSID_APP, dwDirection, lplpenumFormatEtc);
	else if (dwDirection == DATADIR_SET)
		sc = E_NOTIMPL;
	else
		sc = E_INVALIDARG;

	return ResultFromScode(sc);
}


STDMETHODIMP PseudoObj_DataObj_DAdvise(
		LPDATAOBJECT    lpThis,
		FORMATETC FAR*  lpFormatetc,
		DWORD           advf,
		LPADVISESINK    lpAdvSink,
		DWORD FAR*      lpdwConnection
)
{
	LPPSEUDOOBJ lpPseudoObj =
			((struct CPseudoObjDataObjectImpl FAR*)lpThis)->lpPseudoObj;
	HRESULT hrErr;
	SCODE   sc;

	OLEDBG_BEGIN2("PseudoObj_DataObj_DAdvise\r\n")

	/* OLE2NOTE: we must make sure to set all out parameters to NULL. */
	*lpdwConnection = 0;

	/* OLE2NOTE: we should validate if the caller is setting up an
	**    Advise for a data type that we support. we must
	**    explicitly allow an advise for the "wildcard" advise.
	*/
	if ( !( lpFormatetc->cfFormat == 0 &&
		lpFormatetc->ptd == NULL &&
		lpFormatetc->dwAspect == -1L &&
		lpFormatetc->lindex == -1L &&
		lpFormatetc->tymed == -1L) &&
		(hrErr = PseudoObj_DataObj_QueryGetData(lpThis, lpFormatetc))
			!= NOERROR) {
		sc = GetScode(hrErr);
		goto error;
	}

	if (lpPseudoObj->m_lpDataAdviseHldr == NULL &&
		CreateDataAdviseHolder(&lpPseudoObj->m_lpDataAdviseHldr) != NOERROR) {
		sc = E_OUTOFMEMORY;
		goto error;
	}

	OLEDBG_BEGIN2("IOleAdviseHolder::Advise called\r\n")
	hrErr = lpPseudoObj->m_lpDataAdviseHldr->lpVtbl->Advise(
			lpPseudoObj->m_lpDataAdviseHldr,
			(LPDATAOBJECT)&lpPseudoObj->m_DataObject,
			lpFormatetc,
			advf,
			lpAdvSink,
			lpdwConnection
	);
	OLEDBG_END2

	OLEDBG_END2
	return hrErr;

error:
	OLEDBG_END2
	return ResultFromScode(sc);
}


STDMETHODIMP PseudoObj_DataObj_DUnadvise(LPDATAOBJECT lpThis, DWORD dwConnection)
{
	LPPSEUDOOBJ lpPseudoObj =
			((struct CPseudoObjDataObjectImpl FAR*)lpThis)->lpPseudoObj;
	HRESULT hrErr;
	SCODE   sc;

	OLEDBG_BEGIN2("PseudoObj_DataObj_Unadvise\r\n");

	// no one registered
	if (lpPseudoObj->m_lpDataAdviseHldr == NULL) {
		sc = E_FAIL;
		goto error;
	}

	OLEDBG_BEGIN2("IOleAdviseHolder::DUnadvise called\r\n")
	hrErr = lpPseudoObj->m_lpDataAdviseHldr->lpVtbl->Unadvise(
			lpPseudoObj->m_lpDataAdviseHldr,
			dwConnection
	);
	OLEDBG_END2

	OLEDBG_END2
	return hrErr;

error:
	OLEDBG_END2
	return ResultFromScode(sc);
}


STDMETHODIMP PseudoObj_DataObj_EnumAdvise(
		LPDATAOBJECT lpThis,
		LPENUMSTATDATA FAR* lplpenumAdvise
)
{
	LPPSEUDOOBJ lpPseudoObj =
			((struct CPseudoObjDataObjectImpl FAR*)lpThis)->lpPseudoObj;
	HRESULT hrErr;
	SCODE   sc;

	OLEDBG_BEGIN2("PseudoObj_DataObj_EnumAdvise\r\n");

	/* OLE2NOTE: we must make sure to set all out parameters to NULL. */
	*lplpenumAdvise = NULL;

	if (lpPseudoObj->m_lpDataAdviseHldr == NULL) {
		sc = E_FAIL;
		goto error;
	}

	OLEDBG_BEGIN2("IOleAdviseHolder::EnumAdvise called\r\n")
	hrErr = lpPseudoObj->m_lpDataAdviseHldr->lpVtbl->EnumAdvise(
			lpPseudoObj->m_lpDataAdviseHldr,
			lplpenumAdvise
	);
	OLEDBG_END2

	OLEDBG_END2
	return hrErr;

error:
	OLEDBG_END2
	return ResultFromScode(sc);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\letest\outline\isvrotl\chicago\makefile.inc ===
copyfiles:
    xcopy ..\..\*.c . /D
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\letest\outline\isvrotl\daytona\makefile.inc ===
copyfiles:
    xcopy ..\..\*.c . /D
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\letest\outline\svroutl\chicago\makefile.inc ===
copyfiles:
    xcopy ..\..\*.c . /D
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\letest\outline\svroutl\daytona\makefile.inc ===
copyfiles:
    xcopy ..\..\*.c . /D
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\letest\outline\tests.c ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File: 	tests.c
//
//  Contents:  	unit tests for 32bit OLE
//
//  Classes:
//
//  Functions:	StartClipboardTest1
//
//  History:    dd-mmm-yy Author    Comment
//		16-Jun-94 alexgo    author
//
//--------------------------------------------------------------------------

#include "outline.h"

//+-------------------------------------------------------------------------
//
//  Function:  	StartClipboardTest1
//
//  Synopsis:  	copies the loaded object to the clipboard
//
//  Effects:
//
//  Arguments:	void
//
//  Requires:
//
//  Returns: 	void
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//  		16-Jun-94 alexgo    author
//
//  Notes:
//
//--------------------------------------------------------------------------

void StartClipboardTest1( LPOUTLINEAPP lpOutlineApp)
{
        static char FileName[] = "letest12.olc";
	BOOL fStatus;
	HRESULT	hresult = ResultFromScode(E_FAIL);

	lpOutlineApp->m_lpDoc = OutlineApp_CreateDoc(lpOutlineApp, FALSE);
	if (! lpOutlineApp->m_lpDoc)
	{
		goto errRtn;
	}

	fStatus = OutlineDoc_LoadFromFile(lpOutlineApp->m_lpDoc,
			FileName);

	if( !fStatus )
	{
		hresult = ResultFromScode(STG_E_FILENOTFOUND);
		goto errRtn;
	}



	// position and size the new doc window
	OutlineApp_ResizeWindows(lpOutlineApp);
	OutlineDoc_ShowWindow(lpOutlineApp->m_lpDoc);


	// we post a message here to give outline a chance to setup its
	// UI before we do the copy.

	UpdateWindow(lpOutlineApp->m_hWndApp);
	OutlineDoc_SelectAllCommand(lpOutlineApp->m_lpDoc);

	PostMessage(lpOutlineApp->m_hWndApp, WM_TEST2, 0, 0);

	return;

errRtn:

	// we should abort if error
	PostMessage(g_hwndDriver, WM_TESTEND, TEST_FAILURE, hresult);
	PostMessage(lpOutlineApp->m_hWndApp, WM_SYSCOMMAND, SC_CLOSE, 0L);


}

//+-------------------------------------------------------------------------
//
//  Function: 	ContinueClipboardTest1
//
//  Synopsis:	finishes up the clipboard test
//
//  Effects:
//
//  Arguments:
//
//  Requires:
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//	   	16-Jun-94 alexgo    author
//  Notes:
//
//--------------------------------------------------------------------------

void ContinueClipboardTest1( LPOUTLINEAPP lpOutlineApp )
{
	OutlineDoc_CopyCommand(lpOutlineApp->m_lpDoc);

	OleApp_FlushClipboard((LPOLEAPP)lpOutlineApp);

	//flushing will make the app dirty, just reset that here ;-)

	lpOutlineApp->m_lpDoc->m_fModified = FALSE;
	
	PostMessage(g_hwndDriver, WM_TEST1, NOERROR, 0);
	PostMessage(lpOutlineApp->m_hWndApp, WM_SYSCOMMAND, SC_CLOSE, 0L);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\letest\outline\svrbase.c ===
/*************************************************************************
**
**    OLE 2 Server Sample Code
**
**    svrbase.c
**
**    This file contains all interfaces, methods and related support
**    functions for the basic OLE Object (Server) application. The
**    basic OLE Object application supports embedding an object and
**    linking to a file-based or embedded object as a whole. The basic
**    Object application includes the following implementation objects:
**
**    ClassFactory (aka. ClassObject) Object    (see file classfac.c)
**      exposed interfaces:
**          IClassFactory interface
**
**    ServerDoc Object
**      exposed interfaces:
**          IUnknown
**          IOleObject interface
**          IPersistStorage interface
**          IDataObject interface
**
**    ServerApp Object
**      exposed interfaces:
**          IUnknown
**
**    (c) Copyright Microsoft Corp. 1992 - 1993 All Rights Reserved
**
*************************************************************************/


#include "outline.h"

OLEDBGDATA

extern LPOUTLINEAPP             g_lpApp;
extern IOleObjectVtbl           g_SvrDoc_OleObjectVtbl;
extern IPersistStorageVtbl      g_SvrDoc_PersistStorageVtbl;

#if defined( INPLACE_SVR )
extern IOleInPlaceObjectVtbl        g_SvrDoc_OleInPlaceObjectVtbl;
extern IOleInPlaceActiveObjectVtbl  g_SvrDoc_OleInPlaceActiveObjectVtbl;
#endif  // INPLACE_SVR

#if defined( SVR_TREATAS )
extern IStdMarshalInfoVtbl      g_SvrDoc_StdMarshalInfoVtbl;
#endif  // SVR_TREATAS


// REVIEW: should use string resource for messages
extern char ErrMsgSaving[];
extern char ErrMsgFormatNotSupported[];
static char ErrMsgPSSaveFail[] = "PSSave failed";
static char ErrMsgLowMemNClose[] = "Warning OUT OF MEMORY! We must close down";
extern char g_szUpdateCntrDoc[] = "&Update %s";
extern char g_szExitNReturnToCntrDoc[] = "E&xit && Return to %s";


/*************************************************************************
** ServerDoc::IOleObject interface implementation
*************************************************************************/

// IOleObject::QueryInterface method

STDMETHODIMP SvrDoc_OleObj_QueryInterface(
		LPOLEOBJECT             lpThis,
		REFIID                  riid,
		LPVOID FAR*             lplpvObj
)
{
	LPSERVERDOC lpServerDoc =
			((struct CDocOleObjectImpl FAR*)lpThis)->lpServerDoc;

	return OleDoc_QueryInterface((LPOLEDOC)lpServerDoc, riid, lplpvObj);
}


// IOleObject::AddRef method

STDMETHODIMP_(ULONG) SvrDoc_OleObj_AddRef(LPOLEOBJECT lpThis)
{
	LPSERVERDOC lpServerDoc =
			((struct CDocOleObjectImpl FAR*)lpThis)->lpServerDoc;

	OleDbgAddRefMethod(lpThis, "IOleObject");

	return OleDoc_AddRef((LPOLEDOC)lpServerDoc);
}


// IOleObject::Release method

STDMETHODIMP_(ULONG) SvrDoc_OleObj_Release(LPOLEOBJECT lpThis)
{
	LPSERVERDOC lpServerDoc =
			((struct CDocOleObjectImpl FAR*)lpThis)->lpServerDoc;

	OleDbgReleaseMethod(lpThis, "IOleObject");

	return OleDoc_Release((LPOLEDOC)lpServerDoc);
}


// IOleObject::SetClientSite method

STDMETHODIMP SvrDoc_OleObj_SetClientSite(
		LPOLEOBJECT             lpThis,
		LPOLECLIENTSITE         lpclientSite
)
{
	LPSERVERDOC lpServerDoc =
			((struct CDocOleObjectImpl FAR*)lpThis)->lpServerDoc;
	LPOUTLINEDOC lpOutlineDoc = (LPOUTLINEDOC)lpServerDoc;

	OLEDBG_BEGIN2("SvrDoc_OleObj_SetClientSite\r\n")

	// SetClientSite is only valid to call on an embedded object
	if (lpOutlineDoc->m_docInitType != DOCTYPE_EMBEDDED) {
		OleDbgAssert(lpOutlineDoc->m_docInitType == DOCTYPE_EMBEDDED);
		OLEDBG_END2
		return ResultFromScode(E_UNEXPECTED);
	}

	/* if we currently have a client site ptr, then release it. */
	if (lpServerDoc->m_lpOleClientSite)
		OleStdRelease((LPUNKNOWN)lpServerDoc->m_lpOleClientSite);

	lpServerDoc->m_lpOleClientSite = (LPOLECLIENTSITE) lpclientSite;
	// OLE2NOTE: to be able to hold onto clientSite pointer, we must AddRef it
	if (lpclientSite)
		lpclientSite->lpVtbl->AddRef(lpclientSite);

	OLEDBG_END2
	return NOERROR;
}


// IOleObject::GetClientSite method

STDMETHODIMP SvrDoc_OleObj_GetClientSite(
		LPOLEOBJECT             lpThis,
		LPOLECLIENTSITE FAR*    lplpClientSite
)
{
	LPSERVERDOC lpServerDoc =
			((struct CDocOleObjectImpl FAR*)lpThis)->lpServerDoc;
	OleDbgOut2("SvrDoc_OleObj_GetClientSite\r\n");

	/* OLE2NOTE: we MUST AddRef this interface pointer to give the
	**    caller a personal copy of the pointer
	*/
	lpServerDoc->m_lpOleClientSite->lpVtbl->AddRef(
			lpServerDoc->m_lpOleClientSite
	);
	*lplpClientSite = lpServerDoc->m_lpOleClientSite;

	return NOERROR;

}


// IOleObject::SetHostNames method

STDMETHODIMP SvrDoc_OleObj_SetHostNamesA(
		LPOLEOBJECT             lpThis,
		LPCSTR                  szContainerApp,
		LPCSTR                  szContainerObj
)
{
	LPSERVERDOC lpServerDoc =
			((struct CDocOleObjectImpl FAR*)lpThis)->lpServerDoc;
	LPOUTLINEDOC    lpOutlineDoc = (LPOUTLINEDOC)lpServerDoc;
	OleDbgOut2("SvrDoc_OleObj_SetHostNames\r\n");

	LSTRCPYN((LPSTR)lpServerDoc->m_szContainerApp, szContainerApp,
			sizeof(lpServerDoc->m_szContainerApp));
	LSTRCPYN((LPSTR)lpServerDoc->m_szContainerObj, szContainerObj,
			sizeof(lpServerDoc->m_szContainerObj));

	/* The Window title for an embedded object is constructed as
	**    follows:
	**      <server app name> - <obj short type> in <cont. doc name>
	**
	**    here we construct the current document title portion of the
	**    name which follows the '-'. OutlineDoc_SetTitle prepends the
	**    "<server app name> - " to the document title.
	*/
	// REVIEW: this string should be loaded from string resource
	wsprintf(lpOutlineDoc->m_szFileName, "%s in %s",
			(LPSTR)SHORTUSERTYPENAME, (LPSTR)lpServerDoc->m_szContainerObj);

	lpOutlineDoc->m_lpszDocTitle = lpOutlineDoc->m_szFileName;
	OutlineDoc_SetTitle(lpOutlineDoc, FALSE /*fMakeUpperCase*/);

	/* OLE2NOTE: update the application menus correctly for an embedded
	**    object. the changes include:
	**      1 Remove File/New and File/Open (SDI ONLY)
	**      2 Change File/Save As.. to File/Save Copy As..
	**      3 Change File menu so it contains "Update" instead of "Save"
	**      4 Change File/Exit to File/Exit & Return to <client doc>"
	*/
	ServerDoc_UpdateMenu(lpServerDoc);

	return NOERROR;
}

STDMETHODIMP SvrDoc_OleObj_SetHostNames(
		LPOLEOBJECT             lpThis,
		LPCOLESTR		szContainerApp,
		LPCOLESTR		szContainerObj
)
{
    CREATESTR(pstrApp, szContainerApp)
    CREATESTR(pstrObj, szContainerObj)

    HRESULT hr = SvrDoc_OleObj_SetHostNamesA(lpThis, pstrApp, pstrObj);

    FREESTR(pstrApp)
    FREESTR(pstrObj)

    return hr;
}



// IOleObject::Close method

STDMETHODIMP SvrDoc_OleObj_Close(
		LPOLEOBJECT             lpThis,
		DWORD                   dwSaveOption
)
{
	LPSERVERDOC lpServerDoc =
			((struct CDocOleObjectImpl FAR*)lpThis)->lpServerDoc;
	BOOL fStatus;

	OLEDBG_BEGIN2("SvrDoc_OleObj_Close\r\n")

	/* OLE2NOTE: the OLE 2.0 user model is that embedded objects should
	**    always be saved when closed WITHOUT any prompting to the
	**    user. this is the recommendation irregardless of whether the
	**    object is activated in-place or open in its own window.
	**    this is a CHANGE from the OLE 1.0 user model where it
	**    was the guideline that servers always prompt to save changes.
	**    thus OLE 2.0 compound document oriented container's should
	**    always pass dwSaveOption==OLECLOSE_SAVEIFDIRTY. it is
	**    possible that for programmatic uses a container may want to
	**    specify a different dwSaveOption. the implementation of
	**    various save options can be tricky, particularly considering
	**    cases involving in-place activation. the following would be
	**    reasonable behavior:
	**
	**      (1) OLECLOSE_SAVEIFDIRTY: if dirty, save. close.
	**      (2) OLECLOSE_NOSAVE: close.
	**      (3) OLECLOSE_PROMPTSAVE:
	**        (a) object visible, but not in-place:
	**               if not dirty, close.
	**               switch(prompt)
	**                  case IDYES: save. close.
	**                  case IDNO: close.
	**                  case IDCANCEL: return OLE_E_PROMPTSAVECANCELLED
	**        (b) object invisible (includes UIDeactivated object)
	**               if dirty, save. close.
	**               NOTE: NO PROMPT. it is not appropriate to prompt
	**                     if the object is not visible.
	**        (c) object is in-place active:
	**               if dirty, save. close.
	**               NOTE: NO PROMPT. it is not appropriate to prompt
	**                     if the object is active in-place.
	*/
	fStatus = OutlineDoc_Close((LPOUTLINEDOC)lpServerDoc, dwSaveOption);
	OleDbgAssertSz(fStatus == TRUE, "SvrDoc_OleObj_Close failed\r\n");

	OLEDBG_END2
	return (fStatus ? NOERROR : ResultFromScode(E_FAIL));
}


// IOleObject::SetMoniker method

STDMETHODIMP SvrDoc_OleObj_SetMoniker(
		LPOLEOBJECT             lpThis,
		DWORD                   dwWhichMoniker,
		LPMONIKER               lpmk
)
{
	LPSERVERDOC lpServerDoc =
			((struct CDocOleObjectImpl FAR*)lpThis)->lpServerDoc;
	LPOLEDOC lpOleDoc = (LPOLEDOC)lpServerDoc;
	LPOUTLINEDOC lpOutlineDoc = (LPOUTLINEDOC)lpServerDoc;
	LPMONIKER lpmkFull = NULL;
	HRESULT hrErr;
	SCODE sc;

	OLEDBG_BEGIN2("SvrDoc_OleObj_SetMoniker\r\n")

	/* OLE2NOTE: if our full moniker is passed then we can use it,
	**    otherwise we must call back to our ClientSite to get our full
	**    moniker.
	*/
	if (dwWhichMoniker == OLEWHICHMK_OBJFULL) {

		/* Register the document as running with the new moniker and
		**      notify any clients that our moniker has changed.
		*/
		OleDoc_DocRenamedUpdate(lpOleDoc, lpmk);

		if (lpOutlineDoc->m_docInitType != DOCTYPE_EMBEDDED) {
			IBindCtx  FAR  *pbc = NULL;
			LPSTR lpszName = NULL;

			/* OLE2NOTE: if this is a FILE-based or untitled document
			**    then we should accept this new moniker as our document's
			**    moniker. we will remember this moniker instead of the
			**    FileMoniker that we have by default. this allows
			**    systems that use special monikers to track the
			**    location of documents to inform a document that is a
			**    link source of its special moniker. this enables the
			**    document to use this special moniker when building
			**    composite monikers to identify contained objects and
			**    pseudo objects (ranges).
			**
			**    we should also use the DisplayName form of this
			**    moniker as our document name in our window title.
			*/
			if (lpOleDoc->m_lpFileMoniker) {
				lpOleDoc->m_lpFileMoniker->lpVtbl->Release(
						lpOleDoc->m_lpFileMoniker);
			}
			lpOleDoc->m_lpFileMoniker = lpmk;
			// we must AddRef the moniker to hold on to it
			lpmk->lpVtbl->AddRef(lpmk);

			/* we should also use the DisplayName form of this
			**    moniker as our document name in our window title.
			*/
			CreateBindCtx(0, (LPBC FAR*)&pbc);
			CallIMonikerGetDisplayNameA(lpmk,pbc,NULL,&lpszName);
			pbc->lpVtbl->Release(pbc);
			if (lpszName) {
				LSTRCPYN(lpOutlineDoc->m_szFileName, lpszName,
						sizeof(lpOutlineDoc->m_szFileName));
				lpOutlineDoc->m_lpszDocTitle = lpOutlineDoc->m_szFileName;
				OutlineDoc_SetTitle(lpOutlineDoc, FALSE /*fMakeUpperCase*/);
				OleStdFreeString(lpszName, NULL);
			}
		}

		OLEDBG_END2
		return NOERROR;
	}

	/* if the passed moniker was NOT a full moniker then we must call
	**    back to our ClientSite to get our full moniker. this is
	**    needed in order to register in the RunningObjectTable. if we
	**    don't have a ClientSite then this is an error.
	*/
	if (lpServerDoc->m_lpOleClientSite == NULL) {
		sc = E_FAIL;
		goto error;
	}

	hrErr = lpServerDoc->m_lpOleClientSite->lpVtbl->GetMoniker(
			lpServerDoc->m_lpOleClientSite,
			OLEGETMONIKER_ONLYIFTHERE,
			OLEWHICHMK_OBJFULL,
			&lpmkFull
	);
	if (hrErr != NOERROR) {
		sc = GetScode(hrErr);
		goto error;
	}

	/* Register the document as running with the new moniker and
	**      notify any clients that our moniker has changed.
	*/
	OleDoc_DocRenamedUpdate(lpOleDoc, lpmkFull);

	if (lpmkFull)
		OleStdRelease((LPUNKNOWN)lpmkFull);

	OLEDBG_END2
	return NOERROR;

error:
	OLEDBG_END2
	return ResultFromScode(sc);
}


// IOleObject::GetMoniker method

STDMETHODIMP SvrDoc_OleObj_GetMoniker(
		LPOLEOBJECT             lpThis,
		DWORD                   dwAssign,
		DWORD                   dwWhichMoniker,
		LPMONIKER FAR*          lplpmk
)
{
	LPSERVERDOC lpServerDoc =
			((struct CDocOleObjectImpl FAR*)lpThis)->lpServerDoc;
	LPOLEDOC lpOleDoc = (LPOLEDOC)lpServerDoc;
	SCODE sc;

	OLEDBG_BEGIN2("SvrDoc_OleObj_GetMoniker\r\n")

	/* OLE2NOTE: we must make sure to set all out parameters to NULL. */
	*lplpmk = NULL;

	if (lpServerDoc->m_lpOleClientSite) {

		/* document is an embedded object. retrieve our moniker from
		**    our container.
		*/
		OLEDBG_BEGIN2("IOleClientSite::GetMoniker called\r\n")
		sc = GetScode( lpServerDoc->m_lpOleClientSite->lpVtbl->GetMoniker(
				lpServerDoc->m_lpOleClientSite,
				dwAssign,
				dwWhichMoniker,
				lplpmk
		) );
		OLEDBG_END2

	} else if (lpOleDoc->m_lpFileMoniker) {

		/* document is a top-level user document (either
		**    file-based or untitled). return the FileMoniker stored
		**    with the document; it uniquely identifies the document.
		*/
		if (dwWhichMoniker == OLEWHICHMK_CONTAINER)
			sc = E_INVALIDARG;  // file-based object has no CONTAINER moniker
		else {
			*lplpmk = lpOleDoc->m_lpFileMoniker;
			(*lplpmk)->lpVtbl->AddRef(*lplpmk); // must AddRef to pass out ptr
			sc = S_OK;
		}

	} else {
		// document is not yet fully initialized => no moniker
		sc = E_FAIL;
	}

	OLEDBG_END2
	return ResultFromScode(sc);
}


// IOleObject::InitFromData method

STDMETHODIMP SvrDoc_OleObj_InitFromData(
		LPOLEOBJECT             lpThis,
		LPDATAOBJECT            lpDataObject,
		BOOL                    fCreation,
		DWORD                   reserved
)
{
	LPSERVERDOC lpServerDoc =
			((struct CDocOleObjectImpl FAR*)lpThis)->lpServerDoc;

	OLEDBG_BEGIN2("SvrDoc_OleObj_InitFromData\r\n")

	// REVIEW: NOT YET IMPLEMENTED

	OLEDBG_END2
	return ResultFromScode(E_NOTIMPL);
}


// IOleObject::GetClipboardData method

STDMETHODIMP SvrDoc_OleObj_GetClipboardData(
		LPOLEOBJECT             lpThis,
		DWORD                   reserved,
		LPDATAOBJECT FAR*       lplpDataObject
)
{
	LPSERVERDOC lpServerDoc =
			((struct CDocOleObjectImpl FAR*)lpThis)->lpServerDoc;

	OLEDBG_BEGIN2("SvrDoc_OleObj_GetClipboardData\r\n")

	// REVIEW: NOT YET IMPLEMENTED

	OLEDBG_END2
	return ResultFromScode(E_NOTIMPL);
}


// IOleObject::DoVerb method

STDMETHODIMP SvrDoc_OleObj_DoVerb(
		LPOLEOBJECT             lpThis,
		LONG                    lVerb,
		LPMSG                   lpmsg,
		LPOLECLIENTSITE         lpActiveSite,
		LONG                    lindex,
		HWND                    hwndParent,
		LPCRECT                 lprcPosRect
)
{
	LPSERVERDOC lpServerDoc =
			((struct CDocOleObjectImpl FAR*)lpThis)->lpServerDoc;
	LPOUTLINEDOC lpOutlineDoc = (LPOUTLINEDOC)lpServerDoc;
	SCODE sc = S_OK;

	OLEDBG_BEGIN2("SvrDoc_OleObj_DoVerb\r\n")

	switch (lVerb) {

		default:
			/* OLE2NOTE: when an unknown verb number is given, the
			**    server must take careful action:
			**    1. if it is one of the specially defined OLEIVERB
			**    (negative numbered) verbs, the app should return an
			**    error (E_NOTIMPL) and perform no action.
			**
			**    2. if the verb is a application specific verb
			**    (positive numbered verb), then the app should
			**    return the special scode (OLEOBJ_S_INVALIDVERB). BUT,
			**    we should still perform our normal primary verb action.
			*/
			if (lVerb < 0) {
				OLEDBG_END2
				return ResultFromScode(E_NOTIMPL);
			} else {
				sc = OLEOBJ_S_INVALIDVERB;
			}

			// deliberatly fall through to Primary Verb

#if !defined( INPLACE_SVR )
		case 0:
		case OLEIVERB_SHOW:
		case OLEIVERB_OPEN:
			OutlineDoc_ShowWindow(lpOutlineDoc);
			break;

		case OLEIVERB_HIDE:
			OleDoc_HideWindow((LPOLEDOC)lpServerDoc, FALSE /*fShutdown*/);
			break;
#endif  // ! INPLACE_SVR
#if defined( INPLACE_SVR )
		case 0:
		case OLEIVERB_SHOW:

			/* OLE2NOTE: if our window is already open (visible) then
			**    we should simply surface the open window. if not,
			**    then we can do our primary action of in-place
			**    activation.
			*/
			if ( lpServerDoc->m_lpOleClientSite
					&& ! (IsWindowVisible(lpOutlineDoc->m_hWndDoc) &&
							! lpServerDoc->m_fInPlaceActive) ) {
				ServerDoc_DoInPlaceActivate(
						lpServerDoc, lVerb, lpmsg, lpActiveSite);
			}
			OutlineDoc_ShowWindow(lpOutlineDoc);
			break;

		case 1:
		case OLEIVERB_OPEN:
			ServerDoc_DoInPlaceDeactivate(lpServerDoc);
			OutlineDoc_ShowWindow(lpOutlineDoc);
			break;


		case OLEIVERB_HIDE:
			if (lpServerDoc->m_fInPlaceActive) {

				SvrDoc_IPObj_UIDeactivate(
						(LPOLEINPLACEOBJECT)&lpServerDoc->m_OleInPlaceObject);

#if defined( SVR_INSIDEOUT )
				/* OLE2NOTE: an inside-out style in-place server will
				**    NOT hide its window in UIDeactive (an outside-in
				**    style object will hide its window in
				**    UIDeactivate). thus we need to explicitly hide
				**    our window now.
				*/
				ServerDoc_DoInPlaceHide(lpServerDoc);
#endif // INSIEDOUT

			} else {
				OleDoc_HideWindow((LPOLEDOC)lpServerDoc, FALSE /*fShutdown*/);
			}
			break;

		case OLEIVERB_UIACTIVATE:

#if defined( SVR_INSIDEOUT )
		/* OLE2NOTE: only an inside-out style object supports
		**    INPLACEACTIVATE verb
		*/
		case OLEIVERB_INPLACEACTIVATE:
#endif // SVR_INSIDEOUT

			/* OLE2NOTE: if our window is already open (visible) then
			**    we can NOT activate in-place.
			*/
			if (IsWindowVisible(lpOutlineDoc->m_hWndDoc) &&
						! lpServerDoc->m_fInPlaceActive ) {
				sc = OLE_E_NOT_INPLACEACTIVE;
			} else {
				sc = GetScode( ServerDoc_DoInPlaceActivate(
						lpServerDoc, lVerb, lpmsg, lpActiveSite) );
				if (SUCCEEDED(sc))
					OutlineDoc_ShowWindow(lpOutlineDoc);
			}
			break;
#endif  // INPLACE_SVR
	}

	OLEDBG_END2
	return ResultFromScode(sc);
}


// IOleObject::EnumVerbs method

STDMETHODIMP SvrDoc_OleObj_EnumVerbs(
		LPOLEOBJECT             lpThis,
		LPENUMOLEVERB FAR*      lplpenumOleVerb
)
{
	OleDbgOut2("SvrDoc_OleObj_EnumVerbs\r\n");

	/* OLE2NOTE: we must make sure to set all out parameters to NULL. */
	*lplpenumOleVerb = NULL;

	/* An object implemented as a server EXE (as this sample
	**    is) may simply return OLE_S_USEREG to instruct the OLE
	**    DefHandler to call the OleReg* helper API which uses info in
	**    the registration database. Alternatively, the OleRegEnumVerbs
	**    API may be called directly. Objects implemented as a server
	**    DLL may NOT return OLE_S_USEREG; they must call the OleReg*
	**    API or provide their own implementation. For EXE based
	**    objects it is more efficient to return OLE_S_USEREG, because
	**    in then the verb enumerator is instantiated in the callers
	**    process space and no LRPC remoting is required.
	*/
	return ResultFromScode(OLE_S_USEREG);
}


// IOleObject::Update method

STDMETHODIMP SvrDoc_OleObj_Update(LPOLEOBJECT lpThis)
{
	OleDbgOut2("SvrDoc_OleObj_Update\r\n");

	/* OLE2NOTE: a server-only app is always "up-to-date".
	**    a container-app which contains links where the link source
	**    has changed since the last update of the link would be
	**    considered "out-of-date". the "Update" method instructs the
	**    object to get an update from any out-of-date links.
	*/

	return NOERROR;
}


// IOleObject::IsUpToDate method

STDMETHODIMP SvrDoc_OleObj_IsUpToDate(LPOLEOBJECT lpThis)
{
	OleDbgOut2("SvrDoc_OleObj_IsUpToDate\r\n");

	/* OLE2NOTE: a server-only app is always "up-to-date".
	**    a container-app which contains links where the link source
	**    has changed since the last update of the link would be
	**    considered "out-of-date".
	*/
	return NOERROR;
}


// IOleObject::GetUserClassID method

STDMETHODIMP SvrDoc_OleObj_GetUserClassID(
		LPOLEOBJECT             lpThis,
		LPCLSID                 lpClassID
)
{
	LPSERVERDOC lpServerDoc =
			((struct CDocOleObjectImpl FAR*)lpThis)->lpServerDoc;
	OleDbgOut2("SvrDoc_OleObj_GetClassID\r\n");

	/* OLE2NOTE: we must be carefull to return the correct CLSID here.
	**    if we are currently preforming a "TreatAs (aka. ActivateAs)"
	**    operation then we need to return the class of the object
	**    written in the storage of the object. otherwise we would
	**    return our own class id.
	*/
	return ServerDoc_GetClassID(lpServerDoc, lpClassID);
}


// IOleObject::GetUserType method

STDMETHODIMP SvrDoc_OleObj_GetUserTypeA(
		LPOLEOBJECT             lpThis,
		DWORD                   dwFormOfType,
		LPSTR FAR*              lpszUserType
)
{
	LPSERVERDOC lpServerDoc =
			((struct CDocOleObjectImpl FAR*)lpThis)->lpServerDoc;
	OleDbgOut2("SvrDoc_OleObj_GetUserType\r\n");

	/* OLE2NOTE: we must make sure to set all out parameters to NULL. */
	*lpszUserType = NULL;

	/* OLE2NOTE: we must be carefull to return the correct user type here.
	**    if we are currently preforming a "TreatAs (aka. ActivateAs)"
	**    operation then we need to return the user type name that
	**    corresponds to the class of the object we are currently
	**    emmulating. otherwise we should return our normal user type
	**    name corresponding to our own class. This routine determines
	**    the current clsid in effect.
	**
	**    An object implemented as a server EXE (as this sample
	**    is) may simply return OLE_S_USEREG to instruct the OLE
	**    DefHandler to call the OleReg* helper API which uses info in
	**    the registration database. Alternatively, the OleRegGetUserType
	**    API may be called directly. Objects implemented as a server
	**    DLL may NOT return OLE_S_USEREG; they must call the OleReg*
	**    API or provide their own implementation. For EXE based
	**    objects it is more efficient to return OLE_S_USEREG, because
	**    in then the return string is instantiated in the callers
	**    process space and no LRPC remoting is required.
	*/
#if defined( SVR_TREATAS )
	if (! IsEqualCLSID(&lpServerDoc->m_clsidTreatAs, &CLSID_NULL) )
		return OleRegGetUserTypeA(
			&lpServerDoc->m_clsidTreatAs,dwFormOfType,lpszUserType);
	else
#endif  // SVR_TREATAS

	return ResultFromScode(OLE_S_USEREG);
}



STDMETHODIMP SvrDoc_OleObj_GetUserType(
		LPOLEOBJECT             lpThis,
		DWORD                   dwFormOfType,
		LPOLESTR FAR*		lpszUserType
)
{
    LPSTR pstr;

    HRESULT hr = SvrDoc_OleObj_GetUserTypeA(lpThis, dwFormOfType, &pstr);

    CopyAndFreeSTR(pstr, lpszUserType);

    return hr;
}



// IOleObject::SetExtent method

STDMETHODIMP SvrDoc_OleObj_SetExtent(
		LPOLEOBJECT             lpThis,
		DWORD                   dwDrawAspect,
		LPSIZEL                 lplgrc
)
{
	OleDbgOut2("SvrDoc_OleObj_SetExtent\r\n");

	/* SVROUTL does NOT allow the object's size to be set by its
	**    container. the size of the ServerDoc object is determined by
	**    the data contained within the document.
	*/
	return ResultFromScode(E_FAIL);
}


// IOleObject::GetExtent method

STDMETHODIMP SvrDoc_OleObj_GetExtent(
		LPOLEOBJECT             lpThis,
		DWORD                   dwDrawAspect,
		LPSIZEL                 lpsizel
)
{
	LPOLEDOC lpOleDoc =
			(LPOLEDOC)((struct CDocOleObjectImpl FAR*)lpThis)->lpServerDoc;
	OleDbgOut2("SvrDoc_OleObj_GetExtent\r\n");

	/* OLE2NOTE: it is VERY important to check which aspect the caller
	**    is asking about. an object implemented by a server EXE MAY
	**    fail to return extents when asked for DVASPECT_ICON.
	*/
	if (dwDrawAspect == DVASPECT_CONTENT) {
		OleDoc_GetExtent(lpOleDoc, lpsizel);
		return NOERROR;
	}

#if defined( LATER )

	else if (dwDrawAspect == DVASPECT_THUMBNAIL)
	{
		/* as our thumbnail we will render only the first page of the
		**    document. calculate extents of our thumbnail rendering.
		**
		** OLE2NOTE: thumbnails are most often used by applications in
		**    FindFile or FileOpen type dialogs to give the user a
		**    quick view of the contents of the file or object.
		*/
		OleDoc_GetThumbnailExtent(lpOleDoc, lpsizel);
		return NOERROR;
	}
#endif

	else
	{
		return ResultFromScode(E_FAIL);
	}
}


// IOleObject::Advise method

STDMETHODIMP SvrDoc_OleObj_Advise(
		LPOLEOBJECT             lpThis,
		LPADVISESINK            lpAdvSink,
		LPDWORD                 lpdwConnection
)
{
	LPSERVERDOC lpServerDoc =
			((struct CDocOleObjectImpl FAR*)lpThis)->lpServerDoc;
	HRESULT hrErr;
	SCODE   sc;

	OLEDBG_BEGIN2("SvrDoc_OleObj_Advise\r\n");

        if (lpServerDoc->m_OleDoc.m_fObjIsClosing)
        {
            //  We don't accept any more Advise's once we're closing
            sc = OLE_E_ADVISENOTSUPPORTED;
            goto error;
        }

	if (lpServerDoc->m_lpOleAdviseHldr == NULL &&
		CreateOleAdviseHolder(&lpServerDoc->m_lpOleAdviseHldr) != NOERROR) {
		sc = E_OUTOFMEMORY;
		goto error;
	}

	OLEDBG_BEGIN2("IOleAdviseHolder::Advise called\r\n")
	hrErr = lpServerDoc->m_lpOleAdviseHldr->lpVtbl->Advise(
			lpServerDoc->m_lpOleAdviseHldr,
			lpAdvSink,
			lpdwConnection
	);
	OLEDBG_END2

	OLEDBG_END2
	return hrErr;

error:
	OLEDBG_END2
        *lpdwConnection = 0;
	return ResultFromScode(sc);
}


// IOleObject::Unadvise method

STDMETHODIMP SvrDoc_OleObj_Unadvise(LPOLEOBJECT lpThis, DWORD dwConnection)
{
	LPSERVERDOC lpServerDoc =
			((struct CDocOleObjectImpl FAR*)lpThis)->lpServerDoc;
	HRESULT hrErr;
	SCODE   sc;

	OLEDBG_BEGIN2("SvrDoc_OleObj_Unadvise\r\n");

	if (lpServerDoc->m_lpOleAdviseHldr == NULL) {
		sc = E_FAIL;
		goto error;
	}

	OLEDBG_BEGIN2("IOleAdviseHolder::Unadvise called\r\n")
	hrErr = lpServerDoc->m_lpOleAdviseHldr->lpVtbl->Unadvise(
			lpServerDoc->m_lpOleAdviseHldr,
			dwConnection
	);
	OLEDBG_END2

	OLEDBG_END2
	return hrErr;

error:
	OLEDBG_END2
	return ResultFromScode(sc);
}


// IOleObject::EnumAdvise method

STDMETHODIMP SvrDoc_OleObj_EnumAdvise(
		LPOLEOBJECT             lpThis,
		LPENUMSTATDATA FAR*     lplpenumAdvise
)
{
	LPSERVERDOC lpServerDoc =
			((struct CDocOleObjectImpl FAR*)lpThis)->lpServerDoc;
	HRESULT hrErr;
	SCODE   sc;

	OLEDBG_BEGIN2("SvrDoc_OleObj_EnumAdvise\r\n");

	/* OLE2NOTE: we must make sure to set all out parameters to NULL. */
	*lplpenumAdvise = NULL;

	if (lpServerDoc->m_lpOleAdviseHldr == NULL) {
		sc = E_FAIL;
		goto error;
	}

	OLEDBG_BEGIN2("IOleAdviseHolder::EnumAdvise called\r\n")
	hrErr = lpServerDoc->m_lpOleAdviseHldr->lpVtbl->EnumAdvise(
			lpServerDoc->m_lpOleAdviseHldr,
			lplpenumAdvise
	);
	OLEDBG_END2

	OLEDBG_END2
	return hrErr;

error:
	OLEDBG_END2
	return ResultFromScode(sc);
}


// IOleObject::GetMiscStatus method

STDMETHODIMP SvrDoc_OleObj_GetMiscStatus(
		LPOLEOBJECT             lpThis,
		DWORD                   dwAspect,
		DWORD FAR*              lpdwStatus
)
{
	LPSERVERDOC lpServerDoc =
			((struct CDocOleObjectImpl FAR*)lpThis)->lpServerDoc;
	LPOUTLINEDOC lpOutlineDoc = (LPOUTLINEDOC)lpServerDoc;
	OleDbgOut2("SvrDoc_OleObj_GetMiscStatus\r\n");

	/* Get our default MiscStatus for the given Aspect. this
	**    information is registered in the RegDB. We query the RegDB
	**    here to guarantee that the value returned from this method
	**    agrees with the values in RegDB. in this way we only have to
	**    maintain the info in one place (in the RegDB). Alternatively
	**    we could have the values hard coded here.
	*/
	OleRegGetMiscStatus((REFCLSID)&CLSID_APP, dwAspect, lpdwStatus);

	/* OLE2NOTE: check if the data copied is compatible to be
	**    linked by an OLE 1.0 container. it is compatible if
	**    either the data is an untitled document, a file, or a
	**    selection of data within a file. if the data is part of
	**    an embedded object, then it is NOT compatible to be
	**    linked by an OLE 1.0 container. if it is compatible then
	**    we must include OLEMISC_CANLINKBYOLE1 as part of the
	**    dwStatus flags transfered via CF_OBJECTDESCRIPTOR or
	**    CF_LINKSRCDESCRIPTOR.
	*/
	if (lpOutlineDoc->m_docInitType == DOCTYPE_NEW ||
		lpOutlineDoc->m_docInitType == DOCTYPE_FROMFILE)
		*lpdwStatus |= OLEMISC_CANLINKBYOLE1;

#if defined( INPLACE_SVR )
	if (dwAspect == DVASPECT_CONTENT)
		*lpdwStatus |= (OLEMISC_INSIDEOUT | OLEMISC_ACTIVATEWHENVISIBLE);
#endif  // INPLACE_SVR
	return NOERROR;
}


// IOleObject::SetColorScheme method

STDMETHODIMP SvrDoc_OleObj_SetColorScheme(
		LPOLEOBJECT             lpThis,
		LPLOGPALETTE            lpLogpal
)
{
	OleDbgOut2("SvrDoc_OleObj_SetColorScheme\r\n");

	// REVIEW: NOT YET IMPLEMENTED

	return ResultFromScode(E_NOTIMPL);
}


/*************************************************************************
** ServerDoc::IPersistStorage interface implementation
*************************************************************************/

// IPersistStorage::QueryInterface method

STDMETHODIMP SvrDoc_PStg_QueryInterface(
		LPPERSISTSTORAGE        lpThis,
		REFIID                  riid,
		LPVOID FAR*             lplpvObj
)
{
	LPSERVERDOC lpServerDoc =
			((struct CDocPersistStorageImpl FAR*)lpThis)->lpServerDoc;

	return OleDoc_QueryInterface((LPOLEDOC)lpServerDoc, riid, lplpvObj);
}


// IPersistStorage::AddRef method

STDMETHODIMP_(ULONG) SvrDoc_PStg_AddRef(LPPERSISTSTORAGE lpThis)
{
	LPSERVERDOC lpServerDoc =
			((struct CDocPersistStorageImpl FAR*)lpThis)->lpServerDoc;

	OleDbgAddRefMethod(lpThis, "IPersistStorage");

	return OleDoc_AddRef((LPOLEDOC)lpServerDoc);
}


// IPersistStorage::Release method

STDMETHODIMP_(ULONG) SvrDoc_PStg_Release(LPPERSISTSTORAGE lpThis)
{
	LPSERVERDOC lpServerDoc =
			((struct CDocPersistStorageImpl FAR*)lpThis)->lpServerDoc;

	OleDbgReleaseMethod(lpThis, "IPersistStorage");

	return OleDoc_Release((LPOLEDOC)lpServerDoc);
}


// IPersistStorage::GetClassID method

STDMETHODIMP SvrDoc_PStg_GetClassID(
		LPPERSISTSTORAGE        lpThis,
		LPCLSID                 lpClassID
)
{
	LPSERVERDOC lpServerDoc =
			((struct CDocPersistStorageImpl FAR*)lpThis)->lpServerDoc;
	OleDbgOut2("SvrDoc_PStg_GetClassID\r\n");

	/* OLE2NOTE: we must be carefull to return the correct CLSID here.
	**    if we are currently preforming a "TreatAs (aka. ActivateAs)"
	**    operation then we need to return the class of the object
	**    written in the storage of the object. otherwise we would
	**    return our own class id.
	*/
	return ServerDoc_GetClassID(lpServerDoc, lpClassID);
}


// IPersistStorage::IsDirty method

STDMETHODIMP  SvrDoc_PStg_IsDirty(LPPERSISTSTORAGE  lpThis)
{
	LPSERVERDOC lpServerDoc =
			((struct CDocPersistStorageImpl FAR*)lpThis)->lpServerDoc;
	OleDbgOut2("SvrDoc_PStg_IsDirty\r\n");

	if (OutlineDoc_IsModified((LPOUTLINEDOC)lpServerDoc))
		return NOERROR;
	else
		return ResultFromScode(S_FALSE);
}



// IPersistStorage::InitNew method

STDMETHODIMP SvrDoc_PStg_InitNew(
		LPPERSISTSTORAGE        lpThis,
		LPSTORAGE               lpStg
)
{
	LPSERVERDOC lpServerDoc =
			((struct CDocPersistStorageImpl FAR*)lpThis)->lpServerDoc;
	LPOLEDOC lpOleDoc = (LPOLEDOC)lpServerDoc;
	LPOUTLINEAPP lpOutlineApp = (LPOUTLINEAPP)g_lpApp;
	LPSTR    lpszUserType = (LPSTR)FULLUSERTYPENAME;
	HRESULT hrErr;
	SCODE sc;

	OLEDBG_BEGIN2("SvrDoc_PStg_InitNew\r\n")

#if defined( SVR_TREATAS )
	{
		LPOUTLINEAPP lpOutlineApp = (LPOUTLINEAPP)g_lpApp;
		CLSID       clsid;
		CLIPFORMAT  cfFmt;
		LPSTR       lpszType;

		/* OLE2NOTE: if the Server is capable of supporting "TreatAs"
		**    (aka. ActivateAs), it must read the class that is written
		**    into the storage. if this class is NOT the app's own
		**    class ID, then this is a TreatAs operation. the server
		**    then must faithfully pretend to be the class that is
		**    written into the storage. it must also faithfully write
		**    the data back to the storage in the SAME format as is
		**    written in the storage.
		**
		**    SVROUTL and ISVROTL can emulate each other. they have the
		**    simplification that they both read/write the identical
		**    format. thus for these apps no actual conversion of the
		**    native bits is actually required.
		*/
		lpServerDoc->m_clsidTreatAs = CLSID_NULL;
		if (OleStdGetTreatAsFmtUserType(&CLSID_APP, lpStg, &clsid,
							(CLIPFORMAT FAR*)&cfFmt, (LPSTR FAR*)&lpszType)) {

			if (cfFmt == lpOutlineApp->m_cfOutline) {
				// We should perform TreatAs operation
				if (lpServerDoc->m_lpszTreatAsType)
					OleStdFreeString(lpServerDoc->m_lpszTreatAsType, NULL);

				lpServerDoc->m_clsidTreatAs = clsid;
				((LPOUTLINEDOC)lpServerDoc)->m_cfSaveFormat = cfFmt;
				lpServerDoc->m_lpszTreatAsType = lpszType;
				lpszUserType = lpServerDoc->m_lpszTreatAsType;

				OleDbgOut3("SvrDoc_PStg_InitNew: TreateAs ==> '");
				OleDbgOutNoPrefix3(lpServerDoc->m_lpszTreatAsType);
				OleDbgOutNoPrefix3("'\r\n");
			} else {
				// ERROR: we ONLY support TreatAs for CF_OUTLINE format
				OleDbgOut("SvrDoc_PStg_InitNew: INVALID TreatAs Format\r\n");
				OleStdFreeString(lpszType, NULL);
			}
		}
	}
#endif  // SVR_TREATAS

	/* OLE2NOTE: a server EXE object should write its format tag to its
	**    storage in InitNew so that the DefHandler can know the format
	**    of the object. this is particularly important if the objects
	**    uses CF_METATFILE or CF_DIB as its format. the DefHandler
	**    automatically avoids separately storing presentation cache
	**    data when the object's native data is a standard presentation
	**    format.
	*/
	WriteFmtUserTypeStgA(lpStg,lpOutlineApp->m_cfOutline,lpszUserType);

	// set the doc to a new embedded object.
	if (! ServerDoc_InitNewEmbed(lpServerDoc)) {
		sc = E_FAIL;
		goto error;
	}

	/* OLE2NOTE: An embedded object must guarantee that it can save
	**    even in low memory situations. it must be able to
	**    successfully save itself without consuming any additional
	**    memory. this means that a server is NOT supposed to open or
	**    create any streams or storages when
	**    IPersistStorage::Save(fSameAsLoad==TRUE) is called. thus an
	**    embedded object should hold onto its storage and pre-open and
	**    hold open any streams that it will need later when it is time
	**    to save.
	*/
	hrErr = CallIStorageCreateStreamA(
			lpStg,
			"LineList",
			STGM_WRITE | STGM_SHARE_EXCLUSIVE | STGM_CREATE,
			0,
			0,
			&lpOleDoc->m_lpLLStm
	);

	if (hrErr != NOERROR) {
		OleDbgAssertSz(hrErr==NOERROR,"Could not create LineList stream");
		OleDbgOutHResult("LineList CreateStream returned", hrErr);
		sc = GetScode(hrErr);
		goto error;
	}

	hrErr = CallIStorageCreateStreamA(
			lpStg,
			"NameTable",
			STGM_WRITE | STGM_SHARE_EXCLUSIVE | STGM_CREATE,
			0,
			0,
			&lpOleDoc->m_lpNTStm
	);

	if (hrErr != NOERROR) {
		OleDbgAssertSz(hrErr==NOERROR,"Could not create NameTable stream");
		OleDbgOutHResult("NameTable CreateStream returned", hrErr);
		sc = GetScode(hrErr);
		goto error;
	}

	lpOleDoc->m_lpStg = lpStg;

	// OLE2NOTE: to be able to hold onto IStorage* pointer, we must AddRef it
	lpStg->lpVtbl->AddRef(lpStg);

	OLEDBG_END2
	return NOERROR;

error:
	OLEDBG_END2
	return ResultFromScode(sc);
}


// IPersistStorage::Load method

STDMETHODIMP SvrDoc_PStg_Load(
		LPPERSISTSTORAGE        lpThis,
		LPSTORAGE               lpStg
)
{
	LPSERVERDOC lpServerDoc =
			((struct CDocPersistStorageImpl FAR*)lpThis)->lpServerDoc;
	LPOLEDOC lpOleDoc = (LPOLEDOC)lpServerDoc;
	LPOUTLINEDOC lpOutlineDoc = (LPOUTLINEDOC)lpServerDoc;
	SCODE sc;
	HRESULT hrErr;

	OLEDBG_BEGIN2("SvrDoc_PStg_Load\r\n")

	if (OutlineDoc_LoadFromStg((LPOUTLINEDOC)lpServerDoc, lpStg)) {

		((LPOUTLINEDOC)lpServerDoc)->m_docInitType = DOCTYPE_EMBEDDED;

		/* OLE2NOTE: we need to check if the ConvertStg bit is on. if
		**    so, we need to clear the ConvertStg bit and mark the
		**    document as dirty so as to force a save when the document
		**    is closed. the actual conversion of the bits should be
		**    performed when the data is loaded from the IStorage*. in
		**    our case any conversion of data formats would be done in
		**    OutlineDoc_LoadFromStg function. in reality both SVROUTL
		**    and ISVROTL read and write the same format so no actual
		**    conversion of data bits is necessary.
		*/
		if (GetConvertStg(lpStg) == NOERROR) {
			SetConvertStg(lpStg, FALSE);

			OleDbgOut3("SvrDoc_PStg_Load: ConvertStg==TRUE\r\n");
			OutlineDoc_SetModified(lpOutlineDoc, TRUE, FALSE, FALSE);
		}

	} else {
		sc = E_FAIL;
		goto error;
	}

	/* OLE2NOTE: An embedded object must guarantee that it can save
	**    even in low memory situations. it must be able to
	**    successfully save itself without consuming any additional
	**    memory. this means that a server is NOT supposed to open or
	**    create any streams or storages when
	**    IPersistStorage::Save(fSameAsLoad==TRUE) is called. thus an
	**    embedded object should hold onto its storage and pre-open and
	**    hold open any streams that it will need later when it is time
	**    to save.
	*/
	if (lpOleDoc->m_lpLLStm)
		OleStdRelease((LPUNKNOWN)lpOleDoc->m_lpLLStm);
	hrErr = CallIStorageOpenStreamA(
			lpStg,
			"LineList",
			NULL,
			STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
			0,
			&lpOleDoc->m_lpLLStm
	);

	if (hrErr != NOERROR) {
		OleDbgAssertSz(hrErr==NOERROR,"Could not create LineList stream");
		OleDbgOutHResult("LineList CreateStream returned", hrErr);
		sc = GetScode(hrErr);
		goto error;
	}

	if (lpOleDoc->m_lpNTStm)
		OleStdRelease((LPUNKNOWN)lpOleDoc->m_lpNTStm);
	hrErr = CallIStorageOpenStreamA(
			lpStg,
			"NameTable",
			NULL,
			STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
			0,
			&lpOleDoc->m_lpNTStm
	);

	if (hrErr != NOERROR) {
		OleDbgAssertSz(hrErr==NOERROR,"Could not create NameTable stream");
		OleDbgOutHResult("NameTable CreateStream returned", hrErr);
		sc = GetScode(hrErr);
		goto error;
	}

	lpOleDoc->m_lpStg = lpStg;

	// OLE2NOTE: to be able to hold onto IStorage* pointer, we must AddRef it
	lpStg->lpVtbl->AddRef(lpStg);

	OLEDBG_END2
	return NOERROR;

error:
	OLEDBG_END2
	return ResultFromScode(sc);
}


// IPersistStorage::Save method

STDMETHODIMP SvrDoc_PStg_Save(
		LPPERSISTSTORAGE        lpThis,
		LPSTORAGE               lpStg,
		BOOL                    fSameAsLoad
)
{
	LPSERVERDOC lpServerDoc =
			((struct CDocPersistStorageImpl FAR*)lpThis)->lpServerDoc;
	LPOUTLINEDOC lpOutlineDoc = (LPOUTLINEDOC)lpServerDoc;
	BOOL fStatus;
	SCODE sc;

	OLEDBG_BEGIN2("SvrDoc_PStg_Save\r\n")

	fStatus = OutlineDoc_SaveSelToStg(
			(LPOUTLINEDOC)lpServerDoc,
			NULL,
			lpOutlineDoc->m_cfSaveFormat,
			lpStg,
			fSameAsLoad,
			FALSE
	);

	if (! fStatus) {
		OutlineApp_ErrorMessage(g_lpApp, ErrMsgPSSaveFail);
		sc = E_FAIL;
		goto error;
	}

	lpServerDoc->m_fSaveWithSameAsLoad = fSameAsLoad;
	lpServerDoc->m_fNoScribbleMode = TRUE;

	OLEDBG_END2
	return NOERROR;

error:
	OLEDBG_END2
	return ResultFromScode(sc);
}



// IPersistStorage::SaveCompleted method

STDMETHODIMP SvrDoc_PStg_SaveCompleted(
		LPPERSISTSTORAGE        lpThis,
		LPSTORAGE               lpStgNew
)
{
	LPSERVERDOC lpServerDoc =
			((struct CDocPersistStorageImpl FAR*)lpThis)->lpServerDoc;
	LPOLEDOC lpOleDoc = (LPOLEDOC)lpServerDoc;
	LPOUTLINEDOC lpOutlineDoc = (LPOUTLINEDOC)lpServerDoc;
	HRESULT hrErr;

	OLEDBG_BEGIN2("SvrDoc_PStg_SaveCompleted\r\n")

	/* OLE2NOTE: this sample application is a pure server application.
	**    a container/server application would have to call SaveCompleted
	**    for each of its contained compound document objects. if a new
	**    storage was given, then the container/server would have to
	**    open the corresponding new sub-storage for each compound
	**    document object and pass as an argument in the SaveCompleted
	**    call.
	*/

	/* OLE2NOTE: it is only legal to perform a Save or SaveAs operation
	**    on an embedded object. if the document is a file-based document
	**    then we can not be changed to a IStorage-base object.
	**
	**      fSameAsLoad   lpStgNew     Type of Save     Send OnSave
	**    ---------------------------------------------------------
	**         TRUE        NULL        SAVE             YES
	**         TRUE        ! NULL      SAVE *           YES
	**         FALSE       ! NULL      SAVE AS          YES
	**         FALSE       NULL        SAVE COPY AS     NO
	**
	**    * this is a strange case that is possible. it is inefficient
	**    for the caller; it would be better to pass lpStgNew==NULL for
	**    the Save operation.
	*/
	if ( ((lpServerDoc->m_fSaveWithSameAsLoad && lpStgNew==NULL) || lpStgNew)
			&& (lpOutlineDoc->m_docInitType != DOCTYPE_EMBEDDED) ) {
		OLEDBG_END2
		return ResultFromScode(E_INVALIDARG);
	}

	/* OLE2NOTE: inform any linking clients that the document has been
	**    saved. in addition, any currently active pseudo objects
	**    should also inform their clients. we should only broadcast an
	**    OnSave notification if a Save or SaveAs operation was
	**    performed. we do NOT want to send the notification if a
	**    SaveCopyAs operation was performed.
	*/
	if (lpStgNew || lpServerDoc->m_fSaveWithSameAsLoad) {

		/* OLE2NOTE: if IPersistStorage::Save has been called, then we
		**    need to clear the dirty bit and send OnSave notification.
		**    if HandsOffStorage is called directly without first
		**    calling Save, then we do NOT want to clear the dirty bit
		**    and send OnSave when SaveCompleted is called.
		*/
		if (lpServerDoc->m_fNoScribbleMode) {
			OutlineDoc_SetModified(lpOutlineDoc, FALSE, FALSE, FALSE);

			ServerDoc_SendAdvise (
					lpServerDoc,
					OLE_ONSAVE,
					NULL,   /* lpmkDoc -- not relevant here */
					0       /* advf -- not relevant here */
			);
		}
		lpServerDoc->m_fSaveWithSameAsLoad = FALSE;
	}
	lpServerDoc->m_fNoScribbleMode = FALSE;

	/* OLE2NOTE: An embedded object must guarantee that it can save
	**    even in low memory situations. it must be able to
	**    successfully save itself without consuming any additional
	**    memory. this means that a server is NOT supposed to open or
	**    create any streams or storages when
	**    IPersistStorage::Save(fSameAsLoad==TRUE) is called. thus an
	**    embedded object should hold onto its storage and pre-open and
	**    hold open any streams that it will need later when it is time
	**    to save. if this is a SaveAs situtation, then we want to
	**    pre-open and hold open our streams to guarantee that a
	**    subsequent save will be successful in low-memory. if we fail
	**    to open these streams then we want to force ourself to close
	**    to make sure the can't make editing changes that can't be
	**    later saved.
	*/
	if ( lpStgNew && !lpServerDoc->m_fSaveWithSameAsLoad ) {

		// release previous streams
		if (lpOleDoc->m_lpLLStm) {
			OleStdRelease((LPUNKNOWN)lpOleDoc->m_lpLLStm);
			lpOleDoc->m_lpLLStm = NULL;
		}
		if (lpOleDoc->m_lpNTStm) {
			OleStdRelease((LPUNKNOWN)lpOleDoc->m_lpNTStm);
			lpOleDoc->m_lpNTStm = NULL;
		}
		if (lpOleDoc->m_lpStg) {
			OleStdRelease((LPUNKNOWN)lpOleDoc->m_lpStg);
			lpOleDoc->m_lpStg = NULL;
		}

		hrErr = CallIStorageOpenStreamA(
				lpStgNew,
				"LineList",
				NULL,
				STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
				0,
				&lpOleDoc->m_lpLLStm
		);

		if (hrErr != NOERROR) {
			OleDbgAssertSz(hrErr==NOERROR,"Could not create LineList stream");
			OleDbgOutHResult("LineList CreateStream returned", hrErr);
			goto error;
		}

		hrErr = CallIStorageOpenStreamA(
				lpStgNew,
				"NameTable",
				NULL,
				STGM_READWRITE | STGM_SHARE_EXCLUSIVE,
				0,
				&lpOleDoc->m_lpNTStm
		);

		if (hrErr != NOERROR) {
			OleDbgAssertSz(hrErr==NOERROR,"Could not create NameTable stream");
			OleDbgOutHResult("NameTable CreateStream returned", hrErr);
			goto error;
		}

		lpOleDoc->m_lpStg = lpStgNew;

		// OLE2NOTE: to hold onto IStorage* pointer, we must AddRef it
		lpStgNew->lpVtbl->AddRef(lpStgNew);
	}

	OLEDBG_END2
	return NOERROR;

error:
	OLEDBG_END2
	return ResultFromScode(E_OUTOFMEMORY);
}


// IPersistStorage::HandsOffStorage method

STDMETHODIMP SvrDoc_PStg_HandsOffStorage(LPPERSISTSTORAGE lpThis)
{
	LPSERVERDOC lpServerDoc =
			((struct CDocPersistStorageImpl FAR*)lpThis)->lpServerDoc;
	LPOLEDOC lpOleDoc = (LPOLEDOC)lpServerDoc;

	OLEDBG_BEGIN2("SvrDoc_PStg_HandsOffStorage\r\n")

	/* OLE2NOTE: An embedded object must guarantee that it can save
	**    even in low memory situations. it must be able to
	**    successfully save itself without consuming any additional
	**    memory. this means that a server is NOT supposed to open or
	**    create any streams or storages when
	**    IPersistStorage::Save(fSameAsLoad==TRUE) is called. thus an
	**    embedded object should hold onto its storage and pre-open and
	**    hold open any streams that it will need later when it is time
	**    to save. Now when HandsOffStorage is called the object must
	**    release its storage and any streams that is holds open.
	**    later when SaveCompleted is called, it will be given back its
	**    storage.
	*/
	if (lpOleDoc->m_lpLLStm) {
		OleStdRelease((LPUNKNOWN)lpOleDoc->m_lpLLStm);
		lpOleDoc->m_lpLLStm = NULL;
	}
	if (lpOleDoc->m_lpNTStm) {
		OleStdRelease((LPUNKNOWN)lpOleDoc->m_lpNTStm);
		lpOleDoc->m_lpNTStm = NULL;
	}
	if (lpOleDoc->m_lpStg) {
		OleStdRelease((LPUNKNOWN)lpOleDoc->m_lpStg);
		lpOleDoc->m_lpStg = NULL;
	}

	OLEDBG_END2
	return NOERROR;
}



#if defined( SVR_TREATAS )

/*************************************************************************
** ServerDoc::IStdMarshalInfo interface implementation
*************************************************************************/

// IStdMarshalInfo::QueryInterface method

STDMETHODIMP SvrDoc_StdMshl_QueryInterface(
		LPSTDMARSHALINFO        lpThis,
		REFIID                  riid,
		LPVOID FAR*             lplpvObj
)
{
	LPSERVERDOC lpServerDoc =
			((struct CDocStdMarshalInfoImpl FAR*)lpThis)->lpServerDoc;

	return OleDoc_QueryInterface((LPOLEDOC)lpServerDoc, riid, lplpvObj);
}


// IStdMarshalInfo::AddRef method

STDMETHODIMP_(ULONG) SvrDoc_StdMshl_AddRef(LPSTDMARSHALINFO lpThis)
{
	LPSERVERDOC lpServerDoc =
			((struct CDocStdMarshalInfoImpl FAR*)lpThis)->lpServerDoc;

	OleDbgAddRefMethod(lpThis, "IStdMarshalInfo");

	return OleDoc_AddRef((LPOLEDOC)lpServerDoc);
}


// IStdMarshalInfo::Release method

STDMETHODIMP_(ULONG) SvrDoc_StdMshl_Release(LPSTDMARSHALINFO lpThis)
{
	LPSERVERDOC lpServerDoc =
			((struct CDocStdMarshalInfoImpl FAR*)lpThis)->lpServerDoc;

	OleDbgReleaseMethod(lpThis, "IStdMarshalInfo");

	return OleDoc_Release((LPOLEDOC)lpServerDoc);
}


// IStdMarshalInfo::GetClassForHandler

STDMETHODIMP SvrDoc_StdMshl_GetClassForHandler(
		LPSTDMARSHALINFO        lpThis,
		DWORD                   dwDestContext,
		LPVOID                  pvDestContext,
		LPCLSID                 lpClassID
)
{
	LPSERVERDOC lpServerDoc =
			((struct CDocStdMarshalInfoImpl FAR*)lpThis)->lpServerDoc;
	OleDbgOut2("SvrDoc_StdMshl_GetClassForHandler\r\n");

	// OLE2NOTE: we only handle LOCAL marshal context.
	if (dwDestContext != MSHCTX_LOCAL || pvDestContext != NULL)
		return ResultFromScode(E_INVALIDARG);

	/* OLE2NOTE: we must return our REAL clsid, NOT the clsid that we
	**    are pretending to be if a "TreatAs" is in effect.
	*/
	*lpClassID = CLSID_APP;
	return NOERROR;
}
#endif  // SVR_TREATAS



/*************************************************************************
** ServerDoc Support Functions
*************************************************************************/


/* ServerDoc_Init
 * --------------
 *
 *  Initialize the fields of a new ServerDoc object. The object is initially
 *  not associated with a file or an (Untitled) document. This function sets
 *  the docInitType to DOCTYPE_UNKNOWN. After calling this function the
 *  caller should call:
 *      1.) OutlineDoc_InitNewFile to set the ServerDoc to (Untitled)
 *      2.) OutlineDoc_LoadFromFile to associate the ServerDoc with a file.
 *  This function creates a new window for the document.
 *
 *  NOTE: the window is initially created with a NIL size. it must be
 *        sized and positioned by the caller. also the document is initially
 *        created invisible. the caller must call OutlineDoc_ShowWindow
 *        after sizing it to make the document window visible.
 */
BOOL ServerDoc_Init(LPSERVERDOC lpServerDoc, BOOL fDataTransferDoc)
{
	lpServerDoc->m_cPseudoObj                   = 0;
	lpServerDoc->m_lpOleClientSite              = NULL;
	lpServerDoc->m_lpOleAdviseHldr              = NULL;
	lpServerDoc->m_lpDataAdviseHldr             = NULL;

	// initialy doc does not have any storage
	lpServerDoc->m_fNoScribbleMode              = FALSE;
	lpServerDoc->m_fSaveWithSameAsLoad          = FALSE;
	lpServerDoc->m_szContainerApp[0]            = '\0';
	lpServerDoc->m_szContainerObj[0]            = '\0';
	lpServerDoc->m_nNextRangeNo                 = 0L;
	lpServerDoc->m_lrSrcSelOfCopy.m_nStartLine  = -1;
	lpServerDoc->m_lrSrcSelOfCopy.m_nEndLine    = -1;
	lpServerDoc->m_fDataChanged                 = FALSE;
	lpServerDoc->m_fSizeChanged                 = FALSE;
	lpServerDoc->m_fSendDataOnStop              = FALSE;

#if defined( SVR_TREATAS )
	lpServerDoc->m_clsidTreatAs                 = CLSID_NULL;
	lpServerDoc->m_lpszTreatAsType              = NULL;
#endif  // SVR_TREATAS

#if defined( INPLACE_SVR )
	lpServerDoc->m_hWndHatch                    =
			CreateHatchWindow(
					OutlineApp_GetWindow(g_lpApp),
					OutlineApp_GetInstance(g_lpApp)
			);
	if (!lpServerDoc->m_hWndHatch)
		return FALSE;

	lpServerDoc->m_fInPlaceActive               = FALSE;
	lpServerDoc->m_fInPlaceVisible              = FALSE;
	lpServerDoc->m_fUIActive                    = FALSE;
	lpServerDoc->m_lpIPData                     = NULL;
	lpServerDoc->m_fMenuHelpMode                = FALSE; // F1 pressed in menu

	INIT_INTERFACEIMPL(
			&lpServerDoc->m_OleInPlaceObject,
			&g_SvrDoc_OleInPlaceObjectVtbl,
			lpServerDoc
	);
	INIT_INTERFACEIMPL(
			&lpServerDoc->m_OleInPlaceActiveObject,
			&g_SvrDoc_OleInPlaceActiveObjectVtbl,
			lpServerDoc
	);
#endif // INPLACE_SVR

	INIT_INTERFACEIMPL(
			&lpServerDoc->m_OleObject,
			&g_SvrDoc_OleObjectVtbl,
			lpServerDoc
	);

	INIT_INTERFACEIMPL(
			&lpServerDoc->m_PersistStorage,
			&g_SvrDoc_PersistStorageVtbl,
			lpServerDoc
	);

#if defined( SVR_TREATAS )

	INIT_INTERFACEIMPL(
			&lpServerDoc->m_StdMarshalInfo,
			&g_SvrDoc_StdMarshalInfoVtbl,
			lpServerDoc
	);
#endif  // SVR_TREATAS
	return TRUE;
}


/* ServerDoc_InitNewEmbed
 * ----------------------
 *
 *  Initialize the ServerDoc object to be a new embedded object document.
 *  This function sets the docInitType to DOCTYPE_EMBED.
 */
BOOL ServerDoc_InitNewEmbed(LPSERVERDOC lpServerDoc)
{
	LPOUTLINEDOC lpOutlineDoc = (LPOUTLINEDOC)lpServerDoc;

	OleDbgAssert(lpOutlineDoc->m_docInitType == DOCTYPE_UNKNOWN);

	lpOutlineDoc->m_docInitType = DOCTYPE_EMBEDDED;

	/* The Window title for an embedded object is constructed as
	**    follows:
	**      <server app name> - <obj short type> in <cont. doc name>
	**
	**    here we construct the current document title portion of the
	**    name which follows the '-'. OutlineDoc_SetTitle prepends the
	**    "<server app name> - " to the document title.
	*/
	// REVIEW: this string should be loaded from string resource
	wsprintf(lpOutlineDoc->m_szFileName, "%s in %s",
		(LPSTR)SHORTUSERTYPENAME,
		(LPSTR)DEFCONTAINERNAME);
	lpOutlineDoc->m_lpszDocTitle = lpOutlineDoc->m_szFileName;


	/* OLE2NOTE: an embedding should be marked as initially dirty so
	**    that on close we always call IOleClientSite::SaveObject.
	*/
	OutlineDoc_SetModified(lpOutlineDoc, TRUE, FALSE, FALSE);

	OutlineDoc_SetTitle(lpOutlineDoc, FALSE /*fMakeUpperCase*/);

	return TRUE;
}


/* ServerDoc_SendAdvise
 * --------------------
 *
 * This function sends an advise notification on behalf of a specific
 *  doc object to all its clients.
 */
void ServerDoc_SendAdvise(
		LPSERVERDOC     lpServerDoc,
		WORD            wAdvise,
		LPMONIKER       lpmkDoc,
		DWORD           dwAdvf
)
{
	LPOUTLINEDOC lpOutlineDoc = (LPOUTLINEDOC)lpServerDoc;
	LPOLEDOC lpOleDoc = (LPOLEDOC)lpServerDoc;

	switch (wAdvise) {

		case OLE_ONDATACHANGE:

			// inform clients that the data of the object has changed

			if (lpOutlineDoc->m_nDisableDraw == 0) {
				/* drawing is currently enabled. inform clients that
				**    the data of the object has changed
				*/

				lpServerDoc->m_fDataChanged = FALSE;

				/* OLE2NOTE: we must note the time of last change
				**    for our object in the RunningObjectTable.
				**    this is used as the basis to answer
				**    IOleObject::IsUpToDate. we only want to note
				**    the change time when an actual change takes
				**    place. we do NOT want to set it when we are
				**    notifying clients of ADVF_DATAONSTOP
				*/
				if (dwAdvf == 0)
					OleStdNoteObjectChangeTime(lpOleDoc->m_dwRegROT);

				if (lpServerDoc->m_lpDataAdviseHldr) {
					OLEDBG_BEGIN2("IDataAdviseHolder::SendOnDataChange called\r\n");
					lpServerDoc->m_lpDataAdviseHldr->lpVtbl->SendOnDataChange(
							lpServerDoc->m_lpDataAdviseHldr,
							(LPDATAOBJECT)&lpOleDoc->m_DataObject,
							0,
							dwAdvf
					);
					OLEDBG_END2

				}

#if defined( INPLACE_SVR )
				/* OLE2NOTE: if the ServerDoc is currently in-place UI active,
				**    then is it important to renegotiate the size for the
				**    in-place document window BEFORE sending OnDataChange
				**    (which will cause the window to repaint).
				*/
				if (lpServerDoc->m_fSizeChanged) {
					lpServerDoc->m_fSizeChanged = FALSE;
					if (lpServerDoc->m_fInPlaceActive)
						ServerDoc_UpdateInPlaceWindowOnExtentChange(lpServerDoc);
				}
#endif

				/* OLE2NOTE: we do NOT need to tell our pseudo objects to
				**    broadcast OnDataChange notification because
				**    they will do it automatically when an editing
				**    change in the document affects a PseudoObj.
				**    (see OutlineNameTable_AddLineUpdate,
				**         OutlineNameTable_DeleteLineUpdate,
				**    and  ServerNameTable_EditLineUpdate)
				*/

			} else {
				/* drawing is currently disabled. do not send
				**    notifications or call
				**    IOleInPlaceObject::OnPosRectChange until drawing
				**    is re-enabled.
				*/
			}
			break;

		case OLE_ONCLOSE:

			// inform clients that the document is shutting down

			if (lpServerDoc->m_lpOleAdviseHldr) {
				OLEDBG_BEGIN2("IOleAdviseHolder::SendOnClose called\r\n");
				lpServerDoc->m_lpOleAdviseHldr->lpVtbl->SendOnClose(
						lpServerDoc->m_lpOleAdviseHldr
				);
				OLEDBG_END2
			}

			/* OLE2NOTE: we do NOT need to tell our pseudo objects to
			**    broadcast OnClose notification because they will do
			**    it automatically when the pseudo object is closed.
			**    (see PseudoObj_Close)
			*/

			break;

		case OLE_ONSAVE:

			// inform clients that the object has been saved

			OLEDBG_BEGIN3("ServerDoc_SendAdvise ONSAVE\r\n");

			if (lpServerDoc->m_lpOleAdviseHldr) {
				OLEDBG_BEGIN2("IOleAdviseHolder::SendOnSave called\r\n");
				lpServerDoc->m_lpOleAdviseHldr->lpVtbl->SendOnSave(
						lpServerDoc->m_lpOleAdviseHldr
				);
				OLEDBG_END2
			}

			/* OLE2NOTE: inform any clients of pseudo objects
			**    within our document, that our document has been
			**    saved.
			*/
			ServerNameTable_InformAllPseudoObjectsDocSaved(
					(LPSERVERNAMETABLE)lpOutlineDoc->m_lpNameTable,
					lpmkDoc
			);
			OLEDBG_END3
			break;

		case OLE_ONRENAME:

			// inform clients that the object's name has changed

			OLEDBG_BEGIN3("ServerDoc_SendAdvise ONRENAME\r\n");

			if (lpmkDoc && lpServerDoc->m_lpOleAdviseHldr) {
				OLEDBG_BEGIN2("IOleAdviseHolder::SendOnRename called\r\n");
				lpServerDoc->m_lpOleAdviseHldr->lpVtbl->SendOnRename(
						lpServerDoc->m_lpOleAdviseHldr,
						lpmkDoc
				);
				OLEDBG_END2
			}

			OLEDBG_END3
			break;
	}
}


/* ServerDoc_GetClassID
** --------------------
**    Return the class ID corresponding to the bits in the storage.
**    normally this will be our application's given CLSID. but if a
**    "TreateAs (aka. ActivateAs)" operation is taking place, then our
**    application needs to pretend to be the class of the object that
**    we are emulating. this is also the class that will be written
**    into the storage.
*/
HRESULT ServerDoc_GetClassID(LPSERVERDOC lpServerDoc, LPCLSID lpclsid)
{
#if defined( SVR_TREATAS )
	if (! IsEqualCLSID(&lpServerDoc->m_clsidTreatAs, &CLSID_NULL))
		*lpclsid = lpServerDoc->m_clsidTreatAs;
	else
#endif  // SVR_TREATAS
		*lpclsid = CLSID_APP;

	return NOERROR;
}



/* ServerDoc_UpdateMenu
 * --------------------
 *
 *  Update menu for embedding mode. the changes include:
 *      1 Remove File/New and File/Open (SDI ONLY)
 *      2 Change File/Save As.. to File/Save Copy As..
 *      3 Change File menu so it contains "Update" instead of "Save"
 *      4 Change File/Exit to File/Exit & Return to <client doc>"
 */
void ServerDoc_UpdateMenu(LPSERVERDOC lpServerDoc)
{
	char    str[256];
	HWND    hWndMain;
	HMENU   hMenu;
	OleDbgOut2("ServerDoc_UpdateMenu\r\n");

	hWndMain=g_lpApp->m_hWndApp;
	hMenu=GetMenu(hWndMain);

#if defined( SDI_VERSION )
	/* SDI ONLY: Remove File/New and File/Open */
	DeleteMenu(hMenu, IDM_F_NEW, MF_BYCOMMAND);
	DeleteMenu(hMenu, IDM_F_OPEN, MF_BYCOMMAND);
#endif

	// Change File.Save As.. to File.Save Copy As.. */
	ModifyMenu(hMenu,IDM_F_SAVEAS, MF_STRING, IDM_F_SAVEAS, "Save Copy As..");

	// Change File.Save to "&Update <container doc>"
	wsprintf(str, g_szUpdateCntrDoc, lpServerDoc->m_szContainerObj);
	ModifyMenu(hMenu, IDM_F_SAVE, MF_STRING, IDM_F_SAVE, str);

	// Change File/Exit to File/Exit & Return to <container doc>" */
	wsprintf(str, g_szExitNReturnToCntrDoc, lpServerDoc->m_szContainerObj);
	ModifyMenu(hMenu, IDM_F_EXIT, MF_STRING, IDM_F_EXIT, str);

	DrawMenuBar(hWndMain);
}

#if defined( MDI_VERSION )

// NOTE: ServerDoc_RestoreMenu is actually redundant because the
//          app is dying when the function is called.  (In SDI, the
//          app will terminate when the ref counter of the server doc
//          is zero). However, it is important for MDI.

/* ServerDoc_RestoreMenu
 * ---------------------
 *
 *      Reset the menu to non-embedding mode
 */
void ServerDoc_RestoreMenu(LPSERVERDOC lpServerDoc)
{
	LPOUTLINEAPP    lpOutlineApp = (LPOUTLINEAPP)g_lpApp;
	HWND            hWndMain;
	HMENU           hMenu;
	OleDbgOut2("ServerDoc_RestoreMenu\r\n");

	hWndMain = lpOutlineApp->m_hWndApp;
	hMenu = GetMenu(hWndMain);

	/* Add back File/New, File/Open.. and File/Save */
	InsertMenu(hMenu, IDM_F_SAVEAS, MF_BYCOMMAND | MF_ENABLED | MF_STRING,
		IDM_F_NEW, "&New");
	InsertMenu(hMenu, IDM_F_SAVEAS, MF_BYCOMMAND | MF_ENABLED | MF_STRING,
		IDM_F_OPEN, "&Open...");

	/* Change File menu so it contains "Save As..." instead of */
	/* "Save Copy As..." */
	ModifyMenu(hMenu, IDM_F_SAVEAS, MF_STRING, IDM_F_SAVEAS, "Save &As..");

	/* Change File menu so it contains "Save" instead of "Update" */
	ModifyMenu(hMenu, IDM_F_SAVE, MF_STRING, IDM_F_SAVE, "&Save");

	/* Change File menu so it contains "Exit" */
	/* instead of just "Exit & Return to <client doc>" */
	ModifyMenu(hMenu, IDM_F_EXIT, MF_STRING, IDM_F_EXIT, "E&xit");

	DrawMenuBar (hWndMain);
}

#endif  // MDI_VERSION
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\letest\outline\svroutl.h ===
/*************************************************************************
**
**    OLE 2.0 Server Sample Code
**
**    svroutl.h
**
**    This file contains file contains data structure defintions,
**    function prototypes, constants, etc. used by the OLE 2.0 server
**    app version of the Outline series of sample applications:
**          Outline -- base version of the app (without OLE functionality)
**          SvrOutl -- OLE 2.0 Server sample app
**          CntrOutl -- OLE 2.0 Containter sample app
**
**    (c) Copyright Microsoft Corp. 1992 - 1993 All Rights Reserved
**
*************************************************************************/

#if !defined( _SVROUTL_H_ )
#define _SVROUTL_H_

#ifndef RC_INVOKED
#pragma message ("INCLUDING SVROUTL.H from " __FILE__)
#endif  /* RC_INVOKED */

#include "oleoutl.h"

/* Defines */

// Enable SVROUTL and ISVROTL to emulate each other (TreatAs aka. ActivateAs)
#define SVR_TREATAS     1

// Enable SVROUTL and ISVROTL to convert each other (TreatAs aka. ActivateAs)
#define SVR_CONVERTTO   1

// Enable ISVROTL to operate as in inside-out style in-place object
#define SVR_INSIDEOUT   1

/* Default name used for container of the embedded object. used if
**    container forgets to call IOleObject::SetHostNames
*/
// REVIEW: should load from string resource
#define DEFCONTAINERNAME    "Unknown Document"

/* Default prefix for auto-generated range names. This is used with
**    links to unnamed ranges (pseudo objects).
*/
// REVIEW: should load from string resource
#define DEFRANGENAMEPREFIX  "Range"

// Maximum length of strings accepted through IOleObject::SetHostNames
//      (note: this is rather arbitrary; a better strategy would be to
//             dynamically allocated buffers for these strings.)
#define MAXAPPNAME  80
#define MAXCONTAINERNAME    80

// Menu option in embedding mode
#define IDM_F_UPDATE    1151

/* Types */

/* Codes for CallBack events */
typedef enum tagOLE_NOTIFICATION {
	OLE_ONDATACHANGE,        // 0
	OLE_ONSAVE,              // 1
	OLE_ONRENAME,            // 2
	OLE_ONCLOSE              // 3
} OLE_NOTIFICATION;

/* Codes to indicate mode of storage for an object.
**    Mode of the storage is modified by the IPersistStorage methods:
**      Save, HandsOffStorage, and SaveCompleted.
*/
typedef enum tagSTGMODE {
	STGMODE_NORMAL      = 0,
	STGMODE_NOSCRIBBLE  = 1,
	STGMODE_HANDSOFF    = 2
} STGMODE;


/* Forward type definitions */
typedef struct tagSERVERAPP FAR* LPSERVERAPP;
typedef struct tagSERVERDOC FAR* LPSERVERDOC;
typedef struct tagPSEUDOOBJ FAR* LPPSEUDOOBJ;

typedef struct tagINPLACEDATA {
	OLEMENUGROUPWIDTHS      menuGroupWidths;
	HOLEMENU                hOlemenu;
	HMENU                   hMenuShared;
	LPOLEINPLACESITE        lpSite;
	LPOLEINPLACEUIWINDOW    lpDoc;
	LPOLEINPLACEFRAME       lpFrame;
	OLEINPLACEFRAMEINFO     frameInfo;
	HWND                    hWndFrame;
	BOOL                    fBorderOn;
	RECT                    rcPosRect;
	RECT                    rcClipRect;
} INPLACEDATA, FAR* LPINPLACEDATA;


/*************************************************************************
** class SERVERDOC : OLEDOC
**    SERVERDOC is an extention to the abstract base OLEDOC class.
**    The OLEDOC class defines the fields, methods and interfaces that
**    are common to both server and client implementations. The
**    SERVERDOC class adds the fields, methods and interfaces that are
**    specific to OLE 2.0 Server functionality. There is one instance
**    of SERVERDOC object created per document open in the app. The SDI
**    version of the app supports one SERVERDOC at a time. The MDI
**    version of the app can manage multiple documents at one time.
**    The SERVERDOC class inherits all fields from the OLEDOC class.
**    This inheritance is achieved by including a member variable of
**    type OLEDOC as the first field in the SERVERDOC structure. Thus a
**    pointer to a SERVERDOC object can be cast to be a pointer to a
**    OLEDOC object or an OUTLINEDOC object
*************************************************************************/

typedef struct tagSERVERDOC {
	OLEDOC              m_OleDoc;           // ServerDoc inherits from OleDoc
	ULONG               m_cPseudoObj;       // total count of pseudo obj's
	LPOLECLIENTSITE     m_lpOleClientSite;  // Client associated with the obj
	LPOLEADVISEHOLDER   m_lpOleAdviseHldr;  // helper obj to hold ole advises
	LPDATAADVISEHOLDER  m_lpDataAdviseHldr; // helper obj to hold data advises
	BOOL                m_fNoScribbleMode;  // was IPS::Save called
	BOOL                m_fSaveWithSameAsLoad;  // was IPS::Save called with
											// fSameAsLoad==TRUE.
	char                m_szContainerApp[MAXAPPNAME];
	char                m_szContainerObj[MAXCONTAINERNAME];
	ULONG               m_nNextRangeNo;     // next no. for unnamed range
	LINERANGE           m_lrSrcSelOfCopy;   // src sel if doc created for copy
	BOOL                m_fDataChanged;     // data changed when draw disabled
	BOOL                m_fSizeChanged;     // size changed when draw disabled
	BOOL                m_fSendDataOnStop;  // did data ever change?
#if defined( SVR_TREATAS )
	CLSID               m_clsidTreatAs;     // clsid to pretend to be
	LPSTR               m_lpszTreatAsType;  // user type name to pretend to be
#endif  // SVR_TREATAS

#if defined( LATER )
	// REVIEW: is it necessary to register a WildCard Moniker
	DWORD               m_dwWildCardRegROT; // key if wildcard reg'ed in ROT
#endif

#if defined( INPLACE_SVR )
	BOOL                m_fInPlaceActive;
	BOOL                m_fInPlaceVisible;
	BOOL                m_fUIActive;
	HWND                m_hWndParent;
	HWND                m_hWndHatch;
	LPINPLACEDATA       m_lpIPData;
	BOOL                m_fMenuHelpMode;// is F1 pressed in menu, give help

	struct CDocOleInPlaceObjectImpl {
		IOleInPlaceObjectVtbl FAR*  lpVtbl;
		LPSERVERDOC                 lpServerDoc;
		int                         cRef;   // interface specific ref count.
	} m_OleInPlaceObject;

	struct CDocOleInPlaceActiveObjectImpl {
		IOleInPlaceActiveObjectVtbl FAR* lpVtbl;
		LPSERVERDOC                      lpServerDoc;
		int                              cRef;// interface specific ref count.
	} m_OleInPlaceActiveObject;
#endif // INPLACE_SVR

	struct CDocOleObjectImpl {
		IOleObjectVtbl FAR*         lpVtbl;
		LPSERVERDOC                 lpServerDoc;
		int                         cRef;   // interface specific ref count.
	} m_OleObject;

	struct CDocPersistStorageImpl {
		IPersistStorageVtbl FAR*    lpVtbl;
		LPSERVERDOC                 lpServerDoc;
		int                         cRef;   // interface specific ref count.
	} m_PersistStorage;

#if defined( SVR_TREATAS )
	struct CDocStdMarshalInfoImpl {
		IStdMarshalInfoVtbl FAR*    lpVtbl;
		LPSERVERDOC                 lpServerDoc;
		int                         cRef;   // interface specific ref count.
	} m_StdMarshalInfo;
#endif  // SVR_TREATAS

} SERVERDOC;

/* ServerDoc methods (functions) */
BOOL ServerDoc_Init(LPSERVERDOC lpServerDoc, BOOL fDataTransferDoc);
BOOL ServerDoc_InitNewEmbed(LPSERVERDOC lpServerDoc);
void ServerDoc_PseudoObjUnlockDoc(
		LPSERVERDOC         lpServerDoc,
		LPPSEUDOOBJ         lpPseudoObj
);
void ServerDoc_PseudoObjLockDoc(LPSERVERDOC lpServerDoc);
BOOL ServerDoc_PasteFormatFromData(
		LPSERVERDOC             lpServerDoc,
		CLIPFORMAT              cfFormat,
		LPDATAOBJECT            lpSrcDataObj,
		BOOL                    fLocalDataObj,
		BOOL                    fLink
);
BOOL ServerDoc_QueryPasteFromData(
		LPSERVERDOC             lpServerDoc,
		LPDATAOBJECT            lpSrcDataObj,
		BOOL                    fLink
);
HRESULT ServerDoc_GetClassID(LPSERVERDOC lpServerDoc, LPCLSID lpclsid);
void ServerDoc_UpdateMenu(LPSERVERDOC lpServerDoc);
void ServerDoc_RestoreMenu(LPSERVERDOC lpServerDoc);
HRESULT ServerDoc_GetData (
		LPSERVERDOC             lpServerDoc,
		LPFORMATETC             lpformatetc,
		LPSTGMEDIUM             lpMedium
);
HRESULT ServerDoc_GetDataHere (
		LPSERVERDOC             lpServerDoc,
		LPFORMATETC             lpformatetc,
		LPSTGMEDIUM             lpMedium
);
HRESULT ServerDoc_QueryGetData(LPSERVERDOC lpServerDoc,LPFORMATETC lpformatetc);
HRESULT ServerDoc_EnumFormatEtc(
		LPSERVERDOC             lpServerDoc,
		DWORD                   dwDirection,
		LPENUMFORMATETC FAR*    lplpenumFormatEtc
);
HANDLE ServerDoc_GetMetafilePictData(
		LPSERVERDOC             lpServerDoc,
		LPLINERANGE             lplrSel
);
void ServerDoc_SendAdvise(
		LPSERVERDOC     lpServerDoc,
		WORD            wAdvise,
		LPMONIKER       lpmkDoc,
		DWORD           dwAdvf
);
HRESULT ServerDoc_GetObject(
		LPSERVERDOC             lpServerDoc,
		LPOLESTR		lpszItem,
		REFIID                  riid,
		LPVOID FAR*             lplpvObject
);
HRESULT ServerDoc_IsRunning(LPSERVERDOC lpServerDoc, LPOLESTR lpszItem);
LPMONIKER ServerDoc_GetSelRelMoniker(
		LPSERVERDOC             lpServerDoc,
		LPLINERANGE             lplrSel,
		DWORD                   dwAssign
);
LPMONIKER ServerDoc_GetSelFullMoniker(
		LPSERVERDOC             lpServerDoc,
		LPLINERANGE             lplrSel,
		DWORD                   dwAssign
);


#if defined( INPLACE_SVR )
HRESULT ServerDoc_DoInPlaceActivate(
		LPSERVERDOC     lpServerDoc,
		LONG            lVerb,
		LPMSG           lpmsg,
		LPOLECLIENTSITE lpActiveSite
);
HRESULT ServerDoc_DoInPlaceDeactivate(LPSERVERDOC lpServerDoc);
HRESULT ServerDoc_DoInPlaceHide(LPSERVERDOC lpServerDoc);
BOOL ServerDoc_AllocInPlaceData(LPSERVERDOC lpServerDoc);
void ServerDoc_FreeInPlaceData(LPSERVERDOC lpServerDoc);

HRESULT ServerDoc_AssembleMenus(LPSERVERDOC lpServerDoc);
void    ServerDoc_DisassembleMenus(LPSERVERDOC lpServerDoc);
void ServerDoc_CalcInPlaceWindowPos(
		LPSERVERDOC         lpServerDoc,
		LPRECT              lprcListBox,
		LPRECT              lprcDoc,
		LPSCALEFACTOR       lpscale
);
void ServerDoc_UpdateInPlaceWindowOnExtentChange(LPSERVERDOC lpServerDoc);
void ServerDoc_ResizeInPlaceWindow(
		LPSERVERDOC         lpServerDoc,
		LPCRECT             lprcPosRect,
		LPCRECT             lprcClipRect
);
void ServerDoc_ShadeInPlaceBorder(LPSERVERDOC lpServerDoc, BOOL fShadeOn);
void ServerDoc_SetStatusText(LPSERVERDOC lpServerDoc, LPSTR lpszMessage);
LPOLEINPLACEFRAME ServerDoc_GetTopInPlaceFrame(LPSERVERDOC lpServerDoc);
void ServerDoc_GetSharedMenuHandles(
		LPSERVERDOC lpServerDoc,
		HMENU FAR*      lphSharedMenu,
		HOLEMENU FAR*   lphOleMenu
);
void ServerDoc_AddFrameLevelUI(LPSERVERDOC lpServerDoc);
void ServerDoc_AddFrameLevelTools(LPSERVERDOC lpServerDoc);
void ServerDoc_UIActivate (LPSERVERDOC lpServerDoc);

#if defined( USE_FRAMETOOLS )
void ServerDoc_RemoveFrameLevelTools(LPSERVERDOC lpServerDoc);
#endif // USE_FRAMETOOLS

#endif // INPLACE_SVR


/* ServerDoc::IOleObject methods (functions) */
STDMETHODIMP SvrDoc_OleObj_QueryInterface(
		LPOLEOBJECT             lpThis,
		REFIID                  riid,
		LPVOID FAR*             lplpvObj
);
STDMETHODIMP_(ULONG) SvrDoc_OleObj_AddRef(LPOLEOBJECT lpThis);
STDMETHODIMP_(ULONG) SvrDoc_OleObj_Release(LPOLEOBJECT lpThis);
STDMETHODIMP SvrDoc_OleObj_SetClientSite(
		LPOLEOBJECT             lpThis,
		LPOLECLIENTSITE         lpclientSite
);
STDMETHODIMP SvrDoc_OleObj_GetClientSite(
		LPOLEOBJECT             lpThis,
		LPOLECLIENTSITE FAR*    lplpClientSite
);
STDMETHODIMP SvrDoc_OleObj_SetHostNames(
		LPOLEOBJECT             lpThis,
		LPCOLESTR		szContainerApp,
		LPCOLESTR		szContainerObj
);
STDMETHODIMP SvrDoc_OleObj_Close(
		LPOLEOBJECT             lpThis,
		DWORD                   dwSaveOption
);
STDMETHODIMP SvrDoc_OleObj_SetMoniker(
		LPOLEOBJECT             lpThis,
		DWORD                   dwWhichMoniker,
		LPMONIKER               lpmk
);
STDMETHODIMP SvrDoc_OleObj_GetMoniker(
		LPOLEOBJECT             lpThis,
		DWORD                   dwAssign,
		DWORD                   dwWhichMoniker,
		LPMONIKER FAR*          lplpmk
);
STDMETHODIMP SvrDoc_OleObj_InitFromData(
		LPOLEOBJECT             lpThis,
		LPDATAOBJECT            lpDataObject,
		BOOL                    fCreation,
		DWORD                   reserved
);
STDMETHODIMP SvrDoc_OleObj_GetClipboardData(
		LPOLEOBJECT             lpThis,
		DWORD                   reserved,
		LPDATAOBJECT FAR*       lplpDataObject
);
STDMETHODIMP SvrDoc_OleObj_DoVerb(
		LPOLEOBJECT             lpThis,
		LONG                    lVerb,
		LPMSG                   lpmsg,
		LPOLECLIENTSITE         lpActiveSite,
		LONG                    lindex,
		HWND                    hwndParent,
		LPCRECT                 lprcPosRect
);
STDMETHODIMP SvrDoc_OleObj_EnumVerbs(
		LPOLEOBJECT             lpThis,
		LPENUMOLEVERB FAR*      lplpenumOleVerb
);
STDMETHODIMP SvrDoc_OleObj_Update(LPOLEOBJECT lpThis);
STDMETHODIMP SvrDoc_OleObj_IsUpToDate(LPOLEOBJECT lpThis);
STDMETHODIMP SvrDoc_OleObj_GetUserClassID(
		LPOLEOBJECT             lpThis,
		LPCLSID                 lpclsid
);
STDMETHODIMP SvrDoc_OleObj_GetUserType(
		LPOLEOBJECT             lpThis,
		DWORD                   dwFormOfType,
		LPOLESTR FAR*		lpszUserType
);
STDMETHODIMP SvrDoc_OleObj_SetExtent(
		LPOLEOBJECT             lpThis,
		DWORD                   dwDrawAspect,
		LPSIZEL                 lplgrc
);
STDMETHODIMP SvrDoc_OleObj_GetExtent(
		LPOLEOBJECT             lpThis,
		DWORD                   dwDrawAspect,
		LPSIZEL                 lplgrc
);
STDMETHODIMP SvrDoc_OleObj_Advise(
		LPOLEOBJECT             lpThis,
		LPADVISESINK            lpAdvSink,
		LPDWORD                 lpdwConnection
);
STDMETHODIMP SvrDoc_OleObj_Unadvise(LPOLEOBJECT lpThis, DWORD dwConnection);
STDMETHODIMP SvrDoc_OleObj_EnumAdvise(
		LPOLEOBJECT             lpThis,
		LPENUMSTATDATA FAR*     lplpenumAdvise
);
STDMETHODIMP SvrDoc_OleObj_GetMiscStatus(
		LPOLEOBJECT             lpThis,
		DWORD                   dwAspect,
		DWORD FAR*              lpdwStatus
);
STDMETHODIMP SvrDoc_OleObj_SetColorScheme(
		LPOLEOBJECT             lpThis,
		LPLOGPALETTE            lpLogpal
);
STDMETHODIMP SvrDoc_OleObj_LockObject(
		LPOLEOBJECT             lpThis,
		BOOL                    fLock
);

/* ServerDoc::IPersistStorage methods (functions) */
STDMETHODIMP SvrDoc_PStg_QueryInterface(
		LPPERSISTSTORAGE        lpThis,
		REFIID                  riid,
		LPVOID FAR*             lplpvObj
);
STDMETHODIMP_(ULONG) SvrDoc_PStg_AddRef(LPPERSISTSTORAGE lpThis);
STDMETHODIMP_(ULONG) SvrDoc_PStg_Release(LPPERSISTSTORAGE lpThis);
STDMETHODIMP SvrDoc_PStg_GetClassID(
		LPPERSISTSTORAGE        lpThis,
		LPCLSID                 lpClassID
);
STDMETHODIMP  SvrDoc_PStg_IsDirty(LPPERSISTSTORAGE  lpThis);
STDMETHODIMP SvrDoc_PStg_InitNew(
		LPPERSISTSTORAGE        lpThis,
		LPSTORAGE               lpStg
);
STDMETHODIMP SvrDoc_PStg_Load(
		LPPERSISTSTORAGE        lpThis,
		LPSTORAGE               lpStg
);
STDMETHODIMP SvrDoc_PStg_Save(
		LPPERSISTSTORAGE        lpThis,
		LPSTORAGE               lpStg,
		BOOL                    fSameAsLoad
);
STDMETHODIMP SvrDoc_PStg_SaveCompleted(
		LPPERSISTSTORAGE        lpThis,
		LPSTORAGE               lpStgNew
);
STDMETHODIMP SvrDoc_PStg_HandsOffStorage(LPPERSISTSTORAGE lpThis);


#if defined( SVR_TREATAS )

/* ServerDoc::IStdMarshalInfo methods (functions) */
STDMETHODIMP SvrDoc_StdMshl_QueryInterface(
		LPSTDMARSHALINFO        lpThis,
		REFIID                  riid,
		LPVOID FAR*             lplpvObj
);
STDMETHODIMP_(ULONG) SvrDoc_StdMshl_AddRef(LPSTDMARSHALINFO lpThis);
STDMETHODIMP_(ULONG) SvrDoc_StdMshl_Release(LPSTDMARSHALINFO lpThis);
STDMETHODIMP SvrDoc_StdMshl_GetClassForHandler(
		LPSTDMARSHALINFO        lpThis,
		DWORD                   dwDestContext,
		LPVOID                  pvDestContext,
		LPCLSID                 lpClassID
);
#endif  // SVR_TREATAS

/*************************************************************************
** class SERVERAPP : OLEAPP
**    SERVERAPP is an extention to the abstract base OLEAPP class.
**    The OLEAPP class defines the fields, methods and interfaces that
**    are common to both server and client implementations. The
**    SERVERAPP class adds the fields and methods that are specific to
**    OLE 2.0 Server functionality. There is one instance of
**    SERVERAPP object created per running application instance. This
**    object holds many fields that could otherwise be organized as
**    global variables. The SERVERAPP class inherits all fields
**    from the OLEAPP class. This inheritance is achieved by including a
**    member variable of type OLEAPP as the first field in the SERVERAPP
**    structure. OLEAPP inherits from OLEAPP. This inheritance is
**    achieved in the same manner. Thus a pointer to a SERVERAPP object
**    can be cast to be a pointer to an OLEAPP or an OUTLINEAPP object
*************************************************************************/

typedef struct tagSERVERAPP {
	OLEAPP      m_OleApp;       // ServerApp inherits all fields of OleApp

#if defined( INPLACE_SVR )
	HACCEL  m_hAccelIPSvr; // accelerators for server's active object commands
	HACCEL  m_hAccelBaseApp;    // normal accel for non-inplace server mode
	HMENU   m_hMenuEdit;   // handle to Edit menu of the server app
	HMENU   m_hMenuLine;   // handle to Line menu of the server app
	HMENU   m_hMenuName;   // handle to Name menu of the server app
	HMENU   m_hMenuOptions; // handle to Options menu of the server app
	HMENU   m_hMenuDebug;       // handle to Debug menu of the server app
	HMENU   m_hMenuHelp;   // handle to Help menu of the server app
	LPINPLACEDATA   m_lpIPData;
#endif

} SERVERAPP;

/* ServerApp methods (functions) */
BOOL ServerApp_InitInstance(
		LPSERVERAPP             lpServerApp,
		HINSTANCE               hInst,
		int                     nCmdShow
);
BOOL ServerApp_InitVtbls (LPSERVERAPP lpServerApp);



/*************************************************************************
** class SERVERNAME : OUTLINENAME
**    SERVERNAME class is an extension to the OUTLINENAME base class that
**    adds functionallity required to support linking to ranges (pseudo
**    objects). Pseudo objects are used to allow linking to a range
**    (sub-selection) of a SERVERDOC document. The base class OUTLINENAME
**    stores a particular named selection in the document. The
**    NAMETABLE class holds all of the names defined in a particular
**    document. Each OUTLINENAME object has a string as its key and a
**    starting line index and an ending line index for the named range.
**    The SERVERNAME class, also, stores a pointer to a PSEUDOOBJ if one
**    has been allocated that corresponds to the named selection.
**    The SERVERNAME class inherits all fields from the OUTLINENAME class.
**    This inheritance is achieved by including a member variable of
**    type OUTLINENAME as the first field in the SERVERNAME
**    structure. Thus a pointer to an SERVERNAME object can be cast to be
**    a pointer to a OUTLINENAME object.
*************************************************************************/

typedef struct tagSERVERNAME {
	OUTLINENAME     m_Name;         // ServerName inherits all fields of Name
	LPPSEUDOOBJ m_lpPseudoObj;  // ptr to pseudo object if allocated
} SERVERNAME, FAR* LPSERVERNAME;

/* ServerName methods (functions) */
void ServerName_SetSel(
		LPSERVERNAME            lpServerName,
		LPLINERANGE             lplrSel,
		BOOL                    fRangeModified
);
void ServerName_SendPendingAdvises(LPSERVERNAME lpServerName);
LPPSEUDOOBJ ServerName_GetPseudoObj(
		LPSERVERNAME            lpServerName,
		LPSERVERDOC             lpServerDoc
);
void ServerName_ClosePseudoObj(LPSERVERNAME lpServerName);


/*************************************************************************
** class PSEUDOOBJ
**    The PSEUDOOBJ (pseudo object) is a concrete class. A pseudo object
**    is created when a link is made to a range of lines within an
**    SERVERDOC document. A pseudo object is dependent on the existance
**    of the SERVERDOC which represents the whole document.
*************************************************************************/

typedef struct tagPSEUDOOBJ {
	ULONG               m_cRef;             // total ref count for obj
	BOOL                m_fObjIsClosing;    // flag to guard recursive close
	LPSERVERNAME        m_lpName;           // named range for this pseudo obj
	LPSERVERDOC         m_lpDoc;            // ptr to whole document
	LPOLEADVISEHOLDER   m_lpOleAdviseHldr;  // helper obj to hold ole advises
	LPDATAADVISEHOLDER  m_lpDataAdviseHldr; // helper obj to hold data advises
	BOOL                m_fDataChanged;     // data changed when draw disabled

	struct CPseudoObjUnknownImpl {
		IUnknownVtbl FAR*       lpVtbl;
		LPPSEUDOOBJ             lpPseudoObj;
		int                     cRef;   // interface specific ref count.
	} m_Unknown;

	struct CPseudoObjOleObjectImpl {
		IOleObjectVtbl FAR*     lpVtbl;
		LPPSEUDOOBJ             lpPseudoObj;
		int                     cRef;   // interface specific ref count.
	} m_OleObject;

	struct CPseudoObjDataObjectImpl {
		IDataObjectVtbl FAR*    lpVtbl;
		LPPSEUDOOBJ             lpPseudoObj;
		int                     cRef;   // interface specific ref count.
	} m_DataObject;

} PSEUDOOBJ;

/* PseudoObj methods (functions) */
void PseudoObj_Init(
		LPPSEUDOOBJ             lpPseudoObj,
		LPSERVERNAME            lpServerName,
		LPSERVERDOC             lpServerDoc
);
ULONG PseudoObj_AddRef(LPPSEUDOOBJ lpPseudoObj);
ULONG PseudoObj_Release(LPPSEUDOOBJ lpPseudoObj);
HRESULT PseudoObj_QueryInterface(
		LPPSEUDOOBJ         lpPseudoObj,
		REFIID              riid,
		LPVOID FAR*         lplpUnk
);
BOOL PseudoObj_Close(LPPSEUDOOBJ lpPseudoObj);
void PseudoObj_Destroy(LPPSEUDOOBJ lpPseudoObj);
void PseudoObj_GetSel(LPPSEUDOOBJ lpPseudoObj, LPLINERANGE lplrSel);
void PseudoObj_GetExtent(LPPSEUDOOBJ lpPseudoObj, LPSIZEL lpsizel);
void PseudoObj_GetExtent(LPPSEUDOOBJ lpPseudoObj, LPSIZEL lpsizel);
void PseudoObj_SendAdvise(
		LPPSEUDOOBJ lpPseudoObj,
		WORD        wAdvise,
		LPMONIKER   lpmkObj,
		DWORD       dwAdvf
);
LPMONIKER PseudoObj_GetFullMoniker(LPPSEUDOOBJ lpPseudoObj, LPMONIKER lpmkDoc);

/* PseudoObj::IUnknown methods (functions) */
STDMETHODIMP PseudoObj_Unk_QueryInterface(
		LPUNKNOWN         lpThis,
		REFIID            riid,
		LPVOID FAR*       lplpvObj
);
STDMETHODIMP_(ULONG) PseudoObj_Unk_AddRef(LPUNKNOWN lpThis);
STDMETHODIMP_(ULONG) PseudoObj_Unk_Release (LPUNKNOWN lpThis);

/* PseudoObj::IOleObject methods (functions) */
STDMETHODIMP PseudoObj_OleObj_QueryInterface(
		LPOLEOBJECT     lpThis,
		REFIID          riid,
		LPVOID FAR*     lplpvObj
);
STDMETHODIMP_(ULONG) PseudoObj_OleObj_AddRef(LPOLEOBJECT lpThis);
STDMETHODIMP_(ULONG) PseudoObj_OleObj_Release(LPOLEOBJECT lpThis);
STDMETHODIMP PseudoObj_OleObj_SetClientSite(
		LPOLEOBJECT         lpThis,
		LPOLECLIENTSITE     lpClientSite
);
STDMETHODIMP PseudoObj_OleObj_GetClientSite(
		LPOLEOBJECT             lpThis,
		LPOLECLIENTSITE FAR*    lplpClientSite
);
STDMETHODIMP PseudoObj_OleObj_SetHostNames(
		LPOLEOBJECT             lpThis,
		LPCOLESTR		szContainerApp,
		LPCOLESTR		szContainerObj
);
STDMETHODIMP PseudoObj_OleObj_Close(
		LPOLEOBJECT             lpThis,
		DWORD                   dwSaveOption
);
STDMETHODIMP PseudoObj_OleObj_SetMoniker(
		LPOLEOBJECT lpThis,
		DWORD       dwWhichMoniker,
		LPMONIKER   lpmk
);
STDMETHODIMP PseudoObj_OleObj_GetMoniker(
		LPOLEOBJECT     lpThis,
		DWORD           dwAssign,
		DWORD           dwWhichMoniker,
		LPMONIKER FAR*  lplpmk
);
STDMETHODIMP PseudoObj_OleObj_InitFromData(
		LPOLEOBJECT             lpThis,
		LPDATAOBJECT            lpDataObject,
		BOOL                    fCreation,
		DWORD                   reserved
);
STDMETHODIMP PseudoObj_OleObj_GetClipboardData(
		LPOLEOBJECT             lpThis,
		DWORD                   reserved,
		LPDATAOBJECT FAR*       lplpDataObject
);
STDMETHODIMP PseudoObj_OleObj_DoVerb(
		LPOLEOBJECT             lpThis,
		LONG                    lVerb,
		LPMSG                   lpmsg,
		LPOLECLIENTSITE         lpActiveSite,
		LONG                    lindex,
		HWND                    hwndParent,
		LPCRECT                 lprcPosRect
);
STDMETHODIMP PseudoObj_OleObj_EnumVerbs(
		LPOLEOBJECT         lpThis,
		LPENUMOLEVERB FAR*  lplpenumOleVerb
);
STDMETHODIMP PseudoObj_OleObj_Update(LPOLEOBJECT lpThis);
STDMETHODIMP PseudoObj_OleObj_IsUpToDate(LPOLEOBJECT lpThis);
STDMETHODIMP PseudoObj_OleObj_GetUserClassID(
		LPOLEOBJECT             lpThis,
		LPCLSID                 lpclsid
);
STDMETHODIMP PseudoObj_OleObj_GetUserType(
		LPOLEOBJECT             lpThis,
		DWORD                   dwFormOfType,
		LPOLESTR FAR*		lpszUserType
);
STDMETHODIMP PseudoObj_OleObj_SetExtent(
		LPOLEOBJECT             lpThis,
		DWORD                   dwDrawAspect,
		LPSIZEL                 lplgrc
);
STDMETHODIMP PseudoObj_OleObj_GetExtent(
		LPOLEOBJECT             lpThis,
		DWORD                   dwDrawAspect,
		LPSIZEL                 lplgrc
);
STDMETHODIMP PseudoObj_OleObj_Advise(
		LPOLEOBJECT lpThis,
		LPADVISESINK lpAdvSink,
		LPDWORD lpdwConnection
);
STDMETHODIMP PseudoObj_OleObj_Unadvise(LPOLEOBJECT lpThis,DWORD dwConnection);
STDMETHODIMP PseudoObj_OleObj_EnumAdvise(
		LPOLEOBJECT lpThis,
		LPENUMSTATDATA FAR* lplpenumAdvise
);
STDMETHODIMP PseudoObj_OleObj_GetMiscStatus(
		LPOLEOBJECT             lpThis,
		DWORD                   dwAspect,
		DWORD FAR*              lpdwStatus
);
STDMETHODIMP PseudoObj_OleObj_SetColorScheme(
		LPOLEOBJECT             lpThis,
		LPLOGPALETTE            lpLogpal
);
STDMETHODIMP PseudoObj_OleObj_LockObject(
		LPOLEOBJECT             lpThis,
		BOOL                    fLock
);

/* PseudoObj::IDataObject methods (functions) */
STDMETHODIMP PseudoObj_DataObj_QueryInterface (
		LPDATAOBJECT      lpThis,
		REFIID            riid,
		LPVOID FAR*       lplpvObj
);
STDMETHODIMP_(ULONG) PseudoObj_DataObj_AddRef(LPDATAOBJECT lpThis);
STDMETHODIMP_(ULONG) PseudoObj_DataObj_Release (LPDATAOBJECT lpThis);
STDMETHODIMP PseudoObj_DataObj_GetData (
		LPDATAOBJECT    lpThis,
		LPFORMATETC     lpformatetc,
		LPSTGMEDIUM     lpMedium
);
STDMETHODIMP PseudoObj_DataObj_GetDataHere (
		LPDATAOBJECT    lpThis,
		LPFORMATETC     lpformatetc,
		LPSTGMEDIUM     lpMedium
);
STDMETHODIMP PseudoObj_DataObj_QueryGetData (
		LPDATAOBJECT    lpThis,
		LPFORMATETC     lpformatetc
);
STDMETHODIMP PseudoObj_DataObj_GetCanonicalFormatEtc (
		LPDATAOBJECT    lpThis,
		LPFORMATETC     lpformatetc,
		LPFORMATETC     lpformatetcOut
);
STDMETHODIMP PseudoObj_DataObj_SetData (
		LPDATAOBJECT    lpThis,
		LPFORMATETC     lpformatetc,
		LPSTGMEDIUM     lpmedium,
		BOOL            fRelease
);
STDMETHODIMP PseudoObj_DataObj_EnumFormatEtc(
		LPDATAOBJECT            lpThis,
		DWORD                   dwDirection,
		LPENUMFORMATETC FAR*    lplpenumFormatEtc
);
STDMETHODIMP PseudoObj_DataObj_DAdvise(
		LPDATAOBJECT    lpThis,
		FORMATETC FAR*  lpFormatetc,
		DWORD           advf,
		LPADVISESINK    lpAdvSink,
		DWORD FAR*      lpdwConnection
);
STDMETHODIMP PseudoObj_DataObj_DUnadvise(LPDATAOBJECT lpThis, DWORD dwConnection);
STDMETHODIMP PseudoObj_DataObj_EnumAdvise(
		LPDATAOBJECT lpThis,
		LPENUMSTATDATA FAR* lplpenumAdvise
);


/*************************************************************************
** class SERVERNAMETABLE : OUTLINENAMETABLE
**    SERVERNAMETABLE class is an extension to the OUTLINENAMETABLE
**    base class that adds functionallity required to support linking
**    to ranges (pseudo objects). The name table manages the table of
**    named selections in the document. Each name table entry has a
**    string as its key and a starting line index and an ending line
**    index for the named range. The SERVERNAMETABLE entries, in
**    addition, maintain a pointer to a PSEUDOOBJ pseudo object if one
**    has been already allocated. There is always one instance of
**    SERVERNAMETABLE for each SERVERDOC object created.
**    The SERVERNAME class inherits all fields from the NAME class.
**    This inheritance is achieved by including a member variable of
**    type NAME as the first field in the SERVERNAME
**    structure. Thus a pointer to an SERVERNAME object can be cast to be
**    a pointer to a NAME object.
*************************************************************************/

typedef struct tagSERVERNAMETABLE {
	OUTLINENAMETABLE    m_NameTable;    // we inherit from OUTLINENAMETABLE

	// ServerNameTable does NOT add any fields

} SERVERNAMETABLE, FAR* LPSERVERNAMETABLE;

/* ServerNameTable methods (functions) */
void ServerNameTable_EditLineUpdate(
		LPSERVERNAMETABLE       lpServerNameTable,
		int                     nEditIndex
);
void ServerNameTable_InformAllPseudoObjectsDocRenamed(
		LPSERVERNAMETABLE       lpServerNameTable,
		LPMONIKER               lpmkDoc
);
void ServerNameTable_InformAllPseudoObjectsDocSaved(
		LPSERVERNAMETABLE       lpServerNameTable,
		LPMONIKER               lpmkDoc
);
void ServerNameTable_SendPendingAdvises(LPSERVERNAMETABLE lpServerNameTable);
LPPSEUDOOBJ ServerNameTable_GetPseudoObj(
		LPSERVERNAMETABLE       lpServerNameTable,
		LPSTR                   lpszItem,
		LPSERVERDOC             lpServerDoc
);
void ServerNameTable_CloseAllPseudoObjs(LPSERVERNAMETABLE lpServerNameTable);


#if defined( INPLACE_SVR)

/* ServerDoc::IOleInPlaceObject methods (functions) */

STDMETHODIMP SvrDoc_IPObj_QueryInterface(
		LPOLEINPLACEOBJECT  lpThis,
		REFIID              riid,
		LPVOID FAR *        lplpvObj
);
STDMETHODIMP_(ULONG) SvrDoc_IPObj_AddRef(LPOLEINPLACEOBJECT lpThis);
STDMETHODIMP_(ULONG) SvrDoc_IPObj_Release(LPOLEINPLACEOBJECT lpThis);
STDMETHODIMP SvrDoc_IPObj_GetWindow(
		LPOLEINPLACEOBJECT  lpThis,
		HWND FAR*           lphwnd
);
STDMETHODIMP SvrDoc_IPObj_ContextSensitiveHelp(
		LPOLEINPLACEOBJECT  lpThis,
		BOOL                fEnable
);
STDMETHODIMP SvrDoc_IPObj_InPlaceDeactivate(LPOLEINPLACEOBJECT lpThis);
STDMETHODIMP SvrDoc_IPObj_UIDeactivate(LPOLEINPLACEOBJECT lpThis);
STDMETHODIMP SvrDoc_IPObj_SetObjectRects(
		LPOLEINPLACEOBJECT  lpThis,
		LPCRECT             lprcPosRect,
		LPCRECT             lprcClipRect
);
STDMETHODIMP SvrDoc_IPObj_ReactivateAndUndo(LPOLEINPLACEOBJECT lpThis);

/* ServerDoc::IOleInPlaceActiveObject methods (functions) */

STDMETHODIMP SvrDoc_IPActiveObj_QueryInterface(
		LPOLEINPLACEACTIVEOBJECT    lpThis,
		REFIID                      riidReq,
		LPVOID FAR *                lplpUnk
);
STDMETHODIMP_(ULONG) SvrDoc_IPActiveObj_AddRef(
		LPOLEINPLACEACTIVEOBJECT lpThis
);
STDMETHODIMP_(ULONG) SvrDoc_IPActiveObj_Release(
		LPOLEINPLACEACTIVEOBJECT lpThis
);
STDMETHODIMP SvrDoc_IPActiveObj_GetWindow(
		LPOLEINPLACEACTIVEOBJECT    lpThis,
		HWND FAR*                   lphwnd
);
STDMETHODIMP SvrDoc_IPActiveObj_ContextSensitiveHelp(
		LPOLEINPLACEACTIVEOBJECT    lpThis,
		BOOL                        fEnable
);
STDMETHODIMP SvrDoc_IPActiveObj_TranslateAccelerator(
		LPOLEINPLACEACTIVEOBJECT    lpThis,
		LPMSG                       lpmsg
);
STDMETHODIMP SvrDoc_IPActiveObj_OnFrameWindowActivate(
		LPOLEINPLACEACTIVEOBJECT    lpThis,
		BOOL                        fActivate
);
STDMETHODIMP SvrDoc_IPActiveObj_OnDocWindowActivate(
		LPOLEINPLACEACTIVEOBJECT    lpThis,
		BOOL                        fActivate
);
STDMETHODIMP SvrDoc_IPActiveObj_ResizeBorder(
		LPOLEINPLACEACTIVEOBJECT    lpThis,
		LPCRECT                     lprectBorder,
		LPOLEINPLACEUIWINDOW        lpIPUiWnd,
		BOOL                        fFrameWindow
);
STDMETHODIMP SvrDoc_IPActiveObj_EnableModeless(
		LPOLEINPLACEACTIVEOBJECT    lpThis,
		BOOL                        fEnable
);

#endif // INPLACE_SVR

#endif // _SVROUTL_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\memalloc\headers.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:	headers.cxx
//
//  Contents:	Memory allocation unit test headers
//
//  History:	13-Aug-93   CarlH	Created
//
//--------------------------------------------------------------------------
#include "memtest.hxx"
#pragma  hdrstop
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\memalloc\midl.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:	midl.cxx
//
//  Contents:	MIDL memory allocation tests
//
//  Functions:
//
//  History:	29-Sep-93   CarlH	Created
//
//--------------------------------------------------------------------------
#include "memtest.hxx"
#pragma  hdrstop
#include <rpc.h>
#include "test.h"


static const char   g_szMIDLClient[] = "midl";
static const char   g_szMIDLServer[] = "server";

static const WCHAR  g_wszMIDLSignal[] = L"testsignal";
static const WCHAR  g_wszStopSignal[] = L"stopsignal";

static const DWORD  g_ccallMin	    = 1;
static const DWORD  g_ccallMax	    = 1;

static CSignal	    g_sigStop(g_wszStopSignal);


BYTE		g_ab0[] = {0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07};
BYTE		g_ab1[] = {0x00, 0xFF};
BYTE		g_ab2[] = {0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF};
BYTE		g_ab3[] = {0x69};

SCountedBytes	g_acbIn[] =
{
    {(sizeof(g_ab0) / sizeof(g_ab0[0])), g_ab0},
    {(sizeof(g_ab1) / sizeof(g_ab1[0])), g_ab1},
    {(sizeof(g_ab2) / sizeof(g_ab2[0])), g_ab2},
    {(sizeof(g_ab3) / sizeof(g_ab3[0])), g_ab3}
};


SCountedCountedBytes	g_ccbIn =
{
    sizeof(g_acbIn) / sizeof(g_acbIn[0]),
    g_acbIn
};


DWORD	StartServer(WCHAR *pwszServer, DWORD grfOptions);
DWORD	ConnectServer(void);
DWORD	DisconnectServer(void);

BOOL	CompareBytes(SCountedCountedBytes *pccbA, SCountedCountedBytes *pccbB);
BOOL	FreeBytes(SCountedCountedBytes *pccb);

BOOL TestMIDLClient(WCHAR *pwszServer, DWORD grfOptions)
{
    CSignal		    sig(g_wszMIDLSignal);
    SCountedCountedBytes    ccbOut = {0, NULL};
    RPC_STATUS		    stat;
    BOOL		    fPassed;

    PrintHeader(g_szMIDLClient);

    PrintTrace(g_szMIDLClient, "starting server\n");
    stat = StartServer(pwszServer, grfOptions);
    if (!(fPassed = (stat == 0)))
	goto done;

    PrintTrace(g_szMIDLClient, "waiting for server\n");
    stat = sig.Wait(grfOptions & MIDL_DEBUG ? INFINITE : 10000);
    if (!(fPassed = (stat == 0)))
	goto done;

    PrintTrace(g_szMIDLClient, "connecting to server\n");
    stat = ConnectServer();
    if (!(fPassed = (stat == 0)))
	goto done;

    PrintTrace(g_szMIDLClient, "copying bytes\n");
    fPassed = _CopyBytes(&g_ccbIn, &ccbOut);
    if (!fPassed)
	goto done;

    PrintTrace(g_szMIDLClient, "stopping server\n");
    fPassed = _StopServer();
    if (!fPassed)
	goto done;

    PrintTrace(g_szMIDLClient, "comparing bytes\n");
    fPassed = CompareBytes(&g_ccbIn, &ccbOut);
    if (!fPassed)
	goto done;

    PrintTrace(g_szMIDLClient, "freeing bytes\n");
    fPassed = FreeBytes(&ccbOut);
    if (!fPassed)
	goto done;

    PrintTrace(g_szMIDLClient, "disconnecting from server\n");
    stat = DisconnectServer();
    if (!(fPassed = (stat == 0)))
	goto done;

done:
    PrintResult(g_szMIDLClient, fPassed);

    return (fPassed);
}


BOOL TestMIDLServer(DWORD grfOptions)
{
    CSignal	sig(g_wszMIDLSignal);
    RPC_STATUS	stat;
    BOOL	fPassed;

    PrintHeader(g_szMIDLServer);

    PrintTrace(g_szMIDLServer, "registering protocol\n");
    stat = RpcServerUseAllProtseqsIf(g_ccallMax, Test_ServerIfHandle, NULL);
    if (!(fPassed = (stat == 0)))
	goto done;

    PrintTrace(g_szMIDLServer, "registering interface\n");
    stat = RpcServerRegisterIf(Test_ServerIfHandle, NULL, NULL);
    if (!(fPassed = (stat == 0)))
	goto done;

#ifdef NO_OLE_RPC
    PrintTrace(g_szMIDLServer, "listening\n");
    stat = RpcServerListen(
	g_ccallMin,
	g_ccallMax,
	TRUE);
    if (!(fPassed = ((stat == 0) || (stat == RPC_S_ALREADY_LISTENING))))
	goto done;
#endif // NO_OLE_RPC

    PrintTrace(g_szMIDLServer, "signaling client\n");
    stat = sig.Signal();
    if (!(fPassed = (stat == 0)))
	goto done;

    PrintTrace(g_szMIDLServer, "waiting...\n");
#ifdef NO_OLE_RPC
    stat = RpcMgmtWaitServerListen();
    if (!(fPassed = ((stat == 0) || (stat == RPC_S_ALREADY_LISTENING))))
	goto done;
#else
    g_sigStop.Wait();
#endif // NO_OLE_RPC


done:
    PrintResult(g_szMIDLServer, fPassed);

    return (fPassed);
}


boolean CopyBytes(SCountedCountedBytes *pccbIn, SCountedCountedBytes *pccbOut)
{
    HRESULT hr;
    BOOL    fPassed;
    long    ccb = pccbIn->ccb;
    long    icb;

    PrintTrace(g_szMIDLServer, "copying bytes\n");

    pccbOut->ccb = ccb;

    pccbOut->pcb = (SCountedBytes *)CoTaskMemAlloc(ccb * sizeof(*pccbOut->pcb));
    if (!(fPassed = (pccbOut != 0)))
	goto done;

    for (icb = 0; icb < ccb; icb++)
    {
	long	cb = pccbIn->pcb[icb].cb;

	pccbOut->pcb[icb].cb = cb;

	pccbOut->pcb[icb].pb = (byte *)CoTaskMemAlloc(cb);
	if (!(fPassed = (pccbOut->pcb[icb].pb != 0)))
	    goto done;

	memcpy(pccbOut->pcb[icb].pb, pccbIn->pcb[icb].pb, cb);
    }

done:
    return (fPassed);
}


BOOL CompareBytes(SCountedCountedBytes *pccbA, SCountedCountedBytes *pccbB)
{
    BOOL    fPassed;
    long    icb;

    if (!(fPassed = (pccbA->ccb == pccbB->ccb)))
	goto done;

    for (icb = 0; icb < pccbA->ccb; icb++)
    {
	if (!(fPassed = (pccbA->pcb[icb].cb == pccbB->pcb[icb].cb)))
	    goto done;

	int cmp = memcmp(
	    pccbA->pcb[icb].pb,
	    pccbB->pcb[icb].pb,
	    pccbB->pcb[icb].cb);
	if (!(fPassed = (cmp == 0)))
	    goto done;
    }

done:
    return (fPassed);
}


BOOL FreeBytes(SCountedCountedBytes *pccb)
{
    BOOL    fPassed = TRUE;

    for (long icb = 0; icb < pccb->ccb; icb++)
    {
	CoTaskMemFree(pccb->pcb[icb].pb);
    }

    CoTaskMemFree(pccb->pcb);

done:
    return (fPassed);
}


boolean StopServer(void)
{
    BOOL    fPassed;

    PrintTrace(g_szMIDLServer, "stopping\n");

#ifdef NO_OLE_RPC
    fPassed = (RpcMgmtStopServerListening(NULL) == 0);
#else
    g_sigStop.Signal();
    fPassed = TRUE;
#endif // NO_OLE_RPC

    return (fPassed);
}


DWORD StartServer(WCHAR *pwszServer, DWORD grfOptions)
{
    WCHAR	wszCommandLine[MAX_PATH + 1];
    ULONG	cwchDebug;
    BOOL	fOK;
    DWORD	stat;

    if (grfOptions & MIDL_DEBUG)
    {
	cwchDebug = wsprintf(
	    wszCommandLine,
	    L"ntsd %ws %ws ",
	    (grfOptions & MIDL_AUTOGO  ? L"-g" : L""),
	    (grfOptions & MIDL_AUTOEND ? L"-G" : L""));
    }
    else
    {
	cwchDebug = 0;
    }

    wsprintf(
	wszCommandLine + cwchDebug,
	L"%ws midlserver %cc %cs %cv",
	pwszServer,
	(grfOptions & GLOBAL_CLEANUP ? '+' : '-'),
	(grfOptions & GLOBAL_STATUS  ? '+' : '-'),
	(grfOptions & GLOBAL_VERBOSE ? '+' : '-'));

    PrintTrace(g_szMIDLClient, "server command line: %ws\n", wszCommandLine);

    STARTUPINFO 	sui;
    PROCESS_INFORMATION pi;

    sui.cb	    = sizeof(sui);
    sui.lpReserved  = 0;
    sui.lpDesktop   = 0;
    sui.lpTitle     = wszCommandLine;
    sui.dwFlags     = 0;
    sui.cbReserved2 = 0;
    sui.lpReserved2 = 0;

    fOK = CreateProcess(
	NULL,
	wszCommandLine,
	NULL,
	NULL,
	FALSE,
	CREATE_NEW_CONSOLE,
	NULL,
	NULL,
	&sui,
	&pi);
    if (fOK)
    {
	CloseHandle(pi.hThread);
	CloseHandle(pi.hProcess);

	stat = 0;
    }
    else
    {
	stat = GetLastError();
    }

    return (stat);
}


DWORD ConnectServer(void)
{
    RPC_STATUS	stat;
    WCHAR      *pwszBinding;

    stat = RpcStringBindingCompose(
	NULL,
	PWSZ_PROTOCOL,
	NULL,
	PWSZ_ENDPOINT,
	NULL,
	&pwszBinding);
    if (stat == 0)
    {
	stat = RpcBindingFromStringBinding(pwszBinding, &g_hbindTest);
	RpcStringFree(&pwszBinding);
    }

    return (stat);
}


DWORD DisconnectServer(void)
{
    RPC_STATUS	stat;

    stat = RpcBindingFree(&g_hbindTest);

    return (stat);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\memalloc\cairo\makefile.inc ===
!if $(386)
CPP_CMD=cl386
!endif

!if $(MIPS)
CPP_CMD=mcl
!endif

!if $(ALPHA)
CPP_CMD=$(ALPHA_CC)
!endif

allidl:     test.h

clean:
    erase test.h 1>nul 2>nul

test.h:     ..\test.idl
    midl ..\test.idl               \
          -cswtch test_z.c         \
          -Zp8                     \
          -I$(INCLUDES)            \
          -no_warn                 \
          -char unsigned           \
          -mode c_port             \
          -DMIDL_PASS              \
          $(C_DEFINES)             \
          -cpp_cmd "$(CPP_CMD)"    \
          -cpp_opt "-nologo -DMIDL_PASS $(C_DEFINES) -I$(INCLUDES) -E -Tc"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\memalloc\signal.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:	signal.cxx
//
//  Contents:	Signal class implementation
//
//  Classes:	CSignal
//
//  History:	29-Sep-93   CarlH	Created
//
//--------------------------------------------------------------------------
#include <windows.h>
#include "signal.hxx"
#pragma  hdrstop


CSignal::CSignal(WCHAR const *pwszName) :
    _pwszName(new WCHAR[wcslen(pwszName) + 1]),
    _hevent(0)
{
    wcscpy(_pwszName, pwszName);
}


CSignal::~CSignal(void)
{
    delete _pwszName;
    if (_hevent != 0)
    {
	CloseHandle(_hevent);
    }
}


DWORD CSignal::Wait(DWORD dwTimeout)
{
    DWORD   stat = 0;

    if (_hevent == 0)
    {
	_hevent = CreateEvent(NULL, TRUE, FALSE, _pwszName);
	if (_hevent == 0)
	{
	    stat = GetLastError();
	}
    }

    if (stat == 0)
    {
	stat = WaitForSingleObject(_hevent, dwTimeout);
	if (stat == 0)
	{
	    ResetEvent(_hevent);
	}
    }

    return (stat);
}


DWORD CSignal::Signal(void)
{
    DWORD   stat = 0;

    if (_hevent == 0)
    {
	_hevent = CreateEvent(NULL, TRUE, FALSE, _pwszName);
	if (_hevent == 0)
	{
	    stat = GetLastError();
	}
    }

    if (stat == 0)
    {
	if (!SetEvent(_hevent))
	{
	    stat = GetLastError();
	}
    }

    return (stat);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\memalloc\memory.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:	memory.cxx
//
//  Contents:	Memory allocation tests
//
//  Functions:
//
//  History:	13-Aug-93   CarlH	Created
//
//--------------------------------------------------------------------------
#include "memtest.hxx"
#pragma  hdrstop


static char g_szMemory[] = "memory";

//  WARNING:	Do not just start whacking on the elements of this
//		array.	The third element of each structure may hold
//		the index of another entry in the array.  If elements
//		are inserted, these indices may get hosed!
//
static SMemTask g_amemtskStandard[] =
{
    {memopAlloc,	 128,  0, S_OK},
    {memopFree, 	   0,  0, S_OK},
    {memopAlloc,	  12,  0, S_OK},
    {memopAlloc,	1423,  0, S_OK},
    {memopFree, 	   0,  2, S_OK},
    {memopAlloc,	  12,  0, S_OK},
    {memopFree, 	   0,  3, S_OK},
    {memopFree, 	   0,  5, S_OK}
};

static ULONG	g_cmemtskStandard =
    sizeof(g_amemtskStandard) / sizeof(g_amemtskStandard[0]);


//  WARNING:	See warning on the above array definition.
//
static SMemTask g_amemtskMIDL[] =
{
    {memopMIDLAlloc,	 128,  0, S_OK},
    {memopMIDLFree,	   0,  0, S_OK},
    {memopMIDLAlloc,	  12,  0, S_OK},
    {memopMIDLAlloc,	1423,  0, S_OK},
    {memopMIDLFree,	   0,  2, S_OK},
    {memopMIDLAlloc,	  12,  0, S_OK},
    {memopMIDLFree,	   0,  3, S_OK},
    {memopMIDLFree,	   0,  5, S_OK}
};

static ULONG	g_cmemtskMIDL =
    sizeof(g_amemtskMIDL) / sizeof(g_amemtskMIDL[0]);


BOOL TestStandard(DWORD grfOptions);
BOOL TestMIDL(DWORD grfOptions);


//+-------------------------------------------------------------------------
//
//  Function:	TestMemory, public
//
//  Synopsis:	Tests simple memory allocation functionality
//
//  Arguments:	[grfOptions] - options for test
//
//  Returns:	TRUE if successful, FALSE otherwise
//
//  History:	17-Aug-93   CarlH	Created
//
//--------------------------------------------------------------------------
BOOL TestMemory(DWORD grfOptions)
{
    BOOL    fPassed;

    PrintHeader(g_szMemory);

    if (!(fPassed = TestStandard(grfOptions)))
	goto done;

#ifdef TEST_MIDL
    if (!(fPassed = TestMIDL(grfOptions)))
	goto done;
#endif // TEST_MIDL

done:
    PrintResult(g_szMemory, fPassed);

    return (fPassed);
}


//+-------------------------------------------------------------------------
//
//  Function:	TestStandard, public
//
//  Synopsis:	Tests standard memory allocation routines (not linked)
//
//  Arguments:	[grfOptions] - options for test
//
//  Returns:	TRUE if successful, FALSE otherwise
//
//  History:	17-Aug-93   CarlH	Created
//
//--------------------------------------------------------------------------
BOOL TestStandard(DWORD grfOptions)
{
    PrintTrace(g_szMemory, "testing standard allocations\n");

    return (RunMemoryTasks(g_szMemory, g_amemtskStandard, g_cmemtskStandard));
}


//+-------------------------------------------------------------------------
//
//  Function:	TestMIDL, public
//
//  Synopsis:	Tests RPC memory allocation routines (not linked)
//
//  Arguments:	[grfOptions] - options for test
//
//  Returns:	TRUE if successful, FALSE otherwise
//
//  History:	17-Aug-93   CarlH	Created
//
//--------------------------------------------------------------------------
BOOL TestMIDL(DWORD grfOptions)
{
    PrintTrace(g_szMemory, "testing MIDL allocations\n");

    return (RunMemoryTasks(g_szMemory, g_amemtskMIDL, g_cmemtskMIDL));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\memalloc\chicago\makefile.inc ===
!if $(386)
CPP_CMD=cl386
!endif

!if $(MIPS)
CPP_CMD=mcl
!endif

!if $(ALPHA)
CPP_CMD=$(ALPHA_CC)
!endif

allidl:     test.h

clean:
    erase test.h 1>nul 2>nul

test.h:     ..\test.idl
    midl ..\test.idl               \
          -cswtch test_z.c         \
          -Zp8                     \
          -I$(INCLUDES)            \
          -no_warn                 \
          -char unsigned           \
          -mode c_port             \
          -DMIDL_PASS              \
          $(C_DEFINES)             \
          -cpp_cmd "$(CPP_CMD)"    \
          -cpp_opt "-nologo -DMIDL_PASS $(C_DEFINES) -I$(INCLUDES) -E -Tc"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\memalloc\memtask.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:	memtask.cxx
//
//  Contents:	Memory task functions
//
//  Functions:	RunMemoryTasks
//
//  History:	17-Aug-93   CarlH	Created
//
//--------------------------------------------------------------------------
#include "memtest.hxx"
#pragma  hdrstop


#ifdef LINKED_COMPATIBLE
#include <memalloc.h>
#endif


//+-------------------------------------------------------------------------
//
//  Function:	RunMemoryTasks, public
//
//  Synopsis:	Runs through a series of memory tasks
//
//  Arguments:	[pszComponent] - current test component name
//		[pmemtsk]      - pointer to memory tasks to run
//		[cmemtsk]      - count of memory tasks
//
//  Returns:	TRUE if successful, FALSE otherwise
//
//  Algorithm:	A buffer is first allocated and cleared to hold the
//		blocks returned by any allocations.  The array of
//		tasks is then iterated through an each memory task
//		is performed.  The given task array should be
//		constructed so that all allocated memory is freed.
//
//  History:	17-Aug-93   CarlH	Created
//
//--------------------------------------------------------------------------
BOOL RunMemoryTasks(char *pszComponent, SMemTask *pmemtsk, ULONG cmemtsk)
{
    void      **ppvMemory;
    HRESULT	hr;
    BOOL	fPassed = TRUE;

    //	Allocate and clear an array of void *'s to hold the pointers
    //	returned by any allocations made during the test.
    //
    ppvMemory = new void *[cmemtsk];
    for (ULONG ipv = 0; ipv < cmemtsk; ipv++)
    {
	ppvMemory[ipv] = NULL;
    }

    //	For each entry in the array of tasks, figure out what type
    //	of operation is being requested and do it.
    //
    for (ULONG imemtsk = 0; (imemtsk < cmemtsk) && fPassed; imemtsk++)
    {
	switch (pmemtsk[imemtsk].memop)
	{
#ifdef LINKED_COMPATIBLE
	case memopOldAlloc:
	    PrintTrace(
		pszComponent,
		"old allocating a block of %lu bytes\n",
		pmemtsk[imemtsk].cb);
	    hr = MemAlloc(pmemtsk[imemtsk].cb, ppvMemory + imemtsk);
	    PrintTrace(
		pszComponent,
		"old allocated block at %p\n",
		ppvMemory[imemtsk]);
	    break;

	case memopOldAllocLinked:
	    PrintTrace(
		pszComponent,
		"old allocating a linked block of %lu bytes on %p\n",
		pmemtsk[imemtsk].cb,
		ppvMemory[pmemtsk[imemtsk].imemtsk]);
	    hr = MemAllocLinked(
		ppvMemory[pmemtsk[imemtsk].imemtsk],
		pmemtsk[imemtsk].cb,
		ppvMemory + imemtsk);
	    PrintTrace(
		pszComponent,
		"old allocated block at %p\n",
		ppvMemory[imemtsk]);
	    break;

	case memopOldFree:
	    PrintTrace(
		pszComponent,
		"old freeing block at %p\n",
		ppvMemory[pmemtsk[imemtsk].imemtsk]);
	    hr = MemFree(ppvMemory[pmemtsk[imemtsk].imemtsk]);
	    break;

#ifdef TEST_MIDL
	case memopMIDLAlloc:
	    TRY
	    {
		PrintTrace(
		    pszComponent,
		    "MIDL allocating a block of %lu bytes\n",
		    pmemtsk[imemtsk].cb);
		ppvMemory[imemtsk] = MIDL_user_allocate(pmemtsk[imemtsk].cb);
		PrintTrace(
		    pszComponent,
		    "MIDL allocated block at %p\n",
		    ppvMemory[imemtsk]);
		hr = NO_ERROR;
	    }
	    CATCH(CException, e)
	    {
		hr = e.GetErrorCode();
	    }
	    END_CATCH;
	    break;

	case memopMIDLFree:
	    TRY
	    {
		PrintTrace(
		    pszComponent,
		    "MIDL freeing block at %p\n",
		    ppvMemory[pmemtsk[imemtsk].imemtsk]);
		MIDL_user_free(ppvMemory[pmemtsk[imemtsk].imemtsk]);
		hr = NO_ERROR;
	    }
	    CATCH(CException, e)
	    {
		hr = e.GetErrorCode();
	    }
	    END_CATCH;
	    break;
#endif // TEST_MIDL

#endif // LINKED_COMPATIBLE
	case memopAlloc:
	    //	A standard memory allocation is being requested.
	    //	Allocate the number of bytes given in the task
	    //	description and store the block in our array of
	    //	void *'s.
	    //
	    PrintTrace(
		pszComponent,
		"allocating a block of %lu bytes\n",
		pmemtsk[imemtsk].cb);
	    ppvMemory[imemtsk] = CoTaskMemAlloc(pmemtsk[imemtsk].cb);
	    PrintTrace(
		pszComponent,
		"allocated block at %p\n",
		ppvMemory[imemtsk]);
	    hr = (ppvMemory[imemtsk] != 0 ? S_OK : -1);
	    break;

	case memopFree:
	    //	A standard memory free is being requested.  Free
	    //	the block found in our array of void *'s specified
	    //	by the index found in the task description.
	    //
	    PrintTrace(
		pszComponent,
		"freeing block at %p\n",
		ppvMemory[pmemtsk[imemtsk].imemtsk]);
	    CoTaskMemFree(ppvMemory[pmemtsk[imemtsk].imemtsk]);
	    hr = S_OK;
	    break;

	default:
	    //	Uh oh.	We found a memory operation that we don't
	    //	understand.  Set the result code to a value that
	    //	we know will cause the test to fail.
	    //
	    PrintError(pszComponent, "unknown memory operation\n");
	    hr = pmemtsk[imemtsk].hr + 1;
	    break;
	}

	//  Make sure that the returned error code was what we expected
	//  for this task.
	//
	fPassed = (hr == pmemtsk[imemtsk].hr);
    }

    delete ppvMemory;

    return (fPassed);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\memalloc\daytona\makefile.inc ===
!if $(386)
CPP_CMD=cl386
!endif

!if $(MIPS)
CPP_CMD=mcl
!endif

!if $(ALPHA)
CPP_CMD=$(ALPHA_CC)
!endif

allidl:     test.h

clean:
    erase test.h 1>nul 2>nul

test.h:     ..\test.idl
    midl ..\test.idl               \
          -cswtch test_z.c         \
          -Zp8                     \
          -I$(INCLUDES)            \
          -no_warn                 \
          -char unsigned           \
          -mode c_port             \
          -DMIDL_PASS              \
          $(C_DEFINES)             \
          -cpp_cmd "$(CPP_CMD)"    \
          -cpp_opt "-nologo -DMIDL_PASS $(C_DEFINES) -I$(INCLUDES) -E -Tc"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\memalloc\preinit.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:	preinit.cxx
//
//  Contents:	Pre-initialization memory allocation tests
//
//  Functions:	TestPreInit
//
//  History:	24-Jan-94   CarlH	Created
//
//--------------------------------------------------------------------------
#include "memtest.hxx"
#pragma  hdrstop


static char g_szPreInit[] = "preinit";

//  WARNING:	Do not just start whacking on the elements of this
//		array.	The third element of each structure may hold
//		the index of another entry in the array.  If elements
//		are inserted, these indices may get hosed!
//
static SMemTask g_amemtskPreInitialize[] =
{
    {memopAlloc,	 128,  0, S_OK},
    {memopFree, 	   0,  0, S_OK},
    {memopAlloc,	  12,  0, S_OK},
    {memopAlloc,	1423,  0, S_OK},
    {memopFree, 	   0,  2, S_OK},
    {memopAlloc,	  12,  0, S_OK},
    {memopFree, 	   0,  3, S_OK},
    {memopFree, 	   0,  5, S_OK}
};

static ULONG	g_cmemtskPreInitialize =
    sizeof(g_amemtskPreInitialize) / sizeof(g_amemtskPreInitialize[0]);


BOOL	TestGetAllocator(DWORD grfOptions);
BOOL	TestPreInitialize(DWORD grfOptions);


//+-------------------------------------------------------------------------
//
//  Function:	TestPreInitialize, public
//
//  Synopsis:	Tests pre-initialization memory allocation functionality
//
//  Arguments:	[grfOptions] - options for test
//
//  Returns:	TRUE if successful, FALSE otherwise
//
//  History:	24-Jan-94   CarlH	Created
//
//--------------------------------------------------------------------------
BOOL TestPreInit(DWORD grfOptions)
{
    BOOL    fPassed;

    PrintHeader(g_szPreInit);

    if (!(fPassed = TestGetAllocator(grfOptions)))
	goto done;

    if (!(fPassed = TestPreInitialize(grfOptions)))
	goto done;

done:
    PrintResult(g_szPreInit, fPassed);

    return (fPassed);
}


BOOL TestGetAllocator(DWORD grfOptions)
{
    IMalloc    *pmalloc;
    HRESULT	hr;
    BOOL	fPassed;

    PrintTrace(g_szPreInit, "testing default allocator\n");

    hr = CoGetMalloc(MEMCTX_TASK, &pmalloc);
    if (fPassed = SUCCEEDED(hr))
    {
	pmalloc->Release();
    }

    return (fPassed);
}


//+-------------------------------------------------------------------------
//
//  Function:	TestPreInitialize, public
//
//  Synopsis:	Tests standard memory allocation routines
//
//  Arguments:	[grfOptions] - options for test
//
//  Returns:	TRUE if successful, FALSE otherwise
//
//  History:	24-Jan-94   CarlH	Created
//
//--------------------------------------------------------------------------
BOOL TestPreInitialize(DWORD grfOptions)
{
    PrintTrace(g_szPreInit, "testing standard allocations\n");

    return (
	RunMemoryTasks(
	    g_szPreInit,
	    g_amemtskPreInitialize,
	    g_cmemtskPreInitialize));
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\memalloc\memtest.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:	memtest.cxx
//
//  Contents:	Memory allocation API unit test
//
//  Functions:
//
//  History:	13-Aug-93   CarlH	Created
//
//--------------------------------------------------------------------------
#include "memtest.hxx"
#pragma  hdrstop

#include <stdlib.h>
#include <stdio.h>


static DWORD	g_grfGlobal  = GLOBAL_RUN | GLOBAL_CLEANUP;
static DWORD	g_grfPreInit = 0;
static DWORD	g_grfMemory  = 0;
static DWORD	g_grfMIDL    = MIDL_AUTOGO | MIDL_AUTOEND;
static DWORD	g_grfCompat  = 0;

static BOOL	g_fServer = FALSE;


static BOOL	ParseArguments(char *pszName, int cpsz, char **ppsz);
static BOOL	Initialize(void);
static BOOL	Uninitialize(void);

static void	PrintUsage(char *pszName);


//+-------------------------------------------------------------------------
//
//  Function:	main, public
//
//  Synopsis:	Memory allocation test entry point
//
//  Arguments:	[argc] - count of arguments
//		[argv] - list of arguments
//
//  Returns:	Zero if successful, non-zero otherwise
//
//  History:	19-May-93   CarlH	Created
//
//--------------------------------------------------------------------------
int _cdecl main(int argc, char *argv[])
{
    DWORD   grfOptions;
    BOOL    fPassed;

    if (!(fPassed = ParseArguments(argv[0], argc - 1, argv + 1)))
	goto done;

    if (g_fServer)
    {
	if (!(fPassed = Initialize()))
	    goto done;

	grfOptions = g_grfGlobal | g_grfMIDL;
	if (grfOptions & GLOBAL_RUN)
	{
	    if (!(fPassed = TestMIDLServer(grfOptions)))
		goto done;
	}
    }
    else
    {
	//  This test has to be run before initialization since that is
	//  its point.	It tests the memory allocation APIs functionality
	//  before CoInitialize() is called.
	//
	grfOptions = g_grfGlobal | g_grfPreInit;
	if (grfOptions & GLOBAL_RUN)
	{
	    if (!(fPassed = TestPreInit(grfOptions)))
		goto done;
	}

	if (!(fPassed = Initialize()))
	    goto done;

	grfOptions = g_grfGlobal | g_grfMemory;
	if (grfOptions & GLOBAL_RUN)
	{
	    if (!(fPassed = TestMemory(grfOptions)))
		goto done;
	}

	grfOptions = g_grfGlobal | g_grfMIDL;
	if (grfOptions & GLOBAL_RUN)
	{
	    WCHAR   wszServer[MAX_PATH + 1];

	    mbstowcs(wszServer, argv[0], MAX_PATH);
	    if (!(fPassed = TestMIDLClient(wszServer, grfOptions)))
		goto done;
	}

#ifdef LINKED_COMPATIBLE
	grfOptions = g_grfGlobal | g_grfCompat;
	if (grfOptions & GLOBAL_RUN)
	{
	    if (!(fPassed = TestCompatibility(grfOptions)))
		goto done;
	}
#endif // LINKED_COMPATIBLE
    }

    if (!(fPassed = Uninitialize()))
	goto done;

done:
    fprintf(stdout, "%s: %s\n", argv[0], fPassed ? "PASSED" : "FAILED");

    return (fPassed ? 0 : 1);
}


//+-------------------------------------------------------------------------
//
//  Function:	Initialize, public
//
//  Synopsis:	Global initialization routine
//
//  Returns:	TRUE if successful, FALSE otherwise
//
//  History:	07-May-93   CarlH	Created
//
//--------------------------------------------------------------------------
BOOL Initialize(void)
{
    return (SUCCEEDED(CoInitialize(NULL)));
}


//+-------------------------------------------------------------------------
//
//  Function:	Uninitialize, public
//
//  Synopsis:	Global clean-up routine
//
//  Returns:	TRUE if successful, FALSE otherwise
//
//  History:	07-May-93   CarlH	Created
//
//--------------------------------------------------------------------------
BOOL Uninitialize(void)
{
    CoUninitialize();

    return (TRUE);
}


//+-------------------------------------------------------------------------
//
//  Function:	PrintHeader, public
//
//  Synopsis:	Prints the header for a component's test
//
//  Arguments:	[pszComponent] - component test to print header for
//
//  History:	28-Feb-93   CarlH	Created
//
//--------------------------------------------------------------------------
void PrintHeader(char const *pszComponent)
{
    if (g_grfGlobal & GLOBAL_STATUS)
    {
	fprintf(stdout, "%s - running tests\n", pszComponent);
    }
}


//+-------------------------------------------------------------------------
//
//  Function:	PrintResult, public
//
//  Synopsis:	Prints the result of a component's test
//
//  Arguments:	[pszComponent] - component test to print result for
//
//  History:	28-Feb-93   CarlH	Created
//
//--------------------------------------------------------------------------
void PrintResult(char const *pszComponent, BOOL fPassed)
{
    if (g_grfGlobal & GLOBAL_STATUS)
    {
	fprintf(
	    stdout,
	    "%s - tests %s\n",
	    pszComponent,
	    fPassed ? "passed" : "failed");
    }
}


//+-------------------------------------------------------------------------
//
//  Function:	PrintTrace, public
//
//  Synopsis:	Prints a trace message if verbose mode on
//
//  Arguments:	[pszComponent] - component name issuing trace
//		[pszFormat]    - format string
//		[...]	       - arguments for format string
//
//  History:	24-Feb-93   CarlH   Created
//
//--------------------------------------------------------------------------
void PrintTrace(char const *pszComponent, char const *pszFormat, ...)
{
    if (g_grfGlobal & GLOBAL_VERBOSE)
    {
	va_list va;

	fprintf(stdout, "trace: %s - ", pszComponent);

	va_start(va, pszFormat);
	vfprintf(stdout, pszFormat, va);
	va_end(va);
    }
}


//+-------------------------------------------------------------------------
//
//  Function:	PrintError, public
//
//  Synopsis:	Prints an error message
//
//  Arguments:	[pszComponent] - component name issuing trace
//		[pszFormat]    - format string
//		[...]	       - arguments for format string
//
//  History:	24-Feb-93   CarlH   Created
//
//--------------------------------------------------------------------------
void PrintError(char const *pszComponent, char const *pszFormat, ...)
{
    va_list va;

    fprintf(stderr, "error: %s - ", pszComponent);

    va_start(va, pszFormat);
    vfprintf(stderr, pszFormat, va);
    va_end(va);
}


//+-------------------------------------------------------------------------
//
//  Function:	PrintUsage, private
//
//  Synopsis:	Prints a the usage message for this test
//
//  Arguments:	[pszName] - name of the executable
//
//  History:	24-Feb-93   CarlH   Created
//
//--------------------------------------------------------------------------
void PrintUsage(char *pszName)
{
    fprintf(stdout, "Usage: %s {<flag>|<comp>}*\n", pszName);
    fprintf(stdout, "Where: <flag> = {+|-}{?dgecsv}+\n");
    fprintf(stdout, "       <comp> = {preinit|memory|compat|midl}\n");
    fprintf(stdout, "       ? - displays this message\n");
    fprintf(stdout, "       d - turns MIDL debugging on/OFF\n");
    fprintf(stdout, "       g - turns MIDL debugging auto go ON/off\n");
    fprintf(stdout, "       e - turns MIDL debugging auto end ON/off\n");
    fprintf(stdout, "       c - turns cleanup ON/off\n");
    fprintf(stdout, "       s - turns status messages on/OFF\n");
    fprintf(stdout, "       v - turns verbosity on/OFF\n");
}


//+-------------------------------------------------------------------------
//
//  Function:	ParseArguments, private
//
//  Synopsis:	Parses command line arguments
//
//  Arguments:	[pszName] - name of executable
//		[cpsz]	  - number of strings in [ppsz]
//		[ppsz]	  - array of command line arguments
//
//  Returns:	TRUE if successfull, FALSE otherwise
//
//  History:	24-Feb-93   CarlH	Created
//
//--------------------------------------------------------------------------
BOOL ParseArguments(char *pszName, int cpsz, char **ppsz)
{
    BOOL    fOK = TRUE;

    //	As long as we haven't encountered an error, we want to loop
    //	through all of the arguments, excluding the first, which is
    //	the name of the program (argv[0]).
    //
    for (int ipsz = 0; fOK && (ipsz < cpsz); ipsz++)
    {
	//  If the first character of the argument is a plus or minus,
	//  this argument must be a series of flags.
	//
	if ((ppsz[ipsz][0] == '+') || (ppsz[ipsz][0] == '-'))
	{
	    BOOL    fFlag = (ppsz[ipsz][0] == '+');

	    //	We want to check the rest of the characters in the
	    //	argument.
	    //
	    for (int ich = 1; fOK && (ppsz[ipsz][ich] != '\0'); ich++)
	    {
		switch (ppsz[ipsz][ich])
		{
		case '?':
		    //	User is requesting help, so print the usage
		    //	message and stop parsing.
		    //
		    PrintUsage(pszName);
		    fOK = FALSE;
		    break;

		case 'D':
		case 'd':
		    g_grfMIDL = (fFlag ?
			g_grfMIDL |  MIDL_DEBUG :
			g_grfMIDL & ~MIDL_DEBUG);
		    break;

		case 'G':
		case 'g':
		    g_grfMIDL = (fFlag ?
			g_grfMIDL |  MIDL_AUTOGO :
			g_grfMIDL & ~MIDL_AUTOGO);
		    break;

		case 'E':
		case 'e':
		    g_grfMIDL = (fFlag ?
			g_grfMIDL |  MIDL_AUTOEND :
			g_grfMIDL & ~MIDL_AUTOEND);
		    break;

		case 'C':
		case 'c':
		    //	Turn test cleanup on or off depending on the
		    //	first character of this argument.
		    //
		    g_grfGlobal = (fFlag ?
			g_grfGlobal |  GLOBAL_CLEANUP :
			g_grfGlobal & ~GLOBAL_CLEANUP);
		    break;

		case 'S':
		case 's':
		    //	Turn status messages on or off depending on the
		    //	first character of this argument.
		    //
		    g_grfGlobal = (fFlag ?
			g_grfGlobal |  GLOBAL_STATUS :
			g_grfGlobal & ~GLOBAL_STATUS);
		    break;

		case 'V':
		case 'v':
		    //	Turn verbose mode on or off depending on the
		    //	first character of this argument.
		    //
		    g_grfGlobal = (fFlag ?
			g_grfGlobal |  GLOBAL_VERBOSE :
			g_grfGlobal & ~GLOBAL_VERBOSE);
		    break;

		default:
		    //	We don't know what this is, so tell
		    //	the user and stop parsing.
		    //
		    PrintError(
			pszName,
			"unrecognized switch '%c'\n",
			ppsz[ipsz][ich]);
		    fOK = FALSE;
		    break;
		}
	    }
	}
	else
	if (stricmp(ppsz[ipsz], "preinit") == 0)
	{
	    g_grfGlobal  &= ~GLOBAL_RUN;
	    g_grfPreInit |=  GLOBAL_RUN;
	}
	else
	if (stricmp(ppsz[ipsz], "memory") == 0)
	{
	    g_grfGlobal &= ~GLOBAL_RUN;
	    g_grfMemory |=  GLOBAL_RUN;
	}
	else
	if (stricmp(ppsz[ipsz], "compat") == 0)
	{
	    g_grfGlobal &= ~GLOBAL_RUN;
	    g_grfCompat |=  GLOBAL_RUN;
	}
	else
	if (stricmp(ppsz[ipsz], "midl") == 0)
	{
	    g_grfGlobal &= ~GLOBAL_RUN;
	    g_grfMIDL	|=  GLOBAL_RUN;
	}
	else
	if (stricmp(ppsz[ipsz], "midlserver") == 0)
	{
	    g_fServer = TRUE;
	}
	else
	{
	    PrintError(
		pszName,
		"unrecognized argument \"%s\"\n",
		ppsz[ipsz]);
	    fOK = FALSE;
	}
    }

    return (fOK);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\ole1\clidemo\cliver.h ===
#define CLIVER_DEBUG    0
#define CLIVER_PRERELEASE   1

#define CLIVER_FILEFLAGS    (CLIVER_PRERELEASE|CLIVER_DEBUG)

#define CLIVER_FILEOS           VOS_DOS_WINDOWS16
#define CLIVER_FILEVERSION      1,01
#define CLIVER_PRODUCTVERSION   1,01,0,00
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\ole1\clidemo\dialog.h ===
/*
 * dialog.h 
 *
 * Created by Microsoft Corporation.
 * (c) Copyright Microsoft Corp. 1990 - 1992  All Rights Reserved
 */

//*** INCLUDES ***

#include <commdlg.h>

//*** PROTOTYPES ***

//*** FAR 
BOOL FAR          FullyQualify(LPSTR, LPSTR);
BOOL FAR          OfnGetName(HWND, LPSTR, WORD);
LPSTR FAR         OfnGetNewLinkName(HWND, LPSTR);
VOID FAR          OfnInit(HANDLE);
BOOL APIENTRY     fnInsertNew(HWND, UINT, WPARAM, LPARAM);
BOOL APIENTRY     fnProperties(HWND, UINT, WPARAM, LPARAM);
VOID FAR          LinkProperties(VOID);
VOID FAR          AboutBox(VOID);
BOOL  APIENTRY    fnAbout( HWND, UINT, WPARAM, LPARAM);
VOID FAR          RetryMessage (APPITEMPTR,LONG);
BOOL  APIENTRY    fnRetry(HWND, UINT, WPARAM, LPARAM);
VOID FAR          InvalidLink(VOID);
BOOL  APIENTRY    fnInvalidLink(HWND, UINT, WPARAM, LPARAM);

//*** Local
static VOID       AddExtension(LPOPENFILENAME);
static VOID       Normalize(LPSTR);
static BOOL       InitLinkDlg (HWND, INT *, HWND, APPITEMPTR **);
static VOID       UpdateLinkButtons(HWND, INT, HWND, APPITEMPTR *);
static BOOL       ChangeLinks(HWND, INT, HWND, APPITEMPTR *);
static VOID       CancelLinks(HWND, INT, HWND, APPITEMPTR *);
static VOID       DisplayUpdate(INT, HWND, APPITEMPTR *, BOOL);
static VOID       UndoObjects(VOID);
static VOID       DelUndoObjects(BOOL);
static VOID       ChangeUpdateOptions(HWND, INT, HWND, APPITEMPTR *, OLEOPT_UPDATE);
static VOID       MakeListBoxString(LPSTR, LPSTR, OLEOPT_UPDATE);

//*** MACROS ***

#define END_PROP_DLG(hDlg,pLinks) { \
   HANDLE handle; \
   handle = LocalHandle((LPSTR)pLinks); \
   LocalUnlock(handle); \
   LocalFree(handle); \
   Hourglass(FALSE); \
   hwndProp = (HWND)NULL; \
   EndDialog(hDlg, TRUE); \
}

#define CHANGE_LISTBOX_STRING(hwnd,i,pItem,lpLinkData) {\
   char pString[CBMESSAGEMAX*4];\
   MakeListBoxString(lpLinkData,pString,pItem->uoObject);\
   SendMessage(hwndList,LB_DELETESTRING, i , 0L);\
   SendMessage(hwndList,LB_INSERTSTRING, i , (long)((LPSTR)pString));\
   SendMessage(hwndList,LB_SETSEL, 1, (long)i);\
}

#define CHECK_IF_STATIC(pItem) {\
   if (pItem->otObject == OT_STATIC)\
      continue;\
}

#define BLOCK_BUSY(fTest) {\
   if (fTest)\
   {\
      fTest = FALSE;\
      return TRUE;\
   }\
   if (cOleWait)\
   {\
      fTest = TRUE;\
      RetryMessage(NULL,RD_CANCEL);\
      fTest = FALSE;\
      return TRUE;\
   }\
}




 

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\ole1\clidemo\clidemo.c ===
/*
 * clidemo.c - OLE client application sample code
 *
 * Created by Microsoft Corporation.
 * (c) Copyright Microsoft Corp. 1990 - 1992  All Rights Reserved
 *
 */

 /***************************************************************************
 * IMPORTANT - README:
 * OLE client applications are windows programs which use the OLE client
 * APIs.  Therefore it is imperative that you understand how these APIs
 * operate. Most importantly it is essential that you keep in mind which
 * procedure calls result in asynchronous states: a state where the operation
 * is not truely complete after a return from the call.
 *
 * Many functions produce asynchronous states, for example, OleActivate,
 * OleClose, OleCopyFromLink, OleCreate ... Reference your SDK manual for
 * a complete list.
 *
 * So whenever you call any of these library functions keep in mind that
 * the operation is not necessarily complete once a return is made.
 * These operations require communications with a server application.  With
 * OLE the inter-application communication is done through DDE.  In order
 * for a DDE conversation to complete several DDE messages need to be
 * sent and recieved by both the server and client OLE DLLs.  So, the
 * asynchronous operations will not complete until the client application
 * enters a message dipatch loop.  Therefore, it is necessary to enter
 * a dispatch loop and wait for completion.  It is not necessary to block
 * all other operation; however, it is very important to coordinate the
 * user activity to prevent disastrous re-entry cases.
 *
 * In this application I have written a macro to prevent re-entry
 * problems.  Namely: ANY_OBJECT_BUSY which prevents a user from initiating
 * an action which will result in an asynchronous call if there is an object
 * already in an asynchronous state.
 *
 * The following is brief summary of the three macros:
 *
 * ANY_OBJECT_BUSY: checks to see if any object in the document is busy.
 *              This prevents a new document from being saved to file if there are
 *              objects in asynchronous states.
 *
 * So, the problem is that we have to enter a message dispatch loop in order
 * to let DDE messages get through so that asynchronous operations can finish.
 * And while we are in the message dispatch loops (WaitForObject or WaitForAllObjects)
 * we have to prevent the user from doing things that can't be done when an
 * object(s) is busy.  Yes, it is confusing , but, the end result is a super
 * cool application that can have linked and embbeded objects!
 ***************************************************************************/

//*** INCLUDES ***

#include <windows.h>                   //* WINDOWS
#include <ole.h>                       //* OLE structs and defines
#include <shellapi.h>                  //* Shell, drag and drop headers

#include "demorc.h"                    //* header for resource file
#include "global.h"                    //* global app variables
#include "clidemo.h"                   //* app includes:
#include "register.h"
#include "stream.h"
#include "object.h"
#include "dialog.h"
#include "utility.h"

//*** VARIABLES ***

//** Global
HANDLE            hInst;
BOOL              fRetry = FALSE;
HWND              hwndFrame;           //* main window
HANDLE            hAccTable;           //* accelerator table
CHAR              szFrameClass[] = "CliDemo";//* main window class name
CHAR              szItemClass[]  = "ItemClass";//* item window class name
CHAR              szAppName[CBMESSAGEMAX];//* Application name
INT               iObjects = 0;        //* object count
INT               iObjectNumber = 0;   //* object number for object name
CHAR              szFileName[CBPATHMAX];

extern INT giXppli ;
extern INT giYppli ;
                                       //* ClipBoard formats:
OLECLIPFORMAT     vcfLink;             //* "ObjectLink"
OLECLIPFORMAT     vcfNative;           //* "Native"
OLECLIPFORMAT     vcfOwnerLink;        //* "OwnerLink"


/***************************************************************************
 * WinMain() - Main Windows routine
 ***************************************************************************/
int APIENTRY WinMain(
   HINSTANCE hInstance,
   HINSTANCE hPrevInst,
   LPSTR  lpCmdLine,
   INT    nCmdLine
){
    hInst = hInstance;

    if (!InitApplication(hInst))   //* register window classes
      return FALSE;

    if (!InitInstance(hInst))          //* create window instance
        return FALSE;

    OfnInit(hInst);                    //* setup to use <commdlg.dll>

                                       //* register clipboard formats
                                       //* used for OLE
    vcfLink      = RegisterClipboardFormat("ObjectLink");
    vcfNative    = RegisterClipboardFormat("Native");
    vcfOwnerLink = RegisterClipboardFormat("OwnerLink");


    ShowWindow(hwndFrame, SW_SHOWNORMAL);
    UpdateWindow(hwndFrame);
    ProcessCmdLine(lpCmdLine);

    while (ProcessMessage(hwndFrame, hAccTable)) ;

    return FALSE;
}

/***************************************************************************
 * InitApplication()
 *
 * registers the window classes used by the application.
 *
 * Returns BOOL:      - TRUE if successful.
 ***************************************************************************/

static BOOL InitApplication(           //* ENTRY:
   HANDLE         hInst                //* instance handle
){                                     //* LOCAL:
   WNDCLASS       wc;                  //* temp wind-class structure

   wc.style          = 0;
   wc.lpfnWndProc    = (WNDPROC)FrameWndProc;
   wc.cbClsExtra     = 0;
   wc.cbWndExtra     = 0;
   wc.hInstance      = hInst;
   wc.hIcon          = LoadIcon(hInst, MAKEINTRESOURCE(ID_APPLICATION));
   wc.hCursor        = LoadCursor(NULL, IDC_ARROW);
   wc.hbrBackground  = (HBRUSH)(COLOR_APPWORKSPACE + 1);
   wc.lpszMenuName   = MAKEINTRESOURCE(ID_APPLICATION);
   wc.lpszClassName  = szFrameClass;

   if (!RegisterClass(&wc))
      return FALSE;
                                       //* application item class
   wc.style          = CS_DBLCLKS | CS_VREDRAW | CS_HREDRAW;
   wc.lpfnWndProc    = (WNDPROC)ItemWndProc;
   wc.hIcon          = NULL;
   wc.cbWndExtra     = sizeof(APPITEMPTR);
   wc.lpszMenuName   = NULL;
   wc.lpszClassName  = szItemClass;

   if (!RegisterClass(&wc))
      return FALSE;

   return TRUE;

}

/***************************************************************************
 * InitInstance()
 *
 * create the main application window.
 *
 * Returns BOOL:      - TRUE if successful else FALSE.
 ***************************************************************************/

static BOOL InitInstance(              //* ENTRY:
   HANDLE         hInst                //* instance handel
){
	HDC hDC ;

   hAccTable = LoadAccelerators(hInst, MAKEINTRESOURCE(ID_APPLICATION));

   if (!(hwndFrame =
      CreateWindow(
         szFrameClass, "",
         WS_OVERLAPPEDWINDOW | WS_CLIPCHILDREN,
         CW_USEDEFAULT, CW_USEDEFAULT,
         CW_USEDEFAULT, CW_USEDEFAULT,
         NULL,
         NULL,
         hInst,
         NULL
      )))
      return FALSE;                    //* ERROR return

   LoadString(hInst, IDS_APPNAME, szAppName, CBMESSAGEMAX);
   DragAcceptFiles(hwndFrame, TRUE);   //* allow dragged and dropped files

   hDC    = GetDC (NULL);       // Get the hDC of the desktop window
   giXppli = GetDeviceCaps (hDC, LOGPIXELSX);
   giYppli = GetDeviceCaps (hDC, LOGPIXELSY);
   ReleaseDC (NULL, hDC);
	


   return TRUE;                        //* SUCCESS return

}

/***************************************************************************
 *  ProcessCmdLine()
 *
 *  process command line getting any command arguments.
 ***************************************************************************/

VOID ProcessCmdLine(LPSTR lpCmdLine)
{                                     //* LOCAL:
   OFSTRUCT       ofs;


   if (*lpCmdLine)
   {                                   //* look for file extension
      LPSTR lpstrExt = lpCmdLine;      //* pointer to file extension

      while (*lpstrExt && *lpstrExt != '.')
         lpstrExt = AnsiNext(lpstrExt);

      lstrcpy(szFileName, lpCmdLine);
      if (!(*lpstrExt))                //* append default extension
      {
         lstrcat(szFileName,".");
         lstrcat(szFileName,szDefExtension);
      }
                                       //* get the files fully
      OpenFile(szFileName, &ofs, OF_PARSE);//* qualified name
      lstrcpy(szFileName, ofs.szPathName);
   }
   else
      *szFileName = 0;
                                       //* pass filename to main winproc
   SendMessage(hwndFrame,WM_INIT,(WPARAM)0,(LPARAM)0);

}


/***************************************************************************
 *  FrameWndProc()
 *
 *  Message handler for the application frame window.
 *
 *  Returns long - Variable, depends on message.
 ***************************************************************************/

LONG  APIENTRY FrameWndProc(           //* ENTRY:
   HWND           hwnd,                //* standard wind-proc parameters
   UINT           msg,
   DWORD          wParam,
   LONG           lParam
){                                     //* LOCAL:
                                       //* ^ Document file name
   static LHCLIENTDOC   lhcDoc;        //* Document Handle
   static LPOLECLIENT   lpClient;      //* pointer to client
   static LPAPPSTREAM   lpStream;      //* pointer to stream vtbl
   APPITEMPTR           pItem;         //* application item pointer

   switch (msg)
   {
      case WM_INIT:                    //* user defined message
         if (!InitAsOleClient(hInst, hwnd, szFileName, &lhcDoc, &lpClient, &lpStream))
            DestroyWindow(hwnd);
         break;
                                       //* the following three messages are
                                       //* used to avoid problems with OLE
                                       //* see the comment in object.h
      case WM_DELETE:                  //* user defined message
         pItem = (APPITEMPTR) lParam;  //* delete object
         WaitForObject(pItem);
         ObjDelete(pItem,OLE_OBJ_DELETE);
         if (wParam)
            cOleWait--;
         break;

      case WM_ERROR:                   //* user defined message
         ErrorMessage(wParam);         //* display error message
         break;

      case WM_RETRY:                   //* user defined message
         RetryMessage((APPITEMPTR)lParam, RD_RETRY | RD_CANCEL);
         break;

      case WM_INITMENU:
         UpdateMenu((HMENU)wParam);
         break;

      case WM_COMMAND:
      {
         WORD wID = LOWORD(wParam);

         pItem = GetTopItem();

         switch (wID)
         {
            case IDM_NEW:
               ANY_OBJECT_BUSY;
               NewFile(szFileName,&lhcDoc,lpStream);
               break;

            case IDM_OPEN:
               ANY_OBJECT_BUSY;
               MyOpenFile(szFileName,&lhcDoc,lpClient,lpStream);
               break;

            case IDM_SAVE:
               ANY_OBJECT_BUSY;
               SaveFile(szFileName,lhcDoc,lpStream);
               break;

            case IDM_SAVEAS:
               ANY_OBJECT_BUSY;
               SaveasFile(szFileName,lhcDoc,lpStream);
               break;

            case IDM_ABOUT:
               AboutBox();
               break;

            case IDM_INSERT:
               ANY_OBJECT_BUSY;
               ObjInsert(lhcDoc, lpClient);
               break;

            case IDM_INSERTFILE:
               ANY_OBJECT_BUSY;
               ObjCreateFromTemplate(lhcDoc,lpClient);
               break;

            case IDM_PASTE:
            case IDM_PASTELINK:
               ANY_OBJECT_BUSY;
               ObjPaste(wID == IDM_PASTE,lhcDoc,lpClient);
               break;

            case IDM_LINKS:
               ANY_OBJECT_BUSY;
               pItem = GetTopItem();
               LinkProperties();
               break;

            case IDM_EXIT:
               ANY_OBJECT_BUSY;
               SendMessage(hwnd, WM_SYSCOMMAND, SC_CLOSE, 0L);
               break;

            case IDM_COPY:
            case IDM_CUT:
               ANY_OBJECT_BUSY;

               if (!ObjCopy(pItem))
               {
                  ErrorMessage((wParam == IDM_CUT) ?
                     E_CLIPBOARD_CUT_FAILED : E_CLIPBOARD_COPY_FAILED);
                  break;
               }

               if (wParam == IDM_COPY)
                  break;

            case IDM_CLEAR:            //* CUT falls through to clear
               ANY_OBJECT_BUSY;
               ClearItem(pItem);
               break;

            case IDM_CLEARALL:
               ANY_OBJECT_BUSY;
               ClearAll(lhcDoc,OLE_OBJ_DELETE);
               Dirty(DOC_DIRTY);
               break;

            default:
               if( (wParam >= IDM_VERBMIN) && (wParam <= IDM_VERBMAX) )
               {
                  ANY_OBJECT_BUSY;
                  ExecuteVerb(wParam - IDM_VERBMIN,pItem);
                  break;
               }
               return DefWindowProc(hwnd, msg, wParam, lParam);
         }
         break;
      }

      case WM_DROPFILES:
         ANY_OBJECT_BUSY;
         ObjCreateWrap((HANDLE)wParam, lhcDoc, lpClient);
         break;

      case WM_CLOSE:
         ANY_OBJECT_BUSY;
         if (!SaveAsNeeded(szFileName, lhcDoc, lpStream))
            break;
         DeregDoc(lhcDoc);
         DestroyWindow(hwnd);
         break;

      case WM_DESTROY:
         EndStream(lpStream);
         EndClient(lpClient);
         PostQuitMessage(0);
         break;

      case WM_QUERYENDSESSION:         //* don't let windows terminate
         return (QueryEndSession(szFileName,lhcDoc, lpStream));

      default:
         return DefWindowProc(hwnd, msg, wParam, lParam);
   }
   return 0L;

}

/***************************************************************************
 * InitAsOleClient()
 *
 * Initiates the creation of stream and client vtbls.  These vtbls are very
 * important for the proper operation of this application.  The stream vtbl
 * lets the OLE librarys know where the location of the stream I/O routines
 * reside.  The stream routines are used by OleLoadFromStream and the like.
 * The client vtbl is used to hold the pointer to the CallBack function.
 * IMPORTANT: both the client and the stream structures have pointers to
 * vtbls which have the pointers to the functions.  Therefore, it is
 * necessary to allocate space for the vtbl and the client structure
 * which has the pointer to the vtbl.
 **************************************************************************/

static BOOL InitAsOleClient(           //* ENTRY:
   HANDLE         hInstance,           //* applicaion instance handle
   HWND           hwnd,                //* main window handle
   PSTR           pFileName,           //* document file name
   LHCLIENTDOC    *lhcDoc,             //* pointer to document Handle
   LPOLECLIENT    *lpClient,           //* pointer to client pointer
   LPAPPSTREAM    *lpStream            //* pointer to APPSTREAM pointer
){
                                       //* initiate client vtbl creation
   if (!(*lpClient = InitClient(hInstance)))
   {
      SendMessage(hwnd, WM_SYSCOMMAND, SC_CLOSE, 0L);
      return FALSE;                    //* ERROR return
   }
                                       //* initiate stream vtbl creation
   if (!(*lpStream = InitStream(hInstance)))
   {
      SendMessage(hwnd, WM_SYSCOMMAND, SC_CLOSE, 0L);
      return FALSE;                    //* ERROR return
   }

   if (*pFileName && RegDoc(pFileName,lhcDoc)
       && LoadFile(pFileName,*lhcDoc,*lpClient,*lpStream))
   {
      SetTitle(pFileName);
      return TRUE;                     //* SUCCESS return
   }

   NewFile(pFileName, lhcDoc, *lpStream);
   return TRUE;                        //* SUCCESS return

}                                      //* SUCCESS return

/****************************************************************************
 *  InitClient()
 *
 *  Initialize the OLE client structure, create and fill the OLECLIENTVTBL
 *  structure.
 *
 *  Returns LPOLECLIENT - if successful a pointer to a client structure
 *                        , otherwise NULL.
 ***************************************************************************/

static LPOLECLIENT InitClient(         //* ENTRY:
   HANDLE hInstance                    //* application instance handle
){                                     //* LOCAL:
   LPOLECLIENT lpClient=NULL;          //* pointer to client struct
                                       //* Allocate vtbls
   if (!(lpClient = (LPOLECLIENT)GlobalLock(
         GlobalAlloc(GMEM_FIXED | GMEM_ZEROINIT, sizeof(OLECLIENT))
      )))
      goto Error;                      //* ERROR jump

   if (!(lpClient->lpvtbl = (LPOLECLIENTVTBL)GlobalLock(
            GlobalAlloc(GMEM_FIXED | GMEM_ZEROINIT, sizeof(OLECLIENTVTBL))
      )))
      goto Error;                      //* ERROR jump
                                       //* set the CALLBACK function
                                       //* pointer
   lpClient->lpvtbl->CallBack  = CallBack;

   return lpClient;                    //* SUCCESS return

Error:                                 //* ERROR Tag

   ErrorMessage(E_FAILED_TO_ALLOC);
   EndClient(lpClient);                //* free any allocated space

   return NULL;                        //* ERROR return

}

/****************************************************************************
 *  InitStream()
 *
 *  Create and fill the STREAMVTBL. Create a stream structure and initialize
 *  pointer to stream vtbl.
 *
 *  Returns LPAPPSTREAM - if successful a pointer to a stream structure
 *                        , otherwise NULL .
 ***************************************************************************/

static LPAPPSTREAM InitStream(         //* ENTRY:
   HANDLE hInstance                    //* handle to application instance
){                                     //* LOCAL:
   LPAPPSTREAM lpStream = NULL;        //* pointer to stream structure

   if (!(lpStream = (LPAPPSTREAM)GlobalLock(
         GlobalAlloc(GMEM_FIXED | GMEM_ZEROINIT, sizeof(APPSTREAM))
      )))
      goto Error;                      //* ERROR jump

   if (!(lpStream->olestream.lpstbl = (LPOLESTREAMVTBL)GlobalLock(
         GlobalAlloc(GMEM_FIXED | GMEM_ZEROINIT, sizeof(OLESTREAMVTBL))
      )))
      goto Error;                      //* ERROR jump

                                       //* set stream func. pointers
   lpStream->olestream.lpstbl->Get = (DWORD ( CALLBACK *)(LPOLESTREAM, VOID FAR *, DWORD)) ReadStream;
   lpStream->olestream.lpstbl->Put = (DWORD ( CALLBACK *)(LPOLESTREAM, OLE_CONST VOID FAR *, DWORD)) WriteStream;

   return lpStream;                    //* SUCCESS return

Error:                                 //* ERROR Tag

   ErrorMessage(E_FAILED_TO_ALLOC);
   EndStream(lpStream);

   return NULL;                        //* ERROR return

}

/***************************************************************************
 *  UpdateMenu()
 *
 *  Enabling or disable menuitems based upon program state.
 ***************************************************************************/

static VOID UpdateMenu(                //* ENTRY:
   HMENU       hMenu                   //* menu handle to updated
){                                     //* LOCAL:
   INT         mf;                     //* generic menu flag
   APPITEMPTR  paItem;                 //* app item pointer
   HMENU       hSub;
                                       //* there must be at least on object
                                       //* for the following to be enabled

   paItem = GetTopItem() ;

   mf = (paItem ? MF_ENABLED : MF_GRAYED);
   EnableMenuItem(hMenu, IDM_CUT, mf); //* i.e. Cut,Copy,Clear,Clearall...
   EnableMenuItem(hMenu, IDM_COPY, mf);
   EnableMenuItem(hMenu, IDM_CLEAR, mf);
   EnableMenuItem(hMenu, IDM_CLEARALL, mf);
                                       //* enable links option only if there
                                       //* is at least one linked object
   EnableMenuItem(hMenu, IDM_LINKS, MF_GRAYED);
   for (; paItem; paItem = GetNextItem(paItem))
   {
      if (paItem->otObject == OT_LINK)
      {
         EnableMenuItem(hMenu, IDM_LINKS, MF_ENABLED);
         break;
      }
   }

   if (hSub = GetSubMenu(hMenu,POS_EDITMENU))
      UpdateObjectMenuItem(hSub);

   if (OleQueryCreateFromClip(STDFILEEDITING, olerender_draw, 0) == OLE_OK)
      EnableMenuItem(hMenu, IDM_PASTE, MF_ENABLED);
   else if (OleQueryCreateFromClip(STATICP, olerender_draw, 0) == OLE_OK)
      EnableMenuItem(hMenu, IDM_PASTE, MF_ENABLED);
   else
      EnableMenuItem(hMenu, IDM_PASTE, MF_GRAYED);

   if (OleQueryLinkFromClip(STDFILEEDITING, olerender_draw, 0) == OLE_OK)
      EnableMenuItem(hMenu, IDM_PASTELINK, MF_ENABLED);
   else
      EnableMenuItem(hMenu, IDM_PASTELINK, MF_GRAYED);

}

/***************************************************************************
 *  NewFile()
 *
 *  Save the present document and open a new blank one.
 ***************************************************************************/

static VOID NewFile(                   //* ENTRY:
   PSTR           pFileName,           //* open file name
   LHCLIENTDOC    *lhcptrDoc,          //* pointer to client doc. handle
   LPAPPSTREAM    lpStream             //* pointer to stream structure
){                                     //* LOCAL:
   static CHAR  szUntitled[CBMESSAGEMAX] = "";//* "(Untitled)" string
   LHCLIENTDOC lhcDocNew;              //* handle for new doc.

   if (!(*szUntitled))
      LoadString(hInst, IDS_UNTITLED, (LPSTR)szUntitled, CBMESSAGEMAX);

   if (SaveAsNeeded(pFileName, *lhcptrDoc, lpStream))
   {                                   //* try to register new document
      if (!RegDoc(szUntitled, &lhcDocNew))
         return;                       //* before deregistring the old one
      DeregDoc(*lhcptrDoc);
      *lhcptrDoc = lhcDocNew;
      Dirty(DOC_CLEAN);                //* new document is clean
      lstrcpy(pFileName,szUntitled);
      SetTitle(pFileName);
      iObjectNumber = 0;
   }

}

/***************************************************************************
 *  MyOpenFile()
 *
 *  Open a file and load it.  Notice that the new file is loaded before
 *  the old is removed.  This is done to assure a succesful file load
 *  before removing an existing document.
 ***************************************************************************/

static VOID MyOpenFile(                //* ENTRY:
   PSTR           pFileName,           //* open file name
   LHCLIENTDOC    *lhcptrDoc,          //* pointer to document handle
   LPOLECLIENT    lpClient,            //* pointer to client structure
   LPAPPSTREAM    lpStream             //* pointer to stream structure
){                                     //* LOCAL:
   CHAR           szNewFile[CBPATHMAX];//* new file name buffer
   LHCLIENTDOC    lhcDocNew;           //* handle of new document
   APPITEMPTR     pItem;               //* hold top item

   if (SaveAsNeeded(pFileName, *lhcptrDoc, lpStream))
   {
      *szNewFile = 0;

      if (!OfnGetName(hwndFrame, szNewFile, IDM_OPEN))
         return;                       //* ERROR return

      if (!RegDoc(szNewFile,&lhcDocNew))
         return;                       //* ERROR return

      pItem = GetTopItem();
      ShowDoc(*lhcptrDoc,0);           //* make old doc objects hidden.
                                       //* try to load the new file before
      if (!LoadFile(szNewFile, lhcDocNew, lpClient, lpStream))
      {                                //* before removing the old.
         DeregDoc(lhcDocNew);          //* restore old document if new
         SetTopItem(pItem);            //* file did not load
         ShowDoc(*lhcptrDoc,1);
         return;                       //* ERROR return
      }

      DeregDoc(*lhcptrDoc);            //* deregister old document
      *lhcptrDoc = lhcDocNew;
      lstrcpy(pFileName,szNewFile);
      SetTitle(pFileName);             //* set new title
      Dirty(DOC_CLEAN);
   }

}                                      //* SUCCESS return

/***************************************************************************
 *  SaveasFile()
 *
 * Prompt the user for a new file name.  Write the document to the new
 * filename.
 ***************************************************************************/

static VOID SaveasFile(                //* ENTRY:
   PSTR           pFileName,           //* old filename
   LHCLIENTDOC    lhcDoc,              //* document handle
   LPAPPSTREAM    lpStream             //* pointer to stream structure
){
   CHAR           szNewFile[CBPATHMAX];//* new file name

   *szNewFile = 0;                  //* prompt user for new file name
   if (!OfnGetName(hwndFrame, szNewFile, IDM_SAVEAS))
      return;                          //* ERROR return
                                       //* rename document
   if (!SaveFile(szNewFile, lhcDoc, lpStream))
      return;

   if (Error(OleRenameClientDoc(lhcDoc, szNewFile)))
   {
      ErrorMessage(W_FAILED_TO_NOTIFY);
      return;                          //* ERROR return
   }

   lstrcpy(pFileName,szNewFile);
   SetTitle(pFileName);

}                                      //* SUCCESS return

/***************************************************************************
 *  SaveFile()
 *
 * Save a compound document file.  If the file is untitled, ask the user
 * for a name and save the document to that file.
 ***************************************************************************/

static BOOL SaveFile(                  //* ENTRY:
   PSTR           pFileName,           //* file to save document to
   LHCLIENTDOC    lhcDoc,              //* OLE document handle
   LPAPPSTREAM    lpStream             //* pointer to app. stream struct
){                                     //* LOCAL:
   CHAR           szNewFile[CBPATHMAX];//* New file name strings
   CHAR           szOemFileName[2*CBPATHMAX];
   static CHAR    szUntitled[CBMESSAGEMAX] = "";
   int            fh;                  //* file handle

   *szNewFile = 0;
   if (!(*szUntitled))
      LoadString(hInst, IDS_UNTITLED, (LPSTR)szUntitled, CBMESSAGEMAX);

   if (!lstrcmp(szUntitled, pFileName))//* get filename for the untitled case
   {
      if (!OfnGetName(hwndFrame, szNewFile, IDM_SAVEAS))
         return FALSE;                 //* CANCEL return
      lstrcpy(pFileName,szNewFile);
      SetTitle(pFileName);
   }

   AnsiToOem(pFileName, szOemFileName);
   if ((fh = _lcreat((LPSTR)szOemFileName, 0)) <= 0)
   {
      ErrorMessage(E_INVALID_FILENAME);
      return FALSE;                    //* ERROR return
   }

   lpStream->fh = fh;
                                       //* save file on disk
   if (!WriteToFile(lpStream))
   {
      _lclose(fh);
      ErrorMessage(E_FAILED_TO_SAVE_FILE);
      return FALSE;                    //* ERROR return
   }
   _lclose(fh);

   if (Error(OleSavedClientDoc(lhcDoc)))
   {
      ErrorMessage(W_FAILED_TO_NOTIFY);
      return FALSE;                    //* ERROR return
   }

   Dirty(DOC_CLEAN);
   return TRUE;                        //* SUCCESS return

}

/***************************************************************************
 *  LoadFile()
 *
 *  Load a document file from disk.
 ***************************************************************************/

static BOOL LoadFile(                  //* ENTRY:
   PSTR           pFileName,           //* file name
   LHCLIENTDOC    lhcDoc,              //* document handle
   LPOLECLIENT    lpClient,            //* pointer to client structure
   LPAPPSTREAM    lpStream             //* pointer to stream structure
){                                     //* LOCAL:
                                       //* OEM file name
   CHAR           szOemFileName[2*CBPATHMAX];
   int            fh;                  //* file handle
   INT            iObjectNumberHold;   //* hold object number

   AnsiToOem(pFileName, szOemFileName);
   if ((fh = _lopen(szOemFileName, OF_READ | OF_SHARE_DENY_WRITE)) == -1)
   {
      ErrorMessage(E_FAILED_TO_READ_FILE);
      return FALSE;                    //* ERROR return
   }

   lpStream->fh = fh;

   iObjectNumberHold = iObjectNumber;  //* save object number so it can
   iObjectNumber     = 0;              //* be restored if read from file
                                       //* fails
   if (!ReadFromFile(lpStream, lhcDoc, lpClient))
   {
      _lclose(fh);
      ErrorMessage(E_FAILED_TO_READ_FILE);
      iObjectNumber = iObjectNumberHold;
      return FALSE;                    //* ERROR return
   }
   _lclose(fh);
   return TRUE;                        //* SUCCESS return

}

/***************************************************************************
 *  RegDoc()
 *
 * Register the client document with the OLE library.
 **************************************************************************/

static BOOL RegDoc(                    //* ENTRY:
   PSTR           pFileName,           //* file name
   LHCLIENTDOC    *lhcptrDoc           //* pointer to client document handle
){

   if (Error(OleRegisterClientDoc(szAppName, (LPSTR)pFileName, 0L, lhcptrDoc)))
   {
      ErrorMessage(W_FAILED_TO_NOTIFY);
      return FALSE;                    //* ERROR return
   }
   return TRUE;                        //* SUCCESS return

}

/****************************************************************************
 *  DeregDoc()
 *
 *  This function initiates the removal of all OLE objects from the
 *  current document and deregisters the document with the OLE library.
 ***************************************************************************/

static VOID DeregDoc(                  //* ENTRY:
   LHCLIENTDOC    lhcDoc               //* client document handle
){

    if (lhcDoc)
    {                                  //* release all OLE objects
        ClearAll(lhcDoc,OLE_OBJ_RELEASE);      //* and remove them from the screen
        WaitForAllObjects();
        if (Error(OleRevokeClientDoc(lhcDoc)))
            ErrorMessage(W_FAILED_TO_NOTIFY);
    }

}                                      //* SUCCESS return

/***************************************************************************
 *  ClearAll()
 *
 * This function will destroy all of the item windows in the current
 * document and delete all OLE objects.  The loop is basically an enum
 * of all child windows.
 **************************************************************************/

static VOID ClearAll(                  //* ENTRY:
   LHCLIENTDOC    lhcDoc,              //* application document handle
   BOOL           fDelete              //* Delete / Release
){                                     //* LOCAL:
   APPITEMPTR     pItemNext;           //* working handles
   APPITEMPTR     pItem;               //* pointer to application item

   pItem = GetTopItem();

   while (pItem)
   {
      pItemNext = GetNextItem(pItem);
      if (pItem->lhcDoc == lhcDoc)
         ObjDelete(pItem, fDelete);
      pItem = pItemNext;
   }

}
                                    //* SUCCESS return
/***************************************************************************
 * ClearItem()
 *
 * This function will destroy an item window, and make the
 * next window active.
 **************************************************************************/

VOID  FAR ClearItem(                 //* ENTRY:
   APPITEMPTR     pItem                //* application item pointer
){

   pItem->fVisible = FALSE;
   SetTopItem(GetNextActiveItem());
   ObjDelete(pItem, OLE_OBJ_DELETE);
   Dirty(DOC_DIRTY);

}

/****************************************************************************
 *  SaveAsNeeded()
 *
 *  This function will have the file saved if and only
 *  if the document has been modified. If the fDirty flag has
 *  been set to TRUE, then the document needs to be saved.
 *
 *  Returns: BOOL -  TRUE if document doesn't need saving or if the
 *                   document has been saved successfully.
 ***************************************************************************/

static BOOL SaveAsNeeded(              //* ENTRY:
   PSTR           pFileName,           //* file to save
   LHCLIENTDOC    lhcDoc,              //* OLE doc handle
   LPAPPSTREAM    lpStream             //* pointer to OLE stream vtbl ...
){                                     //* LOCAL:
   CHAR           sz[CBMESSAGEMAX];    //* work strings
   CHAR           sz2[CBMESSAGEMAX + CBPATHMAX];

   if (Dirty(DOC_QUERY))               //* if doc is clean don't bother
   {

      LoadString(hInst, IDS_MAYBESAVE, sz, CBMESSAGEMAX);
      wsprintf(sz2, sz, (LPSTR)pFileName );

      switch (MessageBox(hwndFrame, sz2, szAppName, MB_YESNOCANCEL | MB_ICONQUESTION))
      {

         case IDCANCEL:
            return FALSE;              //* CANCEL return

         case IDYES:
            return (SaveFile(pFileName,lhcDoc,lpStream));

         default:
            break;
      }
   }
   return TRUE;                        //* SUCCESS return

}

/****************************************************************************
 *  SetTitle()
 *
 *  Set the window caption to the current file name. If szFileName is
 *  NULL, the caption will be set to "(Untitled)".
 ***************************************************************************/

static VOID SetTitle(                  //* ENTRY:
   PSTR           pFileName            //* file name
){                                     //* LOCAL
                                       //* window title string
   CHAR           szTitle[CBMESSAGEMAX + CBPATHMAX];

   wsprintf(szTitle, "%s - %s", (LPSTR)szAppName, (LPSTR)pFileName);
   SetWindowText(hwndFrame, szTitle);

}

/***************************************************************************
 *  EndClient()
 *
 *  Perform cleanup prior to app termination. The OLECLIENT
 *  memory blocks and procedure instance thunks freed.
 **************************************************************************/

static VOID EndStream(                 //* ENTRY:
   LPAPPSTREAM    lpStream             //* pointer to stream structure
){                                     //* LOCAL:
   HANDLE         hGeneric;            //* temp handle

    if (lpStream)                      //* is there a STREAM struct?
    {
      if (lpStream->olestream.lpstbl)
      {
         FreeProcInstance((FARPROC)lpStream->olestream.lpstbl->Get);
         FreeProcInstance((FARPROC)lpStream->olestream.lpstbl->Put);
         hGeneric = GlobalHandle((LPSTR)lpStream->olestream.lpstbl);
         GlobalUnlock(hGeneric);
         GlobalFree(hGeneric);
      }
      hGeneric = GlobalHandle((LPSTR)lpStream);
      GlobalUnlock(hGeneric);
      GlobalFree(hGeneric);
    }

}                                      //* SUCCESS return

/***************************************************************************
 *  EndClient()
 *
 *  Perform cleanup prior to app termination. The OLECLIENT
 *  memory blocks and procedure instance thunks are freed.
 **************************************************************************/

static VOID EndClient(                 //* ENTRY:
   LPOLECLIENT    lpClient             //* pointer to client structure
){                                     //* LOCAL:
   HANDLE         hGeneric;            //* temp handle

   if (lpClient)                       //* is there a client structure
   {
      if (lpClient->lpvtbl)
      {
         FreeProcInstance(lpClient->lpvtbl->CallBack);
         hGeneric = GlobalHandle((LPSTR)lpClient->lpvtbl);
         GlobalUnlock(hGeneric);
         GlobalFree(hGeneric);
      }
      hGeneric = GlobalHandle((LPSTR)lpClient);
      GlobalUnlock(hGeneric);
      GlobalFree(hGeneric);
   }

}                                      //* SUCCESS return

/****************************************************************************
 * QueryEndSession()
 ***************************************************************************/

static LONG QueryEndSession(           //* ENTRY:
   PSTR           pFileName,           //* document name
   LHCLIENTDOC    lhcDoc,              //* client document handle
   LPAPPSTREAM    lpStream             //* application stream pointer
){                                     //* LOCAL:
   APPITEMPTR     pItem;               //* application item pointer


   for (pItem = GetTopItem(); pItem; pItem = GetNextItem(pItem))
      if (OleQueryOpen(pItem->lpObject) == OLE_OK)
      {
         MessageBox(hwndFrame,"Exit CliDemo1 before closing Windows",
               szAppName, MB_OK | MB_ICONSTOP);
         return 0L;
      }

   if (!SaveAsNeeded(pFileName, lhcDoc, lpStream))
      return 0L;
   DeregDoc(lhcDoc);
   return 1L;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\ole1\clidemo\global.h ===
/* 
 * global.h
 *
 * Created by Microsoft Corporation.
 * (c) Copyright Microsoft Corp. 1990 - 1992  All Rights Reserved
 */

//*** CONSTANTS ***

#define PROTOCOL_STRLEN    15          //* protocol name string size
#define CFILTERMAX         20	         //* Max # filters 
                                       //* Max # chars/filter
#define CBFILTERMAX        (100 * CFILTERMAX)
#define CBPATHMAX          250         //* max qualified file name
#define CBOBJNAMEMAX       14          //* maximum length of object name
#define CBVERBTEXTMAX      30          //* maximum length of verb text 
#define CBVERBNUMBMAX      8           //* maximum number of verbs 
#define OBJECT_LINK_MAX    256*3       //* maximum size of object link data
#define CDIGITSMAX         5
#define KEYNAMESIZE        300         //* Maximum registration key length
#define RETRY              3
                                       //* protocol name strings
#define STDFILEEDITING     ((LPSTR)"StdFileEditing")
#define STATICP            ((LPSTR)"Static")
                                       //* object name prefixes
#define OBJPREFIX          ((LPSTR)"CliDemo #")
#define OBJCLONE           ((LPSTR)"CliDemo1#")
#define OBJTEMP            ((LPSTR)"CliDemo2#")

#define DOC_CLEAN          0           //* Dirty() methods
#define DOC_DIRTY          1
#define DOC_UNDIRTY        2
#define DOC_QUERY          3

#define OLE_OBJ_RELEASE   FALSE       //* object deletion type
#define OLE_OBJ_DELETE    TRUE

#define WM_ERROR           WM_USER + 1 //* user defined messages 
#define WM_INIT            WM_USER + 2
#define WM_DELETE          WM_USER + 3
#define WM_RETRY           WM_USER + 4
#define WM_CHANGE          WM_USER + 5

#define RD_CANCEL          0x00000001
#define RD_RETRY           0x00000002

//*** TYPES ***

typedef struct _APPSTREAM FAR *LPAPPSTREAM;

typedef struct _APPSTREAM {
    OLESTREAM        olestream;
    INT              fh;
} APPSTREAM;

typedef struct _APPITEM *APPITEMPTR;

typedef struct _APPITEM {              //* Application item
   OLECLIENT         oleclient;
   HWND              hwnd; 
   LPOLEOBJECT       lpObject;         //* OLE object pointers
   LPOLEOBJECT       lpObjectUndo;     //* undo object
   LONG              otObject;         //* OLE object type
   LONG              otObjectUndo;
   OLEOPT_UPDATE     uoObject;         //* OLE object update option
   OLEOPT_UPDATE     uoObjectUndo;     //* link name atom
   ATOM              aLinkName;        //* Save the link's document name 
   ATOM              aLinkUndo;        //* Save the link's document name 
   LPSTR             lpLinkData;       //* pointer to link data
   BOOL              fVisible;         //* TRUE: item is to be displayed
   BOOL              fOpen;            //* server open? --for undo objects
   BOOL              fRetry;           //* retry flag for busy servers
   BOOL              fNew;
   BOOL              fServerChangedBounds;
   RECT              rect;             //* bounding rectangle
   LHCLIENTDOC       lhcDoc;           //* client document handle
   ATOM              aServer;
} APPITEM;                             


typedef struct _RETRY *RETRYPTR;

typedef struct _RETRY {                //* Application item
   LPSTR       lpserver;
   BOOL        bCancel;
   APPITEMPTR  paItem;
} RETRYSTRUCT;
                 
//*** GLOBALS ***

extern OLECLIPFORMAT vcfLink;          //* ObjectLink clipboard format 
extern OLECLIPFORMAT vcfNative;        //* Native clipboard format 
extern OLECLIPFORMAT vcfOwnerLink;     //* OwnerLink clipboard format 

extern HANDLE        hInst;            //* instance handle
extern HWND        hwndFrame;        //* main window handle
extern HANDLE        hAccTable;        //* accelerator table
extern HWND          hwndProp;         //* link properties dialog
extern HWND          hRetry;           //* retry dialog box handle
extern INT           cOleWait;         //* wait for asyncc commands
extern INT           iObjects;         //* object count
extern INT           iObjectNumber;    //* unique name id
extern CHAR          szItemClass[];    //* item class name    
extern CHAR          szDefExtension[]; //* default file extension       
extern CHAR          szAppName[];      //* application name
extern BOOL          fLoadFile;        //* load file flag
extern CHAR          szFileName[];     //* open file name
extern FARPROC       lpfnTimerProc;    //* pointer to timer callback function

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\ole1\clidemo\object.c ===
/*
 * object.c - OLE object support routines
 *
 * Created by Microsoft Corporation.
 * (c) Copyright Microsoft Corp. 1990 - 1992  All Rights Reserved
 */

//*** INCLUDES ****

#include <windows.h>                   //* WINDOWS
#include <shellapi.h>                  //* SHELL
#include <ole.h>                       //* OLE

#include "global.h"                    //* global variables and structures
#include "stream.h"                    //* application includes:
#include "dialog.h"
#include "object.h"
#include "clidemo.h"
#include "demorc.h"
#include "utility.h"
#include "register.h"

#define HIMETRIC_PER_INCH       2540

//*** VARIABLES ***

//*** Globals
INT     cOleWait     = 0;

INT giXppli ;
INT giYppli ;



/***************************************************************************
 * CallBack()
 *
 * This routine will be called whenever an object has been changed,
 * saved, renamed, is being painted, or an  asynchronous operation has
 * completed. This routine is called by the OLE client DLL in the
 * above situations.  A pointer to this function is kept in the client
 * vtbl.  It is our obligation as a client application to insure that a
 * pointer to this procedure is in the vtbl.
 *
 * IMMPORTANT: notice that we are posting messages here rather that doing
 * the work right away.  Well, this is done to avoid any possibility of
 * getting into another dispatch message loop.  A MessageBox woul do this!
 *
 * Returns int - see below
 *
 * The return value is generally ignored, except for these notifications:
 * OLE_QUERY_PAINT and  OLE_QUERY_RETRY. For these two notifications,
 * returning TRUE means continue the current operation(eg painting or retry)
 * Returning FALSE means stop the current operation. This is useful as an
 * object which takes a long time to paint can be interrupted in order to
 * perform other operations.
 ***************************************************************************/

INT  APIENTRY CallBack(               //* ENTRY:
   LPOLECLIENT      lpClient,         //* client application pointer
   OLE_NOTIFICATION flags,            //* notification code being sent
   LPOLEOBJECT      lpObject          //* OLE object pointer
){                                    //* LOCAL:
   APPITEMPTR     pItem;              //* application item pointer


   pItem = (APPITEMPTR)lpClient;
   switch (flags)
   {
      case OLE_CLOSED:                 //* server has closed
         if (!pItem->fVisible)
         {
            PostMessage(hwndFrame, WM_DELETE, 0L, (DWORD)pItem);
            Dirty(DOC_UNDIRTY);
         }
         SetFocus( hwndFrame );
         break;

      case OLE_SAVED:                  //* server has saved object
      case OLE_CHANGED:                //* object has changes
         cOleWait++;
         pItem->fServerChangedBounds = pItem->fVisible = TRUE;
         PostMessage(pItem->hwnd, WM_CHANGE, 0, 0L);
         break;

      case OLE_RELEASE:                //* notification that an asynchronous
         ToggleBlockTimer(FALSE);      //* toggle timer off
         if (hRetry)
            PostMessage(hRetry,WM_COMMAND,IDCANCEL,0L);

         if (cOleWait)                 //* operation has completed
         {
            pItem->fRetry = TRUE;
            if (!--cOleWait)
               Hourglass(FALSE);
            Release(pItem);
         }
         break;

      case OLE_QUERY_RETRY:          //* Continue retrying.
         ToggleBlockTimer(FALSE);    //* toggle timer off
         if (!hRetry && pItem->fRetry)
            PostMessage(hwndFrame,WM_RETRY,0L, (DWORD)pItem);
         return (pItem->fRetry);

      case OLE_QUERY_PAINT:          //* continue repainting
         return TRUE;                //* a false return terminates either

        default:
            break;
    }
    return 0;                          //* return value is ignored in
                                       //* most cases, see header
}

/***************************************************************************
 * Release()
 *
 * Check for an error on the OLE_RELEASE notification.
 **************************************************************************/

static VOID Release(                   //* ENTRY:
   APPITEMPTR     pItem                //* Item pointer
){                                     //* LOCAL:
   DWORD wParam;              //* error code parameter

   if ((wParam = OleQueryReleaseError(pItem->lpObject)) == OLE_OK)
      return;

   switch (OleQueryReleaseMethod(pItem->lpObject))
   {
      case OLE_LNKPASTE:
         pItem->fVisible = FALSE;
         break;

      case OLE_CREATEFROMTEMPLATE:
      case OLE_CREATE:
         pItem->fVisible = FALSE;
         cOleWait++;
         PostMessage(hwndFrame, WM_DELETE,1L, (DWORD)pItem);
         Dirty(DOC_UNDIRTY);
   }
                                  //* post a message to the main window
                                  //* which will display a message box
   PostMessage(hwndFrame,WM_ERROR,wParam,0);

}

/***************************************************************************
 *  Error()
 *
 *  This function checks for error conditions
 *  generated by OLE API callsFor OLE_WAIT_FOR_RELEASE,
 *  we keep track of the number of objects waiting, when
 *  this count is zero, it is safe to exit the application.
 *
 *  Returns OLESTATUS -  0 if OLE_WAIT_FOR_RELEASE or OLE_OK
 *                       otherwise the OLESTATUS returned after an action
 *                       is taken.
 *************************************************************************/

OLESTATUS FAR Error(                   //* ENTRY
   OLESTATUS      olestat              //* OLE status
){

   switch (olestat)
   {
      case OLE_WAIT_FOR_RELEASE:
         if (!cOleWait)
            Hourglass(TRUE);
         cOleWait++;                   //* increment wait count

      case OLE_OK:
         return 0;

      case OLE_ERROR_STATIC:           //* static object
         ErrorMessage(W_STATIC_OBJECT);
         break;

      case OLE_ERROR_REQUEST_PICT:
      case OLE_ERROR_ADVISE_RENAME:
      case OLE_ERROR_DOVERB:
      case OLE_ERROR_SHOW:
      case OLE_ERROR_OPEN:
      case OLE_ERROR_NETWORK:
      case OLE_ERROR_ADVISE_PICT:
      case OLE_ERROR_COMM:             //* Invalid links
         InvalidLink();
         break;

      case OLE_BUSY:
         RetryMessage(NULL,RD_CANCEL);

      default:
         break;
    }
    return olestat;
}


/****************************************************************************
 * PreItemCreate()
 *
 * This routine allocates an application item structure. A pointer to this
 * structure is passed as the client structure, therefore we need to
 * have a pointer to the vtbl as the first entry. We are doing this
 * to allow acess to the application item information during a OLE
 * DLL callback.  This approach simplifies matters.
 *
 * Returns APPITEMPTR - a pointer to a new application item structure
 *                      which can operate as a client structure.
 ***************************************************************************/

APPITEMPTR FAR PreItemCreate(          //* ENTRY:
   LPOLECLIENT    lpClient,            //* OLE client pointer
   BOOL           fShow,               //* show/no-show flag
   LHCLIENTDOC    lhcDoc               //* client document handle
){                                     //* LOCAL:
   HANDLE         hitem;               //* temp handle for new item
   APPITEMPTR     pItem;               //* application item pointer


   if (hitem = LocalAlloc(LMEM_MOVEABLE | LMEM_ZEROINIT, sizeof(APPITEM)))
      if (pItem = (APPITEMPTR)LocalLock(hitem))
      {                                //* set the vtbl pointer
         pItem->oleclient.lpvtbl     = lpClient->lpvtbl;
         pItem->lpObjectUndo         = NULL;
         pItem->fVisible             = fShow;
         pItem->fServerChangedBounds = FALSE;
         pItem->lhcDoc               = lhcDoc;

         return pItem;                 //* SUCCESS return
      }

   ErrorMessage(E_FAILED_TO_ALLOC);
   return NULL;                        //* ERROR return

}


/***************************************************************************
 * ItemWndProc()
 *
 * This function handles item window message processing.
 * There is an item window for each OLE object. This was done to
 * to simplify hit testing and repainting. These windows are child
 * windows.

 * returns long - standard child routine
 **************************************************************************/

LONG  APIENTRY ItemWndProc(           //* ENTRY:
   HWND           hwnd,                //* standard windows parameters
   UINT           msg,
   DWORD          wParam,
   LONG           lParam
){                                     //* LOCAL:
   static POINT   dragPt;              //* Mouse drag point
   static RECT    dragRect;            //* Mouse drag rectangle
   static BOOL    fCaptured;           //* captured flag
   APPITEMPTR     pItem;               //* application item pointer
   PAINTSTRUCT    ps;                  //* paint structure
   POINT          pt;                  //* point
   RECT           rc;                  //* bounding rectangle
//   char lpstr[256];

   switch (msg)
   {
      case WM_SIZE:
         if (pItem = (APPITEMPTR)GetWindowLong(hwnd,0))
         {
            if (!pItem->fServerChangedBounds && pItem->otObject == OT_EMBEDDED)
               ObjSetBounds(pItem);
            else
               pItem->fServerChangedBounds = FALSE;
         }
         break;

      case WM_CHANGE:
         --cOleWait;
         pItem = (APPITEMPTR)GetWindowLong(hwnd,0);
         if (!Error(OleQueryBounds(pItem->lpObject, &rc)))
         {
            ConvertToClient(&rc);

            SetWindowPos(
               hwnd,
               NULL,
               0,
               0,
               rc.right - rc.left + 2*GetSystemMetrics(SM_CXFRAME),
               rc.bottom - rc.top + 2*GetSystemMetrics(SM_CYFRAME),
               SWP_NOZORDER | SWP_NOMOVE | SWP_DRAWFRAME
            );

            if (!pItem->fNew && !fLoadFile)
               ShowNewWindow(pItem);
            else
               InvalidateRect(hwnd, NULL, TRUE);

            Dirty(DOC_DIRTY);
         }
         break;

      case WM_NCLBUTTONDOWN:
         SetTopItem((APPITEMPTR)GetWindowLong(hwnd,0));
         return (DefWindowProc(hwnd, msg, wParam, lParam));

      case WM_PAINT:
         BeginPaint(hwnd, (LPPAINTSTRUCT)&ps);
         GetClientRect(hwnd, &rc);
         pItem = (APPITEMPTR)GetWindowLong(hwnd, 0);
                                       //* Call OLE draw
         Error(OleDraw(pItem->lpObject, ps.hdc, &rc, NULL, NULL));

         EndPaint(hwnd, (LPPAINTSTRUCT)&ps);
         break;

      case WM_LBUTTONDBLCLK:           //* execute a verb
         ANY_OBJECT_BUSY;
         ExecuteVerb(OLEVERB_PRIMARY,(APPITEMPTR)GetWindowLong(hwnd,0));
         break;

      case WM_LBUTTONDOWN:
         GetWindowRect(hwnd, (LPRECT)&dragRect);
         ScreenToClient(hwndFrame, (LPPOINT)&dragRect);
         ScreenToClient(hwndFrame, (LPPOINT)&dragRect.right);

         dragPt.x = (LONG)(SHORT)LOWORD(lParam);
         dragPt.y = (LONG)(SHORT)HIWORD(lParam);

         ClientToScreen(hwnd, (LPPOINT)&dragPt);
         ScreenToClient(hwndFrame, (LPPOINT)&dragPt);

         SetCapture(hwnd);
         fCaptured = TRUE;
         SetTopItem((APPITEMPTR)GetWindowLong(hwnd,0));
         break;

      case WM_LBUTTONUP:
         if (!fCaptured)
                break;
         ReleaseCapture();
         fCaptured = FALSE;
         Dirty(DOC_DIRTY);
         break;

      case WM_MOUSEMOVE:
         if (!fCaptured)
            break;
         pt.x = (LONG)(SHORT)LOWORD(lParam);
         pt.y = (LONG)(SHORT)HIWORD(lParam);

         ClientToScreen(hwnd, (LPPOINT)&pt);
         ScreenToClient(hwndFrame, (LPPOINT)&pt);

         OffsetRect(
               (LPRECT)&dragRect,
               pt.x - dragPt.x,
               pt.y - dragPt.y
         );

         MoveWindow(
            hwnd,
            dragRect.left, dragRect.top,
            dragRect.right - dragRect.left,
            dragRect.bottom - dragRect.top, TRUE
         );

         dragPt.x = pt.x;
         dragPt.y = pt.y;
         break;

      default:
         return (DefWindowProc(hwnd, msg, wParam, lParam));
   }
   return 0L;

}

/****************************************************************************
 * PostItemCreate()
 *
 * This function creates a child window which will contain the newly
 * created OLE object. A pointer to our item information is stored in the
 * extra bytes of this window. This is where we internally keep track
 * of information related to the object as well as the
 * pointer to the object for subsequent OLE API calls.  This routine is
 * called after an OLE object has been created by the client library.
 *
 * Returns BOOL - TRUE if application item has been created.
 ****************************************************************************/

BOOL FAR PostItemCreate(               //* ENTRY:
   LPOLEOBJECT    lpObject,            //* OLE object pointer
   LONG           otObject,            //* OLE object type
   LPRECT         lprcObject,          //* object bounding rect
   APPITEMPTR     pItem                //* application item pointer
){                                     //* LOCAL:
   INT            i;                   //* index
   RECT           rc;                  //* bounding rectangle
   CHAR           pData[OBJECT_LINK_MAX];//* copy of link data

   if (lprcObject)                     //* if the size of the objects
      rc = *lprcObject;                //* bounding rectangle is not
   else if (OleQueryBounds(lpObject, &rc) == OLE_OK)
      ConvertToClient(&rc);
   else
      SetRect(&rc, 0, 0, 0, 0);

   if (!(pItem->hwnd = CreateWindow(   //* Create the child window
         szItemClass, "",
         WS_BORDER | WS_CHILD | WS_CLIPSIBLINGS | WS_THICKFRAME,
         rc.left,rc.top,
         rc.right - rc.left + 2 * GetSystemMetrics(SM_CXFRAME),
         rc.bottom - rc.top + 2 * GetSystemMetrics(SM_CYFRAME),
         hwndFrame, NULL, hInst, NULL
   ))) goto Error;

                                       //* in windows extra bytes
   SetWindowLong(pItem->hwnd, 0, (LONG)pItem);

   pItem->otObject = otObject;
   pItem->lpObject = lpObject;
   pItem->fRetry  = TRUE;

   if( pItem->otObject == OT_EMBEDDED )//* if object is embedded tell library
   {                                   //* the container name and object name.
      UINT  cb=CBOBJNAMEMAX;           //* The name will be the server window title.
      CHAR  sz[CBOBJNAMEMAX];          //* when the object is edited.

      OleQueryName(lpObject, (LPSTR)sz, (UINT FAR *)&cb );


      WaitForObject(pItem);
      Error(OleSetHostNames(lpObject, (LPSTR)szAppName, (LPSTR)sz ));
      WaitForObject(pItem);
   }
   else if (pItem->otObject == OT_LINK)//* if the object is linked
   {                                   //* retrieve update options

      WaitForObject(pItem);
      if(Error(OleGetLinkUpdateOptions(pItem->lpObject, &pItem->uoObject)))
         goto Error;

      if (ObjGetData(pItem,pData))
      {
         for (i=0; pData[i];i++);      //* Skip past the server name
         pItem->aLinkName = AddAtom(&pData[++i]);
      }
      else
         pItem->aLinkName = AddAtom("");
   }
   iObjects++;
   Dirty(DOC_DIRTY);
                                       //* a user interface recommendations.
   return TRUE;                        //* SUCCESS return

Error:                                 //* ERROR Tag

   ErrorMessage(E_FAILED_TO_CREATE_CHILD_WINDOW);
   FreeAppItem(pItem);

   return FALSE;                       //* ERROR return

}

/***************************************************************************
 * ConvertToClient()
 *
 * This function will convert to client from himetric.
 **************************************************************************/

VOID FAR ConvertToClient(              //* ENTRY:
   LPRECT         lprc                 //* pointer to bounding rectangle
){                                     //* LOCAL

   //* If we have an empty rectangle then set the default size
   if (!(lprc->left || lprc->top || lprc->right || lprc->bottom))
      SetRect(lprc, 0, 0, CXDEFAULT, CYDEFAULT);
   else
   {
      //* We got the himetric units, converts them to pixels now.
      lprc->right   = MulDiv (giXppli, (lprc->right - lprc->left),
                          HIMETRIC_PER_INCH);

      lprc->bottom  = MulDiv (giYppli, (lprc->top - lprc->bottom),
                          HIMETRIC_PER_INCH);

      lprc->left    = 0;
      lprc->top     = 0;
    }
}

/***************************************************************************
 * ObjInsert()
 *
 * Query the user for object type to insert and insert the new OLE object
 ***************************************************************************/

VOID FAR ObjInsert(                    //* ENTRY:
   LHCLIENTDOC    lhcDoc,              //* OLE document handle
   LPOLECLIENT    lpClient             //* pointer to OLE client structure
){                                     //* LOCAL:
   LPOLEOBJECT    lpObject;            //* pointer to OLE object
   APPITEMPTR     pItem;               //* item pointer
   CHAR           szServerName[CBPATHMAX];//* Class name for OleCreate()
   CHAR           szClassName[CBPATHMAX];//* Class name for OleCreate()
   CHAR           szTmp[CBOBJNAMEMAX]; //* buffer to unique object name

   if (DialogBoxParam(hInst, MAKEINTRESOURCE(DTCREATE),hwndFrame,
            (DLGPROC) fnInsertNew, (LONG)((LPSTR)szClassName)) != IDCANCEL)
   {
      if (pItem = PreItemCreate(lpClient, FALSE, lhcDoc))
      {
         RegGetClassId(szServerName, szClassName);
         pItem->aServer = AddAtom(szServerName);
         if ( Error( OleCreate(STDFILEEDITING,(LPOLECLIENT)&(pItem->oleclient),
            (LPSTR)szClassName, lhcDoc,CreateNewUniqueName(szTmp),
            &lpObject,olerender_draw, 0)))
         {
            ErrorMessage(E_FAILED_TO_CREATE_OBJECT);
            FreeAppItem(pItem);
         }
         else
            PostItemCreate(lpObject, OT_EMBEDDED, NULL, pItem);
      }
   }


}

/***************************************************************************
 *  ObjDelete()
 *
 * Delete an OLE object. For this application, all OLE objects
 * are associated with a child window; therefore the window must be
 * destroyed.
 *
 * NOTE: There is one case when we call OleRelease and the other when
 * we call OleDelete.  We call OleRelease when we are deregistering
 * a document and OleDelete when removing an object from a document.
 **************************************************************************/

VOID FAR ObjDelete(                    //* ENTRY:
   APPITEMPTR     pItem,               //* pointer to application item
   BOOL           fDelete              //* delete or release flag
){                                     //* LOCAL:

   if (pItem->lpObjectUndo)
   {
      Error(OleDelete(pItem->lpObjectUndo));
                                       //* wait for asynchronous operation
      WaitForObject(pItem);
   }

   if (fDelete ? Error(OleDelete(pItem->lpObject))
                     : Error(OleRelease(pItem->lpObject)))
   {
      ErrorMessage(E_FAILED_TO_DELETE_OBJECT);
      return;                          //* ERROR return
   }

   if (pItem->fVisible)
   {
      ShowWindow(pItem->hwnd, SW_HIDE);
      pItem->fVisible = FALSE;
   }
                                       //* the operation has to complete
   WaitForObject(pItem);               //* before the application structure

   FreeAppItem(pItem);
   iObjects--;

}


/***************************************************************************
 *  ObjPaste()
 *
 *  This function obtains an object from the clipboard.
 *  Handles both embedded and linked objects. An item window is
 *  created for each new object.
 *
 *  Returns BOOL  - TRUE if object was pasted succesfully.
 **************************************************************************/

VOID FAR ObjPaste(                     //* ENTRY:
   BOOL           fPaste,              //* Paste/PasteLink flag
   LHCLIENTDOC    lhcDoc,              //* client document handle
   LPOLECLIENT    lpClient             //* pointer to client
){                                     //* LOCAL:
   LPOLEOBJECT    lpObject;            //* object pointer
   LONG           otObject;            //* object type
   APPITEMPTR     pItem;               //* application item pointer
   CHAR           szTmp[CBOBJNAMEMAX]; //* temporary object name string

   if (!(pItem = PreItemCreate(lpClient, TRUE, lhcDoc)))
      return;                          //* ERROR return

   if (!OpenClipboard(hwndFrame))
      goto Error;                      //* ERROR jump


   if (fPaste)                         //* PASTE the object.
   {                                   //* Try "StdFileEditing" protocol
      if (Error(OleCreateFromClip(STDFILEEDITING,(LPOLECLIENT)&(pItem->oleclient),lhcDoc,
         CreateNewUniqueName(szTmp),&lpObject, olerender_draw,0)))
      {
                                       //* next try "Static" protocol
         if (Error(OleCreateFromClip(
                  STATICP, (LPOLECLIENT)&(pItem->oleclient), lhcDoc,
                  CreateNewUniqueName(szTmp), &lpObject, olerender_draw, 0)))
            goto Error;               //* ERROR jump
      }
   }
   else
   {                                   //* LINK therefore must be
                                       // "STdFileEditing" protocol
        if (Error(OleCreateLinkFromClip(
            STDFILEEDITING,(LPOLECLIENT)&(pItem->oleclient), lhcDoc,
            CreateNewUniqueName(szTmp), &lpObject, olerender_draw, 0)))
            goto Error;                //* ERROR jump
   }

   OleQueryType(lpObject, &otObject);
   CloseClipboard();

   if (!PostItemCreate(lpObject, otObject, NULL, pItem))
      return;                          //* ERROR return

   ShowNewWindow(pItem);
   return;                             //* SUCCESS return


Error:                                 //* TAG Error

   ErrorMessage(E_GET_FROM_CLIPBOARD_FAILED);
   CloseClipboard();
   FreeAppItem(pItem);

   return;                             //* ERROR return

}

/***************************************************************************
 * ObjCopy()
 *
 * This function places an OLE object on the clipboard via the \
 * OleCopyToClipboard() function.
 *
 * Returns BOOL - TRUE if object successfully placed on clipboard
 **************************************************************************/

BOOL FAR ObjCopy(                      //* ENTRY:
   APPITEMPTR     pItem                //* pointer to app item
){                                     //* LOCAL:
   BOOL           fReturn = TRUE;      //* return value

   if (!OpenClipboard(hwndFrame))
      return FALSE;                    //* ERROR return

   EmptyClipboard();

   if (Error(OleCopyToClipboard(pItem->lpObject)))
      fReturn = FALSE;                 //* prepare for ERROR out

   CloseClipboard();
   return fReturn;                     //* ERROR or SUCCESS

}

/***************************************************************************
 *  ObjCreateFromTemplate()
 *
 *  Creates an embedded object from file.
 **************************************************************************/

VOID FAR ObjCreateFromTemplate(        //* ENTRY:
   LHCLIENTDOC    lhcDoc,              //* client document handle
   LPOLECLIENT    lpClient             //* client vtbl. pointer
){                                     //* LOCAL:
   LPOLEOBJECT    lpObject;            //* OLE object pointer
   APPITEMPTR     pItem;               //* application item pointer
   CHAR           szTmp[CBOBJNAMEMAX]; //* temporary object name string
   CHAR           szFileName[CBPATHMAX];//* file name string

   *szFileName = 0;

   if (!OfnGetName(hwndFrame, szFileName, IDM_INSERTFILE))
      return;                          //* ERROR operation aborted by user

   if (!(pItem = PreItemCreate(lpClient, FALSE, lhcDoc)))
      return;                          //* ERROR

   if (Error(OleCreateFromTemplate(STDFILEEDITING, (LPOLECLIENT)pItem, szFileName,
         lhcDoc, CreateNewUniqueName(szTmp), &lpObject, olerender_draw, 0)))
   {
      ErrorMessage(E_CREATE_FROM_TEMPLATE);
      FreeAppItem(pItem);
      return;                          //* ERROR
   }

   PostItemCreate(lpObject, OT_EMBEDDED, NULL, pItem);

}                                      //* SUCCESS


/****************************************************************************
 * ObjGetData()
 *
 * Get the object link data.  The data that is retrieved from OLE is copied
 * into lpLinkData if lpLinkData is not NULL.  Otherwise, space is dynamically
 * allocated or reallocated; space is allocated if pItem->lpLinkData is NULL
 * otherwise the pointer is reallocated. The data is returned is freed if
 * there has been an OLE_WARN_DELETE_DATA error.
 ***************************************************************************/

BOOL FAR ObjGetData(                   //* ENTRY:
   APPITEMPTR     pItem,               //* OLE object
   LPSTR          lpLinkData           //* pointer to linkdata
){                                     //* LOCAL:
   HANDLE         hData;               //* handle to OLE link data
   LPSTR          lpData;              //* pointer to OLE link data
   LPSTR          lpWork;              //* copy of OLE link data
   BOOL           fFree = FALSE;       //* free OLE memory flag
   LONG           lSize;               //* size of OLE link data
   INT            i;

   switch (Error(OleGetData(pItem->lpObject,
      (OLECLIPFORMAT)(pItem->otObject == OT_LINK ? vcfLink : vcfOwnerLink), &hData)))
   {
      case OLE_WARN_DELETE_DATA:
         fFree = TRUE;
      case OLE_OK:
         if(lpData = GlobalLock(hData))
         {
                                       //* copy the link data to new buffer
            lSize=SizeOfLinkData(lpData);

            if (!lpLinkData)
            {
               if (!pItem->lpLinkData)  //* allocate
                  AllocLinkData(pItem,lSize);
               else                     //* otherwise reallocate
                  ReallocLinkData(pItem,lSize);
               lpWork = pItem->lpLinkData;
            }
            else
               lpWork = lpLinkData;

            if (lpWork)
               for (i=0L; i<(INT)lSize; i++)
                  *(lpWork+i)=*(lpData+i);

            GlobalUnlock(hData);       //* free the linked data as needed
            if (fFree)
               GlobalFree(hData);

            return TRUE;               //* SUCCESS
         }
      default:
         return FALSE;                 //* FAILURE
   }

}

/***************************************************************************
 * ObjChangeLink()
 *
 * Change the linkdata.  This routine will change the document portion of
 * link data to lpDoc.  The old linkdata is expected to be in
 * lpaItem->lpLinkData
 **************************************************************************/

VOID FAR ObjChangeLinkData(            //* ENTRY:
   APPITEMPTR     pItem,               //* OLE object
   LPSTR          lpDoc                //* document name
){                                     //* LOCAL:
   LONG           lSize;               //* used to link data size
   LPSTR          lpLinkData;          //* OLE link data pointer
   static CHAR    pWork[OBJECT_LINK_MAX]; //* used to construct new link data
   INT            i;                   //* index
   HANDLE         hData;

   pItem->aLinkName = AddAtom(lpDoc);

   for (
      lpLinkData = pItem->lpLinkData, i=0;
      pWork[i] = *lpLinkData;
      lpLinkData++, i++
   );
                                       //* into working buffer.
   lstrcpy((LPSTR)&pWork[++i],lpDoc);  //* copy new document name.

   for (; pWork[i]; i++);              //* skip to end of document name
   for (++lpLinkData;*lpLinkData;lpLinkData++);
                                       //* copy item name.
   lstrcpy((LPSTR)&pWork[++i],++lpLinkData);
   for (; pWork[i]; i++);              //* skip to end of buffer
                                       //* which is the end of item info.
   pWork[++i] = 0;                  //* add extra null.

   lSize = SizeOfLinkData(pWork);      //* reallocate space so there is
   ReallocLinkData(pItem,lSize);       //* a properly sized block of info
                                       //* to send the linked data to the
   if (lpLinkData = pItem->lpLinkData) //* OLE DLL.
      for (i=0; i<(INT)lSize; i++)     //* copy new linkdata into this space
         *lpLinkData++ = pWork[i];
   else
      return;                          //* ERROR return

   Error(OleSetData(pItem->lpObject, vcfLink, GlobalHandle(pItem->lpLinkData)));

   /*
    * The handle passed into OleSetData is owned by the OLE client library
    * and should not be used after the call.  On win32s, it is inaccessible
    * after the call, so restore it by calling OleGetData.  Note that the
    * data is *still* owned by the library, but we will now have access
    * to the memory.
    */
   Error(OleGetData(pItem->lpObject, vcfLink, &hData));
   if (hData) {
       pItem->lpLinkData = GlobalLock(hData);
   }
}                                      //* SUCCESS return

/****************************************************************************
 * ObjSaveUndo()
 *
 * Clone the OLE object so that any changes to object can be undone if the
 * user choses to exit without update.
 ***************************************************************************/

VOID FAR ObjSaveUndo(                  //* ENTRY:
   APPITEMPTR     pItem                //* application item
){                                     //* LOCAL:
   CHAR           szTmp[CBOBJNAMEMAX]; //* holder of object name
   LPSTR          lpClone;             //* pointer to clond object name
   UINT           i=CBOBJNAMEMAX;

   if (!pItem->lpObjectUndo)
   {
      OleQueryName(pItem->lpObject, szTmp, &i);
                                       //* give clone a unique name by
                                       //* altering object name prefix.
      for (lpClone = OBJCLONE, i=0; *lpClone; szTmp[i++] = *lpClone++);

      if (Error(OleClone(pItem->lpObject, (LPOLECLIENT)pItem,
         pItem->lhcDoc, szTmp, &(pItem->lpObjectUndo))))
      return;                          //* ERROR return

      pItem->otObjectUndo  = pItem->otObject;
      pItem->uoObjectUndo  = pItem->uoObject;
      pItem->aLinkUndo     = pItem->aLinkName;

      GetClientRect(pItem->hwnd, &pItem->rect);

      if (OleQueryOpen(pItem->lpObject) == OLE_OK)
         pItem->fOpen = TRUE;

   }

}                                      //* SUCCESS return

/****************************************************************************
 * ObjUndo()
 *
 * Restore an object to its state before changes.  The lpObject Undo is a
 * clone to the original object with a different name, therefore, all we
 * have to do is rename that object and ditch the changed object.
 ***************************************************************************/

VOID FAR ObjUndo(                      //* ENTRY:
   APPITEMPTR     pItem                //* application item
){                                     //* LOCAL:
   CHAR           szTmp[CBOBJNAMEMAX]; //* object name holder
   UINT           i = CBOBJNAMEMAX;

   OleQueryName(pItem->lpObject, szTmp, &i);
   if (Error(OleDelete(pItem->lpObject)))
      return;                          //* ERROR return
                                       //* reset app item vars
   pItem->lpObject      = pItem->lpObjectUndo;
   pItem->otObject      = pItem->otObjectUndo;
   pItem->uoObject      = pItem->uoObjectUndo;
   pItem->aLinkName     = pItem->aLinkUndo;
   pItem->lpObjectUndo  = (LPOLEOBJECT)NULL;
   pItem->otObjectUndo  = (LONG)NULL;

   if (Error(OleRename(pItem->lpObject,szTmp)))
      return;                          //* ERROR return

   if (pItem->fOpen)
   {
      Error(OleReconnect(pItem->lpObject));
      pItem->fOpen = FALSE;
   }

   SetWindowPos(
      pItem->hwnd,
      NULL, 0, 0,
      pItem->rect.right - pItem->rect.left + 2*GetSystemMetrics(SM_CXFRAME),
      pItem->rect.bottom - pItem->rect.top + 2*GetSystemMetrics(SM_CYFRAME),
      SWP_NOZORDER | SWP_NOMOVE | SWP_DRAWFRAME
   );

   InvalidateRect(pItem->hwnd,NULL,TRUE);

}                                      //* SUCCESS return


/****************************************************************************
 * ObjDelUndo()
 *
 * Delete the undo object if the user is happy with the changes he/she made.
 ***************************************************************************/

VOID FAR ObjDelUndo(                   //* ENTRY:
   APPITEMPTR     pItem                //* application item
){

   if (Error(OleDelete(pItem->lpObjectUndo)))
      return;                          //* ERROR return

   pItem->lpObjectUndo = (LPOLEOBJECT)NULL;
   pItem->otObjectUndo = (LONG)NULL;
   DeleteAtom(pItem->aLinkUndo);
   pItem->lpObjectUndo = NULL;

}                                      //* SUCCESS return

/****************************************************************************
 * ObjFreeze()
 *
 * Convert an object to a static object.
 ***************************************************************************/

VOID FAR ObjFreeze(                    //* ENTRY:
   APPITEMPTR     pItem                //* application item
){                                     //* LOCAL:
   CHAR           szTmp[CBOBJNAMEMAX]; //* temporary object name
   LPSTR          lpTemp;              //* temporary prefix string
   LPOLEOBJECT    lpObjectTmp;         //* temporary object pointer
   UINT           i=CBOBJNAMEMAX;

   OleQueryName(pItem->lpObject, szTmp, &i);
                                       //* create a unique name by changing
                                       //* the object name prefix
   for (lpTemp = OBJTEMP, i=0; *lpTemp; szTmp[i++] = *lpTemp++);

                                       //* this API creates a static object
   if (Error(OleObjectConvert(pItem->lpObject, STATICP, (LPOLECLIENT)pItem,
      pItem->lhcDoc, szTmp, &lpObjectTmp)))
      return;
                                       //* delete old object
   if (Error(OleDelete(pItem->lpObject)))
      return;

   WaitForObject(pItem);

   pItem->lpObject = lpObjectTmp;
   pItem->otObject = OT_STATIC;
   pItem->uoObject = -1L;

   for (lpTemp = OBJPREFIX, i=0; *lpTemp; szTmp[i++] = *lpTemp++);
   if (Error(OleRename(pItem->lpObject,szTmp)))
      return;


}

/***************************************************************************
 *  ObjCreateWrap()
 *
 * Create a wrapped object from the drag and drop feature of the 3.1 shell.
 * NOTE: We are assuming that only one file has been dropped.  See the SDK
 * documentation for instructions on how to deal with multiple files.
 ***************************************************************************/

VOID FAR ObjCreateWrap(                //* ENTRY:
   HANDLE         hdrop,               //* handle to dropped object
   LHCLIENTDOC    lhcDoc,              //* document handle
   LPOLECLIENT    lpClient             //* pointer to client structure
){                                     //* LOCAL:
   CHAR           szDragDrop[CBPATHMAX];//* Drag and drop file name
   LPOLEOBJECT    lpObject;            //* pointer to OLE object
   POINT          pt;                  //* position of dropped object
   RECT           rc;                  //* object size and position
   CHAR           szTmp[CBOBJNAMEMAX]; //* buffer for unique object name
   APPITEMPTR     pItem;               //* application item pointer
   INT            x,y;                 //* icon sizes

   x = GetSystemMetrics(SM_CXICON) / 2;
   y = GetSystemMetrics(SM_CYICON) / 2;
                                       //* Get the drag and drop filename
                                       //* position
   DragQueryPoint(hdrop, &pt);
   DragQueryFile(hdrop, 0, szDragDrop, CBPATHMAX);
   DragFinish(hdrop);

   SetRect(&rc, pt.x - x, pt.y - y, pt.x + x, pt.y + y);

   if (!(pItem = PreItemCreate(lpClient, TRUE, lhcDoc)))
      return;                          //* ERROR return
                                       //* create OLE object
   if (Error(OleCreateFromFile(STDFILEEDITING, (LPOLECLIENT)pItem,
         "Package", szDragDrop, lhcDoc, CreateNewUniqueName(szTmp),
         &lpObject, olerender_draw, 0)))
   {
      ErrorMessage(E_FAILED_TO_CREATE_OBJECT);
      FreeAppItem(pItem);
      return;                          //* ERROR return
   }

   if (PostItemCreate(lpObject, OT_EMBEDDED, &rc, pItem))
      ShowNewWindow(pItem);

}                                      //* SUCCESS return

/***************************************************************************
 *  UpdateObjectMenuItem()
 *
 *  Add an object popup menu for the chosen object if multiple verbs exist.
 *  The registration system is used to determine which verbs exist for the
 *   given object.
 **************************************************************************/

VOID FAR UpdateObjectMenuItem(         //* ENTRY:
   HMENU       hMenu                   //* main menu
){                                     //* LOCAL
   INT         cVerbs;                 //* verb
   APPITEMPTR  pItem;                  //* application item ponter
   DWORD       dwSize = KEYNAMESIZE;
   CHAR        szClass[KEYNAMESIZE], szBuffer[200];
   CHAR        szVerb[KEYNAMESIZE];
   HMENU       hPopupNew=NULL;
   HKEY        hkeyTemp;
   CHAR        pLinkData[OBJECT_LINK_MAX];
                                       //* delete current item and submenu
   DeleteMenu(hMenu, POS_OBJECT, MF_BYPOSITION );

   if (!(pItem = GetTopItem()) )
      goto Error;                      //* ERROR jump
   else if (!pItem->fVisible)
      goto Error;                      //* ERROR jump
                                       //* if STATIC ?
   if ((pItem->otObject != OT_EMBEDDED) && (pItem->otObject != OT_LINK))
      goto Error;                      //* ERROR jump

   if (!ObjGetData(pItem, pLinkData))  //* get linkdata as key reg database
      goto Error;                      //* ERROR jump
                                       //* open reg database
   szClass[0] = 0;
   if (RegOpenKey(HKEY_CLASSES_ROOT, szClass, &hkeyTemp))
      goto Error;                      //* ERROR jump
                                       //* check if class is reg-db
   if (RegQueryValue(HKEY_CLASSES_ROOT, pLinkData, szClass, &dwSize))
   {
      RegCloseKey(hkeyTemp);
      goto Error;                      //* ERROR jump
   }

   for (cVerbs=0; ;++cVerbs)           //* extract all verbs from reg-db
   {
      dwSize = KEYNAMESIZE;
      wsprintf(szBuffer, "%s\\protocol\\StdFileEditing\\verb\\%d",
                                     (LPSTR)pLinkData,cVerbs);

      if (RegQueryValue(HKEY_CLASSES_ROOT, szBuffer, szVerb, &dwSize))
         break;

      if (!hPopupNew)
         hPopupNew = CreatePopupMenu();

      InsertMenu(hPopupNew, (UINT)-1, MF_BYPOSITION, IDM_VERBMIN+cVerbs, szVerb);
   }

   //* NOTE: For International versions the following  verb menu
   //* may need to be formatted differently.

   switch (cVerbs)                     //* determine how many verbs found
   {
      case 0:                          //* none
         wsprintf(szBuffer, "Edit %s %s", (LPSTR)szClass, (LPSTR)"&Object");
         InsertMenu(hMenu, POS_OBJECT, MF_BYPOSITION, IDM_VERBMIN, szBuffer);
         break;

      case 1:                          //* one
         wsprintf(szBuffer, "%s %s %s", (LPSTR)szVerb, (LPSTR)szClass,
            (LPSTR)"&Object");
         DestroyMenu(hPopupNew);
         InsertMenu(hMenu, POS_OBJECT, MF_BYPOSITION, IDM_VERBMIN, szBuffer);
         break;

     default:                          //* > 1
         wsprintf(szBuffer, "%s %s", (LPSTR)szClass, (LPSTR)"&Object");
         InsertMenu(hMenu, POS_OBJECT, MF_BYPOSITION | MF_POPUP, (UINT)hPopupNew, szBuffer);
         EnableMenuItem(hMenu, POS_OBJECT, MF_ENABLED|MF_BYPOSITION);
         break;
   }

   RegCloseKey(hkeyTemp);              //* close reg-db
   return;                             //* SUCCESS return

Error:                                 //* ERROR tag
   InsertMenu(hMenu, POS_OBJECT, MF_BYPOSITION, 0, "&Object");
   EnableMenuItem(hMenu, POS_OBJECT, MF_GRAYED | MF_BYPOSITION);

}                                      //* ERROR return

/***************************************************************************
 *  ExecuteVerb()
 *
 *  Execute the verb for the given object.
 ***************************************************************************/

VOID FAR ExecuteVerb(                  //* ENTRY:
   UINT iVerb,                          //* verb
   APPITEMPTR pItem                    //* application item pointer
){                                     //* LOCAL
   RECT        rc;                     //* holds client area bounding rect

   if (pItem->otObject == OT_STATIC)   //* if the object is static beep
   {
      ErrorMessage(W_STATIC_OBJECT);
      return;                          //* return
   }
                                       //* get cliet area rectangle
   GetClientRect(hwndFrame, (LPRECT)&rc);
                                       //* execute OLE verb
   if (Error(OleActivate(pItem->lpObject, iVerb, TRUE, TRUE, hwndFrame, &rc)))
      return;

   WaitForObject(pItem);               //* wait for async. operation

   ObjSetBounds(pItem);


}                                      //* SUCCESS return

/****************************************************************************
 * ObjSetBounds
 *
 * Set the object bounds.  The object bounds are the child windos bounding
 * rectangle.  OLE servers recieve need the bounding rectangle in HIMETRIC
 * coordinates.  So, we convert from screen coordinates to HIMETRIC.
 *
 * Returns BOOL - TRUE if successful.
 ***************************************************************************/
BOOL FAR ObjSetBounds(                 //* ENTRY:
   APPITEMPTR     pItem                //* application item pointer
){                                     //* LOCAL:
   RECT           itemRect;            //* bounding rectangle

   GetWindowRect(pItem->hwnd,&itemRect);//* get item window react

   itemRect.right -= GetSystemMetrics(SM_CXFRAME);
   itemRect.left += GetSystemMetrics(SM_CXFRAME);
   itemRect.top += GetSystemMetrics(SM_CYFRAME);
   itemRect.bottom -= GetSystemMetrics(SM_CYFRAME);

   itemRect.right  = MulDiv ((itemRect.right - itemRect.left),
                        HIMETRIC_PER_INCH, giXppli);
   itemRect.bottom = - MulDiv((itemRect.bottom - itemRect.top),
                        HIMETRIC_PER_INCH, giYppli);
   itemRect.top    = 0;
   itemRect.left   = 0;
                                       //* set the rect for the server
   if (Error(OleSetBounds(pItem->lpObject,(LPRECT)&itemRect)))
      return FALSE;                    //* ERROR return

   WaitForObject(pItem);               //* wait for async. operation
   return TRUE;                        //* SUCCESS return

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\ole1\clidemo\dialog.c ===
/*
 * dialog.c - Handles the Windows 3.1 common dialogs.
 *
 * Created by Microsoft Corporation.
 * (c) Copyright Microsoft Corp. 1990 - 1992  All Rights Reserved
 */

//*** INCLUDES ****

#include <windows.h>                   //* WINDOWS
#include <ole.h>                       //* OLE

#include "global.h"                    //* global
#include "demorc.h"                    //* String table constants
#include "register.h"                  //* Class registration library
#include "utility.h"
#include "dialog.h"
#include "object.h"

//*** GLOBALS ***
                                       //* strings used with commdlg
CHAR        szDefExtension[CBMESSAGEMAX];
CHAR        szFilterSpec[CBFILTERMAX];
CHAR        szInsertFilter[CBFILTERMAX];
CHAR        szLastDir[CBPATHMAX];
OPENFILENAME OFN;
HWND        hwndProp = NULL;
HWND        hRetry;

/***************************************************************************
 * OfnInit()
 * Initializes the standard file dialog OFN structure.
 **************************************************************************/

VOID FAR OfnInit(                      //* ENTRY:
   HANDLE         hInst                //* instance handle
){                                     //* LOCAL:
   LPSTR          lpstr;               //* string pointer

   LoadString(hInst, IDS_FILTER, szFilterSpec, CBMESSAGEMAX);
   LoadString(hInst, IDS_EXTENSION, szDefExtension, CBMESSAGEMAX);

   OFN.lStructSize    = sizeof(OPENFILENAME);
   OFN.hInstance      = hInst;
   OFN.nMaxCustFilter = CBFILTERMAX;
   OFN.nMaxFile       = CBPATHMAX;
   OFN.lCustData      = 0;
   OFN.lpfnHook       = NULL;
   OFN.lpTemplateName = NULL;
   OFN.lpstrFileTitle = NULL;
                                       //* Construct the filter string
                                       //* for the Open and Save dialogs
   lpstr = (LPSTR)szFilterSpec;
   lstrcat(lpstr, " (*.");
   lstrcat(lpstr, szDefExtension);
   lstrcat(lpstr, ")");
   lpstr += lstrlen(lpstr) + 1;

   lstrcpy(lpstr, "*.");
   lstrcat(lpstr, szDefExtension);
   lpstr += lstrlen(lpstr) + 1;
   *lpstr = 0;

   RegMakeFilterSpec(NULL, NULL, (LPSTR)szInsertFilter);

}

/***************************************************************************
 * OfnGetName()
 *
 * Calls the standard file dialogs to get a file name
 **************************************************************************/

BOOL FAR OfnGetName(                   //* ENTRY:
   HWND           hwnd,                //* parent window handle
   LPSTR          szFileName,          //* File name
   WORD           msg                  //* operation
){                                     //* LOCAL:
   BOOL           frc;                 //* return flag
   CHAR           szCaption[CBMESSAGEMAX];//* dialog caption

   OFN.hwndOwner       = hwnd;               //* window
   OFN.nFilterIndex    = 1;
   OFN.lpstrInitialDir = (LPSTR)szLastDir;
   OFN.Flags           = OFN_HIDEREADONLY;

   switch (msg)                        //* message
   {
      case IDM_OPEN:                   //* open file
         Normalize(szFileName);
         OFN.lpstrDefExt = (LPSTR)szDefExtension;
         OFN.lpstrFile   = (LPSTR)szFileName;
         OFN.lpstrFilter = (LPSTR)szFilterSpec;
         LoadString(hInst, IDS_OPENFILE, szCaption, CBMESSAGEMAX);
         OFN.lpstrTitle  = (LPSTR)szCaption;
         OFN.Flags       |= OFN_FILEMUSTEXIST;
         return GetOpenFileName((LPOPENFILENAME)&OFN);
         break;

      case IDM_SAVEAS:                 //* save as file
         Normalize(szFileName);
         OFN.lpstrDefExt = (LPSTR)szDefExtension;
         OFN.lpstrFile   = (LPSTR)szFileName;
         OFN.lpstrFilter = (LPSTR)szFilterSpec;
         LoadString(hInst, IDS_SAVEFILE, szCaption, CBMESSAGEMAX);
         OFN.lpstrTitle  = (LPSTR)szCaption;
         OFN.Flags       |= OFN_PATHMUSTEXIST;
         return GetSaveFileName((LPOPENFILENAME)&OFN);
         break;

      case IDM_INSERTFILE:             //* insert file
         OFN.lpstrDefExt = NULL;
         OFN.lpstrFile   = (LPSTR)szFileName;
         OFN.lpstrFilter = (LPSTR)szInsertFilter;
         LoadString(hInst, IDS_INSERTFILE, szCaption, CBMESSAGEMAX);
         OFN.lpstrTitle  = (LPSTR)szCaption;
         OFN.Flags      |= OFN_FILEMUSTEXIST;
         frc             = GetOpenFileName((LPOPENFILENAME)&OFN);
         AddExtension(&OFN);
         return frc;
         break;

      default:                         //* default
         break;
   }

}

/***************************************************************************
 * OfnGetNewLinkName() - Sets up the "Change Link..." dialog box
 *
 * returns LPSTR - fully qualified filename
 **************************************************************************/

LPSTR FAR OfnGetNewLinkName(           //* ENTRY:
   HWND           hwnd,                //* calling window or dialog
   LPSTR          lpstrData            //* link data
){                                     //* LOCAL:
   LPSTR          lpReturn = NULL;     //* return string
   LPSTR          lpstrFile = NULL;    //* non-qualified file name
   LPSTR          lpstrPath = NULL;    //* pathname
   LPSTR          lpstrTemp = NULL;    //* work string
   CHAR           szDocFile[CBPATHMAX];//* document name
   CHAR           szDocPath[CBPATHMAX];//* document path name
   CHAR           szServerFilter[CBPATHMAX];
   CHAR           szCaption[CBMESSAGEMAX];

                                       //* Figure out the link's path
                                       //* name and file name
   lpstrTemp = lpstrData;
   while (*lpstrTemp++);
   lpstrPath = lpstrFile = lpstrTemp;

   while (*(lpstrTemp = AnsiNext(lpstrTemp)))
      if (*lpstrTemp == '\\')
         lpstrFile = lpstrTemp + 1;
                                        //* Copy the document name
   lstrcpy(szDocFile, lpstrFile);
   *(lpstrFile - 1) = 0;
                                          //* Copy the path name
   lstrcpy(szDocPath, ((lpstrPath != lpstrFile) ? lpstrPath : ""));
   if (lpstrPath != lpstrFile)           //* Restore the backslash
      *(lpstrFile - 1) = '\\';
   while (*lpstrFile != '.' && *lpstrFile)//* Get the extension
   lpstrFile++;
                                          //* Make a filter that respects
                                          //* the link's class name
   OFN.hwndOwner       = hwnd;
   OFN.nFilterIndex    = RegMakeFilterSpec(lpstrData, lpstrFile, szServerFilter);
   OFN.lpstrDefExt     = NULL;
   OFN.lpstrFile       = (LPSTR)szDocFile;
   OFN.lpstrFilter     = (LPSTR)szServerFilter;
   OFN.lpstrInitialDir = (LPSTR)szDocPath;
   LoadString(hInst, IDS_CHANGELINK, szCaption, CBMESSAGEMAX);
   OFN.lpstrTitle     = (LPSTR)szCaption;
   OFN.lpstrCustomFilter = NULL;
   OFN.Flags          = OFN_HIDEREADONLY | OFN_FILEMUSTEXIST;

                                           //* If we get a file... */
   if (GetOpenFileName((LPOPENFILENAME)&OFN))
   {
      if (!(lpReturn = GlobalLock(GlobalAlloc(LHND, CBPATHMAX))))
         goto Error;

      AddExtension(&OFN);
      lstrcpy(lpReturn, szDocFile);

      OFN.lpstrInitialDir = (LPSTR)szLastDir;
   }

   return lpReturn;                    //* SUCCESS return

Error:                                 //* ERROR Tag

   return NULL;                        //* ERROR return

}

/***************************************************************************
 * Normalize()
 * Removes the path specification from the file name.
 *
 * Note:  It isn't possible to get "<drive>:<filename>" as input because
 *        the path received will always be fully qualified.
 **************************************************************************/

VOID Normalize(                        //* ENTRY:
   LPSTR          lpstrFile            //* file name
){                                     //* LOCAL:
   LPSTR          lpstrBackslash = NULL;//* back slash
   LPSTR          lpstrTemp = lpstrFile;//* file name

   while (*lpstrTemp)
   {
      if (*lpstrTemp == '\\')
         lpstrBackslash = lpstrTemp;

      lpstrTemp = AnsiNext(lpstrTemp);
   }
   if (lpstrBackslash)
      lstrcpy(lpstrFile, lpstrBackslash + 1);

}

/***************************************************************************
 * AddExtension()
 *
 * Adds the extension corresponding to the filter dropdown.
 **************************************************************************/

VOID AddExtension(                     //* ENTRY:
   LPOPENFILENAME lpOFN                //* open file structure
){

   if (lpOFN->nFileExtension == (WORD)lstrlen(lpOFN->lpstrFile)
         && lpOFN->nFilterIndex)
   {
      LPSTR   lpstrFilter = (LPSTR)lpOFN->lpstrFilter;

      while (*lpstrFilter && --lpOFN->nFilterIndex)
      {
         while (*lpstrFilter++) ;
         while (*lpstrFilter++) ;
      }
                                       //* If we got to the filter,
      if (*lpstrFilter)                //* retrieve the extension
      {
         while (*lpstrFilter++) ;
         lpstrFilter++;
                                       //* Copy the extension
         if (lpstrFilter[1] != '*')
            lstrcat(lpOFN->lpstrFile, lpstrFilter);
      }
   }

}
/****************************************************************************
 *  fnInsertNew()
 *
 *  Dialog procedure for the Insert New dialog.
 *
 *  Returns int - TRUE if message processed, FALSE otherwise
 ***************************************************************************/

BOOL  APIENTRY fnInsertNew(            //* ENTRY:
   HWND           hDlg,                //* standard dialog box paramters
   UINT           msg,
   WPARAM         wParam,
   LPARAM         lParam               //* (LPSTR) class name
){                                     //* LOCAL:
   HWND           hwndList;            //* handle to listbox
   static LPSTR   lpClassName;         //* classname for return value

   hwndList = GetDlgItem(hDlg, IDD_LISTBOX);

   switch (msg)
   {
      case WM_INITDIALOG:
         if (!RegGetClassNames(hwndList))
            EndDialog(hDlg, IDCANCEL);

         lpClassName = (LPSTR)lParam;
         SetFocus(hwndList);
         SendMessage(hwndList, LB_SETCURSEL, 0, 0L);
         return (FALSE);

      case WM_COMMAND:
      {
         WORD wID  = LOWORD(wParam);
         WORD wCmd = HIWORD(wParam);

         switch (wID)
         {
            case IDD_LISTBOX:
               if (wCmd != LBN_DBLCLK)
               break;

            case IDOK:
               if (!RegCopyClassName(hwndList, lpClassName))
                  wParam = IDCANCEL;

            case IDCANCEL:
               EndDialog(hDlg, wParam);
               break;
         }
         break;
      }
   }
   return FALSE;

}

/***************************************************************************
 * LinkProperties();
 *
 * Manage the link properties dialog box.
 **************************************************************************/

VOID FAR LinkProperties()
{                                      //* LOCAL

   DialogBox (
      hInst,
      MAKEINTRESOURCE(DTPROP),
      hwndFrame,
      (DLGPROC)fnProperties
   );

}

/***************************************************************************
 * fnProperties()
 *
 * Dialog procedure for link properties. The Links dialog allows the user to
 * change the link options, edit/play the object, cancel the link as
 * well change links.
 *
 * returns BOOL - TRUE if processed, FALSE otherwise
 **************************************************************************/

BOOL  APIENTRY fnProperties(           //* ENTRY:
   HWND           hDlg,                //* standard dialog box parameters
   UINT           msg,
   WPARAM         wParam,
   LPARAM         lParam               //* (HWND) child window with focus
){                                     //* LOCAL:
  static APPITEMPTR *pLinks;           //* pointer to links (associated windows)
  static INT      nLinks;              //* number of links
  static HWND     hwndList;            //* handle to listbox window
  static BOOL     fTry;

   switch (msg)
   {
      case WM_INITDIALOG:
         hwndProp = hDlg;
         hwndList = GetDlgItem(hDlg, IDD_LINKNAME);
         if (!(InitLinkDlg(hDlg, &nLinks, hwndList, &pLinks)))
            EndDialog(hDlg, TRUE);
         UpdateLinkButtons(hDlg,nLinks,hwndList,pLinks);
         break;

      case WM_COMMAND:
      {
         WORD wID = LOWORD(wParam);

         switch (wID)
         {
           case IDD_CHANGE:            //* change links
               BLOCK_BUSY(fTry);
               if (ChangeLinks(hDlg,nLinks,hwndList,pLinks))
                  DisplayUpdate(nLinks,hwndList,pLinks, FALSE);
               return TRUE;

           case IDD_FREEZE:            //* cancel links
               BLOCK_BUSY(fTry);
               CancelLinks(hDlg,nLinks,hwndList,pLinks);
               UpdateLinkButtons(hDlg,nLinks,hwndList,pLinks);
               return TRUE;

           case IDD_UPDATE:            //* update links
               BLOCK_BUSY(fTry);
               DisplayUpdate(nLinks,hwndList,pLinks,TRUE);
               UpdateLinkButtons(hDlg,nLinks,hwndList,pLinks);
               return TRUE;

            case IDD_AUTO:
            case IDD_MANUAL:           //* change link update options
               BLOCK_BUSY(fTry);
               if (!SendMessage(GetDlgItem(hDlg,wParam),BM_GETCHECK, 0, 0L))
               {
                  CheckRadioButton(hDlg, IDD_AUTO ,IDD_MANUAL ,wParam);
                  ChangeUpdateOptions(hDlg,nLinks,hwndList,pLinks,
                     (wParam == IDD_AUTO ? oleupdate_always : oleupdate_oncall));
                  UpdateLinkButtons(hDlg,nLinks,hwndList,pLinks);
               }
               return TRUE;

           case IDD_LINKNAME:
               if (HIWORD(wParam) == LBN_SELCHANGE)
                  UpdateLinkButtons(hDlg,nLinks,hwndList,pLinks);
               return TRUE;

            case IDCANCEL:
               BLOCK_BUSY(fTry);
               UndoObjects();
               END_PROP_DLG(hDlg,pLinks);
               return TRUE;

            case IDOK:
               BLOCK_BUSY(fTry);
               DelUndoObjects(FALSE);
               END_PROP_DLG(hDlg,pLinks);
               return TRUE;
         }
      }
   }
   return FALSE;
}


/****************************************************************************
 * InitLinkDlg();
 *
 * Initialize the list box of links.
 ***************************************************************************/

static BOOL InitLinkDlg (              //* ENTRY:
   HWND           hDlg,                //* dialog box handle
   INT            *nLinks,             //* pointer to number of links
   HWND           hwndList,            //* listbox handle
   APPITEMPTR     **pLinks             //* list of window handles of links
){                                     //* LOCAL
   APPITEMPTR     pItem;               //* application item pointer
   LPSTR          lpstrData = NULL;    //* pointer to link data
   CHAR           szFull[CBMESSAGEMAX * 4];//* list box entry string
   CHAR           pLinkData[OBJECT_LINK_MAX];//* holder of link data
   BOOL           fSelect = FALSE;     //* item selected flag
   HANDLE         hWork;               //* working memory handle
   APPITEMPTR     pTop;                //* pointer to the top object

   if (!(*pLinks = (APPITEMPTR *)LocalLock(LocalAlloc(LHND,sizeof(APPITEMPTR)*10))))
   {
      ErrorMessage(E_FAILED_TO_ALLOC);
      return 0;
   }
   *nLinks = 0;
                                       //* set tabs
   SendMessage(hwndList,WM_SETREDRAW,FALSE,0L);
                                       //* enumerate child windows
   for (pTop = pItem = GetTopItem(); pItem; pItem = GetNextItem(pItem))
   {
      if (pItem->otObject == OT_LINK && pItem->fVisible)
      {
         *(*pLinks + *nLinks) = pItem;
         if (!((*nLinks += 1)%10))
         {                             //* add blocks of ten
            hWork = LocalHandle((LPSTR)(*pLinks));
            LocalUnlock(hWork);
            if (!(hWork = LocalReAlloc(hWork,(*nLinks+10)*sizeof(APPITEMPTR),0)))
            {
               ErrorMessage(E_FAILED_TO_ALLOC);
               return FALSE;           //* ERROR return
            }
            *pLinks = (APPITEMPTR *)LocalLock(hWork);
         }

         if (pTop == pItem)
            fSelect = TRUE;

         if (!ObjGetData(pItem, pLinkData))
            continue;
                                       //* make listbox entry
         MakeListBoxString(pLinkData, szFull, pItem->uoObject);
                                       //* add listbox entry
         SendMessage(hwndList, LB_ADDSTRING, 0, (LONG)(LPSTR)szFull);
      }
   }

   if (fSelect)
      SendMessage(hwndList, LB_SETSEL, 1, 0L);

   SendMessage(hwndList,WM_SETREDRAW,TRUE,0L);
   UpdateWindow(hwndList);

   return TRUE;                        //* SUCCESS return

}

/****************************************************************************
 * MakeListBoxString()
 *
 * build an listbox entry string
 ***************************************************************************/

static VOID MakeListBoxString(         //* ENTRY:
   LPSTR          lpLinkData,          //* pointer to link data
   LPSTR          lpBoxData,           //* return string
   OLEOPT_UPDATE  oleopt_update        //* OLE update option
){                                     //* LOCAL:
   CHAR           szType[CBMESSAGEMAX];//* holds update option string
   LPSTR          lpTemp;              //* working string pointer
   INT            i;                   //* index

                                       //* get classname
   RegGetClassId(lpBoxData, lpLinkData);
   lstrcat(lpBoxData, " - ");           //* ads tab

   while (*lpLinkData++);              //* skip to document name

   lpTemp = lpLinkData;
   while (*lpTemp)                     //* copy document name;
   {                                   //* strip drive an directory
      if (*lpTemp == '\\' || *lpTemp == ':')
         lpLinkData = lpTemp + 1;
      lpTemp = AnsiNext(lpTemp);
   }
   lstrcat(lpBoxData, lpLinkData);
   lstrcat(lpBoxData, " - ");

   while (*lpLinkData++);              //* copy item data
   lstrcat(lpBoxData, lpLinkData);
   lstrcat(lpBoxData, " - ");
                                       //* add update option string
   switch (oleopt_update)
   {
      case oleupdate_always: i = SZAUTO; break;
      case oleupdate_oncall: i = SZMANUAL; break;
      default: i = SZFROZEN;
   }
   LoadString(hInst, i, szType, CBMESSAGEMAX);
   lstrcat(lpBoxData, szType);

}                                      //* SUCCESS return

/***************************************************************************
 * UpdateLinkButtons()
 *
 * Keep link buttons active as appropriate.  This routine is called after
 * a selection is made so the buttons reflect the selected items.
 **************************************************************************/

static VOID UpdateLinkButtons(         //* ENTRY:
   HWND           hDlg,                //* dialog box handle
   INT            nLinks,              //* number of links
   HWND           hwndList,            //* listbox handle
   APPITEMPTR     *pLinks              //* pointer to link's window handles
){                                     //* LOCAL:
   ATOM           aCurName=0;          //* atom of current doc
   BOOL           fChangeLink = TRUE;  //* enable/disable changelink button
   INT            iAuto,iManual,i;     //* count of manual and auto links
   APPITEMPTR     pItem;               //* application item pointer
   INT            iStatic;

   iStatic = iAuto = iManual = 0;

   for (i = 0; i < nLinks; i++)        //* enum selected links
   {
      if (SendMessage(hwndList, LB_GETSEL, i, 0L))
      {
         pItem = *(pLinks+i);
         if (pItem->otObject == OT_STATIC)
            iStatic++;
         else
         {
            switch(pItem->uoObject)
            {                          //* count number of manual and
               case oleupdate_always:  //* automatic links selected
                  iAuto++;
                  break;
               case oleupdate_oncall:
                  iManual++;
                  break;
            }
                                       //* check if all selected links are
            if (!aCurName)             //* linked to same file
               aCurName = pItem->aLinkName;
            else if (aCurName != pItem->aLinkName)
               fChangeLink = FALSE;
         }
      }
   }

   if (!(iAuto || iManual || iStatic)  //* if no links disable all buttons
      || (!iAuto && !iManual && iStatic))
   {
      EnableWindow(GetDlgItem(hDlg, IDD_FREEZE), FALSE );
      EnableWindow(GetDlgItem(hDlg, IDD_CHANGE), FALSE );
      EnableWindow(GetDlgItem(hDlg, IDD_UPDATE), FALSE );
      CheckDlgButton(hDlg, IDD_AUTO, FALSE);
      EnableWindow(GetDlgItem(hDlg, IDD_AUTO),FALSE);
      CheckDlgButton(hDlg, IDD_MANUAL, FALSE);
      EnableWindow(GetDlgItem(hDlg, IDD_MANUAL),FALSE);
   }
   else
   {
      EnableWindow(GetDlgItem(hDlg, IDD_UPDATE), TRUE );
      EnableWindow(GetDlgItem(hDlg, IDD_FREEZE), TRUE );

      if (iAuto && iManual || !(iAuto || iManual))
      {                                //* Set update buttons
         CheckDlgButton(hDlg, IDD_AUTO, FALSE);
         EnableWindow(GetDlgItem(hDlg, IDD_AUTO),FALSE);
         CheckDlgButton(hDlg, IDD_MANUAL, FALSE);
         EnableWindow(GetDlgItem(hDlg, IDD_MANUAL),FALSE);
      }
      else
      {
         EnableWindow(GetDlgItem(hDlg, IDD_MANUAL), TRUE);
         EnableWindow(GetDlgItem(hDlg, IDD_AUTO), TRUE);
         if (iAuto)
         {
            CheckDlgButton(hDlg, IDD_AUTO, TRUE);
            CheckDlgButton(hDlg, IDD_MANUAL, FALSE);
         }
         else
         {
            CheckDlgButton(hDlg, IDD_AUTO, FALSE);
            CheckDlgButton(hDlg, IDD_MANUAL, TRUE);
         }
      }
   }

   EnableWindow(GetDlgItem(hDlg, IDD_CHANGE),fChangeLink && aCurName);

}

/****************************************************************************
 * ChangeLinks()
 *
 * This routine changes the linked data if the user chooses a new file to
 * replace the old document data portion of the linked date.  The routine
 * does nothing if the user cancels.
 *
 * returns TRUE - if data changed FALSE if user cancel or err.
 ***************************************************************************/

static BOOL ChangeLinks(               //* ENTRY:
   HWND           hDlg,                //* dialog handle
   INT            nLinks,              //* number of links in listbox
   HWND           hwndList,            //* listbox
   APPITEMPTR     *pLinks              //* list of application link handles
){                                     //* LOCAL
   INT            i;                   //* general index
   HANDLE         hWork;               //* work
   APPITEMPTR     pItem;               //* application item
   LPSTR          lpNewDoc = NULL;     //* new document
   ATOM           aOldDoc;             //* atom of old doc. name
   ATOM           aCurDoc = 0;      //* atom of change-to doc. name
   BOOL           fMessage = FALSE;    //* error message flag
   LPSTR          lpLinkData;          //* pointer to link data

   lpLinkData = NULL;
                                       //* This loop finds all selected links
   for (i = 0; i < nLinks; i++)        //* and updates them
   {
      if (SendMessage(hwndList, LB_GETSEL, i, 0L))
      {
         pItem = *(pLinks+i);
         CHECK_IF_STATIC(pItem);

         pItem->lpLinkData = lpLinkData;
         if (!ObjGetData(pItem,NULL))
            continue;

         if (!lpNewDoc)
         {
            if (!(lpNewDoc = OfnGetNewLinkName(hDlg, pItem->lpLinkData)))
              return FALSE;            //* ERROR jump
            aOldDoc = pItem->aLinkName;
            aCurDoc = AddAtom(lpNewDoc);
            SendMessage(hwndList,WM_SETREDRAW,FALSE,0L);
         }

         ObjSaveUndo(pItem);
         ObjChangeLinkData(pItem,lpNewDoc);
         pItem->aLinkName = aCurDoc;
         lpLinkData = pItem->lpLinkData;

         CHANGE_LISTBOX_STRING(hwndList, i, pItem, pItem->lpLinkData);

         pItem->lpLinkData = NULL;
      }
   }

   /*************************************************************************
   * now deal with non-selected links and look for a match...
   *************************************************************************/

                                       //* this loop finds non-selected links
   for (i = 0; i < nLinks; i++)        //* and asks the user to update these?
   {
      if (!SendMessage(hwndList, LB_GETSEL, i, 0L))
      {
         pItem = *(pLinks+i);
         if (pItem->otObject == OT_STATIC)
            continue;

         if (!ObjGetData(pItem,NULL))
            continue;

         if (pItem->aLinkName == aOldDoc)
         {
            if (!fMessage)
            {
               CHAR szMessage[2*CBMESSAGEMAX+3*CBPATHMAX];
               CHAR szRename[2*CBMESSAGEMAX];
               CHAR szOldDoc[CBMESSAGEMAX];
               LPSTR pOldDoc;

               GetAtomName(aOldDoc,szOldDoc,CBMESSAGEMAX);
               pOldDoc =(LPSTR)UnqualifyPath(szOldDoc);
               LoadString(hInst, IDS_RENAME, szRename, 2*CBMESSAGEMAX);
               wsprintf(
                     szMessage,
                     szRename,
                     pOldDoc,
                     (LPSTR)UnqualifyPath(szFileName),
                     pOldDoc
               );

               if (MessageBox(hDlg, szMessage,
                  szAppName, MB_YESNO | MB_ICONEXCLAMATION) == IDNO)
                  break;
               fMessage = TRUE;
            }

            ObjSaveUndo(pItem);
            ObjChangeLinkData(pItem,lpNewDoc);
            CHANGE_LISTBOX_STRING(hwndList, i, pItem, pItem->lpLinkData);

            pItem->aLinkName = aCurDoc;
         }
      }
   }

   if(lpNewDoc)
   {
      hWork = GlobalHandle(lpNewDoc);
      GlobalUnlock(hWork);
      GlobalFree(hWork);
   }

#if 0
// This is bogus -- this memory is owned by OLECLI32.DLL, not this app,
// so it should not be freed here.
   if (lpLinkData)
      FreeLinkData(lpLinkData);
#endif

   SendMessage(hwndList,WM_SETREDRAW,TRUE,0L);
   InvalidateRect(hwndList,NULL,TRUE);
   UpdateWindow(hwndList);

   WaitForAllObjects();

   if (aCurDoc)
      DeleteAtom(aCurDoc);

   return(TRUE);
}

/****************************************************************************
 * DisplayUpdate()
 *
 * Get the most up to date rendering information and show it.
 ***************************************************************************/

static VOID DisplayUpdate(             //* ENTRY:
   INT            nLinks,              //* number of links in listbox
   HWND           hwndList,            //* listbox
   APPITEMPTR     *pLinks,             //* list of application link handles
   BOOL           fSaveUndo            //* save undo objects
){                                     //* LOCAL:
   INT            i;                   //* index
   APPITEMPTR     pItem;               //* temporary item pointer


   for (i = 0; i < nLinks; i++)
      if (SendMessage(hwndList, LB_GETSEL, i, 0L))
      {
         pItem = *(pLinks+i);
         CHECK_IF_STATIC(pItem);
         if (fSaveUndo)
            ObjSaveUndo(pItem);
         Error(OleUpdate(pItem->lpObject));
      }

   WaitForAllObjects();

}

/****************************************************************************
 * UndoObjects()
 *
 * Bring objects back to their original state.
 ***************************************************************************/

static VOID UndoObjects()
{
   APPITEMPTR     pItem;               //* application item pointer
                                       //* enum objects
   for (pItem = GetTopItem(); pItem; pItem = GetNextItem(pItem))
      if (pItem->lpObjectUndo)
         ObjUndo(pItem);

   WaitForAllObjects();

}


/****************************************************************************
 * DelUndoObjects()
 *
 * remove all objects created for undo operation.
 ***************************************************************************/

static VOID DelUndoObjects(            //* ENTRY:
   BOOL           fPrompt              //* prompt user?
){                                     //* LOCAL:
   APPITEMPTR     pItem;               //* application item pointer
   BOOL           fPrompted = FALSE;   //* prompted user?

   for (pItem = GetTopItem(); pItem; pItem = GetNextItem(pItem))
   {
      if (pItem->lpObjectUndo)
      {
         if (fPrompt && !fPrompted)    //* prompt user in activation case
         {
            CHAR szPrompt[CBMESSAGEMAX];

            LoadString(hInst, IDS_SAVE_CHANGES, szPrompt, CBMESSAGEMAX);

            if (MessageBox(hwndFrame, szPrompt,
                  szAppName, MB_YESNO | MB_ICONEXCLAMATION) == IDNO)
            {
               UndoObjects();
               return;                 //* user canceled operation
            }
            fPrompted = TRUE;
         }
        ObjDelUndo(pItem);             //* delete udo object
      }
   }

   WaitForAllObjects();

}                                      //* SUCCESS return

/****************************************************************************
 * CancelLinks()
 ***************************************************************************/

static VOID CancelLinks(               //* ENTRY:
   HWND           hDlg,                //* calling dialog
   INT            nLinks,              //* number of links in listbox
   HWND           hwndList,            //* listbox
   APPITEMPTR     *pLinks              //* list of application link handles
){                                     //* LOCAL:
   APPITEMPTR     pItem;               //* application item pointer
   INT            i;                   //* index
   CHAR           pLinkData[OBJECT_LINK_MAX];//* holder of link data

   SendMessage(hwndList,WM_SETREDRAW,FALSE,0L);
   for (i = 0; i < nLinks; i++)
      if (SendMessage(hwndList, LB_GETSEL, i, 0L))
      {
         pItem = *(pLinks+i);
         CHECK_IF_STATIC(pItem);
         ObjGetData(pItem,pLinkData);
         ObjSaveUndo(pItem);
         ObjFreeze(pItem);

         CHANGE_LISTBOX_STRING(hwndList, i, pItem, pLinkData);
      }

   SendMessage(hwndList,WM_SETREDRAW,TRUE,0L);
   InvalidateRect(hwndList,NULL,TRUE);
   UpdateWindow(hwndList);

}


/****************************************************************************
 * ChangeUpdateOptions()
 *
 * Change the update options for all selected objects.
 ***************************************************************************/

static VOID ChangeUpdateOptions(       //* ENTRY:
   HWND           hDlg,                //* calling dialog
   INT            nLinks,              //* number of links in listbox
   HWND           hwndList,            //* listbox
   APPITEMPTR     *pLinks,             //* list of application link handles
   OLEOPT_UPDATE  lUpdate              //* update option
){                                     //* LOCAL:
   APPITEMPTR     pItem;               //* application item
   INT            i;                   //* index
   CHAR           pLinkData[OBJECT_LINK_MAX];

   SendMessage(hwndList,WM_SETREDRAW,FALSE,0L);

   for (i = 0; i < nLinks; i++)        //* enum selected objects
   {
      if (SendMessage(hwndList, LB_GETSEL, i, 0L))
      {
         pItem = *(pLinks+i);
         CHECK_IF_STATIC(pItem);
         ObjGetData(pItem,pLinkData);
         ObjSaveUndo(pItem);
         if (Error(OleSetLinkUpdateOptions(pItem->lpObject,lUpdate)))
            continue;
         pItem->uoObject = lUpdate;

         CHANGE_LISTBOX_STRING(hwndList, i, pItem, pLinkData);
      }
   }

   SendMessage(hwndList,WM_SETREDRAW,TRUE,0L);
   InvalidateRect(hwndList,NULL,TRUE);
   UpdateWindow(hwndList);
   WaitForAllObjects();

}
/****************************************************************************
 * InvalidLink()
 *
 * Deal with letting the user know that the program has inadvertently come
 * across an invalid link.
 *
 * Global fPropBoxActive - flag to determine whether or not the link dialog
 *                         box is active.  If it is not active we give the
 *                         user an opportunity to enter the links property
 *                         dialog directly from here.
 ***************************************************************************/

VOID FAR InvalidLink()
{

   if (!hwndProp)
      DialogBox(hInst, "InvalidLink", hwndFrame, (DLGPROC)fnInvalidLink);
   else
      ErrorMessage(E_FAILED_TO_CONNECT);

}

/****************************************************************************
 *  fnABout()
 *
 *  About box dialog box procedure.
 ***************************************************************************/

BOOL  APIENTRY fnInvalidLink(        //* ENTRY:
   HWND           hDlg,              //* standard windows dialog box
   UINT           message,
   WPARAM         wParam,
   LPARAM         lParam
){

   switch (message)
   {
      case WM_INITDIALOG:
         return (TRUE);

      case WM_COMMAND:
         if (LOWORD(wParam) == IDD_CHANGE)
            LinkProperties();
         EndDialog(hDlg, TRUE);
         return (TRUE);
    }
    return (FALSE);

}

/****************************************************************************
 *  AboutBox()
 *
 *  Show the About Box dialog.
 ***************************************************************************/

VOID FAR AboutBox()
{

   DialogBox(hInst, "AboutBox", hwndFrame, (DLGPROC)fnAbout);

}

/****************************************************************************
 *  fnABout()
 *
 *  About box dialog box procedure.
 ***************************************************************************/

BOOL  APIENTRY fnAbout(               //* ENTRY:
   HWND         hDlg,                 //* standard windows dialog box
   UINT         message,
   WPARAM       wParam,
   LPARAM       lParam
){

   switch (message)
   {
      case WM_INITDIALOG:
         return (TRUE);

      case WM_COMMAND:
      {
         WORD wID = LOWORD(wParam);

         if (wID == IDOK || wID == IDCANCEL)
         {
            EndDialog(hDlg, TRUE);
            return (TRUE);
         }
         break;
      }
    }
    return (FALSE);

}



/***************************************************************************
 * RetryMessage()
 *
 * give the user the chance to abort when a server is in retry case.
 *
 * Returns BOOL - TRUE if user chooses to cancel
 **************************************************************************/

VOID FAR RetryMessage (                //* ENTRY:
   APPITEMPTR     paItem,              //* application item pointer
   LONG lParam
){
   RETRYPTR    pRetry;
   LONG        objectType;
   HANDLE      hData;
   static CHAR szServerName[KEYNAMESIZE];
   HWND        hwnd;                   //* window handle

   if (IsWindow(hwndProp))
      hwnd = hwndProp;
   else if (IsWindow(hwndFrame))
      hwnd = hwndFrame;
   else
      return;                          //* should not happen
                                       //* get the busy servers name
   lstrcpy(szServerName, "server application");

   if (paItem)
   {
      if (!paItem->aServer)
      {
         OleQueryType(paItem->lpObject, &objectType );
         if (OLE_OK == OleGetData(paItem->lpObject, (OLECLIPFORMAT) (objectType == OT_LINK ? vcfLink : vcfOwnerLink), &hData ))
         {
            RegGetClassId(szServerName, GlobalLock(hData));
            paItem->aServer = AddAtom(szServerName);
            GlobalUnlock( hData );
         }
      }
      else
         GetAtomName(paItem->aServer,szServerName,KEYNAMESIZE);

   }

   hData = LocalAlloc(LHND,sizeof(RETRYSTRUCT));
   if(!(pRetry = (RETRYPTR)LocalLock(hData)))
     return;

   pRetry->lpserver = (LPSTR)szServerName;
   pRetry->bCancel  = (BOOL)(lParam & RD_CANCEL);
   pRetry->paItem   = paItem;

   DialogBoxParam(hInst, "RetryBox", hwnd, (DLGPROC)fnRetry, (LONG)pRetry );

   LocalUnlock(hData);
   LocalFree(hData);

   hRetry = NULL;

}

/****************************************************************************
 *  fnRetry()
 *
 * Retry message box nothing to tricky; however, when a server becomes
 * unbusy a message is posted to automatically get rid of this dialog.
 * I send a no.
 ***************************************************************************/

BOOL  APIENTRY fnRetry(               //* ENTRY
   HWND   hDlg,                       //* standard dialog entry
   UINT   message,
   WPARAM wParam,
   LPARAM lParam
){
   static RETRYPTR   pRetry;

   switch (message)
   {
      case WM_COMMAND:
      {
         WORD wID = LOWORD(wParam);

         switch (wParam)
         {
               case IDD_SWITCH:
                  DefWindowProc( hDlg, WM_SYSCOMMAND, SC_TASKLIST, 0);
                  break;

               case IDCANCEL:
                  if (pRetry->paItem)
                     pRetry->paItem->fRetry = FALSE;
                  EndDialog(hDlg, TRUE);
                  return TRUE;

               default:
                   break;
         }
         break;
      }

      case WM_INITDIALOG:
      {
          CHAR       szBuffer[CBMESSAGEMAX];
          CHAR       szText[2*CBMESSAGEMAX];

          pRetry = (RETRYPTR)lParam;
          hRetry = hDlg;

          LoadString(hInst, IDS_RETRY_TEXT1, szBuffer, CBMESSAGEMAX);
          wsprintf(szText, szBuffer, pRetry->lpserver);
          SetWindowText (GetDlgItem(hDlg, IDD_RETRY_TEXT1), szText);

          LoadString(hInst, IDS_RETRY_TEXT2, szBuffer, CBMESSAGEMAX);
          wsprintf(szText, szBuffer, pRetry->lpserver);
          SetWindowText (GetDlgItem(hDlg, IDD_RETRY_TEXT2), szText);

          EnableWindow (GetDlgItem(hDlg, IDCANCEL), pRetry->bCancel);

          return TRUE;
      }

      default:
           break;
   }

   return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\ole1\clidemo\clidemo.h ===
/*
 * clidemo.h 
 *
 * Created by Microsoft Corporation.
 * (c) Copyright Microsoft Corp. 1990 - 1992  All Rights Reserved
 */

//*** CONSTANTS ***

#define CXDEFAULT       400     //* Default object size:  400 x 300 
#define CYDEFAULT       300
#define COBJECTSMAX     50      //* max number of objects in our app 

//*** PROTOTYPES ***

//*** Exported window procedures 

LONG  APIENTRY  FrameWndProc(HWND, UINT, DWORD, LONG);

//*** FAR 

VOID FAR             FixObjectBounds(LPRECT lprc);

//*** Local

static LPOLECLIENT   InitClient(HANDLE);
static VOID          EndClient(LPOLECLIENT);
static LPAPPSTREAM   InitStream(HANDLE);
static VOID          EndStream(LPAPPSTREAM);
static VOID          ProcessCmdLine(LPSTR);
static BOOL          InitApplication(HANDLE); 
static BOOL          InitInstance(HANDLE);
static VOID          SetTitle(PSTR);
static VOID          MyOpenFile(PSTR,LHCLIENTDOC *, LPOLECLIENT, LPAPPSTREAM);
static VOID          NewFile(PSTR,LHCLIENTDOC *, LPAPPSTREAM); 
static BOOL          SaveFile(PSTR, LHCLIENTDOC, LPAPPSTREAM);
static VOID          SaveasFile(PSTR, LHCLIENTDOC, LPAPPSTREAM);
static BOOL          LoadFile(PSTR, LHCLIENTDOC, LPOLECLIENT, LPAPPSTREAM); 
static VOID          ClearAll(LHCLIENTDOC, BOOL);
static VOID          EndInstance(VOID);
static BOOL          SaveAsNeeded(PSTR,LHCLIENTDOC,LPAPPSTREAM);
static VOID          UpdateMenu(HMENU);
static BOOL          RegDoc(PSTR, LHCLIENTDOC *);
static VOID          DeregDoc(LHCLIENTDOC);
static BOOL          InitAsOleClient(HANDLE, HWND, PSTR, LHCLIENTDOC *, LPOLECLIENT *,  LPAPPSTREAM *);
VOID FAR             ClearItem(APPITEMPTR);
static LONG          QueryEndSession(PSTR, LHCLIENTDOC, LPAPPSTREAM);

//*** MACROS *** 

/*
 * ANY_OBJECT_BUSY
 * checks to see if any object in the document is busy. This prevents 
 * a new document from being saved to file if there are objects in 
 * asynchronous states.
 */

#define ANY_OBJECT_BUSY  {\
    if (ObjectsBusy()) \
         break; \
}
   

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\ole1\clidemo\demorc.h ===
/*
 * demorc.h - Header file for OLE demo's resource file.
 *
 * Created by Microsoft Corporation.
 * (c) Copyright Microsoft Corp. 1990 - 1992  All Rights Reserved
 */

/* Application resource ID */

#define ID_APPLICATION 1

#define POS_FILEMENU    0
/* File menu */
#define IDM_NEW         0x100
#define IDM_OPEN        0x101
#define IDM_SAVE        0x102
#define IDM_SAVEAS      0x103
#define IDM_EXIT        0x104
#define IDM_ABOUT       0x105

#define POS_EDITMENU    1
/* Edit menu */
#define IDM_CUT         0x200
#define IDM_COPY        0x201
#define IDM_PASTE       0x202
#define IDM_PASTELINK   0x203
#define IDM_CLEAR       0x204
#define IDM_CLEARALL    0x205
#define IDM_LINKS       0x206

/* Object popup menu */
#define POS_OBJECT	   9	// position of Object item in Edit menu
#define IDM_OBJECT      0x210
#define IDM_VERBMIN     0x211
#define IDM_VERBMAX     0x220	// Put this up to 220 (15 verbs) !!!
#define CVERBSMAX       (IDM_VERBMAX - IDM_VERBMIN + 1)

#define POS_OBJECTMENU  2
#define IDM_INSERT	   0x300
#define IDM_INSERTFILE  0x301

#define IDM_UNDO        0x400	/* Only used internally */
#define IDM_LOAD	      0x401
#define IDM_UPDATE      0x402


/* Dialog box ids */
#define DTPROP          1
#define DTINVALIDLINK   2
#define DTCREATE        3

#define IDD_LINKNAME    0x200
#define IDD_AUTO	      0x201	// Auto update
#define IDD_MANUAL	   0x202	// Manual update
#define IDD_EDIT	      0x203	// Edit Object button
#define IDD_FREEZE	   0x204	// Cancel Link button
#define IDD_UPDATE	   0x205	// Update Now Button
#define IDD_CHANGE	   0x206	// Change Links Button
#define IDD_LINKDONE	   0x207	// ???
#define IDD_PLAY	      0x208	// Activate Button
#define IDD_LISTBOX	   0x209	// List of Links List Box
#define IDD_DESTROY     0x20A

#define IDD_YES         0x210
#define IDD_NO          0x211	
#define IDD_RETRY       0x212	
#define IDD_SWITCH      0x213
#define IDD_RETRY_TEXT1 0x214
#define IDD_RETRY_TEXT2 0x215

/* String table constants */
#define CBMESSAGEMAX       80
#define IDS_APPNAME        0x100
#define IDS_UNTITLED       0x101
#define IDS_MAYBESAVE      0x102
#define IDS_OPENFILE	      0x103
#define IDS_SAVEFILE	      0x104
#define IDS_INSERTFILE	   0x105
#define IDS_FILTER	      0x106
#define IDS_EXTENSION	   0x107
#define IDS_CHANGELINK     0x108
#define IDS_ALLFILTER      0x109
#define IDS_EMBEDDED       0x10a
#define IDS_UPDATELINKS    0x10b
#define IDS_RENAME         0x10c
#define IDS_INVALID_LINK   0x10d
#define IDS_SAVE_CHANGES   0x10e
#define IDS_UPDATE_OBJ     0x110
#define IDS_RETRY_TEXT1    0x111
#define IDS_RETRY_TEXT2    0x112

/* Error messages */
#define E_FAILED_TO_OPEN_FILE           0x200
#define E_FAILED_TO_READ_FILE           0x201
#define E_FAILED_TO_SAVE_FILE           0x202
#define E_INVALID_FILENAME              0x203
#define E_CREATE_FROM_TEMPLATE          0x204
#define E_FAILED_TO_WRITE_OBJECT        0x205
#define E_FAILED_TO_READ_OBJECT         0x206
#define E_FAILED_TO_DELETE_OBJECT       0x207
#define E_CLIPBOARD_CUT_FAILED          0x208
#define E_CLIPBOARD_COPY_FAILED         0x209
#define E_GET_FROM_CLIPBOARD_FAILED     0x20a
#define E_FAILED_TO_CREATE_CHILD_WINDOW 0x20b
#define E_FAILED_TO_CREATE_OBJECT	    0x20c
#define E_OBJECT_BUSY			          0x20d
#define E_UNEXPECTED_RELEASE            0x20e
#define E_FAILED_TO_LAUNCH_SERVER       0x20f
#define E_FAILED_TO_UPDATE              0x210
#define E_FAILED_TO_FREEZE              0x211
#define E_FAILED_TO_UPDATE_LINK         0x212
#define E_SERVER_BUSY                   0x213
#define E_FAILED_TO_RECONNECT_OBJECT    0x214
#define E_FAILED_TO_CONNECT		       0x215
#define E_FAILED_TO_RELEASE_OBJECT      0x216
#define E_FAILED_TO_ALLOC               0x217
#define E_FAILED_TO_LOCK                0x218     
#define E_FAILED_TO_DO_VERB             0x219

#define W_IMPROPER_LINK_OPTIONS         0x300
#define W_STATIC_OBJECT                 0x301
#define W_FAILED_TO_CLONE_UNDO          0x302
#define W_FAILED_TO_NOTIFY              0x303

#define SZAUTO    0x400
#define SZMANUAL  0x401
#define SZFROZEN  0x402

#define E_OLE_ERROR_PROTECT_ONLY          3 
#define E_OLE_ERROR_MEMORY                4
#define E_OLE_ERROR_STREAM                5
#define E_OLE_ERROR_STATIC                6
#define E_OLE_ERROR_BLANK                 7
#define E_OLE_ERROR_DRAW                  8
#define E_OLE_ERROR_METAFILE              9
#define E_OLE_ERROR_ABORT                 10
#define E_OLE_ERROR_CLIPBOARD             11
#define E_OLE_ERROR_FORMAT                12
#define E_OLE_ERROR_OBJECT                13
#define E_OLE_ERROR_OPTION                14
#define E_OLE_ERROR_PROTOCOL              15
#define E_OLE_ERROR_ADDRESS               16
#define E_OLE_ERROR_NOT_EQUAL             17
#define E_OLE_ERROR_HANDLE                18
#define E_OLE_ERROR_GENERIC               19
#define E_OLE_ERROR_CLASS                 20
#define E_OLE_ERROR_SYNTAX                21
#define E_OLE_ERROR_DATATYPE              22
#define E_OLE_ERROR_PALETTE               23
#define E_OLE_ERROR_NOT_LINK              24
#define E_OLE_ERROR_NOT_EMPTY             25
#define E_OLE_ERROR_SIZE                  26
#define E_OLE_ERROR_DRIVE                 27
#define E_OLE_ERROR_NETWORK               28
#define E_OLE_ERROR_NAME                  29
#define E_OLE_ERROR_TEMPLATE              30
#define E_OLE_ERROR_NEW                   31
#define E_OLE_ERROR_EDIT                  32
#define E_OLE_ERROR_OPEN                  33
#define E_OLE_ERROR_NOT_OPEN              34
#define E_OLE_ERROR_LAUNCH                35
#define E_OLE_ERROR_COMM                  36
#define E_OLE_ERROR_TERMINATE             37
#define E_OLE_ERROR_COMMAND               38
#define E_OLE_ERROR_SHOW                  39
#define E_OLE_ERROR_DOVERB                40
#define E_OLE_ERROR_ADVISE_NATIVE         41 
#define E_OLE_ERROR_ADVISE_PICT           42
#define E_OLE_ERROR_ADVISE_RENAME         43
#define E_OLE_ERROR_POKE_NATIVE           44
#define E_OLE_ERROR_REQUEST_NATIVE        45
#define E_OLE_ERROR_REQUEST_PICT          46
#define E_OLE_ERROR_SERVER_BLOCKED        47
#define E_OLE_ERROR_REGISTRATION          48
#define E_OLE_ERROR_ALREADY_REGISTERED    49
#define E_OLE_ERROR_TASK                  50
#define E_OLE_ERROR_OUTOFDATE             51
#define E_OLE_ERROR_CANT_UPDATE_CLIENT    52
#define E_OLE_ERROR_UPDATE                53
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\ole1\clidemo\stream.h ===
/*
 * stream.h - OLE stream I/O headers.
 *
 * Created by Microsoft Corporation.
 * (c) Copyright Microsoft Corp. 1990 - 1992  All Rights Reserved
 */

//*** CONSTANTS ***

#define MAXREAD   ((LONG)  (60L * 1024L))

//*** GLOBALS ***

extern DWORD    vcbObject;

//*** PROTOTYPES ***

//* OLE callbacks

DWORD  APIENTRY ReadStream(LPAPPSTREAM, LPSTR, DWORD);
DWORD  APIENTRY WriteStream(LPAPPSTREAM, LPSTR, DWORD);

//* Far

BOOL FAR          WriteToFile(LPAPPSTREAM);
BOOL FAR          ObjWrite(LPAPPSTREAM, APPITEMPTR);
BOOL FAR          ReadFromFile(LPAPPSTREAM, LHCLIENTDOC, LPOLECLIENT);
BOOL FAR          ObjRead(LPAPPSTREAM, LHCLIENTDOC, LPOLECLIENT);

//* Local

DWORD             lread(int, VOID FAR *, DWORD);
DWORD             lwrite(int, VOID FAR *, DWORD);
static VOID       UpdateLinks(LHCLIENTDOC);
static VOID       UpdateFromOpenServers(VOID);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\ole1\clidemo\register.c ===
/*
 * register.c - Handles the Win 3.1 registration library.
 *
 * Created by Microsoft Corporation.
 * (c) Copyright Microsoft Corp. 1990 - 1992  All Rights Reserved
 */

//*** INCLUDES ***

#include <windows.h>
#include <ole.h>

#include "global.h"
#include "register.h"
#include "clidemo.h"	 
#include "demorc.h"   

/****************************************************************************
 * RegGetClassId() - Retrieves the string name of a class.
 *
 * Retrieve the string name of a class. Classes are guarenteed to be 
 * in ASCII, but should not be used directly as a rule because they
 * might be meaningless if running non-English Windows.
 ***************************************************************************/

VOID FAR RegGetClassId(                //* ENTRY:
   LPSTR    lpstrName,                 //* destination string name of class
   LPSTR    lpstrClass                 //* source name of class
){                                     //* LOCAL:
   DWORD    dwSize = KEYNAMESIZE;      //* size of keyname string 
   CHAR     szName[KEYNAMESIZE];       //* string name for class 

   if (!RegQueryValue(HKEY_CLASSES_ROOT, lpstrClass, (LPSTR)szName, &dwSize))
	   lstrcpy(lpstrName, (LPSTR)szName);
   else
	   lstrcpy(lpstrName, lpstrClass);

}



/***************************************************************************
 *  RegMakeFilterSpec() - Retrieves class-associated default extensions.
 *
 * Get the class-associated default extensions, and build a filter spec, 
 * to be used in the "Change Link" standard dialog box, which contains 
 * all the default extensions which are associated with the given class 
 * name.  Again, the class names are guaranteed to be in ASCII.
 *
 * Returns int - The index idFilterIndex states which filter item 
 *               matches the extension, or 0 if none is found.
 ***************************************************************************/

INT FAR RegMakeFilterSpec(             //* ENTRY:
   LPSTR          lpstrClass,          //* class name
   LPSTR          lpstrExt,            //* file extension
   LPSTR          lpstrFilterSpec      //* destination filter spec
){                                     //* LOCAL:
   DWORD          dwSize;              //* size of reg request
   CHAR           szClass[KEYNAMESIZE];//* class name 
   CHAR           szName[KEYNAMESIZE]; //* name of subkey 
   CHAR           szString[KEYNAMESIZE];//* name of subkey 
   INT            i;                    //* index of subkey query 
   INT            idWhich = 0;          //* index of combo box item 
   INT            idFilterIndex = 0;    //* index to filter matching extension 

   for (i = 0; !RegEnumKey(HKEY_CLASSES_ROOT, i++, szName, KEYNAMESIZE); ) 
   {
      if (  *szName == '.'             //* Default Extension...
            && (dwSize = KEYNAMESIZE)
            && !RegQueryValue(HKEY_CLASSES_ROOT, szName, szClass, &dwSize)
            && (!lpstrClass || !lstrcmpi(lpstrClass, szClass))
            && (dwSize = KEYNAMESIZE)
            && !RegQueryValue(HKEY_CLASSES_ROOT, szClass, szString, &dwSize)) 
      {
         idWhich++;	

         if (lpstrExt && !lstrcmpi(lpstrExt, szName))
            idFilterIndex = idWhich;
                                       //* Copy over "<Class Name String> 
                                       //* (*<Default Extension>)"
                                       //* e.g. "Server Picture (*.PIC)"
         lstrcpy(lpstrFilterSpec, szString);
         lstrcat(lpstrFilterSpec, " (*");
         lstrcat(lpstrFilterSpec, szName);
         lstrcat(lpstrFilterSpec, ")");
         lpstrFilterSpec += lstrlen(lpstrFilterSpec) + 1;
                                       //* Copy over "*<Default Extension>" 
                                       //* (e.g. "*.PIC") */
         lstrcpy(lpstrFilterSpec, "*");
         lstrcat(lpstrFilterSpec, szName);
         lpstrFilterSpec += lstrlen(lpstrFilterSpec) + 1;
      }
   }
   
   *lpstrFilterSpec = 0;

   return idFilterIndex;

}



/***************************************************************************
 *  RegCopyClassName()
 *
 *  Get the class name from the registration data base.  We have the
 *  descriptive name and we search for the class name.
 *
 *  returns BOOL - TRUE if class name was found and retrieved from the
 *                 registration database.
 ***************************************************************************/

BOOL FAR RegCopyClassName(             //* ENTRY:
   HWND           hwndList,            //* HANDLE to list box 
   LPSTR          lpstrClassName       //* destination character string
){                                     //* LOCAL:
   DWORD          dwSize;              //* key name size
   HKEY           hkeyTemp;            //* temp key
   CHAR           szClass[KEYNAMESIZE];//* class name string
   CHAR           szKey[KEYNAMESIZE];  //* key name string
   INT            i;                   //* index

   szClass[0] = '\0';

   if (!RegOpenKey(HKEY_CLASSES_ROOT, szClass, &hkeyTemp)) 
   {
      i = (INT)SendMessage(hwndList, LB_GETCURSEL, 0, 0L);
      SendMessage(hwndList, LB_GETTEXT, i, (DWORD)(LPSTR)szKey);

      for (i = 0; !RegEnumKey(HKEY_CLASSES_ROOT, i++, szClass, KEYNAMESIZE); )
         if (*szClass != '.') 
         {
            dwSize = KEYNAMESIZE;
            if (!RegQueryValue(HKEY_CLASSES_ROOT, szClass, lpstrClassName, &dwSize))
               if (!lstrcmp(lpstrClassName, szKey))
               {
                    RegCloseKey(hkeyTemp);
                    lstrcpy(lpstrClassName,szClass);    
                    return TRUE;
                }
         }
      RegCloseKey(hkeyTemp);
   }

   *lpstrClassName = 0;
   return FALSE;

}



/***************************************************************************
 *  RegGetClassNames()
 *
 *  Fills in the list box in the Insert New dialog with the names of 
 *  OLE Servers.
 *
 *  returns TRUE if the listbox filled successfully.
 **************************************************************************/

BOOL FAR RegGetClassNames(       //* ENTRY:
   HWND hwndList                 //* HANDLE to the listbox being filled
){                               //* LOCAL:
   DWORD    dwSize;              //* sixe of data
   HKEY     hkeyTemp;            //* temporary registration key
   CHAR     szExec[KEYNAMESIZE]; //* executables name 
   CHAR     szClass[KEYNAMESIZE];//* class name
   CHAR     szName[KEYNAMESIZE]; //* key name
   INT      i;                   

   SendMessage(hwndList, LB_RESETCONTENT, 0, 0L);

   szClass[0]='\0';

   if (!RegOpenKey(HKEY_CLASSES_ROOT, szClass, &hkeyTemp)) 
   {
      for (i = 0; !RegEnumKey(HKEY_CLASSES_ROOT, i++, szClass, KEYNAMESIZE); )
         if (*szClass != '.') 
         {         
            lstrcpy(szExec, szClass);
            lstrcat(szExec, "\\protocol\\StdFileEditing\\server");
            dwSize = KEYNAMESIZE;
            if (!RegQueryValue(HKEY_CLASSES_ROOT, szExec, szName, &dwSize)) 
            {
               dwSize = KEYNAMESIZE;
               if (!RegQueryValue(HKEY_CLASSES_ROOT, szClass, szName, &dwSize)) 
                  SendMessage(hwndList, LB_ADDSTRING, 0, (DWORD)(LPSTR)szName);
            }
         }
      RegCloseKey(hkeyTemp);
      return TRUE;
   }
   return FALSE;

}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\ole1\clidemo\register.h ===
/*
 * <register.h>
 *
 * Created by Microsoft Corporation.
 * (c) Copyright Microsoft Corp. 1990 - 1992  All Rights Reserved
 */

//*** PROTOTYPES ***

//* Far

BOOL FAR    RegCopyClassName(HWND hwndList, LPSTR lpstrClassName);
VOID FAR    RegGetClassId(LPSTR lpstrName, LPSTR lpstrClass);
BOOL FAR    RegGetClassNames(HWND hwndList);
VOID FAR    RegInit(HANDLE hInst);
INT  FAR    RegMakeFilterSpec(LPSTR lpstrClass, LPSTR lpstrExt, LPSTR lpstrFilterSpec);
VOID FAR    RegTerm(VOID);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\ole1\srvrdemo\doc.c ===
/*
  OLE SERVER DEMO           
  Doc.c             
                                                                     
  This file contains document methods and various document-related support 
  functions.
                                                                     
  (c) Copyright Microsoft Corp. 1990 - 1992 All Rights Reserved   
*/                                                                     
 
/* 
   Important Note:

   No method should ever dispatch a DDE message or allow a DDE message to
   be dispatched.
   Therefore, no method should ever enter a message dispatch loop.
   Also, a method should not show a dialog or message box, because the 
   processing of the dialog box messages will allow DDE messages to be
   dispatched.
*/



#define SERVERONLY
#include <windows.h>
#include <ole.h>

#include "srvrdemo.h"

/* AssociateClient
 * ---------------
 *
 * Add a client to the list of clients associated with an object.
 *
 * This function is necessary only because ServerDemo does not create object
 * structures as they are requested, but rather has a fixed set of objects.
 * When DocGetObject is called with a NULL object name, the entire 
 * document is requested, but ServerDemo does not currently support making
 * the entire document an object, so DocGetObject returns one object.
 * That object now goes by two names: NULL and its real name.  Therefore
 * we need to keep track of both lpoleclient's that were passed to 
 * DocGetObject.  Ideally, DocGetObject should always create a new OBJ 
 * structure containing a pointer (or some reference) to the object's native
 * data and also containing one lpoleclient.
 *
 * LPOLECLIENT lpoleclient - the client to be associated with the object.
 * LPOBJ lpobj             - the object 
 *
 * RETURNS: TRUE if successful
 *          FALSE if out of memory
 *
 * CUSTOMIZATION: Server Demo specific
 *
 */
static BOOL AssociateClient (LPOLECLIENT lpoleclient, LPOBJ lpobj)
{
   INT i;
   for (i=0; i < clpoleclient; i++)
   {
      if (lpobj->lpoleclient[i]==lpoleclient)
      {
         return TRUE;
      }
      if (lpobj->lpoleclient[i]==NULL)
      {
         lpobj->lpoleclient[i]=lpoleclient;
         return TRUE;
      }
   }
   return FALSE;
}



/* CreateNewDoc
 * ------------
 *
 * If lhdoc == NULL then we must register the new document by calling
 * OleRegisterServerDoc, which will return a new handle which will be stored
 * in docMain.lhdoc.
 * Also if lhdoc==NULL then this document is being created at the request of
 * the user, not of the client library.
 *
 * LONG lhdoc      - Document handle
 * LPSTR lpszDoc   - Title of the new document
 * DOCTYPE doctype - What type of document is being created
 * 
 * RETURNS: TRUE if successful, FALSE otherwise.
 *
 * CUSTOMIZATION: Re-implement
 *
 */
BOOL CreateNewDoc (LONG lhdoc, LPSTR lpszDoc, DOCTYPE doctype)
{
   INT i;

   // Fill in the fields of the document structure.

   docMain.doctype      = doctype;
   docMain.oledoc.lpvtbl= &docvtbl;

   if (lhdoc == 0)
   {
      if (OLE_OK != OleRegisterServerDoc 
                     (srvrMain.lhsrvr, 
                      lpszDoc,
                      (LPOLESERVERDOC) &docMain, 
                      (LHSERVERDOC FAR *) &docMain.lhdoc))
         return FALSE;
   }
   else
      docMain.lhdoc = lhdoc;

   // Reset all the flags because no object numbers have been used.
   for (i=1; i <= cfObjNums; i++)
      docMain.rgfObjNums[i] = FALSE;

   fDocChanged = FALSE;

   SetTitle (lpszDoc, doctype == doctypeEmbedded);
   return TRUE;
}



/* DestroyDoc
 * ----------
 *
 * Free all memory that had been allocated for a document.
 *
 *
 * CUSTOMIZATION: Re-implement.  Your application will probably use some
 *                other method for enumerating all the objects in a document.
 *                ServerDemo enumerates the child windows, but if each object 
 *                does not have its own window, this will not work.
 *
 */
VOID DestroyDoc (VOID)
{
   HWND hwnd;
   HWND hwndNext;

   // Delete all object windows.  
   hwnd = SelectedObjectWindow();
   while (hwnd) 
   {
      hwndNext = GetWindow (hwnd, GW_HWNDNEXT);
      // Each object window frees its own memory upon receiving WM_DESTROY.
      DestroyWindow (hwnd);
      hwnd = hwndNext;
   } 

   if (docMain.aName)
   {
      GlobalDeleteAtom (docMain.aName);
      docMain.aName = '\0';
   }

   if (docMain.hpal)
      DeleteObject (docMain.hpal);
}



/* DocClose                DOCUMENT "Close" METHOD
 * --------
 *
 * The library calls this method to unconditionally close the document.
 *
 * LPOLESERVERDOC lpoledoc - The server document to close
 * 
 * RETURNS: Return value from RevokeDoc.
 *
 * CUSTOMIZATION: None
 *
 */
OLESTATUS  APIENTRY DocClose (LPOLESERVERDOC lpoledoc)
{
   return RevokeDoc();
}



/* DocExecute                DOCUMENT "Execute" METHOD
 * ----------
 *
 * This application does not support the execution of DDE execution commands.
 * 
 * LPOLESERVERDOC lpoledoc - The server document
 * HANDLE hCommands        - DDE execute commands
 * 
 * RETURNS: OLE_ERROR_COMMAND
 *
 * CUSTOMIZATION: Re-implement if your application supports the execution of
 *                DDE commands.
 *
 */
OLESTATUS  APIENTRY DocExecute (LPOLESERVERDOC lpoledoc, HANDLE hCommands)
{
   return OLE_ERROR_COMMAND;
}



/* DocGetObject                DOCUMENT "GetObject" METHOD
 * ------------
 *
 * The library uses this method to get an object's structure for the
 * client.  Memory needs to be allocated and initialized here for this.
 * A NULL string indicates that the client has an embedded object
 * which was started from Create, CreateFromTemplate, or Edit, but not Open.
 *
 * First see if the object name is NULL.  If so, you would ordinarily
 * return the entire document, but Server Demo returns the selected object.
 * If the object name is not NULL, then go through the list of objects, 
 * searching for one with that name.  Return an error if there is not one.
 *
 * LPOLESERVERDOC lpoledoc        - The server document
 * OLE_LPCSTR lpszObjectName           - The name of the object to get data for
 * LPOLEOBJECT FAR *lplpoleobject - The object's data is put here
 * LPOLECLIENT lpoleclient        - The client structure
 * 
 * RETURNS:        OLE_OK
 *                 OLE_ERROR_NAME if object not found
 *                 OLE_ERROR_MEMORY if no more memory to store lpoleclient
 *
 * CUSTOMIZATION: Re-implement.
 *                lpszObjectName == "" indicates that the whole document 
 *                should be the object returned.
 *
 */
OLESTATUS  APIENTRY DocGetObject
   (LPOLESERVERDOC lpoledoc, OLE_LPCSTR lpszObjectName, 
    LPOLEOBJECT FAR *lplpoleobject, LPOLECLIENT lpoleclient)
{
    HWND  hwnd;
    ATOM  aName;
    LPOBJ lpobj;


    if (lpszObjectName == NULL || lpszObjectName[0] == '\0')
    {   
        // Return a new object or the selected object.
        hwnd = SelectedObjectWindow();
        lpobj = hwnd ? HwndToLpobj (hwnd) : CreateNewObj (FALSE);
        *lplpoleobject = (LPOLEOBJECT) lpobj;
        // Associate client with object.
        if (!AssociateClient (lpoleclient, lpobj))
            return OLE_ERROR_MEMORY;
        return OLE_OK;
    }

    if (!(aName = GlobalFindAtom (lpszObjectName)))
        return OLE_ERROR_NAME;

    hwnd = SelectedObjectWindow();

    // Go through all the child windows and find the window whose name
    // matches the given object name.

    while (hwnd)
    {
         lpobj = HwndToLpobj (hwnd);

         if (aName == lpobj->aName)
         {
            // Return the object with the matching name.
            *lplpoleobject = (LPOLEOBJECT) lpobj;
            // Associate client with the object.
            if (!AssociateClient (lpoleclient, lpobj))
               return OLE_ERROR_MEMORY;
            return OLE_OK;
         }
         hwnd = GetWindow (hwnd, GW_HWNDNEXT);
    }

   if (((DOCPTR)lpoledoc)->doctype ==  doctypeEmbedded)
   {
      lpobj = CreateNewObj (FALSE);
      *lplpoleobject = (LPOLEOBJECT) lpobj;
      
      // Associate client with object.
      if (!AssociateClient (lpoleclient, lpobj))
         return OLE_ERROR_MEMORY;
      return OLE_OK;
    }

    // Object with name lpszObjName was not found.
    return OLE_ERROR_NAME;
}

/* DocRelease                DOCUMENT "Release" METHOD
 * ----------
 *
 * The library uses this method to notify the server that a revoked
 * document has finally finished all conversations, and can be 
 * destroyed.
 * It sets fWaitingForDocRelease to FALSE so a new document can be created
 * and the user can continue working.
 *
 * LPOLESERVERDOC lpoledoc        - The server document
 * 
 * RETURNS: OLE_OK
 *
 * CUSTOMIZATION: None
 *
 */
OLESTATUS  APIENTRY DocRelease (LPOLESERVERDOC lpoledoc)
{
   fWaitingForDocRelease = FALSE;
   // Free all memory that has been allocated for the document.
   DestroyDoc();

   return OLE_OK;
}



/* DocSave                DOCUMENT "Save" METHOD
 * -------
 *
 * Save document to a file.
 *
 * LPOLESERVERDOC lpoledoc - The document to save
 * 
 * RETURNS: OLE_OK
 *
 * CUSTOMIZATION: None
 *
 */
OLESTATUS  APIENTRY DocSave (LPOLESERVERDOC lpoledoc)
{
    if (docMain.doctype == doctypeFromFile)
    {
         // No "File Save As" dialog box will be brought up because the
         // file name is already known.
         return SaveDoc() ? OLE_OK : OLE_ERROR_GENERIC;
    }
    else
      return OLE_ERROR_GENERIC;
}



/* DocSetDocDimensions        DOCUMENT "SetDocDimensions" METHOD
 * -------------------
 *
 * The library calls this method to tell the server the bounds on
 * the target device for rendering the document.
 * A call to this method is ignored for linked objects because the size of
 * a linked document depends only on the source file.
 *
 * LPOLESERVERDOC lpoledoc - The server document
 * CONST LPRECT         lprect   - The target size in MM_HIMETRIC units
 * 
 * RETURNS: OLE_OK
 *
 * CUSTOMIZATION: Re-implement
 *                How an object is sized is application-specific. (Server Demo
 *                uses MoveWindow.)
 *                     
 */
OLESTATUS  APIENTRY DocSetDocDimensions 
   (LPOLESERVERDOC lpoledoc, OLE_CONST RECT FAR * lprect)
{
   if (docMain.doctype == doctypeEmbedded)
   {
      RECT rect = *lprect;
      
      // the units are in HIMETRIC
      rect.right   = rect.right - rect.left;
		// the following was bottom - top
		rect.bottom  = rect.top -  rect.bottom;
		
      HiMetricToDevice ( (LPPOINT) &rect.right );
      MoveWindow (SelectedObjectWindow(), 0, 0, 
                  rect.right + 2 * GetSystemMetrics(SM_CXFRAME), 
                  rect.bottom + 2 * GetSystemMetrics(SM_CYFRAME), 
                  TRUE);
      /* If for some reason your application needs to notify the client that
         the data has changed because DocSetDocDimensions has been called,
         then notify the client here.
         SendDocMsg (OLE_CHANGED);
      */
   }
   return OLE_OK;
}



/* DocSetHostNames        DOCUMENT "SetHostNames" METHOD
 * ---------------
 *
 * The library uses this method to set the name of the document
 * window.
 * All this function does is change the title bar text, although it could
 * do more if necesary. 
 * This function is only called for embedded objects; linked objects
 * use their filenames for the title bar text.
 *
 * LPOLESERVERDOC lpoledoc    - The server document
 * OLE_LPCSTR lpszClient           - The name of the client
 * OLE_LPCSTR lpszDoc              - The client's name for the document
 * 
 * RETURNS:        OLE_OK
 * 
 * CUSTOMIZATION: None
 *
 */
OLESTATUS  APIENTRY DocSetHostNames 
   (LPOLESERVERDOC lpoledoc, OLE_LPCSTR lpszClient, OLE_LPCSTR lpszDoc)
{
   SetTitle ((LPSTR)lpszDoc, TRUE);
   lstrcpy ((LPSTR) szClient, lpszClient);
   lstrcpy ((LPSTR) szClientDoc, Abbrev((LPSTR)lpszDoc));
   UpdateFileMenu (IDM_UPDATE);   
   return OLE_OK;
}



/* DocSetColorScheme                DOCUMENT "SetColorScheme" METHOD
 * -----------------
 *
 * The client calls this method to suggest a color scheme (palette) for
 * the server to use.
 * In Server Demo the document's palette is never actually used because each 
 * object has its own palette.  See ObjSetColorScheme.
 *
 * LPOLESERVERDOC lpoledoc - The server document
 * CONST LOGPALETTE FAR * lppal    - Suggested palette
 *
 * RETURNS: OLE_ERROR_PALETTE if CreatePalette fails, 
 *          OLE_OK otherwise
 *
 * 
 * CUSTOMIZATION: If your application supports color schemes, then this 
 *                function is a good example of how to create and store
 *                a palette.
 */
OLESTATUS  APIENTRY DocSetColorScheme 
   (LPOLESERVERDOC lpoledoc, OLE_CONST LOGPALETTE FAR * lppal)
{
   HPALETTE hpal = CreatePalette (lppal);

   if (hpal==NULL)
      return OLE_ERROR_PALETTE;

   if (docMain.hpal) 
   {
      // Delete old palette
      DeleteObject (docMain.hpal);
   }
   // Store handle to new palette
   docMain.hpal = hpal;
   return OLE_OK;
}



/* RevokeDoc
 * ---------
 *
 * Call OleRevokeServerDoc.
 * If the return value is OLE_WAIT_FOR_BUSY, then set fWaitingForDocRelease
 * and enter a message-dispatch loop until fWaitingForDocRelease is reset.
 * As long as fWaitingForDocRelease is set, the user interface will be 
 * disabled so that the user will not be able to manipulate the document.
 * When the DocRelease method is called, it will reset fWaitingForDocRelease,
 * allowing RevokeDoc to free the document's memory and return.
 *
 * This is essentially a way to make an asynchronous operation synchronous.
 * We need to wait until the old document is revoked before we can delete
 * its data and create a new one.
 *
 * Note that we cannot call RevokeDoc from a method because it is illegal to
 * enter a message-dispatch loop within a method.
 *
 * RETURNS: The return value of OleRevokeServerDoc.
 *
 * CUSTOMIZATION: lhdoc may need to be passed in as a parameter if your 
 *                application does not have a global variable corresponding 
 *                to docMain.
 * 
 */
OLESTATUS RevokeDoc (VOID)
{
   OLESTATUS olestatus;

   if ((olestatus = OleRevokeServerDoc(docMain.lhdoc)) > OLE_WAIT_FOR_RELEASE)
      DestroyDoc();

   docMain.lhdoc = 0; // A NULL handle indicates that the document 
                         // has been revoked or is being revoked.
   return olestatus;

}



/* SaveChangesOption
 * -----------------
 *
 * Give the user the opportunity to save changes to the current document
 * before continuing.
 *
 * BOOL *pfUpdateLater - Will be set to TRUE if the client does not accept
 *                       the update and needs to be updated when the document
 *                       is closed.  In that case, OLE_CLOSED will be sent.
 *
 * RETURNS: IDYES, IDNO, or IDCANCEL
 *
 * CUSTOMIZATION: None
 *
 */
INT SaveChangesOption (BOOL *pfUpdateLater)
{
   INT  nReply;
   CHAR szBuf[cchFilenameMax];
   
   *pfUpdateLater = FALSE;
   
   if (fDocChanged)
   {
       CHAR szTmp[cchFilenameMax];
       
       if (docMain.aName) 
           GlobalGetAtomName (docMain.aName, szTmp, cchFilenameMax);
       else 
           szTmp[0] = '\0';

       if (docMain.doctype == doctypeEmbedded)
           wsprintf (szBuf, "The object has been changed.\n\nUpdate %s before closing the object?", Abbrev (szTmp));        
       else
           lstrcpy (szBuf, (LPSTR) "Save changes?");         
     
       nReply = MessageBox (hwndMain, szBuf, szAppName, 
                      MB_ICONEXCLAMATION | MB_YESNOCANCEL);
                  
       switch (nReply)
       {
          case IDYES:
              if (docMain.doctype != doctypeEmbedded)
                  SaveDoc();
              else
                  switch (OleSavedServerDoc (docMain.lhdoc))
                  {
                      case OLE_ERROR_CANT_UPDATE_CLIENT:
                          *pfUpdateLater = TRUE;
                          break;
                      case OLE_OK:
                          break;
                      default:
                          ErrorBox ("Fatal Error: Cannot update.");
                  }                                      
              return IDYES;
          case IDNO:
              return IDNO;
         case IDCANCEL:
              return IDCANCEL;
       }
   }
   return TRUE;
}



/* SendDocMsg
 * ----------
 *
 * This function sends messages to all the objects in a document when
 * the document has changed.
 *
 * WORD wMessage - The message to send
 * 
 * CUSTOMIZATION: The means of enumerating all the objects in a document
 *                is application specific.
 */
VOID SendDocMsg (WORD wMessage)
{
    HWND    hwnd;

    // Get handle to first object window.
    hwnd = SelectedObjectWindow();

    // Send message to all object windows.
    while (hwnd)
    {
        SendObjMsg (HwndToLpobj(hwnd), wMessage);
        hwnd = GetWindow (hwnd, GW_HWNDNEXT);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\ole1\clidemo\utility.c ===
/* 
 * utility.c - general purpose utility routines
 *
 * Created by Microsoft Corporation.
 * (c) Copyright Microsoft Corp. 1990 - 1992  All Rights Reserved
 *
 */

//*** INCLUDES ****

#include <windows.h>
#include <ole.h>

#include "global.h"
#include "demorc.h"
#include "utility.h"
#include "object.h"
#include "dialog.h"

static INT        iTimerID = 0;
static APPITEMPTR lpaItemHold;


/****************************************************************************
 *  ErrorMessage()
 *
 *  Display a message box containing the specified string from the table.
 *
 *  id WORD       - Index into string table.
 ***************************************************************************/

VOID FAR ErrorMessage(                 //* ENTRY:
   DWORD          id                   //* message ID
){                                     //* LOCAL:
   CHAR           sz[CBMESSAGEMAX];    //* string 
   HWND           hwnd;                //* parent window handle

   if (IsWindow(hwndProp))
      hwnd = hwndProp;
   else if (IsWindow(hwndFrame))
      hwnd = hwndFrame; 
   else
      return;

   LoadString(hInst, id, sz, CBMESSAGEMAX);
   MessageBox(hwnd, sz, szAppName, MB_OK | MB_ICONEXCLAMATION);

}


/****************************************************************************
 *  Hourglass()
 *
 *  Put up or takes down the hourglass cursor as needed.
 *
 *  int  bToggle  - TRUE turns the hour glass on
 *                  HG_OFF turn it off  
 ***************************************************************************/

VOID FAR Hourglass(                    //* ENTRY:
   BOOL           bOn                  //* hourglass on/off
){                                     //* LOCAL:
   static HCURSOR hcurWait = NULL;     //* hourglass cursor
   static HCURSOR hcurSaved;           //* old cursor
   static         iCount = 0;


   if (bOn)
   {
      iCount++;
      if (!hcurWait) 
         hcurWait = LoadCursor(NULL, IDC_WAIT);
      if (!hcurSaved) 
         hcurSaved = SetCursor(hcurWait);
   }
   else if (!bOn)
   {  
      if (--iCount < 0 )
         iCount = 0;
      else if (!iCount)
      {
         SetCursor(hcurSaved);
         hcurSaved = NULL;
      }
   }

}

/***************************************************************************
 *  WaitForObject()
 *
 *  Dispatch messagee until the specified object is not busy. 
 *  This allows asynchronous processing to occur.
 *
 *  lpObject    LPOLEOBJECT - pointer to object
 **************************************************************************/

void FAR WaitForObject(                //* ENTRY:
   APPITEMPTR    paItem                //* pointer to OLE object
){                                     //* LOCAL
   BOOL bTimerOn = FALSE;

   while (OleQueryReleaseStatus(paItem->lpObject) == OLE_BUSY)
   {
      lpaItemHold = paItem;
      if (!bTimerOn)
         bTimerOn = ToggleBlockTimer(TRUE);//* set timer
      ProcessMessage(hwndFrame, hAccTable);
   }

   if (bTimerOn)
       ToggleBlockTimer(FALSE);//* toggle timer off
}

/***************************************************************************
 *  WaitForAllObjects()
 *
 *  Wait for all asynchronous operations to complete. 
 **************************************************************************/

VOID FAR WaitForAllObjects(VOID)
{
   BOOL bTimerOn = FALSE;

   while (cOleWait) 
   {
      if (!bTimerOn)
         bTimerOn = ToggleBlockTimer(TRUE);//* set timer

      ProcessMessage(hwndFrame, hAccTable) ;
   }

   if (bTimerOn)
       ToggleBlockTimer(FALSE);//* toggle timer off
     
}

/****************************************************************************
 * ProcessMessage()
 *
 * Obtain and dispatch a message. Used when in a message dispatch loop. 
 *
 *  Returns BOOL - TRUE if message other than WM_QUIT retrieved
 *                 FALSE if WM_QUIT retrieved.
 ***************************************************************************/

BOOL FAR ProcessMessage(               //* ENTRY:
   HWND           hwndFrame,           //* main window handle
   HANDLE         hAccTable            //* accelerator table handle
){                                     //* LOCAL:
   BOOL           fReturn;             //* return value
   MSG            msg;                 //* message

   if (fReturn = GetMessage(&msg, NULL, 0, 0)) 
   {
      if (cOleWait || !TranslateAccelerator(hwndFrame, hAccTable, &msg)) 
      {
            TranslateMessage(&msg);
            DispatchMessage(&msg); 
      }
   }
   return fReturn;

}


/****************************************************************************
 *  Dirty()
 *
 *  Keep track of weather modifications have been made 
 *  to the document or not.
 *
 *  iAction - action type:
 *            DOC_CLEAN set document clean flag true
 *            DOC_DIRTY the opposite
 *            DOC_UNDIRTY undo one dirty op
 *            DOC_QUERY return present state
 *
 *  Returs int - present value of fDirty; 0 is clean.
 ***************************************************************************/

INT FAR Dirty(                         //* ENTRY:
   INT            iAction              //* see above comment
){                                     //* LOCAL:
   static INT     iDirty = 0;          //* dirty state >0 is dirty

   switch (iAction)
   {
      case DOC_CLEAN:
         iDirty = 0;
         break;
      case DOC_DIRTY:
         iDirty++;
         break;
      case DOC_UNDIRTY:
         iDirty--;
         break;
      case DOC_QUERY:
         break;
   }
   return(iDirty);

}

/***************************************************************************
 *  ObjectsBusy()
 *
 *  This function enumerates the OLE objects in the current document 
 *  and displays a message box stating whether an object is busy. 
 *  This function calls  the DisplayBusyMessage() function which 
 *  performs most of the work. This function is only used by the macro
 *  BUSY_CHECK(), defined in object.h.
 *
 *  fSelectionOnly  BOOL -NOT USED?
 *
 *  BOOL - TRUE if one or more objects found to be busy
 *             FALSE otherwise
 *
 ***************************************************************************/

BOOL FAR ObjectsBusy ()
{
   APPITEMPTR pItem;

   if (iTimerID)
   {
      RetryMessage(NULL,RD_CANCEL);
      return TRUE;
   }

   for (pItem = GetTopItem(); pItem; pItem = GetNextItem(pItem))
      if (DisplayBusyMessage(pItem))
         return TRUE;

   return FALSE;

}

/***************************************************************************
 *  DisplayBusyMessage()
 *
 *  This function determines if an object is busy and displays 
 *  a message box stating this status. 
 *
 *  Returns BOOL - TRUE if object is busy
 **************************************************************************/

BOOL FAR DisplayBusyMessage (          //* ENTRY:
   APPITEMPTR     paItem               //* application item pointer
){                                     //* LOCAL:
    
   if (OleQueryReleaseStatus(paItem->lpObject) == OLE_BUSY) 
   {
      RetryMessage(paItem,RD_CANCEL);
      return TRUE;    
   }
   return FALSE;

}

/***************************************************************************
 * CreateNewUniqueName()
 *
 * Create a string name unique to this document. This is done by using the
 * prefix string("OleDemo #") and appending a counter to the end of the 
 * prefix string. The counter is incremented  whenever a new object is added. 
 * String will be 14 bytes long.
 *
 * Return LPSTR - pointer to unique object name.
 ***************************************************************************/

LPSTR FAR CreateNewUniqueName(         //* ENTRY:
   LPSTR          lpstr                //* destination pointer
){

    wsprintf( lpstr, "%s%04d", OBJPREFIX, iObjectNumber++ );
    return( lpstr );

}

/***************************************************************************
 *  ValidateName()
 *
 *  This function ensures that the given object name is valid and unique.
 *
 *  Returns: BOOL - TRUE if object name valid
 **************************************************************************/

BOOL FAR ValidateName(                 //* ENTRY:
   LPSTR          lpstr                //* pointer to object name
){                                     //* LOCAL:
   LPSTR          lp;                  //* worker string
   INT            n;
                                       //* check for "OleDemo #" prefix
   lp = OBJPREFIX;

   while( *lp ) 
   {
      if( *lpstr != *lp )
         return( FALSE );

      lpstr++; lp++;
   }
                                       //* convert string number to int
   for (n = 0 ; *lpstr ; n = n*10 + (*lpstr - '0'),lpstr++);

   if( n > 9999 )                      //* 9999 is largest legal number
      return FALSE;

   if( iObjectNumber <= n)             //* Make count > than any current
      iObjectNumber = n + 1;           //* object to ensure uniqueness

    return TRUE;
}

/***************************************************************************
 * FreeAppItem()
 *
 * Free application item structure and destroy the associated structure.
 **************************************************************************/

VOID FAR FreeAppItem(                  //* ENTRY:
   APPITEMPTR     pItem                //* pointer to application item
){                                     //* LOCAL:
   HANDLE         hWork;               //* handle used to free
   
   if (pItem)
   {                                   //* destroy the window
      if (pItem->hwnd)
         DestroyWindow(pItem->hwnd);

      hWork = LocalHandle((LPSTR)pItem);//* get handle from pointer

      if (pItem->aLinkName)
         DeleteAtom(pItem->aLinkName);

      if (pItem->aServer)
         DeleteAtom(pItem->aServer);

      LocalUnlock(hWork);
      LocalFree(hWork);
   }

}

/***************************************************************************
 * SizeOfLinkData()
 *
 * Find the size of a linkdata string.
 **************************************************************************/

LONG FAR SizeOfLinkData(               //* ENTRY:
   LPSTR          lpData               //* pointer to link data
){                                     //* LOCAL:
   LONG           lSize;               //* total size

   lSize = (LONG)lstrlen(lpData)+1;       //* get size of classname
   lSize += (LONG)lstrlen(lpData+lSize)+1; //* get size of doc.
   lSize += (LONG)lstrlen(lpData+lSize)+2;//* get size of item
   return lSize;

}

/****************************************************************************
 * ShowDoc()
 *
 * Display all the child windows associated with a document, or make all the
 * child windows hidden.
 ***************************************************************************/

VOID FAR ShowDoc(                      //* ENTRY:
   LHCLIENTDOC    lhcDoc,              //* document handle
   INT            iShow                //* show/hide
){                                     //* LOCAL:
   APPITEMPTR     pItem;               //* application item pointer
   APPITEMPTR     pItemTop = NULL;

   for (pItem = GetTopItem(); pItem; pItem = GetNextItem(pItem))
   {
      if (pItem->lhcDoc == lhcDoc)
      {
         if (!pItemTop)
            pItemTop = pItem;
         ShowWindow(pItem->hwnd,(iShow ? SW_SHOW : SW_HIDE)); 
         pItem->fVisible = (BOOL)iShow;
      }
   }
   
   if (pItemTop)
      SetTopItem(pItemTop);

}           
      
/****************************************************************************
 * GetNextActiveItem()
 *
 * Returns HWND - the next visible window. 
 ***************************************************************************/

APPITEMPTR FAR GetNextActiveItem()
{                                      //* LOCAL:
   APPITEMPTR     pItem;               //* application item pointer

   for (pItem = GetTopItem(); pItem; pItem = GetNextItem(pItem))
      if (pItem->fVisible)
         break;

   return pItem;

}
 
/****************************************************************************
 * GetTopItem()
 ***************************************************************************/

APPITEMPTR FAR GetTopItem()
{
   HWND hwnd;

   if (hwnd = GetTopWindow(hwndFrame))
      return ((APPITEMPTR)GetWindowLong(hwnd,0));
   else
      return NULL;

}
/****************************************************************************
 * GetNextItem()
 ***************************************************************************/

APPITEMPTR FAR GetNextItem(            //* ENTRY:
   APPITEMPTR     pItem                //* application item pointer
){                                     //* LOCAL:
   HWND           hwnd;                //* next item window handle

   if (hwnd = GetNextWindow(pItem->hwnd, GW_HWNDNEXT))
      return((APPITEMPTR)GetWindowLong(hwnd,0));
   else
      return NULL;

}

/****************************************************************************
 * SetTopItem()
 ***************************************************************************/

VOID FAR SetTopItem(
   APPITEMPTR     pItem
){
   APPITEMPTR     pLastItem;

   pLastItem = GetTopItem();
   if (pLastItem && pLastItem != pItem)
      SendMessage(pLastItem->hwnd,WM_NCACTIVATE, 0, 0L);

   if (!pItem)
      return;

   if (pItem->fVisible)
   {
      BringWindowToTop(pItem->hwnd);
      SendMessage(pItem->hwnd,WM_NCACTIVATE, 1, 0L);
   }

}

/***************************************************************************
 * ReallocLinkData()
 *
 * Reallocate link data in order to avoid creating lots and lots of global
 * memory thunks.
 **************************************************************************/

BOOL FAR ReallocLinkData(              //* ENTRY:
   APPITEMPTR     pItem,               //* application item pointer
   LONG           lSize                //* new link data size
){                                     //* LOCAL:
   HANDLE         handle;              //* temporary memory handle

   handle = GlobalHandle(pItem->lpLinkData);
   GlobalUnlock(handle);

   if (!(pItem->lpLinkData = GlobalLock(GlobalReAlloc(handle, lSize, 0)))) 
   {
      ErrorMessage(E_FAILED_TO_ALLOC); 
      return FALSE;
   }

   return TRUE;

}

/***************************************************************************
 * AllocLinkData()
 *
 * Allocate link data space.
 **************************************************************************/

BOOL FAR AllocLinkData(                //* ENTRY:
   APPITEMPTR     pItem,               //* application item pointer
   LONG           lSize                //* link data size
){

   if (!(pItem->lpLinkData = GlobalLock(
         GlobalAlloc(GMEM_DDESHARE | GMEM_ZEROINIT ,lSize)
      )))
   {
      ErrorMessage(E_FAILED_TO_ALLOC);
      return FALSE;
   }

   return TRUE;
}

/***************************************************************************
 * FreeLinkData()
 *
 * Free the space associated with a linkdata pointer.
 **************************************************************************/

VOID FAR FreeLinkData(                 //* ENTRY:
   LPSTR          lpLinkData           //* pointer to linkdata
){                                     //* LOCAL:
   HANDLE         handle;              //* temporary memory handle

   if (lpLinkData)
   {
      handle = GlobalHandle(lpLinkData);
      GlobalUnlock(handle);
      GlobalFree(handle);
   }
}

/****************************************************************************
 * ShowNewWindow()
 *
 * Show a new application item window.
 ***************************************************************************/

VOID FAR ShowNewWindow(                //* ENTRY:
   APPITEMPTR     pItem
){

   if (pItem->fVisible)
   {
      pItem->fNew = TRUE;
      SetTopItem(pItem);
      ShowWindow(pItem->hwnd,SW_SHOW);
   }
   else
      ObjDelete(pItem,OLE_OBJ_DELETE);

}

/****************************************************************************
 * UnqualifyPath()
 *
 * return pointer to unqualified path name.
 ***************************************************************************/

PSTR FAR UnqualifyPath(PSTR pPath)
{
   PSTR pReturn;

   for (pReturn = pPath; *pPath; pPath++)  
      if (*pPath == ':' || *pPath == '\\')
         pReturn = pPath+1;

   return pReturn;

}

/****************************************************************************
 * ToggleBlockTimer()
 *
 * Toggle a timer used to check for blocked servers.
 ***************************************************************************/

BOOL FAR ToggleBlockTimer(BOOL bSet)
{     
   if (bSet && !iTimerID)
   {
      if (iTimerID = SetTimer(hwndFrame,1, 3000, (TIMERPROC) fnTimerBlockProc))
          return TRUE;
   }
   else if (iTimerID)
   {
      KillTimer(hwndFrame,1);
      iTimerID = 0;
      return TRUE;
   }
   
   return FALSE;
}

/****************************************************************************
 *  fnTimerBlockProc()
 *
 *  Timer callback procedure
 ***************************************************************************/

VOID CALLBACK fnTimerBlockProc(      //* ENTRY: 
   HWND     hWnd,
   UINT     wMsg,
   UINT     iTimerID,
   DWORD    dwTime
){

   if (!hRetry)
      RetryMessage(lpaItemHold, RD_RETRY | RD_CANCEL);

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\ole1\clidemo\utility.h ===
/* 
 * utility.h 
 *
 * Created by Microsoft Corporation.
 * (c) Copyright Microsoft Corp. 1990 - 1992  All Rights Reserved
 */

//*** PROTO TYPES ***

//* FAR  
BOOL FAR          ObjectsBusy(VOID);
VOID FAR          WaitForAllObjects(VOID);
VOID FAR          WaitForObject(APPITEMPTR);
VOID FAR          ErrorMessage(DWORD);
VOID FAR          Hourglass(BOOL);
BOOL FAR          DisplayBusyMessage (APPITEMPTR);
BOOL FAR          Dirty(INT);
LPSTR FAR         CreateNewUniqueName(LPSTR);
BOOL FAR          ValidateName(LPSTR);
BOOL FAR          ProcessMessage(HWND, HANDLE);
VOID FAR          FreeAppItem(APPITEMPTR);
LONG FAR          SizeOfLinkData (LPSTR);
VOID FAR          ShowDoc(LHCLIENTDOC, INT);
APPITEMPTR FAR    GetTopItem(VOID);
VOID FAR          SetTopItem(APPITEMPTR);
APPITEMPTR FAR    GetNextActiveItem(VOID);
APPITEMPTR FAR    GetNextItem(APPITEMPTR);
BOOL FAR          ReallocLinkData(APPITEMPTR,LONG);
BOOL FAR          AllocLinkData(APPITEMPTR,LONG);
VOID FAR          FreeLinkData(LPSTR);
VOID FAR          ShowNewWindow(APPITEMPTR);
PSTR FAR          UnqualifyPath(PSTR);
VOID CALLBACK     fnTimerBlockProc(HWND, UINT, UINT, DWORD);
BOOL FAR          ToggleBlockTimer(BOOL);

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\ole1\clidemo\stream.c ===
/*
 * stream.c - io stream function callbacks
 *
 * Created by Microsoft Corporation.
 * (c) Copyright Microsoft Corp. 1990 - 1992  All Rights Reserved
 */

/***************************************************************************
 * This file contains all routines that directly and indirectly deal with
 * file i/o.  The OLE stream call back functions exist in this file.     
 **************************************************************************/

//*** INCLUDES ***

#include <windows.h>
#include <ole.h>

#include "global.h"
#include "utility.h"
#include "stream.h"
#include "object.h"
#include "demorc.h"

//*** Globals ***

BOOL fLoadFile = FALSE;

/***************************************************************************
 *  ReadStream() - OLE Callback Function (Get)       
 *
 *  This function is pointed to from the OLESTREAM vtbl; it is Get.
 *
 *  returns DWORD  - number of bytes actually read
 **************************************************************************/

DWORD  APIENTRY ReadStream(           //* ENTRY:
   LPAPPSTREAM    lpStream,            //* application stream pointer
   LPSTR          lpstr,               //* string pointer
   DWORD          cb                   //* byte count
){

   return _lread(lpStream->fh, lpstr, cb);

}

/***************************************************************************
 *  WriteStream() - OLE Callback function (Put)
 *
 *  This function is pointed to from the OLESTREAM vtbl; it is Put.
 *
 *  Returns DWORD  - number of bytes actually written
 **************************************************************************/

DWORD  APIENTRY WriteStream(           //* ENTRY:
   LPAPPSTREAM    lpStream,            //* application stream pointer 
   LPSTR          lpstr,               //* string pointer
   DWORD          cb                   //* number of bytes to write
){

   return _lwrite(lpStream->fh, lpstr, cb);

}

/****************************************************************************
 *  ReadFromFile()
 *
 *  This function reads OLE objects from a file. If the document 
 *  contains manual links, the user will be prompted to update those links.
 *
 *  Returns BOOL  - TRUE if the read(s) were successful
 ***************************************************************************/

BOOL FAR ReadFromFile(                 //* ENTRY:
   LPAPPSTREAM    lpStream,            //* application stream pointer
   LHCLIENTDOC    lhcDoc,              //* document handle
   LPOLECLIENT    lpClient             //* pointer to OLE client structure
){                                     //* LOCAL:
   BOOL           bReturn = FALSE;     //* return value
   INT            cFileObjects;        //* number of file objects

   Hourglass(TRUE);
   fLoadFile = TRUE;

   SetFilePointer((HANDLE)lpStream->fh, 0, NULL, 0);
                                       //* in the file
   if (_lread(lpStream->fh, (LPSTR)&cFileObjects, sizeof(INT)) < sizeof(INT))
      goto Error;

   for (; cFileObjects; --cFileObjects) 
   {
      if (!ObjRead(lpStream,lhcDoc,lpClient)) 
      {
         ErrorMessage(E_FAILED_TO_READ_OBJECT);
         goto Error;
      }
   }
   
   ShowDoc(lhcDoc,1);
   UpdateLinks(lhcDoc);

   bReturn = TRUE;                     //* SUCCESS

Error:                                 //* ERROR Tag
    
   Hourglass(FALSE);
   fLoadFile = FALSE;
   return bReturn;                     //* return

}

/****************************************************************************
 *  ObjRead()
 *
 *  Rread an object from the specified file. The file pointer will 
 *  be advanced past the object.
 *
 *  HANDLE fh     - DOS file handle of file to be read from
 *
 *  returns HWND  - window handle to item window containing the OLE object
 ***************************************************************************/

BOOL FAR ObjRead(                      //* ENTRY:
   LPAPPSTREAM    lpStream,            //* application stream pointer
   LHCLIENTDOC    lhcDoc,              //* document handle
   LPOLECLIENT    lpClient             //* pointer to OLE client structure
){                                     //* LOCAL:
   APPITEMPTR     pItem;               //* application item pointer
   LPOLEOBJECT    lpObject;            //* pointer ole object 
   LONG           otObject;            //* type of object 
   RECT           rcObject;            //* object rect 
   CHAR           szTmp[CBOBJNAMEMAX]; //* temporary string buffer
   CHAR           szProto[PROTOCOL_STRLEN+1];//* protocol string
   INT            i;                   //* index

   if (_lread(lpStream->fh, szTmp, CBOBJNAMEMAX) < CBOBJNAMEMAX )
      return FALSE;

   if (_lread(lpStream->fh, szProto, PROTOCOL_STRLEN) < PROTOCOL_STRLEN )
      return FALSE;

   for (i=0; szProto[i] != ' '; i++);
   szProto[i] = 0;

   ValidateName( szTmp );

   if (!(pItem = PreItemCreate(lpClient, TRUE, lhcDoc))) 
      return FALSE;

   if (Error(OleLoadFromStream((LPOLESTREAM)&(lpStream->olestream), 
         szProto,(LPOLECLIENT)&(pItem->oleclient), lhcDoc, szTmp, &lpObject))) 
      goto Error;

   if (_lread(lpStream->fh, (LPSTR)&rcObject, sizeof(RECT)) < sizeof(RECT))
      goto Error;
   
   if (_lread(lpStream->fh, (LPSTR)&otObject, sizeof(LONG)) < sizeof(LONG))
      goto Error;

   if (PostItemCreate(lpObject, otObject, &rcObject, pItem))
   {
      pItem->fNew = TRUE;
      ObjSetBounds(pItem);
      return TRUE;                     //* SUCCESS return
   }
   else
      return FALSE;

Error:                                 //* ERROR Tag

   FreeAppItem(pItem);
   return FALSE;

}

/*************************************************************************
 *  WriteToFile()
 *
 *  Write current document to a file.
 *
 *  returns BOOL - TRUE if file successfully written
 ************************************************************************/

BOOL FAR WriteToFile(                  //* ENTRY:
   LPAPPSTREAM    lpStream             //* application stream pointer
){                                     //* LOCAL:
   INT            iObjectsWritten=0;   //* counter of objects written to file
   APPITEMPTR     pItem;               //* application Item pointer
   
   UpdateFromOpenServers();
      
   SetFilePointer((HANDLE)lpStream->fh, 0, NULL, 0);
   
   Hourglass(TRUE);

   if (_lwrite(lpStream->fh, (LPSTR)&iObjects, sizeof(INT)) < sizeof(INT))
      goto Error;

   for (pItem = GetTopItem(); pItem; pItem = GetNextItem(pItem))
   {
      if (!ObjWrite(lpStream, pItem)) 
         goto Error;
      iObjectsWritten++;
   }

   if (iObjectsWritten != iObjects) 
      goto Error;


   Dirty(DOC_CLEAN);
   Hourglass(FALSE);
   return(TRUE);                       //* SUCCESS return

Error:                                 //* ERROR Tag
    
   Hourglass(FALSE);
   return(FALSE);                      //* ERROR return

}

/****************************************************************************
 *  ObjWrite()
 *
 *  This function writes an object to the specified
 *  file. The file pointer will be advanced past the end of
 *  the written object.

 *  Returns BOOL - TRUE if object written successfully
 ***************************************************************************/

BOOL FAR ObjWrite(                     //* ENTRY:
   LPAPPSTREAM    lpStream,            //* application stream pointer
   APPITEMPTR     pItem                //* application item pointer
){                                     //* LOCAL:
   POINT           pt;                  //* center of rec point
   RECT            rc;                  //* bounding rectangle
   UINT            cbTmp = CBOBJNAMEMAX;
   CHAR            szTmp[PROTOCOL_STRLEN];//* protocol string

   OleQueryName(pItem->lpObject, szTmp, &cbTmp);

   if (_lwrite(lpStream->fh, szTmp, CBOBJNAMEMAX) < CBOBJNAMEMAX )
      return FALSE;

   if (pItem->otObject == OT_STATIC)
      wsprintf(szTmp, "%-15s", STATICP);
   else   
      wsprintf(szTmp, "%-15s", STDFILEEDITING);

   if (_lwrite(lpStream->fh, szTmp, PROTOCOL_STRLEN) < PROTOCOL_STRLEN )
      return FALSE;

   if (Error(OleSaveToStream(pItem->lpObject, (LPOLESTREAM)&(lpStream->olestream))))
      return FALSE;

   GetClientRect(pItem->hwnd, (LPRECT)&rc);
   pt = *(LPPOINT)&rc;
   ClientToScreen(pItem->hwnd, (LPPOINT)&pt);
   ScreenToClient(hwndFrame, (LPPOINT)&pt);
   OffsetRect(
      &rc, 
      pt.x - rc.left - GetSystemMetrics(SM_CXFRAME),
      pt.y - rc.top  - GetSystemMetrics(SM_CYFRAME) 
   );

   if (_lwrite(lpStream->fh, (LPSTR)&rc, sizeof(RECT)) < sizeof(RECT)
         || _lwrite(lpStream->fh, (LPSTR)&(pItem->otObject), sizeof(LONG)) < sizeof(LONG))
      return FALSE;

   return TRUE;                        //* SUCCESS return

}

/****************************************************************************
 * UpdateLinks()
 *
 * Get the most up to date rendering information and show it.  
 ***************************************************************************/

static VOID UpdateLinks(               //* ENTRY
   LHCLIENTDOC    lhcDoc               //* client document handle
){                                     //* LOCAL:
   INT            i=0;                 //* index
   APPITEMPTR     pItem;               //* temporary item pointer
   CHAR           szUpdate[CBMESSAGEMAX];//* update message?

   for (pItem = GetTopItem(); pItem; pItem = GetNextItem(pItem))
   {
      if (pItem->lhcDoc == lhcDoc && pItem->otObject == OT_LINK)
      {   
         if (!i)
         {
            LoadString(hInst, IDS_UPDATELINKS, szUpdate, CBMESSAGEMAX);
            if (MessageBox(hwndFrame, szUpdate, szAppName,
               MB_YESNO | MB_ICONEXCLAMATION) != IDYES)
               break; 
            i++;
         }
         Error(OleUpdate(pItem->lpObject));
      }
   }

   WaitForAllObjects();

}

/****************************************************************************
 * UpdateFromOpenServers()
 *
 * Get the most up to date rendering information before storing it.  
 ***************************************************************************/

static VOID UpdateFromOpenServers(VOID)
{                                      //* LOCAL:
   APPITEMPTR pItem;                   //* temporary item pointer
   APPITEMPTR pItemNext;

   for (pItem = GetTopItem(); pItem; pItem = pItemNext) 
   {
      pItemNext = GetNextItem(pItem); 
      if (pItem->otObject == OT_EMBEDDED || 
         (pItem->uoObject == oleupdate_oncall 
               && pItem->otObject == OT_LINK ))  

         if (OleQueryOpen(pItem->lpObject) == OLE_OK)
         {  
            CHAR szMessage[2*CBMESSAGEMAX];
            CHAR szBuffer[CBMESSAGEMAX];
            UINT cb = CBOBJNAMEMAX;       //* The name will be the server window title.
            CHAR szTmp[CBOBJNAMEMAX];     //* when the object is edited. 

            Error(OleQueryName(pItem->lpObject,szTmp,&cb));
            LoadString(hInst, IDS_UPDATE_OBJ, szBuffer, CBMESSAGEMAX);
            wsprintf(szMessage, szBuffer, (LPSTR)szTmp);

            if (MessageBox(hwndFrame, szMessage, szAppName, MB_YESNO | MB_ICONEXCLAMATION) == IDYES) 
            {
               Error(OleUpdate(pItem->lpObject));
               WaitForObject(pItem);
            }
            if (!pItem->fVisible)
               ObjDelete(pItem, OLE_OBJ_DELETE);
         }

   }

   WaitForAllObjects();

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\ole1\clidemo\object.h ===
/*
 * object.h 
 *
 * Created by Microsoft Corporation.
 * (c) Copyright Microsoft Corp. 1990 - 1992  All Rights Reserved
 */

//*** PROTOTYPES ***

//* OLE Callbacks

INT  APIENTRY CallBack(LPOLECLIENT, OLE_NOTIFICATION, LPOLEOBJECT);

//* Exported Windows procedures

LONG  APIENTRY ItemWndProc(HWND, UINT, DWORD, LONG);

//* Far
VOID FAR       ObjDelete(APPITEMPTR, BOOL);
VOID FAR       ConvertToClient(LPRECT);
OLESTATUS FAR  Error(OLESTATUS);
APPITEMPTR FAR PreItemCreate(LPOLECLIENT, BOOL, LHCLIENTDOC);
BOOL FAR       PostItemCreate(LPOLEOBJECT, LONG, LPRECT, APPITEMPTR);
VOID FAR       ObjPaste(BOOL, LHCLIENTDOC, LPOLECLIENT);
BOOL FAR       ObjCopy(APPITEMPTR);
BOOL FAR       ObjGetData (APPITEMPTR, LPSTR);
VOID FAR       ObjChangeLinkData(APPITEMPTR, LPSTR);
VOID FAR       ObjSaveUndo(APPITEMPTR);
VOID FAR       ObjDelUndo(APPITEMPTR); 
VOID FAR       ObjUndo(APPITEMPTR);
VOID FAR       ObjFreeze(APPITEMPTR);
VOID FAR       ObjInsert(LHCLIENTDOC, LPOLECLIENT);
VOID FAR       ObjCreateFromTemplate(LHCLIENTDOC, LPOLECLIENT);
VOID FAR       ObjCreateWrap(HANDLE, LHCLIENTDOC, LPOLECLIENT);
VOID FAR       UpdateObjectMenuItem(HMENU);
VOID FAR       ExecuteVerb(UINT, APPITEMPTR);

//* Local
static VOID    Release(APPITEMPTR);
BOOL FAR       ObjSetBounds(APPITEMPTR);

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\ole1\srvrdemo\file.c ===
/*
  OLE SERVER DEMO
  File.c

  This file contains file input/output functions for for the OLE server demo.

  (c) Copyright Microsoft Corp. 1990 - 1992 All Rights Reserved
*/



#include <windows.h>
#include <commDlg.h>
#include <ole.h>

#include "srvrdemo.h"

// File signature stored in the file.
#define szSignature "ServerDemo"
#define cchSigLen (10+1)

// Delimiter for fields in the file
#define chDelim ':'

// Default file extension
#define szDefExt "sd1"

// File header structure
typedef struct
{
   CHAR szSig [cchSigLen];
   CHAR chDelim1;
   VERSION version;
   CHAR chDelim2;
   CHAR rgfObjNums [cfObjNums+1];
} HEADER;

// BOOL  GetFileSaveFilename (LPSTR lpszFilename);
static VOID  InitOfn (OPENFILENAME *pofn);
static BOOL  SaveDocIntoFile (PSTR);
static LPOBJ ReadObj (INT fh);



/* CreateDocFromFile
 * -----------------
 *
 * Read a document from the specified file.
 *
 * LPSTR lpszDoc     - Name of the file containing the document
 * LHSERVERDOC lhdoc - Handle to the document
 * DOCTYPE doctype   - In what state the document is created
 *
 * RETURNS: TRUE if successful, FALSE otherwise
 *
 * CUSTOMIZATION: Re-implement
 *                This function will need to be completely re-implemented
 *                to support your application's file format.
 *
 */
BOOL CreateDocFromFile (LPSTR lpszDoc, LHSERVERDOC lhdoc, DOCTYPE doctype)
{
    INT     fh;        // File handle
    HEADER  hdr;
    INT     i;

    if ((fh =_lopen(lpszDoc, OF_READ)) == -1)
        return FALSE;

    // Read header from file.
    if (_lread(fh, (LPSTR) &hdr, (UINT)sizeof(HEADER)) < sizeof (HEADER))
      goto Error;

    // Check to see if file is a server demo file.
    if (lstrcmp(hdr.szSig, szSignature))
      goto Error;

    if (hdr.chDelim1 != chDelim)
      goto Error;

    // Check to see if file was saved under the most recent version.
    // Here is where you would handle reading in old versions.
    if (hdr.version != version)
      goto Error;

    if (hdr.chDelim2 != chDelim)
      goto Error;

    if (!CreateNewDoc (lhdoc, lpszDoc, doctype))
      goto Error;

    // Get the array indicating which object numbers have been used.
    for (i=1; i <= cfObjNums; i++)
      docMain.rgfObjNums[i] = hdr.rgfObjNums[i];

    // Read in object data.
    for (i=0; ReadObj (fh); i++);

    if (!i)
    {
         OLESTATUS olestatus;

         fRevokeSrvrOnSrvrRelease = FALSE;

         if ((olestatus = RevokeDoc()) > OLE_WAIT_FOR_RELEASE)
            goto Error;
         else if (olestatus == OLE_WAIT_FOR_RELEASE)
            Wait (&fWaitingForDocRelease);

         fRevokeSrvrOnSrvrRelease = TRUE;
         EmbeddingModeOff();
         goto Error;
    }

    _lclose(fh);

    fDocChanged = FALSE;
    return TRUE;

Error:
    _lclose(fh);
    return FALSE;

}



/* OpenDoc
 * -------
 *
 * Prompt the user for which document he wants to open
 *
 * RETURNS: TRUE if successful, FALSE otherwise.
 *
 * CUSTOMIZATION: None, except your application may or may not call
 *                CreateNewObj to create a default object.
 *
 */
BOOL OpenDoc (VOID)
{
   CHAR        szDoc[cchFilenameMax];
   BOOL        fUpdateLater;
   OLESTATUS   olestatus;

   if (SaveChangesOption (&fUpdateLater) == IDCANCEL)
      return FALSE;

   if (!GetFileOpenFilename (szDoc))
   {
      if (fUpdateLater)
      {
         // The user chose the "Yes, Update" button but the
         // File Open dialog box failed for some reason
         // (perhaps the user chose Cancel).
         // Even though the user chose "Yes, Update", there is no way
         // to update a client that does not accept updates
         // except when the document is closed.
      }
      return FALSE;
   }

   if (fUpdateLater)
   {
      // The non-standard OLE client did not accept the update when
      // we requested it, so we are sending the client OLE_CLOSED now that
      // we are closing the document.
      SendDocMsg (OLE_CLOSED);
   }

   fRevokeSrvrOnSrvrRelease = FALSE;

   if ((olestatus = RevokeDoc()) > OLE_WAIT_FOR_RELEASE)
      return FALSE;
   else if (olestatus == OLE_WAIT_FOR_RELEASE)
      Wait (&fWaitingForDocRelease);

   fRevokeSrvrOnSrvrRelease = TRUE;
   EmbeddingModeOff();

   if (!CreateDocFromFile (szDoc, 0, doctypeFromFile))
   {
      MessageBox (hwndMain,
                  "Reading from file failed.\r\nFile may not be in proper file format.",
                  szAppName,
                  MB_ICONEXCLAMATION | MB_OK);
      // We already revoked the document, so give the user a new one to edit.
      CreateNewDoc (0, "(Untitled)", doctypeNew);
      CreateNewObj (FALSE);
      return FALSE;
   }
   fDocChanged = FALSE;
   return TRUE;
}



/* ReadObj
 * --------
 *
 * Read the next object from a file, allocate memory for it, and return
 * a pointer to it.
 *
 * int fh - File handle
 *
 * RETURNS: A pointer to the object
 *
 * CUSTOMIZATION: Server Demo specific
 *
 */
static LPOBJ ReadObj (INT fh)
{
    HANDLE hObj = NULL;
    LPOBJ   lpobj = NULL;

    hObj = LocalAlloc (LMEM_MOVEABLE | LMEM_ZEROINIT, sizeof (OBJ));

    if (hObj == NULL)
      return NULL;

    lpobj = (LPOBJ) LocalLock (hObj);

    if (lpobj==NULL)
    {
      LocalFree (hObj);
      return NULL;
    }

    if (_lread(fh, (LPSTR) &lpobj->native, (UINT)sizeof(NATIVE)) < sizeof (NATIVE))
    {
        LocalUnlock (hObj);
        LocalFree (hObj);
        return NULL;
    }

    lpobj->hObj             = hObj;
    lpobj->oleobject.lpvtbl = &objvtbl;
    lpobj->aName            = GlobalAddAtom (lpobj->native.szName);

    if (!CreateWindow(
        "ObjClass",
        "Obj",
        WS_THICKFRAME | WS_BORDER | WS_CHILD | WS_CLIPSIBLINGS | WS_VISIBLE ,
        lpobj->native.nX,
        lpobj->native.nY,
        lpobj->native.nWidth,
        lpobj->native.nHeight,
        hwndMain,
        NULL,
        hInst,
        (LPSTR) lpobj ))
    {
        LocalUnlock (hObj);
        LocalFree (hObj);
        return NULL;
    }

    return lpobj;
}



/* SaveDoc
 * -------
 *
 * Save the document.
 *
 * CUSTOMIZATION: None
 *
 */

BOOL SaveDoc (VOID)
{
    if (docMain.doctype == doctypeNew)
        return SaveDocAs();
    else
    {
        CHAR     szDoc [cchFilenameMax];

        GlobalGetAtomName (docMain.aName, szDoc, cchFilenameMax);
        return SaveDocIntoFile(szDoc);
    }
}



/* SaveDocAs
 * ---------
 *
 * Prompt the user for a filename, and save the document under that filename.
 *
 * RETURNS: TRUE if successful or user chose CANCEL
 *          FALSE if SaveDocIntoFile fails
 *
 * CUSTOMIZATION: None
 *
 */
BOOL SaveDocAs (VOID)
{
   CHAR        szDoc[cchFilenameMax];
   BOOL        fUpdateLater;
   CHAR szDocOld[cchFilenameMax];

   // If document is embedded, give user a chance to update.
   // Save old document name in case the save fails.
   if (!GlobalGetAtomName (docMain.aName, szDocOld, cchFilenameMax))
      ErrorBox ("Fatal Error: Document name is invalid.");

   if (GetFileSaveFilename (szDoc))

   {

      if (docMain.doctype == doctypeEmbedded)
         return SaveDocIntoFile(szDoc);

      if (fUpdateLater)
      {
         // The non-standard OLE client did not accept the update when
         // we requested it, so we are sending the client OLE_CLOSED now that
         // we are closing the document.
         SendDocMsg (OLE_CLOSED);
      }

      // Set the window title bar.
      SetTitle (szDoc, FALSE);
      OleRenameServerDoc(docMain.lhdoc, szDoc);

      if (SaveDocIntoFile(szDoc))
         return TRUE;
      else
      {  // Restore old name
         SetTitle (szDocOld, FALSE);
         OleRenameServerDoc(docMain.lhdoc, szDocOld);
         return FALSE;
      }
   }
   else  // user chose Cancel
      return FALSE;
         // The user chose the "Yes, Update" button but the
         // File Open dialog box failed for some reason
         // (perhaps the user chose Cancel).
         // Even though the user chose "Yes, Update", there is no way
         // to update a non-standard OLE client that does not accept updates
         // except when the document is closed.
}



/* SaveDocIntoFile
 * ---------------
 *
 * Save the document into a file whose name is determined from docMain.aName.
 *
 * RETURNS: TRUE if successful
 *          FALSE otherwise
 *
 * CUSTOMIZATION: Re-implement
 *
 */
static BOOL SaveDocIntoFile (PSTR pDoc)
{
    HWND     hwnd;
    INT      fh;    // File handle
    LPOBJ    lpobj;
    HEADER   hdr;
    INT      i;

    hwnd = GetWindow (hwndMain, GW_CHILD);

    if (!hwnd)
    {
        ErrorBox ("Could not save NULL file.");
        return FALSE;
    }

    // Get document name.
    if ((fh =_lcreat(pDoc, 0)) == -1)
    {
        ErrorBox ("Could not save file.");
        return FALSE;
    }

    // Fill in header.
    lstrcpy (hdr.szSig, szSignature);
    hdr.chDelim1 = chDelim;
    hdr.version  = version;
    hdr.chDelim2 = chDelim;
    for (i=1; i <= cfObjNums; i++)
      hdr.rgfObjNums[i] = docMain.rgfObjNums[i];

    // Write header to file.
    if (_lwrite(fh, (LPSTR) &hdr, (UINT)sizeof(HEADER)) < sizeof(HEADER))
         goto Error; // Error writing file header

    // Write each object's native data.
    while (hwnd)
    {
      lpobj = (LPOBJ) GetWindowLong (hwnd, ibLpobj);
      if (_lwrite(fh, (LPSTR)&lpobj->native, (UINT)sizeof (NATIVE))
          < sizeof(NATIVE))
         goto Error; // Error writing file header

      hwnd = GetWindow (hwnd, GW_HWNDNEXT);
    }
    _lclose(fh);


    if (docMain.doctype != doctypeEmbedded)
    {
         docMain.doctype = doctypeFromFile;
         OleSavedServerDoc(docMain.lhdoc);
         fDocChanged = FALSE;
    }

    return TRUE;

Error:
      _lclose(fh);
      ErrorBox ("Could not save file.");
      return FALSE;

}



/* Common Dialog functions */


/* InitOfn
 * -------
 *
 * Initialize an OPENFILENAME structure with default values.
 * OPENFILENAME is defined in CommDlg.h.
 *
 *
 * CUSTOMIZATION: Change lpstrFilter.  You may also customize the common
 *                dialog box if you wish.  (See the Windows SDK documentation.)
 *
 */
static VOID InitOfn (OPENFILENAME *pofn)
{
   // GetOpenFileName or GetSaveFileName will put the 8.3 filename into
   // szFileTitle[].
   // SrvrDemo does not use this filename, but rather uses the fully qualified
   // pathname in pofn->lpstrFile[].
   static CHAR szFileTitle[13];

   pofn->Flags          = 0;
   pofn->hInstance      = hInst;
   pofn->hwndOwner      = hwndMain;
   pofn->lCustData      = 0;
   pofn->lpfnHook       = NULL;
   pofn->lpstrCustomFilter = NULL;
   pofn->lpstrDefExt    = szDefExt;
   // lpstrFile[] is the initial filespec that appears in the edit control.
   // Must be set to non-NULL before calling the common dialog box function.
   // On return, lpstrFile[] will contain the fully-qualified pathname
   // corresponding to the file the user chose.
   pofn->lpstrFile      = NULL;
   pofn->lpstrFilter    = "Server Demo (*." szDefExt ")\0*." szDefExt "\0" ;
   // lpstrFileTitle[] will contain the user's chosen filename without a path.
   pofn->lpstrFileTitle = szFileTitle;
   pofn->lpstrInitialDir= NULL;
   // Title Bar.  NULL means use default title.
   pofn->lpstrTitle     = NULL;
   pofn->lpTemplateName = NULL;
   pofn->lStructSize    = sizeof (OPENFILENAME);
   pofn->nFilterIndex   = 1L;
   pofn->nFileOffset    = 0;
   pofn->nFileExtension = 0;
   pofn->nMaxFile       = cchFilenameMax;
   pofn->nMaxCustFilter = 0L;
}




/* GetFileOpenFilename
 * -------------------
 *
 * Call the common dialog box function GetOpenFileName to get a file name
 * from the user when the user chooses the "File Open" menu item.
 *
 * LPSTR lpszFilename - will contain the fully-qualified pathname on exit.
 *
 * RETURNS: TRUE if successful, FALSE otherwise.
 *
 * CUSTOMIZATION: None
 *
 */
BOOL GetFileOpenFilename (LPSTR lpszFilename)
{
   OPENFILENAME ofn;
   InitOfn (&ofn);
   ofn.Flags |= OFN_FILEMUSTEXIST | OFN_HIDEREADONLY;
   // Create initial filespec.
   wsprintf (lpszFilename, "*.%s", (LPSTR) szDefExt);
   // Have the common dialog function return the filename in lpszFilename.
   ofn.lpstrFile = lpszFilename;
   if (!GetOpenFileName (&ofn))
      return FALSE;
   return TRUE;
}



/* GetFileSaveFilename
 * -------------------
 *
 * Call the common dialog box function GetSaveFileName to get a file name
 * from the user when the user chooses the "File Save As" menu item, or the
 * "File Save" menu item for an unnamed document.
 *
 * LPSTR lpszFilename - will contain the fully-qualified pathname on exit.
 *
 * RETURNS: TRUE if successful, FALSE otherwise.
 *
 * CUSTOMIZATION: None
 *
 */
BOOL GetFileSaveFilename (LPSTR lpszFilename)
{
   OPENFILENAME ofn;
   InitOfn (&ofn);
   ofn.Flags |= OFN_PATHMUSTEXIST | OFN_HIDEREADONLY;
   // Create initial filespec.
   wsprintf (lpszFilename, "*.%s", (LPSTR) szDefExt);
   // Have the common dialog function return the filename in lpszFilename.
   ofn.lpstrFile = lpszFilename;
   if (!GetSaveFileName (&ofn))
      return FALSE;
   return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\ole1\srvrdemo\obj.c ===
/*
  OLE SERVER DEMO           
  Obj.c             
                                                                     
  This file contains object methods and various object-related support 
  functions.
                                                                     
  (c) Copyright Microsoft Corp. 1990 - 1992 All Rights Reserved   
*/                                                                     

/* 
   Important Note:

   No method should ever dispatch a DDE message or allow a DDE message to
   be dispatched.
   Therefore, no method should ever enter a message dispatch loop.
   Also, a method should not show a dialog or message box, because the 
   processing of the dialog box messages will allow DDE messages to be
   dispatched.
*/


#define SERVERONLY
#include <windows.h>
#include <ole.h>

#include "srvrdemo.h"



// Static functions.
static HBITMAP GetBitmap (LPOBJ lpobj);
static HANDLE  GetLink (LPOBJ lpobj);
static HANDLE  GetMetafilePict (LPOBJ lpobj);
static HANDLE  GetEnhMetafile (LPOBJ lpobj);
static HANDLE  GetNative (LPOBJ lpobj);
static INT     GetObjNum (LPOBJ lpobj);
static HANDLE  GetText (LPOBJ lpobj);
static VOID    DrawObj (HDC hdc, LPOBJ lpobj, RECT rc, INT dctype);



/* CreateNewObj
 * ------------
 *
 * BOOL fDoc_Changed - The new value for the global variable fDocChanged.
 *                     When initializing a new document, we need to create 
 *                     a new object without the creation counting as a 
 *                     change to the document.
 *
 * RETURNS: A pointer to the new object
 *
 * 
 * CUSTOMIZATION: Re-implement
 *                Some applications (like Server Demo) have a finite number of
 *                fixed, distinct, non-overlapping objects.  Other applications
 *                allow the user to create an object from any section of the
 *                document.  For example, the user might select a portion of
 *                a bitmap from a paint program, or a few lines of text from
 *                a word processor.  This latter type of application probably
 *                will not have a function like CreateNewObj.
 *
 */
LPOBJ CreateNewObj (BOOL fDoc_Changed)
{
    HANDLE hObj = NULL;
    LPOBJ  lpobj = NULL;
    // index into an array of flags indicating if that object number is used.
    INT    ifObj = 0;    

    if ((hObj = LocalAlloc (LMEM_MOVEABLE|LMEM_ZEROINIT, sizeof (OBJ))) == NULL)
      return NULL;

    if ((lpobj = (LPOBJ) LocalLock (hObj)) == NULL)
    {
      LocalFree (hObj);
      return NULL;
    }

    // Fill the fields in the object structure.
    
    // Find an unused number.
    for (ifObj=1; ifObj <= cfObjNums; ifObj++)
    {
      if (docMain.rgfObjNums[ifObj]==FALSE)
      {
         docMain.rgfObjNums[ifObj]=TRUE;
         break;
      }
    }

    if (ifObj==cfObjNums+1)
    {
      // Cannot create any more objects.
      MessageBeep(0);
      return NULL;
    }

    wsprintf (lpobj->native.szName, "Object %d", ifObj);

    lpobj->aName            = GlobalAddAtom (lpobj->native.szName);
    lpobj->hObj             = hObj;
    lpobj->oleobject.lpvtbl = &objvtbl;
    lpobj->native.idmColor  = IDM_RED;    // Default color 
    lpobj->native.version   = version;
    lpobj->native.nWidth    = OBJECT_WIDTH;          // Default size
    lpobj->native.nHeight   = OBJECT_HEIGHT;
    SetHiMetricFields (lpobj);

    // Place object in a location corrsponding to its number, for aesthetics.
    lpobj->native.nX = (ifObj - 1) * 20;
    lpobj->native.nY = (ifObj - 1) * 20;

    if (!CreateWindow (
        "ObjClass",
        "Obj",
        WS_BORDER | WS_THICKFRAME | WS_CHILD | WS_CLIPSIBLINGS | WS_VISIBLE,
        lpobj->native.nX,
        lpobj->native.nY,
        lpobj->native.nWidth,
        lpobj->native.nHeight,
        hwndMain,
        NULL,
        hInst,
        (LPSTR) lpobj ))
         return FALSE;

    fDocChanged = fDoc_Changed;

    return lpobj;
}



/* CutOrCopyObj
 * ------------
 *
 * Put data onto clipboard in all the formats supported.  If the 
 * fOpIsCopy is TRUE, the operation is COPY, otherwise it is CUT.
 * This is important, because we cannot put the Object Link format
 * onto the clipboard if the object was cut from the document (there is
 * no longer anything to link to).
 *
 * BOOL fOpIsCopy - TRUE if the operation is COPY; FALSE if CUT
 * 
 * CUSTOMIZATION: None
 *
 *
 */
VOID CutOrCopyObj (BOOL fOpIsCopy)
{
    LPOBJ       lpobj;
    HANDLE      hData;
//	 UINT     hBit;

    if (OpenClipboard (hwndMain))
    {
        EmptyClipboard ();

        lpobj = SelectedObject();

        if ((hData = GetNative (lpobj)) != NULL)
            SetClipboardData(cfNative, hData);

        if ((hData = GetLink(lpobj)) != NULL)
            SetClipboardData(cfOwnerLink, hData);

        if (fOpIsCopy && docMain.doctype == doctypeFromFile)
        {
            // Can create a link if object exists in a file.
            if ((hData = GetLink(lpobj)) != NULL)
               SetClipboardData(cfObjectLink, hData);
        }

        if ((hData = GetEnhMetafile(lpobj)) != NULL)
        {
            SetClipboardData(CF_ENHMETAFILE, hData);
              GlobalFree(hData);
        }

        if ((hData = GetBitmap(lpobj)) != NULL)
        {
        //	  SetClipboardData(CF_BITMAP, GetBitmap(lpobj));
              SetClipboardData(CF_BITMAP, hData);
              DeleteObject(hData);
        }


        CloseClipboard ();
    }
}


/* DestroyObj
 * ----------
 *
 * Revoke an object, and free all memory that had been allocated for it.
 *
 * HWND hwnd - The object's window
 * 
 * CUSTOMIZATION: Re-implement, making sure you free all the memory that
 *                had been allocated for the OBJ structure and each of its
 *                fields.
 * 
 */
VOID DestroyObj (HWND hwnd)
{
   LPOBJ lpobj = HwndToLpobj (hwnd);

   if(lpobj->aName)
   {
      GlobalDeleteAtom (lpobj->aName);
      lpobj->aName = '\0';
   }

   if (lpobj->hpal) 
      DeleteObject (lpobj->hpal);
   // Allow the object's number to be reused.
   docMain.rgfObjNums [GetObjNum(lpobj)] = FALSE;


   // Free the memory that had been allocated for the object structure itself.
   LocalUnlock (lpobj->hObj);
   LocalFree (lpobj->hObj);
}



/* DrawObj
 * -------
 *
 * This function draws an object onto the screen, into a metafile, or into
 * a bitmap.
 * The object will always look the same.
 *
 * HDC    hdc    - The device context to render the object into
 * LPOBJ  lpobj  - The object to render
 * RECT   rc     - The rectangle bounds of the object
 * DCTYPE dctype - The type of device context.
 * 
 * CUSTOMIZATION: Server Demo specific
 *
 */
static VOID DrawObj (HDC hdc, LPOBJ lpobj, RECT rc, INT dctype)
{
   HPEN     hpen;
   HPEN     hpenOld;
   HPALETTE hpalOld = NULL;


   if (dctype == dctypeMetafile)
   {
      SetWindowOrgEx (hdc, 0, 0, NULL);
      // Paint entire object into the given rectangle.
      SetWindowExtEx (hdc, rc.right, rc.bottom, NULL);
   }
 
   if (lpobj->hpal)
   {
      hpalOld = SelectPalette (hdc, lpobj->hpal, TRUE);
      RealizePalette (hdc);
   }

   // Select brush of the color specified in the native data.
   SelectObject (hdc, hbrColor [lpobj->native.idmColor - IDM_RED] );

   hpen = CreatePen (PS_SOLID, 
                     /* Width */ (rc.bottom-rc.top) / 10,
                     /* Gray */ 0x00808080);
   hpenOld = SelectObject (hdc, hpen);

   // Draw rectangle with the gray pen and fill it in with the selected brush.
   Rectangle(hdc, rc.left, rc.top, rc.right, rc.bottom);

   // Print name of object inside rectangle.
   SetBkMode (hdc, TRANSPARENT);
   SetTextAlign (hdc, TA_BASELINE | TA_CENTER);
   TextOut (hdc, 
            rc.right/2, 
            (rc.top+rc.bottom)/2, 
            lpobj->native.szName, 
            lstrlen (lpobj->native.szName));

   // Restore original objects
   SelectObject (hdc, 
                 (dctype == dctypeMetafile || dctype == dctypeEnhMetafile) 
                     ? GetStockObject (BLACK_PEN) : hpenOld);
   if (hpalOld)
   {
      SelectPalette (hdc, 
                     (dctype == dctypeMetafile || dctype == dctypeEnhMetafile) 
                        ? GetStockObject (DEFAULT_PALETTE) : hpalOld,
                     TRUE);
   }

   DeleteObject (hpen);
}



/* GetBitmap
 * ---------
 *
 * Return a handle to an object's picture data in bitmap format.
 *
 * LPOBJ lpobj - The object
 * 
 * RETURNS: A handle to the object's picture data
 * 
 * CUSTOMIZATION: Re-implement
 * 
 */
static HBITMAP GetBitmap (LPOBJ lpobj)
{
    HDC         hdcObj;
    HDC         hdcMem;
    RECT        rc;
    HBITMAP     hbitmap;
    HBITMAP    hbitmapOld;


    hdcObj = GetDC (lpobj->hwnd);
    // Create a memory device context.
    hdcMem = CreateCompatibleDC (hdcObj);
    GetClientRect (lpobj->hwnd, (LPRECT)&rc);
    // Create new bitmap object based on the bitmap of the OLE object.
    hbitmap = CreateCompatibleBitmap 
      (hdcObj, rc.right - rc.left, rc.bottom - rc.top);
    // Select new bitmap as the bitmap object for the memory device context.
    hbitmapOld = SelectObject (hdcMem, hbitmap);

    // Paint directly into the memory dc using the new bitmap object.
    DrawObj (hdcMem, lpobj, rc, dctypeBitmap);

    // Restore old bitmap object.
    hbitmap = SelectObject (hdcMem, hbitmapOld);
    DeleteDC (hdcMem);
    ReleaseDC (lpobj->hwnd, hdcObj);

    // convert width and height to HIMETRIC units
    rc.right  = rc.right - rc.left;
    rc.bottom = rc.bottom - rc.top;
    DeviceToHiMetric ( (LPPOINT) &rc.right );
    
    // Set the 1/10 of HIMETRIC units for the bitmap
    SetBitmapDimensionEx (hbitmap, (DWORD) (rc.right/10), (DWORD) (rc.bottom/10), NULL);

//    if (OpenClipboard (hwndMain))
//    {
//  //      EmptyClipboard ();
//          SetClipboardData(CF_BITMAP, hbitmap);
//          CloseClipboard();
//    }
	 return hbitmap;
}



/* GetLink
 * -------
 *
 * Return a handle to an object's object or owner link data.
 * Link information is in the form of three zero-separated strings,
 * terminated with two zero bytes:  CLASSNAME\0DOCNAME\0OBJNAME\0\0
 *
 * LPOBJ lpobj - The object 
 * 
 * RETURNS: A handle to the object's link data
 * 
 * CUSTOMIZATION: Re-implement
 *
 */
static HANDLE GetLink (LPOBJ lpobj)
{

    CHAR   sz[cchFilenameMax];
    LPSTR  lpszLink = NULL;
    HANDLE hLink = NULL;
    INT    cchLen;
    INT    i;

    // First make the class name.
    lstrcpy (sz, szClassName);
    cchLen = lstrlen (sz) + 1;

    // Then the document name.
    cchLen += GlobalGetAtomName 
               (docMain.aName, (LPSTR)sz + cchLen, 
                cchFilenameMax - cchLen) + 1;

    // Then the object name.
    lstrcpy (sz + cchLen, lpobj->native.szName);
    cchLen += lstrlen (lpobj->native.szName) + 1;

    // Add a second null to the end.
    sz[cchLen++] = 0;       


    hLink = GlobalAlloc (GMEM_DDESHARE | GMEM_ZEROINIT, cchLen);
    if (hLink == NULL)
      return NULL;
    if ((lpszLink = GlobalLock (hLink)) == NULL)
    {
      GlobalFree (hLink);
      return NULL;
    }

    for (i=0; i < cchLen; i++)
        lpszLink[i] = sz[i];

    GlobalUnlock (hLink);

    return hLink;
}



/* GetMetafilePict
 * ---------------
 *
 * Return a handle to an object's picture data in metafile format.
 *
 * LPOBJ lpobj - The object
 * 
 * RETURNS: A handle to the object's data in metafile format.
 *
 * CUSTOMIZATION: Re-implement
 *
 */
static HANDLE GetMetafilePict (LPOBJ lpobj)
{

    LPMETAFILEPICT  lppict = NULL;
    HANDLE          hpict = NULL;
    HANDLE          hMF = NULL;
    RECT            rc;
    HDC             hdc;

    hdc = CreateMetaFile(NULL);

    GetClientRect (lpobj->hwnd, (LPRECT)&rc);

    // Paint directly into the metafile.
    DrawObj (hdc, lpobj, rc, dctypeMetafile);

    // Get handle to the metafile.
    if ((hMF = CloseMetaFile (hdc)) == NULL)
      return NULL;

    if(!(hpict = GlobalAlloc (GMEM_DDESHARE, sizeof (METAFILEPICT))))
    {
        DeleteMetaFile (hMF);
        return NULL;
    }

    if ((lppict = (LPMETAFILEPICT)GlobalLock (hpict)) == NULL)
    {
        DeleteMetaFile (hMF);
        GlobalFree (hpict);
        return NULL;
    }

    rc.right  = rc.right - rc.left;
    rc.bottom = rc.bottom - rc.top;
    
    DeviceToHiMetric ( (LPPOINT) &rc.right);

    lppict->mm   =  MM_ANISOTROPIC;
    lppict->hMF  =  hMF;
    lppict->xExt =  rc.right;
    lppict->yExt =  rc.bottom;
    GlobalUnlock (hpict);
    return hpict;
}

/* GetEnhMetafile
 * ---------------
 *
 * Return a handle to an object's picture data in metafile format.
 *
 * LPOBJ lpobj - The object
 * 
 * RETURNS: A handle to the object's data in metafile format.
 *
 * CUSTOMIZATION: Re-implement
 *
 */
static HANDLE GetEnhMetafile (LPOBJ lpobj)
{

    LPMETAFILEPICT  lppict = NULL;
    HANDLE          hemf   = NULL;
    HANDLE          hMF    = NULL;
    RECT            rc;
    HDC             hdc, hdc2;


    GetClientRect (lpobj->hwnd, (LPRECT)&rc);

    rc.right   -= rc.left;
    rc.bottom  -= rc.top;
    rc.left     = rc.top  = 0;
	 
    DeviceToHiMetric ( (LPPOINT) &rc.right );
	 
    hdc = CreateEnhMetaFile ( NULL, NULL, &rc, NULL );
    
                                       //* this is necessary because
                                       //* we need to draw the object
                                       //* in device coordinates that are
                                       //* the same physical size as the HIMETRIC
                                       //* logical space used in CreateEnhMetaFile.
                                       //* In this case we have scaled the HIMETRIC
                                       //* units down in order to use the logical
                                       //* pixel ratio (which is recommended UI)
                                       //* so we therefore have to convert the
                                       //* scaled HIMETRIC units back to Device.
                                      
    hdc2 = GetDC(NULL);				

    SetMapMode(hdc2, MM_HIMETRIC);
    LPtoDP (hdc2, (LPPOINT)&rc.right, 1);
    if (rc.bottom < 0) rc.bottom *= -1;

    ReleaseDC(NULL,hdc2);

	DrawObj (hdc, lpobj, rc, dctypeMetafile);

    if ((hemf = (HANDLE)CloseEnhMetaFile (hdc)) == NULL)
      return NULL;

    return hemf;
}


/* GetNative
 * ---------
 *
 * Return a handle to an object's native data.
 *
 * LPOBJ lpobj - The object whose native data is to be retrieved.
 * 
 * RETURNS: a handle to the object's native data.
 *
 * CUSTOMIZATION: The line "*lpnative = lpobj->native;" will change to 
 *                whatever code is necessary to copy an object's native data.
 *
 */
static HANDLE GetNative (LPOBJ lpobj)
{
   LPNATIVE lpnative = NULL;
   HANDLE   hNative  = NULL;

   hNative = GlobalAlloc (GMEM_DDESHARE | GMEM_ZEROINIT, sizeof (NATIVE));
   if (hNative == NULL)
      return NULL;
   if ((lpnative = (LPNATIVE) GlobalLock (hNative)) == NULL)
   {
      GlobalFree (hNative);
      return NULL;
   }

   // Copy the native data.
   *lpnative = lpobj->native;

   GlobalUnlock (hNative);
   return hNative;
}



/* GetObjNum
 * ---------
 *
 * LPSTR lpobj - The object whose number is desired
 *
 * RETURNS: The number of the object, i.e., the numerical portion of its name.
 *
 * CUSTOMIZATION: Server Demo specific
 */
static INT GetObjNum (LPOBJ lpobj)
{
   LPSTR lpsz;
   INT n=0;

   lpsz = lpobj->native.szName + 7;
   while (*lpsz && *lpsz>='0' && *lpsz<='9')
      n = 10*n + *lpsz++ - '0';
   return n;
}



/* GetText
 * -------
 *
 * Return a handle to an object's data in text form.
 * This function simply returns the name of the object.
 *
 * LPOBJ lpobj - The object
 * 
 * RETURNS: A handle to the object's text.
 *
 * CUSTOMIZATION: Re-implement, if your application supports CF_TEXT as a 
 *                presentation format.
 *
 */
static HANDLE GetText (LPOBJ lpobj)
{
    HANDLE hText    = NULL;
    LPSTR  lpszText = NULL;

    if(!(hText = GlobalAlloc (GMEM_DDESHARE, sizeof (lpobj->native.szName))))
      return NULL;

    if (!(lpszText = GlobalLock (hText)))
      return NULL;

    lstrcpy (lpszText, lpobj->native.szName);

    GlobalUnlock (hText);

    return hText;
}



/* ObjDoVerb                OBJECT "DoVerb" METHOD
 * ---------
 *
 * This method is called by the client, through the library, to either
 * PLAY, or EDIT the object.  PLAY is implemented as a beep, and
 * EDIT will bring up the server and show the object for editing.
 *
 * LPOLEOBJECT lpoleobject - The OLE object
 * WORD wVerb              - The verb acting on the object: PLAY or EDIT
 * BOOL fShow              - Should the object be shown?
 * BOOL fTakeFocus         - Should the object window get the focus?
 * 
 * RETURNS:        OLE_OK
 *
 * CUSTOMIZATION: Add any more verbs your application supports.
 *                Implement verbPlay if your application supports it.
 *
 */
OLESTATUS  APIENTRY ObjDoVerb 
   (LPOLEOBJECT lpoleobject, UINT wVerb, BOOL fShow, BOOL fTakeFocus)
{
    switch (wVerb) 
    {
         case verbPlay:
         {  // The application can do whatever is appropriate for the object.
            INT i;
            for (i=0; i<25;i++) MessageBeep (0);
            return OLE_OK;
         }

         case verbEdit:
            if (fShow)
               return objvtbl.Show (lpoleobject, fTakeFocus);
            else
               return OLE_OK;
         default:
            // Unknown verb.
            return OLE_ERROR_DOVERB;
    }
}



/* ObjEnumFormats        OBJECT "EnumFormats" METHOD
 * ---------------
 *
 * This method is used to enumerate all supported clipboard formats.
 * Terminate by returning NULL.
 *
 * LPOLEOBJECT lpoleobject - The OLE object
 * OLECLIPFORMAT cfFormat  - The 'current' clipboard format
 * 
 * RETURNS: The 'next' clipboard format which is supported.
 *
 * CUSTOMIZATION: Verify that the list of formats this function 
 *                returns matches the list of formats your application 
 *                supports.
 *
 */
OLECLIPFORMAT  APIENTRY ObjEnumFormats
   (LPOLEOBJECT lpoleobject, OLECLIPFORMAT cfFormat)
{
      if (cfFormat == 0)
        return cfNative;

      if (cfFormat == cfNative)
         return cfOwnerLink;

      if (cfFormat == cfOwnerLink)
         return CF_ENHMETAFILE;

      if (cfFormat == CF_ENHMETAFILE)
         return CF_METAFILEPICT;

      if (cfFormat == CF_METAFILEPICT)
         return CF_BITMAP;

      if (cfFormat == CF_BITMAP)
         return cfObjectLink;

      if (cfFormat == cfObjectLink)
         return 0;

      return 0;
}



/* ObjGetData                OBJECT "GetData" METHOD
 * -----------
 *
 * Return the data requested for the specified object in the specified format.
 *
 * LPOLEOBJECT lpoleobject - The OLE object
 * WORD cfFormat           - The data type requested in standard
 *                           clipboard format
 * LPHANDLE lphandle       - Pointer to handle to memory where data
 *                           will be stored
 * 
 * RETURNS: OLE_OK           if successful
 *          OLE_ERROR_MEMORY if there was an error getting the data.
 *          OLE_ERROR_FORMAT if the requested format is unknown.
 *
 * 
 * CUSTOMIZATION: Add any additional formats your application supports, and
 *                remove any formats it does not support.
 *
 */
OLESTATUS  APIENTRY ObjGetData
   (LPOLEOBJECT lpoleobject, OLECLIPFORMAT cfFormat, LPHANDLE lphandle)
{

   LPOBJ lpobj;

   lpobj = (LPOBJ) lpoleobject;

   if (cfFormat ==  cfNative)
   {
      if (!(*lphandle = GetNative (lpobj)))
         return OLE_ERROR_MEMORY;
      // The client has requested the data in native format, therefore
      // the data in the client and server are in sync.
      fDocChanged = FALSE;
      return OLE_OK; 
   }                

   if (cfFormat == CF_ENHMETAFILE)
   {
      if (!(*lphandle = GetEnhMetafile (lpobj)))
         return OLE_ERROR_MEMORY;
      return OLE_OK; 
   }

   if (cfFormat == CF_METAFILEPICT)
   {
      if (!(*lphandle = GetMetafilePict (lpobj)))
         return OLE_ERROR_MEMORY;
      return OLE_OK; 
   }

   if (cfFormat == CF_BITMAP)
   {
      if (!(*lphandle = (HANDLE)GetBitmap (lpobj)))
         return OLE_ERROR_MEMORY;
      return OLE_OK; 
   }

   if (cfFormat == CF_TEXT) 
   {
      if (!(*lphandle = GetText (lpobj)))
         return OLE_ERROR_MEMORY;
      return OLE_OK; 
   }

   if (cfFormat == cfObjectLink)
   {
      if (!(*lphandle = GetLink (lpobj)))
         return OLE_ERROR_MEMORY;
      return OLE_OK; 
   }

   if (cfFormat ==  cfOwnerLink)
   {
      if (!(*lphandle = GetLink (lpobj)))
         return OLE_ERROR_MEMORY;
      return OLE_OK; 
   }

   return OLE_ERROR_FORMAT;
}



/* ObjQueryProtocol                OBJECT "QueryProtocol" METHOD
 * ----------------
 *
 * LPOLEOBJECT lpoleobject - The OLE object
 * OLE_LPCSTR lpszProtocol      - The protocol name, either "StdFileEditing"
 *                           or "StdExecute"
 * 
 * RETURNS: If lpszProtocol is supported, return a pointer to an OLEOBJECT 
 *          structure with an appropriate method table for that protocol.
 *          Otherwise, return NULL.
 *
 * CUSTOMIZATION: Allow any additional protocols your application supports.
 *
 *
 */
LPVOID  APIENTRY ObjQueryProtocol 
   (LPOLEOBJECT lpoleobject, OLE_LPCSTR lpszProtocol)
{
   return lstrcmp (lpszProtocol, "StdFileEditing") ? NULL : lpoleobject ;
}



/* ObjRelease                OBJECT "Release" METHOD
 * -----------
 *
 * The server application should not destroy data when the library calls the 
 * ReleaseObj method.
 * The library calls the ReleaseObj method when no clients are connected 
 * to the object.
 *
 * LPOLEOBJECT lpoleobject - The OLE object
 * 
 * RETURNS: OLE_OK
 * 
 * CUSTOMIZATION: Re-implement.  Do whatever needs to be done, if anything,
 *                when no clients are connected to an object.
 *
 */
OLESTATUS  APIENTRY ObjRelease (LPOLEOBJECT lpoleobject)
{
   INT i;
   /* No client is connected to the object so break all assocaiations
      between clients and the object. */
   for (i=0; i < clpoleclient; i++)
      ((LPOBJ)lpoleobject)->lpoleclient[i] = NULL;
   return OLE_OK;
}



/* ObjSetBounds        OBJECT "SetBounds" METHOD
 * ------------
 *
 * This method is called to set new bounds for an object.
 * The bounds are in HIMETRIC units.
 * A call to this method is ignored for linked objects because the size of
 * a linked object depends only on the source file.
 *
 * LPOLEOBJECT lpoleobject - The OLE object
 * OLE_CONST RECT FAR* lprect           - The new bounds
 * 
 * RETURNS: OLE_OK
 *
 * CUSTOMIZATION: Re-implement
 *                How an object is sized is application-specific. (Server Demo
 *                uses MoveWindow.)
 *
 */
OLESTATUS  APIENTRY ObjSetBounds (LPOLEOBJECT lpoleobj, OLE_CONST RECT FAR * lprect)
{
   if (docMain.doctype == doctypeEmbedded)
   {
      RECT rect = *lprect;
      LPOBJ lpobj = (LPOBJ) lpoleobj;
      
      // the units are in HIMETRIC
      rect.right   = rect.right - rect.left;
      rect.bottom  = rect.top - rect.bottom;
      HiMetricToDevice ( (LPPOINT) &rect.right);
      MoveWindow (lpobj->hwnd, lpobj->native.nX, lpobj->native.nY, 
                  rect.right + 2 * GetSystemMetrics(SM_CXFRAME), 
                  rect.bottom + 2 * GetSystemMetrics(SM_CYFRAME), 
                  TRUE);
   }
   return OLE_OK;
}



/* ObjSetColorScheme                OBJECT "SetColorScheme" METHOD
 * -----------------
 *
 * The client calls this method to suggest a color scheme (palette) for
 * the server to use for the object.
 *
 * LPOLEOBJECT  lpoleobject       - The OLE object
 * OLE_CONST LOGPALETTE FAR * lppal             - Suggested palette
 *
 * RETURNS: OLE_ERROR_PALETTE if CreatePalette fails, 
 *          OLE_OK otherwise
 *
 * 
 * CUSTOMIZATION: If your application supports color schemes, then this 
 *                function is a good example of how to create and store
 *                a palette.
 *
 */
OLESTATUS  APIENTRY ObjSetColorScheme 
   (LPOLEOBJECT lpoleobject, OLE_CONST LOGPALETTE FAR *lppal)
{
   HPALETTE hpal = CreatePalette (lppal);
   LPOBJ lpobj   = (LPOBJ) lpoleobject;

   if (hpal==NULL)
      return OLE_ERROR_PALETTE;

   if (lpobj->hpal) 
      DeleteObject (lpobj->hpal);
   lpobj->hpal = hpal;
   return OLE_OK;
}



/* ObjSetData                OBJECT "SetData" METHOD
 * ----------
 *
 * This method is used to store data into the object in the specified
 * format.  This will be called with Native format after an embedded
 * object has been opened by the Edit method.
 *
 * LPOLEOBJECT lpoleobject      - The OLE object
 * WORD cfFormat                - Data type, i.e., clipboard format
 * HANDLE hdata                 - Handle to the data.
 * 
 * RETURNS:       OLE_OK if the data was stored properly
 *                OLE_ERROR_FORMAT if format was not cfNative.
 *                OLE_ERROR_MEMORY if memory could not be locked.
 * 
 * CUSTOMIZATION: The large then-clause will need to be re-implemented for
 *                your application.  You may wish to support additional
 *                formats besides cfNative.
 *
 */
OLESTATUS  APIENTRY ObjSetData 
   (LPOLEOBJECT lpoleobject, OLECLIPFORMAT cfFormat, HANDLE hdata)
{
    LPNATIVE lpnative;
    LPOBJ    lpobj;

    lpobj = (LPOBJ)lpoleobject;

    if (cfFormat != cfNative)
    {
      return OLE_ERROR_FORMAT;
    }

    lpnative = (LPNATIVE) GlobalLock (hdata);

    if (lpnative)
    {
        lpobj->native = *lpnative;
        if (lpobj->aName)
            GlobalDeleteAtom (lpobj->aName);
        lpobj->aName = GlobalAddAtom (lpnative->szName);
        // CreateNewObj made an "Object 1" but we may be changing its number.
        docMain.rgfObjNums[1] = FALSE;
        docMain.rgfObjNums [GetObjNum(lpobj)] = TRUE;

        MoveWindow (lpobj->hwnd, 0, 0,
//                    lpobj->native.nWidth + 2 * GetSystemMetrics(SM_CXFRAME), 
//                    lpobj->native.nHeight+ 2 * GetSystemMetrics(SM_CYFRAME),
                    lpobj->native.nWidth, 
                    lpobj->native.nHeight,

                    FALSE);
        GlobalUnlock (hdata);
    }
    // Server is responsible for deleting the data.
    GlobalFree(hdata);           
    return lpnative ? OLE_OK : OLE_ERROR_MEMORY;
}



/* ObjSetTargetDevice        OBJECT "SetTargetDevice" METHOD
 * -------------------
 *
 * This method is used to indicate the device type that an object
 * will be rendered on.  It is the server's responsibility to free hdata.
 *
 * LPOLEOBJECT lpoleobject - The OLE object
 * HANDLE hdata            - Handle to memory containing
 *                           a StdTargetDevice structure
 * 
 * RETURNS: OLE_OK
 * 
 * CUSTOMIZATION: Implement.  Server Demo currently does not do anything.
 *
 */
OLESTATUS  APIENTRY ObjSetTargetDevice (LPOLEOBJECT lpoleobject, HANDLE hdata)
{
    if (hdata == NULL)
    {
      // Rendering for the screen is requested.
    }
    else
    {
      LPSTR lpstd = (LPSTR) GlobalLock (hdata);
      // lpstd points to a StdTargetDevice structure.
      // Use it to do whatever is appropriate to generate the best results 
      // on the specified target device.
      GlobalUnlock (hdata);
      // Server is responsible for freeing the data.
      GlobalFree (hdata);  
    }
    return OLE_OK;
}



/* ObjShow                OBJECT "Show" METHOD
 * --------
 *
 * This method is used to display the object.  
 * The server application should be activated and brought to the top.
 * Also, in a REAL server application, the object should be scrolled
 * into view.  The object should be selected.
 *
 * LPOLEOBJECT lpoleobject - Pointer to the OLE object
 * BOOL fTakeFocus         - Should server window get the focus?
 * 
 * RETURNS:        OLE_OK
 *
 * 
 * CUSTOMIZATION: In your application, the document should be scrolled 
 *                to bring the object into view.  Server Demo brings the 
 *                object to the front, in case it is a linked object inside a 
 *                document with other objects obscuring it.
 *
 */
OLESTATUS  APIENTRY ObjShow (LPOLEOBJECT lpoleobject, BOOL fTakeFocus)
{
    LPOBJ lpobj;
    HWND hwndOldFocus;

    hwndOldFocus = GetFocus();
    lpobj = (LPOBJ) lpoleobject;
    
    if (fTakeFocus)
       SetForegroundWindow (lpobj->hwnd);

    ShowWindow(hwndMain, SW_SHOWNORMAL);

    SetFocus (fTakeFocus ? lpobj->hwnd : hwndOldFocus);
    return OLE_OK;
}



/* PaintObj
 * ---------
 *
 * This function is called by the WM_PAINT message to paint an object 
 * on the screen.  
 *
 * HWND hwnd - The object window in which to paint the object
 *
 * CUSTOMIZATION: Server Demo specific
 *
 */
VOID PaintObj (HWND hwnd)
{
    LPOBJ       lpobj;
    RECT        rc;
    HDC         hdc;
    PAINTSTRUCT paintstruct;

    BeginPaint (hwnd, &paintstruct);
    hdc = GetDC (hwnd);

    lpobj = HwndToLpobj (hwnd);
    GetClientRect (hwnd, (LPRECT) &rc);

    DrawObj (hdc, lpobj, rc, dctypeScreen);

    ReleaseDC (hwnd, hdc);
    EndPaint (hwnd, &paintstruct);
}



/* RevokeObj
 * ---------
 *
 * Call OleRevokeObject because the user has destroyed the object.
 *
 * LPOBJ lpobj - The object which has been destroyed
 *
 * 
 * CUSTOMIZATION: You will only need to call OleRevokeObject once if there
 *                is only one LPOLECLIENT in your OBJ structure, which there
 *                should be.
 *
 */
VOID RevokeObj (LPOBJ lpobj)
{
   INT i;

   for (i=0; i< clpoleclient; i++)
   {
      if (lpobj->lpoleclient[i])
         OleRevokeObject (lpobj->lpoleclient[i]);
      else 
         /* if lpobj->lpoleclient[i]==NULL then there are no more non-NULLs
            in the array. */
         break;
   }
}



/* SendObjMsg
 * ----------
 *
 * This function sends a message to a specific object.
 *
 * LPOBJ lpobj   - The object
 * WORD wMessage - The message to send
 * 
 * CUSTOMIZATION: You will only need to call CallBack once if there
 *                is only one LPOLECLIENT in your OBJ structure, which there
 *                should be.
 *
 */
VOID SendObjMsg (LPOBJ lpobj, WORD wMessage)
{
   INT i;
   for (i=0; i < clpoleclient; i++)
   {
      if (lpobj->lpoleclient[i])
      {
         // Call the object's Callback function.
         lpobj->lpoleclient[i]->lpvtbl->CallBack 
            (lpobj->lpoleclient[i], wMessage, (LPOLEOBJECT) lpobj);
      }
      else
         break;
   }
}



/* SizeObj
 * -------
 *
 * Change the size of an object.
 *
 * HWND hwnd  - The object's window
 * RECT rect  - The requested new size in device units
 * BOOL fMove - Should the object be moved? (or just resized?)
 *
 * CUSTOMIZATION: Server Demo specific
 *
 */
VOID SizeObj (HWND hwnd, RECT rect, BOOL fMove)
{
   LPOBJ lpobj;

   lpobj = HwndToLpobj (hwnd);
   if (fMove)
   {
      lpobj->native.nX   = rect.left;
      lpobj->native.nY   = rect.top;
   }
   lpobj->native.nWidth  = rect.right  - rect.left;
   lpobj->native.nHeight = rect.bottom - rect.top ;
   SetHiMetricFields (lpobj);
   InvalidateRect (hwnd, (LPRECT)NULL, TRUE);
   fDocChanged = TRUE;
   if (docMain.doctype == doctypeFromFile)
   {
      // If object is linked, update it in client now. 
      SendObjMsg (lpobj, OLE_CHANGED);
   }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\olebind\tmalloc.cxx ===
#include    <windows.h>
#include    <stdio.h>
#include    <ole2.h>
#include    <olebind.hxx>

BOOL TestStdMalloc(void)
{
    // Get the allocator
    IMalloc *pIMalloc;
    HRESULT hr = CoGetMalloc(MEMCTX_TASK, &pIMalloc);

    TEST_FAILED_HR(FAILED(hr), "CoGetMalloc failed");

    // Test AddRef/Release
    ULONG cOrigRefs = pIMalloc->AddRef();

#ifdef WIN32
    //  On Win32, we only guarantee that the reference count will be either
    //  zero (if we released the object) or nonzero (if we didn't)
    TEST_FAILED((pIMalloc->Release() == 0),
	"IMalloc: Wrong refcount");
#else
    TEST_FAILED((pIMalloc->Release() != cOrigRefs - 1),
	"IMalloc: Wrong refcount");
#endif

    // Test query interface
    IUnknown *punk;

    hr = pIMalloc->QueryInterface(IID_IMalloc, (void **) &punk);

    TEST_FAILED_HR(FAILED(hr), "IMalloc QueryInterface failed");

    punk->Release();

    // Test allocation
    BYTE *pb = (BYTE *) pIMalloc->Alloc(2048);

    // Test get size
    TEST_FAILED((pIMalloc->GetSize(pb) < 2048), "GetSize failed");

    TEST_FAILED((pb == NULL), "Alloc returned NULL");

    for (int i = 0; i < 2048; i++)
    {
	pb[i] = 'A';
    }

    // Test reallocation to larger buffer
    pb = (BYTE *) pIMalloc->Realloc(pb, 4096);

    TEST_FAILED((pb == NULL), "Realloc larger returned NULL");

    for (i = 0; i < 2048; i++)
    {
	TEST_FAILED((pb[i] != 'A'), "Buffer corrupt on larger realloc");
    }

    // Test reallocation to smaller buffer
    pb = (BYTE *) pIMalloc->Realloc(pb, 990);

    TEST_FAILED((pb == NULL), "Realloc smaller returned NULL");

    for (i = 0; i < 990; i++)
    {
	TEST_FAILED((pb[i] != 'A'), "Buffer corrupt on smaller realloc");
    }

    // Test get size (size is allowed to be larger, but not smaller)
    TEST_FAILED((pIMalloc->GetSize(pb) < 990), "GetSize failed");

    // Test DidAllocate
    TEST_FAILED((pIMalloc->DidAlloc(pb) == 0), "Didalloc failed");

    // Test freeing the buffer
    pIMalloc->Free(pb);

    // Do last release
    pIMalloc->Release();

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\olebind\rot.cxx ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:	rotut.cxx
//
//  Contents:	Unit Test for ROT
//
//  Classes:	MISSING
//
//  Functions:	MISSING
//
//  History:	16-Oct-93 Ricksa    Created
//              31-Dec-93 ErikGav   Chicago port
//
//--------------------------------------------------------------------------
#include    <windows.h>
#include    <ole2.h>
#include    <olebind.hxx>
#include    <stdio.h>


class CRotTestObject : public IUnknown
{
public:
			CRotTestObject(WCHAR *pwszID);

    // IUnknown Interface
    STDMETHOD(QueryInterface)(REFIID riid, void **ppv);

    STDMETHOD_(ULONG, AddRef)(void);

    STDMETHOD_(ULONG, Release)(void);

private:

    WCHAR		_awcID[256];

    ULONG		_cRefs;

};




CRotTestObject::CRotTestObject(WCHAR *pwszID) : _cRefs(1)
{
    wcscpy(_awcID, pwszID);
}




STDMETHODIMP CRotTestObject::QueryInterface(REFIID riid, void **ppv)
{
    if (memcmp((void *) &riid, (void *) &IID_IUnknown, sizeof(GUID)) == 0)
    {
	_cRefs++;
	*ppv = (IUnknown *) this;
	return S_OK;
    }

    *ppv = NULL;
    return E_NOINTERFACE;
}



STDMETHODIMP_(ULONG) CRotTestObject::AddRef(void)
{
    _cRefs++;
    return (ULONG) _awcID;
}



STDMETHODIMP_(ULONG) CRotTestObject::Release(void)
{
    ULONG cRefs = --_cRefs;

    if (cRefs == 0)
    {
	delete this;
    }

    return cRefs;
}



//
//	Test Running Object Table
//
//  BUGBUG: Need to test enumerator
BOOL TestROT(REFCLSID clsid)
{
    XUnknown		 punk2;
    XMoniker		 pmk;
    XMoniker		 pmk2;
    XRunningObjectTable  prot;
    XEnumMoniker	 penummk;


    HRESULT hr = GetRunningObjectTable(0, &prot);

    TEST_FAILED_HR(FAILED(hr), "GetRunningObjectTable failed!")

    // Make sure that we can do something on the pointer that
    // we got back.
    prot->AddRef();
    prot->Release();

    // Create an IUnknown pointer for the class.
    IUnknown *punk = new CRotTestObject(L"First Test Object");

    hr = CreateItemMoniker(L"\\", wszPid, &pmk2);

    TEST_FAILED_HR(FAILED(hr), "CreateItemMoniker for \\Bob failed")

    // Do a get object to make sure that this is not in the ROT already

    hr = prot->GetObject(pmk2, &punk2);

    TEST_FAILED_HR(SUCCEEDED(hr), "GetObject on nonexistent succeeded")

    // Cookie for deregistering object
    DWORD dwRegister;

    hr = prot->Register(0, punk, pmk2, &dwRegister);

    TEST_FAILED_HR(FAILED(hr), "Register in ROT for \\PID failed")

    hr = prot->IsRunning(pmk2);

    TEST_FAILED_HR((hr != S_OK),
	"Unexpected return from IsRunning")

    // Test Get Object
    hr = prot->GetObject(pmk2, &punk2);

    TEST_FAILED_HR((hr != S_OK), "Unexpected from GetObject")

    // Confirm object identity
    WCHAR *pwszID = (WCHAR *) punk2->AddRef();

    TEST_FAILED_HR((wcscmp(pwszID, L"First Test Object") != 0),
	"GetObject ID is invalid");

    // Make sure pointer == original pointer
    TEST_FAILED((punk2 != punk), "GetObject Pointers are not equal!")

    // Clean up punk2 -- two releases because +1 on return and +1 on
    // addref to get id string
    punk2->Release();
    punk2.Set(NULL);


    // Test set the time
    FILETIME filetime;

    memset(&filetime, 'A', sizeof(filetime));

    hr = prot->NoteChangeTime(dwRegister, &filetime);

    TEST_FAILED_HR((hr != S_OK), "NoteChangeTime Failed")

    // Test get the time
    FILETIME filetime2;

    hr = prot->GetTimeOfLastChange(pmk2, &filetime2);

    TEST_FAILED_HR((hr != S_OK), "NoteChangeTime Failed")

    TEST_FAILED((memcmp(&filetime, &filetime2, sizeof(filetime)) != 0),
	"GetTimeOfLastChange != NoteChangeTime value")

    // Enumerate all the running monikers

    hr = prot->EnumRunning(&penummk);

    TEST_FAILED_HR(FAILED(hr), "EnumRunning Failed")

    // Cycle through running object table
    BOOL fFound = FALSE;
    int cIdx = 0;
    int cOurMoniker;

    while (SUCCEEDED(hr = penummk->Next(1, &pmk, NULL))
	&& (hr != S_FALSE))
    {
	if (pmk2->IsEqual(pmk) == S_OK)
	{
	    fFound = TRUE;
	    cOurMoniker = cIdx;
	}

	pmk.Set(NULL);
	cIdx++;
    }

    TEST_FAILED_HR(FAILED(hr), "ROT Moniker Enumeration ended in failure")

    TEST_FAILED((!fFound), "Did not find our moniker in the table");

    // Reset the pointer
    hr = penummk->Reset();

    TEST_FAILED_HR(FAILED(hr), "ROT IEnumMoniker::Reset Failed");

    // Skip to our moniker
    hr = penummk->Skip(cOurMoniker);

    TEST_FAILED_HR(FAILED(hr), "ROT IEnumMoniker::Skip Failed");

    // Read it from the enumerator
    hr = penummk->Next(1, &pmk, NULL);

    TEST_FAILED_HR(FAILED(hr), "ROT IEnumMoniker::Next Failed");

    TEST_FAILED((pmk2->IsEqual(pmk) != S_OK),
	"ROT IEnumMoniker::Next after skip monikers !=");

    pmk.Set(NULL);

    // Clean up enumerator
    penummk.Set(NULL);

    // Test duplicate registration
    DWORD dwRegister2;

    hr = prot->Register(0, punk, pmk2, &dwRegister2);

    TEST_FAILED_HR((hr != MK_S_MONIKERALREADYREGISTERED),
	"2nd Register in ROT for \\PID failed")

    // Revoke non-existent object
    DWORD dwDummy = (DWORD) &dwRegister2;

    hr = prot->Revoke(dwDummy);

    TEST_FAILED_HR((hr != E_INVALIDARG), "Revoke for bad item wrong result")

    // Revoke the object
    hr = prot->Revoke(dwRegister);

    TEST_FAILED_HR(FAILED(hr), "Revoke of first reg in ROT failed")

    // Revoke duplicate registration
    hr = prot->Revoke(dwRegister2);

    TEST_FAILED_HR(FAILED(hr), "2nd Revoke in ROT failed")

    // Make sure it is no longer running
    hr = prot->IsRunning(pmk2);

    TEST_FAILED_HR((hr != S_FALSE),
	"Revoked ROT entry unexpected error")

    // If we get to here the test passed
    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\ole1\srvrdemo\srvrdemo.c ===
/*                     
  OLE SERVER DEMO
  SrvrDemo.c                                               
                                                                         
  This file contains the window handlers, and various initialization and
  utility functions.
                                                                         
  (c) Copyright Microsoft Corp. 1990 - 1992 All Rights Reserved        
*/


#define SERVERONLY
#include <windows.h>
#include <ole.h>

#include "srvrdemo.h"

/* Global variable definitions */

HWND   hwndMain = 0;

// Used in converting units from pixels to Himetric and vice-versa
int    giXppli = 0;       // pixels per logical inch along width
int    giYppli = 0;       // pixels per logical inch along height 



// Since this is a not an MDI app, there can be only one server and one doc.
SRVR   srvrMain;
DOC    docMain;
CHAR   szClient[cchFilenameMax];
CHAR   szClientDoc[cchFilenameMax];

// Has the user made changes to the document? 
BOOL   fDocChanged = FALSE;

// Is this the first instance of this application currently running? 
BOOL   fFirstInstance = TRUE;

// This flag is used when OleRevokeServerDoc returns OLE_WAIT_FOR_RELEASE,
// and we must wait until DocRelease is called.
BOOL   fWaitingForDocRelease = FALSE;

// This flag is used when OleRevokeServer returns OLE_WAIT_FOR_RELEASE,
// and we must wait until SrvrRelease is called.
BOOL   fWaitingForSrvrRelease = FALSE;

// This flag is set to TRUE after an application has called OleBlockServer
// and now wishes to unblock the queued messages.  See WinMain.
// Server Demo never sets fUnblock to TRUE because it never calls 
// OleBlockServer.
BOOL fUnblock = FALSE;

// Set this to FALSE if you want to guarantee that the server will not revoke
// itself when SrvrRelease is called.  This is used in the IDM_NEW case and
// the IDM_OPEN case (in OpenDoc).
BOOL fRevokeSrvrOnSrvrRelease = TRUE;

// Version number, which is stored in the native data.
VERSION version = 1;

HBRUSH hbrColor[chbrMax];

// Clipboard formats
OLECLIPFORMAT cfObjectLink;
OLECLIPFORMAT cfOwnerLink;
OLECLIPFORMAT cfNative;

// Method tables.
OLESERVERDOCVTBL docvtbl;
OLEOBJECTVTBL    objvtbl;
OLESERVERVTBL    srvrvtbl;

HANDLE hInst;
HANDLE hAccelTable;
HMENU  hMainMenu = NULL;

// Window dimensions saved in private profile.
static struct
{
   INT nX;
   INT nY;
   INT nWidth;
   INT nHeight;
} dimsSaved, dimsCurrent;


static enum
{
   // Corresponds to the order of the menus in the .rc file.
   menuposFile,
   menuposEdit,
   menuposColor,
   menuposObject
};               


// Static functions.
static VOID  DeleteInstance (VOID);
static BOOL  ExitApplication (BOOL);
static VOID  GetWord (LPSTR *plpszSrc, LPSTR lpszDst);
static BOOL  InitApplication( HANDLE hInstance);
static BOOL  InitInstance (HANDLE hInstance);
static BOOL  ProcessCmdLine (LPSTR,HWND);
static VOID  SaveDimensions (VOID);
static VOID  SkipBlanks (LPSTR *plpsz);
static VOID  UpdateObjMenus (VOID);
static BOOL  FailedUpdate(HWND);

/* WinMain
 * -------
 *
 * Standard windows entry point
 *
 * CUSTOMIZATION: None
 *
 */
int APIENTRY WinMain(
   HINSTANCE hInstance,
   HINSTANCE hPrevInstance,
   LPSTR  lpCmdLine,
   INT    nCmdShow  
){
    MSG    msg;

    if (!InitApplication(hInstance))
      return FALSE;

    msg.wParam = FALSE;
    
    if (!InitInstance(hInstance))
        goto errRtn;

    if (!InitServer (hwndMain, hInstance))
        goto errRtn;

    if (!ProcessCmdLine(lpCmdLine,hwndMain))
    {
        ExitApplication(FALSE);
        goto errRtn;
    }

    for (;;)
    {
         // Your application should set fUnblock to TRUE when it decides
         // to unblock.
         if (fUnblock)
         {
            BOOL fMoreMsgs = TRUE;
            while (fMoreMsgs)
            {
				if (srvrMain.lhsrvr == 0)
               OleUnblockServer (srvrMain.lhsrvr, &fMoreMsgs);
            }
            // We have taken care of all the messages in the OLE queue
            fUnblock = FALSE;
         }
      
         if (!GetMessage(&msg, NULL, 0, 0)) 
            break;
         if( !TranslateAccelerator(hwndMain, hAccelTable, &msg)) 
         {
               TranslateMessage(&msg);
               DispatchMessage(&msg); 
         }
    }

    
errRtn:

    DeleteInstance ();
    return (msg.wParam);
}



/* InitApplication
 * ---------------
 *
 * Initialize the application - register the window classes
 *
 * HANDLE hInstance
 * 
 * RETURNS: TRUE if classes are properly registered.
 *          FALSE otherwise
 *
 * CUSTOMIZATION: Re-implement
 *
 */
static BOOL InitApplication( HANDLE hInstance )
{
    WNDCLASS  wc;

    wc.lpszClassName = "MainClass";
    wc.lpfnWndProc   = (WNDPROC)MainWndProc;
    wc.style         = 0;
    wc.cbClsExtra    = 4;
    wc.cbWndExtra    = 0;
    wc.hInstance     = hInstance;
    wc.hIcon         = LoadIcon(hInstance, "DocIcon");
    wc.hCursor       = LoadCursor(NULL, IDC_ARROW);
    wc.hbrBackground = GetStockObject(WHITE_BRUSH);
    wc.lpszMenuName  = "MainMenu";

    if (!RegisterClass(&wc))
        return FALSE;

    wc.lpszClassName = "ObjClass";
    wc.lpfnWndProc   = (WNDPROC)ObjWndProc;
    wc.hIcon         = NULL;
    wc.cbWndExtra    = cbWindExtra;
    wc.lpszMenuName  = NULL;
    wc.hCursor       = LoadCursor(NULL, IDC_CROSS);

    if (!RegisterClass(&wc))
        return FALSE;

    return TRUE;
}



/* InitInstance
 * ------------
 *
 * Create brushes used by the program, the main window, and 
 * do any other per-instance initialization.
 *
 * HANDLE hInstance
 * 
 * RETURNS: TRUE if successful 
 *          FALSE otherwise.
 *
 * CUSTOMIZATION: Re-implement
 *
 */
static BOOL InitInstance (HANDLE hInstance)
{
    LONG rglColor [chbrMax] = 
    {
      0x000000ff,  // Red
      0x0000ff00,  // Green
      0x00ff0000,  // Blue
      0x00ffffff,  // White
      0x00808080,  // Gray
      0x00ffff00,  // Cyan
      0x00ff00ff,  // Magenta
      0x0000ffff   // Yellow
    };


    INT iColor;
	 HDC hDC ;
    
    hInst = hInstance;

    // Initialize the method tables.
    InitVTbls ();

    // Initialize the brushes used.
    for (iColor = 0; iColor < chbrMax; iColor++)
      hbrColor[iColor] = CreateSolidBrush (rglColor[iColor]);

    // Register clipboard formats.
    cfObjectLink= RegisterClipboardFormat ("ObjectLink");
    cfOwnerLink = RegisterClipboardFormat ("OwnerLink");
    cfNative    = RegisterClipboardFormat ("Native");

    hAccelTable = LoadAccelerators(hInst, "Accelerators");
//    hMainMenu   = LoadMenu(hInst, "MainMenu");


    hwndMain = CreateWindow(
        "MainClass",
        szAppName,
        WS_OVERLAPPEDWINDOW,
        CW_USEDEFAULT, CW_USEDEFAULT,
        3*OBJECT_WIDTH, 3*OBJECT_HEIGHT,
        NULL,
        NULL,
        hInstance,
        NULL
    );


    if (!hwndMain)
        return FALSE;

    szClient[0] = '\0';
    lstrcpy (szClientDoc, "Client Document");
    
    // Initialize global variables with LOGPIXELSX and LOGPIXELSY
        
    hDC    = GetDC (NULL);       // Get the hDC of the desktop window
    giXppli = GetDeviceCaps (hDC, LOGPIXELSX);
    giYppli = GetDeviceCaps (hDC, LOGPIXELSY);
    ReleaseDC (NULL, hDC);
	 
        
    return TRUE;

}



/* DeleteInstance
 * --------------
 *
 * Deallocate the VTables, and the brushes created for this instance
 *
 *
 * CUSTOMIZATION: The call to FreeVTbls must remain.
 *
 */
static VOID DeleteInstance (VOID)
{
    INT i;

    for (i = 0; i < chbrMax; i++)
        DeleteObject (hbrColor[i]);

}



/* ExitApplication
 * ---------------
 *
 * Handles the WM_CLOSE and WM_COMMAND/IDM_EXIT messages.
 *
 * RETURNS: TRUE if application should really terminate
 *          FALSE if not
 *
 *
 * CUSTOMIZATION: None
 *
 */
static BOOL ExitApplication (BOOL fUpdateLater)
{

   if (fUpdateLater)
   {
      // The non-standard OLE client did not accept the update
      // when we requested it, so we are sending the client 
      // OLE_CLOSED now that we are closing the document.
      SendDocMsg (OLE_CLOSED);
   }

   if (StartRevokingServer() == OLE_WAIT_FOR_RELEASE)
      Wait (&fWaitingForSrvrRelease);
   /* SrvrRelease will not necessarily post a WM_QUIT message.
      If the document is not embedded, SrvrRelease by itself does
      not cause the application to terminate.  But now we want it to.
   */
   if (docMain.doctype != doctypeEmbedded)
      PostQuitMessage(0);
   SaveDimensions();
   return TRUE;
}



/* MainWndProc
 * -----------
 *
 * Main window message handler.
 *
 *
 * CUSTOMIZATION: Remove the color menu and the object menu entirely.  
 *                Add handlers for your application's menu items and any 
 *                Windows messages your application needs to handle.  
 *                The handlers for the menu items that involve OLE
 *                can be added to, but no logic should be removed.
 *                    
 *
 */
LONG  APIENTRY MainWndProc
   (HWND hwnd, UINT message, WPARAM wParam, LONG lParam )
{
    LPOBJ     lpobj;

    switch (message) 
    {
        case WM_COMMAND:
        {
            WORD wID = LOWORD(wParam);

            if (fWaitingForDocRelease)
            {
               ErrorBox ("Waiting for a document to be revoked.\n\rPlease wait.");
               return 0;
            }

            switch (wID) 
            {
               case IDM_EXIT:
                  SendMessage(hwnd, WM_SYSCOMMAND, SC_CLOSE, 0L);
                  break;

               case IDM_ABOUT:
                  DialogBox(hInst, "AboutBox", hwnd, (DLGPROC)About);
                  break;
   
               case IDM_NEW:
               {
                  BOOL fUpdateLater;
                  OLESTATUS olestatus;

                  if (SaveChangesOption (&fUpdateLater) == IDCANCEL)
                     break;
                  else if (fUpdateLater)
                     SendDocMsg (OLE_CLOSED);

                  // We want to revoke the doc but not the server, so if
                  // SrvrRelease is called, do not revoke server.
                  fRevokeSrvrOnSrvrRelease = FALSE;

                  if ((olestatus = RevokeDoc()) > OLE_WAIT_FOR_RELEASE) 
                  {   
                     ErrorBox ("Serious Error: Cannot revoke document.");
                     break;
                  }
                  else if (olestatus == OLE_WAIT_FOR_RELEASE)
                     Wait (&fWaitingForDocRelease);
  
                  fRevokeSrvrOnSrvrRelease = TRUE;

                  if (!CreateNewDoc (0, "(Untitled)", doctypeNew))
                  {
                     ErrorBox ("Serious Error: Cannot create new document.");
                     break;
                  }
                  // Your application need not create a default object.
                  CreateNewObj (FALSE);
                  EmbeddingModeOff();
                  break;
               }
               case IDM_OPEN:
                  OpenDoc();
                  UpdateObjMenus();
                  break;

               case IDM_SAVE:
                  SaveDoc();
                  break;

               case IDM_SAVEAS:
                  if (!SaveDocAs ())
                     break;
                  if (docMain.doctype != doctypeEmbedded)
                     EmbeddingModeOff();
                  break;

               case IDM_UPDATE:
                  switch (OleSavedServerDoc (docMain.lhdoc))
                  {
                     case OLE_ERROR_CANT_UPDATE_CLIENT:
                        if (!FailedUpdate(hwnd))
                           ExitApplication(TRUE);
                        break;
                     case OLE_OK:
                        break;
                     default:
                        ErrorBox ("Serious Error: Cannot update.");
                  }
                  break;

               /* Color menu */

               case IDM_RED:
               case IDM_GREEN:
               case IDM_BLUE:
               case IDM_WHITE:
               case IDM_GRAY:
               case IDM_CYAN:
               case IDM_MAGENTA:
               case IDM_YELLOW:
                  lpobj = SelectedObject();
                  lpobj->native.idmColor = wID;
                  // Recolor the object on the screen.
                  InvalidateRect (lpobj->hwnd, (LPRECT)NULL,  TRUE);
                  UpdateWindow (lpobj->hwnd);
                  fDocChanged = TRUE;
                  if (docMain.doctype == doctypeFromFile)
                     // If object is linked, update it in client now. 
                     SendObjMsg (lpobj, OLE_CHANGED);
                  break;

               /* Edit menu */

               case IDM_COPY:
                  CutOrCopyObj (TRUE);
                  break;

               case IDM_CUT:
                  CutOrCopyObj (FALSE);
                  // Fall through.

               case IDM_DELETE:
                  RevokeObj (SelectedObject());
                  DestroyWindow (SelectedObjectWindow());
                  UpdateObjMenus();
                  break;

               /* Object menu */

               case IDM_NEXTOBJ:
                  lpobj = SelectedObject();
                  /* The 1 in the second parameter puts the current window
                     at the bottom of the current window list. */
                  SetWindowPos(lpobj->hwnd, (HANDLE)1, 0,0,0,0,
                              SWP_NOMOVE | SWP_NOSIZE);
                  break;

               case IDM_NEWOBJ:
                  lpobj = CreateNewObj (TRUE);
                  BringWindowToTop(lpobj->hwnd);
                  break;

               default:
                  ErrorBox ("Unknown Command.");
                  break;
            }         
            break;
         }

        case WM_NCCALCSIZE:
            if (!IsIconic(hwnd) && !IsZoomed(hwnd))
            {
                dimsCurrent.nX = ((LPRECT)lParam)->left;
                dimsCurrent.nWidth = ((LPRECT)lParam)->right - dimsCurrent.nX;
                dimsCurrent.nY = ((LPRECT)lParam)->top;
                dimsCurrent.nHeight = ((LPRECT)lParam)->bottom - dimsCurrent.nY;
            }
            return DefWindowProc(hwnd, message, wParam, lParam);
            break;

        case WM_QUERYENDSESSION:
        {
            BOOL fUpdateLater;

            if (SaveChangesOption(&fUpdateLater) == IDCANCEL)
               return FALSE;

            if (fUpdateLater)
            {
               // The non-standard OLE client did not accept the update
               // when we requested it, so we are sending the client 
               // OLE_CLOSED now that we are closing the document.
               SendDocMsg (OLE_CLOSED);
            }                          
            return TRUE;
        }

        case WM_CLOSE:
         {
            BOOL fUpdateLater;

            if (SaveChangesOption(&fUpdateLater) != IDCANCEL)
               ExitApplication(fUpdateLater);
            break;
         }

        default:
            return DefWindowProc(hwnd, message, wParam, lParam);
    }
    return 0;
}



/* About
 * -----
 *
 * "About Box" dialog handler.
 *
 * CUSTOMIZATION: None
 *
 */
BOOL  APIENTRY About (HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
    switch (message) 
    {
        case WM_INITDIALOG:
            return TRUE;

        case WM_COMMAND:
        {
            WORD wID = LOWORD(wParam);

            if (wID == IDOK || wID == IDCANCEL) 
            {
                EndDialog(hDlg, TRUE);
                return TRUE;
            }
            break;
        }
    }
    return FALSE;
}




/* ObjWndProc
 * ----------
 *
 * Message handler for the object windows.
 *
 *
 * CUSTOMIZATION: Server Demo specific
 *
 */
LONG  APIENTRY ObjWndProc 
   (HWND hwnd, UINT message, WPARAM wParam, LPARAM lParam)
{
    static BOOL    fCapture = FALSE;
    static struct  {RECT rect; POINT pt;} drag;
    static RECT    rectMain;

    switch (message) 
    {
        case WM_CREATE:
        {
            LPOBJ          lpobj;
            LPCREATESTRUCT lpcs;
            // The call to CreateWindow puts lpobj into lpCreateParams
            lpcs = (LPCREATESTRUCT) lParam;
            lpobj = (LPOBJ) lpcs->lpCreateParams;
            // Associate the window just created with the object.
            lpobj->hwnd = hwnd;
            /* Store pointer to object in the window structure. */
            SetWindowLong(hwnd, ibLpobj, (LONG) lpobj);
            UpdateObjMenus ();
            break;
        }
        case WM_SIZE:
        {
            RECT rect;
            if (fWaitingForDocRelease)
            {   
               ErrorBox ("Waiting for a document to be revoked.\n\rPlease wait.");
               return 0;
            }
            // Get coordinates of object relative to main window's client area.
            GetWindowRect (hwnd, (LPRECT)&rect);
            ScreenToClient (hwndMain, (LPPOINT)&rect);
            ScreenToClient (hwndMain, (LPPOINT)&rect.right);
            SizeObj (hwnd, rect, TRUE);
            // Fall through.
        }
        case WM_PAINT:
            PaintObj (hwnd);
            break;

        case WM_LBUTTONDOWN:
            if (fWaitingForDocRelease)
            {   
               ErrorBox ("Waiting for a document to be revoked.\n\rPlease wait.");
               return 0;
            }
            BringWindowToTop (hwnd);

            GetWindowRect (hwnd, (LPRECT) &drag.rect);
            ScreenToClient (hwndMain, (LPPOINT)&drag.rect.left);
            ScreenToClient (hwndMain, (LPPOINT)&drag.rect.right);

            drag.pt.x = LOWORD(lParam);
            drag.pt.y = HIWORD(lParam);

            // Convert drag.pt to the main window's client coordinates.
            ClientToScreen (hwnd, (LPPOINT)&drag.pt);
            ScreenToClient (hwndMain, (LPPOINT)&drag.pt);

            // Remember the coordinates of the main window so we do not drag
            // an object outside the main window.
            GetClientRect (hwndMain, (LPRECT) &rectMain);

            SetCapture (hwnd);
            fCapture = TRUE;
            break;

        case WM_MOUSEMOVE:
        {
            HDC   hdc;
            POINT pt;

            if (!fCapture)
                break;

            fDocChanged = TRUE;
            pt.x = LOWORD(lParam);
            pt.y = HIWORD(lParam);

            // Convert pt to the main window's client coordinates.
            ClientToScreen (hwnd, (LPPOINT)&pt);
            ScreenToClient (hwndMain, (LPPOINT)&pt);

            if (!PtInRect (&rectMain, pt))
               break;

            hdc = GetDC(hwndMain);

            // Erase old drag rectangle
            InvertRect (hdc, (LPRECT)&drag.rect);
                  
            // Update drag.rect
            OffsetRect (&drag.rect, pt.x - drag.pt.x, pt.y - drag.pt.y);

            // Update drag.pt
            drag.pt.x = pt.x;
            drag.pt.y = pt.y;

            // Show new drag rectangle
            InvertRect (hdc, (LPRECT)&drag.rect);
            ReleaseDC (hwndMain, hdc);
            break;
        }

        case WM_LBUTTONUP:
        {
            LPOBJ          lpobj;
            if (!fCapture)
                return TRUE;

            fCapture = FALSE;
            ReleaseCapture ();

            MoveWindow (hwnd, drag.rect.left, drag.rect.top,
                        drag.rect.right - drag.rect.left,
                        drag.rect.bottom - drag.rect.top, TRUE);
            InvalidateRect (hwnd, (LPRECT)NULL, TRUE);
            lpobj = HwndToLpobj (hwnd);
            lpobj->native.nX = drag.rect.left;
            lpobj->native.nY = drag.rect.top;
            break;
        }
        case WM_DESTROY:
            DestroyObj (hwnd);
            return DefWindowProc(hwnd, message, wParam, lParam);

        default:
            return DefWindowProc(hwnd, message, wParam, lParam);
    }
    return 0;
}



/* DeviceToHiMetric
 * ----------------
 *
 * Converts a point from device units to HiMetric units.
 * This function is designed to be generic enough to be reused.
 *
 * HWND hwnd    - The window whose display context is to be used
 * LPPOINT lppt - The point to be converted.
 *
 * CUSTOMIZATION: None
 *
 */
void DeviceToHiMetric ( LPPOINT lppt)
{
    lppt->x = MulDiv (lppt->x, HIMETRIC_PER_INCH, giXppli);
    lppt->y = MulDiv (lppt->y, HIMETRIC_PER_INCH, giYppli);
}


/* UpdateFileMenu
 * --------------
 *
 * Updates the "Update <Client doc>" and "Exit & Return to <Client doc>" 
 * with the currently set client document name
 *
 * CUSTOMIZATION: Re-implement
 *
 */
VOID UpdateFileMenu (INT iSaveUpdateId)
{
    CHAR    str[cchFilenameMax];
    HMENU   hMenu = GetMenu(hwndMain);    

    /* Change File menu so it contains "Update" instead of "Save". */
    
    lstrcpy (str, "&Update ");
    lstrcat (str, szClientDoc);
    ModifyMenu(hMenu, iSaveUpdateId, MF_BYCOMMAND|MF_STRING, IDM_UPDATE, str);
    
    /* Change File menu so it contains "Exit & Return to <client doc>" */
    /* instead of just "Exit" */
    
    lstrcpy (str, "E&xit && Return to ");
    lstrcat (str, szClientDoc);
    ModifyMenu(hMenu, IDM_EXIT, MF_BYCOMMAND|MF_STRING, IDM_EXIT, str);
}



/* EmbeddingModeOn
 * ---------------
 *
 * Do whatever is necessary for the application to start "embedding mode."
 *
 * CUSTOMIZATION: Re-implement
 *
 */
VOID EmbeddingModeOn(VOID) 
{
    HMENU hMenu = GetMenu(hwndMain);

    UpdateFileMenu (IDM_SAVE);

    /* Change File menu so it contains "Save Copy As..." instead of */
    /* "Save As..." */
    ModifyMenu(hMenu, IDM_SAVEAS, MF_BYCOMMAND|MF_STRING, IDM_SAVEAS, 
        "Save Copy As..");
    
    /* In embedded mode, the user can edit only the embedded object, not
       create new ones. */
    EnableMenuItem(hMenu, menuposObject, MF_BYPOSITION | MF_GRAYED);
    EnableMenuItem(hMenu, IDM_CUT,     MF_BYCOMMAND | MF_GRAYED);
    EnableMenuItem(hMenu, IDM_DELETE,  MF_BYCOMMAND | MF_GRAYED);
    DrawMenuBar (hwndMain);
}




/* EmbeddingModeOff
 * ----------------
 *
 * Do whatever is necessary for the application to end "embedding mode."
 *
 * CUSTOMIZATION: Re-implement
 *
 */
VOID EmbeddingModeOff (VOID) 
{
    HMENU hMenu = GetMenu(hwndMain);

    /* Change File menu so it contains "Save" instead of "Update". */
    ModifyMenu(hMenu, IDM_UPDATE, MF_BYCOMMAND | MF_STRING, IDM_SAVE, "&Save");
    /* Change File menu so it contains "Exit & Return to <client doc>" */
    /* instead of just "Exit" */
    ModifyMenu(hMenu, IDM_EXIT, MF_BYCOMMAND | MF_STRING, IDM_EXIT, "E&xit");

    /* Change File menu so it contains "Save As..." instead of */
    /* "Save Copy As..." */
    ModifyMenu(hMenu, IDM_SAVEAS, MF_BYCOMMAND|MF_STRING, IDM_SAVEAS, 
        "Save &As..");
    
    /* In non-embedded mode, the user can create new objects. */
    EnableMenuItem(hMenu, menuposObject, MF_BYPOSITION | MF_ENABLED);
    
    lstrcpy (szClientDoc, "Client Document");
    DrawMenuBar (hwndMain);
}



/* ErrorBox
 * --------
 *
 * char *szMessage - String to display inside message box.
 *
 * CUSTOMIZATION: Server Demo specific
 *
 */
VOID ErrorBox (CHAR *szMessage)
{
   MessageBox (hwndMain, szMessage, szAppName, MB_OK);
}



/* GetWord
 * -------
 *
 * LPSTR *plpszSrc - Pointer to a pointer to a source string
 * LPSTR lpszDst   - Pointer to destination buffer
 *
 * Will copy one space-terminated or null-terminated word from the source
 * string to the destination buffer.
 * When done, *plpszSrc will point to the character after the word. 
 * 
 * CUSTOMIZATION: Server Demo specific
 *
 */
static VOID GetWord (LPSTR *plpszSrc, LPSTR lpszDst)
{
   INT i = 0;
   while (**plpszSrc && **plpszSrc != ' ')
   {
         lpszDst[i++] = *(*plpszSrc)++;
   }
   lpszDst[i] = '\0';
}



/* HiMetricToDevice 
 * ----------------
 *
 * Converts a point from HiMetric units to device units.
 * This function is designed to be generic enough to be reused.
 *
 * HWND hwnd    - The window whose display context is to be used
 * LPPOINT lppt - The point to be converted.
 *
 * CUSTOMIZATION: None
 *
 */
void HiMetricToDevice ( LPPOINT lppt )
{
    lppt->x = MulDiv (giXppli, lppt->x, HIMETRIC_PER_INCH);
    lppt->y = MulDiv (giYppli, lppt->y, HIMETRIC_PER_INCH);
}



/* HwndToLpobj
 * -----------
 *
 * Given an object's window, return a pointer to the object.
 * The GetWindowLong call extracts an LPOBJ from the extra data stored with
 * the window.
 *
 * HWND hwndObj - Handle to the object's window
 *
 * RETURNS: A pointer to the object
 *
 * CUSTOMIZATION: Server Demo specific
 *
 */
LPOBJ HwndToLpobj (HWND hwndObj)
{
   return (LPOBJ) GetWindowLong (hwndObj, ibLpobj);
}



/* CreateUntitledDoc
 * -----------------
 *
 * Create a fresh document with one object.
 *
 * RETURNS: TRUE if successful
 *          FALSE otherwise
 *
 * CUSTOMIZATION: Re-implement 
 *
 */
static BOOL CreateUntitledDoc (INT nCmdShow)
{
      if (!CreateNewDoc (0, "(Untitled)", doctypeNew))
         return FALSE;
      CreateNewObj (FALSE);
      ShowWindow(hwndMain, nCmdShow);
      UpdateWindow(hwndMain);
      return TRUE;
}


/* ProcessCmdLine
 * --------------
 *
 * Parses the Windows command line which was passed to WinMain.
 *
 * Case One: SrvrDemo.exe 
 *   fEmbedding = FALSE
 *   Create an untitled document.
 *
 * Case two: SrvrDemo.exe filename
 *   fEmbedding = FALSE
 *   Create a new document from the file.
 *
 * Case three: SrvrDemo.exe -Embedding
 *   fEmbedding = TRUE
 *   Do not create or register a document.
 *   Do not show window until client requests it.
 * 
 * Case four: SrvrDemo.exe -Embedding filename
 *   fEmbedding = TRUE
 *   Load file.
 *   Call OleRegisterServerDoc.
 *   Do not show window until client requests it.
 *
 * 
 * LPSTR lpszLine - The Windows command line
 * int nCmdShow   - Parameter to WinMain
 * HWND hwndMain  - The application's main window
 * 
 * RETURNS: TRUE  if the command line was processed correctly.
 *          FALSE if a filename was specified which did not
 *                contain a proper document.
 *
 * CUSTOMIZATION: None.
 *
 */
 
static BOOL ProcessCmdLine (LPSTR lpszLine, HWND hwndMain)
{
   CHAR     szBuf[cchFilenameMax];
   BOOL     fEmbedding = FALSE;  // Is "-Embedding" on the command line?
   INT      i=0;
   OFSTRUCT of;
        
   if (!*lpszLine)    // No filename or options, so start a fresh document.
   {
      return CreateUntitledDoc(SW_SHOWNORMAL);
   }
    
   SkipBlanks (&lpszLine);

   // Check for "-Embedding" or "/Embedding" and set fEmbedding.
   if(*lpszLine == '-' || *lpszLine == '/')
   {
      lpszLine++;
      GetWord (&lpszLine, szBuf);
      fEmbedding = !lstrcmp(szBuf, szEmbeddingFlag);
   }

   SkipBlanks (&lpszLine);

   if (*lpszLine) // if there is a filename
   {
      // Put filename into szBuf.
      GetWord (&lpszLine, szBuf);

      if (-1 == OpenFile(szBuf, &of, OF_READ | OF_EXIST))
      {
         // File not found
         if (fEmbedding)
            return FALSE;       
         else
         {
            CHAR sz[100];
            wsprintf (sz, "File %s not found.", (LPSTR) szBuf);
            ErrorBox (sz);
            return CreateUntitledDoc(SW_SHOWNORMAL);
         }
      }

      if (!CreateDocFromFile (szBuf, 0, doctypeFromFile))
      {
         // File not in proper format.
         if (fEmbedding)
            return FALSE;       
         else
         {
            CHAR sz[100];
            wsprintf (sz, "File %s not in proper format.", (LPSTR) szBuf);
            ErrorBox (sz);
            return CreateUntitledDoc(SW_SHOWNORMAL);
         }
      }
   }

   if (fEmbedding)
   {
      /* Do not show window until told to do so by client. */
      ShowWindow(hwndMain, SW_HIDE);
   }
   else
   {
      ShowWindow(hwndMain, SW_SHOWNORMAL);
      UpdateWindow(hwndMain);
   }
   return TRUE;
}



/* SaveDimensions
 * --------------
 *
 * Save the dimensions of the main window in a private profile file.
 *
 * CUSTOMIZATION: This function may be removed.  If you wish to support
 *                intelligent window placement, then the only necessary
 *                change is to change the string "SrvrDemo.Ini" to a filename
 *                appropriate for your application.
 */
static VOID SaveDimensions (VOID)
{
   if ((dimsCurrent.nX != dimsSaved.nX) || 
         (dimsCurrent.nY != dimsSaved.nY) ||
         (dimsCurrent.nWidth != dimsSaved.nWidth) || 
         (dimsCurrent.nHeight != dimsSaved.nHeight) )
   {
         // Save current window dimensions to private profile.
         CHAR szBuf[7];
         wsprintf (szBuf, "%d", dimsCurrent.nX);
         WritePrivateProfileString
         (szAppName, "x", szBuf, "SrvrDemo.Ini");
         wsprintf (szBuf, "%d", dimsCurrent.nY);
         WritePrivateProfileString
         (szAppName, "y", szBuf, "SrvrDemo.Ini");
         wsprintf (szBuf, "%d", dimsCurrent.nWidth);
         WritePrivateProfileString
         (szAppName, "w", szBuf, "SrvrDemo.Ini");
         wsprintf (szBuf, "%d", dimsCurrent.nHeight);
         WritePrivateProfileString
         (szAppName, "h", szBuf, "SrvrDemo.Ini");
   }
}



/* SelectedObject
 * --------------
 *
 * Return a pointer to the currently selected object.
 *
 * CUSTOMIZATION: What a "selected object" is will vary from application
 *                to application.  You may find it useful to have a function
 *                like this.  In your application it may be necessary to
 *                actually create an OBJ structure based on what data the
 *                user has selected from the document (by highlighting some
 *                text for example).  
 *
 */
LPOBJ SelectedObject (VOID)
{
   return HwndToLpobj (SelectedObjectWindow());
}
 



/* SelectedObjectWindow
 * --------------------
 *
 * Return a handle to the window for the currently selected object.
 * The GetWindow calls returns a handle to the main window's first child,
 * which is the selected object's window.  
 *
 * CUSTOMIZATION: Server Demo specific
 *
 */
HWND SelectedObjectWindow (VOID)
{
   return GetWindow (hwndMain, GW_CHILD);
}



/* SetHiMetricFields
 * -----------------
 *
 * Adjust the nHiMetricWidth and nHiMetricHeight fields of a NATIVE structure
 * so that they are equivalent to the nWidth and nHeight fields.
 * The negative sign in the last line is necessary because the positive 
 * y direction is toward the top of the screen in MM_HIMETRIC mode.
 *
 * LPOBJ lpobj - Pointer to the object whose native data will be adjusted
 *
 * CUSTOMIZATION: Server Demo specific, although you may need a function like
 *                this if you keep track of the size of an object, and an 
 *                object handler needs to know the object's size in 
 *                HiMetric units.
 *
 *
 */
VOID SetHiMetricFields (LPOBJ lpobj)
{
   POINT pt;
   
   pt.x = lpobj->native.nWidth;
   pt.y = lpobj->native.nHeight;
   DeviceToHiMetric ( &pt);
   lpobj->native.nHiMetricWidth  = pt.x;
   lpobj->native.nHiMetricHeight = pt.y;
}



/* SkipBlanks
 * ----------
 * 
 * LPSTR *plpsz - Pointer to a pointer to a character
 *
 * Increment *plpsz past any blanks in the character string.
 * This function is used in ProcessCmdLine.
 *
 */
static VOID SkipBlanks (LPSTR *plpsz)
{
   while (**plpsz && **plpsz == ' ')
      (*plpsz)++;
}



/* UpdateObjMenus
 * ---------------
 *
 * Grey or Ungrey menu items depending on the existence of at least one 
 * object in the document.
 *
 * CUSTOMIZATION: Server Demo specific
 *
 */
static VOID UpdateObjMenus (VOID)
{
    static BOOL fObjMenusEnabled = TRUE;
    BOOL        fOneObjExists; // Does at least one object exist?
    WORD        wEnable;
    HMENU       hMenu;

    fOneObjExists = (SelectedObjectWindow() != NULL);
    if (fOneObjExists == fObjMenusEnabled)
    {
         // Nothing has changed.
         return;
    }

    wEnable = (WORD)(fOneObjExists ? MF_ENABLED : MF_GRAYED);

    hMenu = GetMenu(hwndMain);
    EnableMenuItem(hMenu, menuposColor, MF_BYPOSITION | wEnable);

    hMenu = GetSubMenu(GetMenu(hwndMain), menuposFile);
    EnableMenuItem(hMenu, IDM_SAVE,   MF_BYCOMMAND | wEnable);
    EnableMenuItem(hMenu, IDM_SAVEAS, MF_BYCOMMAND | wEnable);

    hMenu = GetSubMenu(GetMenu(hwndMain), menuposEdit);
    EnableMenuItem(hMenu, IDM_CUT,     MF_BYCOMMAND | wEnable);
    EnableMenuItem(hMenu, IDM_COPY,    MF_BYCOMMAND | wEnable);
    EnableMenuItem(hMenu, IDM_DELETE,  MF_BYCOMMAND | wEnable);

    hMenu = GetSubMenu(GetMenu(hwndMain), menuposObject);
    EnableMenuItem(hMenu, IDM_NEXTOBJ, MF_BYCOMMAND | wEnable);

    DrawMenuBar (hwndMain);
    fObjMenusEnabled = fOneObjExists;
}



/* Wait
 * ----
 *
 * Dispatch messages until the given flag is set to FALSE.
 * One use of this function is to wait until a Release method is called
 * after a function has returned OLE_WAIT_FOR_RELEASE.
 *
 * BOOL *pf - Pointer to the flag being waited on.
 *
 * CUSTOMIZATION: The use of OleUnblockServer is for illustration only.
 *                Since Server Demo does not call OleBlockServer, there 
 *                will never be any messages in the OLE queue.
 *
 */
VOID Wait (BOOL *pf)
{
   MSG msg;
   BOOL fMoreMsgs = FALSE;

   *pf = TRUE;
   while (*pf==TRUE)
   {
      OleUnblockServer (srvrMain.lhsrvr, &fMoreMsgs);
      if (!fMoreMsgs)
      // if there are no more messages in the OLE queue, go to system queue
      {
         if (GetMessage (&msg, NULL, 0, 0))
         {
            TranslateMessage (&msg);
            DispatchMessage (&msg);
         }
      }
   }
}

static BOOL FailedUpdate(HWND hwnd)
{

  return(DialogBox(hInst, "FailedUpdate", hwnd, (DLGPROC)fnFailedUpdate));

}

BOOL  APIENTRY fnFailedUpdate (HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{

   switch (message) 
   {
      case WM_COMMAND:
      {
         WORD wID = LOWORD(wParam);

         switch (wID) 
         {
               case IDCANCEL:
               case IDD_CONTINUEEDIT:
                   EndDialog(hDlg, TRUE);
                   break;

               case IDD_UPDATEEXIT:
                   EndDialog(hDlg, FALSE);
                   break;

               default:
                   break;
         }
         break;
       }

       case WM_INITDIALOG:
       {
          CHAR szMsg[200];

          szMsg[0] = '\0';

          wsprintf(
               szMsg, 
               "This %s document can only be updated when you exit %s.",
               (LPSTR) szClient,
               (LPSTR) szAppName
          );

          SetDlgItemText(hDlg, IDD_TEXT, szMsg);
          return TRUE; 
       }
       
      default:
           break;
   }

   return FALSE;
}





=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\ole1\srvrdemo\server.c ===
/*
  OLE SERVER DEMO
  Server.c

  This file contains server methods and various server-related support
  functions.

  (c) Copyright Microsoft Corp. 1990 - 1992  All Rights Reserved
*/



#define SERVERONLY
#include <windows.h>
#include <ole.h>

#include "srvrdemo.h"

CLASS_STRINGS  ClassStrings = {
    "SrvrDemo10", "*.sd1", "Srvr Demo10", "svrdemo1.exe"
};

/*
   Important Note:

   No method should ever dispatch a DDE message or allow a DDE message to
   be dispatched.
   Therefore, no method should ever enter a message dispatch loop.
   Also, a method should not show a dialog or message box, because the
   processing of the dialog box messages will allow DDE messages to be
   dispatched.
*/
BOOL RegServer(){

    LONG        fRet;
    HKEY        hKey;
    CHAR        szKeyName[300]; //Get better value
    BOOL        retVal = FALSE;

    lstrcpy(szKeyName, ClassStrings.pClassName);
    lstrcat(szKeyName, "\\protocol\\StdFileEditing\\verb");

    //Check if Class is installed, following should hold correct if class is installed.
    if ((fRet = RegOpenKey(HKEY_CLASSES_ROOT, szKeyName, &hKey)) == ERROR_SUCCESS)
        return FALSE;

    RegCloseKey(hKey);

    if ((fRet = RegSetValue(HKEY_CLASSES_ROOT, (LPSTR)(ClassStrings.pFileSpec+1),
            REG_SZ, ClassStrings.pClassName, 7)) != ERROR_SUCCESS)
		return FALSE;

    if((fRet = RegSetValue(HKEY_CLASSES_ROOT, ClassStrings.pClassName, REG_SZ,
                  ClassStrings.pHumanReadable, 7)) != ERROR_SUCCESS)
		return FALSE;

    lstrcat(szKeyName, "\\0");
    if((fRet = RegSetValue(HKEY_CLASSES_ROOT, (LPSTR)szKeyName, REG_SZ, "PLAY", 4))
                  != ERROR_SUCCESS)
		return FALSE;

    szKeyName[lstrlen(szKeyName) - 1] = '1';
    if((fRet = RegSetValue(HKEY_CLASSES_ROOT, (LPSTR)szKeyName, REG_SZ, "EDIT", 4))
         != ERROR_SUCCESS)
		return FALSE;

    lstrcpy(szKeyName, ClassStrings.pClassName);
    lstrcat(szKeyName, "\\protocol\\StdFileEditing\\Server");
    if((fRet = RegSetValue(HKEY_CLASSES_ROOT, (LPSTR)szKeyName, REG_SZ, ClassStrings.pExeName, 11))
         != ERROR_SUCCESS)
		return FALSE;

    lstrcpy(szKeyName, ClassStrings.pClassName);
    lstrcat(szKeyName, "\\protocol\\StdExecute\\Server");
    if((fRet = RegSetValue(HKEY_CLASSES_ROOT, (LPSTR)szKeyName, REG_SZ, ClassStrings.pExeName, 11))
         != ERROR_SUCCESS)
		return FALSE;

	
    return TRUE;

}


/* Abbrev
 * ------
 *
 * Return a pointer to the filename part of a fully-qualified pathname.
 *
 * LPSTR lpsz - Fully qualified pathname
 *
 * CUSTOMIZATION: May be useful, but not necessary.
 *
 */
LPSTR Abbrev (LPSTR lpsz)
{
   LPSTR lpszTemp;

   lpszTemp = lpsz + lstrlen(lpsz) - 1;
   while (lpszTemp > lpsz && lpszTemp[-1] != '\\')
      lpszTemp--;
   return lpszTemp;
}





/* InitServer
 * ----------
 *
 * Initialize the server by allocating memory for it, and calling
 * the OleRegisterServer method.  Requires that the server method table
 * has been properly initialized.
 *
 * HWND hwnd      - Handle to the main window
 * LPSTR lpszLine - The Windows command line
 *
 * RETURNS: TRUE if the memory could be allocated, and the server
 *          was properly registered.
 *          FALSE otherwise
 *
 * CUSTOMIZATION: Your application might not use a global variable
 *                for srvrMain.
 *
 */
BOOL InitServer (HWND hwnd, HANDLE hInst)
{
    RegServer();
    srvrMain.olesrvr.lpvtbl = &srvrvtbl;

    if (OLE_OK != OleRegisterServer
         (szClassName, (LPOLESERVER) &srvrMain, &srvrMain.lhsrvr, hInst,
          OLE_SERVER_MULTI))
      return FALSE;
    else
      return TRUE;
}



/* InitVTbls
 * ---------
 *
 * Create procedure instances for all the OLE methods.
 *
 *
 * CUSTOMIZATION: Your application might not use global variables for srvrvtbl,
 *                docvtbl, and objvtbl.
 */
VOID InitVTbls (VOID)
{
   typedef LPVOID ( APIENTRY *LPVOIDPROC) (LPOLEOBJECT, LPSTR);

   // Server method table
   srvrvtbl.Create          = SrvrCreate;
   srvrvtbl.CreateFromTemplate = SrvrCreateFromTemplate;
   srvrvtbl.Edit            = SrvrEdit;
   srvrvtbl.Execute         = SrvrExecute;
   srvrvtbl.Exit            = SrvrExit;
   srvrvtbl.Open            = SrvrOpen;
   srvrvtbl.Release         = SrvrRelease;

   // Document method table
   docvtbl.Close            = DocClose;
   docvtbl.GetObject        = DocGetObject;
   docvtbl.Execute          = DocExecute;
   docvtbl.Release          = DocRelease;
   docvtbl.Save             = DocSave;
   docvtbl.SetColorScheme   = DocSetColorScheme;
   docvtbl.SetDocDimensions = DocSetDocDimensions;
   docvtbl.SetHostNames     = DocSetHostNames;

   // Object method table
   objvtbl.DoVerb           = ObjDoVerb;
   objvtbl.EnumFormats      = ObjEnumFormats;
   objvtbl.GetData          = ObjGetData;
   objvtbl.QueryProtocol    = ObjQueryProtocol;
   objvtbl.Release          = ObjRelease;
   objvtbl.SetBounds        = ObjSetBounds;
   objvtbl.SetColorScheme   = ObjSetColorScheme;
   objvtbl.SetData          = ObjSetData;
   objvtbl.SetTargetDevice  = ObjSetTargetDevice;
   objvtbl.Show             = ObjShow;

}



/* SetTitle
 * --------
 *
 * Sets the main window's title bar. The format of the title bar is as follows
 *
 * If embedded
 *        <Server App name> - <object type> in <client doc name>
 *
 *      Example:  "Server Demo - SrvrDemo Shape in OLECLI.DOC"
 *                where OLECLI.DOC is a Winword document
 *
 * otherwise
 *        <Server App name> - <server document name>
 *
 *      Example:  "Srvr Demo10 - OLESVR.SD1"
 *                where OLESVR.SD1 is a Server demo document
 *
 * LPSTR lpszDoc    - document name
 * BOOL  fEmbedded  - If TRUE embedded document, else normal document
 *
 * RETURNS: OLE_OK
 *
 *
 * CUSTOMIZATION: Your application may store the document's name somewhere
 *                other than docMain.aName.  Other than that, you may
 *                find this a useful utility function as is.
 *
 */
VOID SetTitle (LPSTR lpszDoc, BOOL fEmbedded)
{
   CHAR szBuf[cchFilenameMax];

   if (lpszDoc && lpszDoc[0])
   {
      // Change document name.
      if (docMain.aName)
         GlobalDeleteAtom (docMain.aName);
      docMain.aName = GlobalAddAtom (lpszDoc);
   }

   if (fEmbedded)
   {
     //
      if (lpszDoc && lpszDoc[0])
      {
         wsprintf (szBuf, "%s - SrvrDemo10 Shape in %s", (LPSTR) szAppName,
             Abbrev (lpszDoc));
      }
      else
      {
         // Use name from docMain
         CHAR szDoc [cchFilenameMax];

         GlobalGetAtomName (docMain.aName, szDoc, cchFilenameMax);
         wsprintf (szBuf, "%s - SrvrDemo Shape10 in %s", (LPSTR) szAppName,
             Abbrev (szDoc));
      }
      SetWindowText (hwndMain, (LPSTR)szBuf);
   }
   else if (lpszDoc && lpszDoc[0])
   {
      wsprintf (szBuf, "%s - %s", (LPSTR) szAppName, Abbrev(lpszDoc));
      SetWindowText (hwndMain, szBuf);
   }
}




/* SrvrCreate                SERVER "Create" METHOD
 * ----------
 *
 * Create a document, allocate and initialize the OLESERVERDOC structure,
 * and associate the library's handle with it.
 * In this demo server, we also create an object for the user to edit.
 *
 * LPOLESERVER lpolesrvr          - The server structure registered by
 *                                  the application
 * LHSERVERDOC lhdoc              - The library's handle
 * OLE_LPCSTR lpszClassName            - The class of document to create
 * OLE_LPCSTR lpszDoc                  - The name of the document
 * LPOLESERVERDOC FAR *lplpoledoc - Indicates the server doc structure to be
 *                                  created
 *
 * RETURNS:        OLE_OK if the named document was created.
 *                 OLE_ERROR_NEW if the document could not be created.
 *
 * CUSTOMIZATION: Your application might not call CreateNewObj.
 *
 */
OLESTATUS  APIENTRY SrvrCreate
   (LPOLESERVER lpolesrvr, LHSERVERDOC lhdoc, OLE_LPCSTR lpszClassName,
    OLE_LPCSTR lpszDoc, LPOLESERVERDOC FAR *lplpoledoc)
{
    if (!CreateNewDoc (lhdoc, (LPSTR) lpszDoc, doctypeEmbedded))
        return OLE_ERROR_NEW;

    // Although the document has not actually been changed, the client has not
    // received any data from the server yet, so the client will need to be
    // updated.  Therefore, CreateNewObj sets fDocChanged to TRUE.
    CreateNewObj (TRUE);
    *lplpoledoc = (LPOLESERVERDOC) &docMain;
    EmbeddingModeOn();
    return OLE_OK;
}



/* SrvrCreateFromTemplate        SERVER "CreateFromTemplate" METHOD
 * ----------------------
 *
 * Create a document, allocate and initialize the OLESERVERDOC structure,
 * initializing the document with the contents named in the template name,
 * and associate the library's handle with the document structure.
 *
 * LPOLESERVER lpolesrvr        - The server structure registered by
 *                                the application
 * LHSERVERDOC lhdoc            - The library's handle
 * OLE_LPCSTR lpszClassName          - The class of document to create
 * OLE_LPCSTR lpszDoc                - The name of the document
 * OLE_LPCSTR lpszTemplate           - The name of the template
 * LPOLESERVERDOC FAR *lplpoledoc - Indicates the server doc structure
 *                                  to be created
 *
 * RETURNS:        OLE_OK if the named document was created.
 *                 OLE_ERROR_TEMPLATE if the document could not be created.
 *
 * CUSTOMIZATION: None
 *
 */
OLESTATUS  APIENTRY SrvrCreateFromTemplate
   (LPOLESERVER lpolesrvr, LHSERVERDOC lhdoc, OLE_LPCSTR lpszClassName,
    OLE_LPCSTR lpszDoc, OLE_LPCSTR lpszTemplate, LPOLESERVERDOC FAR *lplpoledoc)
{
    if (!CreateDocFromFile((LPSTR) lpszTemplate, (LHSERVERDOC) lhdoc, doctypeEmbedded))
        return OLE_ERROR_TEMPLATE;

    *lplpoledoc = (LPOLESERVERDOC) &docMain;

    // Although the document has not actually been changed, the client has not
    // received any data from the server yet, so the client will need to be
    // updated.
    fDocChanged = TRUE;
    EmbeddingModeOn();
    return OLE_OK;
}



/* SrvrEdit                SERVER "Edit" METHOD
 * --------
 *
 * A request by the libraries to create a document, allocate and
 * initialize the OLESERVERDOC structure, and associate the
 * library's handle with the document structure.
 * We create an object which will be modified by the SetData method
 * before the user has a chance to touch it.
 *
 * LPOLESERVER lpolesrvr          - The server structure registered by
 *                                  the application
 * LHSERVERDOC lhdoc              - The library's handle
 * OLE_LPCSTR lpszClassName            - The class of document to create
 * OLE_LPCSTR lpszDoc                  - The name of the document
 * LPOLESERVERDOC FAR *lplpoledoc - Indicates the server doc structure to be
 *                                  created
 *
 * RETURNS:        OLE_OK if the named document was created.
 *                 OLE_ERROR_EDIT if the document could not be created.
 *
 * CUSTOMIZATION: None
 *
 */
OLESTATUS  APIENTRY SrvrEdit
   (LPOLESERVER lpolesrvr, LHSERVERDOC lhdoc, OLE_LPCSTR lpszClassName,
    OLE_LPCSTR lpszDoc, LPOLESERVERDOC FAR *lplpoledoc)
{
    if (!CreateNewDoc ((LONG)lhdoc, (LPSTR)lpszDoc, doctypeEmbedded))
        return OLE_ERROR_EDIT;

    // The client is creating an embedded object for the server to edit,
    // so initially the client and server are in sync.
    fDocChanged = FALSE;
    *lplpoledoc = (LPOLESERVERDOC) &docMain;
    EmbeddingModeOn();
    return OLE_OK;

}


/* SrvrExecute                SERVER "Execute" METHOD
 * --------
 *
 * This application does not support the execution of DDE execution commands.
 *
 * LPOLESERVER lpolesrvr - The server structure registered by
 *                         the application
 * HANDLE hCommands      - DDE execute commands
 *
 * RETURNS: OLE_ERROR_COMMAND
 *
 * CUSTOMIZATION: Re-implement if your application supports the execution of
 *                DDE commands.
 *
 */
OLESTATUS  APIENTRY SrvrExecute (LPOLESERVER lpolesrvr, HANDLE hCommands)
{
   return OLE_ERROR_COMMAND;
}



/* SrvrExit                SERVER "Exit" METHOD
 * --------
 *
 * This method is called the library to instruct the server to exit.
 *
 * LPOLESERVER lpolesrvr - The server structure registered by
 *                         the application
 *
 * RETURNS: OLE_OK
 *
 * CUSTOMIZATION: None
 *
 */
OLESTATUS  APIENTRY SrvrExit (LPOLESERVER lpolesrvr)
{
   if (srvrMain.lhsrvr)
   // If we haven't already tried to revoke the server.
   {
      StartRevokingServer();
   }
   return OLE_OK;
}



/* SrvrOpen                SERVER "Open" METHOD
 * --------
 *
 * Open the named document, allocate and initialize the OLESERVERDOC
 * structure, and associate the library's handle with it.
 *
 * LPOLESERVER lpolesrvr          - The server structure registered by
 *                                  the application
 * LHSERVERDOC lhdoc              - The library's handle
 * OLE_LPCSTR lpszDoc                  - The name of the document
 * LPOLESERVERDOC FAR *lplpoledoc - Indicates server doc structure to be
 *                                  created
 *
 * RETURNS:        OLE_OK if the named document was opened.
 *                 OLE_ERROR_OPEN if document could not be opened correctly.
 *
 * CUSTOMIZATION: None
 *
 */
OLESTATUS  APIENTRY SrvrOpen (LPOLESERVER lpolesrvr, LHSERVERDOC lhdoc,
                               OLE_LPCSTR lpszDoc, LPOLESERVERDOC FAR *lplpoledoc)
{
    if (!CreateDocFromFile ((LPSTR)lpszDoc, (LHSERVERDOC)lhdoc, doctypeFromFile))
        return OLE_ERROR_OPEN;

    *lplpoledoc = (LPOLESERVERDOC) &docMain;
    return OLE_OK;
}



/* SrvrRelease                SERVER "Release" METHOD
 * -----------
 *
 * This library calls the SrvrRelease method when it is safe to quit the
 * application.  Note that the server application is not required to quit.
 *
 * srvrMain.lhsrvr != NULL indicates that SrvrRelease has been called
 * because the client is no longer connected, not because the server called
 * OleRevokeServer.
 * Therefore, only start the revoking process if the document is of type
 * doctypeEmbedded or if the server was opened for an invisible update.
 *
 * srvrmain.lhsrvr == NULL indicates that OleRevokeServer has already
 * been called (by the server application), and srvrMain is bad.
 * It is safe to quit now because SrvrRelease has just been called.
 *
 * Note that this method may be called twice: when OleRevokeServer is
 * called in StartRevokingServer, SrvrRelease is called again.
 * Therefore we need to be reentrant.
 *
 * LPOLESERVER lpolesrvr - The server structure to release
 *
 * RETURNS: OLE_OK
 *
 * CUSTOMIZATION: None
 *
 */
OLESTATUS  APIENTRY SrvrRelease (LPOLESERVER lpolesrvr)
{
   if (srvrMain.lhsrvr)
   {
      if (fRevokeSrvrOnSrvrRelease
          && (docMain.doctype == doctypeEmbedded
              || !IsWindowVisible (hwndMain)))
         StartRevokingServer();
   }
   else
   {
      fWaitingForSrvrRelease = FALSE;
      // Here you should free any memory that had been allocated for the server.
      PostQuitMessage (0);
   }
   return OLE_OK;
}



/* StartRevokingServer
 * -------------------
 *
 * Hide the window, and start to revoke the server.
 * Revoking the server will let the library close any registered documents.
 * OleRevokeServer may return OLE_WAIT_FOR_RELEASE.
 * Calling StartRevokingServer starts a chain of events that will eventually
 * lead to the application being terminated.
 *
 * RETURNS: The return value from OleRevokeServer
 *
 * CUSTOMIZATION: None
 *
 */
OLESTATUS StartRevokingServer (VOID)
{
   OLESTATUS olestatus;

   if (srvrMain.lhsrvr)
   {
      LHSERVER lhserver;
      // Hide the window so user can do nothing while we are waiting.
      ShowWindow (hwndMain, SW_HIDE);
      lhserver = srvrMain.lhsrvr;
      // Set lhsrvr to NULL to indicate that srvrMain is a bad and that
      // if SrvrRelease is called, then it is ok to quit the application.
      srvrMain.lhsrvr = 0;
      olestatus = OleRevokeServer (lhserver);
   }
   else
      // The programmer should ensure that this never happens.
      ErrorBox ("Fatal Error: StartRevokingServer called on NULL server.");
   return olestatus;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\olebind\olebind.cxx ===
//+---------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1994.
//
//  File:       olebind.cxx
//
//  Contents:   Test OLE COM
//
//  Classes:
//
//  Functions:  TestSetMoniker
//      `       DoTest
//              ConvertPath
//              CreateFile
//              CleanUpFiles
//              InitFiles
//              main
//
//  History:    31-Dec-93   ErikGav    Chicago port
//              15-Nov-94   BruceMa    Added this header
//              15-Nov-94   BruceMa    Make long file name test work on
//                                      Chicago
//              11-Jan-95   BruceMa    Chicago now use the NT alorithm for
//                                      short file names
//              17-Jan-95   BruceMa    Modify registry so olebind works on
//                                      Cairo when running multi-threaded
//
//----------------------------------------------------------------------

#include <windows.h>
#include "widewrap.h"
#include <stdio.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <errno.h>
#include <io.h>

#include <ole2.h>
#include <com.hxx>
#include "olebind.hxx"
#include "tmoniker.h"
#include <tchar.h>

const char *szOleBindError = "OLEBIND - Fatal Error";
char wszErrBuf[512];

#pragma hdrstop

BOOL SetRegistryThreadingModel(WCHAR *peszFile, WCHAR *pwszThreadingModel);
BOOL ResetRegistryThreadingModel(WCHAR *pwszFile);

#define FILE_SHARE_DELETE               0x00000004

#define INPROC_PATH1 L"p1.ut1"
#define INPROC_PATH2 L"p2.ut1"
#define LOCAL_SERVER_PATH1 L"p1.ut2"
#define LOCAL_SERVER_PATH2 L"p2.ut2"
#define LOCAL_SERVER_PATH4 L"p2.ut4"

WCHAR InprocPath1[MAX_PATH];
WCHAR InprocPath2[MAX_PATH];
WCHAR LocalServerPath1[MAX_PATH];
WCHAR LocalServerPath2[MAX_PATH];
WCHAR LocalServerPath4[MAX_PATH];

#define LONG_SHORT_DIR          L"\\LongDire"
#define LONG_DIR                L"\\LongDirectory"
#define LONG_SHORT_NAME         L"\\Short.Fil"
#define LONG_LONG_NAME          L"\\LongFileName.File"
#define LONG_LONG_SHORT_EQUIV   L"\\LongFi~1.Fil"

WCHAR LongDir[MAX_PATH];
WCHAR LongDirShort[MAX_PATH];
WCHAR LongDirLong[MAX_PATH];
WCHAR LongDirLongSe[MAX_PATH];

// DON"T MODIFY THIS
const DWORD dwRESERVED = 0l;

//  string version of process id
WCHAR wszPid[10];


int TestSetMoniker(IUnknown *punk)
{
    HRESULT	hr;
    XOleObject	poleobject;
    XMoniker	pmk;
    XMalloc	pIMalloc;
    XBindCtx	pbc;


    hr = punk->QueryInterface(IID_IOleObject, (void **) &poleobject);

    // Create an item moniker to the object
    hr = CreateItemMoniker(L"\\", L"1", &pmk);

    TEST_FAILED_HR(FAILED(hr), "TestSetMoniker:CreateItemMoniker failed")

    // Set the moniker
    hr = poleobject->SetMoniker(OLEWHICHMK_CONTAINER, pmk);

    TEST_FAILED_HR(FAILED(hr), "TestSetMoniker:SetMoniker failed")

    pmk.Set(NULL);

    // Get the moniker back
    hr = poleobject->GetMoniker(OLEGETMONIKER_ONLYIFTHERE,
	OLEWHICHMK_CONTAINER, &pmk);

    TEST_FAILED_HR(FAILED(hr), "TestSetMoniker:GetMoniker failed")

    // Get & Verify name is as expected
    WCHAR *pwszName;


    hr = CreateBindCtx(0, &pbc);

    TEST_FAILED_HR(FAILED(hr),
	"CreateBindCtx TestSetMoniker:GetDisplayName failed!")

    hr = pmk->GetDisplayName(pbc, NULL, &pwszName);

    TEST_FAILED_HR(FAILED(hr), "TestSetMoniker:GetDisplayName failed")

    TEST_FAILED((wcscmp(pwszName, L"\\1") != 0),
	"TestSetMoniker: Returned name mismatch!\n")

    // Test OleIsRunning
    hr = OleIsRunning(poleobject);

    TEST_FAILED_HR(FAILED(hr), "OleIsRunning call failed")

    // Free resources
    hr = CoGetMalloc(MEMCTX_TASK, &pIMalloc);

    TEST_FAILED_HR(FAILED(hr), "CoGetMalloc failed")

    pIMalloc->Free(pwszName);

    return 0;
}

static GUID CLSID_Invalid =
    {0xfffffffe,0xffff,0xffff,{0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff}};


//  prototypes for private entry points. These are here to support VB94.
STDAPI	CoGetState(IUnknown **ppUnkState);
STDAPI	CoSetState(IUnknown *pUnkState);

int DoTest(
    GUID guidToTest,
    LPWSTR pszPath1,
    LPWSTR pszPath2)
{
    XMoniker	       pmnk;	       // ptr to moniker
    XUnknown	       pUnk;
    XUnknown	       punk;
    XUnknown	       pUnkTheSame;
    XOleItemContainer  poleitmcon;
    XDispatch	       pdispatch;

    XBindCtx	       pbc1;
    XBindCtx	       pbc2;
    XUnknown	       pUnkState1;
    XUnknown	       pUnkState2;
    XUnknown	       pUnkState3;
    XUnknown	       pUnkState4;
    XUnknown	       pUnkState5;

    HRESULT hr;
    DWORD grfOpt = 0;


    // Test the private CoSetState/CoGetState APIs.  We just need an
    // IUnknown so we will use a BindCtx for this.

    //	test Set/Get
    hr = CreateBindCtx(0, &pbc1);
    TEST_FAILED_HR(FAILED(hr), "Create BindCtx 1 failed");
    hr = pbc1->QueryInterface(IID_IUnknown, (void **)&pUnkState1);
    TEST_FAILED_HR(FAILED(hr), "QI for IUnknown 1 failed.");

    hr = CoSetState(pUnkState1);
    TEST_FAILED_HR(hr != S_OK, "CoSetState failed.");

    hr = CoGetState(&pUnkState2);
    TEST_FAILED_HR(hr != S_OK, "CoGetState failed.");
    if ((IUnknown *)pUnkState2 != (IUnknown *)pUnkState1)
	TEST_FAILED(TRUE, "GetState returned wrong value.\n");


    //	test replacement
    hr = CreateBindCtx(0, &pbc2);
    TEST_FAILED_HR(FAILED(hr), "Create BindCtx 2 failed");
    hr = pbc2->QueryInterface(IID_IUnknown, (void **)&pUnkState3);
    TEST_FAILED_HR(FAILED(hr), "QI for IUnknown 2 failed.");

    hr = CoSetState(pUnkState3);
    TEST_FAILED_HR(hr != S_OK, "CoSetState failed.");

    hr = CoGetState(&pUnkState4);
    TEST_FAILED_HR(hr != S_OK, "CoGetState failed.");
    if ((IUnknown *)pUnkState4 != (IUnknown *)pUnkState3)
	TEST_FAILED(TRUE, "GetState returned wrong value.");


    //	test Set/Get NULL
    hr = CoSetState(NULL);
    TEST_FAILED_HR(hr != S_OK, "CoSetState NULL failed.");

    hr = CoGetState(&pUnkState5);
    TEST_FAILED_HR(hr != S_FALSE, "CoGetState NULL failed.");
    if ((IUnknown *)pUnkState5 != NULL)
	TEST_FAILED(TRUE, "GetState NULL returned wrong value.");




    // Test for a bogus class
    hr = CoGetClassObject(CLSID_Invalid, CLSCTX_SERVER, NULL,
	IID_IClassFactory, (void **) &pUnk);

    TEST_FAILED_HR(SUCCEEDED(hr),
	"CoGetClassObject succeed on invalid class!");

    // Bind to something that does not exist either in the registry
    // or anywhere else.
    hr = CreateFileMoniker(L"C:\\KKK.KKK", &pmnk);
    hr = BindMoniker(pmnk, grfOpt, IID_IUnknown, (void **)&pUnk);
    pmnk.Set(NULL);

    TEST_FAILED_HR(SUCCEEDED(hr),
	"Succeeded binding a moniker to a file that doesn't exist!");

/*
 *  Create a file moniker to start with
 */

    hr = CreateFileMoniker(pszPath1, &pmnk);

    TEST_FAILED_HR(FAILED(hr), "CreateFileMoniker Failed");

    hr = BindMoniker(pmnk, grfOpt, IID_IUnknown, (void **)&pUnk);

    TEST_FAILED_HR(FAILED(hr),
	"BindMoniker to file Failed")

    // Confirm bind to same object produces same object pointer

    hr = BindMoniker(pmnk, grfOpt, IID_IUnknown, (void **)&pUnkTheSame);

    TEST_FAILED_HR(FAILED(hr),
	"BindMoniker to file Failed")
#ifdef NOT_YET
    TEST_FAILED((pUnkTheSame != pUnk), "Object pointers not ==\n")
#endif // NOT_YET
    pUnkTheSame.Set(NULL);
    pmnk.Set(NULL);

/*
 *  OK - we've bound to the IUnknown interface, lets
 *  QueryInterface to something more interesting (for test reasons)
 */
    hr = pUnk->QueryInterface(IID_IOleItemContainer,
	(LPVOID FAR*) &poleitmcon);

    TEST_FAILED_HR(FAILED(hr), "Query Interface Failed")

/*
 *  Make sure we get an error when QI'ing for something the server
 *  does not support.
 */
    hr = pUnk->QueryInterface(IID_IDispatch,
	(LPVOID FAR*) &pdispatch);

    TEST_FAILED_HR(SUCCEEDED(hr),
	"QueryInterface to unsupported interface")

    pdispatch.Set(NULL);
    pUnk.Set(NULL);


/*
 * Call get the class ID using IPersistFile
 */

    hr = poleitmcon->GetObject(L"1", 1, NULL, IID_IUnknown,
	(void **) &punk);

    TEST_FAILED_HR(FAILED(hr), "GetObject Failed")

    TEST_FAILED((punk == NULL),
	"GetObject returned a NULL for punk\n")

    poleitmcon.Set(NULL);

    if (TestSetMoniker(punk))
    {
	return 1;
    }

    hr = punk->QueryInterface(IID_IOleLink, (LPVOID FAR*) &poleitmcon);

    TEST_FAILED_HR(SUCCEEDED(hr),
	"Query Interface to invalid interface succeeded")

    punk.Set(NULL);

    // Do moniker tests:
    if (TestBindCtx())
    {
	return TRUE;
    }

    if (TestROT(guidToTest))
    {
	return TRUE;
    }

    return TestMoniker(pszPath1, pszPath2);
}

// TRUE on failure
BOOL TestPrematureDeath()
{
    XMoniker pmnk;
    XUnknown pUnk;
    HRESULT hr;
    TCHAR   tszFileName[MAX_PATH+1];
    HANDLE hTouchFile;
    SYSTEMTIME st1, st2;
    FILETIME ft1, ft2;
    LONG l;
    DWORD dw;

    ZeroMemory(&st1, sizeof(st1));
    ZeroMemory(&st2, sizeof(st2));

    hr = CreateFileMoniker(LocalServerPath4, &pmnk);
    TEST_FAILED_HR(FAILED(hr), "CreateFileMoniker Failed")

    GetSystemDirectory(tszFileName, MAX_PATH+1);
    _tcscat(tszFileName, TEXT("\\failtst.tst"));

    hTouchFile = CreateFileT(tszFileName,
                                   GENERIC_READ|GENERIC_WRITE,
                                   FILE_SHARE_READ|FILE_SHARE_WRITE,
                                   NULL,
                                   OPEN_ALWAYS,
                                   FILE_ATTRIBUTE_NORMAL,
                                   NULL);
    if(hTouchFile == INVALID_HANDLE_VALUE)
    {
        wsprintfA(&wszErrBuf[0], "Couldn't open touch file - err = %x.\n", GetLastError());
        MessageBoxA(NULL, &wszErrBuf[0], szOleBindError, MB_OK);
        return TRUE;
    }

    GetSystemTime(&st1);
    WriteFile(hTouchFile, &st1, sizeof(st1), &dw, NULL);

    l = GetTickCount();

    // This takes awhile, so tell the user
    printf("SCM dead server test (60 sec) started\n");

    hr = BindMoniker(pmnk, 0, IID_IUnknown, (void **)&pUnk);

    TEST_FAILED_HR((hr != CO_E_SERVER_EXEC_FAILURE),
        "Unexpected hr from BindMoniker in premature death test")

    // Tell the BVT guys
    printf("SCM dead server test succeeded\n");

    //
    // The above bind should have caused fail.exe to execute and write a new
    // time to the file as proof of execution.
    //

    SetFilePointer(hTouchFile, 0, NULL, FILE_BEGIN);
    ReadFile(hTouchFile, &st2, sizeof(st2), &dw, NULL);
    CloseHandle(hTouchFile);

    DeleteFileT(tszFileName);

    SystemTimeToFileTime(&st1, &ft1);
    SystemTimeToFileTime(&st2, &ft2);
    if (0 == CompareFileTime(&ft1, &ft2))
    {
        wsprintfA(&wszErrBuf[0], "Test not configured properly: PROGID50(fail.exe) did not run.");
        MessageBoxA(NULL, &wszErrBuf[0], szOleBindError, MB_OK);
        return TRUE;
    }

    if (GetTickCount() - l > 2*60*1000)
    {
        wsprintfA(&wszErrBuf[0], "Premature death test failed: too long to detect death.");
        MessageBoxA(NULL, &wszErrBuf[0], szOleBindError, MB_OK);
        return TRUE;
    }

    return FALSE;
}

char * ConvertPath(LPWSTR pwsz)
{
    static char szPath[MAX_PATH];
    wcstombs(szPath, pwsz, wcslen(pwsz) + 1);
    return szPath;
}

int CreateFile(LPWSTR pwszPath)
{
    // Try to create the file
    int fh = _creat(ConvertPath(pwszPath), _S_IWRITE|S_IREAD);

    // Did file create fail?
    if (fh != -1)
    {
	// Write some data to file -- makes sure docfile won't delete
	// the file.
	_write(fh, "This is a test file\n", sizeof("This is a test file\n"));

	// No -- then set to success and close the newly created file
	_close(fh);
	fh = 0;
    }

    return fh;
}


void CleanUpFiles(void)
{
    // Delete all the test files.
    remove(ConvertPath(InprocPath1));
    remove(ConvertPath(InprocPath2));
    remove(ConvertPath(LocalServerPath1));
    remove(ConvertPath(LocalServerPath2));
    remove(ConvertPath(LocalServerPath4));
    remove(ConvertPath(LongDirShort));
    remove(ConvertPath(LongDirLong));
#if !defined(_CHICAGO_)
    RemoveDirectory(LongDir);
#else
    RemoveDirectory(ConvertPath(LongDir));
#endif
}

int InitFiles(void)
{
    BOOL fRet;

    TCHAR szCurDir[MAX_PATH];
    TCHAR szTmpLongDir[MAX_PATH];
    WCHAR wcCurDir[MAX_PATH];
    WCHAR wcLong[MAX_PATH], *pwcEnd;

    DWORD cCurDir = GetCurrentDirectory(MAX_PATH, szCurDir);

    #ifdef UNICODE
    wcscpy(wcCurDir, szCurDir);
    #else
    mbstowcs(wcCurDir, szCurDir, MAX_PATH);
    #endif

    // Is the current directory the root of a drive?
    if (wcCurDir[cCurDir - 1] == '\\')
    {
	// We bring the string on char back to take into account
	// the fact the string we will concatenate begins with a slash.
	wcCurDir[cCurDir - 1] = 0;
    }

    //	get the pid. we use the pid to identify the files for a particular
    //	run of the test (so we may run multiple instances simultaneously
    //	without interference).

    DWORD dwPid = GetCurrentProcessId();
    char szPid[9];
    _itoa(dwPid, szPid, 16);
    wszPid[0] = L'\\';
#if defined(_CHICAGO_)
    szPid[4] = '\0';   // This is an all platform bug, but zap for Chicago.
#endif
    mbstowcs(&wszPid[1], szPid, strlen(szPid)+1);

    wcscpy(InprocPath1, wcCurDir);
    wcscat(InprocPath1, wszPid);
    wcscat(InprocPath1, INPROC_PATH1);

    wcscpy(InprocPath2, wcCurDir);
    wcscat(InprocPath2, wszPid);
    wcscat(InprocPath2, INPROC_PATH2);

    wcscpy(LocalServerPath1, wcCurDir);
    wcscat(LocalServerPath1, wszPid);
    wcscat(LocalServerPath1, LOCAL_SERVER_PATH1);

    wcscpy(LocalServerPath2, wcCurDir);
    wcscat(LocalServerPath2, wszPid);
    wcscat(LocalServerPath2, LOCAL_SERVER_PATH2);

    wcscpy(LocalServerPath4, wcCurDir);
    wcscat(LocalServerPath4, wszPid);
    wcscat(LocalServerPath4, LOCAL_SERVER_PATH4);

    wcscpy(wcLong, wcCurDir);
    wcscat(wcLong, LONG_DIR);
    wcscpy(LongDir, wcLong);
    pwcEnd = wcLong+wcslen(wcLong);

    wcscpy(pwcEnd, LONG_SHORT_NAME);
    wcscpy(LongDirShort, wcLong);

    wcscpy(pwcEnd, LONG_LONG_NAME);
    wcscpy(LongDirLong, wcLong);

#ifdef _CHICAGO_
        wcscpy(LongDirLongSe, wcCurDir);
        wcscat(LongDirLongSe, LONG_DIR);

#else
    wcscpy(pwcEnd, LONG_LONG_SHORT_EQUIV);
    wcscpy(LongDirLongSe, wcLong);
#endif // _CHICAGO_

    // Delete any files that exist
    CleanUpFiles();

    // Create a file for each test file needed.
    TEST_FAILED(CreateFile(InprocPath1),
	"Couldn't create first test file!\n");
    TEST_FAILED(CreateFile(InprocPath2),
	"Couldn't create second test file!\n");
    TEST_FAILED(CreateFile(LocalServerPath1),
	"Couldn't create third test file!\n");
    TEST_FAILED(CreateFile(LocalServerPath2),
	"Couldn't create fourth test file!\n");
    TEST_FAILED(CreateFile(LocalServerPath4),
	"Couldn't create fifth test file!\n");

#if !defined(_CHICAGO_)
    fRet = CreateDirectory(LongDir, NULL);
#else
    fRet = CreateDirectory(ConvertPath(LongDir), NULL);
#endif
    TEST_FAILED(!fRet, "Couldn't create long directory\n");
    TEST_FAILED(CreateFile(LongDirShort),
	"Couldn't create short file in long directory\n");
    TEST_FAILED(CreateFile(LongDirLong),
	"Couldn't create long file in long directory\n");

    #ifdef UNICODE
    TEST_FAILED(!GetShortPathName(LongDirLong,
				 LongDirLongSe,
				 sizeof(LongDirLongSe)),
		"Couldn't GetShortPathname of long directory\n");
    #else

    TEST_FAILED(!GetShortPathNameT(ConvertPath(LongDirLong),
				 szCurDir,
				 sizeof(szCurDir)),
		"Couldn't GetShortPathname of long directory\n");

    mbstowcs(LongDirLongSe, szCurDir, strlen(szCurDir)+1);

    #endif

    return 0;
}


DWORD CallCoInitUninit(void *)
{
    // Initialize
    HRESULT hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);

    if (SUCCEEDED(hr))
    {
        // Uninitialize
        CoUninitialize();
    }

    // Return value from function. Note that this is not really used because
    // there is a potential race
    return (DWORD) hr;
}

BOOL DoFreeThreadMultiInitTest(void)
{
    //
    // Get an OLE object in another process
    //
    IClassFactory *pIClassFactory;

    HRESULT hr = CoGetClassObject(
        CLSID_AdvBnd,
        CLSCTX_LOCAL_SERVER,
        NULL,
        IID_IClassFactory,
        (void **) &pIClassFactory);

    TEST_FAILED_HR((hr != NOERROR),
        "DoFreeThreadMultiInitTest CoGetClassObject")

    //
    // Create another thread which does a matching call to
    // CoInitialize/Uninitialize and then exits.
    //

    // Create the thread
    DWORD dwIdUnused;

    HANDLE hInitThread = CreateThread(
        NULL,           // Security - none
        0,              // Stack - use the same as the primary thread
        CallCoInitUninit, // Entry point for thread
        NULL,           // Parameter to the thread - not used.
        0,              // Run this thread immediately (if not sooner).
        &dwIdUnused);   // Id of thread - not used.

    // Did the create succeed?
    TEST_FAILED_LAST_ERROR((NULL == hInitThread),
        "DoFreeThreadMultiInitTest CreateThread")

    // Wait for the thread to do its work
    DWORD dwRes = WaitForSingleObject(hInitThread, INFINITE);

    // Did something terrible happen?
    TEST_FAILED_LAST_ERROR((WAIT_FAILED == dwRes),
        "DoFreeThreadMultiInitTest WaitForSingleObject")

    // Get the result from the thread
    BOOL fGetExitCode = GetExitCodeThread(hInitThread, (DWORD *) &hr);

    TEST_FAILED_LAST_ERROR(!fGetExitCode,
        "DoFreeThreadMultiInitTest GetExitCodeThread")

    // Free handles we no longer need
    CloseHandle(hInitThread);

    //
    // Validate the object we originally got is still alive and well.
    //
    IUnknown *punk;

    hr = pIClassFactory->CreateInstance(NULL, IID_IUnknown, (void **) &punk);

    TEST_FAILED_HR((hr != NOERROR),
        "DoFreeThreadMultiInitTest CoGetClassObject")

    // Free the objects we got in this routine.
    pIClassFactory->Release();
    punk->Release();

    return FALSE;
}




//+--------------------------------------------------------------
// Function:    Main
//
// Synopsis:    Executes the BasicBnd test
//
// Effects:     None
//
//
// Returns:     Exits with exit code 0 if success, 1 otherwise
//
// History:     05-Mar-92   Sarahj   Created
//
//---------------------------------------------------------------

int _cdecl main(int argc, char *argv[])
{
    BOOL          fFailed = FALSE;
    HRESULT       hr;

    if (argc > 1)
    {
	if (!strcmp(argv[1], "M"))
	    goto multithreading;
    }

    // BUGBUG: 1-18-95 To be implemented    BruceMa
    // Correlate the platform we're running on and the platform
    // we built for


    // Write thread mode to initialization file.
    fFailed = !WriteProfileString(
                    TEXT("TestSrv"),
                    TEXT("ThreadMode"),
		    TEXT("ApartmentThreaded"));

    if (fFailed)
    {
        wsprintfA(&wszErrBuf[0], "Failed writing TestSrv profile string.");
        MessageBoxA(NULL, &wszErrBuf[0], szOleBindError, MB_OK);
        goto exit_main;
    }

    fFailed = !WriteProfileString(
                    TEXT("OleSrv"),
                    TEXT("ThreadMode"),
		    TEXT("ApartmentThreaded"));

    if (fFailed)
    {
        wsprintfA(&wszErrBuf[0], "Failed writing OleSrv profile string.");
        MessageBoxA(NULL, &wszErrBuf[0], szOleBindError, MB_OK);
        goto exit_main;
    }

    // Set up test files
    fFailed = InitFiles();
    if (fFailed)
    {
	goto exit_main;
    }

    // Test repeated calls to CoInitialize
    hr = CoInitialize(NULL);

    TEST_FAILED_HR(FAILED(hr), "CoInitialize Failed")

    // must be called before any other OLE API
    hr = OleInitialize(NULL);

    TEST_FAILED_HR(FAILED(hr), "OleInitialize Failed")

    // Call CoUnitialize and see how the rest of the program works!
    CoUninitialize();

    // Test stdmalloc
    if (fFailed = TestStdMalloc())
    {
	goto exit_init;
    }

    fFailed =
	DoTest(CLSID_BasicBnd, InprocPath1, InprocPath2);

    if (fFailed)
    {
	printf( "\nOLE failed in Single Threaded Apartment pass.\n" );
	goto exit_init;
    }

    printf("BasicBnd tests succeeded\n");

    fFailed =
	DoTest(CLSID_AdvBnd, LocalServerPath1, LocalServerPath1);

    if (fFailed)
    {
	printf( "\nOLE failed in Single Threaded Apartment pass.\n" );
	goto exit_init;
    }

    printf("AdvBnd tests succeeded\n");

    if (TestPrematureDeath())
    {
	printf("\nOLE failed testing server premature death.\n");
        goto exit_init;
    }

    OleUninitialize();

    CleanUpFiles();

multithreading:

#ifdef MULTI_THREADING
    // Run the whole thing all over again.

    // Write thread mode to initialization file.
    fFailed = !WriteProfileString(
                    TEXT("TestSrv"),
                    TEXT("ThreadMode"),
		    TEXT("ApartmentThreaded"));

    if (fFailed)
    {
	wsprintfA(&wszErrBuf[0], "Failed writing TestSrv profile string.");
        MessageBoxA(NULL, &wszErrBuf[0], szOleBindError, MB_OK);
        goto exit_main;
    }

    fFailed = !WriteProfileString(
                    TEXT("OleSrv"),
                    TEXT("ThreadMode"),
                    TEXT("MultiThreaded"));

    if (fFailed)
    {
	wsprintfA(&wszErrBuf[0], "Failed writing OleSrv profile string.");
        MessageBoxA(NULL, &wszErrBuf[0], szOleBindError, MB_OK);
        goto exit_main;
    }

    // Set up test files
    if (InitFiles())
    {
        fFailed = TRUE;
	goto exit_main;
    }

    // Mark the dll in the registry as "ThreadingdModel: Free"
    if (!SetRegistryThreadingModel(InprocPath1, L"Free"))
    {
        wsprintfA(&wszErrBuf[0], "Failed trying to set reg ThreadingModel.");
        MessageBoxA(NULL, &wszErrBuf[0], szOleBindError, MB_OK);
        goto exit_main;
    }

    // Test repeated calls to CoInitialize
    hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);

    TEST_FAILED_HR(FAILED(hr), "CoInitializeEx Multi Threaded Failed")

    // must be called before any other OLE API
    hr = CoInitializeEx(NULL, COINIT_MULTITHREADED);

    TEST_FAILED_HR(FAILED(hr), "CoInitializeEx Multi Threaded Failed")

    // Call CoUnitialize and see how the rest of the program works!
    CoUninitialize();

    // Test stdmalloc
    if (fFailed = TestStdMalloc())
    {
	goto exit_init;
    }

    fFailed =
	DoTest(CLSID_BasicBnd, InprocPath1, InprocPath2);
    if (fFailed)
    {
	printf( "\nOLE failed in Multi Threaded Apartment pass.\n" );
	goto exit_init;
    }

    fFailed =
	DoTest(CLSID_AdvBnd, LocalServerPath1, LocalServerPath1);

    if (fFailed)
    {
	printf( "\nOLE failed in Multi Threaded Apartment pass.\n" );
	goto exit_init;
    }

    // Do CoInitialize/Uninitialize on second thread to make sure
    // that other threads initialize/uninitialize do not effect
    // the running of the test.
    if (fFailed = DoFreeThreadMultiInitTest())
    {
	printf( "\nOLE failed in Multi Threaded InitTest.\n" );
        goto exit_init;
    }

#endif // MULTI_THREADING


exit_init:

    CoUninitialize();

    // Remove the dll's threading model registration
    ResetRegistryThreadingModel(InprocPath1);


exit_main:

    CleanUpFiles();

    if (!fFailed)
    {
	printf("\nOLE: PASSED\n");
    }
    else
    {
	printf("\nOLE: FAILED\n");
    }

    return fFailed;
}



//+--------------------------------------------------------
//
//  Function:  SetRegistryThreadingModel
//
//  Algorithm: Set the threading model for the InprocServer32 associated
//             with the file pwszFile tp pwszThreadingModel
//
//  History:   17-Jan-95  BruceMa       Created
//
//---------------------------------------------------------
BOOL SetRegistryThreadingModel(WCHAR *pwszFile, WCHAR *pwszThreadingModel)
{
    DWORD  dwRESERVED = 0;
    WCHAR  wszExt[8];
    HKEY   hKey;
    WCHAR  wszProgId[32];
    DWORD  dwValueType;
    WCHAR  wszCLSID[64];
    HKEY   hClsidKey;
    HKEY   hInproc32Key;
    ULONG  cbValue;


    // Strip the extension off the file name
    int k = wcslen(pwszFile) - 1;
    while (k > 0  &&  pwszFile[k] != L'.')
    {
        k--;
    }
    if (k >= 0  &&  pwszFile[k] == L'.')
    {
        for (int j = 0; pwszFile[k]; j++, k++)
        {
            wszExt[j] = pwszFile[k];
        }
        wszExt[j] = L'\0';
    }
    else
    {
        return FALSE;
    }

    // Open the key for the specified extension
    if (RegOpenKeyEx(HKEY_CLASSES_ROOT, wszExt, dwRESERVED,
                     KEY_READ, &hKey) != ERROR_SUCCESS)
    {
        return FALSE;
    }

    // Read the ProgId for the extension
    cbValue = 32;
    if (RegQueryValueEx(hKey, NULL, NULL, &dwValueType,
                        (LPBYTE) wszProgId, &cbValue) != ERROR_SUCCESS)
    {
        CloseHandle(hKey);
        return FALSE;
    }

    // Open the ProgIdKey
    CloseHandle(hKey);
    if (RegOpenKeyEx(HKEY_CLASSES_ROOT, wszProgId, dwRESERVED,
                     KEY_READ, &hKey) != ERROR_SUCCESS)
    {
        return FALSE;
    }

    // Open the associated CLSID key
    if (RegOpenKeyEx(hKey, L"CLSID", dwRESERVED,
                     KEY_READ, &hClsidKey) != ERROR_SUCCESS)
    {
        CloseHandle(hKey);
        return FALSE;
    }

    // Read the CLSID associated with the ProgId
    cbValue = 128;
    if (RegQueryValueEx(hClsidKey, NULL, NULL, &dwValueType,
                        (LPBYTE) wszCLSID, &cbValue) != ERROR_SUCCESS)
    {
        CloseHandle(hClsidKey);
        CloseHandle(hKey);
        return FALSE;
    }

    // Open the HKEY_CLASSES_ROOT\CLSID key
    CloseHandle(hClsidKey);
    CloseHandle(hKey);
    if (RegOpenKeyEx(HKEY_CLASSES_ROOT, L"CLSID", dwRESERVED,
                     KEY_READ, &hKey) != ERROR_SUCCESS)
    {
        return FALSE;
    }

    // Open the key to our clsid
    if (RegOpenKeyEx(hKey, wszCLSID, dwRESERVED,
                     KEY_READ, &hClsidKey) != ERROR_SUCCESS)
    {
        CloseHandle(hKey);
        return FALSE;
    }

    // Open the InprocServer32 key
    CloseHandle(hKey);
    if (RegOpenKeyEx(hClsidKey, L"InprocServer32", dwRESERVED,
                     KEY_SET_VALUE, &hInproc32Key) != ERROR_SUCCESS)
    {
        CloseHandle(hClsidKey);
        return FALSE;
    }

    // Set the threading model for this InprocServer32 key
    CloseHandle(hClsidKey);
    if (RegSetValueEx(hInproc32Key, L"ThreadingModel", dwRESERVED,
                      REG_SZ, (LPBYTE) pwszThreadingModel,
                      (wcslen(pwszThreadingModel)+1) * sizeof(WCHAR))
        != ERROR_SUCCESS)
    {
        CloseHandle(hInproc32Key);
        return FALSE;
    }

    // Close the InprocServer32 key and return success
    CloseHandle(hInproc32Key);
    return TRUE;
}









//+--------------------------------------------------------
//
//  Function:  ResetRegistryThreadingModel
//
//  Algorithm: Remove the threading model for the InprocServer32 associated
//             with the file pwszFile
//
//  History:   17-Jan-95  BruceMa       Created
//
//---------------------------------------------------------
BOOL ResetRegistryThreadingModel(WCHAR *pwszFile)
{
    DWORD  dwRESERVED = 0;
    WCHAR  wszExt[8];
    HKEY   hKey;
    WCHAR  wszProgId[32];
    DWORD  dwValueType;
    WCHAR  wszCLSID[64];
    HKEY   hClsidKey;
    HKEY   hInproc32Key;
    ULONG  cbValue;


    // Strip the extension off the file name
    int k = wcslen(pwszFile) - 1;
    while (k > 0  &&  pwszFile[k] != L'.')
    {
        k--;
    }
    if (k >= 0  &&  pwszFile[k] == L'.')
    {
        for (int j = 0; pwszFile[k]; j++, k++)
        {
            wszExt[j] = pwszFile[k];
        }
        wszExt[j] = L'\0';
    }
    else
    {
        return FALSE;
    }

    // Open the key for the specified extension
    if (RegOpenKeyEx(HKEY_CLASSES_ROOT, wszExt, dwRESERVED,
                     KEY_READ, &hKey) != ERROR_SUCCESS)
    {
        return FALSE;
    }

    // Read the ProgId for the extension
    cbValue = 32;
    if (RegQueryValueEx(hKey, NULL, NULL, &dwValueType,
                        (LPBYTE) wszProgId, &cbValue) != ERROR_SUCCESS)
    {
        CloseHandle(hKey);
        return FALSE;
    }

    // Open the ProgIdKey
    CloseHandle(hKey);
    if (RegOpenKeyEx(HKEY_CLASSES_ROOT, wszProgId, dwRESERVED,
                     KEY_READ, &hKey) != ERROR_SUCCESS)
    {
        return FALSE;
    }

    // Open the associated CLSID key
    if (RegOpenKeyEx(hKey, L"CLSID", dwRESERVED,
                     KEY_READ, &hClsidKey) != ERROR_SUCCESS)
    {
        CloseHandle(hKey);
        return FALSE;
    }

    // Read the CLSID associated with the ProgId
    cbValue = 128;
    if (RegQueryValueEx(hClsidKey, NULL, NULL, &dwValueType,
                        (LPBYTE) wszCLSID, &cbValue) != ERROR_SUCCESS)
    {
        CloseHandle(hClsidKey);
        CloseHandle(hKey);
        return FALSE;
    }

    // Open the HKEY_CLASSES_ROOT\CLSID key
    CloseHandle(hClsidKey);
    CloseHandle(hKey);
    if (RegOpenKeyEx(HKEY_CLASSES_ROOT, L"CLSID", dwRESERVED,
                     KEY_READ, &hKey) != ERROR_SUCCESS)
    {
        return FALSE;
    }

    // Open the key to our clsid
    if (RegOpenKeyEx(hKey, wszCLSID, dwRESERVED,
                     KEY_READ, &hClsidKey) != ERROR_SUCCESS)
    {
        CloseHandle(hKey);
        return FALSE;
    }

    // Open the InprocServer32 key
    CloseHandle(hKey);
    if (RegOpenKeyEx(hClsidKey, L"InprocServer32", dwRESERVED,
                     KEY_SET_VALUE, &hInproc32Key) != ERROR_SUCCESS)
    {
        CloseHandle(hClsidKey);
        return FALSE;
    }

    // Reset the threading model for this InprocServer32 key
    CloseHandle(hClsidKey);
    if (RegDeleteValue(hInproc32Key, TEXT("ThreadingModel")) != ERROR_SUCCESS)
    {
        CloseHandle(hInproc32Key);
        return FALSE;
    }

    // Close the InprocServer32 key and return success
    CloseHandle(hInproc32Key);
    return TRUE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\ole1\srvrdemo\srvrdemo.h ===
/*
  OLE SERVER DEMO
  SrvrDemo.h

  This file contains typedefs, defines, global variable declarations, and
  function prototypes.

  (c) Copyright Microsoft Corp. 1990 - 1992 All Rights Reserved
*/



/*
   Explanation of Function Comments.

   Every function has a comment preceding it which gives the following
   information:

   1) Function name.
   2) A description of what the function does.
   3) A list of parameters, each with its type and a short description.
   4) A list of return values, each with an explanation of the condition that
      will cause the function to return that value.
   5) A customization section giving tips on how to customize this function
      for your OLE application.
      If the customization section says "None" then you may find the function
      usable as is.
      If the customization section says "Re-implement" then the function
      should still serve the same purpose and do what is indicated in the
      function comment, but will probably need to be re-implemented for
      your particular application.  Any Server Demo code relating to OLE
      will be useful as a guide in your re-implementation.
      If the customization section says "Server Demo specific" then the
      function will probably have no counterpart in your application.
*/


/* Menu Identifiers */

// File menu

#define IDM_NEW      100
#define IDM_OPEN     101
#define IDM_SAVE     102
#define IDM_SAVEAS   103
#define IDM_EXIT     104
#define IDM_ABOUT    105
#define IDM_UPDATE   106

// Edit menu

#define IDM_CUT      107
#define IDM_COPY     108
#define IDM_DELETE   109

// Color menu

#define IDM_RED      110
#define IDM_GREEN    111
#define IDM_BLUE     112
#define IDM_WHITE    113
#define IDM_GRAY     114
#define IDM_CYAN     115
#define IDM_MAGENTA  116
#define IDM_YELLOW   117

// New object menu

#define IDM_NEWOBJ   118
#define IDM_NEXTOBJ  119

#define IDD_CONTINUEEDIT    120
#define IDD_UPDATEEXIT      121
#define IDD_TEXT            122

#define OBJECT_WIDTH        120
#define OBJECT_HEIGHT       60

// number HIMETRIC units per inch
#define  HIMETRIC_PER_INCH  2540

/* Types */

// Document type

typedef enum
{
    doctypeNew,      // The document is untitled.
    doctypeFromFile, // The document exists in a file and may be linked.
    doctypeEmbedded  // The document is an embedded document.
} DOCTYPE;


// Device context type, passed to DrawObj.

typedef enum
{
   dctypeScreen,
   dctypeBitmap,
   dctypeMetafile,
   dctypeEnhMetafile
} DCTYPE ;


// Version

typedef WORD VERSION;


// Verb

typedef enum
{
   verbPlay = OLEVERB_PRIMARY,
   verbEdit
} VERB;


// Server structure

typedef struct
{
    OLESERVER     olesrvr;        // This must be the first field so that
                                  //   an LPOLESERVER can be cast to a SRVR*.
    LHSERVER      lhsrvr;         // Registration handle
} SRVR ;


// How many objects (distinct numbers) will we allow?
#define cfObjNums 20

// How many distinct clients can be associated with the object?
#define clpoleclient 20


// Document structure

typedef struct
{
    OLESERVERDOC oledoc;      // This must be the first field so that an
                              //   LPOLESERVERDOC can be cast to an DOC*.
    LHSERVERDOC  lhdoc;       // Registration handle
    DOCTYPE      doctype;     // Document type
    ATOM         aName;       // Document name
    HPALETTE     hpal;        // Handle to a logical color palette
    BYTE         rgfObjNums[cfObjNums+1]; // What object numbers have been used
} DOC, *DOCPTR ;


// Native data structure

typedef struct
{
    INT         idmColor;
    INT         nWidth;
    INT         nHeight;
    INT         nX;
    INT         nY;
    INT         nHiMetricWidth;  // Used by an object handler.  These two fields
    INT         nHiMetricHeight; // always correspond to nWidth and nHeight.
    VERSION     version;
    CHAR        szName[10];      // "Object nn"
} NATIVE, FAR *LPNATIVE;


// Object structure

/* Ordinarily, an OBJ structure would not contain native data.  Rather, it
   would contain a pointer (or some other reference) to the native data.
   This method would allow multiple objects containing the same native data.
   Each OBJ structure would be created on the fly when some portion of the
   document was to be made into an object.  Each OBJ structure would have
   only one LPOLECLIENT, which would be passed in to DocGetObject.
*/

typedef struct
{
    OLEOBJECT   oleobject;   // This must be the first field so that an
                             //   LPOLEOBJECT can be cast to a LPOBJ.
    HANDLE      hObj;        // A circular handle to this structure,
                             //   used to delete this structure.
    LPOLECLIENT lpoleclient[clpoleclient];
                             // Clients associated with the object.
                             //   The array is NULL terminated.
    HWND        hwnd;        // The object's own window
    ATOM        aName;       // Unique identifier for each object within a doc
    HPALETTE    hpal;        // Logical palette to use in drawing object
    NATIVE      native;      // Object data in native format
} OBJ, FAR *LPOBJ ;

typedef struct {
    CHAR     *pClassName;
    CHAR     *pFileSpec;
    CHAR     *pHumanReadable;
    CHAR     *pExeName;
}  CLASS_STRINGS;



/* Defines */

// The name of the application, used in message boxes and title bars.
#define szAppName        "Server Demo10"

// THe class name in the registration database.
#define szClassName      "SrvrDemo10"

// Used to check for "-Embedding" on command line.
#define szEmbeddingFlag  "Embedding"

// Maximum length of a fully-qualified pathname.
#define cchFilenameMax   256

// Maximum number of HBRUSHes.
#define chbrMax          9

// Number of extra bytes in the window structure for an object
#define cbWindExtra 4

// Offset (in the extra space) of the pointer to the object
#define ibLpobj          0



/* Global variable declarations.  (See SrvrDemo.c for descriptions.) */

extern HANDLE           hInst;
extern HWND             hwndMain;
extern SRVR             srvrMain;
extern DOC              docMain;
extern BOOL             fDocChanged;
extern BOOL             fEmbedding;
extern BOOL             fRevokeSrvrOnSrvrRelease;
extern BOOL             fWaitingForDocRelease;
extern BOOL             fWaitingForSrvrRelease;
extern BOOL             fUnblock;
extern CHAR             szClient[];
extern CHAR             szClientDoc[];
extern HBRUSH           hbrColor[chbrMax];
extern VERSION          version;
extern OLECLIPFORMAT    cfObjectLink;
extern OLECLIPFORMAT    cfOwnerLink;
extern OLECLIPFORMAT    cfNative;
extern OLESERVERDOCVTBL docvtbl;
extern OLEOBJECTVTBL    objvtbl;
extern OLESERVERVTBL    srvrvtbl;



/* Function Prototypes */

// Various functions

BOOL  CreateDocFromFile (LPSTR lpszDoc, LHSERVERDOC lhdoc, DOCTYPE doctype);
BOOL  CreateNewDoc (LONG lhdoc, LPSTR lpszDoc, DOCTYPE doctype);
LPOBJ CreateNewObj (BOOL fDoc_Changed);
VOID  CutOrCopyObj (BOOL fOpIsCopy);
VOID  DestroyDoc (VOID);
VOID  DestroyObj (HWND hwnd);
VOID  DeviceToHiMetric ( LPPOINT lppt);
VOID  EmbeddingModeOff (VOID) ;
VOID  EmbeddingModeOn (VOID);
VOID  UpdateFileMenu (INT);
VOID  ErrorBox (CHAR *jwf);
BOOL  GetFileOpenFilename (LPSTR lpszFilename);
BOOL  GetFileSaveFilename (LPSTR lpszFilename);
VOID  HiMetricToDevice ( LPPOINT lppt);
LPOBJ HwndToLpobj (HWND hwndObj);
BOOL  InitServer (HWND hwnd, HANDLE hInst);
VOID  InitVTbls (VOID);
BOOL  OpenDoc (VOID);
VOID  PaintObj (HWND hwnd);
OLESTATUS RevokeDoc (VOID);
VOID  RevokeObj (LPOBJ lpobj);
INT   SaveChangesOption (BOOL *pfUpdateLater);
BOOL  SaveDoc (VOID);
BOOL  SaveDocAs (VOID);
VOID  SavedServerDoc (VOID);
LPOBJ SelectedObject (VOID);
HWND  SelectedObjectWindow (VOID);
VOID  SendDocMsg (WORD wMessage );
VOID  SendObjMsg (LPOBJ lpobj, WORD wMessage);
VOID  SetTitle (LPSTR lpszDoc, BOOL bEmbedded);
VOID  SetHiMetricFields (LPOBJ lpobj);
VOID  SizeClientArea (HWND hwndMain, RECT rectReq, BOOL fFrame);
VOID  SizeObj (HWND hwnd, RECT rect, BOOL fMove);
OLESTATUS StartRevokingServer (VOID);
VOID  Wait (BOOL *pf);
LPSTR Abbrev (LPSTR lpsz);
BOOL  APIENTRY fnFailedUpdate (HWND, UINT, WPARAM, LONG);
int   Main(USHORT argc, CHAR **argv) ;

// Window handlers

BOOL  APIENTRY About       (HWND, UINT, WPARAM, LPARAM);
LONG  APIENTRY MainWndProc (HWND, UINT, WPARAM, LPARAM);
LONG  APIENTRY ObjWndProc  (HWND, UINT, WPARAM, LPARAM);


// Server methods

OLESTATUS  APIENTRY SrvrCreate (LPOLESERVER, LHSERVERDOC, OLE_LPCSTR, OLE_LPCSTR, LPOLESERVERDOC FAR *);
OLESTATUS  APIENTRY SrvrCreateFromTemplate (LPOLESERVER, LHSERVERDOC, OLE_LPCSTR, OLE_LPCSTR, OLE_LPCSTR, LPOLESERVERDOC FAR *);
OLESTATUS  APIENTRY SrvrEdit (LPOLESERVER, LHSERVERDOC, OLE_LPCSTR, OLE_LPCSTR, LPOLESERVERDOC FAR * );
OLESTATUS  APIENTRY SrvrExecute (LPOLESERVER, HANDLE);
OLESTATUS  APIENTRY SrvrExit (LPOLESERVER);
OLESTATUS  APIENTRY SrvrOpen (LPOLESERVER, LHSERVERDOC, OLE_LPCSTR, LPOLESERVERDOC FAR *);
OLESTATUS  APIENTRY SrvrRelease (LPOLESERVER);

// Document methods

OLESTATUS  APIENTRY DocClose (LPOLESERVERDOC);
OLESTATUS  APIENTRY DocExecute (LPOLESERVERDOC, HANDLE);
OLESTATUS  APIENTRY DocGetObject (LPOLESERVERDOC, OLE_LPCSTR, LPOLEOBJECT FAR *, LPOLECLIENT);
OLESTATUS  APIENTRY DocRelease (LPOLESERVERDOC);
OLESTATUS  APIENTRY DocSave (LPOLESERVERDOC);
OLESTATUS  APIENTRY DocSetColorScheme (LPOLESERVERDOC, OLE_CONST LOGPALETTE FAR*);
OLESTATUS  APIENTRY DocSetDocDimensions (LPOLESERVERDOC, OLE_CONST RECT FAR *);
OLESTATUS  APIENTRY DocSetHostNames (LPOLESERVERDOC, OLE_LPCSTR, OLE_LPCSTR);

// Object methods

OLESTATUS  APIENTRY ObjDoVerb (LPOLEOBJECT, UINT, BOOL, BOOL);
OLESTATUS  APIENTRY ObjGetData (LPOLEOBJECT, OLECLIPFORMAT, LPHANDLE);
LPVOID     APIENTRY ObjQueryProtocol (LPOLEOBJECT, OLE_LPCSTR);
OLESTATUS  APIENTRY ObjRelease (LPOLEOBJECT);
OLESTATUS  APIENTRY ObjSetBounds (LPOLEOBJECT, OLE_CONST RECT FAR*);
OLESTATUS  APIENTRY ObjSetColorScheme (LPOLEOBJECT, OLE_CONST LOGPALETTE FAR*);
OLESTATUS  APIENTRY ObjSetData (LPOLEOBJECT, OLECLIPFORMAT, HANDLE);
OLESTATUS  APIENTRY ObjSetTargetDevice (LPOLEOBJECT, HANDLE);
OLESTATUS  APIENTRY ObjShow (LPOLEOBJECT, BOOL);
OLECLIPFORMAT  APIENTRY ObjEnumFormats (LPOLEOBJECT, OLECLIPFORMAT);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\olebind\tmoniker.h ===
#ifndef __TMONIKER_H__
#define __TMONIKER_H__

BOOL TestBindCtx(void);

BOOL TestROT(REFCLSID clsid);

BOOL TestMoniker(LPWSTR pszPath1, LPWSTR pszPath2);

#endif // __TMONIKER_H__
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\olebind\tmoniker.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1993.
//
//  File:       tmoniker.cxx
//
//  Contents:
//
//  Classes:
//
//  Functions:
//
//  History:    12-31-93   ErikGav   Chicago port
//
//----------------------------------------------------------------------------

// moniker.cxx : various tests related to monikers...
//

#pragma optimize("",off)
#include <stdio.h>
#include <windows.h>
#include <ole2.h>
#include "olebind.hxx"
#include "tmoniker.h"

STDAPI_(LPSTREAM) CreateMemStm(DWORD cb, LPHANDLE phdl);

//  BUGBUG: Make this test more extensive -- all operations on a
//          bind context should be verified.
BOOL TestBindCtx( void )
{
        XBindCtx pbc;
        XUnknown punk;
        XUnknown punk2;

        HRESULT hr = CreateBindCtx(0, &pbc);

        TEST_FAILED_HR(FAILED(hr), "CreateBindCtx Failed")

        hr = pbc->RegisterObjectParam(L"Key1", pbc);

        TEST_FAILED_HR(FAILED(hr), "RegisterObjectParam Failed")

        hr = pbc->GetObjectParam(L"Key1", &punk2);

        TEST_FAILED_HR(FAILED(hr), "GetObjectParam Failed")

        TEST_FAILED((pbc != punk2),
            "Failure to get registered object parameter")

        // BUGBUG:  What do we test for here?
        punk2.Set(NULL);

        hr = pbc->GetObjectParam(L"Key2", &punk2);

        TEST_FAILED_HR((hr != E_FAIL),
            "GetObjectParam with bad key did not return an error")

        TEST_FAILED((punk2 != NULL),
            "Bad GetObjectParam did not return NULL for object")

        hr = pbc->RegisterObjectParam(L"Key2", pbc);

        TEST_FAILED_HR(FAILED(hr), "Second RegisterObjectParam Failed")

        hr = pbc->GetObjectParam(L"Key2", &punk);

        TEST_FAILED_HR(FAILED(hr), "GetObjectParam on second Failed")

        TEST_FAILED((pbc != punk),
            "Failure on second to get registered object parameter")

        // BUGBUG:  What do we check?
        punk.Set(NULL);

        hr = pbc->RevokeObjectParam(L"Key2");

        TEST_FAILED_HR(FAILED(hr),
            "RevokeObjectParam of Key2 Failed")

        hr = pbc->GetObjectParam(L"Key2", &punk);

        TEST_FAILED_HR((hr != E_FAIL),
            "Get of revoked Key2 returned success")

        TEST_FAILED((punk != NULL),
            "Value returned on get of revoked key2")

        hr = pbc->RevokeObjectParam(L"Key1");

        TEST_FAILED_HR(FAILED(hr),
            "RevokeObjectParam of Key1 Failed")

        return FALSE;
}

BOOL VerifyFileMoniker(LPWSTR wcsFile)
{
    HRESULT hr;
    XMoniker   pmk;
    XBindCtx   pbc;
    LPWSTR wcsDisplayName = NULL;

    hr = CreateBindCtx(0,&pbc);
    TEST_FAILED_HR(FAILED(hr), "CreateBindCtx");

    hr = CreateFileMoniker(wcsFile,&pmk);
    TEST_FAILED_HR(FAILED(hr), "CreateFileMoniker failed");

    hr = pmk->GetDisplayName(pbc,NULL,&wcsDisplayName);
    TEST_FAILED_HR(FAILED(hr), "GetDisplayName failed");

    if (0 != wcscmp(wcsFile,wcsDisplayName))
    {
        wsprintfA(&wszErrBuf[0], "(%S) doesn't match displayname (%S)",wcsFile,wcsDisplayName);
        MessageBoxA(NULL, &wszErrBuf[0], szOleBindError, MB_OK);
	hr = E_FAIL;
    }

    CoTaskMemFree(wcsDisplayName);
    return(hr);
}
BOOL TestMoniker(LPWSTR pszPath1, LPWSTR pszPath2)
{
    XUnknown   pUnk;
    XUnknown   pUnk1;
    XBindCtx   pbc;
    XMoniker   pmk1;
    XMoniker   pmk2;
    XMoniker   pmk3;
    XMoniker   pmk4;
    XMoniker   pmk5;
    XMoniker   pmk6;
    XMoniker   pmkItem1;
    XMoniker   pmkItem2;
    XMoniker   pmkAnti;
    XStream    pStm;
    XOleObject pObj;
    XMalloc    pIMalloc;
    XMoniker   pmkLong1;
    XMoniker   pmkLong2;
    XRunningObjectTable prot;

    ULONG chEaten;
    LPWSTR szName;
    LARGE_INTEGER large_int;
    HRESULT hr;

    //
    // Test the dotdot eating methods
    //
    VerifyFileMoniker(L".");
    VerifyFileMoniker(L"..\\");

    VerifyFileMoniker(L"foo.bar");
    VerifyFileMoniker(L".foo.bar");
    VerifyFileMoniker(L".foo..bar");
    VerifyFileMoniker(L"..foo.bar");
    VerifyFileMoniker(L"..foo..bar");

    VerifyFileMoniker(L"foo\\bar");
    VerifyFileMoniker(L"foo\\.bar");
    VerifyFileMoniker(L"foo\\..bar");

    VerifyFileMoniker(L".foo\\bar");
    VerifyFileMoniker(L".foo\\.bar");
    VerifyFileMoniker(L".foo\\..bar");

    VerifyFileMoniker(L"..foo\\bar");
    VerifyFileMoniker(L"..foo\\.bar");
    VerifyFileMoniker(L"..foo\\..bar");

    VerifyFileMoniker(L"...foo\\bar");
    VerifyFileMoniker(L"...foo\\.bar");
    VerifyFileMoniker(L"...foo\\..bar");

    VerifyFileMoniker(L"\\foo\\bar");
    VerifyFileMoniker(L"\\.foo\\bar");
    VerifyFileMoniker(L"\\..foo\\bar");

    VerifyFileMoniker(L"..\\foo\\bar");
    VerifyFileMoniker(L"..\\.foo\\bar");
    VerifyFileMoniker(L"..\\..foo\\bar");

    hr = CoGetMalloc(MEMCTX_TASK, &pIMalloc);

    TEST_FAILED_HR(FAILED(hr), "CoGetMalloc failed");

    hr = CreateFileMoniker(pszPath1, &pmk1);

    TEST_FAILED_HR(FAILED(hr), "CreateFileMoniker for path1 failed!")

    TEST_FAILED((pmk1 == NULL),
        "CreateFileMoniker returned a null moniker ptr")

    hr = CreateBindCtx(0, &pbc);

    TEST_FAILED_HR(FAILED(hr),
        "CreateBindCtx File Moniker GetDisplayName failed!")

    hr = pmk1->GetDisplayName(pbc, NULL, &szName);

    //  release it
    pbc.Set(NULL, FALSE);

    TEST_FAILED_HR(FAILED(hr), "File Moniker GetDisplayName failed!");

    // BUGBUG: The following is an inappropriate test.
    // TEST_FAILED((lstrcmp(szName, pszPath1) != 0), "Wrong path from file mon");

    // Free the path
    pIMalloc->Free(szName);

    LAST_RELEASE(pmk1)

    CreateFileMoniker(pszPath1, &pmk1);

    hr = CreateFileMoniker(pszPath2, &pmk6);

    TEST_FAILED_HR(FAILED(hr), "CreateFileMoniker for path2 failed")

    //
    //  Test Item Monikers
    //
    hr = CreateItemMoniker(L"\\", L"1", &pmk2);

    TEST_FAILED_HR(FAILED(hr), "CreateItemMoniker 1 failed")

    hr = CreateBindCtx(0, &pbc);

    TEST_FAILED_HR(FAILED(hr),
        "CreateBindCtx Item Moniker GetDisplayName failed!")

    hr = pmk2->GetDisplayName(pbc, NULL, &szName);

    pbc.Set(NULL);

    TEST_FAILED_HR(FAILED(hr), "Item Moniker GetDisplayName failed!");

    TEST_FAILED((wcscmp(szName, L"\\1") != 0), "Wrong path from item mon");

    // Free the path
    pIMalloc->Free(szName);

    hr = CreateItemMoniker(L"\\", L"2", &pmk3);

    TEST_FAILED_HR(FAILED(hr), "CreateItemMoniker 0 failed")

    hr = pmk3->Inverse(&pmk4);

    TEST_FAILED_HR(FAILED(hr), "Inverse of 0 failed")

    hr = CreateBindCtx(0, &pbc);

    TEST_FAILED_HR(FAILED(hr), "CreateBindCtx after inverse failed")

    hr = pmk4->GetDisplayName(pbc, NULL, &szName);

    TEST_FAILED_HR(FAILED(hr), "GetDisplayName on AntiMoniker failed")

    TEST_FAILED((memcmp(szName, L"\\..", sizeof(L"\\..")) != 0),
        "GetDisplayName on AntiMoniker name wrong\n")

    // Free memory API allocated.
    pIMalloc->Free(szName);

    // Release interfaces we are finished with
    LAST_RELEASE(pbc)
    LAST_RELEASE(pmk4)

    //
    //  Test composition of file moniker & item moniker
    //
    hr = pmk1->ComposeWith(pmk2, FALSE, &pmk4);

    TEST_FAILED_HR(FAILED(hr), "ComposeWith failed")

    hr = CreateBindCtx(0, &pbc);

    TEST_FAILED_HR(FAILED(hr),
        "CreateBindCtx Composite Moniker GetDisplayName failed!")

    hr = pmk4->GetDisplayName(pbc, NULL, &szName);

    pbc.Set(NULL);

    TEST_FAILED_HR(FAILED(hr), "GetDisplayName on Composite moniker failed")

    // Free memory API allocated.
    pIMalloc->Free(szName);

    Sleep(10);
    hr = BindMoniker(pmk4, 0, IID_IUnknown, (LPVOID FAR*) &pUnk);

    TEST_FAILED_HR(FAILED(hr), "BindMoniker with composed moniker failed")

    TEST_FAILED((pUnk == NULL),
        "BindMoniker with composed moniker returned NULL punk\n")

    hr = pUnk->QueryInterface(IID_IOleObject, (LPVOID FAR*) &pObj);

    TEST_FAILED_HR(FAILED(hr), "QI to IID_IOleObject failed")

    TEST_FAILED((pObj == NULL),
        "pObj returned from QI invalid")

    hr = pmk6->ComposeWith(pmk3, FALSE, &pmk5);

    TEST_FAILED_HR(FAILED(hr), "ComposedWith of pmk6 failed")

    hr = BindMoniker(pmk5, 0, IID_IUnknown, (LPVOID FAR*) &pUnk1);

    TEST_FAILED_HR(FAILED(hr), "BindMoniker of pmk5 failed")

    hr = OleRun(pUnk1);

    TEST_FAILED_HR(FAILED(hr), "OleRun call failed")

    TEST_FAILED_HR(FAILED(hr), "GetObject Failed");

    // Clean up objects
    pObj.Set(NULL);
    LAST_RELEASE(pUnk1);
    LAST_RELEASE(pmk5);
    LAST_RELEASE(pUnk);
    LAST_RELEASE(pmk6);

    //
    //  Test Marshal/Unmarshal Moniker
    //
    // Make a moniker to marshal
    hr = pmk4->ComposeWith(pmk3, FALSE, &pmk6);

    TEST_FAILED_HR(FAILED(hr), "Compose of moniker for marshal test failed");

    // Create a shared memory stream for the marshaled moniker
    hr = CreateStreamOnHGlobal(NULL, TRUE, &pStm);

    TEST_FAILED((FAILED(hr)), "CreateStreamOnHGlobal")

    // Marshal the interface into the stream
    hr = CoMarshalInterface(pStm, IID_IMoniker, pmk6, 0, NULL, MSHLFLAGS_NORMAL);

    TEST_FAILED_HR(FAILED(hr), "CoMarshalInterface failed")

    LISet32(large_int, 0);
    hr = pStm->Seek(large_int, STREAM_SEEK_SET, NULL);

    TEST_FAILED_HR(FAILED(hr), "Seek on shared stream failed")

    hr = CoUnmarshalInterface(pStm, IID_IMoniker, (LPVOID FAR*)&pmk5);

    TEST_FAILED_HR(FAILED(hr), "CoUnmarshalInterface failed")

    // Dump interfaces we are done with
    LAST_RELEASE(pmk6);
    LAST_RELEASE(pmk3);
    LAST_RELEASE(pmk4);
    LAST_RELEASE(pmk1);
    LAST_RELEASE(pmk2);
    LAST_RELEASE(pStm);
    LAST_RELEASE(pmk5);

    //
    //  Test Moniker Composition
    //
    //  BUGBUG: Check result
    hr = CreateFileMoniker(L"\\ole2\\test\\breadth\\servers\\ellipswt",
        &pmk1);

    TEST_FAILED_HR(FAILED(hr),
        "First CreateFileMoniker in composition test failed")

    hr = CreateFileMoniker(L"..\\..\\..\\dll\\sdemo1.exe",&pmk2);

    TEST_FAILED_HR(FAILED(hr),
        "Second CreateFileMoniker in composition test failed")

    hr = pmk1->ComposeWith(pmk2, FALSE, &pmk4);

    TEST_FAILED_HR(FAILED(hr), "ComposeWith of file monikers failed")

    // Dump interfaces we are done with
    LAST_RELEASE(pmk4);
    LAST_RELEASE(pmk1);
    LAST_RELEASE(pmk2);

    //
    //  Testing file moniker CommonPrefixWith
    //
    //	BUGBUG: Check result
    hr = CreateFileMoniker(L"\\Ole2\\Test\\Breadth\\Servers\\Ellipswt",
        &pmk1);

    TEST_FAILED_HR(FAILED(hr),
        "CommonPrefixWith First CreateFileMoniker failed")

    hr = CreateFileMoniker(
	L"\\ole2\\test\\breadth\\serverandthensome\\bar", &pmk2);

    TEST_FAILED_HR(FAILED(hr),
        "CommonPrefixWith second CreateFileMoniker failed")


    hr = pmk1->CommonPrefixWith(pmk2, &pmk4);

    TEST_FAILED_HR(FAILED(hr), "CommonPrefixWith failed")

    hr = CreateBindCtx(0, &pbc);

    TEST_FAILED_HR(FAILED(hr),
        "CreateBindCtx CommonPrefixWith GetDisplayName failed!")

    hr = pmk4->GetDisplayName(pbc, NULL, &szName);

    pbc.Set(NULL);

    TEST_FAILED_HR(FAILED(hr), "CommonPrefixWith: GetDisplayName failed!");

    TEST_FAILED((_wcsicmp(szName, L"\\ole2\\test\\breadth") != 0),
                        "Common prefix with: Wrong Output Path\n");

    // Free the path
    pIMalloc->Free(szName);

    // Dump monikers we are done with
    LAST_RELEASE(pmk4);
    LAST_RELEASE(pmk2);
    LAST_RELEASE(pmk1);

    //
    //  Testing file moniker RelativePathTo
    //
    //	BUGBUG: Check result.
    hr = CreateFileMoniker(L"\\Ole2\\Test\\Breadth\\Servers\\Ellipswt",
        &pmk1);

    TEST_FAILED_HR(FAILED(hr), "RelativePathTo first CreateFileMoniker failed")

    hr = CreateFileMoniker(
	L"\\ole2\\test\\breadth\\serverandthensome\\bar", &pmk2);

    TEST_FAILED_HR(FAILED(hr),
        "RelativePathTo Second CreateFileMoniker failed")

    hr = pmk1->RelativePathTo(pmk2, &pmk4);

    TEST_FAILED_HR(FAILED(hr), "RelativePathTo failed")


    hr = CreateBindCtx(0, &pbc);

    TEST_FAILED_HR(FAILED(hr),
        "CreateBindCtx RelativePathTo GetDisplayName failed!")

    hr = pmk4->GetDisplayName(pbc, NULL, &szName);

    pbc.Set(NULL);

    TEST_FAILED_HR(FAILED(hr), "RelativePathTo: GetDisplayName failed!");

    TEST_FAILED((wcscmp(szName, L"..\\..\\serverandthensome\\bar") != 0),
                        "RelativePathTo: Wrong Output Path");

    // Free the path
    pIMalloc->Free(szName);


    LAST_RELEASE(pmk2);
    LAST_RELEASE(pmk1);
    LAST_RELEASE(pmk4);

    //
    //  Testing MkParseDisplayName
    //
    hr = CreateBindCtx(0, &pbc);

    TEST_FAILED_HR(FAILED(hr), "MkParseDisplayName CreatebindCtx failed")

    // make a path to the object
    WCHAR szBuf[256];
    int cPath1;
    cPath1 = wcslen(pszPath1);
    memcpy(szBuf, pszPath1, cPath1 * sizeof(WCHAR));
    memcpy(szBuf + cPath1, L"\\1", sizeof(L"\\1"));

    hr = MkParseDisplayName(pbc, szBuf, &chEaten, &pmk1);

    TEST_FAILED_HR(FAILED(hr), "MkParseDisplayName failed")

    LAST_RELEASE(pmk1);
    LAST_RELEASE(pbc);

    //
    //  Test Moniker IsEqual function on equivalent paths
    //  The moniker code should catch some forms of equivalent
    //  paths, but doesn't handle all of them.
    //
    //

    hr = CreateFileMoniker(L"first",&pmk1);

    TEST_FAILED_HR(FAILED(hr),
        "First CreateFileMoniker in IsEqual test failed")

    hr = CreateFileMoniker(L".\\first",&pmk2);

    TEST_FAILED_HR(FAILED(hr),
        "Second CreateFileMoniker in IsEqual test failed")

    hr = CreateFileMoniker(L"..\\first",&pmk3);

    TEST_FAILED_HR(FAILED(hr),
        "Third CreateFileMoniker in IsEqual test failed")

        //  This moniker variation has been disabled for Cairo
        //    until the moniker code gets unified.
#ifndef _CAIRO_
    hr = CreateFileMoniker(L"..\\.first",&pmk4);

    TEST_FAILED_HR(FAILED(hr),
        "Fourth CreateFileMoniker in IsEqual test failed")
#endif

    hr = pmk1->IsEqual(pmk2);
    TEST_FAILED_HR((hr != S_OK), "pmk1->IsEqual(pmk2) failed")

    hr = pmk2->IsEqual(pmk3);
    TEST_FAILED_HR((hr != S_FALSE), "pmk2->IsEqual(pmk3) failed")

#ifndef _CAIRO_
    hr = pmk3->IsEqual(pmk4);
    TEST_FAILED_HR((hr != S_FALSE), "pmk3->IsEqual(pmk4) failed")

    hr = pmk4->IsEqual(pmk4);
    TEST_FAILED_HR((hr != S_OK), "pmk4->IsEqual(pmk4) failed")
#endif

    // Dump interfaces we are done with
    LAST_RELEASE(pmk1);
    LAST_RELEASE(pmk2);
    LAST_RELEASE(pmk3);

#ifndef _CAIRO_
    LAST_RELEASE(pmk4);
#endif

    //
    // Test IsRunning
    //

    //  we make up a name based on the pid and an arbitrary string,
    //  so that the name is unique to this process.

    WCHAR   wszMkName[MAX_PATH];
    wcscpy(wszMkName, L"YourStockOptionsDependOnThis");
    wcscat(wszMkName, &wszPid[1]);  //  skip leading backslash

    hr = CreateFileMoniker(wszMkName, &pmk1);

    TEST_FAILED_HR(FAILED(hr),
        "First CreateFileMoniker in IsRunning failed")

    hr = CreateBindCtx(0, &pbc);
    TEST_FAILED_HR(FAILED(hr),
        "CreateBindCtx in IsRunning failed")

    //
    // We shouldn't find the moniker in the ROT
    //
    hr = pmk1->IsRunning(pbc,NULL,NULL);
    TEST_FAILED_HR((hr != S_FALSE),
        "IsRunning returns other than S_FALSE");

    //
    // The FileMoniker should ignore pmk1
    //

    hr = pmk1->IsRunning(pbc,pmk1,NULL);
    TEST_FAILED_HR((hr != S_FALSE),
        "IsRunning #2 returns other than S_FALSE");


    hr = GetRunningObjectTable(0, &prot);

    TEST_FAILED_HR(FAILED(hr),"IsRunning GetRunningObjectTable failed!");


    //
    // Just for kicks, we are going to register this moniker itself
    // as running. We needed an IUnknown pointer here, and the moniker
    // just happens to have one.
    //

    DWORD dwRegister;
    DWORD dwRegister2;

    hr = prot->Register(0,pmk1,pmk1,&dwRegister);
    TEST_FAILED_HR(FAILED(hr),
        "Register with ROT failed in IsRunning");

    //
    // We should find the moniker as running
    //
    hr = pmk1->IsRunning(pbc,NULL,NULL);
    TEST_FAILED_HR((hr != S_OK),
        "IsRunning returns other than S_OK");

    hr = prot->IsRunning(pmk1);
    TEST_FAILED_HR((hr != S_OK),
        "IsRunning returns other than S_OK");

    //
    // Register it again, and we should get notice that it is running
    //
    // This test the ROT, and also test the moniker comparision
    // functions
    //

    hr = prot->Register(0,pmk1,pmk1,&dwRegister2);
    TEST_FAILED_HR(hr != MK_S_MONIKERALREADYREGISTERED,
        "Register with ROT failed in IsRunning");

    hr = prot->IsRunning(pmk1);
    TEST_FAILED_HR((hr != S_OK),
                "IsRunning #1 has returned != S_OK");

    hr = prot->Revoke(dwRegister2);
    TEST_FAILED_HR(FAILED(hr),
        "Revoke dwRegister2 with ROT failed");

    hr = prot->Revoke(dwRegister2);
    TEST_FAILED_HR(hr == S_OK,
        "Revoke dwRegister2 with ROT should have failed");

    //
    // It is registered twice, it should still be there from the original
    // registration
    //
    hr = pmk1->IsRunning(pbc,NULL,NULL);
    TEST_FAILED_HR((hr != S_OK),
                "IsRunning #2 has returned != S_OK");

    //
    // Cram in a ItemMoniker to test its comparision stuff.
    //
    hr = CreateItemMoniker(L"!",L"KevinRo",&pmkItem1);
    TEST_FAILED_HR(FAILED(hr),
                "Creating Item Moniker KevinRo");

    hr = CreateItemMoniker(L"!",L"SueA",&pmkItem2);
    TEST_FAILED_HR(FAILED(hr),
                "Creating Item Moniker SueA");

    DWORD dwKevinRo;
    DWORD dwSueA;

    hr = prot->Register(0,pmkItem1,pmkItem1,&dwKevinRo);
    TEST_FAILED_HR(FAILED(hr),
        "Register KevinRo with ROT failed in IsRunning");

    hr = prot->Register(0,pmkItem2,pmkItem2,&dwSueA);
    TEST_FAILED_HR(FAILED(hr),
        "Register SueA with ROT failed in IsRunning");

    //
    // Now revoke monikers
    //
    hr = prot->Revoke(dwRegister);
    TEST_FAILED_HR(FAILED(hr),
        "Revoke with ROT failed in IsRunning");
    //
    // We shouldn't find the moniker in the ROT
    //
    hr = pmk1->IsRunning(pbc,NULL,NULL);
    TEST_FAILED_HR((hr != S_FALSE),
                "IsRunning returns other than S_FALSE");

    //
    // Now revoke the item monikers.
    //
    hr = prot->Revoke(dwKevinRo);
    TEST_FAILED_HR(FAILED(hr),
        "Revoke with ROT failed in for KevinRo");

    hr = prot->Revoke(dwSueA);
    TEST_FAILED_HR(FAILED(hr),
        "Revoke with ROT failed in for SueA");

    //
    // An AntiMoniker
    //
    hr = CreateAntiMoniker(&pmkAnti);
    TEST_FAILED_HR(FAILED(hr),
    	"Failed creating AntiMoniker in Comparison Data Test");

    DWORD dwAnti;

    hr = prot->Register(0,pmkAnti,pmkAnti,&dwAnti);
    TEST_FAILED_HR(FAILED(hr),
        "Register Anti with ROT failed in IsRunning");

    hr = prot->IsRunning(pmkAnti);
    TEST_FAILED_HR((hr != S_OK),
        "IsRunning pmkAnti returns other than S_OK");

    //
    // Now revoke the 'other' monikers.
    //
    hr = prot->Revoke(dwAnti);
    TEST_FAILED_HR(FAILED(hr),
        "Revoke with ROT failed in for Anti");

    //
    // Test file monikers with long file names
    //

    // Creation
    hr = CreateFileMoniker(LongDirShort, &pmkLong1);

    TEST_FAILED_HR(FAILED(hr), "CreateFileMoniker for long short failed!")

    TEST_FAILED((pmkLong1 == NULL),
        "CreateFileMoniker returned a null moniker ptr\n")

    LAST_RELEASE(pmkLong1);

    // Equivalence with short name version
    hr = CreateFileMoniker(LongDirLong, &pmkLong1);

    TEST_FAILED_HR(FAILED(hr), "CreateFileMoniker for long long failed!")

    TEST_FAILED((pmkLong1 == NULL),
        "CreateFileMoniker returned a null moniker ptr\n")

#if 0
    // Debug code to print out the display name to check that long
    // names are handled correctly

    hr = CreateBindCtx(0, &pbc);

    TEST_FAILED_HR(FAILED(hr),
        "CreateBindCtx File Moniker GetDisplayName failed!")

    hr = pmkLong1->GetDisplayName(pbc, NULL, &szName);

    //  release it
    pbc.Set(NULL, FALSE);

    TEST_FAILED_HR(FAILED(hr), "File Moniker GetDisplayName failed!");

    wprintf(L"Display name: '%s', %d\n", szName, wcslen(szName));

    // Free the path
    pIMalloc->Free(szName);
#endif

    hr = CreateFileMoniker(LongDirLongSe, &pmkLong2);

    TEST_FAILED_HR(FAILED(hr), "CreateFileMoniker for long long se failed!")

    TEST_FAILED((pmkLong2 == NULL),
        "CreateFileMoniker returned a null moniker ptr\n")

    TEST_FAILED(pmkLong1->IsEqual(pmkLong2) != S_OK,
        "Long file monikers not equal\n");

#if 0


    // Debug code to print out the display name to check that long
    // names are handled correctly

    hr = CreateBindCtx(0, &pbc);

    TEST_FAILED_HR(FAILED(hr),
        "CreateBindCtx File Moniker GetDisplayName failed!")

    hr = pmkLong2->GetDisplayName(pbc, NULL, &szName);

    //  release it
    pbc.Set(NULL, FALSE);

    TEST_FAILED_HR(FAILED(hr), "File Moniker GetDisplayName failed!");

    wprintf(L"Display name: '%s', %d\n", szName, wcslen(szName));

    // Free the path
    pIMalloc->Free(szName);
#endif

    LAST_RELEASE(pmkLong1);
    LAST_RELEASE(pmkLong2);

    return FALSE;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\olebind\widewrap.cxx ===
//+---------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1993 - 1993.
//
//  File:       widewrap.cxx
//
//  Contents:   Unicode wrapper API, used only on Chicago
//
//  Functions:  About fifty Win32 function wrappers
//
//  Notes:      'sz' is used instead of the "correct" hungarian 'psz'
//              throughout to enhance readability.
//
//              Not all of every Win32 function is wrapped here.  Some
//              obscurely-documented features may not be handled correctly
//              in these wrappers.  Caller beware.
//
//              These are privately exported for use by the Shell.
//
//  History:    28-Dec-93   ErikGav   Created
//              06-14-94    KentCe    Various Chicago build fixes.
//              21-Dec-94   BruceMa   Use olewcstombs + other fixes
//              21-Feb-95   BruceMa   Add support for AreFileApisANSI
//
//----------------------------------------------------------------------------

#include <windows.h>
#include "widewrap.h"

size_t olembstowcs(WCHAR *pwsz, const char *psz, size_t cCh);
size_t olewcstombs(char *psz, const WCHAR *pwsz , size_t cCh);

inline size_t olembstowcs(WCHAR *pwsz, const char *psz, size_t cCh)
{
    return MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, psz, -1, pwsz, cCh);
}

inline size_t olewcstombs(char *psz, const WCHAR *pwsz , size_t cCh)
{
    return WideCharToMultiByte(CP_ACP, WC_COMPOSITECHECK, pwsz, -1, psz,
                               cCh, NULL, NULL);
}

#ifdef _CHICAGO_

#define HFINDFILE HANDLE
#define ERR ((char*) -1)


//
//  BUGBUG: 9869
//
//  The length of a Unicode string (in chars) and a DBCS string are not
//  always equal.  We need to review all WideChar to MultiByte conversions
//  logic to verify that the proper result buffer size is used.
//
//  Make the below Win95 only change to get the Win95 FE build out.
//

int UnicodeToAnsi(LPSTR sz, LPCWSTR pwsz, LONG cb)
{
    int ret;

    ret = WideCharToMultiByte(CP_ACP, WC_COMPOSITECHECK, pwsz, -1, sz, cb, NULL, NULL);

#if DBG==1
    if (ret == -1)
    {
        DebugBreak();
    }
#endif

    return ret;
}


int UnicodeToAnsiOem(LPSTR sz, LPCWSTR pwsz, LONG cb)
{
    int ret;

    if (AreFileApisANSI())
    {
        ret = WideCharToMultiByte(CP_ACP, WC_COMPOSITECHECK, pwsz, -1, sz,
                                  cb, NULL, NULL);
    }
    else
    {
        ret = WideCharToMultiByte(CP_OEMCP, WC_COMPOSITECHECK, pwsz, -1, sz,
                                  cb, NULL, NULL);
    }

#if DBG==1
    if (ret == -1)
    {
        DebugBreak();
    }
#endif

    return ret;
}



#if DBG==1
int AnsiToUnicode(LPWSTR pwsz, LPCSTR sz, LONG cb)
{
    int ret;

    ret = olembstowcs(pwsz, sz, cb);

    if (ret == -1)
    {
        DebugBreak();
    }

    return ret;
}
#else
#define AnsiToUnicode olembstowcs
#endif



int AnsiToUnicodeOem(LPWSTR pwsz, LPCSTR sz, LONG cb)
{
    int ret;

    if (AreFileApisANSI())
    {
        ret = MultiByteToWideChar(CP_ACP, MB_PRECOMPOSED, sz, cb, pwsz, cb);
    }
    else
    {
        ret = MultiByteToWideChar(CP_OEMCP, MB_PRECOMPOSED, sz, cb, pwsz, cb);
    }

#if DBG==1
    if (ret == -1)
    {
        DebugBreak();
    }
#endif

    return ret;
}




LPSTR Convert(LPCWSTR pwsz)
{
    LONG len;
    LPSTR sz = NULL;

    if (pwsz == NULL)
        goto Exit;

#if DBG==1
    // some Win32 API accept atoms in their string parameters
#endif

    len = (wcslen(pwsz) + 1) * 2;

    sz = new CHAR[len];
    if (sz==NULL)
    {
        sz = ERR;
        goto Exit;
    }

    __try
    {
        UnicodeToAnsi(sz, pwsz, len);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
#if DBG==1
        MessageBoxA(NULL, "GP fault in unicode conversion -- caught",
                   NULL, MB_OK);
#endif
        if (sz)
            delete sz;
        sz = ERR;
    }

Exit:
    return sz;
}









LPSTR ConvertOem(LPCWSTR pwsz)
{
    LONG len;
    LPSTR sz = NULL;

    if (pwsz == NULL)
        goto Exit;

#if DBG==1
    // some Win32 API accept atoms in their string parameters
#endif

    len = (wcslen(pwsz) + 1) * 2;

    sz = new CHAR[len];
    if (sz==NULL)
    {
        sz = ERR;
        goto Exit;
    }

    __try
    {
        UnicodeToAnsiOem(sz, pwsz, len);
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
#if DBG==1
        MessageBoxA(NULL, "GP fault in unicode conversion -- caught",
                   NULL, MB_OK);
#endif
        if (sz)
            delete sz;
        sz = ERR;
    }

Exit:
    return sz;
}





HANDLE WINAPI CreateFileX(LPCWSTR pwsz, DWORD fdwAccess, DWORD fdwShareMask,
        LPSECURITY_ATTRIBUTES lpsa, DWORD fdwCreate, DWORD fdwAttrsAndFlags,
        HANDLE hTemplateFile)
{
    #ifdef DEBUG_OUTPUT
    OutputDebugString("CreateFile\n");
    #endif

    CHAR  sz[MAX_PATH * 2];
    UnicodeToAnsiOem(sz, pwsz, sizeof(sz));

    return CreateFileA(sz, fdwAccess, fdwShareMask, lpsa, fdwCreate,
            fdwAttrsAndFlags, hTemplateFile);
}

BOOL WINAPI DeleteFileX(LPCWSTR pwsz)
{
    #ifdef DEBUG_OUTPUT
    OutputDebugString("DeleteFile\n");
    #endif

    CHAR  sz[MAX_PATH * 2];
    UnicodeToAnsi(sz, pwsz, sizeof(sz));

    return DeleteFileA(sz);
}


LONG APIENTRY RegOpenKeyX(HKEY hKey, LPCWSTR pwszSubKey, PHKEY phkResult)
{
    #ifdef DEBUG_OUTPUT
    OutputDebugString("RegOpenKey\n");
    #endif

    LONG ret;
    LPSTR sz;

    sz = Convert(pwszSubKey);

    if (sz == ERR)
    {
        return ERROR_OUTOFMEMORY;
    }

    ret = RegOpenKeyA(hKey, sz, phkResult);
    if (sz)
        delete sz;
    return ret;
}

LONG APIENTRY RegQueryValueX(HKEY hKey, LPCWSTR pwszSubKey, LPWSTR pwszValue,
    PLONG   lpcbValue)
{
    #ifdef DEBUG_OUTPUT
    OutputDebugString("RegQueryValue\n");
    #endif

    LONG  cb, ret;
    LPSTR szValue = NULL;
    LPSTR sz;

    sz = Convert(pwszSubKey);
    if (sz == ERR)
    {
        return ERROR_OUTOFMEMORY;
    }

    ret = RegQueryValueA(hKey, sz, NULL, &cb);

    // If the caller was just asking for the size of the value, jump out
    //  now, without actually retrieving and converting the value.

    if (pwszValue == NULL)
    {
        // Adjust size of buffer to report, to account for CHAR -> WCHAR
        *lpcbValue = cb * sizeof(WCHAR);
        goto Exit;
    }


    if (ret == ERROR_SUCCESS)
    {
        // If the caller was asking for the value, but allocated too small
        // of a buffer, set the buffer size and jump out.

        if (*lpcbValue < (LONG) (cb * sizeof(WCHAR)))
        {
            // Adjust size of buffer to report, to account for CHAR -> WCHAR
            *lpcbValue = cb * sizeof(WCHAR);
            ret = ERROR_MORE_DATA;
            goto Exit;
        }

        // Otherwise, retrieve and convert the value.

        szValue = new CHAR[cb];
        if (szValue == NULL)
        {
            ret = ERROR_OUTOFMEMORY;
            goto Exit;
        }

        ret = RegQueryValueA(hKey, sz, szValue, &cb);

        if (ret == ERROR_SUCCESS)
        {
            AnsiToUnicode(pwszValue, szValue, cb);

            // Adjust size of buffer to report, to account for CHAR -> WCHAR
            *lpcbValue = cb * sizeof(WCHAR);
        }
    }

Exit:
    if (szValue)
        delete szValue;
    if (sz)
        delete sz;

    return ret;
}

LONG APIENTRY RegSetValueX(HKEY hKey, LPCWSTR lpSubKey, DWORD dwType,
    LPCWSTR lpData, DWORD cbData)
{
    #ifdef DEBUG_OUTPUT
    OutputDebugString("RegSetValue\n");
    #endif

    LPSTR szKey = NULL;
    LPSTR szValue = NULL;
    LONG  ret = ERROR_OUTOFMEMORY;

    szKey = Convert(lpSubKey);
    if (szKey == ERR)
    {
        szKey = NULL;
        goto Exit;
    }

    szValue = Convert(lpData);
    if (szValue == ERR)
    {
        szValue = NULL;
        goto Exit;
    }

    ret = RegSetValueA(hKey, szKey, dwType, szValue, cbData);

Exit:
    if (szKey)
        delete szKey;
    if (szValue)
        delete szValue;
    return ret;
}

LONG APIENTRY RegSetValueExX(HKEY hKey,
			     LPCWSTR lpSubKey,
			     DWORD dwReserved,
			     DWORD dwType,
			     LPBYTE lpData,
			     DWORD cbData)
{
    #ifdef DEBUG_OUTPUT
    OutputDebugString("RegSetValueEx\n");
    #endif

    LPSTR szKey = NULL;
    LPBYTE szValue = lpData;
    LONG  ret = ERROR_OUTOFMEMORY;

    szKey = Convert(lpSubKey);
    if (szKey == ERR)
    {
        szKey = NULL;
        goto Exit;
    }

    if (dwType == REG_SZ)
    {
	szValue = (LPBYTE) Convert((LPWSTR)lpData);
    }
    if (szValue == (LPBYTE) ERR)
    {
        szValue = NULL;
        goto Exit;
    }

    ret = RegSetValueExA(hKey, szKey, dwReserved, dwType, szValue, cbData);

Exit:
    if (szKey)
        delete szKey;
    if ((szValue != lpData) && (szValue != (LPBYTE)ERR))
        delete szValue;
    return ret;
}

UINT WINAPI RegisterWindowMessageX(LPCWSTR lpString)
{
    #ifdef DEBUG_OUTPUT
    OutputDebugString("RegisterWindowMessage\n");
    #endif

    UINT ret;
#if 0
    LPSTR sz;

    sz = Convert(lpString);
    if (sz == ERR)
    {
        return 0;
    }
#else
    // BUGBUG: CairOLE calls this from libmain -- have to use static buffer

    CHAR sz[200];
    UnicodeToAnsi(sz, lpString, sizeof(sz));
#endif

    ret = RegisterWindowMessageA(sz);
#if 0
    delete sz;
#endif
    return ret;
}

LONG
APIENTRY
RegOpenKeyExX (
    HKEY hKey,
    LPCWSTR lpSubKey,
    DWORD ulOptions,
    REGSAM samDesired,
    PHKEY phkResult
    )
{
    #ifdef DEBUG_OUTPUT
    OutputDebugString("RegOpenKeyEx\n");
    #endif

    LONG ret;
    LPSTR sz;

    sz = Convert(lpSubKey);
    if (sz == ERR)
    {
        return ERROR_OUTOFMEMORY;
    }

    ret = RegOpenKeyExA(hKey, sz, ulOptions, samDesired, phkResult);
    if (sz)
        delete sz;
    return ret;
}

LONG
APIENTRY
RegQueryValueExX(
    HKEY hKey,
    LPWSTR lpValueName,
    LPDWORD lpReserved,
    LPDWORD lpType,
    LPBYTE lpData,
    LPDWORD lpcbData
    )
{
    #ifdef DEBUG_OUTPUT
    OutputDebugString("RegQueryValueEx\n");
    #endif

    LPBYTE lpTempBuffer;
    DWORD dwTempType;
    DWORD cb, cbRequired;
    LONG  ret;
    LPSTR sz;
    LPWSTR pwszTempWide;
    LPSTR pszTempNarrow;
    ULONG ulStringLength;

    sz = Convert(lpValueName);
    if (sz == ERR)
    {
        return ERROR_OUTOFMEMORY;
    }

    ret = RegQueryValueExA(hKey, sz, lpReserved, &dwTempType, NULL, &cb);

    // If the caller was just asking for the size of the value, jump out
    //  now, without actually retrieving and converting the value.

    if (lpData == NULL)
    {
        switch (dwTempType)
        {
        case REG_EXPAND_SZ:
        case REG_MULTI_SZ:
        case REG_SZ:

            // Adjust size of buffer to report, to account for CHAR -> WCHAR

            if (lpcbData != NULL)
                *lpcbData = cb * sizeof(WCHAR);
            break;

        default:

            if (lpcbData != NULL)
                *lpcbData = cb;
            break;
        }

        // Set the type, if required.
        if (lpType != NULL)
        {
            *lpType = dwTempType;
        }

        goto Exit;
    }


    if (ret == ERROR_SUCCESS)
    {
        //
        // Determine the size of buffer needed
        //

        switch (dwTempType)
        {
        case REG_EXPAND_SZ:
        case REG_MULTI_SZ:
        case REG_SZ:

            cbRequired = cb * sizeof(WCHAR);
            break;

        default:

            cbRequired = cb;
            break;
        }

        // If the caller was asking for the value, but allocated too small
        // of a buffer, set the buffer size and jump out.

        if (lpcbData != NULL && *lpcbData < cbRequired)
        {
            // Adjust size of buffer to report, to account for CHAR -> WCHAR
            *lpcbData = cbRequired;

            // Set the type, if required.
            if (lpType != NULL)
            {
                *lpType = dwTempType;
            }

            ret = ERROR_MORE_DATA;
            goto Exit;
        }

        // Otherwise, retrieve and convert the value.

        switch (dwTempType)
        {
        case REG_EXPAND_SZ:
        case REG_MULTI_SZ:
        case REG_SZ:

            lpTempBuffer = new BYTE[cbRequired];
            if (lpTempBuffer == NULL)
            {
                return ERROR_OUTOFMEMORY;
            }

            ret = RegQueryValueExA(hKey,
                                  sz,
                                  lpReserved,
                                  &dwTempType,
                                  lpTempBuffer,
                                  &cb);

            if (ret == ERROR_SUCCESS)
            {
                switch (dwTempType)
                {
                case REG_EXPAND_SZ:
                case REG_SZ:

                    AnsiToUnicode((LPWSTR) lpData, (LPSTR) lpTempBuffer, cb);

                    // Adjust size of buffer to report, to account for CHAR -> WCHAR
                    *lpcbData = cbRequired;

                    // Set the type, if required.
                    if (lpType != NULL)
                    {
                        *lpType = dwTempType;
                    }
                    break;

                case REG_MULTI_SZ:

                    pszTempNarrow = (LPSTR) lpTempBuffer;
                    pwszTempWide = (LPWSTR) lpData;

                    while (pszTempNarrow != NULL)
                    {
                        ulStringLength = strlen(pszTempNarrow) + 1;
                        AnsiToUnicode(pwszTempWide,
                                      pszTempNarrow,
                                      ulStringLength);

                        // Compiler will scale appropriately here
                        pszTempNarrow += ulStringLength;
                        pwszTempWide += ulStringLength;
                    }
                    break;
                }
            }

            if (lpTempBuffer)
                delete lpTempBuffer;

            break;

        default:

            //
            // No conversion of out parameters needed.  Just call narrow
            // version with args passed in, and return directly.
            //

            ret = RegQueryValueExA(hKey,
                                   sz,
                                   lpReserved,
                                   lpType,
                                   lpData,
                                   lpcbData);

        }
    }

Exit:
    if (sz)
       delete sz;
    return ret;
}



ATOM
WINAPI
RegisterClassX(
    CONST WNDCLASSW *lpWndClass)
{
    #ifdef DEBUG_OUTPUT
    OutputDebugString("RegisterClass\n");
    #endif

    WNDCLASSA wc;
    ATOM      ret;
    BOOL      fAtom = FALSE;


    memcpy(&wc, lpWndClass, sizeof(WNDCLASS));

    wc.lpszMenuName = Convert(lpWndClass->lpszMenuName);
    if (wc.lpszMenuName==ERR)
    {
        return NULL;
    }

    if (HIWORD(lpWndClass->lpszClassName) == 0)
    {
        wc.lpszClassName = (LPSTR) lpWndClass->lpszClassName;
        fAtom = TRUE;
    }
    else
    {
        wc.lpszClassName = Convert(lpWndClass->lpszClassName);
        if (wc.lpszClassName==ERR)
        {
            if ((LPSTR) wc.lpszMenuName)
                delete (LPSTR) wc.lpszMenuName;
            return NULL;
        }
    }

    ret = RegisterClassA(&wc);
    if ((LPSTR) wc.lpszMenuName)
        delete (LPSTR) wc.lpszMenuName;
    if (!fAtom) delete (LPSTR) wc.lpszClassName;
    return ret;
}

BOOL
WINAPI
UnregisterClassX(
    LPCWSTR lpClassName,
    HINSTANCE hInstance)
{
    #ifdef DEBUG_OUTPUT
    OutputDebugString("UnregisterClass\n");
    #endif

    LPSTR sz;
    BOOL  ret;
    BOOL  fAtom = FALSE;

    if (HIWORD(lpClassName) == 0)
    {
        sz = (LPSTR) lpClassName;
        fAtom = TRUE;
    }
    else
    {
        sz = Convert(lpClassName);
        if (sz == ERR)
            return FALSE;
    }

    ret = UnregisterClassA(sz, hInstance);
    if (!fAtom) delete sz;
    return ret;
}

HANDLE
WINAPI
GetPropX(
    HWND hWnd,
    LPCWSTR lpString)
{
    #ifdef DEBUG_OUTPUT
    OutputDebugString("GetProp\n");
    #endif

    HANDLE ret;
    LPSTR  sz;
    BOOL   fAtom = FALSE;

    if (HIWORD(lpString)==0)
    {
        fAtom = TRUE;
        sz = (LPSTR) lpString;
    }
    else
    {
        sz = Convert(lpString);
        if (sz == ERR)
            return NULL;
    }

    ret = GetPropA(hWnd, sz);
    if (!fAtom) delete sz;
    return ret;
}


BOOL
WINAPI
SetPropX(
    HWND hWnd,
    LPCWSTR lpString,
    HANDLE hData)
{
    #ifdef DEBUG_OUTPUT
    OutputDebugString("SetProp\n");
    #endif

    BOOL  ret;
    LPSTR sz;
    BOOL  fAtom = FALSE;

    if (HIWORD(lpString)==0)
    {
        sz = (LPSTR) lpString;
        fAtom = TRUE;
    }
    else
    {
        sz = Convert(lpString);
        if (sz == ERR)
            return NULL;
    }

    ret = SetPropA(hWnd, sz, hData);
    if (!fAtom) delete sz;
    return ret;
}


HANDLE
WINAPI
RemovePropX(
    HWND hWnd,
    LPCWSTR lpString)
{
    #ifdef DEBUG_OUTPUT
    OutputDebugString("RemoveProp\n");
    #endif

    HANDLE ret;
    LPSTR  sz;
    BOOL   fAtom = FALSE;

    if (HIWORD(lpString)==0)
    {
        sz = (LPSTR) lpString;
        fAtom = TRUE;
    }
    else
    {
        sz = Convert(lpString);
        if (sz == ERR)
            return NULL;
    }

    ret = RemovePropA(hWnd, sz);
    if (!fAtom) delete sz;
    return ret;
}


UINT
WINAPI
GetProfileIntX(
    LPCWSTR lpAppName,
    LPCWSTR lpKeyName,
    INT     nDefault
    )
{
    #ifdef DEBUG_OUTPUT
    OutputDebugString("GetProfileInt\n");
    #endif

    LPSTR szApp;
    LPSTR szKey;
    UINT  ret;

    szApp = Convert(lpAppName);
    if (szApp==ERR)
    {
        return nDefault;
    }

    szKey = Convert(lpKeyName);
    if (szApp==ERR)
    {
        if (szApp)
            delete szApp;
        return nDefault;
    }

    ret = GetProfileIntA(szApp, szKey, nDefault);
    if (szApp)
        delete szApp;
    if (szKey)
        delete szKey;
    return ret;
}

ATOM
WINAPI
GlobalAddAtomX(
    LPCWSTR lpString
    )
{
    #ifdef DEBUG_OUTPUT
    OutputDebugString("GlobalAddAtom\n");
    #endif

    ATOM ret;
    LPSTR sz;

    sz = Convert(lpString);
    if (sz==ERR)
    {
        return NULL;
    }

    ret = GlobalAddAtomA(sz);
    if (sz)
        delete sz;
    return ret;
}

UINT
WINAPI
GlobalGetAtomNameX(
    ATOM nAtom,
    LPWSTR pwszBuffer,
    int nSize
    )
{
    #ifdef DEBUG_OUTPUT
    OutputDebugString("GlobalGetAtomName\n");
    #endif

    LPSTR sz;
    UINT ret;

    sz = new CHAR[nSize];
    if (sz == NULL)
    {
        return 0;
    }

    ret = GlobalGetAtomNameA(nAtom, sz, nSize);
    if (ret)
    {
        AnsiToUnicode(pwszBuffer, sz, lstrlenA(sz) + 1);
    }
    if (sz)
        delete sz;
    return ret;
}


DWORD
WINAPI
GetModuleFileNameX(
    HINSTANCE hModule,
    LPWSTR pwszFilename,
    DWORD nSize
    )
{
    #ifdef DEBUG_OUTPUT
    OutputDebugString("GetModuleFileName\n");
    #endif

    LPSTR sz;
    DWORD ret;

    sz = new CHAR[nSize];
    if (sz == NULL)
    {
        return 0;
    }

    ret = GetModuleFileNameA(hModule, sz, nSize);
    if (ret)
    {
        AnsiToUnicode(pwszFilename, sz, lstrlenA(sz) + 1);
    }

    if (sz)
        delete sz;
    return ret;
}


LPWSTR
WINAPI
CharPrevX(
    LPCWSTR lpszStart,
    LPCWSTR lpszCurrent)
{
    #ifdef DEBUG_OUTPUT
    OutputDebugString("CharPrev\n");
    #endif

    if (lpszCurrent == lpszStart)
    {
        return (LPWSTR) lpszStart;
    }
    else
    {
        return (LPWSTR) lpszCurrent - 1;
    }
}

HFONT WINAPI CreateFontX(int a, int b, int c, int d, int e, DWORD f,
                         DWORD g, DWORD h, DWORD i, DWORD j, DWORD k,
                         DWORD l, DWORD m, LPCWSTR pwsz)
{
    #ifdef DEBUG_OUTPUT
    OutputDebugString("CreateFont\n");
    #endif

    LPSTR sz;
    HFONT ret;

    sz = Convert(pwsz);
    if (sz == ERR)
    {
        return NULL;
    }

    ret = CreateFontA(a,b,c,d,e,f,g,h,i,j,k,l,m,sz);
    if (sz)
        delete sz;
    return ret;
}


HINSTANCE
WINAPI
LoadLibraryX(
    LPCWSTR pwszFileName
    )
{
    #ifdef DEBUG_OUTPUT
    OutputDebugString("LoadLibrary\n");
    #endif

    HINSTANCE ret;
    LPSTR sz;

    sz = Convert(pwszFileName);
    if (sz == ERR)
    {
        return NULL;
    }

    ret = LoadLibraryA(sz);
    if (sz)
        delete sz;
    return ret;
}


HMODULE
WINAPI
LoadLibraryExX(
    LPCWSTR lpLibFileName,
    HANDLE hFile,
    DWORD dwFlags
    )
{
    #ifdef DEBUG_OUTPUT
    OutputDebugString("LoadLibrary\n");
    #endif

    HINSTANCE ret;
    LPSTR sz;

    sz = ConvertOem(lpLibFileName);
    if (sz == ERR)
    {
        return NULL;
    }

    ret = LoadLibraryExA(sz, hFile, dwFlags);
    if (sz)
        delete sz;
    return ret;
}



LONG
APIENTRY
RegDeleteKeyX(
    HKEY hKey,
    LPCWSTR pwszSubKey
    )
{
    #ifdef DEBUG_OUTPUT
    OutputDebugString("RegDeleteKey\n");
    #endif

    LONG ret;
    LPSTR sz;

    sz = Convert(pwszSubKey);
    if (sz == ERR)
    {
        return ERROR_OUTOFMEMORY;
    }

    ret = RegDeleteKeyA(hKey, sz);
    if (sz)
        delete sz;
    return ret;
}

BOOL
APIENTRY
CreateProcessX(
    LPCWSTR lpApplicationName,
    LPWSTR lpCommandLine,
    LPSECURITY_ATTRIBUTES lpProcessAttributes,
    LPSECURITY_ATTRIBUTES lpThreadAttributes,
    BOOL bInheritHandles,
    DWORD dwCreationFlags,
    LPVOID lpEnvironment,
    LPCWSTR lpCurrentDirectory,
    LPSTARTUPINFOW lpStartupInfo,
    LPPROCESS_INFORMATION lpProcessInformation
    )
{
    #ifdef DEBUG_OUTPUT
    OutputDebugString("CreateProcess\n");
    #endif

    STARTUPINFOA si;
    BOOL         ret = FALSE;
    LPSTR        szApp = NULL;
    LPSTR        szCommand = NULL;
    LPSTR        szDir = NULL;

    memcpy(&si, lpStartupInfo, sizeof(STARTUPINFO));

    si.lpTitle = NULL;

    si.lpDesktop = Convert(lpStartupInfo->lpDesktop);
    if (si.lpDesktop == ERR)
    {
        si.lpDesktop = NULL;
        goto Error;
    }
    si.lpTitle = Convert(lpStartupInfo->lpTitle);
    if (si.lpTitle == ERR)
    {
        si.lpTitle = NULL;
        goto Error;
    }

    szApp = Convert(lpApplicationName);
    if (szApp == ERR)
    {
        szApp = NULL;
        goto Error;
    }
    szCommand = ConvertOem(lpCommandLine);
    if (szCommand == ERR)
    {
        szCommand = NULL;
        goto Error;
    }
    szDir = Convert(lpCurrentDirectory);
    if (szDir == ERR)
    {
        szDir = NULL;
        goto Error;
    }

    ret = CreateProcessA(szApp, szCommand, lpProcessAttributes,
                lpThreadAttributes, bInheritHandles, dwCreationFlags,
                lpEnvironment, szDir, &si, lpProcessInformation);

Error:
    if (si.lpDesktop)
        delete si.lpDesktop;
    if (si.lpTitle)
        delete si.lpTitle;

    if (szApp)
        delete szApp;
    if (szCommand)
        delete szCommand;
    if (szDir)
        delete szDir;

    return ret;
}

LONG
APIENTRY
RegEnumKeyExX(
    HKEY hKey,
    DWORD dwIndex,
    LPWSTR lpName,
    LPDWORD lpcbName,
    LPDWORD lpReserved,
    LPWSTR lpClass,
    LPDWORD lpcbClass,
    PFILETIME lpftLastWriteTime
    )
{
    #ifdef DEBUG_OUTPUT
    OutputDebugString("RegEnumKeyEx\n");
    #endif

    LPSTR szName;
    LPSTR szClass = NULL;
    LONG  ret = ERROR_OUTOFMEMORY;

    szName = new CHAR[*lpcbName];
    if (szName == NULL)
        goto Exit;

    if (lpClass != NULL)
    {
        szClass = new CHAR[*lpcbClass + 1];
        if (szName == NULL)
            goto Exit;
    }

    //
    //  Return lengths do not include zero char.
    //
    ret = RegEnumKeyExA(hKey, dwIndex, szName, lpcbName, lpReserved,
                       szClass, lpcbClass, lpftLastWriteTime);

    if (ret == ERROR_SUCCESS)
    {
        AnsiToUnicode(lpName, szName, *lpcbName + 1);

        if (szClass)
        {
            AnsiToUnicode(lpClass, szClass, *lpcbClass + 1);
        }
    }

Exit:
    return ret;
}

BOOL
WINAPI
AppendMenuX(
    HMENU hMenu,
    UINT uFlags,
    UINT uIDnewItem,
    LPCWSTR lpnewItem
    )
{
    #ifdef DEBUG_OUTPUT
    OutputDebugString("AppendMenu\n");
    #endif

    BOOL  ret;
    LPSTR sz;

    if (uFlags == MF_STRING)
    {
        sz = Convert(lpnewItem);
        if (sz==ERR)
        {
            return FALSE;
        }
    }
    else
    {
        sz = (LPSTR) lpnewItem;
    }

    ret = AppendMenuA(hMenu, uFlags, uIDnewItem, sz);

    if (uFlags == MF_STRING)
    {
        if (sz)
            delete sz;
    }

    return ret;
}

HANDLE
WINAPI
OpenEventX(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    LPCWSTR lpName
    )
{
    #ifdef DEBUG_OUTPUT
    OutputDebugString("OpenEvent\n");
    #endif

    LPSTR sz;
    HANDLE ret;

    sz = Convert(lpName);
    if (sz == ERR)
    {
        return NULL;
    }

    ret = OpenEventA(dwDesiredAccess, bInheritHandle, sz);
    if (sz)
        delete sz;
    return ret;
}

HANDLE
WINAPI
CreateEventX(
    LPSECURITY_ATTRIBUTES lpEventAttributes,
    BOOL bManualReset,
    BOOL bInitialState,
    LPCWSTR lpName
    )
{
    #ifdef DEBUG_OUTPUT
    OutputDebugString("CreateEvent\n");
    #endif

    LPSTR sz;
    HANDLE ret;

    sz = Convert(lpName);
    if (sz == ERR)
    {
        return NULL;
    }

    ret = CreateEventA(lpEventAttributes, bManualReset, bInitialState, sz);
    if (sz)
        delete sz;
    return ret;
}

UINT
WINAPI
GetDriveTypeX(
    LPCWSTR lpRootPathName
    )
{
    #ifdef DEBUG_OUTPUT
    OutputDebugString("GetDriveType\n");
    #endif

    LPSTR sz;
    UINT ret;

    sz = Convert(lpRootPathName);
    if (sz == ERR)
    {
        return 0;
    }

    ret = GetDriveTypeA(sz);
    if (sz)
        delete sz;
    return ret;
}

DWORD
WINAPI
GetFileAttributesX(
    LPCWSTR lpFileName
    )
{
    #ifdef DEBUG_OUTPUT
    OutputDebugString("GetFileAttributes\n");
    #endif

    LPSTR sz;
    DWORD ret;

    sz = ConvertOem(lpFileName);
    if (sz == ERR)
        return 0xFFFFFFFF;

    ret = GetFileAttributesA(sz);
    if (sz)
        delete sz;
    return ret;
}

LONG
APIENTRY
RegEnumKeyX(
    HKEY hKey,
    DWORD dwIndex,
    LPWSTR lpName,
    DWORD cbName
    )
{
    #ifdef DEBUG_OUTPUT
    OutputDebugString("RegEnumKey\n");
    #endif

    CHAR sz[MAX_PATH+1];
    LONG ret;

    //
    //  Return lengths do not include zero char.
    //
    ret = RegEnumKeyA(hKey, dwIndex, sz, cbName);
    if (ret == ERROR_SUCCESS)
    {
        AnsiToUnicode(lpName, sz, lstrlenA(sz) + 1);
    }
    return ret;
}

HFINDFILE
WINAPI
FindFirstFileX(
    LPCWSTR lpFileName,
    LPWIN32_FIND_DATAW pwszFd
    )
{
    #ifdef DEBUG_OUTPUT
    OutputDebugString("FindFirstFile\n");
    #endif

    WIN32_FIND_DATAA fd;
    CHAR             sz[MAX_PATH * 2];
    HFINDFILE        ret;
    int              len = wcslen(lpFileName) + 1;

    UnicodeToAnsiOem(sz, lpFileName, sizeof(sz));
    ret = FindFirstFileA(sz, &fd);
    if (ret != INVALID_HANDLE_VALUE)
    {
        memcpy(pwszFd, &fd, sizeof(FILETIME)*3 + sizeof(DWORD)*5);
        AnsiToUnicodeOem(pwszFd->cFileName, fd.cFileName,
                         lstrlenA(fd.cFileName) + 1);
        AnsiToUnicodeOem(pwszFd->cAlternateFileName, fd.cAlternateFileName,
                         14);
    }

    return ret;
}

//+---------------------------------------------------------------------------
//
//  Function:   wsprintfX
//
//  Synopsis:   Nightmare string function
//
//  Arguments:  [pwszOut]    --
//              [pwszFormat] --
//              [...]        --
//
//  Returns:
//
//  History:    1-06-94   ErikGav   Created
//
//  Notes:      If you're reading this, you're probably having a problem with
//              this function.  Make sure that your "%s" in the format string
//              says "%ws" if you are passing wide strings.
//
//              %s on NT means "wide string"
//              %s on Chicago means "ANSI string"
//
//----------------------------------------------------------------------------

int WINAPIV wsprintfX(LPWSTR pwszOut, LPCWSTR pwszFormat, ...)
{
    #ifdef DEBUG_OUTPUT
    OutputDebugString("wsprintf\n");
    #endif

    LPSTR szFormat;
    LPWSTR pwszTemp = NULL;
    int i = 0;

    // Convert the format string over

    szFormat = Convert(pwszFormat);
    if (szFormat == ERR)
    {
        szFormat = NULL;
        goto Exit;
    }

    // magic voodoo follows:
    //
    // 1. Call wvsprintf passing the varargs
    // 2. Use the pwszOut as a temp buffer to hold the ANSI output
    // 3. Save the returned characters

    i = wvsprintfA((LPSTR) pwszOut, szFormat,
                  (LPSTR) ((BYTE*)&pwszFormat) + sizeof(pwszFormat));

    // allocate a buffer for the Ansi to Unicode conversion

    pwszTemp = new WCHAR[i+1];

    // convert the string

    AnsiToUnicode(pwszTemp, (LPSTR) pwszOut, i+1);

    // copy it to the out buffer

    wcsncpy(pwszOut, pwszTemp, i+1);

Exit:
    if (pwszTemp)
        delete pwszTemp;
    if (szFormat)
        delete szFormat;
    return i;
}

BOOL
WINAPI
GetComputerNameX(
    LPWSTR pwszName,
    LPDWORD lpcchBuffer
    )
{
    #ifdef DEBUG_OUTPUT
    OutputDebugString("GetComputerName\n");
    #endif

    BOOL ret;
    LPSTR sz;

    sz  = new CHAR[*lpcchBuffer];
    ret = GetComputerNameA(sz, lpcchBuffer);

    if (ret)
    {
        AnsiToUnicode(pwszName, sz, *lpcchBuffer);
    }

    if (sz)
        delete sz;
    return ret;
}

DWORD
WINAPI
GetFullPathNameX(
    LPCWSTR lpFileName,
    DWORD   cchBuffer,
    LPWSTR  lpPathBuffer,
    LPWSTR *lppFilePart
    )
{
    #ifdef DEBUG_OUTPUT
    OutputDebugString("GetFullPathName\n");
    #endif

    LPSTR szFileName;
    CHAR  szPathBuffer[MAX_PATH];
    LPSTR szFilePart;
    DWORD ret;


    szFileName = ConvertOem(lpFileName);
    if (szFileName == ERR)
        return 0;

    ret = GetFullPathNameA(szFileName, cchBuffer, szPathBuffer, &szFilePart);

    AnsiToUnicode(lpPathBuffer, szPathBuffer, cchBuffer);

    *lppFilePart = lpPathBuffer + (szFilePart - szPathBuffer);

    if (szFileName)
        delete szFileName;

    return ret;
}


DWORD
WINAPI
GetShortPathNameX(
    LPCWSTR lpszFullPath,
    LPWSTR  lpszShortPath,
    DWORD   cchBuffer
    )
{
    #ifdef DEBUG_OUTPUT
    OutputDebugString("GetShortPathName\n");
    #endif

    LPSTR szFullPath;
    CHAR  szShortBuffer[MAX_PATH];
    DWORD ret;


    szFullPath = Convert(lpszFullPath);
    if (szFullPath == ERR)
        return 0;

    if (lpszShortPath == NULL)
    {
        ret = GetShortPathNameA(szFullPath, NULL, cchBuffer);
    }
    else
    {
        ret = GetShortPathNameA(szFullPath, szShortBuffer, sizeof(szShortBuffer));

        //
        //  Only convert the actual data, not the whole buffer.
        //
        if (cchBuffer > ret + 1)
            cchBuffer = ret + 1;

        AnsiToUnicode(lpszShortPath, szShortBuffer, cchBuffer);
    }

    delete szFullPath;

    return ret;
}


DWORD
WINAPI
SearchPathX(
    LPCWSTR lpPath,
    LPCWSTR lpFileName,
    LPCWSTR lpExtension,
    DWORD nBufferLength,
    LPWSTR lpBuffer,
    LPWSTR *lpFilePart
    )
{
    LPSTR lpszFileName;
    CHAR  szBuffer[MAX_PATH];
    DWORD ret;


    #ifdef DEBUG_OUTPUT
    OutputDebugString("SearchPath\n");
    #endif

    lpszFileName = Convert(lpFileName);
    if (lpszFileName == ERR)
        return 0;

    ret = SearchPathA(NULL, lpszFileName, NULL, sizeof(szBuffer), szBuffer, NULL);

    AnsiToUnicode(lpBuffer, szBuffer, lstrlenA(szBuffer) + 1);

    delete lpszFileName;

    return ret;
}


ATOM
WINAPI
GlobalFindAtomX(
    LPCWSTR lpString
    )
{
    LPSTR lpszString;
    ATOM  retAtom;


    #ifdef DEBUG_OUTPUT
    OutputDebugString("GlobalFindAtom\n");
    #endif

    lpszString = Convert(lpString);
    if (lpszString == ERR)
        return 0;

    retAtom = GlobalFindAtomA(lpszString);

    delete lpszString;

    return retAtom;
}


int
WINAPI
GetClassNameX(
    HWND hWnd,
    LPWSTR lpClassName,
    int nMaxCount)
{
    LPSTR lpszClassName;
    int  ret;


    #ifdef DEBUG_OUTPUT
    OutputDebugString("GetClassName\n");
    #endif

    lpszClassName = Convert(lpClassName);
    if (lpszClassName == ERR)
        return 0;

    ret = GetClassNameA(hWnd, lpszClassName, nMaxCount);

    delete lpszClassName;

    return ret;
}


int
WINAPI
lstrlenX(LPCWSTR lpString)
{
    return wcslen(lpString);
}

LPWSTR
WINAPI
lstrcatX(
    LPWSTR lpString1,
    LPCWSTR lpString2)
{
    return wcscat(lpString1, lpString2);
}

int
WINAPI
lstrcmpX(
    LPCWSTR lpString1,
    LPCWSTR lpString2
    )
{
    return wcscmp(lpString1, lpString2);
}

int
WINAPI
lstrcmpiX(
    LPCWSTR lpString1,
    LPCWSTR lpString2
    )
{
    return _wcsicmp(lpString1, lpString2);
}

LPWSTR
WINAPI
lstrcpyX(
    LPWSTR lpString1,
    LPCWSTR lpString2
    )
{
    return wcscpy(lpString1, lpString2);
}



HANDLE
WINAPI
CreateFileMappingX(
    HANDLE hFile,
    LPSECURITY_ATTRIBUTES lpFileMappingAttributes,
    DWORD flProtect,
    DWORD dwMaximumSizeHigh,
    DWORD dwMaximumSizeLow,
    LPCWSTR lpName
    )
{
    LPSTR lpszAName;
    HANDLE ret;


    #ifdef DEBUG_OUTPUT
    OutputDebugString("CreateFileMapping\n");
    #endif

    lpszAName = Convert(lpName);

    if (lpszAName == ERR)
    {
        return 0;
    }

    ret = CreateFileMappingA(
        hFile,
        lpFileMappingAttributes,
        flProtect,
        dwMaximumSizeHigh,
        dwMaximumSizeLow,
        lpszAName);

    delete lpszAName;

    return ret;
}


HANDLE
WINAPI
OpenFileMappingX(
    DWORD dwDesiredAccess,
    BOOL bInheritHandle,
    LPCWSTR lpName
    )
{
    LPSTR lpszAName;
    HANDLE ret;


    #ifdef DEBUG_OUTPUT
    OutputDebugString("CreateFileMapping\n");
    #endif

    lpszAName = Convert(lpName);

    if (lpszAName == ERR)
    {
        return 0;
    }

    ret = OpenFileMappingA(
        dwDesiredAccess,
        bInheritHandle,
        lpszAName);

    delete lpszAName;

    return ret;
}

#endif   //  CHICAGO

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\oledll2\chicago\makefile.inc ===
obj\i386\oledll2.def: oledll2.src
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\com\oleutest\oleexts\oleexts.cpp ===
//+-------------------------------------------------------------------------
//
//  Microsoft Windows
//  Copyright (C) Microsoft Corporation, 1992 - 1993.
//
//  File:       oleexts.cpp
//
//  Contents:   ntsd and windbg debugger extension
//
//  Classes:    none
//
//  Functions:
//              operator new    (global)
//              operator delete (global)
//              sizeofstring
//              dprintfx
//              dump_saferefcount
//              dump_threadcheck
//
//  History:    dd-mmm-yy Author    Comment
//              02-Feb-95 t-ScottH  author
//
//--------------------------------------------------------------------------

#include <windows.h>
#include <imagehlp.h>
#include <ntsdexts.h>

#include <le2int.h>
#include <oaholder.h>
#include <daholder.h>
#include <olerem.h>
#include <defhndlr.h>
#include <deflink.h>
#include <olecache.h>
#include <cachenod.h>
#include <clipdata.h>
#include <mf.h>
#include <emf.h>
#include <gen.h>
#include <defcf.h>
#include <dbgdump.h>

#include "oleexts.h"

// structure of function pointers
NTSD_EXTENSION_APIS ExtensionApis;

//+-------------------------------------------------------------------------
//
//  Function:   operator new (global), internal
//
//  Synopsis:   allocate memory
//
//  Effects:
//
//  Arguments:  [cb]    - number of bytes to allocate
//
//  Requires:   CoTaskMemAlloc
//
//  Returns:    pointer to allocated memory
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              02-Feb-95 t-ScottH  author
//
//  Notes:
//              we define our own operator new so that we do not need to link
//              with the CRT library
//
//              we must also define our own global operator delete
//
//--------------------------------------------------------------------------

void * __cdecl
::operator new(unsigned int cb)
{
    return CoTaskMemAlloc(cb);
}

//+-------------------------------------------------------------------------
//
//  Function:   operator delete (global), internal
//
//  Synopsis:   free memory
//
//  Effects:
//
//  Arguments:  [p] - pointer to the memory to free
//
//  Requires:   CoTaskMemFree
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:  check to see if pointer is valid
//
//  History:    dd-mmm-yy Author    Comment
//              02-Feb-95 t-ScottH  author
//
//  Notes:
//              we define our own operator delete so that we do not need
//              to link with the CRT library
//
//              we must also define our own global operator new
//
//--------------------------------------------------------------------------

void __cdecl
::operator delete (void *p)
{
    // CoTaskMemFree takes care if the pointer is NULL
    CoTaskMemFree(p);
    return;
}

//+-------------------------------------------------------------------------
//
//  Function:   dprintfx, internal
//
//  Synopsis:   prints a formatted string in MAX_STRING_SIZE chunks
//
//  Effects:
//
//  Arguments:  [pszString] - null terminated string
//
//  Requires:   sizeofstring to calculate length of given string
//              dprintf (NTSD Extension API)
//              MAX_STRING_SIZE
//
//              !!!This requires the NTSD_EXTENSION_APIS global variable
//                 ExtensionApis to be initialize with the function
//                 pointers
//
//  Returns:
//
//  Signals:
//
//  Modifies:
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              02-Feb-95 t-ScottH  author
//
//  Notes:
//              NTSD has a limit of a 4K buffer...some of the character
//              arrays from Dump methods can be > 4K. this will
//              print a formatted string in chunks that NTSD can handle
//
//--------------------------------------------------------------------------

#define MAX_STRING_SIZE 1000

void dprintfx(char *pszString)
{
    char *pszFront;
    int size;
    char x;

    for (   pszFront = pszString,
            size = strlen(pszString);
            size > 0;
            pszFront += (MAX_STRING_SIZE - 1),
            size -= (MAX_STRING_SIZE - 1 )  )
    {
        if ( size > (MAX_STRING_SIZE - 1) )
        {
            x = pszFront[MAX_STRING_SIZE - 1];
            pszFront[MAX_STRING_SIZE - 1] = '\0';
            dprintf("%s", pszFront);
            pszFront[MAX_STRING_SIZE - 1] = x;
        }
        else
        {
            dprintf("%s", pszFront);
        }
    }
    return;
}

//+-------------------------------------------------------------------------
//
//  Function:   help, exported
//
//  Synopsis:   print help message
//
//  Effects:
//
//  Arguments:  see DECLARE_API in oleexts.h
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:   ExtensionApis (global)
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              02-Feb-95 t-ScottH  author
//
//  Notes:
//
//--------------------------------------------------------------------------

DECLARE_API( help )
{
    ExtensionApis = *lpExtensionApis;

    if (*args == '\0') {
        dprintf("OLE DEBUGGER EXTENSIONS HELP:\n\n");
        dprintf("!symbol    (<address>|<symbol name>)   - Returns either the symbol name or address\n");

        dprintf("!dump_atom                 <address>      - Dumps a ATOM structure\n");
        dprintf("!dump_clsid                <address>      - Dumps a CLSID structure\n");
        dprintf("!dump_clipformat           <address>      - Dumps a CLIPFORMAT structure\n");
        dprintf("!dump_mutexsem             <address>      - Dumps a CMutexSem class\n");
        dprintf("!dump_filetime             <address>      - Dumps a FILETIME structure\n");
        dprintf("!dump_cachelist_item       <address>      - Dumps a CACHELIST_ITEM struct\n");
        dprintf("!dump_cacheenum            <address>      - Dumps a CCacheEnum class\n");
        dprintf("!dump_cacheenumformatetc   <address>      - Dumps a CCacheEnumFormatEtc class\n");
        dprintf("!dump_cachenode            <address>      - Dumps a CCacheNode class\n");
        dprintf("!dump_clipdataobject       <address>      - Dumps a CClipDataObject class\n");
        dprintf("!dump_clipenumformatetc    <address>      - Dumps a CClipEnumFormatEtc class\n");
        dprintf("!dump_daholder             <address>      - Dumps a CDAHolder class\n");
        dprintf("!dump_dataadvisecache      <address>      - Dumps a CDataAdviseCache class\n");
        dprintf("!dump_defclassfactory      <address>      - Dumps a CDefClassFactory class\n");
        dprintf("!dump_deflink              <address>      - Dumps a CDefLink class\n");
        dprintf("!dump_defobject            <address>      - Dumps a CDefObject class\n");
        dprintf("!dump_emfobject            <address>      - Dumps a CEMfObject class\n");
        dprintf("!dump_enumfmt              <address>      - Dumps a CEnumFmt class\n");
        dprintf("!dump_enumfmt10            <address>      - Dumps a CEnumFmt10 class\n");
        dprintf("!dump_enumstatdata         <address>      - Dumps a CEnumSTATDATA class\n");
        dprintf("!dump_enumverb             <address>      - Dumps a CEnumVerb class\n");
        dprintf("!dump_membytes             <address>      - Dumps a CMemBytes class\n");
        dprintf("!dump_cmemstm              <address>      - Dumps a CMemStm class\n");
        dprintf("!dump_mfobject             <address>      - Dumps a CMfObject class\n");
        dprintf("!dump_oaholder             <address>      - Dumps a COAHolder class\n");
        dprintf("!dump_olecache             <address>      - Dumps a COleCache class\n");
        dprintf("!dump_saferefcount         <address>      - Dumps a CSafeRefCount class\n");
        dprintf("!dump_threadcheck          <address>      - Dumps a CThreadCheck class\n");
        dprintf("!dump_formatetc            <address>      - Dumps a FORMATETC structure\n");
        dprintf("!dump_memstm               <address>      - Dumps a MEMSTM structure\n");
        dprintf("!dump_statdata             <address>      - Dumps a STATDATA structure\n");
        dprintf("!dump_stgmedium            <address>      - Dumps a STGMEDIUM\n");
        dprintf("\n");
    }
}

//+-------------------------------------------------------------------------
//
//  Function:   symbol, exported
//
//  Synopsis:   given an address to a symbol, dumps the symbol name and offset
//              (given a symbol name, dump address and offset)
//
//  Effects:
//
//  Arguments:  see DECLARE_API in oleexts.h
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:   ExtensionApis (global)
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              02-Feb-95 t-ScottH  author
//
//  Notes:
//
//--------------------------------------------------------------------------

DECLARE_API( symbol )
{
    DWORD dwAddr;
    CHAR Symbol[64];
    DWORD Displacement;

    ExtensionApis = *lpExtensionApis;

    dwAddr = GetExpression(args);
    if ( !dwAddr ) {
        return;
    }

    GetSymbol((LPVOID)dwAddr,(unsigned char *)Symbol,&Displacement);
    dprintf("%s+%lx at %lx\n", Symbol, Displacement, dwAddr);
}

//+-------------------------------------------------------------------------
//
//  Function:   dump_atom, exported
//
//  Synopsis:   dumps ATOM object
//
//  Effects:
//
//  Arguments:  see DECLARE_API in oleexts.h
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:   ExtensionApis (global)
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              02-Feb-95 t-ScottH  author
//
//  Notes:
//              The address of the object is passed in the arguments. This
//              address is in the debuggee's process memory. In order for
//              NTSD to view this memory, the debugger must copy the mem
//              using the WIN32 ReadProcessMemory API.
//
//--------------------------------------------------------------------------

DECLARE_API(dump_atom)
{
    // set up global function pointers
    ExtensionApis = *lpExtensionApis;

    dprintf("dump_atom not implemented\n");

    return;
}

//+-------------------------------------------------------------------------
//
//  Function:   dump_clsid, exported
//
//  Synopsis:   dumps CLSID object
//
//  Effects:
//
//  Arguments:  see DECLARE_API in oleexts.h
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:   ExtensionApis (global)
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              02-Feb-95 t-ScottH  author
//
//  Notes:
//              The address of the object is passed in the arguments. This
//              address is in the debuggee's process memory. In order for
//              NTSD to view this memory, the debugger must copy the mem
//              using the WIN32 ReadProcessMemory API.
//
//--------------------------------------------------------------------------

DECLARE_API(dump_clsid)
{
    // set up global function pointers
    ExtensionApis = *lpExtensionApis;

    dprintf("dump_clsid not implemented\n");

    return;
}

//+-------------------------------------------------------------------------
//
//  Function:   dump_clipformat, exported
//
//  Synopsis:   dumps CLIPFORMAT object
//
//  Effects:
//
//  Arguments:  see DECLARE_API in oleexts.h
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:   ExtensionApis (global)
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              02-Feb-95 t-ScottH  author
//
//  Notes:
//              The address of the object is passed in the arguments. This
//              address is in the debuggee's process memory. In order for
//              NTSD to view this memory, the debugger must copy the mem
//              using the WIN32 ReadProcessMemory API.
//
//--------------------------------------------------------------------------

DECLARE_API(dump_clipformat)
{
    // set up global function pointers
    ExtensionApis = *lpExtensionApis;

    dprintf("dump_clipformat not implemented\n");

    return;
}

//+-------------------------------------------------------------------------
//
//  Function:   dump_mutexsem, exported
//
//  Synopsis:   dumps CMutexSem object
//
//  Effects:
//
//  Arguments:  see DECLARE_API in oleexts.h
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:   ExtensionApis (global)
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              02-Feb-95 t-ScottH  author
//
//  Notes:
//              The address of the object is passed in the arguments. This
//              address is in the debuggee's process memory. In order for
//              NTSD to view this memory, the debugger must copy the mem
//              using the WIN32 ReadProcessMemory API.
//
//--------------------------------------------------------------------------

DECLARE_API(dump_mutexsem)
{
    // set up global function pointers
    ExtensionApis = *lpExtensionApis;

    dprintf("dump_mutexsem not implemented\n");

    return;
}

//+-------------------------------------------------------------------------
//
//  Function:   dump_filetime, exported
//
//  Synopsis:   dumps FILETIME object
//
//  Effects:
//
//  Arguments:  see DECLARE_API in oleexts.h
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:   ExtensionApis (global)
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              02-Feb-95 t-ScottH  author
//
//  Notes:
//              The address of the object is passed in the arguments. This
//              address is in the debuggee's process memory. In order for
//              NTSD to view this memory, the debugger must copy the mem
//              using the WIN32 ReadProcessMemory API.
//
//--------------------------------------------------------------------------

DECLARE_API(dump_filetime)
{
    // set up global function pointers
    ExtensionApis = *lpExtensionApis;

    dprintf("dump_filetime not implemented\n");

    return;
}

//+-------------------------------------------------------------------------
//
//  Function:   dump_cachelist_item, exported
//
//  Synopsis:   dumps CACHELIST_ITEM object
//
//  Effects:
//
//  Arguments:  see DECLARE_API in oleexts.h
//
//  Requires:
//
//  Returns:    void
//
//  Signals:
//
//  Modifies:   ExtensionApis (global)
//
//  Algorithm:
//
//  History:    dd-mmm-yy Author    Comment
//              02-Feb-95 t-ScottH  author
//
//  Notes:
//              The address of the object is passed in the arguments. This
//              address is in the debuggee's process memory. In order for
//              NTSD to view this memory, the debugger must copy the mem
//              using the WIN32 ReadProcessMemory API.
//
//--------------------------------------------------------------------------

DECLARE_API(dump_cachelist_item)
{
    BOOL            fError;
    LPVOID          dwAddr;
    DWORD           dwReturnedCount;
    char            *pszCacheListItem;
    char            *blockCacheListItem = NULL;
    char            *blockCacheNode     = NULL;
    char            *blockPresObj       = NULL;
    char            *blockPresObjAF     = NULL;
    CACHELIST_ITEM  *pCacheListItem     = NULL;
    DWORD           dwSizeOfPresObj;

    // set up global function pointers
    ExtensionApis = *lpExtensionApis;

    // get address of object from argument string
    dwAddr = (LPVOID)GetExpression( args );
    if (dwAddr == 0)
    {
        dprintf("Failed to get Address of CACEHLIST_ITEM\n");
        return;
    }

    // read the block of memory from the debugee's process
    blockCacheListItem = new char[sizeof(CACHELIST_ITEM)];

    fError = ReadProcessMemory(
                hCurrentProcess,
                dwAddr,
                blockCacheListItem,
                sizeof(CACHELIST_ITEM),
                &dwReturnedCount
                );

    if (fError == FALSE)
    {
        dprintf("Could not read debuggee's process memory: CACHELIST_ITEM \n");
        dprintf("at address %x\n", dwAddr);
        dprintf("Last Error Code = %d (0x%x)\n", GetLastError(), GetLastError());

        goto errRtn;
    }

    if (