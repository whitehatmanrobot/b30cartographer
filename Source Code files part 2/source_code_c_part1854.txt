nter)(pList->hPrinter64);
                }
                else
                {
                    *((BOOL*)pvOut) = FALSE;
                }
            }                
        break;

        case INDEX_EndDocPrinter:
            {
                PUMPDSIMPLEINPUT    pInput = (PUMPDSIMPLEINPUT) pvIn;
                PHPRINTERLIST       pList = FindPrinterHandle((PUMPD)pInput->umpdCookie, pInput->clientPid, pInput->hPrinter32);                

                if (pList)
                    *((BOOL*)pvOut) = (*fpEndDocPrinter)(pList->hPrinter64);
                else
                    *((BOOL*)pvOut) = FALSE;
            }                
        break;

        case INDEX_AbortPrinter:
            {
                PUMPDSIMPLEINPUT    pInput = (PUMPDSIMPLEINPUT) pvIn;
                PHPRINTERLIST       pList = FindPrinterHandle((PUMPD)pInput->umpdCookie, pInput->clientPid, pInput->hPrinter32);                

                if (pList)
                    *((BOOL*)pvOut) = (*fpAbortPrinter)(pList->hPrinter64);
                else
                    *((BOOL*)pvOut) = FALSE;
            }                
        break;

        case INDEX_ResetPrinterW:
            {
                PRESETPRINTERWINPUT    pInput = (PRESETPRINTERWINPUT) pvIn;
                PHPRINTERLIST          pList = FindPrinterHandle((PUMPD)pInput->umpdCookie, pInput->clientPid, pInput->hPrinter32);                

                if (pList)
                {
                    *((BOOL*)pvOut) = (*fpResetPrinterW)(pList->hPrinter64,
                                                         (PRINTER_DEFAULTSW*)&pInput->ptrDef);
                }
                else
                    *((BOOL*)pvOut) = FALSE;                    
            }                
        break;
        
        case INDEX_QueryColorProfile:
            {
                PQUERYCOLORPROFILEINPUT    pInput = (PQUERYCOLORPROFILEINPUT) pvIn;
                ULONG                      cjProfileSizeOld = pInput->cjProfileSize;
                PHPRINTERLIST              pList = FindPrinterHandle((PUMPD)pInput->umpdCookie, pInput->clientPid, pInput->hPrinter32);                

                if (pList)
                {
                    *((BOOL*)pvOut) = (*fpQueryColorProfile)(pList->hPrinter64,
                                                             pInput->pDevMode,
                                                             pInput->ulQueryMode,
                                                             pInput->pvProfileData,
                                                             &pInput->cjProfileSize,
                                                             &pInput->flProfileFlag);
                    if ((*(INT*)pvOut) == 0 &&
                        pInput->cjProfileSize > cjProfileSizeOld &&
                        (GetLastError() == ERROR_INSUFFICIENT_BUFFER))
                    {
                        pInput->lastError = GetLastError();
                    }
                }
                else
                    *((BOOL*)pvOut) = FALSE;                    
            }                
        break;
        
        case INDEX_UMPDDrvEnableDriver:  // special index for DrvEnableDriver
           {
                PDRVENABLEDRIVERINPUT pInput = (PDRVENABLEDRIVERINPUT) pvIn;
                *((PUMPD *) pvOut) = UMPDDrvEnableDriver(pInput->pwszDriver, DDI_DRIVER_VERSION_NT5_01_SP1);
           }
        break;

        case INDEX_DrvEnablePDEV:
           {
                PDRVENABLEPDEVINPUT pInput = (PDRVENABLEPDEVINPUT) pvIn;
                PUMPD               pUMPD = (PUMPD) pInput->umpdCookie;
                PFN                 pfn = pUMPD->apfn[INDEX_DrvEnablePDEV];
                PUMDHPDEV           pUMdhpdev;
                HANDLE              hPrinter = NULL;
                PHPRINTERLIST       pList;

                // If we have a local hPrinter use it

                if (pInput->bWOW64 &&
                    (pList = FindPrinterHandle((PUMPD)pInput->umpdCookie, pInput->clientPid, HandleToUlong(pInput->hPrinter))))
                {
                    hPrinter = pList->hPrinter64;
                }
                else
                {
                    hPrinter = pInput->hPrinter;
                }
                    
                if (pUMdhpdev = (PUMDHPDEV) LOCALALLOC(sizeof(UMDHPDEV)))
                {
                   ZeroMemory(pUMdhpdev, sizeof(UMDHPDEV));
                   pUMdhpdev->pUMPD = pUMPD;

                   pUMdhpdev->dhpdev = (DHPDEV) pfn(
                                         pInput->pdm,
                                         pInput->pLogAddress,
                                         pInput->cPatterns,
                                         pInput->phsurfPatterns,
                                         pInput->cjCaps,
                                         pInput->pdevcaps,
                                         pInput->cjDevInfo,
                                         pInput->pDevInfo,
                                         pInput->hdev,
                                         pInput->pDeviceName,
                                         hPrinter);


                   if (pUMdhpdev->dhpdev == NULL)
                   {
                       WARNING ("Driver's DrvEnablePDEV failed\n");

                       LOCALFREE(pUMdhpdev);
                       pUMdhpdev = NULL;
                   }
                }
                else
                {
                    WARNING ("umEnablePDEV failed memory allocation \n");
                }

                *((DHPDEV *) pvOut) = (DHPDEV) pUMdhpdev;
           }
        break;

        case INDEX_DrvCompletePDEV:
            {
                PDRVCOMPLETEPDEVINPUT pInput = (PDRVCOMPLETEPDEVINPUT) pvIn;
                PUMDHPDEV             pUMdhpdev = (PUMDHPDEV) pInput->dhpdev;
                PUMPD                 pUMPD = pUMdhpdev->pUMPD;
                PFN                   pfn = pUMPD->apfn[INDEX_DrvCompletePDEV];

                pfn(pUMdhpdev->dhpdev, pInput->hdev);
            }
        break;

        case INDEX_DrvFree:
            {
                PDRVFREEINPUT pInput = (PDRVFREEINPUT) pvIn;
                PUMDHPDEV             pUMdhpdev = (PUMDHPDEV) pInput->dhpdev;
                PUMPD                 pUMPD = pUMdhpdev->pUMPD;
                PFN                   pfn = pUMPD->apfn[INDEX_DrvFree];
                
                if (pfn)
                    pfn(pInput->pv, pInput->id);
            }
        break;

        case INDEX_DrvResetPDEV:
            {
                PDRVRESETPDEVINPUT  pInput = (PDRVRESETPDEVINPUT) pvIn;
                PUMDHPDEV           pUMdhpdevOld= (PUMDHPDEV) pInput->dhpdevOld;
                PUMDHPDEV           pUMdhpdevNew= (PUMDHPDEV) pInput->dhpdevNew;
                PUMPD               pUMPDNew = pUMdhpdevNew->pUMPD;
                PFN                 pfn = pUMPDNew->apfn[INDEX_DrvResetPDEV];
                
                *((BOOL *) pvOut) = (BOOL)pfn(pUMdhpdevOld->dhpdev, pUMdhpdevNew->dhpdev);
            }
        break;

        case INDEX_DrvDisablePDEV:
             {
                PUMDHPDEV pUMdhpdev = (PUMDHPDEV)((PDHPDEVINPUT)pvIn)->dhpdev;
                PUMPD     pUMPD = pUMdhpdev->pUMPD;
                PFN       pfn = pUMPD->apfn[INDEX_DrvDisablePDEV];
                
                pfn(pUMdhpdev->dhpdev);

                // free up memory allocated for user mode printer drivers

                if (pUMdhpdev)
                {
                    LOCALFREE (pUMdhpdev);
                }
             }
        break;

        case INDEX_DrvEnableSurface:
            {
                PUMDHPDEV pUMdhpdev = (PUMDHPDEV)((PDHPDEVINPUT)pvIn)->dhpdev;
                PUMPD     pUMPD = pUMdhpdev->pUMPD;
                PFN       pfn = pUMPD->apfn[INDEX_DrvEnableSurface];
                
                *((HSURF *) pvOut) = (HSURF) pfn(pUMdhpdev->dhpdev);
            }
        break;

        case INDEX_DrvDisableSurface:
            {
                PUMDHPDEV pUMdhpdev = (PUMDHPDEV)((PDHPDEVINPUT)pvIn)->dhpdev;
                PUMPD     pUMPD = pUMdhpdev->pUMPD;
                PFN       pfn = pUMPD->apfn[INDEX_DrvDisableSurface];
                
                pfn(pUMdhpdev->dhpdev);
            }
        break;

        case INDEX_DrvStartDoc:
            {
                PDRVSTARTDOCINPUT  pInput = (PDRVSTARTDOCINPUT)pvIn;
                PUMDHPDEV          pUMdhpdev = AdjustUMdhpdev(pInput->pso);
                //
                // check to make sure we have a dhpdev in the surface
                // neither Unidrv or Pscript checks if EngAssociateSurface is
                // successful or not
                //
                if (pUMdhpdev)
                {
                    PUMPD              pUMPD = pUMdhpdev->pUMPD;
                    PFN                pfn = pUMPD->apfn[INDEX_DrvStartDoc];

                    *((BOOL *) pvOut) = (BOOL)pfn(pInput->pso, pInput->pwszDocName, pInput->dwJobId);
                }
                else
                    *(BOOL *)pvOut = FALSE;
            }
        break;

        case INDEX_DrvEndDoc:
           {
                PDRVENDDOCINPUT pInput = (PDRVENDDOCINPUT)pvIn;
                PUMDHPDEV       pUMdhpdev = AdjustUMdhpdev(pInput->pso);
                PUMPD           pUMPD = pUMdhpdev->pUMPD;
                PFN             pfn = pUMPD->apfn[INDEX_DrvEndDoc];
                
                *((BOOL *) pvOut) = (BOOL)pfn(pInput->pso, pInput->fl );
           }
        break;

        case INDEX_DrvStartPage:
            {
                PSURFOBJINPUT  pInput = (PSURFOBJINPUT)pvIn;
                PUMDHPDEV      pUMdhpdev = AdjustUMdhpdev(pInput->pso);
                PUMPD          pUMPD = pUMdhpdev->pUMPD;
                PFN            pfn = pUMPD->apfn[INDEX_DrvStartPage];
                
                *((BOOL *) pvOut) = (BOOL)pfn(pInput->pso);
            }
        break;

        case INDEX_DrvSendPage:
            {
                PSURFOBJINPUT  pInput = (PSURFOBJINPUT)pvIn;
                PUMDHPDEV      pUMdhpdev = AdjustUMdhpdev(pInput->pso);
                PUMPD          pUMPD = pUMdhpdev->pUMPD;
                PFN            pfn = pUMPD->apfn[INDEX_DrvSendPage];
                
                *((BOOL *) pvOut) = (BOOL)pfn(pInput->pso);
            }
        break;

        case INDEX_DrvEscape:
            {
                PDRVESCAPEINPUT pInput = (PDRVESCAPEINPUT) pvIn;
                PUMDHPDEV       pUMdhpdev = AdjustUMdhpdev(pInput->pso);
                PUMPD           pUMPD = pUMdhpdev->pUMPD;
                PFN             pfn = pUMPD->apfn[INDEX_DrvEscape];
                
                *((ULONG *) pvOut) = (ULONG) pfn(pInput->pso,
                                         pInput->iEsc,
                                         pInput->cjIn,
                                         pInput->pvIn,
                                         pInput->cjOut,
                                         pInput->pvOut);
            }
        break;

        case INDEX_DrvDrawEscape:
            {
                PDRVDRAWESCAPEINPUT pInput = (PDRVDRAWESCAPEINPUT) pvIn;
                PUMDHPDEV       pUMdhpdev = AdjustUMdhpdev(pInput->pso);
                PUMPD           pUMPD = pUMdhpdev->pUMPD;
                PFN             pfn = pUMPD->apfn[INDEX_DrvDrawEscape];
                
                *((ULONG *) pvOut) = (ULONG) pfn(pInput->pso,
                                         pInput->iEsc,
                                         pInput->pco,
                                         pInput->prcl,
                                         pInput->cjIn,
                                         pInput->pvIn);
            }
        break;

        case INDEX_DrvStartBanding:
            {
                PDRVBANDINGINPUT    pInput = (PDRVBANDINGINPUT)pvIn;
                PUMDHPDEV           pUMdhpdev = AdjustUMdhpdev(pInput->pso);
                PUMPD               pUMPD = pUMdhpdev->pUMPD;
                PFN                 pfn = pUMPD->apfn[INDEX_DrvStartBanding];
                
                *((BOOL *) pvOut) = (BOOL)pfn(pInput->pso, pInput->pptl);
            }
        break;

        case INDEX_DrvQueryPerBandInfo:
            {
                PDRVPERBANDINPUT    pInput = (PDRVPERBANDINPUT)pvIn;
                PUMDHPDEV           pUMdhpdev = AdjustUMdhpdev(pInput->pso);
                PUMPD               pUMPD = pUMdhpdev->pUMPD;
                PFN                 pfn = pUMPD->apfn[INDEX_DrvQueryPerBandInfo];
                
                *((BOOL *) pvOut) = (BOOL) pfn(pInput->pso, pInput->pbi);
            }
        break;


        case INDEX_DrvNextBand:
            {
                PDRVBANDINGINPUT    pInput = (PDRVBANDINGINPUT)pvIn;
                PUMDHPDEV           pUMdhpdev = AdjustUMdhpdev(pInput->pso);
                PUMPD               pUMPD = pUMdhpdev->pUMPD;
                PFN                 pfn = pUMPD->apfn[INDEX_DrvNextBand];
                
                *((BOOL *) pvOut) = (BOOL)pfn(pInput->pso, pInput->pptl);
            }
        break;

        case INDEX_DrvBitBlt:
            {
                PDRVBITBLTINPUT  pInput = (PDRVBITBLTINPUT)pvIn;
                PUMDHPDEV        pUMdhpdev = AdjustUMdhpdev(pInput->psoTrg);
                PUMPD            pUMPD = pUMdhpdev->pUMPD;
                PFN              pfn = pUMPD->apfn[INDEX_DrvBitBlt];

                *((BOOL *) pvOut) = (BOOL) pfn(pInput->psoTrg,
                                        pInput->psoSrc,
                                        pInput->psoMask,
                                        pInput->pco,
                                        pInput->pxlo,
                                        pInput->prclTrg,
                                        pInput->pptlSrc,
                                        pInput->pptlMask,
                                        pInput->pbo,
                                        pInput->pptlBrush,
                                        pInput->rop4);

                if (bWOW64 && pInput->pbo)
                {
                    NtGdiBRUSHOBJ_DeleteRbrush(pInput->pbo, NULL);
                }
            }
        break;

        case INDEX_DrvStretchBlt:
            {
                PDRVSTRETCHBLTINPUT  pInput = (PDRVSTRETCHBLTINPUT)pvIn;
                PUMDHPDEV            pUMdhpdev = AdjustUMdhpdev(pInput->psoTrg);
                PUMPD                pUMPD = pUMdhpdev->pUMPD;
                PFN                  pfn = pUMPD->apfn[INDEX_DrvStretchBlt];
                
                *((BOOL *) pvOut) = (BOOL) pfn (pInput->psoTrg,
                                         pInput->psoSrc,
                                         pInput->psoMask,
                                         pInput->pco,
                                         pInput->pxlo,
                                         pInput->pca,
                                         pInput->pptlHTOrg,
                                         pInput->prclTrg,
                                         pInput->prclSrc,
                                         pInput->pptlMask,
                                         pInput->iMode);
            }
        break;

        case INDEX_DrvStretchBltROP:
            {
                PDRVSTRETCHBLTINPUT  pInput = (PDRVSTRETCHBLTINPUT)pvIn;
                PUMDHPDEV            pUMdhpdev = AdjustUMdhpdev(pInput->psoTrg);
                PUMPD                pUMPD = pUMdhpdev->pUMPD;
                PFN                  pfn = pUMPD->apfn[INDEX_DrvStretchBltROP];

                *((BOOL *) pvOut) = (BOOL) pfn (pInput->psoTrg,
                                         pInput->psoSrc,
                                         pInput->psoMask,
                                         pInput->pco,
                                         pInput->pxlo,
                                         pInput->pca,
                                         pInput->pptlHTOrg,
                                         pInput->prclTrg,
                                         pInput->prclSrc,
                                         pInput->pptlMask,
                                         pInput->iMode,
                                         pInput->pbo,
                                         pInput->rop4);

                if (bWOW64 && pInput->pbo)
                {
                    NtGdiBRUSHOBJ_DeleteRbrush(pInput->pbo, NULL);
                }                
            }
        break;

        case INDEX_DrvPlgBlt:
           {
                PDRVPLGBLTINPUT      pInput = (PDRVPLGBLTINPUT)pvIn;
                PUMDHPDEV            pUMdhpdev = AdjustUMdhpdev(pInput->psoTrg);
                PUMPD                pUMPD = pUMdhpdev->pUMPD;
                PFN                  pfn = pUMPD->apfn[INDEX_DrvPlgBlt];
                
                *((BOOL *) pvOut) = (BOOL) pfn(pInput->psoTrg,
                                        pInput->psoSrc,
                                        pInput->psoMask,
                                        pInput->pco,
                                        pInput->pxlo,
                                        pInput->pca,
                                        pInput->pptlBrushOrg,
                                        pInput->pptfx,
                                        pInput->prcl,
                                        pInput->pptl,
                                        pInput->iMode);
           }
        break;

        case INDEX_DrvCopyBits:
            {
                PDRVCOPYBITSINPUT  pInput = (PDRVCOPYBITSINPUT) pvIn;
                PUMDHPDEV          pUMdhpdev;
                PUMPD              pUMPD;
                PFN                pfn;
                SURFOBJ           *pso;
                
                //
                // Special case when psoSrc is a device surface and
                // psoTrg is a bitmap surface. This is used by the engine
                // during simulation of certain drawing calls.
                //

                pso = (pInput->psoTrg->iType == STYPE_BITMAP &&
                       pInput->psoTrg->dhpdev == NULL) ?
                            pInput->psoSrc :
                            pInput->psoTrg;

                if (pso && (pUMdhpdev = AdjustUMdhpdev(pso)))
                {
                    pUMPD = pUMdhpdev->pUMPD;
                    pfn = pUMPD->apfn[INDEX_DrvCopyBits];

                    *((BOOL *) pvOut) = (BOOL) pfn(pInput->psoTrg,
                                            pInput->psoSrc,
                                            pInput->pco,
                                            pInput->pxlo,
                                            pInput->prclTrg,
                                            pInput->pptlSrc);
                }
                else
                {
                    *((BOOL *) pvOut) = FALSE;
                }
            }
        break;

        case INDEX_DrvRealizeBrush:
           {
                PDRVREALIZEBRUSHINPUT  pInput = (PDRVREALIZEBRUSHINPUT)pvIn;
                PUMDHPDEV              pUMdhpdev = AdjustUMdhpdev(pInput->psoTrg);
                PUMPD                  pUMPD = pUMdhpdev->pUMPD;
                PFN                    pfn = pUMPD->apfn[INDEX_DrvRealizeBrush];

                *((BOOL *) pvOut) = (BOOL) pfn(pInput->pbo,
                                        pInput->psoTrg,
                                        pInput->psoPat,
                                        pInput->psoMsk,
                                        pInput->pxlo,
                                        pInput->iHatch);
           }
        break;

        case INDEX_DrvLineTo:
           {
                PDRVLINETOINPUT pInput = (PDRVLINETOINPUT)pvIn;
                PUMDHPDEV       pUMdhpdev = AdjustUMdhpdev(pInput->pso);
                PUMPD           pUMPD = pUMdhpdev->pUMPD;
                PFN             pfn = pUMPD->apfn[INDEX_DrvLineTo];

                *((BOOL *) pvOut) = (BOOL) pfn (pInput->pso,
                                         pInput->pco,
                                         pInput->pbo,
                                         pInput->x1,
                                         pInput->y1,
                                         pInput->x2,
                                         pInput->y2,
                                         pInput->prclBounds,
                                         pInput->mix);
                
                if (bWOW64 && pInput->pbo)
                {
                    NtGdiBRUSHOBJ_DeleteRbrush(pInput->pbo, NULL);
                }
           }
        break;

        case INDEX_DrvStrokePath:
           {
                PSTROKEANDFILLINPUT pInput = (PSTROKEANDFILLINPUT)pvIn;
                PUMDHPDEV           pUMdhpdev = AdjustUMdhpdev(pInput->pso);
                PUMPD               pUMPD = pUMdhpdev->pUMPD;
                PFN                 pfn = pUMPD->apfn[INDEX_DrvStrokePath];

                *((BOOL *) pvOut) = (BOOL) pfn(pInput->pso,
                                        pInput->ppo,
                                        pInput->pco,
                                        pInput->pxo,
                                        pInput->pbo,
                                        pInput->pptlBrushOrg,
                                        pInput->plineattrs,
                                        pInput->mix);

                if (bWOW64 && pInput->pbo)
                {
                    NtGdiBRUSHOBJ_DeleteRbrush(pInput->pbo, NULL);
                }
           }
        break;

        case INDEX_DrvFillPath:
           {
                PSTROKEANDFILLINPUT pInput = (PSTROKEANDFILLINPUT)pvIn;
                PUMDHPDEV           pUMdhpdev = AdjustUMdhpdev(pInput->pso);
                PUMPD               pUMPD = pUMdhpdev->pUMPD;
                PFN                 pfn = pUMPD->apfn[INDEX_DrvFillPath];

                *((BOOL *) pvOut) = (BOOL) pfn(pInput->pso,
                                        pInput->ppo,
                                        pInput->pco,
                                        pInput->pbo,
                                        pInput->pptlBrushOrg,
                                        pInput->mix,
                                        pInput->flOptions);

                if (bWOW64 && pInput->pbo)
                {
                    NtGdiBRUSHOBJ_DeleteRbrush(pInput->pbo, NULL);
                }
           }
        break;

        case INDEX_DrvStrokeAndFillPath:
          {
                PSTROKEANDFILLINPUT pInput = (PSTROKEANDFILLINPUT)pvIn;
                PUMDHPDEV           pUMdhpdev = AdjustUMdhpdev(pInput->pso);
                PUMPD               pUMPD = pUMdhpdev->pUMPD;
                PFN                 pfn = pUMPD->apfn[INDEX_DrvStrokeAndFillPath];

                *((BOOL *) pvOut) = (BOOL) pfn(pInput->pso,
                                        pInput->ppo,
                                        pInput->pco,
                                        pInput->pxo,
                                        pInput->pbo,
                                        pInput->plineattrs,
                                        pInput->pboFill,
                                        pInput->pptlBrushOrg,
                                        pInput->mix,
                                        pInput->flOptions);

                if (bWOW64 && (pInput->pbo || pInput->pboFill))
                {
                    NtGdiBRUSHOBJ_DeleteRbrush(pInput->pbo, pInput->pboFill);
                }
          }
        break;

        case INDEX_DrvPaint:
          {
                PSTROKEANDFILLINPUT pInput = (PSTROKEANDFILLINPUT)pvIn;
                PUMDHPDEV           pUMdhpdev = AdjustUMdhpdev(pInput->pso);
                PUMPD               pUMPD = pUMdhpdev->pUMPD;
                PFN                 pfn = pUMPD->apfn[INDEX_DrvPaint];

                *((BOOL *) pvOut) = (BOOL) pfn(pInput->pso,
                                        pInput->pco,
                                        pInput->pbo,
                                        pInput->pptlBrushOrg,
                                        pInput->mix);

                if (bWOW64 && pInput->pbo)
                {
                    NtGdiBRUSHOBJ_DeleteRbrush(pInput->pbo, NULL);
                }
          }
        break;

        case INDEX_DrvGradientFill:
          {
                PGRADIENTINPUT      pInput = (PGRADIENTINPUT)pvIn;
                PUMDHPDEV           pUMdhpdev = AdjustUMdhpdev(pInput->psoTrg);
                PUMPD               pUMPD = pUMdhpdev->pUMPD;
                PFN                 pfn = pUMPD->apfn[INDEX_DrvGradientFill];

                *((BOOL *) pvOut) = (BOOL) pfn(pInput->psoTrg,
                                        pInput->pco,
                                        pInput->pxlo,
                                        pInput->pVertex,
                                        pInput->nVertex,
                                        pInput->pMesh,
                                        pInput->nMesh,
                                        pInput->prclExtents,
                                        pInput->pptlDitherOrg,
                                        pInput->ulMode);
          }
        break;

        case INDEX_DrvAlphaBlend:
          {
                PALPHAINPUT      pInput = (PALPHAINPUT)pvIn;
                PUMDHPDEV        pUMdhpdev = AdjustUMdhpdev(pInput->psoTrg);
                PUMPD            pUMPD = pUMdhpdev->pUMPD;
                PFN              pfn = pUMPD->apfn[INDEX_DrvAlphaBlend];
                
                *((BOOL *) pvOut) = (BOOL) pfn(pInput->psoTrg,
                                        pInput->psoSrc,
                                        pInput->pco,
                                        pInput->pxlo,
                                        pInput->prclDest,
                                        pInput->prclSrc,
                                        pInput->pBlendObj);
          }
        break;

        case INDEX_DrvTransparentBlt:
            {
                PTRANSPARENTINPUT      pInput = (PTRANSPARENTINPUT)pvIn;
                PUMDHPDEV              pUMdhpdev = AdjustUMdhpdev(pInput->psoTrg);
                PUMPD                  pUMPD = pUMdhpdev->pUMPD;
                PFN                    pfn = pUMPD->apfn[INDEX_DrvTransparentBlt];
                
                *((BOOL *) pvOut) = (BOOL) pfn(pInput->psoTrg,
                                        pInput->psoSrc,
                                        pInput->pco,
                                        pInput->pxlo,
                                        pInput->prclDst,
                                        pInput->prclSrc,
                                        pInput->TransColor,
                                        pInput->ulReserved);
            }
            break;

        case INDEX_DrvTextOut:
            {
                PTEXTOUTINPUT    pInput = (PTEXTOUTINPUT)pvIn;
                PUMDHPDEV        pUMdhpdev = AdjustUMdhpdev(pInput->pso);
                PUMPD            pUMPD = pUMdhpdev->pUMPD;
                PFN              pfn = pUMPD->apfn[INDEX_DrvTextOut];

                *((BOOL *) pvOut) = (BOOL) pfn(pInput->pso,
                                        pInput->pstro,
                                        pInput->pfo,
                                        pInput->pco,
                                        pInput->prclExtra,
                                        pInput->prclOpaque,
                                        pInput->pboFore,
                                        pInput->pboOpaque,
                                        pInput->pptlOrg,
                                        pInput->mix);

                if (bWOW64 && (pInput->pboFore || pInput->pboOpaque))
                {
                    NtGdiBRUSHOBJ_DeleteRbrush(pInput->pboFore, pInput->pboOpaque);
                }
            }
            break;

        case INDEX_DrvQueryFont:
            {
                PQUERYFONTINPUT    pInput = (PQUERYFONTINPUT)pvIn;
                PUMDHPDEV          pUMdhpdev = (PUMDHPDEV)(pInput->dhpdev);
                PUMPD              pUMPD = pUMdhpdev->pUMPD;
                PFN                pfn = pUMPD->apfn[INDEX_DrvQueryFont];
                
                *((PIFIMETRICS *) pvOut) = (PIFIMETRICS) pfn(
                                                pUMdhpdev->dhpdev,
                                                pInput->iFile,
                                                pInput->iFace,
                                                pInput->pid);

                if (pInput->iFace && *((PIFIMETRICS*)pvOut) && pInput->pv)
                {
                    ASSERTGDI(pInput->cjMaxData >= (*(PIFIMETRICS*)pvOut)->cjThis, "gdi32!GdiPrinterThunk: not enough buffer for ifimetrics\n");
                    if (pInput->cjMaxData >= (*(PIFIMETRICS*)pvOut)->cjThis) 
                    {
                        RtlCopyMemory(pInput->pv, (PBYTE)(*(PIFIMETRICS*)pvOut), (*(PIFIMETRICS*)pvOut)->cjThis);
                    }
                    else
                    {
                        iRet = -1;
                        WARNING(("Not enough buffer for ifimetrics  cjMaxData: 0x%lx  cjSize: 0x%lx pInput.pv %lp pvOut %lp\n",
                                 pInput->cjMaxData, (*(PIFIMETRICS*)pvOut)->cjThis, pInput->pv, pvOut));
                        pInput->cjMaxData = 0;
                    }
                }
            }
        break;

        case INDEX_DrvQueryFontTree:
            {
                PQUERYFONTINPUT    pInput = (PQUERYFONTINPUT)pvIn;
                PUMDHPDEV          pUMdhpdev = (PUMDHPDEV)(pInput->dhpdev);
                PUMPD              pUMPD = pUMdhpdev->pUMPD;
                PFN                pfn = pUMPD->apfn[INDEX_DrvQueryFontTree];
                ULONG              cjSize = 0;
                FD_GLYPHSET*       pfdg;

                *((PVOID *) pvOut) = (PVOID) pfn (pUMdhpdev->dhpdev,
                                                  pInput->iFile,
                                                  pInput->iFace,
                                                  pInput->iMode,
                                                  pInput->pid);

                if (pInput->iMode == QFT_GLYPHSET && *((FD_GLYPHSET**)pvOut) && pInput->pv)
                {
                    pfdg = *((FD_GLYPHSET**)pvOut);
                    cjSize = offsetof(FD_GLYPHSET, awcrun) + pfdg->cRuns * sizeof(WCRUN) + pfdg->cGlyphsSupported * sizeof(HGLYPH);

                    ASSERTGDI(pInput->cjMaxData >= cjSize, "gdi32!GdiPrinterThunk: not enough buffer for glyphset\n");

                    if ((pInput->cjMaxData < cjSize) || 
                        !GdiCopyFD_GLYPHSET((FD_GLYPHSET*)pInput->pv, pfdg, cjSize))
                    {
                            WARNING("GDI32: Not enough bufer or error copying FD_GLYPHSET\n");
                            pInput->cjMaxData = 0;
                            iRet = -1;
                    }
                }
                else if (pInput->iMode == QFT_KERNPAIRS && *(FD_KERNINGPAIR **)pvOut && pInput->pv) 
                {
                    FD_KERNINGPAIR *pkpEnd = *(FD_KERNINGPAIR **)pvOut;
                    
                    while ((pkpEnd->wcFirst) || (pkpEnd->wcSecond) || (pkpEnd->fwdKern))
                    {
                        pkpEnd += 1;
                        cjSize++;
                    }

                    cjSize = (cjSize + 1) * sizeof(FD_KERNINGPAIR);

                    ASSERTGDI(pInput->cjMaxData >= cjSize, "gdi32!GdiPrinterThunk: not enough buffer for Kerningpairs\n");
                    if (pInput->cjMaxData >= cjSize) 
                    {
                        RtlCopyMemory(pInput->pv, (PBYTE)(*(FD_KERNINGPAIR **)pvOut), cjSize);
                    }
                    else
                    {
                        WARNING(("Not enough buffer forkerningpair  cjMaxData: 0x%lx  cjSize: 0x%lx pInput.pv %lp pvOut %lp\n",
                                 pInput->cjMaxData, cjSize, pInput->pv, pvOut));
                        pInput->cjMaxData = 0;
                        iRet = -1;
                    }
                }

            }
        break;


        case INDEX_DrvQueryFontData:
            {
                PQUERYFONTDATAINPUT    pInput = (PQUERYFONTDATAINPUT)pvIn;
                PUMDHPDEV              pUMdhpdev = (PUMDHPDEV)(pInput->dhpdev);
                PUMPD                  pUMPD = pUMdhpdev->pUMPD;
                PFN                    pfn = pUMPD->apfn[INDEX_DrvQueryFontData];
                
                *((ULONG *) pvOut) = (ULONG)pfn (pUMdhpdev->dhpdev,
                                          pInput->pfo,
                                          pInput->iMode,
                                          pInput->hg,
                                          pInput->pgd,
                                          pInput->pv,
                                          pInput->cjSize);
            }
            break;

        case INDEX_DrvQueryAdvanceWidths:
            {
                PQUERYADVWIDTHSINPUT   pInput = (PQUERYADVWIDTHSINPUT)pvIn;
                PUMDHPDEV              pUMdhpdev = (PUMDHPDEV)(pInput->dhpdev);
                PUMPD                  pUMPD = pUMdhpdev->pUMPD;
                PFN                    pfn = pUMPD->apfn[INDEX_DrvQueryAdvanceWidths];
                
                *((BOOL *) pvOut) = (BOOL)pfn (pUMdhpdev->dhpdev,
                                         pInput->pfo,
                                         pInput->iMode,
                                         pInput->phg,
                                         pInput->pvWidths,
                                         pInput->cGlyphs);
            }
            break;

       case INDEX_DrvGetGlyphMode:
            {
                PQUERYFONTDATAINPUT    pInput = (PQUERYFONTDATAINPUT)pvIn;
                PUMDHPDEV              pUMdhpdev = (PUMDHPDEV)(pInput->dhpdev);
                PUMPD                  pUMPD = pUMdhpdev->pUMPD;
                PFN                    pfn = pUMPD->apfn[INDEX_DrvGetGlyphMode];
                
                *((ULONG *) pvOut) = (ULONG) pfn (pUMdhpdev->dhpdev, pInput->pfo);
            }
            break;

       case INDEX_DrvFontManagement:
            {
                PFONTMANAGEMENTINPUT   pInput = (PFONTMANAGEMENTINPUT)pvIn;
                PUMDHPDEV              pUMdhpdev;
                PUMPD                  pUMPD;
                PFN                    pfn;
                
                if (pInput->iMode == QUERYESCSUPPORT)
                    pUMdhpdev = (PUMDHPDEV) pInput->dhpdev;
                else
                    pUMdhpdev = AdjustUMdhpdev(pInput->pso);

                pUMPD = pUMdhpdev->pUMPD;
                pfn = pUMPD->apfn[INDEX_DrvFontManagement];

                *((ULONG *) pvOut) = (ULONG)pfn(pInput->pso,
                                         pInput->pfo,
                                         pInput->iMode,
                                         pInput->cjIn,
                                         pInput->pvIn,
                                         pInput->cjOut,
                                         pInput->pvOut);
           }
           break;

        case INDEX_DrvDitherColor:
             {
                PDRVDITHERCOLORINPUT pInput = (PDRVDITHERCOLORINPUT)pvIn;
                PUMDHPDEV pUMdhpdev = (PUMDHPDEV)pInput->dhpdev;
                PUMPD     pUMPD = pUMdhpdev->pUMPD;
                PFN       pfn = pUMPD->apfn[INDEX_DrvDitherColor];
                
                *((ULONG *) pvOut) = (ULONG)pfn(pUMdhpdev->dhpdev,
                                         pInput->iMode,
                                         pInput->rgb,
                                         pInput->pul);
             }
        break;

        case INDEX_DrvDeleteDeviceBitmap:
            {
                PDRVDELETEDEVBITMAP   pInput = (PDRVDELETEDEVBITMAP) pvIn;
                PUMDHPDEV             pUMdhpdev = (PUMDHPDEV) pInput->dhpdev;
                PUMPD                 pUMPD = pUMdhpdev->pUMPD;
                PFN                   pfn = pUMPD->apfn[INDEX_DrvDeleteDeviceBitmap];
                
                pfn(pUMdhpdev->dhpdev, pInput->dhsurf);
            }
        break;

        case INDEX_DrvIcmDeleteColorTransform:
            {
                PDRVICMDELETECOLOR    pInput = (PDRVICMDELETECOLOR)pvIn;
                PUMDHPDEV             pUMdhpdev = (PUMDHPDEV) pInput->dhpdev;
                PUMPD                 pUMPD = pUMdhpdev->pUMPD;
                PFN                   pfn = pUMPD->apfn[INDEX_DrvIcmDeleteColorTransform];
                
                *((BOOL *) pvOut) = (BOOL)pfn(pUMdhpdev->dhpdev, pInput->hcmXform);
            }
        break;

        case INDEX_DrvIcmCreateColorTransform:
            {
                PDRVICMCREATECOLORINPUT    pInput = (PDRVICMCREATECOLORINPUT) pvIn;
                PUMDHPDEV             pUMdhpdev = (PUMDHPDEV) pInput->dhpdev;
                PUMPD                 pUMPD = pUMdhpdev->pUMPD;
                PFN                   pfn = pUMPD->apfn[INDEX_DrvIcmCreateColorTransform];
                
                *((HANDLE *) pvOut) = (HANDLE)pfn(pUMdhpdev->dhpdev,
                                          pInput->pLogColorSpace,
                                          pInput->pvSourceProfile,
                                          pInput->cjSourceProfile,
                                          pInput->pvDestProfile,
                                          pInput->cjDestProfile,
                                          pInput->pvTargetProfile,
                                          pInput->cjTargetProfile,
                                          pInput->dwReserved);
            }
        break;

        case INDEX_DrvIcmCheckBitmapBits:
            {
                PDRVICMCHECKBITMAPINPUT   pInput = (PDRVICMCHECKBITMAPINPUT) pvIn;
                PUMDHPDEV                 pUMdhpdev = (PUMDHPDEV) pInput->dhpdev;
                PUMPD                     pUMPD = pUMdhpdev->pUMPD;
                PFN                       pfn = pUMPD->apfn[INDEX_DrvIcmCheckBitmapBits];
                
                pfn(pUMdhpdev->dhpdev,
                    pInput->hColorTransform,
                    pInput->pso,
                    pInput->paResults);
            }
        break;

        case INDEX_DrvQueryDeviceSupport:
            {
                PDRVQUERYDEVICEINPUT pInput = (PDRVQUERYDEVICEINPUT) pvIn;
                PUMDHPDEV            pUMdhpdev = AdjustUMdhpdev(pInput->pso);
                PUMPD                pUMPD = pUMdhpdev->pUMPD;
                PFN                  pfn = pUMPD->apfn[INDEX_DrvQueryDeviceSupport];
                
                *((ULONG *) pvOut) = (ULONG) pfn(pInput->pso,
                                         pInput->pxlo,
                                         pInput->pxo,
                                         pInput->iType,
                                         pInput->cjIn,
                                         pInput->pvIn,
                                         pInput->cjOut,
                                         pInput->pvOut);
            }
        break;

        case INDEX_UMPDAllocUserMem:
            {
                PUMPDALLOCUSERMEMINPUT pInput = (PUMPDALLOCUSERMEMINPUT) pvIn;

                ASSERTGDI(bWOW64, "Calling INDEX_UMPDAllocUserMem during NONE wow64 printing\n");

                *((KERNEL_PVOID*)pvOut) = UMPDAllocUserMem(pInput->cjSize);
            }
        break;

        case INDEX_UMPDCopyMemory:
            {
                PUMPDCOPYMEMINPUT pInput = (PUMPDCOPYMEMINPUT) pvIn;
            
                ASSERTGDI(bWOW64, "Calling INDEX_UMPDCopyMemory during NONE wow64 printing\n");
            
                *((KERNEL_PVOID*)pvOut) = UMPDCopyMemory(pInput->pvSrc,
                                                         pInput->pvDest,
                                                         pInput->cjSize);
            }
        break;

        case INDEX_UMPDFreeMemory:
            {
                PUMPDFREEMEMINPUT  pInput = (PUMPDFREEMEMINPUT) pvIn;

                ASSERTGDI(bWOW64, "Calling INDEX_UMPDFreeMemory during NONE wow64 printing\n");

                *((BOOL*)pvOut) = UMPDFreeMemory(pInput->pvTrg,
                                                 pInput->pvSrc,
                                                 pInput->pvMsk);
            }
        break;

        case  INDEX_UMPDEngFreeUserMem:
            {
                PUMPDFREEMEMINPUT   pInput = (PUMPDFREEMEMINPUT) pvIn;

                if (bWOW64)
                {
                    *((BOOL*)pvOut) = NtGdiUMPDEngFreeUserMem(&pInput->pvTrg);
                }
            }
        break;

      default:

         WARNING ("Drv call is not supported\n");
         iRet = GPT_ERROR;
         break;
    }

    if (bSetPUMPD)
    {
        NtGdiSetPUMPDOBJ(hSaved, FALSE, &pumpdthdr->humpd, NULL);
    }

    return (iRet);
}

#endif // !_GDIPLUS_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\client\umpd.cxx ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

    umpd.c

Abstract:

    User-mode printer driver support

Environment:

        Windows NT 5.0

Revision History:

        06/30/97 -davidx-
                Created it.

    09/17/97 -davidx-
        Clean up km-um thunking.

--*/

extern "C"
{
#include "precomp.h"
#include "winddi.h"
#include "psapi.h"
#include "proxyport.h"

static PUMPD gCachedUMPDList = NULL;           // cached list of user-mode printer drivers
}

#include "umpd.hxx"

#define IA64_PAGE_SIZE              0x2000
#define PP_SHAREDSECTION_SIZE       IA64_PAGE_SIZE

PVOID
MyGetPrinterDriver(
    HANDLE  hPrinter,
    DWORD   dwLevel
    )

/*++

Routine Description:

    Wrapper function for spooler's GetPrinterDriver API

Arguments:

    hPrinter - Handle to the printer
    dwLevel - Level of DRIVER_INFO_x structure the caller is interested in

Return Value:

    Pointer to a DRIVER_INFO_x structure, NULL if there is an error

--*/

{
    DWORD   cbNeeded;
    PVOID   pv;
    INT     retries = 0;

    //
    // Start with a default buffer size to avoid always
    // having to call GetPrinterDriver twice.
    //

    cbNeeded = 2 * MAX_PATH * sizeof(WCHAR);

    while (retries++ < 2)
    {
        if (! (pv = LOCALALLOC(cbNeeded)))
        {
            WARNING("Memory allocation failed.\n");
            return NULL;
        }

        if (fpGetPrinterDriverW(hPrinter, NULL, dwLevel, (LPBYTE)pv, cbNeeded, &cbNeeded))
            return pv;

        //
        // If GetPrinterDriver failed not for insufficient buffer,
        // skip the retry
        //

        if (GetLastError() != ERROR_INSUFFICIENT_BUFFER)
            retries++;

        LOCALFREE(pv);
    }

    WARNING("GetPrinterDriver failed.\n");
    return NULL;
}


PWSTR
DuplicateString(
    PCWSTR  pSrc
    )

/*++

Routine Description:

    Allocate memory and make a duplicate of the source string

Arguments:

    pSrc - String to be duplicated

Return Value:

    Pointer to the duplicated string
    NULL if there is an error

--*/

{
    PWSTR   pDest;
    INT     cb;

    ASSERTGDI(pSrc != NULL, "Duplicate NULL string!\n");

    cb = (wcslen(pSrc) + 1) * sizeof(WCHAR);

    if (pDest = (PWSTR) LOCALALLOC(cb))
    {
        CopyMemory(pDest, pSrc, cb);
        return pDest;
    }
    else
    {
        WARNING("DuplicateString: out-of-memory.\n");
        return NULL;
    }
}

PDRIVER_INFO_5W
DuplicateDriverInfo5W(PDRIVER_INFO_5W inDriverInfo)
{
    ULONG               size = sizeof(DRIVER_INFO_5W);
    PDRIVER_INFO_5W     pDriverInfo;
    PWSTR               pStr;
    ULONG               len;

    size += (inDriverInfo->pName == NULL ? 0 : (wcslen(inDriverInfo->pName) + 1) * sizeof(WCHAR));
    size += (inDriverInfo->pEnvironment == NULL ? 0 : (wcslen(inDriverInfo->pEnvironment) + 1) * sizeof(WCHAR));
    size += (inDriverInfo->pDriverPath == NULL ? 0 : (wcslen(inDriverInfo->pDriverPath) + 1) * sizeof(WCHAR));
    size += (inDriverInfo->pDataFile == NULL ? 0 : (wcslen(inDriverInfo->pDataFile) + 1) * sizeof(WCHAR));
    size += (inDriverInfo->pConfigFile == NULL ? 0 : (wcslen(inDriverInfo->pConfigFile) + 1) * sizeof(WCHAR));

    if(pDriverInfo = (PDRIVER_INFO_5W) LOCALALLOC(size))
    {
        *pDriverInfo = *inDriverInfo;

        pStr = (PWSTR) (pDriverInfo + 1);

        if(pDriverInfo->pName)
        {
            len = wcslen(pDriverInfo->pName) + 1;
            RtlCopyMemory(pStr, pDriverInfo->pName, len * sizeof(WCHAR));
            pDriverInfo->pName = pStr;
            pStr += len;
        }
    
        if(pDriverInfo->pEnvironment)
        {
            len = wcslen(pDriverInfo->pEnvironment) + 1;
            RtlCopyMemory(pStr, pDriverInfo->pEnvironment, len * sizeof(WCHAR));
            pDriverInfo->pEnvironment = pStr;
            pStr += len;
        }
    
        if(pDriverInfo->pDriverPath)
        {
            len = wcslen(pDriverInfo->pDriverPath) + 1;
            RtlCopyMemory(pStr, pDriverInfo->pDriverPath, len * sizeof(WCHAR));
            pDriverInfo->pDriverPath = pStr;
            pStr += len;
        }
    
        if(pDriverInfo->pDataFile)
        {
            len = wcslen(pDriverInfo->pDataFile) + 1;
            RtlCopyMemory(pStr, pDriverInfo->pDataFile, len * sizeof(WCHAR));
            pDriverInfo->pDataFile = pStr;
            pStr += len;
        }
        
        if(pDriverInfo->pConfigFile)
        {
            len = wcslen(pDriverInfo->pConfigFile) + 1;
            RtlCopyMemory(pStr, pDriverInfo->pConfigFile, len * sizeof(WCHAR));
            pDriverInfo->pConfigFile = pStr;
            pStr += len;
        }
    }

    return pDriverInfo;
}

PUMPD
FindUserModePrinterDriver(
    PCWSTR  pDriverDllName,
    DWORD   dwDriverVersion,
    BOOL    bUseVersion
    )

/*++

Routine Description:

    Search the cached list of user-mode printer drivers and
    see if the specified driver is found

Arguments:

    pDriverDllName - Specifies the name of the driver DLL to be found
    dwDriverVersion - Current version number of the driver
    bUseVersion - Flag for using the version check

Return Value:

    Pointer to the UMPD structure corresponding to the specified driver
    NULL if the specified driver is not in the cached list

Note:

    This function must be called inside a critical section:

        ENTERCRITICALSECTION(&semUMPD);
        ...
        LEAVECRITICALSECTION(&semUMPD);

--*/

{
    PUMPD   pUMPD = gCachedUMPDList;

    while (pUMPD != NULL &&
           _wcsicmp(pDriverDllName, pUMPD->pDriverInfo2->pDriverPath) != 0)
    {
        pUMPD = pUMPD->pNext;
    }

    // Do the version check if neccesary
    if (bUseVersion && pUMPD)
    {
        if (dwDriverVersion != pUMPD->dwDriverVersion)
        {
            // We have a version mismatch. Remove artificial increments on this
            // driver.
            if (pUMPD->bArtificialIncrement)
            {
                pUMPD->bArtificialIncrement = FALSE;

                if (UnloadUserModePrinterDriver(pUMPD, FALSE, 0))
                {
                    pUMPD = NULL;
                }
            }
        }
    }

    return pUMPD;
}

BOOL
GdiArtificialDecrementDriver(
    LPWSTR pDriverDllName,
    DWORD  dwDriverAttributes
    )

/*++

Routine Description:

    Remove the artificial increment on the driver, if any.

Arguments:

    pDriverDllName - Specifies the name of the driver DLL to be found
    dwDriverAttributes - User/Kernel mode printer driver

Return Value:

    TRUE if the driver file is no longer loaded in the spooler
    FALSE otherwise

--*/

{
    PUMPD   pUMPD;
    BOOL    bReturn = FALSE;

    if (!pDriverDllName || !*pDriverDllName)
    {
       // Nothing to unload
       return bReturn;
    }

    if (dwDriverAttributes & DRIVER_KERNELMODE)
    {
       // Unload kernel mode driver
       return NtGdiUnloadPrinterDriver(pDriverDllName,
                                       (wcslen(pDriverDllName) + 1) * sizeof(WCHAR));
    }

    ENTERCRITICALSECTION(&semUMPD);

    pUMPD = gCachedUMPDList;

    while (pUMPD != NULL &&
           _wcsicmp(pDriverDllName, pUMPD->pDriverInfo2->pDriverPath) != 0)
    {
        pUMPD = pUMPD->pNext;
    }

    if (pUMPD)
    {
        if (pUMPD->bArtificialIncrement)
        {
            pUMPD->bArtificialIncrement = FALSE;
            bReturn = UnloadUserModePrinterDriver(pUMPD, FALSE, 0);
        }
    }
    else
    {
        bReturn = TRUE;
    }

    LEAVECRITICALSECTION(&semUMPD);

    return bReturn;
}


BOOL
LoadUserModePrinterDriverEx(
    PDRIVER_INFO_5W  pDriverInfo5,
    LPWSTR           pwstrPrinterName,
    PUMPD           *ppUMPD,
    PRINTER_DEFAULTSW  *pdefaults,
    HANDLE            hPrinter
    )
{
    PDRIVER_INFO_2W pDriverInfo2;
    HINSTANCE       hInst = NULL;
    BOOL            bResult = FALSE;
    PUMPD           pUMPD = NULL;
    ProxyPort *     pp = NULL;
    KERNEL_PVOID    umpdCookie = NULL;
    BOOL            bFreeDriverInfo2 = TRUE;

    if ((pDriverInfo2 = (PDRIVER_INFO_2W) DuplicateDriverInfo5W(pDriverInfo5)) == NULL)
        return FALSE;
 
    //
    // Check the list of cached user-mode printer drivers
    // and see if the requested printer driver is already loaded
    //

    ENTERCRITICALSECTION(&semUMPD);

    if (*ppUMPD = FindUserModePrinterDriver(pDriverInfo5->pDriverPath,
                                            pDriverInfo5->dwDriverVersion,
                                            TRUE))
    {
        if (gbWOW64)
        {
            pUMPD = *ppUMPD;

            ASSERTGDI(pUMPD->pp, "LoadUserModePrinterDriver NULL proxyport\n");
            
            PROXYPORT  proxyport(pUMPD->pp);

            if (proxyport.bValid())
            {
                umpdCookie = proxyport.LoadDriver(pDriverInfo5, pwstrPrinterName, pdefaults, hPrinter);

                if (pUMPD->umpdCookie == umpdCookie)
                {
                    // 64-bit UMPD matches the 32-bit one
                    
                    bResult = TRUE;
                }
                else
                {
                    WARNING("LoadUserModePrinterDriveEx: umpdCookie doesn't match\n");
                }
            }
            else
                WARNING("LoadUserModePrinterDriverEx: invalid proxyport\n");
        }
        else
        {
            // x86 or native ia64 printing, don't need to anything

            bResult = TRUE;
        }
    }
    else
    {
        // Can't find UMPD, first time load the printer driver
    
        if (gbWOW64)
        {
            PROXYPORT proxyport(PP_SHAREDSECTION_SIZE);
    
            if (pp = proxyport.GetPort())
            {
                umpdCookie = proxyport.LoadDriver(pDriverInfo5, pwstrPrinterName, pdefaults, hPrinter);
            }
        }
        else
        {
            hInst = LoadLibraryExW(pDriverInfo2->pDriverPath, NULL, LOAD_WITH_ALTERED_SEARCH_PATH);
        }
        
        if (hInst || umpdCookie)
        {
            if (pUMPD = (PUMPD) LOCALALLOC(sizeof(UMPD)))
            {
                ZeroMemory(pUMPD, sizeof(UMPD));
    
                pUMPD->dwSignature = UMPD_SIGNATURE;
                pUMPD->hInst = hInst;
                pUMPD->pDriverInfo2 = pDriverInfo2;
                pUMPD->bArtificialIncrement = TRUE;
                pUMPD->dwDriverVersion = pDriverInfo5->dwDriverVersion;
                pUMPD->iRefCount = 1;           // aritficial ref count to keep the printer driver around
                                                // till the process goes away
                pUMPD->pp = pp;
                pUMPD->umpdCookie = umpdCookie;
    
                *ppUMPD = pUMPD;
                bResult = TRUE;
    
                bFreeDriverInfo2 = FALSE;
    
                //
                // Add the newly loaded driver to the list of
                // cached user-mode printer drivers
                //
    
                pUMPD->pNext = gCachedUMPDList;
                gCachedUMPDList = pUMPD;
            }
        }    
        
        if (!bResult)
        {
            if (pp)
            {
                PROXYPORT  proxyport(pp);
    
                if (umpdCookie)
                    proxyport.UnloadDriver(umpdCookie, 0, FALSE);
                
                proxyport.Close();            
            }
    
            if (hInst)
                FreeLibrary(hInst);
        }
    }

    if (bResult)
        (*ppUMPD)->iRefCount++;        

    LEAVECRITICALSECTION(&semUMPD);

    if (bFreeDriverInfo2)
        LOCALFREE(pDriverInfo2);

    if (!bResult)
    {
        WARNING("LoadUserModePrinterDriverEx failed\n");
    }

    return bResult;
}


BOOL
LoadUserModePrinterDriver(
    HANDLE  hPrinter,
    LPWSTR  pwstrPrinterName,
    PUMPD  *ppUMPD,
    PRINTER_DEFAULTSW  *pdefaults
    )

/*++

Routine Description:

    Load user-mode printer driver DLL

Arguments:

    hPrinter - Handle to the current printer
    ppUMPD - Return a pointer to a UMPD structure

Return Value:

    TRUE if successful, FALSE if there is an error

    If the printer uses a user-mode printer driver, *ppUMPD will be a pointer
    to a UMPD structure. If the printer uses a kernel-mode printer driver,
    *ppUMPD will be NULL.

--*/

{
    PDRIVER_INFO_5W pDriverInfo5;
    BOOL    bResult;
    HMODULE hModule;
    WCHAR   moduleName[256];

    *ppUMPD = NULL;

    //
    // Get printer driver information
    //

    if ((pDriverInfo5 = (PDRIVER_INFO_5W)MyGetPrinterDriver(hPrinter, 5)) == NULL)
        return FALSE;

    if (pDriverInfo5->dwDriverAttributes & DRIVER_KERNELMODE)
    {
        LOCALFREE(pDriverInfo5);
        return TRUE;
    }

    bResult = LoadUserModePrinterDriverEx(pDriverInfo5, pwstrPrinterName, ppUMPD, pdefaults, hPrinter);
    
    LOCALFREE(pDriverInfo5);

    return bResult;
}

BOOL
UnloadUserModePrinterDriver(
    PUMPD   pUMPD,
    BOOL    bNotifySpooler,
    HANDLE  hPrinter
    )

/*++

Routine Description:

    Unload user-mode printer driver module and notify the spooler if necessary

Arguments:

    pUMPD - Pointer to user-mode printer driver information
    bNotifySpooler - Call into the spooler to notify driver unloading

Return Value:

    TRUE if the driver instance was freed (i.e ref cnt == 0)
    FALSE otherwise

--*/

{
    PUMPD  *ppStartUMPD;

    ASSERTGDI(VALID_UMPD(pUMPD), "Corrupted UMPD structure.\n");
    ASSERTGDI(pUMPD->iRefCount > 0, "Bad UMPD reference count.\n");

    if (gbWOW64)
    {
        PROXYPORT proxyport(pUMPD->pp);
    
        if (proxyport.bValid())
        {            
            proxyport.UnloadDriver(pUMPD->umpdCookie, hPrinter, bNotifySpooler);
        }
    }
    
    ENTERCRITICALSECTION(&semUMPD);
    
    if (pUMPD->iRefCount > 0)
    {
        pUMPD->iRefCount--;
    }
    
    if (pUMPD->iRefCount != 0 || pUMPD->pHandleList != NULL)
    {
        LEAVECRITICALSECTION(&semUMPD);
        return FALSE;
    }

    // Remove the UMPD node from umpd cache list
    
    for (ppStartUMPD = &gCachedUMPDList;
         *ppStartUMPD;
         ppStartUMPD = &((*ppStartUMPD)->pNext))
    {
        if (*ppStartUMPD == pUMPD)
        {
            *ppStartUMPD = pUMPD->pNext;
            break;
        }
    }
    
    LEAVECRITICALSECTION(&semUMPD);
    
    if (gbWOW64)
    {
        PROXYPORT proxyport(pUMPD->pp);

        if (proxyport.bValid())
            proxyport.Close();
    }
    else
    {
        PFN       pfn = pUMPD->apfn[INDEX_DrvDisableDriver];

        if (pfn)
        {
           pfn();
        }

        FreeLibrary(pUMPD->hInst);
    }

    if (bNotifySpooler && pUMPD->pDriverInfo2->pDriverPath)
    {
        (*fpSplDriverUnloadComplete)(pUMPD->pDriverInfo2->pDriverPath);
    }
    
    LOCALFREE(pUMPD->pDriverInfo2);
    LOCALFREE(pUMPD);

    return TRUE;
}

PUMPD
UMPDDrvEnableDriver(
    PWSTR           pDriverDllName,
    ULONG           iEngineVersion
    )

/*++

Routine Description:

    Client-side stub for DrvEnableDriver

Arguments:

    iDriverDllName - Name of the user-mode printer driver DLL
    iEngineVersion - Same parameter as that for DrvEnableDriver

Return Value:

    Pointer to the UMPD structure corresponding to the specified driver
    NULL if there is an error

Note:

    The pointer value returned by this function will be passed back from
    the kernel-mode side to the user-mode side for each subsequent DDI call.

--*/

{
    PUMPD           pUMPD;
    DRVENABLEDATA   ded;

    ENTERCRITICALSECTION(&semUMPD);

    //
    // Find the specified user-mode printer driver
    //

    pUMPD = FindUserModePrinterDriver(pDriverDllName, 0, FALSE);

    if(pUMPD == NULL)
    {
        WARNING("failed to find printer driver\n");
        return NULL;
    }

    if(pUMPD->hInst == NULL)
    {
        WARNING("driver library not loaded\n");
        return NULL;
    }

    ASSERTGDI(pUMPD != NULL, "Non-existent user-mode printer driver.\n");

    if (! (pUMPD->dwFlags & UMPDFLAG_DRVENABLEDRIVER_CALLED))
    {
        PFN_DrvEnableDriver pfn;

        //
        // If we haven't called DrvEnableDriver for this driver, do it now
        //

        if ((pfn = (PFN_DrvEnableDriver) GetProcAddress(pUMPD->hInst, "DrvEnableDriver")) &&
            pfn(iEngineVersion, sizeof(ded), &ded))
        {
            PDRVFN  pdrvfn;
            ULONG   count;

            //
            // Convert driver entrypoint function table to a more convenient format
            //

            for (pdrvfn = ded.pdrvfn, count = ded.c; count--; pdrvfn++)
            {
                if (pdrvfn->iFunc < INDEX_LAST)
                    pUMPD->apfn[pdrvfn->iFunc] = pdrvfn->pfn;
                else
                {
                    WARNING("Unrecognized DDI entrypoint index.\n");
                }
            }

            pUMPD->dwFlags |= UMPDFLAG_DRVENABLEDRIVER_CALLED;
        }
        else
        {
            WARNING("DrvEnableDriver failed.\n");
            pUMPD = NULL;
        }
    }

    LEAVECRITICALSECTION(&semUMPD);

    return pUMPD;
}

extern "C"
int DocumentEventEx(
    PUMPD       pUMPD,
    HANDLE      hPrinter,
    HDC         hdc,
    int         iEsc,
    ULONG       cjIn,
    PVOID       pvIn,
    ULONG       cjOut,
    PVOID       pvOut
)
{
    int iRet;

    if (WOW64PRINTING(pUMPD))
    {
        PROXYPORT  proxyport(pUMPD->pp);

        iRet = proxyport.DocumentEvent(pUMPD->umpdCookie, hPrinter,
                                       hdc, iEsc, cjIn, pvIn, cjOut, pvOut);
    }
    else
    {
        iRet = (*fpDocumentEvent)(hPrinter, hdc, iEsc, cjIn, pvIn, cjOut, pvOut);
    }

    return iRet;
}

extern "C"
DWORD StartDocPrinterWEx(
    PUMPD   pUMPD,
    HANDLE  hPrinter,
    DWORD   level,
    LPBYTE  pDocInfo)
 {
    if (WOW64PRINTING(pUMPD) && level == 1)
    {
        PROXYPORT proxyport(pUMPD->pp);
        
        return proxyport.StartDocPrinterW(pUMPD->umpdCookie,hPrinter, level, pDocInfo);
    }
    else
        return (*fpStartDocPrinterW)(hPrinter, level, pDocInfo);
}

extern "C"
BOOL  EndDocPrinterEx(PUMPD pUMPD, HANDLE hPrinter)
{
    if (WOW64PRINTING(pUMPD))
    {
        PROXYPORT proxyport(pUMPD->pp);

        return proxyport.EndDocPrinter(pUMPD->umpdCookie, hPrinter);
    }
    else
        return (*fpEndDocPrinter)(hPrinter);
}

extern "C"
BOOL  StartPagePrinterEx(PUMPD pUMPD, HANDLE hPrinter)
{
    if (WOW64PRINTING(pUMPD))
    {
        PROXYPORT proxyport(pUMPD->pp);

        return proxyport.StartPagePrinter(pUMPD->umpdCookie, hPrinter);
    }
    else
        return (*fpStartPagePrinter)(hPrinter); 
}

extern "C"
BOOL  EndPagePrinterEx(PUMPD pUMPD, HANDLE hPrinter)
{
    if (WOW64PRINTING(pUMPD))
    {
        PROXYPORT proxyport(pUMPD->pp);

        return proxyport.EndPagePrinter(pUMPD->umpdCookie, hPrinter);
    }
    else
        return (*fpEndPagePrinter)(hPrinter);
}

extern "C"
BOOL  AbortPrinterEx(PLDC pldc, BOOL bEMF)
{
    if (!bEMF && WOW64PRINTING(pldc->pUMPD))
    {
        PROXYPORT proxyport(pldc->pUMPD->pp);

        return proxyport.AbortPrinter(pldc->pUMPD->umpdCookie, pldc->hSpooler);
    }
    else
        return (*fpAbortPrinter)(pldc->hSpooler); 
}

extern "C"
BOOL  ResetPrinterWEx(PLDC pldc, PRINTER_DEFAULTSW *pPtrDef)
{
    BOOL bRet = TRUE;

    if (WOW64PRINTING(pldc->pUMPD))
    {
        if (!(pldc->fl & LDC_META_PRINT))
        {
            // either RAW printing or
            // ResetDC called before StartDoc, don't know
            // whether it is going RAW or EMF yet

            PROXYPORT proxyport(pldc->pUMPD->pp);
    
            bRet = proxyport.ResetPrinterW(pldc->pUMPD->umpdCookie, pldc->hSpooler, pPtrDef);

        }

        if (bRet && !(pldc->fl & LDC_PRINT_DIRECT))
        {
            // either EMF printing or
            // ResetDC called before StartDoc, we need to
            // call ResetPrinter on both 32-bit and 64-bit
            // printer handles.

            bRet = (*fpResetPrinterW)(pldc->hSpooler, pPtrDef);
        }

    }       
    else
    {
        bRet = (*fpResetPrinterW)(pldc->hSpooler, pPtrDef);
    }

    return bRet;
}

extern "C"
BOOL
QueryColorProfileEx(
    PLDC    pldc,
    PDEVMODEW pDevMode,
    ULONG   ulQueryMode,
    PVOID   pvProfileData,
    ULONG * pcjProfileSize,
    FLONG * pflProfileFlag)
{
    if (!(pldc->fl & LDC_META_PRINT) && WOW64PRINTING(pldc->pUMPD))
    {
        PROXYPORT proxyport(pldc->pUMPD->pp);

        return proxyport.QueryColorProfile(pldc->pUMPD->umpdCookie,
                                           pldc->hSpooler,
                                           pDevMode,
                                           ulQueryMode,
                                           pvProfileData,
                                           pcjProfileSize,
                                           pflProfileFlag);
    }
    else
        return (*fpQueryColorProfile)(pldc->hSpooler,
                                      pDevMode,
                                      ulQueryMode,
                                      pvProfileData,
                                      pcjProfileSize,
                                      pflProfileFlag);
}


PPORT_MESSAGE
PROXYPORT::InitMsg(
    PPROXYMSG       Msg,
    SERVERPTR       pvIn,
    ULONG           cjIn,
    SERVERPTR       pvOut,
    ULONG           cjOut
    )
{
    Msg->h.u1.s1.DataLength = (short) (sizeof(*Msg) - sizeof(Msg->h));
    Msg->h.u1.s1.TotalLength = (short) (sizeof(*Msg));

    Msg->h.u2.ZeroInit = 0;

    if(pvOut == 0) cjOut = 0;

    Msg->cjIn = cjIn;
    Msg->pvIn = pvIn;
    
    Msg->cjOut = cjOut;
    Msg->pvOut = pvOut;

    return( (PPORT_MESSAGE)Msg );
}

BOOL
PROXYPORT::CheckMsg(
    NTSTATUS        Status,
    PPROXYMSG       Msg,
    SERVERPTR       pvOut,
    ULONG           cjOut
    )
{
    ULONG       cbData = Msg->h.u1.s1.DataLength;

    if (cbData == (sizeof(*Msg) - sizeof(Msg->h)))
    {
        if(pvOut != Msg->pvOut)
        {
            return(FALSE);
        }

        if(cjOut != Msg->cjOut)
        {
            return(FALSE);
        }

        // do nothing

    }
    else
    {
        return(FALSE);
    }

    return( TRUE );
}

NTSTATUS
PROXYPORT::SendRequest(
    SERVERPTR       pvIn,
    ULONG           cjIn,
    SERVERPTR       pvOut,
    ULONG           cjOut
    )
{
    NTSTATUS        Status;
    PROXYMSG        Request;
    PROXYMSG        Reply;

    InitMsg( &Request, pvIn, cjIn, pvOut, cjOut );
    
    Status = NtRequestWaitReplyPort( pp->PortHandle,
                                     (PPORT_MESSAGE)&Request,
                                     (PPORT_MESSAGE)&Reply
                                   );

    if (!NT_SUCCESS( Status ))
    {
        return( Status );
    }

    if (Reply.h.u2.s2.Type == LPC_REPLY)
    {
        if (!CheckMsg( Status, &Reply, pvOut, cjOut ))
        {
            return(STATUS_UNSUCCESSFUL);
        }
    }
    else
    {
        return(STATUS_UNSUCCESSFUL);
    }

    return( Status );
}


#define ALIGN_UMPD_BUFFER(cj)   (((cj) + (sizeof(KERNEL_PVOID) -1)) & ~(sizeof(KERNEL_PVOID)-1))

SERVERPTR
PROXYPORT::HeapAlloc(ULONG inSize)
{
    KPBYTE ptr;

    if(pp->ClientMemoryAllocSize + ALIGN_UMPD_BUFFER(inSize) > pp->ClientMemorySize)
        return 0;

    ptr = pp->ClientMemoryBase + pp->ClientMemoryAllocSize + pp->ServerMemoryDelta;

    pp->ClientMemoryAllocSize += ALIGN_UMPD_BUFFER(inSize);

    return (SERVERPTR) ptr;
}


PROXYPORT::PROXYPORT(ULONGLONG inMaxSize)
{
    NTSTATUS                        Status;
    PORT_VIEW                       ClientView;
    ULONG                           MaxMessageLength;
    LARGE_INTEGER                   MaximumSize;
    UNICODE_STRING                  PortName;
    SECURITY_QUALITY_OF_SERVICE     DynamicQos;
    WCHAR                           awcPortName[MAX_PATH] = {0};
    DWORD                           CurrSessionId;
    DWORD                           CurrProcessId = GetCurrentProcessId();
    
    ProcessIdToSessionId(CurrProcessId,&CurrSessionId);
    wsprintfW(awcPortName, L"%s_%x", L"\\RPC Control\\UmpdProxy", CurrSessionId);
     
    DynamicQos.Length = 0;
    DynamicQos.ImpersonationLevel = SecurityImpersonation;
    DynamicQos.ContextTrackingMode = SECURITY_DYNAMIC_TRACKING;
    DynamicQos.EffectiveOnly = TRUE;

    
    if ((pp = (ProxyPort *) LOCALALLOC(sizeof(ProxyPort))) == NULL ||
        !NT_SUCCESS((NTSTATUS)INITIALIZECRITICALSECTION(&pp->semPort)))
    {
        WARNING("PROXYPORT::PROXYPORT mem alloc OR critical section init failed\n");
        
        if (pp)
            LOCALFREE(pp);
        
        pp = NULL;
        return;
    }

    pp->ClientMemoryBase = 0;
    pp->ClientMemorySize = 0;
    pp->ClientMemoryAllocSize = 0;
    pp->PortHandle = NULL;
    pp->ServerMemoryBase = 0;
    pp->ServerMemoryDelta = 0;

    Status = STATUS_SUCCESS;

    RtlInitUnicodeString( &PortName, awcPortName );

    MaximumSize.QuadPart = inMaxSize;

    ZeroMemory(&ClientView.SectionHandle, sizeof(ClientView.SectionHandle));

    Status = NtCreateSection( (PHANDLE)&ClientView.SectionHandle,
                              SECTION_MAP_READ | SECTION_MAP_WRITE,
                              NULL,
                              &MaximumSize,
                              PAGE_READWRITE,
                              SEC_COMMIT,
                              NULL
                            );

    if (NT_SUCCESS( Status ))
    {
        ClientView.Length = sizeof( ClientView );
        ClientView.SectionOffset = 0;
        ClientView.ViewSize = (LPC_SIZE_T) inMaxSize;
        ClientView.ViewBase = 0;
        ClientView.ViewRemoteBase = 0;

        if (BLOADSPOOLER &&
            (*fpLoadSplWow64)(NULL) == ERROR_SUCCESS)
        {
            Status = NtConnectPort( &pp->PortHandle,
                                    &PortName,
                                    &DynamicQos,
                                    &ClientView,
                                    NULL,
                                    (PULONG)&MaxMessageLength,
                                    NULL,
                                    0
                                  );

            if (NT_SUCCESS( Status ))
            {
                pp->SectionHandle = (HANDLE)ClientView.SectionHandle;
                pp->ClientMemoryBase = (KPBYTE)ClientView.ViewBase;
                pp->ClientMemorySize = (SIZE_T)inMaxSize;
                pp->ServerMemoryBase = (KPBYTE)ClientView.ViewRemoteBase;
                pp->ServerMemoryDelta = pp->ServerMemoryBase - 
                                        pp->ClientMemoryBase;

                NtRegisterThreadTerminatePort(pp->PortHandle);
            }
            else
            {
                WARNING("PROXYPORT::PROXYPORT: NtConnectPort failed\n");
            }
        }
        else
        {
            Status = STATUS_UNSUCCESSFUL;
            WARNING("PROXYPORT::PROXYPORT failed to load spooler or splwow64\n");
        }
    }
    else
    {
        WARNING("PROXYPORT::PROXYPORT: failed to create section\n");
    }

    if(!NT_SUCCESS( Status ))
    {
        if ((HANDLE)ClientView.SectionHandle)
        {
            NtClose((HANDLE)ClientView.SectionHandle);
        }
        
        DELETECRITICALSECTION(&pp->semPort);
        LOCALFREE(pp);
        
        pp = NULL;
    }
    else
    {
        // grab port access

        ENTERCRITICALSECTION(&pp->semPort);
    }
}

void
PROXYPORT::Close()
{
    if (pp->SectionHandle)
    {
        if (!CloseHandle(pp->SectionHandle))
        {
            WARNING("PROXYPORT::Close failed to close the section handle\n");
        }
    }

    if (pp->PortHandle != NULL)
    {
        if (!CloseHandle( pp->PortHandle ))
        {
            WARNING("PROXYPORT::Close failed to close the port handle\n");
        }
    }

    LEAVECRITICALSECTION(&pp->semPort);
    DELETECRITICALSECTION(&pp->semPort);
    LOCALFREE(pp);

    pp = NULL;
}

void vUMPDWow64Shutdown()
{
    PUMPD pUMPD = gCachedUMPDList;

    while(pUMPD)
    {
        if (pUMPD->pp)
        {
            PROXYPORT   proxyPort(pUMPD->pp);

            proxyPort.Shutdown();
        }
        pUMPD = pUMPD->pNext;
    }
}

BOOL
PROXYPORT::ThunkMemBlock(
    KPBYTE *            ptr,
    ULONG               size)
{
    BOOL  bRet = TRUE;

    if (*ptr)
    {
        SERVERPTR           sp = HeapAlloc(size);
        CLIENTPTR           cp = ServerToClientPtr(sp);
    
        if (cp)
        {
            RtlCopyMemory((PVOID)cp, (PVOID)*ptr, size);
            *ptr = sp;
        }
        else
            bRet = FALSE;
    }

    return bRet;
}

BOOL
PROXYPORT::ThunkStr(LPWSTR * ioLpstr)
{
    BOOL bRet = TRUE;

    if(*ioLpstr != NULL)
    {
        bRet = ThunkMemBlock((KPBYTE *) ioLpstr, (wcslen(*ioLpstr) + 1) * sizeof(WCHAR));
    }
    
    return bRet;
}

KERNEL_PVOID
PROXYPORT::LoadDriver(
    PDRIVER_INFO_5W     pDriverInfo,
    LPWSTR              pwstrPrinterName,
    PRINTER_DEFAULTSW*  pdefaults,
    HANDLE              hPrinter32
    )
{
    NTSTATUS            Status = STATUS_SUCCESS;
    SERVERPTR           spInput;
    SERVERPTR           spOutput;
    LOADDRIVERINPUT*    pInput;
    KERNEL_PVOID        umpdCookie = NULL;

    HeapInit();

    if (!(spInput = HeapAlloc(sizeof(LOADDRIVERINPUT))) ||
        !(spOutput = HeapAlloc(sizeof(KERNEL_PVOID))))
        return NULL;

    pInput = (LOADDRIVERINPUT *) ServerToClientPtr(spInput);

    pInput->driverInfo.cVersion = pDriverInfo->cVersion; 
    pInput->driverInfo.pName = (KLPWSTR)pDriverInfo->pName;
    pInput->driverInfo.pEnvironment = (KLPWSTR)pDriverInfo->pEnvironment;
    pInput->driverInfo.pDriverPath = (KLPWSTR)pDriverInfo->pDriverPath;
    pInput->driverInfo.pDataFile = (KLPWSTR)pDriverInfo->pDataFile;
    pInput->driverInfo.pConfigFile = (KLPWSTR)pDriverInfo->pConfigFile;
    pInput->driverInfo.dwDriverAttributes = pDriverInfo->dwDriverAttributes;
    pInput->driverInfo.dwConfigVersion = pDriverInfo->dwConfigVersion;
    pInput->driverInfo.dwDriverVersion = pDriverInfo->dwDriverVersion;
    pInput->clientPid = GetCurrentProcessId();
    pInput->hPrinter32 = HandleToUlong(hPrinter32);

    pInput->pPrinterName = (KLPWSTR)pwstrPrinterName;

    pInput->defaults.pDatatype = (KLPWSTR)pdefaults->pDatatype;
    pInput->defaults.pDevMode = (KPBYTE)pdefaults->pDevMode;
    pInput->defaults.DesiredAccess = pdefaults->DesiredAccess;

    if (!ThunkStr((LPWSTR *)&pInput->driverInfo.pName)           ||
        !ThunkStr((LPWSTR *)&pInput->driverInfo.pEnvironment)    ||
        !ThunkStr((LPWSTR *)&pInput->driverInfo.pDriverPath)     ||
        !ThunkStr((LPWSTR *)&pInput->driverInfo.pDataFile)       ||
        !ThunkStr((LPWSTR *)&pInput->driverInfo.pConfigFile)     ||
        !ThunkStr((LPWSTR *)&pInput->pPrinterName)               ||
        !ThunkStr((LPWSTR *)&pInput->defaults.pDatatype)         ||
        !ThunkMemBlock(&pInput->defaults.pDevMode, sizeof(DEVMODEW))
       )
       return NULL;

    pInput->umpdthdr.umthdr.ulType = INDEX_LoadUMPrinterDrv;

    Status = SendRequest(spInput, sizeof(LOADDRIVERINPUT),
                                   spOutput, sizeof(KERNEL_PVOID));

    if (NT_SUCCESS( Status ))
    {
        umpdCookie = *((KERNEL_PVOID *) ServerToClientPtr(spOutput));
    }

    return umpdCookie;
}

void
PROXYPORT::UnloadDriver(
    KERNEL_PVOID    umpdCookie,
    HANDLE          hPrinter32,
    BOOL            bNotifySpooler
    )
{
    NTSTATUS                Status = STATUS_SUCCESS;
    SERVERPTR               spInput;
    UNLOADDRIVERINPUT *     pInput;

    HeapInit();

    if (spInput = HeapAlloc(sizeof(UNLOADDRIVERINPUT)))
    {
        pInput = (UNLOADDRIVERINPUT *) ServerToClientPtr(spInput);
    
        pInput->umpdCookie = umpdCookie;
        pInput->clientPid = GetCurrentProcessId();
        pInput->hPrinter32 = HandleToUlong(hPrinter32);
        pInput->bNotifySpooler = bNotifySpooler;
    
        pInput->umpdthdr.umthdr.ulType = INDEX_UnloadUMPrinterDrv;
    
        Status = SendRequest(spInput, sizeof(spInput), 0, 0);
    }
}

int
PROXYPORT::DocumentEvent(
    KERNEL_PVOID    umpdCookie,
    HANDLE          hPrinter32,
    HDC             hdc,
    INT             iEsc,
    ULONG           cjIn,
    PVOID           pvIn,
    ULONG           cjOut,
    PVOID           pvOut
)
{
    NTSTATUS                Status = STATUS_SUCCESS;
    SERVERPTR               spInput;
    SERVERPTR               spOutput;
    DOCUMENTEVENTINPUT*     pInput;
    CLIENTPTR               cppvIn = NULL;
    INT                     iRet = DOCUMENTEVENT_FAILURE;
    ULONG                   cjAlloc = 0;
    DEVMODEW                *pdmCopy = NULL;

    HeapInit();

    if (!(spInput = HeapAlloc(sizeof(DOCUMENTEVENTINPUT)))                ||
        !(pInput = (DOCUMENTEVENTINPUT *) ServerToClientPtr(spInput))     ||
        !(spOutput = HeapAlloc(sizeof(int))))
    {
        return DOCUMENTEVENT_FAILURE;
    }

    pInput->umpdthdr.umthdr.ulType = INDEX_DocumentEvent;
    pInput->umpdthdr.umthdr.cjSize = sizeof(*pInput);
    pInput->umpdCookie = umpdCookie;
    pInput->clientPid = GetCurrentProcessId();
    pInput->hPrinter32 = HandleToUlong(hPrinter32);
    pInput->hdc = (KHDC)hdc;
    pInput->iEsc = iEsc;
    pInput->cjIn = cjIn;
    pInput->pvIn = NULL;
    pInput->cjOut = cjOut;
    pInput->pvOut = NULL;
    pInput->pdmCopy = NULL;
    
    // thunk input data
    
    if (cjIn && pvIn)
    {
        if (iEsc == DOCUMENTEVENT_CREATEDCPRE)
        {
            cjAlloc = sizeof(DOCEVENT_CREATEDCPRE_UMPD);
        }
        else if (iEsc == DOCUMENTEVENT_CREATEDCPOST ||
                 iEsc == DOCUMENTEVENT_RESETDCPRE   ||
                 iEsc == DOCUMENTEVENT_RESETDCPOST  ||
                 iEsc == DOCUMENTEVENT_STARTDOCPRE)
        {
            cjAlloc = sizeof(KPBYTE);
        }
        else if (iEsc == DOCUMENTEVENT_ESCAPE)
        {
            cjAlloc = sizeof(DOCEVENT_ESCAPE_UMPD);
        }

        // allocate heap

        if (cjAlloc)
        {
            if (!(pInput->pvIn = HeapAlloc(cjAlloc)))
            {
                return DOCUMENTEVENT_FAILURE;
            }

            pInput->cjIn = cjAlloc;
            cppvIn = ServerToClientPtr(pInput->pvIn);
        }

        switch (iEsc)
        {
        case DOCUMENTEVENT_CREATEDCPRE:
            {
                DOCEVENT_CREATEDCPRE_UMPD  *pDocEvent = (DOCEVENT_CREATEDCPRE_UMPD*)cppvIn;
                DOCEVENT_CREATEDCPRE       *pDocEventIn = (DOCEVENT_CREATEDCPRE*)pvIn;
                
                pDocEvent->pszDriver = (KPBYTE)0;
                pDocEvent->pszDevice = (KPBYTE)pDocEventIn->pszDevice;
                pDocEvent->pdm = (KPBYTE)pDocEventIn->pdm;
                pDocEvent->bIC = pDocEventIn->bIC;
    
                if (!ThunkStr((LPWSTR*)&pDocEvent->pszDevice)    ||
                    !ThunkMemBlock(&pDocEvent->pdm, sizeof(DEVMODEW)))
                {
                    return DOCUMENTEVENT_FAILURE;
                }
            }
            break;

        case DOCUMENTEVENT_RESETDCPRE:
            {
                *((KPBYTE*)cppvIn) = (KPBYTE)(*((DEVMODEW**)pvIn));
                
                if (!ThunkMemBlock((KPBYTE*)cppvIn, sizeof(DEVMODEW)))
                    return DOCUMENTEVENT_FAILURE;                
            }
            break;

        case DOCUMENTEVENT_STARTDOCPRE:
            {
                SERVERPTR       spTemp;
                DOCINFOW_UMPD   *pDocInfo;
                DOCINFOW        *pDocInfoIn = *((DOCINFOW**)pvIn);

                if (!(spTemp = HeapAlloc(sizeof(DOCINFOW_UMPD))))
                    return DOCUMENTEVENT_FAILURE;
                
                *((KPBYTE*)cppvIn) = spTemp;
                pDocInfo = (DOCINFOW_UMPD*)ServerToClientPtr(spTemp);

                pDocInfo->cbSize        = pDocInfoIn->cbSize;
                pDocInfo->lpszDocName   = (KLPWSTR)pDocInfoIn->lpszDocName;
                pDocInfo->lpszOutput    = (KLPWSTR)pDocInfoIn->lpszOutput;
                pDocInfo->lpszDatatype  = (KLPWSTR)pDocInfoIn->lpszDatatype;
                pDocInfo->fwType        = pDocInfoIn->fwType;
    
                if (!ThunkStr((LPWSTR*)&pDocInfo->lpszDocName)    ||
                    !ThunkStr((LPWSTR*)&pDocInfo->lpszOutput)     ||
                    !ThunkStr((LPWSTR*)&pDocInfo->lpszDatatype))
                {
                    return DOCUMENTEVENT_FAILURE;                                
                }
            }
            break;
        
        case DOCUMENTEVENT_CREATEDCPOST:
        case DOCUMENTEVENT_RESETDCPOST:
            {
                if (*((PDEVMODEW *)pvIn))
                {
                    KPBYTE *ppdmDrv = (KPBYTE*)(*((PBYTE*)pvIn) + sizeof(DEVMODEW));

                    *((KPBYTE*)cppvIn) = *ppdmDrv;
                    
                    LOCALFREE(*(PBYTE*)pvIn);
                }
                else 
                {
                    *((KPBYTE*)cppvIn) = NULL;
                }

            }
            break;

        case DOCUMENTEVENT_STARTDOCPOST:
            {
                pInput->pvIn = (KPBYTE)pvIn;
                
                if (!ThunkMemBlock(&pInput->pvIn, sizeof(LONG)))
                    return DOCUMENTEVENT_FAILURE;
            }
            break;

        case DOCUMENTEVENT_ESCAPE:
            {
                DOCEVENT_ESCAPE_UMPD    *pEscape = (DOCEVENT_ESCAPE_UMPD*)cppvIn;
                DOCEVENT_ESCAPE         *pEscapeIn = (DOCEVENT_ESCAPE*)pvIn;

                pEscape->iEscape = pEscapeIn->iEscape;
                pEscape->cjInput = pEscapeIn->cjInput;
                pEscape->pvInData = (KPBYTE)pEscapeIn->pvInData;
    
                if (!ThunkMemBlock(&pEscape->pvInData, (ULONG)pEscapeIn->cjInput))
                    return DOCUMENTEVENT_FAILURE;
            }
            break;

        default:
            return DOCUMENTEVENT_FAILURE;
        }
    }

    if (cjOut && pvOut)
    {
        if (iEsc == DOCUMENTEVENT_CREATEDCPRE || iEsc == DOCUMENTEVENT_RESETDCPRE)
        {
            if (!(pInput->pvOut = HeapAlloc(sizeof(KPBYTE))) ||
                !(pInput->pdmCopy = HeapAlloc(sizeof(DEVMODEW))) ||
                !(pdmCopy = (DEVMODEW*)LOCALALLOC(sizeof(DEVMODEW) + sizeof(KPBYTE))))
            {
                return DOCUMENTEVENT_FAILURE;
            }

            *((KPBYTE*)ServerToClientPtr(pInput->pvOut)) = 0;
            pInput->cjOut = sizeof(KPBYTE);
        }
        else if (iEsc == DOCUMENTEVENT_ESCAPE)
        {
            if (!(pInput->pvOut = HeapAlloc(cjOut)))
                return DOCUMENTEVENT_FAILURE;
        }
    }
        
    Status = SendRequest(spInput, sizeof(DOCUMENTEVENTINPUT), spOutput, sizeof(int));

    if (NT_SUCCESS( Status ))
    {
        iRet = *((int *) ServerToClientPtr(spOutput));
        
        if (iRet != DOCUMENTEVENT_FAILURE)
        {
            if (iEsc == DOCUMENTEVENT_CREATEDCPRE || iEsc == DOCUMENTEVENT_RESETDCPRE)
            {
                PDEVMODEW   *ppvOut = (PDEVMODEW*)pvOut;
                KPBYTE      kpdm = *((KPBYTE*)ServerToClientPtr(pInput->pvOut));

                ASSERTGDI(pvOut, "ProxyPort::DocumentEvent pvOut NULL\n");
                
                *ppvOut = kpdm ? pdmCopy : NULL;

                if (kpdm)
                {
                    RtlCopyMemory(pdmCopy, (PVOID)ServerToClientPtr(pInput->pdmCopy), sizeof(DEVMODEW));
                    
                    KPBYTE      *ppdmDrv = (KPBYTE*)((PBYTE)pdmCopy + sizeof(DEVMODEW));
                    
                    *ppdmDrv = kpdm;                     
                }
                else
                {
                    LOCALFREE(pdmCopy);
                }
            }
            else if (iEsc == DOCUMENTEVENT_ESCAPE)
            {
                if (cjOut && pvOut)
                    RtlCopyMemory(pvOut, (PVOID)ServerToClientPtr(pInput->pvOut), cjOut);
            }
        }
        else
        {
            WARNING("DocumentEvent failed \n");
        }
    }

    if (iRet == DOCUMENTEVENT_FAILURE && pdmCopy)
    {
        LOCALFREE(pdmCopy);
    }

    return iRet;
}


DWORD
PROXYPORT::StartDocPrinterW(
    KERNEL_PVOID    umpdCookie,
    HANDLE          hPrinter32,
    DWORD           level,
    LPBYTE          pDocInfo
    )
{
    NTSTATUS                Status = STATUS_SUCCESS;
    SERVERPTR               spInput;
    SERVERPTR               spOutput;
    STARTDOCPRINTERWINPUT*  pInput;
    CLIENTPTR               cppDocInfo;

    HeapInit();

    if (!(spInput = HeapAlloc(sizeof(STARTDOCPRINTERWINPUT))) ||
        !(spOutput = HeapAlloc(sizeof(DWORD))))
        return 0;

    pInput = (STARTDOCPRINTERWINPUT *) ServerToClientPtr(spInput);

    pInput->umpdthdr.umthdr.ulType = INDEX_StartDocPrinterW;
    pInput->umpdthdr.umthdr.cjSize = sizeof(*pInput);
    pInput->umpdCookie = umpdCookie;
    pInput->clientPid = GetCurrentProcessId();
    pInput->hPrinter32 = HandleToUlong(hPrinter32);
    pInput->level = level;
    pInput->lastError = 0;
    pInput->docInfo.pDocName = (KLPWSTR)((DOC_INFO_1W*)pDocInfo)->pDocName;
    pInput->docInfo.pOutputFile = (KLPWSTR)((DOC_INFO_1W*)pDocInfo)->pOutputFile;
    pInput->docInfo.pDatatype = (KLPWSTR)((DOC_INFO_1W*)pDocInfo)->pDatatype;
    
    // GDI only uses level 1 and level 3
    if (level == 3)
        pInput->docInfo.dwFlags = ((DOC_INFO_3W*)pDocInfo)->dwFlags;
    else
        pInput->docInfo.dwFlags = 0;
        
    if (!ThunkStr((LPWSTR *)&pInput->docInfo.pDocName)      ||
        !ThunkStr((LPWSTR *)&pInput->docInfo.pOutputFile)   ||
        !ThunkStr((LPWSTR *)&pInput->docInfo.pDatatype))
        return 0;
    
    Status = SendRequest(spInput, sizeof(STARTDOCPRINTERWINPUT), spOutput, sizeof(DWORD));

    if (!NT_SUCCESS( Status ))
         return 0;
    else
    {
        if (pInput->lastError)
            GdiSetLastError(pInput->lastError);
        return (*((DWORD *) ServerToClientPtr(spOutput)));
    }
}


BOOL
PROXYPORT::StartPagePrinter(KERNEL_PVOID umpdCookie, HANDLE hPrinter32)
{
    NTSTATUS                Status = STATUS_SUCCESS;
    SERVERPTR               spInput;
    SERVERPTR               spOutput;
    UMPDSIMPLEINPUT*        pInput;

    HeapInit();

    if (!(spInput = HeapAlloc(sizeof(UMPDSIMPLEINPUT)))   ||
        !(spOutput = HeapAlloc(sizeof(BOOL))))
        return FALSE;

    pInput = (UMPDSIMPLEINPUT *) ServerToClientPtr(spInput);

    pInput->umpdthdr.umthdr.ulType = INDEX_StartPagePrinter;
    pInput->umpdthdr.umthdr.cjSize = sizeof(UMPDSIMPLEINPUT);
    pInput->umpdCookie = umpdCookie;
    pInput->clientPid = GetCurrentProcessId();
    pInput->hPrinter32 = HandleToUlong(hPrinter32);

    Status = SendRequest(spInput, sizeof(UMPDSIMPLEINPUT), spOutput, sizeof(BOOL));

    if (!NT_SUCCESS( Status ))
         return FALSE;
    
    return (*((BOOL*)ServerToClientPtr(spOutput)));        
}

BOOL
PROXYPORT::EndPagePrinter(KERNEL_PVOID umpdCookie, HANDLE hPrinter32)
{
    NTSTATUS                Status = STATUS_SUCCESS;
    SERVERPTR               spInput;
    SERVERPTR               spOutput;
    UMPDSIMPLEINPUT*        pInput;

    HeapInit();

    if (!(spInput = HeapAlloc(sizeof(UMPDSIMPLEINPUT)))   ||
        !(spOutput = HeapAlloc(sizeof(BOOL))))
        return FALSE;

    pInput = (UMPDSIMPLEINPUT *) ServerToClientPtr(spInput);

    pInput->umpdthdr.umthdr.ulType = INDEX_EndPagePrinter;
    pInput->umpdthdr.umthdr.cjSize = sizeof(UMPDSIMPLEINPUT);
    pInput->umpdCookie = umpdCookie;
    pInput->clientPid = GetCurrentProcessId();
    pInput->hPrinter32 = HandleToUlong(hPrinter32);

    Status = SendRequest(spInput, sizeof(UMPDSIMPLEINPUT), spOutput, sizeof(BOOL));

    if (!NT_SUCCESS( Status ))
         return FALSE;
    
    return (*((BOOL*)ServerToClientPtr(spOutput)));        
}

BOOL
PROXYPORT::EndDocPrinter(KERNEL_PVOID umpdCookie, HANDLE hPrinter32)
{
    NTSTATUS                Status = STATUS_SUCCESS;
    SERVERPTR               spInput;
    SERVERPTR               spOutput;
    UMPDSIMPLEINPUT*        pInput;

    HeapInit();

    if (!(spInput = HeapAlloc(sizeof(UMPDSIMPLEINPUT)))   ||
        !(spOutput = HeapAlloc(sizeof(BOOL))))
        return FALSE;

    pInput = (UMPDSIMPLEINPUT *) ServerToClientPtr(spInput);

    pInput->umpdthdr.umthdr.ulType = INDEX_EndDocPrinter;
    pInput->umpdthdr.umthdr.cjSize = sizeof(UMPDSIMPLEINPUT);
    pInput->umpdCookie = umpdCookie;
    pInput->clientPid = GetCurrentProcessId();
    pInput->hPrinter32 = HandleToUlong(hPrinter32);

    Status = SendRequest(spInput, sizeof(UMPDSIMPLEINPUT), spOutput, sizeof(BOOL));

    if (!NT_SUCCESS( Status ))
         return FALSE;
    
    return (*((BOOL*)ServerToClientPtr(spOutput)));        
}


BOOL
PROXYPORT::AbortPrinter(KERNEL_PVOID umpdCookie, HANDLE hPrinter32)
{
    NTSTATUS                Status = STATUS_SUCCESS;
    SERVERPTR               spInput;
    SERVERPTR               spOutput;
    UMPDSIMPLEINPUT*        pInput;

    HeapInit();

    if (!(spInput = HeapAlloc(sizeof(UMPDSIMPLEINPUT)))   ||
        !(spOutput = HeapAlloc(sizeof(BOOL))))
        return FALSE;

    pInput = (UMPDSIMPLEINPUT *) ServerToClientPtr(spInput);

    pInput->umpdthdr.umthdr.ulType = INDEX_AbortPrinter;
    pInput->umpdthdr.umthdr.cjSize = sizeof(UMPDSIMPLEINPUT);
    pInput->umpdCookie = umpdCookie;
    pInput->clientPid = GetCurrentProcessId();
    pInput->hPrinter32 = HandleToUlong(hPrinter32);

    Status = SendRequest(spInput, sizeof(UMPDSIMPLEINPUT), spOutput, sizeof(BOOL));

    if (!NT_SUCCESS( Status ))
         return FALSE;
    
    return (*((BOOL*)ServerToClientPtr(spOutput)));        
}

BOOL
PROXYPORT::ResetPrinterW(KERNEL_PVOID umpdCookie, HANDLE hPrinter32, PRINTER_DEFAULTSW *pPtrDef)
{
    NTSTATUS                Status = STATUS_SUCCESS;
    SERVERPTR               spInput;
    SERVERPTR               spOutput;
    RESETPRINTERWINPUT*     pInput;

    HeapInit();

    if (!(spInput = HeapAlloc(sizeof(RESETPRINTERWINPUT)))    ||
        !(spOutput = HeapAlloc(sizeof(BOOL))))
        return FALSE;

    pInput = (RESETPRINTERWINPUT *) ServerToClientPtr(spInput);

    pInput->umpdthdr.umthdr.ulType = INDEX_ResetPrinterW;
    pInput->umpdthdr.umthdr.cjSize = sizeof(RESETPRINTERWINPUT);
    pInput->umpdCookie = umpdCookie;
    pInput->clientPid = GetCurrentProcessId();
    pInput->hPrinter32 = HandleToUlong(hPrinter32);
    
    pInput->ptrDef.pDatatype = (KLPWSTR)pPtrDef->pDatatype;
    pInput->ptrDef.pDevMode = (KPBYTE)pPtrDef->pDevMode;
    pInput->ptrDef.DesiredAccess = pPtrDef->DesiredAccess;

    if (!ThunkStr((LPWSTR *)&pInput->ptrDef.pDatatype)  ||
        !ThunkMemBlock(&pInput->ptrDef.pDevMode, sizeof(DEVMODEW)))
        return FALSE;

    Status = SendRequest(spInput, sizeof(RESETPRINTERWINPUT), spOutput, sizeof(BOOL));

    if (!NT_SUCCESS( Status ))
         return FALSE;
    
    return (*((BOOL*)ServerToClientPtr(spOutput)));     
}

BOOL
PROXYPORT::QueryColorProfile(
    KERNEL_PVOID umpdCookie,
    HANDLE hPrinter32,
    PDEVMODEW pDevMode,
    ULONG ulQueryMode,
    PVOID pvProfileData,
    ULONG* pcjProfileSize,
    FLONG* pflProfileFlag
)
{   
    NTSTATUS                Status = STATUS_SUCCESS;
    SERVERPTR               spInput;
    SERVERPTR               spOutput;
    QUERYCOLORPROFILEINPUT*     pInput;

    HeapInit();

    if (!(spInput = HeapAlloc(sizeof(QUERYCOLORPROFILEINPUT)))    ||
        !(spOutput = HeapAlloc(sizeof(BOOL))))
        return -1;

    pInput = (QUERYCOLORPROFILEINPUT*) ServerToClientPtr(spInput);

    pInput->umpdthdr.umthdr.ulType = INDEX_QueryColorProfile;
    pInput->umpdthdr.umthdr.cjSize = sizeof(QUERYCOLORPROFILEINPUT);
    pInput->umpdCookie = umpdCookie;
    pInput->clientPid = GetCurrentProcessId();
    pInput->hPrinter32 = HandleToUlong(hPrinter32);
        
    pInput->pDevMode = pDevMode;
    pInput->ulQueryMode = ulQueryMode;
    pInput->cjProfileSize = *pcjProfileSize;
    pInput->flProfileFlag = *pflProfileFlag;
    pInput->lastError = 0;

    if (!(pInput->pvProfileData = HeapAlloc(*pcjProfileSize)) ||
        !ThunkMemBlock((KPBYTE*)&pInput->pDevMode, sizeof(DEVMODEW)))
        return -1;

    Status = SendRequest(spInput, sizeof(QUERYCOLORPROFILEINPUT), spOutput, sizeof(BOOL));

    if (!NT_SUCCESS( Status ))
         return -1;
    else
    {
        if (pInput->lastError)
            GdiSetLastError(pInput->lastError);
        return (*((BOOL*)ServerToClientPtr(spOutput)));     
    }    
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\client\umpdeng.c ===
/*++

Copyright (c) 1997-1999  Microsoft Corporation

Module Name:

    umpdeng.c

Abstract:

    User-mode printer driver stubs for Eng callback functions

Environment:

    Windows NT 5.0

Revision History:

    07/23/97 -lingyunw-
        Created it.

   10/28/97 -davidx-
        Combine umpdeng.c and ddiglue.c into a single file.

   10/28/97 -lingyunw-
        Move straight Eng to NtGdiEng calls etc to gdi32.def.

--*/

#include "precomp.h"
#pragma hdrstop
#include "winddi.h"

#if !defined(_GDIPLUS_)

//
// Functions to get information about driver DLLs
//
// anyway, before we return back from DrvEnablePDEV, our
// pdev->dhpdev points to pUMPD, only after returning, we
// ppdev->dhpdev points to pUMdhpdev
//

LPWSTR
EngGetPrinterDataFileName(
    HDEV hdev
    )

{
    PUMPD pUMPD;

    if ((pUMPD = (PUMPD) NtGdiGetDhpdev(hdev)) == NULL)
        return NULL;

    if (pUMPD->dwSignature != UMPD_SIGNATURE)
        pUMPD = ((PUMDHPDEV) pUMPD)->pUMPD;

    return pUMPD->pDriverInfo2->pDataFile;
}


LPWSTR
EngGetDriverName(
    HDEV hdev
    )
{
    PUMPD pUMPD;

    if ((pUMPD = (PUMPD) NtGdiGetDhpdev(hdev)) == NULL)
        return NULL;

    if (pUMPD->dwSignature != UMPD_SIGNATURE)
        pUMPD = ((PUMDHPDEV) pUMPD)->pUMPD;

    return pUMPD->pDriverInfo2->pDriverPath;
}

PULONG APIENTRY XLATEOBJ_piVector(
    IN XLATEOBJ  *pxlo
   )
{
    return ((ULONG *)pxlo->pulXlate);
}

//
// Simulate kernel-mode file mapping functions
//

HANDLE
EngLoadModule(
    LPWSTR pwsz
    )

{
    return LoadLibraryExW(pwsz, NULL, LOAD_LIBRARY_AS_DATAFILE);
}


PVOID
EngFindResource(
    HANDLE h,
    INT    iName,
    INT    iType,
    PULONG pulSize
    )

{
    HRSRC   hrsrc;
    HGLOBAL hmem;
    PVOID   p = NULL;
    DWORD   size = 0;

    hrsrc = FindResourceW(h, MAKEINTRESOURCEW(iName), MAKEINTRESOURCEW(iType));

    if (hrsrc != NULL &&
        (size = SizeofResource(h, hrsrc)) != 0 &&
        (hmem = LoadResource(h, hrsrc)) != NULL)
    {
        p = LockResource(hmem);
    }

    *pulSize = size;
    return p;
}

VOID
EngFreeModule(
    HANDLE h
    )

{
    FreeLibrary(h);
}


//
// Unicode <=> MultiByte conversion functions
//

VOID
EngMultiByteToUnicodeN(
    PWSTR UnicodeString,
    ULONG MaxBytesInUnicodeString,
    PULONG BytesInUnicodeString,
    PCHAR MultiByteString,
    ULONG BytesInMultiByteString
    )

{

    RtlMultiByteToUnicodeN(UnicodeString,
                           MaxBytesInUnicodeString,
                           BytesInUnicodeString,
                           MultiByteString,
                           BytesInMultiByteString);
}

VOID
EngUnicodeToMultiByteN(
    PCHAR MultiByteString,
    ULONG MaxBytesInMultiByteString,
    PULONG BytesInMultiByteString,
    PWSTR UnicodeString,
    ULONG BytesInUnicodeString
    )

{
    RtlUnicodeToMultiByteN(MultiByteString,
                           MaxBytesInMultiByteString,
                           BytesInMultiByteString,
                           UnicodeString,
                           BytesInUnicodeString);
}


INT
EngMultiByteToWideChar(
    UINT CodePage,
    LPWSTR WideCharString,
    INT BytesInWideCharString,
    LPSTR MultiByteString,
    INT BytesInMultiByteString
    )

{
    return MultiByteToWideChar(CodePage,
                               0,
                               MultiByteString,
                               BytesInMultiByteString,
                               WideCharString,
                               BytesInWideCharString / sizeof(WCHAR));
}


INT
EngWideCharToMultiByte(
    UINT CodePage,
    LPWSTR WideCharString,
    INT BytesInWideCharString,
    LPSTR MultiByteString,
    INT BytesInMultiByteString
    )

{
    return WideCharToMultiByte(CodePage,
                               0,
                               WideCharString,
                               BytesInWideCharString / sizeof(WCHAR),
                               MultiByteString,
                               BytesInMultiByteString,
                               NULL,
                               NULL);
}


VOID
EngGetCurrentCodePage(
    PUSHORT OemCodePage,
    PUSHORT AnsiCodePage
    )

{
    *AnsiCodePage = (USHORT) GetACP();
    *OemCodePage =  (USHORT) GetOEMCP();
}


//
// Copy FD_GLYPHSET information
//
// IMPORTANT!!
//  We assume FD_GLYPHSET information is stored in one contiguous block
//  of memory and FD_GLYPHSET.cjThis field is the size of the entire block.
//  HGLYPH arrays in each WCRUN are part of the block, placed just after
//  FD_GLYPHSET structure itself.
//

BOOL
CopyFD_GLYPHSET(
    FD_GLYPHSET *dst,
    FD_GLYPHSET *src,
    ULONG       cjSize
    )

{
    ULONG   index, offset;

    RtlCopyMemory(dst, src, cjSize);

    //
    // Patch up memory pointers in each WCRUN structure
    //

    for (index=0; index < src->cRuns; index++)
    {
        if (src->awcrun[index].phg != NULL)
        {
            offset = (ULONG) ((PBYTE) src->awcrun[index].phg - (PBYTE) src);

            if (offset >= cjSize)
            {
                WARNING("GreCopyFD_GLYPHSET failed.\n");
                return FALSE;
            }

            dst->awcrun[index].phg = (HGLYPH*) ((PBYTE) dst + offset);
        }
    }

    return TRUE;
}

FD_GLYPHSET*
EngComputeGlyphSet(
    INT nCodePage,
    INT nFirstChar,
    INT cChars
    )

{
    FD_GLYPHSET *pGlyphSet, *pGlyphSetTmp = NULL;
    ULONG       cjSize;

    //
    // The driver will always call EngFreeMem after done using pGlyphSet
    // We have to provide them a user mode pointer here
    //

    if ((pGlyphSet = NtGdiEngComputeGlyphSet(nCodePage, nFirstChar, cChars)) &&
        (cjSize = pGlyphSet->cjThis) &&
        (pGlyphSetTmp = (FD_GLYPHSET *) GlobalAlloc(GMEM_FIXED, cjSize)))
    {
        if (!CopyFD_GLYPHSET(pGlyphSetTmp, pGlyphSet, cjSize))
        {
            GlobalFree((HGLOBAL) pGlyphSetTmp);
            pGlyphSetTmp = NULL;
        }
    }

    //
    // the user memory allocated from the kernel (pGlyphSet)
    // will be gone after the call is finished
    //

    return (pGlyphSetTmp);
}

//
// Query current local time
//

VOID
EngQueryLocalTime(
    PENG_TIME_FIELDS    ptf
    )

{
    SYSTEMTIME  localtime;

    GetLocalTime(&localtime);

    ptf->usYear         = localtime.wYear;
    ptf->usMonth        = localtime.wMonth;
    ptf->usDay          = localtime.wDay;
    ptf->usHour         = localtime.wHour;
    ptf->usMinute       = localtime.wMinute;
    ptf->usSecond       = localtime.wSecond;
    ptf->usMilliseconds = localtime.wMilliseconds;
    ptf->usWeekday      = localtime.wDayOfWeek;
}


//
// Simulate Eng-semaphore functions
//

HSEMAPHORE
EngCreateSemaphore(
    VOID
    )

{
    LPCRITICAL_SECTION pcs;

    if (pcs = (LPCRITICAL_SECTION) LOCALALLOC(sizeof(CRITICAL_SECTION)))
    {
        InitializeCriticalSection(pcs);
    }
    else
    {
        WARNING("Memory allocation failed.\n");
    }

    return (HSEMAPHORE) pcs;
}


VOID
EngAcquireSemaphore(
    HSEMAPHORE hsem
    )

{
    EnterCriticalSection((LPCRITICAL_SECTION) hsem);
}


VOID
EngReleaseSemaphore(
    HSEMAPHORE hsem
    )

{
    LeaveCriticalSection((LPCRITICAL_SECTION) hsem);
}


VOID
EngDeleteSemaphore(
    HSEMAPHORE hsem
    )

{
    LPCRITICAL_SECTION pcs = (LPCRITICAL_SECTION) hsem;

    if (pcs != NULL)
    {
        DeleteCriticalSection(pcs);
        LOCALFREE(pcs);
    }
}

BOOL APIENTRY
EngQueryEMFInfo(
    HDEV               hdev,
    EMFINFO           *pEMFInfo)
{
   WARNING("EngQueryEMFInfo no longer supported\n");
   return FALSE;
}

#endif // !_GDIPLUS_


=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\client\gdiplus\usermode.c ===
/******************************Module*Header*******************************\
* Module Name: usermode.c
*
* Client side stubs for any user-mode GDI-Plus thunks.
*
* Created: 2-May-1998
* Author: J. Andrew Goossen [andrewgo]
*
* Copyright (c) 1998-1999 Microsoft Corporation
\**************************************************************************/

#include "precomp.h"
#pragma hdrstop

BOOLEAN GdiProcessSetup();
BOOL InitializeGre();

/******************************Public*Routine******************************\
* GdiPlusDllInitialize                                                         
*                                                                          
* DLL initialization routine to initialize GRE and CLIENT for user-mode
* GDI+.                                                     
*                                                                          
*  02-May-1998 -by- J. Andrew Goossen [andrewgo]
* Wrote it.                                                                
\**************************************************************************/

BOOL 
GdiPlusDllInitialize(
PVOID       pvDllHandle,
ULONG       ulReason,
PCONTEXT    pcontext)
{
    NTSTATUS status = 0;
    INT i;
    PTEB pteb = NtCurrentTeb();
    BOOLEAN bRet = TRUE;

    switch (ulReason)
    {
    case DLL_PROCESS_ATTACH:

        DisableThreadLibraryCalls(pvDllHandle);

        bRet = (InitializeGre() && GdiProcessSetup());

        ghbrDCBrush = GetStockObject (DC_BRUSH);
        ghbrDCPen = GetStockObject (DC_PEN);
        break;

    case DLL_PROCESS_DETACH:
        break;
    }

    return(bRet);
}

/******************************Public*Routine******************************\
* NtUserSelectPalette                                                         
*                                                                          
* Fake stub to allow user-mode GDI+ to link.
*                                                                          
*  02-May-1998 -by- J. Andrew Goossen [andrewgo]
* Wrote it.                                                                
\**************************************************************************/

HPALETTE
NtUserSelectPalette(
    HDC hdc,
    HPALETTE hpalette,
    BOOL fForceBackground)
{
    return(0);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\client\gdiplus\usermode.h ===
/******************************Module*Header*******************************\
* Module Name: usermode.h
*
* Client side stubs for any user-mode GDI-Plus thunks.
*
* Created: 2-May-1998
* Author: J. Andrew Goossen [andrewgo]
*
* Copyright (c) 1998-1999 Microsoft Corporation
\**************************************************************************/

#define InitializeLpkHooks(a)

#if DBG
    VOID DoRip(PSZ psz);
    #define PLUSRIP DoRip
#else
    #define PLUSRIP
#endif

#define GetDC(a) \
    (PLUSRIP("GetDC"), 0)
#define ReleaseDC(a, b) \
    (PLUSRIP("ReleaseDC"), 0)
#define UserRealizePalette(a) \
    (PLUSRIP("UserRealizePalette"), 0)
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\client\gdiplus\gpprefix.h ===
/**************************************************************************
*                                                                         
* gpprefix.h -- GDI+ header file which prepends all of the GDI+ exports
*               with a 'Gp' prefix.
*                                                                    
* Copyright (c) 1998-1999 Microsoft Corp. All rights reserved.           
*                                                                    
**************************************************************************/

#if defined(_GDIPLUS_)

#define GetTextFaceAliasW               GpGetTextFaceAliasW	  	
#define AbortDoc                        GpAbortDoc
#define AddFontResourceA                GpAddFontResourceA
#define AddFontResourceW                GpAddFontResourceW
#define AddFontResourceExA              GpAddFontResourceExA
#define AddFontResourceExW              GpAddFontResourceExW
#define AddFontMemResourceEx            GpAddFontMemResourceEx
#define AngleArc                        GpAngleArc
#define Arc                             GpArc
#define BitBlt                          GpBitBlt
#define CancelDC                        GpCancelDC
#define ChoosePixelFormat               GpChoosePixelFormat
#define Chord                           GpChord
#define CloseMetaFile                   GpCloseMetaFile
#define CloseEnhMetaFile                GpCloseEnhMetaFile
#define CombineRgn                      GpCombineRgn
#define CombineTransform                GpCombineTransform
#define CopyMetaFileA                   GpCopyMetaFileA
#define CopyMetaFileW                   GpCopyMetaFileW
#define CopyEnhMetaFileA                GpCopyEnhMetaFileA
#define CopyEnhMetaFileW                GpCopyEnhMetaFileW
#define CreateCompatibleBitmap          GpCreateCompatibleBitmap
#define CreateCompatibleDC              GpCreateCompatibleDC
#define CreateDCA                       GpCreateDCA
#define CreateDCW                       GpCreateDCW
#define CreateDiscardableBitmap         GpCreateDiscardableBitmap
#define CreateEllipticRgn               GpCreateEllipticRgn
#define CreateEllipticRgnIndirect       GpCreateEllipticRgnIndirect
#define CreateFontA                     GpCreateFontA
#define CreateFontW                     GpCreateFontW
#define CreateFontIndirectA             GpCreateFontIndirectA
#define CreateFontIndirectW             GpCreateFontIndirectW
#define CreateFontIndirectExA           GpCreateFontIndirectExA
#define CreateFontIndirectExW           GpCreateFontIndirectExW
#define CreateHatchBrush                GpCreateHatchBrush
#define CreateICA                       GpCreateICA
#define CreateICW                       GpCreateICW
#define CreateMetaFileA                 GpCreateMetaFileA
#define CreateMetaFileW                 GpCreateMetaFileW
#define CreateEnhMetaFileA              GpCreateEnhMetaFileA
#define CreateEnhMetaFileW              GpCreateEnhMetaFileW
#define CreatePatternBrush              GpCreatePatternBrush
#define CreatePen                       GpCreatePen
#define ExtCreatePen                    GpExtCreatePen
#define CreatePenIndirect               GpCreatePenIndirect
#define CreateRectRgn                   GpCreateRectRgn
#define CreateRectRgnIndirect           GpCreateRectRgnIndirect
#define CreateRoundRectRgn              GpCreateRoundRectRgn
#define CreateScalableFontResourceA     GpCreateScalableFontResourceA
#define CreateScalableFontResourceW     GpCreateScalableFontResourceW
#define CreateSolidBrush                GpCreateSolidBrush
#define DeleteDC                        GpDeleteDC
#define DeleteMetaFile                  GpDeleteMetaFile
#define DeleteEnhMetaFile               GpDeleteEnhMetaFile
#define DeleteObject                    GpDeleteObject
#define DescribePixelFormat             GpDescribePixelFormat
#define DeviceCapabilitiesExA           GpDeviceCapabilitiesExA
#define DeviceCapabilitiesExW           GpDeviceCapabilitiesExW 
#define DrawEscape                      GpDrawEscape
#define EndDoc                          GpEndDoc
#define EndPage                         GpEndPage
#define EndFormPage                     GpEndFormPage
#define EnumFontFamiliesA               GpEnumFontFamiliesA
#define EnumFontFamiliesW               GpEnumFontFamiliesW
#define EnumFontsA                      GpEnumFontsA
#define EnumFontsW                      GpEnumFontsW
#define EnumObjects                     GpEnumObjects
#define Ellipse                         GpEllipse
#define EqualRgn                        GpEqualRgn
#define Escape                          GpEscape
#define ExtEscape                       GpExtEscape
#define ExcludeClipRect                 GpExcludeClipRect
#define ExtFloodFill                    GpExtFloodFill
#define ExtCreateRegion                 GpExtCreateRegion
#define ExtSelectClipRgn                GpExtSelectClipRgn
#define FillRgn                         GpFillRgn
#define FloodFill                       GpFloodFill
#define FrameRgn                        GpFrameRgn
#define GdiComment                      GpGdiComment
#define GdiFlush                        GpGdiFlush
#define GdiPlayScript                   GpGdiPlayScript
#define GdiPlayDCScript                 GpGdiPlayDCScript
#define GdiPlayJournal                  GpGdiPlayJournal
#define GdiGetBatchLimit                GpGdiGetBatchLimit
#define GdiSetBatchLimit                GpGdiSetBatchLimit
#define GetAspectRatioFilterEx          GpGetAspectRatioFilterEx
#define GetBitmapDimensionEx            GpGetBitmapDimensionEx
#define GetBkColor                      GpGetBkColor
#define GetBkMode                       GpGetBkMode
#define GetBrushOrgEx                   GpGetBrushOrgEx
#define GetCharABCWidthsA               GpGetCharABCWidthsA
#define GetCharABCWidthsW               GpGetCharABCWidthsW
#define GetCharABCWidthsFloatA          GpGetCharABCWidthsFloatA
#define GetCharABCWidthsFloatW          GpGetCharABCWidthsFloatW
#define GetCharABCWidthsI               GpGetCharABCWidthsI
#define GetClipBox                      GpGetClipBox
#define GetClipRgn                      GpGetClipRgn
#define GetColorAdjustment              GpGetColorAdjustment
#define GetCurrentObject                GpGetCurrentObject
#define GetCurrentPositionEx            GpGetCurrentPositionEx
#define GetDeviceCaps                   GpGetDeviceCaps
#define GetFontResourceInfoW            GpGetFontResourceInfoW
#define GetFontUnicodeRanges            GpGetFontUnicodeRanges 
#define GetGlyphIndicesA                GpGetGlyphIndicesA
#define GetGlyphIndicesW                GpGetGlyphIndicesW 
#define GetGraphicsMode                 GpGetGraphicsMode
#define GetMapMode                      GpGetMapMode
#define GetMetaFileA                    GpGetMetaFileA
#define GetMetaFileW                    GpGetMetaFileW
#define GetMetaRgn                      GpGetMetaRgn
#define GetEnhMetaFileA                 GpGetEnhMetaFileA
#define GetEnhMetaFileW                 GpGetEnhMetaFileW
#define GetEnhMetaFileDescriptionA      GpGetEnhMetaFileDescriptionA
#define GetEnhMetaFileDescriptionW      GpGetEnhMetaFileDescriptionW
#define GetEnhMetaFileHeader            GpGetEnhMetaFileHeader
#define GetEnhMetaFilePaletteEntries    GpGetEnhMetaFilePaletteEntries
#define GetEnhMetaFilePixelFormat       GpGetEnhMetaFilePixelFormat
#define GetFontData                     GpGetFontData
#define GetGlyphOutlineA                GpGetGlyphOutlineA
#define GetGlyphOutlineW                GpGetGlyphOutlineW
#define GetKerningPairsA                GpGetKerningPairsA
#define GetKerningPairsW                GpGetKerningPairsW
#define GetNearestColor                 GpGetNearestColor
#define GetNearestPaletteIndex          GpGetNearestPaletteIndex
#define GetOutlineTextMetricsA          GpGetOutlineTextMetricsA
#define GetOutlineTextMetricsW          GpGetOutlineTextMetricsW
#define GetPixel                        GpGetPixel
#define GetPixelFormat                  GpGetPixelFormat
#define GetPolyFillMode                 GpGetPolyFillMode
#define GetRasterizerCaps               GpGetRasterizerCaps
#define GetRandomRgn                    GpGetRandomRgn
#define GetRegionData                   GpGetRegionData
#define GetRelAbs                       GpGetRelAbs
#define GetRgnBox                       GpGetRgnBox
#define GetROP2                         GpGetROP2
#define GetStockObject                  GpGetStockObject
#define GetStretchBltMode               GpGetStretchBltMode
#define GetSystemPaletteUse             GpGetSystemPaletteUse
#define GetTextAlign                    GpGetTextAlign
#define GetTextCharacterExtra           GpGetTextCharacterExtra
#define GetTextColor                    GpGetTextColor
#define GetDCBrushColor                 GpGetDCBrushColor
#define GetDCPenColor                   GpGetDCPenColor
#define GetTextExtentPointA             GpGetTextExtentPointA
#define GetTextExtentPointW             GpGetTextExtentPointW
#define GetTextExtentPoint32A           GpGetTextExtentPoint32A
#define GetTextExtentPoint32W           GpGetTextExtentPoint32W
#define GetTextExtentExPointA           GpGetTextExtentExPointA
#define GetTextExtentExPointW           GpGetTextExtentExPointW
#define GetTextExtentPointI             GpGetTextExtentPointI
#define GetTextExtentExPointI           GpGetTextExtentExPointI
#define GetTextFaceA                    GpGetTextFaceA
#define GetTextFaceW                    GpGetTextFaceW
#define GetTextMetricsA                 GpGetTextMetricsA
#define GetTextMetricsW                 GpGetTextMetricsW
#define GetViewportExtEx                GpGetViewportExtEx
#define GetViewportOrgEx                GpGetViewportOrgEx
#define GetWindowExtEx                  GpGetWindowExtEx
#define GetWindowOrgEx                  GpGetWindowOrgEx
#define GetWorldTransform               GpGetWorldTransform
#define IntersectClipRect               GpIntersectClipRect
#define InvertRgn                       GpInvertRgn
#define LineDDA                         GpLineDDA
#define LineTo                          GpLineTo
#define MaskBlt                         GpMaskBlt
#define ModifyWorldTransform            GpModifyWorldTransform
#define MoveToEx                        GpMoveToEx
#define OffsetClipRgn                   GpOffsetClipRgn
#define OffsetRgn                       GpOffsetRgn
#define OffsetViewportOrgEx             GpOffsetViewportOrgEx
#define OffsetWindowOrgEx               GpOffsetWindowOrgEx
#define PaintRgn                        GpPaintRgn
#define PatBlt                          GpPatBlt
#define PolyPatBlt                      GpPolyPatBlt
#define Pie                             GpPie
#define PlayMetaFile                    GpPlayMetaFile
#define PlayEnhMetaFile                 GpPlayEnhMetaFile
#define PlgBlt                          GpPlgBlt
#define PtInRegion                      GpPtInRegion
#define PtVisible                       GpPtVisible
#define RealizePalette                  GpRealizePalette
#define Rectangle                       GpRectangle
#define RectInRegion                    GpRectInRegion
#define RectVisible                     GpRectVisible
#define RemoveFontResourceA             GpRemoveFontResourceA
#define RemoveFontResourceW             GpRemoveFontResourceW
#define RemoveFontResourceExA           GpRemoveFontResourceExA
#define RemoveFontResourceExW           GpRemoveFontResourceExW
#define RemoveFontMemResourceEx         GpRemoveFontMemResourceEx
#define ResizePalette                   GpResizePalette
#define RestoreDC                       GpRestoreDC
#define RoundRect                       GpRoundRect
#define SaveDC                          GpSaveDC
#define ScaleViewportExtEx              GpScaleViewportExtEx
#define ScaleWindowExtEx                GpScaleWindowExtEx
#define SelectClipRgn                   GpSelectClipRgn
#define SelectObject                    GpSelectObject
#define SelectBrushLocal                GpSelectBrushLocal
#define SelectFontLocal                 GpSelectFontLocal
#define SelectPalette                   GpSelectPalette
#define SetBitmapDimensionEx            GpSetBitmapDimensionEx
#define SetBkColor                      GpSetBkColor
#define SetBkMode                       GpSetBkMode
#define SetBrushOrgEx                   GpSetBrushOrgEx
#define SetColorAdjustment              GpSetColorAdjustment
#define SetFontEnumeration              GpSetFontEnumeration
#define SetGraphicsMode                 GpSetGraphicsMode
#define SetMapMode                      GpSetMapMode
#define SetMapperFlags                  GpSetMapperFlags
#define SetPixel                        GpSetPixel
#define SetPixelFormat                  GpSetPixelFormat
#define SetPixelV                       GpSetPixelV
#define SetPolyFillMode                 GpSetPolyFillMode
#define SetRectRgn                      GpSetRectRgn
#define SetRelAbs                       GpSetRelAbs
#define SetROP2                         GpSetROP2
#define SetStretchBltMode               GpSetStretchBltMode
#define SetSystemPaletteUse             GpSetSystemPaletteUse
#define SetTextAlign                    GpSetTextAlign
#define SetTextCharacterExtra           GpSetTextCharacterExtra
#define SetTextColor                    GpSetTextColor
#define SetDCBrushColor                 GpSetDCBrushColor
#define SetDCPenColor                   GpSetDCPenColor
#define SetTextJustification            GpSetTextJustification
#define SetLayout                       GpSetLayout
#define GetLayout                       GpGetLayout
#define SetLayoutWidth                  GpSetLayoutWidth            
#define MirrorRgn                       GpMirrorRgn                 
#define SetViewportExtEx                GpSetViewportExtEx
#define SetViewportOrgEx                GpSetViewportOrgEx
#define SetWindowExtEx                  GpSetWindowExtEx
#define SetWindowOrgEx                  GpSetWindowOrgEx
#define SetWorldTransform               GpSetWorldTransform
#define StartDocA                       GpStartDocA
#define StartDocW                       GpStartDocW
#define StartPage                       GpStartPage
#define StartFormPage                   GpStartFormPage
#define StretchBlt                      GpStretchBlt
#define SwapBuffers                     GpSwapBuffers
#define TextOutA                        GpTextOutA
#define TextOutW                        GpTextOutW
#define UpdateColors                    GpUpdateColors
#define UnrealizeObject                 GpUnrealizeObject
#define FixBrushOrgEx                   GpFixBrushOrgEx
#define GetDCOrgEx                      GpGetDCOrgEx
#define AnimatePalette                  GpAnimatePalette
#define ArcTo                           GpArcTo
#define BeginPath                       GpBeginPath
#define CloseFigure                     GpCloseFigure
#define CreateBitmap                    GpCreateBitmap
#define CreateBitmapIndirect            GpCreateBitmapIndirect
#define CreateBrushIndirect             GpCreateBrushIndirect
#define CreateDIBitmap                  GpCreateDIBitmap
#define CreateDIBPatternBrush           GpCreateDIBPatternBrush
#define CreateDIBPatternBrushPt         GpCreateDIBPatternBrushPt
#define CreateDIBSection                GpCreateDIBSection
#define CreateHalftonePalette           GpCreateHalftonePalette    
#define CreatePalette                   GpCreatePalette
#define CreatePolygonRgn                GpCreatePolygonRgn
#define CreatePolyPolygonRgn            GpCreatePolyPolygonRgn
#define DPtoLP                          GpDPtoLP
#define EndPath                         GpEndPath
#define EnumMetaFile                    GpEnumMetaFile
#define EnumEnhMetaFile                 GpEnumEnhMetaFile
#define ExtTextOutA                     GpExtTextOutA
#define ExtTextOutW                     GpExtTextOutW
#define PolyTextOutA                    GpPolyTextOutA
#define PolyTextOutW                    GpPolyTextOutW
#define FillPath                        GpFillPath
#define FlattenPath                     GpFlattenPath
#define GetArcDirection                 GpGetArcDirection
#define GetBitmapBits                   GpGetBitmapBits
#define GetCharWidthA                   GpGetCharWidthA
#define GetCharWidthW                   GpGetCharWidthW
#define GetCharWidth32A                 GpGetCharWidth32A
#define GetCharWidth32W                 GpGetCharWidth32W
#define GetCharWidthFloatA              GpGetCharWidthFloatA
#define GetCharWidthFloatW              GpGetCharWidthFloatW
#define GetCharWidthI                   GpGetCharWidthI
#define GetDIBColorTable                GpGetDIBColorTable
#define GetDIBits                       GpGetDIBits
#define GetMetaFileBitsEx               GpGetMetaFileBitsEx
#define GetMiterLimit                   GpGetMiterLimit
#define GetEnhMetaFileBits              GpGetEnhMetaFileBits
#define GetObjectA                      GpGetObjectA
#define GetObjectW                      GpGetObjectW
#define GetObjectType                   GpGetObjectType
#define GetPaletteEntries               GpGetPaletteEntries
#define GetPath                         GpGetPath
#define GetSystemPaletteEntries         GpGetSystemPaletteEntries
#define GetWinMetaFileBits              GpGetWinMetaFileBits
#define LPtoDP                          GpLPtoDP
#define PathToRegion                    GpPathToRegion
#define PlayMetaFileRecord              GpPlayMetaFileRecord
#define PlayEnhMetaFileRecord           GpPlayEnhMetaFileRecord
#define PolyBezier                      GpPolyBezier
#define PolyBezierTo                    GpPolyBezierTo
#define PolyDraw                        GpPolyDraw
#define Polygon                         GpPolygon
#define Polyline                        GpPolyline
#define PolylineTo                      GpPolylineTo
#define PolyPolygon                     GpPolyPolygon
#define PolyPolyline                    GpPolyPolyline
#define ResetDCA                        GpResetDCA
#define ResetDCW                        GpResetDCW
#define SelectClipPath                  GpSelectClipPath
#define SetAbortProc                    GpSetAbortProc
#define SetBitmapBits                   GpSetBitmapBits
#define SetDIBColorTable                GpSetDIBColorTable
#define SetDIBits                       GpSetDIBits
#define SetDIBitsToDevice               GpSetDIBitsToDevice
#define SetMetaFileBitsEx               GpSetMetaFileBitsEx
#define SetEnhMetaFileBits              GpSetEnhMetaFileBits
#define SetMiterLimit                   GpSetMiterLimit
#define SetPaletteEntries               GpSetPaletteEntries
#define SetWinMetaFileBits              GpSetWinMetaFileBits
#define StretchDIBits                   GpStretchDIBits
#define StrokeAndFillPath               GpStrokeAndFillPath
#define StrokePath                      GpStrokePath
#define WidenPath                       GpWidenPath
#define AbortPath                       GpAbortPath
#define SetArcDirection                 GpSetArcDirection
#define SetMetaRgn                      GpSetMetaRgn
#define GetBoundsRect                   GpGetBoundsRect
#define SetBoundsRect                   GpSetBoundsRect
#define SetICMMode                      GpSetICMMode
#define EnumICMProfilesA                GpEnumICMProfilesA
#define EnumICMProfilesW                GpEnumICMProfilesW
#define CheckColorsInGamut              GpCheckColorsInGamut
#define GetColorSpace                   GpGetColorSpace
#define GetLogColorSpaceA               GpGetLogColorSpaceA
#define GetLogColorSpaceW               GpGetLogColorSpaceW
#define CreateColorSpaceA               GpCreateColorSpaceA
#define CreateColorSpaceW               GpCreateColorSpaceW
#define SetColorSpace                   GpSetColorSpace
#define DeleteColorSpace                GpDeleteColorSpace
#define GetICMProfileA                  GpGetICMProfileA
#define GetICMProfileW                  GpGetICMProfileW
#define SetICMProfileA                  GpSetICMProfileA
#define SetICMProfileW                  GpSetICMProfileW
#define GetDeviceGammaRamp              GpGetDeviceGammaRamp
#define SetDeviceGammaRamp              GpSetDeviceGammaRamp
#define ColorMatchToTarget              GpColorMatchToTarget
#define UpdateICMRegKeyA                GpUpdateICMRegKeyA
#define UpdateICMRegKeyW                GpUpdateICMRegKeyW
#define ColorCorrectPalette             GpColorCorrectPalette
#define gdiPlaySpoolStream              GpgdiPlaySpoolStream
#define EnumFontFamiliesExA             GpEnumFontFamiliesExA
#define EnumFontFamiliesExW             GpEnumFontFamiliesExW
#define GetCharacterPlacementA          GpGetCharacterPlacementA
#define GetCharacterPlacementW          GpGetCharacterPlacementW
#define GetFontLanguageInfo             GpGetFontLanguageInfo
#define TranslateCharsetInfo            GpTranslateCharsetInfo
#define GetTextCharsetInfo              GpGetTextCharsetInfo 
#define GetTextCharset                  GpGetTextCharset
#define SetMagicColors                  GpSetMagicColors 
#define EnableEUDC                      GpEnableEUDC 
#define EudcLoadLinkW                   GpEudcLoadLinkW
#define EudcUnloadLinkW                 GpEudcUnloadLinkW
#define GetEUDCTimeStamp                GpGetEUDCTimeStamp       
#define GetEUDCTimeStampExW             GpGetEUDCTimeStampExW    
#define GetStringBitmapA                GpGetStringBitmapA       
#define GetStringBitmapW                GpGetStringBitmapW       
#define QueryFontAssocStatus            GpQueryFontAssocStatus   
#define GetFontAssocStatus              GpGetFontAssocStatus
#define GdiGetPageCount                 GpGdiGetPageCount
#define GdiGetDC                        GpGdiGetDC
#define GdiDeleteSpoolFileHandle        GpGdiDeleteSpoolFileHandle
#define GdiGetPageHandle                GpGdiGetPageHandle
#define GdiGetSpoolFileHandle           GpGdiGetSpoolFileHandle
#define GdiPlayEMF                      GpGdiPlayEMF
#define GdiStartDocEMF                  GpGdiStartDocEMF
#define GdiStartPageEMF                 GpGdiStartPageEMF
#define GdiPlayPageEMF                  GpGdiPlayPageEMF
#define GdiPlayPageEMF                  GpGdiPlayPageEMF
#define GdiEndPageEMF                   GpGdiEndPageEMF
#define GdiEndDocEMF                    GpGdiEndDocEMF
#define GdiGetDevmodeForPage            GpGdiGetDevmodeForPage
#define GdiResetDCEMF                   GpGdiResetDCEMF

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\client\wow6432\i386\cmpexch.asm ===
title  "Interlocked Support"
;++
;
; Copyright (c) 1989-1999  Microsoft Corporation
;
; Module Name:
;
;    cmpexch.asm
;
; Abstract:
;
;    This module implements InterlockedCompareExchangeKernelPointer.
;
; Author:
;
;    mzoran  1-Jan-99
;
; Environment:
;
;    User-mode.
;
; Revision History:
;
;--
.386p
        .xlist
include ks386.inc
include callconv.inc                    ; calling convention macros
        .list


_TEXT   SEGMENT DWORD PUBLIC 'CODE'
        ASSUME  DS:FLAT, ES:FLAT, SS:NOTHING, FS:NOTHING, GS:NOTHING   

;++
;
; KERNEL_PVOID
; InterlockedCompareExchangeKernelPointer (
;    IN OUT KERNEL_PVOID *Destination,
;    IN KERNEL_PVOID Exchange,
;    IN KERNEL_PVOID Comperand,
;    )
;
; Routine Description:
;
; 	Performs an atomin comparison of the value pointed to by Destination and Compare.
;  	The function exchanges the values based on the comparison.
;
;
; Arguments:
;
;    (esp+4) Destination - Supplies a pointer to the destination variable.
;
;    (esp+8) Exchange - Supplies the exchange value.
;
;    (esp+16) Comperand - Supplies the comperand value.
;
;
; Return Value:
;
;    The current destination value is returned as the function value.
;
;--

cPublicProc _InterlockedCompareExchangeKernelPointer ,5
cPublicFpo 5,2
      
        push ebp                        ; save nonvolatile registers
        push ebx                 

        mov     ebp, [esp] + 12         ; get destination address
        mov     ebx, [esp] + 16         ; get exchange value
        mov     ecx, [esp] + 20         ;
        mov     eax, [esp] + 24         ; get comperand value
        mov     edx, [esp] + 28         ;       

.586
        lock cmpxchg8b qword ptr [ebp]  ; compare and exchange
.386

;
; Restore nonvolatile registers and return result in edx:eax.
;

        pop     ebx                     ; restore nonvolatile registers
        pop     ebp        
 
        stdRET    _InterlockedCompareExchangeKernelPointer

stdENDP _InterlockedCompareExchangeKernelPointer

_TEXT   ends
        end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\dciman\dllinit.c ===
/******************************Module*Header*******************************\
* Module Name: dllinit.c                                                   *
*                                                                          *
* Contains the DCI library initialization routines.                        *
*                                                                          *
* Created: 23-Sep-1994                                                     *
* Author: Andre Vachon [andreva]                                           *
*                                                                          *
* Copyright (c) 1990,1994 Microsoft Corporation                            *
\**************************************************************************/

#include <windows.h>

extern CRITICAL_SECTION gcsWinWatchLock;

/******************************Public*Routine******************************\
* DciDllInitialize                                                         *
*                                                                          *
* This is the init procedure for DCIMAN32.dll, which is called each time a *
* new process links to it.                                                 *
*                                                                          *
\**************************************************************************/

BOOLEAN DciDllInitialize(
    PVOID pvDllHandle,
    ULONG ulReason,
    PCONTEXT pcontext)
{
    //
    // Suppress compiler warnings.
    //

    pvDllHandle;
    pcontext;

    //
    // Do appropriate attach/detach processing.
    //

    switch (ulReason)
    {
    case DLL_PROCESS_ATTACH:

        //
        // On process attach, initialize the global semaphore.
        //

        InitializeCriticalSection(&gcsWinWatchLock);
        break;

    case DLL_PROCESS_DETACH:

        //
        // On process detach, initialize the global semaphore.
        //

        DeleteCriticalSection(&gcsWinWatchLock);
        break;

    case DLL_THREAD_ATTACH:
    case DLL_THREAD_DETACH:

        //
        // Nothing to do yet for thread attach/detach.
        //

        break;

    default:
        break;
    }

    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\debug\gdiview\debug.h ===
/**************************************************************************\
* 
* Copyright (c) 1998  Microsoft Corporation
*
* Module Name:
*
*   debug.h
*
* Abstract:
*
*   Macros used for debugging purposes
*
* Revision History:
*
*   12/02/1998 davidx
*       Created it.
*
\**************************************************************************/

#ifndef _DEBUG_H
#define _DEBUG_H

#ifdef __cplusplus
extern "C" {
#endif

//
// These macros are used for debugging purposes. They expand
// to white spaces on a free build. Here is a brief description
// of what they do and how they are used:
//
// _debugLevel
//  Global variable which set the current debug level to control
//  the amount of debug messages emitted.
//
// VERBOSE(msg)
//  Display a message if the current debug level is <= DBG_VERBOSE.
//
// TERSE(msg)
//  Display a message if the current debug level is <= DBG_TERSE.
//
// WARNING(msg)
//  Display a message if the current debug level is <= DBG_WARNING.
//  The message format is: WRN filename (linenumber): message
//
// ASSERT(cond)
//  Verify a condition is true. If not, force a breakpoint.
//
// ASSERTMSG(cond, msg)
//  Verify a condition is true. If not, display a message and 
//  force a breakpoint.
//
// RIP(msg)
//  Display a message and force a breakpoint.
//
// Usage:
//
//  These macros require extra parantheses for the msg argument
//  for example:
//      WARNING(("App passed NULL pointer, ignoring...\n"));
//      ASSERTMSG(x > 0, ("x is less than 0\n"));
//

#if DBG

// Global debug level

#define DBG_VERBOSE 1
#define DBG_TERSE   2
#define DBG_WARNING 3
#define DBG_RIP     4

extern INT _debugLevel;

//--------------------------------------------------------------------------
// Debug build for native DLL
//--------------------------------------------------------------------------

// Emit debug messages

ULONG DbgPrint(const CHAR*, ...);

// Strip the directory prefix from a filename

const CHAR*
StripDirPrefix(
    const CHAR* filename
    );

#define DBGMSG(level, prefix, msg) \
        do { \
            if (_debugLevel <= (level)) \
            { \
                DbgPrint("%s %s (%d): ", prefix, StripDirPrefix(__FILE__), __LINE__); \
                DbgPrint msg; \
            } \
        } while (0)

#define DBGPRINT(level, msg) \
        do { \
            if (_debugLevel <= (level)) \
            { \
                DbgPrint msg; \
            } \
        } while (0)
    
#define VERBOSE(msg) DBGPRINT(DBG_VERBOSE, msg)
#define TERSE(msg) DBGPRINT(DBG_TERSE, msg)
#define WARNING(msg) DBGMSG(DBG_WARNING, "WRN", msg)

#define ASSERT(cond) \
        do { \
            if (! (cond)) \
            { \
                RIP(("\n")); \
            } \
        } while (0)

#define ASSERTMSG(cond, msg) \
        do { \
            if (! (cond)) \
            { \
                RIP(msg); \
            } \
        } while (0)

#define RIP(msg) \
        do { \
            DBGMSG(DBG_RIP, "RIP", msg); \
            DebugBreak(); \
        } while (0)

#define ENTERFUNC(func) VERBOSE(("%x:%x: Enter "##func##"\n", GetCurrentProcessId(), GetCurrentThreadId()))
#define LEAVEFUNC(func) VERBOSE(("%x:%x: Leave "##func##"\n", GetCurrentProcessId(), GetCurrentThreadId()))

#else // !DBG

//--------------------------------------------------------------------------
// Retail build
//--------------------------------------------------------------------------

#define DbgPrint

#define VERBOSE(msg)
#define TERSE(msg)
#define WARNING(msg)

#define ASSERT(cond)
#define ASSERTMSG(cond, msg)
#define RIP(msg)
#define DBGMSG(level, prefix, msg) 
#define DBGPRINT(level, msg)

#define ENTERFUNC(func)
#define LEAVEFUNC(func)

#endif // !DBG

#ifdef __cplusplus
}
#endif

#endif // !_DEBUG_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\debug\gdiview\output.h ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    output.h

Abstract:

    This header file declares output routines
    and classes.

Author:

    Jason Hartman (JasonHa) 2000-10-16

--*/


#ifndef _OUTPUT_H_
#define _OUTPUT_H_


class OutputMonitor
{
public:
    OutputMonitor() {
        Client = NULL;
    }

    HRESULT Monitor(PDEBUG_CLIENT Client, ULONG OutputMask);

    HRESULT GetOutputMask(PULONG OutputMask);
    HRESULT SetOutputMask(ULONG OutputMask);

    ~OutputMonitor();

private:
    PDEBUG_CLIENT Client;
    PDEBUG_CLIENT MonitorClient;
};


//----------------------------------------------------------------------------
//
// Default output callbacks implementation, provides IUnknown for
// static classes and prints all text sent through Output.
//
//----------------------------------------------------------------------------

class PrintOutputCallbacks :
    public IDebugOutputCallbacks
{
public:
    // IUnknown.
    STDMETHOD(QueryInterface)(
        THIS_
        IN REFIID InterfaceId,
        OUT PVOID* Interface
        );
    STDMETHOD_(ULONG, AddRef)(
        THIS
        );
    STDMETHOD_(ULONG, Release)(
        THIS
        );

    // IDebugOutputCallbacks.
    STDMETHOD(Output)(
        THIS_
        IN ULONG Mask,
        IN PCSTR Text
        );
};

#endif  _OUTPUT_H_
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\debug\gdiview\debug.cpp ===
/**************************************************************************\
*
* Copyright (c) 1998-1999  Microsoft Corporation
*
* Abstract:
*
*   Debugging routines
*
* Revision History:
*
*   09/07/1999 agodfrey
*       Created it.
*
\**************************************************************************/

#include <windows.h>
#include <stdio.h>

#include "debug.h"

#if DBG

// _debugLevel is used to control the amount/severity of debugging messages
// that are actually output.

INT _debugLevel = DBG_VERBOSE;

/**************************************************************************\
*
* Function Description:
*
*   Removes the path portion of a pathname
*
* Arguments:
*
*   [IN] str - pathname to strip
*
* Return Value:
*
*   A pointer to the filename portion of the pathname
*
* History:
*
*   09/07/1999 agodfrey
*       Moved from Entry\Initialize.cpp 
*
\**************************************************************************/

const CHAR*
StripDirPrefix(
    const CHAR* str
    )

{
    const CHAR* p;

    p = strrchr(str, '\\');
    return p ? p+1 : str;
}

/**************************************************************************\
*
* Function Description:
*
*   Outputs to the debugger
*
* Arguments:
*
*   [IN] format - printf-like format string and variable arguments
*
* Return Value:
*
*   Zero. This is to conform to NTDLL's definition of DbgPrint.
*
* Notes:
*
*   There will be no output if a debugger is not connected.
*
* History:
*
*   09/07/1999 agodfrey
*       Moved from Entry\Initialize.cpp 
*
\**************************************************************************/

ULONG _cdecl
DbgPrint(
    const CHAR* format,
    ...
    )

{
    va_list arglist;
    va_start(arglist, format);
    
    const int BUFSIZE=1024;
    
    char buf[BUFSIZE];
    
    _vsnprintf(buf, BUFSIZE, format, arglist);
    buf[BUFSIZE-1]=0;
        
    OutputDebugStringA(buf);
    
    va_end(arglist);
    return 0;
}

#endif // DBG
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\dciman\dciman.c ===
/******************************Module*Header*******************************\
* Module Name: dciman.c                                                    *
*                                                                          *
* Client side stubs for DCIMAN functions.                                  *
*                                                                          *
* Created: 07-Sep-1994                                                     *
* Author: Andre Vachon [andreva]                                           *
*                                                                          *
* Copyright (c) 1994-1998 Microsoft Corporation                            *
\**************************************************************************/

#include <nt.h>
#include <ntrtl.h>
#include <nturtl.h>
#include <stddef.h>
#include <windows.h>
#include <winspool.h>
#include <wingdip.h>
#include <ddrawp.h>
#include <winddi.h>
#include "dciddi.h"
#include "dciman.h"
#include <ddrawi.h>
#include <ddrawgdi.h>

#if DBG

#define RIP(x) {DbgPrint(x); DbgBreakPoint();}
#define ASSERTGDI(x,y) if(!(x)) RIP(y)
#define WARNING(x) {DbgPrint(x);}

#else

#define ASSERTGDI(x,y)
#define WARNING(x)

#endif

typedef struct _WINWATCH *PWINWATCH;

typedef struct _WINWATCH {

    PWINWATCH         pWinWatchNext;
    HWND              hwnd;
    BOOL              changed;
    ULONG             lprgndataSize;
    LPRGNDATA         lprgndata;

} WINWATCH, *PWINWATCH;

//
// The following structure incorporates the DirectDraw structures required
// to identify a surface.  It is allocated before the start of the
// DCISURFACEINFO structure.
//

typedef struct _DCIMAN_SURF
{
    BOOL                     SurfaceLost;       // True if the surface can no
                                                //   longer be accessed because
                                                //   a mode change occured
    DDRAWI_DIRECTDRAW_GBL    DirectDrawGlobal;  // Identifies device
    DDRAWI_DDRAWSURFACE_GBL  SurfaceGlobal;     // Identifies surface
    DDRAWI_DDRAWSURFACE_LCL  SurfaceLocal;      // Identifies surface
    DDHAL_DDCALLBACKS        DDCallbacks;       // Contains address of CreateSurface
                                                //   call for BeginAccess
    DDHAL_DDSURFACECALLBACKS DDSurfaceCallbacks;// Contains addresses of Lock, Unlock,
                                                //   and DestroySurface calls for
                                                //   BeginAccess and EndAccess
} DCIMAN_SURF, *PDCIMAN_SURF;

//
// We maintain a linked list of all winwatch's so that we can notify their
// owners whenever we notice that the clippping has changed.  The list may
// be accessed only while holding the gcsWinWatchLock critical section.
//

CRITICAL_SECTION gcsWinWatchLock;

PWINWATCH gpWinWatchList = NULL;

/******************************Private*Routine*****************************\
* dciCreateSurface
*
* History:  1-Aug-1998 Jerry Van Aken [jvanaken] wrote it.
\**************************************************************************/

static BOOL bCreateSurface(PDCIMAN_SURF pPrivate)
{
    DDSURFACEDESC ddsd;
    DDHAL_CREATESURFACEDATA csd;
    LPDDRAWI_DDRAWSURFACE_LCL pSurfaceLocal = &pPrivate->SurfaceLocal;

    //
    // Fill in DDSURFACEDESC struct for CreateSurface call.
    //

    ZeroMemory(&ddsd, sizeof(ddsd));
    ddsd.dwSize = sizeof(ddsd);
    ddsd.dwFlags = DDSD_CAPS;
    ddsd.ddsCaps.dwCaps = DDSCAPS_PRIMARYSURFACE | DDSCAPS_VISIBLE;

    //
    // Fill in DDHAL_CREATESURFACEDATA struct for CreateSurface call.
    //

    csd.lpDD = pPrivate->SurfaceGlobal.lpDD;
    csd.lpDDSurfaceDesc = &ddsd;
    csd.lplpSList = &pSurfaceLocal;
    csd.dwSCnt = 1;
    csd.ddRVal = DDERR_GENERIC;
    csd.CreateSurface = pPrivate->DDCallbacks.CreateSurface;

    if ((pPrivate->DDCallbacks.dwFlags & DDHAL_CB32_CREATESURFACE) &&
	(csd.CreateSurface != NULL) &&
	((*csd.CreateSurface)(&csd) == DDHAL_DRIVER_HANDLED) &&
	(csd.ddRVal == DD_OK))
    {
    	return TRUE;
    }
    return FALSE;
}

/******************************Private*Routine*****************************\
* dciCreateSurface
*
* History:  1-Aug-1998 Jerry Van Aken [jvanaken] wrote it.
\**************************************************************************/

static BOOL bDestroySurface(PDCIMAN_SURF pPrivate)
{
    DDHAL_DESTROYSURFACEDATA dsd;

    dsd.lpDD = pPrivate->SurfaceGlobal.lpDD;
    dsd.lpDDSurface = &pPrivate->SurfaceLocal;
    dsd.ddRVal = DDERR_GENERIC;
    dsd.DestroySurface = pPrivate->DDSurfaceCallbacks.DestroySurface;

    if ((pPrivate->DDSurfaceCallbacks.dwFlags & DDHAL_SURFCB32_DESTROYSURFACE) &&
	(dsd.DestroySurface != NULL) &&
	((*dsd.DestroySurface)(&dsd) == DDHAL_DRIVER_HANDLED) &&
	(dsd.ddRVal == DD_OK))
    {
    	return TRUE;
    }
    return FALSE;
}

/******************************Public*Routine******************************\
* DciOpenProvider
*
* History:  1-Aug-1998 Jerry Van Aken [jvanaken] added multimon support.
\**************************************************************************/

HDC
WINAPI
DCIOpenProvider(
    void
)
{
    HANDLE h;
    DWORD iDevice;
    BOOL (WINAPI *pfnEnum)(LPVOID, DWORD, DISPLAY_DEVICEW *, DWORD);
    int cMonitors = GetSystemMetrics(SM_CMONITORS);

    if (cMonitors <= 1)
    {
	//
	// This is a single-monitor system.
	//

	return CreateDCW(L"Display", NULL, NULL, NULL);
    }

    //
    // This is a multimon system.  Get the DC for the primary monitor.
    //

    h = GetModuleHandle("user32.dll");

    (FARPROC)pfnEnum = GetProcAddress(h, "EnumDisplayDevicesW");

    if (pfnEnum == NULL)
    {
	return NULL;
    }

    for (iDevice = 0; iDevice < (DWORD)cMonitors; ++iDevice)
    {
        DISPLAY_DEVICEW dd;

	ZeroMemory(&dd, sizeof(dd));
	dd.cb = sizeof(dd);

	if (!(*pfnEnum)(NULL, iDevice, &dd, 0))
	{
    	    return NULL;
	}

	if (dd.StateFlags & DISPLAY_DEVICE_PRIMARY_DEVICE)
	{
	    //
            // Return the DC for the primary monitor.
	    //

	    return CreateDCW(NULL, dd.DeviceName, NULL, NULL);
	}
    }

    return NULL;
}

/******************************Public*Routine******************************\
* DciCloseProvider
*
* History:
\**************************************************************************/

void
WINAPI
DCICloseProvider(
    HDC hdc
)
{
    DeleteDC(hdc);
}

/******************************Public*Routine******************************\
* DciEnum
*
* History:
\**************************************************************************/

int
WINAPI
DCIEnum(
    HDC hdc,
    LPRECT lprDst,
    LPRECT lprSrc,
    LPVOID lpFnCallback,
    LPVOID lpContext
)
{
    return DCI_FAIL_UNSUPPORTED;
}

/******************************Public*Routine******************************\
* DciCreatePrimarySurface
*
* History:
\**************************************************************************/

int
WINAPI
DCICreatePrimary(
    HDC hdc,
    LPDCISURFACEINFO *lplpSurface
)
{
    int iRet;
    LPDCISURFACEINFO lpSurface;
    PDCIMAN_SURF pPrivate;
    DDHALINFO HalInfo;
    DDHAL_DDCALLBACKS DDCallbacks;
    DDHAL_DDPALETTECALLBACKS DDPaletteCallbacks;
    BOOL NewMode;

    *lplpSurface = NULL;
    iRet = DCI_FAIL_GENERIC;

    pPrivate = (PDCIMAN_SURF) LocalAlloc(LMEM_ZEROINIT, sizeof(DCIMAN_SURF)
                                                      + sizeof(DCISURFACEINFO));
    if (pPrivate != NULL)
    {
        //
        // We store private DCIMAN information in the DCIMAN_SURF structure
        // that immediately preceeds the DCISURFACEINFO structure we'll give
        // out.
        //

        lpSurface = (LPDCISURFACEINFO) (pPrivate + 1);

        if (DdCreateDirectDrawObject(&pPrivate->DirectDrawGlobal, hdc))
        {
            if (DdReenableDirectDrawObject(&pPrivate->DirectDrawGlobal, &NewMode) &&
                DdQueryDirectDrawObject(&pPrivate->DirectDrawGlobal,
                                        &HalInfo,
                                        &pPrivate->DDCallbacks,
                                        &pPrivate->DDSurfaceCallbacks,
                                        &DDPaletteCallbacks,
                                        NULL, NULL, NULL, NULL,
                                        NULL,
                                        NULL))
            {
		//
                // Build the required DirectDraw links for the 'global' and
                // 'local' surfaces.
                //

                pPrivate->SurfaceLost              = FALSE;
                pPrivate->DirectDrawGlobal.vmiData = HalInfo.vmiData;
                pPrivate->SurfaceLocal.ddsCaps.dwCaps = DDSCAPS_PRIMARYSURFACE;
                pPrivate->SurfaceLocal.lpGbl       = &pPrivate->SurfaceGlobal;
                pPrivate->SurfaceLocal.hDDSurface  = 0;
                pPrivate->SurfaceGlobal.lpDD       = &pPrivate->DirectDrawGlobal;
                pPrivate->SurfaceGlobal.wHeight    = (WORD) HalInfo.vmiData.dwDisplayHeight;
		pPrivate->SurfaceGlobal.wWidth     = (WORD) HalInfo.vmiData.dwDisplayWidth;
		pPrivate->SurfaceGlobal.lPitch     = HalInfo.vmiData.lDisplayPitch;

		if (bCreateSurface(pPrivate))
                {
                    //
                    // Associate an hwnd of '-1' with this surface to let the
                    // kernel know that the application may be drawing to any
                    // window, so Visrgn notifications should happen when any
                    // window changes.
                    //

                    if (DdResetVisrgn(&pPrivate->SurfaceLocal, (HWND) -1))
                    {
                        lpSurface->dwSize = sizeof(DCISURFACEINFO);

                        if (HalInfo.vmiData.ddpfDisplay.dwRGBBitCount <= 8)
                        {
                            lpSurface->dwCompression = BI_RGB;
                        }
                        else
                        {
                            lpSurface->dwCompression = BI_BITFIELDS;
                        }

                        lpSurface->dwDCICaps      = DCI_PRIMARY | DCI_VISIBLE;
                        lpSurface->dwMask[0]      = HalInfo.vmiData.ddpfDisplay.dwRBitMask;
                        lpSurface->dwMask[1]      = HalInfo.vmiData.ddpfDisplay.dwGBitMask;
                        lpSurface->dwMask[2]      = HalInfo.vmiData.ddpfDisplay.dwBBitMask;
                        lpSurface->dwWidth        = HalInfo.vmiData.dwDisplayWidth;
                        lpSurface->dwHeight       = HalInfo.vmiData.dwDisplayHeight;
                        lpSurface->lStride        = HalInfo.vmiData.lDisplayPitch;
                        lpSurface->dwBitCount     = HalInfo.vmiData.ddpfDisplay.dwRGBBitCount;
                        lpSurface->dwOffSurface   = 0;
                        lpSurface->wSelSurface    = 0;
                        lpSurface->wReserved      = 0;
                        lpSurface->dwReserved1    = 0;
                        lpSurface->dwReserved2    = 0;
                        lpSurface->dwReserved3    = 0;
                        lpSurface->BeginAccess    = NULL;
                        lpSurface->EndAccess      = NULL;
                        lpSurface->DestroySurface = NULL;

                        *lplpSurface = lpSurface;
                        return(DCI_OK);
                    }

		    //
		    // The call to DdResetVisrgn failed.
		    //

		    bDestroySurface(pPrivate);
                }
            }
            else
            {
                //
                // DirectDraw is not supported on this device.
                //

                iRet = DCI_FAIL_UNSUPPORTED;
            }

            DdDeleteDirectDrawObject(&pPrivate->DirectDrawGlobal);
        }
        else
        {
            //
            // DirectDraw is not supported on this device.
            //

            iRet = DCI_FAIL_UNSUPPORTED;
        }

        LocalFree(pPrivate);
    }
    else
    {
	//
	// Can't allocate memory for PDCIMAN_SURF struct.
	//

	iRet = DCI_ERR_OUTOFMEMORY;
    }

    *lplpSurface = NULL;

    return iRet;
}



/******************************Public*Routine******************************\
* GdiDciCreateOffscreenSurface
*
* Stub to call CreateOffscreenSurface
*
* History:
\**************************************************************************/

int
WINAPI
DCICreateOffscreen(
    HDC hdc,
    DWORD dwCompression,
    DWORD dwRedMask,
    DWORD dwGreenMask,
    DWORD dwBlueMask,
    DWORD dwWidth,
    DWORD dwHeight,
    DWORD dwDCICaps,
    DWORD dwBitCount,
    LPDCIOFFSCREEN *lplpSurface
)
{
    return DCI_FAIL_UNSUPPORTED;
}


/******************************Public*Routine******************************\
* DciCreateOverlay
*
* History:
\**************************************************************************/

int
WINAPI
DCICreateOverlay(
    HDC hdc,
    LPVOID lpOffscreenSurf,
    LPDCIOVERLAY FAR *lplpSurface
)
{
    return DCI_FAIL_UNSUPPORTED;
}


/******************************Public*Routine******************************\
* WinWatchOpen
*
* History:
\**************************************************************************/

HWINWATCH
WINAPI
WinWatchOpen(
    HWND hwnd
)
{
    HDC hdc;
    PWINWATCH pwatch;

    EnterCriticalSection(&gcsWinWatchLock);

    pwatch = (PWINWATCH) LocalAlloc(LPTR, sizeof(WINWATCH));

    if (pwatch)
    {
        pwatch->hwnd          = hwnd;
        pwatch->changed       = FALSE;
        pwatch->lprgndataSize = 0;
        pwatch->lprgndata     = NULL;

        //
        // Add this to the head of the list.
        //

        pwatch->pWinWatchNext = gpWinWatchList;
        gpWinWatchList = pwatch;
    }

    LeaveCriticalSection(&gcsWinWatchLock);

    return (HWINWATCH) (pwatch);
}

/******************************Public*Routine******************************\
* WinWatchClose
*
* History:
\**************************************************************************/

void
WINAPI
WinWatchClose(
    HWINWATCH hWW
)
{
    PWINWATCH pwatch = (PWINWATCH) hWW;
    PWINWATCH ptmp;

    EnterCriticalSection(&gcsWinWatchLock);

    if (gpWinWatchList == pwatch)
    {
        //
        // The specified winwatch is at the head of the list.
        //

        gpWinWatchList = pwatch->pWinWatchNext;
        LocalFree(pwatch->lprgndata);
        LocalFree(pwatch);
    }
    else
    {
        for (ptmp = gpWinWatchList;
             ptmp != NULL;
             ptmp = ptmp->pWinWatchNext)
        {
            if (ptmp->pWinWatchNext == pwatch)
            {
                //
                // We've found the specified winwatch in the list.
                //

                ptmp->pWinWatchNext = pwatch->pWinWatchNext;
                LocalFree(pwatch->lprgndata);
                LocalFree(pwatch);

                break;
            }
        }
    }

    LeaveCriticalSection(&gcsWinWatchLock);
}


/******************************Public*Routine******************************\
* WinWatchGetClipList
*
* History:
\**************************************************************************/

UINT
WINAPI
WinWatchGetClipList(
    HWINWATCH hWW,
    LPRECT prc,             // May be NULL
    UINT size,
    LPRGNDATA prd
)
{
    PWINWATCH pwatch = (PWINWATCH) hWW;
    DWORD dwSize;
    DWORD dwNewSize;
    UINT dwRet;

    //
    // The first time after the VisRgn has changed, we download and
    // cache a copy of the clipping region.  We do this because the VisRgn
    // can change under our implementation even between doing a BeginAccess/
    // EndAccess, and we should at least maintain a consistent copy of what
    // we think is the current VisRgn.
    //
    // Mostly, we do this so that the following scenario doesn't happen:
    //
    // 1.  The app calls WinWatchGetClipList to ascertain the clip size;
    // 2.  The VisRgn gets more complex;
    // 3.  The app then calls WinWatchGetClipList with a buffer size
    //     allocated from the return code of step 1., and the call fails
    //     because now the buffer isn't long enough.  The problem is that
    //     most applications probably wouldn't expect this second call to
    //     fail, and so would keep on using what is now a completely invalid
    //     region buffer.
    //

    if (pwatch->changed)
    {
        pwatch->changed = FALSE;

        //
        // Assume failure.
        //

        pwatch->lprgndataSize = 0;

        dwSize = GetWindowRegionData(pwatch->hwnd,
                                     0,
                                     NULL);

        if (dwSize != 0)
        {

        Try_Again:

            if (pwatch->lprgndata != NULL)
            {
                LocalFree(pwatch->lprgndata);
            }

            pwatch->lprgndata = LocalAlloc(0, dwSize);

            if (pwatch->lprgndata != NULL)
            {
                dwNewSize = GetWindowRegionData(pwatch->hwnd,
                                                dwSize,
                                                pwatch->lprgndata);

                if (dwNewSize == dwSize)
                {
                    //
                    // Success!  (Note that the docs are wrong and NT does
                    // not return '1' for success -- it returns the size
                    // of the buffer.)
                    //

                    pwatch->lprgndataSize = dwSize;
                }
                else if (dwSize != 0)
                {
                    //
                    // Since dwSize is not zero, which would indicate failure
                    // or success, then we know that the clipping region grew
                    // in size between the time we queried the size and the
                    // time we tried to download it.  This is a pretty rare
                    // event, and the chances of it happening again are slight
                    // (it's more likely that it will shrink the second time,
                    // anyway), so we just try it again.
                    //

                    dwSize = dwNewSize;

                    goto Try_Again;
                }
            }
        }
    }

    //
    // Now use the cached copy to handle any queries.
    //

    dwRet = 0;

    if (size < pwatch->lprgndataSize)
    {
        dwRet = pwatch->lprgndataSize;
    }
    else
    {
        if (pwatch->lprgndataSize != 0)
        {
            RtlCopyMemory(prd, pwatch->lprgndata, pwatch->lprgndataSize);
            dwRet = 1;
        }
    }

    return dwRet;
}


/******************************Public*Routine******************************\
* WinWatchDidStatusChange
*
* History:
\**************************************************************************/


BOOL
WINAPI
WinWatchDidStatusChange(
    HWINWATCH hWW
)
{
    PWINWATCH pwatch = (PWINWATCH) hWW;

    return pwatch->changed;
}


/******************************Public*Routine******************************\
* GetWindowRegionData
*
* History:
\**************************************************************************/

DWORD
WINAPI
GetWindowRegionData(
    HWND hwnd,
    DWORD size,
    LPRGNDATA prd
)
{
    HDC hdc;
    DWORD dwRet = 0;

    hdc = GetDC(hwnd);
    if (hdc)
    {
        dwRet = GetDCRegionData(hdc, size, prd);
        ReleaseDC(hwnd, hdc);
    }

    return dwRet;
}

/******************************Public*Routine******************************\
* GetDCRegionData
*
* History:
\**************************************************************************/

DWORD
WINAPI GetDCRegionData(
    HDC hdc,
    DWORD size,
    LPRGNDATA prd
)
{
    HRGN hrgn;
    DWORD num;
    LPRGNDATA lpdata;

    hrgn = CreateRectRgn(0, 0, 0, 0);
    
    if (hrgn == NULL) {
	WARNING("GetDCRegionData - CreateRectRgn failed.\n");
	return 0;
    }

    GetRandomRgn(hdc, hrgn, 4);

    num = GetRegionData(hrgn, size, prd);

    DeleteObject(hrgn);
    
    return num;
}


/******************************Public*Routine******************************\
* WinWatchNotify
*
* History:
\**************************************************************************/


BOOL
WINAPI
WinWatchNotify(
    HWINWATCH hWW,
    WINWATCHNOTIFYPROC NotifyCallback,
    LPARAM NotifyParam
)
{
    return FALSE;
}

/******************************Private*Routine*****************************\
* bDisplayModeChanged
*
* History:  9-Feb-1999 John Stephens [johnstep] wrote it.
\**************************************************************************/

static BOOL bDisplayModeChanged(PDCIMAN_SURF pPrivate)
{
    LPDCISURFACEINFO lpSurface;
    DDHALINFO HalInfo;
    
    lpSurface = (LPDCISURFACEINFO) (pPrivate + 1);
    if (DdQueryDirectDrawObject(&pPrivate->DirectDrawGlobal,
                                &HalInfo,
                                NULL,
                                NULL,
                                NULL,
                                NULL, NULL, NULL, NULL,
                                NULL,
                                NULL))
    {

        return
            (lpSurface->dwWidth    != HalInfo.vmiData.dwDisplayWidth) ||
            (lpSurface->dwHeight   != HalInfo.vmiData.dwDisplayHeight) ||
            (lpSurface->lStride    != HalInfo.vmiData.lDisplayPitch) ||
            (lpSurface->dwBitCount != HalInfo.vmiData.ddpfDisplay.dwRGBBitCount);
    }

    //
    // If we cannot even query the DirectDraw object, then we cannot make any
    // assumptions about the current display mode, so it may have changed.
    //
    
    return TRUE;
}

/******************************Public*Routine******************************\
* DciBeginAccess
*
* History:
\**************************************************************************/

DCIRVAL
WINAPI
DCIBeginAccess(
    LPDCISURFACEINFO lpSurface,
    int x,
    int y,
    int dx,
    int dy
)
{
    DCIRVAL iRet;
    PDCIMAN_SURF pPrivate;
    DDHAL_LOCKDATA LockData;
    BOOL NewMode;
    PWINWATCH pwatch;

    iRet = DCI_FAIL_GENERIC;

    pPrivate = ((PDCIMAN_SURF) lpSurface) - 1;

    __try
    {
	//
	// Fail if the mode changed.
	//

	if (pPrivate->SurfaceLost)
	{
	    return DCI_FAIL_INVALIDSURFACE;
	}

	LockData.lpDD         = &pPrivate->DirectDrawGlobal;
	LockData.lpDDSurface  = &pPrivate->SurfaceLocal;
	LockData.bHasRect     = TRUE;
	LockData.rArea.left   = x;
	LockData.rArea.top    = y;
	LockData.rArea.right  = x + dx;
	LockData.rArea.bottom = y + dy;
	LockData.dwFlags      = DDLOCK_SURFACEMEMORYPTR;

	//
	// The DCI specification says we could return DCI_STATUS_WASSTILLDRAWING
	// if the accelerator was still busy, but the previous release of DCI on
	// Windows NT 3.51 did not support that feature, so we will endeavor to
	// remain backwards compatible and do the wait explicitly on behalf of
	// the application.
	//

    Try_Again:

	do {

	    //
	    // Hold the DCI critical section while calling the kernel to do the
	    // lock because the kernel surface lock API does not have waiting
	    // semantics; it will fail if another thread is currently in the
	    // kernel locking the same surface.  This is the expected behaviour
	    // for DirectDraw, but some clients of DCI -- OpenGL in particular --
	    // do not expect this.  So we will protect them against themselves
	    // by acquiring the WinWatch lock before calling the kernel.
	    //
	    // This lock is also needed for traversing the WinWatchList.
	    //

	    EnterCriticalSection(&gcsWinWatchLock);

	    do {
		pPrivate->DDSurfaceCallbacks.Lock(&LockData);

	    } while (LockData.ddRVal == DDERR_WASSTILLDRAWING);

	    if (LockData.ddRVal == DDERR_VISRGNCHANGED)
	    {
		if (!DdResetVisrgn(&pPrivate->SurfaceLocal, (HWND) -1))
		{
		    WARNING("DCIBeginAccess - ResetVisRgn failed\n");
		}

		//
		// The VisRgn has changed, and we can't be sure what window it
		// was for.  So we'll mark all WinWatches as having dirty VisRgns.
		// This effect of this is that some of the WinWatches will have to
		// re-download their clipping information when they don't really
		// have to because their specific window has not changed.
		//
		// Note that the WinWatchLock must be held here.
		//

		for (pwatch = gpWinWatchList;
		     pwatch != NULL;
		     pwatch = pwatch->pWinWatchNext)
		{
		    pwatch->changed = TRUE;
		}
	    }

	    LeaveCriticalSection(&gcsWinWatchLock);

	} while (LockData.ddRVal == DDERR_VISRGNCHANGED);

	//
	// 'Surface Lost' means that some sort of mode change occured, and
	// we have to re-enable DirectDraw.
	//

	if (LockData.ddRVal == DDERR_SURFACELOST)
	{
	    if (!DdReenableDirectDrawObject(&pPrivate->DirectDrawGlobal,
					    &NewMode))
	    {
		//
		// We're still in full-screen mode:
		//

		iRet = DCI_ERR_SURFACEISOBSCURED;
	    }
	    else
	    {
                if (!bDisplayModeChanged(pPrivate))
                {
		    //
		    // We switched back to the same mode.  Now that we've re-enabled
		    // DirectDraw, we can try again:
		    //

		    bDestroySurface(pPrivate);
		    if (bCreateSurface(pPrivate) &&
			DdResetVisrgn(&pPrivate->SurfaceLocal, (HWND) -1))
		    {
			goto Try_Again;
		    }
		    else
		    {
			WARNING("DCIBeginAccess - couldn't recreate surface.\n");
		    }
		}

		//
		// We can't reenable the surface, perhaps because a resolution
		// switch or colour depth change occured.  Mark this surface as
		// unusable -- the application will have to reinitialize:
		//

		pPrivate->SurfaceLost = TRUE;
		iRet = DCI_FAIL_INVALIDSURFACE;

		//
		// Unmap the frame buffer now:
		//

                if (!bDestroySurface(pPrivate) ||
		    !DdDeleteDirectDrawObject(&pPrivate->DirectDrawGlobal))
		{
		    WARNING("DCIBeginAccess - failed to delete surface.\n");
		}
	    }
	}

	if (LockData.ddRVal == DD_OK)
	{
	    //
	    // Return the pointer to the frame buffer in the DCI structure.
	    // We always return DCI_STATUS_POINTERCHANGED because it's possible
	    // that the Lock() call mapped the frame buffer to a different
	    // virtual address than it was previously.
	    //

	    lpSurface->wSelSurface = 0;

	    //
	    // DirectDraw has a goofy convention where it returns a pointer to
	    // the upper-left corner of the specified rectangle.  We have to
	    // undo that for DCI:
	    //

	    lpSurface->dwOffSurface = (ULONG_PTR) LockData.lpSurfData
		- (y * lpSurface->lStride)
		- (x * (lpSurface->dwBitCount >> 3));

	    iRet = DCI_STATUS_POINTERCHANGED;
	}
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        WARNING("DCIBeginAccess - exception caused by invalid surface pointer.\n");
	return DCI_FAIL_GENERIC;
    }

    return iRet;
}

/******************************Public*Routine******************************\
* DciEndAccess
*
* History:
\**************************************************************************/

void
WINAPI
DCIEndAccess(
    LPDCISURFACEINFO pdci
)
{
    DDHAL_UNLOCKDATA UnlockData;
    PDCIMAN_SURF pPrivate = ((PDCIMAN_SURF) pdci) - 1;

    __try
    {
	if (!(pPrivate->SurfaceLost))
	{
	    UnlockData.lpDD        = &pPrivate->DirectDrawGlobal;
	    UnlockData.lpDDSurface = &pPrivate->SurfaceLocal;

	    //
	    // For the same reasons as stated in DCIBeginAccess, protect against
	    // two threads trying to unlock the same surface at the same time
	    // in kernel -- kernel would simply fail the call instead of waiting,
	    // and DCI apps won't expect that.
	    //

	    EnterCriticalSection(&gcsWinWatchLock);

	    pPrivate->DDSurfaceCallbacks.Unlock(&UnlockData);

	    LeaveCriticalSection(&gcsWinWatchLock);

	    if (UnlockData.ddRVal != DD_OK)
	    {
		WARNING("DCIEndAccess - failed Unlock\n");
	    }
	}

	//
	// The application shouldn't try to access the frame buffer after
	// after having called EndAccess.
	//

	pdci->wSelSurface = 0;
	pdci->dwOffSurface = 0;
    }
    __except(EXCEPTION_EXECUTE_HANDLER)
    {
        WARNING("DCIEndAccess - exception caused by invalid surface pointer.\n");
    }
}

/******************************Public*Routine******************************\
* DciDestroy
*
* History:
\**************************************************************************/

void
WINAPI
DCIDestroy(
    LPDCISURFACEINFO pdci
)
{
    PDCIMAN_SURF pPrivate;

    if (pdci != NULL)
    {
        pPrivate = ((PDCIMAN_SURF) pdci) - 1;

        if (!(pPrivate->SurfaceLost))
        {
	    DDHAL_DESTROYSURFACEDATA dsd;

	    dsd.lpDD = pPrivate->SurfaceGlobal.lpDD;
	    dsd.lpDDSurface = &pPrivate->SurfaceLocal;
	    dsd.ddRVal = DDERR_GENERIC;
	    dsd.DestroySurface = pPrivate->DDSurfaceCallbacks.DestroySurface;

	    if (!(pPrivate->DDSurfaceCallbacks.dwFlags & DDHAL_SURFCB32_DESTROYSURFACE) ||
		(dsd.DestroySurface == NULL) ||
		((*dsd.DestroySurface)(&dsd) != DDHAL_DRIVER_HANDLED) ||
                !DdDeleteDirectDrawObject(&pPrivate->DirectDrawGlobal))
            {
                WARNING("DCIDestroy - failed to delete surface.\n");
            }
        }

        LocalFree(pPrivate);
    }
}

DCIRVAL
WINAPI
DCIDraw(
    LPDCIOFFSCREEN pdci
)
{
    return DCI_FAIL_UNSUPPORTED;
}

DCIRVAL
WINAPI
DCISetClipList(
    LPDCIOFFSCREEN pdci,
    LPRGNDATA prd
)
{
    return DCI_FAIL_UNSUPPORTED;
}

DCIRVAL
WINAPI
DCISetDestination(
    LPDCIOFFSCREEN pdci,
    LPRECT dst,
    LPRECT src
)
{
    return DCI_FAIL_UNSUPPORTED;
}


DCIRVAL
WINAPI
DCISetSrcDestClip(
    LPDCIOFFSCREEN pdci,
    LPRECT srcrc,
    LPRECT destrc,
    LPRGNDATA prd
)
{
    return DCI_FAIL_UNSUPPORTED;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\debug\gdiview\gdiview.cpp ===
#include <windows.h>
#include <tchar.h>

#include <stdio.h>

#include <dbgeng.h>

#include "debug.h"
#include "output.h"

typedef HRESULT (CALLBACK* PDEBUG_EXTENSION_SET_CLIENT)(LPCSTR RemoteArgs);

#if DBG
CHAR    szDefaultExtPath[] = "\\\\JasonHa\\DbgExts\\gdikdxd";
#else
CHAR    szDefaultExtPath[] = "\\\\JasonHa\\DbgExts\\gdikdxr";
#endif

HMODULE         ghGDIExt = NULL;
PDEBUG_CONTROL  Control = NULL;
BOOL            Continue = TRUE;
PCSTR           gRemoteSpec = NULL;
PCSTR           gMainExtPath = szDefaultExtPath;


HMODULE LoadExtension(PDEBUG_CLIENT Client, PCSTR ExtPath);
BOOL FreeExtension(PDEBUG_CLIENT, HMODULE hExt);
VOID ProcessCommands(PDEBUG_CLIENT Client, OutputMonitor *Monitor);
VOID SetOutputCmd(OutputMonitor *Monitor, const char *Args);
BOOL CtrlHandler(DWORD fdwCtrlType);


int __cdecl main(int argc, char** argv)
{
    HRESULT hr;
    BOOL    CtrlHandlerSet;

    PDEBUG_CLIENT   Client = NULL;

    OutputMonitor   Monitor;

    if (argc < 2)
    {
        printf("Missing remote specification.\n");
        return 1;
    }

    if (argc > 3)
    {
        printf("Too many arguments.\n");
        return 1;
    }

    gRemoteSpec = argv[1];

    if ((hr = DebugConnect(gRemoteSpec,  __uuidof(IDebugClient), (void **)&Client)) != S_OK ||
        Client == NULL)
    {
        printf("Couldn't connect to client: %s, HRESULT: 0x%lx\n", argv[1], hr);
        return 2;
    }

    if ((hr = Client->QueryInterface(__uuidof(IDebugControl), (void **)&Control)) != S_OK ||
        Control == NULL)
    {
        printf("Couldn't connect to IDebugControl, HRESULT: 0x%lx\n", hr);
        Client->Release();
        return 3;
    }

    if ((hr = Monitor.Monitor(Client,
                              DEBUG_OUTPUT_NORMAL |
                              DEBUG_OUTPUT_ERROR |
                              DEBUG_OUTPUT_WARNING// | DEBUG_OUTPUT_VERBOSE
                              )) != S_OK)
    {
        printf("Output monitor setup failed, HRESULT: 0x%lx\n", hr);
        Control->Release();
        Client->Release();
        return 4;
    }

    CtrlHandlerSet = SetConsoleCtrlHandler(
                        (PHANDLER_ROUTINE) CtrlHandler, // handler function
                        TRUE);                          // add to list

    if ((hr = Client->ConnectSession(DEBUG_CONNECT_SESSION_NO_VERSION, 0)) != S_OK)
    {
        printf("Couldn't finalize connection.  HRESULT 0x%lx\n", hr);
    }
    else
    {
        if (argc > 2)
        {
            gMainExtPath = argv[2];
        }

        ghGDIExt = LoadExtension(Client, gMainExtPath);

        if (ghGDIExt != NULL)
        {
            ProcessCommands(Client, &Monitor);

            FreeExtension(Client, ghGDIExt);
        }

        Control->Output(DEBUG_OUTPUT_NORMAL, "GDIView disconnecting.\n");
    }

    if (CtrlHandlerSet)
    {
        SetConsoleCtrlHandler(
            (PHANDLER_ROUTINE) CtrlHandler, // handler function
            FALSE);                         // remove from list
    }

    Control->Release();
    Client->Release();

    return 0;
}


HMODULE
LoadExtension(
    PDEBUG_CLIENT Client,
    PCSTR ExtPath
    )
{
    HMODULE hExt = NULL;
    BOOL    bInitComplete = FALSE;

    PDEBUG_CONTROL2 Control2;
    ULONG           Status = DEBUG_STATUS_BREAK;

    if (Client->QueryInterface(__uuidof(IDebugControl2),
                               (void **)&Control2) == S_OK)
    {
        Control2->GetExecutionStatus(&Status);
        Control2->Release();
    }

    if (Status != DEBUG_STATUS_NO_DEBUGGEE)
    {
        if ((hExt = LoadLibraryA(ExtPath)) != NULL)
        {
            PDEBUG_EXTENSION_SET_CLIENT     pfnDbgExtSetClient;
            PDEBUG_EXTENSION_INITIALIZE     pfnDbgExtInit;
            PDEBUG_EXTENSION_NOTIFY         pfnDbgExtNotify;
            PDEBUG_EXTENSION_UNINITIALIZE   pfnDbgExtUninit;

            pfnDbgExtSetClient = (PDEBUG_EXTENSION_SET_CLIENT)
                GetProcAddress(hExt, "DebugExtensionSetClient");
            pfnDbgExtInit = (PDEBUG_EXTENSION_INITIALIZE)
                GetProcAddress(hExt, "DebugExtensionInitialize");
            pfnDbgExtNotify = (PDEBUG_EXTENSION_NOTIFY)
                GetProcAddress(hExt, "DebugExtensionNotify");
            pfnDbgExtUninit = (PDEBUG_EXTENSION_UNINITIALIZE)
                GetProcAddress(hExt, "DebugExtensionUninitialize");

            if ((pfnDbgExtSetClient != NULL) &&
                (pfnDbgExtInit != NULL) &&
                (pfnDbgExtNotify != NULL) &&
                (pfnDbgExtUninit != NULL))
            {
                HRESULT hr;
                ULONG   Version, Flags;

                if ((hr = pfnDbgExtSetClient(gRemoteSpec) == S_OK) &&
                    (hr = pfnDbgExtInit(&Version, &Flags)) == S_OK)
                {
                    pfnDbgExtNotify(DEBUG_NOTIFY_SESSION_ACTIVE, 0);

                    if (Status == DEBUG_STATUS_BREAK)
                    {
                        pfnDbgExtNotify(DEBUG_NOTIFY_SESSION_ACCESSIBLE, 0);
                    }

                    bInitComplete = TRUE;
                }
                else
                {
                    printf("Extension init failed: 0x%lx\n", hr);
                }
            }
            else
            {
                printf("Couldn't get all required proc addresses.\n");
            }

            if (!bInitComplete)
            {
                FreeExtension(Client, hExt);
                hExt = NULL;
            }
        }
        else
        {
            printf("LoadLibrary for %s failed with 0x%lx.\n",
                   ExtPath, GetLastError());
        }
    }
    else
    {
        printf("Extension was not loaded since there is no debuggee.\n");
    }

    return hExt;
}


BOOL
FreeExtension(
    PDEBUG_CLIENT Client,
    HMODULE hExt
    )
{
    PDEBUG_EXTENSION_UNINITIALIZE   pfnDbgExtUninit;

    if (hExt == NULL) return FALSE;

    pfnDbgExtUninit = (PDEBUG_EXTENSION_UNINITIALIZE)
        GetProcAddress(ghGDIExt, "DebugExtensionUninitialize");

    if (pfnDbgExtUninit != NULL)
    {
        pfnDbgExtUninit();
    }

    return FreeLibrary(hExt);
}


VOID
ProcessCommands(
    PDEBUG_CLIENT Client,
    OutputMonitor *Monitor)
{
    PDEBUG_CONTROL  DbgControl;
    CHAR    CmdLine[MAX_PATH];
    CHAR   *pCmd;
    CHAR   *pArgs;
    PDEBUG_EXTENSION_CALL pfnDbgExt;

    if (Client == NULL ||
        Client->QueryInterface(__uuidof(IDebugControl), (void **)&DbgControl) != S_OK)
    {
        return;
    }

    while (Continue)
    {
        printf("GDIView> ");

        if (gets(CmdLine))
        {
            pCmd = CmdLine;
            while (*pCmd && isspace(*pCmd)) pCmd++;

            if (! *pCmd) continue;

            if (*pCmd == '.')
            {
                BOOL    FoundCmd = FALSE;

                pCmd++;

                switch (tolower(*pCmd))
                {
                    case 'h':
                        if (_strnicmp(pCmd, "help", strlen(pCmd)) == 0)
                        {
                            printf("GDIView Help:\n"
                                   " .help      This help\n"
                                   " .output    Display/toggle output filtering\n"
                                   " .quit      Exit GDIView\n"
                                   "\n"
                                   " <GDIKDX Extension>     Execute GDIKDX Extension\n"
                                   " help                   GDIKDX help information\n");
                            FoundCmd = TRUE;
                        }
                        break;
                    case 'q':
                        if (_strnicmp(pCmd, "quit", strlen(pCmd)) == 0)
                        {
                            Continue = FALSE;
                            FoundCmd = TRUE;
                        }
                        break;
                    case 'o':
                    {
                        ULONG CmdLen;

                        pArgs = pCmd;
                        do
                        {
                            pArgs++;
                        } while (*pArgs != '\0' && !isspace(*pArgs));

                        if (_strnicmp(pCmd, "output", pArgs - pCmd) == 0)
                        {
                            SetOutputCmd(Monitor, pArgs);
                            FoundCmd = TRUE;
                        }
                        break;
                    }
                    default:
                        break;
                }

                if (!FoundCmd)
                {
                    printf("Unknown internal command: .%s\n", pCmd);
                }
            }
            else
            {
                pArgs = pCmd;
                while (*pArgs && !isspace(*pArgs)) pArgs++;
                if (*pArgs)
                {
                    *pArgs++ = '\0';
                    while (*pArgs && isspace(*pArgs)) pArgs++;
                }

                pfnDbgExt = (PDEBUG_EXTENSION_CALL)GetProcAddress(ghGDIExt, pCmd);
                if (pfnDbgExt != NULL)
                {
                    DbgControl->ControlledOutput(DEBUG_OUTCTL_ALL_OTHER_CLIENTS,
                                                 DEBUG_OUTPUT_NORMAL,
                                                 "GDIView> !%s.%s %s\n",
                                                 gMainExtPath,
                                                 pCmd,
                                                 pArgs);

                    pfnDbgExt(Client, pArgs);
                }
                else
                {
                    printf("Couldn't find extension: %s\n", pCmd);
                }
            }
        }
    }

    DbgControl->Release();
}


VOID
SetOutputCmd(
    OutputMonitor *Monitor,
    const char *Args
    )
{
    HRESULT hr;
    ULONG   OutputMask;
    ULONG   NewMask;
    ULONG   ToggleMask;
    BOOL    Clear = FALSE;

    if (Monitor == NULL) return;

    hr = Monitor->GetOutputMask(&OutputMask);
    if (hr != S_OK)
    {
        printf("Failed to retrieve Monitor's output mask.\n");
        return;
    }
    NewMask = OutputMask;

    while (isspace(*Args)) Args++;

    while (hr == S_OK && *Args != '\0')
    {
        switch (tolower(*Args))
        {
            case '+': Clear = FALSE; ToggleMask = 0; break;
            case '-': Clear = TRUE; ToggleMask = 0; break;
            case 'n': ToggleMask |= DEBUG_OUTPUT_NORMAL; break;
            case 'e': ToggleMask |= DEBUG_OUTPUT_ERROR; break;
            case 'w': ToggleMask |= DEBUG_OUTPUT_WARNING; break;
            case 'v': ToggleMask |= DEBUG_OUTPUT_VERBOSE; break;
            case '?':
                printf("Usage: .output [+-][newv]\n");
                return;
            default: hr = E_INVALIDARG; break;
        }
        Args++;

        if (*Args == '\0' || isspace(*Args))
        {
            if (Clear)
            {
                NewMask &= ~ToggleMask;
            }
            else
            {
                NewMask |= ToggleMask;
            }

            while (isspace(*Args)) Args++;
        }
    }

    if (hr != S_OK)
    {
        printf("Invalid arguments to .output.\n");
    }
    else if (NewMask != OutputMask)
    {
        hr = Monitor->SetOutputMask(NewMask);
        if (hr == S_OK)
        {
            OutputMask = NewMask;
        }
        else
        {
            printf("Error while trying to set new monitor mask.\n");
        }
    }

    printf("Monitoring:");
    if (OutputMask & DEBUG_OUTPUT_NORMAL) printf(" Normal");
    if (OutputMask & DEBUG_OUTPUT_ERROR) printf(" Error");
    if (OutputMask & DEBUG_OUTPUT_WARNING) printf(" Warning");
    if (OutputMask & DEBUG_OUTPUT_VERBOSE) printf(" Verbose");

    OutputMask &= ~(DEBUG_OUTPUT_NORMAL | DEBUG_OUTPUT_ERROR |
                    DEBUG_OUTPUT_WARNING | DEBUG_OUTPUT_VERBOSE);
    if (OutputMask) printf(" Other: 0x%lx", OutputMask);

    printf("\n");
}


// CtrlHandler - process Console Control signals
//
// Note: Global Control must be available whenever
//       CtrlHandler is registered.

BOOL CtrlHandler(DWORD fdwCtrlType)
{
    switch (fdwCtrlType)
    {
        // Handle the CTRL+C and CTRL+Break signals.

        case CTRL_C_EVENT:

        case CTRL_BREAK_EVENT:

            Control->SetInterrupt(DEBUG_INTERRUPT_PASSIVE);
            return TRUE;


        // User wants to exit.

        case CTRL_CLOSE_EVENT:

        case CTRL_LOGOFF_EVENT:

        case CTRL_SHUTDOWN_EVENT:

            Continue = FALSE;
            Control->SetInterrupt(DEBUG_INTERRUPT_EXIT);
            return TRUE;


        // Pass other signals to the next handler.

        default:

            return FALSE;
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\debug\gdiview\output.cpp ===
/*++

Copyright (c) 2000  Microsoft Corporation

Module Name:

    output.cpp

Abstract:

    This file contains routines and classes
    to handle output.

Author:

    Jason Hartman (JasonHa) 2000-10-16

Environment:

    User Mode

--*/

#include <stdio.h>

#include <dbgeng.h>

#include "debug.h"
#include "output.h"

#define HISTORY_LENGTH  2048

typedef struct {
    PDEBUG_CLIENT   MonitorClient;  // To be set by created thread
    PDEBUG_CLIENT   Client;
    ULONG           OutputMask;
} MonitorThreadParams;

DWORD WINAPI OutputMonitorThread(MonitorThreadParams *);


HRESULT
OutputMonitor::Monitor(
    PDEBUG_CLIENT ClientToMonitor,
    ULONG OutputMask
    )
{
    Client = ClientToMonitor;

    if (Client == NULL) return S_FALSE;

    Client->AddRef();

    MonitorThreadParams  NewThreadParams = { NULL, Client, OutputMask };
    HANDLE  hThread;
    DWORD   ThreadID = 0;

    hThread = CreateThread(NULL,
                           0,
                           (LPTHREAD_START_ROUTINE)OutputMonitorThread,
                           &NewThreadParams,
                           0,
                           &ThreadID);

    if (hThread)
    {
        while (NewThreadParams.MonitorClient == NULL)
        {
            DWORD ExitCode = 0;
            if (!GetExitCodeThread(hThread, &ExitCode))
                DbgPrint("GetExitCodeThread returned error %lx.\n", GetLastError());
            if (ExitCode != STILL_ACTIVE)
            {
                ThreadID = 0;
                break;
            }

            SleepEx(10, TRUE);
        }

        CloseHandle(hThread);
    }

    MonitorClient = NewThreadParams.MonitorClient;

    return (MonitorClient != NULL) ? S_OK : S_FALSE;
}


HRESULT
OutputMonitor::GetOutputMask(
    PULONG OutputMask
    )
{
    HRESULT hr = S_FALSE;

    if (Client != NULL &&
        MonitorClient != NULL)
    {
        hr = Client->GetOtherOutputMask(MonitorClient, OutputMask);
    }

    return hr;
}


HRESULT
OutputMonitor::SetOutputMask(
    ULONG OutputMask
    )
{
    HRESULT hr = S_FALSE;

    if (Client != NULL &&
        MonitorClient != NULL)
    {
        hr = Client->SetOtherOutputMask(MonitorClient, OutputMask);
    }

    return hr;
}


OutputMonitor::~OutputMonitor()
{
    if (Client)
    {
        if (MonitorClient)
        {
            Client->ExitDispatch(MonitorClient);
        }

        Client->Release();
    }
}


DWORD
WINAPI
OutputMonitorThread(
    MonitorThreadParams *Params
    )
{
    HRESULT                 hr = S_FALSE;
    PDEBUG_CLIENT           MonitorClient;
    PrintOutputCallbacks    PrintCallbacks;

    if (Params != NULL &&
        Params->Client != NULL &&
        (hr = Params->Client->CreateClient(&MonitorClient)) == S_OK)
    {
        if ((hr = MonitorClient->SetOutputMask(Params->OutputMask |
                                               DEBUG_OUTPUT_PROMPT |
                                               DEBUG_OUTPUT_PROMPT_REGISTERS |
                                               DEBUG_OUTPUT_DEBUGGEE |
                                               DEBUG_OUTPUT_DEBUGGEE_PROMPT
                                               )) == S_OK &&
            (hr = MonitorClient->SetOutputCallbacks(&PrintCallbacks)) == S_OK)
        {
            if ((hr = MonitorClient->ConnectSession(DEBUG_CONNECT_SESSION_NO_ANNOUNCE, HISTORY_LENGTH)) != S_OK)
            {
                printf("Couldn't get debugger version/history: HRESULT 0x%lx\n", hr);
            }

            MonitorClient->SetOutputMask(Params->OutputMask);

            Params->MonitorClient = MonitorClient;
            hr = MonitorClient->DispatchCallbacks(INFINITE);
        }
        else
        {
            printf("Output callbacks setup failed, HRESULT: 0x%lx\n", hr);
        }

        MonitorClient->Release();
    }

    DbgPrint("OutputMonitorThread calling ExitThread().\n");

    ExitThread((DWORD)hr);
}



//----------------------------------------------------------------------------
//
// Default output callbacks implementation, provides IUnknown for
// static classes.
//
//----------------------------------------------------------------------------

STDMETHODIMP
PrintOutputCallbacks::QueryInterface(
    THIS_
    IN REFIID InterfaceId,
    OUT PVOID* Interface
    )
{
    *Interface = NULL;

    if (//(InterfaceId == IID_IUnknown) ||
        (InterfaceId == __uuidof(IDebugOutputCallbacks)))
    {
        *Interface = (IDebugOutputCallbacks *)this;
        AddRef();
        return S_OK;
    }
    else
    {
        return E_NOINTERFACE;
    }
}

STDMETHODIMP_(ULONG)
PrintOutputCallbacks::AddRef(
    THIS
    )
{
    // This class is designed to be static so
    // there's no true refcount.
    return 1;
}

STDMETHODIMP_(ULONG)
PrintOutputCallbacks::Release(
    THIS
    )
{
    // This class is designed to be static so
    // there's no true refcount.
    return 0;
}

STDMETHODIMP
PrintOutputCallbacks::Output(
    THIS_
    IN ULONG Mask,
    IN PCSTR Text
    )
{
    printf("%s", Text);
    return S_OK;
}






#if 0
// Stuff we probably don't need

OutputMonitor::OutputMonitor(
    PDEBUG_CLIENT DbgClient
    )
{
    Client = DbgClient;

    if (Client != NULL)
    {
        Client->AddRef();
    }

    Saved = FALSE;
}


HRESULT
OutputMonitor::Setup(
    ULONG OutMask,
    PDEBUG_OUTPUT_CALLBACKS OutCallbacks
    )
{
    HRESULT Hr = S_FALSE;
    ULONG   LastOutMask;
    PDEBUG_CLIENT f;

    if (Client == NULL)
    {
        return Hr;
    }

    if (!Saved)
    {
        if ((Hr = Client->GetOutputMask(&OrgOutMask)) != S_OK ||
            (Hr = Client->GetOutputCallbacks(&OrgOutCallbacks)) != S_OK)
        {
            return Hr;
        }

        Saved = TRUE;
    }

    if ((Hr = Client->GetOutputMask(&LastOutMask)) == S_OK &&
        (Hr = Client->SetOutputMask(OutMask)) == S_OK)
    {
        if ((Hr = Client->SetOutputCallbacks(OutCallbacks)) != S_OK)
        {
            Client->SetOutputMask(LastOutMask);
        }
    }

    return Hr;
}


HRESULT
OutputMonitor::Execute(
    PCSTR pszCommand
    )
{
    HRESULT         hr = S_FALSE;
    PDEBUG_CONTROL  DbgControl;

    if (Client != NULL &&
        (hr = Client->QueryInterface(__uuidof(IDebugControl),
                                     (void **)&DbgControl)) == S_OK)
    {
        hr = DbgControl->Execute(DEBUG_OUTCTL_THIS_CLIENT |
                                 DEBUG_OUTCTL_OVERRIDE_MASK,
                                 pszCommand,
                                 DEBUG_EXECUTE_NO_REPEAT);

        DbgControl->Release();
    }

    return hr;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\bmfd\fdquery.c ===
/******************************Module*Header*******************************\
* Module Name: fdquery.c
*
* (Brief description)
*
* Created: 08-Nov-1990 11:57:35
* Author: Bodin Dresevic [BodinD]
*
* Copyright (c) 1990 Microsoft Corporation
\**************************************************************************/
#include "fd.h"

ULONG
cjBmfdDeviceMetrics (
    PFONTCONTEXT     pfc,
    FD_DEVICEMETRICS *pdevm
    );

VOID
vStretchCvtToBitmap
(
    GLYPHBITS *pgb,
    PBYTE pjBitmap,     // bitmap in *.fnt form
    ULONG cx,           // unscaled width
    ULONG cy,           // unscaled height
    ULONG yBaseline,
    PBYTE pjLineBuffer, // preallocated buffer for use by stretch routines
    ULONG cxScale,      // horizontal scaling factor
    ULONG cyScale,      // vertical scaling factor
    ULONG flSim         // simulation flags
);

#ifdef FE_SB // Rotation
VOID
vFill_RotateGLYPHDATA (
    GLYPHDATA *pDistinationGlyphData,
    PVOID      SourceGLYPHBITS,
    PVOID      DistinationGLYPHBITS,
    UINT       RotateDegree
    );
#endif

/******************************Public*Routine******************************\
* BmfdQueryFont
*
* Returns:
*   Pointer to IFIMETRICS.  Returns NULL if an error occurs.
*
* History:
*  30-Aug-1992 -by- Gilman Wong [gilmanw]
* IFI/DDI merge.
*
*  19-Nov-1990 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

PIFIMETRICS
BmfdQueryFont (
    DHPDEV dhpdev,
    HFF    hff,
    ULONG  iFace,
    ULONG_PTR  *pid
    )
{
    FACEINFO   *pfai;

    DONTUSE(dhpdev);
    DONTUSE(pid);

//
// Validate handle.
//
    if (hff == HFF_INVALID)
        return (PIFIMETRICS) NULL;

//
// We assume the iFace is within range.
//
    ASSERTGDI(
        (iFace >= 1L) && (iFace <= PFF(hff)->cFntRes),
        "gdisrv!BmfdQueryFont: iFace out of range\n"
        );

//
// Get ptr to the appropriate FACEDATA struct, take into account that
// iFace values are 1 based.
//
    pfai = &PFF(hff)->afai[iFace - 1];

//
// Return the pointer to IFIMETRICS.
//
    return pfai->pifi;
}


/******************************Public*Routine******************************\
* BmfdQueryFontTree
*
* This function returns pointers to per-face information.
*
* Parameters:
*
*   dhpdev      Not used.
*
*   hff         Handle to a font file.
*
*   iFace       Index of a face in the font file.
*
*   iMode       This is a 32-bit number that must be one of the following
*               values:
*
*       Allowed ulMode values:
*       ----------------------
*
*       QFT_LIGATURES -- returns a pointer to the ligature map.
*
*       QFT_KERNPAIRS -- return a pointer to the kerning pair table.
*
*       QFT_GLYPHSET  -- return a pointer to the WC->HGLYPH mapping table.
*
*   pid         Not used.
*
* Returns:
a   Returns a pointer to the requested data.  This data will not change
*   until BmfdFree is called on the pointer.  Caller must not attempt to
*   modify the data.  NULL is returned if an error occurs.
*
* History:
*  30-Aug-1992 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

PVOID
BmfdQueryFontTree (
    DHPDEV  dhpdev,
    HFF     hff,
    ULONG   iFace,
    ULONG   iMode,
    ULONG_PTR   *pid
    )
{
    FACEINFO   *pfai;

    DONTUSE(dhpdev);
    DONTUSE(pid);

//
// Validate parameters.
//
    if (hff == HFF_INVALID)
        return ((PVOID) NULL);

    // Note: iFace values are index-1 based.

    if ((iFace < 1L) || (iFace > PFF(hff)->cFntRes))
    {
    RETURN("gdisrv!BmfdQueryFontTree()\n", (PVOID) NULL);
    }

//
// Which mode?
//
    switch (iMode)
    {
    case QFT_LIGATURES:
    case QFT_KERNPAIRS:

    //
    // There are no ligatures or kerning pairs for the bitmap fonts,
    // therefore we return NULL
    //
        return ((PVOID) NULL);

    case QFT_GLYPHSET:

    //
    // Find glyphset structure corresponding to this iFace:
    //
        pfai = &PFF(hff)->afai[iFace - 1];

        return ((PVOID) &pfai->pcp->gset);

    default:

    //
    // Should never get here.
    //
    RIP("gdisrv!BmfdQueryFontTree(): unknown iMode\n");
        return ((PVOID) NULL);
    }
}

/******************************Public*Routine******************************\
*
* BOOL bReconnectBmfdFont(FONTFILE *pff)
*
*
* Effects: If the file is marked gone, we try to reconnect and see if we can
*          use it again. We clear the exception bit so that the system will
*          be able to use this font again.
*
* History:
*  17-Aug-1994 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/



BOOL bReconnectBmfdFont(FONTFILE *pff)
{
    INT i;
    PVOID pvView;
    COUNT cjView;

    EngAcquireSemaphore(ghsemBMFD);
    if (pff->fl & FF_EXCEPTION_IN_PAGE_ERROR)
    {
        if (!EngMapFontFileFD(pff->iFile, (PULONG*) &pvView, &cjView))
        {
            WARNING("BMFD! can not reconnect this bm font file!!!\n");
            EngReleaseSemaphore(ghsemBMFD);
            return FALSE;
        }

        for (i = 0; i < (INT)pff->cFntRes; i++)
        {
            pff->afai[i].re.pvResData = (PVOID) (
                (BYTE*)pvView + pff->afai[i].re.dpResData
                );
        }

    // everything is fine again, clear the bit

        pff->fl &= ~FF_EXCEPTION_IN_PAGE_ERROR;
    }
    EngReleaseSemaphore(ghsemBMFD);

    return TRUE;
}


/******************************Public*Routine******************************\
*
* Routine Name:
*
*   vBmfdScrubGLYPHBITS
*
* Routine Description:
*
*   This procedure will mask off the last byte of each row so that there
*   are no pixels set outside the boundary of the glyph. This problem
*   has been detected in a Bitstream font named ncd0018.fon.
*   This particular font is in the form of a 32-bit resource.
*   The problem came to light because the ATI driver relies
*   on the fact that the glyphs are "scrubbed" and contain no
*   extraneous bits, even outside the glyph boundary.
*
* Arguments:
*
*   pGb - a pointer to a GLYPHBITS structure
*
* Called by:
*
*   BmfdQueryFontData
*
* Return Value:
*
*   None.
*
\**************************************************************************/

void vBmfdScrubGLYPHBITS(GLYPHBITS *pGb)
{
    int dp;         // number of bytes in each scan
    int cx;         // number of pixels per row
    BYTE jMask;     // mask for last byte of each row;
    BYTE *pj;       // pointer to last byte of row;
    BYTE *pjLast;   // sentinel pointer
    static BYTE ajMonoMask[8] = {0x00, 0x80, 0xc0, 0xe0, 0xf0, 0xf8, 0xfc, 0xfe};

    cx = pGb->sizlBitmap.cx;
    if ( jMask = ajMonoMask[cx & 7] )
    {
        dp = (cx + 7) / 8;
        pj = pGb->aj + dp - 1;
        pjLast = pj + dp * pGb->sizlBitmap.cy;
        for ( ; pj < pjLast; pj += dp )
        {
            *pj &= jMask;
        }
    }
}

/******************************Public*Routine******************************\
* BmfdQueryFontData
*
*   pfo         Pointer to a FONTOBJ.
*
*   iMode       This is a 32-bit number that must be one of the following
*               values:
*
*       Allowed ulMode values:
*       ----------------------
*
*       QFD_GLYPH           -- return glyph metrics only
*
*       QFD_GLYPHANDBITMAP  -- return glyph metrics and bitmap
*
*       QFD_GLYPHANDOUTLINE -- return glyph metrics and outline
*
*       QFD_MAXEXTENTS      -- return FD_DEVICEMETRICS structure
*
*       QFD_MAXGLYPHBITMAP  -- return size of largest glyph AND its metrics
*
*   cData       Count of data items in the pvIn buffer.
*
*   pvIn        An array of glyph handles.
*
*   pvOut       Output buffer.
*
* Returns:
*   If mode is QFD_MAXGLYPHBITMAP, then size of glyph metrics plus
*   largest bitmap is returned.
*
*   Otherwise, if pvOut is NULL, function will return size of the buffer
*   needed to copy the data requested; else, the function will return the
*   number of bytes written.
*
*   FD_ERROR is returned if an error occurs.
*
* History:
*  30-Aug-1992 -by- Gilman Wong [gilmanw]
* Wrote it.  Contructed from pieces of BodinD's original
* BmfdQueryGlyphBitmap() and BmfdQueryOutline() functions.
\**************************************************************************/

LONG
BmfdQueryFontData (
    FONTOBJ *pfo,
    ULONG   iMode,
    HGLYPH  hg,
    GLYPHDATA *pgd,
    PVOID   pv,
    ULONG   cjSize
    )
{
    PFONTCONTEXT pfc;
    LONG         cjGlyphData = 0;
    LONG         cjAllData = 0;
    PCVTFILEHDR  pcvtfh;
    PBYTE        pjBitmap;  // raw bitmap in the resource file
    ULONG        cxNoSim;   // bm width in pels before simulations
    FWORD        sAscent;
#ifdef FE_SB // BmfdQueryFontData()
    PVOID        pvDst = NULL;
    LONG         cjGlyphDataNoRotate;
#endif // FE_SB

// The net connection died on us, but maybe it is alive again:

    if (!bReconnectBmfdFont(PFF(pfo->iFile)))
    {
        WARNING("bmfd!bmfdQueryFontData: this file is gone\n");
        return FD_ERROR;
    }

// If pfo->pvProducer is NULL, then we need to open a font context.
//
    if ( pfo->pvProducer == (PVOID) NULL )
        pfo->pvProducer = (PVOID) BmfdOpenFontContext(pfo);

    pfc = PFC(pfo->pvProducer);

    if ( pfc == (PFONTCONTEXT) NULL )
    {
        WARNING("gdisrv!bmfdQueryFontData(): cannot create font context\n");
        return FD_ERROR;
    }

// What mode?

    switch (iMode)
    {

    case QFD_GLYPHANDBITMAP:

    //
    // This code is left all inline for better performance.
    //
        pcvtfh = &(pfc->pfai->cvtfh);
        sAscent = pfc->pfai->pifi->fwdWinAscender;

        pjBitmap = pjRawBitmap(hg, pcvtfh, &pfc->pfai->re, &cxNoSim);

#ifdef FE_SB // BmfdQueryFontDate(): Compute size of RASTERGLYPH for ROTATION

    //
    // Compute the size of the RASTERGLYPH. ( GLYPHBITS structure size )
    //

    // Compute No Rotated GLYPHBITS size.

        cjGlyphDataNoRotate = cjGlyphDataSimulated (
                                pfo,
                                cxNoSim * pfc->ptlScale.x,
                                pcvtfh->cy * pfc->ptlScale.y,
                                (PULONG) NULL,
                                0L
                                );

    // Compute Rotated GLYPHBITS size.

        switch( pfc->ulRotate )
        {
            case 0L    :
            case 1800L :

                cjGlyphData = cjGlyphDataNoRotate;

                break;

            case 900L  :
            case 2700L :

                cjGlyphData = cjGlyphDataSimulated (
                                pfo,
                                cxNoSim * pfc->ptlScale.x,
                                pcvtfh->cy * pfc->ptlScale.y,
                                (PULONG) NULL,
                                pfc->ulRotate
                                );


                break;
        }

    //
    // Allocate Buffer for Rotation
    //

        if( pfc->ulRotate != 0L && pv != NULL )
        {

        //  We have to rotate this bitmap. below here , we keep data in temp Buffer
        // And will write this data into pv ,when rotate bitmap.
        //  We can't use original pv directly. Because original pv size is computed
        // for Rotated bitmap. If we use this. it may causes access violation.
        //              hideyukn 08-Feb-1993

        // Keep Master pv
            pvDst = pv;

        // Allocate New pv
            pv    = (PVOID)EngAllocMem(0, cjGlyphDataNoRotate, 'dfmB');

            if( pv == NULL )
            {
                 WARNING("BMFD:LocalAlloc for No Rotated bitmap is fail\n");
                 return( FD_ERROR );
            }

        }
        else
        {

        // This Routine is for at ulRotate != 0 && pv == NULL
        //
        // If User want to only GLYPHDATA , We do not do anything for glyphbits
        // at vFill_RotateGLYPHDATA
        //
        // pvDst is only used in case of ulRotate is Non-Zero
                 ;
        }
#else
    //
    // Compute the size of the RASTERGLYPH.
    //
        cjGlyphData = cjGlyphDataSimulated (
                            pfo,
                            cxNoSim * pfc->ptlScale.x,
                            pcvtfh->cy * pfc->ptlScale.y,
                            (PULONG) NULL
                            );
#endif

#ifdef FE_SB
    // !!!
    // !!! Following vComputeSimulatedGLYPHDATA function will set up GLYPHDATA
    // !!! structure with NO Rotation. If We want to Rotate bitmap , We have to
    // !!! re-setup this GLYPHDATA structure. Pls look into end of this function.
    // !!! But No need to ratate bitmap , We don't need to re-set up it.
    // !!!                          hideyukn 08-Feb-1993
    // !!!
#endif // FE_SB

    //
    // Fill in the GLYPHDATA portion (metrics) of the RASTERGLYPH.
    //
        if ( pgd != (GLYPHDATA *)NULL )
        {
            vComputeSimulatedGLYPHDATA (
                pgd,
                pjBitmap,
                cxNoSim,
                pcvtfh->cy,
                (ULONG)sAscent,
                pfc->ptlScale.x,
                pfc->ptlScale.y,
                pfo
                );
            pgd->hg = hg;
        }

    //
    // Fill in the bitmap portion of the RASTERGLYPH.
    //
        if ( pv != NULL )
        {
            if (cxNoSim == 0)
            {
            // stolen from ttfd:

                GLYPHBITS *pgb = (GLYPHBITS *)pv;

                pgb->ptlOrigin.x = 0;
                pgb->ptlOrigin.y = -sAscent;

                pgb->sizlBitmap.cx = 1;    // cheating
                pgb->sizlBitmap.cy = 1;    // cheating


                *((ULONG *)pgb->aj) = 0;  // fill in a blank 1x1 dib
            }
            else
            {

                if (pfc->flStretch & FC_DO_STRETCH)
                {
                    BYTE ajStretchBuffer[CJ_STRETCH];
                    if (pfc->flStretch & FC_STRETCH_WIDE)
                    {
                        EngAcquireSemaphore(ghsemBMFD);

                    // need to put try/except here so as to release the semaphore
                    // in case the file disappeares [bodind]

                        try
                        {
                            vStretchCvtToBitmap(
                                pv,
                                pjBitmap,
                                cxNoSim                 ,
                                pcvtfh->cy              ,
                                (ULONG)sAscent ,
                                pfc->ajStretchBuffer,
                                pfc->ptlScale.x,
                                pfc->ptlScale.y,
                                pfo->flFontType & (FO_SIM_BOLD | FO_SIM_ITALIC));
                        }
                        except (EXCEPTION_EXECUTE_HANDLER)
                        {
                            WARNING("bmfd! exception while stretching a glyph\n");
                            vBmfdMarkFontGone(
                                (FONTFILE *)pfc->hff,
                                GetExceptionCode()
                                );
                        }

                        EngReleaseSemaphore(ghsemBMFD);
                    }
                    else
                    {
                    // we are protected by higher level try/excepts

                        vStretchCvtToBitmap(
                            pv,
                            pjBitmap,
                            cxNoSim                 ,
                            pcvtfh->cy              ,
                            (ULONG)sAscent ,
                            ajStretchBuffer,
                            pfc->ptlScale.x,
                            pfc->ptlScale.y,
                            pfo->flFontType & (FO_SIM_BOLD | FO_SIM_ITALIC));
                    }
                }
                else
                {
                    switch (pfo->flFontType & (FO_SIM_BOLD | FO_SIM_ITALIC))
                    {
                    case 0:

                        vCvtToBmp(
                            pv                      ,
                            pgd                     ,
                            pjBitmap                ,
                            cxNoSim                 ,
                            pcvtfh->cy              ,
                            (ULONG)sAscent
                            );

                        break;

                    case FO_SIM_BOLD:

                        vCvtToBoldBmp(
                            pv                      ,
                            pgd                     ,
                            pjBitmap                ,
                            cxNoSim                 ,
                            pcvtfh->cy              ,
                            (ULONG)sAscent
                            );

                        break;

                    case FO_SIM_ITALIC:

                        vCvtToItalicBmp(
                            pv                      ,
                            pgd                     ,
                            pjBitmap                ,
                            cxNoSim                 ,
                            pcvtfh->cy              ,
                            (ULONG)sAscent
                            );

                        break;

                    case (FO_SIM_BOLD | FO_SIM_ITALIC):

                        vCvtToBoldItalicBmp(
                            pv                      ,
                            pgd                     ,
                            pjBitmap                ,
                            cxNoSim                 ,
                            pcvtfh->cy              ,
                            (ULONG)sAscent
                            );

                        break;

                    default:
                        RIP("BMFD!WRONG SIMULATION REQUEST\n");

                    }
                }
            }
            // Record the pointer to the RASTERGLYPH in the pointer table.

            if ( pgd != NULL )
            {
                pgd->gdf.pgb = (GLYPHBITS *)pv;
            }

            vBmfdScrubGLYPHBITS((GLYPHBITS*)pv);
        }

#ifdef FE_SB // BmfdQueryFontData(): Set up GLYPHDATA and GLYPHBITS for Rotation

        // Check rotation

        if( pfc->ulRotate != 0L )
        {

        // Rotate GLYPHDATA and GLYPHBITS

        // if pv and pvDst is NULL , We only set up GLYPHDATA only
        // and if pgd is NULL , we only set up pvDst

            if (pvDst)
                memset(pvDst, 0, cjSize);

            vFill_RotateGLYPHDATA(
                    pgd,                     // GLYPHDATA *pDistinationGlyphData
                    pv,                      // PVOID      SourceGLYPHBITS
                    pvDst,                   // PVOID      DistinationGLYPHBITS
                    pfc->ulRotate            // UINT       Rotate degree
                    );

        // Free GLYPHBITS tenmorary buffer

        // !!! Now pvDst is Original buffer from GRE.

           if( pv != NULL ) VFREEMEM( pv );
        }

#endif // FE_SB
        return cjGlyphData;

    case QFD_MAXEXTENTS:
    //
    // If buffer NULL, return size.
    //
        if ( pv == (PVOID) NULL )
            return (sizeof(FD_DEVICEMETRICS));

    //
    // Otherwise, copy the data structure.
    //
        else
            return cjBmfdDeviceMetrics(pfc, (FD_DEVICEMETRICS *) pv);

    case QFD_GLYPHANDOUTLINE:
    default:

        WARNING("gdisrv!BmfdQueryFontData(): unsupported mode\n");
        return FD_ERROR;
    }
}

/******************************Public*Routine******************************\
* BmfdQueryAdvanceWidths                                                   *
*                                                                          *
* Queries the advance widths for a range of glyphs.                        *
*                                                                          *
*  Sat 16-Jan-1993 22:28:41 -by- Charles Whitmer [chuckwh]                 *
* Wrote it.  The code is repeated to avoid multiplies wherever possible.   *
* The crazy loop unrolling cuts the time of this routine by 25%.           *
\**************************************************************************/

typedef struct _TYPE2TABLE
{
    USHORT  cx;
    USHORT  offData;
} TYPE2TABLE;

typedef struct _TYPE3TABLE
{
    USHORT  cx;
    USHORT  offDataLo;
    USHORT  offDataHi;
} TYPE3TABLE;

BOOL BmfdQueryAdvanceWidths
(
    FONTOBJ *pfo,
    ULONG    iMode,
    HGLYPH  *phg,
    LONG    *plWidths,
    ULONG    cGlyphs
)
{
    USHORT      *psWidths = (USHORT *) plWidths;   // True for the cases we handle.

    FONTCONTEXT *pfc       ;
    FACEINFO    *pfai      ;
    CVTFILEHDR  *pcvtfh    ;
    BYTE        *pjTable   ;
    USHORT       xScale    ;
    USHORT       cxExtra   ;
    USHORT       cx;

    if (!bReconnectBmfdFont(PFF(pfo->iFile)))
    {
        WARNING("bmfd!bmfdQueryAdvanceWidths: this file is gone\n");
        return FD_ERROR;
    }

// If pfo->pvProducer is NULL, then we need to open a font context.
//
    if ( pfo->pvProducer == (PVOID) NULL )
        pfo->pvProducer = (PVOID) BmfdOpenFontContext(pfo);

    pfc = PFC(pfo->pvProducer);

    if ( pfc == (PFONTCONTEXT) NULL )
    {
        WARNING("bmfd!bmfdQueryAdvanceWidths: cannot create font context\n");
        return FD_ERROR;
    }

    pfai    = pfc->pfai;
    pcvtfh  = &(pfai->cvtfh);
    pjTable = (BYTE *) pfai->re.pvResData + pcvtfh->dpOffsetTable;
    xScale  = (USHORT) (pfc->ptlScale.x << 4);
    cxExtra = (pfc->flFontType & FO_SIM_BOLD) ? 16 : 0;

    if (iMode > QAW_GETEASYWIDTHS)
        return(GDI_ERROR);

// Retrieve widths from type 2 tables.

    if (pcvtfh->iVersion == 0x00000200)
    {
        TYPE2TABLE *p2t = (TYPE2TABLE *) pjTable;

        if (xScale == 16)
        {
            while (cGlyphs > 3)
            {
                cx = p2t[phg[0]].cx;
                psWidths[0] = (cx << 4) + cxExtra;
                cx = p2t[phg[1]].cx;
                psWidths[1] = (cx << 4) + cxExtra;
                cx = p2t[phg[2]].cx;
                psWidths[2] = (cx << 4) + cxExtra;
                cx = p2t[phg[3]].cx;
                psWidths[3] = (cx << 4) + cxExtra;

                phg += 4; psWidths += 4; cGlyphs -= 4;
            }

            while (cGlyphs)
            {
                cx = p2t[*phg].cx;
                *psWidths = (cx << 4) + cxExtra;
                phg++,psWidths++,cGlyphs--;
            }
        }
        else
        {
            while (cGlyphs)
            {
                cx = p2t[*phg].cx;
                *psWidths = (cx * xScale) + cxExtra;
                phg++,psWidths++,cGlyphs--;
            }
        }
    }

// Retrieve widths from type 3 tables.

    else
    {
        TYPE3TABLE *p3t = (TYPE3TABLE *) pjTable;

        if (xScale == 16)
        {
            while (cGlyphs > 3)
            {
                cx = p3t[phg[0]].cx;
                psWidths[0] = (cx << 4) + cxExtra;
                cx = p3t[phg[1]].cx;
                psWidths[1] = (cx << 4) + cxExtra;
                cx = p3t[phg[2]].cx;
                psWidths[2] = (cx << 4) + cxExtra;
                cx = p3t[phg[3]].cx;
                psWidths[3] = (cx << 4) + cxExtra;
                phg += 4; psWidths += 4; cGlyphs -= 4;
            }

            while (cGlyphs)
            {
                cx = p3t[*phg].cx;
                *psWidths = (cx << 4) + cxExtra;
                phg++,psWidths++,cGlyphs--;
            }
        }
        else
        {
            while (cGlyphs)
            {
                cx = p3t[*phg].cx;
                *psWidths = (cx * xScale) + cxExtra;
                phg++,psWidths++,cGlyphs--;
            }
        }
    }
    return(TRUE);
}

/******************************Public*Routine******************************\
* BmfdQueryFontFile
*
* A function to query per font file information.
*
* Parameters:
*
*   hff         Handle to a font file.
*
*   ulMode      This is a 32-bit number that must be one of the following
*               values:
*
*       Allowed ulMode values:
*       ----------------------
*
*       QFF_DESCRIPTION -- copies a UNICODE string in the buffer
*                          that describes the contents of the font file.
*
*       QFF_NUMFACES   -- returns number of faces in the font file.
*
*   cjBuf       Maximum number of BYTEs to copy into the buffer.  The
*               driver will not copy more than this many BYTEs.
*
*               This should be zero if pulBuf is NULL.
*
*               This parameter is not used in QFF_NUMFACES mode.
*
*   pulBuf      Pointer to the buffer to receive the data
*               If this is NULL, then the required buffer size
*               is returned as a count of BYTEs.  Notice that this
*               is a PULONG, to enforce 32-bit data alignment.
*
*               This parameter is not used in QFF_NUMFACES mode.
*
* Returns:
*
*   If mode is QFF_DESCRIPTION, then the number of BYTEs copied into
*   the buffer is returned by the function.  If pulBuf is NULL,
*   then the required buffer size (as a count of BYTEs) is returned.
*
*   If mode is QFF_NUMFACES, then number of faces in font file is returned.
*
*   FD_ERROR is returned if an error occurs.
*
* History:
*  30-Aug-1992 -by- Gilman Wong [gilmanw]
* Added QFF_NUMFACES mode (IFI/DDI merge).
*
*  Fri 20-Mar-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

LONG
BmfdQueryFontFile (
    HFF     hff,        // handle to font file
    ULONG   ulMode,     // type of query
    ULONG   cjBuf,      // size of buffer (in BYTEs)
    PULONG  pulBuf      // return buffer (NULL if requesting size of data)
    )
{
// Verify the HFF.

    if (hff == HFF_INVALID)
    {
    WARNING("bmfd!BmfdQueryFontFile(): invalid HFF\n");
        return(FD_ERROR);
    }

//
// Which mode?.
//
    switch(ulMode)
    {
    case QFF_DESCRIPTION:
    //
    // If present, return the description string.
    //
        if ( PFF(hff)->cjDescription != 0 )
        {
        //
        // If there is a buffer, copy the data.
        //
            if ( pulBuf != (PULONG) NULL )
            {
            //
            // Is buffer big enough?
            //
                if ( cjBuf < PFF(hff)->cjDescription )
                {
                    WARNING("bmfd!BmfdQueryFontFile(): buffer too small for string\n");
                    return (FD_ERROR);
                }
                else
                {
                    RtlCopyMemory((PVOID) pulBuf,
                                  ((PBYTE) PFF(hff)) + PFF(hff)->dpwszDescription,
                                  PFF(hff)->cjDescription);
                }
            }

            return (LONG) PFF(hff)->cjDescription;
        }

    //
    // Otherwise, substitute the facename.
    //
        else
        {
        //
        // There is no description string associated with the font therefore we
        // substitue the facename of the first font in the font file.
        //
            IFIMETRICS *pifi         = PFF(hff)->afai[0].pifi;
            PWSZ        pwszFacename = (PWSZ)((PBYTE) pifi + pifi->dpwszFaceName);
            ULONG       cjFacename   = (wcslen(pwszFacename) + 1) * sizeof(WCHAR);

        //
        // If there is a buffer, copy to it.
        //
            if ( pulBuf != (PULONG) NULL )
            {
            //
            // Is buffer big enough?
            //
                if ( cjBuf < cjFacename )
                {
                    WARNING("bmfd!BmfdQueryFontFile(): buffer too small for face\n");
                    return (FD_ERROR);
                }
                else
                {
                    RtlCopyMemory((PVOID) pulBuf,
                                  (PVOID) pwszFacename,
                                  cjFacename);
                }
            }
            return ((LONG) cjFacename);
        }

    case QFF_NUMFACES:
        return PFF(hff)->cFntRes;

    default:
        WARNING("gdisrv!BmfdQueryFontFile(): unknown mode\n");
        return FD_ERROR;
    }

}


/******************************Public*Routine******************************\
* cjBmfdDeviceMetrics
*
*
* Effects:
*
* Warnings:
*
* History:
*  30-Aug-1992 -by- Gilman Wong [gilmanw]
* Stole it from BodinD's FdQueryFaceAttr() implementation.
\**************************************************************************/

ULONG
cjBmfdDeviceMetrics (
    PFONTCONTEXT     pfc,
    FD_DEVICEMETRICS *pdevm
    )
{
    PIFIMETRICS pifi;
    UINT xScale = pfc->ptlScale.x;
    UINT yScale = pfc->ptlScale.y;

// compute the accelerator flags for this font
// If this is a bitmap font where some of the glyphs have zero widths,
// we need to turn off all the accelerator flags

    if (pfc->pfai->cvtfh.fsFlags & FS_ZERO_WIDTH_GLYPHS)
    {
        pdevm->flRealizedType = 0;
    }
    else
    {
        pdevm->flRealizedType =
            (
            FDM_TYPE_BM_SIDE_CONST  |  // all char bitmaps have the same cy
            FDM_TYPE_CONST_BEARINGS |  // ac spaces for all chars the same,  not 0 necessarilly
            FDM_TYPE_MAXEXT_EQUAL_BM_SIDE
            );

    // the above flags are set regardless of the possible simulation performed on the face
    // the remaining two are only set if italicizing has not been done

        if ( !(pfc->flFontType & FO_SIM_ITALIC) )
        {
            pdevm->flRealizedType |=
                (FDM_TYPE_ZERO_BEARINGS | FDM_TYPE_CHAR_INC_EQUAL_BM_BASE);
        }
    }

    pifi = pfc->pfai->pifi;

#ifdef FE_SB // ROTATION:cjBmfdDeviceMetric(): set direction unit vectors

/**********************************************************************
  Coordinate    (0 degree)   (90 degree)   (180 degree)  (270 degree)
   System

     |(-)          A                 A
     |        Side |                 | Base
     |             |                 |         Base         Side
-----+----->X      +------>   <------+      <------+      +------>
(-)  |  (+)          Base       Side               |      |
     |                                         Side|      | Base
     |(+)                                          V      V
     Y
***********************************************************************/

    switch( pfc->ulRotate )
    {
    case 0L:

    // the direction unit vectors for all ANSI bitmap fonts are the
    // same. We do not even have to look to the font context:

        vLToE(&pdevm->pteBase.x, 1L);
        vLToE(&pdevm->pteBase.y, 0L);
        vLToE(&pdevm->pteSide.x, 0L);
        vLToE(&pdevm->pteSide.y, -1L);    // y axis points down

        pdevm->fxMaxAscender  = LTOFX((LONG)pifi->fwdWinAscender * yScale);
        pdevm->fxMaxDescender = LTOFX((LONG)pifi->fwdWinDescender * yScale );

        pdevm->ptlUnderline1.x = 0L;
        pdevm->ptlUnderline1.y = -(LONG)pifi->fwdUnderscorePosition * yScale;

        pdevm->ptlStrikeOut.x  =
            (pfc->flFontType & FO_SIM_ITALIC) ? (LONG)pifi->fwdStrikeoutPosition / 2 : 0;
        pdevm->ptlStrikeOut.y  = -(LONG)pifi->fwdStrikeoutPosition * yScale;

        pdevm->ptlULThickness.x = 0;
        pdevm->ptlULThickness.y = (LONG)pifi->fwdUnderscoreSize * yScale;

        pdevm->ptlSOThickness.x = 0;
        pdevm->ptlSOThickness.y = (LONG)pifi->fwdStrikeoutSize * yScale;

        break;

    case 900L:

    // the direction unit vectors for all ANSI bitmap fonts are the
    // same. We do not even have to look to the font context:

        vLToE(&pdevm->pteBase.x, 0L);
        vLToE(&pdevm->pteBase.y, -1L);
        vLToE(&pdevm->pteSide.x, -1L);
        vLToE(&pdevm->pteSide.y, 0L);


        pdevm->fxMaxAscender  = LTOFX((LONG)pifi->fwdWinAscender * yScale);
        pdevm->fxMaxDescender = LTOFX((LONG)pifi->fwdWinDescender * yScale );

        pdevm->ptlUnderline1.x = -(LONG)pifi->fwdUnderscorePosition * yScale;
        pdevm->ptlUnderline1.y = 0;

        pdevm->ptlStrikeOut.x  = -(LONG)pifi->fwdStrikeoutPosition * yScale;
        pdevm->ptlStrikeOut.y  =
            (pfc->flFontType & FO_SIM_ITALIC) ? -(LONG)pifi->fwdStrikeoutPosition / 2 : 0;

        pdevm->ptlULThickness.x = (LONG)pifi->fwdUnderscoreSize * yScale;
        pdevm->ptlULThickness.y = 0;

        pdevm->ptlSOThickness.x = (LONG)pifi->fwdStrikeoutSize * yScale;
        pdevm->ptlSOThickness.y = 0;

        break;

    case 1800L:

    // the direction unit vectors for all ANSI bitmap fonts are the
    // same. We do not even have to look to the font context:

        vLToE(&pdevm->pteBase.x, -1L);
        vLToE(&pdevm->pteBase.y, 0L);
        vLToE(&pdevm->pteSide.x, 0L);
        vLToE(&pdevm->pteSide.y, 1L);


        pdevm->fxMaxAscender  = LTOFX((LONG)pifi->fwdWinAscender * yScale);
        pdevm->fxMaxDescender = LTOFX((LONG)pifi->fwdWinDescender * yScale );

        pdevm->ptlUnderline1.x = 0L;
        pdevm->ptlUnderline1.y = (LONG)pifi->fwdUnderscorePosition * yScale;

        pdevm->ptlStrikeOut.x  =
            (pfc->flFontType & FO_SIM_ITALIC) ? -(LONG)pifi->fwdStrikeoutPosition / 2 : 0;
        pdevm->ptlStrikeOut.y  = pifi->fwdStrikeoutPosition * yScale;

        pdevm->ptlULThickness.x = 0;
        pdevm->ptlULThickness.y = (LONG)pifi->fwdUnderscoreSize * yScale;

        pdevm->ptlSOThickness.x = 0;
        pdevm->ptlSOThickness.y = (LONG)pifi->fwdStrikeoutSize * yScale;

        break;

    case 2700L:

    // the direction unit vectors for all ANSI bitmap fonts are the
    // same. We do not even have to look to the font context:

        vLToE(&pdevm->pteBase.x, 0L);
        vLToE(&pdevm->pteBase.y, 1L);
        vLToE(&pdevm->pteSide.x, 1L);
        vLToE(&pdevm->pteSide.y, 0L);

        pdevm->fxMaxAscender  = LTOFX((LONG)pifi->fwdWinAscender * yScale);
        pdevm->fxMaxDescender = LTOFX((LONG)pifi->fwdWinDescender * yScale );

        pdevm->ptlUnderline1.x = (LONG)pifi->fwdUnderscorePosition * yScale;
        pdevm->ptlUnderline1.y = 0L;

        pdevm->ptlStrikeOut.x  = (LONG)pifi->fwdStrikeoutPosition * yScale;
        pdevm->ptlStrikeOut.y  =
            (pfc->flFontType & FO_SIM_ITALIC) ? (LONG)pifi->fwdStrikeoutPosition / 2 : 0;

        pdevm->ptlULThickness.x = (LONG)pifi->fwdUnderscoreSize * yScale;
        pdevm->ptlULThickness.y = 0;

        pdevm->ptlSOThickness.x = (LONG)pifi->fwdStrikeoutSize * yScale;
        pdevm->ptlSOThickness.y = 0;

        break;

    default:

        break;
    }

#else

// the direction unit vectors for all ANSI bitmap fonts are the
// same. We do not even have to look to the font context:

    vLToE(&pdevm->pteBase.x, 1L);
    vLToE(&pdevm->pteBase.y, 0L);
    vLToE(&pdevm->pteSide.x, 0L);
    vLToE(&pdevm->pteSide.y, -1L);    // y axis points down

#endif // FE_SB

// Set the constant increment for a fixed pitch font.  Don't forget to
// take into account a bold simulation!

    pdevm->lD = 0;

    if ((pifi->flInfo & FM_INFO_CONSTANT_WIDTH) &&
        !(pfc->pfai->cvtfh.fsFlags & FS_ZERO_WIDTH_GLYPHS))
    {
        pdevm->lD = (LONG) pifi->fwdMaxCharInc * xScale;

        if (pfc->flFontType & FO_SIM_BOLD)
            pdevm->lD++;
    }

#ifndef FE_SB // cjBmfdDeviceMetric():

// for a bitmap font there is no difference between notional and device
// coords, so that the Ascender and Descender can be copied directly
// from PIFIMETRICS where these two numbers are in notional coords

    pdevm->fxMaxAscender  = LTOFX((LONG)pifi->fwdWinAscender * yScale);
    pdevm->fxMaxDescender = LTOFX((LONG)pifi->fwdWinDescender * yScale );

    pdevm->ptlUnderline1.x = 0L;
    pdevm->ptlUnderline1.y = - pifi->fwdUnderscorePosition * yScale;

    pdevm->ptlStrikeOut.y  = - pifi->fwdStrikeoutPosition * yScale;

    pdevm->ptlStrikeOut.x  =
        (pfc->flFontType & FO_SIM_ITALIC) ? (LONG)pifi->fwdStrikeoutPosition / 2 : 0;

    pdevm->ptlULThickness.x = 0;
    pdevm->ptlULThickness.y = (LONG)pifi->fwdUnderscoreSize * yScale;

    pdevm->ptlSOThickness.x = 0;
    pdevm->ptlSOThickness.y = (LONG)pifi->fwdStrikeoutSize * yScale;


// for a bitmap font there is no difference between notional and device
// coords, so that the Ascender and Descender can be copied directly
// from PIFIMETRICS where these two numbers are in notional coords

    pdevm->fxMaxAscender  = LTOFX((LONG)pifi->fwdWinAscender * yScale);
    pdevm->fxMaxDescender = LTOFX((LONG)pifi->fwdWinDescender * yScale );

    pdevm->ptlUnderline1.x = 0L;
    pdevm->ptlUnderline1.y = - pifi->fwdUnderscorePosition * yScale;

    pdevm->ptlStrikeOut.y  = - pifi->fwdStrikeoutPosition * yScale;

    pdevm->ptlStrikeOut.x  =
        (pfc->flFontType & FO_SIM_ITALIC) ? (LONG)pifi->fwdStrikeoutPosition / 2 : 0;

    pdevm->ptlULThickness.x = 0;
    pdevm->ptlULThickness.y = (LONG)pifi->fwdUnderscoreSize * yScale;

    pdevm->ptlSOThickness.x = 0;
    pdevm->ptlSOThickness.y = (LONG)pifi->fwdStrikeoutSize * yScale;

#endif // FE_SB

// max glyph bitmap width in pixels in x direction
// does not need to be multiplied by xScale, this has already been taken into
// account, see the code in fdfc.c:
//    cjGlyphMax =
//        cjGlyphDataSimulated(
//            pfo,
//            (ULONG)pcvtfh->usMaxWidth * ptlScale.x,
//            (ULONG)pcvtfh->cy * ptlScale.y,
//            &cxMax);
// [bodind]

    pdevm->cxMax = pfc->cxMax;

// new fields

    pdevm->cyMax      = pfc->cjGlyphMax / ((pfc->cxMax + 7) / 8);
    pdevm->cjGlyphMax = pfc->cjGlyphMax;


    return (sizeof(FD_DEVICEMETRICS));
}


#ifdef FE_SB // vFill_RotateGLYPHDATA()

#define CJ_DIB8_SCAN(cx) ((((cx) + 7) & ~7) >> 3)


/*
   BIT macro returns non zero ( if bitmap[x,y] is on) or zero (bitmap[x,y] is off).
   pb : bitmap
   w  : byte count per scan line
   x  : Xth bit in x direction
   y  : scan line

        x
       -------------------->
   y | *******************************
     | *******************************
     | *******************************
     V
*/

BYTE BitON[8] = { 0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01 };
BYTE BitOFF[8] = { 0x7f, 0xbf, 0xdf, 0xef, 0xf7, 0xfb, 0xfd, 0xfe };
#define BIT(pb, w, x, y)  (*((PBYTE)(pb) + (w) * (y) + ((x)/8)) & (BitON[(x) & 7]))

/******************************************************************************\
*
* VOID vFill_RotateGLYPHDATA()
*
*
* History :
*
*  11-Feb-1992 (Thu) -by- Hideyuki Nagase [hideyukn]
* Wrote it.
*
\******************************************************************************/

VOID
vFill_RotateGLYPHDATA (
    GLYPHDATA *pDistGlyphData,
    PVOID      SrcGLYPHBITS,
    PVOID      DistGLYPHBITS,
    UINT       RotateDegree
    )
{
    GLYPHDATA  SrcGlyphData;
    ULONG      ulSrcBitmapSizeX , ulDistBitmapSizeX;
    ULONG      ulSrcBitmapSizeY , ulDistBitmapSizeY;
    GLYPHBITS *pSrcGlyphBits , *pDistGlyphBits;
    PBYTE      pbSrcBitmap , pbDistBitmap;
    UINT       x , y , k;
    UINT       cjScanSrc , cjScanDist;
    PBYTE      pb;

//  Now , in this point *pDistGlyphData contain No rotated GLYPHDATA
// Copy No rotate GLYPHDATA to Source Area . later we write back changed data to
// distination area.

//
// these field are defined as:
//
//   unit vector along the baseline -  fxD, fxA, fxAB
// or
//   unit vector in the ascent direction - fxInkTop, fxInkBottom
//
// Because baseline direction and ascent direction are rotated
// as ulRotate specifies, these fileds should be considered as
// rotation independent.
//

// Init Local value
// Set pointer to GLYPHBITS structure

    pSrcGlyphBits = (GLYPHBITS *)SrcGLYPHBITS;
    pDistGlyphBits = (GLYPHBITS *)DistGLYPHBITS;

    if( pDistGlyphData != NULL )
    {

    // Init Source GlyphData

        SrcGlyphData = *pDistGlyphData;

    // Record the pointer to GLYPHBITS in GLYPHDATA structure

        pDistGlyphData->gdf.pgb = pDistGlyphBits;
    }

// Check Rotation

    switch( RotateDegree )
    {
        case 0L :

            WARNING("BMFD:vFill_RotateGLYPHDATA():Why come here?\n");
            break;

        case 900L :

        if( pDistGlyphData != NULL )
        {

        // Setup GLYPHDATA structure

        //  x =  y;
        //  y = -x; !!!! HighPart include plus or minus flag

            pDistGlyphData->ptqD.x = SrcGlyphData.ptqD.y;
            pDistGlyphData->ptqD.y.HighPart = -(SrcGlyphData.ptqD.x.HighPart);
            pDistGlyphData->ptqD.y.LowPart = SrcGlyphData.ptqD.x.LowPart;

        // top = -rihgt ; bottom = -left ; right = bottom ; left = top

            pDistGlyphData->rclInk.top = -(SrcGlyphData.rclInk.right);
            pDistGlyphData->rclInk.bottom = -(SrcGlyphData.rclInk.left);
            pDistGlyphData->rclInk.right = SrcGlyphData.rclInk.bottom;
            pDistGlyphData->rclInk.left = SrcGlyphData.rclInk.top;

        }

        if( pSrcGlyphBits != NULL && pDistGlyphBits != NULL )
        {

        // Get Bitmap size

            ulSrcBitmapSizeX = pSrcGlyphBits->sizlBitmap.cx;
            ulSrcBitmapSizeY = pSrcGlyphBits->sizlBitmap.cy;

        // Get the pointer to Bitmap images

            pbSrcBitmap = (PBYTE)pSrcGlyphBits->aj;
            pbDistBitmap = (PBYTE)pDistGlyphBits->aj;

        // Set Distination Bitmap Size

            ulDistBitmapSizeX = ulSrcBitmapSizeY;
            ulDistBitmapSizeY = ulSrcBitmapSizeX;

        // Setup GLYPHBITS stuff

            pDistGlyphBits->ptlOrigin.x = pSrcGlyphBits->ptlOrigin.y;
            pDistGlyphBits->ptlOrigin.y = -(LONG)(ulSrcBitmapSizeX);

            pDistGlyphBits->sizlBitmap.cx = pSrcGlyphBits->sizlBitmap.cy;
            pDistGlyphBits->sizlBitmap.cy = pSrcGlyphBits->sizlBitmap.cx;

        // Rotate bitmap inage

            cjScanSrc = CJ_DIB8_SCAN( ulSrcBitmapSizeX );
            cjScanDist = CJ_DIB8_SCAN( ulDistBitmapSizeX );

        // we need to clear the dst buffer because the S3 driver expects
        // extra stuff on the edges to be zeroed out

            for ( y = 0; y < ulDistBitmapSizeY ; y++ )
            {
                for ( x= 0 , pb = pbDistBitmap + cjScanDist * y ;
                      x < ulDistBitmapSizeX ;
                      x++ )
                {
                    k = x & 7; // k is from 0 to 7;

                    if ( BIT( pbSrcBitmap , cjScanSrc,
                              ulDistBitmapSizeY - y - 1 ,
                              x
                            )
                       )
                         *pb |= (BitON[ k ] );
                     else
                         *pb &= (BitOFF[ k ] );
                    if ( k == 7 )
                         pb++;
                }
            }
        }

        break;

        case 1800L :

        if( pDistGlyphData != NULL )
        {

        // Setup GLYPHDATA structure

        //  x = -x; !!!! HighPart include plus or minus flag
        //  y = -y; !!!! HighPart include plus or minus flag

            pDistGlyphData->ptqD.x.HighPart = -(SrcGlyphData.ptqD.x.HighPart);
            pDistGlyphData->ptqD.x.LowPart = SrcGlyphData.ptqD.x.LowPart;
            pDistGlyphData->ptqD.y.HighPart = -(SrcGlyphData.ptqD.y.HighPart);
            pDistGlyphData->ptqD.y.LowPart = SrcGlyphData.ptqD.y.LowPart;

        // top = -bottom ; bottom = -top ; right = -left ; left = -right

            pDistGlyphData->rclInk.top = -(SrcGlyphData.rclInk.bottom);
            pDistGlyphData->rclInk.bottom = -(SrcGlyphData.rclInk.top);
            pDistGlyphData->rclInk.right = -(SrcGlyphData.rclInk.left);
            pDistGlyphData->rclInk.left = -(SrcGlyphData.rclInk.right);
        }

        if( pSrcGlyphBits != NULL && pDistGlyphBits != NULL )
        {

        // Get Bitmap size

            ulSrcBitmapSizeX = pSrcGlyphBits->sizlBitmap.cx;
            ulSrcBitmapSizeY = pSrcGlyphBits->sizlBitmap.cy;

        // Get the pointer to Bitmap images

            pbSrcBitmap = (PBYTE)pSrcGlyphBits->aj;
            pbDistBitmap = (PBYTE)pDistGlyphBits->aj;

        // Set Distination Bitmap Size

            ulDistBitmapSizeX = ulSrcBitmapSizeX;
            ulDistBitmapSizeY = ulSrcBitmapSizeY;

        // Setup GLYPHBITS stuff

            pDistGlyphBits->ptlOrigin.x = -(LONG)(ulSrcBitmapSizeX);
            pDistGlyphBits->ptlOrigin.y = -(LONG)(ulSrcBitmapSizeY + pSrcGlyphBits->ptlOrigin.y);

            pDistGlyphBits->sizlBitmap.cx = pSrcGlyphBits->sizlBitmap.cx;
            pDistGlyphBits->sizlBitmap.cy = pSrcGlyphBits->sizlBitmap.cy;


        // Rotate bitmap inage

            cjScanSrc = CJ_DIB8_SCAN( ulSrcBitmapSizeX );
            cjScanDist = CJ_DIB8_SCAN( ulDistBitmapSizeX );

            for ( y = 0; y < ulDistBitmapSizeY ; y++ )
            {
                for ( x = 0 , pb = pbDistBitmap + cjScanDist * y ;
                      x < ulDistBitmapSizeX ;
                      x++ )
                {
                    k = x & 7;

                    if ( BIT( pbSrcBitmap, cjScanSrc,
                              ulDistBitmapSizeX - x - 1,
                              ulDistBitmapSizeY - y - 1
                            )
                       )
                        *pb |= (BitON[ k ] );
                    else
                        *pb &= (BitOFF[ k ] );
                    if ( k == 7 )
                        pb++;
                }
            }
        }

        break;

        case 2700L :

        if( pDistGlyphData != NULL )
        {

        // Setup GLYPHDATA structure

        //  x = -y; !!!! HighPart include plus or minus flag
        //  y =  x;

            pDistGlyphData->ptqD.x.HighPart = -(SrcGlyphData.ptqD.y.HighPart);
            pDistGlyphData->ptqD.x.LowPart = SrcGlyphData.ptqD.y.LowPart;
            pDistGlyphData->ptqD.y = SrcGlyphData.ptqD.x;

        // top = left ; bottom = right ; right = -bottom ; left = -top

            pDistGlyphData->rclInk.top = SrcGlyphData.rclInk.left;
            pDistGlyphData->rclInk.bottom = SrcGlyphData.rclInk.right;
            pDistGlyphData->rclInk.right = -(SrcGlyphData.rclInk.bottom);
            pDistGlyphData->rclInk.left = -(SrcGlyphData.rclInk.top);

        }

        if( pSrcGlyphBits != NULL && pDistGlyphBits != NULL )
        {

        // Get Bitmap size

            ulSrcBitmapSizeX = pSrcGlyphBits->sizlBitmap.cx;
            ulSrcBitmapSizeY = pSrcGlyphBits->sizlBitmap.cy;

        // Get the pointer to Bitmap images

            pbSrcBitmap = (PBYTE)pSrcGlyphBits->aj;
            pbDistBitmap = (PBYTE)pDistGlyphBits->aj;

        // Set Distination Bitmap Size

            ulDistBitmapSizeX = ulSrcBitmapSizeY;
            ulDistBitmapSizeY = ulSrcBitmapSizeX;

        // Setup GLYPHBITS stuff

            pDistGlyphBits->ptlOrigin.x = -(LONG)(ulSrcBitmapSizeY + pSrcGlyphBits->ptlOrigin.y);
            pDistGlyphBits->ptlOrigin.y = pSrcGlyphBits->ptlOrigin.x;

            pDistGlyphBits->sizlBitmap.cx = pSrcGlyphBits->sizlBitmap.cy;
            pDistGlyphBits->sizlBitmap.cy = pSrcGlyphBits->sizlBitmap.cx;

        // Rotate bitmap inage

            cjScanSrc = CJ_DIB8_SCAN( ulSrcBitmapSizeX );
            cjScanDist = CJ_DIB8_SCAN( ulDistBitmapSizeX );

            for ( y = 0; y < ulDistBitmapSizeY ; y++ )
            {
                for ( x = 0 , pb = pbDistBitmap + cjScanDist * y ;
                      x < ulDistBitmapSizeX ;
                      x++ )
                {
                    k = x & 7;

                    if ( BIT( pbSrcBitmap, cjScanSrc,
                              y ,
                              ulDistBitmapSizeX - x - 1
                            )
                       )
                        *pb |= (BitON[ k ] );
                    else
                        *pb &= (BitOFF[ k ] );
                    if ( k == 7 )
                        pb++;
                }
            }
        }

        break;

        default :

            WARNING("BMFD:vFill_RotateGLYPHDATA():ulRotate is invalid\n");
            break;

    } // end switch
}

#endif // FE_SB
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\bmfd\cvt.h ===
/******************************Module*Header*******************************\
* Module Name: cvt.h
*
* function declarations that are private to cvt.c
*
* Created: 26-Nov-1990 17:39:35
* Author: Bodin Dresevic [BodinD]
*
* Copyright (c) 1990 Microsoft Corporation
*
\**************************************************************************/

FSHORT
fsSelectionFlags(
    PBYTE
    );

VOID
vAlignHdrData(
    PCVTFILEHDR,
    PRES_ELEM
    );

BOOL
bVerifyResource(
    PCVTFILEHDR,
    PRES_ELEM
    );

BOOL
bVerifyFNTQuick(
    PRES_ELEM
    );

BOOL
bVerifyFNT(
    PCVTFILEHDR,
    PRES_ELEM
    );

BOOL
bGrep(
    PSZ,
    PSZ
    );

VOID
vFigureVendorId(
    CHAR*,
    PSZ
    );

BYTE
jFamilyType(
    FSHORT
    );

ULONG
cjGLYPHDATA(
    ULONG
    );

USHORT
usConvertWeightClass(
    USHORT
    );

VOID
vComputeSpecialChars(
    PCVTFILEHDR,
    PWCHAR,
    PWCHAR
    );

PBYTE
pjRawBitmap(
    HGLYPH,
    PCVTFILEHDR,
    PRES_ELEM,
    PULONG
    );

BOOL
bDescStr(
    PVOID,
    PSZ
    );

VOID
vCvtToBmp(
    GLYPHBITS *,
    GLYPHDATA *,
    PBYTE,
    ULONG,
    ULONG,
    ULONG
    );

VOID
vCvtToBoldBmp(
    GLYPHBITS *,
    GLYPHDATA *,
    PBYTE,
    ULONG,
    ULONG,
    ULONG
    );

VOID
vCvtToItalicBmp(
    GLYPHBITS *,
    GLYPHDATA *,
    PBYTE,
    ULONG,
    ULONG,
    ULONG
    );

VOID
vCvtToBoldItalicBmp(
    GLYPHBITS *,
    GLYPHDATA *,
    PBYTE,
    ULONG,
    ULONG,
    ULONG
    );

VOID
vComputeSimulatedGLYPHDATA(
    GLYPHDATA*,
    PBYTE,
    ULONG,
    ULONG,
    ULONG,
    ULONG,
    ULONG,
    FONTOBJ*
    );

VOID
vFindTAndB(
    PBYTE,
    ULONG,
    ULONG,
    ULONG*,
    ULONG*
    );

BOOL
bConvertFontRes
(
    PRES_ELEM,
    FACEINFO*
    );

VOID
vCheckOffsetTable(
    PCVTFILEHDR,
    PRES_ELEM
    );

ULONG
cjBMFDIFIMETRICS(
    PCVTFILEHDR pcvtfh,
    PRES_ELEM   pre
    );

VOID
vDefFace(
    FACEINFO *pfai,
    RES_ELEM *pre
    );

VOID
vBmfdFill_IFIMETRICS(
    FACEINFO   *pfai,
    PRES_ELEM   pre
    );


typedef VOID (* PFN_IFI)(PIFIMETRICS);

//
// This is a useful macro. It returns the offset from the address y
// to the next higher address aligned to an object of type x
//

#define OFFSET_OF_NEXT(x,y) sizeof(x)*((y+sizeof(x)-1)/sizeof(x))

//
// ISIMULATE -- converts from FO_SIM_FOO to FC_SIM_FOO
//
#define ISIMULATE(x)                                 \
                                                     \
        (x) == 0 ?                                   \
            FC_SIM_NONE :                            \
            (                                        \
                (x) == FO_SIM_BOLD ?            \
                    FC_SIM_BOLD :                    \
                    (                                \
                        (x) == FO_SIM_ITALIC ?  \
                            FC_SIMULATE_ITALIC :     \
                            FC_SIMULATE_BOLDITALIC   \
                    )                                \
            )

// minimal hglyph allowed, MIN_HGLYPH must be != 0, otherwise is random

#define MIN_HGLYPH  (HGLYPH)13  // lucky number !


// The missing range in SYMBOL character set (inclusive-inclusive)

#define CHARSET_SYMBOL_GAP_MIN  127
#define CHARSET_SYMBOL_GAP_MAX  160

// save some typing here, rename what used to be functions into
// these macros

#define   ulMakeULONG(pj)    ((ULONG)READ_DWORD(pj))
#define   lMakeLONG(pj)      ((LONG)READ_DWORD(pj))
#define   usMakeUSHORT(pj)   ((USHORT)READ_WORD(pj))
#define   sMakeSHORT(pj)     ((SHORT)READ_WORD(pj))

//!!! the next one is specific to win31 us char set (1252 cp) and this
//!!! has to be generalized to an arbitrary code page

#define    C_RUNS       15


// these are the indicies into the array of strings below

#define I_DONTCARE     0         // don't care or don't know
#define I_ROMAN        1
#define I_SWISS        2
#define I_MODERN       3
#define I_SCRIPT       4
#define I_DECORATIVE   5

// #define DUMPCALL

#if defined(_X86_)

typedef struct  _FLOATINTERN
{
    LONG    lMant;
    LONG    lExp;
} FLOATINTERN;

typedef FLOATINTERN  EFLOAT;
typedef EFLOAT *PEFLOAT;

VOID    ftoef_c(FLOATL, PEFLOAT);
BOOL    eftol_c(EFLOAT *, PLONG, LONG);

#define vEToEF(e, pef)      ftoef_c((e), (pef))
#define bEFtoL(pe, pl )     eftol_c((pe), (pl), 1 )

#define bIsZero(ef)     ( ((ef).lMant == 0) && ((ef).lExp == 0) )
#define bPositive(ef)       ( (ef).lMant >= 0 )
FIX  fxLTimesEf(EFLOAT *pef, LONG l);

#else // not X86

typedef FLOAT EFLOAT;
typedef EFLOAT *PEFLOAT;

//
//  these could come from the real header files in math
//

#if defined(_AMD64_) || defined(_IA64_)
#define bFToLRound(e, pl) (bFToL(e, pl, 4+2))
extern BOOL bFToL(FLOAT e, PLONG pl, LONG lType);
#else
extern BOOL bFToLRound(FLOAT e, PLONG pl);
#endif

#define vEToEF(e, pef)      ( *(pef) = (e) )
#define bEFtoL( pe, pl )    ( bFToLRound(*(pe), (pl) ))
#define bIsZero(ef)     ( (ef) == 0 )
#define bPositive(ef)       ( (ef) >= 0 )

#endif


BOOL bLoadNtFon(
HFF iFile,
PVOID pvView,
HFF *phff
);


VOID vBmfdMarkFontGone(FONTFILE *pff, DWORD iExceptionCode);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\bmfd\fd.h ===
/******************************Module*Header*******************************\
* Module Name: fd.h
*
* file which is going to be included by the most *.c files in this directory.
* Supplies basic types, debugging stuff, error logging and checking stuff,
* error codes, usefull macros etc.
*
* Created: 22-Oct-1990 15:23:44
* Author: Bodin Dresevic [BodinD]
*
* Copyright (c) 1990 Microsoft Corporation
\**************************************************************************/
#define  IFI_PRIVATE

// macros for allocating and freeing memory

//#include <stddef.h>
//#include <stdarg.h>
//#include <windef.h>
//#include <wingdi.h>
//#include <winddi.h>

//#include "mapfile.h"

#include "engine.h"
#include "winres.h"

#define abs(x) max((x),-(x))

#if defined(_AMD64_) || defined(_IA64_)

#define  vLToE(pe,l)           (*(pe) = (FLOAT)(l))

#else   // i386

ULONG  ulLToE (LONG l);
VOID   vLToE(FLOATL * pe, LONG l);

#endif

//#define DEBUGSIM

BOOL BmfdEnableDriver(
ULONG iEngineVersion,
ULONG cj,
PDRVENABLEDATA pded);

BOOL
bBmfdLoadFont(
    HFF        iFile,
    PVOID      pvView,
    ULONG      cjView,
    ULONG      iType,
    HFF        *phff
    );

BOOL
BmfdUnloadFontFile (
    HFF hff
    );

LONG
BmfdQueryFontCaps (
    ULONG culCaps,
    PULONG pulCaps
    );

LONG
BmfdQueryFontFile (
    HFF     hff,
    ULONG   ulMode,
    ULONG   cjBuf,
    PULONG  pulBuf
    );

PIFIMETRICS
BmfdQueryFont (
    DHPDEV dhpdev,
    HFF    hff,
    ULONG  iFace,
    ULONG_PTR  *pid
    );

PVOID
BmfdQueryFontTree (
    DHPDEV  dhpdev,
    HFF     hff,
    ULONG   iFace,
    ULONG   iMode,
    ULONG_PTR   *pid
    );

LONG
BmfdQueryFontData (
    FONTOBJ *pfo,
    ULONG   iMode,
    HGLYPH  hg,
    GLYPHDATA *pgd,
    PVOID   pv,
    ULONG   cjSize
    );

VOID
BmfdDestroyFont (
    FONTOBJ *pfo
    );

HFC
BmfdOpenFontContext (
    FONTOBJ *pfo
    );

BOOL
    BmfdCloseFontContext(
    HFC hfc
    );

LONG
BmfdQueryFaceAttr(
    HFC hfc,
    ULONG ulType,
    ULONG culBuffer,
    PULONG pulBuffer
    );

BOOL BmfdQueryAdvanceWidths
(
    FONTOBJ *pfo,
    ULONG    iMode,
    HGLYPH  *phg,
    LONG    *plWidths,
    ULONG    cGlyphs
);

BOOL bDbgPrintAndFail(PSZ);


#include "fontfile.h"
#include "winfont.h"
#include "cvt.h"
#include "simulate.h"
#include "fon32.h"
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\bmfd\fdfc.c ===
/******************************Module*Header*******************************\
* Module Name: fdfc.c
*
* functions that deal with font contexts
*
* Created: 08-Nov-1990 12:42:34
* Author: Bodin Dresevic [BodinD]
*
* Copyright (c) 1990 Microsoft Corporation
\**************************************************************************/

#include "fd.h"

#define MAX_HORZ_SCALE      5
#define MAX_VERT_SCALE      255

#ifdef FE_SB // ROTATION: ulGetRotate() function body

/******************************Private*Routine*****************************\
*
* VOID vComputeRotatedXform()
*
* History :
*
*  14-Feb-1993 -By- Hideyuki Nagase [HideyukN]
* Wrote it.
\**************************************************************************/

VOID
vComputeRotatedXform
(
POINTL      *pptlScale,
LONG         lXscale ,
LONG         lYscale
)
{

// If the caling factor is 0 , We have to set it to 1 for avoiding overflow

    if( lXscale == 0L )
    {
        pptlScale->x = 1L;
    }
    else
    {
        pptlScale->x = lXscale;

        if( pptlScale->x < 0 )
            pptlScale->x = -(pptlScale->x);

        if( pptlScale->x > MAX_HORZ_SCALE )
            pptlScale->x = MAX_HORZ_SCALE;
    }

    if( lYscale == 0L )
    {
        pptlScale->y = 1L;
    }
    else
    {
        pptlScale->y = lYscale;

        if( pptlScale->y < 0 )
            pptlScale->y = -(pptlScale->y);

        if( pptlScale->y > MAX_VERT_SCALE )
            pptlScale->y = MAX_VERT_SCALE;
    }
}

/******************************Public*Routine******************************\
* ULONG  ulGetRotate()
*
* Effects:
*
* Warnings:
*
* History:
*
*  8-Feb-1993 -by- Hideyuki Nagase [HideyukN]
* Wrote it.
\**************************************************************************/

ULONG ulGetRotate( POINTL *pptlScale , XFORMOBJ *pxo )
{
    EFLOAT efXX , efXY , efYX , efYY;
    LONG    lXX ,  lXY ,  lYX ,  lYY;
    XFORML  xform;

// Get the transform elements.

    XFORMOBJ_iGetXform(pxo,&xform);

// Convert elements of the matrix from IEEE float to our EFLOAT.

    vEToEF(xform.eM11 , &efXX );
    vEToEF(xform.eM12 , &efXY );
    vEToEF(xform.eM21 , &efYX );
    vEToEF(xform.eM22 , &efYY );

// Convert these from EFLOAT to LONG

    if( !bEFtoL( &efXX , &lXX ) ||
        !bEFtoL( &efXY , &lXY ) ||
        !bEFtoL( &efYX , &lYX ) ||
        !bEFtoL( &efYY , &lYY )
      )
    {
        WARNING("BMFD!bEToEF() fail\n");
        vComputeRotatedXform( pptlScale , MAX_HORZ_SCALE , MAX_VERT_SCALE );
        return( 0L );
    }

// Check transform.

//
// 0 '                  180 '
//
// (  1  0 )(X) = ( X)   ( -1  0 )(X) = (-X)     ( XX XY )(X)
// (  0  1 )(Y)   ( Y)   (  0 -1 )(Y)   (-Y)     ( YX YY )(Y)
//
// 90 '                 270 '
//
// (  0 -1 )(X) = (-Y)   (  0  1 )(X) = ( Y)
// (  1  0 )(Y)   ( X)   ( -1  0 )(Y)   (-X)
//

#ifdef FIREWALLS_MORE
    DbgPrint(" XX = %ld , XY = %ld\n" , lXX , lXY );
    DbgPrint(" YX = %ld , YY = %ld\n" , lYX , lYY );
#endif // FIREWALLS_MORE

    if ( ( lXX >  0 && lXY == 0 ) &&
         ( lYX == 0 && lYY >  0 ) )
    {

    // We have to Rotate bitmap image to 0 degree

    // Compute X Y scaling factor

         vComputeRotatedXform( pptlScale , lXX , lYY );
         return( 0L );
    }
    else if ( ( lXX == 0 && lXY <  0 ) &&
              ( lYX >  0 && lYY == 0 ) )
    {
         vComputeRotatedXform( pptlScale , lXY , lYX );
         return( 900L );
    }
    else if ( ( lXX <  0 && lXY == 0 ) &&
              ( lYX == 0 && lYY <  0 ) )
    {
         vComputeRotatedXform( pptlScale , lXX , lYY );
         return( 1800L );
    }
    else if ( ( lXX == 0 && lXY >  0 ) &&
              ( lYX <  0 && lYY == 0 ) )
    {
         vComputeRotatedXform( pptlScale , lXY , lYX );
         return( 2700L );
    }

    //
    // we are here because:
    // 1) we are asked to handle arbitrary rotation. ( this should not happen )
    // 2) lXX == lXY == lYX == lYY == 0
    //
    // we choose default transformation
    //

    vComputeRotatedXform( pptlScale , 1L , 1L );

#ifdef FIREWALLS_MORE
    WARNING("Bmfd:ulGetRatate():Use default transform ( ulRotate = 0 )\n");
#endif // FIREWALLS_MORE

    return( 0L );
}

#endif // FE_SB


#ifndef FE_SB // We use vComputeRotatedXform() instead of vInitXform()

/******************************Private*Routine*****************************\
* VOID vInitXform
*
* Initialize the coefficients of the transforms for the given font context.
* It also transforms and saves various measurements of the font in the
* context.
*
*  Mon 01-Feb-1993 -by- Bodin Dresevic [BodinD]
* update: changed it to return data into pptlScale
*
\**************************************************************************/



VOID vInitXform(POINTL * pptlScale , XFORMOBJ *pxo)
{
    EFLOAT    efloat;
    XFORM     xfm;

// Get the transform elements.

    XFORMOBJ_iGetXform(pxo, &xfm);

// Convert elements of the matrix from IEEE float to our EFLOAT.

    vEToEF(xfm.eM11, &efloat);

//  If we overflow set to the maximum scaling factor

    if( !bEFtoL( &efloat, &pptlScale->x ) )
        pptlScale->x = MAX_HORZ_SCALE;
    else
    {
    // Ignore the sign of the scale

        if( pptlScale->x == 0 )
        {
            pptlScale->x = 1;
        }
        else
        {
            if( pptlScale->x < 0 )
                pptlScale->x = -pptlScale->x;


            if( pptlScale->x > MAX_HORZ_SCALE )
                pptlScale->x = MAX_HORZ_SCALE;
        }
    }

    vEToEF(xfm.eM22, &efloat);

    if( !bEFtoL( &efloat, &pptlScale->y ) )
        pptlScale->y = MAX_VERT_SCALE;
    else
    {
    // Ignore the sign of the scale

        if( pptlScale->y == 0 )
        {
            pptlScale->y = 1;
        }
        else
        {
            if( pptlScale->y < 0 )
                pptlScale->y = -pptlScale->y;

            if( pptlScale->y > MAX_VERT_SCALE )
                pptlScale->y = MAX_VERT_SCALE;
        }

    }

}


#endif

/******************************Public*Routine******************************\
* BmfdOpenFontContext
*
* History:
*  19-Nov-1990 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

HFC
BmfdOpenFontContext (
    FONTOBJ *pfo
    )
{
    PFONTFILE    pff;
    FACEINFO     *pfai;
    FONTCONTEXT  *pfc = (FONTCONTEXT *)NULL;
    PCVTFILEHDR  pcvtfh;
    ULONG        cxMax;
    ULONG        cjGlyphMax;
    POINTL       ptlScale;
    PVOID        pvView;
    COUNT        cjView;
    ULONG        cjfc = offsetof(FONTCONTEXT,ajStretchBuffer);
    FLONG        flStretch;
#ifdef FE_SB
    ULONG        cxMaxNoRotate;
    ULONG        cjGlyphMaxNoRotate;
    ULONG        cyMax;
    ULONG        ulRotate;
#endif // FE_SB

#ifdef DUMPCALL
    DbgPrint("\nBmfdOpenFontContext(");
    DbgPrint("\n    FONTOBJ *pfo = %-#8lx", pfo);
    DbgPrint("\n    )\n");
#endif

    if ( ((HFF) pfo->iFile) == HFF_INVALID)
        return(HFC_INVALID);

    pff = PFF((HFF) pfo->iFile);

    if ((pfo->iFace < 1L) || (pfo->iFace > pff->cFntRes)) // pfo->iFace values are 1 based
        return(HFC_INVALID);

    pfai = &pff->afai[pfo->iFace - 1];
    pcvtfh = &(pfai->cvtfh);

    if ((pfo->flFontType & FO_SIM_BOLD) && (pfai->pifi->fsSelection & FM_SEL_BOLD))
        return HFC_INVALID;
    if ((pfo->flFontType & FO_SIM_ITALIC) && (pfai->pifi->fsSelection & FM_SEL_ITALIC))
        return HFC_INVALID;

#ifdef FE_SB // BmfdOpenFontContext():Get Rotate and compute XY scaling

// get rotation ( 0 , 900 , 1800 or 2700 )
// And we compute horizontal and vertical scaling factors

    ulRotate = ulGetRotate( &ptlScale , FONTOBJ_pxoGetXform(pfo));

#else  // We compute horizontal and vertical scaling facter in above function.

// compute the horizontal and vertical scaling factors

    vInitXform(&ptlScale, FONTOBJ_pxoGetXform(pfo));

#endif


#ifdef FE_SB // BmfdOpenFontConText(): Compute cjGlyphMax

// Compute cjGlyphMax of Rotated font

    cjGlyphMaxNoRotate =
        cjGlyphDataSimulated(
            pfo,
            (ULONG)pcvtfh->usMaxWidth * ptlScale.x,
            (ULONG)pcvtfh->cy * ptlScale.y,
            &cxMaxNoRotate,
            0L);

// In Y axis, We do not have to consider font simulation.

    cyMax = (ULONG)pcvtfh->cy * ptlScale.y;

    if( ( ulRotate == 0L ) || ( ulRotate == 1800L ) )
    {

    // In the case of 0 or 180 degree.

        cjGlyphMax = cjGlyphMaxNoRotate;
        cxMax = cxMaxNoRotate;
    }
     else
    {

    // In the case of 90 or 270 degree.
    // Compute simulated and rotated cjGlyphMax.

        cjGlyphMax =
            cjGlyphDataSimulated(
                pfo,
                (ULONG)pcvtfh->usMaxWidth * ptlScale.x,
                (ULONG)pcvtfh->cy * ptlScale.y,
                NULL,
                ulRotate);

        cxMax = cyMax;
    }

#ifdef DBG_MORE
    DbgPrint("clGlyphMax - 0x%x\n",cjGlyphMax);
#endif

#else
    cjGlyphMax =
        cjGlyphDataSimulated(
            pfo,
            (ULONG)pcvtfh->usMaxWidth * ptlScale.x,
            (ULONG)pcvtfh->cy * ptlScale.y,
            &cxMax);
#endif

// init stretch flags

    flStretch = 0;
    if ((ptlScale.x != 1) || (ptlScale.y != 1))
    {
#ifdef FE_SB // BmfdOpenFontContext() Adjust stretch buffer
        ULONG cjScan = CJ_SCAN(cxMaxNoRotate);
#else
        ULONG cjScan = CJ_SCAN(cxMax); // cj of the stretch buffer
#endif

        flStretch |= FC_DO_STRETCH;

        if (cjScan > CJ_STRETCH) // will use the one at the bottom of FC
        {
            cjfc += cjScan;
            flStretch |= FC_STRETCH_WIDE;
        }
    }

// allocate memory for the font context and get the pointer to font context
// NOTE THAT WE ARE NOT TOUCHING THE MEMORY MAPPED FILE AFTER WE ALLOCATE MEMORY
// IN THIS ROUTINE. GOOD CONSEQUENCE OF THIS IS THAT NO SPECIAL CLEAN UP
// CODE IS NECESSARY TO FREE THAT MEMORY, IT WILL GET CLEANED WHEN
// CloseFontContext is called [bodind]

    if (!(pfc = PFC(hfcAlloc(cjfc))))
    {
        SAVE_ERROR_CODE(ERROR_NOT_ENOUGH_MEMORY);
        return(HFC_INVALID);
    }

    pfc->ident  = ID_FONTCONTEXT;

// state that the hff passed to this function is the FF selected in
// this font context

    pfc->hff        = (HFF) pfo->iFile;
    pfc->pfai       = pfai;
    pfc->flFontType = pfo->flFontType;
    pfc->ptlScale   = ptlScale;
    pfc->flStretch  = flStretch;
    pfc->cxMax      = cxMax;
    pfc->cjGlyphMax = cjGlyphMax;
#ifdef FE_SB // BmfdOpenFontContext() keep rotation degree in FONTCONTEXT
    pfc->ulRotate   = ulRotate;
#endif // FE_SB

// increase the reference count of the font file
// ONLY AFTER WE ARE SURE THAT WE CAN NOT FAIL ANY MORE
// make sure that another thread is not doing it at the same time
// opening another context off of the same fontfile pff

    EngAcquireSemaphore(ghsemBMFD);

    // if this is the first font context corresponding to this font file
    // and then we have to remap file to memory and make sure the pointers
    // to FNT resources are updated accordingly

    if (pff->cRef == 0)
    {
        INT  i;

        if (!EngMapFontFileFD(pff->iFile, (PULONG *) &pvView, &cjView))
        {
            WARNING("BMFD!somebody removed that bm font file!!!\n");

            EngReleaseSemaphore(ghsemBMFD);
            VFREEMEM(pfc);
            return HFC_INVALID;
        }

        for (i = 0; i < (INT)pff->cFntRes; i++)
        {
            pff->afai[i].re.pvResData = (PVOID) (
                (BYTE*)pvView + pff->afai[i].re.dpResData
                );
        }
    }

// now can not fail, update cRef

    (pff->cRef)++;
    EngReleaseSemaphore(ghsemBMFD);

    return((HFC)pfc);
}


/******************************Public*Routine******************************\
* BmfdDestroyFont
*
* Driver can release all resources associated with this font realization
* (embodied in the FONTOBJ).
*
* History:
*  30-Aug-1992 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

VOID
BmfdDestroyFont (
    FONTOBJ *pfo
    )
{
//
// For the bitmap font driver, this is simply closing the font context.
// We cleverly store the font context handle in the FONTOBJ pvProducer
// field.
//

// This pvProducer could be null if exception occured while
// trying to create fc

    if (pfo->pvProducer)
    {
        BmfdCloseFontContext((HFC) pfo->pvProducer);
        pfo->pvProducer = NULL;
    }
}


/******************************Public*Routine******************************\
* BmfdCloseFontContext
*
* History:
*  19-Nov-1990 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

BOOL
BmfdCloseFontContext (
    HFC hfc
    )
{
    PFONTFILE    pff;
    BOOL bRet;

    if (hfc != HFC_INVALID)
    {
        //
        // get the handle of the font file that is selected into this FONTCONTEXT
        // get the pointer to the FONTFILE
        //

        pff = PFF(PFC(hfc)->hff);

        // decrement the reference count for the corresponding FONTFILE
        // make sure that another thread is not doing it at the same time
        // closing  another context off of the same fontfile pff

        EngAcquireSemaphore(ghsemBMFD);

        if (pff->cRef > 0L)
        {
            (pff->cRef)--;

            //
            // if this file is temporarily going out of use, unmap it
            //

            if (pff->cRef == 0)
            {
                if (!(pff->fl & FF_EXCEPTION_IN_PAGE_ERROR))
                {
                // if FF_EXCEPTION_IN_PAGE_ERROR is set
                // the file should have been unmapped
                // in vBmfdMarkFontGone function

                    EngUnmapFontFileFD(pff->iFile);
                }
                pff->fl &= ~FF_EXCEPTION_IN_PAGE_ERROR;
            }


            // free the memory associated with hfc

            VFREEMEM(hfc);

            bRet = TRUE;
        }
        else
        {
            WARNING("BmfdCloseFontContext: cRef <= 0\n");
            bRet = FALSE;
        }

        EngReleaseSemaphore(ghsemBMFD);
    }
    else
    {
        bRet = FALSE;
    }

    return bRet;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\bmfd\fdcvt.c ===
/******************************Module*Header*******************************\
* Module Name: fdcvt.c
*
* ifi interface calls, file loading and file conversions.
*
* Created: 22-Oct-1990 13:33:55
* Author: Bodin Dresevic [BodinD]
*
* Copyright (c) 1990 Microsoft Corporation
\**************************************************************************/

#include "fd.h"
#include "ctype.h"
#include "exehdr.h"
#include <string.h>

#if DBG
unsigned gflBmfdDebug = 0;
#define BMFD_DEBUG_DUMP_HEADER 1
typedef VOID (*VPRINT) (char*,...);
VOID vDumpFontHeader(PRES_ELEM, VPRINT);
#endif

// This points to the base of our list of FD_GLYPHSETS

CP_GLYPHSET *gpcpGlyphsets = NULL;

/******************************Public*Routine******************************\
* BmfdQueryFontCaps
*
* Effects: returns the capabilities of this driver.
*          Only mono bitmaps are supported.
*
* History:
*  27-Nov-1990 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

LONG BmfdQueryFontCaps(ULONG culCaps, PULONG pulCaps)
{
    ASSERTGDI(culCaps == 2, "ERROR why would the engine call us like this");

    pulCaps[0] = 2L;

    //
    // 1 bit per pel bitmaps only are supported
    //

    pulCaps[1] = QC_1BIT;

    return(2L);
}

/******************************Public*Routine******************************\
* BmfdUnloadFontFile(HFF hff)
*
* Frees the resources that have been loced allocated by BmfdLoadFontFile
* BmfdLoadFontResData
*
* History:
*  15-Nov-1990 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

BOOL
BmfdUnloadFontFile(
    HFF hff
    )
{
    FACEINFO    *pfai, *pfaiTooFar;

    ASSERTGDI(hff, "BmfdUnloadFontFile, hff\n");

// check the reference count, if not 0 (font file is still
// selected into a font context) we have a problem

    ASSERTGDI(PFF(hff)->cRef == 0L, "cRef: did not update links properly\n");

// free the memory associated with all converted files

    pfai = PFF(hff)->afai;
    pfaiTooFar = pfai + PFF(hff)->cFntRes;

    EngAcquireSemaphore(ghsemBMFD);

    while (pfai < pfaiTooFar)
    {
        vUnloadGlyphset(&gpcpGlyphsets, pfai->pcp);
        pfai += 1;
    }

    EngReleaseSemaphore(ghsemBMFD);

// free memory associated with this FONTFILE object,

    VFREEMEM(hff);
    return(TRUE);
}


/******************************Public*Routine******************************\
*
* FSHORT fsSelectionFlags(PBYTE ajHdr)
*
* Effects: compute fsSelection field of the ifimetrics
*
* History:
*  13-May-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

FSHORT
fsSelectionFlags(
    PBYTE ajHdr
    )
{
    FSHORT fsSelection = 0;

    if (ajHdr[OFF_Italic])
        fsSelection |= FM_SEL_ITALIC;

    if (ajHdr[OFF_Underline])
        fsSelection |= FM_SEL_UNDERSCORE;

    if (ajHdr[OFF_StrikeOut])
        fsSelection |= FM_SEL_STRIKEOUT;

#ifdef DEBUG_ITALIC
    DbgPrint("It = %ld, Str = %ld, Und = %ld, Asc = %ld\n",
       (ULONG)ajHdr[OFF_Italic],
       (ULONG)ajHdr[OFF_StrikeOut],
       (ULONG)ajHdr[OFF_Underline],
       (ULONG)sMakeSHORT((PBYTE)&ajHdr[OFF_Ascent])
       );
#endif // DEBUG_ITALIC

// the following line is somewhat arbitrary, we set the FM_SEL_BOLD
// flag iff weight is > FW_NORMAL (400). we will not allow emboldening
// simulation on the font that has this flag set

    if (usMakeUSHORT((PBYTE)&ajHdr[OFF_Weight]) > FW_NORMAL)
        fsSelection |= FM_SEL_BOLD;

    return(fsSelection);
}


/******************************Public*Routine******************************\
*
*    vAlignHdrData
*
* Effects: packs header data into dword alligned structure
*
* History:
*  29-Oct-1990 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/


VOID
vAlignHdrData(
    PCVTFILEHDR  pcvtfh,
    PRES_ELEM    pre
    )
{
    PBYTE ajHdr  = (PBYTE)pre->pvResData;

#ifdef DUMPCALL
    DbgPrint("\nvAlignHdrData("                             );
    DbgPrint("\n    PCVTFILEHDR  pcvtfh = %-#8lx", pcvtfh   );
    DbgPrint("\n    PRES_ELEM    pre    = %-#8lx", pre      );
    DbgPrint("\n    )\n"                                    );
#endif


    /******************************************************/
    /**/  #if DBG                                       /**/
    /**/    if (gflBmfdDebug & BMFD_DEBUG_DUMP_HEADER)  /**/
    /**/      vDumpFontHeader(pre, (VPRINT) DbgPrint);  /**/
    /**/  #endif                                        /**/
    /******************************************************/
// zero out the whole structure before doing anything

    RtlZeroMemory(pcvtfh, sizeof(CVTFILEHDR));

// The iVersion only had length of 2 bytes in the original struct

    pcvtfh->iVersion = usMakeUSHORT((PBYTE)&ajHdr[OFF_Version]);

    pcvtfh->chFirstChar   = ajHdr[OFF_FirstChar  ];
    pcvtfh->chLastChar    = ajHdr[OFF_LastChar   ];
    pcvtfh->chDefaultChar = ajHdr[OFF_DefaultChar];
    pcvtfh->chBreakChar   = ajHdr[OFF_BreakChar  ];

    pcvtfh->cy = usMakeUSHORT((PBYTE)&ajHdr[OFF_PixHeight]);

#ifdef FE_SB // vAlignHdrData():Get DBCS character's width
    pcvtfh->usCharSet     = (USHORT) ajHdr[OFF_CharSet];

    if( !IS_ANY_DBCS_CHARSET( pcvtfh->usCharSet ) )
#endif // FE_SB
    {
        // Fri 29-Apr-1994 07:11:06 by Kirk Olynyk [kirko]
        //
        // There are some buggy font files that are fixed pitch but
        // have a MaxWidth greater than the fixed pitch width
        // e.g. "Crosstalk IBMPC Fonts v2.0". We check for the
        // disparity here. If the font is fixed pitch, as indicated
        // by a non zero value of PixWidth, and the average width
        // is equal to the fixed pitch width, then the maximum
        // pixel width (MaxWidth) is set equal to the PixWidth.
        // If the MaxWidth value was correct, then this piece
        // of code puts in a bad value for the maxiumum width.
        // But this will be fixed! The calling sequences of
        // interest are:
        //
        // bConverFontRes() calls bVerifyFNT() calls vAlignHdrData()
        //
        // then later in bConvertFontRes()
        //
        // bConverFontRes() calls vCheckOffsetTable()
        //
        // It is vCheckOffsetTabl() that would correct
        // the maximum pixel if it was incorrectly set here

        USHORT usPixWidth  = usMakeUSHORT(ajHdr + OFF_PixWidth);
        USHORT usAvgWidth  = usMakeUSHORT(ajHdr + OFF_AvgWidth);
        USHORT usMaxWidth  = usMakeUSHORT(ajHdr + OFF_MaxWidth);

        if (usPixWidth && usPixWidth == usAvgWidth)
            usMaxWidth = usPixWidth;
        pcvtfh->usMaxWidth = usMaxWidth;
#ifdef FE_SB // vAlignHdrData():Init DBCS width 0 for non DBCS font.
        pcvtfh->usDBCSWidth = 0;
#endif // FE_SB
    }
#ifdef FE_SB // vAlignHdrData():Get DBCS character's width
     else
    {
    // usMaxWidth specifies DBCS width in 3.0J and 3.1J font width of double byte
    // character let keep this value, because pcvtfh->usMaxWidth might be change in
    // vCheckOffsetTable()

        pcvtfh->usDBCSWidth = usMakeUSHORT(ajHdr + OFF_MaxWidth);
        pcvtfh->usMaxWidth  = usMakeUSHORT(ajHdr + OFF_MaxWidth);
    }
#endif // FE_SB


    if (pcvtfh->iVersion == 0x00000200)
        pcvtfh->dpOffsetTable = OFF_OffTable20;
    else if (pcvtfh->iVersion == 0x00000300)
        pcvtfh->dpOffsetTable = OFF_OffTable30;
    else
        pcvtfh->dpOffsetTable = -1; // will generate error

}

/******************************Public*Routine******************************\
* BOOL bDbgPrintAndFail(PSZ psz)
*
* History:
*  06-Dec-1990 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

#if DBG
BOOL
bDbgPrintAndFail(
    PSZ psz
    )
{
    DONTUSE(psz);
#ifdef DEBUGFF
    DbgPrint(psz);
#endif
    return(FALSE);
}

#else

#define bDbgPrintAndFail(psz) FALSE

#endif


BOOL
bVerifyFNTQuick(
    PRES_ELEM   pre
    )
{
#ifdef DUMPCALL
    DbgPrint("\nbVerifyResource("                       );
    DbgPrint("\n    PCVTFILEHDR pcvtfh = %-#8lx", pcvtfh);
    DbgPrint("\n    PRES_ELEM   pre    = %-#8lx", pre   );
    DbgPrint("\n    )\n"                                );
#endif

    PBYTE ajHdr  = (PBYTE)pre->pvResData;

    if ((READ_WORD(&ajHdr[OFF_Type]) & TYPE_VECTOR))   // Vector bit has to
        return(bDbgPrintAndFail("fsType \n"));          // be off

    if ((READ_WORD(&ajHdr[OFF_Version]) != 0x0200) &&     // The only version
        (READ_WORD(&ajHdr[OFF_Version]) != 0x0300) )      // The only version
        return(bDbgPrintAndFail("iVersion\n"));         // supported.

    return TRUE;
}

/******************************Public*Routine******************************\
* bVerifyResource
*
* Effects: CHECK whether header contains file info which corresponds to
*          the raster font requirements, go into the file and check
*          the consistency of the header data
*
* History:
*  30-Oct-1990 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

BOOL
bVerifyResource(
    PCVTFILEHDR pcvtfh,
    PRES_ELEM   pre
    )
{
#ifdef DUMPCALL
    DbgPrint("\nbVerifyResource("                       );
    DbgPrint("\n    PCVTFILEHDR pcvtfh = %-#8lx", pcvtfh);
    DbgPrint("\n    PRES_ELEM   pre    = %-#8lx", pre   );
    DbgPrint("\n    )\n"                                );
#endif

    PBYTE ajHdr  = (PBYTE)pre->pvResData;
    ULONG cjSize;
    LONG  dpBits = lMakeLONG((PBYTE)&ajHdr[OFF_BitsOffset]);
    SHORT sAscent;


    ASSERTGDI(
        ((READ_WORD(&ajHdr[OFF_Version]) == 0x0200) || (READ_WORD(&ajHdr[OFF_Version]) == 0x0300)),
        "BMFD!wrong iVersion for bitmap  font\n"
        );

    if (pcvtfh->iVersion == 0x00000200)
        if (dpBits > SEGMENT_SIZE)
            return(bDbgPrintAndFail("dpBits \n")); // Bits Offset Not Ok

// file size must be <= than the size of the view

    cjSize = ulMakeULONG(ajHdr + OFF_Size);
    if (cjSize > pre->cjResData)
    {
        cjSize = pre->cjResData; // no offset can be bigger than this
    }

    sAscent     = sMakeSHORT((PBYTE)&ajHdr[OFF_Ascent]);
    if (abs(sAscent) > (SHORT)pcvtfh->cy)
        return(bDbgPrintAndFail("sAscent \n")); // Ascent Too Big

    if (sMakeSHORT((PBYTE)&ajHdr[OFF_ExtLeading]) < 0)
        return(bDbgPrintAndFail("ExtLeading \n")); // Ext Lead Not Ok;

#if DBG

// CHECK fsType field, if vector type, this would have been caught by
// bVerifyFNTQuick

    ASSERTGDI(
        (READ_WORD(&ajHdr[OFF_Type]) & TYPE_VECTOR) == 0,
        "bmfd!this mustn't have been a vector font\n"
        );

    if (sMakeSHORT((PBYTE)&ajHdr[OFF_IntLeading]) < 0)
        DbgPrint(
            "bmfd warning: possibly bad font file - sIntLeading = %ld\n\n",
            (LONG)sMakeSHORT((PBYTE)&ajHdr[OFF_IntLeading])
            );

#endif

    if (sMakeSHORT((PBYTE)&ajHdr[OFF_IntLeading]) > sAscent)
        return(bDbgPrintAndFail(" IntLeading too big\n")); // Int Lead Too Big;

// check consistency of character ranges

    if (pcvtfh->chFirstChar > pcvtfh->chLastChar)
        return(bDbgPrintAndFail(" FirstChar\n")); // this can't be

// default and break character are given relative to the FirstChar,
// so that the actual default (break) character is given as
// chFirst + chDefault(Break)

    if ((UCHAR)(pcvtfh->chDefaultChar + pcvtfh->chFirstChar) > pcvtfh->chLastChar)
    {
    // here we will do something which never should have been done if
    // win 3.0 did any parameter validation on loading fonts .
    // This is done in order not to reject fonts that have only Def and Break
    // chars messed up, but everything else is ok. Example of such shipped
    // fonts are some samna corp. fonts that come with AmiPro application.
    // Their Def char is the absolute value rather than value relative to
    // the first char in the font. This is of course the bug in the font
    // files, but since win30 does not reject these files, we must not do that
    // either.

    #if DBG
        DbgPrint("bmfd!_bVerifyResource: warning -- bogus Default char = %ld\n", (ULONG)pcvtfh->chDefaultChar);
    #endif

        if ((pcvtfh->chDefaultChar >= pcvtfh->chFirstChar) && (pcvtfh->chDefaultChar <= pcvtfh->chLastChar))
        {
        // attempt to fix the problem stemming from the bug in the font file

            pcvtfh->chDefaultChar -= pcvtfh->chFirstChar;
        }
        else
        {
        // this definitely is not a sensible font file, but samna provided us
        // withone such font as well

            pcvtfh->chDefaultChar = 0;
        }
    }

    if ((UCHAR)(pcvtfh->chBreakChar + pcvtfh->chFirstChar) > pcvtfh->chLastChar)
    {
    // here we will do something which never should have been done if
    // win 3.0 did any parameter validation on loading fonts .
    // This is done in order not to reject fonts that have only Def and Break
    // chars messed up, but everything else is ok. Example of such shipped
    // fonts are some samna corp. fonts that come with AmiPro application.
    // Their Break char is the absolute value rather than value relative to
    // the first char in the font. This is of course the bug in the font
    // files, but since win30 does not reject these files, we must not do that
    // either.

    #if DBG
        DbgPrint("bmfd!_bVerifyResource: warning bogus Break char = %ld\n", (ULONG)pcvtfh->chBreakChar);
    #endif

        if ((pcvtfh->chBreakChar >= pcvtfh->chFirstChar) && (pcvtfh->chBreakChar <= pcvtfh->chLastChar))
        {
        // attempt to fix the problem stemming from the bug in the font file

            pcvtfh->chBreakChar -= pcvtfh->chFirstChar;
        }
        else
        {
        // this definitely is not a sensible font file, but samna provided us
        // with one such font as well

            pcvtfh->chBreakChar = 0;
        }
    }

// offset to the offset table

    ASSERTGDI((pcvtfh->dpOffsetTable & 1) == 0, "dpOffsetTable is not even\n");

    if ((pcvtfh->dpOffsetTable != OFF_OffTable20) &&
        (pcvtfh->dpOffsetTable != OFF_OffTable30))
        return(bDbgPrintAndFail("dpOffsetTable \n"));

// make sure that the first offset in the offset table is equal to dpBits,
// this is an internal consistency check of the font, also verify that
// all offsets are smaller than cjSize

    {
        PBYTE pjFirstOffset = (PBYTE)pre->pvResData + pcvtfh->dpOffsetTable + 2;
        UINT  cGlyphs = pcvtfh->chLastChar - pcvtfh->chFirstChar + 1;
        PBYTE pjOffsetEnd;

        if (pcvtfh->iVersion == 0x00000200)
        {
        // in 2.0 offsets are 16 bit

            if (dpBits != (PTRDIFF)(*((PUSHORT)pjFirstOffset)))
                return(bDbgPrintAndFail("2.0 pjFirstOffset \n"));

            pjOffsetEnd = pjFirstOffset + cGlyphs * 4;
            for ( ; pjFirstOffset < pjOffsetEnd; pjFirstOffset += 4)
            {
                if ((ULONG)READ_WORD(pjFirstOffset) > cjSize)
                    return bDbgPrintAndFail("invalid offset in 2.0 bm font\n");
            }
        }
        else // 3.0 guarantedd by the very first check
        {
        // in 3.0 offsets are 32 bit

            if (dpBits != (PTRDIFF)ulMakeULONG(pjFirstOffset))
                return(bDbgPrintAndFail("3.0 pjFirstOffset \n"));

            pjOffsetEnd = pjFirstOffset + cGlyphs * 6;
            for ( ; pjFirstOffset < pjOffsetEnd; pjFirstOffset += 6)
            {
                if (READ_DWORD(pjFirstOffset) > cjSize)
                    return bDbgPrintAndFail(" invalid offset in 3.0 bm font\n");
            }
        }
    }

// check 3.0 fields if necessary

    if (pcvtfh->iVersion == 0x00000300)
    {
        FSHORT fsFlags = usMakeUSHORT ((PBYTE)&ajHdr[OFF_Flags]);

        if (fsFlags & (DFF_16COLOR | DFF_256COLOR | DFF_RGBCOLOR))
            return(bDbgPrintAndFail("Flags: Do not support color fonts\n"));

        if (lMakeLONG((PBYTE)pre->pvResData + OFF_ColorPointer))
            return(bDbgPrintAndFail("dpColor: Do not support color fonts\n"));
    }

    return(TRUE);
}

/******************************Public*Routine******************************\
* bVerifyFNT
*
* Combine the two routines into a single one
*
* History:
*  27-Jan-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

BOOL
bVerifyFNT(
    PCVTFILEHDR pcvtfh,
    PRES_ELEM   pre
    )
{
#ifdef DUMPCALL
    DbgPrint("\nbVerifyFNT("                                );
    DbgPrint("\n    PCVTFILEHDR pcvtfh = %-#8lx", pcvtfh    );
    DbgPrint("\n    PRES_ELEM   pre    = %-#8lx", pre       );
    DbgPrint("\n    )\n"                                    );
#endif


// read nonalligned header data at the top of the view into an alligned structure

    vAlignHdrData(pcvtfh,pre);

// make sure that the data matches requirements of a windows bitmap font

    return(bVerifyResource(pcvtfh,pre));
}

/******************************Public*Routine******************************\
*
* BOOL bBmfdLoadFont    // forward declaration
*
* Loads an *.fon or an *.fnt file,
* returns handle to a fonfile object if successfull
*
* History:
*  27-Jan-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

BOOL bBmfdLoadFont    // forward declaration
(
HFF        iFile,
PBYTE      pvView,
ULONG      cjView,
ULONG      iType,
HFF        *phff
)
{
    PFONTFILE   pff;
    ULONG       cjff;
    WINRESDATA  wrd;
    RES_ELEM    re;
    ULONG       ifnt;
    ULONG       cjDescription;      // size of the desctiption string (in bytes)
    PTRDIFF     dpwszDescription;   // offset to the description string
    CHAR        achDescription[256];    // this is the max length of string
                                        // in the 16-bit EXE format.

#ifdef FE_SB // hffLoadFont()
    ULONG       cFontResIncludeVert;
#endif // FE_SB

    ULONG       dpIFI;
    IFIMETRICS *pifi;

    *phff = (HFF)NULL;

#ifdef DUMPCALL
    DbgPrint("\nbBmfdLoadFont("                 );
    DbgPrint("\n    ULONG      iType = %-#8lx"  );
    DbgPrint("\n    )\n"                        );
#endif

    ASSERTGDI((iType == TYPE_DLL16) || (iType == TYPE_FNT) || ((iType == TYPE_EXE)),
               "bmfd!bBmfdLoadFont(): unknown iType\n");

// If .FON format, there are possibly multiple font resources.  Handle it.

    if (iType == TYPE_DLL16)
    {
        if (!bInitWinResData(pvView,cjView,&wrd))
        {
            return FALSE;
        }
    }

// Otherwise, if .FNT format, the current file view may be used.

    else // fnt
    {
        re.pvResData = pvView;
        re.dpResData = 0;
        re.cjResData = cjView;
        re.pjFaceName = NULL;           // get the face name from the FNT resource
        wrd.cFntRes = 1;
    }

// If .FON format, retrieve the description string (because we won't have
// the mapped file view later and therefore cannot search for it later).


#ifdef FE_SB // hffLoadFont()
// We assume font all font resource is SHIFT_JIS font. We prepare room for Vertical font
    cjff = offsetof(FONTFILE,afai) + ( wrd.cFntRes * 2 ) * sizeof(FACEINFO);
#else
    cjff = offsetof(FONTFILE,afai) + wrd.cFntRes * sizeof(FACEINFO);
#endif

    dpwszDescription = 0;   // no description string, use Facename later
    cjDescription = 0;

    if ((iType == TYPE_DLL16) && bDescStr(pvView, achDescription))
    {
        dpwszDescription = cjff;
        cjDescription = (strlen(achDescription) + 1) * sizeof(WCHAR);
        cjff += cjDescription;
    }

// remember where the first ifimetrics goes

    dpIFI = cjff = ALIGN_UP( cjff, PVOID );

// compute the total amount of memory needed for the ifimetrics and everything
// else:

    for (ifnt = 0L; ifnt < wrd.cFntRes; ifnt++)
    {
        if (iType == TYPE_DLL16)
            vGetFntResource(&wrd,ifnt,&re);

    // do a preliminary check on the resource, before doing a thorough one

        if (!bVerifyFNTQuick(&re))
            return FALSE;

#ifdef FE_SB //
        cjff += ( cjBMFDIFIMETRICS(NULL,&re) * 2 );
#else
        cjff += cjBMFDIFIMETRICS(NULL,&re);
#endif
    }


// Allocate a FONTFILE of the appropriate size from the handle manager.

    if ((*phff = hffAlloc(cjff)) == HFF_INVALID)
    {
        SAVE_ERROR_CODE(ERROR_NOT_ENOUGH_MEMORY);
        RETURN("bmfd!bBmfdLoadFont(): memory allocation error\n", FALSE);
    }

    pff = PFF(*phff);


// Init fields of pff structure

    pff->ident      = ID_FONTFILE;
    pff->fl         = 0;
    pff->iType      = iType;
    pff->iFile    = iFile;        // will be needed at unload time
    pff->cFntRes    = wrd.cFntRes;
    pff->cjDescription    = cjDescription;
    pff->dpwszDescription = dpwszDescription;

// Convert each of the font resources (RES_ELEM) to a CVTRESDATA and a
// (set of) FACEDATA.

    pifi = (IFIMETRICS *)((PBYTE)pff + dpIFI);

#ifdef FE_SB // bBmfdLoadFont()

// We have to compute strict font face count include simulated @face

// ifnt                = Physical font counter
// cFontResIncludeVert = FACEINFO structure counter

    cFontResIncludeVert = 0;

    for (ifnt = 0L; ifnt < wrd.cFntRes; ifnt++)
    {
        // At first We process for nomal face font

        if (iType == TYPE_DLL16)
            vGetFntResource(&wrd,ifnt,&re);

        pff->afai[cFontResIncludeVert].re = re;    // remember this for easier access later
        pff->afai[cFontResIncludeVert].bVertical = FALSE;
        pff->afai[cFontResIncludeVert].pifi = pifi;

        if (!bConvertFontRes(&re,&pff->afai[cFontResIncludeVert]))
        {
        #ifdef DBG_NTRES
            WARNING("bmfd!hffLoadFont(): file format conversion failed\n");
        #endif // DBG_NTRES
            VFREEMEM(*phff);
            *phff = (HFF)NULL;
            return FALSE;
        }

        // Count Nomal face font

        cFontResIncludeVert ++;

        // Point it to next room

        pifi = (IFIMETRICS *)((PBYTE)pifi + pifi->cjThis);

        //
        // Check this font resource's Charset is some DBCS charset. If it is so , Set up
        // Vertical font stuff. Or not so. Increment counter.
        //
        // if the font is for DBCS font, usDBCSWidth is not be zero, the value is setted
        // above bConvertFontRes().
        //

        if( (pff->afai[cFontResIncludeVert - 1].cvtfh.usDBCSWidth) != 0 )
        {
            // Vertical Writting use the same font at SBCS CodeArea

            pff->afai[cFontResIncludeVert].re = re;

            // Vertical Writting use the different font at DBCS CoreArea

            pff->afai[cFontResIncludeVert].bVertical = TRUE;

            pff->afai[cFontResIncludeVert].pifi = pifi;

            // Convert font resource and setup CVTFILEHDR and IFIMETRICS

            if ( !bConvertFontRes(&re,&pff->afai[cFontResIncludeVert]))
            {
            #ifdef DBG_NTRES
                WARNING("bmfd!hffLoadFont(): file format conversion failed at Vertical font\n");
            #endif // DBG_NTRES
                VFREEMEM(*phff);
                *phff = (HFF)NULL;
                return FALSE;
            }

            // Count Vertical face font

            cFontResIncludeVert ++;

            // Point it to next room

            pifi = (IFIMETRICS *)((PBYTE)pifi + pifi->cjThis);
        }
    }

// We have strictly font resource count include simulated Vertical font now
// Reset font resource count in FONTFILE structure

    pff->cFntRes    = cFontResIncludeVert;

#else
    for (ifnt = 0L; ifnt < wrd.cFntRes; ifnt++)
    {
        if (iType == TYPE_DLL16)
            vGetFntResource(&wrd,ifnt,&re);

        pff->afai[ifnt].re   = re;    // remember this for easier access later
        pff->afai[ifnt].pifi = pifi;    // remember this for easier access later

        if (!bConvertFontRes(&re,&pff->afai[ifnt]))
        {
        #ifdef DBG_NTRES
            WARNING("bmfd!bBmfdLoadFont(): file format conversion failed\n");
        #endif // DBG_NTRES
            VFREEMEM(*phff);
            *phff = (HFF)NULL;
            return FALSE;
        }

        pifi = (IFIMETRICS *)((PBYTE)pifi + pifi->cjThis);
    }
#endif


// If we found a description string, store it in the FONTFILE.

    if (cjDescription != 0)
        vToUNICODEN((PWSZ) ((PBYTE) pff + dpwszDescription), cjDescription/sizeof(WCHAR), achDescription, cjDescription/sizeof(WCHAR));

// Initialize the rest.

    pff->cRef = 0;

    return TRUE;
}



/******************************Public*Routine******************************\
* jFamilyType(FSHORT fsPitchAndFamily)
*
* computes jFamilyType field of the panose structure
*
* History:
*  19-Dec-1990 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

BYTE
jFamilyType(
    FSHORT fsPitchAndFamily
    )
{
    BYTE j;

    if (fsPitchAndFamily & FF_DONTCARE)
        j = PAN_ANY;
    else if (fsPitchAndFamily & FF_SCRIPT)
        j = PAN_FAMILY_SCRIPT;
    else if (fsPitchAndFamily & FF_DECORATIVE)
        j = PAN_FAMILY_DECORATIVE;
    else
    {
        j = PAN_FAMILY_TEXT_DISPLAY;
    }
    return(j);
}

/******************************Public*Routine******************************\
* bConvertFontRes
*
* format of the converted file:
*
* converted header on the top, followed by array of IFIMETRICS structures,
* followed by the table of offsets to GLYPHDATA structures for individual
* glyphs, followed by an array of GLYPHDATA structures themselves
*
* Warnings:
*
* History:
*  13-Nov-1990 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

BOOL
bConvertFontRes(
    PRES_ELEM    pre,            // IN
    FACEINFO    *pfai            // OUT
    )
{

#ifdef DUMPCALL
    DbgPrint("\nbConverFontRes(\n"                  );
    DbgPrint("    PRES_ELEM    pre  = %-#8lx\n",pre );
    DbgPrint("    FACEINFO    *pfai = %-#8lx\n",pfai);
    DbgPrint("    );\n\n"                           );
#endif

// make sure that the data matches requirements of a windows bitmap font
// Note: bVerifyFNT() does more than just look at the font -- it does
//       part of the conversion by copying the data to the CVFILEHDR
//       "converted file header"
//
    if(!bVerifyFNT(&pfai->cvtfh,pre))
    {
        return(FALSE);
    }

    ASSERTGDI(pfai->cvtfh.dpOffsetTable != -1L, "BMFD!bConvertFontRes(): could not align header\n");

// compute the size of the IFIMETRICS structure that is followed by
// FamilyName, FaceName and UniqueName UNICODE strings and simulations

    cjBMFDIFIMETRICS(&pfai->cvtfh,pre);

// compute the size of the converted file to be created, fix bugs in file header

    vCheckOffsetTable(&pfai->cvtfh, pre);

// calucate pfai->iDefFace

    vDefFace(pfai,pre);

// compute glyph set that corresponds to this resource:

    EngAcquireSemaphore(ghsemBMFD);

    pfai->pcp = pcpComputeGlyphset(&gpcpGlyphsets,
                                   (UINT) pfai->cvtfh.chFirstChar,
                                   (UINT) pfai->cvtfh.chLastChar,
                                   ((PBYTE)pre->pvResData)[OFF_CharSet]);

    EngReleaseSemaphore(ghsemBMFD);

    if (pfai->pcp == NULL)
    {
        // If we fail it should be because of we are out of memory.

       SAVE_ERROR_CODE(ERROR_NOT_ENOUGH_MEMORY);
       WARNING("BMFD!bConvertFontRes(): memory allocation error\n");
       return(FALSE);
    }

    // fill the ifimetrics

    vBmfdFill_IFIMETRICS(pfai,pre);

    return(TRUE);
}

/******************************Public*Routine******************************\
* cjBMFDIFIMETRICS
*
* Effects:  returns the size cjIFI of IFIMETRICS struct, with appended strings
*           cashes the lengths of these strings,pszFamilyName, and cjIFI
*           for later use by vBmfdFill_IFIMETRICS
* Warnings:
*
* History:
*  20-Oct-1992 -by- Kirk Olynyk [kirko]
* The IFIMETRICS structure has changed. The effect of the change upon
* this procedure is to allocate room for the new simulation structure
* FONTDIFF which informs GDI of the available simulations.
*  20-Nov-1990 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

ULONG
cjBMFDIFIMETRICS(
    PCVTFILEHDR pcvtfh,
    PRES_ELEM   pre
    )
{
// face name lives in the original file

    ULONG cSims,cjIFI,cjFaceName;
    PSZ pszFaceName;


    if( pre->pjFaceName == NULL )
    {
    // get facename from FNT resource for non 16bit resource files

        pszFaceName = (PSZ)((PBYTE)pre->pvResData +
            lMakeLONG((PBYTE)pre->pvResData + OFF_Face));
    }
    else
    {
    // otherwise get facename from the FONTDIR resource for win 3.1
    // compatibility reasons

        pszFaceName = pre->pjFaceName;

    }

// 1 is added to the length of a string in WCHAR's
// so as to allow for the terminating zero character, the number of
// WCHAR's is then multiplied by 2 to get the corresponding number of bytes,
// which is then rounded up to a DWORD boundary for faster access

#ifdef FE_SB // VERTICAL:cjIFIMETRICS(): make room for '@'
    cjFaceName   = ALIGN4(sizeof(WCHAR) * (strlen(pszFaceName) + 1 + 1));
#else
    cjFaceName   = ALIGN4(sizeof(WCHAR) * (strlen(pszFaceName) + 1));
#endif

// the full size of IFIMETRICS is the size of the structure itself followed by
// the appended strings AND the 3 FONTDIFF structures corresponding to the
// BOLD, ITALIC, and BOLD_ITALIC simulations.

    cjIFI = sizeof(IFIMETRICS) + cjFaceName;

    if (cSims = (cFacesRes(pre) - 1))
    {
        cjIFI += sizeof(FONTSIM) + cSims * sizeof(FONTDIFF);
    }

    cjIFI = ALIGN_UP( cjIFI, PVOID );

    if (pcvtfh)
    {
    // cache the lengths of these strings for later use

        pcvtfh->cjFaceName   = cjFaceName;
        pcvtfh->cjIFI        = cjIFI;
    }

// make sure that the result is a multiple of ULONG size, otherwise we may
// have a problem when making arrays of IFIMETRICS structures

    ASSERTGDI((cjIFI & 3L) == 0L, "ifi is not DWORD alligned\n");

    return cjIFI;
}

/******************************Public*Routine******************************\
* bNonZeroRow
*
* History:
*  21-Jun-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

BOOL
bNonZeroRow(
    PBYTE pjRow,
    ULONG cy,
    ULONG cjWidth
    )
{
    ULONG ij;  // index into a byte

    for (ij = 0; ij < cjWidth; ij++, pjRow += cy)
    {
        if (*pjRow)
        {
            return(TRUE);
        }
    }
    return(FALSE);  // zero scan
}

/******************************Public*Routine******************************\
* vFindTAndB
*
* computes top and bottom of the ink using the bits in the raw fnt format
*
* History:
*  21-Jun-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

VOID
vFindTAndB(
    PBYTE pjBitmap, // pointer to the bitmap in *.fnt column format
    ULONG cx,
    ULONG cy,
    ULONG *pyTopIncMin,
    ULONG *pyBottomExcMax
    )
{
    ULONG cjWidth = CJ_SCAN(cx); // # of bytes in row of the bitmap in the *.fnt format

    PBYTE pjRow,pjRowEnd;

#ifdef DUMPCALL
    DbgPrint("\nvFindTAndB(\n"                                          );
    DbgPrint("    PBYTE  pjBitmap          = %-#8lx\n",pjBitmap         );
    DbgPrint("    ULONG  cx                = %d\n",cx                   );
    DbgPrint("    ULONG  cy                = %d\n",cy                   );
    DbgPrint("    ULONG *pyTopIncMin       = %-#8lx\n",pyTopIncMin      );
    DbgPrint("    ULONG *pyBottomExcMax    = %-#8lx\n",pyBottomExcMax   );
    DbgPrint("    );\n\n"                                               );
#endif

    /* default them to null in every case to prevent accessing unitialized data
       in the case the bitmap is null, or all it's row are filled with zero */
    *pyTopIncMin = *pyBottomExcMax = 0;

// case of zero width glyphs

    if (!pjBitmap)
    {
    // no ink at all, out of here

        ASSERTGDI(cx == 0, "bmfd, vFindTAndB, cx != 0\n");

        return;
    }

// real glyphs

    for
    (
        pjRow = pjBitmap, pjRowEnd = pjRow + cy;
        pjRow < pjRowEnd;
        pjRow++
    )
    {
        if (bNonZeroRow(pjRow, cy, cjWidth))
        {
            *pyTopIncMin = (ULONG)(pjRow - pjBitmap);
            break;
        }
    }

    if (pjRow == pjRowEnd)
    {
    // no ink at all, out of here
        return;
    }

// start searhing backwards for the bottom

    for
    (
        pjRow = pjBitmap + (cy - 1);
        pjRow >= pjBitmap;
        pjRow--
    )
    {
        if (bNonZeroRow(pjRow, cy, cjWidth))
        {
            *pyBottomExcMax = (ULONG)((pjRow - pjBitmap) + 1); // + 1 for exclusiveness
            break;
        }
    }

    ASSERTGDI(*pyTopIncMin <= *pyBottomExcMax, "BMFD!top>bottom\n");
}


/******************************Public*Routine******************************\
* vComputeSpecialChars
*
* Effects:
*    compute special characters taking into account character set
*    Not quite sure what to do when char set is not ansi. It is really
*    to figure out what to do for a "font" where glyph bitmaps
*    are pushbuttons etc.
*    This routine will clearly blow up when a char set is catacana
*    This is char set == 37 (amisym)
*
* History:
*  28-Nov-1990 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

VOID
vComputeSpecialChars(
    PCVTFILEHDR pcvtfh,
    PWCHAR pwcDefaultChar,
    PWCHAR pwcBreakChar
    )
{
    UCHAR chDefault = pcvtfh->chDefaultChar + pcvtfh->chFirstChar;
    UCHAR chBreak   = pcvtfh->chBreakChar + pcvtfh->chFirstChar;

// Default and Break chars are given relative to the first chaR

    RtlMultiByteToUnicodeN(pwcDefaultChar, sizeof(WCHAR), NULL, &chDefault, 1);
    RtlMultiByteToUnicodeN(pwcBreakChar, sizeof(WCHAR), NULL, &chBreak, 1);
}

/******************************Public*Routine******************************\
* vBmfdFill_IFIMETRICS
*
* Effects:
*   fills the fields of the IFIMETRICS structure using the info from
*   the converted and the original font file and converted file header
*
*
* History:
*  Fri 24-Jun-1994 20:30:41 by Kirk Olynyk [kirko]
* Changed the test for pitch to look at PixWidth.
*  20-Oct-92 by Kirk Olynyk [kirko]
* Made changes to be compatible with the new and improved IFIMETRICS
* structure.
*  Fri 24-Jan-1992 07:56:16 by Kirk Olynyk [kirko]
* Changed the way EmHeight is calculated.
*  Fri 18-Oct-1991 10:36:43 by Kirk Olynyk [kirko]
* Changed the InlineDir, CharRot, CharSlope, and WidthClass
* to be expressed as POINTL's.
*  23-Jul-1991  Gilman Wong [gilmanw]
* Fixed PANOSE numbers for jFamily and jSerifStyle.
*  12-Nov-1990 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

VOID
vBmfdFill_IFIMETRICS(
    FACEINFO   *pfai,
    PRES_ELEM   pre
    )
{
    FWORD     fwdHeight;
    FONTSIM  *pFontSim;
    FONTDIFF *pfdiffBold = 0, *pfdiffItalic = 0, *pfdiffBoldItalic = 0;
    PANOSE   *ppanose;
    ULONG     cchFaceName;
    PBYTE     ajHdr  = (PBYTE)pre->pvResData;
    FWORD     sAscent,sIntLeading;
#ifdef FE_SB // vBmfdFill_IFIMETRICS()
    BOOL      bDBCSFont = (pfai->cvtfh.usDBCSWidth != 0 ? TRUE : FALSE);
#endif // FE_SB

// compute pointers to the various sections of the converted file

    PCVTFILEHDR  pcvtfh = &pfai->cvtfh;
    PIFIMETRICS  pifi   = pfai->pifi;

// face name lives in the original file, this is the only place pvView is used

    PSZ   pszFaceName;

// Either grab the facename from the FONTDIR or the FNT resources depending
// on wether or not this is a 16bit font resource.

    if( pre->pjFaceName == NULL )
    {
        pszFaceName = (PSZ)(ajHdr + lMakeLONG((PBYTE)&ajHdr[OFF_Face]));
    }
    else
    {
        pszFaceName = pre->pjFaceName;
    }

#ifdef DUMPCALL
    DbgPrint("\nvBmfdFill_IFIMETRICS(\n"                );
    DbgPrint("    FACEINFO   *pfai = %-#8lx\n",  pfai   );
    DbgPrint("    PRES_ELEM   pre  = %-#8lx\n", pre     );
    DbgPrint("    );\n\n"                               );
#endif

    pifi->cjIfiExtra = 0;

//
// the string begins on a DWORD aligned address.
//
    pifi->dpwszFaceName = OFFSET_OF_NEXT(DWORD,sizeof(IFIMETRICS));

// face name == family name for bitmap fonts [Win3.0 compatibility]

    pifi->dpwszFamilyName    = pifi->dpwszFaceName;

//
// these names don't exist, so point to the NULL char  [Win3.1 compatibility]
// Note: lstrlen() does not count the terminating NULL.
//
    cchFaceName = strlen(pszFaceName);
    pifi->dpwszStyleName =
       pifi->dpwszFaceName + sizeof(WCHAR) * cchFaceName;
    pifi->dpwszUniqueName = pifi->dpwszStyleName;

// copy the strings to their new location. Here we assume that the sufficient
// memory has been allocated

#ifdef FE_SB // vBmfdFill_IFIMETRICS():Add @ to face name

    if( pfai->bVertical )
    {
        vToUNICODEN((PWSZ)((PBYTE)pifi + pifi->dpwszFaceName + sizeof(WCHAR)),
                                cchFaceName+1, pszFaceName, cchFaceName+1);

    // Insert @

        *(PWCHAR)((PBYTE)pifi + pifi->dpwszFaceName) = L'@';
    }
     else
    {
#endif // FE_SB
        vToUNICODEN((PWSZ)((PBYTE)pifi + pifi->dpwszFaceName), cchFaceName+1, pszFaceName, cchFaceName+1);

#ifdef FE_SB
    }
#endif // DBCS_VERT


    pifi->cjThis = pcvtfh->cjIFI;

//
// Check to see if simulations are necessary and if they are, fill
// in the offsets to the various simulation fields and update cjThis
// field of the IFIMETRICS structure
//
    switch (pfai->iDefFace)
    {
    case FF_FACE_NORMAL:
    case FF_FACE_BOLD:
    case FF_FACE_ITALIC:

        pifi->dpFontSim =
           OFFSET_OF_NEXT(
               DWORD,
               sizeof(IFIMETRICS) + pcvtfh->cjFaceName
               );

        pFontSim = (FONTSIM*) ((BYTE*)pifi + pifi->dpFontSim);

        switch (pfai->iDefFace)
        {
        case FF_FACE_NORMAL:
        //
        // simulations are needed for bold, italic, and bold-italic
        //
            pFontSim->dpBold       =
                OFFSET_OF_NEXT(DWORD,sizeof(FONTSIM));

            pFontSim->dpItalic     =
                OFFSET_OF_NEXT(DWORD,pFontSim->dpBold + sizeof(FONTDIFF));

            pFontSim->dpBoldItalic =
                OFFSET_OF_NEXT(DWORD,pFontSim->dpItalic + sizeof(FONTDIFF));


            pfdiffBold      =
                (FONTDIFF*) ((BYTE*) pFontSim + pFontSim->dpBold);

            pfdiffItalic    =
                (FONTDIFF*) ((BYTE*) pFontSim + pFontSim->dpItalic);

            pfdiffBoldItalic =
                (FONTDIFF*) ((BYTE*) pFontSim + pFontSim->dpBoldItalic);

            break;

        case FF_FACE_BOLD:
        case FF_FACE_ITALIC:
        //
        // a simulation is needed for bold-italic only
        //
            pFontSim->dpBold       = 0;
            pFontSim->dpItalic     = 0;

            pFontSim->dpBoldItalic = OFFSET_OF_NEXT(DWORD,sizeof(FONTSIM));
            pfdiffBoldItalic       =
                (FONTDIFF*) ((BYTE*) pFontSim + pFontSim->dpBoldItalic);
            break;

        default:

            RIP("BMFD -- bad iDefFace\n");
        }

        break;

    case FF_FACE_BOLDITALIC:

        pifi->dpFontSim = 0;
        break;

    default:

        RIP("vBmfdFill_IFIMETRICS -- bad iDefFace");

    }

    pifi->jWinCharSet        = ajHdr[OFF_CharSet];

    // There are two way to determine the pitch of a font.
    //
    // a) If the low nibble of ajHdr[OFF_Family] is not zero then
    //    the font is variable pitch otherwise it is fixed
    // b) if ajHdr[OFF_PixWidth] is non zero then the font is
    //    fixed pitch and this is the character width otherwise
    //    the font is varialble pitch
    //
    // Under Windows, method b) is used to determine the pitch of
    // a font. There exist buggy fonts in which methods a) and
    // b) give different answers. An example is found in Issac
    // Asimov's "The Ultimate Robot". For the font face "URPalatI"
    // method a) indicates that the font is fixed pitch while
    // method b) indicates that it is variable. The truth is that
    // this font is varialbe pitch. So, we choose method b).
    // Of course, if another font gives the correct answer for method
    // a) and the incorrect answer for method b) then we will
    // look bad.
    // Mon 27-Jun-1994 06:58:46 by Kirk Olynyk [kirko]

    pifi->jWinPitchAndFamily = ajHdr[OFF_Family] & 0xf0;
    pifi->jWinPitchAndFamily |= ajHdr[OFF_PixWidth] ? FIXED_PITCH : VARIABLE_PITCH;

#ifdef MAYBE_NEEDED_FOR_MET

    if (ajHdr[OFF_Family] & MONO_FONT)
    {
    // Have no idea what MONO_FONT is, some new win95 invetion

        pifi->jWinPitchAndFamily |= MONO_FONT;
    }

#endif

// weight, we have seen files where the weight has been 0 or some other junk
// we replace 400, our mapper would have done it anyway [bodind]

    pifi->usWinWeight = usMakeUSHORT((PBYTE)&ajHdr[OFF_Weight]);
    if ((pifi->usWinWeight > MAX_WEIGHT)  || (pifi->usWinWeight < MIN_WEIGHT))
        pifi->usWinWeight = 400;

    pifi->flInfo = (  FM_INFO_TECH_BITMAP
                    | FM_INFO_RETURNS_BITMAPS
                    | FM_INFO_1BPP
                    | FM_INFO_INTEGER_WIDTH
                    | FM_INFO_RIGHT_HANDED
                    | FM_INFO_INTEGRAL_SCALING
                    | FM_INFO_NONNEGATIVE_AC
#ifdef FE_SB // vBmfdFill_IFIMETRICS():set FM_INFO_90DEGREE_ROTATIONS flag
                    | FM_INFO_90DEGREE_ROTATIONS
#endif
                   );

// we have set it correctly above, we want to make sure that somebody
// is not going to alter that code so as to break the code here

    ASSERTGDI(
        ((pifi->jWinPitchAndFamily & 0xf) == FIXED_PITCH) || ((pifi->jWinPitchAndFamily & 0xf) == VARIABLE_PITCH),
        "BMFD!WRONG PITCH \n"
        );
#ifdef FE_SB // vBmfdFill_IFIMETRICS():remove FM_INFO_CONSTANT_WIDTH flag
    if ((pifi->jWinPitchAndFamily & 0xf) == FIXED_PITCH)
    {
        if( !bDBCSFont )
            pifi->flInfo |= FM_INFO_CONSTANT_WIDTH;

        pifi->flInfo |= FM_INFO_OPTICALLY_FIXED_PITCH;
    }

// Bmfd treat only FIXED pitch font in full width character, We report this infomation to GRE
// for optimaization

    if( bDBCSFont )
    {
        pifi->flInfo |= FM_INFO_DBCS_FIXED_PITCH;
    }
#else
    if ((pifi->jWinPitchAndFamily & 0xf) == FIXED_PITCH)
    {
        pifi->flInfo |= FM_INFO_CONSTANT_WIDTH;
        pifi->flInfo |= FM_INFO_OPTICALLY_FIXED_PITCH;
    }
#endif

    pifi->lEmbedId = 0;
    pifi->fsSelection = fsSelectionFlags(ajHdr);

//
// The choices for fsType are FM_TYPE_LICENSED and FM_READONLY_EMBED
// These are TrueType things and do not apply to old fashioned bitmap
// fonts.
//
    pifi->fsType = 0;

    sIntLeading = sMakeSHORT((PBYTE)&ajHdr[OFF_IntLeading]);
    pifi->fwdUnitsPerEm = (sIntLeading > 0) ?
        (FWORD)pcvtfh->cy - sIntLeading : (FWORD)pcvtfh->cy;

    pifi->fwdLowestPPEm    = 0;

    sAscent                = (FWORD)sMakeSHORT((PBYTE)&ajHdr[OFF_Ascent]);
    pifi->fwdWinAscender   = sAscent;
    pifi->fwdWinDescender  = (FWORD)pcvtfh->cy - sAscent;

    pifi->fwdMacAscender   =  sAscent;
    pifi->fwdMacDescender  = -pifi->fwdWinDescender;
    pifi->fwdMacLineGap    =  (FWORD)sMakeSHORT((PBYTE)&ajHdr[OFF_ExtLeading]);

    pifi->fwdTypoAscender  = pifi->fwdMacAscender;
    pifi->fwdTypoDescender = pifi->fwdMacDescender;
    pifi->fwdTypoLineGap   = pifi->fwdMacLineGap;

    pifi->fwdMaxCharInc    = (FWORD)pcvtfh->usMaxWidth;

    pifi->fwdAveCharWidth  = (FWORD)usMakeUSHORT((PBYTE)&ajHdr[OFF_AvgWidth]);
    if (pifi->fwdAveCharWidth > pcvtfh->usMaxWidth)
    {
    // fix the bug in the header if there is one

        pifi->fwdAveCharWidth = pcvtfh->usMaxWidth;
    }

// don't know much about SuperScripts

    pifi->fwdSubscriptXSize     = 0;
    pifi->fwdSubscriptYSize     = 0;
    pifi->fwdSubscriptXOffset   = 0;
    pifi->fwdSubscriptYOffset   = 0;

//
// don't know much about SubScripts
//
    pifi->fwdSuperscriptXSize   = 0;
    pifi->fwdSuperscriptYSize   = 0;
    pifi->fwdSuperscriptXOffset = 0;
    pifi->fwdSuperscriptYOffset = 0;

//
// win 30 magic. see the code in textsims.c in the Win 3.1 sources
//
    fwdHeight = pifi->fwdWinAscender + pifi->fwdWinDescender;
    pifi->fwdUnderscoreSize     = (fwdHeight > 12) ? (fwdHeight / 12) : 1;
    pifi->fwdUnderscorePosition = -(FWORD)(pifi->fwdUnderscoreSize / 2 + 1);

    pifi->fwdStrikeoutSize = pifi->fwdUnderscoreSize;

    {
    // We are further adjusting underscore position if underline
    // hangs below char stems.
    // The only font where this effect is noticed to
    // be important is an ex pm font sys08cga.fnt, presently used in console

        FWORD yUnderlineBottom = -pifi->fwdUnderscorePosition
                               + ((pifi->fwdUnderscoreSize + (FWORD)1) >> 1);

        FWORD dy = yUnderlineBottom - pifi->fwdWinDescender;

        if (dy > 0)
        {
        #ifdef CHECK_CRAZY_DESC
            DbgPrint("bmfd: Crazy descender: old = %ld, adjusted = %ld\n\n",
            (ULONG)pifi->fwdMaxDescender,
            (ULONG)yUnderlineBottom);
        #endif // CHECK_CRAZY_DESC

            pifi->fwdUnderscorePosition += dy;
        }
    }



//
// Win 3.1 method
//
//    LineOffset = ((((Ascent-IntLeading)*2)/3) + IntLeading)
//
// [remember that they measure the offset from the top of the cell,
//  where as NT measures offsets from the baseline]
//
    pifi->fwdStrikeoutPosition =
        (FWORD) ((sAscent - sIntLeading + 2)/3);

    pifi->chFirstChar   = pcvtfh->chFirstChar;
    pifi->chLastChar    = pcvtfh->chLastChar;
    pifi->chBreakChar   = pcvtfh->chBreakChar   + pcvtfh->chFirstChar;

// chDefault: here we are just putting the junk from the header, which we
// know may be wrong but this is what win31 is reporting.
// E.g. for SmallFonts (shipped with win31) they report
// 128 as default even though it is not even supported in a font.
// In NT however, we must report an existent char as default char to
// the engine. So for buggy fonts we break the relationship
//             wcDefault == AnsiToUnicode(chDefault);

    pifi->chDefaultChar = ((PBYTE)pre->pvResData)[OFF_DefaultChar] +
                          ((PBYTE)pre->pvResData)[OFF_FirstChar]   ;

// wcDefaultChar
// wcBreakChar

    vComputeSpecialChars(
        pcvtfh,
        &(pifi->wcDefaultChar),
        &(pifi->wcBreakChar)
        );

// These should be taken from the glyph set

    {
        FD_GLYPHSET * pgset = &pfai->pcp->gset;
        WCRUN *pwcrunLast =  &(pgset->awcrun[pgset->cRuns - 1]);

        pifi->wcFirstChar =  pgset->awcrun[0].wcLow;
        pifi->wcLastChar  =  pwcrunLast->wcLow + pwcrunLast->cGlyphs - 1;
    }

// This is what Win 3.1 returns for CapHeight and XHeight
// for TrueType fonts ... we will do the same here.
//
    pifi->fwdCapHeight = pifi->fwdUnitsPerEm/2;
    pifi->fwdXHeight   = pifi->fwdUnitsPerEm/4;

    pifi->dpCharSets = 0; // no multiple charsets in bm fonts

// All the fonts that this font driver will see are to be rendered left
// to right

    pifi->ptlBaseline.x = 1;
    pifi->ptlBaseline.y = 0;

    pifi->ptlAspect.y = (LONG) usMakeUSHORT((PBYTE)&ajHdr[OFF_VertRes ]);
    pifi->ptlAspect.x = (LONG) usMakeUSHORT((PBYTE)&ajHdr[OFF_HorizRes]);

    if (!(pifi->fsSelection & FM_SEL_ITALIC))
    {
    // The base class of font is not italicized,

        pifi->ptlCaret.x = 0;
        pifi->ptlCaret.y = 1;
    }
    else
    {
    // somewhat arbitrary

        pifi->ptlCaret.x = 1;
        pifi->ptlCaret.y = 2;
    }



//
// The font box reflects the  fact that a-spacing and c-spacing are zero
//
    pifi->rclFontBox.left   = 0;
    pifi->rclFontBox.top    = (LONG) pifi->fwdTypoAscender;
    pifi->rclFontBox.right  = (LONG) pifi->fwdMaxCharInc;
    pifi->rclFontBox.bottom = (LONG) pifi->fwdTypoDescender;

//
// achVendorId, unknown, don't bother figure it out from copyright msg
//
    pifi->achVendId[0] = 'U';
    pifi->achVendId[1] = 'n';
    pifi->achVendId[2] = 'k';
    pifi->achVendId[3] = 'n';

    pifi->cKerningPairs   = 0;

//
// Panose
//
    pifi->ulPanoseCulture = FM_PANOSE_CULTURE_LATIN;
    ppanose = &(pifi->panose);
    ppanose->bFamilyType = jFamilyType((USHORT)pifi->jWinPitchAndFamily);
    ppanose->bSerifStyle =
        ((pifi->jWinPitchAndFamily & 0xf0) == FF_SWISS) ?
            PAN_SERIF_NORMAL_SANS : PAN_ANY;

    ppanose->bWeight = (BYTE) WINWT_TO_PANWT(pifi->usWinWeight);
    ppanose->bProportion = (usMakeUSHORT((PBYTE)&ajHdr[OFF_PixWidth]) == 0) ? PAN_ANY : PAN_PROP_MONOSPACED;
    ppanose->bContrast        = PAN_ANY;
    ppanose->bStrokeVariation = PAN_ANY;
    ppanose->bArmStyle        = PAN_ANY;
    ppanose->bLetterform      = PAN_ANY;
    ppanose->bMidline         = PAN_ANY;
    ppanose->bXHeight         = PAN_ANY;

//
// Now fill in the fields for the simulated fonts
//

    if (pifi->dpFontSim)
    {
    //
    // Create a FONTDIFF template reflecting the base font
    //
        FONTDIFF FontDiff;

        FontDiff.jReserved1      = 0;
        FontDiff.jReserved2      = 0;
        FontDiff.jReserved3      = 0;
        FontDiff.bWeight         = pifi->panose.bWeight;
        FontDiff.usWinWeight     = pifi->usWinWeight;
        FontDiff.fsSelection     = pifi->fsSelection;
        FontDiff.fwdAveCharWidth = pifi->fwdAveCharWidth;
        FontDiff.fwdMaxCharInc   = pifi->fwdMaxCharInc;
        FontDiff.ptlCaret        = pifi->ptlCaret;

        if (pfdiffBold)
        {
            *pfdiffBold = FontDiff;
            pfdiffBoldItalic->bWeight    = PAN_WEIGHT_BOLD;
            pfdiffBold->fsSelection     |= FM_SEL_BOLD;
            pfdiffBold->usWinWeight      = FW_BOLD;
            pfdiffBold->fwdAveCharWidth += 1;
            pfdiffBold->fwdMaxCharInc   += 1;
        }

        if (pfdiffItalic)
        {
            *pfdiffItalic = FontDiff;
            pfdiffItalic->fsSelection     |= FM_SEL_ITALIC;
            pfdiffItalic->ptlCaret.x = 1;
            pfdiffItalic->ptlCaret.y = 2;
        }

        if (pfdiffBoldItalic)
        {
            *pfdiffBoldItalic = FontDiff;
            pfdiffBoldItalic->bWeight          = PAN_WEIGHT_BOLD;
            pfdiffBoldItalic->fsSelection     |= (FM_SEL_BOLD | FM_SEL_ITALIC);
            pfdiffBoldItalic->usWinWeight      = FW_BOLD;
            pfdiffBoldItalic->fwdAveCharWidth += 1;
            pfdiffBoldItalic->fwdMaxCharInc   += 1;
            pfdiffBoldItalic->ptlCaret.x       = 1;
            pfdiffBoldItalic->ptlCaret.y       = 2;
        }
    }

}



#if defined(_X86_)

extern VOID vLToE(FLOATL *pe, LONG l);
/*
VOID vLToE(FLOATL *pe, LONG l)
{
    PULONG pul = (PULONG)pe;

    ASSERTGDI(sizeof(FLOAT) == sizeof(LONG),
              "vLtoE : sizeof(FLOAT) != sizeof(LONG)\n");

    *pul = ulLToE(l);
}
*/

/*
//!!! an assembly routine should be provided here instead
//!!! Now we comment out all lines where this function should be
//!!! used. Fortunately, this info is not used by the Engine yet
//!!! This is done per request of mikehar (BodinD)

VOID vDivE(FLOAT *pe, LONG l1, LONG l2)   // *pe = l1/l2
{
//!!! this is a hack, it must be fixed to avoid
// 387 instructions in assembled code. This does not work
// on a machine without 387 or a system without math emulator

    *pe = ((FLOAT)l1) / ((FLOAT)l2);
}

*/

#endif


/******************************Public*Routine******************************\
* bDescStr
*
* Grunge around in the EXE header to retrieve the description string.  Copy
* the string (if found) to the return string buffer.  This buffer should
* be at least 256 characters.  The EXE format limits the string to 255
* characters (not including a terminating NULL).
*
* Returns:
*   TRUE if successful, FALSE otherwise.
*
* History:
*  09-Mar-1992 -by- Gilman Wong [gilmanw]
* Wrote it.
\**************************************************************************/

// !!! [GilmanW] 09-Mar-1992
// !!! This only supports the 16-bit .FON file format (which corresponds to
// !!! the 16-bit NEWEXE format defined in exehdr.h).
// !!!
// !!! We need to add support for the 32-bit .FON format, whatever that is.
// !!!
// !!! Effect this has on 32-bit files: facename will be used as descr string.

BOOL
bDescStr(
    PVOID pvView,
    PSZ pszString
    )
{
    PTRDIFF dpNewExe;       // offset to NEWEXE header
    PTRDIFF dpNRSTOffset;   // offset to non-resident names table
    ULONG cch;              // count of characters in string resource
    PSZ psz;                // pointer to characters in string resource
    PSZ pszTmp;
    PBYTE pj = (PBYTE) pvView;    // PBYTE pointer into file view

#ifdef DUMPCALL
    DbgPrint("\nbDescStr(\n"                            );
    DbgPrint("    PSZ pszString  = %-#8lx\n", pszString );
    DbgPrint("    );\n\n"                               );
#endif

// Validation.  Check EXE_HDR magic number.

    if (READ_WORD(pj + OFF_e_magic) != EMAGIC)
    {
        WARNING("bmfd!bDescStr(): not a 16-bit .FON file (bad EMAGIC number)!\n");
        return(FALSE);
    }

// More validation.  Check NEWEXE magic number.

    dpNewExe = READ_DWORD(pj + OFF_e_lfanew);

    if (READ_WORD(pj + dpNewExe) != NEMAGIC )
    {
        WARNING("bmfd!bDescStr(): not a 16-bit .FON file (bad NEMAGIC number)!\n");
        return(FALSE);
    }

// Get description string out of the non-resident strings table of the
// NEWEXE header.  Resource strings are counted strings: the first byte
// is the count of characters, and the string follows.  A NULL is not
// guaranteed.  However, we know the string is < 256 characters.

    dpNRSTOffset = READ_DWORD(pj + dpNewExe + OFF_ne_nrestab);

    // If zero length string, then there is none.

    if ( (cch = (ULONG)(*(pj + dpNRSTOffset))) == 0 )
    {
        WARNING("bmfd!bDescStr(): bad description string\n");
        return (FALSE);
    }

    // Pointer to the actual string.

    psz = pj + dpNRSTOffset + 1;

// Parse out the "FONTRES xxx, yyy, zzz : " header if it exists.

    if ( (pszTmp = strchr(psz, ':')) != (PSZ) NULL )
    {
    // Skip over the ':'.

        pszTmp++;

    // Skip spaces.

        while ( *pszTmp == ' ' ) pszTmp++;

    // If not at end of string, then we're at the string.

        if ( *pszTmp != '\0' )
        {
            psz = pszTmp;
        }

    // Otherwise, this is a bad string (contains only a header).

        else
        {
            WARNING("bmfd!bDescStr(): bad description string (only string header)\n");
            return (FALSE);
        }
    }

// Copy the string.

    strncpy(pszString, psz, cch);
    pszString[cch] = '\0';          // add terminating NULL

// Success.

    return(TRUE);
}

/******************************Public*Routine******************************\
*
* PBYTE pjRawBitmap
*
* gets the pointer to the raw bitmap data in the resource file
*
* History:
*  23-Mar-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

PBYTE
pjRawBitmap(
    HGLYPH      hg,      // IN
    PCVTFILEHDR pcvtfh,  // IN
    PRES_ELEM   pre,     // IN
    PULONG      pcx      // OUT place cx here
    )
{
// size of table entry in USHORT's

    ULONG cusTableEntry = ((pcvtfh->iVersion == 0x00000200) ? 2 : 3);

// get the pointer to the beginning of the offset table in
// the original *.fnt file

    PUSHORT pusOffTable = (PUSHORT)((PBYTE)pre->pvResData + pcvtfh->dpOffsetTable);
    PUSHORT pus_cx;

#ifdef DUMPCALL
    DbgPrint("\npjRawBitmap(\n");
    DbgPrint("    HGLYPH      hg     = %-#8lx\n", hg    );
    DbgPrint("    PCVTFILEHDR pcvtfh = %-#8lx\n", pcvtfh);
    DbgPrint("    PRES_ELEM   pre    = %-#8lx\n", pre   );
    DbgPrint("    PULONG      pcx    = %-#8lx\n", pcx   );
    DbgPrint("    );\n\n"                               );
#endif

// hg is equal to the ansi value of the glyph - chFirstChar:

    if (hg > (HGLYPH)(pcvtfh->chLastChar - pcvtfh->chFirstChar))
    {
        // DbgPrint ( "hg 0x %lx, chFirst 0x %x, chLastChar 0x %x \n",
        //         hg, (WCHAR)pcvtfh->chFirstChar, (WCHAR)pcvtfh->chLastChar);

        hg = pcvtfh->chDefaultChar;
    }

// points to the table entry for this character

    pus_cx = pusOffTable + hg * cusTableEntry;

// If cx is non-zero, then the character exists, else use default char

    *pcx = *pus_cx;

    if (*pus_cx == 0)
    {
    // no bits, will have to return fake bitmap

        return NULL;
    }

// increment pus_cx to point to the offset to the bitmap in the resource file

    pus_cx++;

    if (pcvtfh->iVersion == 0x00000200)
    {
        return ((PBYTE)pre->pvResData + READ_WORD(pus_cx));
    }
    else // long offset, win 3.0 format
    {
        return ((PBYTE)pre->pvResData + READ_DWORD(pus_cx));
    }
}

/******************************Public*Routine******************************\
*
* vCheckOffsetTable: fixes the possible problems in the file header
*
* History:
*  23-Mar-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

VOID
vCheckOffsetTable(
    PCVTFILEHDR pcvtfh,
    PRES_ELEM   pre
    )
{
    ULONG    cusTableEntry;  // size of table entry in USHORT's
    ULONG    i;              // loop index
    USHORT   cxMax;          // has to be computed since there are bugs in files
    ULONG    cCodePoints = pcvtfh->chLastChar + 1 - pcvtfh->chFirstChar;
    PUSHORT  pus_cx;         // pointer to the beginning of the offset table

#ifdef DUMPCALL
    DbgPrint("\nvCheckOffsetTable(\n"                   );
    DbgPrint("    PCVTFILEHDR pcvtfh = %-#8lx\n", pcvtfh);
    DbgPrint("    PRES_ELEM   pre    = %-#8lx\n", pre   );
    DbgPrint("    );\n\n"                               );
#endif

    pus_cx = (PUSHORT)((PBYTE)pre->pvResData + pcvtfh->dpOffsetTable);

    ASSERTGDI (
        ((ULONG_PTR)pus_cx & 1L) == 0,
        "offset table begins at odd address\n"
        );

// initialize the max so far

    cxMax = 0;

    if (pcvtfh->iVersion == 0x00000200)        // 2.0 font file
        cusTableEntry = 2; // 2 bytes for cx + 2 bytes for offset
    else    // 3.0 font file
    {
        ASSERTGDI(pcvtfh->iVersion == 0x00000300, "must be 0x00000300 font\n");
        cusTableEntry = 3; // 2 bytes for cx + 4 bytes for offset
    }

// check offset table for all codepoints. It is important to find the
// real cxMax and not to trust the value in the header since as we have
// seen it may be wrong, which could cause a crash. This in fact is the
// case with one of the faces in aldfonte.fon, where they report avg. width
// to be 0x14 and max width to be 0x13, i.e. smaller than the avg!!!!.
// However, cxMax for that font, found in the loop below, turns out to be
// 0x14, i.e. >= avg width, as it should be. [bodind]

    pcvtfh->fsFlags = 0;

    for (i = 0; i < cCodePoints; i++, pus_cx += cusTableEntry)
    {
        if ((*pus_cx) > cxMax)
            cxMax = (*pus_cx);

    // See if this font file contains zero width glyphs,
    // if so we have to turn off usual DEVICEMETRICS accelerator
    // flags for this font. We shall have to be providing
    // the fake 1x1 bitmap for this font.

        if ((*pus_cx) == 0)
        {
            pcvtfh->fsFlags |= FS_ZERO_WIDTH_GLYPHS;
        }
    }

#ifdef FOOGOO
    if (pcvtfh->fsFlags & FS_ZERO_WIDTH_GLYPHS)
    {
        KdPrint(("\n %s: .fnt font resource with zero width glyphs\n", pre->pjFaceName));
    }
#endif

// cash the values

    pcvtfh->cjGlyphMax = CJ_GLYPHDATA(cxMax,pcvtfh->cy);

    pcvtfh->usMaxWidth = max(pcvtfh->usMaxWidth, cxMax);

}

#if DBG
/******************************Public*Routine******************************\
* vDumpFontHeader                                                          *
*                                                                          *
* History:                                                                 *
*  Mon 27-Jun-1994 07:00:29 by Kirk Olynyk [kirko]                         *
* Wrote it.                                                                *
\**************************************************************************/

#define GETBYTE(XXX)  ajHdr[OFF_##XXX]
#define GETWORD(XXX)  READ_WORD(&ajHdr[OFF_##XXX])
#define GETDWORD(XXX) READ_DWORD(&ajHdr[OFF_##XXX])

VOID vDumpFontHeader(
    PRES_ELEM   pre
  , VPRINT      vPrint
)
{
    PBYTE ajHdr  = (PBYTE)pre->pvResData;

    vPrint("\n\nvDumpFontHeader\n\n");
    vPrint("Version     = %-#x\n", GETWORD(Version));
    vPrint("Size        = %-#x\n", GETDWORD(Size));
    vPrint("Copyright   = \"%s\"\n",ajHdr + OFF_Copyright);
    vPrint("Type        = %-#x\n", GETWORD(Type));
    vPrint("Points      = %-#x\n", GETWORD(Points));
    vPrint("VertRes     = %-#x\n", GETWORD(VertRes));
    vPrint("HorizRes    = %-#x\n", GETWORD(HorizRes));
    vPrint("Ascent      = %-#x\n", GETWORD(Ascent));
    vPrint("IntLeading  = %-#x\n", GETWORD(IntLeading));
    vPrint("ExtLeading  = %-#x\n", GETWORD(ExtLeading));
    vPrint("Italic      = %-#x\n", GETBYTE(Italic));
    vPrint("Underline   = %-#x\n", GETBYTE(Underline));
    vPrint("StrikeOut   = %-#x\n", GETBYTE(StrikeOut));
    vPrint("Weight      = %-#x\n", GETWORD(Weight));
    vPrint("CharSet     = %-#x\n", GETBYTE(CharSet));
    vPrint("PixWidth    = %-#x\n", GETWORD(PixWidth));
    vPrint("PixHeight   = %-#x\n", GETWORD(PixHeight));
    vPrint("Family      = %-#x\n", GETBYTE(Family));
    vPrint("AvgWidth    = %-#x\n", GETWORD(AvgWidth));
    vPrint("MaxWidth    = %-#x\n", GETWORD(MaxWidth));
    vPrint("FirstChar   = %-#x\n", GETBYTE(FirstChar));
    vPrint("LastChar    = %-#x\n", GETBYTE(LastChar));
    vPrint("DefaultChar = %-#x\n", GETBYTE(DefaultChar));
    vPrint("BreakChar   = %-#x\n", GETBYTE(BreakChar));
    vPrint("WidthBytes  = %-#x\n", GETWORD(WidthBytes));
    vPrint("Device      = %-#x\n", GETDWORD(Device));
    vPrint("Face        = %-#x\n", GETDWORD(Face));
    vPrint("            = \"%s\"\n",
        (PSZ)(pre->pjFaceName == 0 ? ajHdr + GETWORD(Face) : pre->pjFaceName));
    vPrint("BitsPointer = %-#x\n", GETDWORD(BitsPointer));
    vPrint("BitsOffset  = %-#x\n", GETDWORD(BitsOffset));
    vPrint("jUnused20   = %-#x\n", GETBYTE(jUnused20));
    vPrint("OffTable20  = %-#x\n", GETWORD(OffTable20));
    vPrint("\n\n");
    {
    // consistency checks go here

    char *pszBad = "Inconsistency detected:";
    if ((GETWORD(PixWidth)) && (GETWORD(PixWidth) != GETWORD(MaxWidth)))
        DbgPrint("%s PixWidth != MaxWidth\n",pszBad);
    if ((ajHdr[OFF_Family] & 0xf) && ajHdr[OFF_PixWidth])
        DbgPrint("%s Family indicates variable pitch and PixWidth indicates fixed\n",pszBad);
    else if (!(ajHdr[OFF_Family] & 0xf) && !ajHdr[OFF_PixWidth])
        DbgPrint("%s Family indicates fixed pitch and PixWidth indicates variable\n",pszBad);
    vPrint("\n\n");
    }
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\bmfd\fon32.h ===
/******************************Module*Header*******************************\
* Module Name: fon32.h
*
*
* Created: 24-Mar-1992 10:07:14
* Author: Bodin Dresevic [BodinD]
*
* Copyright (c) 1990 Microsoft Corporation
*
\**************************************************************************/


BOOL
bFindLoadAndLockResourceA(
    HANDLE    ,
    LPCSTR    ,
    LPSTR     ,
    HANDLE*   ,
    RES_ELEM*
    );


BOOL bRelockResourcesInDll32(FONTFILE * pff);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\bmfd\fontfile.c ===
/******************************Module*Header*******************************\
* Module Name: fontfile.c
*
* "methods" for operating on FONTCONTEXT and FONTFILE objects
*
* Created: 18-Nov-1990 15:23:10
* Author: Bodin Dresevic [BodinD]
*
* Copyright (c) 1990 Microsoft Corporation
\**************************************************************************/

#include "fd.h"

HSEMAPHORE ghsemBMFD;

/******************************Public*Routine******************************\
*
* VOID vBmfdMarkFontGone(FONTFILE *pff, DWORD iExceptionCode)
*
*
* Effects:
*
* Warnings:
*
* History:
*  07-Apr-1993 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

VOID vBmfdMarkFontGone(FONTFILE *pff, DWORD iExceptionCode)
{

    ASSERTGDI(pff, "bmfd!vBmfdMarkFontGone, pff\n");
    
    EngAcquireSemaphore(ghsemBMFD);    

// this font has disappeared, probably net failure or somebody pulled the
// floppy with vt file out of the floppy drive

    if (iExceptionCode == STATUS_IN_PAGE_ERROR) // file disappeared
    {
    // prevent any further queries about this font:

        pff->fl |= FF_EXCEPTION_IN_PAGE_ERROR;
        EngUnmapFontFileFD(pff->iFile);
    }
    
    EngReleaseSemaphore(ghsemBMFD);

    if (iExceptionCode == STATUS_ACCESS_VIOLATION)
    {
        RIP("BMFD!this is probably a buggy BITMAP font file\n");
    }
}

BOOL bBmfdMapFontFileFD(FONTFILE *pff)
{
    PVOID       pvView;
    COUNT       cjView;

    return (pff ? (EngMapFontFileFD(pff->iFile, (PULONG *)&pvView, &cjView))
                : FALSE);
}

/******************************Public*Routine******************************\
*
* try/except wrappers:
*
*    BmfdQueryFontData,
*    BmfdLoadFontFile,
*    BmfdUnloadFontFile,
*    BmfdQueryAdvanceWidths
*
* History:
*  29-Mar-1993 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

LONG
BmfdQueryFontDataTE (
    DHPDEV  dhpdev,
    FONTOBJ *pfo,
    ULONG   iMode,
    HGLYPH  hg,
    GLYPHDATA *pgd,
    PVOID   pv,
    ULONG   cjSize
    )
{
    LONG lRet = FD_ERROR;

    DONTUSE(dhpdev);
    
    if (bBmfdMapFontFileFD((FONTFILE *)pfo->iFile))
    {
        try
        {
            lRet = BmfdQueryFontData (pfo, iMode, hg, pgd, pv, cjSize);
        }
        except (EXCEPTION_EXECUTE_HANDLER)
        {
            WARNING("bmfd, exception in BmfdQueryFontData\n");
            vBmfdMarkFontGone((FONTFILE *)pfo->iFile, GetExceptionCode());
        }

        EngUnmapFontFileFD(PFF(pfo->iFile)->iFile);
    }
    return lRet;
}

/******************************Public*Routine******************************\
*
* BmfdLoadFontFileTE
*
*
* History:
*  07-Apr-1993 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/


HFF
BmfdLoadFontFileTE (
    ULONG  cFiles,
    HFF   *piFile,
    PVOID *ppvView,
    ULONG *pcjView,
    DESIGNVECTOR *pdv,
    ULONG  ulLangId,
    ULONG  ulFastCheckSum
    )
{
    HFF hff = (HFF) NULL;
    HFF   iFile;
    PVOID pvView;
    ULONG cjView;

    DONTUSE(ulLangId);       // avoid W4 level compiler warning
    DONTUSE(ulFastCheckSum); // avoid W4 level compiler warning

    if ((cFiles != 1) || pdv)
        return hff;

    iFile  = *piFile;
    pvView = *ppvView;
    cjView = *pcjView;

    try
    {
        BOOL     bRet;

    // try loading it as an fon file, if it does not work, try as
    // fnt file

        if (!(bRet = bBmfdLoadFont(iFile, pvView, cjView,TYPE_DLL16, &hff)))
        {
        // try as an *.fnt file

            bRet = bBmfdLoadFont(iFile, pvView, cjView,TYPE_FNT,&hff);
        }

        //
        // if this did not work try to load it as a 32 bit dll
        //

        if (!bRet)
        {
            bRet = bLoadNtFon(iFile,pvView,&hff);
        }

        if (!bRet)
        {
            ASSERTGDI(hff == (HFF)NULL, "BMFD!bBmfdLoadFontFile, hff\n");
        }
    }
    except (EXCEPTION_EXECUTE_HANDLER)
    {
        WARNING("bmfd, exception in BmfdLoadFontFile\n");

        ASSERTGDI(GetExceptionCode() == STATUS_IN_PAGE_ERROR,
                  "bmfd!bBmfdLoadFontFile, strange exception code\n");


        // if the file disappeared after mem was allocated, free the mem

        if (hff)
        {
            VFREEMEM(hff);
        }

        hff = (HFF)NULL;
    }

    return hff;
}

/******************************Public*Routine******************************\
*
* BmfdUnloadFontFileTE (
*
* History:
*  07-Apr-1993 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/




BOOL
BmfdUnloadFontFileTE (
    HFF  hff
    )
{
    BOOL bRet;

    try
    {
        bRet = BmfdUnloadFontFile(hff);
    }
    except (EXCEPTION_EXECUTE_HANDLER)
    {
        WARNING("bmfd, exception in BmfdUnloadFontFile\n");
        bRet = FALSE;
    }
    return bRet;
}

/******************************Public*Routine******************************\
*
* BOOL BmfdQueryAdvanceWidthsTE
*
* Effects:
*
* Warnings:
*
* History:
*  07-Apr-1993 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

BOOL BmfdQueryAdvanceWidthsTE
(
    DHPDEV   dhpdev,
    FONTOBJ *pfo,
    ULONG    iMode,
    HGLYPH  *phg,
    LONG    *plWidths,
    ULONG    cGlyphs
)
{
    BOOL bRet = FD_ERROR;    // tri bool according to chuckwh
    DONTUSE(dhpdev);
    
    if (bBmfdMapFontFileFD((FONTFILE *)pfo->iFile))
    {
        try
        {
            bRet = BmfdQueryAdvanceWidths(pfo,iMode,phg,plWidths,cGlyphs);
        }
        except (EXCEPTION_EXECUTE_HANDLER)
        {
            WARNING("bmfd, exception in BmfdQueryAdvanceWidths\n");
            vBmfdMarkFontGone((FONTFILE *)pfo->iFile, GetExceptionCode());
        }

        EngUnmapFontFileFD(PFF(pfo->iFile)->iFile);
    }
    return bRet;
}


/******************************Public*Routine******************************\
* DHPDEV DrvEnablePDEV
*
* Initializes a bunch of fields for GDI
*
\**************************************************************************/

DHPDEV
BmfdEnablePDEV(
    DEVMODEW*   pdm,
    PWSTR       pwszLogAddr,
    ULONG       cPat,
    HSURF*      phsurfPatterns,
    ULONG       cjCaps,
    ULONG*      pdevcaps,
    ULONG       cjDevInfo,
    DEVINFO*    pdi,
    HDEV        hdev,
    PWSTR       pwszDeviceName,
    HANDLE      hDriver)
{

    PVOID*   ppdev;

    //
    // Allocate a four byte PDEV for now
    // We can grow it if we ever need to put information in it.
    //

    ppdev = (PVOID*) EngAllocMem(0, sizeof(PVOID), 'dfmB');

    return ((DHPDEV) ppdev);
}

/******************************Public*Routine******************************\
* DrvDisablePDEV
*
* Release the resources allocated in DrvEnablePDEV.  If a surface has been
* enabled DrvDisableSurface will have already been called.
*
\**************************************************************************/

VOID
BmfdDisablePDEV(
    DHPDEV  dhpdev)
{
    EngFreeMem(dhpdev);
}

/******************************Public*Routine******************************\
* VOID DrvCompletePDEV
*
* Store the HPDEV, the engines handle for this PDEV, in the DHPDEV.
*
\**************************************************************************/

VOID
BmfdCompletePDEV(
    DHPDEV dhpdev,
    HDEV   hdev)
{
    return;
}




// The driver function table with all function index/address pairs

DRVFN gadrvfnBMFD[] =
{
    {   INDEX_DrvEnablePDEV,            (PFN) BmfdEnablePDEV,          },
    {   INDEX_DrvDisablePDEV,           (PFN) BmfdDisablePDEV,         },
    {   INDEX_DrvCompletePDEV,          (PFN) BmfdCompletePDEV,        },
    {   INDEX_DrvQueryFont,             (PFN) BmfdQueryFont,           },
    {   INDEX_DrvQueryFontTree,         (PFN) BmfdQueryFontTree,       },
    {   INDEX_DrvQueryFontData,         (PFN) BmfdQueryFontDataTE,     },
    {   INDEX_DrvDestroyFont,           (PFN) BmfdDestroyFont,         },
    {   INDEX_DrvQueryFontCaps,         (PFN) BmfdQueryFontCaps,       },
    {   INDEX_DrvLoadFontFile,          (PFN) BmfdLoadFontFileTE,      },
    {   INDEX_DrvUnloadFontFile,        (PFN) BmfdUnloadFontFileTE,    },
    {   INDEX_DrvQueryFontFile,         (PFN) BmfdQueryFontFile,       },
    {   INDEX_DrvQueryAdvanceWidths,    (PFN) BmfdQueryAdvanceWidthsTE }
};

/******************************Public*Routine******************************\
* BmfdEnableDriver
*
* Enables the driver by retrieving the drivers function table and version.
*
*  Sun 25-Apr-1993 -by- Patrick Haluptzok [patrickh]
* Change to be same as DDI Enable.
*
* History:
*  12-Dec-1990 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

BOOL BmfdEnableDriver(
ULONG iEngineVersion,
ULONG cj,
PDRVENABLEDATA pded)
{
// Engine Version is passed down so future drivers can support previous
// engine versions.  A next generation driver can support both the old
// and new engine conventions if told what version of engine it is
// working with.  For the first version the driver does nothing with it.

    iEngineVersion;

    if ((ghsemBMFD = EngCreateSemaphore()) == (HSEMAPHORE) 0)
    {
        return(FALSE);
    }

    pded->pdrvfn = gadrvfnBMFD;
    pded->c = sizeof(gadrvfnBMFD) / sizeof(DRVFN);
    pded->iDriverVersion = DDI_DRIVER_VERSION_NT5;
    return(TRUE);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\bmfd\stretch.c ===
/******************************Module*Header*******************************\
* Module Name: stretch.c
*
* Routines to stretch a glyph bitmap up to five times in the x direction
* and an arbitrary number of times in the y direction.  These limits are
* the ones imposed by windows.
*
* Created: 7-Dec-1992 16:00:00
* Author: Gerrit van Wingerden
*
* Copyright (c) 1992 Microsoft Corporation
\**************************************************************************/

#include "fd.h"

// Since there are only four ways we can stretch in the x direction we use
// tables to do our stretching.  The tables index 2 to 3 bit quantities to
// bytes or words that correspond to the stretched values of those quantities.
// This is much faster than doing all the shifting neccesary to stretch those
// quantities.

BYTE ajStretch2[16] = { 0x00, 0x03, 0x0C, 0x0F, 0x30, 0x33, 0x3C, 0x3F, 0xC0,
                        0xC3, 0xCC, 0xCF, 0xF0, 0xF3, 0xFC, 0xFF };
BYTE ajStretch3B1[8] = { 0x00, 0x03, 0x1C, 0x1F, 0xE0, 0xE3, 0xFC, 0xFF };
BYTE ajStretch3B2[16] = { 0x00, 0x01, 0x0E, 0x0F, 0x70, 0x71, 0x7E, 0x7F, 0x80,
                          0x81, 0x8E, 0x8F, 0xF0, 0xF1, 0xFE, 0xFF };
BYTE ajStretch3B3[8] = { 0x00, 0x07, 0x38, 0x3F, 0xC0, 0xC7, 0xF8, 0xFF };
WORD awStretch4[16] = { 0x0000, 0x0F00, 0xF000, 0xFF00, 0x000F, 0x0F0F, 0xF00F,
                        0xFF0F, 0x00F0, 0x0FF0, 0xF0F0, 0xFFF0, 0x00FF, 0x0FFF,
                        0xF0FF, 0xFFFF };
WORD awStretch5W1[16] = { 0x0000, 0x0100, 0x3E00, 0x3F00, 0xC007, 0xC107,
                          0xFE07, 0xFF07, 0x00F8, 0x01F8, 0x3EF8, 0x3FF8,
                          0xC0FF, 0xC1FF, 0xFEFF, 0xFFFF };
WORD awStretch5W2[16] = { 0x0000, 0x0300, 0x7C00, 0x7F00, 0x800F, 0x830F,
                          0xFC0F, 0xFF0F, 0x00F0, 0x03F0, 0x7CF0, 0x7FF0,
                          0x80FF, 0x83FF, 0xFCFF, 0xFFFF };
BYTE ajStretch5B1[4] = { 0x00, 0x1F, 0xE0, 0xFF };

/**************************************************************************\
* void vEmboldenItalicizeLine
*
* Emboldens and italicizes a scan line.
*
* Created: 7-Dec-1992 16:00:00
* Author: Gerrit van Wingerden
*
* Copyright (c) 1992 Microsoft Corporation
\**************************************************************************/



void vEmboldenItalicizeLine( BYTE *pjDst,       // Destitnation scan line
                             BYTE *pjSrc,       // Source scan line
                             BYTE *pjEnd,       // End of source scan line
                             LONG lShift,       // Amount by which to shift
                             UINT uiPixelWidth  // Width of scan line in pixels
                            )
{
    BYTE jSrcItalic;
    BYTE jCarry = (BYTE) 0;
    BYTE jCarryBold = (BYTE) 0;

    for( ; pjSrc < pjEnd; pjDst++, pjSrc++  )
    {
        jSrcItalic = (BYTE) ( (*pjSrc >> lShift) | jCarry );
        *pjDst = (BYTE) ( jSrcItalic | ( jSrcItalic >> 1 ) | jCarryBold );

        // remember the lShift rightmost and mve them over to the left

        jCarry = (BYTE) ( *pjSrc << ( 8 - lShift ));
        jCarryBold = (BYTE) ( jSrcItalic << 7 );
    }

    if( ( (long) ( 8 - ( uiPixelWidth & 7l )) & 7l ) < lShift )
    {
        jSrcItalic = jCarry;
        *pjDst = (BYTE) ( jSrcItalic | ( jSrcItalic >> 1 ) | jCarryBold );
        jCarryBold = (BYTE) (jSrcItalic << 7 );

        if( ( uiPixelWidth & 0x7l ) == 0l )
        {
            *(++pjDst) = jCarryBold;
        }
    }
}


/**************************************************************************\
* void vEmboldenLine
*
* Emboldens a scan line.
*
* Created: 7-Dec-1992 16:00:00
* Author: Gerrit van Wingerden
*
* Copyright (c) 1992 Microsoft Corporation
\**************************************************************************/




void vEmboldenLine( BYTE *pjDst,        // Destination scan line
                    BYTE *pjSrc,        // Source scan line
                    BYTE *pjEnd,        // End of dest scan line
                    UINT uiPixelWidth   // Width of scan line in pixels
                    )
{
    BYTE jCarry = (BYTE) 0;

    for( ; pjDst < pjEnd; pjDst++, pjSrc++  )
    {
        *pjDst = ( *pjSrc | (( *pjSrc >> 1 ) | jCarry ));
        jCarry = ( *pjSrc << 7);
    }

    if( (( uiPixelWidth << 1 ) & 7l ) == 0l )
        *pjDst = jCarry;
}



/**************************************************************************\
* void vItalicizeLine
*
* Italicizes a scan line.
*
* Created: 7-Dec-1992 16:00:00
* Author: Gerrit van Wingerden
*
* Copyright (c) 1992 Microsoft Corporation
\**************************************************************************/



void vItalicizeLine( BYTE *pjDst,       // Destitnation scan line
                     BYTE *pjSrc,       // Source scan line
                     BYTE *pjEnd,       // End of source scan line
                     LONG lShift,       // Amount by which to shift
                     UINT uiPixelWidth  // Width of scan line in pixels
                     )
{
    BYTE jCarry = (BYTE) 0;

    for( ; pjSrc < pjEnd; pjDst++, pjSrc++  )
    {
        *pjDst = (( *pjSrc >> lShift ) | jCarry );
        jCarry = ( *pjSrc << ( 8 - lShift) );
    }

    if( ( (long) ( 8 - ( uiPixelWidth & 7l )) & 7l ) < lShift )
        *pjDst = jCarry;
}



/*************************************************************************\
* VOID vStretchGlyphBitmap
*
* Stretches a bitmap in fontfile format ( collumns ) to a row format and
* performs bold and italic simulations.  This routine could be faster
* by spliting it up into several special case routines to handle simulations
* and or different widths or by inlining the italicizing or emboldening
* routines.  However, we hardly ever need to stretch bitmap fonts so it
* was deemed better to have one, nice neat routine that takes up less
* code than several routines that are overall faster.
*
*
* Created: 7-Dec-1992 16:00:00
* Author: Gerrit van Wingerden [gerritv]
*
* Copyright (c) 1992 Microsoft Corporation
\**************************************************************************/



VOID vStretchGlyphBitmap( BYTE *pjTarget,       // Target bitmap
                         BYTE *pjSourceBitmap,  // Source bitmap
                         BYTE *pjLineBuffer,    // Scan line buffer
                         UINT uiPixelWidth,     // Width of bitmap in pixels
                         UINT uiHeight,         // Height of bitmap in bits
                         UINT uiVertScale,      // Vertical scaling factor
                         UINT uiHorzScale,      // Horizontal scaling factor
                         UINT flSim )           // Simulation flags
{
    BYTE *pjSource, *pjBufferBase, *pjScanEnd, *pjSimEnd;
    UINT uiScanDelta, uiNewWidth, uiNewWidthSim, cjEmpty, uiCurScan;
    LONG lShift;
    BYTE *pjDone = pjSourceBitmap + uiHeight;

    uiNewWidth = ( ( uiPixelWidth * uiHorzScale ) + 7 ) >> 3;
    pjSimEnd = pjLineBuffer + uiNewWidth;
    cjEmpty = 0;

    switch( flSim )
    {
    case (FO_SIM_ITALIC | FO_SIM_BOLD):
        // fall through to the italic case with one added to cxOffset
    case FO_SIM_ITALIC:
    {
        UINT cxOffset = ( uiHeight * uiVertScale - 1 ) / 2;

        if( flSim & FO_SIM_BOLD )
            cxOffset += 1;

        uiNewWidthSim = ( ( uiPixelWidth * uiHorzScale ) + cxOffset + 7 ) >> 3;
        uiCurScan = 0;
        lShift = cxOffset & (UINT) 7;
        cjEmpty = cxOffset >> 3;
        break;
    }
    case FO_SIM_BOLD:
        uiNewWidthSim = ( ( uiPixelWidth *uiHorzScale ) + 8 ) >> 3; 
        break;
    default:
        uiNewWidthSim = uiNewWidth;
        break;
    }

// output bytes generated per new scan line

    uiScanDelta = uiNewWidthSim * uiVertScale;


    for( ; pjSourceBitmap < pjDone; pjSourceBitmap += 1 )
    {

    // first stretch one scan line

        for( pjSource = pjSourceBitmap, pjBufferBase = pjLineBuffer;
           pjBufferBase < pjLineBuffer + uiNewWidth;
           pjSource += uiHeight )
        {

      switch( uiHorzScale )
      {
      case 1:
        // don't stretch just copy
          *pjBufferBase++ = *pjSource;
          break;
      case 2:
        // stretch first nibble
            *pjBufferBase++ = ajStretch2[ *pjSource >> 4];

        //stretch second nibble
            *pjBufferBase++ = ajStretch2[ *pjSource & 0xf];
         break;
      case 3:
        // first byte
            *pjBufferBase++ = ajStretch3B1[ *pjSource >> 5];
        // second byte
            *pjBufferBase++ = ajStretch3B2[ (*pjSource >> 2) & 0xf];
        // third byte
            *pjBufferBase++ = ajStretch3B3[ *pjSource &0x7];
         break;
      case 4:
                // I know this is strange but I didn't think about alignment
                // errors when I used word sized tables. So i had to hack it.
                // !!! later these tables should be writen to be byte tables.
                // [gerritv]

        // first nibble
                        *pjBufferBase++ = ((BYTE*)(&awStretch4[ *pjSource >> 4]))[0];
                        *pjBufferBase++ = ((BYTE*)(&awStretch4[ *pjSource >> 4]))[1];

                // second nibble
                        *pjBufferBase++ = ((BYTE*)(&awStretch4[ *pjSource & 0xf]))[0];
                        *pjBufferBase++ = ((BYTE*)(&awStretch4[ *pjSource & 0xf]))[1];
         break;
      case 5:
                // first word
                        *pjBufferBase++ = ((BYTE*)(&awStretch5W1[ *pjSource >> 4]))[0];
                        *pjBufferBase++ = ((BYTE*)(&awStretch5W1[ *pjSource >> 4]))[1];

                // second byte
                        *pjBufferBase++ = ((BYTE*)(&awStretch5W2[ (*pjSource >> 1) & 0xf]))[0];
                        *pjBufferBase++ = ((BYTE*)(&awStretch5W2[ (*pjSource >> 1) & 0xf]))[1];

        // third byte
            *pjBufferBase++ = ajStretch5B1[ *pjSource &0x3];
         break;
        }
   }

    // now copy stretched scan line uiVertScale times while making the bitmap byte aligned

      pjScanEnd = pjTarget + uiScanDelta;

        switch( flSim )
        {
        case FO_SIM_ITALIC:

        for( ; pjTarget < pjScanEnd; pjTarget += uiNewWidthSim )
        {

            vItalicizeLine( pjTarget + cjEmpty,
                            pjLineBuffer,
                            pjLineBuffer + uiNewWidth,
                            lShift,
                            uiPixelWidth * uiHorzScale );

            lShift -= ( uiCurScan++ & 0x1 );

            if( lShift < 0 )
            {
                lShift = 7;
                cjEmpty--;
            }
        }
        break;

        case ( FO_SIM_ITALIC | FO_SIM_BOLD ):

            for( ; pjTarget < pjScanEnd; pjTarget += uiNewWidthSim )
            {

                vEmboldenItalicizeLine( pjTarget + cjEmpty,
                                pjLineBuffer,
                                pjLineBuffer + uiNewWidth,
                                lShift,
                                uiPixelWidth * uiHorzScale );

                lShift -= ( uiCurScan++ & 0x1 );

                if( lShift < 0 )
                {
                    lShift = 7;
                    cjEmpty--;
                }
            }

        break;
        case FO_SIM_BOLD:

          // first embolden this scan line

            vEmboldenLine( pjTarget, pjLineBuffer, pjTarget + uiNewWidth, uiPixelWidth * uiHorzScale );
            pjBufferBase = pjTarget;
            pjTarget += uiNewWidthSim;

            for( ; pjTarget < pjScanEnd; pjTarget += uiNewWidthSim )
                memcpy( (PVOID) pjTarget, (PVOID) pjBufferBase, (size_t) uiNewWidthSim );

            break;

        case 0:

        // just copy the scan line uiVertScale times

        for( ; pjTarget < pjScanEnd; pjTarget += uiNewWidthSim )
            memcpy( (PVOID) pjTarget, (PVOID) pjLineBuffer, (size_t) uiNewWidthSim );

        break;
        }

    }
}


/***************************************************************************\
* VOID vStretchCvtToBitmap
*
* Stretches a bitmap and performs bold and italic simulations.
*
* Created: 7-Dec-1992 16:00:00
* Author: Gerrit van Wingerden
*
* Copyright (c) 1992 Microsoft Corporation
\**************************************************************************/




VOID
vStretchCvtToBitmap
(
    GLYPHBITS *pgb,
    PBYTE pjBitmap,     // bitmap in *.fnt form
    ULONG cx,           // unscaled width
    ULONG cy,           // unscaled height
    ULONG yBaseline,    // baseline from font file
    PBYTE pjLineBuffer, // preallocated buffer for use by stretch routines
    ULONG cxScale,      // horizontal scaling factor
    ULONG cyScale,      // vertical scaling factor
    ULONG flSim         // simulation flags
)
{
    ULONG cxNew, cyNew, yBaselineNew;

// compute new height, width, and baseline

    cxNew = cx * cxScale;
    cyNew = cy * cyScale;
    yBaselineNew = yBaseline * cyScale;

    switch( flSim )
    {
    case ( FO_SIM_ITALIC | FO_SIM_BOLD ):
        cxNew = cxNew + ( cyNew + 1 ) / 2;
        break;

    case FO_SIM_ITALIC:
        cxNew = cxNew + ( cyNew - 1 ) / 2;
        break;
    case FO_SIM_BOLD:
        cxNew += 1;
        break;
    case 0:
        break;
    }

// glyphbits data


    pgb->sizlBitmap.cx = cxNew;
    pgb->sizlBitmap.cy = cyNew;

    pgb->ptlOrigin.x = 0l;
    pgb->ptlOrigin.y = -(LONG) yBaselineNew;

    RtlZeroMemory( pgb->aj, ( CJ_SCAN( cxNew )) * cyNew );

    vStretchGlyphBitmap(  pgb->aj,
                    pjBitmap,
                    pjLineBuffer,
                    cx,
                    cy,
                    cyScale,
                    cxScale,
                    flSim );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\bmfd\simulate.c ===
/******************************Module*Header*******************************\
* Module Name: simulate.c
*
*  routines associated with simulated faces i.e. emboldened
*  and/or italicized  faces
*
* Created: 17-Apr-1991 08:31:18
* Author: Bodin Dresevic [BodinD]
*
* Copyright (c) 1990 Microsoft Corporation
*
\**************************************************************************/

#include "fd.h"

#ifdef SAVE_FOR_HISTORICAL_REASONS

/******************************Public*Routine******************************\
*
* VOID vEmboldenBitmap(RASTERGLYPH * pgldtSrc,RASTERGLYPH * pgldtDst,LONG culDst)
*
* modifies an original glyph bitmap for the default face
* to produce the bitmap that corresponds to an emboldened char.
* Emboldened bitmap is simply an original bitmap offsetted to the right
* by one pel and OR-ed with the original bitmap itself.
*
* History:
*  22-Apr-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

VOID
vEmboldenBitmap(
    RASTERGLYPH * prgSrc,
    RASTERGLYPH * prgDst
    )
{
    ULONG cxSrc = prgSrc->gb.sizlBitmap.cx;
    ULONG cy    = prgSrc->gb.sizlBitmap.cy;      // same for src and dst
    ULONG cxDst = cxSrc + 1;                // + 1 for emboldening

    PBYTE pjSrc = prgSrc->gb.aj;
    PBYTE pjDst = prgDst->gb.aj;

    ULONG iScan,iByte;        // loop indices
    PBYTE pjS,pjD;

// number of bytes in one scan of the Dst or Src bitmaps. (dword aligned)

    ULONG cjScanDst = CJ_SCAN(cxDst);
    ULONG cjScanSrc = CJ_SCAN(cxSrc);
    ULONG cjBmp        = cjScanDst * cy;

    ULONG cjScanDst = CJ_SCAN(cxDst);
    ULONG cjScanSrc = CJ_SCAN(cxSrc);
    BYTE  jCarry;   // carry bit from shifting Src byte by 1;

    GLYPHDATA *pgldtSrc = &prgSrc->gd;
    GLYPHDATA *pgldtDst = &prgDst->gd;

#ifdef DUMPCALL
    DbgPrint("\nvEmboldenBitmap(");
    DbgPrint("\n    RASTERGLYPH *prgSrc = %-#8lx",prgSrc);
    DbgPrint("\n    RASTERGLYPH *prgDst = %-#8lx",prgDst);
    DbgPrint("\n    )\n");
#endif

    RtlCopyMemory(prgDst,
                  prgSrc,
                  offsetof(RASTERGLYPH,gb) + offsetof(GLYPHBITS,sizlBitmap));

// if engine requested memory that is zero-ed out we would not have to do it
// ourselves

    RtlZeroMemory(pjDst, cjBmp);

// make necessary changes to the fields of GLYPHDATA which
// are affected by emboldening

    pgldtDst->gdf.pgb = &prgDst->gb;

    pgldtDst->rclInk.right += (LONG)1;

// pre and post bearings have not changed nor bmp origin, only inked box

    pgldtDst->fxD = LTOFX(cxDst);
    pgldtDst->ptqD.x.HighPart = (LONG)pgldtDst->fxD;
    pgldtDst->fxAB = pgldtDst->fxD;     // right edge of the black box

// this needs to be changed a bit since aulBMData will not live
// in the GLYPHDATA structure any more

    prgDst->gb.sizlBitmap.cx = cxDst;
    prgDst->gb.sizlBitmap.cy = cy;

// embolden bitmap scan by scan

    for (iScan = 0L; iScan < cy; iScan++)
    {
        pjS = pjSrc;
        pjD = pjDst;

    // embolden individual scans

        jCarry = (BYTE)0;   // no carry to the first byte in the row

        for(iByte = 0L; iByte < cjScanSrc; iByte++, pjS++, pjD++)
        {
            *pjD = (BYTE)(*pjS | ((*pjS >> 1) | jCarry));

        // remember the rightmost bit and shift it to the leftmost position

            jCarry = (BYTE)(*pjS << 7);
        }

        if ((cxSrc & 7L) == 0L)
            *pjD = jCarry;

    // advance to the next scan of the src and dst

        pjSrc += cjScanSrc;
        pjDst += cjScanDst;
    }
}
#endif // SAVE_FOR_HISTORICAL_REASONS

/******************************Public*Routine******************************\
* cjGlyphDataSimulated
*
* Computes the size of the glyphdata for the simulated face given cx and cy
* for the corresponding char in the default face
*
* History:
*  22-Apr-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

#ifdef FE_SB // cjGlyphDataSimulated():
LONG
cjGlyphDataSimulated(
    FONTOBJ *pfo,
    ULONG    cxNoSim,    // cx for the same char of the default face
    ULONG    cyNoSim,    // cy for the same char of the default face
    ULONG   *pcxSim,
    ULONG    ulRotate    // Rotation degree
    )
#else
LONG
cjGlyphDataSimulated(
    FONTOBJ *pfo,
    ULONG    cxNoSim,    // cx for the same char of the default face
    ULONG    cyNoSim,    // cy for the same char of the default face
    ULONG   *pcxSim
    )
#endif
{
    ULONG cxSim;

#ifdef DUMPCALL
    DbgPrint("\ncjGlyphDataSimulated(");
    DbgPrint("\n    ULONG        cxNoSim = %-#8lx",cxNoSim);
    DbgPrint("\n    ULONG        cyNoSim = %-#8lx",cyNoSim);
    DbgPrint("\n    ULONG       *pcxSim  = %-#8lx",pcxSim );
    DbgPrint("\n    )\n");
#endif

    if (cxNoSim == 0)
    {
    // blank 1x1 bitmap

        cxSim    = 1;
        cyNoSim  = 1;
    }
    else
    {
        switch( pfo->flFontType & (FO_SIM_BOLD | FO_SIM_ITALIC) )
        {
        case 0:
            cxSim = cxNoSim;
            break;

        case FO_SIM_BOLD:

            cxSim = cxNoSim + 1;
            break;

        case FO_SIM_ITALIC:

            cxSim = cxNoSim + (cyNoSim - 1) / 2;
            break;

        default:

        // here we have used that
        // (k - 1) / 2 + 1 == (k + 1) / 2 for every integer k, (k == cy)

            cxSim = cxNoSim + (cyNoSim + 1) / 2;
            break;
        }
    }

    if (pcxSim != (ULONG *)NULL)
    {
        *pcxSim = cxSim;
    }

#ifdef FE_SB // cjGlyphDataSimulated():

#ifdef DBG_MORE
    DbgPrint("cxSim - 0x%x\n : cyNoSim - 0x%x\n",cxSim , cyNoSim);
#endif // DBG_MORE

    switch( ulRotate )
    {
    case 0L :
    case 1800L :

        return(CJ_GLYPHDATA(cxSim, cyNoSim));

    case 900L :
    case 2700L :

        return(CJ_GLYPHDATA(cyNoSim, cxSim));
    default :
        /* we should never be here */
        return(CJ_GLYPHDATA(cxSim, cyNoSim));
    }
#else
    return(CJ_GLYPHDATA(cxSim, cyNoSim));
#endif

}

/******************************Public*Routine******************************\
*
* cFacesRes
*
* History:
*  13-May-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

ULONG
cFacesRes(
    PRES_ELEM pre
    )
{
    FSHORT fs = fsSelectionFlags((PBYTE)pre->pvResData);

#ifdef DUMPCALL
    DbgPrint("\ncFacesRes(");
    DbgPrint("\n    PRES_ELEM pre = %-#8lx", pre);
    DbgPrint("\n    )\n");
#endif

// kill all the bits but BOLD and ITALIC

    fs = fs & (FSHORT)(FM_SEL_BOLD | FM_SEL_ITALIC);

    //!!! DbgPrint("fsSelection = 0x%lx\n", (ULONG)fs);

    if (fs == 0)    // default face is NORMAL
        return(4L);

    if ((fs == FM_SEL_BOLD) || (fs == FM_SEL_ITALIC))
        return(2L);

    if (fs == (FM_SEL_BOLD | FM_SEL_ITALIC))
        return(1L);

    /* we should never be here */
    return (4L);
}

/******************************Public*Routine******************************\
* VOID vDefFace
*
* History:
*  13-May-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

VOID
vDefFace(
    FACEINFO   *pfai,
    RES_ELEM   *pre
    )
{
// kill all bits but BOLD and ITALIC bits that should remain unchanged

    FSHORT fs = (FSHORT)(
        fsSelectionFlags((PBYTE) pre->pvResData) &
        (FM_SEL_BOLD  | FM_SEL_ITALIC)
        );

    switch (fs)
    {
    case 0:
        pfai->iDefFace = FF_FACE_NORMAL;
        return;

    case FM_SEL_BOLD:
        pfai->iDefFace = FF_FACE_BOLD;
        return;

    case FM_SEL_ITALIC:
        pfai->iDefFace = FF_FACE_ITALIC;
        return;

    case (FM_SEL_ITALIC | FM_SEL_BOLD):
        pfai->iDefFace = FF_FACE_BOLDITALIC;
        return;

    default:
        RIP("bmfd!_which ape has messed up the code ?\n");
        return;
    }
}

/******************************Public*Routine******************************\
*
* ULONG cFacesFON     // no. of faces associated with this FON file
*
* History:
*  13-May-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

ULONG
cFacesFON(
    PWINRESDATA pwrd
    )
{
    ULONG cFace;
    ULONG iRes;
    RES_ELEM re;

#ifdef DUMPCALL
    DbgPrint("\ncFacesFON(");
    DbgPrint("\n    PWINRESDATA pwrd = %-#8lx", pwrd);
    DbgPrint("\n    )\n");
#endif

// this function should have not been called if there are no
// font resources associated with this pwrd

    ASSERTGDI(pwrd->cFntRes != 0L, "No font resources\n");

    cFace = 0L;     // init the sum

    for (iRes = 0L; iRes < pwrd->cFntRes; iRes++)
    {
        vGetFntResource(pwrd,iRes,&re);
        cFace += cFacesRes(&re);
    }
    return(cFace);
}

/******************************Public*Routine******************************\
*
* vComputeSimulatedGLYPHDATA
*
* History:
*  06-Oct-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

VOID
vComputeSimulatedGLYPHDATA(
    GLYPHDATA *pgldt    ,
    PBYTE      pjBitmap ,
    ULONG      cxNoSim  ,
    ULONG      cy       ,
    ULONG      yBaseLine,
    ULONG      cxScale,
    ULONG      cyScale,
    FONTOBJ   *pfo
    )
{
    ULONG cxSim;            // cx for the bitmap
    LONG  xCharInc;         // x component of the char inc vector

// the following coords refer to bitmap coord system, i.e. the one in which
// the BM origin has coors (0,0)

    ULONG yTopIncMin;    // min over non zero raws
    ULONG yBottomExcMax; // max+1 over non zero raws

#ifdef DUMPCALL
    DbgPrint("\nvComputeSimulatedGLYPHDATA(");
    DbgPrint("\n    GLYPHDATA         *pgldt     = %-#8lx",pgldt     );
    DbgPrint("\n    PBYTE              pjBitmap  = %-#8lx",pjBitmap  );
    DbgPrint("\n    ULONG              cxNoSim   = %-#8lx",cxNoSim   );
    DbgPrint("\n    ULONG              cy        = %-#8lx",cy        );
    DbgPrint("\n    ULONG              yBaseLine = %-#8lx",yBaseLine );
    DbgPrint("\n    FONTOBJ           *pfo       = %-#8lx",pfo       );
    DbgPrint("\n    )\n");
#endif

// compute top and bottom by looking into the bitmap in the row format:

    vFindTAndB (
        pjBitmap, // pointer to the bitmap in *.fnt column format
        cxNoSim,
        cy,
        &yTopIncMin,
        &yBottomExcMax
        );

    if( cyScale != 1 )
    {
        yTopIncMin *= cyScale;
        yBottomExcMax *= cyScale;
        cy *= cyScale;
        yBaseLine *= cyScale;
    }

    cxNoSim *= cxScale;

    pgldt->gdf.pgb = NULL;

    if (yTopIncMin == yBottomExcMax) // no ink at all
    {
    // this is a tricky point. We are dealing with a blank bitmap.
    // The first thought would be to report the zero inked box. It
    // then ambiguous what an A and C spaces should be. The right way to
    // think of this bitmap (this is in fact the break char) is that the
    // inked box is the whole bitmap, just the "color" of the ink happens
    // to be invisible. This is important when dealing with strings
    // which have break character as the first or the last char in the string.
    // If the inked box was reported as zero, text extent for such a string
    // would be computed incorrectly when the corrections for the first A
    // and last C are taken into account

        yTopIncMin = 0L;    // coincides with the top
        yBottomExcMax = cy * cyScale; // coincides with the bottom
    }

// these have to be correct, important for computing char inc for esc != 0

    pgldt->rclInk.top = (LONG)(yTopIncMin - yBaseLine);
    pgldt->rclInk.bottom = (LONG)(yBottomExcMax - yBaseLine);

// minus sign is because the scalar product is supposed to be taken with
// a unit ascender vector

    pgldt->fxInkTop    = -LTOFX(pgldt->rclInk.top);
    pgldt->fxInkBottom = -LTOFX(pgldt->rclInk.bottom);

    switch(pfo->flFontType & (FO_SIM_BOLD | FO_SIM_ITALIC))
    {
    case 0:
        cxSim = cxNoSim;
        xCharInc = (LONG)cxNoSim;
        break;

    case FO_SIM_BOLD:

        cxSim = cxNoSim + 1;
        xCharInc = (LONG)(cxNoSim + 1);
        break;

    case FO_SIM_ITALIC:

        cxSim = cxNoSim + (cy - 1) / 2;
        xCharInc = (LONG)cxNoSim;
        break;

    case (FO_SIM_BOLD | FO_SIM_ITALIC):

    // here we have used that
    // (k - 1) / 2 + 1 == (k + 1) / 2 for every integer k, (k == cy)

        cxSim = cxNoSim + (cy + 1) / 2;
        xCharInc = (LONG)(cxNoSim + 1);
        break;

    default:
        // to silence prefix
        cxSim = 1;
        RIP("BMFD!BAD SIM FLAG\n");
    }

    if (cxNoSim == 0)
    {
        cxSim = 1; // 1X1 blank box
        xCharInc = 0;
    }

    pgldt->fxD = LTOFX(xCharInc);
    pgldt->ptqD.x.HighPart = (LONG)pgldt->fxD;
    pgldt->ptqD.x.LowPart  = 0;
    pgldt->ptqD.y.HighPart = 0;
    pgldt->ptqD.y.LowPart  = 0;

// in this crude picture we are luying about x extents of the black box
// and report the whole bitmap width as an extent

    pgldt->rclInk.left  = 0;           // rclInk.left == lhs of the bitmap, => A < 0
    pgldt->rclInk.right = (LONG)cxSim; // the rhs of the bitmap => c < 0

// compute bearings, remember the rule A + B + C == char inc
// where B is the size of the inked box. For the horizontal case:
//          A == ePreBearing , C == ePostBearing
// In view of these sum rules and the definitions of A,B,C we have
//          B = rclInk.right - rclInk.left;
//          A = rclInk.left;
//          C = xCharInc - rclInk.right;
//      The sum rule is trivially obeyed.

    pgldt->fxA =  LTOFX(pgldt->rclInk.left); // fxA
    pgldt->fxAB = LTOFX(pgldt->rclInk.right); // right edge of the black box
}

/******************************Public*Routine******************************\
*
* VOID vCvtToBmp
*
* Effects: takes the bitmap in the original *.fnt column format and converts
*          it to the Bmp format.
*
* History:
*  25-Nov-1990 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

VOID vCvtToBmp
(
GLYPHBITS *pgb,
GLYPHDATA *pgd,
PBYTE pjBitmap,     // pointer to the bitmap in *.fnt column format
ULONG cx,
ULONG cy,
ULONG yBaseLine
)
{
    ULONG cjScan = CJ_SCAN(cx);  // # of bytes per scan of the Bmp

// pjColumn points to one of the bytes in the first ROW of the Bmp

    PBYTE pjColumn, pjColumnEnd;
    PBYTE pjDst, pjDstEnd;           // current destination byte

#ifdef DUMPCALL
    DbgPrint("\nvCvtToDIB(");
    DbgPrint("\n    GLYPHBITS    pgb       = %-#8lx",pgb      );
    DbgPrint("\n    GLYPHDATA    pgd       = %-#8lx",pgd      );
    DbgPrint("\n    PBYTE        pjBitmap  = %-#8lx",pjBitmap );
    DbgPrint("\n    ULONG        cx        = %-#8lx",cx       );
    DbgPrint("\n    ULONG        cy        = %-#8lx",cy       );
    DbgPrint("\n    ULONG        yBaseLine = %-#8lx",yBaseLine);
    DbgPrint("\n    )\n");
#endif

// store cx and cy at the top, before Bits

    pgb->sizlBitmap.cx = cx;
    pgb->sizlBitmap.cy = cy;

// this is character independent for BM fonts

    pgb->ptlOrigin.x = 0L;
    pgb->ptlOrigin.y = -(LONG)yBaseLine;

    RtlZeroMemory(pgb->aj, cjScan * cy);

// we shall fill the Bmp column by column, thus traversing the src a byte at
// the time:

    for
    (
        pjColumn = pgb->aj, pjColumnEnd = pjColumn + cjScan;
        pjColumn < pjColumnEnd;
        pjColumn++
    )
    {
        for
        (
            pjDst = pjColumn, pjDstEnd = pjColumn + cy * cjScan;
            pjDst < pjDstEnd;
            pjDst += cjScan, pjBitmap++
        )
        {
            *pjDst = *pjBitmap;
        }
    }
}

/******************************Public*Routine******************************\
*
* vCvtToBoldBmp
*
* History:
*  06-Oct-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

VOID vCvtToBoldBmp
(
GLYPHBITS *pgb,
GLYPHDATA *pgd,
PBYTE pjBitmap,     // pointer to the bitmap in *.fnt column format
ULONG cxSrc,
ULONG cy,
ULONG yBaseLine
)
{
    PBYTE pjSrc;
    PBYTE pjDst;

    ULONG cxDst = cxSrc + 1;                // + 1 for emboldening
    ULONG iScan,iByte;        // loop indices
    PBYTE pjS,pjD;

// number of bytes in one scan of the Dst or Src bitmaps. (dword aligned)

    ULONG cjScanDst = CJ_SCAN(cxDst);
    ULONG cjScanSrc = CJ_SCAN(cxSrc);
    BYTE  jCarry;   // carry bit from shifting Src byte by 1;

#ifdef DUMPCALL
    DbgPrint("\nVOID");
    DbgPrint("\nvCvtToBoldDIB(");
    DbgPrint("\n    GLYPHBITS    pgb       = %-#8lx",pgb      );
    DbgPrint("\n    GLYPHDATA    pgd       = %-#8lx",pgd      );
    DbgPrint("\n    PBYTE        pjBitmap  = %-#8lx",pjBitmap );
    DbgPrint("\n    ULONG        cxSrc     = %-#8lx",cxSrc    );
    DbgPrint("\n    ULONG        cy        = %-#8lx",cy       );
    DbgPrint("\n    ULONG        yBaseLine = %-#8lx",yBaseLine);
    DbgPrint("\n    )\n");
#endif

// this is character independent for BM fonts

    pgb->ptlOrigin.x = 0L;
    pgb->ptlOrigin.y = -(LONG)yBaseLine;

    pgb->sizlBitmap.cx = cxDst;
    pgb->sizlBitmap.cy = cy;

// init the loop over scans

    pjSrc = pjBitmap;
    pjDst = pgb->aj;

// embolden bitmap scan by scan

// if engine requested memory that is zero-ed out we would not have to do it
// ourselves

    RtlZeroMemory(pjDst, cjScanDst * cy);

    for (iScan = 0L; iScan < cy; iScan++)
    {
        pjS = pjSrc;
        pjD = pjDst;

    // embolden individual scans

        jCarry = (BYTE)0;   // no carry to the first byte in the row

        for
        (
            iByte = 0L;
            iByte < cjScanSrc;
            iByte++, pjS += cy, pjD++
        )
        {
            *pjD = (BYTE)(*pjS | ((*pjS >> 1) | jCarry));

        // remember the rightmost bit and shift it to the leftmost position

            jCarry = (BYTE)(*pjS << 7);
        }

        if ((cxSrc & 7L) == 0L)
            *pjD = jCarry;

    // advance to the next scan of the src and dst

        pjSrc++;
        pjDst += cjScanDst;
    }
}

/******************************Public*Routine******************************\
*
* vCvtToItalicBmp
*
* History:
*  06-Oct-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

VOID vCvtToItalicBmp
(
GLYPHBITS *pgb,
GLYPHDATA *pgd,
PBYTE pjBitmap,     // pointer to the bitmap in *.fnt column format
ULONG cxSrc,
ULONG cy,
ULONG yBaseLine
)
{
    ULONG cxDst = cxSrc + (ULONG)(cy - 1) / 2; // add correction for the

    PBYTE pjSrcScan, pjS;
    PBYTE pjDstScan, pjD;

    LONG  iScan,iByte;        // loop indices

// number of bytes in one scan of the Dst or Src bitmaps. (dword aligned)

    ULONG cjScanDst = CJ_SCAN(cxDst);

    LONG  cjScanSrc = (LONG)CJ_SCAN(cxSrc);
    LONG  lShift;
    BYTE  jCarry;   // carry from shifting Src byte by lShift;
    LONG  cjEmpty;  // number of untouched bytes at the begining of the dest scans

#ifdef DUMPCALL
    DbgPrint("\nVOID");
    DbgPrint("\nvCvtToItalicDIB(");
    DbgPrint("\n    GLYPHBITS    pgb       = %-#8lx",pgb      );
    DbgPrint("\n    GLYPHDATA    pgd       = %-#8lx",pgd      );
    DbgPrint("\n    PBYTE        pjBitmap  = %-#8lx",pjBitmap );
    DbgPrint("\n    ULONG        cxSrc     = %-#8lx",cxSrc    );
    DbgPrint("\n    ULONG        cy        = %-#8lx",cy       );
    DbgPrint("\n    ULONG        yBaseLine = %-#8lx",yBaseLine);
    DbgPrint("\n    )\n");
#endif


// this is character independent for BM fonts

    pgb->ptlOrigin.x = 0;
    pgb->ptlOrigin.y = -(LONG)yBaseLine;

    pgb->sizlBitmap.cx = cxDst;
    pgb->sizlBitmap.cy = cy;

// init the loop over scans

    pjSrcScan = pjBitmap;
    pjDstScan = pgb->aj;

// italicize bitmap row by row

    lShift = ((cy - 1) / 2) & (LONG)7;
    cjEmpty = ((cy - 1) / 2) >> 3;

#ifdef DEBUGITAL
    DbgPrint("cy = %ld,  yBaseLine = %ld, lShift = %ld, cjEmpty = %ld\n",
              cy,  -pgldtSrc->ptlBmpOrigin.y, lShift, cjEmpty);
    DbgPrint("cxSrc = %ld, cxDst = %ld, cjScanSrc = %ld, cjScanDst = %ld\n",
              cxSrc, cxDst, cjScanSrc, cjScanDst);
    DbgPrint("cy = %ld,  cjScanSrc = %ld, \n",
              cy, cjScanSrc);

#endif //  DEBUGITAL

// if engine requested memory that is zero-ed out we would not have to do it
// ourselves

    RtlZeroMemory(pjDstScan , cjScanDst * cy);

    for (iScan = 0L; iScan < (LONG)cy; iScan++)
    {
        if (lShift < 0L)
        {
            lShift = 7L;
            cjEmpty--;
        }

        ASSERTGDI(cjEmpty >= 0L, "cjEmpty\n");

    #ifdef DEBUGITALIC
        DbgPrint("iScan = %ld, lShift = %ld\n", iScan, lShift);
    #endif  // DEBUGITALIC

        pjS = pjSrcScan;
        pjD = pjDstScan + cjEmpty;

    // italicize individual scans

        jCarry = (BYTE)0;   // no carry to the first byte in the row

        for
        (
            iByte = 0L;
            iByte < cjScanSrc;
            iByte++, pjS += cy, pjD++
        )
        {
            *pjD = (BYTE)((*pjS >> lShift) | jCarry);

        // remember the lShift rightmost bits and move them over to the left

            jCarry = (BYTE)(*pjS << (8 - lShift));
        }

    // see if an extra bit in the destination has to be used to store info

        if ((LONG)((8 - (cxSrc & 7L)) & 7L) < lShift)
            *pjD = jCarry;

    // advance to the next scan

        pjSrcScan++;
        pjDstScan += cjScanDst;

    // decrease shift if switching to the next row (row = 2 scans)

        lShift -= (iScan & 1);
    }

    ASSERTGDI(lShift <= 0L, "vItalicizeBitmap: lShift > 0\n");
}

/******************************Public*Routine******************************\
*
* vCvtToBoldItalicBmp
*
* History:
*  06-Oct-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

VOID vCvtToBoldItalicBmp
(
GLYPHBITS *pgb,
GLYPHDATA *pgd,
PBYTE pjBitmap,     // pointer to the bitmap in *.fnt column format
ULONG cxSrc,
ULONG cy,
ULONG yBaseLine
)
{
// This is the length in pels for the destination for italicizing
// which serves as a source for subsequent emboldening
// This length is a length in pels of the "virtual"
// italicized source that is to be emboldened.

    ULONG cxSrcItalic = cxSrc + (cy - 1) / 2;  // + slope of italic chars

// length in pels of the true emboldened and italicized destination

    ULONG cxDst = cxSrcItalic + 1;  // + 1 for emboldening

    PBYTE pjSrcScan, pjS;
    PBYTE pjDstScan, pjD;

    LONG iScan,iByte;        // loop indices

// number of bytes in one scan of the Dst or Src bitmaps. (dword aligned)

    ULONG cjScanDst = CJ_SCAN(cxDst);
    ULONG cjScanSrc = CJ_SCAN(cxSrc);

    LONG  lShift;   // shift used to italicize;
    BYTE  jCarry;   // carry from shifting Src byte by lShift;
    LONG  cjEmpty;  // number of untouched bytes at the begining of the dest scans
    BYTE  jSrcItalic;
    BYTE  jCarryBold;

#ifdef DUMPCALL
    DbgPrint("\nVOID");
    DbgPrint("\nvCvtToBoldItalicDIB(");
    DbgPrint("\n    GLYPHBITS    pgb       = %-#8lx",pgb      );
    DbgPrint("\n    GLYPHDATA    pgd       = %-#8lx",pgd      );
    DbgPrint("\n    PBYTE        pjBitmap  = %-#8lx",pjBitmap );
    DbgPrint("\n    ULONG        cxSrc     = %-#8lx",cxSrc    );
    DbgPrint("\n    ULONG        cy        = %-#8lx",cy       );
    DbgPrint("\n    ULONG        yBaseLine = %-#8lx",yBaseLine);
    DbgPrint("\n    )\n");
#endif


// this is character independent for BM fonts

    pgb->ptlOrigin.x = 0;
    pgb->ptlOrigin.y = -(LONG)yBaseLine;

    pgb->sizlBitmap.cx = cxDst;
    pgb->sizlBitmap.cy = cy;

// init the loop over scans

    pjSrcScan = pjBitmap;
    pjDstScan = pgb->aj;

// embold and italicize bitmap row by row   (row = 2 scans)

    lShift = ((cy - 1) / 2) & (LONG)7;
    cjEmpty = ((cy - 1) / 2) >> 3;

#ifdef DEBUGBOLDITAL
    DbgPrint("cy = %ld,  yBaseLine = %ld, lShift = %ld, cjEmpty = %ld\n",
              cy, -pgldtSrc->ptlBmpOrigin.y, lShift, cjEmpty);
    DbgPrint("cxSrc = %ld, cxDst = %ld, cjScanSrc = %ld, cjScanDst = %ld\n",
              cxSrc, cxDst, cjScanSrc, cjScanDst);
    DbgPrint("cy = %ld,  cjScanSrc = %ld\n",
              cy, cjScanSrc);

#endif //  DEBUGBOLDITAL

// if engine requested memory that is zero-ed out we would not have to do it
// ourselves

    RtlZeroMemory(pjDstScan , cjScanDst * cy);

    for (iScan = 0L; iScan < (LONG)cy; iScan++)
    {
        if (lShift < 0L)
        {
            lShift = 7L;
            cjEmpty--;
        }

    #ifdef DEBUGBOLDITAL
        DbgPrint("iScan = %ld, lShift = %ld\n", iScan, lShift);
    #endif  // DEBUGBOLDITAL

        ASSERTGDI(cjEmpty >= 0L, "cjEmpty\n");

        pjS = pjSrcScan;
        pjD = pjDstScan + cjEmpty;

    // embolden individual scans

        jCarry = (BYTE)0;   // no carry to the first byte in the row
        jCarryBold = (BYTE)0;

        for
        (
            iByte = 0L;
            iByte < (LONG)cjScanSrc;
            iByte++, pjS += cy, pjD++
        )
        {
            jSrcItalic = (BYTE)((*pjS >> lShift) | jCarry);
            *pjD = (BYTE)(jSrcItalic | (jSrcItalic >> 1) | jCarryBold);

        // remember the lShift rightmost bits and move them over to the left

            jCarry = (BYTE)(*pjS << (8 - lShift));
            jCarryBold = (BYTE)(jSrcItalic << 7);
        }

    // see if an extra bit in the destination has to be used to store info

        if ((LONG)((8 - (cxSrc & 7L)) & 7L) < lShift)
        {
            jSrcItalic = jCarry;
            *pjD = (BYTE)(jSrcItalic | (jSrcItalic >> 1) | jCarryBold);
            jCarryBold = (BYTE)(jSrcItalic << 7);

            if ((cxSrcItalic & 7L) == 0L)
            {
                pjD++;
                *pjD = jCarryBold;
            }

        }

    // advance to the next scan

        pjSrcScan++;
        pjDstScan += cjScanDst;

    // change the value of the shift if doing the next row

        lShift -= (iScan & 1);
    }


    ASSERTGDI(lShift <= 0L, "vBoldItalicizeBitmap: lShift > 0\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\bmfd\fon32.c ===
/******************************Module*Header*******************************\
* Module Name: fon32.c
*
* support for 32 bit fon files
*
* Created: 03-Mar-1992 15:48:53
* Author: Bodin Dresevic [BodinD]
*
* Copyright (c) 1990 Microsoft Corporation
*
\**************************************************************************/

#include "fd.h"

/******************************Public*Routine******************************\
* bLoadntFon()
*
* History:
*  07-Jul-1995 -by- Gerrit van Wingerden [gerritv]
* Rewrote for kernel mode.
*  02-Mar-1992 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

BOOL
bLoadNtFon(
    HFF    iFile,
    PVOID  pvView,
    HFF    *phff
    )
{
    PFONTFILE      pff;
    IFIMETRICS*    pifi;
    INT            cFonts,i;
    BOOL           bRet = FALSE;
    PVOID          *ppvBases = NULL;
    ULONG          cjIFI,cVerified;
    ULONG          dpIFI;
    ULONG          dpszFileName;
    ULONG          cjff;
#ifdef FE_SB
    ULONG          cVerticalFaces = 0;
    USHORT         CharSet;
#endif

    // first find the number of font resource in the executeable

    cFonts = cParseFontResources( (HANDLE) iFile, &ppvBases );

    if (cFonts == 0)
    {
        return bRet;
    }
    cVerified = cjIFI = 0;

    // next loop through all the FNT resources to get the size of each fonts
    // IFIMETRICS

    for( i = 0; i < cFonts; i++ )
    {
        RES_ELEM re;

        re.pvResData = ppvBases[i];
        re.cjResData = ulMakeULONG((PBYTE) ppvBases[i] + OFF_Size );
        re.pjFaceName = NULL;

        if( bVerifyFNTQuick( &re ) )
        {
            cVerified += 1;
            cjIFI += cjBMFDIFIMETRICS(NULL,&re);
        }
        else
        {
            goto exit_freemem;
        }
    }

    *phff = (HFF)NULL;

#ifdef FE_SB
// extra space for possible vertical face
    cjIFI *= 2;
    dpIFI = offsetof(FONTFILE,afai[0]) + cVerified * 2 * sizeof(FACEINFO);
#else
    dpIFI = offsetof(FONTFILE,afai[0]) + cVerified * sizeof(FACEINFO);
#endif
    dpszFileName = dpIFI + cjIFI;
    cjff = dpszFileName;

    if ((*phff = hffAlloc(cjff)) == (HFF)NULL)
    {
        SAVE_ERROR_CODE(ERROR_NOT_ENOUGH_MEMORY);
        RETURN("BMFD! bLoadDll32: memory allocation error\n", FALSE);
    }
    pff = PFF(*phff);

    // init fields of pff structure

    pff->ident      = ID_FONTFILE;
    pff->fl         = 0;
    pff->iType      = TYPE_DLL32;
    pff->cFntRes    = cVerified;
    pff->iFile      = iFile;

    //!!! we could do better here, we could try to get a description string from
    //!!! the version stamp of the file, if there is one, if not we can still use
    //!!! this default mechanism [bodind]

    pff->dpwszDescription = 0;   // no description string, use Facename later
    pff->cjDescription    = 0;

    // finally convert all the resources

    pifi = (IFIMETRICS*)((PBYTE) pff + dpIFI);



    for( i = 0; i < cFonts; i++ )
    {
        RES_ELEM re;
        re.pvResData = ppvBases[i];
        re.cjResData = ulMakeULONG((PBYTE) ppvBases[i] + OFF_Size );
        re.dpResData = (PTRDIFF)((PBYTE) re.pvResData - (PBYTE) pvView );
        re.pjFaceName = NULL;

        pff->afai[i].re = re;
        pff->afai[i].pifi = pifi;
#if FE_SB
        pff->afai[i].bVertical = FALSE;
#endif
        if( !bConvertFontRes( &re, &pff->afai[i] ) )
        {
            goto exit_freemem;
        }

        pifi = (IFIMETRICS*)((PBYTE)pifi + pff->afai[i].pifi->cjThis);

#ifdef FE_SB
        CharSet = pff->afai[i].pifi->jWinCharSet;

        if( IS_ANY_DBCS_CHARSET(CharSet) )
        {
            re.pvResData = ppvBases[i];
            re.cjResData = ulMakeULONG((PBYTE) ppvBases[i] + OFF_Size );
            re.dpResData = (PTRDIFF)((PBYTE) re.pvResData - (PBYTE) pvView );
            re.pjFaceName = NULL;

            pff->afai[cFonts+cVerticalFaces].re = re;
            pff->afai[cFonts+cVerticalFaces].pifi = pifi;
            pff->afai[cFonts+cVerticalFaces].bVertical = TRUE;

            if( !bConvertFontRes( &re, &pff->afai[cFonts+cVerticalFaces] ) )
            {
                goto exit_freemem;
            }

            pifi = (IFIMETRICS*)((PBYTE)pifi + pff->afai[i].pifi->cjThis);
            cVerticalFaces += 1;
        }
#endif
    }

#ifdef FE_SB
    pff->cFntRes += cVerticalFaces;
#endif

    bRet = TRUE;
    pff->cRef = 0L;

exit_freemem:

    EngFreeMem( (PVOID*) ppvBases );

    if( !bRet && *phff )
    {
        EngFreeMem( (PVOID) *phff );
        *phff = (HFF)NULL;
    }

    return(bRet);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\bmfd\fon16.c ===
/******************************Module*Header*******************************\
* Module Name: fon16.c
*
* routines for accessing font resources within *.fon files
* (win 3.0 16 bit dlls)
*
* Created: 08-May-1991 12:55:14
* Author: Bodin Dresevic [BodinD]
*
* Copyright (c) 1990 Microsoft Corporation
*
\**************************************************************************/

#include "fd.h"
#include "exehdr.h"

// GETS ushort at (PBYTE)pv + off. both pv and off must be even

#define  US_GET(pv,off) ( *(PUSHORT)((PBYTE)(pv) + (off)) )
#define  S_GET(pv,off)  ((SHORT)US_GET((pv),(off)))


/******************************Public*Routine******************************\
* bInitWinResData
*
* Initializes the fields of the WINRESDATA structure so as to make it
* possible for the user to access *.fnt resources within the
* corresponding *.fon file
*
*   The function returns True if *.fnt resources found in the *.fon
* file, otherwise false (if not an *.fon file or if it contains no
* *.fnt resources
*
*
* History:
*  09-May-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

BOOL
bInitWinResData(
    PVOID  pvView,
    COUNT  cjView,
    PWINRESDATA pwrd
    )
{
    PBYTE pjNewExe;     // ptr to the beginning of the new exe hdr
    PBYTE pjResType;    // ptr to the beginning of TYPEINFO struct
    PBYTE pjResName;    // ptr to the beginning of NAMEINFO struct
    ULONG iResID;       // resource type id

#ifdef DUMPCALL
    DbgPrint("\nbInitWinResData(");
    DbgPrint("\n    PFILEVIEW   pfvw = %-#8lx", pfvw);
    DbgPrint("\n    PWINRESDATA pwrd = %-#8lx", pwrd);
    DbgPrint("\n    )\n");
#endif

    pwrd->pvView = pvView;
    pwrd->cjView = cjView;

// check the magic # at the beginning of the old header

    if (US_GET(pvView, OFF_e_magic) != EMAGIC)
        return(FALSE);

    pwrd->dpNewExe = (PTRDIFF)READ_DWORD((PBYTE)pvView + OFF_e_lfanew);

// make sure that offset is consistent

    if ((ULONG)pwrd->dpNewExe > pwrd->cjView)
        return FALSE;

    pjNewExe = (PBYTE)pvView + pwrd->dpNewExe;

    if (US_GET(pjNewExe, OFF_ne_magic) != NEMAGIC)
        return(FALSE);

    pwrd->cjResTab = (ULONG)(US_GET(pjNewExe, OFF_ne_restab) -
                             US_GET(pjNewExe, OFF_ne_rsrctab));

    if (pwrd->cjResTab == 0L)
    {
    //
    //  The following test is applied by DOS,  so I presume that it is
    // legitimate.  The assumption is that the resident name table
    // FOLLOWS the resource table directly,  and that if it points to
    // the same location as the resource table,  then there are no
    // resources.

        WARNING("No resources in *.fon file\n");
        return(FALSE);
    }

// want offset from pvView, not from pjNewExe => must add dpNewExe

    pwrd->dpResTab = (PTRDIFF)US_GET(pjNewExe, OFF_ne_rsrctab) + pwrd->dpNewExe;

// make sure that offset is consistent

    if ((ULONG)pwrd->dpResTab > pwrd->cjView)
        return FALSE;

// what really lies at the offset OFF_ne_rsrctab is a NEW_RSRC.rs_align field
// that is used in computing resource data offsets and sizes as a  shift factor.
// This field occupies two bytes on the disk and the first TYPEINFO structure
// follows right after. We want pwrd->dpResTab to point to the first
// TYPEINFO structure, so we must add 2 to get there and subtract 2 from
// the length

    pwrd->ulShift = (ULONG) US_GET(pvView, pwrd->dpResTab);
    pwrd->dpResTab += 2;
    pwrd->cjResTab -= 2;

// Now we want to determine where the resource data is located.
// The data consists of a RSRC_TYPEINFO structure, followed by
// an array of RSRC_NAMEINFO structures,  which are then followed
// by a RSRC_TYPEINFO structure,  again followed by an array of
// RSRC_NAMEINFO structures.  This continues until an RSRC_TYPEINFO
// structure which has a 0 in the rt_id field.

    pjResType = (PBYTE)pvView + pwrd->dpResTab;
    iResID = (ULONG) US_GET(pjResType,OFF_rt_id);

    while((iResID != 0L) && (iResID != RT_FNT))
    {
    // # of NAMEINFO structures that follow = resources of this type

        ULONG crn = (ULONG)US_GET(pjResType, OFF_rt_nres);

    // get ptr to the new TYPEINFO struc and the new resource id

        pjResType = pjResType + CJ_TYPEINFO + crn * CJ_NAMEINFO;
        iResID = (ULONG) US_GET(pjResType,OFF_rt_id);
    }

    if (iResID == RT_FNT)   // we found the font resource type
    {
    // # of NAMEINFO structures that follow == # of font resources

        pwrd->cFntRes = (ULONG)US_GET(pjResType, OFF_rt_nres);

    // this is ptr to the first NAMEINFO struct that follows
    // an RT_FNT TYPEINFO structure

        pjResName = pjResType + CJ_TYPEINFO;
        pwrd->dpFntTab = (PTRDIFF)(pjResName - (PBYTE)pvView);
    }
    else   // iResID == 0L, no font resources found in the font file
    {
    // no font resources

        pwrd->cFntRes = (ULONG)0;
        pwrd->dpFntTab = (PTRDIFF)0;
        return(FALSE);
    }

// make sure that offset is consistent

    if ((ULONG)pwrd->dpFntTab > pwrd->cjView)
        return FALSE;

// Now we search for the FONDIR resource.  Windows actually grabs facenames
// from the FONDIR entries and not the FNT entries.  For some wierd fonts this
// makes a difference. [gerritv]


    pjResType = (PBYTE)pvView + pwrd->dpResTab;
    iResID = (ULONG) US_GET(pjResType,OFF_rt_id);

    while((iResID != 0L) && (iResID != RT_FDIR))
    {
    // # of NAMEINFO structures that follow = resources of this type

        ULONG crn = (ULONG)US_GET(pjResType, OFF_rt_nres);

    // get ptr to the new TYPEINFO struc and the new resource id

        pjResType = pjResType + CJ_TYPEINFO + crn * CJ_NAMEINFO;
        iResID = (ULONG) US_GET(pjResType,OFF_rt_id);
    }

    if (iResID == RT_FDIR)   // we found the font resource type
    {
        COUNT cFdirEntries;

    // this is ptr to the first NAMEINFO struct that follows
    // an RT_FDIR TYPEINFO structure

        pjResName = pjResType + CJ_TYPEINFO;

    // Get the offset to res data computed from the top of the new header

        pwrd->dpFdirRes = (PTRDIFF)((ULONG)US_GET(pjResName,OFF_rn_offset) <<
                           pwrd->ulShift);

        if ((ULONG)pwrd->dpFdirRes > pwrd->cjView)
            return FALSE;

    // Now pwrd->dpFdirRes is an offset to the FONTDIR resource, the first
    // byte will be the number of entries in the font dir.  Lets make sure it
    // matches the number of FNT resources in the file.

        cFdirEntries = (ULONG)US_GET(pvView,pwrd->dpFdirRes);

        if( cFdirEntries != pwrd->cFntRes )
        {
            WARNING( "bInitWinResData: # of FONTDIR entries != # of FNT entries.\n");
            pwrd->cFntRes = (ULONG)0;
            pwrd->dpFntTab = (PTRDIFF)0;
            return(FALSE);
        }

    // now increment dpFdirRes so it points passed the count of entries and
    // to the first entry.

        pwrd->dpFdirRes += 2;

        return(TRUE);
    }
    else   // iResID == 0L, no FONTDIR resources found in the font file
    {
    // no font resources

        pwrd->cFntRes = (ULONG)0;
        pwrd->dpFntTab = (PTRDIFF)0;
        return(FALSE);
    }

}

/******************************Public*Routine******************************\
* vGetFntResource
*
* Writes the pointer to and the size of the iFntRes-th *.fnt resource
* of the *.fon file identified by pwrd. The info is written into RES_ELEM
* structure if successful. The function returns FALSE if it is not possible
* to locate iFntRes-th *.fnt resource in the file.
*
*
* History:
*  09-May-1991 -by- Bodin Dresevic [BodinD]
* Wrote it.
\**************************************************************************/

VOID
vGetFntResource(
    PWINRESDATA pwrd   ,
    ULONG       iFntRes,
    PRES_ELEM   pre
    )
{
    PBYTE pjResName,pjFaceName;
    PTRDIFF dpResData;

#ifdef DUMPCALL
    DbgPrint("\nvGetFntResource(");
    DbgPrint("\n    PWINRESDATA pwrd    = %-#8lx", pwrd);
    DbgPrint("\n    ULONG       iFntRes = %-#8lx", iFntRes);
    DbgPrint("\n    PRES_ELEM   pre     = %-#8lx", pre);
    DbgPrint("\n    )\n");
#endif

    ASSERTGDI((pwrd->cFntRes != 0L) && (iFntRes < pwrd->cFntRes),
               "vGetFntResource\n");

// get to the Beginning of the NAMEINFO struct that correspoonds to
// the iFntRes-th *.fnt resource. (Note: iFntRes is zero based)

    pjResName = (PBYTE)pwrd->pvView + pwrd->dpFntTab + iFntRes * CJ_NAMEINFO;

// Get the offset to res data computed from the top of the new header

    dpResData = (PTRDIFF)((ULONG)US_GET(pjResName,OFF_rn_offset) <<
                           pwrd->ulShift);

    pre->pvResData = (PVOID)((PBYTE)pwrd->pvView + dpResData);
    pre->dpResData = dpResData;

    pre->cjResData = (ULONG)US_GET(pjResName,OFF_rn_length) << pwrd->ulShift;

// Get the face name from the FONTDIR

    pjFaceName = (PBYTE) (PBYTE)pwrd->pvView + pwrd->dpFdirRes;

    do
    {
    // The first two bytes of the entry are the resource index so we will skip
    // past that.  After that add in the size of the font header.  This will
    // point us to the string for the device_name


        pjFaceName += 2 + OFF_BitsOffset;

    // skip past the device name

        while( *pjFaceName++ );

    // pjFaceName now really points to the facename


        if( iFntRes )
        {
        // skip past the facename if this isn't one we are looking for

            while( *pjFaceName++ );

        }

    }
    while( iFntRes-- );

    pre->pjFaceName = pjFaceName;

    #ifdef FOOGOO
    KdPrint(("%s: offset= 0x%lx, charset = %ld\n", pjFaceName, dpResData + OFF_CharSet, *((BYTE *)pwrd->pvView + dpResData + OFF_CharSet)));
    #endif
    return;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\bmfd\simulate.h ===
/******************************Module*Header*******************************\
* Module Name: simulate.h
*
* Created: 17-Apr-1991 08:30:37
* Author: Bodin Dresevic [BodinD]
*
* Copyright (c) 1990 Microsoft Corporation
*
\**************************************************************************/

ULONG
cFacesRes
(
    RES_ELEM*
    );

ULONG
cFacesFON
(
    WINRESDATA*
    );

VOID
vDontTouchIFIMETRICS(
    IFIMETRICS*
    );



#ifdef FE_SB
LONG
cjGlyphDataSimulated
(
    FONTOBJ*,
    ULONG,
    ULONG,
    ULONG*,
    ULONG
    );
#else
LONG
cjGlyphDataSimulated
(
    FONTOBJ*,
    ULONG,
    ULONG,
    ULONG*
    );
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\bmfd\fontfile.h ===
/******************************Module*Header*******************************\
* Module Name: fontfile.h
*
* (Brief description)
*
* Created: 25-Oct-1990 09:20:11
* Author: Bodin Dresevic [BodinD]
*
* Copyright (c) 1990 Microsoft Corporation
*
* (General description of its use)
*
* Dependencies:
*
*   (#defines)
*   (#includes)
*
\**************************************************************************/

// The CVTRESDATA  struct contains the info about particular resource
// The info is in the converted form (RES_ELEM points to the "raw"
// data in the font file, while  CVTRESDATA points to the data obtained
// from bConvertFontRes

// header of the converted font file, it is used both for 2.0 and 3.0 files,
// the fields that are 3.0 specofic are all zero filled for 2.0 font file.
// this structure has proper DWORD allignment, so that its fields can be
// accessed in the usual fashion, pcvtfh->field_name

#define FS_ZERO_WIDTH_GLYPHS     1

typedef struct _CVTFILEHDR        //  cvtfh,
{
    USHORT  iVersion;             // 2 OR 3
    USHORT  fsFlags;              // zero width glyphs present
    UCHAR   chFirstChar;          // First character defined in font
    UCHAR   chLastChar;           // Last character defined in font
    UCHAR   chDefaultChar;        // Sub. for out of range chars.
    UCHAR   chBreakChar;          // Word Break Character

    USHORT  cy;                   // height in Fixed Height
    USHORT      usMaxWidth;           // Maximum width; one of the corrected values
#ifdef FE_SB // _CVTFILEHDR - add fields for DBCS
    USHORT      usDBCSWidth;          // Width of double byte character
    USHORT      usCharSet;            // Charset of this font resource
#endif // FE_SB

    PTRDIFF     dpOffsetTable;      // offset to the offset table, I added this field

// fields that have no analog in original headers, to be filled with the data
// that corresponds to the converted "file" only. This info is cashed for
// later use by vFill_IFIMETRICS

    ULONG  cjFaceName;
    ULONG  cjIFI;
    ULONG  cjGlyphMax;    // size of the largest GLYPHDATA structure in ULONG's

} CVTFILEHDR, *PCVTFILEHDR;


// flags for the fsSelection field are the same as for the corresponding
// field of the IFIMETRICS structure of the ntifi.h interface, i.e.:

// FM_SEL_ITALIC
// FM_SEL_STRIKEOUT
// FM_SEL_UNDERSCORE
// FM_SEL_BOLD



typedef struct _FACEINFO  // fai
{
    RES_ELEM     re;
    HANDLE       hResData;   // only used for 32 bit dlls
#ifdef FE_SB
    BOOL         bVertical;  // if this face is @face , this field is TRUE
#endif // FE_SB
    CVTFILEHDR   cvtfh;      // aligned and CORRECTED data from the ogiginal header
    ULONG        iDefFace;
    CP_GLYPHSET *pcp;        // pointer to struc describing supported glyph set
    IFIMETRICS  *pifi;       // pointer to ifimetrics for this face
} FACEINFO, *PFACEINFO;


// The FACEDATA  struct contains the info about particular face
// (simulated faces included)

// allowed values for the FACEDATA.iSimulate field, !!! these must not change

#define  FC_SIM_NONE               0L
#define  FC_SIM_EMBOLDEN           1L
#define  FC_SIM_ITALICIZE          2L
#define  FC_SIM_BOLDITALICIZE      3L



typedef struct _FONTFILE       *PFONTFILE;    // pff
typedef struct _FONTCONTEXT    *PFONTCONTEXT; // pfc


#define FF_EXCEPTION_IN_PAGE_ERROR 1

typedef struct _FONTFILE    // ff
{
// fields required by handle manager

    ULONG   ident;          // identifier,conveniently chosen as 0X000000FF

// remaining fields

    FLONG fl;
    ULONG iType;            // original file is *.fnt, 16 bit dll or 32 bit dll

    HFF   iFile;    

    ULONG cRef;    // # no of times this font file is selected into fnt context

    ULONG   cFntRes; // # of *.fnt files associated with this fontfile struct
                     // == # of default faces

    ULONG   cjDescription;      // size of the desctiption string (in bytes)
                                // if size is zero, then there is no string
                                // and the facename should be used instead.

    PTRDIFF dpwszDescription;   // offset to the description string

// array of FACEDATA strucs, which is followed by a UNICODE description
// string.
// Full size of the FONTFILE structure is equal to

    FACEINFO afai[1];
} FONTFILE;

// allowed values for FONTFILE.iType field:

// ORIGINAL FILE IS AN *.FNT FILE which contains a single
// size of the single font

#define TYPE_FNT          1L

// ORIGINAL FILE IS A win 3.0 16 bit *.DLL (*.fon FILE),
// This file is compiled out of many *.fnt files
// that correspond to different sizes of the same face, (e.g. tmsr or helv)
// This is provided to ensure binary compatibility with win 3.0 *.fon files

#define TYPE_DLL16        2L

// ORIGINAL FILE IS A win 3.0 32 bit *.DLL
// This file is compiled out of many *.fnt files using NT tools
// (coff linker and nt resource compiler)

#define TYPE_DLL32        3L

// an fnt file that is embeded in an exe and loaded using FdLoadResData

#define TYPE_EXE          4L


//
// Allowed values for the    FONTFILE.iDefaultFace field
//

#define FF_FACE_NORMAL          0L
#define FF_FACE_BOLD            1L
#define FF_FACE_ITALIC          2L
#define FF_FACE_BOLDITALIC      3L


typedef struct _FONTCONTEXT     // fc
{
// fields required by handle manager

    ULONG ident;            // identifier,conveniently chosen as 0X000000FC

// remaining fields

    HFF    hff;      // handle of the font file selected into this context

#ifdef FE_SB // FONTCONTEXT
    ULONG ulRotate;         // Rotation degree 0 , 900 , 1800 , 2700
#endif // FE_SB

// which resource (face) this context corresponds

    FACEINFO *pfai;

// what to do

    FLONG flFontType;

//  For Win 3.1 compatibility raster fonts can be scaled from 1 to 5
//  vertically and 1-256 horizontally.  ptlScale contains the x and y
//  scaling factors.

    POINTL ptlScale;

// the size of the GLYPHDATA structure necessary to store the largest
// glyph bitmap with the header info. This is value is cashed at the
// time the font context is opened and used later in FdQueryGlyphBitmap

    ULONG cxMax;        // the width in pels of the largest bitmap
    ULONG cjGlyphMax;   // size of the RASTERGLYPH for the largest glyph

// true if ptlScale != (1,1)

    FLONG flStretch;

// buffer of the width of the maximum bm scan, to be used by sretch routine
// We shall only use ajStrecthBuffer if the buffer of length CJ_STRETCH
// that is allocated on the stack is not big enough, which should almost
// never happen

    BYTE ajStretchBuffer[1];

}FONTCONTEXT;

// set if ptlScale != (1,1)

#define FC_DO_STRETCH       1

// set if streching WIDE glyph which can not fit in CJ_STRETCH buffer

#define FC_STRETCH_WIDE   2


// exaple: if CJ_STRETCH == 256, that suffices for bitmap of width cx = 2048
// ==  8 bits * 256 bytes

#define CJ_STRETCH (sizeof(DWORD)  * 64)


//
//  The face  provided in the *.fnt file may or may not be emboldened
//  or italicized, but most often (I'd say in 99.99% of the cases)
//  it will be neither emboldened nor italicized.
//
//  If the font provided in the *.fnt file is "normal" (neither bold nor italic)
//  there will be 4 faces associated with this *.fnt:
//
//       default,                   // neither bold nor italic
//       emboldened,                // simulated
//       italicized                 // simulated
//       emboldened and italicized. // simulated
//
//  If the font provided in the *.fnt file is already emboldened
//  there will be 2 faces associated with this *.fnt:
//
//       default,       // already emboldened
//       italicized     // will appear as emboldened and italicized font
//                      // where italicization will be simulated
//
//  If the font provided in the *.fnt file is already italicized
//  there will be 2 faces associated with this *.fnt:
//
//       default,       // already italicized
//       emboldened     // will appear as emboldened and italicized font
//                      // where emboldening will be simulated
//
//  If the font provided in the *.fnt file is already italicized and emboldened
//  only a single default face will be associated with this *.fnt. No simulated faces
//  will be provided
//

// identifiers for FONTFILE and FONTCONTEXT objects

#define ID_FONTFILE     0x000000FF
#define ID_FONTCONTEXT  0x000000FC

// object types for these objects

#define TYPE_FONTCONTEXT    (OBJTYPE)0x0040
#define TYPE_FONTFILE       (OBJTYPE)0x0041



// basic "methods" that act on the FONTFILE object  (in fontfile.c)

#define hffAlloc(cj)         ((HFF)EngAllocMem(0, cj, 'dfmB'))
#define PFF(hff)             ((PFONTFILE)(hff))

// basic "methods" that act on the FONTCONTEXT object  (in fontfile.c)

#define hfcAlloc(cj)         ((HFC)EngAllocMem(0, cj, 'dfmB'))
#define PFC(hfc)             ((PFONTCONTEXT)(hfc))

#undef  VFREEMEM
#define VFREEMEM(pv)         EngFreeMem((PVOID)pv)

extern HSEMAPHORE   ghsemBMFD;
extern CP_GLYPHSET *gpcpGlyphsets;
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\fs\fnterr.h ===
#ifndef _FNTERR_H
#define _FNTERR_H
/**********************************************************************
	
	fnterr.h -- Error Support Routines prototypes.

	(c) Copyright 1992  Microsoft Corp.
	All rights reserved.

	This header file provides prototypes for the fnterr.c 
	 source module.  This module keys on the #define FSCFG_FNTERR
	which is defined in fsconfig.h

	 7/28/92 dj         First cut.

 **********************************************************************/


#ifdef FSCFG_FNTERR

#define ERR_RANGE                 1
#define ERR_ASSERTION             2
#define ERR_CVT                   3
#define ERR_FDEF                  4
#define ERR_ELEMENT               5
#define ERR_INDEX                 6
#define ERR_STORAGE               7
#define ERR_STACK                 8
#define ERR_POINT                 9
#define ERR_POINT_TLP             10
#define ERR_POINT_PP              11
#define ERR_CONTOUR               12
#define ERR_VECTOR                13
#define ERR_LARGER                14
#define ERR_INT8                  15
#define ERR_INT16                 16
#define ERR_SCANMODE              17
#define ERR_SELECTOR              18
#define ERR_STATE                 19
#define ERR_GETSINGLEWIDTHNIL     20
#define ERR_GETCVTENTRYNIL        21
#define ERR_INVOPC                22
#define ERR_UNBALANCEDIF          23

#define ERR_CONTEXT_FILE          0
#define ERR_CONTEXT_SIZE          1
#define ERR_CONTEXT_CODE          2

#define ERR_CONTEXT(a,b,c,d)      fnterr_Context((a),(b),(c),(d))
#define ERR_START()               fnterr_Start()
#define ERR_RECORD(a)             fnterr_Record((int)(a))
#define ERR_REPORT(a,b,c,d,e)     fnterr_Report((int)(a),(long)(b),(long)(c),(long)(d),(long)(e))
#define ERR_BREAK()               { if ( fnterr_Break() ) break; }
#define ERR_OPC(a)                fnterr_Opc(a)
#define ERR_END()                 fnterr_End()
#define ERR_IF(a)                 fnterr_If(a)

void fnterr_Context (int, char *, unsigned short, unsigned short);
void fnterr_Start (void);
void fnterr_Record (int);
void fnterr_Report (int, long, long, long, long);
int  fnterr_Break (void);
void fnterr_Opc (char*);
void fnterr_End (void);
void fnterr_If (int);

#else

#define ERR_CONTEXT(a,b,c,d)
#define ERR_START()
#define ERR_RECORD(a)
#define ERR_REPORT(a,b,c,d,e)     DEBUGGER ()
#define ERR_BREAK()
#define ERR_OPC(a)
#define ERR_END()
#define ERR_IF(a)

#endif
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\kdexts\kdexts.cxx ===
/*++

Copyright (c) 1993  Microsoft Corporation

Module Name:

    kdexts.c

Abstract:

    This file contains the generic routines and initialization code
    for the kernel debugger extensions dll.

Author:

    Wesley Witt (wesw) 26-Aug-1993

Environment:

    User Mode

--*/

#include "precomp.hxx"

#include <ntverp.h>

//
// globals
//
EXT_API_VERSION        ApiVersion = { 3, 5, EXT_API_VERSION_NUMBER, 0 };
WINDBG_EXTENSION_APIS  ExtensionApis;
ULONG                  STeip;
ULONG                  STebp;
ULONG                  STesp;
USHORT                 SavedMajorVersion;
USHORT                 SavedMinorVersion;



DllInit(
    HANDLE hModule,
    DWORD  dwReason,
    DWORD  dwReserved
    )
{
    switch (dwReason) {
        case DLL_THREAD_ATTACH:
            break;

        case DLL_THREAD_DETACH:
            break;

        case DLL_PROCESS_DETACH:
            break;

        case DLL_PROCESS_ATTACH:
            break;
    }

    return TRUE;
}


VOID
WinDbgExtensionDllInit(
    PWINDBG_EXTENSION_APIS lpExtensionApis,
    USHORT MajorVersion,
    USHORT MinorVersion
    )
{
    ExtensionApis = *lpExtensionApis;

    SavedMajorVersion = MajorVersion;
    SavedMinorVersion = MinorVersion;

    return;
}

DECLARE_API( version )
{
#if DBG
    PCHAR DebuggerType = "Checked";
#else
    PCHAR DebuggerType = "Free";
#endif

    dprintf( "%s Extension dll for Build %d debugging %s kernel for Build %d\n",
             DebuggerType,
             VER_PRODUCTBUILD,
             SavedMajorVersion == 0x0c ? "Checked" : "Free",
             SavedMinorVersion
           );
}

VOID
CheckVersion(
    VOID
    )
{
#if DBG
    if ((SavedMajorVersion != 0x0c) || (SavedMinorVersion != VER_PRODUCTBUILD)) {
        dprintf("\r\n*** Extension DLL(%d Checked) does not match target system(%d %s)\r\n\r\n",
                VER_PRODUCTBUILD, SavedMinorVersion, (SavedMajorVersion==0x0f) ? "Free" : "Checked" );
    }
#else
    if ((SavedMajorVersion != 0x0f) || (SavedMinorVersion != VER_PRODUCTBUILD)) {
        dprintf("\r\n*** Extension DLL(%d Free) does not match target system(%d %s)\r\n\r\n",
                VER_PRODUCTBUILD, SavedMinorVersion, (SavedMajorVersion==0x0f) ? "Free" : "Checked" );
    }
#endif
}

LPEXT_API_VERSION
ExtensionApiVersion(
    VOID
    )
{
    return &ApiVersion;
}

=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\fs\fnterr.c ===
/**********************************************************************
	
	fnterr.c -- Error Support Routines.

	(c) Copyright 1992  Microsoft Corp.
	All rights reserved.

	This source file provides support for debugging routines in fnt.c
	(and macjob.c to a much lesser extent).  This module keys on the
	 #define FSCFG_FNTERR which is defined in fsconfig.h

	 7/28/92 dj         First cut.
	 8/12/94 deanb      included fnterr.h for mac
	12/07/94 deanb		changed %x to %hx or %lx; %d to %hd

 **********************************************************************/

#define FSCFG_INTERNAL

#include "fsconfig.h"
#include "fnterr.h"

#ifdef FSCFG_FNTERR
#include <stdio.h>
#include <string.h>
#include <ctype.h>

/* FILE * fopen(); */
int    abs (int);
/*
int    strlen (char*);
int    strcmp (char*, char*);
int    strcpy (char*, char*);
int    strncpy( char*, char *, int);
*/

#define ERR_MAX_IFS      8
#define ERR_MAX_CODE     16
#define ERR_MAX_FNAME    80
#define ERR_MAX_MSG  512

static int               errOpc;
static int               errBreak;
static int               errIfOk  = 1;
static unsigned short    errSize  = 0;
static unsigned short    errCode  = 0;
static int               errIfNdx = 0;
static long              errInstCount;
static int               errIfs[ERR_MAX_IFS];
static char              errOpName[ERR_MAX_CODE];
static char              errFname[ERR_MAX_FNAME];
static char            * errOpcs[] =
{
  "SVTCA_0",
  "SVTCA_1",
  "SPVTCA",
  "SPVTCA",
  "SFVTCA",
  "SFVTCA",
  "SPVTL",
  "SPVTL",
  "SFVTL",
  "SFVTL",
  "WPV",
  "WFV",
  "RPV",
  "RFV",
  "SFVTPV",
  "ISECT",
  "SetLocalGraphicState",
  "SetLocalGraphicState",
  "SetLocalGraphicState",
  "SetElementPtr",
  "SetElementPtr",
  "SetElementPtr",
  "SetElementPtr",
  "SetLocalGraphicState",
  "SetRoundState",
  "SetRoundState",
  "LMD",
  "ELSE",
  "JMPR",
  "LWTCI",
  "LSWCI",
  "LSW",
  "DUP",
  "SetLocalGraphicState",
  "CLEAR",
  "SWAP",
  "DEPTH",
  "CINDEX",
  "MINDEX",
  "ALIGNPTS",
  "RAW",
  "UTP",
  "LOOPCALL",
  "CALL",
  "FDEF",
  "IllegalInstruction",
  "MDAP",
  "MDAP",
  "IUP",
  "IUP",
  "SHP",
  "SHP",
  "SHC",
  "SHC",
  "SHE",
  "SHE",
  "SHPIX",
  "IP",
  "MSIRP",
  "MSIRP",
  "ALIGNRP",
  "SetRoundState",
  "MIAP",
  "MIAP",
  "NPUSHB",
  "NPUSHW",
  "WS",
  "RS",
  "WCVT",
  "RCVT",
  "RC",
  "RC",
  "WC",
  "MD",
  "MD",
  "MPPEM",
  "MPS",
  "FLIPON",
  "FLIPOFF",
  "DEBUG",
  "BinaryOperand",
  "BinaryOperand",
  "BinaryOperand",
  "BinaryOperand",
  "BinaryOperand",
  "BinaryOperand",
  "UnaryOperand",
  "UnaryOperand",
  "IF",
  "EIF",
  "BinaryOperand",
  "BinaryOperand",
  "UnaryOperand",
  "DELTAP1",
  "SDB",
  "SDS",
  "BinaryOperand",
  "BinaryOperand",
  "BinaryOperand",
  "BinaryOperand",
  "UnaryOperand",
  "UnaryOperand",
  "UnaryOperand",
  "UnaryOperand",
  "ROUND",
  "ROUND",
  "ROUND",
  "ROUND",
  "NROUND",
  "NROUND",
  "NROUND",
  "NROUND",
  "WCVTFOD",
  "DELTAP2",
  "DELTAP3",
  "DELTAC1",
  "DELTAC2",
  "DELTAC3",
  "SROUND",
  "S45ROUND",
  "JROT",
  "JROF",
  "SetRoundState",
  "IllegalInstruction",
  "SetRoundState",
  "SetRoundState",
  "SANGW",
  "AA",
  "FLIPPT",
  "FLIPRGON",
  "FLIPRGOFF",
  "IDefPatch",
  "IDefPatch",
  "SCANCTRL",
  "SDPVTL",
  "SDPVTL",
  "GETINFO",
  "IDEF",
  "ROTATE",
  "BinaryOperand",
  "BinaryOperand",
  "SCANTYPE",
  "INSTCTRL",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "IDefPatch",
  "PUSHB",
  "PUSHB",
  "PUSHB",
  "PUSHB",
  "PUSHB",
  "PUSHB",
  "PUSHB",
  "PUSHB",
  "PUSHW",
  "PUSHW",
  "PUSHW",
  "PUSHW",
  "PUSHW",
  "PUSHW",
  "PUSHW",
  "PUSHW",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MDRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP",
  "MIRP"
};

/*
  errOutput() - writes an error to standard out and to a log file.  the
  log file is always opened and closes in order to avoid file corruption
  by an application gone wild.
*/
static void errOutput( char * );
static void errOutput( char * msg )
{
  static  int firsttime = 1;
  FILE  * fp;

  printf("%s", msg);
  fp = fopen ("compfont.err", (firsttime ? "w" : "a"));
  if (fp)
  {
	fprintf (fp, "%s", msg);
	fclose (fp);
  }
  firsttime = 0;
  return;
}

/*
  errPrint() - used to generate a useful (?) error message based on the 
  error 'flag' and the parameters ('v1..v4').
*/
static void errPrint (int, long, long, long, long);
static void errPrint (int flag, long v1, long v2, long v3, long v4)
{
  char   msg[ERR_MAX_MSG];
  char * opcodeName;
  char   c;
  int    i;

/*
  build the context line.  it indicates the file being processed, the point
  size, the character code (or glyph index), as well as the releative inst 
  number of this instruction for this code.
*/
  i  = sprintf (msg,   "\n*** ERROR*** ");
  i += sprintf (msg+i, "\"%s\", ", errFname);
  i += sprintf (msg+i, "%hd Point, ", errSize);
  i += sprintf (msg+i, "Code %hd (0x%hX), ", errCode, errCode);
  i += sprintf (msg+i, "Inst: #%ld\n", errInstCount);

/*
  build the error line.  it indicates the name of the instruction followed
  by the actual error information.  note: finding the actual opcode name
  for some the instructions is sorta kludgy.  names like "SetLocalGraphicState",
  and "BinaryOperand" are not actual instructions.  In these cases, look to
  the second character of the name - if it is lower case, then we need to 
  work a little harder, so look to 'errOpName' (which should be set by this
  point) it should contain the correct instruction name.
*/
  c = *(errOpcs[errOpc]+1);
  opcodeName =(islower(c) && strlen(errOpName)) ? errOpName : errOpcs[errOpc];
  i += sprintf (msg+i, "(%s) ", opcodeName);
  errOpName[0] = '\0';

/*
  output what you have so far and then process the error
*/
  errOutput (msg);
  switch (flag)
  {
	case ERR_RANGE:
	  sprintf (msg, "Value out of range: value = %ld, range = %ld .. %ld\n",
				v1, v2, v3); 
	  break;
	case ERR_ASSERTION:
	  sprintf (msg, "Assertion check failed\n"); 
	  break;
	case ERR_CVT:
	  sprintf (msg, "CVT out of range: CVT = %ld, range = %ld .. %ld\n",
				v1, v2, v3); 
	  break;
	case ERR_FDEF:
	  sprintf (msg, "FDEF out of range: FDEF = %ld, range = %ld .. %ld\n",
				v1, v2, v3); 
	  break;
	case ERR_ELEMENT:
	  sprintf (msg, "Element %ld exceeds max elements (%ld)\n", v1, v2, v3); 
	  break;
	case ERR_CONTOUR:
	  i = sprintf (msg, "CONTOUR out of range: ");
	sprintf (msg+i, "CONTOUR = %ld, range = %ld .. %ld\n", v1, v2, v3); 
	  break;
	case ERR_POINT:
	  i = sprintf (msg, "POINT out of range: ");
	sprintf (msg+i, "POINT = %ld, range = %ld .. %ld\n", v1, v2, v3); 
	  break;
	case ERR_INDEX:
	  i = sprintf (msg, "POINT 0x%lX is neither element[0] ", v1);
	  sprintf( msg+i, "(0x%lX) nor element[1] (0x%lX)\n", v2, v3); 
	  break;
	case ERR_STORAGE:
	  i = sprintf (msg, "Storage index out of range: ");
	sprintf (msg+i, "Index = %ld, range = %ld .. %ld\n", v1, v2, v3); 
	  break;
	case ERR_STACK:
	  i = sprintf (msg, "Stack pointer out of range: ");
	sprintf (msg+i, "Pointer = %ld, range = %ld .. %ld\n", v1, v2, v3); 
	  break;
	case ERR_VECTOR:
	  sprintf (msg, "Illegal (x.y) vector: (%ld.%ld)\n", v1, v2); 
	  break;
	case ERR_LARGER:
	  sprintf (msg, "Value too small: %ld is not larger than %ld\n", v2, v1); 
	  break;
	case ERR_INT8:
	  sprintf (msg, "Value too large: 0x%lX exceeds 1 byte capacity\n", v1);
	  break;
	case ERR_INT16:
	  sprintf (msg, "Value too large: 0x%lX exceeds 2 byte capacity\n", v1);
	  break;
	case ERR_SCANMODE:
	  sprintf (msg, "Invalid scan mode: %ld\n", v1);
	  break;
	case ERR_SELECTOR:
	  sprintf (msg, "Invalid scan value: %ld\n", v1);
	  break;
	case ERR_STATE:
	  i = sprintf (msg, "Boundry limit error: xmin = ");
	  sprintf (msg+1, "%ld, xmax = %ld, ymin = %ld, ymax = %ld\n",
				v1, v2, v3, v4); 
	  break;
	case ERR_GETSINGLEWIDTHNIL:
	  sprintf (msg, "Sanity: Single width is nil\n");
	  break;
	case ERR_GETCVTENTRYNIL:
	  sprintf (msg, "Sanity: CVT Entry is nil\n");
	  break;
	case ERR_INVOPC:
	  sprintf (msg, "Invalid opcode: %ld\n", v1);
	  break;
	case ERR_UNBALANCEDIF:
	  sprintf (msg, "Unbalanced: missing %s instruction\n",
				( v1 > 0 ) ? "EIF" : "IF" );
	  break;
	default:
	  sprintf (msg, "Unknown Error:\n");
	  break;
  }

/*
  output the rest and return
*/
  errOutput (msg);
  return;
}

/*
  fnterr_Context() - called before any other fnterr routine.  it records
  the job name, character size and character code / glyph index.
*/
void fnterr_Context (int sw, char * str, unsigned short sz, unsigned short cd)
{
/*
  record a piece of the context
*/
  switch (sw)
  {
	case ERR_CONTEXT_FILE:
	  strncpy ( errFname, str, ERR_MAX_FNAME);
	  errFname[ERR_MAX_FNAME-1] = '\0';
	  break;
	case ERR_CONTEXT_SIZE:
	  errSize = sz;
	  break;
	case ERR_CONTEXT_CODE:
	  errCode = cd;
	  break;
  }

/*
  reset errOpName to be NULL before we start any real processing
*/
  errOpName[0] = '\0';
  return;
}

/*
  fnterr_Start() - called before the main execute loop of fnt_Execute() and
  fnt_TraceExecute().  it resets the instruction count to zero, and errBreak
  to 0 (ie: don't break out of execution loop).  set up IF/EIF counter for
  this level.
*/
void fnterr_Start (void)
{
  errInstCount = 0L;
  errBreak = 0;

  if (errIfOk && (++errIfNdx < ERR_MAX_IFS ))
	errIfs[errIfNdx] = 0;
  else
	errIfOk = 0;

  return;
}

/*
  fnterr_Record() - called inside the main execute loop of fnt_Execute()
  and fnt_TraceExecute().  it increments the instruction count, and resets
  the opcode number.  IFs or EIFs are accounted for. (note: other IFs and
  EIFs will be accounted for by calls to ERR_IF() in fnt.c)
*/
void fnterr_Record (int opc)
{
  errInstCount++;
  errOpc = opc;

  if (!strcmp ("IF", errOpcs[errOpc]))
	fnterr_If (1);
  else if (!strcmp ("EIF", errOpcs[errOpc]))
	fnterr_If (-1);

  return;
}

/*
  fnterr_Report() - called inside the main execute loop of fnt_Execute()
  and fnt_TraceExecute().  it calls errPrint() (with the passed parameters)
  to note the error, and sets errBreak so that the execution loop will end.
*/
void fnterr_Report (int flag, long v1, long v2, long v3, long v4)
{
  errPrint (flag, v1, v2, v3, v4);
  errBreak = 1;
  return;
}

/*
  fnterr_Break() - returns the value of errBreak.  if a non-zero valid is
  returned (re: fnterr_Report()), the main execute loop of fnt_Execute()
  or fnt_TraceExecute() will terminate.
*/
int fnterr_Break (void)
{
  return (errBreak);
}

/*
  fnterr_Opc() - called by combinate fnt calls to indicate the actual
  opcode errGet() can use.  this is a kludgy way to get around the non
  real opcode name in the errOpcs[] table.
*/
void fnterr_Opc (char *opc)
{
  strcpy (errOpName, opc);
  return;
}

/*
  fnterr_End() - called after the main execute loop of fnt_Execute() and
  fnt_TraceExecute().  it checks for balanced IF/EIF pairs.
*/
void fnterr_End (void)
{
  if (errIfOk)
  {
	if (errIfs[errIfNdx])
	  errPrint (ERR_UNBALANCEDIF, (long)errIfs[errIfNdx], 0L, 0L, 0L);
	if (--errIfNdx < 0)
	  errIfOk = 0;
  }
  return;
}

/*
  fnterr_If() - records IF/EIF activity inside of fnt_IF(), fnt_ELSE() and
  fnt_EIF() (re: fnt.c).
*/
void fnterr_If (int val)
{
  if (errIfOk)
	errIfs[errIfNdx] += val;
  return;
}

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\fs\fontmath.c ===
/*
	File:       FontMath.c

	Contains:   xxx put contents here xxx

	Written by: xxx put writers here xxx

	Copyright:  (c) 1987-1990, 1992 by Apple Computer, Inc., all rights reserved.
				(c) 1989-1997. Microsoft Corporation, all rights reserved.

	Change History (most recent first):

		  <>     2/21/97	CB		ClaudeBe, add mth_UnitarySquare for scaled component in composite glyphs
		 <3>     11/9/90    MR      Fix CompDiv when numer and denom have zero hi longs. [rb]
		 <2>     11/5/90    MR      Remove Types.h from include list, rename FixMulDiv to LongMulDiv
									[rb]
		 <1>    10/20/90    MR      Math routines for font scaler. [rj]

	To Do:
*/

// Has anybody ever thought of replacing some of the 64bit arithmetic in here (and probably in other places)
// by "native" __int64 arithmetic, at least in the INTEL case? Could be faster, since the compiler gets to do
// the inline code, and would be ready for future 64bit architectures. Just a thought. B.St.

#define FSCFG_INTERNAL

#include "fscdefs.h"
#include "fserror.h"
#include "fontmath.h"

#define HIBITSET                      0x80000000UL
#define POSINFINITY               0x7FFFFFFFUL
#define NEGINFINITY               0x80000000UL
#define POINTSPERINCH               72
#define ALMOSTZERO 33
#define ISNOTPOWEROF2(n)        ((n) & ((n)-1))
#define CLOSETOONE(x)   ((x) >= ONEFIX-ALMOSTZERO && (x) <= ONEFIX+ALMOSTZERO)
#define MAKEABS(x)  if (x < 0) x = -x
#define FXABS(x)  ((x) >= 0L ? (x) : -(x))
#define FRACT2FIX(n)    (((n) + (1 << (sizeof (Fract) - 3))) >> 14)

#define FASTMUL26LIMIT      46340
#define FASTDIV26LIMIT  (1L << 25)

#define USHORTMUL(a, b) ((uint32)((uint32)(uint16)(a)*(uint32)(uint16)(b)))

boolean mth_Max45Trick (Fixed x, Fixed y);

/*******************************************************************/

/* local prototypes */

void CompMul(int32 src1, int32 src2, int32 dst[2]);

int32 CompDiv(int32 src1, int32 src2[2]);

/*******************************************************************/

#ifndef CompMul

void CompMul(int32 lSrc1, int32 lSrc2, int32 alDst[2])
{
	boolean     bNegative;
	uint32      ulDstLo;
	uint32      ulDstHi;
	uint16      usSrc1lo;
	uint16      usSrc1hi;
	uint16      usSrc2lo;
	uint16      usSrc2hi;
	uint32      ulTemp;

	bNegative = (lSrc1 ^ lSrc2) < 0;

	if (lSrc1 < 0)
	{
		lSrc1 = -lSrc1;
	}
	if (lSrc2 < 0)
	{
		lSrc2 = -lSrc2;
	}

	usSrc1hi = (uint16)(lSrc1 >> 16);
	usSrc1lo = (uint16)lSrc1;
	usSrc2hi = (uint16)(lSrc2 >> 16);
	usSrc2lo = (uint16)lSrc2;
	ulTemp   = (uint32)usSrc1hi * (uint32)usSrc2lo + (uint32)usSrc1lo * (uint32)usSrc2hi;
	ulDstHi  = (uint32)usSrc1hi * (uint32)usSrc2hi + (ulTemp >> 16);
	ulDstLo  = (uint32)usSrc1lo * (uint32)usSrc2lo;
	ulTemp <<= 16;
	ulDstLo += ulTemp;
	ulDstHi += (uint32)(ulDstLo < ulTemp);

	if (bNegative)
	{
		ulDstLo = (uint32)-((int32)ulDstLo);

		if (ulDstLo != 0L)
		{
			ulDstHi = ~ulDstHi;
		}
		else
		{
			ulDstHi = (uint32)-((int32)ulDstHi);
		}
	}

	alDst[0] = (int32)ulDstHi;
	alDst[1] = (int32)ulDstLo;
}
#endif

/*******************************************************************/

#ifndef CompDiv

int32 CompDiv(int32 lSrc1, int32 alSrc2[2])
{
	boolean     bNegative;
	uint32      ulSrc1Lo;
	uint32      ulSrc1Hi;
	uint32      ulSrc2Lo;
	uint32      ulSrc2Hi;
	uint32      ulResult;
	uint32      ulPlace;

	int32    lResult;

	ulSrc2Hi = (uint32)alSrc2[0];
	ulSrc2Lo = (uint32)alSrc2[1];

	bNegative = ((int32)ulSrc2Hi ^ lSrc1) < 0;

	if ((int32)ulSrc2Hi < 0L)
	{
		ulSrc2Lo = (uint32)-((int32)ulSrc2Lo);

		if (ulSrc2Lo != 0L)
		{
			ulSrc2Hi = ~ulSrc2Hi;
		}
		else
		{
			ulSrc2Hi = (uint32)-((int32)ulSrc2Hi);
		}
	}
	if (lSrc1 < 0)
	{
		lSrc1 = -lSrc1;
	}

	ulResult = 0;
	ulPlace = HIBITSET >> 1;

	ulSrc1Hi = (uint32)lSrc1;

	if (ulSrc1Hi & 1)
	{
		ulSrc1Lo = HIBITSET;
	}
	else
	{
		ulSrc1Lo = 0;
	}

	ulSrc1Hi >>= 1;
	ulSrc2Lo += ulSrc1Hi;
	ulSrc2Hi += (uint32)(ulSrc2Lo < ulSrc1Hi);      /* round the result */

	if (ulSrc2Hi > ulSrc1Hi || ulSrc2Hi == ulSrc1Hi && ulSrc2Lo >= ulSrc1Lo)
	{
		if (bNegative)
		{
			return (int32)NEGINFINITY;
		}
		else
		{
			return (int32)POSINFINITY;
		}
	}

	while (ulPlace && ulSrc2Hi)
	{
		ulSrc1Lo >>= 1;
		if (ulSrc1Hi & 1)
		{
			ulSrc1Lo += HIBITSET;
		}
		ulSrc1Hi >>= 1;
		if (ulSrc1Hi < ulSrc2Hi)
		{
			/* 64 bit subtract */
			ulSrc2Hi -= ulSrc1Hi;
			ulSrc2Hi -= (uint32)(ulSrc1Lo > ulSrc2Lo);
			ulSrc2Lo -= ulSrc1Lo;

			ulResult += ulPlace;
		}
		else if (ulSrc1Hi == ulSrc2Hi && ulSrc1Lo <= ulSrc2Lo)
		{
			ulSrc2Hi = 0;
			ulSrc2Lo -= ulSrc1Lo;
			ulResult += ulPlace;
		}
		ulPlace >>= 1;
	}
	if (ulSrc2Lo >= (uint32)lSrc1)   /* Assert(lSrc1 >= 0)   */
	{
		ulResult += ulSrc2Lo/(uint32)lSrc1;
	}
	if (bNegative)
	{
		lResult = -((int32)ulResult);
	}
	else
	{
		lResult = (int32)ulResult;
	}
	return lResult;
}
#endif

/*******************************************************************/

/*
 *  a*b/c
 */
int32 LongMulDiv(int32 a, int32 b, int32 c)
{
	int32 temp[2];

	 CompMul(a, b, temp);
	return CompDiv(c, temp);
}

/*******************************************************************/

F26Dot6 ShortFracMul (F26Dot6 aDot6, ShortFract b)
{
	int32       lTemp[2];
	uint32      ulLow;
	F26Dot6     fxProduct;

	CompMul(aDot6, b, lTemp);

	ulLow = (((uint32)lTemp[1]) >> 13) + 1;           /* rounds up */
	fxProduct = (F26Dot6)(lTemp[0] << 18) + (F26Dot6)(ulLow >> 1);

	return (fxProduct);
}

/*******************************************************************/

ShortFract ShortFracDot (ShortFract a, ShortFract b)
{
	return (ShortFract)((((int32)a * (int32)b) + (1L << 13)) >> 14);
}


int32 ShortMulDiv(int32 a, int16 b, int16 c)
{
	return LongMulDiv(a, (int32)b, (int32)c);
}

int16 MulDivShorts (int16 a, int16 b, int16 c)
{
	return (int16)LongMulDiv((int32)a, (int32)b, (int32)c);
}

/*
 *  Total precision routine to multiply two 26.6 numbers        <3>
 */
F26Dot6 Mul26Dot6(F26Dot6 a, F26Dot6 b)
{
	 int32 negative = false;
	uint16 al, bl, ah, bh;
	uint32 lowlong, midlong, hilong;

	if ((a <= FASTMUL26LIMIT) && (b <= FASTMUL26LIMIT) && (a >= -FASTMUL26LIMIT) && (b >= -FASTMUL26LIMIT))
		  return (F26Dot6)((int32)(a * b + (1 << 5)) >> 6);                            /* fast case */

	if (a < 0) { a = -a; negative = true; }
	if (b < 0) { b = -b; negative ^= true; }

	 al = FS_LOWORD(a); ah = FS_HIWORD(a);
	 bl = FS_LOWORD(b); bh = FS_HIWORD(b);

	midlong = USHORTMUL(al, bh) + USHORTMUL(ah, bl);
	 hilong = USHORTMUL(ah, bh) + (uint32)FS_HIWORD(midlong);
	midlong <<= 16;
	midlong += 1 << 5;
	lowlong = USHORTMUL(al, bl) + midlong;
	hilong += (uint32)(lowlong < midlong);

	midlong = (lowlong >> 6) | (hilong << 26);
	if( negative)
	{
		return  (F26Dot6)-((int32)midlong);
	}
	else
	{
		return (F26Dot6)midlong;
	}
}

/*
 *  Total precision routine to divide two 26.6 numbers          <3>
 */
F26Dot6 Div26Dot6(F26Dot6 num, F26Dot6 den)
{
	 int32 negative = false;
	uint32 hinum, lownum, hiden, lowden, result, place;

	if (den == 0L)
	{
		if (num < 0L )
		{
				return (F26Dot6)NEGINFINITY;
		}
		else
		{
			return (F26Dot6)POSINFINITY;
		}
	}

	if ( (num <= FASTDIV26LIMIT) && (num >= -FASTDIV26LIMIT) )          /* fast case */
		  return (F26Dot6)(((int32)num << 6) / den);

	if (num < 0)
	{
		num = -num;
		negative = true;
	}
	if (den < 0)
	{
		den = -den;
		negative ^= true;
	}

	hinum = ((uint32)num >> 26);
	lownum = ((uint32)num << 6);
	hiden = (uint32)den;
	lowden = 0;
	result = 0;
	place = HIBITSET;

	if (hinum >= hiden)
	{
		if( negative )
		{
				return (F26Dot6)(uint32)NEGINFINITY;
		}
		else
		{
			return (F26Dot6)POSINFINITY;
		}
	}

	while (place)
	{
		lowden >>= 1;
		if (hiden & 1)
		{
			lowden += HIBITSET;
		}
		hiden >>= 1;
		if (hiden < hinum)
		{
			hinum -= hiden;
			hinum -= (uint32)(lowden > lownum);
			lownum -= lowden;
			result += place;
		}
		else if (hiden == hinum && lowden <= lownum)
		{
			hinum = 0;
			lownum -= lowden;
			result += place;
		}
		place >>= 1;
	}

	if (negative)
	{
		return (F26Dot6)-((int32)result);
	}
	else
	{
		return (F26Dot6)result;
	}
}

ShortFract ShortFracDiv(ShortFract num,ShortFract denum)
{
	return (ShortFract)(((int32)(num) << 14) / (int32)denum);
}

ShortFract ShortFracMulDiv(ShortFract numA,ShortFract numB,ShortFract denum)
{
	return (ShortFract) LongMulDiv ((int32) numA,(int32) numB, (int32)denum);
}

/* ------------------------------------------------------------ */

#ifndef FSCFG_USE_EXTERNAL_FIXMATH
/*  Here we define Fixed [16.16] and Fract [2.30] precision 
 *  multiplication and division functions and a Fract square root 
 *  function which are compatible with those in the Macintosh toolbox.
 *
 *  The division functions load the 32-bit numerator into the "middle"
 *  bits of a 64-bit numerator, then call the 64-bit by 32-bit CompDiv()
 *  function defined above, which can return a NEGINFINITY or POSINFINITY
 *  overflow return code.
 *
 *  The multiply functions call the 32-bit by 32-bit CompMul() function
 *  defined above which produces a 64-bit result, then they extract the
 *  "interesting" 32-bits from the middle of the 64-bit result and test 
 *  for overflow.
 *
 *  The GET32(a,i) macro defined below extracts a 32-bit value with "i" 
 *  bits of fractional precision from the 64-bit value in "a", a 2-element
 *  array of longs.
 *
 *  The CHKOVF(a,i,v) macro tests the most significant bits of the 
 *  64-bit value in "a", a 2-element array of longs, and tests the 
 *  32-bit result "v" for overflow.  "v" is defined as having "i" bits
 *  of fractional precision.
 *
 *  BIT() and OVFMASK() are "helper" macros used by GET32() and CHKOVF().
 *
 *  BIT(i) returns a mask with the "i"-th bit set.
 *  OVFMASK(i) returns a mask with the most-significant "32-i" bits set.
 */

#define BIT(i)          (1L<<(i))
#define OVFMASK(i)   ( ~0L ^ ( ((uint32)BIT(i)) - 1 ) )
#define CHKOVF(a,i,v)   (\
		( ((uint32)(a)[0] & OVFMASK(i))==0)          ? ( (v)>=0 ?(v) :POSINFINITY) : \
		( ((uint32)(a)[0] & OVFMASK(i))==OVFMASK(i)) ? ( (v)<=0 ?(v) :NEGINFINITY) : \
		( ((uint32)(a)[0] & BIT(31))                 ? POSINFINITY   :NEGINFINITY)   \
	)
#define GET32(a,i) \
((((a)[0]<<(32-(i))) | (int32)((uint32)((a)[1])>>(i))) + (int32)!!((a)[1] & BIT((i)-1)))

FS_MAC_PASCAL Fixed FS_PC_PASCAL FixMul (Fixed fxA, Fixed fxB)
{
	int32 alCompProd[2];
	Fixed fxProd;

	if  (fxA == 0 || fxB == 0)
		return 0;

	CompMul ((int32)fxA, (int32)fxB, alCompProd);
	fxProd = (Fixed)GET32 (alCompProd,16);
	return (Fixed)CHKOVF(alCompProd,16,fxProd);
}

FS_MAC_PASCAL Fixed FS_PC_PASCAL FixDiv (Fixed fxA, Fixed fxB)
{
	int32 alCompProd[2];
	
	alCompProd[0] = fxA >> 16;
	alCompProd[1] = fxA << 16;

	return CompDiv ((int32)fxB, alCompProd);
}

FS_MAC_PASCAL Fixed FS_PC_PASCAL FixRatio (int16 sA, int16 sB)
{
	int32 alCompProd[2];
	
	alCompProd[0] = ((int32)(sA)) >> 16;
	alCompProd[1] = ((int32)(sA)) << 16;

	return CompDiv ((int32)(sB), alCompProd);
}

FS_MAC_PASCAL Fract FS_PC_PASCAL FracMul (Fract frA, Fract frB)
{
	int32 alCompProd[2];
	Fract frProd;

	if  (frA == 0 || frB == 0)
		return 0;

	CompMul (frA,frB,alCompProd);
	frProd = (Fract)GET32 (alCompProd,30);
	return (Fract)CHKOVF(alCompProd,30,frProd);
}

FS_MAC_PASCAL Fract FS_PC_PASCAL FracDiv (Fract frA, Fract frB)
{
	int32 alCompProd[2];

	alCompProd[0] = frA >> 2;
	alCompProd[1] = frA << 30;
	return CompDiv ((int32)frB, alCompProd);
}

/*******************************************************************/

#ifndef FracSqrt

/* 
   Fract FracSqrt (Fract xf)
   Input:  xf           2.30 fixed point value
   Return: sqrt(xf)     2.30 fixed point value
*/

FS_MAC_PASCAL Fract FS_PC_PASCAL FracSqrt (Fract xf)
{
	Fract b = 0L;
	uint32 c, d, x = xf;
	
	if (xf < 0) return (NEGINFINITY);

	/*
	The algorithm extracts one bit at a time, starting from the
	left, and accumulates the square root in b.  The algorithm 
	takes advantage of the fact that non-negative input values
	range from zero to just under two, and corresponding output
	ranges from zero to just under sqrt(2).  Input is assigned
	to temporary value x (unsigned) so we can use the sign bit
	for more precision.
	*/
	
	if (x >= 0x40000000)
	{
		x -= 0x40000000; 
		b  = 0x40000000; 
	}

	/*
	This is the main loop.  If we had more precision, we could 
	do everything here, but the lines above perform the first
	iteration (to align the 2.30 radix properly in b, and to 
	preserve full precision in x without overflow), and afterward 
	we do two more iterations.
	*/
	
	for (c = 0x10000000; c; c >>= 1)
	{
		d = b + c;
		if (x >= d)
		{
			x -= d; 
			b += (c<<1); 
		}
		x <<= 1;
	}

	/*
	Iteration to get last significant bit.
	
	This code has been reduced beyond recognition, but basically,
	at this point c == 1L>>1 (phantom bit on right).  We would
	like to shift x and d left 1 bit when we enter this iteration,
	instead of at the end.  That way we could get phantom bit in
	d back into the word.  Unfortunately, that may cause overflow
	in x.  The solution is to break d into b+c, subtract b from x,
	then shift x left, then subtract c<<1 (1L).
	*/
	
	if (x > (uint32)b) /* if (x == b) then (x < d).  We want to test (x >= d). */
	{
		x -= b;
		x <<= 1;
		x -= 1L;
		b += 1L; /* b += (c<<1) */
	}
	else
	{
		x <<= 1;
	}

	/* 
	Final iteration is simple, since we don't have to maintain x.
	We just need to calculate the bit to the right of the least
	significant bit in b, and use the result to round our final answer.
	*/
	
	return ( b + (Fract)(x>(uint32)b) );
}

#endif  /* FracSqrt */

/*******************************************************************/

#endif


/* TRANSFORMATION ROUTINES */

/*
 *  Good for transforming fixed point values.  Assumes NO translate  <4>
 */
void mth_FixXYMul (Fixed*x, Fixed*y, transMatrix*matrix)
{
  Fixed xTemp, yTemp;
  Fixed *m0, *m1;

  m0 = (Fixed *) & matrix->transform[0][0];
  m1 = (Fixed *) & matrix->transform[1][0];

  xTemp = *x;
  yTemp = *y;
  *x = FixMul (*m0++, xTemp) + FixMul (*m1++, yTemp);
  *y = FixMul (*m0++, xTemp) + FixMul (*m1++, yTemp);

#ifndef PC_OS   /* Never a perspecitive with Windows */ /* !!!DISCUSS   */

  if (*m0 || *m1)     /* these two are Fracts */
  {
	Fixed tmp = FracMul (*m0, xTemp) + FracMul (*m1, yTemp);
	tmp += matrix->transform[2][2];
	if (tmp && tmp != ONEFIX)
	{
	  *x = FixDiv (*x, tmp);
	  *y = FixDiv (*y, tmp);
	}
  }
#endif
}


/*
 *  This could be faster        <4>
 */
void mth_FixVectorMul (vectorType*v, transMatrix*matrix)
{
  mth_FixXYMul (&v->x, &v->y, matrix);
}


/*
 *   B = A * B;     <4>
 *
 *         | a  b  0  |
 *    B =  | c  d  0  | * B;
 *         | 0  0  1  |
 */
void mth_MxConcat2x2 (transMatrix*A, transMatrix*B)
{
  Fixed storage[6];
  Fixed * s = storage;
  int32 i, j;

  for (j = 0; j < 2; j++)
	for (i = 0; i < 3; i++)
	  *s++ = FixMul (A->transform[j][0], B->transform[0][i]) + FixMul (A->transform[j][1], B->transform[1][i]);

  {
	Fixed*dst = &B->transform[2][0];
	Fixed*src = s;
	int16 i;
	for (i = 5; i >= 0; --i)
	  *--dst = *--src;
  }
}


/*
 * scales a matrix by sx and sy.
 *
 *
 *              | sx 0  0  |
 *    matrix =  | 0  sy 0  | * matrix;
 *              | 0  0  1  |
 *
 */
void mth_MxScaleAB (Fixed sx, Fixed sy, transMatrix *matrixB)
{
  int32       i;
  Fixed  *m = (Fixed *) & matrixB->transform[0][0];

  for (i = 0; i < 3; i++, m++)
	*m = FixMul (sx, *m);

  for (i = 0; i < 3; i++, m++)
	*m = FixMul (sy, *m);
}


/*
 *  Return 45 degreeness
 */
#ifndef PC_OS   /* !!!DISCUSS   */
boolean mth_Max45Trick (Fixed x, Fixed y)
{
  MAKEABS (x);
  MAKEABS (y);

  if (x < y)      /* make sure x > y */
  {
	Fixed z = x;
	x = y;
	y = z;
  }

  return  (x - y <= ALMOSTZERO);
}
#else
  #define mth_Max45Trick(x,y)     (x == y || x == -y)
#endif


/*
 *  Sets bPhaseShift to true if X or Y are at 45 degrees, flaging the outline
 *  to be moved in the low bit just before scan-conversion.
 *  Sets [xy]Stretch factors to be applied before hinting.
 *  Returns true if the contours need to be reversed.
 */
boolean mth_IsMatrixStretched (transMatrix*trans)
{
  Fixed*matrix = &trans->transform[0][0];
  Fixed x, y;
  int32 i;
  boolean   bPhaseShift;

  bPhaseShift = FALSE;

  for (i = 0; i < 2; i++, matrix++)
  {
	x = *matrix++;
	y = *matrix++;
	bPhaseShift |= mth_Max45Trick (x, y);
  }
  return( bPhaseShift );
}


/*
 * Returns true if we have the identity matrix.
 */

boolean mth_PositiveSquare (transMatrix *matrix)
{
	return (matrix->transform[0][0] == matrix->transform[1][1] && matrix->transform[0][1] == 0 && matrix->transform[1][0] == 0 && matrix->transform[1][1] >= 0);
}

boolean mth_Identity (transMatrix *matrix)
{
	return (matrix->transform[0][0] == matrix->transform[1][1] && matrix->transform[0][1] == 0 && matrix->transform[1][0] == 0 && matrix->transform[0][0] == ONEFIX);
}


boolean mth_PositiveRectangle (transMatrix *matrix)
{
	 return (matrix->transform[0][1] == 0 && matrix->transform[1][0] == 0 && matrix->transform[0][0] >= 0 && matrix->transform[1][1] >= 0);
}

/*
 * unitary Square
 *
 *              | +-1    0  0  |
 *    matrix =  |   0  +-1  0  |
 *              |   0    0  1  |
 */

boolean mth_UnitarySquare (transMatrix *matrix)
{
	return (matrix->transform[0][1] == 0 && matrix->transform[1][0] == 0 && FXABS(matrix->transform[0][0]) == FXABS(matrix->transform[1][1]) && FXABS(matrix->transform[0][0]) == ONEFIX);
}

boolean mth_SameStretch (Fixed fxScaleX, Fixed fxScaleY)
{
	return(fxScaleX == fxScaleY);
}

boolean mth_GeneralRotation (transMatrix *matrix)
{
  return ((matrix->transform[0][0] || matrix->transform[1][1]) && (matrix->transform[1][0] || matrix->transform[0][1]));
}

/* for a rotation that is a multiple of 90 degrees, return the multiplier factor */
/* for non 90 degree rotations, return 4  (this is used for sbit rotations) */

uint16 mth_90degRotationFactor (transMatrix *matrix)
{
	if (matrix->transform[1][0] == 0 && matrix->transform[0][1] == 0)
    {
    	if (matrix->transform[0][0] > 0 && matrix->transform[1][1] > 0)
            return (0);
    	else if (matrix->transform[0][0] < 0 && matrix->transform[1][1] < 0)
            return (2);
    }
	else if (matrix->transform[0][0] == 0 && matrix->transform[1][1] == 0)
    {
        if (matrix->transform[1][0] < 0 && matrix->transform[0][1] > 0)
            return (1);
       	else if (matrix->transform[1][0] > 0 && matrix->transform[0][1] < 0)
            return (3);
	}
    return (4);                 /* non 90 degree rotation */
}

/* This is for Italic simulation.
/* return 0 if it's italic for 0 degree
/* return 1 if it's italic for 90 degree
/* return 2 if it's italic for 180 degree
/* return 3 if it's italic for 270 degree
/* return 4 if anything else */

uint16 mth_90degClosestRotationFactor (transMatrix *matrix)
{
    // 0 degree or vertical 270 degree
	if (matrix->transform[0][0] > 0 && matrix->transform[0][1] == 0 && matrix->transform[1][0] > 0 && matrix->transform[1][1] > 0 ||
        matrix->transform[0][0] > 0 && matrix->transform[0][1] < 0 && matrix->transform[1][0] == 0 && matrix->transform[1][1] > 0 ) 
        return (0); 
    // 90 degree or vertical 0 degree
	else if (matrix->transform[0][0] == 0 && matrix->transform[0][1] > 0 && matrix->transform[1][0] < 0 && matrix->transform[1][1] > 0 ||
             matrix->transform[0][0] > 0 && matrix->transform[0][1] > 0 && matrix->transform[1][0] < 0 && matrix->transform[1][1] == 0 ) 
        return (1); 
    // 180 degree or vertical 90 degree
	else if (matrix->transform[0][0] < 0 && matrix->transform[0][1] == 0 && matrix->transform[1][0] < 0 && matrix->transform[1][1] < 0 ||
             matrix->transform[0][0] < 0 && matrix->transform[0][1] > 0 && matrix->transform[1][0] == 0 && matrix->transform[1][1] < 0 ) 
        return (2); 
    // 270 degree or vertical 180 degree
	else if (matrix->transform[0][0] == 0 && matrix->transform[0][1] < 0 && matrix->transform[1][0] > 0 && matrix->transform[1][1] < 0 ||
             matrix->transform[0][0] < 0 && matrix->transform[0][1] < 0 && matrix->transform[1][0] > 0 && matrix->transform[1][1] ==  0 ) 
        return (3); 
    // anything else
    else
        return (4); 
}

void mth_Non90DegreeTransformation(transMatrix *matrix, boolean *non90degreeRotation, boolean *nonUniformStretching) {
	Fixed Xx,Xy,Yx,Yy;

	// first, we apply the matrix to the base vectors X = (1, 0) and Y = (0, 1)
	// this seemingly trivial step tends to be a hidden trap because there are two ways to apply a matrix to a vector, prefix and postfix.
	// in the rasterizer we seem to apply matrices as postfix operators, i.e.
	//
	//          (a00 a01)
	// (x, y) * (       ) = (a00*x + a10*y, a01*x + a11*y)
	//          (a10 a11)
	//
	//   apply to X = (1, 0)           apply to Y = (0, 1)
	Xx = matrix->transform[0][0]; Yx = matrix->transform[1][0];
	Xy = matrix->transform[0][1]; Yy = matrix->transform[1][1];

	// then we test whether the transformation shears the coordinates
	// if so, the transformed base vectors are no longer perpendicular, so we test their dot product against 0
	// notice that due to the limited precision of the fixed point representation , we may introduce a numerical error in general. 	
	// however, we're interested in identifying special cases like multiples of 90 rotations, for which one of the components
	// of the transformed vectors will be 0, hence the dot product should be accurate in these cases.
	if (FixMul(Xx,Yx) + FixMul(Xy,Yy) == 0) { // we're perpendicular

		// next we analyze whether the transformation rotates by a multiple of 90 or not
		// rotations which are multiples of 90 have 0s in either both non-diagonal matrix elements or both diagonal matrix elements
		// notice that this analysis includes mirrorings in x or y, which are handled in much the same way
		*non90degreeRotation = !(Xx == 0 && Yy == 0 || Xy == 0 && Yx == 0);

		// finally we analyze whether the transformation stretches the coordinates uniformly or not
		// for uniform stretchings the transformed base vectors have the same lengths
		// notice again that due to limited precision we may introduce a numerical error which we can ignore for the same reasons
		*nonUniformStretching = FixMul(Xx,Xx) + FixMul(Xy,Xy) != FixMul(Yx,Yx) + FixMul(Yy,Yy);
	
	} else { // we're sheared
		
		// here, we analyze whether the transformation rotates the x-axis by a multiple of 90 or not
		// we do not consider the y-axis because we don't want to exclude italicized fonts
		// for a multiple of 90 rotation, the transformed base vector X is either [anti-]parallel or perpendicular to its original
		// to be perpendicular, its x-component must be 0, hence a00 = 0; to be [anti-]parallel, its y-component must be 0, hence a01 = 0
		*non90degreeRotation = !(Xx == 0 || Xy == 0);

		// finally, we need to know whether the transformation stretches the coordinates at all
		// we know already that the stretching is not uniform, except in the unlikely case that the transformation rotates the y-axis
		// relative to the x-axis, which is a combination of stretching in y (actually, squeezing) by a particular amount, followed by
		// shearing, which stretches the y-axis again. For the correct combination of squeezing and shearing, this yields a uniform
		// stretching. For italicizing characters, this is an unlikely scenario, as italics tend to have the same [x-]height as their
		// roman ancestors. Italicizing is achieved by a shearing without separate stretching, which is a much more likely scenario.
		// For the reasons of their likelyhood, we consider shearing a uniform stretching, but not the rotation of the y-axis. Further-
		// more, for the purpose of identifying special cases, we do so only for rotations by multiples of 90, and only if the area
		// of the parallelogram defined by the two transformed base vectors remains 1, which is what happens under shearing. The area
		// of the parallelogram equals the determinant of the matrix. All other cases are considered proper non-uniform stretchings.
		
		*nonUniformStretching = *non90degreeRotation || FixMul(Xx,Xx) + FixMul(Xy,Xy) != ONEFIX || FixMul(Xx,Yy) - FixMul(Xy,Yx) != ONEFIX;
	}

} // mth_Non90DegreeTransformation

/*
 * mth_GetShift
 * return 2log of n if n is a power of 2 otherwise -1;
 */
int32 mth_GetShift( uint32 n )
{
		if (ISNOTPOWEROF2(n) || !n)
				return -1;
		else
				return mth_CountLowZeros( n );
}

int32 mth_CountLowZeros( uint32 n )
{
		  int32 shift = 0;
		  uint32    one = 1;
		for (shift = 0; !( n & one ); shift++)
				n >>= 1;
		return shift;
}

Fixed mth_max_abs (Fixed a, Fixed b)
{
  if (a < 0)
	a = -a;
  if (b < 0)
	b = -b;
  return (a > b ? a : b);
}

/*
 *  Call this guy before you use the matrix.  He does two things:
 *      He folds any perspective-translation back into perspective,
 *       and then changes the [2][2] element from a Fract to a fixed.
 */
void mth_ReduceMatrix(transMatrix *trans)
{
	Fixed a, *matrix = &trans->transform[0][0];
	Fract bottom = matrix[8];

/*
 *  First, fold translation into perspective, if any.
 */
	a = matrix[2];

	if (a != 0)
	{
		matrix[0] -= LongMulDiv(a, matrix[6], bottom);
		matrix[1] -= LongMulDiv(a, matrix[7], bottom);
	}

	a = matrix[5];

	if (a != 0)
	{
		matrix[3] -= LongMulDiv(a, matrix[6], bottom);
		matrix[4] -= LongMulDiv(a, matrix[7], bottom);
	}
	matrix[6] = matrix[7] = 0;
	matrix[8] = FRACT2FIX(bottom);      /* make this guy a fixed for XYMul routines */
}

void mth_IntelMul (
	int32           lNumPts,
	F26Dot6 *       fxX,
	F26Dot6 *       fxY,
	transMatrix *   trans,
	Fixed           fxXStretch,
	Fixed           fxYStretch)

{
	Fixed   fxM00;
	Fixed   fxM01;
	Fixed   fxM10;
	Fixed   fxM11;
	Fixed   fxOrigX;
	Fixed   fxOrigY;

	if (fxXStretch == 0L || fxYStretch == 0L)
	{
		for (--lNumPts; lNumPts >= 0; --lNumPts)
		{
			*fxY++ = 0;
			*fxX++ = 0;
		}
	}
	else
	{
		if(fxXStretch != ONEFIX)
		{
			fxM00 = FixDiv (trans->transform[0][0], fxXStretch);
			fxM01 = FixDiv (trans->transform[0][1], fxXStretch);
		}
		else
		{
			fxM00 = trans->transform[0][0];
			fxM01 = trans->transform[0][1];
		}

		if(fxYStretch != ONEFIX)
		{
			fxM10 = FixDiv (trans->transform[1][0], fxYStretch);
			fxM11 = FixDiv (trans->transform[1][1], fxYStretch);
		}
		else
		{
			fxM10 = trans->transform[1][0];
			fxM11 = trans->transform[1][1];
		}

		for (--lNumPts; lNumPts >= 0; --lNumPts)
		{
			fxOrigX = *fxX;
			fxOrigY = *fxY;

			*fxX++ = (F26Dot6) (FixMul (fxM00, fxOrigX) + FixMul (fxM10, fxOrigY));
			*fxY++ = (F26Dot6) (FixMul (fxM01, fxOrigX) + FixMul (fxM11, fxOrigY));
		}
	}
}


/*
 *  Fold the point size and resolution into the matrix
 */

void    mth_FoldPointSizeResolution(
	Fixed           fxPointSize,
	int16           sXResolution,
	int16           sYResolution,
	transMatrix *   trans)
{
	Fixed fxScale;

	fxScale = ShortMulDiv(fxPointSize, sYResolution, POINTSPERINCH);
	trans->transform[0][1] = FixMul( trans->transform[0][1], fxScale );
	trans->transform[1][1] = FixMul( trans->transform[1][1], fxScale );
	trans->transform[2][1] = FixMul( trans->transform[2][1], fxScale );

	fxScale = ShortMulDiv(fxPointSize, sXResolution, POINTSPERINCH);
	trans->transform[0][0] = FixMul( trans->transform[0][0], fxScale );
	trans->transform[1][0] = FixMul( trans->transform[1][0], fxScale );
	trans->transform[2][0] = FixMul( trans->transform[2][0], fxScale );
}


/*********************************************************************/

/*  Find the power of 2 greater than the absolute value of passed parameter  */

int32 PowerOf2(
		int32 lValue )
{
	static const int32 iTable[] = { 0, 1, 2, 2, 3, 3, 3, 3,
								  4, 4, 4, 4, 4, 4, 4, 4  };

	if (lValue < 0L)
	{
		lValue = -lValue;
	}

	if (lValue < (1L << 16))
	{
		if (lValue < (1L << 8))
		{
			if (lValue < (1L << 4))
			{
				return (iTable[lValue]);
			}
			else
			{
				return (iTable[lValue >> 4] + 4);
			}
		}
		else
		{
			if (lValue < (1L << 12))
			{
				return (iTable[lValue >> 8] + 8);
			}
			else
			{
				return (iTable[lValue >> 12] + 12);
			}
		}
	}
	else
	{
		if (lValue < (1L << 24))
		{
			if (lValue < (1L << 20))
			{
				return (iTable[lValue >> 16] + 16);
			}
			else
			{
				return (iTable[lValue >> 20] + 20);
			}
		}
		else
		{
			if (lValue < (1L << 28))
			{
				return (iTable[lValue >> 24] + 24);
			}
			else
			{
				return (iTable[lValue >> 28] + 28);
			}
		}
	}
}

/********************************************************************/

/* divide by shifting for translation invariant negatives */

FS_PUBLIC int16 mth_DivShiftShort(int16 sValue, int16 sFactor)
{
	return (int16)mth_DivShiftLong((int32)sValue, sFactor);
}

FS_PUBLIC int32 mth_DivShiftLong(int32 lValue, int16 sFactor)
{
	switch (sFactor)
	{
	case 0:
	case 1:
		break;
	case 2:
		lValue >>= 1;
		break;
	case 4:
		lValue >>= 2;
		break;
	case 8:
		lValue >>= 3;
		break;
	default:
		if (lValue >= 0)
		{
			lValue /= (int32)sFactor;
		}
		else
		{
			lValue = ((lValue - (int32)sFactor + 1) / (int32)sFactor);
		}
		break;
	}
	return lValue;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\bmfd\i386\convert.asm ===
page    ,132
        .386

ifndef  DOS_PLATFORM
        .model  small,c
else
ifdef   STD_CALL
        .model  small,c
else
        .model  small,pascal
endif;  STD_CALL
endif;  DOS_PLATFORM

        .xlist
        include stdcall.inc
        .list

        assume cs:FLAT,ds:FLAT,es:FLAT,ss:FLAT
        assume fs:nothing,gs:nothing

        .code


;******************************Public*Routine******************************
;    Here is the sequence for turning a long into a float in 32 bit assembler.
;
;  This conversion uses chop or round to zero rounding.
;
;These guys have come up with a pretty good sequence.  sadly, its 386 only,
;and making it work for double is somewhat more painful.  but still, its
;probably worth putting into altmath and the emulator.
;
;
;    1 bit for the sign.
;    8 bits for the exponent, which is the power of 2 of the highest bit
;      in the mantissa, and is also biased by 127.
;   23 bits for the mantissa, except the highest bit is never stored.
;
;; The following code assumes that the LONG (l) is in EAX and is to be
;; converted to a FLOAT (e) also in EAX.  ECX and EDX are trashed.
;
; History:
;  14-Feb-1991 -by- Bodin Dresevic [BodinD]
; Wrote it. Stolen form ChuckWh;
;
;**************************************************************************

cProc   ulLToE,4,<      \
        l:      dword   >

        mov     eax,l

ltoe:   cdq                 ; EDX = sign bit repeated.

; Use the old absolute value trick.

        xor     eax,edx
        sub     eax,edx     ; EAX = abs(l).

; Find the power of the highest bit.

        bsr     ecx,eax     ; ECX = index of highest bit.
        jz      @F          ; If EAX is zero, we're already done.
        mov     dl,cl       ; DL = power of highest bit.

; Shift EAX left to kill the high bit.

        ror     eax,cl          ; identical except for bit 0 which
                                ; is trashed later anyway.

; Put the exponent and sign on top of EAX.

        add     dl,127      ; Bias the exponent by 127.
        shrd    eax,edx,9   ; Move exponent and a sign bit into EAX.
@@:

; EAX is now a FLOAT.

        cRet    ulLToE
endProc ulLToE


end
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\kdexts\ttexts.cxx ===
/******************************Module*Header*******************************\
* Module Name: ttexts.cxx
*
* Created: 29-Aug-1994 08:42:10
* Author: Kirk Olynyk [kirko]
*
* Copyright (c) 1994 Microsoft Corporation
*
\**************************************************************************/


#include "precomp.hxx"

#define N2(a,b) dprintf("[%x] %s", &pRemote->##a, (b))
#define N3(a,b,c) N2(a,b); dprintf((c), pLocal->##a)

DWORD adw[1024];

DECLARE_API( help )
{
    char **ppsz;
    static char *apszHelp[] = {
        "",
        "fc     -- FONTCONTEXT",
        "ff     -- FONTFILE",
        "gout   -- fsGlyphInfo",
        "gin    -- fsGlyphInputType",
        "gmc    -- GMC",
        "poly   -- TTPOLYGONHEADER and curves",
        "ttc    -- TTC_FONTFILE"
        "\n",
        0
    };
    for( ppsz=apszHelp; *ppsz; ppsz++ )
        dprintf("\t%s\n", *ppsz);
}

DECLARE_API( gmc )
{
    GMC gmc;
    ULONG_PTR arg;
    int i;

    if ( *args == '\0' )
    {
        dprintf( "Enter address of GMC\n" );
        return;
    }

    sscanf( args, "%p", &arg );
    ReadMemory(arg, &gmc, sizeof(gmc), NULL);

    dprintf("\n\n");
    dprintf("[%p] dyTop    %d\n",  arg+offsetof(GMC,dyTop   ), gmc.dyTop   );
    dprintf("[%p] dyBottom %d\n",  arg+offsetof(GMC,dyBottom), gmc.dyBottom);
    dprintf("[%p] cxCor    %u\n",  arg+offsetof(GMC,cxCor   ), gmc.cxCor   );
    dprintf("[%p] cyCor    %u\n",  arg+offsetof(GMC,cyCor   ), gmc.cyCor   );

    dprintf("\n\n");
}

void dump28_4(LONG l)
{
    if (l < 0)
    {
        l = -l;
        dprintf("%3d.%1x-", l >> 4, l & 15);
    }
    else
        dprintf("%3d.%1x+", l >> 4, l & 15);
}

DECLARE_API( poly )
{
    ULONG_PTR arg;
    TTPOLYGONHEADER Header;
    char *pHeader, *pCurve, *pCopy, *pStart, *pStop;
    POINTFX *pfx, *pfxStop;
    INT_PTR dp;

    if ( *args == '\0')
    {
        dprintf("Enter an argument\n");
        return;
    }
    sscanf( args, "%p", &arg );
    pHeader = (char*) arg;
    ReadMemory( arg, &Header, sizeof(Header), 0);

    dprintf("\n"
            "\n"
            "[%8x] cb         %-#x\n"
            "[%8x] dwType     %-#x %s\n"
            , pHeader + offsetof(TTPOLYGONHEADER, cb ), Header.cb
            , pHeader + offsetof(TTPOLYGONHEADER, dwType), Header.dwType
            , Header.dwType == TT_POLYGON_TYPE ? "TT_POLYGON_TYPE" : "?");

    dprintf(
            "[%8x] pfxStart.x %-#10x "
            , pHeader + offsetof(TTPOLYGONHEADER, pfxStart.x), Header.pfxStart.x);
    dump28_4(*(LONG*)&Header.pfxStart.x);
    dprintf("\n");

    dprintf(
            "[%8x] pfxStart.y %-#10x "
            , pHeader + offsetof(TTPOLYGONHEADER, pfxStart.y), Header.pfxStart.y);
    dump28_4(*(LONG*)&Header.pfxStart.y);
    dprintf("\n");


    if (pCopy = (char*) LocalAlloc(LMEM_FIXED,Header.cb))
    {
        ReadMemory((ULONG_PTR)pHeader, pCopy, Header.cb, 0);
        dp = pHeader - pCopy;
        pStart = pCopy + sizeof(Header);
        pStop  = pCopy + Header.cb;
        for (pCurve = pStart; pCurve < pStop; pCurve = (char*) pfxStop)
        {
            char *pszType;
            WORD i;
            TTPOLYCURVE *p = (TTPOLYCURVE*) pCurve;

            pfx = &p->apfx[0];
            pfxStop = pfx + p->cpfx;

            switch (p->wType)
            {
            case TT_PRIM_LINE:      pszType = "TT_PRIM_LINE"; break;
            case TT_PRIM_QSPLINE:   pszType = "TT_PRIM_QSPLINE";break;
            default: pszType = "?";
            }

            dprintf(    "[%8x] wType %-#x %s\n"
                        "[%8x] cpfx  %-#x\n"
                    , (char*) (&p->wType) + dp, p->wType, pszType
                    , (char*) (&p->cpfx) + dp, p->cpfx);

            for ( i = 0; i < p->cpfx; i++,pfx++)
            {
                dprintf("[%8x] [%3u] %-#10x ", (char*)(&pfx->x) + dp, i, pfx->x);  dump28_4(*(LONG*)&pfx->x); dprintf("\n");
                dprintf("[%8x]       %-#10x ", (char*)(&pfx->y) + dp,    pfx->y);  dump28_4(*(LONG*)&pfx->y); dprintf("\n");
            }
        }
        LocalFree(pCopy);
    }
}

DECLARE_API( gout )
{
    fs_GlyphInfoType gi, *pGi;
    ULONG_PTR arg;
    int i;

    if ( *args == '\0' )
    {
        dprintf( "Enter address of argument\n" );
        return;
    }

    sscanf( args, "%p", &arg );
    ReadMemory(arg, &gi, sizeof(gi), NULL);
    pGi = (fs_GlyphInfoType*) arg;

    dprintf("\n\n");
        dprintf("[%x] memorySizes        \n", &pGi->memorySizes);
    for (i = 0; i < MEMORYFRAGMENTS; i++)
        dprintf("                        %u\n", gi.memorySizes[i]);
    dprintf("[%x] glyphIndex         %06x\n" , &pGi->glyphIndex , gi.glyphIndex        );
    dprintf("[%x] numberOfBytesTaken %06x\n" , &pGi->numberOfBytesTaken, gi.numberOfBytesTaken);

    dprintf("     metricInfo\n");
    dprintf("\t  advanceWidth\n");
    dprintf("[%x]       x                   %-#x\n",  &pGi->metricInfo.advanceWidth.x         , gi.metricInfo.advanceWidth.x        );
    dprintf("[%x]       y                   %-#x\n",  &pGi->metricInfo.advanceWidth.y         , gi.metricInfo.advanceWidth.y        );

    dprintf("\t  leftSideBearing\n");
    dprintf("[%x]       x                   %-#x\n",  &pGi->metricInfo.leftSideBearing.x      , gi.metricInfo.leftSideBearing.x     );
    dprintf("[%x]       y                   %-#x\n",  &pGi->metricInfo.leftSideBearing.y      , gi.metricInfo.leftSideBearing.y     );

    dprintf("\t  leftSideBearingLine\n");
    dprintf("[%x]       x                   %-#x\n",  &pGi->metricInfo.leftSideBearingLine.x  , gi.metricInfo.leftSideBearingLine.x );
    dprintf("[%x]       y                   %-#x\n",  &pGi->metricInfo.leftSideBearingLine.y  , gi.metricInfo.leftSideBearingLine.y );


    dprintf("\t  devLeftSideBearingLine\n");
    dprintf("[%x]       x                   %-#x\n",  &pGi->metricInfo.devLeftSideBearingLine.x , gi.metricInfo.devLeftSideBearingLine.x );
    dprintf("[%x]       y                   %-#x\n",  &pGi->metricInfo.devLeftSideBearingLine.y , gi.metricInfo.devLeftSideBearingLine.y );

    dprintf("\t  devAdvanceWidth\n");
    dprintf("[%x]       x                   %-#x\n",  &pGi->metricInfo.devAdvanceWidth.x      , gi.metricInfo.devAdvanceWidth.x          );
    dprintf("[%x]       y                   %-#x\n",  &pGi->metricInfo.devAdvanceWidth.y      , gi.metricInfo.devAdvanceWidth.y          );

    dprintf("\t  devLeftSideBearing\n");
    dprintf("[%x]       x                   %-#x\n",  &pGi->metricInfo.devLeftSideBearing.x  , gi.metricInfo.devLeftSideBearing.x        );
    dprintf("[%x]       y                   %-#x\n",  &pGi->metricInfo.devLeftSideBearing.y  , gi.metricInfo.devLeftSideBearing.y        );


    dprintf("     bitMapInfo\n");
    dprintf("[%x]    baseAddr %-#x\n"    , &pGi->bitMapInfo.baseAddr, gi.bitMapInfo.baseAddr            );
    dprintf("[%x]    rowBytes %d\n"      , &pGi->bitMapInfo.rowBytes, gi.bitMapInfo.rowBytes            );
    dprintf("[%x]    bounds\n"           , &pGi->bitMapInfo.bounds                                      );
    dprintf("[%x]      top    %d\n"      , &pGi->bitMapInfo.bounds.top   , gi.bitMapInfo.bounds.top     );
    dprintf("[%x]      left   %d\n"      , &pGi->bitMapInfo.bounds.left  , gi.bitMapInfo.bounds.left    );
    dprintf("[%x]      bottom %d\n"      , &pGi->bitMapInfo.bounds.bottom, gi.bitMapInfo.bounds.bottom  );
    dprintf("[%x]      right  %d\n"      , &pGi->bitMapInfo.bounds.right , gi.bitMapInfo.bounds.right   );

    dprintf("[%x] outlineCacheSize   %d\n"   , &pGi->outlineCacheSize   , gi.outlineCacheSize  );
    dprintf("[%x] outlinesExist      %u\n"   , &pGi->outlinesExist      , gi.outlinesExist     );
    dprintf("[%x] numberOfContours   %u\n"   , &pGi->numberOfContours   , gi.numberOfContours  );
    dprintf("[%x] xPtr               %-#x\n" , &pGi->xPtr               , gi.xPtr              );
    dprintf("[%x] yPtr               %-#x\n" , &pGi->yPtr               , gi.yPtr              );
    dprintf("[%x] startPtr           %-#x\n" , &pGi->startPtr           , gi.startPtr          );
    dprintf("[%x] endPtr             %-#x\n" , &pGi->endPtr             , gi.endPtr            );
    dprintf("[%x] onCurve;           %-#x\n" , &pGi->onCurve            , gi.onCurve           );
    dprintf("[%x] scaledCVT          %-#x\n" , &pGi->scaledCVT          , gi.scaledCVT         );
    dprintf("[%x] usBitmapFound      %u\n"   , &pGi->usBitmapFound      , gi.usBitmapFound     );
    dprintf("[%x] usGrayLevels       %u\n"   , &pGi->usGrayLevels       , gi.usGrayLevels       );
}

DECLARE_API( gin )
{
    fs_GlyphInputType gi, *pInput;
    ULONG_PTR arg;
    int i;

    if ( *args == '\0' )
    {
        dprintf( "Enter address of argument\n" );
        return;
    }

    sscanf( args, "%p", &arg );
    pInput = (fs_GlyphInputType*) arg;
    ReadMemory(arg, &gi, sizeof(gi), NULL);

    dprintf("\n\n");
    dprintf("[%x] version                  = %-#x\n"  , &pInput->version, gi.version);
    dprintf("[%x] memoryBases\n"                      , &pInput->memoryBases[0], gi.memoryBases[0]);

    for (i = 0; i < MEMORYFRAGMENTS; i++)
        dprintf("[%x]                           %-#x:%d\n", &pInput->memoryBases[i], gi.memoryBases[i],i);

    dprintf("[%x] sfntDirectroy            %-#x\n", &pInput->sfntDirectory                   , gi.sfntDirectory                  );
    dprintf("[%x] GetSfntFragmentPtr       %-#x\n", &pInput->GetSfntFragmentPtr              , gi.GetSfntFragmentPtr             );
    dprintf("[%x] ReleaseSfntFrag          %-#x\n", &pInput->ReleaseSfntFrag                 , gi.ReleaseSfntFrag                );
    dprintf("[%x] clientID                 %-#x\n", &pInput->clientID                        , gi.clientID                       );
    dprintf("[%x] newsfnt.PlatformID       %04x\n", &pInput->param.newsfnt.platformID        , gi.param.newsfnt.platformID       );
    dprintf("[%x]        .specificID       %04x\n", &pInput->param.newsfnt.specificID        , gi.param.newsfnt.specificID       );
    dprintf("[%x] newtrans.pointSize       %-#x\n", &pInput->param.newtrans.pointSize        , gi.param.newtrans.pointSize       );
    dprintf("[%x]         .xResolution     %d\n",   &pInput->param.newtrans.xResolution      , gi.param.newtrans.xResolution     );
    dprintf("[%x]         .yResolution     %d\n",   &pInput->param.newtrans.yResolution      , gi.param.newtrans.yResolution     );
    dprintf("[%x]         .pixelDiameter   %-#x\n", &pInput->param.newtrans.pixelDiameter    , gi.param.newtrans.pixelDiameter   );
    dprintf("[%x]         .transformMatrix %-#x\n", &pInput->param.newtrans.transformMatrix  , gi.param.newtrans.transformMatrix );
    dprintf("[%x]         .FntTraceFunc    %-#x\n", &pInput->param.newtrans.traceFunc        , gi.param.newtrans.traceFunc       );
    dprintf("[%x]         .usOverScale     %u\n"  , &pInput->param.newtrans.usOverScale      , gi.param.newtrans.usOverScale     );
    dprintf("[%x]         .usEmboldWeightx %u\n"  , &pInput->param.newtrans.usEmboldWeightx  , gi.param.newtrans.usEmboldWeightx );
    dprintf("[%x]         .usEmboldWeighty %u\n"  , &pInput->param.newtrans.usEmboldWeighty  , gi.param.newtrans.usEmboldWeighty );
    dprintf("[%x]         .lDescDev        %d\n"  , &pInput->param.newtrans.lDescDev         , gi.param.newtrans.lDescDev        );
    dprintf("[%x]         .bBitmapEmboldening %d\n", &pInput->param.newtrans.bBitmapEmboldening, gi.param.newtrans.bBitmapEmboldening);
    dprintf("[%x] newglyph.characterCode   %04x\n", &pInput->param.newglyph.characterCode    , gi.param.newglyph.characterCode   );
    dprintf("[%x]         .glyphIndex      %04x\n", &pInput->param.newglyph.glyphIndex       , gi.param.newglyph.glyphIndex      );
    dprintf("[%x]         .bMatchBBox      %d\n"  , &pInput->param.newglyph.bMatchBBox       , gi.param.newglyph.bMatchBBox      );
    dprintf("[%x]         .bNoEmbedded     %d\n"  , &pInput->param.newglyph.bNoEmbeddedBitmap, gi.param.newglyph.bNoEmbeddedBitmap);
    dprintf("[%x] gridfit.styleFunc        %-#x\n", &pInput->param.gridfit.styleFunc         , gi.param.gridfit.styleFunc        );
    dprintf("[%x]        .traceFunc        %-#x\n", &pInput->param.gridfit.traceFunc         , gi.param.gridfit.traceFunc        );
    dprintf("[%x]        .bSkipIfBitmap    %d\n"  , &pInput->param.gridfit.bSkipIfBitmap     , gi.param.gridfit.bSkipIfBitmap    );
    dprintf("[%x] outlineCache             %-#x\n", &pInput->param.outlineCache              , gi.param.outlineCache             );
    dprintf("[%x] band.usBandType          %u\n"  , &pInput->param.band.usBandType           , gi.param.band.usBandType          );
    dprintf("[%x]     .usBandWidth         %u\n"  , &pInput->param.band.usBandWidth          , gi.param.band.usBandWidth         );
    dprintf("[%x]     .outlineCache        %-#x\n", &pInput->param.band.outlineCache         , gi.param.band.outlineCache        );
    dprintf("[%x] scan.bottomClip          %d\n"  , &pInput->param.scan.bottomClip           , gi.param.scan.bottomClip          );
    dprintf("[%x]     .topClip             %d\n"  , &pInput->param.scan.topClip              , gi.param.scan.topClip             );
    dprintf("[%x]     .outlineCache        %-#x\n", &pInput->param.scan.outlineCache         , gi.param.scan.outlineCache        );
    dprintf("\n\n");
}

DECLARE_API( fc )
{
    ULONG_PTR arg;
    LONG l;
    FONTCONTEXT fc,*pfc;
    char ach[200];

    if ( *args == '\0' )
    {
        dprintf( "Enter address of GMC\n" );
        return;
    }

    sscanf( args, "%p", &arg );
    ReadMemory(arg, &fc, sizeof(fc), NULL);

    pfc = (FONTCONTEXT*) arg;

    dprintf("\n\n");
    dprintf("[%x] pfo               %-#10x \n" , &pfc->pfo              , fc.pfo                                      );
    dprintf("[%x] pff               %-#10x \n" , &pfc->pff              , fc.pff                                      );
    dprintf("[%x] gstat                    \n" , &pfc->gstat                                                          );
    dprintf("[%x] flFontType        %-#10x \n" , &pfc->flFontType       , fc.flFontType                               );
    dprintf("[%x] sizLogResPpi      %d %d  \n" , &pfc->sizLogResPpi     , fc.sizLogResPpi.cx, fc.sizLogResPpi.cy      );
    dprintf("[%x] ulStyleSize       %u     \n" , &pfc->ulStyleSize      , fc.ulStyleSize                              );
    dprintf("[%x] xfm                      \n" , &pfc->xfm                                                            );
    dprintf("[%x] mx                       \n" , &pfc->mx                                                             );
    dprintf("           %-#x %-#x %-#x\n"        , fc.mx.transform[0][0], fc.mx.transform[0][1], fc.mx.transform[0][2]);
    dprintf("           %-#x %-#x %-#x\n"        , fc.mx.transform[1][0], fc.mx.transform[1][1], fc.mx.transform[1][2]);
    dprintf("           %-#x %-#x %-#x\n"        , fc.mx.transform[2][0], fc.mx.transform[2][1], fc.mx.transform[2][2]);
    dprintf("[%x] flXform           %-#10x \n" , &pfc->flXform          , fc.flXform                                  );
    dprintf("[%x] lEmHtDev          %d     \n" , &pfc->lEmHtDev         , fc.lEmHtDev                                 );
    dprintf("[%x] fxPtSize          %-#10x \n" , &pfc->fxPtSize         , fc.fxPtSize                                 );
    dprintf("[%x] phdmx             %-#10x \n" , &pfc->phdmx            , fc.phdmx                                    );
    dprintf("[%x] lAscDev           %d     \n" , &pfc->lAscDev          , fc.lAscDev                                  );
    dprintf("[%x] lDescDev          %d     \n" , &pfc->lDescDev         , fc.lDescDev                                 );
    dprintf("[%x] xMin              %d     \n" , &pfc->xMin             , fc.xMin                                     );
    dprintf("[%x] xMax              %d     \n" , &pfc->xMax             , fc.xMax                                     );
    dprintf("[%x] yMin              %d     \n" , &pfc->yMin             , fc.yMin                                     );
    dprintf("[%x] yMax              %d     \n" , &pfc->yMax             , fc.yMax                                     );
    dprintf("[%x] cxMax             %u     \n" , &pfc->cxMax            , fc.cxMax                                    );
    dprintf("[%x] cjGlyphMax        %u     \n" , &pfc->cjGlyphMax       , fc.cjGlyphMax                               );
    dprintf("[%x] pgin              %-#10x \n" , &pfc->pgin             , fc.pgin                                     );
    dprintf("[%x] pgout             %-#10x \n" , &pfc->pgout            , fc.pgout                                    );
    dprintf("[%x] ptp               %-#10x \n" , &pfc->ptp              , fc.ptp                                      );
    dprintf("[%x] ptlSingularOrigin %d %d\n"   , &pfc->ptlSingularOrigin, fc.ptlSingularOrigin.x, fc.ptlSingularOrigin.y);

    dprintf("[%x] pteUnitBase       %-#x %-#x\n" , &pfc->pteUnitBase, fc.pteUnitBase.x, fc.pteUnitBase.y );

    dprintf("[%x] efBase (use !gdikdx.ef %x)\n" , &pfc->efBase , &pfc->efBase);
    dprintf("[%x] ptqUnitBase\n"                 , &pfc->ptqUnitBase);
    dprintf("[%x] vtflSide (use !gdikdx.ef)  \n", &pfc->vtflSide);
    dprintf("[%x] pteUnitSide\n"                 , &pfc->pteUnitSide);
    dprintf("[%x] efSide (use !gdikdx.ef %x)\n" , &pfc->efSide , &pfc->efSide);
    dprintf("[%x] ptqUnitSide\n"                 , &pfc->ptqUnitSide);
    dprintf("[%x] ptfxTop           %-#x %-#x\n" , &pfc->ptfxTop   , fc.ptfxTop.x, fc.ptfxTop.y);
    dprintf("[%x] ptfxBottom        %-#x %-#x\n" , &pfc->ptfxBottom, fc.ptfxBottom.x , fc.ptfxBottom.y);
    dprintf("[%x] ulControl         %-#x\n", &pfc->ulControl, fc.ulControl);
    dprintf("[%x] bVertical         %-#x\n", &pfc->bVertical, fc.bVertical);
    dprintf("[%x] hgSave            %-#x\n", &pfc->hgSave, fc.hgSave);
    dprintf("[%x] pointSize         %-#x\n", &pfc->pointSize, fc.pointSize);
    dprintf("[%x] mxv\n", &pfc->mxv);
    dprintf("[%x] mxn\n", &pfc->mxn);
    dprintf("[%x] fxdevShiftX       %-#x\n", &pfc->fxdevShiftX, fc.fxdevShiftX);
    dprintf("[%x] fxdevShiftY       %-#x\n", &pfc->fxdevShiftY, fc.fxdevShiftY);
    dprintf("[%x] dBase             %d     \n" , &pfc->dBase            , fc.dBase                                    );
    dprintf("[%x] overScale         %d     \n" , &pfc->overScale, fc.overScale);    

    dprintf("\n\n");
}

DECLARE_API( ff )
{
    ULONG_PTR arg;
    LONG l;
    FONTFILE ff, *pLocal, *pRemote;
    char **ppsz;
    TABLE_ENTRY *pte;

    static char *apszReq[] =
    {
        "IT_REQ_CMAP ", "IT_REQ_GLYPH", "IT_REQ_HEAD ", "IT_REQ_HHEAD",
        "IT_REQ_HMTX ", "IT_REQ_LOCA ", "IT_REQ_MAXP ", "IT_REQ_NAME ",
        0
    };
    static char *apszOpt[] =
    {
        "IT_OPT_OS2 ", "IT_OPT_HDMX", "IT_OPT_VDMX", "IT_OPT_KERN",
        "IT_OPT_LSTH", "IT_OPT_POST", "IT_OPT_GASP", 0
    };

    dprintf("\n\n");

    if ( *args == '\0' )
    {
        dprintf( "Enter address of GMC\n" );
        return;
    }

    sscanf( args, "%p", &arg );
    ReadMemory(arg, &ff, sizeof(ff), NULL);

    pLocal  = &ff;
    pRemote = (FONTFILE*) arg;

    dprintf("\n\n");
    N3(pttc,                  "pttc                  ", "%-#x\n");
    N3(hgSearchVerticalGlyph, "hgSearchVerticalGlyph ", "%-#x\n");
    N3(pifi_vertical,         "pifi_vertical         ", "%-#x\n");
    N3(pj034,                 "pj034                 ", "%-#x\n");
    N3(pfcLast,               "pfcLast               ", "%-#x\n");
    N3(pfcToBeFreed,          "pfcToBeFreed          ", "%-#x\n");
    N3(cRef,                  "cRef                  ", "%u\n"  );
    N3(iFile,                 "iFile                 ", "%-#x\n");
    N3(pvView,                "pvView                ", "%-#x\n");
    N3(cjView,                "cjView                ", "%u\n"  );
    N3(pkp,                   "pkp                   ", "%-#x\n");
    N3(pgset,                 "pgset                 ", "%-#x\n");
    N3(pgsetv,                "pgsetv                ", "%-#x\n");
    N3(cRefGSet,              "cRefGSet              ", "%u\n"  );
    N3(cRefGSetV,             "cRefGSetV             ", "%u\n"  );

    dprintf("[%p] tp     [dp]     [cj]\n", arg+offsetof(FONTFILE,ffca)+offsetof(FFCACHE,tp));
    for (ppsz = apszReq, pte = ff.ffca.tp.ateReq; *ppsz; ppsz++, pte++)
        dprintf(
            "[%p]       %-#x %-#x %s\n",
            arg+(ULONG_PTR)pte-(ULONG_PTR)ff.ffca.tp.ateReq,
            pte->dp,
            pte->cj,
            *ppsz
            );
    for (ppsz = apszOpt, pte = ff.ffca.tp.ateOpt; *ppsz; ppsz++, pte++)
        dprintf(
            "[%p]       %-#x %-#x %s\n",
            arg+(ULONG_PTR)pte-(ULONG_PTR)ff.ffca.tp.ateReq,
            pte->dp,
            pte->cj,
            *ppsz
            );

    N3(ffca.ulTableOffset,         "ffca.ulTableOffset         ", "%-#x\n");
    N3(ffca.ulVerticalTableOffset, "ffca.ulVerticalTableOffset ", "%-#x\n");
    N3(ffca.uLongVerticalMetrics,  "ffca.uLongVerticalMetrics  ", "%-#x\n");
    N3(ffca.ulNumFaces,            "ffca.ulNumFaces            ", "%-#x\n");
    N3(ffca.uiFontCodePage,        "ffca.uiFontCodePage        ", "%u\n"  );
    N3(ffca.cj3,                   "ffca.cj3                   ", "%u\n"  );
    N3(ffca.cj4,                   "ffca.cj4                   ", "%u\n"  );
    N3(ffca.fl,                    "ffca.fl                    ", "%-#x\n");
    N3(ffca.dpMappingTable,        "ffca.dpMappingTable        ", "%-#x\n");
    N3(ffca.ui16EmHt,              "ffca.ui16EmHt              ", "%u\n"  );
    N3(ffca.ui16PlatformID,        "ffca.ui16PlatformID        ", "%-#x\n");
    N3(ffca.ui16SpecificID,        "ffca.ui16SpecificID        ", "%-#x\n");
    N3(ffca.ui16LanguageID,        "ffca.ui16LanguageID        ", "%-#x\n");
    N3(ffca.iGlyphSet,             "ffca.iGlyphSet             ", "%u\n"  );
    N3(ffca.wcBiasFirst,           "ffca.wcBiasFirst           ", "%u\n"  );
    N3(ffca.usMinD,                "ffca.usMinD                ", "%u\n"  );
    N3(ffca.igMinD,                "ffca.igMinD                ", "%u\n"  );
    N3(ffca.sMinA,                 "ffca.sMinA                 ", "%d\n"  );
    N3(ffca.sMinC,                 "ffca.sMinC                 ", "%d\n"  );
    N2(ifi,                   "ifi\n");
    dprintf("\n\n");
}

DECLARE_API( ttc )
{
    ULONG_PTR arg;
    unsigned int size;
    TTC_FONTFILE ttc, *pLocal, *pRemote;
    TTC_HFF_ENTRY *pEntry, *pEntryLast, *pRemoteEntry;

    if ( *args == '\0' )
    {
        dprintf( "Enter address of TTC_FONTFILE\n" );
        return;
    }

    sscanf( args, "%p", &arg );
    ReadMemory(arg, &ttc, sizeof(ttc), NULL);

    size = (unsigned int)((char*)&ttc.ahffEntry[ttc.ulNumEntry] - (char*)&ttc);
    ReadMemory(arg, adw, size, 0);

    pLocal  = (TTC_FONTFILE*) adw;
    pRemote = (TTC_FONTFILE*) arg;

    dprintf("\n\n");
    dprintf("[%x] cRef               %-#x\n", &pRemote->cRef, pLocal->cRef);
    dprintf("[%x] fl                 %-#x\n", &pRemote->fl, pLocal->fl);
    dprintf("[%x] ulTrueTypeResource %-#x\n", &pRemote->ulTrueTypeResource, pLocal->ulTrueTypeResource);
    dprintf("[%x] ulNumEntry         %-#x\n", &pRemote->ulNumEntry, pLocal->ulNumEntry);
    dprintf("[%x] pvView             %-#x\n", &pRemote->pvView, pLocal->pvView);
    dprintf("[%x] cjView             %-#x\n", &pRemote->pvView, pLocal->cjView);

    pEntry = pLocal->ahffEntry;
    pEntryLast = pEntry + pLocal->ulNumEntry;
    pRemoteEntry = pRemote->ahffEntry;

    for (; pEntry < pEntryLast; pEntry++, pRemoteEntry++)
    {
        TTC_HFF_ENTRY *pL = pEntry, *pR = pRemoteEntry;

        dprintf("[%x] ulOffsetTable      %-#x\n", &pR->ulOffsetTable, pL->ulOffsetTable);
        dprintf("[%x] iFace              %-#x\n", &pR->iFace, pL->iFace);
        dprintf("[%x] hff                %-#x\n", &pR->hff, pL->iFace);
    }
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\fs\fnt.h ===
/*
	File:       fnt.h

	Contains:   xxx put contents here (or delete the whole line) xxx

	Written by: xxx put name of writer here (or delete the whole line) xxx

	Copyright:  (c) 1987-1990, 1992 by Apple Computer, Inc., all rights reserved.
				(c) 1989-1999. Microsoft Corporation, all rights reserved.

	Change History (most recent first):

				 7/10/99  BeatS		Add support for native SP fonts, vertical RGB
		  <>     4/30/97    CB      ClaudeBe, catching infinite loops/recursions
	      <>     2/21/97    CB      ClaudeBe, scaled component in composite glyphs
	      <>     2/05/96    CB      ClaudeBe, add bHintForGray in globalGS
	   <11+>     9/15/90    MR,rb   Change pvx and pvy to proj.[xy].  Same for freedom vector.
									Conditionalize vectors for Fracts or ShortFracts.
		<10>     7/26/90    MR      rearrange local graphic state, remove unused parBlockPtr
		 <9>     7/18/90    MR      change loop variable from long to short, and other Ansi-changes
		 <8>     7/13/90    MR      Prototypes for function pointers
		 <5>      6/4/90    MR      Remove MVT
		 <4>      5/3/90    RB      replaced dropoutcontrol with scancontrolin and scancontrol out
									in global graphics state
		 <3>     3/20/90    CL      fields for multiple preprograms fields for ppemDot6 and
									pointSizeDot6 changed SROUND to take D/2 as argument
		 <2>     2/27/90    CL      Added DSPVTL[] instruction.  Dropoutcontrol scanconverter and
									SCANCTRL[] instruction
	   <3.1>    11/14/89    CEL     Fixed two small bugs/feature in RTHG, and RUTG. Added SROUND &
									S45ROUND.
	   <3.0>     8/28/89    sjk     Cleanup and one transformation bugfix
	   <2.2>     8/14/89    sjk     1 point contours now OK
	   <2.1>      8/8/89    sjk     Improved encryption handling
	   <2.0>      8/2/89    sjk     Just fixed EASE comment
	   <1.7>      8/1/89    sjk     Added composites and encryption. Plus some enhancements.
	   <1.6>     6/13/89    SJK     Comment
	   <1.5>      6/2/89    CEL     16.16 scaling of metrics, minimum recommended ppem, point size 0
									bug, correct transformed integralized ppem behavior, pretty much
									so
	   <1.4>     5/26/89    CEL     EASE messed up on "c" comments
	  <,1.3>     5/26/89    CEL     Integrated the new Font Scaler 1.0 into Spline Fonts

	To Do:
*/
/*  rwb 4/24/90 Replaced dropoutControl with scanControlIn and scanControlOut in
		global graphics state. 
		<3+>     3/20/90    mrr     Added support for IDEFs.  Made funcDefs long aligned
									by storing int16 length instead of int32 end.
*/

#ifndef FNT_DEFINED
#define FNT_DEFINED

#define STUBCONTROL 0x10000
#define NODOCONTROL 0x20000

#define FNT_PIXELSIZE  ((F26Dot6)0x40)
#define FNT_PIXELSHIFT 6

// public phantom points (cf. scale.c for private phantom points), relative to number of points in glyph
#define LEFTSIDEBEARING		0
#define RIGHTSIDEBEARING	1

#define TOPSIDEBEARING		2
#define BOTTOMSIDEBEARING	3

#define VECTORTYPE	ShortFract

#define NON90DEGTRANS_ROTATED	0x01
#define NON90DEGTRANS_STRETCH	0x02

#ifdef FSCFG_SUBPIXEL
/* For the SubPixel hinting flag field, internal flags */
#define FNT_SP_SUB_PIXEL			0x0001      /* set when calling fs_NewTransformation() */
#define FNT_SP_COMPATIBLE_WIDTH		0x0002      /* set when calling fs_NewTransformation() */
#define FNT_SP_VERTICAL_DIRECTION	0x0004		// set when calling fs_NewTransformation()
#define FNT_SP_BGR_ORDER			0x0008		// set when calling fs_NewTransformation()

#define SPCF_iupxCalled				0x0001		// individual bits of GlobalGS.subPixelCompatibilityFlags
#define SPCF_iupyCalled				0x0002
#define SPCF_inDiagEndCtrl			0x0004
#define SPCF_inVacuformRound		0x0008
#define SPCF_inSkippableDeltaFn		0x0010
#define SPCF_detectedDandIStroke	0x0100
#define SPCF_detectedJellesSpacing	0x0200
#define SPCF_detectedVacuformRound	0x0400
#define SPCF_detectedTomsDiagonal	0x0800


#endif // FSCFG_SUBPIXEL

#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA

	#define BADREL	0x01
	#define DONE	0x02
	#define DOING	0x04

	// Data structure for information leap. This information leap is necessary because of the following reason:
	// Technically, what we're doing is to automatically add on-the-fly in-line deltas to the stream of instructions. Such deltas appear
	// after an incoming "link" (MIRP, MDRP), but before one or more outgoing "links". If one of these outgoing links controls a stroke,
	// then this stroke's phase may need to be adjusted (by a delta). However, we don't know whether any of the outgoing links controls a
	// stroke, nor which one, until we've interpreted them all, at which point it is too late to apply a delta, because the delta has to be
	// applied before any outgoing links (dependency). Conversely, the incoming link does not bear any information that would suggest that
	// it links to a stroke (don't know the future). To make matters worse, it is possible that in the stream of instructions the link that
	// controls a stroke comes at the very end of the TT code, even though there may have been many other, unrelated instructions inbetween.
	// Therefore, we have to interpert the entire TT code (upto the IUP instruction in the SP direction) before we know all we need to 
	// calculate and apply the phase control.
	
	typedef struct {
		int16 parent0,parent1; // -1 for none
		int16 child; // for black links (we can satisfy 1 phase shift only, hence no need for several children), else -1
		uint16 flags; // BADREL, DONE, DOING
		F26Dot6 phaseShift;
	} PhaseControlRelation; // 12 bytes (?)
	
#endif

typedef struct VECTOR {
	VECTORTYPE x;
	VECTORTYPE y;
} VECTOR;

typedef struct {
	F26Dot6 *x;         /* The Points the Interpreter modifies */
	F26Dot6 *y;         /* The Points the Interpreter modifies */
	F26Dot6 *ox;        /* Old Points */
	F26Dot6 *oy;        /* Old Points */
	F26Dot6 *oox;       /* Old Unscaled Points, really ints */
	F26Dot6 *ooy;       /* Old Unscaled Points, really ints */
	uint8   *onCurve;   /* indicates if a point is on or off the curve */
	int16   *sp;        /* Start points */
	int16   *ep;        /* End points */
	uint8   *f;         /* Internal flags, one byte for every point */
	int16   nc;         /* Number of contours */
	uint8   *fc;         /* contour flags, one byte for every contour */
#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	boolean phaseControlExecuted;
	PhaseControlRelation *pcr;
#endif
} fnt_ElementType;

/* flags for contour flags : */
#define OUTLINE_MISORIENTED 1

typedef struct {
	int32 start;        /* offset to first instruction */
	uint16 length;      /* number of bytes to execute <4> */
	uint16 pgmIndex;    /* index to appropriate preprogram for this func (0..1) */
} fnt_funcDef;

/* <4> pretty much the same as fnt_funcDef, with the addition of opCode */
typedef struct {
	int32 start;
	uint16 length;
	uint8  pgmIndex;
	uint8  opCode;
} fnt_instrDef;

typedef struct {
	uint8 *    Instruction;
	uint32     Length;
} fnt_pgmList;

struct fnt_LocalGraphicStateType;
typedef void (FS_CALLBACK_PROTO *FntTraceFunc)(struct fnt_LocalGraphicStateType*, uint8*);

#ifdef FSCFG_REENTRANT
typedef uint8* (*FntFunc)(struct fnt_LocalGraphicStateType*, uint8*, int32);
typedef void (*FntMoveFunc)(struct fnt_LocalGraphicStateType*, fnt_ElementType*, int32, F26Dot6);
typedef F26Dot6 (*FntProject)(struct fnt_LocalGraphicStateType*, F26Dot6, F26Dot6);
typedef void (*InterpreterFunc)(struct fnt_LocalGraphicStateType*, uint8*, uint8*);
typedef F26Dot6 (*FntRoundFunc)(struct fnt_LocalGraphicStateType*, F26Dot6, F26Dot6);
#else 
typedef uint8* (*FntFunc)(uint8*, int32);
typedef void (*FntMoveFunc)(fnt_ElementType*, int32, F26Dot6);
typedef F26Dot6 (*FntProject)(F26Dot6 x, F26Dot6 y);
typedef void (*InterpreterFunc)(uint8*, uint8*);
typedef F26Dot6 (*FntRoundFunc)(F26Dot6 xin, F26Dot6 engine);
#endif 

typedef struct {

/* PARAMETERS CHANGEABLE BY TT INSTRUCTIONS */
	F26Dot6 wTCI;                   /* width table cut in */
	F26Dot6 sWCI;                   /* single width cut in */
	F26Dot6 scaledSW;               /* scaled single width */
	int32 scanControl;              /* controls kind and when of dropout control */
	int32 instructControl;          /* controls gridfitting and default setting */
	
	F26Dot6 minimumDistance;        /* moved from local gs  7/1/90  */
	FntRoundFunc RoundValue;        /*                              */
#ifdef FSCFG_SUBPIXEL
	uint16		roundState;			// see comments in interp.c
#endif
	F26Dot6 periodMask;             /* ~(gs->period-1)              */
	VECTORTYPE period45;            /*                              */
	int16   period;                 /* for power of 2 periods       */
	int16   phase;                  /*                              */
	int16   threshold;              /* moved from local gs  7/1/90  */

	int16 deltaBase;
	int16 deltaShift;
	int16 angleWeight;
	int16 sW;                       /* single width, expressed in the same units as the character */
	int8 autoFlip;                  /* The auto flip Boolean */
	int8 pad;   
#ifndef FSCFG_NOPAD_PARAMETER_BLOCK_4
	int16 pad2;   
#endif 
} fnt_ParameterBlock;               /* this is exported to client */

#define PREPROGRAM     0
#define FONTPROGRAM    1
#define GLYPHPROGRAM   2

#define MAXPREPROGRAMS 2

#ifdef FSCFG_SUBPIXEL
	#define maxDeltaFunctions	4
#endif

typedef struct fnt_ScaleRecord {
	Fixed fixedScale;       /* Slow Scale */
	int32 denom;            /* Fast and Medium Scale */
	int32 numer;            /* Fast and Medium Scale */
	int32 shift;            /* Fast Scale */
} fnt_ScaleRecord;

typedef F26Dot6 (*GlobalGSScaleFunc)(fnt_ScaleRecord*, F26Dot6);

typedef struct fnt_GlobalGraphicStateType {
	F26Dot6* stackBase;             /* the stack area */
	F26Dot6* store;                 /* the storage area */
	F26Dot6* controlValueTable;     /* the control value table */
	
	uint16  pixelsPerEm;            /* number of pixels per em as an integer */
	uint16  pointSize;              /* the requested point size as an integer */
	Fixed   fpem;                   /* fractional pixels per em    <3> */
	F26Dot6 engine[4];              /* Engine Characteristics */
	
	fnt_ParameterBlock defaultParBlock; /* variables settable by TT instructions */
	fnt_ParameterBlock localParBlock;

	/* Only the above is exported to Client throught FontScaler.h */

/* VARIABLES NOT DIRECTLY MANIPULABLE BY TT INSTRUCTIONS  */
	
	fnt_funcDef*    funcDef;           /* function Definitions identifiers */
	fnt_instrDef*   instrDef;         /* instruction Definitions identifiers */
	GlobalGSScaleFunc ScaleFuncXChild; /* child scaling when !bSameTransformAsMaster */
	GlobalGSScaleFunc ScaleFuncYChild; /* child scaling when !bSameTransformAsMaster */
	GlobalGSScaleFunc ScaleFuncX;
	GlobalGSScaleFunc ScaleFuncY;
	GlobalGSScaleFunc ScaleFuncCVT;
	fnt_pgmList     pgmList[MAXPREPROGRAMS];  /* each program ptr is in here */
	
/* These are parameters used by the call back function */
	fnt_ScaleRecord   scaleXChild; /* child scaling when !bSameTransformAsMaster */
	fnt_ScaleRecord   scaleYChild; /* child scaling when !bSameTransformAsMaster */
	fnt_ScaleRecord   scaleX;
	fnt_ScaleRecord   scaleY;
	fnt_ScaleRecord   scaleCVT;

	Fixed           cvtStretchX;
	Fixed           cvtStretchY;

	int8            identityTransformation;  /* true/false  (does not mean identity from a global sense) */
	int8            non90DegreeTransformation; /* bit 0 is 1 if non-90 degree, bit 1 is 1 if x scale doesn't equal y scale */
	Fixed           xStretch;           /* Tweaking for glyphs under transformational stress <4> */
	Fixed           yStretch;           /* Tweaking for glyphs under transformational stress <4> */
	
	int8            init;               /* executing preprogram ?? */
	/* !!! Should not be uint8, instead fnt_ProgramIndex */
	uint8           pgmIndex;           /* which preprogram is current */
	int32           instrDefCount;      /* number of currently defined IDefs */
	uint8			bSameStretch;
	uint8			bCompositeGlyph;	/* Flag that indicates composite glyph */
	LocalMaxProfile *	 maxp;
	uint16          cvtCount;
	Fixed           interpScalarX;      /* scalar for instructable things */
	Fixed           interpScalarY;      /* scalar for instructable things */
	Fixed           fxMetricScalarX;    /* scalar for metric things */
	Fixed           fxMetricScalarY;    /* scalar for metric things */
	/* int16  pad2; */

	boolean	bHintForGray;
	uint8			bSameTransformAsMaster;	/* for composite glyph, indicate the the sub-componenent has the same scaling than the master glyph */
	uint8			bOriginalPointIsInvalid;/* original point are invalid, we need to use ox/oy instead of scaling oox/ooy */

	uint32		ulMaxJumpCounter;			/* jump counter used to catch infinite loops */
	uint32		ulMaxRecursiveCall;		/* recursive calls counter used to check the level of recursion */
    ClientIDType            clientID;  /* client private id/stamp, it's saved here to allow a trace function to access it */
#ifdef FSCFG_SECURE
	F26Dot6* stackMax;             /* maximum stack area */
	int32      maxPointsIncludePhantom;  /* in an individual glyph, including maxCompositePoints  */
#endif // FSCFG_SECURE
	uint16	uBoldSimulVertShift; /* vertical and horizontal (along baseline) shift for embolding simulation */
	uint16	uBoldSimulHorShift;
	F26Dot6	fxScaledDescender; /* scaled descender, used to clip emboldening if necessary */
#ifdef FSCFG_SUBPIXEL
	uint16	flHintForSubPixel;
	uint16	subPixelCompatibilityFlags;
	uint16	numDeltaFunctionsDetected;		  // fns to implement delta instr for range of ppem sizes or odd delta size use SHPIX,
	uint16	deltaFunction[maxDeltaFunctions]; // keep track of these cases to intelligently skip SHPIX
	Fixed	compatibleWidthStemConcertina;
#endif // FSCFG_SUBPIXEL
	boolean bHintAtEmSquare;        /* hint at the design resolution, this flag is used for sub-pixel position
									   or text animation where we want to turn off gridfitting hinting
									   but for fonts where glyphs are build by hinting, we still want the
									   glyph shape to be correct */
} fnt_GlobalGraphicStateType;

/* 
 * This is the local graphics state  
 */
typedef struct fnt_LocalGraphicStateType {
	fnt_ElementType *CE0, *CE1, *CE2;   /* The character element pointers */
	VECTOR proj;                        /* Projection Vector */
	VECTOR free;                        /* Freedom Vector */
	VECTOR oldProj;                     /* Old Projection Vector */
	F26Dot6 *stackPointer;

	uint8 *insPtr;                      /* Pointer to the instruction we are about to execute */
	fnt_ElementType *elements;
	fnt_GlobalGraphicStateType *globalGS;
		FntTraceFunc TraceFunc;

	int32 Pt0, Pt1, Pt2;           /* The internal reference points */
	int16 roundToGrid;
	int32 loop;                         /* The loop variable */
	uint8 opCode;                       /* The instruction we are executing */
	uint8 padByte;
	int16 padWord;

	/* Above is exported to client in FontScaler.h */

	VECTORTYPE pfProj; /* = pvx * fvx + pvy * fvy */

	FntMoveFunc MovePoint;
	FntProject Project;
	FntProject OldProject;
	InterpreterFunc Interpreter;
#ifdef FSCFG_REENTRANT
		F26Dot6 (*GetCVTEntry) (struct fnt_LocalGraphicStateType*,int32);
		F26Dot6 (*GetSingleWidth) (struct fnt_LocalGraphicStateType*);
#else 
		F26Dot6 (*GetCVTEntry) (int32 n);
		F26Dot6 (*GetSingleWidth) (void);
#endif 
	FntMoveFunc ChangeCvt;
	Fixed       cvtDiagonalStretch;

	int16       MIRPCode;               /* for fast or slow MIRP's */

	ErrorCode   ercReturn;              /* NO_ERR unless illegal instruction */
	uint8       *pbyEndInst;            /* one past last instruction */
	uint8       *pbyStartInst;          /* used to detect a jump before the begining of the program */

	uint32		ulJumpCounter;			/* jump counter used to catch infinite loops */
	uint32		ulRecursiveCall;		/* recursive calls counter used to check the level of recursion */
#ifdef FSCFG_SUBPIXEL
	uint16		inSubPixelDirection;
#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	int16		pt0,pt1;
#endif
#endif
} fnt_LocalGraphicStateType;

#endif  /* FNT_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\fs\fscaler.c ===
/*
	File:       FontScaler.c

	Contains:   xxx put contents here (or delete the whole line) xxx

	Written by: xxx put name of writer here (or delete the whole line) xxx

   Copyright:  (c) 1987-1990, 1992 by Apple Computer, Inc., all rights reserved.
			   (c) 1989-1999. Microsoft Corporation, all rights reserved.

	Change History (most recent first):

				 7/10/99  BeatS		Add support for native SP fonts, vertical RGB
		         4/01/99  BeatS		Implement alternative interpretation of TT instructions for SP
		<>      10/14/97    CB      move usOverScale to fs_NewTransformation
		<>       2/21/97    CB      no need to call pre-program if no hints (was causing div by zero)
		<>       1/10/97    CB      empty bitmap with bMatchBbox == TRUE causes crash
		<>      12/14/95    CB      add	usNonScaledAH to the private key
		<11>    11/27/90    MR      Need two scalars: one for (possibly rounded) outlines and cvt,
									and one (always fractional) metrics. [rb]
		<10>    11/21/90    RB      Allow client to disable DropOutControl by returning a NIL
									pointer to memoryarea[7]. Also make it clear that we inhibit
									DOControl whenever we band. [This is a reversion to 8, so mr's
									initials are added by proxy]
		 <9>    11/13/90    MR      (dnf) Revert back to revision 7 to fix a memmory-trashing bug
									(we hope). Also fix signed/unsigned comparison bug in outline
									caching.
		 <8>    11/13/90    RB      Fix banding so that we can band down to one row, using only
									enough bitmap memory and auxillary memory for one row.[mr]
		 <7>     11/9/90    MR      Add Default return to fs_dropoutval. Continue to fiddle with
									banding. [rb]
		 <6>     11/5/90    MR      Remove FixMath.h from include list. Clean up Stamp macros. [rb]
		 <5>    10/31/90    MR      Conditionalize call to ComputeMapping (to avoid linking
									MapString) [ha]
		 <4>    10/31/90    MR      Add bit-field option for integer or fractional scaling [rb]
		 <3>    10/30/90    RB      [MR] Inhibit DropOutControl when Banding
		 <2>    10/20/90    MR      Restore changes since project died. Converting to smart math
									routines, integer ppem scaling. [rb]
		<16>     7/26/90    MR      don't include ToolUtils.h
		<15>     7/18/90    MR      Fix return bug in GetAdvanceWidth, internal errors are now ints.
		<14>     7/14/90    MR      remove unused fields from FSInfo
		<13>     7/13/90    MR      Ansi-C fixes, rev. for union in FSInput
		<11>     6/29/90    RB      Thus endeth the too long life of encryption
		<10>     6/21/90    MR      Add calls to ReleaseSfntFrag
		 <9>     6/21/90    RB      add scanKind info to fs_dropoutVal
		 <8>      6/5/90    MR      remove fs_MapCharCodes
		 <7>      6/1/90    MR      
		 <6>      6/1/90    RB      fixed bandingbug under dropout control
		 <4>      5/3/90    RB      added dropoutval function.  simplified restore outlines.
									support for new scanconverter in contourscan, findbitmapsize,
									saveoutlines, restoreoutlines.
		 <3>     3/20/90    CL      Changed to use fpem (16.16) instead of pixelsPerEm (int) Removed
									call to AdjustTransformation (not needed with fpem) Added call
									to RunXFormPgm Removed WECANNOTDOTHIS #ifdef Added
									fs_MapCharCodes
		 <2>     2/27/90    CL      New error code for missing but needed table. (0x1409).  New
									CharToIndexMap Table format.
									Fixed transformed component bug.
	   <3.6>    11/15/89    CEL     Put an else for the ifdef WeCanNotDoThis so Printer compile
									could use more effecient code.
	   <3.5>    11/14/89    CEL     Left Side Bearing should work right for any transformation. The
									phantom points are in, even for components in a composite glyph.
									They should also work for transformations. Device metric are
									passed out in the output data structure. This should also work
									with transformations. Another leftsidebearing along the advance
									width vector is also passed out. whatever the metrics are for
									the component at it's level. Instructions are legal in
									components. Instructions are legal in components. The
									transformation is internally automatically normalized. This
									should also solve the overflow problem we had. Now it is legal
									to pass in zero as the address of memory when a piece of the
									sfnt is requested by the scaler. If this happens the scaler will
									simply exit with an error code ! Five unnecessary element in the
									output data structure have been deleted. (All the information is
									passed out in the bitmap data structure) fs_FindBMSize now also
									returns the bounding box.
	   <3.4>     9/28/89    CEL     fs_newglyph did not initialize the output error. Caused routine
									to return error from previous routines.
	   <3.3>     9/27/89    CEL     Took out devAdvanceWidth & devLeftSideBearing.
	   <3.2>     9/25/89    CEL     Changed the NEED_PROTOTYPE ifdef to use the NOT_ON_THE_MAC flag
									that existed previously.
	   <3.1>     9/15/89    CEL     Changed dispatch scheme. Calling conventions through a trap
									needed to match Macintosh pascal. Pascal can not call C unless
									there is extra mucky glue. Bug that caused text not to appear.
									The font scaler state was set up correctly but the sfnt was
									purged. It was reloaded and the clientid changed but was still
									the same font. Under the rules of the FontScaler fs_newsfnt
									should not have to be called again to reset the state. The extra
									checks sent back a BAD_CLIENTID_ERROR so QuickDraw would think
									it was a bad font and not continue to draw.
	   <3.0>     8/28/89    sjk     Cleanup and one transformation bugfix
	   <2.4>     8/17/89    sjk     Coded around MPW C3.0 bug
	   <2.3>     8/14/89    sjk     1 point contours now OK
	   <2.2>      8/8/89    sjk     Improved encryption handling
	   <2.1>      8/2/89    sjk     Fixed outline caching bug
	   <2.0>      8/2/89    sjk     Just fixed EASE comment
	   <1.5>      8/1/89    sjk     Added composites and encryption. Plus some enhancements.
	   <1.4>     6/13/89    SJK     Comment
	   <1.3>      6/2/89    CEL     16.16 scaling of metrics, minimum recommended ppem, point size 0
									bug, correct transformed integralized ppem behavior, pretty much
									so
	   <1.2>     5/26/89    CEL     EASE messed up on "c" comments
	  <y1.1>     5/26/89    CEL     Integrated the new Font Scaler 1.0 into Spline Fonts
	   <1.0>     5/25/89    CEL     Integrated 1.0 Font scaler into Bass code for the first time.

	To Do:
*/
/*      <3+>     3/20/90    mrr     Conditionalized error checking in fs_SetUpKey.
									Compiler option for stamping memmory areas for debugging
									Removed error field from FSInfo structure.
									Added call to RunFontProgram
									Added private function prototypes.
									Optimizations from diet clinic

*/

/** FontScaler's Includes **/

#define FSCFG_INTERNAL

#include "fserror.h"
#include "fscdefs.h"
#include "fontmath.h"        /* For numeric conversion macros    */
#include "fnt.h"
#include "scentry.h"
#include "sfntaccs.h"
#include "fsglue.h"
#include "sbit.h"
#include "fscaler.h"         // moved this to be the last include file (key moved in dot h)


#include "stat.h"                   /* STAT timing card prototypes */
boolean gbTimer = FALSE;            /* set true when timer running */

#ifndef FSCFG_MOVE_KEY_IN_DOT_H
/* the definition of the key in fscaler.h and fscaler.c must be identical */

/** Private Structures  **/

/*** The Internal Key ***/
typedef struct fs_SplineKey {
	sfac_ClientRec      ClientInfo;         /* Client Information */
	char* const *       memoryBases;        /* array of memory Areas */
	char *              apbPrevMemoryBases[MEMORYFRAGMENTS];

	uint16              usScanType;         /* flags for dropout control etc.*/

	fsg_TransformRec    TransformInfo;

	uint16              usNonScaledAW;
	uint16              usNonScaledAH;

	LocalMaxProfile     maxProfile;         /* copy of profile */

	uint32              ulState;            /* for error checking purposes */
	
	boolean             bExecutePrePgm;
	boolean             bExecuteFontPgm;    /* <4> */

	fsg_WorkSpaceAddr   pWorkSpaceAddr;     /* Hard addresses in Work Space */
	fsg_WorkSpaceOffsets WorkSpaceOffsets;  /* Address offsets in Work Space     */
	fsg_PrivateSpaceOffsets PrivateSpaceOffsets; /* Address offsets in Private Space */

	uint16              usBandType;         /* old, small or fast */
	uint16              usBandWidth;        /* from FindBandingSize */

	GlyphBitMap         GBMap;              /* newscan bitmap type */
	WorkScan            WScan;              /* newscan workspace type */

	GlyphBitMap         OverGBMap;          /* for gray scale */
	uint16              usOverScale;        /* 0 => mono; mag factor => gray */
	boolean             bGrayScale;			/* FALSE if mono (usOverScale == 0)	*/
	boolean             bMatchBBox;         /* force bounding box match */
	boolean             bEmbeddedBitmap;    /* embedded bitmap found */			

	metricsType         metricInfo;         /* Glyph metrics info */
	verticalMetricsType     verticalMetricInfo;

	int32               lExtraWorkSpace;    /* Amount of extra space in workspace */

	boolean             bOutlineIsCached;   /* Outline is cached */
	boolean             bGlyphHasOutline;   /* Outline is empty */
	boolean             bGridFitSkipped;    /* sbit anticipated, no outline loaded */

	uint32              ulGlyphOutlineSize; /* Size of outline cache */
	
	sbit_State          SbitMono;           /* for monochrome bitmaps */
	boolean             bHintingEnabled;    /* hinting is enabled, set to FALSE when 
                                               fs_NewTransformNoGridFit is called */
	boolean             bBitmapEmboldening; /* bitmap emboldening simulation */
	int16               sBoldSimulHorShift; /* shift for emboldening simulation, horizonatlly */
	int16               sBoldSimulVertShift; /* shift for emboldening simulation, vertically */
#ifdef FSCFG_SUBPIXEL
	uint16				flSubPixel;
	fsg_TransformRec    TransformInfoSubPixel;
#endif // FSCFG_SUBPIXEL
} fs_SplineKey;

#endif // FSCFG_MOVE_KEY_IN_DOT_H

/*  CONSTANTS   */

/* Change this if the format for cached outlines change. */
/* Someone might be caching old stuff for years on a disk */

#define OUTLINESTAMP 0x2D0CBBAD
#define OUTLINESTAMP2 0xA5

#define BITMAP_MEMORY_COUNT 4       /* now for gray scale we need 4 */

/* for the key->ulState field */
#define INITIALIZED 0x0000L
#define NEWSFNT     0x0002L
#define NEWTRANS    0x0004L
#define GOTINDEX    0x0008L
#define GOTGLYPH    0x0010L
#define SIZEKNOWN   0x0020L

#define STAMPEXTRA      4

/* 'sfnt' in ASCII  */
#define STAMP           0x73666E74

/*** Memory shared between all fonts and sizes and transformations ***/
#define KEY_PTR_BASE                0 /* Constant Size ! */
#define VOID_FUNC_PTR_BASE          1 /* Constant Size ! */
#define SCAN_PTR_BASE               2 /* Constant Size ! */
#define WORK_SPACE_BASE             3 /* size is sfnt dependent, can't be shared between grid-fitting and scan-conversion */
/*** Memory that can not be shared between fonts and different sizes, can not dissappear after InitPreProgram () ***/
#define PRIVATE_FONT_SPACE_BASE     4 /* size is sfnt dependent */
/* Only needs to exist when ContourScan is called, and it can be shared */
#define BITMAP_PTR_1                5 /* the bitmap - size is glyph size dependent */
#define BITMAP_PTR_2                6 /* size is proportional to number of rows */
#define BITMAP_PTR_3                7 /* used for dropout control - glyph size dependent */
#define BITMAP_PTR_4                8 /* used in gray scale for overscaled bitmap */

static  const   transMatrix   IdentTransform =
	{{{ONEFIX,      0,      0},
	  {     0, ONEFIX,      0},
	  {     0,      0, ONEFIX}}};


/* PRIVATE DEFINITIONS    */

FS_PRIVATE fs_SplineKey *  fs_SetUpKey (fs_GlyphInputType* inptr, uint32 ulStateBits, ErrorCode * error);
FS_PRIVATE void            fs_InitializeKey(fs_SplineKey * key);
FS_PRIVATE int32           fs__Contour (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr, boolean useHints);
FS_PRIVATE int32           fs__NewTransformation (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr, boolean useHints);
FS_PRIVATE void            fs_SetState(fs_SplineKey * key, uint32 ulState);
FS_PRIVATE void            FS_CALLBACK_PROTO dummyReleaseSfntFrag (voidPtr p);
FS_PRIVATE void            CHECKSTAMP (char * p);
FS_PRIVATE void            SETSTAMP (char * p);

FS_PRIVATE FS_ENTRY LookForSbitAdvanceWidth(fs_SplineKey *key, uint16 usGlyphIndex, boolean *pbBitmapFound, point *pf26DevAdvanceWidth );
FS_PRIVATE FS_ENTRY LookForSbitAdvanceHeight(fs_SplineKey *key, uint16 usGlyphIndex, boolean *pbBitmapFound,
    point *pf26DevAdvanceHeight);

/* FUNCTIONS    */

FS_PRIVATE void SETSTAMP (char * p)
{
	* ((uint32 *) ((p) - STAMPEXTRA)) = STAMP;
}


FS_PRIVATE void CHECKSTAMP (char * p)
{
	if (* ((uint32 *) ((p) - STAMPEXTRA)) != STAMP)
	{
#ifdef  NOT_ON_THE_MAC
		Assert(FALSE);
#else
		DEBUGGER ();
#endif
	}
}


FS_PRIVATE void FS_CALLBACK_PROTO dummyReleaseSfntFrag (voidPtr p)
{
	FS_UNUSED_PARAMETER(p);
}

FS_PRIVATE void   fs_SetState(fs_SplineKey * key, uint32 ulState)
{
	key->ulState = ulState;
}

/*
 *  Set up the key in case memmory has moved or been purged.
 */
FS_PRIVATE fs_SplineKey * fs_SetUpKey (
	fs_GlyphInputType * inptr,
	uint32              ulStateBits,
	ErrorCode *         error)
{
	fs_SplineKey *  key;

	key = (fs_SplineKey *)inptr->memoryBases[KEY_PTR_BASE];
	if (key == NULL)
	{
		*error = NULL_KEY_ERR;
		return 0;
	}

	key->memoryBases =                           inptr->memoryBases;
	if(key->memoryBases == NULL)
	{
		*error = NULL_MEMORY_BASES_ERR;
		return 0;
	}
	key->ClientInfo.GetSfntFragmentPtr =    inptr->GetSfntFragmentPtr;
	if(key->ClientInfo.GetSfntFragmentPtr == NULL)
	{
		*error = NULL_SFNT_FRAG_PTR_ERR;
		return 0;
	}

	key->ClientInfo.ReleaseSfntFrag = inptr->ReleaseSfntFrag;
	if (!(key->ClientInfo.ReleaseSfntFrag))
	{
		key->ClientInfo.ReleaseSfntFrag = dummyReleaseSfntFrag;
	}

	if ((key->ulState & ulStateBits) != ulStateBits)
	{
		*error = OUT_OFF_SEQUENCE_CALL_ERR;
		return 0;
	}

	key->ClientInfo.lClientID = inptr->clientID;
	*error = NO_ERR;

	return key;
}

FS_PRIVATE void fs_InitializeKey(fs_SplineKey * key)
{
	MEMSET(key, 0, sizeof(fs_SplineKey));
	key->TransformInfo.currentTMatrix = IdentTransform;
#ifdef FSCFG_SUBPIXEL
	key->TransformInfoSubPixel.currentTMatrix = IdentTransform;
#endif // FSCFG_SUBPIXEL
}

/*** FONT SCALER INTERFACE ***/

/*
 *
 */

FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_OpenFonts (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
{
	Assert(FS_SBIT_BITDEPTH_MASK == SBIT_BITDEPTH_MASK);
	/* sanity check that the embedded bitmap mask is the same in fscaler.h than in sfntaccs.h */

	if ( outputPtr )
	{
		outputPtr->memorySizes[KEY_PTR_BASE]        = (int32)sizeof (fs_SplineKey) + STAMPEXTRA;
		outputPtr->memorySizes[VOID_FUNC_PTR_BASE]  = 0;
		outputPtr->memorySizes[SCAN_PTR_BASE]       = 0;
		outputPtr->memorySizes[WORK_SPACE_BASE]      = 0; /* we need the sfnt for this */
		outputPtr->memorySizes[PRIVATE_FONT_SPACE_BASE] = 0; /* we need the sfnt for this */
		outputPtr->memorySizes[BITMAP_PTR_1]         = 0; /* we need the grid fitted outline for this */
		outputPtr->memorySizes[BITMAP_PTR_2]         = 0; /* we need the grid fitted outline for this */
		outputPtr->memorySizes[BITMAP_PTR_3]         = 0; /* we need the grid fitted outline for this */
		outputPtr->memorySizes[BITMAP_PTR_4]         = 0; /* gray scale memory */
	}
	else
	{
		return NULL_OUTPUT_PTR_ERR;
	}
	if ( inputPtr )
	{
		inputPtr->memoryBases[KEY_PTR_BASE]             = NULL;
		inputPtr->memoryBases[VOID_FUNC_PTR_BASE]       = NULL;
		inputPtr->memoryBases[SCAN_PTR_BASE]            = NULL;
		inputPtr->memoryBases[WORK_SPACE_BASE]          = NULL;
		inputPtr->memoryBases[PRIVATE_FONT_SPACE_BASE]  = NULL;
		inputPtr->memoryBases[BITMAP_PTR_1]             = NULL;
		inputPtr->memoryBases[BITMAP_PTR_2]             = NULL;
		inputPtr->memoryBases[BITMAP_PTR_3]             = NULL;
		inputPtr->memoryBases[BITMAP_PTR_4]             = NULL;
	}
	else
	{
		return NULL_INPUT_PTR_ERR;
	}
	return NO_ERR;
}

FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_Initialize (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
{
	fs_SplineKey *  key;

	FS_UNUSED_PARAMETER(outputPtr);

	key = (fs_SplineKey *)inputPtr->memoryBases[KEY_PTR_BASE];
	SETSTAMP (inputPtr->memoryBases[KEY_PTR_BASE] + outputPtr->memorySizes[KEY_PTR_BASE]);

	fs_InitializeKey(key);

	key->memoryBases = inputPtr->memoryBases;

	fs_SetState(key, INITIALIZED);

	fsc_Initialize();                            /* initialize scan converter */

	CHECKSTAMP (inputPtr->memoryBases[KEY_PTR_BASE] + outputPtr->memorySizes[KEY_PTR_BASE]);

	return NO_ERR;
}


/*
 *  This guy asks for memmory for points, instructions, fdefs and idefs
 */
FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_NewSfnt (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
{
	ErrorCode       error;
	fs_SplineKey *  key;

	CHECKSTAMP (inputPtr->memoryBases[KEY_PTR_BASE] + outputPtr->memorySizes[KEY_PTR_BASE]);

	STAT_ON_NEWSFNT;                 /* start STAT timer */

	key = fs_SetUpKey(inputPtr, INITIALIZED, &error);

	if(!key)
	{
		return (FS_ENTRY)error;
	}

	error = sfac_DoOffsetTableMap (&key->ClientInfo);  /* Map offset and length table */

	if(error != NO_ERR)
	{
		return (FS_ENTRY)error;
	}

	error = sfac_LoadCriticalSfntMetrics(
		&key->ClientInfo,
		&key->TransformInfo.usEmResolution,
		&key->TransformInfo.bIntegerScaling,
		&key->maxProfile);

	if(error != NO_ERR)
	{
		return (FS_ENTRY)error;
	}

	outputPtr->memorySizes[PRIVATE_FONT_SPACE_BASE] = (int32)fsg_PrivateFontSpaceSize (&key->ClientInfo, &key->maxProfile, &key->PrivateSpaceOffsets) + STAMPEXTRA;
	outputPtr->memorySizes[WORK_SPACE_BASE]         = (int32)fsg_WorkSpaceSetOffsets (&key->maxProfile, &key->WorkSpaceOffsets, &key->lExtraWorkSpace) + STAMPEXTRA;


	error = sfac_ComputeMapping (
		&key->ClientInfo,
		inputPtr->param.newsfnt.platformID,
		inputPtr->param.newsfnt.specificID);

	if(error != NO_ERR)
	{
		return (FS_ENTRY)error;
	}

	fs_SetState(key, (INITIALIZED | NEWSFNT));

	/*
	 *  Can't run font program yet, we don't have any memory for the
	 *  graphic state. Mark it to be run in NewTransformation.
	 */

	key->bExecuteFontPgm = TRUE;

	CHECKSTAMP (inputPtr->memoryBases[KEY_PTR_BASE] + outputPtr->memorySizes[KEY_PTR_BASE]);

	STAT_OFF_NEWSFNT;                /* stop STAT timer */

	return NO_ERR;
}

FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_NewTransformNoGridFit (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
{
	return fs__NewTransformation (inputPtr, outputPtr, FALSE);
}


FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_NewTransformation (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
{
	return fs__NewTransformation (inputPtr, outputPtr, TRUE);
}


FS_PRIVATE int32 fs__NewTransformation (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr, boolean useHints)
{
	void *          pvGlobalGS;
	void *          pvStack;
	void *          pvTwilightZone;
	void *          pvFontProgram;
	void *          pvPreProgram;
	ErrorCode       error;
	fs_SplineKey *  key;
	int16			xOverResolution;
#ifdef FSCFG_SUBPIXEL
	void *          pvGlobalGSSubPixel;
    uint16          flSubPixelHintFlag;
	void *          pvTwilightZoneSubPixel;
#endif // FSCFG_SUBPIXEL
   	uint16            usPPEMX;                  /* for sbits */
	uint16            usPPEMY; 
    uint16            usRotation;

	if((inputPtr->memoryBases[WORK_SPACE_BASE] == NULL) ||
	   (inputPtr->memoryBases[PRIVATE_FONT_SPACE_BASE] == NULL))
	{
		return NULL_MEMORY_BASES_ERR;
	}
	CHECKSTAMP (inputPtr->memoryBases[KEY_PTR_BASE] + outputPtr->memorySizes[KEY_PTR_BASE]);

	SETSTAMP (inputPtr->memoryBases[WORK_SPACE_BASE] + outputPtr->memorySizes[WORK_SPACE_BASE]);
	SETSTAMP (inputPtr->memoryBases[PRIVATE_FONT_SPACE_BASE] + outputPtr->memorySizes[PRIVATE_FONT_SPACE_BASE]);

	STAT_ON_NEWTRAN;                 /* start STAT timer */

	key = fs_SetUpKey(inputPtr, (INITIALIZED | NEWSFNT), &error);

	if(!key)
	{
		return (FS_ENTRY)error;
	}


    key->bHintingEnabled = useHints;

	fsg_UpdateWorkSpaceAddresses(
		key->memoryBases[WORK_SPACE_BASE],
		&(key->WorkSpaceOffsets),
		&(key->pWorkSpaceAddr));

	fsg_UpdateWorkSpaceElement(
		&(key->WorkSpaceOffsets),
		&(key->pWorkSpaceAddr));

	pvStack = fsg_QueryStack(&key->pWorkSpaceAddr);

	fsg_UpdatePrivateSpaceAddresses(
		&key->ClientInfo,
		&key->maxProfile,
		key->memoryBases[PRIVATE_FONT_SPACE_BASE],
		&(key->PrivateSpaceOffsets),
		pvStack,
		&pvFontProgram,
		&pvPreProgram);

	pvGlobalGS = fsg_QueryGlobalGS(
		key->memoryBases[PRIVATE_FONT_SPACE_BASE],
		&(key->PrivateSpaceOffsets));

	pvTwilightZone = fsg_QueryTwilightElement(
		key->memoryBases[PRIVATE_FONT_SPACE_BASE],
		&(key->PrivateSpaceOffsets));

	MEMCPY(key->apbPrevMemoryBases, key->memoryBases, sizeof(char *) * (size_t)MEMORYFRAGMENTS);

	key->bExecutePrePgm = (boolean) !inputPtr->param.newtrans.traceFunc;

    if (!key->bHintingEnabled)
    {
        /* if fs_NewTransformNoGridFit was called, we disabled hinting : */
        key->bExecutePrePgm = TRUE;
        key->bExecuteFontPgm = FALSE;
    }

    /* Load the font program and pre program if necessary */

	if (key->bExecuteFontPgm)
	{
		error = sfac_CopyFontAndPrePrograms(
			&key->ClientInfo,
			(char *)pvFontProgram,
			(char *)pvPreProgram);

		if(error)
		{
			return (FS_ENTRY)error;
		}
	}

	key->TransformInfo.currentTMatrix = *inputPtr->param.newtrans.transformMatrix;
	key->TransformInfo.fxPixelDiameter  = inputPtr->param.newtrans.pixelDiameter;
	key->usOverScale = inputPtr->param.newtrans.usOverScale; /* read input param */

	xOverResolution = inputPtr->param.newtrans.xResolution;

#ifdef FSCFG_SUBPIXEL
    /* convert from external client flags to internal flags */
    key->flSubPixel = 0;
	if (inputPtr->param.newtrans.flSubPixel & SP_SUB_PIXEL)
    {
        key->flSubPixel |= FNT_SP_SUB_PIXEL;
    }
	if (inputPtr->param.newtrans.flSubPixel & SP_COMPATIBLE_WIDTH)
    {
        /* compatible width is disabled under rotation but kept under italization */
        if (key->TransformInfo.currentTMatrix.transform[0][1] == 0)
        {
            key->flSubPixel |= FNT_SP_COMPATIBLE_WIDTH;
        }
    }
	if (inputPtr->param.newtrans.flSubPixel & SP_VERTICAL_DIRECTION)
    {
        key->flSubPixel |= FNT_SP_VERTICAL_DIRECTION;
    }
	if (inputPtr->param.newtrans.flSubPixel & SP_SUB_PIXEL && key->TransformInfo.currentTMatrix.transform[0][0] == 0) {
	// we have a combination of rotation and/or mirroring which swaps the roles of the x- and y-axis
		key->flSubPixel ^= FNT_SP_VERTICAL_DIRECTION;
	}
	
	if (inputPtr->param.newtrans.flSubPixel & SP_BGR_ORDER)
    {
        key->flSubPixel |= FNT_SP_BGR_ORDER;
    }
	
    flSubPixelHintFlag = 0;

	if (((key->flSubPixel & FNT_SP_SUB_PIXEL) && (key->usOverScale != 0) ) || 
        (((key->flSubPixel & FNT_SP_COMPATIBLE_WIDTH) || (key->flSubPixel & FNT_SP_VERTICAL_DIRECTION) || (key->flSubPixel & FNT_SP_BGR_ORDER)) && !(key->flSubPixel & FNT_SP_SUB_PIXEL)))
	{
		/*****
		We do not yet allow a combination of SubPixel and Gray antialiazing
        The following table lists legal combinations of flags in flSubPixel:

		SubPixel	CompWidth	VertDirect	BGROrder	Comment
			No			No			No			No		b/w
			No			No			No			Yes		Illegal to ask for BGR order without asking for SubPixel
			No			No			Yes			No		Illegal to ask for vertical direction without asking for SubPixel
			No			No			Yes			Yes		Illegal by disjunctive combination
			No			Yes			No			No		Illegal to ask for compatible width without asking for SubPixel 
			No			Yes			No			Yes		Illegal by disjunctive combination 
			No			Yes			Yes			No		Illegal by disjunctive combination
			No			Yes			Yes			Yes		Illegal by disjunctive combination
			Yes			No			No			No		Plain SubPixel horizontal direction RGB
			Yes			No			No			Yes		Plain SubPixel horizontal direction BGR
			Yes			No			Yes			No		Plain SubPixel vertical direction RGB
			Yes			No			Yes			Yes		Plain SubPixel vertical direction BGR
			Yes			Yes			No			No		b/w compatible advance width SubPixel horizontal direction RGB
			Yes			Yes			No			Yes		b/w compatible advance width SubPixel horizontal direction BGR
			Yes			Yes			Yes			No		b/w compatible advance width SubPixel vertical direction RGB
			Yes			Yes			Yes			Yes		b/w compatible advance width SubPixel vertical direction BGR
		
		Note that it could be argued that in vertical direction RGB|BGR, advance widths should be b/w compatible
		by nature, because we are not rounding any x-direction positions and distances any differently than
		in b/w. However, with vertical direction RGB, a glyph may assume a height that is closer to its natural
		height than what it would in b/w, and as a result may seem too narrow or too wide, which in turn would
		call for a correction in x, specific to SubPixel with vertical direction RGB and potentially making the
		advance width incompatible. Therefore, we allow the last two combinations of flags.
		*****/

		return BAD_GRAY_LEVEL_ERR;
	}
	
	if ((key->flSubPixel & FNT_SP_SUB_PIXEL))
    {
        if (key->flSubPixel & FNT_SP_COMPATIBLE_WIDTH)
        {
	        pvGlobalGSSubPixel = fsg_QueryGlobalGSSubPixel(
		        key->memoryBases[PRIVATE_FONT_SPACE_BASE],
		        &(key->PrivateSpaceOffsets));
	        pvTwilightZoneSubPixel = fsg_QueryTwilightElementSubPixel(
		        key->memoryBases[PRIVATE_FONT_SPACE_BASE],
		        &(key->PrivateSpaceOffsets));
            key->TransformInfoSubPixel = key->TransformInfo;
        } else
        {
            xOverResolution = xOverResolution * HINTING_HOR_OVERSCALE;
            flSubPixelHintFlag = key->flSubPixel;
        }

    }
#endif // FSCFG_SUBPIXEL

	if (key->usOverScale != 0 && 
			(((1 << (key->usOverScale - 1)) & FS_GRAY_VALUE_MASK) == 0) || key->usOverScale > 31)
	{
		return BAD_GRAY_LEVEL_ERR;
	}


	key->bGrayScale = (key->usOverScale == 0) ? FALSE : TRUE;
	fsg_SetHintFlags(pvGlobalGS, key->bGrayScale
#ifdef FSCFG_SUBPIXEL
	    ,flSubPixelHintFlag
#endif // FSCFG_SUBPIXEL
        );

	error = fsg_InitInterpreterTrans (
		&key->TransformInfo,
		pvGlobalGS,
		inputPtr->param.newtrans.pointSize,
#ifdef FSCFG_SUBPIXEL
        xOverResolution,
#else
		inputPtr->param.newtrans.xResolution,
#endif // FSCFG_SUBPIXEL
		inputPtr->param.newtrans.yResolution,
		inputPtr->param.newtrans.bHintAtEmSquare,
		inputPtr->param.newtrans.usEmboldWeightx ,
		inputPtr->param.newtrans.usEmboldWeighty,
		key->ClientInfo.sWinDescender,
		inputPtr->param.newtrans.lDescDev,
		&key->sBoldSimulHorShift,
		&key->sBoldSimulVertShift );

#ifdef FSCFG_SUBPIXEL
	if ((key->flSubPixel & FNT_SP_COMPATIBLE_WIDTH))
    {
	    fsg_SetHintFlags(pvGlobalGSSubPixel, key->bGrayScale, key->flSubPixel);

	    error = fsg_InitInterpreterTrans (
		    &key->TransformInfoSubPixel,
		    pvGlobalGSSubPixel,
		    inputPtr->param.newtrans.pointSize,
		    (int16)(xOverResolution * HINTING_HOR_OVERSCALE),
		    inputPtr->param.newtrans.yResolution,
		    inputPtr->param.newtrans.bHintAtEmSquare,
		    inputPtr->param.newtrans.usEmboldWeightx ,
		    inputPtr->param.newtrans.usEmboldWeighty,
		    key->ClientInfo.sWinDescender,
		    inputPtr->param.newtrans.lDescDev,
		    &key->sBoldSimulHorShift,
		    &key->sBoldSimulVertShift  );
    }
#endif // FSCFG_SUBPIXEL

	key->bBitmapEmboldening = inputPtr->param.newtrans.bBitmapEmboldening;

	if(error)
	{
		return (FS_ENTRY)error;
	}

	if (key->bExecuteFontPgm)
	{
		error = fsg_RunFontProgram (pvGlobalGS, &key->pWorkSpaceAddr, pvTwilightZone,
									inputPtr->param.newtrans.traceFunc);

		if(error)
		{
			return (FS_ENTRY)error;
		}

        key->bExecuteFontPgm = FALSE;
	}

#ifdef FSCFG_SUBPIXEL
	if ((key->flSubPixel & FNT_SP_COMPATIBLE_WIDTH))
    {
		fsg_CopyFontProgramResults (pvGlobalGS, pvGlobalGSSubPixel);
    }
#endif // FSCFG_SUBPIXEL

	if (!key->bExecutePrePgm)
	{

		/* Do this now so we do not confuse font editors    */
		/* Run the pre program and scale the control value table */
		/* Sets key->bExecutePrePgm to false          */

		error = fsg_RunPreProgram (
			&key->ClientInfo,
			&key->maxProfile,
			&key->TransformInfo,
			pvGlobalGS,
			&key->pWorkSpaceAddr,
			pvTwilightZone,
			inputPtr->param.newtrans.traceFunc);

		if(error)
		{
			/* If the pre-program fails, switch off hinting for further glyphs */
			key->bHintingEnabled = FALSE;
			return (FS_ENTRY)error;
		}
#ifdef FSCFG_SUBPIXEL
	    if ((key->flSubPixel & FNT_SP_COMPATIBLE_WIDTH))
        {
		    error = fsg_RunPreProgram (
			    &key->ClientInfo,
			    &key->maxProfile,
			    &key->TransformInfoSubPixel,
			    pvGlobalGSSubPixel,
			    &key->pWorkSpaceAddr,
			    pvTwilightZoneSubPixel,
			    inputPtr->param.newtrans.traceFunc);

		    if(error)
		    {
			    /* If the pre-program fails, switch off hinting for further glyphs */
			    key->bHintingEnabled = FALSE;
			    return (FS_ENTRY)error;
		    }
        }
#endif // FSCFG_SUBPIXEL
	}

	fsg_GetScaledCVT(
		key->memoryBases[PRIVATE_FONT_SPACE_BASE],
		&key->PrivateSpaceOffsets,
		&outputPtr->scaledCVT);

    fsg_QueryPPEMXY(pvGlobalGS, &key->TransformInfo, 
	            &usPPEMX, &usPPEMY, &usRotation);

	error = sbit_NewTransform(&key->SbitMono,key->TransformInfo.usEmResolution,
		key->sBoldSimulHorShift, key->sBoldSimulVertShift, usPPEMX, usPPEMY, usRotation );      /* setup for sbits */
	
	if(error)
	{
		return (FS_ENTRY)error;
	}

	fs_SetState(key, (INITIALIZED | NEWSFNT | NEWTRANS));

	CHECKSTAMP (inputPtr->memoryBases[KEY_PTR_BASE] + outputPtr->memorySizes[KEY_PTR_BASE]);
	CHECKSTAMP (inputPtr->memoryBases[WORK_SPACE_BASE] + outputPtr->memorySizes[WORK_SPACE_BASE]);
	CHECKSTAMP (inputPtr->memoryBases[PRIVATE_FONT_SPACE_BASE] + outputPtr->memorySizes[PRIVATE_FONT_SPACE_BASE]);

	STAT_OFF_NEWTRAN;             /* stop STAT timer */

	return NO_ERR;
}


/*
 * Compute the glyph index from the character code.
 */

FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_NewGlyph (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
{
	ErrorCode         error;
	fs_SplineKey *    key;
	void *            pvGlobalGS;
	uint16			  usBitDepth;			/* 1 for B/W bitmap, 2, 4 or 8 for gray sbit */

	if((inputPtr->memoryBases[WORK_SPACE_BASE] == NULL) ||
	   (inputPtr->memoryBases[PRIVATE_FONT_SPACE_BASE] == NULL))
	{
		return NULL_MEMORY_BASES_ERR;
	}
	CHECKSTAMP (inputPtr->memoryBases[KEY_PTR_BASE] + outputPtr->memorySizes[KEY_PTR_BASE]);
	CHECKSTAMP (inputPtr->memoryBases[WORK_SPACE_BASE] + outputPtr->memorySizes[WORK_SPACE_BASE]);
	CHECKSTAMP (inputPtr->memoryBases[PRIVATE_FONT_SPACE_BASE] + outputPtr->memorySizes[PRIVATE_FONT_SPACE_BASE]);

	STAT_ON_NEWGLYPH;                /* start STAT timer */

	key = fs_SetUpKey(inputPtr, (INITIALIZED | NEWSFNT | NEWTRANS), &error);

	if(!key)
	{
		return (FS_ENTRY)error;
	}

	if (inputPtr->param.newglyph.characterCode != NONVALID)
	{
		error = sfac_GetGlyphIndex(
			&key->ClientInfo,
			inputPtr->param.newglyph.characterCode);

		if(error)
		{
			return (FS_ENTRY)error;
		}

		outputPtr->numberOfBytesTaken = 2;  /*  !!!DISCUSS  */
		outputPtr->glyphIndex = key->ClientInfo.usGlyphIndex;
	}
	else
	{
		key->ClientInfo.usGlyphIndex = inputPtr->param.newglyph.glyphIndex;
		outputPtr->glyphIndex =        inputPtr->param.newglyph.glyphIndex;
		outputPtr->numberOfBytesTaken = 0;
	}

	if( key->ClientInfo.usGlyphIndex > key->maxProfile.numGlyphs - 1)
	{
		return INVALID_GLYPH_INDEX;
	}

	pvGlobalGS = fsg_QueryGlobalGS(
		key->memoryBases[PRIVATE_FONT_SPACE_BASE],
		&(key->PrivateSpaceOffsets));

	key->bEmbeddedBitmap = !inputPtr->param.newglyph.bNoEmbeddedBitmap; /* read input param */

	key->bMatchBBox = inputPtr->param.newglyph.bMatchBBox;

	if (inputPtr->param.newglyph.bNoEmbeddedBitmap)
	{
		outputPtr->usBitmapFound = FALSE;
	} else {
		error = sbit_SearchForBitmap(
			&key->SbitMono,
			&key->ClientInfo,
			key->ClientInfo.usGlyphIndex,
			key->usOverScale,
			&usBitDepth,
			&outputPtr->usBitmapFound );
	
		if(error)
		{
			return (FS_ENTRY)error;
		}

	}

	if (key->usOverScale == 0)
	{
		outputPtr->usGrayLevels = 0; 
		/* usGrayLevels == 0 means 1 bit per pixel */
	} else {
#ifndef FSCFG_CONVERT_GRAY_LEVELS
		if(outputPtr->usBitmapFound)
		{
			outputPtr->usGrayLevels = 0x01 << usBitDepth;
		} else {
#endif // FSCFG_CONVERT_GRAY_LEVELS
			outputPtr->usGrayLevels = key->usOverScale * key->usOverScale + 1;
#ifndef FSCFG_CONVERT_GRAY_LEVELS
		}
#endif // FSCFG_CONVERT_GRAY_LEVELS
	}

	key->bEmbeddedBitmap = outputPtr->usBitmapFound;

#ifdef FSCFG_SUBPIXEL
	if ((key->flSubPixel & FNT_SP_SUB_PIXEL))
	{
		outputPtr->usBitmapFound = FALSE;
	}
#endif // FSCFG_SUBPIXEL

	/* clear all other bits */

	fs_SetState(key, (INITIALIZED | NEWSFNT | NEWTRANS | GOTINDEX));

	CHECKSTAMP (inputPtr->memoryBases[KEY_PTR_BASE] + outputPtr->memorySizes[KEY_PTR_BASE]);
	CHECKSTAMP (inputPtr->memoryBases[WORK_SPACE_BASE] + outputPtr->memorySizes[WORK_SPACE_BASE]);
	CHECKSTAMP (inputPtr->memoryBases[PRIVATE_FONT_SPACE_BASE] + outputPtr->memorySizes[PRIVATE_FONT_SPACE_BASE]);

	STAT_OFF_NEWGLYPH;                   /* stop STAT timer */

	return NO_ERR;
}


/*
 * this call is optional.
 *
 * can be called right after fs_NewGlyph ()
 */

FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_GetAdvanceWidth (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
{
	ErrorCode       error;
	int16           sNonScaledLSB;
	fs_SplineKey *  key;
	void *          pvGlobalGS;

	key = fs_SetUpKey(inputPtr, (INITIALIZED | NEWSFNT | NEWTRANS | GOTINDEX), &error);

	if(!key)
	{
		return (FS_ENTRY)error;
	}

	pvGlobalGS = fsg_QueryGlobalGS(
		key->memoryBases[PRIVATE_FONT_SPACE_BASE],
		&(key->PrivateSpaceOffsets));

	error = sfac_ReadGlyphHorMetrics (
		&key->ClientInfo,
		key->ClientInfo.usGlyphIndex,
		&key->usNonScaledAW,
		&sNonScaledLSB);

	if(error)
	{
		return (FS_ENTRY)error;
	}

	fsg_UpdateAdvanceWidth (&key->TransformInfo, pvGlobalGS, key->usNonScaledAW,
		&outputPtr->metricInfo.advanceWidth);

#ifdef FSCFG_SUBPIXEL
	if ((key->flSubPixel & FNT_SP_SUB_PIXEL) && !(key->flSubPixel & FNT_SP_COMPATIBLE_WIDTH) )
	{
        /* in the SubPixel mode, key->TransformInfo is overscaled when we don't ask for compatible width */
	    ROUND_FROM_HINT_OVERSCALE(outputPtr->metricInfo.advanceWidth.x);
	}
#endif // FSCFG_SUBPIXEL
	return NO_ERR;
}

/*
 * this call is optional.
 *
 * can be called right after fs_NewGlyph ()
 */

FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_GetAdvanceHeight (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
{
	ErrorCode       error;
	int16           sNonScaledTSB;
	fs_SplineKey *  key;
	void *          pvGlobalGS;

	key = fs_SetUpKey(inputPtr, (INITIALIZED | NEWSFNT | NEWTRANS | GOTINDEX), &error);

	if(!key)
	{
		return (FS_ENTRY)error;
	}

	pvGlobalGS = fsg_QueryGlobalGS(
		key->memoryBases[PRIVATE_FONT_SPACE_BASE],
		&(key->PrivateSpaceOffsets));


	error = sfac_ReadGlyphVertMetrics (
		&key->ClientInfo,
		key->ClientInfo.usGlyphIndex,
		&key->usNonScaledAH,
		&sNonScaledTSB);

	if(error)
	{
		return (FS_ENTRY)error;
	}

	fsg_UpdateAdvanceHeight (&key->TransformInfo, pvGlobalGS, key->usNonScaledAH,
		&outputPtr->verticalMetricInfo.advanceHeight);

#ifdef FSCFG_SUBPIXEL	
	if ((key->flSubPixel & FNT_SP_SUB_PIXEL) && !(key->flSubPixel & FNT_SP_COMPATIBLE_WIDTH) )
	{
        /* in the SubPixel mode, key->TransformInfo is overscaled when we don't ask for compatible width */
	    ROUND_FROM_HINT_OVERSCALE(outputPtr->verticalMetricInfo.advanceHeight.x);
	}
#endif
    return NO_ERR;
}

FS_PRIVATE int32 fs__Contour (fs_GlyphInputType*inputPtr, fs_GlyphInfoType*outputPtr, boolean useHints)
{
	ErrorCode       error;
	void *          pvGlobalGS;
	fs_SplineKey *  key;
	point           f26DevAdvanceWidth;
	point           f26DevAdvanceHeight;
	void *          pvTwilightZone;
	void *          pvStack;
	void *          pvFontProgram;
	void *          pvPreProgram;
#ifdef FSCFG_SUBPIXEL	
	void *          pvGlobalGSSubPixel;
	void *          pvTwilightZoneSubPixel;
	boolean         bSubPixelWidth = FALSE;
#endif // FSCFG_SUBPIXEL

	if((inputPtr->memoryBases[WORK_SPACE_BASE] == NULL) ||
	   (inputPtr->memoryBases[PRIVATE_FONT_SPACE_BASE] == NULL))
	{
		return NULL_MEMORY_BASES_ERR;
	}

	CHECKSTAMP (inputPtr->memoryBases[KEY_PTR_BASE] + outputPtr->memorySizes[KEY_PTR_BASE]);
	CHECKSTAMP (inputPtr->memoryBases[WORK_SPACE_BASE] + outputPtr->memorySizes[WORK_SPACE_BASE]);
	CHECKSTAMP (inputPtr->memoryBases[PRIVATE_FONT_SPACE_BASE] + outputPtr->memorySizes[PRIVATE_FONT_SPACE_BASE]);

	STAT_ON_GRIDFIT;                 /* start STAT timer */

	key = fs_SetUpKey(inputPtr, (INITIALIZED | NEWSFNT | NEWTRANS | GOTINDEX), &error);

	if(!key)
	{
		return (FS_ENTRY)error;
	}

	if((key->apbPrevMemoryBases[WORK_SPACE_BASE] != key->memoryBases[WORK_SPACE_BASE]) ||
	   (key->apbPrevMemoryBases[PRIVATE_FONT_SPACE_BASE] != key->memoryBases[PRIVATE_FONT_SPACE_BASE]))
	{
		fsg_UpdateWorkSpaceAddresses(
			key->memoryBases[WORK_SPACE_BASE],
			&(key->WorkSpaceOffsets),
			&(key->pWorkSpaceAddr));

		pvStack = fsg_QueryStack(&key->pWorkSpaceAddr);

		fsg_UpdatePrivateSpaceAddresses(
			&key->ClientInfo,
			&key->maxProfile,
			key->memoryBases[PRIVATE_FONT_SPACE_BASE],
			&(key->PrivateSpaceOffsets),
			pvStack,
			&pvFontProgram,
			&pvPreProgram);

		MEMCPY(key->apbPrevMemoryBases, key->memoryBases, sizeof(char *) * (size_t)MEMORYFRAGMENTS);
	}

	/* The element data structures need to be updated here because if the    */
	/* WorkSpace memory is shared, the pointers will not be correct. Since  */
	/* fs_Contour[No]GridFit - fs_ContourScan must have the same shared      */
	/* base, these address do not have to be updated explicitly between      */
	/* each call, only if the memory base has physically moved.              */

	fsg_UpdateWorkSpaceElement(
		&(key->WorkSpaceOffsets),
		&(key->pWorkSpaceAddr));

	pvGlobalGS = fsg_QueryGlobalGS(
		key->memoryBases[PRIVATE_FONT_SPACE_BASE],
		&(key->PrivateSpaceOffsets));

#ifdef FSCFG_SUBPIXEL	
	if ((key->flSubPixel & FNT_SP_COMPATIBLE_WIDTH))
    {
	    pvGlobalGSSubPixel = fsg_QueryGlobalGSSubPixel(
		    key->memoryBases[PRIVATE_FONT_SPACE_BASE],
		    &(key->PrivateSpaceOffsets));
	    pvTwilightZoneSubPixel = fsg_QueryTwilightElementSubPixel(
		    key->memoryBases[PRIVATE_FONT_SPACE_BASE],
		    &(key->PrivateSpaceOffsets));
    }

	if ( (key->flSubPixel & FNT_SP_SUB_PIXEL) && !(key->flSubPixel & FNT_SP_COMPATIBLE_WIDTH) ) 
    {
        bSubPixelWidth = TRUE;
    }
#endif // FSCFG_SUBPIXEL

	pvTwilightZone = fsg_QueryTwilightElement(
		key->memoryBases[PRIVATE_FONT_SPACE_BASE],
		&(key->PrivateSpaceOffsets));

    if (!key->bHintingEnabled)
    {
        /* if fs_NewTransformNoGridFit was called, we disabled hinting : */
        key->bExecutePrePgm = FALSE;
        useHints = FALSE;
    }

	/*  potentially do delayed pre program execution */

	if (key->bExecutePrePgm)
	{
		/* Run the pre program and scale the control value table */

		key->bExecutePrePgm = FALSE;

		error = fsg_RunPreProgram (
			&key->ClientInfo,
			&key->maxProfile,
			&key->TransformInfo,
			pvGlobalGS,
			&key->pWorkSpaceAddr,
			pvTwilightZone,
			NULL);

		if(error)
		{
			/* If the pre-program fails, switch off hinting for further glyphs */
			key->bHintingEnabled = FALSE;
			return (FS_ENTRY)error;
		}
#ifdef FSCFG_SUBPIXEL	
	    if ((key->flSubPixel & FNT_SP_COMPATIBLE_WIDTH))
        {
		    error = fsg_RunPreProgram (
			    &key->ClientInfo,
			    &key->maxProfile,
			    &key->TransformInfoSubPixel,
			    pvGlobalGSSubPixel,
			    &key->pWorkSpaceAddr,
			    pvTwilightZoneSubPixel,
			    NULL);

		    if(error)
		    {
			    /* If the pre-program fails, switch off hinting for further glyphs */
			    key->bHintingEnabled = FALSE;
			    return (FS_ENTRY)error;
		    }
	    }
#endif // FSCFG_SUBPIXEL	
	}

#ifdef FSCFG_SUBPIXEL
	if (inputPtr->param.gridfit.bSkipIfBitmap && key->bEmbeddedBitmap && !(key->flSubPixel & FNT_SP_SUB_PIXEL))
#else
	if (inputPtr->param.gridfit.bSkipIfBitmap && key->bEmbeddedBitmap)
#endif // FSCFG_SUBPIXEL	
	{
		key->bGridFitSkipped = TRUE;    /* disallow grayscale, outline caching, banding */
		
		error = sbit_GetDevAdvanceWidth (
			&key->SbitMono,
			&key->ClientInfo,
			&f26DevAdvanceWidth );
		
		if(error)
		{
			return (FS_ENTRY)error;
		}

		error = sbit_GetDevAdvanceHeight (
			&key->SbitMono,
			&key->ClientInfo,
			&f26DevAdvanceHeight );

		if(error)
		{
			return (FS_ENTRY)error;
		}

	}
	else                                /* if we're using the outline */
	{
		key->bGridFitSkipped = FALSE;   /* allow grayscale, outline caching, banding */

		/* THE CALL */

		error = fsg_GridFit (
			&key->ClientInfo,
			&key->maxProfile,
			&key->TransformInfo,
			pvGlobalGS,
			&key->pWorkSpaceAddr,
			pvTwilightZone,
			inputPtr->param.gridfit.traceFunc,
			useHints,
			&key->usScanType,
			&key->bGlyphHasOutline,
			&key->usNonScaledAW,
			key->bBitmapEmboldening
#ifdef FSCFG_SUBPIXEL
	        ,bSubPixelWidth
#endif // FSCFG_SUBPIXEL
			);

		if(error)
		{
			return (FS_ENTRY)error;
		}

#ifdef FSCFG_SUBPIXEL

        if (key->flSubPixel & FNT_SP_SUB_PIXEL) {
            Fixed   fxCompatibleWidthScale;
            F26Dot6 devAdvanceWidthX, devLeftSideBearingX, devRightSideBearingX;
            F26Dot6 horTranslation;
			
			/* default scale back factor if we don't need to adjust for compatible width
			   (FNT_SP_COMPATIBLE_WIDTH is set off under rotation at fs_NewTransformation) */
			
			fxCompatibleWidthScale = SUBPIXEL_SCALEBACK_FACTOR; 

            if (key->flSubPixel & FNT_SP_COMPATIBLE_WIDTH) {
				Fixed concertFactor;

				// compute the B/W glyph metrics
        	    if (key->bEmbeddedBitmap) {
		            error = sbit_CalcDevHorMetrics (&key->SbitMono,&key->ClientInfo,&devAdvanceWidthX,&devLeftSideBearingX,&devRightSideBearingX);
		            if(error)
		                return (FS_ENTRY)error;
				} else {
		            fsg_CalcDevHorMetrics(&key->pWorkSpaceAddr,&devAdvanceWidthX,&devLeftSideBearingX,&devRightSideBearingX);
                }

				if (key->usNonScaledAW) {
					concertFactor = FixDiv(devAdvanceWidthX,((fnt_GlobalGraphicStateType *)pvGlobalGS)->ScaleFuncX(
										   &((fnt_GlobalGraphicStateType *)pvGlobalGS)->scaleX,(F26Dot6)key->usNonScaledAW));
					if (concertFactor < 0) concertFactor = -concertFactor;
				} else {
					concertFactor = 0x10000; // Fixed 1.0 for 0 AW glyphs
				}
				((fnt_GlobalGraphicStateType *)pvGlobalGSSubPixel)->compatibleWidthStemConcertina = concertFactor;
				
				/* grid fit for the SubPixel overscale resolution */
		        error = fsg_GridFit (
			        &key->ClientInfo,
			        &key->maxProfile,
			        &key->TransformInfoSubPixel,
			        pvGlobalGSSubPixel,
			        &key->pWorkSpaceAddr,
			        pvTwilightZoneSubPixel,
			        inputPtr->param.gridfit.traceFunc,
			        useHints,
			        &key->usScanType,
			        &key->bGlyphHasOutline,
			        &key->usNonScaledAW,
			        key->bBitmapEmboldening,
			        (key->flSubPixel & FNT_SP_SUB_PIXEL)
			        );

		        if(error) {
			        return (FS_ENTRY)error;
		        }
			} // key->flSubPixel & FNT_SP_COMPATIBLE_WIDTH
			
			fsg_ScaleToCompatibleWidth(&key->pWorkSpaceAddr,fxCompatibleWidthScale);

			if (useHints && (key->flSubPixel & FNT_SP_COMPATIBLE_WIDTH)) {
				horTranslation = 0;
				fsg_AdjustCompatibleMetrics (
					&key->pWorkSpaceAddr,
					horTranslation,
					devAdvanceWidthX*RGB_OVERSCALE);
			}
		}
#endif // FSCFG_SUBPIXEL

        fsg_GetContourData(
			&key->pWorkSpaceAddr,
#ifdef FSCFG_SUBPIXEL
			(boolean)(key->flSubPixel & FNT_SP_SUB_PIXEL),            
#endif // FSCFG_SUBPIXEL
			&outputPtr->xPtr,
			&outputPtr->yPtr,
			&outputPtr->startPtr,
			&outputPtr->endPtr,
			&outputPtr->onCurve,
			&outputPtr->fc,
			&outputPtr->numberOfContours);

		fsg_GetDevAdvanceWidth(
			&key->pWorkSpaceAddr,
			&f26DevAdvanceWidth);

		fsg_GetDevAdvanceHeight(
			&key->pWorkSpaceAddr,
			&f26DevAdvanceHeight);
	}
	
	outputPtr->metricInfo.devAdvanceWidth.x = DOT6TOFIX(f26DevAdvanceWidth.x);
	outputPtr->metricInfo.devAdvanceWidth.y = DOT6TOFIX(f26DevAdvanceWidth.y);

	outputPtr->verticalMetricInfo.devAdvanceHeight.x = DOT6TOFIX(f26DevAdvanceHeight.x);
	outputPtr->verticalMetricInfo.devAdvanceHeight.y = DOT6TOFIX(f26DevAdvanceHeight.y);

#ifdef FSCFG_SUBPIXEL
	if ((key->flSubPixel & FNT_SP_SUB_PIXEL))
	{
		ROUND_FROM_RGB_OVERSCALE(outputPtr->metricInfo.devAdvanceWidth.x);
		ROUND_FROM_RGB_OVERSCALE(outputPtr->verticalMetricInfo.devAdvanceHeight.x);
	}
#endif // FSCFG_SUBPIXEL

	outputPtr->outlinesExist = (uint16)key->bGlyphHasOutline;

	fsg_GetScaledCVT(
		key->memoryBases[PRIVATE_FONT_SPACE_BASE],
		&key->PrivateSpaceOffsets,
		&outputPtr->scaledCVT);

	fs_SetState(key, (INITIALIZED | NEWSFNT | NEWTRANS | GOTINDEX | GOTGLYPH));

	CHECKSTAMP (inputPtr->memoryBases[KEY_PTR_BASE] + outputPtr->memorySizes[KEY_PTR_BASE]);
	CHECKSTAMP (inputPtr->memoryBases[WORK_SPACE_BASE] + outputPtr->memorySizes[WORK_SPACE_BASE]);
	CHECKSTAMP (inputPtr->memoryBases[PRIVATE_FONT_SPACE_BASE] + outputPtr->memorySizes[PRIVATE_FONT_SPACE_BASE]);

	STAT_OFF_GRIDFIT;             /* stop STAT timer */

	return NO_ERR;
}

FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_ContourNoGridFit (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
{
	return fs__Contour (inputPtr, outputPtr, FALSE);
}


FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_ContourGridFit (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
{
	return fs__Contour (inputPtr, outputPtr, TRUE);
}

/*********************************************************************/

/* Calculate scan conversion memory requirements                     */

FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_FindBitMapSize (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
{

	ErrorCode       error;
	BitMap *        pBMI;

	ContourList     CList;        /* newscan contour list type */
	void *          pvGlobalGS;
	fs_SplineKey *  key;

	point           f26DevAdvanceWidth;
	point           f26DevLeftSideBearing;
	point           f26LeftSideBearing;
	point           f26DevLeftSideBearingLine;
	point           f26LeftSideBearingLine;

	point           f26DevAdvanceHeight;
	point           f26DevTopSideBearing;
	point           f26TopSideBearing;
	point           f26DevTopSideBearingLine;
	point           f26TopSideBearingLine;

	int16           sOverScale;
	uint16          usRoundXMin;
	Rect *          pOrigB;             /* original outline bounding box */
	Rect *          pOverB;             /* over scaled outline bounding box */
	GlyphBitMap *   pOverG;             /* over scaled glyph bitmap struct */
	GlyphBitMap *   pGBMap;             /* orig or over pointer */
	
	uint16          usRowBytes;
	uint32          ulSbitOutSize;      /* sbit output memory */
	uint32          ulSbitWorkSize;     /* sbit workspace memory */
	int16           sNonScaledLSB;      /* for non-dev metrics calc */
	int16           sNonScaledTSB;      /* for non-dev metrics calc */
	int16           sBitmapEmboldeningHorExtra;      
	int16           sBitmapEmboldeningVertExtra;      

	if((inputPtr->memoryBases[WORK_SPACE_BASE] == NULL) ||
	   (inputPtr->memoryBases[PRIVATE_FONT_SPACE_BASE] == NULL))
	{
		return NULL_MEMORY_BASES_ERR;
	}

	CHECKSTAMP (inputPtr->memoryBases[KEY_PTR_BASE] + outputPtr->memorySizes[KEY_PTR_BASE]);
	CHECKSTAMP (inputPtr->memoryBases[WORK_SPACE_BASE] + outputPtr->memorySizes[WORK_SPACE_BASE]);
	CHECKSTAMP (inputPtr->memoryBases[PRIVATE_FONT_SPACE_BASE] + outputPtr->memorySizes[PRIVATE_FONT_SPACE_BASE]);

	STAT_ON_FINDBMS;                 /* start STAT timer */
	
	key = fs_SetUpKey(inputPtr, (INITIALIZED | NEWSFNT | NEWTRANS | GOTINDEX | GOTGLYPH), &error);
	if(!key)
	{
		return (FS_ENTRY)error;
	}

	if(key->apbPrevMemoryBases[WORK_SPACE_BASE] != key->memoryBases[WORK_SPACE_BASE])
	{
		  fsg_UpdateWorkSpaceAddresses(
				key->memoryBases[WORK_SPACE_BASE],
				&(key->WorkSpaceOffsets),
				&(key->pWorkSpaceAddr));
		
		  fsg_UpdateWorkSpaceElement(
				&(key->WorkSpaceOffsets),
				&(key->pWorkSpaceAddr));
		
		  MEMCPY(key->apbPrevMemoryBases, key->memoryBases, sizeof(char *) * (size_t)MEMORYFRAGMENTS);
	}

	pvGlobalGS = fsg_QueryGlobalGS(
		key->memoryBases[PRIVATE_FONT_SPACE_BASE],
		&(key->PrivateSpaceOffsets));

	pOrigB = &key->GBMap.rectBounds;    /* local copy of bounds pointer */

#ifdef FSCFG_SUBPIXEL
	if (key->bEmbeddedBitmap && !(key->flSubPixel & FNT_SP_SUB_PIXEL))  				/* if bitmap are not disabled */
#else
	if (key->bEmbeddedBitmap)  				/* if bitmap are not disabled */
#endif // FSCFG_SUBPIXEL	
	{
		error = sbit_GetMetrics (                   /* get device metrics */
			&key->SbitMono,
			&key->ClientInfo,
			&f26DevAdvanceWidth,
			&f26DevLeftSideBearing,
            &f26LeftSideBearing,
			&f26DevAdvanceHeight,
			&f26DevTopSideBearing,
			&f26TopSideBearing,
			pOrigB,
			&usRowBytes,
			&ulSbitOutSize,
			&ulSbitWorkSize );
		
		if (error != NO_ERR)
		{
			return(error);
		}
		
		outputPtr->metricInfo.devAdvanceWidth.x = DOT6TOFIX(f26DevAdvanceWidth.x);
		outputPtr->metricInfo.devAdvanceWidth.y = DOT6TOFIX(f26DevAdvanceWidth.y);
		outputPtr->metricInfo.devLeftSideBearing.x = DOT6TOFIX(f26DevLeftSideBearing.x);
		outputPtr->metricInfo.devLeftSideBearing.y = DOT6TOFIX(f26DevLeftSideBearing.y);
		outputPtr->metricInfo.leftSideBearing.x = DOT6TOFIX(f26LeftSideBearing.x);
		outputPtr->metricInfo.leftSideBearing.y = DOT6TOFIX(f26LeftSideBearing.y);
		
		outputPtr->verticalMetricInfo.devAdvanceHeight.x = DOT6TOFIX(f26DevAdvanceHeight.x);
		outputPtr->verticalMetricInfo.devAdvanceHeight.y = DOT6TOFIX(f26DevAdvanceHeight.y);
		outputPtr->verticalMetricInfo.devTopSideBearing.x = DOT6TOFIX(f26DevTopSideBearing.x);
		outputPtr->verticalMetricInfo.devTopSideBearing.y = DOT6TOFIX(f26DevTopSideBearing.y);
		outputPtr->verticalMetricInfo.topSideBearing.x = DOT6TOFIX(f26TopSideBearing.x);
		outputPtr->verticalMetricInfo.topSideBearing.y = DOT6TOFIX(f26TopSideBearing.y);
		
        /* just copy to 'Line' metrics */

		outputPtr->metricInfo.devLeftSideBearingLine.x = outputPtr->metricInfo.devLeftSideBearing.x;
		outputPtr->metricInfo.devLeftSideBearingLine.y = outputPtr->metricInfo.devLeftSideBearing.y;
		outputPtr->metricInfo.leftSideBearingLine.x = outputPtr->metricInfo.leftSideBearing.x;
		outputPtr->metricInfo.leftSideBearingLine.y = outputPtr->metricInfo.leftSideBearing.y;

		outputPtr->verticalMetricInfo.devTopSideBearingLine.x = outputPtr->verticalMetricInfo.devTopSideBearing.x;
		outputPtr->verticalMetricInfo.devTopSideBearingLine.y = outputPtr->verticalMetricInfo.devTopSideBearing.y;
		outputPtr->verticalMetricInfo.topSideBearingLine.x = outputPtr->verticalMetricInfo.topSideBearing.x;
		outputPtr->verticalMetricInfo.topSideBearingLine.y = outputPtr->verticalMetricInfo.topSideBearing.y;


	error = sfac_ReadGlyphMetrics (             /* get non-dev adv width */
			&key->ClientInfo,
			key->ClientInfo.usGlyphIndex,
			&key->usNonScaledAW,
			&key->usNonScaledAH,
			&sNonScaledLSB,
			&sNonScaledTSB);

		if(error != NO_ERR)
		{
			return error;
		}

		fsg_UpdateAdvanceWidth (
			&key->TransformInfo,                    /* scale the design adv width */
			pvGlobalGS, 
			key->usNonScaledAW,
			&outputPtr->metricInfo.advanceWidth );

		fsg_UpdateAdvanceHeight (
			&key->TransformInfo,                    /* scale the design adv height */
			pvGlobalGS, 
			key->usNonScaledAH,
			&outputPtr->verticalMetricInfo.advanceHeight );

		pBMI = &outputPtr->bitMapInfo;
		pBMI->bounds.left = pOrigB->left;               /* return bbox to client */
		pBMI->bounds.right = pOrigB->right;
		pBMI->bounds.top = pOrigB->bottom;              /* reversed! */
		pBMI->bounds.bottom = pOrigB->top;
		pBMI->rowBytes = (int16)usRowBytes;
		pBMI->baseAddr = 0L;

		outputPtr->memorySizes[BITMAP_PTR_1] = ulSbitOutSize;
		outputPtr->memorySizes[BITMAP_PTR_2] = ulSbitWorkSize;
		outputPtr->memorySizes[BITMAP_PTR_3] = 0L;
		outputPtr->memorySizes[BITMAP_PTR_4] = 0L;
	}
	else                                /* if rasterizing from a contour */
	{
		if (key->TransformInfo.bPhaseShift)
		{
			fsg_45DegreePhaseShift (&key->pWorkSpaceAddr);
		}

		fsg_GetContourData(
			&key->pWorkSpaceAddr,
#ifdef FSCFG_SUBPIXEL
			FALSE,            
#endif // FSCFG_SUBPIXEL
			&CList.afxXCoord,
			&CList.afxYCoord,
			&CList.asStartPoint,
			&CList.asEndPoint,
			&CList.abyOnCurve,
			&CList.abyFc,
			&CList.usContourCount);

		error = fsc_RemoveDups(&CList);                 /* collapse dup'd points */
		if (error != NO_ERR)
		{
			return(error);
		}

		pGBMap = &key->GBMap;                           /* default to usual structure */
		usRoundXMin = 1;

		if (key->bGrayScale)                                 /* if doing gray scale */
		{
			error = fsc_OverScaleOutline(&CList, key->usOverScale);
			if (error != NO_ERR)
			{
				return(error);
			}
			pGBMap = &key->OverGBMap;                   /* measure overscaled structure */
			usRoundXMin = key->usOverScale;
		}
		
		fsg_GetWorkSpaceExtra(
			key->memoryBases[WORK_SPACE_BASE],
			&(key->WorkSpaceOffsets),
			&(key->WScan.pchRBuffer));
		key->WScan.lRMemSize = key->lExtraWorkSpace;    /* use extra for MeasureGlyph workspace */
		
		if (key->bBitmapEmboldening) 
		{
			if (key->bGrayScale)                                 /* if doing gray scale */
			{
				sBitmapEmboldeningHorExtra = key->usOverScale * key->sBoldSimulHorShift;
				sBitmapEmboldeningVertExtra = key->usOverScale * key->sBoldSimulVertShift;
			} 
#ifdef FSCFG_SUBPIXEL
			else if ((key->flSubPixel & FNT_SP_SUB_PIXEL))
			{
				sBitmapEmboldeningHorExtra = RGB_OVERSCALE * key->sBoldSimulHorShift; 
				sBitmapEmboldeningVertExtra = key->sBoldSimulVertShift; 
			}
#endif // FSCFG_SUBPIXEL
			else
			{
				sBitmapEmboldeningHorExtra = key->sBoldSimulHorShift; 
				sBitmapEmboldeningVertExtra = key->sBoldSimulVertShift; 
			}
		}
		else
		{
			sBitmapEmboldeningHorExtra = 0;
			sBitmapEmboldeningVertExtra = 0;
		}

		error = fsc_MeasureGlyph(
			&CList, 
			pGBMap, 
			&key->WScan, 
			key->usScanType, 
			usRoundXMin,
			sBitmapEmboldeningHorExtra,
			sBitmapEmboldeningVertExtra );

		if (error == SMART_DROP_OVERFLOW_ERR)
		{
			/* glyph is too complex for the smart dropout control */
			key->usScanType &= ~SK_SMART;
			error = fsc_MeasureGlyph(
				&CList, 
				pGBMap, 
				&key->WScan, 
				key->usScanType, 
				usRoundXMin,
				sBitmapEmboldeningHorExtra,
				sBitmapEmboldeningVertExtra );
		}
		if (error != NO_ERR)
		{
			return(error);
		}
		Assert(key->WScan.lRMemSize < key->lExtraWorkSpace);
		
		if (key->bGrayScale)                                 /* if doing gray scale */
		{
			sOverScale = (int16)key->usOverScale;
			
			if (key->bMatchBBox)        /* if bounding box is fixed */
			{                                           /* the calc as if orig monochrome */
				pOverG = &key->OverGBMap;        
				pOrigB->left = (int16)((mth_DivShiftLong(pOverG->fxMinX, sOverScale) + 31L) >> 6);
				pOrigB->right = (int16)((mth_DivShiftLong(pOverG->fxMaxX, sOverScale) + 32L) >> 6);
				pOrigB->bottom = (int16)((mth_DivShiftLong(pOverG->fxMinY, sOverScale) + 31L) >> 6);
				pOrigB->top = (int16)((mth_DivShiftLong(pOverG->fxMaxY, sOverScale) + 32L) >> 6);

				/* force the bitmap to have at least one pixel wide and one pixel high */
				if (pOrigB->left == pOrigB->right)
				{
					pOrigB->right++;                                /* force 1 pixel wide */
				}
				if (pOrigB->bottom == pOrigB->top)
				{
					pOrigB->top++;                                /* force 1 pixel high */
				}

			}
			else                                        /* if bounding box can grow */
			{                                           /* then size to gray box */
				pOverB = &key->OverGBMap.rectBounds;        
				pOrigB->left = mth_DivShiftShort(pOverB->left, sOverScale);
				pOrigB->right = mth_DivShiftShort((int16)(pOverB->right + sOverScale - 1), sOverScale);
				pOrigB->bottom = mth_DivShiftShort(pOverB->bottom, sOverScale);
				pOrigB->top = mth_DivShiftShort((int16)(pOverB->top + sOverScale - 1), sOverScale);
			}
		}
		
		fsg_CalcLSBsAndAdvanceWidths(                   /* use original size for all metrics */
			&key->pWorkSpaceAddr,
			INTTODOT6(pOrigB->left),
			INTTODOT6(pOrigB->top),
			&f26DevAdvanceWidth,
			&f26DevLeftSideBearing,
			&f26LeftSideBearing,
			&f26DevLeftSideBearingLine,
			&f26LeftSideBearingLine);

		outputPtr->metricInfo.devAdvanceWidth.x        = DOT6TOFIX(f26DevAdvanceWidth.x);
		outputPtr->metricInfo.devAdvanceWidth.y        = DOT6TOFIX(f26DevAdvanceWidth.y);
		outputPtr->metricInfo.devLeftSideBearing.x     = DOT6TOFIX(f26DevLeftSideBearing.x);
		outputPtr->metricInfo.devLeftSideBearing.y     = DOT6TOFIX(f26DevLeftSideBearing.y);
		outputPtr->metricInfo.leftSideBearing.x        = DOT6TOFIX(f26LeftSideBearing.x);
		outputPtr->metricInfo.leftSideBearing.y        = DOT6TOFIX(f26LeftSideBearing.y);
		outputPtr->metricInfo.devLeftSideBearingLine.x = DOT6TOFIX(f26DevLeftSideBearingLine.x);
		outputPtr->metricInfo.devLeftSideBearingLine.y = DOT6TOFIX(f26DevLeftSideBearingLine.y);
		outputPtr->metricInfo.leftSideBearingLine.x    = DOT6TOFIX(f26LeftSideBearingLine.x);
		outputPtr->metricInfo.leftSideBearingLine.y    = DOT6TOFIX(f26LeftSideBearingLine.y);

		fsg_CalcTSBsAndAdvanceHeights(                   /* use original size for all metrics */
			&key->pWorkSpaceAddr,
			INTTODOT6(pOrigB->left),
			INTTODOT6(pOrigB->top),
			&f26DevAdvanceHeight,
			&f26DevTopSideBearing,
			&f26TopSideBearing,
			&f26DevTopSideBearingLine,
			&f26TopSideBearingLine);

		outputPtr->verticalMetricInfo.devAdvanceHeight.x      = DOT6TOFIX(f26DevAdvanceHeight.x);
		outputPtr->verticalMetricInfo.devAdvanceHeight.y      = DOT6TOFIX(f26DevAdvanceHeight.y);
		outputPtr->verticalMetricInfo.devTopSideBearing.x     = DOT6TOFIX(f26DevTopSideBearing.x);
		outputPtr->verticalMetricInfo.devTopSideBearing.y     = DOT6TOFIX(f26DevTopSideBearing.y);
		outputPtr->verticalMetricInfo.topSideBearing.x        = DOT6TOFIX(f26TopSideBearing.x);
		outputPtr->verticalMetricInfo.topSideBearing.y        = DOT6TOFIX(f26TopSideBearing.y);
		outputPtr->verticalMetricInfo.devTopSideBearingLine.x = DOT6TOFIX(f26DevTopSideBearingLine.x);
		outputPtr->verticalMetricInfo.devTopSideBearingLine.y = DOT6TOFIX(f26DevTopSideBearingLine.y);
		outputPtr->verticalMetricInfo.topSideBearingLine.x    = DOT6TOFIX(f26TopSideBearingLine.x);
		outputPtr->verticalMetricInfo.topSideBearingLine.y    = DOT6TOFIX(f26TopSideBearingLine.y);

		fsg_UpdateAdvanceWidth (&key->TransformInfo, pvGlobalGS, key->usNonScaledAW,
			&outputPtr->metricInfo.advanceWidth);

		fsg_UpdateAdvanceHeight (&key->TransformInfo, pvGlobalGS, key->usNonScaledAH,
			&outputPtr->verticalMetricInfo.advanceHeight);

		MEMCPY(&key->metricInfo, &outputPtr->metricInfo, sizeof( metricsType ));
		MEMCPY(&key->verticalMetricInfo, &outputPtr->verticalMetricInfo, sizeof( verticalMetricsType ));

		pBMI = &outputPtr->bitMapInfo;
		pBMI->bounds.top = pOrigB->bottom;              /* reversed! */
		pBMI->bounds.bottom = pOrigB->top;
		pBMI->baseAddr = 0;
		
#ifdef FSCFG_SUBPIXEL
		if ((key->flSubPixel & FNT_SP_SUB_PIXEL))
		{
	        if (!(key->flSubPixel & FNT_SP_COMPATIBLE_WIDTH) )
	        {
                /* in the SubPixel mode, key->TransformInfo is overscaled when we don't ask for compatible width */
	            ROUND_FROM_HINT_OVERSCALE(outputPtr->metricInfo.advanceWidth.x);
	            ROUND_FROM_HINT_OVERSCALE(outputPtr->verticalMetricInfo.advanceHeight.x);
	        }
			ROUND_FROM_RGB_OVERSCALE(outputPtr->metricInfo.devAdvanceWidth.x);
			ROUND_FROM_RGB_OVERSCALE(outputPtr->metricInfo.devLeftSideBearing.x);
			ROUND_FROM_RGB_OVERSCALE(outputPtr->metricInfo.leftSideBearing.x);
			ROUND_FROM_RGB_OVERSCALE(outputPtr->metricInfo.devLeftSideBearingLine.x);
			ROUND_FROM_RGB_OVERSCALE(outputPtr->metricInfo.leftSideBearingLine.x);
			ROUND_FROM_RGB_OVERSCALE(outputPtr->verticalMetricInfo.devAdvanceHeight.x);
			ROUND_FROM_RGB_OVERSCALE(outputPtr->verticalMetricInfo.devTopSideBearing.x);
			ROUND_FROM_RGB_OVERSCALE(outputPtr->verticalMetricInfo.topSideBearing.x);
			ROUND_FROM_RGB_OVERSCALE(outputPtr->verticalMetricInfo.devTopSideBearingLine.x);
			ROUND_FROM_RGB_OVERSCALE(outputPtr->verticalMetricInfo.topSideBearingLine.x);

			pBMI->bounds.left = FLOOR_RGB_OVERSCALE(pOrigB->left);               /* return bbox to client */
			pBMI->bounds.right = CEIL_RGB_OVERSCALE(pOrigB->right);

			pBMI->rowBytes = ((pBMI->bounds.right - pBMI->bounds.left) + 3) & (-4);

            key->OverGBMap = key->GBMap;
            key->GBMap.sRowBytes = pBMI->rowBytes;
            key->GBMap.rectBounds.left = pBMI->bounds.left;
            key->GBMap.rectBounds.right = pBMI->bounds.right;
			key->GBMap.lMMemSize = (int32)pBMI->rowBytes * (int32)(key->GBMap.rectBounds.top - key->GBMap.rectBounds.bottom);
			outputPtr->memorySizes[BITMAP_PTR_4] = (FS_MEMORY_SIZE) key->OverGBMap.lMMemSize; 
		}
		else
		{
#endif // FSCFG_SUBPIXEL
			pBMI->bounds.left = pOrigB->left;               /* return bbox to client */
			pBMI->bounds.right = pOrigB->right;
			pBMI->rowBytes = key->GBMap.sRowBytes;
#ifdef FSCFG_SUBPIXEL
		}
#endif // FSCFG_SUBPIXEL

		if (key->bGrayScale)                                 /* if doing gray scale */
		{
			pBMI->rowBytes = ((pOrigB->right - pOrigB->left) + 3) & (-4);
			key->GBMap.lMMemSize = (int32)pBMI->rowBytes * (int32)(pOrigB->top - pOrigB->bottom);
			outputPtr->memorySizes[BITMAP_PTR_4] = (FS_MEMORY_SIZE) key->OverGBMap.lMMemSize; 
		}
		
		key->GBMap.sRowBytes = pBMI->rowBytes;
		outputPtr->memorySizes[BITMAP_PTR_1] = (FS_MEMORY_SIZE) key->GBMap.lMMemSize;
		outputPtr->memorySizes[BITMAP_PTR_2] = (FS_MEMORY_SIZE) key->WScan.lHMemSize;
		outputPtr->memorySizes[BITMAP_PTR_3] = (FS_MEMORY_SIZE) key->WScan.lVMemSize;

	}
	fsg_CheckWorkSpaceForFit(
		&(key->WorkSpaceOffsets),
		key->lExtraWorkSpace,
		key->WScan.lRMemSize,
		&(outputPtr->memorySizes[BITMAP_PTR_2]),
		&(outputPtr->memorySizes[BITMAP_PTR_3]));

	key->usBandType = FS_BANDINGOLD;                /* assume old banding */
	key->usBandWidth = 0;
	key->bOutlineIsCached = FALSE;                  /* assume no caching */

	fs_SetState(key,(INITIALIZED | NEWSFNT | NEWTRANS | GOTINDEX | GOTGLYPH | SIZEKNOWN));

	CHECKSTAMP (inputPtr->memoryBases[KEY_PTR_BASE] + outputPtr->memorySizes[KEY_PTR_BASE]);
	CHECKSTAMP (inputPtr->memoryBases[WORK_SPACE_BASE] + outputPtr->memorySizes[WORK_SPACE_BASE]);
	CHECKSTAMP (inputPtr->memoryBases[PRIVATE_FONT_SPACE_BASE] + outputPtr->memorySizes[PRIVATE_FONT_SPACE_BASE]);

	STAT_OFF_FINDBMS;             /* stop STAT timer */
	
	return NO_ERR;
}

/*********************************************************************/

FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_SizeOfOutlines (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
{
	fs_SplineKey *     key;
	int32              ulSize;
	ErrorCode          error;

	key = fs_SetUpKey(inputPtr, (INITIALIZED | NEWSFNT | NEWTRANS | GOTGLYPH | SIZEKNOWN), &error);
	if(!key)
	{
		return (FS_ENTRY)error;
	}

	if (key->bEmbeddedBitmap)
	{
        return SBIT_OUTLINE_CACHE_ERR;      /* can't cache sbits */
    }

	if(key->apbPrevMemoryBases[WORK_SPACE_BASE] != key->memoryBases[WORK_SPACE_BASE])
	{
		fsg_UpdateWorkSpaceAddresses(
			key->memoryBases[WORK_SPACE_BASE],
			&(key->WorkSpaceOffsets),
			&(key->pWorkSpaceAddr));

		fsg_UpdateWorkSpaceElement(
			&(key->WorkSpaceOffsets),
			&(key->pWorkSpaceAddr));

		key->WScan.pchRBuffer = (char *)fsg_QueryReusableMemory(
		key->memoryBases[WORK_SPACE_BASE],
		&(key->WorkSpaceOffsets));

		MEMCPY(key->apbPrevMemoryBases, key->memoryBases, sizeof(char *) * (size_t)MEMORYFRAGMENTS);
	}

	ulSize = (uint32)sizeof( uint32 );                         /* OUTLINESTAMP              */
	ulSize += (uint32)( sizeof( FS_MEMORY_SIZE ) * BITMAP_MEMORY_COUNT );   /* Memory Bases */
	ulSize += (uint32)( sizeof( uint32 ));                     /* Outlines Exist (padded)   */
	ulSize += (uint32)( sizeof( uint32 ));                     /* Scan Type (padded)        */
	ulSize += (uint32)( sizeof( uint32 ));                     /* Glyph Index (padded)      */
	ulSize += (uint32)( sizeof( uint32 ));                     /* Outline Cache Size        */
	ulSize += (uint32)( sizeof( uint32 ));                     /* Gray Scale Over Factor    */
	ulSize += (uint32)( sizeof( uint32 ));                     /* Grid Fit Skipped Boolean  */
	ulSize += (uint32)( sizeof( uint32 ));                     /* no embedded bitmap Boolean*/
	ulSize += (uint32)sizeof( metricsType );                   /* Metrics information       */
	ulSize += (uint32)sizeof( verticalMetricsType );           /* Vert metrics information  */
	ulSize += (uint32)sizeof( GlyphBitMap );                   /* Glyph Bitmap              */
	ulSize += (uint32)sizeof( GlyphBitMap );                   /* Gray Overscaled Bitmap    */
	ulSize += (uint32)sizeof( WorkScan );                      /* Scanconverter Workspace   */
	ulSize += (uint32)key->WScan.lRMemSize;                    /* Reversal list             */
	ulSize += fsg_GetContourDataSize(&key->pWorkSpaceAddr);    /* Contour Data              */
	ulSize += (uint32)sizeof( uint32 );                        /* OUTLINESTAMP2             */
	ALIGN(uint32, ulSize);

	outputPtr->outlineCacheSize = ulSize;
	key->ulGlyphOutlineSize = ulSize;

	return NO_ERR;
}

/*********************************************************************/

FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_SaveOutlines (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
{
	uint8 *            pbyDest;

	fs_SplineKey *     key;
	ErrorCode          error;

	key = fs_SetUpKey(inputPtr, (INITIALIZED | NEWSFNT | NEWTRANS | GOTGLYPH | SIZEKNOWN), &error);

	if(!key)
	{
		return (FS_ENTRY)error;
	}

	if(key->apbPrevMemoryBases[WORK_SPACE_BASE] != key->memoryBases[WORK_SPACE_BASE])
	{
		fsg_UpdateWorkSpaceAddresses(
			key->memoryBases[WORK_SPACE_BASE],
			&(key->WorkSpaceOffsets),
			&(key->pWorkSpaceAddr));

		fsg_UpdateWorkSpaceElement(
			&(key->WorkSpaceOffsets),
			&(key->pWorkSpaceAddr));

		MEMCPY(key->apbPrevMemoryBases, key->memoryBases, sizeof(char *) * (size_t)MEMORYFRAGMENTS);
	}

	if( (outputPtr->memorySizes[BITMAP_PTR_2] == 0L) || (outputPtr->memorySizes[BITMAP_PTR_3] == 0L))
	{
		fsg_GetRealBitmapSizes(
			&(key->WorkSpaceOffsets),
			&outputPtr->memorySizes[BITMAP_PTR_2],
			&outputPtr->memorySizes[BITMAP_PTR_3]);
	}

	pbyDest = (uint8 *)inputPtr->param.outlineCache;

	*((uint32 *)pbyDest) = OUTLINESTAMP;
	pbyDest += sizeof( uint32 );

	*((FS_MEMORY_SIZE *)pbyDest) = outputPtr->memorySizes[BITMAP_PTR_1];
	pbyDest += sizeof( FS_MEMORY_SIZE  );

	*((FS_MEMORY_SIZE *)pbyDest) = outputPtr->memorySizes[BITMAP_PTR_2];
	pbyDest += sizeof( FS_MEMORY_SIZE  );

	*((FS_MEMORY_SIZE *)pbyDest) = outputPtr->memorySizes[BITMAP_PTR_3];
	pbyDest += sizeof( FS_MEMORY_SIZE  );

	*((FS_MEMORY_SIZE *)pbyDest) = outputPtr->memorySizes[BITMAP_PTR_4];
	pbyDest += sizeof( FS_MEMORY_SIZE   );
	 
	/* Outlines exist state */

	*((uint32 *)pbyDest) = (uint32)key->bGlyphHasOutline;
	pbyDest += sizeof( uint32 );

	/* Dropout control state */

	*((uint32 *)pbyDest) = (uint32)key->usScanType;
	pbyDest += sizeof( uint32 );

	/* Glyph Index */

	*((uint32 *)pbyDest) = (uint32)key->ClientInfo.usGlyphIndex;
	pbyDest += sizeof( uint32 );

	/* Outline Cache Size */

	*((uint32 *)pbyDest) = (uint32)key->ulGlyphOutlineSize;
	pbyDest += sizeof( uint32 );

	/* Gray Over Scale Factor */

	*((uint32 *)pbyDest) = (uint32)key->usOverScale;
	pbyDest += sizeof( uint32 );

    /* Grid Fit Skipped Boolean  */

	*((uint32 *)pbyDest) = (uint32)key->bGridFitSkipped;
	pbyDest += sizeof( uint32 );

    /* No embedded bitmap Boolean  */

	*((uint32 *)pbyDest) = (uint32)key->bEmbeddedBitmap;
	pbyDest += sizeof( uint32 );

	/* Glyph metrics */

	MEMCPY(pbyDest, &key->metricInfo, sizeof(metricsType));
	pbyDest += sizeof(metricsType);

	MEMCPY(pbyDest, &key->verticalMetricInfo, sizeof(verticalMetricsType));
	pbyDest += sizeof(verticalMetricsType);

	/* Scan Converter Data Structures */

	MEMCPY(pbyDest, &key->GBMap, sizeof(GlyphBitMap));
	pbyDest += sizeof(GlyphBitMap);

	MEMCPY(pbyDest, &key->OverGBMap, sizeof(GlyphBitMap));
	pbyDest += sizeof(GlyphBitMap);

	MEMCPY(pbyDest, &key->WScan, sizeof(WorkScan));
	pbyDest += sizeof(WorkScan);

	MEMCPY(pbyDest, key->WScan.pchRBuffer, (size_t)key->WScan.lRMemSize);
	pbyDest += key->WScan.lRMemSize;

	/*** save charData ***/

	fsg_DumpContourData(&key->pWorkSpaceAddr, &pbyDest);

	*((uint32 *)pbyDest) = OUTLINESTAMP2;

	fs_SetState(key,(INITIALIZED | NEWSFNT | NEWTRANS | GOTINDEX | GOTGLYPH | SIZEKNOWN));

	return NO_ERR;
}

/*********************************************************************/

FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_RestoreOutlines (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
{
	fs_SplineKey *  key;
	uint8 *         pbySrc;
	ErrorCode       error;

	key = fs_SetUpKey(inputPtr, INITIALIZED, &error);
	if(!key)
	{
		return (FS_ENTRY)error;
	}

	pbySrc = (uint8 *)inputPtr->param.outlineCache;

	if ( *((uint32 *)pbySrc) != OUTLINESTAMP )
	{
		return TRASHED_OUTLINE_CACHE;
	}
	pbySrc += sizeof(uint32);

	outputPtr->memorySizes[BITMAP_PTR_1] = *((FS_MEMORY_SIZE *)pbySrc);
	pbySrc += sizeof( FS_MEMORY_SIZE   );

	outputPtr->memorySizes[BITMAP_PTR_2] = *((FS_MEMORY_SIZE *)pbySrc);
	pbySrc += sizeof( FS_MEMORY_SIZE   );

	outputPtr->memorySizes[BITMAP_PTR_3] = *((FS_MEMORY_SIZE *)pbySrc);
	pbySrc += sizeof( FS_MEMORY_SIZE   );

	outputPtr->memorySizes[BITMAP_PTR_4] = *((FS_MEMORY_SIZE *)pbySrc);
	pbySrc += sizeof( FS_MEMORY_SIZE    );

	/* Read in GlyphHasOutline */

	outputPtr->outlinesExist = (uint16)(*((uint32 *)pbySrc));
	pbySrc += sizeof( uint32 );

	/* Read ScanType state */

	key->usScanType = (uint16)(*((uint32 *)pbySrc));
	pbySrc += sizeof( uint32 );

	/* Read Glyph Index */

	outputPtr->glyphIndex = (uint16)(*((uint32 *)pbySrc));
	pbySrc += sizeof( uint32 );

	/* Read Size of Outline Cache  */

	outputPtr->outlineCacheSize = (uint16)(*((uint32 *)pbySrc));
	pbySrc += sizeof( uint32 );

	/* Read Gray Over Scale Factor  */

    key->usOverScale = (uint16)(*((uint32 *)pbySrc));
	outputPtr->usGrayLevels = key->usOverScale * key->usOverScale + 1;
	key->bGrayScale = (key->usOverScale == 0) ? FALSE : TRUE;
	pbySrc += sizeof( uint32 );

    /* Grid Fit Skipped Boolean  */

    key->bGridFitSkipped = (boolean)(*((uint32 *)pbySrc));
	pbySrc += sizeof( uint32 );

    /* No embedded bitmap Boolean  */

    key->bEmbeddedBitmap = (boolean)(*((uint32 *)pbySrc));
	pbySrc += sizeof( uint32 );

	/* Load fs_FindBitmapSize metrics */

	MEMCPY(&outputPtr->metricInfo, pbySrc, sizeof(metricsType));
	pbySrc += sizeof(metricsType);

	MEMCPY(&outputPtr->verticalMetricInfo, pbySrc, sizeof(verticalMetricsType));
	pbySrc += sizeof(verticalMetricsType);

	/* Load ScanConverter data structures */

	MEMCPY(&key->GBMap, pbySrc, sizeof(GlyphBitMap));
	pbySrc += sizeof(GlyphBitMap);

	MEMCPY(&key->OverGBMap, pbySrc, sizeof(GlyphBitMap));
	pbySrc += sizeof(GlyphBitMap);

	MEMCPY(&key->WScan, pbySrc, sizeof(WorkScan));
	pbySrc += sizeof(WorkScan);

	key->WScan.pchRBuffer = (char *)pbySrc;
	pbySrc += key->WScan.lRMemSize;

	fsg_RestoreContourData(
		&pbySrc,
		&outputPtr->xPtr,
		&outputPtr->yPtr,
		&outputPtr->startPtr,
		&outputPtr->endPtr,
		&outputPtr->onCurve,
		&outputPtr->fc,
		&outputPtr->numberOfContours);

	outputPtr->bitMapInfo.baseAddr = NULL;
	outputPtr->bitMapInfo.rowBytes = key->GBMap.sRowBytes;
	outputPtr->bitMapInfo.bounds.left = key->GBMap.rectBounds.left;
	outputPtr->bitMapInfo.bounds.right = key->GBMap.rectBounds.right;
	outputPtr->bitMapInfo.bounds.top = key->GBMap.rectBounds.bottom;   /* reversed! */
	outputPtr->bitMapInfo.bounds.bottom = key->GBMap.rectBounds.top;

	outputPtr->scaledCVT = NULL;
	outputPtr->numberOfBytesTaken = 0;

	key->usBandType = FS_BANDINGOLD;                    /* assume old banding */
	key->usBandWidth = 0;
    key->apbPrevMemoryBases[BITMAP_PTR_2] = NULL;       /* for fast/faster check */
    key->apbPrevMemoryBases[BITMAP_PTR_3] = NULL;

	key->bOutlineIsCached = TRUE;

	fs_SetState(key,(INITIALIZED | NEWSFNT | NEWTRANS | GOTINDEX | GOTGLYPH | SIZEKNOWN));
	return NO_ERR;
}

/*********************************************************************/

/* Calculate memory requirements for banding                         */

FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_FindBandingSize (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
{
	ErrorCode       error;
	fs_SplineKey *  key;
	uint8 *         pbyOutline;
	int16           sMaxOvershoot;
	int16           sHiOvershoot;
	int16           sLoOvershoot;
	GlyphBitMap *   pGBMap;             /* orig or over pointer */


	CHECKSTAMP (inputPtr->memoryBases[KEY_PTR_BASE] + outputPtr->memorySizes[KEY_PTR_BASE]);

	key = fs_SetUpKey(inputPtr, (INITIALIZED | NEWSFNT | NEWTRANS | GOTINDEX | GOTGLYPH | SIZEKNOWN), &error);
	if(!key)
	{
		return (FS_ENTRY)error;
	}

	if (key->bGridFitSkipped || key->bEmbeddedBitmap)
	{
		return SBIT_BANDING_ERR;                /* can't band sbits */
	}
	
	if( !key->bOutlineIsCached )
	{
		CHECKSTAMP (inputPtr->memoryBases[WORK_SPACE_BASE] + outputPtr->memorySizes[WORK_SPACE_BASE]);
		key->WScan.pchRBuffer = (char *)fsg_QueryReusableMemory(
			key->memoryBases[WORK_SPACE_BASE],
			&(key->WorkSpaceOffsets));
	}
	else
	{
		/* Unload the outline cache */

		pbyOutline = (uint8 *)inputPtr->param.band.outlineCache;

		if( *((uint32 *)pbyOutline) != OUTLINESTAMP )
		{
			  return TRASHED_OUTLINE_CACHE;
		}

		pbyOutline += sizeof( uint32 ) +
			  (BITMAP_MEMORY_COUNT * sizeof (FS_MEMORY_SIZE))  /* !!! Skip over stamp & 3 bitmap sizes */
			  + sizeof( uint32 )                      /* Outlines Exist (padded)  */
			  + sizeof( uint32 )                      /* Scan Type (padded)        */
			  + sizeof( uint32 )                      /* Glyph Index (padded)      */
			  + sizeof( uint32 )                      /* Outline Cache Size        */
			  + sizeof( uint32 )                      /* Gray Over Scale Factor    */
			  + sizeof( uint32 )                      /* Grid Fit Skipped Boolean  */
			  + sizeof( uint32 )                      /* no embedded bitmap Boolean*/
			  + sizeof( metricsType )                 /* Metrics information       */
			  + sizeof( verticalMetricsType )         /* Vert metrics information  */
			  + sizeof( GlyphBitMap )
			  + sizeof( GlyphBitMap )                 /* Over Scale structure      */
			  + sizeof( WorkScan );

		key->WScan.pchRBuffer = (char *)pbyOutline;

		/* No need to further unload outline cache */
	}

	pGBMap = &key->GBMap;                           /* default usual structure */
	key->usBandWidth = inputPtr->param.band.usBandWidth;
	key->usBandType = inputPtr->param.band.usBandType;

	if (key->bGrayScale)                                 /* if doing gray scale */
	{
		pGBMap = &key->OverGBMap;                   /* measure overscaled structure */
		key->usBandWidth *= key->usOverScale;
/*  
 *  Band width for the over scaled bitmap is basically just the requested band 
 *  width times the overscale factor.  However! if the gray scaled bounding 
 *  box has been trimmed to match the monochrome box (i.e. bMatchBBox = TRUE),
 *  then top and bottom bands must be made bigger to include the entire over
 *  scaled bitmap.  If this were not done it would break dropout control, and
 *  bitmaps would change with banding.  So that's why we do this messing around
 *  with overshoot in the key->usBandWidth calculation.
 */
		sMaxOvershoot = 0;
		sHiOvershoot = (int16)(key->OverGBMap.rectBounds.top -
					   key->GBMap.rectBounds.top * (int16)key->usOverScale);
		if (sHiOvershoot > sMaxOvershoot)
		{
			sMaxOvershoot = sHiOvershoot;
		}
		sLoOvershoot = (int16)(key->GBMap.rectBounds.bottom * (int16)key->usOverScale -
					   key->OverGBMap.rectBounds.bottom);
		if (sLoOvershoot > sMaxOvershoot)
		{
			sMaxOvershoot = sLoOvershoot;
		}
		key->usBandWidth += (uint16)sMaxOvershoot;
	}

	error = fsc_MeasureBand(
		pGBMap,                     /* orig or over scaled bounding box, etc. */
		&key->WScan,
		key->usBandType,
		key->usBandWidth,           /* worst case band width */
		key->usScanType );
	if (error != NO_ERR)
	{
		return(error);
	}

	if (key->bGrayScale)                                 /* if doing gray scale */
	{
		key->GBMap.lMMemSize = (int32)key->GBMap.sRowBytes * (int32)inputPtr->param.band.usBandWidth;
		outputPtr->memorySizes[BITMAP_PTR_4] = (FS_MEMORY_SIZE) key->OverGBMap.lMMemSize;
	}
	
	outputPtr->memorySizes[BITMAP_PTR_1] = (FS_MEMORY_SIZE) key->GBMap.lMMemSize;
	outputPtr->memorySizes[BITMAP_PTR_2] = (FS_MEMORY_SIZE) key->WScan.lHMemSize;
	outputPtr->memorySizes[BITMAP_PTR_3] = (FS_MEMORY_SIZE) key->WScan.lVMemSize;
	
	if( !key->bOutlineIsCached )
	{
		fsg_CheckWorkSpaceForFit(
			&(key->WorkSpaceOffsets),
			key->lExtraWorkSpace,
			key->WScan.lRMemSize,                             /* MeasureGlyph workspace */
			&(outputPtr->memorySizes[BITMAP_PTR_2]),
			&(outputPtr->memorySizes[BITMAP_PTR_3]));
	}

	CHECKSTAMP (inputPtr->memoryBases[KEY_PTR_BASE] + outputPtr->memorySizes[KEY_PTR_BASE]);
	if( !key->bOutlineIsCached )
	{
		CHECKSTAMP (inputPtr->memoryBases[WORK_SPACE_BASE] + outputPtr->memorySizes[WORK_SPACE_BASE]);
	}

	return NO_ERR;
}

/*********************************************************************/

#ifdef FSCFG_CONVERT_GRAY_LEVELS

// Tables to speed up bitmap translation from different GrayLevels.
uint8 Gray4To5Table[4]= {0,1,3,4};
uint8 Gray16To5Table[16]={0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4};

uint8 Gray4To17Table[4]= {0,5,11,16};
uint8 Gray16To17Table[16]={0,1,2,3,4,5,6,7,9,10,11,12,13,14,15,16};

uint8 Gray4To65Table[4]= {0,21,43,64};
uint8 Gray16To65Table[16]={0,4,9,13,17,21,26,30,34,38,43,47,51,55,60,64};

FS_PRIVATE FS_ENTRY  fs_ConvertGrayLevels (fs_GlyphInfoType *outputPtr, uint16 usOverScale, uint16 usBitDepth);

FS_PRIVATE FS_ENTRY  fs_ConvertGrayLevels (fs_GlyphInfoType *outputPtr, uint16 usOverScale, uint16 usBitDepth)
	{
	  uint16    index; // Gray level xlate table index
      switch (usOverScale) {
       case 2:
		   {
             uint32 i;
             uint32 bitmapSize=0;
             bitmapSize = (outputPtr->bitMapInfo.bounds.bottom - outputPtr->bitMapInfo.bounds.top)
                         *(outputPtr->bitMapInfo.rowBytes);

             switch (usBitDepth) {
             case 2:
                for (i=0 ; i<bitmapSize; i++) {
                    index=((outputPtr->bitMapInfo.baseAddr[i])&0x03);
                    outputPtr->bitMapInfo.baseAddr[i]=Gray4To5Table[index];
				} /* endfor */
                break;
             case 4:
                for (i=0 ; i<bitmapSize; i++) {
                    index=((outputPtr->bitMapInfo.baseAddr[i])&0x0f);
                    outputPtr->bitMapInfo.baseAddr[i]=Gray16To5Table[index];
				} /* endfor */            
                break;
             case 8:
                for (i=0 ; i<bitmapSize; i++) {
                    index=((outputPtr->bitMapInfo.baseAddr[i])>>4);
                    outputPtr->bitMapInfo.baseAddr[i]=Gray16To5Table[index];
				} /* endfor */
                break;

             default:
                  return BAD_GRAY_LEVEL_ERR;
          
             } /* endswitch */
		   }
          break;
       case 4:
		   {
             uint32 i;
             uint32 bitmapSize=0;
             bitmapSize = (outputPtr->bitMapInfo.bounds.bottom - outputPtr->bitMapInfo.bounds.top)
                         *(outputPtr->bitMapInfo.rowBytes);

             switch (usBitDepth) {
             case 2:
                for (i=0 ; i<bitmapSize; i++) {
                    index=((outputPtr->bitMapInfo.baseAddr[i])&0x03);
                    outputPtr->bitMapInfo.baseAddr[i]=Gray4To17Table[index];
				} /* endfor */
                break;
             case 4:
                for (i=0 ; i<bitmapSize; i++) {
                    index=((outputPtr->bitMapInfo.baseAddr[i])&0x0f);
                    outputPtr->bitMapInfo.baseAddr[i]=Gray16To17Table[index];
				} /* endfor */            
                break;
             case 8:
                for (i=0 ; i<bitmapSize; i++) {
                    index=((outputPtr->bitMapInfo.baseAddr[i])>>4);
                    outputPtr->bitMapInfo.baseAddr[i]=Gray16To17Table[index];
				} /* endfor */
                break;

             default:
                  return BAD_GRAY_LEVEL_ERR;
          
			 } /* endswitch */
		   }
          break;
       case 8:
		   {
             uint32 i;
             uint32 bitmapSize=0;
             bitmapSize = (outputPtr->bitMapInfo.bounds.bottom - outputPtr->bitMapInfo.bounds.top)
                         *(outputPtr->bitMapInfo.rowBytes);

             switch (usBitDepth) {
             case 2:
                for (i=0 ; i<bitmapSize; i++) {
                    index=((outputPtr->bitMapInfo.baseAddr[i])&0x03);
                    outputPtr->bitMapInfo.baseAddr[i]=Gray4To65Table[index];
				} /* endfor */
                break;
             case 4:
                for (i=0 ; i<bitmapSize; i++) {
                    index=((outputPtr->bitMapInfo.baseAddr[i])&0x0f);
                    outputPtr->bitMapInfo.baseAddr[i]=Gray16To65Table[index];
				} /* endfor */            
                break;
             case 8:
                for (i=0 ; i<bitmapSize; i++) {
                    index=((outputPtr->bitMapInfo.baseAddr[i])>>4);
                    outputPtr->bitMapInfo.baseAddr[i]=Gray16To65Table[index];
				} /* endfor */
                break;

             default:
                  return BAD_GRAY_LEVEL_ERR;
          
			 } /* endswitch */
		   }
          break;

       default:
               return BAD_GRAY_LEVEL_ERR;
       } /* endswitch */
	   return NO_ERR;

    } /* end if bGrayScale */

#endif // FSCFG_CONVERT_GRAY_LEVELS

/* Generate a bitmap                                                 */

FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_ContourScan (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
{    
	ContourList     CList;        /* newscan contour list type */
	fs_SplineKey *  key;
	char *          pBitmapPtr2;
	char *          pBitmapPtr3;
	uint8 *         pbyOutline;
	ErrorCode       error;
	GlyphBitMap *   pGBMap;             /* orig or over pointer */


	CHECKSTAMP (inputPtr->memoryBases[KEY_PTR_BASE] + outputPtr->memorySizes[KEY_PTR_BASE]);

	STAT_ON_SCAN;                    /* start STAT timer */

	key = fs_SetUpKey(inputPtr, (INITIALIZED | NEWSFNT | NEWTRANS | GOTINDEX | GOTGLYPH | SIZEKNOWN), &error);
	if(!key)
	{
		return (FS_ENTRY)error;
	}

	if( !key->bOutlineIsCached )                /* if outline or embedded bitmap */
	{
		CHECKSTAMP (inputPtr->memoryBases[WORK_SPACE_BASE] + outputPtr->memorySizes[WORK_SPACE_BASE]);

		if(key->apbPrevMemoryBases[WORK_SPACE_BASE] != key->memoryBases[WORK_SPACE_BASE])
		{
			fsg_UpdateWorkSpaceAddresses(
				 key->memoryBases[WORK_SPACE_BASE],
				 &(key->WorkSpaceOffsets),
				 &(key->pWorkSpaceAddr));

			fsg_UpdateWorkSpaceElement(
				 &(key->WorkSpaceOffsets),
				 &(key->pWorkSpaceAddr));

			key->apbPrevMemoryBases[WORK_SPACE_BASE] = key->memoryBases[WORK_SPACE_BASE];
		}

		fsg_SetUpWorkSpaceBitmapMemory(
			key->memoryBases[WORK_SPACE_BASE],
			&(key->WorkSpaceOffsets),
			key->memoryBases[BITMAP_PTR_2],
			key->memoryBases[BITMAP_PTR_3],
			&pBitmapPtr2,                       /* sbits may need Ptr2 */
			&pBitmapPtr3);

        /* check for embedded bitmap, quick return if found */

#ifdef FSCFG_SUBPIXEL
	    if (key->bEmbeddedBitmap && !(key->flSubPixel & FNT_SP_SUB_PIXEL))  				/* if bitmap are not disabled */
#else
	    if (key->bEmbeddedBitmap)  				/* if bitmap are not disabled */
#endif // FSCFG_SUBPIXEL	
    	{
    		if ((inputPtr->param.scan.topClip > inputPtr->param.scan.bottomClip) &&  /* if legal band */
               ((inputPtr->param.scan.topClip < key->GBMap.rectBounds.top) ||
                (inputPtr->param.scan.bottomClip > key->GBMap.rectBounds.bottom)))
    		{
        		return SBIT_BANDING_ERR;            /* can't band sbits */
            }

    		error = sbit_GetBitmap (
    			&key->SbitMono,
    			&key->ClientInfo,
    			(uint8 *) inputPtr->memoryBases[BITMAP_PTR_1],
    			(uint8 *) pBitmapPtr2 );
		
    		if (error != NO_ERR)
    		{
    			return((FS_ENTRY)error);
    		}
        	outputPtr->bitMapInfo.baseAddr = key->memoryBases[BITMAP_PTR_1];  /* return bitmap addr */

        	CHECKSTAMP (inputPtr->memoryBases[KEY_PTR_BASE] + outputPtr->memorySizes[KEY_PTR_BASE]);
       		CHECKSTAMP (inputPtr->memoryBases[WORK_SPACE_BASE] + outputPtr->memorySizes[WORK_SPACE_BASE]);

        	STAT_OFF_SCAN;                  /* stop STAT timer */

#ifdef FSCFG_CONVERT_GRAY_LEVELS
			if (key->bGrayScale)
			{
				error = fs_ConvertGrayLevels (outputPtr, key->usOverScale, key->SbitMono.usBitDepth);
			
				if(error)
				{
					return (FS_ENTRY)error;
				}
			} /* end if bGrayScale */
#endif // FSCFG_CONVERT_GRAY_LEVELS

        	return NO_ERR;                  /* return now with an sbit */
    	}
        else        /* if scan converting an outline */
        {
			fsg_GetWorkSpaceExtra(
				key->memoryBases[WORK_SPACE_BASE],
				&(key->WorkSpaceOffsets),
				&(key->WScan.pchRBuffer));

			fsg_GetContourData(
				&key->pWorkSpaceAddr,
#ifdef FSCFG_SUBPIXEL
				FALSE,            
#endif // FSCFG_SUBPIXEL
				&CList.afxXCoord,
				&CList.afxYCoord,
				&CList.asStartPoint,
				&CList.asEndPoint,
				&CList.abyOnCurve,
				&CList.abyFc,
				&CList.usContourCount);
        }
    }
    else            /* Unload the outline cache */
	{
		pbyOutline = (uint8 *)inputPtr->param.scan.outlineCache;

		if( *((uint32 *)pbyOutline) != OUTLINESTAMP )
		{
			 return TRASHED_OUTLINE_CACHE;
		}

		pbyOutline += sizeof( uint32 ) +
			(BITMAP_MEMORY_COUNT * sizeof (FS_MEMORY_SIZE))  /* !!! Skip over stamp & 3 bitmap sizes */
			+ sizeof( uint32 )                      /* Outlines Exist (padded)  */
			+ sizeof( uint32 )                      /* Scan Type (padded)        */
			+ sizeof( uint32 )                      /* Glyph Index (padded)      */
			+ sizeof( uint32 )                      /* Outline Cache Size        */
			+ sizeof( uint32 )                      /* Gray Over Scale Factor    */
	        + sizeof( uint32 )                      /* Grid Fit Skipped Boolean  */
	        + sizeof( uint32 )                      /* no embedded bitmap Boolean*/
			+ sizeof( metricsType )                 /* Metrics information       */
			+ sizeof( verticalMetricsType )         /* Vert metrics information  */
			+ sizeof( GlyphBitMap )
			+ sizeof( GlyphBitMap )                 /* Over Scale structure      */
			+ sizeof( WorkScan );

		key->WScan.pchRBuffer = (char *)pbyOutline;
		pbyOutline += key->WScan.lRMemSize;

		fsg_RestoreContourData(
			&pbyOutline,
			&CList.afxXCoord,
			&CList.afxYCoord,
			&CList.asStartPoint,
			&CList.asEndPoint,
			&CList.abyOnCurve,
			&CList.abyFc,
			&CList.usContourCount);

		if( *((uint32 *)pbyOutline) != OUTLINESTAMP2 )
		{
			return TRASHED_OUTLINE_CACHE;
		}

		pBitmapPtr2 = key->memoryBases[BITMAP_PTR_2];
		pBitmapPtr3 = key->memoryBases[BITMAP_PTR_3];
	}

	if (pBitmapPtr3 == NULL)  /* Allow client to turn off DOControl */
	{
		key->usScanType = SK_NODROPOUT;
	}

	key->GBMap.pchBitMap = inputPtr->memoryBases[BITMAP_PTR_1];
	key->GBMap.sHiBand = inputPtr->param.scan.topClip;
	key->GBMap.sLoBand = inputPtr->param.scan.bottomClip;

	if (key->GBMap.sHiBand <= key->GBMap.sLoBand)            /* if negative or no band */
	{
		key->GBMap.sHiBand = key->GBMap.rectBounds.top;     /* then for Apple compatiblity */
		key->GBMap.sLoBand = key->GBMap.rectBounds.bottom;  /* do the entire bitmap */
	}
	if (key->GBMap.sHiBand > key->GBMap.rectBounds.top)
	{
		key->GBMap.sHiBand = key->GBMap.rectBounds.top;     /* clip to bounding box */
	}
	if (key->GBMap.sLoBand < key->GBMap.rectBounds.bottom)
	{
		key->GBMap.sLoBand = key->GBMap.rectBounds.bottom;  /* clip to bounding box */
	}
		 
	if ((key->usBandType == FS_BANDINGFASTER) &&
		((key->apbPrevMemoryBases[BITMAP_PTR_2] != pBitmapPtr2) ||
		 (key->apbPrevMemoryBases[BITMAP_PTR_3] != pBitmapPtr3)))
	{
		 key->usBandType = FS_BANDINGFAST;  /* to recalculate memory */
	}

	if (key->usBandType == FS_BANDINGOLD)   /* if FindGrayBandingSize wasn't called */
	{
		if ((key->GBMap.sHiBand != key->GBMap.rectBounds.top) ||
			(key->GBMap.sLoBand != key->GBMap.rectBounds.bottom))   /* if banding */
		{
			if (key->bGrayScale)
			{
				return GRAY_OLD_BANDING_ERR;        /* gray scale fails with old banding */
			}
			key->usScanType = SK_NODROPOUT;         /* else force dropout off */
		}
	}
	else if (key->usBandType == FS_BANDINGSMALL)  /* if small mem type */
	{
		if (key->bGrayScale)
		{
			if (key->usOverScale *(key->GBMap.sHiBand - key->GBMap.sLoBand) > (int16)key->usBandWidth)
			{
				return BAND_TOO_BIG_ERR;          /* don't let band exceed calc'd size */
			}
		} else {
			if (key->GBMap.sHiBand - key->GBMap.sLoBand > (int16)key->usBandWidth)
			{
				return BAND_TOO_BIG_ERR;          /* don't let band exceed calc'd size */
			}
		}
		key->usScanType = SK_NODROPOUT;       /* turn off dropout control */
	}
	pGBMap = &key->GBMap;                     /* default to usual structure */
	
	if (key->bGrayScale)
	{
		pGBMap = &key->OverGBMap;             /* measure overscaled structure */
		
		if (key->GBMap.sHiBand == key->GBMap.rectBounds.top)            /* if gray band at top */
		{
			key->OverGBMap.sHiBand = key->OverGBMap.rectBounds.top;     /* use over top */
		}
		else
		{
			key->OverGBMap.sHiBand = (int16)(key->GBMap.sHiBand * (int16)key->usOverScale);
			if (key->OverGBMap.sHiBand > key->OverGBMap.rectBounds.top)
			{
				key->OverGBMap.sHiBand = key->OverGBMap.rectBounds.top; /* clip */
			}
		}
		if (key->GBMap.sLoBand == key->GBMap.rectBounds.bottom)         /* if gray band at bottom */
		{
			key->OverGBMap.sLoBand = key->OverGBMap.rectBounds.bottom;  /* use over bottom */
		}
		else
		{
			key->OverGBMap.sLoBand = (int16)(key->GBMap.sLoBand * (int16)key->usOverScale);
			if (key->OverGBMap.sLoBand < key->OverGBMap.rectBounds.bottom)
			{
				key->OverGBMap.sLoBand = key->OverGBMap.rectBounds.bottom;  /* clip */
			}
		}
		key->OverGBMap.pchBitMap = inputPtr->memoryBases[BITMAP_PTR_4];
	}
#ifdef FSCFG_SUBPIXEL
	if ((key->flSubPixel & FNT_SP_SUB_PIXEL))
	{
		pGBMap = &key->OverGBMap;             /* draw into the overscaled structure */

	    key->OverGBMap.pchBitMap = inputPtr->memoryBases[BITMAP_PTR_4];

        /* no banding yet !!! */
	    key->OverGBMap.sHiBand = key->OverGBMap.rectBounds.top;
	    key->OverGBMap.sLoBand = key->OverGBMap.rectBounds.bottom;
    }
#endif // FSCFG_SUBPIXEL

	key->WScan.pchHBuffer = pBitmapPtr2;
	key->WScan.pchVBuffer = pBitmapPtr3;

	error = fsc_FillGlyph(
		&CList,
		pGBMap,
		&key->WScan,
		key->usBandType,
		key->usScanType
		);
	if (error != NO_ERR)
	{
		return(error);
	}
	 
	if (key->bGrayScale)
	{
		error = fsc_CalcGrayMap(
			&key->OverGBMap, 
			&key->GBMap, 
			key->usOverScale
			);
		if (error != NO_ERR)
		{
			return((FS_ENTRY)error);
		}
	}

#ifdef FSCFG_SUBPIXEL
	if ((key->flSubPixel & FNT_SP_SUB_PIXEL))
	{
#ifdef FSCFG_SUBPIXEL_STANDALONE // B.St.
		outputPtr->overscaledBitmapInfo.baseAddr = key->OverGBMap.pchBitMap;
		outputPtr->overscaledBitmapInfo.rowBytes = key->OverGBMap.sRowBytes;
		outputPtr->overscaledBitmapInfo.bounds = key->OverGBMap.rectBounds; // save for more detailed processing
#endif
        fsc_OverscaleToSubPixel (&key->OverGBMap, (key->flSubPixel & FNT_SP_BGR_ORDER) > 0, &key->GBMap);
	}
#endif // FSCFG_SUBPIXEL

	if (key->bBitmapEmboldening)
	{
		if (key->bGrayScale)
		{
			uint16 usGrayLevels = key->usOverScale * key->usOverScale + 1;
			sbit_EmboldenGray((uint8 *)key->GBMap.pchBitMap, (uint16)(key->GBMap.rectBounds.right - key->GBMap.rectBounds.left), 
						  (uint16)(key->GBMap.sHiBand - key->GBMap.sLoBand), key->GBMap.sRowBytes,usGrayLevels, key->sBoldSimulHorShift, key->sBoldSimulVertShift);
		} 
#ifdef FSCFG_SUBPIXEL
		else if ((key->flSubPixel & FNT_SP_SUB_PIXEL))
		{
			sbit_EmboldenSubPixel((uint8 *)key->GBMap.pchBitMap, (uint16)(key->GBMap.rectBounds.right - key->GBMap.rectBounds.left), 
						  (uint16)(key->GBMap.sHiBand - key->GBMap.sLoBand), key->GBMap.sRowBytes, key->sBoldSimulHorShift, key->sBoldSimulVertShift);
		} 
#endif // FSCFG_SUBPIXEL
		else 
		{
			sbit_Embolden((uint8 *)pGBMap->pchBitMap, (uint16)(pGBMap->rectBounds.right - pGBMap->rectBounds.left), 
						  (uint16)(pGBMap->sHiBand - pGBMap->sLoBand), pGBMap->sRowBytes, key->sBoldSimulHorShift, key->sBoldSimulVertShift);
		}
	}

/*  Setting the Band Type to FS_BANDINGFASTER will allow the next call      */
/*  to fsc_FillGlyph to skip the rendering phase of scan conversion and     */
/*  get right to the bitmap fill.  If the client moves either memoryBase[6] */ 
/*  or memoryBase[7] between fs_ContourScan calls, then we must reset the   */
/*  band type to FS_BANDINGFAST to regenerate the data structures.          */

	if (key->usBandType == FS_BANDINGFAST)
	{
		key->usBandType = FS_BANDINGFASTER;    /* to save re-rendering */
		key->apbPrevMemoryBases[BITMAP_PTR_2] = pBitmapPtr2;
		key->apbPrevMemoryBases[BITMAP_PTR_3] = pBitmapPtr3;
	}

	outputPtr->bitMapInfo.baseAddr = key->memoryBases[BITMAP_PTR_1];  /* return bitmap addr */

	CHECKSTAMP (inputPtr->memoryBases[KEY_PTR_BASE] + outputPtr->memorySizes[KEY_PTR_BASE]);
	if( !key->bOutlineIsCached )
	{
		CHECKSTAMP (inputPtr->memoryBases[WORK_SPACE_BASE] + outputPtr->memorySizes[WORK_SPACE_BASE]);
	}

	STAT_OFF_SCAN;                /* stop STAT timer */

	return NO_ERR;
}

/*********************************************************************/

FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_CloseFonts (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
{
	FS_UNUSED_PARAMETER(inputPtr);
	FS_UNUSED_PARAMETER(outputPtr);
	return NO_ERR;
}

#ifdef  FSCFG_NO_INITIALIZED_DATA
FS_PUBLIC  void FS_ENTRY_PROTO fs_InitializeData (void)
	{
		fsg_InitializeData ();
	}
#endif



/*********************************************************************/

/* fs_GetScaledAdvanceWidths returns only horizontal advance widths and is not meant to be used under rotation */

FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_GetScaledAdvanceWidths (
	fs_GlyphInputType * inputPtr,
	uint16              usFirstGlyph,
	uint16              usLastGlyph,
	int16 *             psGlyphWidths)
{
	fs_SplineKey *      key;
	void *              pvGlobalGS;
	void *              pvStack;
	void *              pvFontProgram;
	void *              pvPreProgram;
	void *              pvTwilightZone;
	uint16              usCurrentGlyphIndex;
	uint16              usGlyphIndex;
	uint16              usPPEm;
	int16               sNonScaledLSB;
	vectorType          fxGlyphWidth;
	point               f26DevAdvanceWidth;
	boolean             bHdmxEntryExist;
	boolean             bBitmapFound;
	ErrorCode           error;
#ifdef FSCFG_SUBPIXEL	
	boolean             bSubPixelWidth = FALSE;
    fsg_TransformRec *  TransformInfoForGridFit;
	void *              pvGlobalGSSubPixel;
	void *              pvTwilightZoneSubPixel;
#endif // FSCFG_SUBPIXEL

	key = fs_SetUpKey(inputPtr, (INITIALIZED | NEWSFNT | NEWTRANS ), &error);

	if(!key)
	{
		return (FS_ENTRY)error;
	}

	if((key->apbPrevMemoryBases[WORK_SPACE_BASE] != key->memoryBases[WORK_SPACE_BASE]) ||
	   (key->apbPrevMemoryBases[PRIVATE_FONT_SPACE_BASE] != key->memoryBases[PRIVATE_FONT_SPACE_BASE]))
	{
		fsg_UpdateWorkSpaceAddresses(
			key->memoryBases[WORK_SPACE_BASE],
			&(key->WorkSpaceOffsets),
			&(key->pWorkSpaceAddr));

		pvStack = fsg_QueryStack(&key->pWorkSpaceAddr);

		fsg_UpdatePrivateSpaceAddresses(
			&key->ClientInfo,
			&key->maxProfile,
			key->memoryBases[PRIVATE_FONT_SPACE_BASE],
			&(key->PrivateSpaceOffsets),
			pvStack,
			&pvFontProgram,
			&pvPreProgram);

		MEMCPY(key->apbPrevMemoryBases, key->memoryBases, sizeof(char *) * (size_t)MEMORYFRAGMENTS);
	}

	pvGlobalGS = fsg_QueryGlobalGS(
		key->memoryBases[PRIVATE_FONT_SPACE_BASE],
		&(key->PrivateSpaceOffsets));

	/*  Initialization  */

	bHdmxEntryExist = FALSE;

#ifdef FSCFG_SUBPIXEL	
	if ( (key->flSubPixel & FNT_SP_SUB_PIXEL) && !(key->flSubPixel & FNT_SP_COMPATIBLE_WIDTH) ) 
    {
        bSubPixelWidth = TRUE;
    }
#endif // FSCFG_SUBPIXEL	

	/*  Save current glyph index    */

	usCurrentGlyphIndex = key->ClientInfo.usGlyphIndex;

	/*  Check input parameters  */

	if( (usLastGlyph > key->maxProfile.numGlyphs ) ||
		(usLastGlyph < usFirstGlyph))
	{
		return INVALID_GLYPH_INDEX;
	}

	if( psGlyphWidths == NULL )
	{
		return NULL_INPUT_PTR_ERR;
	}

	/*  Find our current PPEm   */

	fsg_QueryPPEM(pvGlobalGS, &usPPEm);
	/* Only Grab 'hdmx' if not stretched or rotated */

#ifdef FSCFG_SUBPIXEL	
    /* for SubPixel, use Hdmx width only if we are in compatible width mode */
	if( !bSubPixelWidth &&
	    (!fsg_IsTransformStretched( &key->TransformInfo )) &&
		(!fsg_IsTransformRotated( &key->TransformInfo )) )
#else
	if( (!fsg_IsTransformStretched( &key->TransformInfo )) &&
		(!fsg_IsTransformRotated( &key->TransformInfo )) )
#endif // FSCFG_SUBPIXEL	
	{

		/*  Check if we can quickly grab the widths from the 'hdmx' table   */

		error = sfac_CopyHdmxEntry(
			&key->ClientInfo,
			usPPEm,
			&bHdmxEntryExist,
			usFirstGlyph,
			usLastGlyph,
			psGlyphWidths);

		if (error != NO_ERR)
		{
			return(error);
		}

		/* If we got a hit on the 'hdmx' we are done    */

		if( bHdmxEntryExist )
		{
			return NO_ERR;
		}
	}

	/* No hit on 'hmdx', now it is time for the dirty work  */

	/* We need to prepare ourselves here for a potential grid fit */

	fsg_UpdateWorkSpaceElement(
		&(key->WorkSpaceOffsets),
		&(key->pWorkSpaceAddr));

	pvTwilightZone = fsg_QueryTwilightElement(
		key->memoryBases[PRIVATE_FONT_SPACE_BASE],
		&(key->PrivateSpaceOffsets));

#ifdef FSCFG_SUBPIXEL
    TransformInfoForGridFit = &key->TransformInfo;
	if ((key->flSubPixel & FNT_SP_COMPATIBLE_WIDTH))
    {
	    pvGlobalGSSubPixel = fsg_QueryGlobalGSSubPixel(
		    key->memoryBases[PRIVATE_FONT_SPACE_BASE],
		    &(key->PrivateSpaceOffsets));
	    pvTwilightZoneSubPixel = fsg_QueryTwilightElementSubPixel(
		    key->memoryBases[PRIVATE_FONT_SPACE_BASE],
		    &(key->PrivateSpaceOffsets));
    }
#endif // FSCFG_SUBPIXEL

    /*  potentially do delayed pre program execution */

	if (key->bExecutePrePgm)
	{
		/* Run the pre program and scale the control value table */

		key->bExecutePrePgm = FALSE;

		error = fsg_RunPreProgram (
			&key->ClientInfo,
			&key->maxProfile,
			&key->TransformInfo,
			pvGlobalGS,
			&key->pWorkSpaceAddr,
			pvTwilightZone,
			NULL);

		if(error)
		{
			/* If the pre-program fails, prevent further glyphs from being called */
			fs_SetState(key, (INITIALIZED | NEWSFNT));

			/* If the pre-program fails, switch off hinting for further glyphs */
			key->bHintingEnabled = FALSE;
			return (FS_ENTRY)error;
		}
#ifdef FSCFG_SUBPIXEL	
	    if ((key->flSubPixel & FNT_SP_COMPATIBLE_WIDTH))
        {
		    error = fsg_RunPreProgram (
			    &key->ClientInfo,
			    &key->maxProfile,
			    &key->TransformInfoSubPixel,
			    pvGlobalGSSubPixel,
			    &key->pWorkSpaceAddr,
			    pvTwilightZoneSubPixel,
			    NULL);

		    if(error)
		    {
			    /* If the pre-program fails, prevent further glyphs from being called */
			    fs_SetState(key, (INITIALIZED | NEWSFNT));

                /* If the pre-program fails, switch off hinting for further glyphs */
			    key->bHintingEnabled = FALSE;
			    return (FS_ENTRY)error;
		    }
	    }
#endif // FSCFG_SUBPIXEL	
	}

	/*  Now check 'LTSH' table for linear cutoff information    */

	error = sfac_GetLTSHEntries(
		&key->ClientInfo,
		usPPEm,
		usFirstGlyph,
		usLastGlyph,
		psGlyphWidths);

	/* The pfxGlyphWidths array contains a boolean for each glyph (from     */
	/* first glyph to last glyph) that indicates if the glyph scales        */
	/* linearly.                                                            */

	/* Handle each glyph    */

	for( usGlyphIndex = usFirstGlyph; usGlyphIndex <= usLastGlyph; usGlyphIndex++)
	{
#ifdef FSCFG_SUBPIXEL
        /* for SubPixel, use linear width only if we are in compatible width mode */
		if( !bSubPixelWidth &&
            (psGlyphWidths[usGlyphIndex - usFirstGlyph]) &&
			(!fsg_IsTransformStretched( &key->TransformInfo )) &&
			(!fsg_IsTransformRotated( &key->TransformInfo )) )
#else
		if( (psGlyphWidths[usGlyphIndex - usFirstGlyph]) &&
			(!fsg_IsTransformStretched( &key->TransformInfo )) &&
			(!fsg_IsTransformRotated( &key->TransformInfo )) )
#endif // FSCFG_SUBPIXEL	
		{
			/* Glyph Scales Linearly    */


		error = sfac_ReadGlyphHorMetrics (
				&key->ClientInfo,
				usGlyphIndex,
				&key->usNonScaledAW,
				&sNonScaledLSB);

			if(error)
			{
				return (FS_ENTRY)error;
			}

			fsg_UpdateAdvanceWidth (
				&key->TransformInfo,
				pvGlobalGS,
				key->usNonScaledAW,
				&fxGlyphWidth);

			psGlyphWidths[usGlyphIndex - usFirstGlyph] = (int16)((fxGlyphWidth.x + ONEHALFFIX) >> 16);
		}
		else    /* Glyph does not scale linearly */
		{
			error = LookForSbitAdvanceWidth (
				key, 
				usGlyphIndex, 
				&bBitmapFound, 
				&f26DevAdvanceWidth );          /* value returned if found */
			
			if(error)
			{
				return (FS_ENTRY)error;
			}

			if (bBitmapFound == FALSE)
			{
				/* Glyph needs to be grid fitted */

				key->ClientInfo.usGlyphIndex = usGlyphIndex;

				error = fsg_GridFit (
					&key->ClientInfo,
					&key->maxProfile,
					&key->TransformInfo,
					pvGlobalGS,
					&key->pWorkSpaceAddr,
					pvTwilightZone,
					(FntTraceFunc)NULL,
					TRUE,
					&key->usScanType,
					&key->bGlyphHasOutline,
					&key->usNonScaledAW,
					key->bBitmapEmboldening
#ifdef FSCFG_SUBPIXEL
	                ,bSubPixelWidth
#endif // FSCFG_SUBPIXEL
					);

				if(error)
				{
					return (FS_ENTRY)error;
				}

				fsg_GetDevAdvanceWidth (
					&key->pWorkSpaceAddr,
					&f26DevAdvanceWidth );
#ifdef FSCFG_SUBPIXEL
                if (bSubPixelWidth)
                /* we need to scale the value downs from hinting overscale */
                {
                    ROUND_FROM_HINT_OVERSCALE(f26DevAdvanceWidth.x);
                }
#endif // FSCFG_SUBPIXEL
			}
			psGlyphWidths[(size_t)(usGlyphIndex - usFirstGlyph)] = (int16)((f26DevAdvanceWidth.x + DOT6ONEHALF) >> 6);
		}
	}

	/* Restore current glyph    */

	key->ClientInfo.usGlyphIndex = usCurrentGlyphIndex;
	
	return NO_ERR;
}

/*********************************************************************/

/*                  Vertical Metrics Helper Function                 */

/*            returns AdvanceHeight vectors for glyph range          */

/*********************************************************************/

FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_GetScaledAdvanceHeights (
	fs_GlyphInputType * inputPtr,
	uint16              usFirstGlyph,
	uint16              usLastGlyph,
	shortVector *       psvAdvanceHeights)
{
	fs_SplineKey *      key;
	void *              pvGlobalGS;
	void *              pvFontProgram;
	void *              pvPreProgram;
	void *              pvStack;
	uint16              usGlyphIndex;
	uint16              usPPEm;
    uint16              usNonScaledAH;              /* advance height from vmtx */
	int16               sNonScaledTSB;              /* top side bearing from vmtx, not used */
	shortVector		    svDevAdvanceHeight;         /* advance height from sbits */
	vectorType			vecAdvanceHeight;
	vectorType			vecTopSideBearing;			/* not used */
	point               f26DevAdvanceHeight;
	boolean             bBitmapFound;
	ErrorCode           error;

	key = fs_SetUpKey(inputPtr, (INITIALIZED | NEWSFNT | NEWTRANS ), &error);

	if(!key)
	{
		return (FS_ENTRY)error;
	}

	if((key->apbPrevMemoryBases[WORK_SPACE_BASE] != key->memoryBases[WORK_SPACE_BASE]) ||
	   (key->apbPrevMemoryBases[PRIVATE_FONT_SPACE_BASE] != key->memoryBases[PRIVATE_FONT_SPACE_BASE]))
	{
		fsg_UpdateWorkSpaceAddresses(
			key->memoryBases[WORK_SPACE_BASE],
			&(key->WorkSpaceOffsets),
			&(key->pWorkSpaceAddr));

		pvStack = fsg_QueryStack(&key->pWorkSpaceAddr);

		fsg_UpdatePrivateSpaceAddresses(
			&key->ClientInfo,
			&key->maxProfile,
			key->memoryBases[PRIVATE_FONT_SPACE_BASE],
			&(key->PrivateSpaceOffsets),
			pvStack,
			&pvFontProgram,
			&pvPreProgram);

		MEMCPY(key->apbPrevMemoryBases, key->memoryBases, sizeof(char *) * (size_t)MEMORYFRAGMENTS);
	}

	pvGlobalGS = fsg_QueryGlobalGS(
		key->memoryBases[PRIVATE_FONT_SPACE_BASE],
		&(key->PrivateSpaceOffsets));

	/*  Check input parameters  */

	if( (usLastGlyph > key->maxProfile.numGlyphs ) ||
		(usLastGlyph < usFirstGlyph))
	{
		return INVALID_GLYPH_INDEX;
	}

	if( psvAdvanceHeights == NULL )
	{
		return NULL_INPUT_PTR_ERR;
	}

	/*  Find our current PPEm   */

	fsg_QueryPPEM(pvGlobalGS, &usPPEm);

	/* Handle each glyph    */

	for( usGlyphIndex = usFirstGlyph; usGlyphIndex <= usLastGlyph; usGlyphIndex++)
	{
		error = LookForSbitAdvanceHeight (
				key, 
				usGlyphIndex, 
				&bBitmapFound, 
				&f26DevAdvanceHeight);           /* values returned if found */

		if(error)
		{
			return (FS_ENTRY)error;
		}

		if (bBitmapFound)                      /*   if bitmap metrics found */
		{
			svDevAdvanceHeight.x = (int16)((f26DevAdvanceHeight.x + DOT6ONEHALF) >> 6);
			svDevAdvanceHeight.y = (int16)((f26DevAdvanceHeight.y + DOT6ONEHALF) >> 6);
		}
		else        /* if (bBitmapFound == FALSE)   if no bitmap, read vmtx */
		{
			error = sfac_ReadGlyphVertMetrics (
				&key->ClientInfo,
				usGlyphIndex,
				&usNonScaledAH,
				&sNonScaledTSB);

			if(error)
			{
				return (FS_ENTRY)error;
			}

			fsg_ScaleVerticalMetrics (
				&key->TransformInfo,
				pvGlobalGS,
				usNonScaledAH,
				sNonScaledTSB,
				&vecAdvanceHeight,
				&vecTopSideBearing);

			svDevAdvanceHeight.x = (int16)((vecAdvanceHeight.x + ONEHALFFIX) >> 16);
			svDevAdvanceHeight.y = (int16)((vecAdvanceHeight.y + ONEHALFFIX) >> 16);
		}
    	
    	*psvAdvanceHeights++ = svDevAdvanceHeight;
	}

	return NO_ERR;
}

/*********************************************************************/

/*  Look for an embedded bitmap, if found return the advance width */

FS_PRIVATE FS_ENTRY LookForSbitAdvanceWidth(
	fs_SplineKey *key,
	uint16 usGlyphIndex, 
	boolean *pbBitmapFound, 
	point *pf26DevAdvanceWidth )
{
	uint16      usFoundCode;
	ErrorCode   error;
	uint16		usBitDepth;			/* 1 for B/W bitmap, 2, 4 or 8 for gray sbit */
	
	*pbBitmapFound = FALSE;                 /* default value */

	error = sbit_SearchForBitmap(
		&key->SbitMono,
		&key->ClientInfo,
		usGlyphIndex, 
		key->usOverScale,
		&usBitDepth,
		&usFoundCode );

	if (error)
	{
		return (FS_ENTRY)error;
	}

	if (usFoundCode != 0)
	{
		error = sbit_GetDevAdvanceWidth (
			&key->SbitMono,
			&key->ClientInfo,
			pf26DevAdvanceWidth );
		
		if (error)
		{
			return (FS_ENTRY)error;
		}
		*pbBitmapFound = TRUE;
	}
	return NO_ERR;
}

/*********************************************************************/

/*  Look for an embedded bitmap, if found return the advance height */

FS_PRIVATE FS_ENTRY LookForSbitAdvanceHeight(
	fs_SplineKey *key,
	uint16 usGlyphIndex, 
	boolean *pbBitmapFound, 
	point *pf26DevAdvanceHeight )
{
	uint16      usFoundCode;
	ErrorCode   error;
	uint16		usBitDepth;			/* 1 for B/W bitmap, 2, 4 or 8 for gray sbit */
	
	*pbBitmapFound = FALSE;                 /* default value */

	error = sbit_SearchForBitmap(
		&key->SbitMono,
		&key->ClientInfo,
		usGlyphIndex, 
		key->usOverScale,
		&usBitDepth,
		&usFoundCode );

	if (error)
	{
		return (FS_ENTRY)error;
	}

	if (usFoundCode != 0)
	{
		error = sbit_GetDevAdvanceHeight (
			&key->SbitMono,
			&key->ClientInfo,
        	pf26DevAdvanceHeight);
		
		if (error)
		{
			return (FS_ENTRY)error;
		}
		*pbBitmapFound = TRUE;
	}
	return NO_ERR;
}


/*********************************************************************/

/*              Char Code to Glyph ID Helper Function                */

/*      returns glyph IDs for array or range of character codes      */

/*********************************************************************/

extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_GetGlyphIDs (
	fs_GlyphInputType * inputPtr,
	uint16	            usCharCount,
	uint16	            usFirstChar,
	uint16 *	        pusCharCode,
	uint16 *	        pusGlyphID)
{
	ErrorCode           error;
	fs_SplineKey *      key;

	key = fs_SetUpKey(inputPtr, (INITIALIZED | NEWSFNT), &error);
	if(!key)
	{
		return (FS_ENTRY)error;
	}

	error = sfac_GetMultiGlyphIDs(
	    &key->ClientInfo, 
	    usCharCount, 
	    usFirstChar, 
	    pusCharCode, 
	    pusGlyphID);

	if(error)
	{
		return (FS_ENTRY)error;
	}
	return NO_ERR;
}

/*********************************************************************/

/*              Char Code to Glyph ID Helper Function                */

/*   specific to Win95 - needs no font context, just a cmap pointer  */

/*********************************************************************/

extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_Win95GetGlyphIDs (
	uint8 *             pbyCmapSubTable,
	uint16	            usCharCount,
	uint16	            usFirstChar,
	uint16 *	        pusCharCode,
	uint16 *	        pusGlyphID)
{
	ErrorCode           error;

	error = sfac_GetWin95GlyphIDs(
	    pbyCmapSubTable, 
	    usCharCount, 
	    usFirstChar, 
	    pusCharCode, 
	    pusGlyphID);

	if(error)
	{
		return (FS_ENTRY)error;
	}
	return NO_ERR;
}

/*********************************************************************/

/*              Char Code to Glyph ID Helper Function                */

/*   specific to WinNT                                               */

/*********************************************************************/

/* special helper function fs_WinNTGetGlyphIDs
   - an offset ulCharCodeOffset is added to the character codes from pulCharCode 
     before converting the value to glyph index
   - pulCharCode and pulGlyphID are both uint32 *
   - pulCharCode and pulGlyphID can point to the same address        
*/
extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_WinNTGetGlyphIDs (
	fs_GlyphInputType * inputPtr,
	uint16	            usCharCount,
	uint16	            usFirstChar,
	uint32	            ulCharCodeOffset,
	uint32 *	        pulCharCode,
	uint32 *	        pulGlyphID)
{
	ErrorCode           error;
	fs_SplineKey *      key;

	key = fs_SetUpKey(inputPtr, (INITIALIZED | NEWSFNT), &error);
	if(!key)
	{
		return (FS_ENTRY)error;
	}

	error = sfac_GetWinNTGlyphIDs(
	    &key->ClientInfo, 
	    usCharCount, 
	    usFirstChar, 
		ulCharCodeOffset,
	    pulCharCode, 
	    pulGlyphID);

	if(error)
	{
		return (FS_ENTRY)error;
	}
	return NO_ERR;
}


/*********************************************************************/

/*                Outline Coordinates Helper Function                */

/* returns (x,y) coordinates of array of points on the glyph outline */

/*********************************************************************/

extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_GetOutlineCoordinates (
	fs_GlyphInputType * inputPtr,
	uint16              usPointCount,
	uint16 *            pusPointIndex,
	shortVector *       psvCoordinates)
{
	ErrorCode       error;
	ContourList     CList;        /* newscan contour list type */
	fs_SplineKey *  key;

	key = fs_SetUpKey(inputPtr, (INITIALIZED | NEWSFNT | NEWTRANS | GOTINDEX | GOTGLYPH), &error);
	if(!key)
	{
		return (FS_ENTRY)error;
	}
	if (key->ulState & SIZEKNOWN)               /* fail a call after FindBimapSize */
	{
		return OUT_OFF_SEQUENCE_CALL_ERR;
	}
    
    if (key->bGlyphHasOutline == FALSE)
    {
        return BAD_POINT_INDEX_ERR;             /* no meaning if no outlines */
    }

	if(key->apbPrevMemoryBases[WORK_SPACE_BASE] != key->memoryBases[WORK_SPACE_BASE])
	{
		  fsg_UpdateWorkSpaceAddresses(
				key->memoryBases[WORK_SPACE_BASE],
				&(key->WorkSpaceOffsets),
				&(key->pWorkSpaceAddr));
		
		  fsg_UpdateWorkSpaceElement(
				&(key->WorkSpaceOffsets),
				&(key->pWorkSpaceAddr));
		
		  MEMCPY(key->apbPrevMemoryBases, key->memoryBases, sizeof(char *) * (size_t)MEMORYFRAGMENTS);
	}

	fsg_GetContourData(
		&key->pWorkSpaceAddr,
#ifdef FSCFG_SUBPIXEL
		(boolean)(key->flSubPixel & FNT_SP_SUB_PIXEL),            
#endif // FSCFG_SUBPIXEL
		&CList.afxXCoord,
		&CList.afxYCoord,
		&CList.asStartPoint,
		&CList.asEndPoint,
		&CList.abyOnCurve,
		&CList.abyFc,
		&CList.usContourCount);

	error = fsc_GetCoords(&CList, usPointCount, pusPointIndex, (PixCoord *)psvCoordinates);
	if (error != NO_ERR)
	{
		return(error);
	}

	return NO_ERR;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\fs\fontmath.h ===
/*
		File:           fontmath.h

		Contains:       xxx put contents here xxx

		Written by:     xxx put writers here xxx

		Copyright:      c 1990 by Apple Computer, Inc., all rights reserved.
						(c) 1989-1997. Microsoft Corporation, all rights reserved.

		Change History (most recent first):

				  <>     2/21/97		CB				ClaudeBe, add mth_UnitarySquare for scaled component in composite glyphs
				 <4>    11/27/90        MR              make pascal declaration a macro, conditionalize traps -vs-
																		externs for Fix/Frac math routines. [ph]
				 <3>     11/5/90        MR              Move [U]SHORTMUL into fscdefs.h Rename FixMulDiv to LongMulDiv.
																		[rb]
				 <2>    10/20/90        MR              Add some new math routines (stolen from skia). [rj]
				 <1>     4/11/90        dba             first checked in

		To Do:
*/
#ifdef __cplusplus
extern "C" {
#endif

#define HIWORDMASK              0xffff0000
#define LOWORDMASK              0x0000ffff
#define DOT6ONEHALF             0x00000020
#define ONESHORTFRAC            (1 << 14)

#define ROUNDFIXTOINT( x )      (int16)((((Fixed) x) + ONEHALFFIX) >> 16)
#define ROUNDFIXED( x )         (((x) + (Fixed)ONEHALFFIX) & (Fixed)HIWORDMASK)
#define DOT6TOFIX(n)            ((Fixed) (n) << 10)
#define FIXEDTODOT6(n)          (F26Dot6) (((n) + ((1) << (9))) >> 10)
#define INTTOFIX(n)             ((Fixed) (n) << 16)
#define INTTODOT6(n)            ((F26Dot6) (n) << 6)
#define FS_HIWORD(n)            ((uint16)((uint32)(n) >> 16))
#define FS_LOWORD(n)            ((uint16)(n))
#define LOWSIXBITS              0x3F


#ifndef __TOOLUTILS__
FS_MAC_PASCAL Fixed FS_PC_PASCAL FixMul(Fixed,Fixed)   FS_MAC_TRAP(0xA868);
FS_MAC_PASCAL Fixed FS_PC_PASCAL FixRatio (int16 sA, int16 sB);
#endif

#ifndef __FIXMATH__
FS_MAC_PASCAL Fixed FS_PC_PASCAL FixDiv(Fixed,Fixed)  FS_MAC_TRAP(0xA84D);
FS_MAC_PASCAL Fract FS_PC_PASCAL FracMul(Fract,Fract) FS_MAC_TRAP(0xA84A);
FS_MAC_PASCAL Fract FS_PC_PASCAL FracDiv(Fract,Fract) FS_MAC_TRAP(0xA84B);
FS_MAC_PASCAL Fract FS_PC_PASCAL FracSqrt(Fract)      FS_MAC_TRAP(0xA849);
#endif


ShortFract      TMP_CONV NEAR ShortFracDot (ShortFract x, ShortFract y);
F26Dot6         TMP_CONV NEAR ShortFracMul (F26Dot6 x, ShortFract y);
ShortFract      TMP_CONV NEAR ShortFracDiv (ShortFract x, ShortFract y);
F26Dot6         TMP_CONV NEAR Mul26Dot6 (F26Dot6 a, F26Dot6 b);
F26Dot6         TMP_CONV NEAR Div26Dot6 (F26Dot6 num, F26Dot6 den);
int16           TMP_CONV NEAR MulDivShorts (int16 x, int16 y, int16 z);


#define MulDiv26Dot6(a,b,c) LongMulDiv(a,b,c)

int32 LongMulDiv(int32 a, int32 b, int32 c);     /* (a*b)/c */

int32 ShortMulDiv(int32 a, int16 b, int16 c);     /* (a*b)/c */

ShortFract ShortFracMulDiv(ShortFract,ShortFract,ShortFract);

void mth_FixXYMul (Fixed* x, Fixed* y, transMatrix* matrix);
void mth_FixVectorMul (vectorType* v, transMatrix* matrix);

/*
 *   B = A * B;     <4>
 *
 *         | a  b  0  |
 *    B =  | c  d  0  | * B;
 *         | 0  0  1  |
 */
void mth_MxConcat2x2 (transMatrix* matrixA, transMatrix* matrixB);

/*
 * scales a matrix by sx and sy.
 *
 *              | sx 0  0  |
 *    matrix =  | 0  sy 0  | * matrix;
 *              | 0  0  1  |
 */
void mth_MxScaleAB (Fixed sx, Fixed sy, transMatrix *matrixB);

boolean mth_IsMatrixStretched (transMatrix*trans);

boolean mth_Identity (transMatrix *matrix);
boolean mth_PositiveSquare (transMatrix *matrix);
boolean mth_PositiveRectangle (transMatrix *matrix);

/*
 * unitary Square
 *
 *              | +-1    0  0  |
 *    matrix =  |   0  +-1  0  |
 *              |   0    0  1  |
 */

boolean mth_UnitarySquare (transMatrix *matrix);

boolean mth_SameStretch (Fixed fxScaleX, Fixed fxScaleY);

boolean mth_GeneralRotation (transMatrix *matrix);
uint16 mth_90degRotationFactor (transMatrix *matrix);
uint16 mth_90degClosestRotationFactor (transMatrix *matrix);
void mth_Non90DegreeTransformation(transMatrix *matrix, boolean *non90degreeRotation, boolean *nonUniformStretching);

int32 mth_CountLowZeros (uint32 n );
Fixed mth_max_abs (Fixed a, Fixed b);

int32 mth_GetShift (uint32 n);

void mth_ReduceMatrix(transMatrix *trans);

void mth_IntelMul (
	int32           lNumPts,
	F26Dot6 *       fxX,
	F26Dot6 *       fxY,
	transMatrix *   trans,
	Fixed           fxXStretch,
	Fixed           fxYStretch);

void    mth_FoldPointSizeResolution(
	Fixed           fxPointSize,
	int16           sXResolution,
	int16           sYResolution,
	transMatrix *   trans);

/*********************************************************************/

/*  Scan Converter Math Functions Appended for now         <5> DeanB */

/*********************************************************************/

int32 PowerOf2(
		int32                   /* + or - 32 bit value */
);

FS_PUBLIC int16 mth_DivShiftShort(int16 sValue, int16 sFactor);
FS_PUBLIC int32 mth_DivShiftLong(int32 sValue, int16 sFactor);

/*********************************************************************/
#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\fs\fscaler.h ===
#ifdef __cplusplus
extern "C" {
#endif

/*
	File:       fscaler.h

	Contains:   xxx put contents here (or delete the whole line) xxx

	Written by: xxx put name of writer here (or delete the whole line) xxx

	Copyright:  (c) 1987-1990, 1992 by Apple Computer, Inc., all rights reserved.
				(c) 1989-1999. Microsoft Corporation, all rights reserved.

	Change History (most recent first):

				 7/10/99  BeatS		Add support for native SP fonts, vertical RGB
		  <>    10/14/97    CB      move usOverScale to fs_NewTransformation
		<9+>     7/17/90    MR      Conditionalize names in FSInput
		 <9>     7/14/90    MR      rename SQRT2 to FIXEDSQRT2, removed specificID and lowestRecPPEM
									from FSInfo
		 <8>     7/13/90    MR      FSInput now has a union to save space, points to matrix instead
									of storing it
		 <6>     6/21/90    MR      Change fillFunc to ReleaseSfntFrag
		 <5>      6/5/90    MR      remove readmvt and mapcharcodes
		 <4>      5/3/90    RB      Added memory area for new scan converter. MIKE REED - Removed
									.error from fsinfo structure. Added MapCharCodes and ReadMVT
									calls.
		 <3>     3/20/90    CL      New comment style for BBS. 
		 <2>     2/27/90    CL      New CharToIndexMap Table format.
	   <3.5>    11/15/89    CEL     Placed an ifdef around inline MPW calls to the trap. This makes
									it easier to compile for skia and the likes who do not use the
									MPW compiler.
	   <3.4>    11/14/89    CEL     Left Side Bearing should work right for any transformation. The
									phantom points are in, even for components in a composite glyph.
									They should also work for transformations. Device metric are
									passed out in the output data structure. This should also work
									with transformations. Another leftsidebearing along the advance
									width vector is also passed out. whatever the metrics are for
									the component at it's level. Instructions are legal in
									components. Instructions are legal in components. Five
									unnecessary element in the output data structure have been
									deleted. (All the information is passed out in the bitmap data
									structure) fs_FindBMSize now also returns the bounding box.
	   <3.3>     9/27/89    CEL     Took out devAdvanceWidth & devLeftSideBearing.
	   <3.2>     9/25/89    CEL     Took out Mac specific functions.
	   <3.1>     9/15/89    CEL     Re-working dispatcher.
	   <3.0>     8/28/89    sjk     Cleanup and one transformation bugfix
	   <2.2>     8/14/89    sjk     1 point contours now OK
	   <2.1>      8/8/89    sjk     Improved encryption handling
	   <2.0>      8/2/89    sjk     Just fixed EASE comment
	   <1.5>      8/1/89    sjk     Added composites and encryption. Plus some enhancements.
	   <1.4>     6/13/89    SJK     Comment
	   <1.3>      6/2/89    CEL     16.16 scaling of metrics, minimum recommended ppem, point size 0
									bug, correct transformed integralized ppem behavior, pretty much
									so
	   <1.2>     5/26/89    CEL     EASE messed up on "c" comments
	  <,1.1>  5/26/89    CEL     Integrated the new Font Scaler 1.0 into Spline Fonts
	   <1.0>     5/25/89    CEL     Integrated 1.0 Font scaler into Bass code for the first time.

	To Do:
*/

#include    "fscdefs.h"
#include    "fnt.h"

/* QuickDraw Types */

#ifndef _Quickdraw_
#ifndef __QUICKDRAW__   
	typedef struct BitMap {
		char* baseAddr;
		int16 rowBytes;
		Rect bounds;
	} BitMap;
#endif
#endif

#define MEMORYFRAGMENTS 9           /* extra memory base for overscaled bitmap */

#define NONVALID        0xffff

/* For the flags field in the flags field */

/* set on 68020, do not set on 68000 */
#define READ_NONALIGNED_SHORT_IS_OK 0x0001          /* set when calling fs_OpenFonts() */
/* set on 68020, do not set on 68000 */
#define READ_NONALIGNED_LONG_IS_OK  0x0002          /* set when calling fs_OpenFonts() */

#ifdef FSCFG_SUBPIXEL
/* For the SubPixel flag field */
#define SP_SUB_PIXEL			0x0001          /* set when calling fs_NewTransformation() */
#define SP_COMPATIBLE_WIDTH		0x0002          /* set when calling fs_NewTransformation() */
#define SP_VERTICAL_DIRECTION	0x0004          /* set when calling fs_NewTransformation() */
#define SP_BGR_ORDER			0x0008          /* set when calling fs_NewTransformation() */
#endif // FSCFG_SUBPIXEL

typedef struct {
	vectorType      advanceWidth, leftSideBearing;
	vectorType      leftSideBearingLine, devLeftSideBearingLine;/* along AW line */
	vectorType      devAdvanceWidth, devLeftSideBearing;
} metricsType;

typedef struct {
	vectorType      advanceHeight, topSideBearing;
	vectorType      topSideBearingLine, devTopSideBearingLine;/* along AH line */
	vectorType      devAdvanceHeight, devTopSideBearing;
} verticalMetricsType;

#define FS_MEMORY_SIZE  int32

/*
 * Output data structure to the Font Scaler.
 */
typedef struct {
	FS_MEMORY_SIZE  memorySizes[MEMORYFRAGMENTS];

	uint16          glyphIndex;
	uint16          numberOfBytesTaken; /* from the character code */

	metricsType     metricInfo;
	BitMap          bitMapInfo;

	/* Spline Data */
	int32           outlineCacheSize;
	uint16          outlinesExist;
	uint16          numberOfContours;
	F26Dot6         *xPtr, *yPtr;
	int16           *startPtr;
	int16           *endPtr;
	uint8           *onCurve;
	/* End of spline data */

	/* Only of interest to editors */
	F26Dot6         *scaledCVT;

	/* embedded bitmap return values */
	uint16          usBitmapFound;

	/* vertical metrics */
	verticalMetricsType     verticalMetricInfo;

	/* resulting number of gray levels, 0 means black/white, 1 bit per pixel,
	   (grayscale bitmap are 1 byte per pixel)
	   the number of level you receive is not necessarily what you ask for.
	   If there is no embedded gray bitmap :
			usOverscale 2 -> usGrayLevels 5,
			usOverscale 4 -> usGrayLevels 17,
			usOverscale 8 -> usGrayLevels 65,
	   If an embedded gray bitmap is present in the font, the embedded bitmap
	   will be selected before a gray bitmap generated with an higher overscale.
	   If you are unhappy with the number of gray levels (usGrayLevels) you can force
	   the embedded bitmap off by setting bNoEmbeddedBitmap to TRUE  */
	uint16          usGrayLevels;            
#ifdef FSCFG_SUBPIXEL_STANDALONE // B.St.
	BitMap			overscaledBitmapInfo;
#endif
	uint8			*fc;         /* contour flags, one byte for every contour */
} fs_GlyphInfoType;

/*
 * Input data structure to the Font Scaler.
 *
 * styleFunc is not supported in this version of the Font Scalar. Should be set to NULL.
 *
 */

#ifndef UNNAMED_UNION

typedef struct {
	Fixed                   version;
	char*                   memoryBases[MEMORYFRAGMENTS];
	int32                   *sfntDirectory; 
	GetSFNTFunc             GetSfntFragmentPtr; /* (clientID, offset, length) */
	ReleaseSFNTFunc         ReleaseSfntFrag;
	ClientIDType            clientID; /* client private id/stamp (eg. handle for the sfnt) */

	union {
		struct {
			uint16          platformID;
			uint16          specificID;
		} newsfnt;
		struct {
			Fixed           pointSize;
			int16           xResolution;
			int16           yResolution;
			Fixed           pixelDiameter;      /* compute engine char from this */
			transMatrix*    transformMatrix;
			FntTraceFunc    traceFunc;
			uint16          usOverScale;            /* outline magnification */
            /* embolding simulation */
			uint16          usEmboldWeightx;        /* scaling factor in x between 0 and 40 (20 means 2% fo the height) */
			uint16          usEmboldWeighty;        /* scaling factor in y between 0 and 40 (20 means 2% fo the height) */
			int32           lDescDev;               /* descender in device metric, used for clipping */
			boolean         bBitmapEmboldening;
#ifdef FSCFG_SUBPIXEL
			uint16          flSubPixel;
#endif // FSCFG_SUBPIXEL
			boolean         bHintAtEmSquare;        /* hint at the design resolution, this flag is used for sub-pixel position
													   or text animation where we want to turn off gridfitting hinting
													   but for fonts where glyphs are build by hinting, we still want the
													   glyph shape to be correct */
		} newtrans;
		struct {
			uint16          characterCode;
			uint16          glyphIndex;
			boolean         bMatchBBox;             /* force bounding box match */
			boolean         bNoEmbeddedBitmap;      /* disable the embedded bitmap */			
		} newglyph;
		struct {
			void            (*styleFunc) (fs_GlyphInfoType*);
			FntTraceFunc    traceFunc;
			boolean         bSkipIfBitmap;
		} gridfit;
		int32*  outlineCache;
		struct {                                    /* for fs_FindBandingSize */
			uint16          usBandType;             /* old, small or fast */
			uint16          usBandWidth;            /* number of scanlines */
			int32*          outlineCache;           /* cacheing works with banding */
		} band;
		struct {
			int16           bottomClip;
			int16           topClip;
			int32*          outlineCache;
		} scan;
	} param;
} fs_GlyphInputType;

#else

typedef struct {
	Fixed                   version;
	char*                   memoryBases[MEMORYFRAGMENTS];
	int32                   *sfntDirectory; 
	GetSFNTFunc             GetSfntFragmentPtr; /* (clientID, offset, length) */
	ReleaseSFNTFunc         ReleaseSfntFrag;
	ClientIDType            clientID; /* client private id/stamp (eg. handle for the sfnt) */

	union {
		struct {
			uint16          platformID;
			uint16          specificID;
		};
		struct {
			Fixed           pointSize;
			int16           xResolution;
			int16           yResolution;
			Fixed           pixelDiameter;      /* compute engine char from this */
			transMatrix*    transformMatrix;
			FntTraceFunc    tracePreProgramFunc;
			uint16          usOverScale;            /* outline magnification */
            /* embolding simulation */
			uint16          usEmboldWeightx;        /* scaling factor in x between 0 and 40 (20 means 2% fo the height) */
			uint16          usEmboldWeighty;        /* scaling factor in y between 0 and 40 (20 means 2% fo the height) */
			int32           lDescDev;               /* descender in device metric, used for clipping */
			boolean         bBitmapEmboldening;
#ifdef FSCFG_SUBPIXEL
			uint16          flSubPixel;
#endif // FSCFG_SUBPIXEL
			boolean         bHintAtEmSquare;        /* hint at the design resolution, this flag is used for sub-pixel position
													   or text animation where we want to turn off gridfitting hinting
													   but for fonts where glyphs are build by hinting, we still want the
													   glyph shape to be correct */
		};
		struct {
			uint16          characterCode;
			uint16          glyphIndex;
			boolean         bMatchBBox;             /* force bounding box match */
			boolean         bNoEmbeddedBitmap;      /* disable the embedded bitmap */			
		};
		struct {
			void            (*styleFunc) (fs_GlyphInfoType*);
			FntTraceFunc    traceGridFitFunc;
			boolean         bSkipIfBitmap;
		};
		int32*              outlineCache1;
		struct {                                    /* for fs_FindBandingSize */
			uint16          usBandType;             /* old, small or fast */
			uint16          usBandWidth;            /* number of scanlines */
			int32*          outlineCache3;          /* cacheing works with banding */
		};
		struct {
			int16           bottomClip;
			int16           topClip;
			int32*          outlineCache2;
		};
	};
} fs_GlyphInputType;

#endif      /* unnamed union */

#ifndef FIXEDSQRT2
#define FIXEDSQRT2 0x00016A0A
#endif

/* Font scaler trap selctors */
#define OUTLINEFONTTRAP     0xA854
#define FS_OPENFONTS        0x8000
#define FS_INITIALIZE       0x8001
#define FS_NEWSFNT          0x8002
#define FS_NEWTRANS         0x8003
#define FS_NEWGLYPH         0x8004
#define FS_GETAW            0x8005
#define FS_GRIDFITT         0x8006
#define FS_NOGRIDFITT       0x8007
#define FS_FINDBMSIZE       0x8008
#define FS_SIZEOFOUTLINES   0x8009
#define FS_SAVEOUTLINES     0x800a
#define FS_RESTOREOUTLINES  0x800b
#define FS_CONTOURSCAN      0x800c
#define FS_CLOSE            0x800d
#define FS_READMVT          0x800e
#define FS_MAPCHAR_CODES    0x800f

#ifndef FS_ENTRY
#define FS_ENTRY int32
#endif

#ifdef MACINIT
extern FS_ENTRY fs__OpenFonts (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
	= {0x303C,FS_OPENFONTS,0xA854};
extern FS_ENTRY fs__Initialize (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
	= {0x303C,FS_INITIALIZE,0xA854};
extern FS_ENTRY fs__NewSfnt (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
	= {0x303C,FS_NEWSFNT,0xA854};
extern FS_ENTRY fs__NewTransformation (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
	= {0x303C,FS_NEWTRANS,0xA854};
extern FS_ENTRY fs__NewGlyph (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
	= {0x303C,FS_NEWGLYPH,0xA854};
extern FS_ENTRY fs__GetAdvanceWidth (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
	= {0x303C,FS_GETAW,0xA854};
extern FS_ENTRY fs__ContourGridFit (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
	= {0x303C,FS_GRIDFITT,0xA854};
extern FS_ENTRY fs__ContourNoGridFit (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
	= {0x303C,FS_NOGRIDFITT,0xA854};
extern FS_ENTRY fs__FindBitMapSize (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
	= {0x303C,FS_FINDBMSIZE,0xA854};
extern FS_ENTRY fs__FindBandingSize (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
	= {0x303C,FS_FINDBMSIZE,0xA854};

/* these three optional calls are for caching the outlines */
extern FS_ENTRY fs__SizeOfOutlines (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
	= {0x303C,FS_SIZEOFOUTLINES,0xA854};
extern FS_ENTRY fs__SaveOutlines (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
	= {0x303C,FS_SAVEOUTLINES,0xA854};
extern FS_ENTRY fs__RestoreOutlines (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
	= {0x303C,FS_RESTOREOUTLINES,0xA854};

extern FS_ENTRY fs__ContourScan (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
	= {0x303C,FS_CONTOURSCAN,0xA854};
extern FS_ENTRY fs__CloseFonts (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr)
	= {0x303C,FS_CLOSE,0xA854};

#else

/*** Direct Calls to Font Scaler Client Interface, for Clients not using the trap mechanism ***/

extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_OpenFonts (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr);
extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_Initialize (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr);
extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_NewSfnt (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr);
extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_NewTransformation (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr);
extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_NewTransformNoGridFit (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr);
extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_NewGlyph (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr);
extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_GetAdvanceWidth (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr);
extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_ContourGridFit (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr);
extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_ContourNoGridFit (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr);
extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_FindBitMapSize (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr);
extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_FindBandingSize (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr);

/* these three optional calls are for caching the outlines */
extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_SizeOfOutlines (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr);
extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_SaveOutlines (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr);
extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_RestoreOutlines (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr);

extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_ContourScan (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr);
extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_CloseFonts (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr);

#endif

#ifdef FSCFG_NO_INITIALIZED_DATA
FS_PUBLIC void FS_ENTRY_PROTO fs_InitializeData (void);
#endif

/*** Rasterizer Helper Functions ***/

extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_GetScaledAdvanceWidths (
	fs_GlyphInputType * inputPtr,
	uint16              usFirstGlyph,
	uint16              usLastGlyph,
	int16 *             psGlyphWidths);

typedef struct {
	int16 x;
	int16 y;
} shortVector;

extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_GetScaledAdvanceHeights (
	fs_GlyphInputType * inputPtr,
	uint16              usFirstGlyph,
	uint16              usLastGlyph,
	shortVector *       psvAdvanceHeights);

extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_GetGlyphIDs (
	fs_GlyphInputType * inputPtr,
	uint16	            usCharCount,
	uint16	            usFirstChar,
	uint16 *	        pusCharCode,
	uint16 *	        pusGlyphID);

extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_Win95GetGlyphIDs (
	uint8 *             pbyCmapSubTable,
	uint16	            usCharCount,
	uint16	            usFirstChar,
	uint16 *	        pusCharCode,
	uint16 *	        pusGlyphID);


/* special helper function fs_WinNTGetGlyphIDs
   - an offset ulCharCodeOffset is added to the character codes from pulCharCode 
     before converting the value to glyph index
   - pulCharCode and pulGlyphID are both uint32 *
   - pulCharCode and pulGlyphID can point to the same address        
*/
extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_WinNTGetGlyphIDs (
	fs_GlyphInputType * inputPtr,
	uint16	            usCharCount,
	uint16	            usFirstChar,
	uint32	            ulCharCodeOffset,
	uint32 *	        pulCharCode,
	uint32 *	        pulGlyphID);

extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_GetOutlineCoordinates (
	fs_GlyphInputType * inputPtr,
	uint16              usPointCount,
	uint16 *            pusPointIndex,
	shortVector *       psvCoordinates);

/*** Gray scale definitions ***/

#ifndef FSCFG_DISABLE_GRAYSCALE

#define FS_GRAY_VALUE_MASK  0x008B      /* support usOverScale of 1, 2, 4, & 8 */
#define FS_SBIT_BITDEPTH_MASK	0x0116	 /* support sbit with bitDepth of 1, 2, 4 and 8 */
/* FS_SBIT_BITDEPTH_MASK must have the same value as SBIT_BITDEPTH_MASK in sfntaccs.h */ 

#else

#define FS_GRAY_VALUE_MASK  0x0000      /* no grayscale support */
#define FS_SBIT_BITDEPTH_MASK	0x0002	 /* support only sbit with bitDepth of 1 */
/* FS_SBIT_BITDEPTH_MASK must have the same value as SBIT_BITDEPTH_MASK in sfntaccs.h */ 

#endif
/* the value of FS_GRAY_VALUE_MASK and FS_SBIT_BITDEPTH_MASK can be used to determine
   the usGrayLevels the client need to support.

   Fonts without embedded bitmap :
		usGrayLevels = usOverScale * usOverScale + 1;

   Fonts with embedded bitmap (sbit) :
		usGrayLevels = 0x01 << usBitDepth;

  The usGrayLevels the client may receive with the current version are :

  0 for black/white
  5, 17, 65 fonts without embedded bitmap
  4, 16, 256 fonts with embedded bitmap

*/

extern FS_PUBLIC FS_ENTRY FS_ENTRY_PROTO fs_GetAdvanceHeight (fs_GlyphInputType *inputPtr, fs_GlyphInfoType *outputPtr);

#ifdef FSCFG_MOVE_KEY_IN_DOT_H
/* the definition of the key in fscaler.h and fscaler.c must be identical */

/*** The Internal Key ***/
typedef struct fs_SplineKey {
	sfac_ClientRec      ClientInfo;         /* Client Information */
	char* const *       memoryBases;        /* array of memory Areas */
	char *              apbPrevMemoryBases[MEMORYFRAGMENTS];

	uint16              usScanType;         /* flags for dropout control etc.*/

	fsg_TransformRec    TransformInfo;

	uint16              usNonScaledAW;
	uint16              usNonScaledAH;

	LocalMaxProfile     maxProfile;         /* copy of profile */

	uint32              ulState;            /* for error checking purposes */
	
	boolean             bExecutePrePgm;
	boolean             bExecuteFontPgm;    /* <4> */

	fsg_WorkSpaceAddr   pWorkSpaceAddr;     /* Hard addresses in Work Space */
	fsg_WorkSpaceOffsets WorkSpaceOffsets;  /* Address offsets in Work Space     */
	fsg_PrivateSpaceOffsets PrivateSpaceOffsets; /* Address offsets in Private Space */

	uint16              usBandType;         /* old, small or fast */
	uint16              usBandWidth;        /* from FindBandingSize */

	GlyphBitMap         GBMap;              /* newscan bitmap type */
	WorkScan            WScan;              /* newscan workspace type */

	GlyphBitMap         OverGBMap;          /* for gray scale */
	uint16              usOverScale;        /* 0 => mono; mag factor => gray */
	boolean             bGrayScale;			/* FALSE if mono (usOverScale == 0)	*/
	boolean             bMatchBBox;         /* force bounding box match */
	boolean             bEmbeddedBitmap;    /* embedded bitmap found */			

	metricsType         metricInfo;         /* Glyph metrics info */
	verticalMetricsType     verticalMetricInfo;

	int32               lExtraWorkSpace;    /* Amount of extra space in workspace */

	boolean             bOutlineIsCached;   /* Outline is cached */
	boolean             bGlyphHasOutline;   /* Outline is empty */
	boolean             bGridFitSkipped;    /* sbit anticipated, no outline loaded */

	uint32              ulGlyphOutlineSize; /* Size of outline cache */
	
	sbit_State          SbitMono;           /* for monochrome bitmaps */
	boolean             bHintingEnabled;    /* hinting is enabled, set to FALSE when 
                                               fs_NewTransformNoGridFit is called */
	boolean             bBitmapEmboldening; /* bitmap emboldening simulation */
	int16               sBoldSimulHorShift; /* shift for emboldening simulation, horizonatlly */
	int16               sBoldSimulVertShift; /* shift for emboldening simulation, vertically */
#ifdef FSCFG_SUBPIXEL
	uint16				flSubPixel;
	fsg_TransformRec    TransformInfoSubPixel;
#endif // FSCFG_SUBPIXEL
} fs_SplineKey;

#endif // FSCFG_MOVE_KEY_IN_DOT_H

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\fs\fshelper.h ===
/*
	 File:		 helper.h

	 Contains:	 Helper exports for Font Scaler

	 Written by: GregH

    Copyright:  (c) 1987-1990, 1992 by Apple Computer, Inc., all rights reserved.
                (c) 1989-1993. Microsoft Corporation, all rights reserved.

    Change History (most recent first):

		 <1>		 6/11/93	 GregH		Created.
*/

#ifndef FS_MATH_PROTO
#define FS_MATH_PROTO
#endif

int32 FS_MATH_PROTO ShortMulDiv(int32 a, int16 b, int16 c);	 /* (a*b)/c */

Fract FS_MATH_PROTO FracSqrt(Fract);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\fs\fscdefs.h ===
/*
	File:       fscdefs.h

	Contains:   xxx put contents here (or delete the whole line) xxx

	Written by: xxx put name of writer here (or delete the whole line) xxx

	Copyright:  c 1988-1990 by Apple Computer, Inc., all rights reserved.
	Copyright:  c 1991-1999 by Microsoft Corp., all rights reserved.

	Change History (most recent first):
		
				 7/10/99  BeatS		Add support for native SP fonts, vertical RGB
		         4/01/99  BeatS		Implement alternative interpretation of TT instructions for SP
		 <>     10/14/97    CB      rename ASSERT into FS_ASSERT
		 <3>    11/27/90    MR      Add #define for PASCAL. [ph]
		 <2>     11/5/90    MR      Move USHORTMUL from fontmath.h, add Debug definition [rb]
		 <7>     7/18/90    MR      Add byte swapping macros for INTEL, moved rounding macros from
									fnt.h to here
		 <6>     7/14/90    MR      changed defines to typedefs for int[8,16,32] and others
		 <5>     7/13/90    MR      Declared ReleaseSFNTFunc and GetSFNTFunc
		 <4>      5/3/90    RB      cant remember any changes
		 <3>     3/20/90    CL      type changes for Microsoft
		 <2>     2/27/90    CL      getting bbs headers
	   <3.0>     8/28/89    sjk     Cleanup and one transformation bugfix
	   <2.2>     8/14/89    sjk     1 point contours now OK
	   <2.1>      8/8/89    sjk     Improved encryption handling
	   <2.0>      8/2/89    sjk     Just fixed EASE comment
	   <1.5>      8/1/89    sjk     Added composites and encryption. Plus some enhancements.
	   <1.4>     6/13/89    SJK     Comment
	   <1.3>      6/2/89    CEL     16.16 scaling of metrics, minimum recommended ppem, point size 0
									bug, correct transformed integralized ppem behavior, pretty much
									so
	   <1.2>     5/26/89    CEL     EASE messed up on "c" comments
	  <,1.1>     5/26/89    CEL     Integrated the new Font Scaler 1.0 into Spline Fonts
	   <1.0>     5/25/89    CEL     Integrated 1.0 Font scaler into Bass code for the first time.

	To Do:
*/

#ifndef FSCDEFS_DEFINED
#define FSCDEFS_DEFINED

#include "fsconfig.h"
#include <stddef.h>
#include <limits.h>

#if !defined(__cplusplus)       // true/false are reserved words for C++
#define true 1
#define false 0
#endif

#ifndef TRUE
	#define TRUE    1
#endif

#ifndef FALSE
#define FALSE   0
#endif

#ifndef FS_PRIVATE
#define FS_PRIVATE static
#endif

#ifndef FS_PUBLIC
#define FS_PUBLIC
#endif

#define ONEFIX      ( 1L << 16 )
#define ONEFRAC     ( 1L << 30 )
#define ONEHALFFIX  0x8000L
#define ONEVECSHIFT 16
#define HALFVECDIV  (1L << (ONEVECSHIFT-1))

#define NULL_GLYPH  0

/* banding type constants */

#define FS_BANDINGOLD       0
#define FS_BANDINGSMALL     1
#define FS_BANDINGFAST      2
#define FS_BANDINGFASTER    3

/* Dropout control values are now defined as bit masks to retain compatability */
/* with the old definition, and to allow for current and future expansion */

#define SK_STUBS          0x0001       /* leave stubs white */
#define SK_NODROPOUT      0x0002       /* disable all dropout control */
#define SK_SMART              0x0004        /* symmetrical dropout, closest pixel */

/* Values used to decode curves */

#define ONCURVE             0x01

typedef signed char int8;
typedef unsigned char uint8;
typedef short int16;
typedef unsigned short uint16;
typedef long int32;
typedef unsigned long uint32;

typedef __int64 int64;
typedef unsigned __int64 uint64;

typedef short FUnit;
typedef unsigned short uFUnit;

typedef short ShortFract;                       /* 2.14 */

#ifndef F26Dot6
#define F26Dot6 long
#endif

#ifndef boolean
#define boolean int
#endif

#ifndef ClientIDType
#define ClientIDType int32
#endif

#ifndef CONST
#define CONST const
#endif

#ifndef FAR
#define FAR
#endif

#ifndef NEAR
#define NEAR
#endif

#ifndef TMP_CONV
#define TMP_CONV
#endif

#ifndef FS_MAC_PASCAL
#define FS_MAC_PASCAL
#endif

#ifndef FS_PC_PASCAL
#define FS_PC_PASCAL
#endif

#ifndef FS_MAC_TRAP
#define FS_MAC_TRAP(a)
#endif

/* QuickDraw Types */

#ifndef _MacTypes_
#ifndef __TYPES__
	typedef struct Rect {
		int16 top;
		int16 left;
		int16 bottom;
		int16 right;
	} Rect;

typedef long Fixed;         /* also defined in Mac's types.h */
typedef long Fract;

#endif
#endif

typedef struct {
	Fixed       transform[3][3];
} transMatrix;

typedef struct {
	Fixed       x, y;
} vectorType;

/* Private Data Types */
typedef struct {
	int16 xMin;
	int16 yMin;
	int16 xMax;
	int16 yMax;
} BBOX;

typedef struct {
	F26Dot6 x;
	F26Dot6 y;
} point;

typedef int32 ErrorCode;

#define ALIGN(object, p) p =    (p + ((uint32)sizeof(object) - 1)) & ~((uint32)sizeof(object) - 1);

#define ROWBYTESLONG(x)     (((x + 31) >> 5) << 2)

#ifndef SHORTMUL
#define SHORTMUL(a,b)   (int32)((int32)(a) * (b))
#endif

#ifndef SHORTDIV
#define SHORTDIV(a,b)   (int32)((int32)(a) / (b))
#endif

#ifdef FSCFG_BIG_ENDIAN /* target byte order matches Motorola 68000 */
	#define SWAPL(a)        (a)
	#define CSWAPL(a)       (a)
	#define SWAPW(a)        (a)
	#define CSWAPW(a)       (a)
	#define SWAPWINC(a)     (*(a)++)
#else
	/* Portable code to extract a short or a long from a 2- or 4-byte buffer */
	/* which was encoded using Motorola 68000 (TrueType "native") byte order. */
	#define FS_2BYTE(p) ( ((unsigned short)((p)[0]) << 8) |  (p)[1])
	#define FS_4BYTE(p) ( FS_2BYTE((p)+2) | ( (FS_2BYTE(p)+0L) << 16) )
	#define SWAPW(a)	((int16) FS_2BYTE( (unsigned char *)(&a) ))
	#define CSWAPW(num)	(((((num) & 0xff) << 8) & 0xff00) + (((num) >> 8) & 0xff)) // use this variant or else cannot apply to constants due to FS_2BYTE and FS_4BYTE
	#define SWAPL(a)	((int32) FS_4BYTE( (unsigned char *)(&a) ))
	#define CSWAPL(num)	((CSWAPW((num) & 0xffff) << 16) + CSWAPW((num) >> 16)) // use this variant or else cannot apply to constants due to FS_2BYTE and FS_4BYTE
	#define SWAPWINC(a) SWAPW(*(a)); a++    /* Do NOT parenthesize! */
#endif

#ifndef SWAPW // provoke compiler error if still not defined
	#define SWAPW	a
	#define SWAPW	b
#endif

#ifndef LoopCount
#define LoopCount int16      /* short gives us a Motorola DBF */
#endif

#ifndef ArrayIndex
#define ArrayIndex int32     /* avoids EXT.L on Motorola */
#endif

typedef void (*voidFunc) ();
typedef void * voidPtr;
typedef void (FS_CALLBACK_PROTO *ReleaseSFNTFunc) (voidPtr);
typedef void * (FS_CALLBACK_PROTO *GetSFNTFunc) (ClientIDType, int32, int32);

#ifndef	FS_ASSERT
#define FS_ASSERT(expression, message)
#endif

#ifndef Assert
#define Assert(a)
#endif

#ifndef MEMSET
#define MEMSET(dst, value, size) (void)memset(dst,value,(size_t)(size))
#define FS_NEED_STRING_DOT_H
#endif

#ifndef MEMCPY
#define MEMCPY(dst, src, size) (void)memcpy(dst,src,(size_t)(size))
#ifndef FS_NEED_STRING_DOT_H
#define FS_NEED_STRING_DOT_H
#endif
#endif

#ifdef FS_NEED_STRING_DOT_H
#undef FS_NEED_STRING_DOT_H
#include <string.h>
#endif

#ifndef FS_UNUSED_PARAMETER
#define FS_UNUSED_PARAMETER(a) (a=a)     /* Silence some warnings */
#endif

typedef struct {
	Fixed       version;                /* for this table, set to 1.0 */
	uint16      numGlyphs;
	uint16      maxPoints;              /* in an individual glyph */
	uint16      maxContours;            /* in an individual glyph */
	uint16      maxCompositePoints;     /* in an composite glyph */
	uint16      maxCompositeContours;   /* in an composite glyph */
	uint16      maxElements;            /* set to 2, or 1 if no twilightzone points */
	uint16      maxTwilightPoints;      /* max points in element zero */
	uint16      maxStorage;             /* max number of storage locations */
	uint16      maxFunctionDefs;        /* max number of FDEFs in any preprogram */
	uint16      maxInstructionDefs;     /* max number of IDEFs in any preprogram */
	uint16      maxStackElements;       /* max number of stack elements for any individual glyph */
	uint16      maxSizeOfInstructions;  /* max size in bytes for any individual glyph */
	uint16      maxComponentElements;   /* number of glyphs referenced at top level */
	uint16      maxComponentDepth;      /* levels of recursion, 1 for simple components */
} LocalMaxProfile;

#ifdef FSCFG_SUBPIXEL

	// master switch for turning on Backwards Compatible SubPixel
	// if we turn this off, we basically get the same as in b/w, but with coloured fringes
	// to get the complete original 16x overscaling behaviour back, set HINTING_HOR_OVERSCALE below to 16
	#define	SUBPIXEL_BC
	
	#define ProjVectInX(localGS)	((localGS).proj.x == ONEVECTOR && (localGS).proj.y == 0)
	#define	ProjVectInY(localGS)	((localGS).proj.y == ONEVECTOR && (localGS).proj.x == 0)
	
	#ifdef SUBPIXEL_BC
		
		// master switch for turning on Enhanced Backwards Compatible Advance Width SubPixel Algorithm
		#define SUBPIXEL_BC_AW_STEM_CONCERTINA
		
		#define RunningSubPixel(globalGS)		((uint16)((globalGS)->flHintForSubPixel & FNT_SP_SUB_PIXEL))
		#define CompatibleWidthSP(globalGS)		((uint16)((globalGS)->flHintForSubPixel & FNT_SP_COMPATIBLE_WIDTH))
		#define VerticalSPDirection(globalGS)	((uint16)((globalGS)->flHintForSubPixel & FNT_SP_VERTICAL_DIRECTION))
		#define BGROrderSP(globalGS)			((uint16)((globalGS)->flHintForSubPixel & FNT_SP_BGR_ORDER))
	//	assume that horizontal direction RGB is more frequent than vertical direction, hence put the latter into the else-path
	//	Notice that in order to decide whether we're currently in SubPixel direction, we look at the projection vector, because that's the direction
	//	along which distances are measured. If this projection vector has a non-zero component in the physical direction of our device, we will decide
	//	that rounding should be done in the SubPixel way. For example, if our device has its SubPixel direction in x, and if the projection vector
	//	points in any direction other than the y direction, the pv has a non-zero component in x, hence we round in the SubPixel way. This behaviour
	//	corresponds to the original implementation of the 16x overscaling rasterizer, where the non-zero component in x would be overscaled by 16.
		#define InSubPixelDirection(localGS)	((uint16)(!VerticalSPDirection((localGS).globalGS) ? !ProjVectInY(localGS) : !ProjVectInX(localGS)))
	//	primary values; in interp.c there are further values which are derived from these values, but which are specific to the interpreter
		#define VIRTUAL_OVERSCALE				16 // for itrp_RoundToGrid & al to work properly, this should be a power of two, else have to tabulate rounding
		#define VISUAL_OVERSCALE				2  // between 1.7 and 3, corresponding to the visually experienced resolution relative to the physical resolution.
												   // for our purposes, the exact value is not particularly crucial (cf. ENGINE_COMP_OVERSCALE, MIN_DIST_OVERSCALE,
												   // in interp.c) hence we set it to 2 for efficiency
	#else
		#define RunningSubPixel(globalGS)		false
		#define CompatibleWidthSP(globalGS)		false
		#define VerticalSPDirection(globalGS)	false
		#define InSubPixelDirection(localGS)	false
	//	primary values; in interp.c there are further values which are derived from these values, but which are specific to the interpreter
		#define VIRTUAL_OVERSCALE				1
		#define VISUAL_OVERSCALE				1
	#endif
//	#define VIRTUAL_PIXELSIZE		(FNT_PIXELSIZE/VIRTUAL_OVERSCALE)
//	these values are used in various rounding functions, which includes rounding the advance width
//	they are specific to the rounding operation, if this should become necessary in the future
	#define VIRTUAL_PIXELSIZE_RTDG	(FNT_PIXELSIZE/VIRTUAL_OVERSCALE)
	#define VIRTUAL_PIXELSIZE_RDTG	(FNT_PIXELSIZE/VIRTUAL_OVERSCALE)
	#define VIRTUAL_PIXELSIZE_RUTG	(FNT_PIXELSIZE/VIRTUAL_OVERSCALE)
	#define VIRTUAL_PIXELSIZE_RTG	(FNT_PIXELSIZE/VIRTUAL_OVERSCALE)
	#define VIRTUAL_PIXELSIZE_RTHG	(FNT_PIXELSIZE/VIRTUAL_OVERSCALE)
	#define VIRTUAL_PIXELSIZE_ROFF	(FNT_PIXELSIZE/VIRTUAL_OVERSCALE)
	

	#define HINTING_HOR_OVERSCALE 1 // see SUBPIXEL_BC above for further comments

#ifdef FSCFG_SUBPIXEL_STANDALONE
	
	#define R_Subpixels		5
	#define G_Subpixels		9
	#define B_Subpixels		2

	/* IMPORTANT :
 
	   If you change any of the above
	   make sure you update abColorIndexTable[] in scentry.c
	   and that (R_Subpixels + 1) * (G_Subpixels + 1) * (B_Subpixels + 1) <= 256

	  */

	#define RGB_OVERSCALE (R_Subpixels + G_Subpixels + B_Subpixels)

#else

	#define SUBPIXEL_OVERSCALE 2

	/* IMPORTANT :
 
	   If you change SUBPIXEL_OVERSCALE
	   make sure you update abColorIndexTable[] in scentry.c
	   and that (SUBPIXEL_OVERSCALE + 1) * (SUBPIXEL_OVERSCALE + 1) * (SUBPIXEL_OVERSCALE + 1) <= 256

	  */

	#define RGB_OVERSCALE (SUBPIXEL_OVERSCALE * 3)
#endif

	#define ROUND_FROM_RGB_OVERSCALE(x) x = ((x) + (RGB_OVERSCALE >> 1) ) / RGB_OVERSCALE
	#define ROUND_FROM_HINT_OVERSCALE(x) x = ((x) + (HINTING_HOR_OVERSCALE >> 1) ) / HINTING_HOR_OVERSCALE
	#define ROUND_RGB_OVERSCALE(x) ((x) + (RGB_OVERSCALE >> 1) ) / RGB_OVERSCALE

	#define FLOOR_RGB_OVERSCALE(x) ((x) < 0) ? -((-(x)+ RGB_OVERSCALE -1) / RGB_OVERSCALE) : ((x) / RGB_OVERSCALE) // by the way, this is NOT a floor operation
	#define CEIL_RGB_OVERSCALE(x) FLOOR_RGB_OVERSCALE((x) + RGB_OVERSCALE -1)

	/* we are storing into 2 bits per pixels, weight for each color can be 0,1 or 2 */
	#define MAX_RGB_INDEX (2 * 16 + 2 * 4 + 2 )

	#define SUBPIXEL_SCALEBACK_FACTOR ((RGB_OVERSCALE << 16) / HINTING_HOR_OVERSCALE)

	#define SUBPIXEL_SCALEBACK_UPPER_LIMIT (SUBPIXEL_SCALEBACK_FACTOR *120 /100)
	#define SUBPIXEL_SCALEBACK_LOWER_LIMIT (SUBPIXEL_SCALEBACK_FACTOR *100 /120)
#endif // FSCFG_SUBPIXEL

#endif  /* FSCDEFS_DEFINED */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\fs\fsglue.c ===
/*++
	File:       FSglue.c

	Contains:   xxx put contents here (or delete the whole line) xxx

	Written by: xxx put name of writer here (or delete the whole line) xxx

	Copyright:  (c) 1987-1990, 1992 by Apple Computer, Inc., all rights reserved.
				(c) 1989-1999. Microsoft Corporation, all rights reserved.

	Change History (most recent first):


				 7/10/99  BeatS		Add support for native SP fonts, vertical RGB
		 <>     10/14/97    CB      rename ASSERT into FS_ASSERT
		 <>     02/21/97    CB      ClaudeBe, scaled component in composite glyphs
		 <>     12/14/95    CB      add usNonScaledAH and sNonScaledTSB to  GlyphData
		 <7>    11/27/90    MR      Need two scalars: one for (possibly rounded) outlines and cvt,
													and one (always fractional) metrics. [rb]
		 <6>    11/16/90    MR      Add SnapShotOutline to make instructions after components work
													[rb]
		 <5>     11/9/90    MR      Unrename fsg_ReleaseProgramPtrs to RELEASESFNTFRAG. [rb]
		 <4>     11/5/90    MR      Change globalGS.ppemDot6 to globalGS.fpem, change all instrPtr
													and curve flags to uint8. [rb]
		 <3>    10/31/90    MR      Add bit-field option for integer or fractional scaling [rb]
		 <2>    10/20/90    MR      Change matrix[2][2] back to a fract (in response to change in
													skia). However, ReduceMatrix converts it to a fixed after it has
													been used to "regularize" the matrix. Changed scaling routines
													for outline and CVT to use integer pixelsPerEm. Removed
													scaleFunc from the splineKey. Change some routines that were
													calling FracDiv and FixDiv to use LongMulDiv and ShortMulDiv for
													greater speed and precision. Removed fsg_InitScaling. [rb]
		<20>     8/22/90    MR      Only call fixmul when needed in finalComponentPass loop
		<19>      8/1/90    MR      Add line to set non90DegreeTransformation
		<18>     7/26/90    MR      remove references to metricInfo junk, don't include ToolUtils.h
		<17>     7/18/90    MR      Change error return type to int, split WorkSpace routine into
													two calls, added SWAPW macros
		<16>     7/14/90    MR      Fixed reference to const SQRT2 to FIXEDSQRT2
		<15>     7/13/90    MR      Ansi-C stuff, tried to use correct sizes for variables to avoid
									coercion (sp?)
		<12>     6/21/90    MR      Add calls to ReleaseSfntFrag
		<11>      6/4/90    MR      Remove MVT, change matrix to have bottom right element be a
									fixed.
		<10>      6/1/90    MR      Thou shalt not pay no more attention to the MVT!
		<8+>     5/29/90    MR      look for problem in Max45Trick
		 <8>     5/21/90    RB      bugfix in fsg_InitInterpreterTrans setting key->imageState
		 <7>      5/9/90    MR      Fix bug in MoreThanXYStretch
		 <6>      5/4/90    RB      support for new scan converter and decryption          mrr - add
									fsg_ReverseContours and key->reverseContour         to account
									for glyphs that are flipped.         This keeps the
									winding-number correct for         the scan converter.  Mike
									fixed fsg_Identity
		 <5>      5/3/90    RB      support for new scan converter and decryption  mrr - add
									fsg_ReverseContours and key->reverseContour to account for
									glyphs that are flipped. This keeps the winding-number correct
									for the scan converter.
		 <4>     4/10/90    CL      Fixed infinite loop counter - changed uint16 to int16 (Mikey).
		 <3>     3/20/90    CL      Added HasPerspective for finding fast case
									Removed #ifdef SLOW, OLD
									Changed NormalizeTransformation to use fpem (16.16) and to use max instead of length
									and to loop instead of recurse.
									Removed compensation for int ppem in fsg_InitInterpreterTrans (not needed with fpem)
									Greased loops in PreTransformGlyph, PostTransformGlyph, LocalPostTransformGlyph,
													 ShiftChar, ZeroOutTwilightZone, InitLocalT
									Changed GetPreMultipliers to special case unit vector * 2x2 matrix
									Added support for ppemDot6 and pointSizeDot6
									Changed fsg_MxMul to treat the perspective elements as Fracts
									arrays to pointers in ScaleChar
									Fixed bugs in loops in posttransformglyph, convert loops to --numPts >= 0
		 <2>     2/27/90    CL      It reconfigures itself during runtime !  New lsb and rsb
									calculation.  Shift bug in instructed components:  New error
									code for missing but needed table. (0x1409)  Optimization which
									has to do with shifting and copying ox/x and oy/y.  Fixed new
									format bug.  Changed transformed width calculation.  Fixed
									device metrics for transformed uninstructed sidebearing
									characters.  Dropoutcontrol scanconverter and SCANCTRL[]
									instruction.  Fixed transformed component bug.
									
	   <3.3>    11/14/89    CEL     Left Side Bearing should work right for any transformation. The
									phantom points are in, even for components in a composite glyph.
									They should also work for transformations. Device metric are
									passed out in the output data structure. This should also work
									with transformations. Another leftsidebearing along the advance
									width vector is also passed out. whatever the metrics are for
									the component at it's level. Instructions are legal in
									components. The old perspective bug has been fixed. The
									transformation is internally automatically normalized. This
									should also solve the overflow problem we had. Changed
									sidebearing point calculations to use 16.16 precision. For zero
									or negative numbers in my tricky/fast square root computation it
									would go instable and loop forever. It was not able to handle
									large transformations correctly. This has been fixed and the
									normalization may call it self recursively to gain extra
									precision! It used to normalize an identity transformation
									unecessarily.
	   <3.2>     10/6/89    CEL     Phantom points were removed causing a rounding of last 2 points
									bug. Characters would become distorted.
	   <3.1>     9/27/89    CEL     Fixed transformation anchor point bug.
	   <3.0>     8/28/89    sjk     Cleanup and one transformation bugfix
	   <2.2>     8/14/89    sjk     1 point contours now OK
	   <2.1>      8/8/89    sjk     Improved encryption handling
	   <2.0>      8/2/89    sjk     Just fixed EASE comment
	   <1.5>      8/1/89    sjk     Added composites and encryption. Plus some
									enhanclocalpostements.
	   <1.4>     6/13/89    SJK     Comment
	   <1.3>      6/2/89    CEL     16.16 scaling of metrics, minimum recommended ppem, point size 0
									bug, correct transformed integralized ppem behavior, pretty much
									so
	   <1.2>     5/26/89    CEL     EASE messed up on "c" comments
	  <y1.1>  5/26/89    CEL     Integrated the new Font Scaler 1.0 into Spline Fonts
	   <1.0>     5/25/89    CEL     Integrated 1.0 Font scaler into Bass code for the first time.

	To Do:
*/
/* rwb r/24/90 - Add support for scanControlIn and scanControlOut variables in global graphiscs
 * state
 */
/** System Includes **/

#define FSCFG_INTERNAL

/** FontScaler's Includes **/
#include "fserror.h"
#include "fscdefs.h"
#include "fontmath.h"
#include "fnt.h"
#include "interp.h"
#include "sfntaccs.h"
#include "fsglue.h"
#include "scale.h"

/*  CONSTANTS   */

/*  These constants are used for interpreting the scan control and scan type
	fields returned by the interpreter. They are documented in the TrueType
	specification under the SCANCTRL and SCANTYPE instructions.
 */

#define SCANINFO_SIZE_MASK   0x000000FF
#define SCANINFO_FLAGS_MASK  0x00003F00
#define SCANINFO_TYPE_MASK   0xFFFF0000
#define SCANINFO_SIZE_CLEAR  ~SCANINFO_SIZE_MASK
#define SCANINFO_FLAGS_CLEAR ~SCANINFO_FLAGS_MASK
#define SCANINFO_TYPE_CLEAR  ~SCANINFO_TYPE_MASK
#define SCANINFO_FLAGS_DONT  0x00003800
#define SCANINFO_FLAGS_DO    0x00000700
#define SCANCTRL_SIZE_MASK                   0x000000FF
#define SCANCTRL_DROPOUT_ALL_SIZES           0xFF
#define SCANCTRL_DROPOUT_IF_LESS             0x0100
#define SCANCTRL_DROPOUT_IF_ROTATED          0x0200
#define SCANCTRL_DROPOUT_IF_STRETCHED        0x0400
#define SCANCTRL_NODROP_UNLESS_LESS          0x0800
#define SCANCTRL_NODROP_UNLESS_ROTATED       0x1000
#define SCANCTRL_NODROP_UNLESS_STRETCH       0x2000
#define SCANTYPE_UNINITIALIZED               0xFFFF

/* fo the key->imageState field */
#define IMAGESTATE_ROTATED      0x0400
#define IMAGESTATE_STRETCHED    0x1000
#define IMAGESTATE_NON_POS_RECT 0x2000
#define IMAGESTATE_SIZE_MASK    0x00FF
#define IMAGESTATE_MAX_PPEM_SIZE 0x000000FF

#define COMPOSITE_ROOT                  0
#define MAX_TWILIGHT_CONTOURS       1
#define DEFAULT_COMPONENT_ELEMENTS  3UL
#define DEFAULT_COMPONENT_DEPTH     1UL
static  const   transMatrix   IdentTransform =
	{{{ONEFIX,      0,      0},
	  {     0, ONEFIX,      0},
	  {     0,      0, ONEFIX}}};

/*********** macros ************/

#define MAX(a, b)   (((a) > (b)) ? (a) : (b))

#define CHECK_GLYPHDATA(pglyphdata) FS_ASSERT((( (pglyphdata)->acIdent[0] == 'G') &&                            \
											( (pglyphdata)->acIdent[1] == 'D')),"Illegal GlyphData pointer");
#define MAX_COMPONENT_DEPTH(pMaxProfile) (uint32)MAX (pMaxProfile->maxComponentDepth, DEFAULT_COMPONENT_DEPTH)
#define MAX_COMPONENT_ELEMENTS(pMaxProfile) (uint32)MAX (pMaxProfile->maxComponentElements, DEFAULT_COMPONENT_ELEMENTS)

#define MAX_NESTED_GLYPHS(pMaxProfile) (uint32)((MAX_COMPONENT_DEPTH(pMaxProfile) + 1) + MAX_COMPONENT_ELEMENTS(pMaxProfile));

/**********************************************************************************/
/*  TYPEDEFS    */

typedef enum {
	glyphSimple,
	glyphIncompleteComposite,
	glyphComposite,
	glyphUndefined
} GlyphTypes;


/* Glyph Data   */

typedef struct GlyphData GlyphData;

struct GlyphData{
	char        acIdent[2];             /* Identifier for GlyphData                         */
	GlyphData * pSibling;               /* Pointer to siblings                              */
	GlyphData * pChild;                 /* Pointer to children                              */
	GlyphData * pParent;                /* Pointer to parent                                */
	sfac_GHandle hGlyph;                /* Handle for font access                           */
	GlyphTypes  GlyphType;              /* Type of glyph                                    */
	uint16      usGlyphIndex;           /* Glyph Index                                      */
	BBOX        bbox;                   /* Bounding box for glyph                           */
	uint16      usNonScaledAW;          /* Nonscaled Advance Width                          */
	uint16      usNonScaledAH;          /* Nonscaled Advance Height                         */
	int16       sNonScaledLSB;          /* Nonscaled Left Side Bearing                      */
	int16       sNonScaledTSB;          /* Nonscaled Top Side Bearing                       */
	uint16      usDepth;                /* Depth of Glyph in composite tree                 */
	sfac_ComponentTypes MultiplexingIndicator;/* Flag for arguments of composites                */
	boolean     bRoundXYToGrid;         /* Round composite offsets to grid                  */
	int16       sXOffset;               /* X offset for composite (if supplied)             */
	int16       sYOffset;               /* Y offset for composite (if supplied)             */
	uint16      usAnchorPoint1;         /* Anchor Point 1 for composites (if not offsets)   */
	uint16      usAnchorPoint2;         /* Anchor Point 2 for composites (if not offsets)   */
	transMatrix mulT;                   /* Transformation matrix for composite              */
	boolean     bUseChildMetrics;       /* Should use child metrics?                        */
	boolean     bUseMyMetrics;          /* Is glyph USE_MY_METRICS?                         */
	boolean     bScaleCompositeOffset; 	/* false by default, Apple scale the composite offset, MS doesn't */ 
	point       ptDevLSB;               /* Left Side Bearing Point                          */
	point       ptDevRSB;               /* Right Side Bearing Point                         */
	uint16      usScanType;             /* ScanType value for this glyph                    */
	uint16      usSizeOfInstructions;   /* Size (in bytes) of glyph instructions            */
	uint8 *     pbyInstructions;        /* Pointer to glyph instructions                    */
	fnt_ElementType * pGlyphElement;    /* Current glyph element pointer                    */

	/* the following variables were added to allow correct handling of scaled/rotated coposite glyphs */
	transMatrix currentTMatrix;         /* current Transf matrix, composite + user transform */
	boolean     bSameTransformAsMaster; /* same transformation as the master glyph, no composite scaling or rotation  */
};

/**********************************************************************************/

/* PRIVATE PROTOTYPES <4> */

FS_PRIVATE void fsg_GetOutlineSizeAndOffsets(
	uint16      usMaxPoints,
	uint16      usMaxContours,
	fsg_OutlineFieldInfo * offsetPtr,
	uint32 *    pulOutlineSize,
	uint32 *    pulReusableMarker);

FS_PRIVATE ErrorCode    fsg_CreateGlyphData(
	sfac_ClientRec *    ClientInfo,         /* sfnt Client information           */
	LocalMaxProfile *   pMaxProfile,        /* Max Profile Table                     */
	fsg_TransformRec *  TransformInfo,      /* Transformation information        */
	void *              pvGlobalGS,         /* GlobalGS                              */
	fsg_WorkSpaceAddr * pWorkSpaceAddr,     /* WorkSpace Address                     */
	fnt_ElementType *   pTwilightElement,   /* Twilight zone element */
	FntTraceFunc        traceFunc,          /* Trace function for interpreter   */
	boolean             bUseHints,          /* True if glyph is gridfitted       */
	uint16 *            pusScanType,        /* ScanType value                        */
	boolean *           pbGlyphHasOutline,  /* Outline for glyph                 */
	uint16 *            pusNonScaledAW);     /* Return NonScaled Advance Width    */
	
FS_PRIVATE ErrorCode   fsg_ExecuteGlyph(
	sfac_ClientRec *    ClientInfo,         /* sfnt Client information           */
	LocalMaxProfile *   pMaxProfile,        /* Max Profile Table                     */
	fsg_TransformRec *  TransformInfo,      /* Transformation information         */
	uint32              ulGlyphDataCount,   /* Max nested components */
	void *              pvGlobalGS,         /* GlobalGS                              */
	GlyphData *         pGlyphData,         /* GlyphData pointer                     */
	fsg_WorkSpaceAddr * pWorkSpaceAddr,     /* WorkSpace Address                     */
	fnt_ElementType *   pTwilightElement,   /* Twilight zone element */
	FntTraceFunc        traceFunc,          /* Trace function for interpreter    */
	boolean             bUseHints,          /* True if glyph is gridfitted       */
	boolean *           pbHasOutline,      /* True if glyph has outline         */
    uint32*             pCompositePoints,   /* total number of point for composites, to check for overflow */
    uint32*             pCompositeContours); /* total number of contours for composites, to check for overflow */
	
FS_PRIVATE void fsg_ChooseNextGlyph(
	fsg_WorkSpaceAddr * pWorkSpaceAddr,     /* WorkSpace Address        */
	GlyphData *         pGlyphData,         /* GlyphData pointer        */
	GlyphData **        ppNextGlyphData);   /* Next GlyphData pointer   */

FS_PRIVATE ErrorCode    fsg_SimpleInnerGridFit (
	void *              pvGlobalGS,
	fnt_ElementType *   pTwilightElement,
	fnt_ElementType *   pGlyphElement,
	boolean             bUseHints,
	FntTraceFunc        traceFunc,
	uint16              usEmResolution,
	uint16              usNonScaledAW,
	uint16              usNonScaledAH,
	int16               sNonScaledLSB,
	int16               sNonScaledTSB,
	boolean				bSameTransformAsMaster, /* local transf. same as master transf.   */
	transMatrix		    CurrentTMatrix,               /* Current Transformation   */
	BBOX *              bbox,
	uint16              usSizeOfInstructions,
	uint8 *             instructionPtr,
	uint16 *            pusScanType,
	uint16 *            pusScanControl,
	boolean *           pbChangeScanControl);

FS_PRIVATE ErrorCode    fsg_CompositeInnerGridFit (
	void *              pvGlobalGS,
	fnt_ElementType *   pTwilightElement,
	fnt_ElementType *   pGlyphElement,
	boolean             bUseHints,
	FntTraceFunc        traceFunc,
	uint16              usEmResolution,
	uint16              usNonScaledAW,
	uint16              usNonScaledAH,
	int16               sNonScaledLSB,
	int16               sNonScaledTSB,
	boolean				bSameTransformAsMaster, /* local transf. same as master transf.   */
	transMatrix		    CurrentTMatrix,               /* Current Transformation   */
	BBOX *              bbox,
	uint16              usSizeOfInstructions,
	uint8 *             instructionPtr,
	uint16 *            pusScanType,
	uint16 *            pusScanControl,
	boolean *           pbChangeScanControl);

FS_PRIVATE void fsg_LinkChild(
	GlyphData *     pGlyphData,             /* GlyphData pointer        */
	GlyphData *     pChildGlyphData);       /* Child GlyphData pointer  */

FS_PRIVATE void fsg_MergeGlyphData(
	void *          pvGlobalGS,             /* GlobalGS            */
	GlyphData *     pChildGlyphData,       /* GlyphData pointer     */
	uint16          usEmResolution);

FS_PRIVATE void fsg_TransformChild(
	GlyphData *     pGlyphData);            /* GlyphData pointer    */

FS_PRIVATE void fsg_MergeScanType(
	GlyphData *     pGlyphData,             /* GlyphData pointer    */
	GlyphData *     pParentGlyphData);      /* GlyphData pointer    */

FS_PRIVATE boolean fsg_DoScanControl(
	uint16 usScanControl,
	uint32 ulImageState);

FS_PRIVATE void fsg_InitializeGlyphDataMemory(
	uint32                  ulGlyphDataCount,
	fsg_WorkSpaceAddr *     pWorkSpaceAddr);/* WorkSpace Address    */

FS_PRIVATE  ErrorCode fsg_AllocateGlyphDataMemory(
	uint32                  ulGlyphDataCount,
	fsg_WorkSpaceAddr *     pWorkSpaceAddr, /* WorkSpace Address    */
	GlyphData **            ppGlyphData);   /* GlyphData pointer    */

FS_PRIVATE void fsg_DeallocateGlyphDataMemory(
	fsg_WorkSpaceAddr * pWorkSpaceAddr,     /* WorkSpace Address    */
	GlyphData *         pGlyphData);        /* GlyphData pointer    */

FS_PRIVATE void fsg_InitializeGlyphData(
	GlyphData *             pGlyphData,     /* GlyphData pointer    */
	fsg_WorkSpaceAddr *     pWorkSpaceAddr, /* WorkSpace Address    */
	uint16                  usGlyphIndex,   /* Glyph Index          */
	uint16                  usDepth);       /* Glyph depth          */

FS_PRIVATE void fsg_CheckFit(
	int32       lSize1,
	int32       lSize2,
	int32       lSize3,
	int32       lTotalSize,
	uint32 *    pfResult);

FS_PRIVATE void  fsg_Embold(
	fsg_WorkSpaceAddr * pWorkSpaceAddr,
	void *              pvGlobalGS,
	boolean             bUseHints, /* True if glyph is gridfitted       */
	boolean             bBitmapEmboldening
#ifdef FSCFG_SUBPIXEL
	,boolean            bSubPixel
#endif // FSCFG_SUBPIXEL
	);     

void fsg_CheckOutlineOrientation (fnt_ElementType *pElement);

/* FSGlue Code  */

/* ..............MEMORY MANAGEMENT ROUTINES................ */


/*                                                              
 * fsg_PrivateFontSpaceSize : This data should remain intact for the life of the sfnt
 *              because function and instruction defs may be defined in the font program
 *              and/or the preprogram.
 */
/*

	 PRIVATE SPACE Memory Layout

typedef struct fsg_PrivateSpaceOffsets {
	 0  +===========+   ---------------------  <- PrivateSpaceOffsets.offset_storage;
		|           |
		|           |   TrueType Storage
		|           |
		+===========+   ---------------------  <- PrivateSpaceOffsets.offset_functions;
		|           |
		|           |   TrueType Function Defs
		|           |
		+===========+   ---------------------  <- PrivateSpaceOffsets.offset_instrDefs;
		|           |
		|           |   TrueType Instruction Defs
		|           |
		+===========+   ---------------------  <- PrivateSpaceOffsets.offset_controlValues;
		|           |
		|           |   TrueType Scaled CVT
		|           |
		+===========+   ---------------------  <- PrivateSpaceOffsets.offset_globalGS;
		| pStack    |
		| pStorage  |
		| pCVT      |
		| pFDEF     |   TrueType Global GS
		| pIDEF     |
		| pFPGM     |
		| pPPGM     |
		| pGlyphPgm |
		+===========+   ---------------------  <- PrivateSpaceOffsets.offset_FontProgram;
		|           |
		|           |   TrueType Font Program
		|           |
		+===========+   ---------------------  <- PrivateSpaceOffsets.offset_PreProgram;
		|           |
		|           |   TrueType Pre Program
		|           |
		+===========+   ---------------------  <- PrivateSpaceOffsets.offset_TwilightZone;
		|   poox    |
		+-----------+
		|    pox    |
		+-----------+
		|    px     |   Twilight Element
		+-----------+
		:   ...     :
		+-----------+
		|    pep    |
		+-----------+
		|    nc     |
		+===========+   ---------------------  <- PrivateSpaceOffsets.offset_TwilightOutline;
		|x[maxtzpts]|   Twilight Outline
		+-----------+
		|y[maxtzpts]|
		+-----------+
		:   ...     :
		+-----------+
		|ep[maxtzct]|
		+-----------+
		|ox[maxtzpt]|
		+-----------+
		|oox[mxtzpt]|
		+-----------+
		:   ...     :
		+-----------+
		|f[maxtzpts]|
		+===========+   ---------------------

*/
FS_PUBLIC uint32  fsg_PrivateFontSpaceSize (
	sfac_ClientRec *            ClientInfo,
	LocalMaxProfile *           pMaxProfile,      /* Max Profile Table    */
	fsg_PrivateSpaceOffsets *   PrivateSpaceOffsets)
{
	uint32  ulOutlineSize;
	uint32  ulReusableMarker;   /* Unused dummy variable */
    uint32  ulLastOffset;

	PrivateSpaceOffsets->offset_storage         = 0L;
	PrivateSpaceOffsets->offset_functions       = PrivateSpaceOffsets->offset_storage         + (uint32)sizeof (F26Dot6) * (uint32)pMaxProfile->maxStorage;
	PrivateSpaceOffsets->offset_instrDefs       = PrivateSpaceOffsets->offset_functions   + (uint32)sizeof (fnt_funcDef) * (uint32)pMaxProfile->maxFunctionDefs;
	PrivateSpaceOffsets->offset_controlValues   = PrivateSpaceOffsets->offset_instrDefs   + (uint32)sizeof (fnt_instrDef) * (uint32)pMaxProfile->maxInstructionDefs;     /* <4> */
	PrivateSpaceOffsets->offset_globalGS        = PrivateSpaceOffsets->offset_controlValues + (uint32)sizeof (F26Dot6) *
		((uint32)SFAC_LENGTH (ClientInfo, sfnt_controlValue) / (uint32)sizeof (sfnt_ControlValue));

	ALIGN(voidPtr, PrivateSpaceOffsets->offset_globalGS);
#ifdef FSCFG_SUBPIXEL
	PrivateSpaceOffsets->offset_storageSubPixel         = PrivateSpaceOffsets->offset_globalGS    + (uint32)sizeof (fnt_GlobalGraphicStateType);
	PrivateSpaceOffsets->offset_functionsSubPixel       = PrivateSpaceOffsets->offset_storageSubPixel         + (uint32)sizeof (F26Dot6) * (uint32)pMaxProfile->maxStorage;
	PrivateSpaceOffsets->offset_instrDefsSubPixel       = PrivateSpaceOffsets->offset_functionsSubPixel   + (uint32)sizeof (fnt_funcDef) * (uint32)pMaxProfile->maxFunctionDefs;
	PrivateSpaceOffsets->offset_controlValuesSubPixel   = PrivateSpaceOffsets->offset_instrDefsSubPixel   + (uint32)sizeof (fnt_instrDef) * (uint32)pMaxProfile->maxInstructionDefs;     /* <4> */
	PrivateSpaceOffsets->offset_globalGSSubPixel        = PrivateSpaceOffsets->offset_controlValuesSubPixel + (uint32)sizeof (F26Dot6) *
		((uint32)SFAC_LENGTH (ClientInfo, sfnt_controlValue) / (uint32)sizeof (sfnt_ControlValue));

	ALIGN(voidPtr, PrivateSpaceOffsets->offset_globalGSSubPixel);
	PrivateSpaceOffsets->offset_FontProgram     = PrivateSpaceOffsets->offset_globalGSSubPixel + (uint32)sizeof (fnt_GlobalGraphicStateType);
#else
	PrivateSpaceOffsets->offset_FontProgram     = PrivateSpaceOffsets->offset_globalGS    + (uint32)sizeof (fnt_GlobalGraphicStateType);
#endif // FSCFG_SUBPIXEL
	PrivateSpaceOffsets->offset_PreProgram      = PrivateSpaceOffsets->offset_FontProgram + (uint32)SFAC_LENGTH (ClientInfo, sfnt_fontProgram);

    PrivateSpaceOffsets->offset_TwilightZone    = PrivateSpaceOffsets->offset_PreProgram      + (uint32)SFAC_LENGTH (ClientInfo, sfnt_preProgram);
	ALIGN(voidPtr, PrivateSpaceOffsets->offset_TwilightZone);

#ifdef FSCFG_SUBPIXEL
    PrivateSpaceOffsets->offset_TwilightZoneSubPixel    = PrivateSpaceOffsets->offset_TwilightZone + (uint32)sizeof (fnt_ElementType);
	ALIGN(voidPtr, PrivateSpaceOffsets->offset_TwilightZoneSubPixel);
/*
	Setup the twilight zone element data structure. This data structure will
	contain all of the address into the twilight zone outline space.
*/
	PrivateSpaceOffsets->offset_TwilightOutline = PrivateSpaceOffsets->offset_TwilightZoneSubPixel + (uint32)sizeof (fnt_ElementType);
	ALIGN(int32, PrivateSpaceOffsets->offset_TwilightOutline);
#else
/*
	Setup the twilight zone element data structure. This data structure will
	contain all of the address into the twilight zone outline space.
*/
	PrivateSpaceOffsets->offset_TwilightOutline = PrivateSpaceOffsets->offset_TwilightZone + (uint32)sizeof (fnt_ElementType);
	ALIGN(int32, PrivateSpaceOffsets->offset_TwilightOutline);
    ulLastOffset = PrivateSpaceOffsets->offset_TwilightOutline;
#endif // FSCFG_SUBPIXEL

/*
	Setup Twilight Zone outline space. This space contains all of the components
	to describe a Twilight Zone outline. Set the offset to our current position,
	and as we calculate the size of this outline space, update the field
	offsets e.g. x, ox, oox, &c.
*/
	/*** Outline -- TWILIGHT ZONE ***/

	fsg_GetOutlineSizeAndOffsets(
		pMaxProfile->maxTwilightPoints,
		MAX_TWILIGHT_CONTOURS,
		&(PrivateSpaceOffsets->TwilightOutlineFieldOffsets),
		&ulOutlineSize,
		&ulReusableMarker);

#ifdef FSCFG_SUBPIXEL
	PrivateSpaceOffsets->offset_TwilightOutlineSubPixel = PrivateSpaceOffsets->offset_TwilightOutline + ulOutlineSize;
	ALIGN(int32, PrivateSpaceOffsets->offset_TwilightOutlineSubPixel);
    ulLastOffset = PrivateSpaceOffsets->offset_TwilightOutlineSubPixel;
#endif // FSCFG_SUBPIXEL

#ifdef FSCFG_FONTOGRAPHER_BUG
/*
		Fontographer 3.5 has a bug. This is causing numerous symbol fonts to
		have the critical error : Inst: RCVT CVT Out of range. CVT = 255
		This flag is meant to be set under Windows. If will cause additional
		memory to be allocated for the CVT if necessary in order to be sure
		that this illegal read will access memory within the legal range.
		Under a secure rasterizer, this flag will cause RCVT with CVT <= 255
		and CVT > NumCvt to be classified as error instead of critical error */

	if ((ulLastOffset + ulOutlineSize) - PrivateSpaceOffsets->offset_controlValues < 256 * (uint32)sizeof (F26Dot6))
	{
		ulOutlineSize = (256 * (uint32)sizeof (F26Dot6)) + PrivateSpaceOffsets->offset_controlValues - ulLastOffset;
	}
#endif // FSCFG_FONTOGRAPHER_BUG

	return ((ulLastOffset + ulOutlineSize) - PrivateSpaceOffsets->offset_storage);
}


/*                          
 * fsg_WorkSpaceSetOffsets : This stuff changes with each glyph
 *
 * Computes the workspace size and sets the offsets into it.
 *
 */

/*

	WORKSPACE Memory Layout

	  0 +===========+    ---------------------  <- WorkSpaceOffsets.ulGlyphElementOffset
		|   poox    |
		+-----------+
		|    pox    |
		+-----------+
		|    px     |   Glyph Element 1
		+-----------+
		:   ...     :
		+-----------+
		|    pep    |
		+-----------+
		|    nc     |
		+===========+   ---------------------
		|   poox    |
		+-----------+
		|    pox    |
		+-----------+
		|    px     |   Glyph Element 2
		+-----------+
		:   ...     :
		+-----------+
		|    pep    |
		+-----------+
		|    nc     |
		+===========+   ---------------------
		|           |
		:           :          :
		|           |
		+===========+   ---------------------
		|   poox    |
		+-----------+
		|    pox    |
		+-----------+
		|    px     |   Glyph Element [MaxComponentDepth + 1]
		+-----------+
		:   ...     :
		+-----------+
		|    pep    |
		+-----------+
		|    nc     |
		+===========+   ---------------------  <- WorkSpaceOffsets.ulGlyphOutlineOffset
		|x[maxpts]  |   Glyph Outline
		+-----------+
		|y[maxpts]  |
		+-----------+
		:   ...     :
		+-----------+
		|ep[maxctrs]|
		+-----------+
		|ox[maxpts] |   <- WorkSpaceOffsets.ulReusableMemoryOffset


        !!! with SubPixel, we need to put the ulReusableMemoryOffset after ox because of the conversion done in GetContourData !!!
		+-----------+
		|oox[maxpts]|
		+-----------+
		:   ...     :
		+-----------+
		|f[maxpts]  |
		+===========+   ---------------------  <- WorkSpaceOffsets.ulGlyphDataByteSetBaseOffset
		| T| F| T| F|
		+-----------+
		| F| F| F| F|
		+-----------+
		| F| F| F| F|   Glyph Data Allocation ByteSet
		+-----------+   (number of bytes = ulGlyphDataCount)
		| F| F| F| F|
		+-----------+
		| F| F| F| F|
		+===========+   ---------------------  <- WorkSpaceOffsets.ulGlyphDataBaseOffset
		|  acIdent  |
		+-----------+
		| pSibling  |
		+-----------+
		|  pChild   |
		+-----------+
		|  pParent  |
		+-----------+   GlyphData 1
		|  hGlyph   |
		+-----------+
		| GlyphType |
		+-----------+
		:           :
		+-----------+
		|GlyphElemnt|
		+===========+   ---------------------
		|  acIdent  |
		+-----------+
		| pSibling  |
		+-----------+
		|  pChild   |
		+-----------+
		|  pParent  |
		+-----------+   GlyphData 2
		|  hGlyph   |
		+-----------+
		| GlyphType |
		+-----------+
		:           :
		+-----------+
		|GlyphElemnt|
		+===========+   ---------------------
		|           |
		:           :           :
		|           |
		+===========+   ---------------------
		|  acIdent  |
		+-----------+
		| pSibling  |
		+-----------+
		|  pChild   |
		+-----------+
		|  pParent  |
		+-----------+   GlyphData [ulGlyphDataCount]
		|  hGlyph   |
		+-----------+
		| GlyphType |
		+-----------+
		:           :
		+-----------+
		|GlyphElemnt|
		+===========+   ---------------------  <- WorkSpaceOffsets.ulStackOffset
		|           |
		|           |
		|           |   Stack
		|           |
		|           |
		|           |
		+===========+   ---------------------

*/

FS_PUBLIC uint32    fsg_WorkSpaceSetOffsets (
	LocalMaxProfile *        pMaxProfile,    /* Max Profile Table    */
	fsg_WorkSpaceOffsets *  WorkSpaceOffsets,
	int32 *                 plExtraWorkSpace)
{
	uint32                       ulOutlineDataSize;
	uint32                       ulWorkSpacePos;
	uint32                       ulGlyphDataCount;
    uint16                       maxStackElements;

	ulWorkSpacePos = 0UL;

/*
	Setup the glyph element data array. This data structure contains all of the
	addresses into the glyph outline space. There are the same number of glyph
	element arrays as there are outline spaces; this allows us to handle the
	worstcase composite in the font.
*/
	WorkSpaceOffsets->ulGlyphElementOffset = ulWorkSpacePos;
	ulWorkSpacePos += (uint32)sizeof (fnt_ElementType) *
		  (uint32)(MAX_COMPONENT_DEPTH(pMaxProfile) + 1);

/*** Outline -- GLYPH *****/
/*
	Setup Glyph outline space. This space contains all of the components
	to describe a Glyph outline. Set the offset to our current position,
	and as we calculate the size of this outline space, update the elemental
	offsets e.g. x, ox, oox, &c.

	Once we have calculated the size of one outline space, we will duly note
	its size, and then add enough space to handle the outlines for the worst
	case composite depth in the font.
*/
	ALIGN(int16, ulWorkSpacePos);
	WorkSpaceOffsets->ulGlyphOutlineOffset = ulWorkSpacePos; /* Remember start of Glyph Element */

	fsg_GetOutlineSizeAndOffsets(
		(uint16)(PHANTOMCOUNT + MAX (pMaxProfile->maxPoints, pMaxProfile->maxCompositePoints)),
		(uint16)MAX (pMaxProfile->maxContours, pMaxProfile->maxCompositeContours),
		&(WorkSpaceOffsets->GlyphOutlineFieldOffsets),
		&ulOutlineDataSize,
		(uint32 *)&(WorkSpaceOffsets->ulReusableMemoryOffset));

	/* Adjust Reusable memory marker to be based from zero, rather than GlyphOutline */

	WorkSpaceOffsets->ulReusableMemoryOffset += WorkSpaceOffsets->ulGlyphOutlineOffset;

	ulWorkSpacePos += ulOutlineDataSize;
/*
	Set the GlyphData ByteSet array. This array is used to track the memory used
	in GlyphData. Each entry in this array is a boolean.  One needs to also
	calculate the number of GlyphData's that will be needed to handle the
	worstcase composite in the font.
*/
	ALIGN(boolean, ulWorkSpacePos);
	WorkSpaceOffsets->ulGlyphDataByteSetOffset = ulWorkSpacePos;
	ulGlyphDataCount = MAX_NESTED_GLYPHS(pMaxProfile);

	ulWorkSpacePos += ulGlyphDataCount * (uint32)sizeof (boolean);
/*
	Set up the GlyphData array. This array contains the information needed
	to describe composites and components for a glyph.
*/
	ALIGN(voidPtr, ulWorkSpacePos);
	WorkSpaceOffsets->ulGlyphDataOffset = ulWorkSpacePos;
	ulWorkSpacePos += (uint32)sizeof(GlyphData) * ulGlyphDataCount;


	ALIGN(F26Dot6, ulWorkSpacePos);
	WorkSpaceOffsets->ulStackOffset = ulWorkSpacePos;

    maxStackElements = pMaxProfile->maxStackElements;

#ifdef FSCFG_EUDC_EDITOR_BUG
    if (maxStackElements == 0)
    {
        maxStackElements = 1;
    }
#endif // FSCFG_EUDC_EDITOR_BUG

	ulWorkSpacePos += (uint32)maxStackElements * (uint32)sizeof (F26Dot6);

/* Calculate amount of extra memory */

	*plExtraWorkSpace = (int32)ulWorkSpacePos - (int32)WorkSpaceOffsets->ulReusableMemoryOffset;
	WorkSpaceOffsets->ulMemoryBase6Offset = 0L;
	WorkSpaceOffsets->ulMemoryBase7Offset = 0L;

/* Return the total size of the WorkSpace memory.   */

	return(ulWorkSpacePos);

}

FS_PRIVATE void fsg_GetOutlineSizeAndOffsets(
	uint16                  usMaxPoints,
	uint16                  usMaxContours,
	fsg_OutlineFieldInfo *  offsetPtr,
	uint32 *                pulOutlineSize,
	uint32 *                pulReusableMarker)

{
	uint32      ulArraySize;

	offsetPtr->onCurve = 0;

	*pulOutlineSize    = (uint32)usMaxPoints * (uint32)sizeof (uint8);
	ALIGN(int16, *pulOutlineSize);

	offsetPtr->sp   = *pulOutlineSize;
	ulArraySize = (uint32)usMaxContours * (uint32)sizeof (int16);
	*pulOutlineSize += ulArraySize;
	offsetPtr->ep   = *pulOutlineSize;
	*pulOutlineSize += ulArraySize;

	/* need to be before the reusable marker, now that this flag is exported */
	offsetPtr->fc       = *pulOutlineSize;
	*pulOutlineSize    += (uint32)usMaxContours * (uint32)sizeof (uint8);

	ALIGN(F26Dot6, *pulOutlineSize);
	offsetPtr->x       = *pulOutlineSize;
	ulArraySize = (uint32)usMaxPoints * (uint32)sizeof (F26Dot6);
	*pulOutlineSize    += ulArraySize;
	offsetPtr->y       = *pulOutlineSize;
	*pulOutlineSize    += ulArraySize;

#ifndef FSCFG_SUBPIXEL
	*pulReusableMarker = *pulOutlineSize;
	ALIGN(voidPtr, *pulReusableMarker);
#endif // FSCFG_SUBPIXEL
	/* Everything below this point can be reused during contour scanning */

	offsetPtr->ox      = *pulOutlineSize;
	*pulOutlineSize    += ulArraySize;

#ifdef FSCFG_SUBPIXEL
	*pulReusableMarker = *pulOutlineSize;
	ALIGN(voidPtr, *pulReusableMarker);
#endif // FSCFG_SUBPIXEL

    offsetPtr->oy      = *pulOutlineSize;
	*pulOutlineSize    += ulArraySize;

    offsetPtr->oox     = *pulOutlineSize;
	*pulOutlineSize    += ulArraySize;
	offsetPtr->ooy     = *pulOutlineSize;
	*pulOutlineSize    += ulArraySize;

	offsetPtr->f       = *pulOutlineSize;
	*pulOutlineSize    += (uint32)usMaxPoints * (uint32)sizeof (uint8);

    ALIGN(int32, *pulOutlineSize);

#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	offsetPtr->pcr      = *pulOutlineSize;
	*pulOutlineSize    += (uint32)usMaxPoints * (uint32)sizeof (PhaseControlRelation);
#endif

}


FS_PUBLIC void  fsg_UpdatePrivateSpaceAddresses(
	sfac_ClientRec *        ClientInfo,     /* Cached sfnt information  */
	LocalMaxProfile *       pMaxProfile,     /* Max Profile Table         */
	char *                  pPrivateFontSpace,
	fsg_PrivateSpaceOffsets * PrivateSpaceOffsets,
	void *                  pvStack,        /* pointer to stack         */
	void **                 pvFontProgram,  /* pointer to font program  */
	void **                 pvPreProgram)   /* pointer to pre program   */
{
	void *                       pvGlobalGS;
	void *                       pvCVT;          /* pointer to CVT  */
	void *                       pvStore;
	void *                       pvFuncDef;
	void *                       pvInstrDef;
	uint32                       ulLengthFontProgram, ulLengthPreProgram;

	pvCVT =         pPrivateFontSpace + PrivateSpaceOffsets->offset_controlValues;
	pvStore =       pPrivateFontSpace + PrivateSpaceOffsets->offset_storage;
	pvFuncDef =     pPrivateFontSpace + PrivateSpaceOffsets->offset_functions;
	pvInstrDef =    pPrivateFontSpace + PrivateSpaceOffsets->offset_instrDefs;
	pvGlobalGS =    pPrivateFontSpace + PrivateSpaceOffsets->offset_globalGS;

	*pvFontProgram =  pPrivateFontSpace + PrivateSpaceOffsets->offset_FontProgram;
	ulLengthFontProgram = SFAC_LENGTH(ClientInfo, sfnt_fontProgram);
	*pvPreProgram =   pPrivateFontSpace + PrivateSpaceOffsets->offset_PreProgram;
	ulLengthPreProgram = SFAC_LENGTH(ClientInfo, sfnt_preProgram);

	itrp_UpdateGlobalGS(pvGlobalGS, pvCVT, pvStore, pvFuncDef, pvInstrDef, pvStack,
		pMaxProfile, (uint16)((uint32)SFAC_LENGTH (ClientInfo, sfnt_controlValue) / (uint32)sizeof (sfnt_ControlValue)),
		ulLengthFontProgram, *pvFontProgram, ulLengthPreProgram, *pvPreProgram, ClientInfo->lClientID);

#ifdef FSCFG_SUBPIXEL
    /* prepare the second pvGlobalGS for SubPixel compatible width */
	pvCVT =         pPrivateFontSpace + PrivateSpaceOffsets->offset_controlValuesSubPixel;
	pvStore =       pPrivateFontSpace + PrivateSpaceOffsets->offset_storageSubPixel;
	pvFuncDef =     pPrivateFontSpace + PrivateSpaceOffsets->offset_functionsSubPixel;
	pvInstrDef =    pPrivateFontSpace + PrivateSpaceOffsets->offset_instrDefsSubPixel;
	pvGlobalGS =    pPrivateFontSpace + PrivateSpaceOffsets->offset_globalGSSubPixel;

	itrp_UpdateGlobalGS(pvGlobalGS, pvCVT, pvStore, pvFuncDef, pvInstrDef, pvStack,
		pMaxProfile, (uint16)((uint32)SFAC_LENGTH (ClientInfo, sfnt_controlValue) / (uint32)sizeof (sfnt_ControlValue)),
		ulLengthFontProgram, *pvFontProgram, ulLengthPreProgram, *pvPreProgram, ClientInfo->lClientID);
#endif // FSCFG_SUBPIXEL

}

FS_PUBLIC void  fsg_UpdateWorkSpaceAddresses(
	char *                  pWorkSpace,
	fsg_WorkSpaceOffsets *  WorkSpaceOffsets,
	fsg_WorkSpaceAddr *     pWorkSpaceAddr)
{
	pWorkSpaceAddr->pStack = (F26Dot6 *)(WorkSpaceOffsets->ulStackOffset + pWorkSpace);
	pWorkSpaceAddr->pGlyphOutlineBase = WorkSpaceOffsets->ulGlyphOutlineOffset + pWorkSpace;
	pWorkSpaceAddr->pGlyphElement = (fnt_ElementType *)(WorkSpaceOffsets->ulGlyphElementOffset + pWorkSpace);
	pWorkSpaceAddr->pGlyphDataByteSet = (boolean *)(WorkSpaceOffsets->ulGlyphDataByteSetOffset + pWorkSpace);
	pWorkSpaceAddr->pvGlyphData = (void *)(WorkSpaceOffsets->ulGlyphDataOffset + pWorkSpace);
	pWorkSpaceAddr->pReusableMemoryMarker = WorkSpaceOffsets->ulReusableMemoryOffset + pWorkSpace;
}

FS_PUBLIC void  fsg_UpdateWorkSpaceElement(
	fsg_WorkSpaceOffsets *  WorkSpaceOffsets,
	fsg_WorkSpaceAddr *     pWorkSpaceAddr)
{
	char *                  pOutlineBase;
	fnt_ElementType *       pGlyphElement;        /* Address of Glyph Element array   */
	fsg_OutlineFieldInfo *  pOffset;

	pOutlineBase =  (char *)pWorkSpaceAddr->pGlyphOutlineBase;
	pGlyphElement = pWorkSpaceAddr->pGlyphElement;

	/* Note: only the first level glyph element has address updated. Second */
	/* levels are updated when referenced.                                           */

	pOffset             = & (WorkSpaceOffsets->GlyphOutlineFieldOffsets);

	pGlyphElement->x        = (F26Dot6 *) (pOutlineBase + pOffset->x);
	pGlyphElement->y        = (F26Dot6 *) (pOutlineBase + pOffset->y);
	pGlyphElement->ox       = (F26Dot6 *) (pOutlineBase + pOffset->ox);
	pGlyphElement->oy       = (F26Dot6 *) (pOutlineBase + pOffset->oy);
	pGlyphElement->oox      = (F26Dot6 *) (pOutlineBase + pOffset->oox);
	pGlyphElement->ooy      = (F26Dot6 *) (pOutlineBase + pOffset->ooy);
	pGlyphElement->sp       = (int16 *) (pOutlineBase + pOffset->sp);
	pGlyphElement->ep       = (int16 *) (pOutlineBase + pOffset->ep);
	pGlyphElement->onCurve  = (uint8 *) (pOutlineBase + pOffset->onCurve);
	pGlyphElement->f        = (uint8 *) (pOutlineBase + pOffset->f);

	pGlyphElement->fc       = (uint8 *) (pOutlineBase + pOffset->fc);

#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	pGlyphElement->pcr      = (PhaseControlRelation *) (pOutlineBase + pOffset->pcr);
#endif
}

FS_PUBLIC void *    fsg_QueryGlobalGS(
	char *                  pPrivateFontSpace,
	fsg_PrivateSpaceOffsets * PrivateSpaceOffsets)
{
	return ((void *)(pPrivateFontSpace + PrivateSpaceOffsets->offset_globalGS));
}

#ifdef FSCFG_SUBPIXEL
FS_PUBLIC void *    fsg_QueryGlobalGSSubPixel(
	char *                  pPrivateFontSpace,
	fsg_PrivateSpaceOffsets * PrivateSpaceOffsets)
{
	return ((void *)(pPrivateFontSpace + PrivateSpaceOffsets->offset_globalGSSubPixel));
}
#endif // FSCFG_SUBPIXEL

FS_PUBLIC void *      fsg_QueryTwilightElement(
	char *                  pPrivateFontSpace,
	fsg_PrivateSpaceOffsets * PrivateSpaceOffsets)
{
	fnt_ElementType *        pTwilightElement; /* Address of Twilight Zone Element */
	fsg_OutlineFieldInfo *  pOffset;
	char *                       pTemp;

	pOffset                 = &(PrivateSpaceOffsets->TwilightOutlineFieldOffsets);
	pTemp                   = pPrivateFontSpace + PrivateSpaceOffsets->offset_TwilightOutline;
	pTwilightElement        = (fnt_ElementType *)(pPrivateFontSpace + PrivateSpaceOffsets->offset_TwilightZone);

	pTwilightElement->x         = (F26Dot6 *) (pTemp + pOffset->x);
	pTwilightElement->y         = (F26Dot6 *) (pTemp + pOffset->y);
	pTwilightElement->ox        = (F26Dot6 *) (pTemp + pOffset->ox);
	pTwilightElement->oy        = (F26Dot6 *) (pTemp + pOffset->oy);
	pTwilightElement->oox       = (F26Dot6 *) (pTemp + pOffset->oox);
	pTwilightElement->ooy       = (F26Dot6 *) (pTemp + pOffset->ooy);
	pTwilightElement->sp        = (int16 *) (pTemp + pOffset->sp);
	pTwilightElement->ep        = (int16 *) (pTemp + pOffset->ep);
	pTwilightElement->onCurve   = (uint8 *) (pTemp + pOffset->onCurve);
	pTwilightElement->f         = (uint8 *) (pTemp + pOffset->f);

	pTwilightElement->fc        = (uint8 *) (pTemp + pOffset->fc);

#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	pTwilightElement->pcr		= (PhaseControlRelation *) (pTemp + pOffset->pcr);
#endif

	return (void *)pTwilightElement;
}

#ifdef FSCFG_SUBPIXEL
FS_PUBLIC void *      fsg_QueryTwilightElementSubPixel(
	char *                  pPrivateFontSpace,
	fsg_PrivateSpaceOffsets * PrivateSpaceOffsets)
{
	fnt_ElementType *        pTwilightElement; /* Address of Twilight Zone Element */
	fsg_OutlineFieldInfo *  pOffset;
	char *                       pTemp;

	pOffset                 = &(PrivateSpaceOffsets->TwilightOutlineFieldOffsets);
	pTemp                   = pPrivateFontSpace + PrivateSpaceOffsets->offset_TwilightOutlineSubPixel;
	pTwilightElement        = (fnt_ElementType *)(pPrivateFontSpace + PrivateSpaceOffsets->offset_TwilightZoneSubPixel);

	pTwilightElement->x         = (F26Dot6 *) (pTemp + pOffset->x);
	pTwilightElement->y         = (F26Dot6 *) (pTemp + pOffset->y);
	pTwilightElement->ox        = (F26Dot6 *) (pTemp + pOffset->ox);
	pTwilightElement->oy        = (F26Dot6 *) (pTemp + pOffset->oy);
	pTwilightElement->oox       = (F26Dot6 *) (pTemp + pOffset->oox);
	pTwilightElement->ooy       = (F26Dot6 *) (pTemp + pOffset->ooy);
	pTwilightElement->sp        = (int16 *) (pTemp + pOffset->sp);
	pTwilightElement->ep        = (int16 *) (pTemp + pOffset->ep);
	pTwilightElement->onCurve   = (uint8 *) (pTemp + pOffset->onCurve);
	pTwilightElement->f         = (uint8 *) (pTemp + pOffset->f);

#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	pTwilightElement->pcr		= (PhaseControlRelation *) (pTemp + pOffset->pcr);
#endif
	return (void *)pTwilightElement;
}
#endif // FSCFG_SUBPIXEL

FS_PUBLIC void *      fsg_QueryStack(fsg_WorkSpaceAddr * pWorkSpaceAddr)
{
    /* we don't allow the stack to be used to pass informations between pre-program and glyph program
       or between two glyph programs */
	return ((void *)pWorkSpaceAddr->pStack);
}

FS_PUBLIC void *      fsg_QueryReusableMemory(
	char *                  pWorkSpace,
	fsg_WorkSpaceOffsets *  WorkSpaceOffsets)
{
	return pWorkSpace + WorkSpaceOffsets->ulReusableMemoryOffset;
}

FS_PUBLIC void  fsg_CheckWorkSpaceForFit(
	fsg_WorkSpaceOffsets *  WorkSpaceOffsets,
	int32                   lExtraWorkSpace,
	int32                   lMGWorkSpace,
	int32 *                 plSizeBitmap1,
	int32 *                 plSizeBitmap2)
{
	uint32              ulMemoryOffset;

	ulMemoryOffset = WorkSpaceOffsets->ulReusableMemoryOffset;

	ulMemoryOffset += (uint32)lMGWorkSpace;  /* correct for MeasureGlyph Workspace */
	lExtraWorkSpace -= lMGWorkSpace;

	WorkSpaceOffsets->ulMemoryBase6Offset = 0L;
	WorkSpaceOffsets->ulMemoryBase7Offset = 0L;

	/* Save original sizes */

	WorkSpaceOffsets->ulMemoryBase6Size = *plSizeBitmap1;
	WorkSpaceOffsets->ulMemoryBase7Size = *plSizeBitmap2;

	if( *plSizeBitmap1 > *plSizeBitmap2)
	{
		if( *plSizeBitmap1 <= lExtraWorkSpace )
		{
			WorkSpaceOffsets->ulMemoryBase6Offset = ulMemoryOffset;
			ulMemoryOffset += (uint32)*plSizeBitmap1;

			if (( *plSizeBitmap2 <= lExtraWorkSpace - *plSizeBitmap1 ) &&
				( *plSizeBitmap2 > 0L ))
			{
				WorkSpaceOffsets->ulMemoryBase7Offset = ulMemoryOffset;
				*plSizeBitmap2 = 0L;
			}
			*plSizeBitmap1 = 0L;
		}
		else if (( *plSizeBitmap2 <= lExtraWorkSpace ) &&
				 ( *plSizeBitmap2 > 0L))
		{
			WorkSpaceOffsets->ulMemoryBase7Offset = ulMemoryOffset;
			*plSizeBitmap2 = 0L;
		}

	}
	else  /* (plSizeBitmap1 <= *plSizeBitmap2) */
	{
		if(( *plSizeBitmap2 <= lExtraWorkSpace ) &&
		   ( *plSizeBitmap2 > 0L ))
		{
			WorkSpaceOffsets->ulMemoryBase7Offset = ulMemoryOffset;
			ulMemoryOffset += (uint32)*plSizeBitmap2;

			if (( *plSizeBitmap1 <= lExtraWorkSpace - *plSizeBitmap2 ) &&
				 ( *plSizeBitmap1 > 0L ))
			{
				WorkSpaceOffsets->ulMemoryBase6Offset = ulMemoryOffset;
				*plSizeBitmap1 = 0L;
			}
			*plSizeBitmap2 = 0L;
		}
		else if (( *plSizeBitmap1 <= lExtraWorkSpace ) &&
				 ( *plSizeBitmap1 > 0L ))
		{
			WorkSpaceOffsets->ulMemoryBase6Offset = ulMemoryOffset;
			*plSizeBitmap1 = 0L;
		}
	}
}

FS_PUBLIC void  fsg_GetRealBitmapSizes(
	fsg_WorkSpaceOffsets *  WorkSpaceOffsets,
	int32 *                 plSizeBitmap1,
	int32 *                 plSizeBitmap2)
{
	 *plSizeBitmap1 = WorkSpaceOffsets->ulMemoryBase6Size;
	 *plSizeBitmap2 = WorkSpaceOffsets->ulMemoryBase7Size;
}

FS_PUBLIC void  fsg_SetUpWorkSpaceBitmapMemory(
	char *                  pWorkSpace,
	fsg_WorkSpaceOffsets *  WorkSpaceOffsets,
	char *                  pClientBitmapPtr2,
	char *                  pClientBitmapPtr3,
	char **                 ppMemoryBase6,
	char **                 ppMemoryBase7)
{
	if(WorkSpaceOffsets->ulMemoryBase6Offset != 0L)
	{
		*ppMemoryBase6 = WorkSpaceOffsets->ulMemoryBase6Offset + (char *)pWorkSpace;
	}
	else
	{
		*ppMemoryBase6 = pClientBitmapPtr2;
	}

	if(WorkSpaceOffsets->ulMemoryBase7Offset != 0L)
	{
		  *ppMemoryBase7 = WorkSpaceOffsets->ulMemoryBase7Offset + (char *)pWorkSpace;
	}
	else
	{
		*ppMemoryBase7 = pClientBitmapPtr3;
	}
}

FS_PUBLIC void  fsg_GetWorkSpaceExtra(
	char *                  pWorkSpace,
	fsg_WorkSpaceOffsets *  WorkSpaceOffsets,
	char **                 ppWorkSpaceExtra)
{
	 *ppWorkSpaceExtra = (char *)(pWorkSpace + WorkSpaceOffsets->ulReusableMemoryOffset);
}

FS_PUBLIC void  fsg_QueryPPEM(
	void *      pvGlobalGS,
	uint16 *    pusPPEM)
{
	scl_QueryPPEM(pvGlobalGS, pusPPEM);
}

/*  Return PPEM in both X and Y and 90 degree rotation factor for sbit matching */

FS_PUBLIC void  fsg_QueryPPEMXY(
	void *              pvGlobalGS,
	fsg_TransformRec *  TransformInfo,
	uint16 *            pusPPEMX,
	uint16 *            pusPPEMY,
	uint16 *            pusRotation)
{
	*pusRotation = mth_90degRotationFactor( &TransformInfo->currentTMatrix );
	scl_QueryPPEMXY(pvGlobalGS, pusPPEMX, pusPPEMY);
}


/*  FSGlue Access Routines  */

FS_PUBLIC void  fsg_GetContourData(
	fsg_WorkSpaceAddr * pWorkSpaceAddr,
#ifdef FSCFG_SUBPIXEL
	boolean				bSubPixel,            
#endif // FSCFG_SUBPIXEL
	F26Dot6 **          pX,
	F26Dot6 **          pY,
	int16 **            pSp,
	int16 **            pEp,
	uint8 **            pOnCurve,
	uint8 **            pFc,
	uint16 *            pNc)
{
	fnt_ElementType *   pElement;

	pElement = pWorkSpaceAddr->pGlyphElement;

	*pX =       pElement->x;
	*pY =       pElement->y;
	*pSp =      pElement->sp;
	*pEp =      pElement->ep;
	*pOnCurve = pElement->onCurve;
	*pFc =     pElement->fc;
	*pNc      = (uint16)pElement->nc;
#ifdef FSCFG_SUBPIXEL
	if (bSubPixel)
	{
		/* we scale down the coordinate from x,y into ox, oy and return those */
		scl_ScaleDownFromSubPixelOverscale(pElement);
		*pX =       pElement->ox;
	}
#endif // FSCFG_SUBPIXEL
}

FS_PUBLIC uint32      fsg_GetContourDataSize(
	fsg_WorkSpaceAddr * pWorkSpaceAddr)
{
	fnt_ElementType *   pElement;

	pElement = pWorkSpaceAddr->pGlyphElement;

	return( scl_GetContourDataSize( pElement ) );
}

FS_PUBLIC void  fsg_DumpContourData(
	fsg_WorkSpaceAddr * pWorkSpaceAddr,
	uint8 **            ppbyOutline)
{
	fnt_ElementType *   pElement;

	pElement = pWorkSpaceAddr->pGlyphElement;

	scl_DumpContourData(pElement, ppbyOutline);
}

FS_PUBLIC void  fsg_RestoreContourData(
	uint8 **        ppbyOutline,
	F26Dot6 **      ppX,
	F26Dot6 **      ppY,
	int16 **        ppSp,
	int16 **        ppEp,
	uint8 **        ppOnCurve,
	uint8 **        ppFc,
	uint16 *        pNc)
{
	fnt_ElementType     pElement;

	scl_RestoreContourData(&pElement, ppbyOutline);

	*ppX =          pElement.x;
	*ppY =          pElement.y;
	*ppSp =         pElement.sp;
	*ppEp =         pElement.ep;
	*ppOnCurve =    pElement.onCurve;
	*ppFc =         pElement.fc;
	*pNc =          (uint16)pElement.nc;
}

FS_PUBLIC void  fsg_GetDevAdvanceWidth(
	fsg_WorkSpaceAddr * pWorkSpaceAddr,
	point *             pDevAdvanceWidth)
{
	fnt_ElementType *   pElement;

	pElement = pWorkSpaceAddr->pGlyphElement;

	scl_CalcDevAdvanceWidth(pElement, pDevAdvanceWidth);
}

FS_PUBLIC void  fsg_GetDevAdvanceHeight(
	fsg_WorkSpaceAddr * pWorkSpaceAddr,
	point *             pDevAdvanceHeight)
{
	fnt_ElementType *   pElement;

	pElement = pWorkSpaceAddr->pGlyphElement;

	scl_CalcDevAdvanceHeight(pElement, pDevAdvanceHeight);
}

FS_PUBLIC void  fsg_GetScaledCVT(
	char *                      pPrivateFontSpace,
	fsg_PrivateSpaceOffsets *   PrivateSpaceOffsets,
	F26Dot6 **                  ppScaledCVT)
{
	*ppScaledCVT = (F26Dot6 *)(pPrivateFontSpace + PrivateSpaceOffsets->offset_controlValues);
}

FS_PUBLIC void  fsg_45DegreePhaseShift(
	fsg_WorkSpaceAddr * pWorkSpaceAddr)
{
	fnt_ElementType *   pElement;

	pElement = pWorkSpaceAddr->pGlyphElement;

	scl_45DegreePhaseShift(pElement);
}

FS_PUBLIC void  fsg_UpdateAdvanceWidth (
	fsg_TransformRec *  TransformInfo,
	void *              pvGlobalGS,
	uint16              usNonScaledAW,
	vectorType *        AdvanceWidth)
{
	AdvanceWidth->y = 0;
	scl_ScaleAdvanceWidth(
		pvGlobalGS,
		AdvanceWidth,
		usNonScaledAW,
		TransformInfo->bPositiveSquare,
		TransformInfo->usEmResolution,
		&TransformInfo->currentTMatrix);
}

FS_PUBLIC void  fsg_UpdateAdvanceHeight (
	fsg_TransformRec *  TransformInfo,
	void *              pvGlobalGS,
	uint16              usNonScaledAH,
	vectorType *        AdvanceHeight)
{
	AdvanceHeight->x = 0;
	scl_ScaleAdvanceHeight(
		pvGlobalGS,
		AdvanceHeight,
		usNonScaledAH,
		TransformInfo->bPositiveSquare,
		TransformInfo->usEmResolution,
		&TransformInfo->currentTMatrix);
}


FS_PUBLIC void  fsg_ScaleVerticalMetrics (
    fsg_TransformRec *  TransformInfo,
    void *              pvGlobalGS,
	uint16              usNonScaledAH,
    int16               sNonScaledTSB,
	vectorType *        pvecAdvanceHeight,
	vectorType *        pvecTopSideBearing )
{
	pvecAdvanceHeight->x = 0;           /* start with x values at zero */
	pvecTopSideBearing->x = 0;          /* since 'vmtx' refers to y values */

    scl_ScaleVerticalMetrics (
    	pvGlobalGS,
    	usNonScaledAH,
    	sNonScaledTSB,
		TransformInfo->bPositiveSquare,
		TransformInfo->usEmResolution,
		&TransformInfo->currentTMatrix,
    	pvecAdvanceHeight,
    	pvecTopSideBearing);
}


FS_PUBLIC void  fsg_CalcLSBsAndAdvanceWidths(
	fsg_WorkSpaceAddr *     pWorkSpaceAddr,
	F26Dot6                 fxXMin,
	F26Dot6                 fxYMax,
	point *                 devAdvanceWidth,
	point *                 devLeftSideBearing,
	point *                 LeftSideBearing,
	point *                 devLeftSideBearingLine,
	point *                 LeftSideBearingLine)
{
	fnt_ElementType *   pElement;

	pElement = pWorkSpaceAddr->pGlyphElement;

	scl_CalcLSBsAndAdvanceWidths(
		pElement,
		fxXMin,
		fxYMax,
		devAdvanceWidth,
		devLeftSideBearing,
		LeftSideBearing,
		devLeftSideBearingLine,
		LeftSideBearingLine);
}

FS_PUBLIC void  fsg_CalcTSBsAndAdvanceHeights(
	fsg_WorkSpaceAddr *     pWorkSpaceAddr,
	F26Dot6                 fxXMin,
	F26Dot6                 fxYMax,
	point *                 devAdvanceHeight,
	point *                 devTopSideBearing,
	point *                 TopSideBearing,
	point *                 devTopSideBearingLine,
	point *                 TopSideBearingLine)
{
	fnt_ElementType *   pElement;

	pElement = pWorkSpaceAddr->pGlyphElement;

	scl_CalcTSBsAndAdvanceHeights(
		pElement,
		fxXMin,
		fxYMax,
		devAdvanceHeight,
		devTopSideBearing,
		TopSideBearing,
		devTopSideBearingLine,
		TopSideBearingLine);
}

FS_PUBLIC boolean   fsg_IsTransformStretched(
	fsg_TransformRec *  TransformInfo)
{
	return (boolean)(( TransformInfo->ulImageState & IMAGESTATE_STRETCHED ) == IMAGESTATE_STRETCHED);
}

FS_PUBLIC boolean   fsg_IsTransformRotated(
	fsg_TransformRec *  TransformInfo)
{
	return (boolean)(( TransformInfo->ulImageState & IMAGESTATE_ROTATED ) == IMAGESTATE_ROTATED);
}

/*  Control Routines    */

FS_PUBLIC ErrorCode fsg_InitInterpreterTrans (
	fsg_TransformRec *  TransformInfo,
	void *              pvGlobalGS,
	Fixed               fxPointSize,
	int16               sXResolution,
	int16               sYResolution,
	boolean           bHintAtEmSquare,
	uint16            usEmboldWeightx,     /* scaling factor in x between 0 and 40 (20 means 2% fo the height) */
	uint16              usEmboldWeighty,     /* scaling factor in y between 0 and 40 (20 means 2% fo the height) */
	int16               sWinDescender,
	int32               lDescDev,               /* descender in device metric, used for clipping */
	int16 *				psBoldSimulHorShift,   /* shift for emboldening simulation, horizontally */
	int16 *				psBoldSimulVertShift   /* shift for emboldening simulation, vertically */
	)
{
	ErrorCode       error;
	uint32          ulPixelsPerEm;
	transMatrix *   trans;

	trans = &TransformInfo->currentTMatrix;

	error = scl_InitializeScaling(
		pvGlobalGS,
		TransformInfo->bIntegerScaling,
		&TransformInfo->currentTMatrix,
		TransformInfo->usEmResolution,
		fxPointSize,
		sXResolution,
		sYResolution,
		usEmboldWeightx,       /* scaling factor in x between 0 and 40 (20 means 2% fo the height) */
		usEmboldWeighty,      /* scaling factor in y between 0 and 40 (20 means 2% fo the height) */
		sWinDescender,
		lDescDev,
		psBoldSimulHorShift,   /* shift for emboldening simulation, horizontally */
		psBoldSimulVertShift,   /* shift for emboldening simulation, vertically */
		bHintAtEmSquare,
		&ulPixelsPerEm);

	if(error)
	{
		return error;
	}

	TransformInfo->bPhaseShift = false;

	if ( ulPixelsPerEm > IMAGESTATE_MAX_PPEM_SIZE )
	{
		TransformInfo->ulImageState = (uint32)IMAGESTATE_MAX_PPEM_SIZE;
	}
	else
	{
		TransformInfo->ulImageState = ulPixelsPerEm;
	}

	TransformInfo->bPositiveSquare = mth_PositiveSquare( trans );

	if ( !(mth_PositiveRectangle( trans )))
	{
		TransformInfo->ulImageState |= IMAGESTATE_NON_POS_RECT;
	}

	if ( !(TransformInfo->bPositiveSquare) )
	{
		if( mth_GeneralRotation (trans))
		{
			TransformInfo->ulImageState |=  IMAGESTATE_ROTATED;
		}

		TransformInfo->ulImageState |= IMAGESTATE_STRETCHED;

		TransformInfo->bPhaseShift = mth_IsMatrixStretched(trans); /*<8>*/
	}

	TransformInfo->bEmboldSimulation = ((usEmboldWeightx != 0) || (usEmboldWeighty != 0)); 

	return NO_ERR;
}

FS_PUBLIC void  fsg_SetHintFlags(
	void *              pvGlobalGS,
	boolean				bHintForGray
#ifdef FSCFG_SUBPIXEL
	,uint16				flHintForSubPixel
#endif // FSCFG_SUBPIXEL
    )
{
	scl_SetHintFlags(
		pvGlobalGS,
		bHintForGray
#ifdef FSCFG_SUBPIXEL
	    ,flHintForSubPixel
#endif // FSCFG_SUBPIXEL
        );
}
/*
 *  All this guy does is record FDEFs and IDEFs, anything else is ILLEGAL
 */
FS_PUBLIC ErrorCode fsg_RunFontProgram(
	void *                  pvGlobalGS,               /* GlobalGS     */
	fsg_WorkSpaceAddr *     pWorkSpaceAddr,
	void *                  pvTwilightElement,
	FntTraceFunc           traceFunc)
{
	return itrp_ExecuteFontPgm (
		(fnt_ElementType *)pvTwilightElement,
		pWorkSpaceAddr->pGlyphElement,
		pvGlobalGS,
		traceFunc);
}

/*
 * fsg_RunPreProgram
 *
 * Runs the pre-program and scales the control value table
 *
 */
FS_PUBLIC ErrorCode fsg_RunPreProgram (
	sfac_ClientRec *    ClientInfo,
	LocalMaxProfile *   pMaxProfile,     /* Max Profile Table    */
	fsg_TransformRec *  TransformInfo,
	void *              pvGlobalGS,
	fsg_WorkSpaceAddr * pWorkSpaceAddr,
	void *              pvTwilightElement,
	FntTraceFunc        traceFunc)
{
	ErrorCode           result;
	F26Dot6 *           pfxCVT;
	fnt_ElementType *   pTwilightElement;

	pTwilightElement = (fnt_ElementType *)pvTwilightElement;

	result = itrp_SetDefaults (pvGlobalGS, TransformInfo->fxPixelDiameter);

	if (result != NO_ERR)
	{
		return result;
	}

	scl_GetCVTPtr(pvGlobalGS, &pfxCVT);

	result = sfac_CopyCVT(ClientInfo, pfxCVT);

	if (result != NO_ERR)
	{
		return result;
	}

	scl_ScaleCVT (pvGlobalGS, pfxCVT);

	scl_InitializeTwilightContours(
		pTwilightElement,
		(int16)pMaxProfile->maxTwilightPoints,
		MAX_TWILIGHT_CONTOURS);

	scl_ZeroOutlineData(
		pTwilightElement,
		pMaxProfile->maxTwilightPoints,
		MAX_TWILIGHT_CONTOURS);

	result = itrp_ExecutePrePgm (
		pTwilightElement,
		pWorkSpaceAddr->pGlyphElement,
		pvGlobalGS,
		traceFunc);

	return result;
}

/*
 *      fsg_GridFit
 */
FS_PUBLIC ErrorCode fsg_GridFit (
	sfac_ClientRec *    ClientInfo,     /* sfnt Client information      */
	LocalMaxProfile *   pMaxProfile,    /* Max Profile Table            */
	fsg_TransformRec *  TransformInfo,  /* Transformation information   */
	void *              pvGlobalGS,     /* GlobalGS                     */
	fsg_WorkSpaceAddr * pWorkSpaceAddr,
	void *              pvTwilightElement,
	FntTraceFunc        traceFunc,
	boolean             bUseHints,
	uint16 *            pusScanType,
	boolean *           pbGlyphHasOutline,
	uint16 *            pusNonScaledAW,
	boolean            bBitmapEmboldening
#ifdef FSCFG_SUBPIXEL
	,boolean			bSubPixel
#endif // FSCFG_SUBPIXEL
	)
{
	ErrorCode           result;
	fnt_ElementType *   pTwilightElement;
	fnt_GlobalGraphicStateType *globalGS;

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

	pTwilightElement = (fnt_ElementType *)pvTwilightElement;

	scl_InitializeTwilightContours(
		pTwilightElement,
		(int16)pMaxProfile->maxTwilightPoints,
		MAX_TWILIGHT_CONTOURS);

	result = fsg_CreateGlyphData (
		ClientInfo,
		pMaxProfile,
		TransformInfo,
		pvGlobalGS,
		pWorkSpaceAddr,
		pTwilightElement,
		traceFunc,
		bUseHints,
		pusScanType,
		pbGlyphHasOutline,
		pusNonScaledAW);

	if(result == NO_ERR)
	{
		if (TransformInfo->bEmboldSimulation)
		{
			fsg_Embold( pWorkSpaceAddr, pvGlobalGS, bUseHints, bBitmapEmboldening
#ifdef FSCFG_SUBPIXEL
	                ,bSubPixel
#endif // FSCFG_SUBPIXEL
            );
			*pusNonScaledAW +=  (TransformInfo->usEmResolution * 2 - 1) / 100; /* adjust pusNonScaledAW by 2% of Em height */
		}

		if ((TransformInfo->ulImageState & (IMAGESTATE_NON_POS_RECT)) || globalGS->bHintAtEmSquare)
		{
			scl_PostTransformGlyph (
				pvGlobalGS,
				pWorkSpaceAddr->pGlyphElement,
				&TransformInfo->currentTMatrix);
		}

		/* apply the translation part of the transformation matrix */
		scl_ApplyTranslation (
			pWorkSpaceAddr->pGlyphElement,
			&TransformInfo->currentTMatrix,
			bUseHints,
			globalGS->bHintAtEmSquare
#ifdef FSCFG_SUBPIXEL
	        ,bSubPixel
#endif // FSCFG_SUBPIXEL
            );
	}
	return result;
}

FS_PRIVATE ErrorCode    fsg_CreateGlyphData(
	sfac_ClientRec *    ClientInfo,         /* sfnt Client information           */
	LocalMaxProfile *   pMaxProfile,        /* Max Profile Table                     */
	fsg_TransformRec *  TransformInfo,      /* Transformation information        */
	void *              pvGlobalGS,         /* GlobalGS                              */
	fsg_WorkSpaceAddr * pWorkSpaceAddr,     /* WorkSpace Address                     */
	fnt_ElementType *   pTwilightElement,   /* Twilight zone element */
	FntTraceFunc        traceFunc,          /* Trace function for interpreter    */
	boolean             bUseHints,          /* True if glyph is gridfitted       */
	uint16 *            pusScanType,        /* ScanType value                        */
	boolean *           pbGlyphHasOutline,  /* Outline for glyph                 */
	uint16 *            pusNonScaledAW)     /* Return NonScaled Advance Width    */
{
	GlyphData * pGlyphData;
	GlyphData * pNextGlyphData;
	boolean      bHasOutline;
	uint32       ulGlyphDataCount;
	ErrorCode   ReturnCode;
    uint32      CompositePoints = 0;
    uint32      CompositeContours = 0;

	*pbGlyphHasOutline = FALSE;
	bHasOutline = FALSE;

	ulGlyphDataCount = MAX_NESTED_GLYPHS(pMaxProfile);

	fsg_InitializeGlyphDataMemory(ulGlyphDataCount, pWorkSpaceAddr);
	ReturnCode = fsg_AllocateGlyphDataMemory(ulGlyphDataCount, pWorkSpaceAddr, &pGlyphData); /* Allocates GlyphData for topmost   */
	if(ReturnCode != NO_ERR)
	{
		return ReturnCode;
	}
												 /* parent  */
	fsg_InitializeGlyphData(pGlyphData, pWorkSpaceAddr,
		ClientInfo->usGlyphIndex, COMPOSITE_ROOT);

	while(pGlyphData != NULL)
	{
		CHECK_GLYPHDATA( pGlyphData );

		ReturnCode = fsg_ExecuteGlyph(
			ClientInfo,
			pMaxProfile,
			TransformInfo,
			ulGlyphDataCount,
			pvGlobalGS,
			pGlyphData,
			pWorkSpaceAddr,
			pTwilightElement,
			traceFunc,
			bUseHints,
			&bHasOutline,
            &CompositePoints,
            &CompositeContours);
		if(ReturnCode)
		{
			return ReturnCode;
		}
		*pbGlyphHasOutline |= bHasOutline;
		*pusScanType = pGlyphData->usScanType;
		fsg_ChooseNextGlyph(pWorkSpaceAddr, pGlyphData, &pNextGlyphData);
		*pusNonScaledAW = pGlyphData->usNonScaledAW;
		pGlyphData = pNextGlyphData;
	}

	return NO_ERR;
}

FS_PRIVATE ErrorCode    fsg_ExecuteGlyph(
	sfac_ClientRec *    ClientInfo,         /* sfnt Client information           */
	LocalMaxProfile *   pMaxProfile,        /* Max Profile Table                     */
	fsg_TransformRec *  TransformInfo,      /* Transformation information         */
	uint32              ulGlyphDataCount,   /* Max Number of nested glyphs */
	void *              pvGlobalGS,         /* GlobalGS                              */
	GlyphData *         pGlyphData,         /* GlyphData pointer                     */
	fsg_WorkSpaceAddr * pWorkSpaceAddr,     /* WorkSpace Address                      */
	fnt_ElementType *   pTwilightElement,   /* Twilight zone element */
	FntTraceFunc        traceFunc,          /* Trace function for interpreter    */
	boolean             bUseHints,          /* True if glyph is gridfitted       */
	boolean *           pbHasOutline,       /* True if glyph has outline         */
    uint32*                pCompositePoints,/* total number of point for composites, to check for overflow */
    uint32*                pCompositeContours)  /* total number of contours for composites, to check for overflow */
{
	ErrorCode       ReturnCode;
	boolean         bCompositeGlyph;
	boolean         bLastComponent;
	boolean         bWeHaveInstructions;
	boolean         bWeHaveCompositeInstructions;
	boolean         bScanInfoChanged;
	boolean 		bWeHaveAScale;
	uint16          usScanType;
	uint16          usScanControl;
	GlyphData *     pChildGlyphData;
	uint16          usComponentElementCount;
	uint16          contour;

	*pbHasOutline = FALSE;

	if (pGlyphData->GlyphType == glyphUndefined)
	{
		if(pGlyphData->pParent != NULL)
		{
			scl_IncrementChildElement(pGlyphData->pGlyphElement, pGlyphData->pParent->pGlyphElement);
		} else {
			pGlyphData->currentTMatrix = TransformInfo->currentTMatrix;
		}

		ReturnCode = sfac_ReadGlyphHeader(ClientInfo, pGlyphData->usGlyphIndex,
			&pGlyphData->hGlyph, &bCompositeGlyph, pbHasOutline,
			&pGlyphData->pGlyphElement->nc, &pGlyphData->bbox);

		if(ReturnCode != NO_ERR)
		{
			return ReturnCode;
		}

		/* Get advance width, advance height, left side bearing and top side bearing information  */

		ReturnCode = sfac_ReadGlyphMetrics(
			ClientInfo, pGlyphData->usGlyphIndex,
			&pGlyphData->usNonScaledAW, &pGlyphData->usNonScaledAH, 
			&pGlyphData->sNonScaledLSB, &pGlyphData->sNonScaledTSB);

		if(ReturnCode != NO_ERR)
		{
			return ReturnCode;
		}

		if (bCompositeGlyph)
		{
			pGlyphData->GlyphType = glyphIncompleteComposite;
		}
		else
		{
			pGlyphData->GlyphType = glyphSimple;
		}
	}

	if (pGlyphData->GlyphType == glyphSimple)
	{
		ReturnCode = sfac_ReadOutlineData(
			pGlyphData->pGlyphElement->onCurve,
			pGlyphData->pGlyphElement->ooy, pGlyphData->pGlyphElement->oox,
			&pGlyphData->hGlyph, pMaxProfile, *pbHasOutline, pGlyphData->pGlyphElement->nc,
			pGlyphData->pGlyphElement->sp, pGlyphData->pGlyphElement->ep,
			&pGlyphData->usSizeOfInstructions, &pGlyphData->pbyInstructions,
            pCompositePoints, pCompositeContours);

		if(ReturnCode != NO_ERR)
		{
			return ReturnCode;
		}


        fsg_CheckOutlineOrientation (pGlyphData->pGlyphElement);

        ReturnCode = fsg_SimpleInnerGridFit(
			pvGlobalGS,
			pTwilightElement,
			pGlyphData->pGlyphElement,
			bUseHints,
			traceFunc,
			TransformInfo->usEmResolution,
			pGlyphData->usNonScaledAW,
			pGlyphData->usNonScaledAH,
			pGlyphData->sNonScaledLSB,
			pGlyphData->sNonScaledTSB,
			pGlyphData->bSameTransformAsMaster, /* current transf. same as master transf.   */
			pGlyphData->currentTMatrix, /* current transf. : user + composite transf. */
			&pGlyphData->bbox,
			pGlyphData->usSizeOfInstructions,
			pGlyphData->pbyInstructions,
			&usScanType,
			&usScanControl,
			&bScanInfoChanged);

		if(ReturnCode != NO_ERR)
		{
			return ReturnCode;
		}

		if( ! fsg_DoScanControl(usScanControl, TransformInfo->ulImageState))
		{
			pGlyphData->usScanType = SK_NODROPOUT;
		}
		else
		{
			pGlyphData->usScanType = usScanType;
		}

		// here we update the contour orientation bit if necessary, to reflect the final orientation of the contours in the composite
		if (FixMul(pGlyphData->mulT.transform[0][0],pGlyphData->mulT.transform[1][1]) - FixMul(pGlyphData->mulT.transform[0][1],pGlyphData->mulT.transform[1][0]) < 0) {
			for (contour = 0; contour < pGlyphData->pGlyphElement->nc; contour++) {
				pGlyphData->pGlyphElement->fc[contour] ^= OUTLINE_MISORIENTED;
			}
		}

		if (pGlyphData->pParent != NULL)
		{
			fsg_MergeGlyphData(pvGlobalGS, pGlyphData, TransformInfo->usEmResolution);
		}

		ReturnCode = sfac_ReleaseGlyph(ClientInfo, &pGlyphData->hGlyph);

		if(ReturnCode != NO_ERR)
		{
			return ReturnCode;
		}

		pGlyphData->pbyInstructions = 0;
		pGlyphData->usSizeOfInstructions = 0;
	}
	else if (pGlyphData->GlyphType == glyphComposite)
	{
		ReturnCode = fsg_CompositeInnerGridFit(
			pvGlobalGS,
			pTwilightElement,
			pGlyphData->pGlyphElement,
			bUseHints,
			traceFunc,
			TransformInfo->usEmResolution,
			pGlyphData->usNonScaledAW,
			pGlyphData->usNonScaledAH,
			pGlyphData->sNonScaledLSB,
			pGlyphData->sNonScaledTSB,
			pGlyphData->bSameTransformAsMaster, /* current transf. same as master transf.   */
			pGlyphData->currentTMatrix, /* current transf. : user + composite transf. */
			&pGlyphData->bbox,
			pGlyphData->usSizeOfInstructions,
			pGlyphData->pbyInstructions,
			&usScanType,
			&usScanControl,
			&bScanInfoChanged);

		if(ReturnCode != NO_ERR)
		{
			return ReturnCode;
		}

		if (pGlyphData->bUseChildMetrics)
		{
			scl_SetSideBearingPoints(
				pGlyphData->pGlyphElement,
				&pGlyphData->ptDevLSB,
				&pGlyphData->ptDevRSB);
		}

		/* If composite has set SCANCTRL, use that value, otherwise merged children */

		if(bScanInfoChanged)
		{
			if( ! fsg_DoScanControl(usScanControl, TransformInfo->ulImageState))
			{
				pGlyphData->usScanType = SK_NODROPOUT;
			}
			else
			{
				pGlyphData->usScanType = usScanType;
			}
		}

		if (pGlyphData->pParent != NULL)
		{
			fsg_MergeGlyphData(pvGlobalGS, pGlyphData, TransformInfo->usEmResolution);
		}

		ReturnCode = sfac_ReleaseGlyph(ClientInfo, &pGlyphData->hGlyph);

		if(ReturnCode != NO_ERR)
		{
			return ReturnCode;
		}

		pGlyphData->pbyInstructions = 0;
		pGlyphData->usSizeOfInstructions = 0;
	}
	else if (pGlyphData->GlyphType == glyphIncompleteComposite)
	{
		bLastComponent = FALSE;
		bWeHaveInstructions = FALSE;
		bWeHaveCompositeInstructions = FALSE;

		pGlyphData->GlyphType = glyphComposite;

		usComponentElementCount = 0;

		do
		{
			if(pGlyphData->usDepth + 1UL > MAX_COMPONENT_DEPTH(pMaxProfile))
			{
				return BAD_MAXP_DATA;
			}

			usComponentElementCount++;

			if(usComponentElementCount > MAX_COMPONENT_ELEMENTS(pMaxProfile))
			{
				return BAD_MAXP_DATA;
			}

			ReturnCode = fsg_AllocateGlyphDataMemory(ulGlyphDataCount, pWorkSpaceAddr, &pChildGlyphData);
			if(ReturnCode != NO_ERR)
			{
				return ReturnCode;
			}

			fsg_InitializeGlyphData(
				pChildGlyphData,
				pWorkSpaceAddr,
				NULL_GLYPH,
				(uint16)(pGlyphData->usDepth + 1U) );

			fsg_LinkChild(pGlyphData, pChildGlyphData);

			ReturnCode = sfac_ReadComponentData(
				&pGlyphData->hGlyph,
				&pChildGlyphData->MultiplexingIndicator,
				&pChildGlyphData->bRoundXYToGrid,
				&pChildGlyphData->bUseMyMetrics,
				&pChildGlyphData->bScaleCompositeOffset,
				&bWeHaveInstructions,
				&pChildGlyphData->usGlyphIndex,
				&pChildGlyphData->sXOffset,
				&pChildGlyphData->sYOffset,
				&pChildGlyphData->usAnchorPoint1,
				&pChildGlyphData->usAnchorPoint2,
				&pChildGlyphData->mulT,
				&bWeHaveAScale,
				&bLastComponent);

			if (bWeHaveAScale)
			{
				mth_MxConcat2x2( &pChildGlyphData->mulT, &pChildGlyphData->currentTMatrix );
				if (!mth_UnitarySquare(&pChildGlyphData->mulT))
				{
					pChildGlyphData->bSameTransformAsMaster	= FALSE; /* the component is scaled/rotated */
				}

			}

			if(ReturnCode != NO_ERR)
			{
				return ReturnCode;
			}

			bWeHaveCompositeInstructions |= bWeHaveInstructions;
		}
		while (!bLastComponent);

		if(bWeHaveCompositeInstructions)
		{
			ReturnCode = sfac_ReadCompositeInstructions(
				&pGlyphData->hGlyph,
				&pGlyphData->pbyInstructions,
				&pGlyphData->usSizeOfInstructions);

			if(ReturnCode != NO_ERR)
			{
				return ReturnCode;
			}
		}

	}
	return NO_ERR;
}


/*
 *      fsg_SimpleInnerGridFit
 */
FS_PRIVATE ErrorCode    fsg_SimpleInnerGridFit (
	void *              pvGlobalGS,
	fnt_ElementType *   pTwilightElement,
	fnt_ElementType *   pGlyphElement,
	boolean             bUseHints,
	FntTraceFunc        traceFunc,
	uint16              usEmResolution,
	uint16              usNonScaledAW,
	uint16              usNonScaledAH,
	int16               sNonScaledLSB,
	int16               sNonScaledTSB,
	boolean				bSameTransformAsMaster, /* local transf. same as master transf.   */
	transMatrix			CurrentTMatrix,                  /* Current Transformation   */
	BBOX *              bbox,
	uint16              usSizeOfInstructions,
	uint8 *             instructionPtr,
	uint16 *            pusScanType,
	uint16 *            pusScanControl,
	boolean *           pbChangeScanControl)
{
	ErrorCode           result;
/*
	On entry to fsg_SimpleInnerGrid fit the element structure should
	contain only valid original points (oox, ooy). The original points
	will be scaled into the old points (ox, oy) and those will be
	copied into the current points (x, y).
*/
	itrp_SetCompositeFlag(pvGlobalGS, FALSE);

	itrp_QueryScanInfo(pvGlobalGS, pusScanType, pusScanControl);
	*pbChangeScanControl = FALSE;

	scl_CalcOrigPhantomPoints(pGlyphElement, bbox, sNonScaledLSB, sNonScaledTSB, usNonScaledAW, usNonScaledAH);

	if (itrp_bApplyHints(pvGlobalGS) && bUseHints)
	{
		itrp_SetSameTransformFlag(pvGlobalGS, bSameTransformAsMaster);

		if (!bSameTransformAsMaster)
		{
			scl_InitializeChildScaling(
				pvGlobalGS,
				CurrentTMatrix,
				usEmResolution);
		}

		/* hint and same transformation as master glyph */
		scl_ScaleOldCharPoints (pGlyphElement, pvGlobalGS);
		scl_ScaleOldPhantomPoints (pGlyphElement, pvGlobalGS);

		scl_AdjustOldCharSideBearing(pGlyphElement
#ifdef FSCFG_SUBPIXEL
			, pvGlobalGS
#endif
			);
		scl_AdjustOldPhantomSideBearing(pGlyphElement
#ifdef FSCFG_SUBPIXEL
			, pvGlobalGS
#endif
			);

		scl_CopyCurrentCharPoints(pGlyphElement);
		scl_CopyCurrentPhantomPoints(pGlyphElement);

		scl_RoundCurrentSideBearingPnt(pGlyphElement, pvGlobalGS, usEmResolution);

		if (usSizeOfInstructions > 0)
		{
			scl_ZeroOutlineFlags(pGlyphElement);

			result = itrp_ExecuteGlyphPgm (
				pTwilightElement,
				pGlyphElement,
				instructionPtr,
				instructionPtr + usSizeOfInstructions,
				pvGlobalGS,
				traceFunc,
				pusScanType,
				pusScanControl,
				pbChangeScanControl);

			if(result != NO_ERR)
			{
				return result;
			}

		}

		if (!bSameTransformAsMaster)
		{
			/* scale back to fixed FUnits */
			scl_ScaleBackCurrentCharPoints (pGlyphElement, pvGlobalGS);
			scl_ScaleBackCurrentPhantomPoints (pGlyphElement, pvGlobalGS);
		}
	}
	else 
		/* no hints */
	{
		if (bSameTransformAsMaster)
		{
			/* no hint and same transformation as master glyph */
			/* as ox/oy are not used in this case, we shouldn't need to first
			   scale the original coordinate oox/ooy into ox/oy before copying
			   them into the current coordinate x/y, the code is left as it
			   for historic reason */
			scl_ScaleOldCharPoints (pGlyphElement, pvGlobalGS);
			scl_ScaleOldPhantomPoints (pGlyphElement, pvGlobalGS);

			scl_CopyCurrentCharPoints(pGlyphElement);
			scl_CopyCurrentPhantomPoints(pGlyphElement);
		}
		else
		{
			/* no hint and different transformation as master glyph */
			/* we shift directly the original coordinates oox/ooy into the
			   current coordinates x/y in FixedFUnits,
			   as ox/oy are not used in this case, we don't need to do
			   a temporary copy into ox/oy */
			scl_OriginalCharPointsToCurrentFixedFUnits (pGlyphElement);
			scl_OriginalPhantomPointsToCurrentFixedFUnits (pGlyphElement);
		}
	}

	return NO_ERR;
}


/*
 *      fsg_CompositeInnerGridFit
 */
FS_PRIVATE ErrorCode    fsg_CompositeInnerGridFit (
	void *              pvGlobalGS,
	fnt_ElementType *   pTwilightElement,
	fnt_ElementType *   pGlyphElement,
	boolean             bUseHints,
	FntTraceFunc        traceFunc,
	uint16              usEmResolution,
	uint16              usNonScaledAW,
	uint16              usNonScaledAH,
	int16               sNonScaledLSB,
	int16               sNonScaledTSB,
	boolean				bSameTransformAsMaster, /* local transf. same as master transf.   */
	transMatrix		    CurrentTMatrix,               /* Current Transformation   */
	BBOX *              bbox,
	uint16              usSizeOfInstructions,
	uint8 *             instructionPtr,
	uint16 *            pusScanType,
	uint16 *            pusScanControl,
	boolean *           pbChangeScanControl)
{
	ErrorCode             result;
/*
	On entry to fsg_CompositeInnerGridFit, the current points (x, y)
	are the only valid points in the element. We copy the current points
	onto the old points (ox, oy)
*/
	itrp_SetCompositeFlag(pvGlobalGS, TRUE);

	itrp_QueryScanInfo(pvGlobalGS, pusScanType, pusScanControl);
	*pbChangeScanControl = FALSE;

	/* Note: The original composite character points are invalid at this point. */
	/*       The interpreter handles this case correctly for composites.        */

	scl_CalcOrigPhantomPoints(pGlyphElement, bbox, sNonScaledLSB, sNonScaledTSB, usNonScaledAW, usNonScaledAH);
																  
	scl_CopyOldCharPoints(pGlyphElement);


	if (itrp_bApplyHints(pvGlobalGS) && bUseHints)
	{
		itrp_SetSameTransformFlag(pvGlobalGS, bSameTransformAsMaster);

		if (!bSameTransformAsMaster)
		{
			scl_InitializeChildScaling(
				pvGlobalGS,
				CurrentTMatrix,
				usEmResolution);
			scl_ScaleFixedCurrentCharPoints (pGlyphElement, pvGlobalGS);
		}

		scl_ScaleOldPhantomPoints (pGlyphElement, pvGlobalGS);

		scl_AdjustOldSideBearingPoints(pGlyphElement
#ifdef FSCFG_SUBPIXEL
			, pvGlobalGS
#endif
			);

		scl_CopyCurrentPhantomPoints(pGlyphElement);

		scl_RoundCurrentSideBearingPnt(pGlyphElement, pvGlobalGS, usEmResolution);

		if (usSizeOfInstructions > 0)
		{
			scl_ZeroOutlineFlags(pGlyphElement);

			result = itrp_ExecuteGlyphPgm (
				pTwilightElement,
				pGlyphElement,
				instructionPtr,
				instructionPtr + usSizeOfInstructions,
				pvGlobalGS,
				traceFunc,
				pusScanType,
				pusScanControl,
				pbChangeScanControl);

			if(result != NO_ERR)
			{
				return result;
			}
		}

		if (!bSameTransformAsMaster)
		{
			/* scale back to fixed FUnits */
			scl_ScaleBackCurrentCharPoints (pGlyphElement, pvGlobalGS);
			scl_ScaleBackCurrentPhantomPoints (pGlyphElement, pvGlobalGS);
		}

	}
	else 
	{
		if (bSameTransformAsMaster)
		{
			/* no hint and same transformation as master glyph */
			/* as ox/oy are not used in this case, we shouldn't need to first
			   scale the original coordinate oox/ooy into ox/oy before copying
			   them into the current coordinate x/y, the code is left as it
			   for historic reason */
			scl_ScaleOldPhantomPoints (pGlyphElement, pvGlobalGS);

			scl_CopyCurrentPhantomPoints(pGlyphElement);

		}
		else
		{
			/* no hint and different transformation as master glyph */
			/* we shift directly the original coordinates oox/ooy into the
			   current coordinates x/y in FixedFUnits,
			   as ox/oy are not used in this case, we don't need to do
			   a temporary copy into ox/oy */
			scl_OriginalPhantomPointsToCurrentFixedFUnits (pGlyphElement);

		}
	}

	return NO_ERR;
}

FS_PRIVATE void fsg_ChooseNextGlyph(
	fsg_WorkSpaceAddr * pWorkSpaceAddr, /* WorkSpace Address        */
	GlyphData *         pGlyphData,     /* GlyphData pointer        */
	GlyphData **        ppNextGlyphData)/* Next GlyphData pointer   */
{
	if (pGlyphData->pChild != NULL)
	{
		*ppNextGlyphData = pGlyphData->pChild;
		CHECK_GLYPHDATA( *ppNextGlyphData );
		pGlyphData->pChild = NULL;
	}
	else
	{
		*ppNextGlyphData = pGlyphData->pSibling;
		fsg_DeallocateGlyphDataMemory(pWorkSpaceAddr, pGlyphData);
	}
}

#ifdef FSCFG_SUBPIXEL
long fsg_AnalyzeCurrentTransformationMatrix(transMatrix *CTM);
long fsg_AnalyzeCurrentTransformationMatrix(transMatrix *CTM) {
	if (CTM->transform[0][1] == 0 && CTM->transform[1][0] == 0) return 0; // Identity, 180 rotation, mirroring in x or y
	if (CTM->transform[0][0] == 0 && CTM->transform[1][1] == 0) return 1; // 90 rotation, 270 rotation, or any combination of these rotation with a mirroring in x or y
	return 2; // assume arbitrary rotation
} // fsg_AnalyzeCurrentTransformationMatrix
#endif

FS_PRIVATE void fsg_MergeGlyphData(
	void *          pvGlobalGS,             /* GlobalGS            */
	GlyphData *     pChildGlyphData,       /* GlyphData pointer     */
	uint16          usEmResolution)
{
	fnt_ElementType * pChildElement;
	fnt_ElementType * pParentElement;
	F26Dot6         fxXOffset, fxYOffset;
	GlyphData *     pParentGlyphData; /* Parent GlyphData pointer   */
#ifdef FSCFG_SUBPIXEL
	RotationParity	rotationParity;
#endif

	CHECK_GLYPHDATA(pChildGlyphData);
	pParentGlyphData = pChildGlyphData->pParent;
	CHECK_GLYPHDATA(pParentGlyphData);

	pChildElement = pChildGlyphData->pGlyphElement;
	pParentElement = pParentGlyphData->pGlyphElement;

	fsg_TransformChild(pChildGlyphData);

	if (!pChildGlyphData->bSameTransformAsMaster && pChildGlyphData->pParent->bSameTransformAsMaster)
	{
		/* coordinates need to be converted from fixed FUnits to user space */
		/* scaling the cordinate of the child glyph from fixed FUnits to user space,
		   scaling from original coordinate x/y to original coordinate x/y 
		   this is done to have the child and parent glyph at the same coordinate space */

		/* use the master transform */
		itrp_SetSameTransformFlag(pvGlobalGS, TRUE);

		scl_ScaleFixedCurrentCharPoints(pChildElement, pvGlobalGS);
		scl_ScaleFixedCurrentPhantomPoints(pChildElement, pvGlobalGS);

		pChildGlyphData->bSameTransformAsMaster = TRUE;
	}
	
#ifdef FSCFG_SUBPIXEL
	rotationParity = fsg_AnalyzeCurrentTransformationMatrix(&pParentGlyphData->currentTMatrix);
#endif

	if (pChildGlyphData->MultiplexingIndicator == OffsetPoints)
	{
		if (!pChildGlyphData->pParent->bSameTransformAsMaster)
		{
			/* we have both the parent and the child that are not at the same transformation as the master glyph
			   we need to use the scaling of the parent as a child scaling to scale the offset */
			scl_InitializeChildScaling(
				pvGlobalGS,
				pChildGlyphData->pParent->currentTMatrix,
				usEmResolution);
		}

		scl_CalcComponentOffset(
			pvGlobalGS,
			pChildGlyphData->sXOffset,
			pChildGlyphData->sYOffset,
			pChildGlyphData->bRoundXYToGrid,
			pChildGlyphData->bSameTransformAsMaster,
			pChildGlyphData->bScaleCompositeOffset,
			pChildGlyphData->mulT,
#ifdef FSCFG_SUBPIXEL
			rotationParity,
#endif
			&fxXOffset,
			&fxYOffset);
	}
	else        /* Values are anchor points */
	{
		FS_ASSERT(pChildGlyphData->MultiplexingIndicator == AnchorPoints,
			   "Bad Multiplexing Indicator");
		scl_CalcComponentAnchorOffset(
			pParentElement,
			pChildGlyphData->usAnchorPoint1,
			pChildElement,
			pChildGlyphData->usAnchorPoint2,
			&fxXOffset,
			&fxYOffset);
	}
	scl_ShiftCurrentCharPoints(pChildElement, fxXOffset, fxYOffset);


	/* If USE_MY_METRICS, copy side bearings to parent  */

	if (pChildGlyphData->bUseMyMetrics)
	{
		pParentGlyphData->bUseChildMetrics = TRUE;

		scl_SaveSideBearingPoints(
			pChildElement,
			&pParentGlyphData->ptDevLSB,
			&pParentGlyphData->ptDevRSB);
	}

	fsg_MergeScanType(pChildGlyphData, pParentGlyphData);

	/* Start the copy   */

	/* scl_AppendOutlineData(pChildElement, pParentElement); */

	scl_UpdateParentElement(pChildElement, pParentElement);

	pChildElement->nc = 0;
}



FS_PRIVATE void fsg_LinkChild(
	GlyphData *     pGlyphData,     /* GlyphData pointer        */
	GlyphData *     pChildGlyphData)/* Child GlyphData pointer  */
{
	GlyphData * pTempGlyphData;

	if (pGlyphData->pChild == NULL)
	{
		pGlyphData->pChild = pChildGlyphData;
	}
	else
	{

		pTempGlyphData = pGlyphData->pChild;

		CHECK_GLYPHDATA(pTempGlyphData);

		while (pTempGlyphData->pSibling != pGlyphData)
		{
			pTempGlyphData = pTempGlyphData->pSibling;
			CHECK_GLYPHDATA(pTempGlyphData);
		}

		pTempGlyphData->pSibling = pChildGlyphData;
	}
	pChildGlyphData->pSibling = pGlyphData;
	pChildGlyphData->pParent =  pGlyphData;

	/* copy the transformation info from the parent */
	pChildGlyphData->currentTMatrix = pGlyphData->currentTMatrix;
	pChildGlyphData->bSameTransformAsMaster = pGlyphData->bSameTransformAsMaster;
}

FS_PRIVATE void fsg_TransformChild(
	GlyphData *     pGlyphData)     /* GlyphData pointer    */
{

	/* Apply local transform to glyph   */

	if (!mth_Identity(&pGlyphData->mulT))
	{
		scl_LocalPostTransformGlyph (pGlyphData->pGlyphElement, &pGlyphData->mulT);
	}
}

FS_PRIVATE void fsg_MergeScanType(
	GlyphData *     pGlyphData,       /* GlyphData pointer  */
	GlyphData *     pParentGlyphData) /* GlyphData pointer  */
{
	CHECK_GLYPHDATA(pGlyphData);
	CHECK_GLYPHDATA(pParentGlyphData);

	/* Merge Scan Type of parent and child  */

	if(pParentGlyphData->usScanType != SCANTYPE_UNINITIALIZED)
	{

		pParentGlyphData->usScanType =
			(uint16)(((pParentGlyphData->usScanType & (SK_NODROPOUT | SK_STUBS)) &
			(pGlyphData->usScanType & (SK_NODROPOUT | SK_STUBS))) |
			(pParentGlyphData->usScanType & SK_SMART));
	}
	else
	{
		pParentGlyphData->usScanType = pGlyphData->usScanType;
	}
}

/* Use various spline key values to determine if dropout control is to be activated
 * for this glyph, and if so what kind of dropout control.
 * The use of dropout control mode in the scan converter is controlled by 3 conditions.
 * The conditions are: Is the glyph rotated?, is the glyph stretched?,
 * is the current pixels per Em less than a specified threshold?
 * These conditions can be OR'd or ANDed together to determine whether the dropout control
 * mode ought to be used.

Six bits are used to specify the joint condition.  Their meanings are:

BIT     Meaning if set
8       Do dropout mode if other conditions don't block it AND
			pixels per em is less than or equal to bits 0-7
9       Do dropout mode if other conditions don't block it AND
			glyph is rotated
10      Do dropout mode if other conditions don't block it AND
			glyph is stretched
11      Do not do dropout mode unless ppem is less than or equal to bits 0-7
			A value of FF in 0-7  means all sizes
			A value of 0 in 0-7 means no sizes
12      Do not do dropout mode unless glyph is rotated
13      Do not do dropout mode unless glyph is stretched

In other words, we do not do dropout control if:
No bits are set,
Bit 8 is set, but ppem is greater than threshold
Bit 9 is set, but glyph is not rotated
Bit 10 is set, but glyph is not stretched
None of the conditions specified by bits 11-13 are true.

For example, 0xA10 specifies turn dropout control on if the glyph is rotated providing
that it is also less than 0x10 pixels per em.  A glyph is considered stretched if
the X and Y resolutions are different either because of the device characteristics
or because of the transformation matrix.  If both X and Y are changed by the same factor
the glyph is not considered stretched.

 */

FS_PRIVATE boolean fsg_DoScanControl(
	uint16 usScanControl,
	uint32 ulImageState)
{
	if ((usScanControl & SCANCTRL_DROPOUT_IF_LESS) &&
		((uint8)(ulImageState & IMAGESTATE_SIZE_MASK) <= (uint8)(usScanControl & SCANCTRL_SIZE_MASK)))
	{
		return TRUE;
	}

	if ((usScanControl & SCANCTRL_DROPOUT_IF_LESS) &&
		((usScanControl & SCANCTRL_SIZE_MASK) == SCANCTRL_DROPOUT_ALL_SIZES))
	{
		return TRUE;
	}

	if ((usScanControl & SCANCTRL_DROPOUT_IF_ROTATED) &&
		(ulImageState & IMAGESTATE_ROTATED))
	{
		return TRUE;
	}

	if ((usScanControl & SCANCTRL_DROPOUT_IF_STRETCHED) &&
		(ulImageState & IMAGESTATE_STRETCHED))
	{
		return TRUE;
	}

	if ((usScanControl & SCANCTRL_NODROP_UNLESS_LESS) &&
		((uint8)(ulImageState & IMAGESTATE_SIZE_MASK) > (uint8)(usScanControl & SCANCTRL_SIZE_MASK)))
	{
		return FALSE;
	}

	if ((usScanControl & SCANCTRL_NODROP_UNLESS_ROTATED) &&
		! (ulImageState & IMAGESTATE_ROTATED))
	{
		return FALSE;
	}

	if ((usScanControl & SCANCTRL_NODROP_UNLESS_STRETCH) &&
		! (ulImageState & IMAGESTATE_STRETCHED))
	{
		return FALSE;
	}

	return FALSE;
}

FS_PRIVATE void fsg_InitializeGlyphDataMemory(
	uint32              ulGlyphDataCount,
	fsg_WorkSpaceAddr * pWorkSpaceAddr) /* WorkSpace Address      */
{
	uint32      ulIndex;
	boolean *   abyGlyphDataFreeBlocks;

	abyGlyphDataFreeBlocks = pWorkSpaceAddr->pGlyphDataByteSet;

	for(ulIndex = 0; ulIndex < ulGlyphDataCount; ulIndex++)
	{
		abyGlyphDataFreeBlocks[ulIndex] = TRUE;
	}
}

FS_PRIVATE  ErrorCode fsg_AllocateGlyphDataMemory(
	uint32              ulGlyphDataCount,
	fsg_WorkSpaceAddr * pWorkSpaceAddr, /* WorkSpace Address      */
	GlyphData **        ppGlyphData)      /* GlyphData pointer    */
{
	uint32      ulIndex;
	boolean *   abyGlyphDataFreeBlocks;

	abyGlyphDataFreeBlocks = pWorkSpaceAddr->pGlyphDataByteSet;

	ulIndex = 0;
	while((!abyGlyphDataFreeBlocks[ulIndex]) && ulIndex < ulGlyphDataCount)
	{
		ulIndex++;
	}

	if (ulIndex == ulGlyphDataCount)
	{
		return SFNT_RECURSIVE_COMPOSITE_ERR;
	}

	abyGlyphDataFreeBlocks[ulIndex] = FALSE;

	*ppGlyphData = (GlyphData *)&((GlyphData *)pWorkSpaceAddr->pvGlyphData)[ulIndex];
	return NO_ERR;
}

FS_PRIVATE void fsg_DeallocateGlyphDataMemory(
	fsg_WorkSpaceAddr * pWorkSpaceAddr, /* WorkSpace Address    */
	GlyphData *         pGlyphData)     /* GlyphData pointer    */
{
	ptrdiff_t   ptIndex;
	boolean *   abyGlyphDataFreeBlocks;

	pGlyphData->acIdent[0] = '\0';
	pGlyphData->acIdent[1] = '\0';

	abyGlyphDataFreeBlocks = pWorkSpaceAddr->pGlyphDataByteSet;

	ptIndex = (ptrdiff_t)(pGlyphData - (GlyphData *)pWorkSpaceAddr->pvGlyphData);

	abyGlyphDataFreeBlocks[ptIndex] = TRUE;
}

FS_PRIVATE void fsg_InitializeGlyphData(
	GlyphData *             pGlyphData,     /* GlyphData pointer    */
	fsg_WorkSpaceAddr *     pWorkSpaceAddr, /* WorkSpace Address    */
	uint16                  usGlyphIndex,   /* Glyph Index          */
	uint16                  usDepth)        /* Glyph depth          */
{
	pGlyphData->acIdent[0] = 'G';
	pGlyphData->acIdent[1] = 'D';
	pGlyphData->pSibling = NULL;
	pGlyphData->pChild = NULL;
	pGlyphData->pParent = NULL;
	pGlyphData->GlyphType = glyphUndefined;
	pGlyphData->hGlyph.pvGlyphBaseAddress = NULL;
	pGlyphData->hGlyph.pvGlyphNextAddress = NULL;
	pGlyphData->usDepth = usDepth;
	pGlyphData->bUseMyMetrics = FALSE;
	pGlyphData->bScaleCompositeOffset = FALSE;
	pGlyphData->bUseChildMetrics = FALSE;
	pGlyphData->bbox.xMin = SHRT_MAX;
	pGlyphData->bbox.yMin = SHRT_MAX;
	pGlyphData->bbox.xMax = SHRT_MIN;
	pGlyphData->bbox.yMax = SHRT_MIN;
	pGlyphData->usSizeOfInstructions = 0;
	pGlyphData->pbyInstructions = NULL;
	pGlyphData->usNonScaledAW = 0;
	pGlyphData->sNonScaledLSB = 0;
	pGlyphData->MultiplexingIndicator = Undefined;
	pGlyphData->bRoundXYToGrid = FALSE;
	pGlyphData->usGlyphIndex = usGlyphIndex;
	pGlyphData->sXOffset = 0;
	pGlyphData->sYOffset = 0;
	pGlyphData->usAnchorPoint1 = 0;
	pGlyphData->usAnchorPoint2 = 0;
	pGlyphData->mulT = IdentTransform;
	pGlyphData->usScanType = SCANTYPE_UNINITIALIZED;
	pGlyphData->ptDevLSB.x = 0L;
	pGlyphData->ptDevLSB.y = 0L;
	pGlyphData->ptDevRSB.x = 0L;
	pGlyphData->ptDevRSB.y = 0L;
	pGlyphData->pGlyphElement = &pWorkSpaceAddr->pGlyphElement[usDepth];
	pGlyphData->pGlyphElement->nc = 0;
	pGlyphData->currentTMatrix = IdentTransform;
	pGlyphData->bSameTransformAsMaster = TRUE;
}

#ifdef  FSCFG_NO_INITIALIZED_DATA
FS_PUBLIC  void fsg_InitializeData (void)
{
	itrp_InitializeData ();
}
#endif

/* definitions and prototype for functions used in emboldening */

#define MABS(x)                 ( (x) < 0 ? (-(x)) : (x) )

#define LEFTSIDEBEARING 0
#define RIGHTSIDEBEARING 1

#define TOPSIDEBEARING 2
#define BOTTOMSIDEBEARING 3

#define LSBPOINTNUM(pElement) (uint16)(pElement->ep[pElement->nc - 1] + 1 + LEFTSIDEBEARING)
#define RSBPOINTNUM(pElement) (uint16)(pElement->ep[pElement->nc - 1] + 1 + RIGHTSIDEBEARING)

#define TOPSBPOINTNUM(pElement) (uint16)(pElement->ep[pElement->nc - 1] + 1 + TOPSIDEBEARING)
#define BOTTOMSBPOINTNUM(pElement) (uint16)(pElement->ep[pElement->nc - 1] + 1 + BOTTOMSIDEBEARING)

#define POSINFINITY               0x7FFFFFFFUL

#define NotSameKnot(a,b) ((a).x != (b).x || (a).y != (b).y)

/* used by QDiv2 and FQuadraticEqn */
#define places16 16
#define half16 (1 << (places16-1))

#define F32Dot32 int64

#ifndef	Sgn
	#define Sgn(a)		((a) < 0 ? -1 : ((a) > 0 ? 1 : 0))
#endif

typedef struct F26Dot6VECTOR {
	F26Dot6 x;
	F26Dot6 y;
} F26Dot6VECTOR;

typedef struct { long x,y; } Vector;

typedef enum { linkBlack, linkGrey, linkWhite } LinkColor;

short ComputeSign(int32 DeltaPrevX, int32 DeltaPrevY, int32 DeltaNextX, int32 DeltaNextY);

int64 QDiv2(int64 a, int64 b);

void FQuadraticEqn(int64 a, int64 b, int64 c, long* solutions, int64* t1, int64* t2);

F32Dot32 FSqrt(uint64 radicand);

long CurveTransitions(Vector V0, Vector V1, Vector W0, Vector W1, Vector W2);

long CurveTransitionsSegment(Vector V0, Vector V1, Vector W0, Vector W1);

void CalculateXExtremum(boolean min, long V0X, long V0Y, boolean V0On, long V1X, long V1Y, long V2X, long V2Y, boolean V2On, long *extrX, long *extrY);

void CalculateYExtremum(boolean min, long V0X, long V0Y, boolean V0On, long V1X, long V1Y, long V2X, long V2Y, boolean V2On, long *extrX, long *extrY);

void SetLineToInfinity (int16 extremumNumber, Vector extremum, Vector* C0, Vector* C1);

void MinMax2Vectors (Vector A,Vector B,Vector *Min, Vector *Max);

void MinMax3Vectors (Vector A,Vector B,Vector C, Vector *Min, Vector *Max);

boolean CheckBoundingBoxCurve(Vector C0,Vector W0,Vector W1,Vector W2,int16 extremumNumber);

boolean CheckBoundingBoxSegment(Vector C0,Vector W0,Vector W1,int16 extremumNumber);

void NormalizeVector26Dot6 (F26Dot6VECTOR *pVect);

void Intersect26Dot6(F26Dot6VECTOR Pt1, F26Dot6VECTOR Pt2, F26Dot6VECTOR Pt3, F26Dot6VECTOR Pt4, F26Dot6VECTOR *ResultPt);

void  EmboldPoint(int32 iPt, int32 iPt1, 
                  boolean bUnderTheThreshold, boolean bMisoriented, 
				  F26Dot6VECTOR PrevPt, 
				  F26Dot6VECTOR CurrPt, 
				  F26Dot6VECTOR NextPt, 
				  F26Dot6 fxRightShift, F26Dot6 fxLeftShift, 
				  F26Dot6 fxTopShift, F26Dot6 fxBottomShift, 
				  F26Dot6	fxScaledDescender,
				  fnt_ElementType * pElement); 
 
boolean Misoriented(int32 contour, uint16 extremumNumber, short extremumKnot, Vector extremum, fnt_ElementType *pElement);

/* emboldening related code */

void NormalizeVector26Dot6 (F26Dot6VECTOR *pVect)
{
	VECTOR Vec;

	itrp_Normalize (pVect->x, pVect->y, &Vec);

	/* transform from ShortFract to 26.6 */
	pVect->x = Vec.x >> 8;
	pVect->y = Vec.y >> 8;	
}

void Intersect26Dot6(F26Dot6VECTOR Pt1, F26Dot6VECTOR Pt2, F26Dot6VECTOR Pt3, F26Dot6VECTOR Pt4, F26Dot6VECTOR *ResultPt)
{
	/* this procedure was inspired by itrp_ISECT */
	F26Dot6 N, D;
	F26Dot6VECTOR B, A;
	F26Dot6VECTOR dB, dA;

	  dA.x = Pt2.x - (A.x = Pt1.x);
	  dA.y = Pt2.y - (A.y = Pt1.y);

	  dB.x = Pt4.x - (B.x = Pt3.x);
	  dB.y = Pt4.y - (B.y = Pt3.y);

	  if (dA.y == 0) 
	  {
		if (dB.x == 0) 
		{
		  ResultPt->x = B.x;
		  ResultPt->y = A.y;
		  return;
		}
		N = B.y - A.y;
		D = -dB.y;
	  } 
	  else if (dA.x == 0) 
	  {
		if (dB.y == 0) 
		{
		  ResultPt->x = A.x;
		  ResultPt->y = B.y;
		  return;
		}
		N = B.x - A.x;
		D = -dB.x;
	  } 
	  else if (MABS (dA.x) >= MABS (dA.y))
	  {
/* To prevent out of range problems divide both N and D with the max */
		N = (B.y - A.y) - MulDiv26Dot6 (B.x - A.x, dA.y, dA.x);
		D = MulDiv26Dot6 (dB.x, dA.y, dA.x) - dB.y;
	  } 
	  else 
	  {
		N = MulDiv26Dot6 (B.y - A.y, dA.x, dA.y) - (B.x - A.x);
		D = dB.x - MulDiv26Dot6 (dB.y, dA.x, dA.y);
	  }

	  if (MABS(D) > 16) /* this test used to be D != 0 but for very small D we get degenerescence */
	  {
		ResultPt->x = B.x + (F26Dot6) MulDiv26Dot6 (dB.x, N, D);
		ResultPt->y = B.y + (F26Dot6) MulDiv26Dot6 (dB.y, N, D);
	  } 
	  else 
	  {
/* degenerate case: parallell lines, what make sence in this special case is to take the
		  middle point between Pt2 and Pt3 */
		ResultPt->x = (Pt2.x + Pt3.x) >> 1;
		ResultPt->y = (Pt2.y + Pt3.y) >> 1;
	  }

	
}

void  EmboldPoint(int32 iPt, int32 iPt1, 
                  boolean bUnderTheThreshold, boolean bMisoriented,
				  F26Dot6VECTOR PrevPt, 
				  F26Dot6VECTOR CurrPt, 
				  F26Dot6VECTOR NextPt, 
				  F26Dot6 fxRightShift, F26Dot6 fxLeftShift, 
				  F26Dot6 fxTopShift, F26Dot6 fxBottomShift, 
				  F26Dot6	fxScaledDescender,
				  fnt_ElementType * pElement) 


{
	F26Dot6VECTOR dPrev, dNext, Shift, CurrPt1,  NewPt, Delta ;
	F26Dot6 fxTemp;
    int32 i;

	dPrev.x = CurrPt.x - PrevPt.x;
	dPrev.y = CurrPt.y - PrevPt.y;

	dNext.x = NextPt.x - CurrPt.x;
	dNext.y = NextPt.y - CurrPt.y;

	/* compute the orthogonal vectors */

	fxTemp = dPrev.x;
	dPrev.x = -dPrev.y;
	dPrev.y = fxTemp;

	fxTemp = dNext.x;
	dNext.x = -dNext.y;
	dNext.y = fxTemp;

    if (bMisoriented)
    {
	    dPrev.x = -dPrev.x;
	    dPrev.y = -dPrev.y;
	    dNext.x = -dNext.x;
	    dNext.y = -dNext.y;
    }

    /* copy of the current point */

	CurrPt1 = CurrPt;

    if (bUnderTheThreshold)
    {
        /* most common case, we are just moving control points one pixel horizontally */

 	    if (dPrev.x > 0)
	    {
            CurrPt1.x += fxRightShift;
	    }
	    if (dNext.x > 0)
	    {
            CurrPt.x += fxRightShift;
	    }
    } else 
    {
        /* generalization, move along the vector normal to the curve */

	    /* normalize the vectors */
	    NormalizeVector26Dot6 (&dPrev);
	    NormalizeVector26Dot6 (&dNext);


        /* apply the shift on the previous segment */

	    /* Multiply the normalized vector by the shift factor */
	    if (dPrev.x > 0)
	    {
		    Shift.x = Mul26Dot6(dPrev.x, fxRightShift);
	    } else {
		    Shift.x = Mul26Dot6(dPrev.x, fxLeftShift);
	    }

	    if (dPrev.y < 0)
	    {
		    Shift.y = Mul26Dot6(dPrev.y, fxBottomShift);
	    } else {
		    Shift.y = Mul26Dot6(dPrev.y, fxTopShift);
	    }

	    PrevPt.x += Shift.x;
	    PrevPt.y += Shift.y;

	    CurrPt1.x += Shift.x;
	    CurrPt1.y += Shift.y;

	    /* second segment */

	    /* Multiply the normalized vector by the shift factor */
	    if (dNext.x > 0)
	    {
		    Shift.x = Mul26Dot6(dNext.x, fxRightShift);
	    } else {
		    Shift.x = Mul26Dot6(dNext.x, fxLeftShift);
	    }

	    if (dNext.y < 0)
	    {
		    Shift.y = Mul26Dot6(dNext.y, fxBottomShift);
	    } else {
		    Shift.y = Mul26Dot6(dNext.y, fxTopShift);
	    }

	    NextPt.x += Shift.x;
	    NextPt.y += Shift.y;

	    CurrPt.x += Shift.x;
	    CurrPt.y += Shift.y;
    }

	if (CurrPt1.x == CurrPt.x && CurrPt1.y == CurrPt.y)
	{
		/* both points were moved by the same value, no need to intersect */
		pElement->x[iPt] = CurrPt.x;
		pElement->y[iPt] = CurrPt.y;
	} else
	{
	/* we need to reintersect */
		Intersect26Dot6(PrevPt, CurrPt1, CurrPt, NextPt, &NewPt);

		/* sanity check that we are not moving the point too far from it's original position,
			this happen at low ppem size when segment lenght get small compared to the shift 
			or when hinting caused outline overlapp */
		Delta.x = NewPt.x - pElement->x[iPt];
		Delta.y = NewPt.y - pElement->y[iPt];

		if (Delta.x > fxRightShift)
		{
			NewPt.x = pElement->x[iPt] + fxRightShift;
		}
		if (Delta.x < -fxLeftShift)
		{
			NewPt.x = pElement->x[iPt] - fxLeftShift;
		}
		if (Delta.y < -fxBottomShift)
		{
			NewPt.y = pElement->y[iPt] - fxBottomShift;
		} 
		if (Delta.y > fxTopShift)
		{
			NewPt.y = pElement->y[iPt] + fxBottomShift;
		} 

		pElement->x[iPt] = NewPt.x;
		pElement->y[iPt] = NewPt.y;

	}
	/* shift all points by fxLeftShift, fxTopShift */
	pElement->x[iPt] += fxLeftShift;
	pElement->y[iPt] += fxBottomShift;

	if (pElement->y[iPt] < fxScaledDescender)
	{
		/* clipping to prevent going below the descender and causing out of bounds problems */
		pElement->y[iPt] = fxScaledDescender;
	}

    if (iPt != iPt1)
    {
        /* duplicate points at the same coordinate, we need to move them all */
	    for(i= iPt + 1; i <= iPt1; i++)
        {
	        pElement->x[i] = pElement->x[iPt];
	        pElement->y[i] = pElement->y[iPt];
        }
    }

}

FS_PRIVATE void  fsg_Embold(
	fsg_WorkSpaceAddr * pWorkSpaceAddr,
	void *              pvGlobalGS,
	boolean             bUseHints, /* True if glyph is gridfitted       */
	boolean             bBitmapEmboldening
#ifdef FSCFG_SUBPIXEL
	,boolean            bSubPixel
#endif // FSCFG_SUBPIXEL
    )
{
	fnt_ElementType *pElement;
	fnt_GlobalGraphicStateType *globalGS;
	int32 iContour, iPt, iPt1, iStartPt, iEndPt;
	F26Dot6VECTOR FirstPt, PrevPt, NextPt, CurrPt;
	F26Dot6 fxRightShift, fxLeftShift; 
	F26Dot6 fxTopShift, fxBottomShift; 
    boolean bUnderTheThreshold;
    boolean bMisoriented;

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

	pElement = pWorkSpaceAddr->pGlyphElement;

    bUnderTheThreshold = (globalGS->uBoldSimulHorShift == 1);

#ifdef FSCFG_SUBPIXEL
	if (bSubPixel)
    {
        bUnderTheThreshold = (globalGS->uBoldSimulHorShift <= HINTING_HOR_OVERSCALE);
    }
#endif // FSCFG_SUBPIXEL

	/* adjust the right sidebearing */
    if (pElement->x[RSBPOINTNUM(pElement)] != pElement->x[LSBPOINTNUM(pElement)]) 
        /* we don't increase the width of a zero width glyph, problem with indic script */
    {
#ifdef FSCFG_SUBPIXEL
	    if (bSubPixel)
        {
    	    pElement->x[RSBPOINTNUM(pElement)] += ( ( 1 / HINTING_HOR_OVERSCALE) << 6); /* we increase the widht by one pixel regardless of size for backwards compatibility */
        } else {
#endif // FSCFG_SUBPIXEL
			pElement->x[RSBPOINTNUM(pElement)] += (1 << 6); /* we increase the widht by one pixel regardless of size for backwards compatibility */
#ifdef FSCFG_SUBPIXEL
        }
#endif // FSCFG_SUBPIXEL
    }

	/* adjust the bottom sidebearing, this is done by the value of the HorShift and not the VertShift for backwards compatibility
	   in vertical writing */
    if (pElement->y[BOTTOMSBPOINTNUM(pElement)] != pElement->y[TOPSBPOINTNUM(pElement)])
        /* we don't increase the width of a zero width glyph, problem with indic script */
    {
    	pElement->y[BOTTOMSBPOINTNUM(pElement)] -= (1 << 6); /* we increase the widht by one pixel regardless of size for backwards compatibility */
    }

	if (!bBitmapEmboldening)
	{    

		if (bUseHints)
		{
			/* to preserve the hinting, we should move by an integer amount of pixel */
			/* divide by 2, round to pixel, convert to 26.6 */
#ifdef FSCFG_SUBPIXEL
	        if (bSubPixel)
            {
			    fxLeftShift = ((globalGS->uBoldSimulHorShift /HINTING_HOR_OVERSCALE) >> 1) * HINTING_HOR_OVERSCALE; 
			    fxRightShift = (globalGS->uBoldSimulHorShift - fxLeftShift) << 6;
			    fxLeftShift = fxLeftShift << 6; 
            } else {
#endif // FSCFG_SUBPIXEL
			    fxLeftShift = globalGS->uBoldSimulHorShift >> 1; 
			    fxRightShift = (globalGS->uBoldSimulHorShift - fxLeftShift) << 6;
			    fxLeftShift = fxLeftShift << 6; 
#ifdef FSCFG_SUBPIXEL
            }
#endif // FSCFG_SUBPIXEL
			fxTopShift = globalGS->uBoldSimulVertShift >> 1;
			fxBottomShift = (globalGS->uBoldSimulVertShift - fxTopShift) << 6;
			fxTopShift = fxTopShift << 6;
		} else {
			/* divide by 2, convert to 26.6 */
			fxRightShift = globalGS->uBoldSimulHorShift << 5;
			fxLeftShift = globalGS->uBoldSimulHorShift << 5; 
			fxTopShift = globalGS->uBoldSimulVertShift << 5;
			fxBottomShift = globalGS->uBoldSimulVertShift << 5;
		}

		for (iContour = 0; iContour < pElement->nc; iContour++)
		{
			iStartPt = pElement->sp[iContour];
			iEndPt = pElement->ep[iContour];

			if (iEndPt - iStartPt >= 2)
			/* contour with less than 3 points cannot be emboldened */
			{
                bMisoriented = FALSE;
                if (pElement->fc[iContour] & OUTLINE_MISORIENTED)
                {
                    bMisoriented = TRUE;
                }
				/* we need to save the original coordinate of the first point for the computation of the last point */
				/* to compute the new coordinate for a point, we need the original coordinate of the point, the previous point
				  and the next point */

				FirstPt.x = pElement->x[iStartPt];
				FirstPt.y = pElement->y[iStartPt];

				CurrPt = FirstPt;

				PrevPt.x = pElement->x[iEndPt];
				PrevPt.y = pElement->y[iEndPt];

				NextPt.x = pElement->x[iStartPt+1];
				NextPt.y = pElement->y[iStartPt+1];

				iPt = iStartPt;

				while (iPt <= iEndPt)
				{
					iPt1 = iPt;

					/* deal with the special case of two points at the same coordinate, current and next */
					while ((NextPt.x == CurrPt.x) && (NextPt.y == CurrPt.y) && (iPt1 < iEndPt))
					{
						iPt1++;

						 if (iPt1 >= iEndPt)
							 /* the >= is to avoid goind out of bounds when preparing Prev, Next, Curr at the last step */
						{
							NextPt.x = FirstPt.x;
							NextPt.y = FirstPt.y;
						} else {
							NextPt.x = pElement->x[iPt1 +1];
							NextPt.y = pElement->y[iPt1 +1];
						}
					}

					/* we do the computation for the current point */

					EmboldPoint(iPt, iPt1, bUnderTheThreshold, bMisoriented, PrevPt, CurrPt, NextPt, 
							fxRightShift, fxLeftShift, fxTopShift, fxBottomShift, globalGS->fxScaledDescender, pElement); 
                
					iPt = iPt1;

					iPt++;
					/* we compute Prev, Next, Curr coordinate for the next point */

					PrevPt = CurrPt;

					CurrPt = NextPt;

					 if (iPt >= iEndPt)
						 /* the >= is to avoid goind out of bounds when preparing Prev, Next, Curr at the last step */
					{
						NextPt.x = FirstPt.x;
						NextPt.y = FirstPt.y;
					} else {
						NextPt.x = pElement->x[iPt +1];
						NextPt.y = pElement->y[iPt +1];
					}
				}
			}
		}
    }
}

short ComputeSign(int32 DeltaPrevX, int32 DeltaPrevY, int32 DeltaNextX, int32 DeltaNextY)
{
    int32 sgn;

	/* as our coordinates are in desing unit, they fit in 16 bits and we are not overflowing here */

    sgn = DeltaPrevX*DeltaNextY - DeltaPrevY*DeltaNextX;
	return (short)Sgn(sgn); // +1 => left turn, -1 => right turn, 0 => straight
}

Vector AddV(const Vector a, const Vector b) {
	Vector c;
	
	c.x = a.x + b.x;
	c.y = a.y + b.y;
	return c;
} // AddV

Vector SubV(const Vector a, const Vector b) {
	Vector c;
	
	c.x = a.x - b.x;
	c.y = a.y - b.y;
	return c;
} // SubV

Vector ShlV(const Vector a, long by) {
	Vector b;
	
	b.x = a.x << by;
	b.y = a.y << by;
	return b;
} // ShlV

Vector ShrV(const Vector a, long by) {
	Vector b;
	
	b.x = a.x >> by;
	b.y = a.y >> by;
	return b;
} // ShrV

int64 QDiv2(int64 a, int64 b) { // special version that replaces epsilons by 1, which is actually 1/65536 since we're actually returning F48Dot16
	int64 q;

	if (a < 0 != b < 0) {
		if (a < 0) a = -a; else b = -b;
		if (a < b) q = -1; else if (a > b << places16) q = -65536-1; else q = -((a + (b >> 1))/b);
	} else {
		if (a < 0) a = -a, b = -b;
		if (a < b) q = 1; else if (a > b << places16) q = 65536+1; else q = (a + (b >> 1))/b;
	}
	return q;
} // QDiv2

F32Dot32 FSqrt(uint64 radicand) {
	uint64 bit,root,s;

	root = 0;
	for (bit = (uint64)1 << 62; bit >= 0x8000 /* we don't need the last 16 bits */; bit >>= 1) {
		s = bit + root;
		if (s <= radicand) {
			radicand -= s;
			root |= (bit << 1);
		};
		radicand <<= 1;
	}
	return root;
} // FSqrt

void FQuadraticEqn(int64 a, int64 b, int64 c, long* solutions, int64* t1, int64* t2) {
	// the usual method for solving quadratic equations
	// input is actually in 32bit, output is F48Dot16
	int64 radicand,root,b1,b2,c1;
	
	*solutions = 0;
	if (a == 0) {
		if (b != 0) {
			*solutions = 1;
			c1 = -(c << places16);
			*t1 = QDiv2(c1,b);
		} // else b == 0, no solutions
	} else {
		a *= 2;
		radicand = b*b - 2*a*c;
		if (radicand > 0) {
			*solutions = 2;

            root = (FSqrt(radicand) + half16) >> places16;
            b <<= places16;

			b1 = -(b - root);
			b2 = -(b + root);
			*t1 = QDiv2(b1,a);
			*t2 = QDiv2(b2,a);
		} else if (radicand == 0) {
			*solutions = 1;
			b1 = -(b << places16);
			*t1 = QDiv2(b1,a);
		} // else radicand < 0, no solutions
	}
} // FQuadraticEqn

long CurveTransitionsSegment(Vector V0, Vector V1, Vector W0, Vector W1) {

//	here we're intersecting a straight line (W0, W1) with a straight line (V0, V1).
//	for the two to intersect, and writing both intersectees in standard polynomial form, there must be parameters u and v such that
//
//		A.x*u + B.x = C.x*v + D.x
//		A.y*u + B.y = C.y*v + D.y
//
//	a system of two "halfway" linear eqns. in two unknowns u and v
//	solving the first eqn. for v (which is linear in v, hence the "halfway") yields
//
//		v = (A.x*u + B.x - D.x)/C.x
//
//	substituting v into the second eqn. yields
//
//		A.y*u + B.y - D.y = C.y*(A.x*u + B.x - D.x)/C.x
//
//	rearranging terms by powers of u and multiplying by D.x yields
//
//		(A.y*C.x - C.y*A.x)*u + B.y*C.x - D.y*C.x + C.y*D.x - C.y*B.x = 0
//
//	which is a single linear eqn. in u with 0 thru 1 solutions obtained "the usual way".
//	solutions must be in the interval ]0,1] to make sure we only accept intersections of the actual segment
//	and we don't count start/end points twice by including them in adjacent segments as well (cf. also ColorTransitions above)

	Vector A,B,C,D;
    int64 a, b;
	long transitions;
	int64 u,vd;

//	re-write Line in polynomial form
//	(W1 - W0)*u + W0, which follows immediately from the "first degree" Bzier "curve" W0*(1-u) + W1*u
	A = SubV(W1,W0);
	B = W0;


//	re-write Line in polynomial form
//	(V1 - V0)*v + V0, which follows immediately from the "first degree" Bzier "curve" V0*(1-u) + V1*u
	C = SubV(V1,V0);
	D = V0;

    a = (A.y*C.x - C.y*A.x);

	transitions = 0;

    if (a != 0)
    {
        b = B.y*C.x - D.y*C.x + C.y*D.x - C.y*B.x;

    //  a*u + b = 0 => u = -b / a

	    b = -b << places16;
	    u = QDiv2(b,a); /* u stored in 48.16 */
	    
	    if (0 < u && u <= 0x10000) {
                /* to avoid loss of precision, select in which equation to replace the value of u[] */
            if (MABS(C.x) > MABS(C.y))
            {
			    vd = ((int64)A.x)*u  + ((int64)(B.x - D.x))*0x10000; // avoid division by 0 => multiply by C.x
		    //	transitions += 0 < vd && vd <= Abs(C.x);
			    if (C.x >= 0) {
				    if (0 < vd && vd <= ((int64)C.x)*0x10000) transitions++;
			    } else {
				    if (((int64)C.x)*0x10000 <= vd && vd < 0) transitions++;
			    }
            } else {
			    vd = ((int64)A.y)*u  + ((int64)(B.y - D.y))*0x10000; // avoid division by 0 => multiply by C.y
		    //	transitions += 0 < vd && vd <= Abs(C.y);
			    if (C.y >= 0) {
				    if (0 < vd && vd <= ((int64)C.y)*0x10000) transitions++;
			    } else {
				    if (((int64)C.y)*0x10000 <= vd && vd < 0) transitions++;
			    }
            }
	    }
    }

	return transitions;
} // CurveTransitionsSegment

long CurveTransitions(Vector V0, Vector V1, Vector W0, Vector W1, Vector W2) {

//	here we're intersecting a quadratic Bzier curve (W0, W1, W2) with a straight line (V0, V1).
//	for the two to intersect, and writing both intersectees in standard polynomial form, there must be parameters u and v such that
//
//		A.x*u^2 + B.x*u + C.x = D.x*v + E.x
//		A.y*u^2 + B.y*u + C.y = D.y*v + E.y
//
//	a system of two "halfway" quadratic eqns. in two unknowns u and v
//	solving the first eqn. for v (which is linear in v, hence the "halfway") yields
//
//		v = (A.x*u^2 + B.x*u + C.x - E.x)/D.x
//
//	substituting v into the second eqn. yields
//
//		A.y*u^2 + B.y*u + C.y - E.y = D.y*(A.x*u^2 + B.x*u + C.x - E.x)/D.x
//
//	rearranging terms by powers of u and multiplying by D.x yields
//
//		(A.y*D.x - D.y*A.x)*u^2 + (B.y*D.x - D.y*B.x)*u + C.y*D.x - D.y*C.x - E.y*D.x + D.y*E.x = 0
//
//	which is a single quadratic eqn. in u with 0 thru 2 solutions obtained "the usual way".
//	solutions must be in the interval ]0,1] to make sure we only accept intersections of the actual Bzier segment
//	and we don't count start/end points twice by including them in adjacent Bzier segments as well (cf. also ColorTransitions above)

	Vector A,B,C,D,E;
	long i,solutions,transitions;
	int64 u[2],vd;

//	re-write Bzier curve in polynomial form
//	W0*(1-u)^2 + 2*W1*(1-u)*u + W2*u^2 = W0*(1 - 2*u + u^2) + 2*W1*(u - u^2) + W2*u^2 = 
//	(W0 - 2*W1 + W2)*u^2 + 2*(W1 - W0)*u + W0
	A = AddV(SubV(W0,ShlV(W1,1)),W2);
	B = ShlV(SubV(W1,W0),1);
	C = W0;

//	re-write Line in polynomial form
//	(V1 - V0)*v + V0, which follows immediately from the "first degree" Bzier "curve" V0*(1-u) + V1*u
	D = SubV(V1,V0);
	E = V0;

	FQuadraticEqn(A.y*D.x - D.y*A.x,B.y*D.x - D.y*B.x,C.y*D.x - D.y*C.x - E.y*D.x + D.y*E.x,&solutions,&u[0],&u[1]);
	
	transitions = 0;
	for (i = 0; i < solutions; i++) {
		if (0 < u[i] && u[i] <= 0x10000) {
            /* to avoid loss of precision, select in which equation to replace the value of u[] */
            if (MABS(D.x) > MABS(D.y))
            {
			    vd = ((int64)A.x)*u[i]*u[i] + ((int64)B.x)*u[i]*0x10000 + ((int64)(C.x - E.x))*0x100000000; // avoid division by 0 => multiply by D.x
		    //	transitions += 0 < vd && vd <= Abs(D.x);
			    if (D.x >= 0) {
				    if (0 < vd && vd <= ((int64)D.x)*0x100000000) transitions++;
			    } else {
				    if (((int64)D.x)*0x100000000 <= vd && vd < 0) transitions++;
			    }
            } else {
			    vd = ((int64)A.y)*u[i]*u[i] + ((int64)B.y)*u[i]*0x10000 + ((int64)(C.y - E.y))*0x100000000; // avoid division by 0 => multiply by D.y
		    //	transitions += 0 < vd && vd <= Abs(D.y);
			    if (D.y >= 0) {
				    if (0 < vd && vd <= ((int64)D.y)*0x100000000) transitions++;
			    } else {
				    if (((int64)D.y)*0x100000000 <= vd && vd < 0) transitions++;
			    }
            }
		}
	}


	return transitions;
} // CurveTransitions

boolean CheckBoundingBoxCurve(Vector C0,Vector W0,Vector W1,Vector W2,int16 extremumNumber)
{
    Vector Min, Max;

    /* the curve is completely conatined in the triangle W0,W1,W2 */
    MinMax3Vectors (W0, W1, W2, &Min, &Max);

	switch (extremumNumber)
	{
	case 0:
        /* look for Min X */
        if ((Min.y <= C0.y) && (Max.y >= C0.y) && (Min.x <= C0.x) )
        {
            /* we may have an intersection */
            return TRUE;
        } else {
            return FALSE;
        }
        break;
	case 1:
        /* look for Max X */
        if ((Min.y <= C0.y) && (Max.y >= C0.y) && (Max.x >= C0.x) )
        {
            /* we may have an intersection */
            return TRUE;
        } else {
            return FALSE;
        }
        break;
	case 2:
        /* look for Min Y */
        if ((Min.x <= C0.x) && (Max.x >= C0.x) && (Min.y <= C0.y) )
        {
            /* we may have an intersection */
            return TRUE;
        } else {
            return FALSE;
        }
        break;
	case 3:
        /* look for Max Y */
        if ((Min.x <= C0.x) && (Max.x >= C0.x) && (Max.y >= C0.y) )
        {
            /* we may have an intersection */
            return TRUE;
        } else {
            return FALSE;
        }
        break;
	default:  
        /* we should never get in that case */
        FS_ASSERT(FALSE,"fsglue.c, CheckBoundingBoxCurve, illegal case");
        return TRUE;
    }

}

boolean CheckBoundingBoxSegment(Vector C0,Vector W0,Vector W1, int16 extremumNumber)
{
    Vector Min, Max;

    MinMax2Vectors (W0, W1, &Min, &Max);

	switch (extremumNumber)
	{
	case 0:
        /* look for Min X */
        if ((Min.y <= C0.y) && (Max.y >= C0.y) && (Min.x <= C0.x) )
        {
            /* we may have an intersection */
            return TRUE;
        } else {
            return FALSE;
        }
        break;
	case 1:
        /* look for Max X */
        if ((Min.y <= C0.y) && (Max.y >= C0.y) && (Max.x >= C0.x) )
        {
            /* we may have an intersection */
            return TRUE;
        } else {
            return FALSE;
        }
        break;
	case 2:
        /* look for Min Y */
        if ((Min.x <= C0.x) && (Max.x >= C0.x) && (Min.y <= C0.y) )
        {
            /* we may have an intersection */
            return TRUE;
        } else {
            return FALSE;
        }
        break;
	case 3:
        /* look for Max Y */
        if ((Min.x <= C0.x) && (Max.x >= C0.x) && (Max.y >= C0.y) )
        {
            /* we may have an intersection */
            return TRUE;
        } else {
            return FALSE;
        }
        break;
	default:  
        /* we should never get in that case */
        FS_ASSERT(FALSE,"fsglue.c, CheckBoundingBoxSegment, illegal case");
        return TRUE;
    }

}

void CalculateXExtremum(boolean min, long V0X, long V0Y, boolean V0On, long V1X, long V1Y, long V2X, long V2Y, boolean V2On, long *extrX, long *extrY) {
	int64 uNum,u1Num,uDen2,xNum,yNum; // use int64 to avoid 32 bit integer overflow...
    int64 uDen = 0;

    if (V0On) {
		V0X = V0X << 1;
		V0Y = V0Y << 1;
	} else { // both V0 and V1 are off-curve points, hence calc implied on-curve point
		V0X = V0X + V1X;
		V0Y = V0Y + V1Y;
	}
	if (V2On) {
		V2X = V2X << 1;
		V2Y = V2Y << 1;
	} else { // both V2 and V1 are off-curve points, hence calc implied on-curve point
		V2X = V2X + V1X;
		V2Y = V2Y + V1Y;
	}
	V1X = V1X << 1;
	V1Y = V1Y << 1;
	// at this point we have a quadratic bezier curve V0*(1-u)^2 + 2*V1*(1-u)*u + V2*u^2,
	// with all its control points scaled by 2 to avoid precision loss upon calculating the implied on-curve point
	// its first derivative (with respect to u) is 2*(V0 - 2*V1 + V2)*u + 2*(V1 - V0),
	// which is zero for u = (V0 - V1)/(V0 - 2*V1 + V2)
	// likewise, for 1 - u = (V2 - V1)/(V0 - 2*V1 + V2)
	uDen = V0X - 2*V1X + V2X;
	if (uDen != 0) { // put that back into the eqn. of the quadratic bezier curve
		uNum = V0X - V1X;
		u1Num = V2X - V1X;
		uDen2 = uDen*uDen;
		xNum = V0X*u1Num*u1Num + 2*V1X*u1Num*uNum + V2X*uNum*uNum;
		yNum = V0Y*u1Num*u1Num + 2*V1Y*u1Num*uNum + V2Y*uNum*uNum;
	//	if we're calculating the left extremal point, we floor the result for the probing line
	//	not to start inside the contour as a result of rounding. Starting on the contour should be fine,
	//	as this is handled in CurveTransitions, which does not include the lower end of the interval.
		*extrX = min ? (long)(xNum/uDen2) : (long)((xNum + uDen2 - 1)/uDen2);
	//	symmetrical rounding here
		*extrY = yNum >= 0 ? (long)((yNum + uDen2)/uDen2) : -(long)((uDen2 - yNum)/uDen2);
	} else { // can't solve it
		*extrX = V1X;
		*extrY = V1Y;
	}
} // CalculateXExtremum

void CalculateYExtremum(boolean min, long V0X, long V0Y, boolean V0On, long V1X, long V1Y, long V2X, long V2Y, boolean V2On, long *extrX, long *extrY) {
	int64 uNum,u1Num,uDen2,xNum,yNum; // use int64 to avoid 32 bit integer overflow...
    int64 uDen = 0;

    if (V0On) {
		V0X = V0X << 1;
		V0Y = V0Y << 1;
	} else { // both V0 and V1 are off-curve points, hence calc implied on-curve point
		V0X = V0X + V1X;
		V0Y = V0Y + V1Y;
	}
	if (V2On) {
		V2X = V2X << 1;
		V2Y = V2Y << 1;
	} else { // both V2 and V1 are off-curve points, hence calc implied on-curve point
		V2X = V2X + V1X;
		V2Y = V2Y + V1Y;
	}
	V1X = V1X << 1;
	V1Y = V1Y << 1;
	// at this point we have a quadratic bezier curve V0*(1-u)^2 + 2*V1*(1-u)*u + V2*u^2,
	// with all its control points scaled by 2 to avoid precision loss upon calculating the implied on-curve point
	// its first derivative (with respect to u) is 2*(V0 - 2*V1 + V2)*u + 2*(V1 - V0),
	// which is zero for u = (V0 - V1)/(V0 - 2*V1 + V2)
	// likewise, for 1 - u = (V2 - V1)/(V0 - 2*V1 + V2)
	uDen = V0Y - 2*V1Y + V2Y;
	if (uDen != 0) { // put that back into the eqn. of the quadratic bezier curve
		uNum = V0Y - V1Y;
		u1Num = V2Y - V1Y;
		uDen2 = uDen*uDen;
		xNum = V0X*u1Num*u1Num + 2*V1X*u1Num*uNum + V2X*uNum*uNum;
		yNum = V0Y*u1Num*u1Num + 2*V1Y*u1Num*uNum + V2Y*uNum*uNum;

        *extrY = min ? (long)(yNum/uDen2) : (long)((yNum + uDen2 - 1)/uDen2);
	//	symmetrical rounding here
		*extrX = xNum >= 0 ? (long)((xNum + uDen2)/uDen2) : -(long)((uDen2 - xNum)/uDen2);
	} else { // can't solve it
		*extrX = V1X;
		*extrY = V1Y;
	}
} // CalculateYExtremum

void SetLineToInfinity (int16 extremumNumber, Vector extremum, Vector* C0, Vector* C1)
{
/* extremumKnot = 0 : MinX
   extremumKnot = 1 : MaxX
   extremumKnot = 2 : MinY
   extremumKnot = 3 : MaxY,
    the coordinates returned in C0 and C1 are scaled by 2 */

    switch (extremumNumber) {
	case 0:
        /* line from minX to infinity */
	    C0->x = extremum.x+1;
	    C0->y = extremum.y;
	    C1->x = -32768;
	    C1->y = C0->y-1; // and make sure color transition test line does not align with any straight line in the glyph...
        break;
	case 1:
        /* line from maxX to infinity */
	    C0->x = extremum.x-1;
	    C0->y = extremum.y;
	    C1->x = 32767;
	    C1->y = C0->y-1; // and make sure color transition test line does not align with any straight line in the glyph...
        break;
	case 2:
        /* line from minY to infinity */
	    C0->x = extremum.x;
	    C0->y = extremum.y+1;
	    C1->x = C0->x-1; // and make sure color transition test line does not align with any straight line in the glyph...     
	    C1->y = -32768;
        break;
	case 3:
        /* line from maxY to infinity */
	    C0->x = extremum.x;
	    C0->y = extremum.y-1;
	    C1->x = C0->x-1; // and make sure color transition test line does not align with any straight line in the glyph...     
	    C1->y = 32767;
        break;
	default:  
        /* we should never get in that case */
        FS_ASSERT(FALSE,"fsglue.c, FindExtremaKnot, illegal case");
    }
}

void MinMax3Vectors (Vector A,Vector B,Vector C, Vector *Min, Vector *Max)
{
    *Min = A;
    if (B.x < Min->x) Min->x = B.x;
    if (C.x < Min->x) Min->x = C.x;
    if (B.y < Min->y) Min->y = B.y;
    if (C.y < Min->y) Min->y = C.y;
    *Max = A;
    if (B.x > Max->x) Max->x = B.x;
    if (C.x > Max->x) Max->x = C.x;
    if (B.y > Max->y) Max->y = B.y;
    if (C.y > Max->y) Max->y = C.y;
}

void MinMax2Vectors (Vector A,Vector B, Vector *Min, Vector *Max)
{
    *Min = A;
    if (B.x < Min->x) Min->x = B.x;
    if (B.y < Min->y) Min->y = B.y;
    *Max = A;
    if (B.x > Max->x) Max->x = B.x;
    if (B.y > Max->y) Max->y = B.y;
}

void fsg_CheckOutlineOrientation (fnt_ElementType *pElement)
{
    int32 Contour;
    boolean bMisoriented;
    short knot, n, i, start, end, predKnot, succKnot;
    short extremumKnot[4];
	Vector extremum[4];
    long minX, maxX, minY, maxY;
    long distance0_1, distance0_2, distance0_3;
    uint16 extremaNumber2, extremaNumber3;

    for (Contour = 0; Contour < pElement->nc; Contour++)
	{
        pElement->fc[Contour] = 0;

        start = pElement->sp[Contour];
        end = pElement->ep[Contour];
        
        n = end - start + 1;

        if (n > 2) 
        {
            /* we are not interested in degenerated contours */

            /* look for exterma knots to decide which direction to look to increase our chance of getting the correct result even on bad fonts */

            /* we will look for the following extrema :
               extremumKnot = 0 : MinX
               extremumKnot = 1 : MaxX
               extremumKnot = 2 : MinY
               extremumKnot = 3 : MaxY */

            for (i = 0; i < 4; i++) extremumKnot[i] = -1;
            
            minX = minY = 0x7fffffff;
    	    maxX = maxY = 0x80000000;

	        for (knot = 0; knot < n; knot++) {
                /* look for Min X */
		        if (pElement->oox[start + knot] < minX || 
			        pElement->oox[start + knot] == minX && !pElement->onCurve[extremumKnot[0]] ||  // try to get an on-curve point at same x coord
			        pElement->oox[start + knot] == minX && pElement->onCurve[extremumKnot[0]] && pElement->onCurve[start + knot] && pElement->ooy[start + knot] < pElement->ooy[extremumKnot[0]]) {
					extremumKnot[0] = start + knot;
					minX = pElement->oox[extremumKnot[0]];
					if (pElement->onCurve[extremumKnot[0]]) {
						extremum[0].x = pElement->oox[extremumKnot[0]] << 1;
						extremum[0].y = pElement->ooy[extremumKnot[0]] << 1;
					} else {
						predKnot = extremumKnot[0] == start ? end : extremumKnot[0] - 1;
						succKnot = extremumKnot[0] == end ? start : extremumKnot[0] + 1;
						CalculateXExtremum(true,pElement->oox[predKnot],pElement->ooy[predKnot],pElement->onCurve[predKnot]&true,
											pElement->oox[extremumKnot[0]],pElement->ooy[extremumKnot[0]],
											pElement->oox[succKnot],pElement->ooy[succKnot],pElement->onCurve[succKnot]&true,&extremum[0].x,&extremum[0].y);
					}
				}
                /* look for Max X */
		        if (pElement->oox[start + knot] > maxX || 
			        pElement->oox[start + knot] == maxX && !pElement->onCurve[extremumKnot[1]] ||  // try to get an on-curve point at same x coord
			        pElement->oox[start + knot] == maxX && pElement->onCurve[extremumKnot[1]] && pElement->onCurve[start + knot] && pElement->ooy[start + knot] > pElement->ooy[extremumKnot[1]]) {
					extremumKnot[1] = start + knot;
					maxX = pElement->oox[extremumKnot[1]];
					if (pElement->onCurve[extremumKnot[1]]) {
						extremum[1].x = pElement->oox[extremumKnot[1]] << 1;
						extremum[1].y = pElement->ooy[extremumKnot[1]] << 1;
					} else {
						predKnot = extremumKnot[1] == start ? end : extremumKnot[1] - 1;
						succKnot = extremumKnot[1] == end ? start : extremumKnot[1] + 1;
						CalculateXExtremum(false,pElement->oox[predKnot],pElement->ooy[predKnot],pElement->onCurve[predKnot]&true,
											pElement->oox[extremumKnot[1]],pElement->ooy[extremumKnot[1]],
											pElement->oox[succKnot],pElement->ooy[succKnot],pElement->onCurve[succKnot]&true,&extremum[1].x,&extremum[1].y);
		        		}
				}
                /* look for Min Y */
		        if (pElement->ooy[start + knot] < minY || 
			        pElement->ooy[start + knot] == minY && !pElement->onCurve[extremumKnot[2]] ||  // try to get an on-curve point at same y coord
			        pElement->ooy[start + knot] == minY && pElement->onCurve[extremumKnot[2]] && pElement->onCurve[start + knot] && pElement->oox[start + knot] > pElement->oox[extremumKnot[2]]) {
					extremumKnot[2] = start + knot;
					minY = pElement->ooy[extremumKnot[2]];
					if (pElement->onCurve[extremumKnot[2]]) {
						extremum[2].x = pElement->oox[extremumKnot[2]] << 1;
						extremum[2].y = pElement->ooy[extremumKnot[2]] << 1;
					} else {
						predKnot = extremumKnot[2] == start ? end : extremumKnot[2] - 1;
						succKnot = extremumKnot[2] == end ? start : extremumKnot[2] + 1;
						CalculateYExtremum(true,pElement->oox[predKnot],pElement->ooy[predKnot],pElement->onCurve[predKnot]&true,
											pElement->oox[extremumKnot[2]],pElement->ooy[extremumKnot[2]],
											pElement->oox[succKnot],pElement->ooy[succKnot],pElement->onCurve[succKnot]&true,&extremum[2].x,&extremum[2].y);
					}
				}
                /* look for Max Y */
		        if (pElement->ooy[start + knot] > maxY || 
			        pElement->ooy[start + knot] == maxY && !pElement->onCurve[extremumKnot[3]] ||  // try to get an on-curve point at same y coord
			        pElement->ooy[start + knot] == maxY && pElement->onCurve[extremumKnot[3]] && pElement->onCurve[start + knot] && pElement->oox[start + knot] < pElement->oox[extremumKnot[3]]) {
					extremumKnot[3] = start + knot;
					maxY = pElement->ooy[extremumKnot[3]];
					if (pElement->onCurve[extremumKnot[3]]) {
						extremum[3].x = pElement->oox[extremumKnot[3]] << 1;
						extremum[3].y = pElement->ooy[extremumKnot[3]] << 1;
					} else {
						predKnot = extremumKnot[3] == start ? end : extremumKnot[3] - 1;
						succKnot = extremumKnot[3] == end ? start : extremumKnot[3] + 1;
						CalculateYExtremum(false,pElement->oox[predKnot],pElement->ooy[predKnot],pElement->onCurve[predKnot]&true,
											pElement->oox[extremumKnot[3]],pElement->ooy[extremumKnot[3]],
											pElement->oox[succKnot],pElement->ooy[succKnot],pElement->onCurve[succKnot]&true,&extremum[3].x,&extremum[3].y);
					}
				}
	        }

            /* diagonal distance, we don't need a precise distance */

            distance0_1 = MABS(pElement->oox[extremumKnot[1]] - pElement->oox[extremumKnot[0]]) + MABS(pElement->ooy[extremumKnot[1]] - pElement->ooy[extremumKnot[0]]);
            distance0_2 = MABS(pElement->oox[extremumKnot[2]] - pElement->oox[extremumKnot[0]]) + MABS(pElement->ooy[extremumKnot[2]] - pElement->ooy[extremumKnot[0]]);
            distance0_3 = MABS(pElement->oox[extremumKnot[3]] - pElement->oox[extremumKnot[0]]) + MABS(pElement->ooy[extremumKnot[3]] - pElement->ooy[extremumKnot[0]]);

            if (distance0_2 > distance0_3)
            {
                /* we will look at MinY */
                extremaNumber2 = 2;
                if (distance0_3 > distance0_1)
                {
                    /* we will look then at MaxY */
                    extremaNumber3 = 3;
                } else {
                    /* we will look then at MaxX */
                    extremaNumber3 = 1;
                }
            } else {
                /* we will look at MaxY */
                extremaNumber2 = 3;
                if (distance0_2 > distance0_1)
                {
                    /* we will look then at MinY */
                    extremaNumber3 = 2;
                } else {
                    /* we will look then at MaxX */
                    extremaNumber3 = 1;
                }
            }

            bMisoriented = Misoriented(Contour, 0 /* MinX */, extremumKnot[0], extremum[0], pElement);

            /* look in a second direction to check if same result 
               this additional work help weed out problems with bad fonts having self-intersecting
               or overlapping outlines */
            if (bMisoriented != Misoriented(Contour, extremaNumber2, extremumKnot[extremaNumber2], extremum[extremaNumber2], pElement))
            {
                /* we need to look in a third direction */
                bMisoriented = Misoriented(Contour, extremaNumber3, extremumKnot[extremaNumber3], extremum[extremaNumber3], pElement);
            }

                // at this point we store the orientation of the original component (original in the sense of before the composite code potentially
                // applies a mirroring), such that the concertina code can work on the component w/o having to know about composite transformations
                if (bMisoriented) pElement->fc[Contour] |= OUTLINE_MISORIENTED;
        }
    }
}

boolean Misoriented(int32 contour, uint16 extremumNumber, short extremumKnot, Vector extremum, fnt_ElementType *pElement)
/* we will check the coutour orientation at the following extrema :
   extremumKnot = 0 : MinX
   extremumKnot = 1 : MaxX
   extremumKnot = 2 : MinY
   extremumKnot = 3 : MaxY */

{
	LinkColor color,orientation;
	short predKnot,cont,knot,start,iter,end,n;
	long parity;
	Vector V[3],D[2],C[2],W[3],Wi;
	boolean on[3];

    short dirChange = 0;      
    
	start = pElement->sp[contour];
	end = pElement->ep[contour];
	n = end - start + 1;

	// here we determine the straight line that runs from the extreme of the contour to infinity, to be used below.
    SetLineToInfinity(extremumNumber, extremum, &C[0], &C[1]);
	
	// find out the current orientation of the contour
	// to do so first determine what kinds of turns we make at each knot
	orientation = linkBlack; // assume as default

    knot = extremumKnot - start;
    predKnot = (knot+n-1)%n;

    V[0].x = pElement->oox[start+predKnot]; V[1].x = pElement->oox[start+knot];
	V[0].y = pElement->ooy[start+predKnot]; V[1].y = pElement->ooy[start+knot];
	D[0] = SubV(V[1],V[0]);
	for (iter = 0; iter < n && !dirChange; iter++) {
		V[2].x = pElement->oox[start + (knot + 1)%n];
		V[2].y = pElement->ooy[start + (knot + 1)%n];
		if (NotSameKnot(V[1],V[2])) {
    		D[1] = SubV(V[2],V[1]);
		    dirChange = ComputeSign(D[0].x, D[0].y, D[1].x, D[1].y);
		    V[0] = V[1]; V[1] = V[2]; D[0] = D[1];
        }
        knot = (knot + 1)%n;
	}

    if (iter < n && dirChange > 0)
    {
        orientation = linkWhite; /* counter clockwise */
    }
	
	// now find out what the orientation of the contour should really be
	// to do so we intersect the above probing line with all other contours.
	// If the number of intersections is odd, we have started inside, else outside.
	// if this doesn't correspond to the contour orientation determined above, then we're misoriented.
	// The loops below follow the same pattern used for Contour::Draw but are separate due to different underlying data structure.
	// Notice that this doesn't work for overlapping or self-intersecting contours. They're against the TT laws...
	parity = 0;
	for (cont = 0; cont < pElement->nc; cont++) {
        if (cont != contour) 
        /* we are not interested by the intersections of the contour with itself, optimization */
        {
		    start = pElement->sp[cont];
		    end = pElement->ep[cont];
		    n = end - start + 1;
		    W[1].x = pElement->oox[start] << 1;
		    W[1].y = pElement->ooy[start] << 1;
		    on[1] = pElement->onCurve[start];
		    if (!on[1]) { // we start amidst a curve => get curve start point
			    W[0].x = pElement->oox[end] << 1;
			    W[0].y = pElement->ooy[end] << 1;
			    on[0] = pElement->onCurve[end];
			    if (!on[0]) { // curve start point is implied on-curve point => compute
				    W[0] = ShrV(AddV(W[0],W[1]),1);
			    }
		    }
		    knot = start;
		    do {
			    knot = knot == end ? start : knot + 1;
			    W[2].x = pElement->oox[knot] << 1;
			    W[2].y = pElement->ooy[knot] << 1;
			    on[2] = pElement->onCurve[knot];
			    switch (on[1] << 1 | on[2]) {
				    case 3: // on---on => start and end a line => intersect with line
					    if (NotSameKnot(W[1],W[2]))
                        {
                        /* check bounding box before computing the intersection for performance */
							if (CheckBoundingBoxSegment(C[0],W[1],W[2],extremumNumber))
							{
                                parity += CurveTransitionsSegment(C[0],C[1],W[1],W[2]); // repeating first vertex makes Bzier curve a line...
							}
                        }
					    break;
				    case 2: // on---off => start a curve => intersect with nothing
					    W[0] = W[1];
					    break;
				    case 1: // off---on => end a curve => intersect with the curve
					    if (NotSameKnot(W[0],W[2])) 
                        {
                            /* check bounding box before computing the intersection for performance */
							if (CheckBoundingBoxCurve(C[0],W[0],W[1],W[2],extremumNumber))
							{
                                parity += CurveTransitions(C[0],C[1],W[0],W[1],W[2]);
							}
                        }
					    break;
				    case 0: // off---off => end a curve => intersect with the curve; then start a curve => intersect with nothing
					    Wi = ShrV(AddV(W[1],W[2]),1);
					    if (NotSameKnot(W[0],Wi))
                        {
							if (CheckBoundingBoxCurve(C[0],W[0],W[1],Wi,extremumNumber))
							{
                                parity += CurveTransitions(C[0],C[1],W[0],W[1],Wi);
							}
                        }
					    W[0] = Wi;
					    break;
			    }
			    W[1] = W[2]; on[1] = on[2];
		    } while (knot != start);
        }
	}
	color = parity & 1 ? linkBlack : linkWhite;

	return color == orientation; // cw (black) contours should have white to their left, and v.v., else they're oriented the wrong way round
} // Misoriented

#ifdef FSCFG_SUBPIXEL
FS_PUBLIC void  fsg_CopyFontProgramResults(
	void *              pvGlobalGS,
	void *              pvGlobalGSSubPixel)
{
	fnt_GlobalGraphicStateType *globalGS, *globalGSSubPixel;
	int32 i;

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;
	globalGSSubPixel = (fnt_GlobalGraphicStateType *)pvGlobalGSSubPixel;

	for (i = 0; i < globalGS->maxp->maxFunctionDefs; i++)
	{
		globalGSSubPixel->funcDef[i] = globalGS->funcDef[i];

	}

    globalGSSubPixel->instrDefCount = globalGS->instrDefCount;

	for (i = 0; i < globalGS->instrDefCount; i++)
	{
		globalGSSubPixel->instrDef[i] = globalGS->instrDef[i];

	}
	globalGSSubPixel->subPixelCompatibilityFlags = globalGS->subPixelCompatibilityFlags;

	globalGSSubPixel->numDeltaFunctionsDetected = globalGS->numDeltaFunctionsDetected;
	for (i = 0; i < globalGSSubPixel->numDeltaFunctionsDetected; i++)
		globalGSSubPixel->deltaFunction[i] = globalGS->deltaFunction[i];
}


FS_PUBLIC void  fsg_ScaleToCompatibleWidth (
	fsg_WorkSpaceAddr * pWorkSpaceAddr,
    Fixed   fxCompatibleWidthScale)
{
	fnt_ElementType *   pElement;

	pElement = pWorkSpaceAddr->pGlyphElement;
    scl_ScaleToCompatibleWidth(pElement, fxCompatibleWidthScale);
}


FS_PUBLIC void  fsg_AdjustCompatibleMetrics (
	fsg_WorkSpaceAddr * pWorkSpaceAddr,
    F26Dot6   horTranslation,
    F26Dot6   newDevAdvanceWidthX)
{
	fnt_ElementType *   pElement;

	pElement = pWorkSpaceAddr->pGlyphElement;
    scl_AdjustCompatibleMetrics(pElement, horTranslation, newDevAdvanceWidthX);
}

FS_PUBLIC void  fsg_CalcDevHorMetrics(
	fsg_WorkSpaceAddr * pWorkSpaceAddr,
	F26Dot6 *           pDevAdvanceWidthX,
	F26Dot6 *           pDevLeftSideBearingX,
	F26Dot6 *           pDevRightSideBearingX)
{
    fnt_ElementType *   pElement;

	pElement = pWorkSpaceAddr->pGlyphElement;

    scl_CalcDevHorMetrics(pElement, pDevAdvanceWidthX, pDevLeftSideBearingX, pDevRightSideBearingX);

}

FS_PUBLIC void  fsg_CalcDevNatHorMetrics(
	fsg_WorkSpaceAddr * pWorkSpaceAddr,
	F26Dot6 *           pDevAdvanceWidthX,
	F26Dot6 *           pDevLeftSideBearingX,
	F26Dot6 *           pDevRightSideBearingX,
	F26Dot6 *           pNatAdvanceWidthX,
	F26Dot6 *           pNatLeftSideBearingX,
	F26Dot6 *           pNatRightSideBearingX)
{
    fnt_ElementType *   pElement;

	pElement = pWorkSpaceAddr->pGlyphElement;

    scl_CalcDevNatHorMetrics(pElement, pDevAdvanceWidthX, pDevLeftSideBearingX, pDevRightSideBearingX, pNatAdvanceWidthX, pNatLeftSideBearingX, pNatRightSideBearingX);

}

#endif // FSCFG_SUBPIXEL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\fs\sbit.h ===
/*********************************************************************

      sbit.h -- Embedded Bitmap Module Export Definitions

      (c) Copyright 1993-1996  Microsoft Corp.  All rights reserved.

      01/12/96  claudebe    Vertical metrics support
      02/07/95  deanb       Workspace pointers for GetMetrics & GetBitmap
      01/27/95  deanb       usShaveLeft & usShaveRight added to sbit state
      01/05/94  deanb       Bitmap scaling state
      11/29/93  deanb       First cut 
 
**********************************************************************/

/*      SBIT Module State Definition    */

typedef struct
{
    uint32  ulStrikeOffset;         /* into bloc or bsca */
    uint32  ulMetricsOffset;        /* may be either table */
    uint32  ulBitmapOffset;         /* into bdat table */
    uint32  ulBitmapLength;         /* bytes of bdat data */
    uint32  ulOutMemSize;           /* bytes of bitmap output data */
    uint32  ulWorkMemSize;          /* bytes of pre-scaled,rotated bitmap data */
    uint32  ulReadMemSize;          /* bytes of extra memory, to read gray sbit under scaling or rotation */
    uint16  usTableState;           /* unsearched, bloc, bsca, or not found */
    uint16  usPpemX;                /* x pixels per Em */
    uint16  usPpemY;                /* y pixels per Em */
    uint16  usSubPpemX;             /* substitute x ppem for bitmap scaling */
    uint16  usSubPpemY;             /* substitute y ppem for bitmap scaling */
	uint16	usRotation;				/* 0=none; 1=90; 2=180; 3=270; 4=other */
    uint16  usMetricsType;          /* horiz, vert, or big */
    uint16  usMetricsTable;         /* bloc or bdat */
    uint16  usBitmapFormat;         /* bdat definitions */
    uint16  usHeight;               /* bitmap rows */
    uint16  usWidth;                /* bitmap columns */
    uint16  usAdvanceWidth;         /* advance width */
    uint16  usAdvanceHeight;        /* advance height */     /* NEW */
    uint16  usOriginalRowBytes;     /* bytes per row (padded long) */
    uint16  usExpandedRowBytes;     /* bytes per row after grayscale expansion (padded long) */
    uint16  usScaledHeight;         /* scaled bitmap rows */
    uint16  usScaledWidth;          /* scaled bitmap columns */
    uint16  usScaledRowBytes;       /* scaled bytes per row (padded long) */
    uint16  usOutRowBytes;          /* reported bytes per row (for rotation) */
    uint16  usShaveLeft;            /* white pixels on left of bbox in format 5 */
    uint16  usShaveRight;           /* white pixels on right of bbox in format 5 */
    uint16  usShaveTop;             /* white pixels on top of bbox in format 5 */   /* NEW */
    uint16  usShaveBottom;          /* white pixels on bottom of bbox in format 5 */  /* NEW */
	int16   sLSBearingX;            /* left side bearing */
	int16   sLSBearingY;            /* y coord of top left corner */ 
	int16   sTopSBearingX;          /* top side bearing X */ /* NEW */
	int16   sTopSBearingY;          /* top side bearing Y */ /* NEW */
    boolean bGlyphFound;            /* TRUE if glyph found in strike */
    boolean bMetricsValid;          /* TRUE when metrics have been read */
	uint16  usEmResolution;			/* needed when substituting missing metrics */ /* NEW */
	uint16	usBitDepth;				/* 1 for B/W bitmap, 2, 4 or 8 for gray sbit */
	uint16	uBoldSimulHorShift;
	uint16	uBoldSimulVertShift;
} 
sbit_State;

/**********************************************************************/

/*      SBIT Export Prototypes      */

FS_PUBLIC ErrorCode sbit_NewTransform(
    sbit_State  *pSbit,
    uint16		usEmResolution,
    int16 	sBoldSimulHorShift,
    int16 	sBoldSimulVertShift,
    uint16          usPpemX,
    uint16          usPpemY,
    uint16          usRotation             /* 0 - 3 => 90 deg rotation, else not 90 */
);

FS_PUBLIC ErrorCode sbit_SearchForBitmap(
    sbit_State      *pSbit,
    sfac_ClientRec  *pClientInfo,
	uint16			usGlyphCode,
	uint16          usOverScale,            /* outline magnification requested */
	uint16			*pusBitDepth,			/* 1 for B/W bitmap, 2, 4 or 8 for gray sbit */
    uint16          *pusFoundCode           /* 0 = not found, 1 = bloc, 2 = bsca */
);

FS_PUBLIC ErrorCode sbit_GetDevAdvanceWidth (
    sbit_State      *pSbit,
    sfac_ClientRec  *pClientInfo,
    point           *pf26DevAdvW 
);

#ifdef FSCFG_SUBPIXEL
FS_PUBLIC ErrorCode  sbit_CalcDevHorMetrics(
    sbit_State      *pSbit,
    sfac_ClientRec  *pClientInfo,
	F26Dot6 *       pDevAdvanceWidthX,
	F26Dot6 *       pDevLeftSideBearingX,
	F26Dot6 *       pDevRightSideBearingX);
#endif // FSCFG_SUBPIXEL

FS_PUBLIC ErrorCode sbit_GetDevAdvanceHeight (	/* NEW */
    sbit_State      *pSbit,
    sfac_ClientRec  *pClientInfo,
    point           *pf26DevAdvH 
);

FS_PUBLIC ErrorCode sbit_GetMetrics (
    sbit_State      *pSbit,
    sfac_ClientRec  *pClientInfo,
    point           *pf26DevAdvanceWidth,
    point           *pf26DevLeftSideBearing,
    point           *pf26LSB,
    point           *pf26DevAdvanceHeight, 	/* NEW */
    point           *pf26DevTopSideBearing,	/* NEW */
    point           *pf26TopSB,	/* NEW */
    Rect            *pRect,
    uint16          *pusRowBytes,
    uint32          *pulOutSize,
    uint32          *pulWorkSize
);

FS_PUBLIC ErrorCode sbit_GetBitmap (
    sbit_State      *pSbit,
    sfac_ClientRec  *pClientInfo,
    uint8           *pbyOut,
    uint8           *pbyWork
);


/**********************************************************************/

FS_PUBLIC void sbit_Embolden(uint8 *pbyBitmap, uint16 usBitmapWidth, uint16 usBitmapHeight, uint16 usRowBytes, int16 sBoldSimulHorShift, int16 sBoldSimulVertShift);

FS_PUBLIC void sbit_EmboldenGray(uint8 *pbyBitmap, uint16 usBitmapWidth, uint16 usBitmapHeight, uint16 usRowBytes, uint16 usGrayLevels, int16 sBoldSimulHorShift, int16 sBoldSimulVertShift);

#ifdef FSCFG_SUBPIXEL
FS_PUBLIC void sbit_EmboldenSubPixel(uint8 *pbyBitmap, uint16 usBitmapWidth, uint16 usBitmapHeight, uint16 usRowBytes, int16 suBoldSimulHorShift, int16 sBoldSimulVertShift);
#endif // FSCFG_SUBPIXEL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\fs\fsconfig.h ===
/*
	File:       fsconfig.h : (Portable "Standard C" version)

	Written by: Lenox Brassell

	Contains:   #define directives for FontScaler build options

   Copyright:  c 1989-1993 by Microsoft Corp., all rights reserved.

	Change History (most recent first):
		<3>      4/21/93 GregH Documented file
		<2>      7/16/92    DJ      Added fnt_Report_Error() declaration.
		<1>      8/27/91    LB      Created file.

	Usage:  This file is "#include"-ed as the first statement in
			"fscdefs.h".  This file contains platform-specific
			override definitions for the following #define-ed data
		types and macros, which have default definitions in
		"fscdefs.h":

	Purpose:

		This file gives the integrator a place to override the
		default definitions of these items, as well as a place
		to define other configuration-specific macros.

	Definitions:

		The following type definitations can be changed. The defaults have been
		set up for a 32-bit system. Caveat emptor: any change to the defaults may
		severly effect performace or place severe limitations on the capabilities
		of the TrueType rasterizer.

				F26Dot6
					 This is currently defined as a fixed point 26.6 number.
					 If changed to short, it is a 10.6 number.

		The following definition changes the return type for all Font Scalar
		Client Interface calls.

				FS_ENTRY

		The following definition changes the calling convention for all Font
		Scalar Client Interface calls.  By default, the rasterizer uses register
		calling conventions because of the performance gains.

				FS_ENTRY_PROTO

		The following definitions are used for all private and public entry points
		in the TrueType Rasterizer. By default FS_PRIVATE is set to static, but
		for some uses, like profiling and debugging this is undesirable, and
		FS_PRIVATE can be set to null. FS_PUBLIC defaults to null.

				FS_PRIVATE
				FS_PUBLIC

		The following definitions are used for calling conventions to external
		math routines. The Macintosh has external math routines that use pascal
		calling conventions. To enable these, the FS_MAC_PASCAL must be set to
		"pascal". Similary the FS_PC_PASCAL variable needs to be set to "pascal"
		when calling external routines using pascal calling conventions.

				FS_MAC_PASCAL
				FS_PC_PASCAL

		This definition is used for calling Macintosh ToolBox routines. If the
		rasterizer is implemented on a non-Macintosh platform, this Macro should
		be null.

				FS_MAC_TRAP

		These macros are used to override the C memcpy and memset routines

				MEMCPY
				MEMSET

		These math routines can be hooked out by system routines.

				SHORTDIV
				SHORTMUL

		These macros are used to convert big-endian to little-endian. When
		running on a big-endian platform these macros are not necessary.

				SWAPL
				SWAPW
				SWAPWINC

		These macros are used to replace some math routines by faster assembly
		language routines. The notation used for the assembly language routines
		should indicate the processor targeted. For example:

				#define CompMul   CompMul386
				#define CompDiv   CompDiv386
				#define FracSqrt      FracSqrt386

	The following definitions change the way the TrueType rasterizer works on
	specific implementations. These definitions are usually switches that are
	defined or not defined.

		FSCFG_DEBUG

		This is used to create a debugging version of the rasterizer. This
		version does additional error checking and creates a debugger trap
		when the TrueType DEBUG instruction is called.

		FSCFG_FNTERR

		This is used to create a error checking version of the rasterizer. With
		this set, parameters passed to TrueType instructions are range checked.
		If any instructions fails a test, a error message is returned.

		FSCFG_MOVEABLE_MEMBASE

		This is used to implement moveable memory bases. If it is possible that
		the address of a memory base could change between a Font Scaler Client
		Interface call, then this flag should be set in the rasterizer.

		FSCFG_MICROSOFT_KK

		This flag is used to implement the Microsoft KK version of the TrueType
		rasterizer. The effect of this flag is to use a slightly different
		algorithm for parsing the Format 2 cmap table.

		FSCFG_BIG_ENDIAN

		This flag indicates the target platform of the rasterizer uses big-endian
		representation of multiple-byte integers. If this flag is not set, SWAP
		macros are used to convert all multiple-byte integers read from TrueType
		Font Files.

		FSCFG_REENTRANT

		This flag indicates that the TrueType rasterizer should be reentrant.
		This allows multiple treads of execution through the executable and gives
		better system through put on multi-threaded/process environments. Slight
		performance gains are possible when not setting this flag in single tasking
		environments.

		FSCFG_NO_INITIALIZED_DATA

		This flag should be set for platforms that do not support static
		initialization of data. With this flag, a new Font Scalar Client Interface
		call fs_InitializeData needs to be made.

		FSCFG_USESTATCARD

		This flag is set to turn on stat card timing services in the rasterizer.
		This can be used to collect timing information for profiling.
		
		FSCFG_USE_MASK_SHIFT

		This flag is set to enable bitmask generated by shifting rather than by
		table lookup.  Shifted bitmasks use less memory and MAY be faster than
		table bitmasks.  On Big-Endian platforms shifted bitmasks will produce
		bitmaps that are identical to Apple's definition (same byte order).
		Table bitmaps will be identical for all platforms.
		
		FSCFG_DISABLE_GRAYSCALE

		This flag is set to disable all grayscale functions and save a little 
		code space along the way. If defined, all grayscale functions return
		a BAD_GRAY_LEVEL_ERR error code.

		FSCFG_FONTOGRAPHER_BUG

		Fontographer 3.5 has a bug. This is causing numerous symbol fonts to
		have the critical error : Inst: RCVT CVT Out of range. CVT = 255
		This flag is meant to be set under Windows. If will cause additional
		memory to be allocated for the CVT if necessary in order to be sure
		that this illegal read will access memory within the legal range.
		Under a secure rasterizer, this flag will cause RCVT with CVT <= 255
		and CVT > NumCvt to be classified as error instead of critical error

		FSCFG_EUDC_EDITOR_BUG

		The EUDC editor under NT 4.0 has a bug and create bogous fonts. 
 		The EUDC editor set maxp->maxStackElements to 0 and use 1 stack element
		 in the pre/font program. If this flag is defined, we will ensure that
		 at least one StackElement is reserved to avoid memory corruption.

                FSCFG_CONVERT_GRAY_LEVELS

                with grayscale embedded bitmap, the number of gray levels can be different than expected
                4, 16, 256 instead of 5, 17, 65. If FSCFG_CONVERT_GRAY_LEVELS is defined, a conversion will be done
                in the rasterizer to the expected number of gray levels

                FSCFG_SECURE

                Enable critical error checking in the TrueType rasterizer.

		MAC_INIT

		This flag indicates that the TrueType rasterizer will be implemented as
		a Macintosh Init.

		UNNAMED_UNION

		This flag is set for compilers that implement unnamed unions

                ClientIDType

                This definition allow the change the type definition for ClientID. If you are using ClientID to pass a pointer
                and compiling the TrueType rasterizer for a platform where pointer are bigger than 32 bits, 
                you need to change this definition.

*/

/* #define FSCFG_MICROSOFT_KK   */
/* #define FSCFG_USESTATCARD      */
/* #define FSCFG_NO_INITIALIZED_DATA */
/* #define FSCFG_FNTERR           */
/* #define FSCFG_DEBUG            */
/* #define FSCFG_MOVABLE_MEM_BASE */
/* #define FSCFG_BIG_ENDIAN   */
/* #define FSCFG_REENTRANT */    
/* #define FSCFG_NO_INITIALIZED_DATA */
/* #define FSCFG_USE_MASK_SHIFT */
/* #define FSCFG_FONTOGRAPHER_BUG */
#define FSCFG_CONVERT_GRAY_LEVELS
#define FSCFG_SECURE

/* !!! This should be removed */
#define NOT_ON_THE_MAC
#define FS_CALLBACK_PROTO __cdecl
#define FS_ENTRY_PROTO  __fastcall

/* Assembly Optimization Switches */

/* #define CompMul      CompMul386  */
/* #define CompDiv      CompDiv386  */
/* #define FracSqrt     FracSqrt386 */

#ifdef FSCFG_INTERNAL
#include "nt.h"
#include "ntrtl.h"
// if you need to have some additional .h files included only by the .c files form the rasterizer, insert your includes here

#endif

#define ClientIDType ULONG_PTR
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\fs\fserror.h ===
/*
    File:       fserror.h

    Contains:   xxx put contents here (or delete the whole line) xxx

    Written by: xxx put name of writer here (or delete the whole line) xxx

    Copyright:  c 1989-1990 by Apple Computer, Inc., all rights reserved.
				(c) 1989-1997. Microsoft Corporation, all rights reserved.

    Change History (most recent first):

		<>      10/14/97    CB      error if FDEF/IDEF in GlyphProgram
 		 <>     04/30/97    CB      ClaudeBe, missing ENDF, infinite loop/recursion
		 <>     03/1/97    CB      ClaudeBe, div by 0 in hinting error
        <4>     7/13/90    MR      made endif at bottom use a comment
         <3>      5/3/90    RB      Changed char to int8 for variable type.   Now it is legal to
                                    pass in zero as the address of memory when a piece of
         <2>     2/27/90    CL      New error code for missing but needed table. (0x1409)
       <3.1>    11/14/89    CEL     Now it is legal to pass in zero as the address of memory when a
                                    piece of the sfnt is requested by the scaler. If this happens
                                    the scaler will simply exit with an error code !
       <3.0>     8/28/89    sjk     Cleanup and one transformation bugfix
       <2.2>     8/14/89    sjk     1 point contours now OK
       <2.1>      8/8/89    sjk     Improved encryption handling
       <2.0>      8/2/89    sjk     Just fixed EASE comment
       <1.5>      8/1/89    sjk     Added composites and encryption. Plus some enhancements.
       <1.4>     6/13/89    SJK     Comment
       <1.3>      6/2/89    CEL     16.16 scaling of metrics, minimum recommended ppem, point size 0
                                    bug, correct transformed integralized ppem behavior, pretty much
                                    so
       <1.2>     5/26/89    CEL     EASE messed up on "c" comments
      <,1.1>  5/26/89    CEL     Integrated the new Font Scaler 1.0 into Spline Fonts
       <1.0>     5/25/89    CEL     Integrated 1.0 Font scaler into Bass code for the first time.

    To Do:
*/
/************/
/** ERRORS **/
/************/
#define NO_ERR                      0x0000
#define NULL_KEY                    0x0000


/** EXTERNAL INTERFACE PACKAGE **/
#define NULL_KEY_ERR                0x1001
#define NULL_INPUT_PTR_ERR          0x1002
#define NULL_MEMORY_BASES_ERR       0x1003
#define VOID_FUNC_PTR_BASE_ERR      0x1004  /* No longer used */
#define OUT_OFF_SEQUENCE_CALL_ERR   0x1005
#define BAD_CLIENT_ID_ERR           0x1006
#define NULL_SFNT_DIR_ERR           0x1007
#define NULL_SFNT_FRAG_PTR_ERR      0x1008
#define NULL_OUTPUT_PTR_ERR         0x1009
#define INVALID_GLYPH_INDEX         0x100A
#define BAND_TOO_BIG_ERR            0x100B  /* possible with FindBandingSize */
#define INVALID_CHARCODE_ERR        0x100C

/* fnt_execute */
#define UNDEFINED_INSTRUCTION_ERR   0x1101
#define TRASHED_MEM_ERR             0x1102
#define DIV_BY_0_IN_HINTING_ERR     0x1103
#define MISSING_ENDF_ERR			0x1104
#define MISSING_EIF_ERR				0x1105
#define INFINITE_RECURSION_ERR		0x1106 
#define INFINITE_LOOP_ERR			0x1107 
#define FDEF_IN_GLYPHPGM_ERR		0x1108 
#define IDEF_IN_GLYPHPGM_ERR		0x1109 

#define TRACE_FAILURE_ERR			0x110A  /* can be used by a trace function to notify of an 
                                               internal error (memory allocation failed,...) */
#define JUMP_BEFORE_START_ERR	    0x110B
#define INSTRUCTION_ERR             0x110C  /* can be used by a trace function to notify the discovery of an error */

#define RAW_NOT_IN_GLYPHPGM_ERR		0x110D 

#define SECURE_STACK_UNDERFLOW      0x1110
#define SECURE_STACK_OVERFLOW       0x1111
#define SECURE_POINT_OUT_OF_RANGE   0x1112
#define SECURE_INVALID_STACK_ACCESS 0x1113
#define SECURE_FDEF_OUT_OF_RANGE    0x1114
#define SECURE_ERR_FUNCTION_NOT_DEFINED    0x1115
#define SECURE_INVALID_ZONE         0x1116
#define SECURE_INST_OPCODE_TO_LARGE 0x1117
#define SECURE_EXCEEDS_INSTR_DEFS_IN_MAXP  0x1118
#define SECURE_STORAGE_OUT_OF_RANGE 0x1119
#define SECURE_CONTOUR_OUT_OF_RANGE 0x111A
#define SECURE_CVT_OUT_OF_RANGE     0x111B
#define SECURE_UNITIALIZED_ZONE     0x111C


/* fsg_CalculateBBox */
#define POINT_MIGRATION_ERR         0x1201

/* sc_ScanChar */
#define BAD_START_POINT_ERR         0x1301
#define SCAN_ERR                    0x1302
#define BAD_SCAN_KIND_ERR           0x1303
#define BAD_POINT_INDEX_ERR         0x1304

#define SMART_DROP_OVERFLOW_ERR     0x1305


/** SFNT DATA ERROR and errors in sfnt.c **/
#define SFNT_DATA_ERR               0x1400
#define POINTS_DATA_ERR             0x1401
#define INSTRUCTION_SIZE_ERR        0x1402
#define CONTOUR_DATA_ERR            0x1403
#define GLYPH_INDEX_ERR             0x1404
#define BAD_MAGIC_ERR               0x1405
#define OUT_OF_RANGE_SUBTABLE       0x1406
#define UNKNOWN_COMPOSITE_VERSION   0x1407
#define CLIENT_RETURNED_NULL        0x1408
#define MISSING_SFNT_TABLE          0x1409
#define UNKNOWN_CMAP_FORMAT         0x140A
#define BAD_MAXP_DATA               0x140B
#define SFNT_RECURSIVE_COMPOSITE_ERR 0x140C
#define GLYF_TABLE_CORRUPTION_ERR   0x140D
#define BAD_UNITSPEREM_ERR   		0x140E
/* spline call errors */
#define BAD_CALL_ERR                0x1500

#define TRASHED_OUTLINE_CACHE       0x1600

/* gray scale errors */
#define BAD_GRAY_LEVEL_ERR          0x1701
#define GRAY_OLD_BANDING_ERR        0x1703
#define GRAY_NO_OUTLINE_ERR         0x1704

/* embedded bitmap (sbit) errors */
#define SBIT_COMPONENT_MISSING_ERR  0x1801
#define SBIT_ROTATION_ERR           0x1802
#define SBIT_BANDING_ERR            0x1803
#define SBIT_OUTLINE_CACHE_ERR      0x1804

/* new transformation errors : */
#define TRAN_NULL_TRANSFORM_ERR     0x1901

/************ For Debugging *************/

#ifdef XXX
#define DEBUG_ON
pascal  Debug ()                     /* User break drop into Macsbug */
#ifdef  DEBUG_ON
extern  0xA9FF;
#else
{
    ;
}
#endif

#ifndef DEBUGGER
pascal void DEBUGGER(void) = 0xA9FF; 
#endif

#ifdef  LEAVEOUT
#ifndef DEBUGSTR
pascal  void DEBUGSTR (aString) int8 *aString; extern 0xABFF;
int8    *c2pstr ();
#define BugInfo( aString) DEBUGSTR( c2pstr(aString))
#endif
#endif

#endif  /* XXX */
/****************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\fs\scanlist.h ===
/*********************************************************************

	  scanlist.h -- ScanList Module Exports

	  (c) Copyright 1992  Microsoft Corp.  All rights reserved.

	   8/23/93  deanb   gray scale pass through functions
	   6/10/93  deanb   fsc_InitializeScanlist added
	  12/22/92  deanb   Rectangle -> Rect
	  10/28/92  deanb   uiRowBytes moved from setup to fillbitmap
	  10/09/92  deanb   PSTP added
	  10/08/92  deanb   reworked for split workspace
	   9/25/92  deanb   separate entry for nodrop/dropout 
	   9/10/92  deanb   horiz & vert callbacks 
	   9/09/92  deanb   size_t changes 
	   9/08/92  deanb   SetElemGlobals added 
	   6/18/92  deanb   int x coord for HorizScanAdd 
	   6/01/92  deanb   New/Old FillBitMap for debug comparisons 
	   4/21/92  deanb   Single HorizScan with flag 
	   4/13/92  deanb   unsigned int to int for HorizScanOn/Off 
	   3/31/92  deanb   InitScanArray Rectangle param 
	   3/23/92  deanb   GetWorkSize added 
	   3/16/92  deanb   New types 
	   1/31/92  deanb   HorizScan[On/Off] export functions 
	   1/14/92  deanb   First cut 

**********************************************************************/

#include "fscdefs.h"                /* for type definitions */
#include "scgray.h"                 /* for gray param definition */


typedef struct RevRoots *PRevRoot;  /* opaque type */


/*********************************************************************/

/*              Export Functions                                     */

/*********************************************************************/


FS_PUBLIC void fsc_InitializeScanlist (
		void
);

FS_PUBLIC PRevRoot fsc_SetupRevRoots (
		char*,                      /* reversal list buffer space */
		int32                       /* size of buffer space */
);

FS_PUBLIC void fsc_AddYReversal (
		PRevRoot,                   /* pointer to reversal roots */
		F26Dot6,                    /* reversal coordinate */
		int16                       /* +1 / -1 reversal value */
);

FS_PUBLIC void fsc_AddXReversal (
		PRevRoot,                   /* pointer to reversal roots */
		F26Dot6,                    /* reversal coordinate */
		int16                       /* +1 / -1 reversal value */
);

FS_PUBLIC int32 fsc_GetReversalCount (
		PRevRoot                    /* pointer to reversal roots */
);

FS_PUBLIC int32 fsc_GetHIxEstimate  (
		PRevRoot                    /* pointer to reversal roots */
);

FS_PUBLIC int32 fsc_GetVIxEstimate (
		PRevRoot                    /* pointer to reversal roots */
);

FS_PUBLIC int32 fsc_GetHIxBandEst  (
		PRevRoot,                   /* pointer to reversal roots */
		Rect*,                      /* bitmap bounding box */
		int32                                /* band width in scan lines */
);

FS_PUBLIC int32 fsc_GetRevMemSize(
		PRevRoot                    /* pointer to reversal roots */
);


/*********************************************************************/

FS_PUBLIC int32 fsc_GetScanHMem( 
		uint16,                     /* scan type */
		int32,                      /* number of horiz scanlines */
		int32                       /* number of horiz intersections */
);

FS_PUBLIC int32 fsc_GetScanVMem( 
		uint16,                     /* scan type */
		int32,                      /* number of vert scanlines */
		int32,                      /* number of vert intersections */
		int32                       /* number of contour element points */
);

/*********************************************************************/

FS_PUBLIC void fsc_SetupCallBacks( 
		PSTATE                      /* pointer to state variables */
		int16,                      /* element code (line, spline, endpoint) */
		F26Dot6 (*)(int32, F26Dot6*, F26Dot6*),   /* horiz callback */
		F26Dot6 (*)(int32, F26Dot6*, F26Dot6*)    /* vert callback */
);

FS_PUBLIC int32 fsc_SetupScan( 
		PSTATE                      /* pointer to state variables */
		Rect*,                      /* bitmap bounding box */
		uint16,                     /* scan type */
		int32,                      /* band scan upper limit */
		int32,                      /* band scan lower limit */
		boolean,                    /* save over scan bitmap row */
		int32,                      /* bytes per bitmap row */
		int32,                      /* estimate of horiz intersections */
		int32,                      /* estimate of vert intersections */
		int32,                      /* estimate of element points */
		PRevRoot                    /* reversal list Roots */ 
);


FS_PUBLIC void fsc_BeginContourScan(
		PSTATE                      /* pointer to state variables */
		uint16,                     /* scan type */
		F26Dot6,                    /* starting point x coordinate */
		F26Dot6                     /* starting point y coordinate */
);


FS_PUBLIC void fsc_BeginElement( 
		PSTATE                      /* pointer to state variables */
		uint16,                     /* type of dropout control */
		int32,                      /* determines scan on/off */   
		int32,                      /* element (line, spline, ep) */
		int32,                      /* number of points to store */
		F26Dot6*,                   /* next x control point(s) */
		F26Dot6*,                   /* next y control point(s) */
		void (**)(PSTATE int32, int32),    /* horiz add scan return */
		void (**)(PSTATE int32, int32)     /* vert add scan return */
);

/*********************************************************************/

FS_PUBLIC int32 fsc_FillBitMap( 
		PSTATE                      /* pointer to state variables */
		char*,                      /* target memory */
		int32,                      /* bitmap upper limit */
		int32,                      /* bitmap lower limit */
		int32,                      /* bitmap bytes per row */
		int32,                      /* original low band row */
		uint16                      /* scan type */
);

/*********************************************************************/

FS_PUBLIC int32 fsc_ScanClearBitMap ( 
		uint32,                     /* longs per bmp */
		uint32*                     /* bitmap ptr caste long */
);

FS_PUBLIC int32 fsc_ScanCalcGrayRow(
		GrayScaleParam*             /* pointer to param block */
);

/*********************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\fs\fsglue.h ===
/*
	File:       fsglue.h

	Contains:   xxx put contents here (or delete the whole line) xxx

	Written by: xxx put name of writer here (or delete the whole line) xxx

	Copyright:  (c) 1987-1990, 1992 by Apple Computer, Inc., all rights reserved.
				(c) 1989-1996. Microsoft Corporation, all rights reserved.

	Change History (most recent first):

	      <>    12/15/95    CB      add fsg_UpdateAdvanceHeight
	   <11+>     7/17/90    MR      Change error return type to int
		<11>     7/13/90    MR      Declared function pointer prototypes, Debug fields for runtime
									range checking
		 <8>     6/21/90    MR      Add field for ReleaseSfntFrag
		 <7>      6/5/90    MR      remove vectorMappingF
		 <6>      6/4/90    MR      Remove MVT
		 <5>      6/1/90    MR      Thus endeth the too-brief life of the MVT...
		 <4>      5/3/90    RB      adding support for new scan converter and decryption.
		 <3>     3/20/90    CL      Added function pointer for vector mapping
									Removed devRes field
									Added fpem field
		 <2>     2/27/90    CL      Change: The scaler handles both the old and new format
									simultaneously! It reconfigures itself during runtime !  Changed
									transformed width calculation.  Fixed transformed component bug.
	   <3.1>    11/14/89    CEL     Left Side Bearing should work right for any transformation. The
									phantom points are in, even for components in a composite glyph.
									They should also work for transformations. Device metric are
									passed out in the output data structure. This should also work
									with transformations. Another leftsidebearing along the advance
									width vector is also passed out. whatever the metrics are for
									the component at it's level. Instructions are legal in
									components. Now it is legal to pass in zero as the address of
									memory when a piece of the sfnt is requested by the scaler. If
									this happens the scaler will simply exit with an error code !
	   <3.0>     8/28/89    sjk     Cleanup and one transformation bugfix
	   <2.2>     8/14/89    sjk     1 point contours now OK
	   <2.1>      8/8/89    sjk     Improved encryption handling
	   <2.0>      8/2/89    sjk     Just fixed EASE comment
	   <1.5>      8/1/89    sjk     Added composites and encryption. Plus some enhancements.
	   <1.4>     6/13/89    SJK     Comment
	   <1.3>      6/2/89    CEL     16.16 scaling of metrics, minimum recommended ppem, point size 0
									bug, correct transformed integralized ppem behavior, pretty much
									so
	   <1.2>     5/26/89    CEL     EASE messed up on "c" comments
	  <,1.1>  5/26/89    CEL     Integrated the new Font Scaler 1.0 into Spline Fonts
	   <1.0>     5/25/89    CEL     Integrated 1.0 Font scaler into Bass code for the first time.

	To Do:
*/
/*      <3+>     3/20/90    mrr     Added flag executeFontPgm, set in fs_NewSFNT
*/


/*** Offset table ***/

typedef struct {
	uint32 x;
	uint32 y;
	uint32 ox;
	uint32 oy;
	uint32 oox;
	uint32 ooy;
	uint32 onCurve;
	uint32 sp;
	uint32 ep;
	uint32 f;
	uint32 fc;        
#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	uint32 pcr;
#endif
} fsg_OutlineFieldInfo;

typedef struct fsg_WorkSpaceAddr{
	 F26Dot6 *              pStack;                     /* Address of stack                  */
	 void *                 pGlyphOutlineBase;      /* Address of Glyph Outline Base     */
	 fnt_ElementType *  pGlyphElement;          /* Address of Glyph Element array    */
	 boolean *              pGlyphDataByteSet;      /* Address of ByteSet array          */
	 void *                 pvGlyphData;                /* Address of GlyphData array        */
	 void *                 pReusableMemoryMarker;  /* Address of reusable memory        */
} fsg_WorkSpaceAddr;

typedef struct fsg_WorkSpaceOffsets {
	uint32                  ulStackOffset;
	uint32                  ulGlyphOutlineOffset;
	uint32                  ulGlyphElementOffset;
	uint32                  ulGlyphDataByteSetOffset;
	uint32                  ulGlyphDataOffset;
	fsg_OutlineFieldInfo    GlyphOutlineFieldOffsets;
	 uint32                      ulReusableMemoryOffset;
	uint32                  ulMemoryBase6Offset;
	uint32                  ulMemoryBase7Offset;
	 uint32                      ulMemoryBase6Size;
	 uint32                      ulMemoryBase7Size;
} fsg_WorkSpaceOffsets;

typedef struct fsg_PrivateSpaceOffsets {
	 uint32                      offset_storage;
	 uint32                      offset_functions;
	 uint32                      offset_instrDefs;       /* <4> */
	 uint32                      offset_controlValues;
	 uint32                      offset_globalGS;
	 uint32                      offset_FontProgram;
	 uint32                      offset_PreProgram;
	 uint32                      offset_TwilightZone;
	 uint32                      offset_TwilightOutline;
	fsg_OutlineFieldInfo    TwilightOutlineFieldOffsets;
#ifdef FSCFG_SUBPIXEL
	 uint32                      offset_storageSubPixel;
	 uint32                      offset_functionsSubPixel;
	 uint32                      offset_instrDefsSubPixel;       /* <4> */
	 uint32                      offset_controlValuesSubPixel;
	 uint32                      offset_globalGSSubPixel;
	 uint32                      offset_TwilightZoneSubPixel;
	 uint32                      offset_TwilightOutlineSubPixel;
#endif // FSCFG_SUBPIXEL
} fsg_PrivateSpaceOffsets;

typedef struct fsg_TransformRec {
	uint16              usEmResolution;     /* used to be int32 <4> */
	transMatrix         currentTMatrix;     /* Current Transform Matrix */
	boolean             bPhaseShift;        /* 45 degrees flag <4> */
	boolean             bPositiveSquare;    /* Transform is a positive square */
	boolean             bIntegerScaling;    /* Font uses integer scaling */
	Fixed               fxPixelDiameter;
	uint32              ulImageState;       /* is glyph rotated, stretched, etc. */
	boolean				bEmboldSimulation; 
	uint16	uBoldSimulHorShift;
} fsg_TransformRec;

/**********************/
/** MODULE INTERFACE **/
/**********************/

/*      Memory Management Routines  */

FS_PUBLIC uint32  fsg_PrivateFontSpaceSize (
	sfac_ClientRec *            ClientInfo,
	 LocalMaxProfile *            pMaxProfile,    /* Max Profile Table    */
	fsg_PrivateSpaceOffsets *   PrivateSpaceOffsets);

FS_PUBLIC uint32    fsg_WorkSpaceSetOffsets (
	 LocalMaxProfile *       pMaxProfile,    /* Max Profile Table    */
	 fsg_WorkSpaceOffsets *  WorkSpaceOffsets,
	int32 *                 plExtraWorkSpace);

FS_PUBLIC void  fsg_UpdatePrivateSpaceAddresses(
	sfac_ClientRec *        ClientInfo,      /* Cached sfnt information */
	 LocalMaxProfile *       pMaxProfile,    /* Max Profile Table         */
	char *                  pPrivateFontSpace,
	fsg_PrivateSpaceOffsets * PrivateSpaceOffsets,
	void *                  pvStack,        /* pointer to stack         */
	void **                 pvFontProgram,  /* pointer to font program  */
	void **                 pvPreProgram);  /* pointer to pre program   */

FS_PUBLIC void  fsg_UpdateWorkSpaceAddresses(
	char *                  pWorkSpace,
	 fsg_WorkSpaceOffsets *  WorkSpaceOffsets,
	 fsg_WorkSpaceAddr *     pWorkSpaceAddr);

FS_PUBLIC void  fsg_UpdateWorkSpaceElement(
	 fsg_WorkSpaceOffsets *  WorkSpaceOffsets,
	 fsg_WorkSpaceAddr *     pWorkSpaceAddr);

FS_PUBLIC void *    fsg_QueryGlobalGS(
	char *                  pPrivateFontSpace,
	fsg_PrivateSpaceOffsets * PrivateSpaceOffsets);

#ifdef FSCFG_SUBPIXEL
FS_PUBLIC void *    fsg_QueryGlobalGSSubPixel(
	char *                  pPrivateFontSpace,
	fsg_PrivateSpaceOffsets * PrivateSpaceOffsets);
#endif // FSCFG_SUBPIXEL

FS_PUBLIC void *      fsg_QueryTwilightElement(
	char *                  pPrivateFontSpace,
	 fsg_PrivateSpaceOffsets * PrivateSpaceOffsets);

#ifdef FSCFG_SUBPIXEL
FS_PUBLIC void *      fsg_QueryTwilightElementSubPixel(
	char *                  pPrivateFontSpace,
	 fsg_PrivateSpaceOffsets * PrivateSpaceOffsets);
#endif // FSCFG_SUBPIXEL

FS_PUBLIC void *      fsg_QueryStack(fsg_WorkSpaceAddr * pWorkSpaceAddr);

FS_PUBLIC void *      fsg_QueryReusableMemory(
	char *                  pWorkSpace,
	 fsg_WorkSpaceOffsets *  WorkSpaceOffsets);

FS_PUBLIC void fsg_CheckWorkSpaceForFit(
	fsg_WorkSpaceOffsets *  WorkSpaceOffsets,
	int32                   lExtraWorkSpace,
	int32                   lMGWorkSpace,
	int32 *                 plSizeBitmap1,
	int32 *                 plSizeBitmap2);

FS_PUBLIC void  fsg_GetRealBitmapSizes(
	fsg_WorkSpaceOffsets *  WorkSpaceOffsets,
	int32 *                 plSizeBitmap1,
	 int32 *                     plSizeBitmap2);

FS_PUBLIC void  fsg_SetUpWorkSpaceBitmapMemory(
	 char *                      pWorkSpace,
	fsg_WorkSpaceOffsets *  WorkSpaceOffsets,
	char *                  pClientBitmapPtr2,
	char *                  pClientBitmapPtr3,
	char **                 ppMemoryBase6,
	char **                 ppMemoryBase7);

FS_PUBLIC void  fsg_GetWorkSpaceExtra(
	 char *                      pWorkSpace,
	fsg_WorkSpaceOffsets *  WorkSpaceOffsets,
	char **                 ppWorkSpaceExtra);

FS_PUBLIC void  fsg_QueryPPEM(
	void *      pvGlobalGS,
	uint16 *    pusPPEM);

FS_PUBLIC void  fsg_QueryPPEMXY(
	void *              pvGlobalGS,
	fsg_TransformRec *  TransformInfo,
	uint16 *            pusPPEMX,
	uint16 *            pusPPEMY,
	uint16 *            pusRotation);


/*      FSGlue Access Routines  */

FS_PUBLIC void  fsg_GetContourData(
	fsg_WorkSpaceAddr * pWorkSpaceAddr,
#ifdef FSCFG_SUBPIXEL
	boolean				bSubPixel,            
#endif // FSCFG_SUBPIXEL
	F26Dot6 **          pX,
	F26Dot6 **          pY,
	int16 **            pSp,
	int16 **            pEp,
	uint8 **            pOnCurve,
	uint8 **			pFc,
	uint16 *            pNc);

FS_PUBLIC uint32      fsg_GetContourDataSize(
	 fsg_WorkSpaceAddr * pWorkSpaceAddr);

FS_PUBLIC void  fsg_DumpContourData(
	 fsg_WorkSpaceAddr * pWorkSpaceAddr,
	 uint8 **               pbyOutline);

FS_PUBLIC void  fsg_RestoreContourData(
	 uint8 **               ppbyOutline,
	 F26Dot6 **             ppX,
	 F26Dot6 **             ppY,
	 int16 **               ppSp,
	 int16 **               ppEp,
	 uint8 **               ppOnCurve,
	 uint8 **               ppFc,
	 uint16 *               pNc);

FS_PUBLIC void  fsg_GetDevAdvanceWidth(
	 fsg_WorkSpaceAddr * pWorkSpaceAddr,
	 point *                pDevAdvanceWidth);

FS_PUBLIC void  fsg_GetDevAdvanceHeight(
	 fsg_WorkSpaceAddr * pWorkSpaceAddr,
	 point *                pDevAdvanceHeight);

FS_PUBLIC void  fsg_GetScaledCVT(
	char *                      pPrivateFontSpace,
	fsg_PrivateSpaceOffsets *   PrivateSpaceOffsets,
	F26Dot6 **                  ppScaledCVT);

FS_PUBLIC void  fsg_45DegreePhaseShift(
	 fsg_WorkSpaceAddr * pWorkSpaceAddr);

FS_PUBLIC void  fsg_UpdateAdvanceWidth (
	fsg_TransformRec *  TransformInfo,
	void *              pvGlobalGS,
	uint16              usNonScaledAW,
	vectorType *        AdvanceWidth);

FS_PUBLIC void  fsg_UpdateAdvanceHeight (
	fsg_TransformRec *  TransformInfo,
	void *              pvGlobalGS,
	uint16              usNonScaledAH,
	vectorType *        AdvanceHeight);

FS_PUBLIC void  fsg_ScaleVerticalMetrics (
    fsg_TransformRec *  TransformInfo,
    void *              pvGlobalGS,
	uint16              usNonScaledAH,
    int16               sNonScaledTSB,
	vectorType *        pvecAdvanceHeight,
	vectorType *        pvecTopSideBearing);

FS_PUBLIC void  fsg_CalcLSBsAndAdvanceWidths(
	 fsg_WorkSpaceAddr * pWorkSpaceAddr,
	 F26Dot6                fxXMin,
	 F26Dot6                fxYMax,
	 point *                devAdvanceWidth,
	 point *                devLeftSideBearing,
	 point *                LeftSideBearing,
	 point *                devLeftSideBearingLine,
	 point *                LeftSideBearingLine);

FS_PUBLIC void  fsg_CalcTSBsAndAdvanceHeights(
	 fsg_WorkSpaceAddr * pWorkSpaceAddr,
	 F26Dot6                fxXMin,
	 F26Dot6                fxYMax,
	 point *                devAdvanceHeight,
	 point *                devTopSideBearing,
	 point *                TopSideBearing,
	 point *                devTopSideBearingLine,
	 point *                TopSideBearingLine);

FS_PUBLIC boolean   fsg_IsTransformStretched(
	fsg_TransformRec *  TransformInfo);

FS_PUBLIC boolean   fsg_IsTransformRotated(
	fsg_TransformRec *  TransformInfo);

/*  Control Routines    */

FS_PUBLIC ErrorCode fsg_InitInterpreterTrans (
	fsg_TransformRec *  TransformInfo,
	void *              pvGlobalGS,     /* GlobalGS */
	Fixed               fxPointSize,
	int16               sXResolution,
	int16               sYResolution,
	boolean           bHintAtEmSquare,
	uint16             usEmboldWeightx,     /* scaling factor in x between 0 and 40 (20 means 2% fo the height) */
	uint16             usEmboldWeighty,     /* scaling factor in y between 0 and 40 (20 means 2% fo the height) */
	int16               sWinDescender,
	int32               lDescDev,               /* descender in device metric, used for clipping */
	int16 *            psBoldSimulHorShift,   /* shift for emboldening simulation, horizontally */
	int16 *            psBoldSimulVertShift   /* shift for emboldening simulation, vertically */
	);

FS_PUBLIC void  fsg_SetHintFlags(
	void *              pvGlobalGS,
	boolean				bHintForGray
#ifdef FSCFG_SUBPIXEL
	,uint16				flHintForSubPixel
#endif // FSCFG_SUBPIXEL
    );

FS_PUBLIC ErrorCode fsg_RunFontProgram(
	 void *                 globalGS,           /* GlobalGS */
	 fsg_WorkSpaceAddr * pWorkSpaceAddr,
	 void *                 pvTwilightElement,
	 FntTraceFunc           traceFunc);

FS_PUBLIC ErrorCode fsg_RunPreProgram (
	 sfac_ClientRec *   ClientInfo,
	 LocalMaxProfile *  pMaxProfile,     /* Max Profile Table    */
	 fsg_TransformRec * TransformInfo,
	 void *                 pvGlobalGS,
	 fsg_WorkSpaceAddr * pWorkSpaceAddr,
	 void *                 pvTwilightElement,
	 FntTraceFunc           traceFunc);

FS_PUBLIC ErrorCode fsg_GridFit (
	 sfac_ClientRec *   ClientInfo,      /* sfnt Client information     */
	 LocalMaxProfile *  pMaxProfile,     /* Max Profile Table               */
	 fsg_TransformRec * TransformInfo,  /* Transformation information    */
	 void *                 pvGlobalGS,      /* GlobalGS                            */
	 fsg_WorkSpaceAddr * pWorkSpaceAddr,
	 void *                 pvTwilightElement,
	 FntTraceFunc           traceFunc,
	 boolean                bUseHints,
	 uint16 *               pusScanType,
	 boolean *              pbGlyphHasOutline,
	 uint16 *               pusNonScaledAW,
	boolean                bBitmapEmboldening
#ifdef FSCFG_SUBPIXEL
	,boolean			    bSubPixel
#endif // FSCFG_SUBPIXEL
	 );

#ifdef  FSCFG_NO_INITIALIZED_DATA
FS_PUBLIC  void fsg_InitializeData (void);
#endif

#ifdef FSCFG_SUBPIXEL
FS_PUBLIC void  fsg_CopyFontProgramResults(
	void *              pvGlobalGS,
	void *              pvGlobalGSSubPixel);


FS_PUBLIC void  fsg_ScaleToCompatibleWidth (
	fsg_WorkSpaceAddr * pWorkSpaceAddr,
    Fixed   fxCompatibleWidthScale);  

FS_PUBLIC void  fsg_AdjustCompatibleMetrics (
	fsg_WorkSpaceAddr * pWorkSpaceAddr,
    F26Dot6   horTranslation,
    F26Dot6   newDevAdvanceWidthX);  

FS_PUBLIC void  fsg_CalcDevHorMetrics(
	fsg_WorkSpaceAddr * pWorkSpaceAddr,
	F26Dot6 *           pDevAdvanceWidthX,
	F26Dot6 *           pDevLeftSideBearingX,
	F26Dot6 *           pDevRightSideBearingX);

FS_PUBLIC void  fsg_CalcDevNatHorMetrics(
	fsg_WorkSpaceAddr * pWorkSpaceAddr,
	F26Dot6 *           pDevAdvanceWidthX,
	F26Dot6 *           pDevLeftSideBearingX,
	F26Dot6 *           pDevRightSideBearingX,
	F26Dot6 *           pNatAdvanceWidthX,
	F26Dot6 *           pNatLeftSideBearingX,
	F26Dot6 *           pNatRightSideBearingX);

#endif // FSCFG_SUBPIXEL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\fs\scbitmap.h ===
/*********************************************************************

	  scbitmap.h -- BitMap Module Exports

	  (c) Copyright 1992  Microsoft Corp.  All rights reserved.

	   8/19/93 deanb    fsc_CalcGrayRow added
	   6/10/93 deanb    fsc_InitializeBitMasks added
	   4/29/93 deanb    BLTCopy routine added
	   9/15/92 deanb    GetBit returns uint32 
	   8/17/92 deanb    GetBit, SetBit added 
	   7/27/92 deanb    ClearBitMap call added 
	   6/02/92 deanb    Row pointer, integer limits, no descriptor 
	   4/09/92 deanb    New types again 
	   3/16/92 deanb    New types 
	   1/15/92 deanb    First cut 

**********************************************************************/

#include "fscdefs.h"                /* for type definitions */


/*********************************************************************/

/*      Export Functions                                             */

/*********************************************************************/


FS_PUBLIC void fsc_InitializeBitMasks (
		void
);

FS_PUBLIC int32 fsc_ClearBitMap ( 
		uint32,             /* longs per bmp */
		uint32*             /* bitmap ptr caste long */
);

FS_PUBLIC int32 fsc_BLTHoriz ( 
		int32,              /* x start */
		int32,              /* x stop */
		uint32*             /* bit map row pointer */
);

FS_PUBLIC int32 fsc_BLTCopy ( 
		uint32*,            /* source row pointer */
		uint32*,            /* destination row pointer */
		int32               /* long word counter */
);

FS_PUBLIC uint32 fsc_GetBit ( 
		int32,              /* x coordinate */
		uint32*             /* bit map row pointer */
);

FS_PUBLIC int32 fsc_SetBit ( 
		int32,              /* x coordinate */
		uint32*             /* bit map row pointer */
);

FS_PUBLIC int32 fsc_CalcGrayRow(
		GrayScaleParam*     /* pointer to param block */
);


/*********************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\fs\sbit.c ===
/*********************************************************************

      sbit.c -- Embedded Bitmap Module

      (c) Copyright 1993-96  Microsoft Corp.  All rights reserved.

      04/01/96  claudebe    adding support for embedded grayscale bitmap
      02/07/95  deanb       Workspace pointers for GetMetrics & GetBitmap
      01/31/95  deanb       memset unrotated bitmap to zero
      01/27/95  deanb       usShaveLeft & usShaveRight added to sbit state
      12/21/94  deanb       rotation and vertical metrics support
      08/02/94  deanb       pf26DevLSB->y calculated correctly
      01/05/94  deanb       Bitmap scaling added
      11/29/93  deanb       First cut 
 
**********************************************************************/

#define FSCFG_INTERNAL

#include    "fscdefs.h"             /* shared data types  */
#include    "fserror.h"             /* error codes */
#include    "fontmath.h"            /* for inttodot6 macro */
        
#include    "sfntaccs.h"            /* sfnt access functions */
#include    "sbit.h"                /* own function prototypes */

/**********************************************************************/

#define MAX_BIT_INDEX	8			/* maximum bit index in a byte */

/*  Local structure */

typedef struct
{
    uint8*  pbySrc;                 /* unrotated source bitmap (as read) */
    uint8*  pbyDst;                 /* rotated destination bitmap (as returned) */
    uint16  usSrcBytesPerRow;       /* source bitmap width */
    uint16  usDstBytesPerRow;       /* destination bitmap width */
    uint16  usSrcX;                 /* source horiz pixel index */
    uint16  usSrcY;                 /* destination horiz pixel index */
    uint16  usDstX;                 /* source vert pixel index */
    uint16  usDstY;                 /* destination vert pixel index */
	uint16	usBitDepth;				/* bit depth of source/destination bitmap */
} 
CopyBlock;

/**********************************************************************/

/*  Local prototypes  */

FS_PRIVATE ErrorCode GetSbitMetrics(
    sbit_State      *pSbit,
    sfac_ClientRec  *pClientInfo 
);

FS_PRIVATE ErrorCode GetSbitComponent (
    sfac_ClientRec  *pClientInfo,
    uint32          ulStrikeOffset,
    uint16          usBitmapFormat,
    uint32          ulBitmapOffset,
    uint32          ulBitmapLength,
    uint16          usHeight,
    uint16          usWidth,
    uint16          usShaveLeft,
    uint16          usShaveRight,
    uint16          usShaveTop,
    uint16          usShaveBottom,
    uint16          usXOffset,
    uint16          usYOffset,
    uint16          usOriginalRowBytes,
    uint16          usExpandedRowBytes,
	uint16			usBitDepth,
    uint8           *pbyRead, 
    uint8           *pbyExpand 
);

FS_PRIVATE void ExpandSbitToBytePerPixel (
    uint16          usHeight,
    uint16          usWidth,
    uint16          usOriginalRowBytes,
    uint16          usExpandedRowBytes,
	uint16			usBitDepth,
    uint8           *pbySrcBitMap,
    uint8           *pbyDstBitMap );

FS_PRIVATE uint16 UScaleX(
    sbit_State  *pSbit,
    uint16      usValue
);

FS_PRIVATE uint16 UScaleY(
    sbit_State  *pSbit,
    uint16      usValue
);

FS_PRIVATE int16 SScaleX(
    sbit_State  *pSbit,
    int16       sValue
);

FS_PRIVATE int16 SScaleY(
    sbit_State  *pSbit,
    int16       sValue
);

FS_PRIVATE uint16 UEmScaleX(
    sbit_State  *pSbit,
    uint16      usValue
);

FS_PRIVATE uint16 UEmScaleY(
    sbit_State  *pSbit,
    uint16      usValue
);

FS_PRIVATE int16 SEmScaleX(
    sbit_State  *pSbit,
    int16       sValue
);

FS_PRIVATE int16 SEmScaleY(
    sbit_State  *pSbit,
    int16       sValue
);

FS_PRIVATE void ScaleVertical (
    uint8 *pbyBitmap,
    uint16 usBytesPerRow,
    uint16 usOrgHeight,
    uint16 usNewHeight
);

FS_PRIVATE void ScaleHorizontal (
    uint8 *pbyBitmap,
    uint16 usOrgBytesPerRow,
    uint16 usNewBytesPerRow,
	uint16 usBitDepth,
    uint16 usOrgWidth,
    uint16 usNewWidth,
    uint16 usRowCount
);

FS_PRIVATE void CopyBit(
    CopyBlock* pcb );

FS_PRIVATE ErrorCode SubstituteVertMetrics(
    sbit_State      *pSbit,
    sfac_ClientRec  *pClientInfo 
);

FS_PRIVATE ErrorCode SubstituteHorMetrics(
    sbit_State      *pSbit,
    sfac_ClientRec  *pClientInfo 
);



/**********************************************************************/
/***                                                                ***/
/***                       SBIT Functions                           ***/
/***                                                                ***/
/**********************************************************************/

/*  reset sbit state structure to default values */

#define MABS(x)                 ( (x) < 0 ? (-(x)) : (x) )

FS_PUBLIC ErrorCode sbit_NewTransform(
    sbit_State  *pSbit,
    uint16		usEmResolution,
    int16		sBoldSimulHorShift,
     int16		sBoldSimulVertShift,
    uint16          usPpemX,
    uint16          usPpemY,
    uint16          usRotation             /* 0 - 3 => 90 deg rotation, else not 90 */
	)
{
    pSbit->usPpemX = usPpemX;                       /* save requested ppem */
    pSbit->usPpemY = usPpemY;
    pSbit->usRotation = usRotation;                 /* used later on */

    pSbit->bGlyphFound = FALSE;
    pSbit->usTableState = SBIT_UN_SEARCHED;
    pSbit->usEmResolution = usEmResolution;

    /* with embedded bitmap, the emboldement is done before the rotation */
    pSbit->uBoldSimulHorShift = MABS(sBoldSimulHorShift); 
    pSbit->uBoldSimulVertShift = MABS(sBoldSimulVertShift); 
    if ((pSbit->usRotation == 1) || (pSbit->usRotation == 3))
    {
        /* with embedded bitmap, the emboldement is done before the rotation */
        uint16 temp;
        temp = pSbit->uBoldSimulHorShift;
        pSbit->uBoldSimulHorShift = pSbit->uBoldSimulVertShift;
        pSbit->uBoldSimulVertShift = temp;
    }
    return NO_ERR;
}

/**********************************************************************/

/*  Determine whether a glyph bitmap exists */

FS_PUBLIC ErrorCode sbit_SearchForBitmap(
    sbit_State      *pSbit,
    sfac_ClientRec  *pClientInfo,
    uint16          usGlyphCode,
	uint16          usOverScale,            /* outline magnification requested */
	uint16			*pusBitDepth,			/* 1 for B/W bitmap, 2, 4 or 8 for gray sbit */
    uint16          *pusFoundCode )         /* 0 = not found, 1 = bloc, 2 = bsca */
{    
    ErrorCode   ReturnCode;

    *pusFoundCode = 0;                              /* default */
    if (pSbit->usRotation > 3)
    {
        return NO_ERR;                              /* can't match a general rotation */
    }


    if (pSbit->usTableState == SBIT_UN_SEARCHED)    /* new trans - 1st glyph */
    {
        ReturnCode = sfac_SearchForStrike (         /* look for a strike */
            pClientInfo,
            pSbit->usPpemX, 
            pSbit->usPpemY, 
			usOverScale,            /* outline magnification requested */
			&pSbit->usBitDepth,			/* 1 for B/W bitmap, 2, 4 or 8 for gray sbit */
            &pSbit->usTableState,                   /* may set to BLOC or BSCA */
            &pSbit->usSubPpemX,                     /* if BSCA us this ppem */
            &pSbit->usSubPpemY,
            &pSbit->ulStrikeOffset );
        
        if (ReturnCode != NO_ERR) return ReturnCode;
    }

	*pusBitDepth = pSbit->usBitDepth;

    if ((pSbit->usTableState == SBIT_BLOC_FOUND) || 
        (pSbit->usTableState == SBIT_BSCA_FOUND))
    {
        ReturnCode = sfac_SearchForBitmap (         /* now look for this glyph */
            pClientInfo,
            usGlyphCode,
            pSbit->ulStrikeOffset,
            &pSbit->bGlyphFound,                    /* return values */
            &pSbit->usMetricsType,
            &pSbit->usMetricsTable,
            &pSbit->ulMetricsOffset,
            &pSbit->usBitmapFormat,
            &pSbit->ulBitmapOffset,
            &pSbit->ulBitmapLength );
        
        if (ReturnCode != NO_ERR) return ReturnCode;
        
        if (pSbit->bGlyphFound)
        {
            if (pSbit->usTableState == SBIT_BLOC_FOUND)
            {
                *pusFoundCode = 1;
            }
            else
            {
                *pusFoundCode = 2;
            }
            pSbit->bMetricsValid = FALSE;
        }
    }
    return NO_ERR;
}


/**********************************************************************/

FS_PUBLIC ErrorCode sbit_GetDevAdvanceWidth (
    sbit_State      *pSbit,
    sfac_ClientRec  *pClientInfo,
    point           *pf26DevAdvW )
{
    point       ptDevAdvW;                  /* unrotated metrics */
    ErrorCode   ReturnCode;
	boolean		bHorMetricsFound;
	boolean		bVertMetricsFound;

    ReturnCode = sfac_GetSbitMetrics (
        pClientInfo,
        pSbit->usMetricsType,
        pSbit->usMetricsTable,
        pSbit->ulMetricsOffset,
        &pSbit->usHeight,
        &pSbit->usWidth,
        &pSbit->sLSBearingX,
        &pSbit->sLSBearingY,
        &pSbit->sTopSBearingX,
        &pSbit->sTopSBearingY,
        &pSbit->usAdvanceWidth,
        &pSbit->usAdvanceHeight,
        &bHorMetricsFound,
        &bVertMetricsFound );
	
    if (ReturnCode != NO_ERR) return ReturnCode;

	/* we are only interested in AdvanceWidth */
	if (!bHorMetricsFound)
	{
		ReturnCode = SubstituteHorMetrics (pSbit, pClientInfo);
		if (ReturnCode != NO_ERR) return ReturnCode;
	}

    ptDevAdvW.x = INTTODOT6(UScaleX(pSbit, pSbit->usAdvanceWidth));
    ptDevAdvW.y = 0L;                           /* always zero for horizontal metrics */

 	switch(pSbit->usRotation)                   /* handle 90 degree rotations */
	{
	case 0:                                     /* no rotation */
        pf26DevAdvW->x = ptDevAdvW.x;
        pf26DevAdvW->y = ptDevAdvW.y;
		break;
	case 1:                                     /* 90 degree rotation */
        pf26DevAdvW->x = -ptDevAdvW.y;
        pf26DevAdvW->y = ptDevAdvW.x;
		break;
	case 2:                                     /* 180 degree rotation */
        pf26DevAdvW->x = -ptDevAdvW.x;
        pf26DevAdvW->y = -ptDevAdvW.y;
		break;
	case 3:                                     /* 270 degree rotation */
        pf26DevAdvW->x = ptDevAdvW.y;
        pf26DevAdvW->y = -ptDevAdvW.x;
		break;
	default:                                    /* non 90 degree rotation */
		return SBIT_ROTATION_ERR;
	}

    return NO_ERR;
}

#ifdef FSCFG_SUBPIXEL
FS_PUBLIC ErrorCode  sbit_CalcDevHorMetrics(
    sbit_State      *pSbit,
    sfac_ClientRec  *pClientInfo,
	F26Dot6 *       pDevAdvanceWidthX,
	F26Dot6 *       pDevLeftSideBearingX,
	F26Dot6 *       pDevRightSideBearingX)
{
    ErrorCode   ReturnCode;
	boolean		bHorMetricsFound;
	boolean		bVertMetricsFound;

	/* metrics without rotation */
    FS_ASSERT(((pSbit->usRotation == 0) || (pSbit->usRotation == 2)), "sbit_CalcDevHorMetrics called under rotation\n");

    ReturnCode = sfac_GetSbitMetrics (
        pClientInfo,
        pSbit->usMetricsType,
        pSbit->usMetricsTable,
        pSbit->ulMetricsOffset,
        &pSbit->usHeight,
        &pSbit->usWidth,
        &pSbit->sLSBearingX,
        &pSbit->sLSBearingY,
        &pSbit->sTopSBearingX,
        &pSbit->sTopSBearingY,
        &pSbit->usAdvanceWidth,
        &pSbit->usAdvanceHeight,
        &bHorMetricsFound,
        &bVertMetricsFound );
	
    if (ReturnCode != NO_ERR) return ReturnCode;

	if (!bHorMetricsFound)
	{
		ReturnCode = SubstituteHorMetrics (pSbit, pClientInfo);
		if (ReturnCode != NO_ERR) return ReturnCode;
	}

 	switch(pSbit->usRotation)                   /* handle 90 degree rotations */
	{
	case 0:                                     /* no rotation */
        *pDevAdvanceWidthX = INTTODOT6(UScaleX(pSbit, pSbit->usAdvanceWidth));
        *pDevLeftSideBearingX = INTTODOT6(UScaleX(pSbit, pSbit->sLSBearingX));
        *pDevRightSideBearingX = *pDevAdvanceWidthX - *pDevLeftSideBearingX - INTTODOT6(UScaleX(pSbit, pSbit->usWidth));
		break;
	case 2:                                     /* 180 degree rotation */
        *pDevAdvanceWidthX = -INTTODOT6(UScaleX(pSbit, pSbit->usAdvanceWidth));
        *pDevLeftSideBearingX = -INTTODOT6(UScaleX(pSbit, pSbit->sLSBearingX));
        *pDevRightSideBearingX = *pDevAdvanceWidthX - *pDevLeftSideBearingX + INTTODOT6(UScaleX(pSbit, pSbit->usWidth));
		break;
	default:                                    /* non 90 degree rotation */
		return SBIT_ROTATION_ERR;
	}
    

    return NO_ERR;
}
#endif // FSCFG_SUBPIXEL

/**********************************************************************/

FS_PUBLIC ErrorCode sbit_GetDevAdvanceHeight (
    sbit_State      *pSbit,
    sfac_ClientRec  *pClientInfo,
    point           *pf26DevAdvH )
{
    point       ptDevAdvH;                  /* unrotated metrics */
    ErrorCode   ReturnCode;
	boolean		bHorMetricsFound;
	boolean		bVertMetricsFound;

    ReturnCode = sfac_GetSbitMetrics (
        pClientInfo,
        pSbit->usMetricsType,
        pSbit->usMetricsTable,
        pSbit->ulMetricsOffset,
        &pSbit->usHeight,
        &pSbit->usWidth,
        &pSbit->sLSBearingX,
        &pSbit->sLSBearingY,
        &pSbit->sTopSBearingX,
        &pSbit->sTopSBearingY,
        &pSbit->usAdvanceWidth,
        &pSbit->usAdvanceHeight,
        &bHorMetricsFound,
        &bVertMetricsFound);
	
    if (ReturnCode != NO_ERR) return ReturnCode;

	/* we are only interested in AdvanceHeight */
	if (!bVertMetricsFound)
	{
		ReturnCode = SubstituteVertMetrics (pSbit, pClientInfo);
		if (ReturnCode != NO_ERR) return ReturnCode;
	}

/* set x components to zero */

    ptDevAdvH.x = 0L;
    ptDevAdvH.y = INTTODOT6(UScaleY(pSbit, pSbit->usAdvanceHeight));
        
     switch(pSbit->usRotation)                   /* handle 90 degree rotations */
    {
    case 0:                                     /* no rotation */
           pf26DevAdvH->x = ptDevAdvH.x;
           pf26DevAdvH->y = ptDevAdvH.y;
    	break;
    case 1:                                     /* 90 degree rotation */
           pf26DevAdvH->x = -ptDevAdvH.y;
           pf26DevAdvH->y = ptDevAdvH.x;
    	break;
    case 2:                                     /* 180 degree rotation */
           pf26DevAdvH->x = -ptDevAdvH.x;
           pf26DevAdvH->y = -ptDevAdvH.y;
    	break;
    case 3:                                     /* 270 degree rotation */
           pf26DevAdvH->x = ptDevAdvH.y;
           pf26DevAdvH->y = -ptDevAdvH.x;
    	break;
    default:                                    /* non 90 degree rotation */
    	return SBIT_ROTATION_ERR;
    }
	return NO_ERR;
}

/**********************************************************************/

FS_PUBLIC ErrorCode sbit_GetMetrics (
    sbit_State      *pSbit,
    sfac_ClientRec  *pClientInfo,
    point           *pf26DevAdvW,
    point           *pf26DevLSB,
    point           *pf26LSB,
    point           *pf26DevAdvH, 	/* NEW */
    point           *pf26DevTopSB,	/* NEW */
    point           *pf26TopSB,	/* NEW */
    Rect            *pRect,
    uint16          *pusRowBytes,
    uint32          *pulOutSize,
    uint32          *pulWorkSize )
{
    ErrorCode   ReturnCode;
    uint32      ulOrgMemSize;               /* size of unscaled bitmap */
    uint32      ulExpMemSize;               /* size of unscaled bitmap after gray expansion */
    uint32      ulScaMemSize;               /* size of scaled bitmap */
    uint32      ulMaxMemSize;               /* size of larger of scaled, unscaled */
    
    F26Dot6     f26DevAdvWx;                /* unrotated metrics */
    F26Dot6     f26DevAdvWy;
    F26Dot6     f26DevLSBx;
    F26Dot6     f26DevLSBy;
    F26Dot6     f26DevAdvHx;                /* unrotated metrics */
    F26Dot6     f26DevAdvHy;
    F26Dot6     f26DevTopSBx;
    F26Dot6     f26DevTopSBy;
    int16       sTop;                       /* unrotated bounds */
    int16       sLeft;
    int16       sBottom;
    int16       sRight;
	uint16		usOutBitDepth;				/* number of bit per pixel in the output */

	if (pSbit->usBitDepth == 1)
	{
		usOutBitDepth = 1;
	} else {
		usOutBitDepth = 8;
	}

    ReturnCode = GetSbitMetrics(pSbit, pClientInfo);
    if (ReturnCode != NO_ERR) return ReturnCode;
    
    pSbit->usScaledWidth = UScaleX(pSbit, pSbit->usWidth);
    pSbit->usScaledHeight = UScaleY(pSbit, pSbit->usHeight);


    
    sTop = SScaleY(pSbit, pSbit->sLSBearingY);            /* calc scaled metrics */
    sLeft = SScaleX(pSbit, pSbit->sLSBearingX);
    sBottom = sTop - (int16)pSbit->usScaledHeight;
    sRight = sLeft + (int16)pSbit->usScaledWidth;

    f26DevAdvWx = INTTODOT6(UScaleX(pSbit, pSbit->usAdvanceWidth));
    f26DevAdvWy = 0L;                   /* always zero for horizontal metrics */
    f26DevAdvHx = 0L;                   /* always zero for vertical metrics */
    f26DevAdvHy = INTTODOT6(UScaleY(pSbit, pSbit->usAdvanceHeight));
    f26DevLSBx = INTTODOT6(SScaleX(pSbit, pSbit->sLSBearingX));
    f26DevLSBy = INTTODOT6(SScaleY(pSbit, pSbit->sLSBearingY));
    f26DevTopSBx = INTTODOT6(SScaleX(pSbit, pSbit->sTopSBearingX));
    f26DevTopSBy = INTTODOT6(SScaleY(pSbit, pSbit->sTopSBearingY));

    pSbit->usOriginalRowBytes = ROWBYTESLONG(pSbit->usWidth * pSbit->usBitDepth);   /* keep unscaled */
    pSbit->usExpandedRowBytes = ROWBYTESLONG(pSbit->usWidth * usOutBitDepth);   /* keep unscaled */
    pSbit->usScaledRowBytes = ROWBYTESLONG(pSbit->usScaledWidth * usOutBitDepth);

	pSbit->ulReadMemSize = 0; /* size of extra memory, to read gray sbit under scaling or rotation */

    ulOrgMemSize = (uint32)pSbit->usHeight * (uint32)pSbit->usOriginalRowBytes;
    ulExpMemSize = (uint32)pSbit->usHeight * (uint32)pSbit->usExpandedRowBytes;
    ulScaMemSize = (uint32)pSbit->usScaledHeight * (uint32)pSbit->usScaledRowBytes;
    if (ulExpMemSize >= ulScaMemSize)
    {
         ulMaxMemSize = ulExpMemSize;
    }
    else
    {
         ulMaxMemSize = ulScaMemSize;
    }

 	switch(pSbit->usRotation)                   /* handle 90 degree rotations */
	{
	case 0:                                     /* no rotation */
        pRect->top = sTop;                      /* return scaled metrics */
        pRect->left = sLeft;
        pRect->bottom = sBottom;
        pRect->right = sRight;

        pf26DevAdvW->x = f26DevAdvWx;
        pf26DevAdvW->y = f26DevAdvWy;
        pf26DevLSB->x = f26DevLSBx;
        pf26DevLSB->y = f26DevLSBy;
        pf26LSB->x = f26DevLSBx;
        pf26LSB->y = INTTODOT6(sTop);

        pf26DevAdvH->x = f26DevAdvHx;
        pf26DevAdvH->y = f26DevAdvHy;
        pf26DevTopSB->x = f26DevTopSBx;
        pf26DevTopSB->y = f26DevTopSBy;
        pf26TopSB->x = f26DevTopSBx;
        pf26TopSB->y = f26DevTopSBy;

        pSbit->usOutRowBytes = ROWBYTESLONG(pSbit->usScaledWidth * usOutBitDepth);
		pSbit->ulOutMemSize = (uint32)pSbit->usScaledHeight * (uint32)pSbit->usOutRowBytes;

        if ((pSbit->usTableState == SBIT_BSCA_FOUND) || (pSbit->usBitDepth != 1))
        {
            pSbit->ulWorkMemSize = ulMaxMemSize;  /* room to read & scale or expand gray pixels */
			if (pSbit->usBitDepth != 1)
			{
				pSbit->ulWorkMemSize += ulOrgMemSize;  /* extra room to read gray pixels */
				pSbit->ulReadMemSize = ulOrgMemSize;
			}
        }
        else
        {
            pSbit->ulWorkMemSize = 0L;
        }
		break;
	case 1:                                     /* 90 degree rotation */
        pRect->top = sRight;
        pRect->left = -sTop;
        pRect->bottom = sLeft;
        pRect->right = -sBottom;
        
        pf26DevAdvW->x = -f26DevAdvWy;
        pf26DevAdvW->y = f26DevAdvWx;
        pf26DevLSB->x = -f26DevLSBy;
        pf26DevLSB->y = f26DevLSBx + INTTODOT6(sRight - sLeft);
        pf26LSB->x = 0L;
        pf26LSB->y = INTTODOT6(sRight) - f26DevLSBx;

        pf26DevAdvH->x = -f26DevAdvHy;
        pf26DevAdvH->y = f26DevAdvHx;
        pf26DevTopSB->x = -f26DevTopSBy;
        pf26DevTopSB->y = f26DevTopSBx + INTTODOT6(sRight - sLeft);

        pf26TopSB->x = INTTODOT6(-sTop) - f26DevTopSBy; 
        pf26TopSB->y = 0L; 	

        pSbit->usOutRowBytes = ROWBYTESLONG(pSbit->usScaledHeight * usOutBitDepth);
		pSbit->ulOutMemSize = (uint32)pSbit->usScaledWidth * (uint32)pSbit->usOutRowBytes; 
        pSbit->ulWorkMemSize = ulMaxMemSize;    /* room to read & scale or expand gray pixels */
		if (pSbit->usBitDepth != 1)
		{
			pSbit->ulWorkMemSize += ulOrgMemSize;  /* extra room to read gray pixels */
			pSbit->ulReadMemSize = ulOrgMemSize;
		}
		break;
	case 2:                                     /* 180 degree rotation */
        pRect->top = -sBottom;
        pRect->left = -sRight;
        pRect->bottom = -sTop;
        pRect->right = -sLeft;

        pf26DevAdvW->x = -f26DevAdvWx;
        pf26DevAdvW->y = -f26DevAdvWy;
        pf26DevLSB->x = -f26DevLSBx + INTTODOT6(sLeft - sRight);
        pf26DevLSB->y = -f26DevLSBy + INTTODOT6(sTop - sBottom);
        pf26LSB->x = -f26DevLSBx;
        pf26LSB->y = INTTODOT6(-sBottom);

        pf26DevAdvH->x = -f26DevAdvHx;
        pf26DevAdvH->y = -f26DevAdvHy;
        pf26DevTopSB->x = -f26DevTopSBx + INTTODOT6(sLeft - sRight);
        pf26DevTopSB->y = -f26DevTopSBy + INTTODOT6(sTop - sBottom);

		pf26TopSB->x = INTTODOT6(-sRight);	
        pf26TopSB->y = -f26DevTopSBy;

        pSbit->usOutRowBytes = ROWBYTESLONG(pSbit->usScaledWidth * usOutBitDepth);
		pSbit->ulOutMemSize = (uint32)pSbit->usScaledHeight * (uint32)pSbit->usOutRowBytes;
        pSbit->ulWorkMemSize = ulMaxMemSize;    /* room to read & scale or expand gray pixels */
		if (pSbit->usBitDepth != 1)
		{
			pSbit->ulWorkMemSize += ulOrgMemSize;  /* extra room to read gray pixels */
			pSbit->ulReadMemSize = ulOrgMemSize;
		}
		break;
	case 3:                                     /* 270 degree rotation */
        pRect->top = -sLeft;
        pRect->left = sBottom;
        pRect->bottom = -sRight;
        pRect->right = sTop;
        
        pf26DevAdvW->x = f26DevAdvWy;
        pf26DevAdvW->y = -f26DevAdvWx;
        pf26DevLSB->x = f26DevLSBy + INTTODOT6(sBottom - sTop);
        pf26DevLSB->y = -f26DevLSBx;
        pf26LSB->x = 0L;
        pf26LSB->y = INTTODOT6(-sLeft) + f26DevLSBx;

        pf26DevAdvH->x = f26DevAdvHy;
        pf26DevAdvH->y = -f26DevAdvHx;
        pf26DevTopSB->x = f26DevTopSBy + INTTODOT6(sBottom - sTop);
        pf26DevTopSB->y = -f26DevTopSBx;

        pf26TopSB->x = INTTODOT6(sBottom) -INTTODOT6(sTop) -INTTODOT6(sTop) + f26DevTopSBy;
        pf26TopSB->y = 0L;

        pSbit->usOutRowBytes = ROWBYTESLONG(pSbit->usScaledHeight * usOutBitDepth);
		pSbit->ulOutMemSize = (uint32)pSbit->usScaledWidth * (uint32)pSbit->usOutRowBytes;
        pSbit->ulWorkMemSize = ulMaxMemSize;    /* room to read & scale or expand gray pixels */
		if (pSbit->usBitDepth != 1)
		{
			pSbit->ulWorkMemSize += ulOrgMemSize;  /* extra room to read gray pixels */
			pSbit->ulReadMemSize = ulOrgMemSize;
		}
		break;
	default:                                    /* non 90 degree rotation */
		return SBIT_ROTATION_ERR;
	}
        
    *pusRowBytes = pSbit->usOutRowBytes;
    *pulOutSize = pSbit->ulOutMemSize;          /* return mem requirement */
    *pulWorkSize = pSbit->ulWorkMemSize;
    return NO_ERR;
}

/******************************Public*Routine******************************\
*
* sbit_Embolden adapted from vTtfdEmboldenX
*
* Does emboldening in the x direction
*
* History:
*  07-Jul-1998 -by- Claude Betrisey [ClaudeBe]
*      Moved the routine from ttfd into the rasterizer
*  24-Jun-1997 -by- Bodin Dresevic [BodinD]
* Stole from YungT
\**************************************************************************/

#define CJ_MONOCHROME_SCAN(cx)  (((cx)+7)/8)

/* embold only one pixel in the x direction */
#define DXABSBOLD 1

// array of masks for the last byte in a row

static uint8 gjMaskLeft[8] = {0XFF, 0X80, 0XC0, 0XE0, 0XF0, 0XF8, 0XFC, 0XFE };
static uint8 gjMaskRight[8] = {0XFF, 0X01, 0X03, 0X07, 0X0F, 0X1f, 0X3f, 0X7f };

//FS_PUBLIC void sbit_Embolden(uint8 *pbyBitmap, uint16 usBitmapWidth, uint16 usBitmapHeight, uint16 usRowBytes, uint16 uBoldSimulHorShift)
FS_PUBLIC void sbit_Embolden(uint8 *pbyBitmap, uint16 usBitmapWidth, uint16 usBitmapHeight, uint16 usRowBytes, int16 sBoldSimulHorShift, int16 sBoldSimulVertShift)
{
    uint8   *pCur, *pyCur, *pyCurEnd, *pAdd, newByte;	

    uint8    beginMask, endMask;
    int32    i, j;
    int32    noOfValidBitsAtEndBold;
    int32    noOfValidBitsAtEndNormal;
    int32    noOfBytesForOneLineNormal;
    int32    noOfBytesForOneLineBold;
    int32   nBytesMore;
    uint8 *pyTopNormal, *pyBottomNormal, *pyTopBold, *pyBottomBold;	

	// we want to embolden by sBoldSimulHorShift pixels horizontally(if sBoldSimulHorShift>0 then to the right; else to the left) along the base line 
    // and by sBoldSimulVertShift vertically(if sBoldSimulVertShift>0 then to the bottom; else to the top) )

	if ((usBitmapHeight == 0) || (pbyBitmap == NULL))
	{
		return;                              /* quick out for null glyph */
	}


    noOfValidBitsAtEndBold = usBitmapWidth & 7; // styoo: same as noOfValidBitsAtEndBold = usBitmapWidth % 8

    // Before emboldening,the origninal image had scans of width
    // usBitmapWidth - sBoldSimulHorShift.

    noOfBytesForOneLineBold = CJ_MONOCHROME_SCAN(usBitmapWidth);
    if( sBoldSimulHorShift >= 0 ){
        noOfBytesForOneLineNormal = CJ_MONOCHROME_SCAN(usBitmapWidth - sBoldSimulHorShift);
        noOfValidBitsAtEndNormal = (usBitmapWidth - sBoldSimulHorShift) & 7; // styoo: same as noOfValidBitsAtEndNormal = (usBitmapWidth - sBoldSimulHorShift) % 8
    }
    else{
        noOfBytesForOneLineNormal = CJ_MONOCHROME_SCAN(usBitmapWidth - (-sBoldSimulHorShift));
        noOfValidBitsAtEndNormal = (usBitmapWidth - (-sBoldSimulHorShift)) & 7; // styoo: same as noOfValidBitsAtEndNormal = (usBitmapWidth - sBoldSimulHorShift) % 8
    }

    if( sBoldSimulVertShift >= 0 ){
        pyTopNormal = pbyBitmap;
        pyBottomNormal = pbyBitmap + (usBitmapHeight-sBoldSimulVertShift-1)*usRowBytes;
        pyTopBold = pbyBitmap;
        pyBottomBold = pbyBitmap + (usBitmapHeight-1)*usRowBytes;
    }
    else{
        pyTopNormal = pbyBitmap+(-sBoldSimulVertShift)*usRowBytes;
        pyBottomNormal = pbyBitmap + (usBitmapHeight-1)*usRowBytes;
        pyTopBold = pbyBitmap;
        pyBottomBold = pyBottomNormal;
    }

//=============================================================================================================
	//Horizontal To Right
    if( sBoldSimulHorShift > 0){
        endMask = gjMaskLeft[noOfValidBitsAtEndNormal];

        for (pyCur = pyTopNormal ; pyCur <= pyBottomNormal ; pyCur += usRowBytes)
        {
		    // Clear additional Horizontal pixels
            /***************************************************************
            *    Before emboldening,the origninal image had scans of width *
            *    usBitmapWidth - sBoldSimulHorShift. Any pixels beyond this limit are       *
            *    currently garbage and must be cleared. This means that    *
            *    if the width of the emboldened bitmap is even then the low*
            *    nibble of the last byte of each scan must be cleared      *
            *    otherwise the last byte of each scan must be cleared.     *
            ***************************************************************/
            

            pCur = &pyCur[noOfBytesForOneLineNormal - 1];
            *pCur &= endMask;

            pCur++;
            while( pCur < pyCur+usRowBytes ){
                *pCur = 0;
                pCur++;
            }

            //
            pCur = &pyCur[noOfBytesForOneLineBold - 1];

            while( pCur >= pyCur)
            {
                newByte = *pCur;
                // nByteMore is how many bytes we have to borrow for bitwise oring
                // for example, if sBoldSimulHorShift is 8, we need to borrow 2 bytes(current byte(0) and previous byte(-1))
                // if if sBoldSimulHorShift is 9, we need to borrow 3 bytes(current byte(0) and 2 previous bytes(-1,-2)
                nBytesMore = (sBoldSimulHorShift+7)/8;

                for(i = 1; i <= sBoldSimulHorShift; i++){
                    for(j = 0; j<= nBytesMore; j++){
                        // if pCur-j < pyCur then out of bound
                        if(pCur-j < pyCur)
                            break;

                        if( (i-j*8) >= 0 && (i-j*8) < 8 )
                            newByte |= (pCur[-j] >> (i-j*8));
                        else if( (i-j*8) < 0 && (i-j*8) > -8 )
                            newByte |= (pCur[-j] << (j*8 - i));
                    }
                }
                *pCur = newByte;

                pCur--;
            }

        // Special implementation for the last byte, styoo: don't need to borrow from previous byte

        }
    }

    //Horizontal To Left
    else if( sBoldSimulHorShift < 0){
        beginMask = gjMaskRight[8-(-sBoldSimulHorShift)];
        endMask = gjMaskLeft[noOfValidBitsAtEndBold];

        for (pyCur = pyTopNormal ; pyCur <= pyBottomNormal ; pyCur += usRowBytes)
        {
		    // Clear additional Horizontal pixels
            /***************************************************************
            *    Before emboldening,the origninal image had scans of width *
            *    usBitmapWidth - (-sBoldSimulHorShift). Any pixels beyond this limit are       *
            *    currently garbage and must be cleared. This means that    *
            *    if the width of the emboldened bitmap is even then the low*
            *    nibble of the last byte of each scan must be cleared      *
            *    otherwise the last byte of each scan must be cleared.     *
            ***************************************************************/

            pCur = pyCur;
            *pCur &= beginMask;

            pCur = &pyCur[noOfBytesForOneLineBold-1];
            *pCur &= endMask;
            pCur++;

            while( pCur < pyCur+usRowBytes ){
                *pCur = 0;
                pCur++;
            }

            //
            pCur = pyCur;
            pyCurEnd = pyCur+(noOfBytesForOneLineBold-1);

            while( pCur <= pyCurEnd)
            {
                newByte = *pCur;

                // nByteMore is how many bytes we have to borrow for bitwise oring
                // for example, if sBoldSimulHorShift is -8, we need to borrow 2 bytes(current byte(0) and next byte(+1))
                // if if sBoldSimulHorShift is -9, we need to borrow 3 bytes(current byte(0) and 2 next bytes(+1,+2)
                nBytesMore = (-sBoldSimulHorShift+7)/8;

                for(i = 1; i <= -sBoldSimulHorShift; i++){
                    for(j = 0; j<= nBytesMore; j++){
                        // if pCur+j > pyCur+usRowBytes then out of bound
                        if(pCur+j > pyCurEnd)
                            break;

                        if( (i-j*8) >= 0 && (i-j*8) < 8 )
                            newByte |= (pCur[j] << (i-j*8));
                        else if( (i-j*8) < 0 && (i-j*8) > -8 )
                            newByte |= (pCur[j] >> (j*8 - i));
                    }
                }
                *pCur = newByte;

                pCur++;
            }

            // Special implementation for the last byte, styoo: don't need to borrow from previous byte


        }
    }
    // Vertical To the Bottom
	if( sBoldSimulVertShift > 0 ){
		// Clear additional vertical lines
        pyCur = pyBottomNormal + usRowBytes;
        while(pyCur <= pyBottomBold){
            pCur = pyCur;
			for(i=0; i<usRowBytes;i++,pCur++)
				*pCur = 0;

            pyCur += usRowBytes;
        }

        //
		pyCur = pyBottomBold;
		while ( pyCur > pyTopNormal){
			pCur = pyCur;
			for(i=0; i<noOfBytesForOneLineBold;i++,pCur++){
				newByte = *pCur;

				for(j=1; j<=sBoldSimulVertShift; j++){
                    pAdd = pCur - j*usRowBytes;
					if(pAdd >= pyTopNormal)
						newByte |= *pAdd;
					else 
						break;
				}

                *pCur = newByte;
			}

			pyCur -= usRowBytes;
		}

	}
    // Vertical To the Top
	else if( sBoldSimulVertShift < 0 ){

		// Clear additional Vertical lines
        pyCur = pyTopNormal - usRowBytes;
        while(pyCur >= pyTopBold){
            pCur = pyCur;
			for(i=0; i<usRowBytes;i++,pCur++)
				*pCur = 0;

            pyCur -= usRowBytes;
        }
        
		//
		pyCur = pyTopBold;
		while ( pyCur < pyBottomNormal){
			pCur = pyCur;
			for(i=0; i<noOfBytesForOneLineBold;i++,pCur++){
				newByte = *pCur;

				for(j=1; j<=-sBoldSimulVertShift; j++){
                    pAdd = pCur + j*usRowBytes;
					if(pAdd < pyBottomNormal+usRowBytes)
						newByte |= *pAdd;
					else 
						break;
				}

                *pCur = newByte;
			}

			pyCur += usRowBytes;
		}
	}
}

/******************************Public*Routine******************************\
* sbit_EmboldenGray adapted from vEmboldenOneBitGrayBitmap
*
* History:
*  03-Mar-2000 -by- Sung-Tae Yoo [styoo]
*      Bitmap level emboldening
*  07-Jul-1998 -by- Claude Betrisey [ClaudeBe]
*      Moved the routine from ttfd into the rasterizer
*  Wed 28-May-1997 by Tony Tsai [YungT]
*      Rename the function name, a special case for 1-bit embolden
*  Wed 22-Feb-1995 13:21:55 by Kirk Olynyk [kirko]
* Wrote it.
\**************************************************************************/

//FS_PUBLIC void sbit_EmboldenGray(uint8 *pbyBitmap, uint16 usBitmapWidth, uint16 usBitmapHeight, uint16 usRowBytes, uint16 usGrayLevels, uint16 uBoldSimulHorShift)
FS_PUBLIC void sbit_EmboldenGray(uint8 *pbyBitmap, uint16 usBitmapWidth, uint16 usBitmapHeight, uint16 usRowBytes, uint16 usGrayLevels, int16 sBoldSimulHorShift, int16 sBoldSimulVertShift)
{
    uint8 newPix;
    uint8 *pCur, *pyCur, *pAdd;	
    int32  i, j;
    uint8 *pyTopNormal, *pyBottomNormal, *pyTopBold, *pyBottomBold;	

	if ((usBitmapHeight == 0) || (pbyBitmap == NULL))
	{
		return;                              /* quick out for null glyph */
	}

    if( sBoldSimulVertShift >= 0 ){
        pyTopNormal = pbyBitmap;
        pyBottomNormal = pbyBitmap + (usBitmapHeight-sBoldSimulVertShift-1)*usRowBytes;
        pyTopBold = pbyBitmap;
        pyBottomBold = pbyBitmap + (usBitmapHeight-1)*usRowBytes;
    }
    else{
        pyTopNormal = pbyBitmap+(-sBoldSimulVertShift)*usRowBytes;
        pyBottomNormal = pbyBitmap + (usBitmapHeight-1)*usRowBytes;
        pyTopBold = pbyBitmap;
        pyBottomBold = pyBottomNormal;
    }

	//Horizontal To Right
    if( sBoldSimulHorShift > 0 ){
        for (pyCur = pyTopNormal ; pyCur <= pyBottomNormal ; pyCur += usRowBytes)
        {
		    // Clear additional Horizontal pixels

            /***************************************************************
            *    Before emboldening,the origninal image had scans of width *
            *    usBitmapWidth - sBoldSimulHorShift. Any pixels beyond this limit are       *
            *    currently garbage and must be cleared. This means that    *
            *    if the width of the emboldened bitmap is even then the low*
            *    nibble of the last byte of each scan must be cleared      *
            *    otherwise the last byte of each scan must be cleared.     *
            ***************************************************************/

            pCur = pyCur + (usBitmapWidth - 1);
			for(i=0; i<sBoldSimulHorShift;i++,pCur--)
				*pCur = 0;

            // set pCur to point to the last byte in the scan
            pCur = pyCur + (usBitmapWidth - 1);

            /***************************************************
            *    start at the right edge of the scan and work  *
            *    back toward the left edge                     *
            ***************************************************/

            while ( pCur > pyCur )
            {
			    newPix = *pCur;

			    for(i=1; i<=sBoldSimulHorShift; i++){
				    if( (pCur-i) >= pyCur )
                    {
					  newPix += *(pCur-i);
                      if (newPix >= usGrayLevels){
                          newPix = (uint8)(usGrayLevels -1);
                          break;
                      }
                    }
			    }

                *pCur = newPix;

			    pCur--;
            }
        }
	}
	//Horizontal To Left
    else if( sBoldSimulHorShift < 0 ){
        for (pyCur = pyTopNormal ; pyCur <= pyBottomNormal ; pyCur += usRowBytes)
        {
		    // Clear additional Horizontal pixels
            /***************************************************************
            *    Before emboldening,the origninal image had scans of width *
            *    usBitmapWidth - (-sBoldSimulHorShift). Any pixels beyond this limit are       *
            *    currently garbage and must be cleared. This means that    *
            *    if the width of the emboldened bitmap is even then the low*
            *    nibble of the last byte of each scan must be cleared      *
            *    otherwise the last byte of each scan must be cleared.     *
            ***************************************************************/

            pCur = pyCur;
			for(i=0; i<-sBoldSimulHorShift;i++,pCur++)
				*pCur = 0;

            /***************************************************
            *    start at the leftt edge of the scan and work  *
            *    back toward the right edge                     *
            ***************************************************/

            pCur = pyCur;
            while ( pCur < pyCur+usBitmapWidth )
            {
			    newPix = *pCur;

			    for(i=1; i<=-sBoldSimulHorShift; i++){
				    if( (pCur+i) < pyCur+usBitmapWidth )
                    {
					    newPix += *(pCur+i);
                        if (newPix >= usGrayLevels){
                            newPix = (uint8)(usGrayLevels -1);
                            break;
                        }
                    }
			    }


                *pCur = newPix;

			    pCur++;
            }
        }
	}

    // Vertical To Down
	if( sBoldSimulVertShift > 0 ){

		// Clear additional vertical lines
        pyCur = pyBottomNormal + usRowBytes;
        while(pyCur <= pyBottomBold){
            pCur = pyCur;
			for(i=0; i<usBitmapWidth;i++,pCur++)
				*pCur = 0;

            pyCur += usRowBytes;
        }
        
		//
		pyCur = pyBottomBold;
		while ( pyCur > pyTopNormal){
			pCur = pyCur;
			for(i=0; i<usBitmapWidth;i++,pCur++){
				newPix = *pCur;

				for(j=1; j<=sBoldSimulVertShift; j++){
                    pAdd = pCur - j*usRowBytes;
					if(pAdd >= pyTopNormal)
                    {
						newPix += *pAdd;
                        if (newPix >= usGrayLevels){
					        newPix = (uint8)(usGrayLevels -1);
                            break;
                        }
                    }
					else 
						break;
				}


                *pCur = newPix;
			}

			pyCur -= usRowBytes;
		}
	}

    // Vertical To Up
	else if( sBoldSimulVertShift < 0 ){

		// Clear additional Vertical lines
        pyCur = pyTopNormal - usRowBytes;
        while(pyCur >= pyTopBold){
            pCur = pyCur;
			for(i=0; i<usBitmapWidth;i++,pCur++)
				*pCur = 0;

            pyCur -= usRowBytes;
        }
        
		//
		pyCur = pyTopBold;
		while ( pyCur < pyBottomNormal){
			pCur = pyCur;
			for(i=0; i<usBitmapWidth;i++,pCur++){
				newPix = *pCur;

				for(j=1; j<=-sBoldSimulVertShift; j++){
                    pAdd = pCur + j*usRowBytes;
					if(pAdd < pyBottomNormal+usRowBytes)
                    {
						newPix += *pAdd;
                        if (newPix >= usGrayLevels){
					        newPix = (uint8)(usGrayLevels -1);
                            break;
                        }
                    }
					else 
						break;
				}


                *pCur = newPix;
			}

			pyCur += usRowBytes;
		}
	}
}

#ifdef FSCFG_SUBPIXEL

#define MAX(a,b)    ((a) > (b) ? (a) : (b))

/******************************Public*Routine******************************\
* sbit_EmboldenSubPixel adapted from vEmboldenOneBitGrayBitmap
*
* History:
*  03-Mar-2000 -by- Sung-Tae Yoo [styoo]
*      Bitmap level emboldening
*  07-Jul-1998 -by- Claude Betrisey [ClaudeBe]
*      Moved the routine from ttfd into the rasterizer
*  Wed 28-May-1997 by Tony Tsai [YungT]
*      Rename the function name, a special case for 1-bit embolden
*  Wed 22-Feb-1995 13:21:55 by Kirk Olynyk [kirko]
* Wrote it.
\**************************************************************************/

//FS_PUBLIC void sbit_EmboldenSubPixel(uint8 *pbyBitmap, uint16 usBitmapWidth, uint16 usBitmapHeight, uint16 usRowBytes, uint16 uBoldSimulHorShift)
FS_PUBLIC void sbit_EmboldenSubPixel(uint8 *pbyBitmap, uint16 usBitmapWidth, uint16 usBitmapHeight, uint16 usRowBytes, int16 sBoldSimulHorShift, int16 sBoldSimulVertShift)
{
    uint8 *pCur, *pyCur, *pAdd;	
    int32  i, j;
	uint8 newPix;
    uint8 *pyTopNormal, *pyBottomNormal, *pyTopBold, *pyBottomBold;	

	if ((usBitmapHeight == 0) || (pbyBitmap == NULL))
	{
		return;                              /* quick out for null glyph */
	}

    if( sBoldSimulVertShift >= 0 ){
        pyTopNormal = pbyBitmap;
        pyBottomNormal = pbyBitmap + (usBitmapHeight-sBoldSimulVertShift-1)*usRowBytes;
        pyTopBold = pbyBitmap;
        pyBottomBold = pbyBitmap + (usBitmapHeight-1)*usRowBytes;
    }
    else{
        pyTopNormal = pbyBitmap+(-sBoldSimulVertShift)*usRowBytes;
        pyBottomNormal = pbyBitmap + (usBitmapHeight-1)*usRowBytes;
        pyTopBold = pbyBitmap;
        pyBottomBold = pyBottomNormal;
    }


	//Horizontal To Right
    if( sBoldSimulHorShift > 0 ){
        for (pyCur = pyTopNormal ; pyCur <= pyBottomNormal ; pyCur += usRowBytes)
        {
		    // Clear additional Horizontal pixels in the right side
            /***************************************************************
            *    Before emboldening,the origninal image had scans of width *
            *    usBitmapWidth - sBoldSimulHorShift. Any pixels beyond this limit are       *
            *    currently garbage and must be cleared. This means that    *
            *    if the width of the emboldened bitmap is even then the low*
            *    nibble of the last byte of each scan must be cleared      *
            *    otherwise the last byte of each scan must be cleared.     *
            ***************************************************************/

            pCur = pyCur + (usBitmapWidth - 1);
			for(i=0; i<sBoldSimulHorShift;i++,pCur--)
				*pCur = 0;

            // set pCur to point to the last byte in the scan
            pCur = pyCur + (usBitmapWidth - 1);

            /***************************************************
            *    start at the right edge of the scan and work  *
            *    back toward the left edge                     *
            ***************************************************/

            while ( pCur > pyCur )
            {
			    newPix = *pCur;

			    for(i=1; i<=sBoldSimulHorShift; i++){
				    if( (pCur-i) >= pyCur && *(pCur-i) )
                    {
                        if(newPix){
                            newPix = (uint8)MAX_RGB_INDEX;
						    break;
                        }
					    else
						    newPix = *(pCur-i);
					}
			    }

                *pCur = newPix;

			    pCur--;
            }
        }
	}
	//Horizontal To Left
    else if( sBoldSimulHorShift < 0 ){
        for (pyCur = pyTopNormal ; pyCur <= pyBottomNormal ; pyCur += usRowBytes)
        {
		    // Clear additional Horizontal pixels in the left side
            /***************************************************************
            *    Before emboldening,the origninal image had scans of width *
            *    usBitmapWidth - (-sBoldSimulHorShift). Any pixels beyond this limit are       *
            *    currently garbage and must be cleared. This means that    *
            *    if the width of the emboldened bitmap is even then the low*
            *    nibble of the last byte of each scan must be cleared      *
            *    otherwise the last byte of each scan must be cleared.     *
            ***************************************************************/

            pCur = pyCur;
			for(i=0; i<-sBoldSimulHorShift;i++,pCur++)
				*pCur = 0;

            /***************************************************
            *    start at the left edge of the scan and work  *
            *    back toward the right edge                     *
            ***************************************************/

            pCur = pyCur;
            while ( pCur < pyCur+usBitmapWidth )
            {
			    newPix = *pCur;

			    for(i=1; i<=-sBoldSimulHorShift; i++){
                    if( (pCur+i) < pyCur+usBitmapWidth && *(pCur+i) ){
                        if(newPix){
                            newPix = (uint8)MAX_RGB_INDEX;
						    break;
                        }
					    else
						    newPix = *(pCur+i);
                    }
			    }

                *pCur = newPix;

			    pCur++;
            }
        }
	}

    // Vertical To Down
	if( sBoldSimulVertShift > 0 ){

		// Clear additional vertical lines
        pyCur = pyBottomNormal + usRowBytes;
        while(pyCur <= pyBottomBold){
            pCur = pyCur;
			for(i=0; i<usBitmapWidth;i++,pCur++)
				*pCur = 0;

            pyCur += usRowBytes;
        }
        
		//
		pyCur = pyBottomBold;
		while ( pyCur > pyTopNormal){
			pCur = pyCur;
			for(i=0; i<usBitmapWidth;i++,pCur++){
				newPix = *pCur;

				for(j=1; j<=sBoldSimulVertShift; j++){
                    pAdd = pCur - j*usRowBytes;
                    if(pAdd >= pyTopNormal){
                        if(*pAdd && newPix){
                            newPix = MAX(*pAdd,newPix);
                            break;
                        }
                        else if(*pAdd && !newPix){
                            newPix = *pAdd;
                        }
                    }
					else 
						break;
				}

                *pCur = newPix;
			}

			pyCur -= usRowBytes;
		}
	}
    // Vertical To Up
	else if( sBoldSimulVertShift < 0 ){

		// Clear additional Vertical lines
        pyCur = pyTopNormal - usRowBytes;
        while(pyCur >= pyTopBold){
            pCur = pyCur;
			for(i=0; i<usBitmapWidth;i++,pCur++)
				*pCur = 0;

            pyCur -= usRowBytes;
        }
        
		//
		pyCur = pyTopBold;
		while ( pyCur < pyBottomNormal){
			pCur = pyCur;
			for(i=0; i<usBitmapWidth;i++,pCur++){
				newPix = *pCur;

				for(j=1; j<=-sBoldSimulVertShift; j++){
                    pAdd = pCur + j*usRowBytes;
                    if(pAdd < pyBottomNormal+usRowBytes){
                        if(*pAdd && newPix){
                            newPix = MAX(*pAdd,newPix);
                            break;
                        }
                        else if(*pAdd && !newPix){
                            newPix = *pAdd;
                        }
                    }
                    else 
						break;
				}

                *pCur = newPix;
			}

			pyCur += usRowBytes;
		}
	}

    // Second Pass to modify non edge pixel to MaxIndex
    if( MABS(sBoldSimulVertShift) > 1 ){ // If adding 2 or more pix vertically
        pyCur = pyTopBold+usRowBytes;
        while(pyCur < pyBottomBold){
            uint8 *pEndOfLine = pyCur+usBitmapWidth-1;

            pCur = pyCur+1;
            while(pCur < pEndOfLine){
                if( *pCur > (uint8)0 && *pCur < (uint8)MAX_RGB_INDEX){  // If it's color pix
                    if( *(pCur-1) && *(pCur+1) && *(pCur-usRowBytes) && *(pCur+usRowBytes)){  // If it's not edge pix
                        *pCur = (uint8)MAX_RGB_INDEX;
                    }
                }
                pCur++;
            }
            pyCur += usRowBytes;
        }
    }
}
#endif // FSCFG_SUBPIXEL

/**********************************************************************/
/*  if scaling or rotating, read bitmap into workspace,               */
/*  fix it up and copy it to the output map                           */

FS_PUBLIC ErrorCode sbit_GetBitmap (
    sbit_State      *pSbit,
    sfac_ClientRec  *pClientInfo,
    uint8           *pbyOut,
    uint8           *pbyWork )
{
    ErrorCode   ReturnCode;
    uint8       *pbyRead;
    uint8       *pbyExpand;
    CopyBlock   cb;                                 /* for bitmap rotations */
    uint16      usSrcXMax;
    uint16      usSrcYMax;

    MEMSET(pbyOut, 0, pSbit->ulOutMemSize);         /* always clear the output map */

    if ((pSbit->usRotation == 0) &&                 /* if no rotation */
        (pSbit->usTableState != SBIT_BSCA_FOUND))   /* and no scaling */
    {
		if (pSbit->usBitDepth != 1)
		{
			MEMSET(pbyWork, 0, pSbit->ulWorkMemSize);
			pbyRead = pbyWork;                       /* read in the work memory */
			pbyExpand = pbyOut;						 /* expand in the output */
		} else {
			pbyRead = pbyOut;                           /* read straight to output map */
			pbyExpand = NULL;							/* expansion memory not used in that case */
		}
    } else                                            /* if any rotation or scaling */
    {
        MEMSET(pbyWork, 0, pSbit->ulWorkMemSize);
		if (pSbit->usBitDepth != 1)
		{
			pbyRead = pbyWork;                       /* read in the work memory */
			pbyExpand = pbyWork + pSbit->ulReadMemSize;	/* expand in the work memory */
		} else {
			pbyRead = pbyWork;                          /* read into workspace */
			pbyExpand = pbyWork;						/* scaling done in pbyExpand */
		}
    }

    ReturnCode = GetSbitComponent (                 /* fetch the bitmap */
        pClientInfo,
        pSbit->ulStrikeOffset,
        pSbit->usBitmapFormat,                      /* root data only in state */
        pSbit->ulBitmapOffset,
        pSbit->ulBitmapLength,
        pSbit->usHeight,
        pSbit->usWidth,
        pSbit->usShaveLeft,
        pSbit->usShaveRight,
        pSbit->usShaveTop,
        pSbit->usShaveBottom,
        0,                                          /* no offset for the root */
        0,
        pSbit->usOriginalRowBytes,
        pSbit->usExpandedRowBytes,
		pSbit->usBitDepth,
        pbyRead,
		pbyExpand);
            
    if (ReturnCode != NO_ERR) return ReturnCode;

    
    if (pSbit->usTableState == SBIT_BSCA_FOUND)
    {
        ScaleVertical (
            pbyExpand, 
            pSbit->usExpandedRowBytes, 
            pSbit->usHeight, 
            pSbit->usScaledHeight );

        ScaleHorizontal (
            pbyExpand, 
            pSbit->usExpandedRowBytes,
            pSbit->usScaledRowBytes,
            pSbit->usBitDepth, 
            pSbit->usWidth, 
            pSbit->usScaledWidth,
            pSbit->usScaledHeight );
            
        if (pSbit->usRotation == 0)                         /* if no rotation */
        {
            MEMCPY (pbyOut, pbyExpand, pSbit->ulOutMemSize);  /* keep this one */
        }
		/* in the SBIT_BSCA_FOUND the bitmap was already scaled to the final usScaledWidth, no need for additional emboldment */
	} else {
		if ((pSbit->uBoldSimulHorShift != 0) || (pSbit->uBoldSimulVertShift != 0))
		{
			if (pSbit->usRotation == 0)                             /* if no rotation */
			{
				cb.pbySrc = pbyOut;
			} else 
			{
				cb.pbySrc = pbyExpand;
			}
    
			if (pSbit->usBitDepth == 1)
			{
				sbit_Embolden(cb.pbySrc, pSbit->usScaledWidth, pSbit->usScaledHeight, pSbit->usScaledRowBytes, pSbit->uBoldSimulHorShift, pSbit->uBoldSimulVertShift);
			} else {
				uint16 usGrayLevels = (0x01 << pSbit->usBitDepth) ; /* Max gray level index */
				sbit_EmboldenGray(cb.pbySrc, pSbit->usScaledWidth, pSbit->usScaledHeight, pSbit->usScaledRowBytes, usGrayLevels, pSbit->uBoldSimulHorShift, pSbit->uBoldSimulVertShift);
			}

		}
    }

    if (pSbit->usRotation == 0)                             /* if no rotation */
    {
        return NO_ERR;                                      /* done */
    }
    
    cb.pbySrc = pbyExpand;
    cb.pbyDst = pbyOut;
    cb.usSrcBytesPerRow = pSbit->usScaledRowBytes;
    cb.usDstBytesPerRow = pSbit->usOutRowBytes;

	cb.usBitDepth = 1;
	if (pSbit->usBitDepth != 1)
		cb.usBitDepth = 8;

    usSrcXMax = pSbit->usScaledWidth;
    usSrcYMax = pSbit->usScaledHeight;

   	switch(pSbit->usRotation)
	{
	case 1:                                     /* 90 degree rotation */
        for (cb.usSrcY = 0; cb.usSrcY < usSrcYMax; cb.usSrcY++)
        {
            cb.usDstX = cb.usSrcY;                          /* x' = y */
            for (cb.usSrcX = 0; cb.usSrcX < usSrcXMax; cb.usSrcX++)
            {
                cb.usDstY = usSrcXMax - cb.usSrcX - 1;      /* y' = -x */
                CopyBit(&cb);
            }
        }
		break;
	case 2:                                     /* 180 degree rotation */
        for (cb.usSrcY = 0; cb.usSrcY < usSrcYMax; cb.usSrcY++)
        {
            cb.usDstY = usSrcYMax - cb.usSrcY - 1;          /* y' = -y */
            for (cb.usSrcX = 0; cb.usSrcX < usSrcXMax; cb.usSrcX++)
            {
                cb.usDstX = usSrcXMax - cb.usSrcX - 1;      /* x' = -x */
                CopyBit(&cb);
            }
        }
		break;
	case 3:                                     /* 270 degree rotation */
        for (cb.usSrcY = 0; cb.usSrcY < usSrcYMax; cb.usSrcY++)
        {
            cb.usDstX = usSrcYMax - cb.usSrcY - 1;          /* x' = -y */
            for (cb.usSrcX = 0; cb.usSrcX < usSrcXMax; cb.usSrcX++)
            {
                cb.usDstY = cb.usSrcX;                      /* y' = x */
                CopyBit(&cb);
            }
        }
		break;
	default:                                    /* shouldn't happen */
		return SBIT_ROTATION_ERR;
	}

    return NO_ERR;
}


/**********************************************************************/

/*      Private Functions                                             */

/**********************************************************************/

FS_PRIVATE ErrorCode GetSbitMetrics(
    sbit_State      *pSbit,
    sfac_ClientRec  *pClientInfo
)
{
    ErrorCode   ReturnCode;
	boolean		bHorMetricsFound;
	boolean		bVertMetricsFound;

    if (pSbit->bMetricsValid)
    {
        return NO_ERR;                      /* already got 'em */
    }

    ReturnCode = sfac_GetSbitMetrics (
        pClientInfo,
        pSbit->usMetricsType,
        pSbit->usMetricsTable,
        pSbit->ulMetricsOffset,
        &pSbit->usHeight,
        &pSbit->usWidth,
        &pSbit->sLSBearingX,
        &pSbit->sLSBearingY,
        &pSbit->sTopSBearingX,
        &pSbit->sTopSBearingY,
        &pSbit->usAdvanceWidth,
        &pSbit->usAdvanceHeight,
        &bHorMetricsFound,
        &bVertMetricsFound);
	
    if (ReturnCode != NO_ERR) return ReturnCode;

	if (!bHorMetricsFound)
	{
		ReturnCode = SubstituteHorMetrics (pSbit, pClientInfo);
		if (ReturnCode != NO_ERR) return ReturnCode;
	}

	if (!bVertMetricsFound)
	{
		ReturnCode = SubstituteVertMetrics (pSbit, pClientInfo);
		if (ReturnCode != NO_ERR) return ReturnCode;
	}

    ReturnCode = sfac_ShaveSbitMetrics (
	    pClientInfo,
        pSbit->usBitmapFormat,
	    pSbit->ulBitmapOffset,
        pSbit->ulBitmapLength,
		pSbit->usBitDepth,
    	&pSbit->usHeight,
    	&pSbit->usWidth,
        &pSbit->usShaveLeft,
        &pSbit->usShaveRight,
        &pSbit->usShaveTop,
        &pSbit->usShaveBottom,
    	&pSbit->sLSBearingX,
    	&pSbit->sLSBearingY,
    	&pSbit->sTopSBearingX,
    	&pSbit->sTopSBearingY);

    if (ReturnCode != NO_ERR) return ReturnCode;
        
    pSbit->bMetricsValid = TRUE;
    return NO_ERR;
}

/**********************************************************************/

FS_PRIVATE ErrorCode SubstituteVertMetrics(
    sbit_State      *pSbit,
    sfac_ClientRec  *pClientInfo 
)
{
    ErrorCode   ReturnCode;
	uint16	usNonScaledAH;
	int16	sNonScaledTSB;

	ReturnCode = sfac_ReadGlyphVertMetrics (
		pClientInfo,
		pClientInfo->usGlyphIndex,
		&usNonScaledAH,
		&sNonScaledTSB);
	if (ReturnCode != NO_ERR) return ReturnCode;

	pSbit->usAdvanceHeight = UEmScaleY(pSbit, usNonScaledAH);

	pSbit->sTopSBearingX = pSbit->sLSBearingX;
	pSbit->sTopSBearingY = - SEmScaleY(pSbit, sNonScaledTSB);

    return NO_ERR;
}

/**********************************************************************/

FS_PRIVATE ErrorCode SubstituteHorMetrics(
    sbit_State      *pSbit,
    sfac_ClientRec  *pClientInfo 
)
{
    ErrorCode   ReturnCode;
	uint16	usNonScaledAW;
	int16	sNonScaledLSB;

	ReturnCode = sfac_ReadGlyphHorMetrics (
		pClientInfo,
		pClientInfo->usGlyphIndex,
		&usNonScaledAW,
		&sNonScaledLSB);
	if (ReturnCode != NO_ERR) return ReturnCode;

	pSbit->usAdvanceWidth = UEmScaleX(pSbit, usNonScaledAW);

	pSbit->sLSBearingX = pSbit->sTopSBearingX;
	pSbit->sLSBearingY = SEmScaleY(pSbit, sNonScaledLSB);
	
    return NO_ERR;
}

FS_PRIVATE void ExpandSbitToBytePerPixel (
    uint16          usHeight,
    uint16          usWidth,
    uint16          usOriginalRowBytes,
    uint16          usExpandedRowBytes,
	uint16			usBitDepth,
    uint8           *pbySrcBitMap,
    uint8           *pbyDstBitMap )
{
	uint16          usCount;
	uint16			usBitIndex, usOriginalBitIndex;
	uint8			*pbyDstBitRow;
	uint8			*pbySrcBitRow;
	uint16			usMask, usShift, usMaxLevel;

	usMaxLevel = (0x01 << usBitDepth) -1; /* Max gray level index */

	if (usBitDepth == 2)
	{
		usMask = 0x03;
		usShift = 0x02;
		usOriginalBitIndex = ((usWidth -1) & 0x03) << 0x01;
	} else if (usBitDepth == 4)
	{
		usMask = 0x0F;
		usShift = 0x01;
		usOriginalBitIndex = ((usWidth -1) & 0x01) << 0x02;
	} else if (usBitDepth == 8)
	{
		usMask = 0xFF;
		usShift = 0x00;
		usOriginalBitIndex = 0; /* ((usWidth -1) & 0x00) << 0x03 */
	} else
	{
		return;
	}

	/* start from the end to be able to use overlapping memories */
	pbyDstBitRow = pbyDstBitMap + (long) (usHeight-1) * (long) usExpandedRowBytes;
	pbySrcBitRow = pbySrcBitMap + (long) (usHeight-1) * (long) usOriginalRowBytes;
	
	while (usHeight > 0)
	{
		pbyDstBitMap = pbyDstBitRow + (long)(usWidth -1);
		pbySrcBitMap = pbySrcBitRow + (long)((usWidth -1) >> usShift);
		usBitIndex = usOriginalBitIndex;

		*pbySrcBitMap = *pbySrcBitMap >> (MAX_BIT_INDEX - usBitDepth - usBitIndex);

		for (usCount = usWidth; usCount > 0; usCount--)
		{
			if (*pbyDstBitMap == 0)
			{
				/* 99.9% of the case */
				*pbyDstBitMap = *pbySrcBitMap & usMask;
			} else {
				*pbyDstBitMap = usMaxLevel - 
						(usMaxLevel - *pbyDstBitMap) * (usMaxLevel - *pbySrcBitMap & usMask) / usMaxLevel;
			}
			*pbySrcBitMap = *pbySrcBitMap >> usBitDepth;

			pbyDstBitMap--;
			if (usBitIndex == 0)
			{
				usBitIndex = MAX_BIT_INDEX;
				pbySrcBitMap--;
			}
			usBitIndex = usBitIndex - usBitDepth;

		}
		pbyDstBitRow -= usExpandedRowBytes;
		pbySrcBitRow -= usOriginalRowBytes;
		usHeight--;
	}
}
/**********************************************************************/

/*  This is the recursive composite routine */

FS_PRIVATE ErrorCode GetSbitComponent (
    sfac_ClientRec  *pClientInfo,
    uint32          ulStrikeOffset,
    uint16          usBitmapFormat,
    uint32          ulBitmapOffset,
    uint32          ulBitmapLength,
    uint16          usHeight,
    uint16          usWidth,
    uint16          usShaveLeft,
    uint16          usShaveRight,
    uint16          usShaveTop,
    uint16          usShaveBottom,
    uint16          usXOffset,
    uint16          usYOffset,
    uint16          usOriginalRowBytes,
    uint16          usExpandedRowBytes,
	uint16			usBitDepth,
    uint8           *pbyRead,
    uint8           *pbyExpand )
{
    uint32          ulCompMetricsOffset;            /* component params */
    uint32          ulCompBitmapOffset;
    uint32          ulCompBitmapLength;
    uint16          usComponent;                    /* index counter */
    uint16          usCompCount;
    uint16          usCompGlyphCode;
    uint16          usCompXOff;
    uint16          usCompYOff;
    uint16          usCompMetricsType;
    uint16          usCompMetricsTable;
    uint16          usCompBitmapFormat;
    uint16          usCompHeight;
    uint16          usCompWidth;
    uint16          usCompShaveLeft;
    uint16          usCompShaveRight;
    uint16          usCompShaveTop;
    uint16          usCompShaveBottom;
    uint16          usCompAdvanceWidth;
    uint16          usCompAdvanceHeight;
    int16           sCompLSBearingX;
    int16           sCompLSBearingY;
    int16           sCompTopSBearingX;
    int16           sCompTopSBearingY;
    boolean         bCompGlyphFound;
   	boolean         bCompHorMetricsFound;
   	boolean         bCompVertMetricsFound;
    ErrorCode       ReturnCode;

		ReturnCode = sfac_GetSbitBitmap (               /* fetch the bitmap */
        pClientInfo,
        usBitmapFormat,
        ulBitmapOffset,
        ulBitmapLength,
        usHeight,
        usWidth,
        usShaveLeft,
        usShaveRight,
        usShaveTop,
        usShaveBottom,
        usXOffset,
        usYOffset,
        usOriginalRowBytes,
		usBitDepth,
        pbyRead,
        &usCompCount );                             /* zero for simple glyph */
            
    if (ReturnCode != NO_ERR) return ReturnCode;
    
	/* we expand after handling composite glyphs and before scaling and applying rotation */	
	if (usBitDepth != 1 && usCompCount == 0)
		ExpandSbitToBytePerPixel (
			usHeight,
			usWidth,
			usOriginalRowBytes,
			usExpandedRowBytes,
			usBitDepth,
			pbyRead,
			pbyExpand );

    if (usCompCount > 0)                            /* if composite glyph */
    {
        for (usComponent = 0; usComponent < usCompCount; usComponent++)
        {
			if (usBitDepth != 1)
			{
				/* for grayscale, the composition is done during expansion, I need to
				   clean the memory used to read between each component */
				MEMSET(pbyRead, 0, usOriginalRowBytes*usHeight);
			}
            ReturnCode = sfac_GetSbitComponentInfo (
                pClientInfo,
                usComponent,                        /* component index */
                ulBitmapOffset,
                ulBitmapLength,
                &usCompGlyphCode,                   /* return values */
                &usCompXOff,
                &usCompYOff );
            
            if (ReturnCode != NO_ERR) return ReturnCode;

            ReturnCode = sfac_SearchForBitmap (     /* look for component glyph */
                pClientInfo,
                usCompGlyphCode,
                ulStrikeOffset,                     /* same strike for all */
                &bCompGlyphFound,                   /* return values */
                &usCompMetricsType,
                &usCompMetricsTable,
                &ulCompMetricsOffset,
                &usCompBitmapFormat,
                &ulCompBitmapOffset,
                &ulCompBitmapLength );
            
            if (ReturnCode != NO_ERR) return ReturnCode;
            
            if (bCompGlyphFound == FALSE)           /* should be there! */
            {
                return SBIT_COMPONENT_MISSING_ERR;
            }

            ReturnCode = sfac_GetSbitMetrics (      /* get component's metrics */
                pClientInfo,
                usCompMetricsType,
                usCompMetricsTable,
                ulCompMetricsOffset,
                &usCompHeight,                      /* these matter */
                &usCompWidth,
                &sCompLSBearingX,                     /* these don't */
                &sCompLSBearingY,
                &sCompTopSBearingX,                     
                &sCompTopSBearingY,
                &usCompAdvanceWidth,
                &usCompAdvanceHeight,
   				&bCompHorMetricsFound,
   				&bCompVertMetricsFound	);
            
            if (ReturnCode != NO_ERR) return ReturnCode;

            ReturnCode = sfac_ShaveSbitMetrics (    /* shave white space for const metrics */
        	    pClientInfo,
                usCompBitmapFormat,
                ulCompBitmapOffset,
                ulCompBitmapLength,
				usBitDepth,
            	&usCompHeight,
            	&usCompWidth,
                &usCompShaveLeft,
                &usCompShaveRight,
                &usCompShaveTop,
                &usCompShaveBottom,
            	&sCompLSBearingX,
            	&sCompLSBearingY,
            	&sCompTopSBearingX,
             	&sCompTopSBearingY );

            if (ReturnCode != NO_ERR) return ReturnCode;

            ReturnCode = GetSbitComponent (         /* recurse here */
                pClientInfo,
                ulStrikeOffset,
                usCompBitmapFormat,
                ulCompBitmapOffset,
                ulCompBitmapLength,
                usCompHeight,
                usCompWidth,
                usCompShaveLeft,
                usCompShaveRight,
                usCompShaveTop,
                usCompShaveBottom,
                (uint16)(usCompXOff + usXOffset + usCompShaveLeft),   /* for nesting */
                (uint16)(usCompYOff + usYOffset + usCompShaveTop),
                usOriginalRowBytes,                         /* same for all */
                usExpandedRowBytes,                         /* same for all */
				usBitDepth,
                pbyRead,
				pbyExpand);
            
            if (ReturnCode != NO_ERR) return ReturnCode;
        }
    }
    return NO_ERR;
}

/********************************************************************/

/*                  Bitmap Scaling Routines                         */

/********************************************************************/

FS_PRIVATE uint16 UScaleX(
    sbit_State  *pSbit,
    uint16      usValue
)
{
    uint32      ulValue;

    if (pSbit->usTableState == SBIT_BSCA_FOUND)     /* if scaling needed */
    {
        ulValue = (uint32)usValue;
        ulValue *= (uint32)pSbit->usPpemX << 1; 
        ulValue += (uint32)pSbit->usSubPpemX;       /* for rounding */
        ulValue /= (uint32)pSbit->usSubPpemX << 1;
        usValue = (uint16)ulValue;
    }
	if (pSbit->uBoldSimulHorShift != 0)
	{
        if (usValue != 0) /* we don't increase the width of a zero width glyph, problem with indic script */
		    usValue += 1; /* we increase the width by one pixel regardless of size for backwards compatibility */
	}
    return usValue;
}

/********************************************************************/

FS_PRIVATE uint16 UScaleY(
    sbit_State  *pSbit,
    uint16      usValue
)
{
    uint32      ulValue;

    if (pSbit->usTableState == SBIT_BSCA_FOUND)     /* if scaling needed */
    {
        ulValue = (uint32)usValue;
        ulValue *= (uint32)pSbit->usPpemY << 1; 
        ulValue += (uint32)pSbit->usSubPpemY;       /* for rounding */
        ulValue /= (uint32)pSbit->usSubPpemY << 1;
        usValue = (uint16)ulValue;
    }
    return usValue;
}

/********************************************************************/

FS_PRIVATE int16 SScaleX(
    sbit_State  *pSbit,
    int16       sValue
)
{
    if (pSbit->usTableState == SBIT_BSCA_FOUND)
    {
        if (sValue >= 0)                    /* positive Value */
        {
            return (int16)UScaleX(pSbit, (uint16)sValue);
        }
        else                                /* negative Value */
        {
            return -(int16)(UScaleX(pSbit, (uint16)(-sValue)));
        }
    }
    else                                    /* no scaling needed */
    {
        return sValue;
    }
}

/********************************************************************/

FS_PRIVATE int16 SScaleY(
    sbit_State  *pSbit,
    int16       sValue
)
{
    if (pSbit->usTableState == SBIT_BSCA_FOUND)
    {
        if (sValue >= 0)                    /* positive Value */
        {
            return (int16)UScaleY(pSbit, (uint16)sValue);
        }
        else                                /* negative Value */
        {
            return -(int16)(UScaleY(pSbit, (uint16)(-sValue)));
        }
    }
    else                                    /* no scaling needed */
    {
        return sValue;
    }
}


FS_PRIVATE uint16 UEmScaleX(
    sbit_State  *pSbit,
    uint16      usValue
)
{
    uint32      ulValue;
	uint16		usPpemX;

    if (pSbit->usTableState == SBIT_BSCA_FOUND)     /* if scaling needed */
    {
		usPpemX = pSbit->usSubPpemX;
    } else {
		usPpemX = pSbit->usPpemX;
	}
    ulValue = (uint32)usValue;
    ulValue *= (uint32)usPpemX << 1; 
    ulValue += (uint32)pSbit->usEmResolution;       /* for rounding */
    ulValue /= (uint32)pSbit->usEmResolution << 1;
    usValue = (uint16)ulValue;
	if (pSbit->uBoldSimulHorShift != 0)
	{
        if (usValue != 0) /* we don't increase the width of a zero width glyph, problem with indic script */
		    usValue += 1; /* we increase the width by one pixel regardless of size for backwards compatibility */
	}
    return usValue;
}

/********************************************************************/

FS_PRIVATE uint16 UEmScaleY(
    sbit_State  *pSbit,
    uint16      usValue
)
{
    uint32      ulValue;
	uint16		usPpemY;

    if (pSbit->usTableState == SBIT_BSCA_FOUND)     /* if scaling needed */
    {
		usPpemY = pSbit->usSubPpemY;
    } else {
		usPpemY = pSbit->usPpemY;
	}
    ulValue = (uint32)usValue;
    ulValue *= (uint32)usPpemY << 1; 
    ulValue += (uint32)pSbit->usEmResolution;       /* for rounding */
    ulValue /= (uint32)pSbit->usEmResolution << 1;
    usValue = (uint16)ulValue;
    return usValue;
}

/********************************************************************/

FS_PRIVATE int16 SEmScaleX(
    sbit_State  *pSbit,
    int16       sValue
)
{
     if (sValue >= 0)                    /* positive Value */
     {
         return (int16)UEmScaleX(pSbit, (uint16)sValue);
     }
     else                                /* negative Value */
     {
         return -(int16)(UEmScaleX(pSbit, (uint16)(-sValue)));
     }
}

/********************************************************************/

FS_PRIVATE int16 SEmScaleY(
    sbit_State  *pSbit,
    int16       sValue
)
{
     if (sValue >= 0)                    /* positive Value */
     {
         return (int16)UEmScaleY(pSbit, (uint16)sValue);
     }
     else                                /* negative Value */
     {
         return -(int16)(UEmScaleY(pSbit, (uint16)(-sValue)));
     }
}

/********************************************************************/

FS_PRIVATE void ScaleVertical (
    uint8 *pbyBitmap,
    uint16 usBytesPerRow,
    uint16 usOrgHeight,
    uint16 usNewHeight
)
{
    uint8 *pbyOrgRow;                   /* original data pointer */
    uint8 *pbyNewRow;                   /* new data pointer */
    uint16 usErrorTerm;                 /* for 'Bresenham' calculation */
    uint16 usLine;                      /* loop counter */

    usErrorTerm = usOrgHeight >> 1;                 /* used by both comp and exp */

    if (usOrgHeight > usNewHeight)                  /* Compress Vertical */
    {
        pbyOrgRow = pbyBitmap;
        pbyNewRow = pbyBitmap;

        for (usLine = 0; usLine < usNewHeight; usLine++)
        {
            while (usErrorTerm >= usNewHeight)
            {
                pbyOrgRow += usBytesPerRow;         /* skip a row */
                usErrorTerm -= usNewHeight;
            }
            if (pbyOrgRow != pbyNewRow)
            {
                MEMCPY(pbyNewRow, pbyOrgRow, usBytesPerRow);
            }
            pbyNewRow += usBytesPerRow;
            usErrorTerm += usOrgHeight;
        }
        for (usLine = usNewHeight; usLine < usOrgHeight; usLine++)
        {
            MEMSET(pbyNewRow, 0, usBytesPerRow);    /* erase the leftover */
            pbyNewRow += usBytesPerRow;
        }
    }
    else if (usNewHeight > usOrgHeight)             /* Expand Vertical */
    {
        pbyOrgRow = pbyBitmap + (usOrgHeight - 1) * usBytesPerRow;
        pbyNewRow = pbyBitmap + (usNewHeight - 1) * usBytesPerRow;

        for (usLine = 0; usLine < usOrgHeight; usLine++)
        {
            usErrorTerm += usNewHeight;
            
            while (usErrorTerm >= usOrgHeight)      /* executes at least once */
            {
                if (pbyOrgRow != pbyNewRow)
                {
                    MEMCPY(pbyNewRow, pbyOrgRow, usBytesPerRow);
                }
                pbyNewRow -= usBytesPerRow;
                usErrorTerm -= usOrgHeight;
            }
            pbyOrgRow -= usBytesPerRow;
        }
    }
}

/********************************************************************/

FS_PRIVATE void ScaleHorizontal (
    uint8 *pbyBitmap,
    uint16 usOrgBytesPerRow,
    uint16 usNewBytesPerRow,
	uint16 usBitDepth,
    uint16 usOrgWidth,
    uint16 usNewWidth,
    uint16 usRowCount
)
{
    uint8 *pbyOrgRow;               /* points to original row beginning */
    uint8 *pbyNewRow;               /* points to new row beginning */
    uint8 *pbyOrg;                  /* original data pointer */
    uint8 *pbyNew;                  /* new data pointer */
    uint8 byOrgData;                /* original data read 1 byte at a time */
    uint8 byNewData;                /* new data assembled bit by bit */

    uint16 usErrorTerm;             /* for 'Bresenham' calculation */
    uint16 usByte;                  /* to byte counter */
    uint16 usOrgBytes;              /* from width rounded up in bytes */
    uint16 usNewBytes;              /* to width rounded up in bytes */
    
    int16 sOrgBits;                 /* counts valid bits of from data */
    int16 sNewBits;                 /* counts valid bits of to data */
    int16 sOrgBitsInit;             /* valid original bits at row begin */
    int16 sNewBitsInit;             /* valid new bits at row begin */

    
	if (usBitDepth == 1)
	{
		if (usOrgWidth > usNewWidth)                    /* Compress Horizontal */
		{
			pbyOrgRow = pbyBitmap;
			pbyNewRow = pbyBitmap;
			usNewBytes = (usNewWidth + 7) >> 3;

			while (usRowCount > 0)
			{
				pbyOrg = pbyOrgRow;
				pbyNew = pbyNewRow;
				usErrorTerm = usOrgWidth >> 1;
            
				sOrgBits = 0;                           /* start at left edge */
				sNewBits = 0;
				usByte = 0;
				byNewData = 0;
				while (usByte < usNewBytes)
				{
					while (usErrorTerm >= usNewWidth)
					{
						sOrgBits--;                     /* skip a bit */
						usErrorTerm -= usNewWidth;
					}
					while (sOrgBits <= 0)               /* if out of data */
					{
						byOrgData = *pbyOrg++;          /*   then get some fresh */
						sOrgBits += 8;
					}
					byNewData <<= 1;                    /* new bit to lsb */
					byNewData |= (byOrgData >> (sOrgBits - 1)) & 1;
                
					sNewBits++;
					if (sNewBits == 8)                  /* if to data byte is full */
					{
						*pbyNew++ = byNewData;          /*   then write it out */
						sNewBits = 0;
						usByte++;                       /* loop counter */
					}
					usErrorTerm += usOrgWidth;
				}
				while (usByte < usNewBytesPerRow)
				{
					*pbyNew++ = 0;                      /* blank out the rest */
					usByte++;
				}
				pbyOrgRow += usOrgBytesPerRow;
				pbyNewRow += usNewBytesPerRow;
				usRowCount--;
			}
		}
		else if (usNewWidth > usOrgWidth)               /* Expand Horizontal */
		{
			pbyOrgRow = pbyBitmap + (usRowCount - 1) * usOrgBytesPerRow;
			pbyNewRow = pbyBitmap + (usRowCount - 1) * usNewBytesPerRow;

			usOrgBytes = (usOrgWidth + 7) >> 3;
			sOrgBitsInit = (int16)((usOrgWidth + 7) & 0x07) - 7;
        
			usNewBytes = (usNewWidth + 7) >> 3;
			sNewBitsInit = 7 - (int16)((usNewWidth + 7) & 0x07);

			while (usRowCount > 0)                      /* for each row */
			{
				pbyOrg = pbyOrgRow + usOrgBytes - 1;    /* point to right edges */
				pbyNew = pbyNewRow + usNewBytes - 1;
				usErrorTerm = usOrgWidth >> 1;
            
				sOrgBits = sOrgBitsInit;                /* initially unaligned */
				sNewBits = sNewBitsInit;
				usByte = 0;
				byNewData = 0;
				while (usByte < usNewBytes)             /* for each output byte */
				{
					if (sOrgBits <= 0)                  /* if out of data */
					{
						byOrgData = *pbyOrg--;          /*   then get some fresh */
						sOrgBits += 8;
					}
					usErrorTerm += usNewWidth;
                
					while (usErrorTerm >= usOrgWidth)   /* executes at least once */
					{
						byNewData >>= 1;                /* use the msb of byte */
						byNewData |= (byOrgData << (sOrgBits - 1)) & 0x80;
                    
						sNewBits++;
						if (sNewBits == 8)              /* if to data byte is full */
						{
							*pbyNew-- = byNewData;      /*   then write it out */
							sNewBits = 0;
							usByte++;                   /* loop counter */
						}
						usErrorTerm -= usOrgWidth;
					}
					sOrgBits--;                         /* get next bit */
				}
				pbyOrgRow -= usOrgBytesPerRow;
				pbyNewRow -= usNewBytesPerRow;
				usRowCount--;
			}
        }
    } else {											/* one byte per pixel */
		if (usOrgWidth > usNewWidth)                    /* Compress Horizontal */
		{
			pbyOrgRow = pbyBitmap;
			pbyNewRow = pbyBitmap;

			while (usRowCount > 0)
			{
				pbyOrg = pbyOrgRow;
				pbyNew = pbyNewRow;
				usErrorTerm = usOrgWidth >> 1;
            
				usByte = 0;
				while (usByte < usNewWidth)
				{
					while (usErrorTerm >= usNewWidth)
					{
						pbyOrg++;                     /* skip a byte */
						usErrorTerm -= usNewWidth;
					}
					*pbyNew++ = *pbyOrg;
					usByte++;                       /* loop counter */
					usErrorTerm += usOrgWidth;
				}
				while (usByte < usNewBytesPerRow)
				{
					*pbyNew++ = 0;                      /* blank out the rest */
					usByte++;
				}
				pbyOrgRow += usOrgBytesPerRow;
				pbyNewRow += usNewBytesPerRow;
				usRowCount--;
			}
		}
		else if (usNewWidth > usOrgWidth)               /* Expand Horizontal */
		{
			pbyOrgRow = pbyBitmap + (usRowCount - 1) * usOrgBytesPerRow;
			pbyNewRow = pbyBitmap + (usRowCount - 1) * usNewBytesPerRow;

			usOrgBytes = usOrgWidth;        
			usNewBytes = usNewWidth ;

			while (usRowCount > 0)                      /* for each row */
			{
				pbyOrg = pbyOrgRow + usOrgBytes - 1;    /* point to right edges */
				pbyNew = pbyNewRow + usNewBytesPerRow - 1;
				usErrorTerm = usOrgWidth >> 1;
            
				usByte = usNewBytesPerRow;
				while (usByte > usNewBytes)
				{
					*pbyNew-- = 0;                      /* blank out the extra bytes on the right */
					usByte--;
				}
				while (usByte > 0)             /* for each output byte */
				{
					usErrorTerm += usNewWidth;
                
					while (usErrorTerm >= usOrgWidth)   /* executes at least once */
					{
						*pbyNew-- = *pbyOrg;

						usByte--;                   /* loop counter */
						usErrorTerm -= usOrgWidth;
					}
					pbyOrg--;
				}
				pbyOrgRow -= usOrgBytesPerRow;
				pbyNewRow -= usNewBytesPerRow;
				usRowCount--;
			}
        }
	}
}

/********************************************************************/

FS_PRIVATE void CopyBit(
    CopyBlock* pcb )
{
    uint16  usSrcOffset;
    uint16  usSrcShift;
    uint16  usDstOffset;
    uint16  usDstShift;
    
    static  uint16 usByteMask[8] = 
        { 0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01 };

/*  if speed becomes an issue, this next multiply could be moved up */
/*  to the calling routine, and placed outside the 'x' loop */

/*  if speed becomes an issue, the test between 1 bit and 1 byte per pixel */
/*  could be moved up to the calling routine */

	if (pcb->usBitDepth == 1)
	{
		usSrcOffset = (pcb->usSrcY * pcb->usSrcBytesPerRow) + (pcb->usSrcX >> 3);
		usSrcShift = pcb->usSrcX & 0x0007;

		if (pcb->pbySrc[usSrcOffset] & usByteMask[usSrcShift])
		{
			usDstOffset = (pcb->usDstY * pcb->usDstBytesPerRow) + (pcb->usDstX >> 3);
			usDstShift = pcb->usDstX & 0x0007;
			pcb->pbyDst[usDstOffset] |= usByteMask[usDstShift];
		}
	} else {
		usSrcOffset = (pcb->usSrcY * pcb->usSrcBytesPerRow) + pcb->usSrcX;
		usDstOffset = (pcb->usDstY * pcb->usDstBytesPerRow) + pcb->usDstX;
		pcb->pbyDst[usDstOffset] = pcb->pbySrc[usSrcOffset];
	}

}

/********************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\fs\interp.h ===
/*
	 File:		 interp.h

	 Contains:	 Exports and constants used by TrueType Interpreter

	 Written by: GregH

    Copyright:  (c) 1987-1990, 1992 by Apple Computer, Inc., all rights reserved.
                (c) 1989-1997. Microsoft Corporation, all rights reserved.

    Change History (most recent first):
*/

#include 	"fnterr.h"

#define NOGRIDFITFLAG   1
#define DEFAULTFLAG     2
#define TUNED4SPFLAG	4

FS_PUBLIC ErrorCode itrp_SetDefaults (
    void *  pvGlobalGS,
    Fixed   fxPixelDiameter);

FS_PUBLIC void  itrp_UpdateGlobalGS(
    void *              pvGlobalGS, /* GlobalGS                             */
    void *              pvCVT,      /* Pointer to control value table       */
    void *              pvStore,    /* Pointer to storage                   */
    void *              pvFuncDef,  /* Pointer to function defintions       */
    void *              pvInstrDef, /* Pointer to instruction definitions   */
    void *              pvStack,    /* Pointer to the stack                 */
	 LocalMaxProfile *	maxp,
    uint16              cvtCount,
    uint32              ulLengthFontProgram, /* Length of font program      */
    void *              pvFontProgram, /* Pointer to font program           */
    uint32              ulLengthPreProgram, /* Length of pre program        */
    void *              pvPreProgram, /* Pointer to pre program             */
	ClientIDType        clientID);    /* User ID Number                     */

#ifdef FSCFG_NO_INITIALIZED_DATA
FS_PUBLIC void itrp_InitializeData (void);
#endif

FS_PUBLIC ErrorCode   itrp_ExecuteFontPgm(
    fnt_ElementType *   pTwilightElement,
    fnt_ElementType *   pGlyphElement,
    void *              pvGlobalGS,
	 FntTraceFunc			TraceFunc);

FS_PUBLIC ErrorCode   itrp_ExecutePrePgm(
    fnt_ElementType *   pTwilightElement,
    fnt_ElementType *   pGlyphElement,
    void *              pvGlobalGS,
	 FntTraceFunc			TraceFunc);

FS_PUBLIC ErrorCode   itrp_ExecuteGlyphPgm(
    fnt_ElementType *   pTwilightElement,
    fnt_ElementType *   pGlyphElement,
    uint8 *             ptr,
    uint8 *             eptr,
    void *              pvGlobalGS,
	 FntTraceFunc			TraceFunc,
    uint16 *            pusScanType,
    uint16 *            pusScanControl,
    boolean *           pbChangeScanControl);

FS_PUBLIC boolean itrp_bApplyHints(
    void *      pvGlobalGS);

FS_PUBLIC void  itrp_QueryScanInfo(
    void *      pvGlobalGS,
    uint16 *    pusScanType,
    uint16 *    pusScanControl);

FS_PUBLIC void	itrp_SetCompositeFlag(
	void *      pvGlobalGS,
	uint8		bCompositeFlag);

FS_PUBLIC void	itrp_SetSameTransformFlag(
	void *      pvGlobalGS,
	boolean		bSameTransformAsMaster);

FS_PUBLIC void itrp_Normalize (F26Dot6 x, F26Dot6 y, VECTOR *pVec);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\fs\scale.c ===
/****************************** Module Header ******************************\
* Module Name: Scale.c
*
* Created: 16-Oct-1992
*
* Copyright:  (c) 1987-1990, 1992 by Apple Computer, Inc., all rights reserved.
*             (c) 1989-1999. Microsoft Corporation.
*
* All Rights Reserved
*
* History:
*  Tue 16-Oct-1992 09:53:51 -by-  Greg Hitchcock [gregh]
* Created.
*   
*	 7/10/99	BeatS	   Add support for native SP fonts, vertical RGB
*	 4/01/99	BeatS	   Implement alternative interpretation of TT instructions for SP
*	02/21/97    claudebe   scaled component in composite glyphs
*	12/14/95    claudebe   adding two private phantom points for vertical positionning
* .
\***************************************************************************/

#define FSCFG_INTERNAL

/* INCLUDES */

#include "fserror.h"
#include "fscdefs.h"
#include "fontmath.h"
#include "fnt.h"
#include "scale.h"

#include "stat.h"

/* Constants    */

/* use the lower ones for public phantom points */

// public phantom points moved to fnt.h more global use

/* private phantom points start here */

#define ORIGINPOINT 4
#define LEFTEDGEPOINT 5

#define TOPORIGINPOINT 6
#define TOPEDGEPOINT 7

#define CANTAKESHIFT    0x02000000

/* MACROS   */

/* d is half of the denumerator */
#define FROUND( x, n, d, s ) \
		((SHORTMUL (x, n) + (d)) >> s)

#define SROUND( x, n, d, halfd ) \
	(x < 0 ? -((SHORTMUL (-(x), (n)) + (halfd)) / (d)) : ((SHORTMUL ((x), (n)) + (halfd)) / (d)))

#define NUMBEROFCHARPOINTS(pElement)  (uint16)(pElement->ep[pElement->nc - 1] + 1)
#define NUMBEROFTOTALPOINTS(pElement)  (uint16)(pElement->ep[pElement->nc - 1] + 1 + PHANTOMCOUNT)

#define LSBPOINTNUM(pElement) (uint16)(pElement->ep[pElement->nc - 1] + 1 + LEFTSIDEBEARING)
#define RSBPOINTNUM(pElement) (uint16)(pElement->ep[pElement->nc - 1] + 1 + RIGHTSIDEBEARING)

#define TOPSBPOINTNUM(pElement) (uint16)(pElement->ep[pElement->nc - 1] + 1 + TOPSIDEBEARING)
#define BOTTOMSBPOINTNUM(pElement) (uint16)(pElement->ep[pElement->nc - 1] + 1 + BOTTOMSIDEBEARING)

#define ORIGINPOINTNUM(pElement) (uint16)(pElement->ep[pElement->nc - 1] + 1 + ORIGINPOINT)
#define LEFTEDGEPOINTNUM(pElement) (uint16)(pElement->ep[pElement->nc - 1] + 1 + LEFTEDGEPOINT)

#define TOPORIGINPOINTNUM(pElement) (uint16)(pElement->ep[pElement->nc - 1] + 1 + TOPORIGINPOINT)
#define TOPEDGEPOINTNUM(pElement) (uint16)(pElement->ep[pElement->nc - 1] + 1 + TOPEDGEPOINT)

/* PROTOTYPES   */

FS_PRIVATE GlobalGSScaleFunc scl_ComputeScaling(fnt_ScaleRecord* rec, Fixed N, Fixed D);
FS_PRIVATE F26Dot6 scl_FRound (fnt_ScaleRecord* rec, F26Dot6 value);
FS_PRIVATE F26Dot6 scl_SRound (fnt_ScaleRecord* rec, F26Dot6 value);
FS_PRIVATE F26Dot6 scl_FixRound (fnt_ScaleRecord* rec, F26Dot6 value);

FS_PRIVATE void scl_ShiftOldPoints (
	fnt_ElementType *   pElement,
	F26Dot6             fxXShift,
	F26Dot6             fxYShift,
	uint16              usFirstPoint,
	uint16              usNumPoints);

FS_PRIVATE void  scl_Scale (
	fnt_ScaleRecord *   sr,
	GlobalGSScaleFunc   ScaleFunc,
	F26Dot6 *           oop,
	F26Dot6 *           p,
	int32               numPts);

FS_PRIVATE void  scl_ScaleBack (
	fnt_ScaleRecord *   sr,
	GlobalGSScaleFunc   ScaleFunc,
	F26Dot6 *           oop,
	F26Dot6 *           p,
	int32               numPts);

FS_PRIVATE void  scl_ConvertToFixedFUnits (
	F26Dot6 *           oop,
	F26Dot6 *           p,
	int32               numPts);

FS_PRIVATE void  scl_ScaleFromFixedFUnits (
	fnt_ScaleRecord *   sr,
	GlobalGSScaleFunc   ScaleFunc,
	F26Dot6 *           oop,
	F26Dot6 *           p,
	int32               numPts);
/* FUNCTIONS    */

#define BOLD_FACTOR 0x51e
#define MABS(x)                 ( (x) < 0 ? (-(x)) : (x) )
#define POINTSPERINCH               72

void  multiplyForEmbold(long a, long b, long *highRes, long *lowRes)
{
    long lowA, highA, lowB, highB, temp1, temp2;

    lowA = a & 0xffff;
    highA = (a & 0xffff0000) >> 16;
    lowB = b & 0xffff;
    highB = (b & 0xffff0000) >> 16;

    *highRes = highA*highB;
    *lowRes = lowA*lowB;

    temp1 = highA*lowB;
    temp2 = lowA*highB;

    *highRes += (temp1 & 0xffff0000) >> 16;
    *highRes += (temp2 & 0xffff0000) >> 16;

    *lowRes += (temp1 & 0xffff) << 16;
    *lowRes += (temp2 & 0xffff) << 16;
}

void  adjustTrans(transMatrix *trans)   //Adjust matrix for Emboldening
{
    int i,j;
    int  bNegative;
    long tmp, highRes, lowRes;

    for(i=0; i<2; i++)
        for(j=0; j<2; j++){
        
        	tmp = (long) trans->transform[i][j];

            bNegative = tmp < 0 ? TRUE: FALSE;
            tmp = MABS(tmp);

            multiplyForEmbold(tmp, BOLD_FACTOR, &highRes, &lowRes);

            highRes <<= 16;
            tmp -= highRes;

            if(bNegative)
	            tmp = -tmp;

            trans->transform[i][j] = tmp;
        }
}

FS_PUBLIC ErrorCode   scl_InitializeScaling(
	void *          pvGlobalGS,             /* GlobalGS                 */
	boolean         bIntegerScaling,        /* Integer Scaling Flag     */
	transMatrix *   trans,                  /* Current Transformation   */
	uint16          usUpem,                 /* Current units per Em     */
	Fixed           fxPointSize,            /* Current point size       */
	int16           sXResolution,           /* Current X Resolution     */
	int16           sYResolution,           /* Current Y Resolution     */
	uint16          usEmboldWeightx,     /* scaling factor in x between 0 and 40 (20 means 2% fo the height) */
	uint16          usEmboldWeighty,     /* scaling factor in y between 0 and 40 (20 means 2% fo the height) */
	int16           sWinDescender,
	int32           lDescDev,               /* descender in device metric, used for clipping */
	int16 *			psBoldSimulHorShift,   /* shift for emboldening simulation, horizontally */
	int16 *			psBoldSimulVertShift,   /* shift for emboldening simulation, vertically */
	boolean			bHintAtEmSquare,
	uint32 *        pulPixelsPerEm)         /* OUT: Pixels Per Em       */
{
	Fixed        maxScale;
	Fixed        fxUpem;
	fnt_GlobalGraphicStateType *    globalGS;
	transMatrix   origTrans = *trans;
	uint16		usRotation;
	boolean			non90degreeRotation,nonUniformStretching;

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

	mth_FoldPointSizeResolution(fxPointSize, sXResolution, sYResolution, trans);

	if ( ( (usEmboldWeightx != 0) || (usEmboldWeighty != 0))  && 							// Adjust matrix for Emboldening
		 (uint16)ROUNDFIXTOINT(ShortMulDiv(fxPointSize, sYResolution, POINTSPERINCH)) > 50 )// when bigger than 50 ppem
	{
        adjustTrans(trans);
    }

	mth_ReduceMatrix (trans);

	fxUpem = INTTOFIX(usUpem);

/*
 *  First set up the scalars...
 */

	/*save the flag for use in composite glyphs */
	globalGS->bHintAtEmSquare = bHintAtEmSquare;

	if (bHintAtEmSquare)
	{
		globalGS->interpScalarX = fxUpem;
		globalGS->interpScalarY = fxUpem;
		globalGS->fxMetricScalarX = mth_max_abs (trans->transform[0][0], trans->transform[0][1]);
		globalGS->fxMetricScalarY = mth_max_abs (trans->transform[1][0], trans->transform[1][1]);

		/* we don't want to round the interpScalar */
	}
	else
	{
		globalGS->interpScalarX = mth_max_abs (trans->transform[0][0], trans->transform[0][1]);
		globalGS->interpScalarY = mth_max_abs (trans->transform[1][0], trans->transform[1][1]);
		globalGS->fxMetricScalarX = globalGS->interpScalarX;
		globalGS->fxMetricScalarY = globalGS->interpScalarY;

		if (bIntegerScaling)
		{
			globalGS->interpScalarX = (Fixed)ROUNDFIXED(globalGS->interpScalarX);
			globalGS->interpScalarY = (Fixed)ROUNDFIXED(globalGS->interpScalarY);
		}
	}

	globalGS->ScaleFuncX = scl_ComputeScaling(&globalGS->scaleX, globalGS->interpScalarX, fxUpem);
	globalGS->ScaleFuncY = scl_ComputeScaling(&globalGS->scaleY, globalGS->interpScalarY, fxUpem);

	if ((globalGS->interpScalarX == 0) && (globalGS->interpScalarY == 0))
	{
		return TRAN_NULL_TRANSFORM_ERR;
	}
	if (globalGS->interpScalarX >= globalGS->interpScalarY)
	{
		globalGS->ScaleFuncCVT = globalGS->ScaleFuncX;
		globalGS->scaleCVT = globalGS->scaleX;
		globalGS->cvtStretchX = ONEFIX;
		globalGS->cvtStretchY = FixDiv(globalGS->interpScalarY, globalGS->interpScalarX);;
		maxScale = globalGS->interpScalarX;
	}
	else
	{
		globalGS->ScaleFuncCVT = globalGS->ScaleFuncY;
		globalGS->scaleCVT = globalGS->scaleY;
		globalGS->cvtStretchX = FixDiv(globalGS->interpScalarX, globalGS->interpScalarY);
		globalGS->cvtStretchY = ONEFIX;
		maxScale = globalGS->interpScalarY;
	}

	*pulPixelsPerEm = (uint32)ROUNDFIXTOINT (globalGS->interpScalarY);

	globalGS->bSameStretch  = (uint8)mth_SameStretch( globalGS->interpScalarX, globalGS->interpScalarY );
	globalGS->pixelsPerEm   = (uint16)ROUNDFIXTOINT(maxScale);
	globalGS->pointSize     = (uint16)ROUNDFIXTOINT( fxPointSize );
	globalGS->fpem          = maxScale;
	globalGS->identityTransformation = (int8)mth_PositiveSquare( trans );

	/* Use bit 1 of non90degreeTransformation to signify stretching.  stretch = 2 */

	mth_Non90DegreeTransformation(&origTrans,&non90degreeRotation,&nonUniformStretching);

	globalGS->non90DegreeTransformation = 0;

	if (non90degreeRotation)  globalGS->non90DegreeTransformation |= NON90DEGTRANS_ROTATED;
	if (nonUniformStretching) globalGS->non90DegreeTransformation |= NON90DEGTRANS_STRETCH;


	*psBoldSimulHorShift = 0;
	*psBoldSimulVertShift = 0;

	if ((usEmboldWeightx != 0) || (usEmboldWeighty != 0))
	{
		/* we cannot use globalGS->pixelsPerEm because it s incorrect under non 90degree rotation */
		uint16 ppemY;
		Fixed fxBoldSimulHorShift,fxBoldSimulVertShift;
		F26Dot6	fxDefaultDescender;
        transMatrix reverseTrans;
        Fixed   fxDeterminant;
		Fixed fxScale;

		fxScale = ShortMulDiv(fxPointSize, sYResolution, POINTSPERINCH);
		ppemY = (uint16)ROUNDFIXTOINT(fxScale);  
		usRotation = mth_90degRotationFactor(trans);
		if( usRotation == 4 )   // Consider Italic/Bold case
            usRotation = mth_90degClosestRotationFactor(trans);

		if (bHintAtEmSquare)
		{
            *psBoldSimulVertShift = (ppemY * usEmboldWeighty - 10) /1000; /* save the number of pixels for bitmap emboldening */
			ppemY = usUpem;
		}

		/* this computation is intended to give backwards compatible results with the
			bitmap emboldening simulation done in Windows NT 4.0
		    The following computation was adapted to get the same cutoff than Win'98 between 50 and 51 ppem
			for an emboldening factor of 2% (usEmboldWeight = 20)
		*/

		globalGS->uBoldSimulVertShift = (ppemY * usEmboldWeighty - 10) /1000;
		globalGS->uBoldSimulHorShift = (ppemY * usEmboldWeightx - 10) /1000 + 1;

		if (!bHintAtEmSquare)
		    *psBoldSimulVertShift = globalGS->uBoldSimulVertShift; /* save the number of pixels for bitmap emboldening */

 		switch(usRotation)                   /* handle 90 degree rotations */
		{
		case 0:                                     /* no rotation */
			*psBoldSimulHorShift = *psBoldSimulVertShift+1;
			*psBoldSimulVertShift = -(*psBoldSimulVertShift);
 			break;
		case 1:                                     /* 90 degree rotation */
			*psBoldSimulHorShift = -(*psBoldSimulVertShift);
			*psBoldSimulVertShift = -(*psBoldSimulVertShift+1);
			break;
		case 2:                                     /* 180 degree rotation */
			*psBoldSimulHorShift = -(*psBoldSimulVertShift+1);
			*psBoldSimulVertShift = *psBoldSimulVertShift;
			break;
		case 3:                                     /* 270 degree rotation */
			*psBoldSimulHorShift = *psBoldSimulVertShift;
			*psBoldSimulVertShift = *psBoldSimulVertShift + 1;
			break;
		default:                                    /* non 90 degree rotation */
			*psBoldSimulHorShift = 0;
			*psBoldSimulVertShift = 0;
		}

		if (!bHintAtEmSquare && (sYResolution != sXResolution))
		{
			fxBoldSimulHorShift = globalGS->uBoldSimulHorShift << 16;
			fxBoldSimulVertShift = globalGS->uBoldSimulVertShift << 16;
            fxDeterminant = MABS( FixMul(origTrans.transform[0][0],origTrans.transform[1][1]) - FixMul(origTrans.transform[0][1],origTrans.transform[1][0]) );

			if (fxDeterminant == 0)
			{
				globalGS->uBoldSimulHorShift = 0;  
				globalGS->uBoldSimulVertShift = 0;  
			}
			else
			{
				origTrans.transform[0][0] = FixDiv(origTrans.transform[0][0], fxDeterminant);
				origTrans.transform[0][1] = FixDiv(origTrans.transform[0][1], fxDeterminant);
				origTrans.transform[1][0] = FixDiv(origTrans.transform[1][0], fxDeterminant);
				origTrans.transform[1][1] = FixDiv(origTrans.transform[1][1], fxDeterminant);
				reverseTrans = origTrans;
				reverseTrans.transform[0][1] = - reverseTrans.transform[0][1];
				reverseTrans.transform[1][0] = - reverseTrans.transform[1][0];

				mth_IntelMul (
					1,
					&fxBoldSimulHorShift,
					&fxBoldSimulVertShift,
					&origTrans,
					ONEFIX,
					ONEFIX);

				fxBoldSimulHorShift = ShortMulDiv(fxBoldSimulHorShift, sXResolution, sYResolution);

				mth_IntelMul (
					1,
					&fxBoldSimulHorShift,
					&fxBoldSimulVertShift,
					&reverseTrans,
					ONEFIX,
					ONEFIX);

				globalGS->uBoldSimulHorShift = (uint16)ROUNDFIXTOINT(MABS(fxBoldSimulHorShift));  
				globalGS->uBoldSimulVertShift = (uint16)ROUNDFIXTOINT(MABS(fxBoldSimulVertShift));  
			}

        }

		if (!bHintAtEmSquare && !(globalGS->non90DegreeTransformation & NON90DEGTRANS_ROTATED))
		{
			/* 90 degree rotation, convert the device value into 26.6 */
			globalGS->fxScaledDescender = -lDescDev << 6;
		} else 
		{
			/* under rotation, we use the value from head-Descender and scale it */
			fxDefaultDescender = sWinDescender;

			scl_Scale (&globalGS->scaleY,
					globalGS->ScaleFuncY,
					&fxDefaultDescender,
					&globalGS->fxScaledDescender,
					1);

			/* add the uBoldSimulVertShift and round to the next pixel */
			globalGS->fxScaledDescender = globalGS->fxScaledDescender & ~(LOWSIXBITS);
		}
	} else {
		globalGS->uBoldSimulHorShift = 0;
		globalGS->uBoldSimulVertShift = 0;
		globalGS->fxScaledDescender = 0;
	}
	return NO_ERR;
}

FS_PUBLIC void scl_InitializeChildScaling(
	void *          pvGlobalGS,             /* GlobalGS                 */
	transMatrix     CurrentTMatrix,                  /* Current Transformation   */
	uint16          usUpem)                 /* Current units per Em     */
{
	Fixed        fxUpem;
	fnt_GlobalGraphicStateType *    globalGS;
	Fixed           interpScalarX;    
	Fixed           interpScalarY;    

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

	fxUpem = INTTOFIX(usUpem);

/* 
 * This procedure is a subset from scl_InitializeScaling. 
 * There is no perfect solution here, we decided that the best, in the case of a
 * component that is not at the same transformation as the master glyph,
 * is to scale this child glyph to the user grid for hinting, without re-running
 * the pre-program, without rescaling the cvt or changing other GloblaGS information (pointSize, pixelPerEm,...)
 */

/*
 *  First set up the scalars...
 */
	if (globalGS->bHintAtEmSquare)
	{
		interpScalarX = fxUpem;
		interpScalarY = fxUpem;
	}
	else
	{
		interpScalarX = mth_max_abs (CurrentTMatrix.transform[0][0], CurrentTMatrix.transform[0][1]);
		interpScalarY = mth_max_abs (CurrentTMatrix.transform[1][0], CurrentTMatrix.transform[1][1]);
	}

	globalGS->ScaleFuncXChild = scl_ComputeScaling(&globalGS->scaleXChild, interpScalarX, fxUpem);
	globalGS->ScaleFuncYChild = scl_ComputeScaling(&globalGS->scaleYChild, interpScalarY, fxUpem);

}

FS_PUBLIC void  scl_SetHintFlags(
	void *              pvGlobalGS,
	boolean				bHintForGray
#ifdef FSCFG_SUBPIXEL
	,uint16			flHintForSubPixel
#endif // FSCFG_SUBPIXEL
    )

{
	fnt_GlobalGraphicStateType *    globalGS;

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

	globalGS->bHintForGray = bHintForGray;

#ifdef FSCFG_SUBPIXEL
	globalGS->flHintForSubPixel = flHintForSubPixel;
#endif // FSCFG_SUBPIXEL
}

/******************** These three scale 26.6 to 26.6 ********************/
/*
 * Fast (scaling)
 */
FS_PRIVATE F26Dot6 scl_FRound(fnt_ScaleRecord* rec, F26Dot6 value)
{
	return (F26Dot6) FROUND (value, rec->numer, rec->denom >> 1, rec->shift);
}

/*
 * Medium (scaling)
 */
FS_PRIVATE F26Dot6 scl_SRound(fnt_ScaleRecord* rec, F26Dot6 value)
{
	int32 D;

	D = rec->denom;
	return (F26Dot6) SROUND (value, rec->numer, D, D >> 1);
}

/*
 * Fixed Rounding (scaling), really slow
 */
FS_PRIVATE F26Dot6 scl_FixRound(fnt_ScaleRecord* rec, F26Dot6 value)
{
	return (F26Dot6) FixMul ((Fixed)value, rec->fixedScale);
}

/********************************* End scaling utilities ************************/

FS_PRIVATE GlobalGSScaleFunc scl_ComputeScaling(fnt_ScaleRecord* rec, Fixed N, Fixed D)
{
	int32     lShift;

	lShift = mth_CountLowZeros((uint32)(N | D) ) - 1;

	if (lShift > 0)
	{
		N >>= lShift;
		D >>= lShift;
	}


	if ( N < CANTAKESHIFT )
	{
		N <<= FNT_PIXELSHIFT;
	}
	else
	{
		D >>= FNT_PIXELSHIFT;
	}

	/* fixedScale is now set in every case for the scale back in scaled composites */
	rec->fixedScale = FixDiv(N, D);

	if (N <= SHRT_MAX)   /* Check to see if N fits in a short    */
	{
		lShift = mth_GetShift ((uint32) D);
		rec->numer = (int32)N;
		rec->denom = (int32)D;

		if ( lShift >= 0 )                  /* FAST SCALE */
		{
			rec->shift = (int32)lShift;
			return (GlobalGSScaleFunc)scl_FRound;
		}
		else                                /* MEDIUM SCALE */
		{
			return (GlobalGSScaleFunc)scl_SRound;
		}
	}
	else                                    /* SLOW SCALE */
	{
		return (GlobalGSScaleFunc)scl_FixRound;
	}
}


FS_PRIVATE void  scl_Scale (
	fnt_ScaleRecord *   sr,
	GlobalGSScaleFunc   ScaleFunc,
	F26Dot6 *           oop,
	F26Dot6 *           p,
	int32               numPts)
{
	int32   Index;

	if (ScaleFunc == scl_FRound)
	{
		for(Index = 0; Index < numPts; Index++)
		{
			p[Index] = (F26Dot6) FROUND (oop[Index], sr->numer, sr->denom >> 1, sr->shift);
		}
	}
	else
	{
		if (ScaleFunc == scl_SRound)
		{
			for(Index = 0; Index < numPts; Index++)
			{
				p[Index] = (F26Dot6) SROUND (oop[Index], sr->numer, sr->denom, sr->denom >> 1);
			}
		}
		else
		{
			for(Index = 0; Index < numPts; Index++)
			{
				p[Index] = (F26Dot6) FixMul ((Fixed)oop[Index], sr->fixedScale);
			}
		}
	}
}


FS_PRIVATE void  scl_ScaleFromFixedFUnits (
	fnt_ScaleRecord *   sr,
	GlobalGSScaleFunc   ScaleFunc,
	F26Dot6 *           oop,
	F26Dot6 *           p,
	int32               numPts)
{
	int32   Index;
	int32	Scale;
	int32	Shift;
	int32	Numer;

	/* we are now multiplying a 26.6 by sr->numer, we could overflow if (sr->numer >= SHRT_MAX >> FNT_PIXELSHIFT) */
	if ((ScaleFunc == scl_FRound) && (sr->numer < (SHRT_MAX >> FNT_PIXELSHIFT) ))
	{
		
		Shift = sr->shift + FNT_PIXELSHIFT;

		for(Index = 0; Index < numPts; Index++)
		{
			p[Index] = (F26Dot6) FROUND (oop[Index], sr->numer, sr->denom >> 1, Shift);
		}
	}
	else
	{
		if (ScaleFunc == scl_SRound)
		{
			Numer = sr->numer >> FNT_PIXELSHIFT;

			for(Index = 0; Index < numPts; Index++)
			{
				p[Index] = (F26Dot6) SROUND (oop[Index], Numer, sr->denom, sr->denom >> 1);
			}
		}
		else
		{
			Scale = sr->fixedScale >> FNT_PIXELSHIFT;
			for(Index = 0; Index < numPts; Index++)
			{
				p[Index] = (F26Dot6) FixMul ((Fixed)oop[Index], Scale);
			}
		}
	}
}

FS_PRIVATE void  scl_ScaleBack (
	fnt_ScaleRecord *   sr,
	GlobalGSScaleFunc   ScaleFunc,
	F26Dot6 *           oop,
	F26Dot6 *           p,
	int32               numPts)
{
	int32   Index;
	int32	ScaleBack;

	ScaleBack = sr->fixedScale >> FNT_PIXELSHIFT;
	for(Index = 0; Index < numPts; Index++)
	{
		p[Index] = (F26Dot6) FixDiv ((Fixed)oop[Index], ScaleBack);
	}
}

FS_PRIVATE void  scl_ConvertToFixedFUnits (
	F26Dot6 *           oop,
	F26Dot6 *           p,
	int32               numPts)
{
	int32   Index;

	for(Index = 0; Index < numPts; Index++)
	{
		p[Index] = (Fixed)oop[Index] << FNT_PIXELSHIFT;
	}
}

/*
 *  scl_ScaleChar                       <3>
 *
 *  Scales a character
 */

FS_PUBLIC void  scl_ScaleOldCharPoints (
	fnt_ElementType *   pElement,   /* Element  */
	void *              pvGlobalGS) /* GlobalGS */
{
	fnt_GlobalGraphicStateType *    globalGS;

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

	if (globalGS->bSameTransformAsMaster)
	{
		scl_Scale (&globalGS->scaleX,
				globalGS->ScaleFuncX,
				pElement->oox,
				pElement->ox,
				(int32)NUMBEROFCHARPOINTS(pElement));
		scl_Scale (&globalGS->scaleY,
				globalGS->ScaleFuncY,
				pElement->ooy,
				pElement->oy,
				(int32)NUMBEROFCHARPOINTS(pElement));
	}
	else
	{
		scl_Scale (&globalGS->scaleXChild,
				globalGS->ScaleFuncXChild,
				pElement->oox,
				pElement->ox,
				(int32)NUMBEROFCHARPOINTS(pElement));
		scl_Scale (&globalGS->scaleYChild,
				globalGS->ScaleFuncYChild,
				pElement->ooy,
				pElement->oy,
				(int32)NUMBEROFCHARPOINTS(pElement));
	}

}
/*
 *  scl_ScaleChar                       <3>
 *
 *  Scales a character
 */

FS_PUBLIC void  scl_ScaleFixedCurrentCharPoints (
	fnt_ElementType *   pElement,   /* Element  */
	void *              pvGlobalGS) /* GlobalGS */
{
	fnt_GlobalGraphicStateType *    globalGS;

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

	if (globalGS->bSameTransformAsMaster)
	{
		scl_ScaleFromFixedFUnits (&globalGS->scaleX,
				globalGS->ScaleFuncX,
				pElement->x,
				pElement->x,
				(int32)NUMBEROFCHARPOINTS(pElement));
		scl_ScaleFromFixedFUnits (&globalGS->scaleY,
				globalGS->ScaleFuncY,
				pElement->y,
				pElement->y,
				(int32)NUMBEROFCHARPOINTS(pElement));
	}
	else
	{
		scl_ScaleFromFixedFUnits (&globalGS->scaleXChild,
				globalGS->ScaleFuncXChild,
				pElement->x,
				pElement->x,
				(int32)NUMBEROFCHARPOINTS(pElement));
		scl_ScaleFromFixedFUnits (&globalGS->scaleYChild,
				globalGS->ScaleFuncYChild,
				pElement->y,
				pElement->y,
				(int32)NUMBEROFCHARPOINTS(pElement));
	}

}

FS_PUBLIC void  scl_ScaleOldPhantomPoints (
	fnt_ElementType *   pElement,   /* Element  */
	void *              pvGlobalGS) /* GlobalGS */
{
	uint16                    usFirstPhantomPoint;
	fnt_GlobalGraphicStateType *    globalGS;

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

	usFirstPhantomPoint = LSBPOINTNUM(pElement);

	if (globalGS->bSameTransformAsMaster)
	{
		scl_Scale (&globalGS->scaleX,
				globalGS->ScaleFuncX,
				&(pElement->oox[usFirstPhantomPoint]),
				&(pElement->ox[usFirstPhantomPoint]),
				(int32)PHANTOMCOUNT);

		scl_Scale (&globalGS->scaleY,
				globalGS->ScaleFuncY,
				&(pElement->ooy[usFirstPhantomPoint]),
				&(pElement->oy[usFirstPhantomPoint]),
				(int32)PHANTOMCOUNT);
	}
	else
	{
		scl_Scale (&globalGS->scaleXChild,
				globalGS->ScaleFuncXChild,
				&(pElement->oox[usFirstPhantomPoint]),
				&(pElement->ox[usFirstPhantomPoint]),
				(int32)PHANTOMCOUNT);

		scl_Scale (&globalGS->scaleYChild,
				globalGS->ScaleFuncYChild,
				&(pElement->ooy[usFirstPhantomPoint]),
				&(pElement->oy[usFirstPhantomPoint]),
				(int32)PHANTOMCOUNT);
	}

}

FS_PUBLIC void  scl_ScaleFixedCurrentPhantomPoints (
	fnt_ElementType *   pElement,   /* Element  */
	void *              pvGlobalGS) /* GlobalGS */
{
	uint16                    usFirstPhantomPoint;
	fnt_GlobalGraphicStateType *    globalGS;


	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

	Assert(globalGS->bSameTransformAsMaster);

	usFirstPhantomPoint = LSBPOINTNUM(pElement);

	scl_ScaleFromFixedFUnits (&globalGS->scaleX,
			   globalGS->ScaleFuncX,
			   &(pElement->x[usFirstPhantomPoint]),
			   &(pElement->x[usFirstPhantomPoint]),
			   (int32)PHANTOMCOUNT);

	scl_ScaleFromFixedFUnits (&globalGS->scaleY,
			   globalGS->ScaleFuncY,
			   &(pElement->y[usFirstPhantomPoint]),
			   &(pElement->y[usFirstPhantomPoint]),
			   (int32)PHANTOMCOUNT);

}

/*
 *  scl_ScaleBackCurrentCharPoints                     
 *
 *  Scales back a character to hinted fixed FUnits
 */

FS_PUBLIC void  scl_ScaleBackCurrentCharPoints (
	fnt_ElementType *   pElement,   /* Element  */
	void *              pvGlobalGS) /* GlobalGS */
{
	fnt_GlobalGraphicStateType *    globalGS;

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

	if (globalGS->bSameTransformAsMaster)
	{
		scl_ScaleBack (&globalGS->scaleX,
			    globalGS->ScaleFuncX,
				pElement->x,
				pElement->x,
				(int32)NUMBEROFCHARPOINTS(pElement));
		scl_ScaleBack (&globalGS->scaleY,
			    globalGS->ScaleFuncY,
				pElement->y,
				pElement->y,
				(int32)NUMBEROFCHARPOINTS(pElement));
	}
	else
	{
		scl_ScaleBack (&globalGS->scaleXChild,
			    globalGS->ScaleFuncXChild,
				pElement->x,
				pElement->x,
				(int32)NUMBEROFCHARPOINTS(pElement));
		scl_ScaleBack (&globalGS->scaleYChild,
			    globalGS->ScaleFuncYChild,
				pElement->y,
				pElement->y,
				(int32)NUMBEROFCHARPOINTS(pElement));
	}

}

FS_PUBLIC void  scl_ScaleBackCurrentPhantomPoints (
	fnt_ElementType *   pElement,   /* Element  */
	void *              pvGlobalGS) /* GlobalGS */
{
	uint16                    usFirstPhantomPoint;
	fnt_GlobalGraphicStateType *    globalGS;

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

	usFirstPhantomPoint = LSBPOINTNUM(pElement);

	if (globalGS->bSameTransformAsMaster)
	{
		scl_ScaleBack (&globalGS->scaleX,
			    globalGS->ScaleFuncX,
				&(pElement->x[usFirstPhantomPoint]),
				&(pElement->x[usFirstPhantomPoint]),
				(int32)PHANTOMCOUNT);

		scl_ScaleBack (&globalGS->scaleY,
			    globalGS->ScaleFuncY,
				&(pElement->y[usFirstPhantomPoint]),
				&(pElement->y[usFirstPhantomPoint]),
				(int32)PHANTOMCOUNT);
	}
	else
	{
		scl_ScaleBack (&globalGS->scaleXChild,
			    globalGS->ScaleFuncXChild,
				&(pElement->x[usFirstPhantomPoint]),
				&(pElement->x[usFirstPhantomPoint]),
				(int32)PHANTOMCOUNT);

		scl_ScaleBack (&globalGS->scaleYChild,
			    globalGS->ScaleFuncYChild,
				&(pElement->y[usFirstPhantomPoint]),
				&(pElement->y[usFirstPhantomPoint]),
				(int32)PHANTOMCOUNT);
	}
}

/*
 *  scl_OriginalCharPointsToCurrentFixedFUnits                     
 *
 *  Scales back a character to hinted fixed FUnits
 */

FS_PUBLIC void  scl_OriginalCharPointsToCurrentFixedFUnits (
	fnt_ElementType *   pElement) /* Element */
{

	scl_ConvertToFixedFUnits (
			   pElement->oox,
			   pElement->x,
			   (int32)NUMBEROFCHARPOINTS(pElement));

	scl_ConvertToFixedFUnits (
			   pElement->ooy,
			   pElement->y,
			   (int32)NUMBEROFCHARPOINTS(pElement));
}

FS_PUBLIC void  scl_OriginalPhantomPointsToCurrentFixedFUnits (
	fnt_ElementType *   pElement) /* Element */
{
	uint16                    usFirstPhantomPoint;

	usFirstPhantomPoint = LSBPOINTNUM(pElement);

	scl_ConvertToFixedFUnits (
			   &(pElement->oox[usFirstPhantomPoint]),
			   &(pElement->x[usFirstPhantomPoint]),
			   (int32)PHANTOMCOUNT);

	scl_ConvertToFixedFUnits (
			   &(pElement->ooy[usFirstPhantomPoint]),
			   &(pElement->y[usFirstPhantomPoint]),
			   (int32)PHANTOMCOUNT);
}

/*
 * scl_ScaleCVT
 */

FS_PUBLIC void  scl_ScaleCVT(
	void *      pvGlobalGS,
	F26Dot6 *   pfxCVT)
{
	fnt_GlobalGraphicStateType *    globalGS;

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

	if(globalGS->cvtCount > 0)
	{
		scl_Scale (
			&globalGS->scaleCVT,
			globalGS->ScaleFuncCVT,
			pfxCVT,
			globalGS->controlValueTable,
			(int32)globalGS->cvtCount);
	}
}

FS_PUBLIC void  scl_GetCVTPtr(
	void *      pvGlobalGS,
	F26Dot6 **  pfxCVT)
{
	fnt_GlobalGraphicStateType *    globalGS;

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

	*pfxCVT = globalGS->controlValueTable;

}

FS_PUBLIC void  scl_CalcOrigPhantomPoints(
	fnt_ElementType *   pElement,       /* Element                      */
	BBOX *              bbox,           /* Bounding Box                 */
	int16               sNonScaledLSB,  /* Non-scaled Left Side Bearing */
	int16               sNonScaledTSB,  /* Non-scaled Top Side Bearing  */
	uint16              usNonScaledAW,  /* Non-scaled Advance Width     */
	uint16              usNonScaledAH)  /* Non-scaled Advance Height    */
{

	F26Dot6             fxXMinMinusLSB;
	F26Dot6             fxYMaxPlusTSB;

	MEMSET (&(pElement->ooy[LSBPOINTNUM(pElement)]),
			'\0',
			PHANTOMCOUNT * sizeof (pElement->ooy[0]));

	MEMSET (&(pElement->oox[LSBPOINTNUM(pElement)]),
			'\0',
			PHANTOMCOUNT * sizeof (pElement->oox[0]));

	fxXMinMinusLSB = ((F26Dot6)bbox->xMin - (F26Dot6)sNonScaledLSB);

	pElement->oox[LSBPOINTNUM(pElement)] = fxXMinMinusLSB;
	pElement->oox[RSBPOINTNUM(pElement)] = fxXMinMinusLSB + (F26Dot6)usNonScaledAW;
	pElement->oox[ORIGINPOINTNUM(pElement)] = fxXMinMinusLSB;
	pElement->oox[LEFTEDGEPOINTNUM(pElement)] = (F26Dot6)bbox->xMin;

	fxYMaxPlusTSB = ((F26Dot6)bbox->yMax + (F26Dot6)sNonScaledTSB);

	pElement->ooy[TOPSBPOINTNUM(pElement)] = fxYMaxPlusTSB;
	pElement->ooy[BOTTOMSBPOINTNUM(pElement)] = fxYMaxPlusTSB - (F26Dot6)usNonScaledAH;
	pElement->ooy[TOPORIGINPOINTNUM(pElement)] = fxYMaxPlusTSB;
	pElement->ooy[TOPEDGEPOINTNUM(pElement)] = (F26Dot6)bbox->yMax;
}

FS_PUBLIC void  scl_AdjustOldCharSideBearing(
	fnt_ElementType* pElement
#ifdef FSCFG_SUBPIXEL
	, void* pvGlobalGS
#endif
	)   /* Element  */
{
	F26Dot6     fxOldLeftOrigin;
	F26Dot6     fxNewLeftOrigin;
	uint16      cNumCharPoints;
#ifdef FSCFG_SUBPIXEL
	fnt_GlobalGraphicStateType* globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;
#endif

	cNumCharPoints = NUMBEROFCHARPOINTS(pElement);

	fxOldLeftOrigin = pElement->ox[LSBPOINTNUM(pElement)];
	fxNewLeftOrigin = fxOldLeftOrigin;
#ifdef FSCFG_SUBPIXEL
	if (RunningSubPixel(globalGS) && !VerticalSPDirection(globalGS)) {
		fxNewLeftOrigin += VIRTUAL_PIXELSIZE_RTG/2; // round to a virtual pixel boundary
		fxNewLeftOrigin &= ~(VIRTUAL_PIXELSIZE_RTG - 1);
	} else {
#endif
		fxNewLeftOrigin += FNT_PIXELSIZE/2; /* round to a pixel boundary */
		fxNewLeftOrigin &= ~(FNT_PIXELSIZE - 1);
#ifdef FSCFG_SUBPIXEL
	}
#endif

	scl_ShiftOldPoints (
		pElement,
		fxNewLeftOrigin - fxOldLeftOrigin,
		0L,
		0,
		cNumCharPoints);

}

FS_PUBLIC void  scl_AdjustOldPhantomSideBearing(
	fnt_ElementType* pElement
#ifdef FSCFG_SUBPIXEL
	, void* pvGlobalGS
#endif
	)   /* Element  */
{
	F26Dot6     fxOldLeftOrigin;
	F26Dot6     fxNewLeftOrigin;
#ifdef FSCFG_SUBPIXEL
	fnt_GlobalGraphicStateType* globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;
#endif

	fxOldLeftOrigin = pElement->ox[LSBPOINTNUM(pElement)];
	fxNewLeftOrigin = fxOldLeftOrigin;
#ifdef FSCFG_SUBPIXEL
	if (RunningSubPixel(globalGS) && !VerticalSPDirection(globalGS)) {
		fxNewLeftOrigin += VIRTUAL_PIXELSIZE_RTG/2; // round to a virtual pixel boundary
		fxNewLeftOrigin &= ~(VIRTUAL_PIXELSIZE_RTG - 1);
	} else {
#endif
		fxNewLeftOrigin += FNT_PIXELSIZE/2; /* round to a pixel boundary */
		fxNewLeftOrigin &= ~(FNT_PIXELSIZE - 1);
#ifdef FSCFG_SUBPIXEL
	}
#endif

	scl_ShiftOldPoints (
		pElement,
		fxNewLeftOrigin - fxOldLeftOrigin,
		0L,
		LSBPOINTNUM(pElement),
		PHANTOMCOUNT);
}

FS_PUBLIC void  scl_AdjustOldSideBearingPoints(
	fnt_ElementType* pElement
#ifdef FSCFG_SUBPIXEL
	, void* pvGlobalGS
#endif
	)   /* Element  */
{
	F26Dot6 fxOldLeftOrigin;
	F26Dot6 fxNewLeftOrigin;
#ifdef FSCFG_SUBPIXEL
	fnt_GlobalGraphicStateType* globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;
#endif

	fxOldLeftOrigin = pElement->ox[LSBPOINTNUM(pElement)];
	fxNewLeftOrigin = fxOldLeftOrigin;
#ifdef FSCFG_SUBPIXEL
	if (RunningSubPixel(globalGS) && !VerticalSPDirection(globalGS)) {
		fxNewLeftOrigin += VIRTUAL_PIXELSIZE_RTG/2; // round to a virtual pixel boundary
		fxNewLeftOrigin &= ~(VIRTUAL_PIXELSIZE_RTG - 1);
	} else {
#endif
		fxNewLeftOrigin += FNT_PIXELSIZE/2; /* round to a pixel boundary */
		fxNewLeftOrigin &= ~(FNT_PIXELSIZE - 1);
#ifdef FSCFG_SUBPIXEL
	}
#endif

	pElement->ox[LSBPOINTNUM(pElement)]  = fxNewLeftOrigin;
	pElement->ox[RSBPOINTNUM(pElement)] += fxNewLeftOrigin - fxOldLeftOrigin;
}

FS_PUBLIC void  scl_CopyOldCharPoints(
	fnt_ElementType *           pElement)   /* Element  */
{
	MEMCPY(pElement->ox, pElement->x, (size_t)NUMBEROFCHARPOINTS(pElement) * sizeof(F26Dot6));
	MEMCPY(pElement->oy, pElement->y, (size_t)NUMBEROFCHARPOINTS(pElement) * sizeof(F26Dot6));
}

FS_PUBLIC void  scl_CopyCurrentCharPoints(
	fnt_ElementType *           pElement)   /* Element  */
{
	MEMCPY(pElement->x, pElement->ox, (size_t)NUMBEROFCHARPOINTS(pElement) * sizeof(F26Dot6));
	MEMCPY(pElement->y, pElement->oy, (size_t)NUMBEROFCHARPOINTS(pElement) * sizeof(F26Dot6));
}

FS_PUBLIC void  scl_CopyCurrentPhantomPoints(
	fnt_ElementType *           pElement)   /* Element  */
{
	uint16    usFirstPhantomPoint;

	usFirstPhantomPoint = LSBPOINTNUM(pElement);
	MEMCPY(&pElement->x[usFirstPhantomPoint],
		   &pElement->ox[usFirstPhantomPoint],
		   PHANTOMCOUNT * sizeof(F26Dot6));

	MEMCPY(&pElement->y[usFirstPhantomPoint],
		   &pElement->oy[usFirstPhantomPoint],
		   PHANTOMCOUNT * sizeof(F26Dot6));
}

FS_PUBLIC void  scl_RoundCurrentSideBearingPnt(
	fnt_ElementType *   pElement,   /* Element  */
	void *              pvGlobalGS, /* GlobalGS */
	uint16              usEmResolution)
{
	F26Dot6     fxWidth;
	F26Dot6     fxHeight;
	fnt_GlobalGraphicStateType* globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

	/* autoround the right side bearing */

	fxWidth = FIXEDTODOT6 (ShortMulDiv( (int32)globalGS->interpScalarX,
		(int16)(pElement->oox[RSBPOINTNUM(pElement)] - pElement->oox[LSBPOINTNUM(pElement)]),
		(int16)usEmResolution ));
/*
	fxWidth = globalGS->ScaleFuncX(&globalGS->scaleX,
		(pElement->oox[RSBPOINTNUM(pElement)] - pElement->oox[LSBPOINTNUM(pElement)]));
*/

#ifdef FSCFG_SUBPIXEL
	if (RunningSubPixel(globalGS) && !VerticalSPDirection(globalGS)  ) {
		fxWidth += VIRTUAL_PIXELSIZE_RTG / 2;
		fxWidth &= ~(VIRTUAL_PIXELSIZE_RTG - 1);
	} else { // for SubPixel in compatible width mode, always round to full pixel to get full pixel advance width
#endif
		fxWidth += FNT_PIXELSIZE / 2;
		fxWidth &= ~(FNT_PIXELSIZE - 1);
#ifdef FSCFG_SUBPIXEL
	}
#endif
	pElement->x[RSBPOINTNUM(pElement)] = pElement->x[LSBPOINTNUM(pElement)] + fxWidth;

	/* autoround the top side bearing */

	fxHeight = FIXEDTODOT6 (ShortMulDiv( (int32)globalGS->interpScalarY,
		(int16)(pElement->ooy[BOTTOMSBPOINTNUM(pElement)] - pElement->ooy[TOPSBPOINTNUM(pElement)]),
		(int16)usEmResolution ));
/*
	fxHeight = globalGS->ScaleFuncY(&globalGS->scaleY,
		(pElement->ooy[BOTTOMSBPOINTNUM(pElement)] - pElement->ooy[TOPSBPOINTNUM(pElement)]));
*/

	/* in the vertical direction, as we don't round the old TOPSBPOINT 
	    and do scl_ShiftOldPoints, we need to round TOPSBPOINT here */
	pElement->y[TOPSBPOINTNUM(pElement)] =
		(pElement->y[TOPSBPOINTNUM(pElement)] + DOT6ONEHALF) & ~(LOWSIXBITS);

	pElement->y[BOTTOMSBPOINTNUM(pElement)] =
		pElement->y[TOPSBPOINTNUM(pElement)] + (fxHeight + DOT6ONEHALF) & ~(LOWSIXBITS);
}

/*
 *  scl_ShiftChar
 *
 *  Shifts a character          <3>
 */
FS_PUBLIC void scl_ShiftCurrentCharPoints (
	fnt_ElementType *   pElement,
	F26Dot6             fxXShift,
	F26Dot6             fxYShift)

{
	uint32  ulCharIndex;

	if (fxXShift != 0)
	{
		for(ulCharIndex = 0; ulCharIndex < (uint32)NUMBEROFCHARPOINTS(pElement); ulCharIndex++)
		{
		   pElement->x[ulCharIndex] += fxXShift;
		}
	}

	if (fxYShift != 0)
	{
		for(ulCharIndex = 0; ulCharIndex < (uint32)NUMBEROFCHARPOINTS(pElement); ulCharIndex++)
		{
		   pElement->y[ulCharIndex] += fxYShift;
		}
	}
}

FS_PRIVATE void scl_ShiftOldPoints (
	fnt_ElementType *   pElement,
	F26Dot6             fxXShift,
	F26Dot6             fxYShift,
	uint16              usFirstPoint,
	uint16              usNumPoints)
{
	uint32  ulCharIndex;

	if (fxXShift != 0)
	{
		for(ulCharIndex = (uint32)usFirstPoint; ulCharIndex < ((uint32)usFirstPoint + (uint32)usNumPoints); ulCharIndex++)
		{
			pElement->ox[ulCharIndex] += fxXShift;
		}
	}

	if (fxYShift != 0)
	{
		for(ulCharIndex = (uint32)usFirstPoint; ulCharIndex < ((uint32)usFirstPoint + (uint32)usNumPoints); ulCharIndex++)
		{
			pElement->oy[ulCharIndex] += fxYShift;
		}
	}
}

FS_PUBLIC void  scl_CalcComponentOffset(
	void *      pvGlobalGS,         /* GlobalGS             */
	int16       sXOffset,           /* IN: X Offset         */
	int16       sYOffset,           /* Y Offset             */
	boolean     bRounding,          /* Rounding Indicator   */
	boolean		bSameTransformAsMaster, /* local transf. same as master transf. */
	boolean     bScaleCompositeOffset,  /* does the component offset need to be scaled Apple/MS */
	transMatrix mulT,                   /* Transformation matrix for composite              */
#ifdef FSCFG_SUBPIXEL
	RotationParity	rotationParity,
#endif
	F26Dot6 *   pfxXOffset,         /* OUT: X Offset        */
	F26Dot6 *   pfxYOffset)         /* Y Offset             */
{
	fnt_GlobalGraphicStateType *    globalGS;
	Fixed     scalarX;
	Fixed     scalarY;

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

	if (bSameTransformAsMaster) {
		*pfxXOffset = globalGS->ScaleFuncX(&globalGS->scaleX,(F26Dot6)sXOffset);
		*pfxYOffset = globalGS->ScaleFuncY(&globalGS->scaleY,(F26Dot6)sYOffset);
	} else {
		*pfxXOffset = globalGS->ScaleFuncXChild(&globalGS->scaleXChild,(F26Dot6)sXOffset);
		*pfxYOffset = globalGS->ScaleFuncYChild(&globalGS->scaleYChild,(F26Dot6)sYOffset);
	}

	if (bScaleCompositeOffset)
	/* the composite is designed to have its offset scaled (designed for Apple) */
	{
		/* Apple use a 45 degree special case that they are dropping on their GX rasterizer,
		   I'm not implementing this special rule here */
		scalarX = mth_max_abs (mulT.transform[0][0], mulT.transform[0][1]);
		scalarY = mth_max_abs (mulT.transform[1][0], mulT.transform[1][1]);
		if ((scalarX != ONEFIX) || (scalarY != ONEFIX)) {
			*pfxXOffset = (F26Dot6) FixMul ((Fixed)*pfxXOffset, scalarX);
			*pfxYOffset = (F26Dot6) FixMul ((Fixed)*pfxYOffset, scalarY);
		}
	}

	if (bRounding) {
#ifdef FSCFG_SUBPIXEL
		if (RunningSubPixel(globalGS) && ((rotationParity == arbitraryRotation) || ((rotationParity == evenMult90DRotation) != VerticalSPDirection(globalGS)))) {
			*pfxXOffset += VIRTUAL_PIXELSIZE_RTG / 2;
			*pfxXOffset &= ~(VIRTUAL_PIXELSIZE_RTG - 1);
		} else {
#endif
			*pfxXOffset += FNT_PIXELSIZE / 2;
			*pfxXOffset &= ~(FNT_PIXELSIZE - 1);
#ifdef FSCFG_SUBPIXEL
		}
#endif
#ifdef FSCFG_SUBPIXEL
		if (RunningSubPixel(globalGS) && ((rotationParity == arbitraryRotation) || ((rotationParity == evenMult90DRotation) == VerticalSPDirection(globalGS)))) {
			*pfxYOffset += VIRTUAL_PIXELSIZE_RTG / 2;
			*pfxYOffset &= ~(VIRTUAL_PIXELSIZE_RTG - 1);
		} else {
#endif
			*pfxYOffset += FNT_PIXELSIZE / 2;
			*pfxYOffset &= ~(FNT_PIXELSIZE - 1);
#ifdef FSCFG_SUBPIXEL
		}
#endif
	}
	if (!bSameTransformAsMaster)
	/* we need to scale back the offset in fixed FUnits */
	{
		scl_ScaleBack (&globalGS->scaleXChild,
				globalGS->ScaleFuncXChild,
				pfxXOffset,
				pfxXOffset,
				1 /* only one value to scale */);
		scl_ScaleBack (&globalGS->scaleYChild,
				globalGS->ScaleFuncYChild,
				pfxYOffset,
				pfxYOffset,
				1 /* only one value to scale */);
	}
}

FS_PUBLIC void  scl_CalcComponentAnchorOffset(
	fnt_ElementType *   pParentElement,     /* Parent Element       */
	uint16              usAnchorPoint1,     /* Parent Anchor Point  */
	fnt_ElementType *   pChildElement,      /* Child Element        */
	uint16              usAnchorPoint2,     /* Child Anchor Point   */
	F26Dot6 *           pfxXOffset,         /* OUT: X Offset        */
	F26Dot6 *           pfxYOffset)         /* Y Offset             */
{
	*pfxXOffset = pParentElement->x[usAnchorPoint1] - pChildElement->x[usAnchorPoint2];
	*pfxYOffset = pParentElement->y[usAnchorPoint1] - pChildElement->y[usAnchorPoint2];
}



FS_PUBLIC void  scl_SetSideBearingPoints(
	fnt_ElementType *   pElement,   /* Element                  */
	point *             pptLSB,     /* Left Side Bearing point  */
	point *             pptRSB)     /* Right Side Bearing point */
{
	uint16    usPhantomPointNumber;

	usPhantomPointNumber = LSBPOINTNUM(pElement);
	pElement->x[usPhantomPointNumber] = pptLSB->x;
	pElement->y[usPhantomPointNumber] = pptLSB->y;
	usPhantomPointNumber++;
	pElement->x[usPhantomPointNumber] = pptRSB->x;
	pElement->y[usPhantomPointNumber] = pptRSB->y;
}

FS_PUBLIC void  scl_SaveSideBearingPoints(
	fnt_ElementType *   pElement,   /* Element                  */
	point *             pptLSB,     /* Left Side Bearing point  */
	point *             pptRSB)     /* Right Side Bearing point */
{
	uint16    usPhantomPointNumber;

	usPhantomPointNumber = LSBPOINTNUM(pElement);
	pptLSB->x = pElement->x[usPhantomPointNumber];
	pptLSB->y = pElement->y[usPhantomPointNumber];
	usPhantomPointNumber++;
	pptRSB->x = pElement->x[usPhantomPointNumber];
	pptRSB->y = pElement->y[usPhantomPointNumber];
}

FS_PUBLIC void  scl_InitializeTwilightContours(
	fnt_ElementType *   pElement,       /* Element  */
	int16               sMaxPoints,
	int16               sMaxContours)
{
	pElement->sp[0] = 0;
	pElement->ep[0] = sMaxPoints - 1;
	pElement->nc = sMaxContours;
}

FS_PUBLIC void  scl_ZeroOutlineData(
	fnt_ElementType * pElement,     /* Element pointer  */
	uint16      usNumberOfPoints,
	uint16      usNumberOfContours)
{

	MEMSET (&pElement->x[0], 0, (size_t)usNumberOfPoints * sizeof(F26Dot6));
	MEMSET (&pElement->ox[0], 0, (size_t)usNumberOfPoints * sizeof(F26Dot6));
	MEMSET (&pElement->oox[0], 0, (size_t)usNumberOfPoints * sizeof(F26Dot6));

	MEMSET (&pElement->y[0], 0, (size_t)usNumberOfPoints * sizeof(F26Dot6));
	MEMSET (&pElement->oy[0], 0, (size_t)usNumberOfPoints * sizeof(F26Dot6));
	MEMSET (&pElement->ooy[0], 0, (size_t)usNumberOfPoints * sizeof(F26Dot6));

	MEMSET (&pElement->onCurve[0], 0, (size_t)usNumberOfPoints * sizeof(uint8));
	MEMSET (&pElement->f[0], 0, (size_t)usNumberOfPoints * sizeof(uint8));

	MEMSET (&pElement->sp[0], 0, (size_t)usNumberOfContours * sizeof(int16));
	MEMSET (&pElement->ep[0], 0, (size_t)usNumberOfContours * sizeof(int16));
}

FS_PUBLIC void scl_ZeroOutlineFlags(
	fnt_ElementType * pElement)     /* Element pointer  */
{
	MEMSET (&pElement->f[0], 0, (size_t)NUMBEROFTOTALPOINTS(pElement) * sizeof(uint8));
}

FS_PUBLIC void  scl_IncrementChildElement(
	fnt_ElementType * pChildElement,    /* Child Element pointer    */
	fnt_ElementType * pParentElement)   /* Parent Element pointer   */
{
	uint16          usParentNewStartPoint;

	if(pParentElement->nc != 0)
	{
		usParentNewStartPoint = LSBPOINTNUM(pParentElement);

		pChildElement->x = &pParentElement->x[usParentNewStartPoint];
		pChildElement->y = &pParentElement->y[usParentNewStartPoint];

		pChildElement->ox = &pParentElement->ox[usParentNewStartPoint];
		pChildElement->oy = &pParentElement->oy[usParentNewStartPoint];

		pChildElement->oox = &pParentElement->oox[usParentNewStartPoint];
		pChildElement->ooy = &pParentElement->ooy[usParentNewStartPoint];

		pChildElement->onCurve = &pParentElement->onCurve[usParentNewStartPoint];
		pChildElement->f = &pParentElement->f[usParentNewStartPoint];

		pChildElement->fc = &pParentElement->fc[pParentElement->nc];

#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
		pChildElement->pcr = &pParentElement->pcr[usParentNewStartPoint];
#endif

		pChildElement->sp = &pParentElement->sp[pParentElement->nc];
		pChildElement->ep = &pParentElement->ep[pParentElement->nc];

		pChildElement->nc = 0;
	}
	else
	{
		MEMCPY(pChildElement, pParentElement, sizeof(fnt_ElementType));
	}
}

FS_PUBLIC void  scl_UpdateParentElement(
	fnt_ElementType * pChildElement,    /* Child Element pointer    */
	fnt_ElementType * pParentElement)   /* Parent Element pointer   */
{
	uint16          usNumberOfParentPoints;
	uint32          ulPointIndex;

	if(pParentElement->nc != 0)
	{
		usNumberOfParentPoints = NUMBEROFCHARPOINTS(pParentElement);

		for(ulPointIndex = (uint32)(uint16)pParentElement->nc;
			ulPointIndex < (uint32)(uint16)pParentElement->nc + (uint32)(uint16)pChildElement->nc;
			ulPointIndex++)
		{
			pParentElement->sp[ulPointIndex] += (int16)usNumberOfParentPoints;
			pParentElement->ep[ulPointIndex] += (int16)usNumberOfParentPoints;
		}
	}

	pParentElement->nc += pChildElement->nc;
}

FS_PUBLIC uint32      scl_GetContourDataSize (
	 fnt_ElementType *  pElement)
{
	 uint16 usNumberOfPoints;
	 uint32 ulSize;

	 usNumberOfPoints = NUMBEROFCHARPOINTS(pElement);

	 ulSize =  sizeof( pElement->nc );
	 ulSize += sizeof( *pElement->sp ) * (size_t)pElement->nc;
	 ulSize += sizeof( *pElement->ep ) * (size_t)pElement->nc;
	 ulSize += sizeof( *pElement->x ) * (size_t)usNumberOfPoints;
	 ulSize += sizeof( *pElement->y ) * (size_t)usNumberOfPoints;
	 ulSize += sizeof( *pElement->onCurve ) * (size_t)usNumberOfPoints;

	 return( ulSize );
}

FS_PUBLIC void  scl_DumpContourData(
	 fnt_ElementType *  pElement,
	 uint8 **               ppbyOutline)
{
	 uint16 usNumberOfPoints;

	 usNumberOfPoints = NUMBEROFCHARPOINTS(pElement);

	 *((int16 *)*ppbyOutline) = pElement->nc;
	 *ppbyOutline += sizeof( pElement->nc   );

	 MEMCPY(*ppbyOutline, pElement->sp, (size_t)pElement->nc * sizeof( *pElement->sp ));
	 *ppbyOutline += (size_t)pElement->nc * sizeof( *pElement->sp );

	 MEMCPY(*ppbyOutline, pElement->ep, (size_t)pElement->nc * sizeof( *pElement->ep ));
	 *ppbyOutline += (size_t)pElement->nc * sizeof( *pElement->sp );

	 MEMCPY(*ppbyOutline, pElement->x, (size_t)usNumberOfPoints * sizeof(*pElement->x));
	 *ppbyOutline += (size_t)usNumberOfPoints * sizeof( *pElement->x );

	 MEMCPY(*ppbyOutline, pElement->y, (size_t)usNumberOfPoints * sizeof(*pElement->y));
	 *ppbyOutline += (size_t)usNumberOfPoints * sizeof( *pElement->y );

	 MEMCPY(*ppbyOutline, pElement->onCurve, (size_t)usNumberOfPoints * sizeof(*pElement->onCurve));
	 *ppbyOutline += (size_t)usNumberOfPoints * sizeof( *pElement->onCurve );

}

FS_PUBLIC void  scl_RestoreContourData(
	 fnt_ElementType *  pElement,
	 uint8 **               ppbyOutline)
{
	 uint16 usNumberOfPoints;

	 pElement->nc = *((int16 *)(*ppbyOutline));
	 *ppbyOutline += sizeof( int16 );

	 pElement->sp = (int16 *)(*ppbyOutline);
	 *ppbyOutline += (size_t)pElement->nc * sizeof( int16 );

	 pElement->ep = (int16 *)(*ppbyOutline);
	 *ppbyOutline += (size_t)pElement->nc * sizeof( int16 );

	 usNumberOfPoints = NUMBEROFCHARPOINTS(pElement);

	 pElement->x = (F26Dot6 *)(*ppbyOutline);
	 *ppbyOutline += (size_t)usNumberOfPoints * sizeof( F26Dot6 );

	 pElement->y = (F26Dot6 *)(*ppbyOutline);
	 *ppbyOutline += (size_t)usNumberOfPoints * sizeof( F26Dot6 );

	 pElement->onCurve = (uint8 *)(*ppbyOutline);
	 *ppbyOutline += (size_t)usNumberOfPoints * sizeof( uint8 );
}

FS_PUBLIC void  scl_ScaleAdvanceWidth (
	void *          pvGlobalGS,         /* GlobalGS             */
	vectorType *    AdvanceWidth,
	uint16          usNonScaledAW,
	 boolean          bPositiveSquare,
	uint16          usEmResolution,
	transMatrix *   trans)

{
	fnt_GlobalGraphicStateType *    globalGS;

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

	 if ( bPositiveSquare )
	{
		AdvanceWidth->x = (Fixed)ShortMulDiv( (int32)globalGS->fxMetricScalarX, (int16)usNonScaledAW, (int16)usEmResolution );
        if (AdvanceWidth->x != 0 /* B.St. */ && globalGS->uBoldSimulHorShift != 0 /* B.St. */) /* we don't increase the width of a zero width glyph, problem with indic script */
		    AdvanceWidth->x += ((Fixed)1 << 16); /* we increase the widht by one pixel regardless of size for backwards compatibility */
	}
	else
	{
		AdvanceWidth->x = FixRatio( (int16)usNonScaledAW, (int16)usEmResolution );
        if ((globalGS->fxMetricScalarX != ONEFIX) && (globalGS->uBoldSimulHorShift != 0))
        {
            AdvanceWidth->x = FixMul(AdvanceWidth->x, globalGS->fxMetricScalarX);
            if (AdvanceWidth->x != 0 /* B.St. */ && globalGS->uBoldSimulHorShift != 0 /* B.St. */) /* we don't increase the width of a zero width glyph, problem with indic script */
		        AdvanceWidth->x += ((Fixed)1 << 16); /* we increase the widht by one pixel regardless of size for backwards compatibility */
            AdvanceWidth->x = FixDiv(AdvanceWidth->x, globalGS->fxMetricScalarX);
        }
        else
        {
            if (AdvanceWidth->x != 0 /* B.St. */ && globalGS->uBoldSimulHorShift != 0 /* B.St. */) /* we don't increase the width of a zero width glyph, problem with indic script */
		        AdvanceWidth->x += ((Fixed)1 << 16); /* we increase the widht by one pixel regardless of size for backwards compatibility */
        }
		mth_FixXYMul( &AdvanceWidth->x, &AdvanceWidth->y, trans );
	}
}

FS_PUBLIC void  scl_ScaleAdvanceHeight (
	void *          pvGlobalGS,         /* GlobalGS             */
	vectorType *    AdvanceHeight,
	uint16          usNonScaledAH,
	 boolean          bPositiveSquare,
	uint16          usEmResolution,
	transMatrix *   trans)

{
	fnt_GlobalGraphicStateType *    globalGS;

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

	 if ( bPositiveSquare )
	{
		AdvanceHeight->y = (Fixed)ShortMulDiv( (int32)globalGS->fxMetricScalarY, (int16)usNonScaledAH, (int16)usEmResolution );
        if (AdvanceHeight->y != 0) /* we don't increase the width of a zero width glyph, problem with indic script */
		    AdvanceHeight->y += ((Fixed)1 << 16); /* we increase the widht by one pixel regardless of size for backwards compatibility */
	}
	else
	{
		AdvanceHeight->y = FixRatio( (int16)usNonScaledAH, (int16)usEmResolution );
        if (AdvanceHeight->y != 0) /* we don't increase the width of a zero width glyph, problem with indic script */
		    AdvanceHeight->y += ((Fixed)1 << 16); /* we increase the widht by one pixel regardless of size for backwards compatibility */
		mth_FixXYMul( &AdvanceHeight->x, &AdvanceHeight->y, trans );
	}
}

FS_PUBLIC void  scl_ScaleVerticalMetrics (
	void *          pvGlobalGS,
	uint16          usNonScaledAH,
	int16           sNonScaledTSB,
	boolean         bPositiveSquare,
	uint16          usEmResolution,
	transMatrix *   trans,
	vectorType *    pvecAdvanceHeight,
	vectorType *    pvecTopSideBearing
)
{
	fnt_GlobalGraphicStateType *    globalGS;

	if ( bPositiveSquare )
	{
	    globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;
		pvecAdvanceHeight->y = (Fixed)ShortMulDiv(
		    (int32)globalGS->fxMetricScalarY, 
		    (int16)usNonScaledAH, 
		    (int16)usEmResolution );
		
		pvecTopSideBearing->y = (Fixed)ShortMulDiv(
		    (int32)globalGS->fxMetricScalarY, 
		    sNonScaledTSB, 
		    (int16)usEmResolution );
	}
	else
	{
		pvecAdvanceHeight->y = FixRatio( (int16)usNonScaledAH, (int16)usEmResolution );
		mth_FixXYMul( &pvecAdvanceHeight->x, &pvecAdvanceHeight->y, trans );

		pvecTopSideBearing->y = FixRatio( sNonScaledTSB, (int16)usEmResolution );
		mth_FixXYMul( &pvecTopSideBearing->x, &pvecTopSideBearing->y, trans );
	}
}


FS_PUBLIC void  scl_CalcLSBsAndAdvanceWidths(
	fnt_ElementType *   pElement,
	F26Dot6             f26XMin,
	F26Dot6             f26YMax,
	point *             devAdvanceWidth,
	point *             devLeftSideBearing,
	point *             LeftSideBearing,
	point *             devLeftSideBearingLine,
	point *             LeftSideBearingLine)
{
	scl_CalcDevAdvanceWidth(pElement, devAdvanceWidth);

	devLeftSideBearing->x = f26XMin - pElement->x[LSBPOINTNUM(pElement)];
	devLeftSideBearing->y = f26YMax - pElement->y[LSBPOINTNUM(pElement)];

	LeftSideBearing->x = pElement->x[LEFTEDGEPOINTNUM(pElement)];
	LeftSideBearing->x -= pElement->x[ORIGINPOINTNUM(pElement)];
	LeftSideBearing->y = f26YMax - pElement->y[LEFTEDGEPOINTNUM(pElement)];
	LeftSideBearing->y -= pElement->y[ORIGINPOINTNUM(pElement)];

	*devLeftSideBearingLine = *devLeftSideBearing;
	*LeftSideBearingLine = *LeftSideBearing;

}

FS_PUBLIC void  scl_CalcDevAdvanceWidth(
	fnt_ElementType *   pElement,
	point *             devAdvanceWidth)

{
	devAdvanceWidth->x = pElement->x[RSBPOINTNUM(pElement)]; 
	devAdvanceWidth->x -= pElement->x[LSBPOINTNUM(pElement)];
	devAdvanceWidth->y = pElement->y[RSBPOINTNUM(pElement)]; 
	devAdvanceWidth->y -= pElement->y[LSBPOINTNUM(pElement)];
}

FS_PUBLIC void  scl_CalcTSBsAndAdvanceHeights(
	fnt_ElementType *   pElement,
	F26Dot6             f26XMin,
	F26Dot6             f26YMax,
	point *             devAdvanceHeight,
	point *             devTopSideBearing,
	point *             TopSideBearing,
	point *             devTopSideBearingLine,
	point *             TopSideBearingLine)
{
	scl_CalcDevAdvanceHeight(pElement, devAdvanceHeight);

	devTopSideBearing->x = f26XMin - pElement->x[TOPSBPOINTNUM(pElement)];
	devTopSideBearing->y = f26YMax - pElement->y[TOPSBPOINTNUM(pElement)];

	TopSideBearing->x = f26XMin - pElement->x[TOPEDGEPOINTNUM(pElement)];
	TopSideBearing->x -= pElement->x[TOPORIGINPOINTNUM(pElement)];
	TopSideBearing->y = pElement->y[TOPEDGEPOINTNUM(pElement)];
	TopSideBearing->y -= pElement->y[TOPORIGINPOINTNUM(pElement)];

	*devTopSideBearingLine = *devTopSideBearing;
	*TopSideBearingLine = *TopSideBearing;

}

FS_PUBLIC void  scl_CalcDevAdvanceHeight(
	fnt_ElementType *   pElement,
	point *             devAdvanceHeight)

{
	devAdvanceHeight->x = pElement->x[TOPSBPOINTNUM(pElement)]; 
	devAdvanceHeight->x -= pElement->x[BOTTOMSBPOINTNUM(pElement)];
	devAdvanceHeight->y = pElement->y[TOPSBPOINTNUM(pElement)]; 
	devAdvanceHeight->y -= pElement->y[BOTTOMSBPOINTNUM(pElement)];
}


FS_PUBLIC void  scl_QueryPPEM(
	void *      pvGlobalGS,
	uint16 *    pusPPEM)
{
	fnt_GlobalGraphicStateType *    globalGS;

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

	*pusPPEM = globalGS->pixelsPerEm;
}

/*  Return ppem in X and Y directions for sbits */

FS_PUBLIC void  scl_QueryPPEMXY(
	void *      pvGlobalGS,
	uint16 *    pusPPEMX,
	uint16 *    pusPPEMY)
{
	fnt_GlobalGraphicStateType *    globalGS;

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

	*pusPPEMX = (uint16)ROUNDFIXTOINT(globalGS->interpScalarX);
	*pusPPEMY = (uint16)ROUNDFIXTOINT(globalGS->interpScalarY);
}


FS_PUBLIC void scl_45DegreePhaseShift (
	fnt_ElementType *   pElement)
{
  F26Dot6 * x;
  int16     count;

  x = pElement->x;
  count = (int16)NUMBEROFCHARPOINTS(pElement) - 1;
  for (; count >= 0; --count)
  {
	(*x)++;
	++x;
  }
}

/*
 *  scl_PostTransformGlyph              <3>
 */
FS_PUBLIC void  scl_PostTransformGlyph (
	void *              pvGlobalGS,         /* GlobalGS             */
	fnt_ElementType *   pElement,
	transMatrix *       trans)
{
	fnt_GlobalGraphicStateType *    globalGS;

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

	if (globalGS->bHintAtEmSquare)
	{
		mth_IntelMul (
			(int32)NUMBEROFTOTALPOINTS (pElement),
			pElement->x,
			pElement->y,
			trans,
			globalGS->interpScalarX,
			globalGS->interpScalarY); 
	}
	else
	{
		mth_IntelMul (
			(int32)NUMBEROFTOTALPOINTS (pElement),
			pElement->x,
			pElement->y,
			trans,
	/*        globalGS->interpScalarX,
			globalGS->interpScalarY); */
			globalGS->fxMetricScalarX,
			globalGS->fxMetricScalarY);
	}
}

/*
 *  scl_ApplyTranslation              
 */
FS_PUBLIC void  scl_ApplyTranslation (
	fnt_ElementType *   pElement,
	transMatrix *       trans,
	boolean             bUseHints,
	boolean             bHintAtEmSquare
#ifdef FSCFG_SUBPIXEL
	,boolean             bSubPixel
#endif // FSCFG_SUBPIXEL
   )
{
	int32 ulPointIndex;
	F26Dot6 xShift, yShift;

	/* transform from 16.16 to 26.6 */
	xShift = (trans->transform[0][2] + 0x200) >> 10;
	yShift = (trans->transform[1][2] + 0x200) >> 10;

#ifdef FSCFG_SUBPIXEL
	if (bSubPixel)
	{
		xShift = xShift * RGB_OVERSCALE;
    }
#endif

	/* lsb point should be moved to (0,0) so that we can get correct bitmap bounding box when overscaling */
	xShift -= pElement->x[LSBPOINTNUM(pElement)];
	yShift -= pElement->y[LSBPOINTNUM(pElement)];

	
	if (bUseHints && !bHintAtEmSquare) {
#ifdef FSCFG_SUBPIXEL
		if (bSubPixel) {
			/* We want to round to a virtual pixel boundary when hinted */ 
			xShift += VIRTUAL_PIXELSIZE_RTG/2; 
			xShift &= ~(VIRTUAL_PIXELSIZE_RTG - 1); 
		} else {
#endif
			/* We want to round to a pixel boundary when hinted */ 
			xShift += FNT_PIXELSIZE/2; 
			xShift &= ~(FNT_PIXELSIZE - 1); 
#ifdef FSCFG_SUBPIXEL
		}
#endif
	}

	if (xShift != 0 || yShift != 0)
	{
		for(ulPointIndex = 0;
				ulPointIndex < NUMBEROFTOTALPOINTS(pElement);
				ulPointIndex++)
		{
			pElement->x[ulPointIndex] += xShift;
			pElement->y[ulPointIndex] += yShift;
		}
	}

}
/*
 *      scl_LocalPostTransformGlyph                             <3>
 *
 * (1) Inverts the stretch from the CTM
 * (2) Applies the local transformation passed in in the trans parameter
 * (3) Applies the global stretch from the root CTM
 * (4) Restores oox, ooy, oy, ox, and f.
 */
FS_PUBLIC void  scl_LocalPostTransformGlyph(fnt_ElementType * pElement, transMatrix *trans)
{
	int32 lCount;

	lCount = (int32)NUMBEROFTOTALPOINTS(pElement);

	mth_IntelMul (lCount, pElement->x, pElement->y, trans, ONEFIX, ONEFIX);
}

#ifdef FSCFG_SUBPIXEL

FS_PUBLIC void  scl_ScaleDownFromSubPixelOverscale (
	fnt_ElementType *   pElement)   /* Element  */
{
	int32 ulPointIndex;
	for(ulPointIndex = 0;
			ulPointIndex < NUMBEROFTOTALPOINTS(pElement);
			ulPointIndex++)
	{
		pElement->ox[ulPointIndex] = ROUND_RGB_OVERSCALE(pElement->x[ulPointIndex]);
	}
}

FS_PUBLIC void  scl_ScaleToCompatibleWidth (
	fnt_ElementType *   pElement,  /* Element  */
    Fixed   fxCompatibleWidthScale)  
{
	int32 ulPointIndex;

	for(ulPointIndex = 0;
			ulPointIndex < NUMBEROFTOTALPOINTS(pElement);
			ulPointIndex++)
	{
		pElement->x[ulPointIndex] = FixMul(pElement->x[ulPointIndex], fxCompatibleWidthScale);
	}
}


FS_PUBLIC void  scl_AdjustCompatibleMetrics (
	fnt_ElementType *   pElement,  /* Element  */
    F26Dot6   horTranslation,
    F26Dot6   newDevAdvanceWidthX)
{
	int32 ulPointIndex;

	for(ulPointIndex = 0;
			ulPointIndex < NUMBEROFCHARPOINTS(pElement);
			ulPointIndex++)
	{
		pElement->x[ulPointIndex] += horTranslation;
	}
    pElement->x[RSBPOINTNUM(pElement)] = pElement->x[LSBPOINTNUM(pElement)] + newDevAdvanceWidthX;
}


FS_PUBLIC void  scl_CalcDevHorMetrics(
	fnt_ElementType *   pElement,
	F26Dot6 *           pDevAdvanceWidthX,
	F26Dot6 *           pDevLeftSideBearingX,
	F26Dot6 *           pDevRightSideBearingX)
{
	int32 ulPointIndex;
	F26Dot6 fxMaxX;             /* for bounding box left, right */

	*pDevLeftSideBearingX = LONG_MAX;     /* default bounds limits */
	fxMaxX = LONG_MIN;

	*pDevAdvanceWidthX = pElement->x[RSBPOINTNUM(pElement)]; 
	*pDevAdvanceWidthX -= pElement->x[LSBPOINTNUM(pElement)];

	for(ulPointIndex = 0;
			ulPointIndex < NUMBEROFCHARPOINTS(pElement);
			ulPointIndex++)
	{
		if (pElement->x[ulPointIndex] > fxMaxX)
			fxMaxX = pElement->x[ulPointIndex];
		if (pElement->x[ulPointIndex] < *pDevLeftSideBearingX)
			*pDevLeftSideBearingX = pElement->x[ulPointIndex];
	}

    FS_ASSERT(*pDevLeftSideBearingX != LONG_MAX, "scl_CalcDevHorMetrics called on an empty glyph\n");

    *pDevRightSideBearingX = *pDevAdvanceWidthX - fxMaxX;

}

FS_PUBLIC void  scl_CalcDevNatHorMetrics(
	fnt_ElementType *   pElement,
	F26Dot6 *           pDevAdvanceWidthX,
	F26Dot6 *           pDevLeftSideBearingX,
	F26Dot6 *           pDevRightSideBearingX,
	F26Dot6 *           pNatAdvanceWidthX,
	F26Dot6 *           pNatLeftSideBearingX,
	F26Dot6 *           pNatRightSideBearingX)
{
	int32 ulPointIndex;

	*pDevLeftSideBearingX = LONG_MAX; *pDevRightSideBearingX = LONG_MIN;
	*pNatLeftSideBearingX = LONG_MAX; *pNatRightSideBearingX = LONG_MIN;
	
	*pDevAdvanceWidthX = pElement->x[RSBPOINTNUM(pElement)]  - pElement->x[LSBPOINTNUM(pElement)];
	*pNatAdvanceWidthX = pElement->ox[RSBPOINTNUM(pElement)] - pElement->ox[LSBPOINTNUM(pElement)];

	for(ulPointIndex = 0; ulPointIndex < NUMBEROFCHARPOINTS(pElement); ulPointIndex++) {
		if (pElement->x[ulPointIndex]  > *pDevRightSideBearingX) *pDevRightSideBearingX = pElement->x[ulPointIndex];
		if (pElement->x[ulPointIndex]  < *pDevLeftSideBearingX)  *pDevLeftSideBearingX  = pElement->x[ulPointIndex];
		if (pElement->ox[ulPointIndex] > *pNatRightSideBearingX) *pNatRightSideBearingX = pElement->ox[ulPointIndex];
		if (pElement->ox[ulPointIndex] < *pNatLeftSideBearingX)  *pNatLeftSideBearingX  = pElement->ox[ulPointIndex];
	}

    FS_ASSERT(*pDevLeftSideBearingX != LONG_MAX, "scl_CalcDevHorMetrics called on an empty glyph\n");

    *pDevRightSideBearingX = *pDevAdvanceWidthX - *pDevRightSideBearingX;
    *pNatRightSideBearingX = *pNatAdvanceWidthX - *pNatRightSideBearingX;
} // scl_CalcDevNatHorMetrics

#endif // FSCFG_SUBPIXEL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\fs\scale.h ===
/*

	Copyright:  (c) 1992-1999. Microsoft Corporation, all rights reserved.

	Change History (most recent first):

				7/10/99  BeatS	Add support for native SP fonts, vertical RGB
	   <1>     02/21/97    CB   claudebe, scaled component in composite glyphs
	   <1>     12/14/95    CB   add private phantom points for vertical positionning
*/

/* total number of phantom points */

typedef enum { evenMult90DRotation = 0, oddMult90DRotation, arbitraryRotation } RotationParity;

#define PHANTOMCOUNT 8

FS_PUBLIC ErrorCode   scl_InitializeScaling(
	void *          pvGlobalGS,             /* GlobalGS                 */
	boolean         bIntegerScaling,        /* Integer Scaling Flag     */
	transMatrix *   trans,                  /* Current Transformation   */
	uint16          usUpem,                 /* Current units per Em     */
	Fixed           fxPointSize,            /* Current point size       */
	int16           sXResolution,           /* Current X Resolution     */
	int16           sYResolution,           /* Current Y Resolution     */
	uint16          usEmboldWeightx,     /* scaling factor in x between 0 and 40 (20 means 2% fo the height) */
	uint16          usEmboldWeighty,      /* scaling factor in y between 0 and 40 (20 means 2% fo the height) */
	int16           sWinDescender,
	int32           lDescDev,               /* descender in device metric, used for clipping */
	int16 *			psBoldSimulHorShift,   /* shift for emboldening simulation, horizontally */
	int16 *			psBoldSimulVertShift,   /* shift for emboldening simulation, vertically */
	boolean			bHintAtEmSquare,
	uint32 *        pulPixelsPerEm);        /* OUT: Pixels Per Em       */

FS_PUBLIC void scl_InitializeChildScaling(
	void *          pvGlobalGS,             /* GlobalGS                 */
	transMatrix     CurrentTMatrix,                  /* Current Transformation   */
	uint16          usUpem);                 /* Current units per Em     */

FS_PUBLIC void  scl_SetHintFlags(
	void *              pvGlobalGS,
	boolean				bHintForGray
#ifdef FSCFG_SUBPIXEL
	,uint16			flHintForSubPixel
#endif // FSCFG_SUBPIXEL
    );

FS_PUBLIC void  scl_GetCVTPtr(
	void *      pvGlobalGS,
	F26Dot6 **  pfxCVT);

FS_PUBLIC void  scl_ScaleCVT (
	void *      pvGlobalGS,
	F26Dot6 *   pfxCVT);

FS_PUBLIC void  scl_CalcOrigPhantomPoints(
	fnt_ElementType *   pElement,       /* Element                      */
	BBOX *              bbox,           /* Bounding Box                 */
	int16               sNonScaledLSB,  /* Non-scaled Left Side Bearing */
	int16               sNonScaledTSB,  /* Non-scaled Top Side Bearing  */
	uint16              usNonScaledAW,  /* Non-scaled Advance Width     */
	uint16              usNonScaledAH); /* Non-scaled Advance Height    */

FS_PUBLIC void  scl_ScaleOldCharPoints(
	fnt_ElementType *   pElement,   /* Element  */
	void *              pvGlobalGS);/* GlobalGS */

FS_PUBLIC void  scl_ScaleOldPhantomPoints(
	fnt_ElementType *   pElement,   /* Element  */
	void *              pvGlobalGS);/* GlobalGS */

FS_PUBLIC void  scl_ScaleBackCurrentCharPoints(
	fnt_ElementType *   pElement,   /* Element  */
	void *              pvGlobalGS);/* GlobalGS */

FS_PUBLIC void  scl_ScaleBackCurrentPhantomPoints(
	fnt_ElementType *   pElement,   /* Element  */
	void *              pvGlobalGS);/* GlobalGS */

FS_PUBLIC void  scl_ScaleFixedCurrentCharPoints(
	fnt_ElementType *   pElement,   /* Element  */
	void *              pvGlobalGS);/* GlobalGS */

FS_PUBLIC void  scl_ScaleFixedCurrentPhantomPoints(
	fnt_ElementType *   pElement,   /* Element  */
	void *              pvGlobalGS);/* GlobalGS */

FS_PUBLIC void  scl_OriginalCharPointsToCurrentFixedFUnits(
	fnt_ElementType *   pElement);/* Element */

FS_PUBLIC void  scl_OriginalPhantomPointsToCurrentFixedFUnits(
	fnt_ElementType *   pElement);/* Element */

FS_PUBLIC void  scl_AdjustOldCharSideBearing(
	fnt_ElementType* pElement
#ifdef FSCFG_SUBPIXEL
	, void* pvGlobalGS
#endif
	);  /* Element  */

FS_PUBLIC void  scl_AdjustOldPhantomSideBearing(
	fnt_ElementType* pElement
#ifdef FSCFG_SUBPIXEL
	, void* pvGlobalGS
#endif
	);  /* Element  */

FS_PUBLIC void  scl_AdjustOldSideBearingPoints(
	fnt_ElementType* pElement
#ifdef FSCFG_SUBPIXEL
	, void* pvGlobalGS
#endif
	);  /* Element  */

FS_PUBLIC void  scl_CopyOldCharPoints(
	fnt_ElementType *           pElement);  /* Element  */

FS_PUBLIC void  scl_CopyCurrentCharPoints(
	fnt_ElementType *           pElement);  /* Element  */

FS_PUBLIC void  scl_CopyCurrentPhantomPoints(
	fnt_ElementType *           pElement);  /* Element  */

FS_PUBLIC void  scl_RoundCurrentSideBearingPnt(
	fnt_ElementType *   pElement,   /* Element  */
	void *              pvGlobalGS, /* GlobalGS */
	uint16              usEmResolution);

FS_PUBLIC void  scl_CalcComponentOffset(
	void *      pvGlobalGS,         /* GlobalGS             */
	int16       sXOffset,           /* IN: X Offset         */
	int16       sYOffset,           /* Y Offset             */
	boolean     bRounding,          /* Rounding Indicator   */
	boolean		bSameTransformAsMaster, /* local transf. same as master transf. */
	boolean     bScaleCompositeOffset,  /* does the component offset need to be scaled Apple/MS */
	transMatrix mulT,                   /* Transformation matrix for composite              */
#ifdef FSCFG_SUBPIXEL
	RotationParity	rotationParityParity,
#endif
	F26Dot6 *   pfxXOffset,         /* OUT: X Offset        */
	F26Dot6 *   pfxYOffset);        /* Y Offset             */

FS_PUBLIC void  scl_CalcComponentAnchorOffset(
	fnt_ElementType *   pParentElement,     /* Parent Element       */
	uint16              usAnchorPoint1,     /* Parent Anchor Point  */
	fnt_ElementType *   pChildElement,      /* Child Element        */
	uint16              usAnchorPoint2,     /* Child Anchor Point   */
	F26Dot6 *           pfxXOffset,         /* OUT: X Offset        */
	F26Dot6 *           pfxYOffset);        /* Y Offset             */


FS_PUBLIC void scl_ShiftCurrentCharPoints (
	fnt_ElementType *   pElement,
	F26Dot6             xShift,
	F26Dot6             yShift);

FS_PUBLIC void  scl_SetSideBearingPoints(
	fnt_ElementType *   pElement,   /* Element                  */
	point *             pptLSB,     /* Left Side Bearing point  */
	point *             pptRSB);    /* Right Side Bearing point */

FS_PUBLIC void  scl_SaveSideBearingPoints(
	fnt_ElementType *   pElement,   /* Element                  */
	point *             pptLSB,     /* Left Side Bearing point  */
	point *             pptRSB);    /* Right Side Bearing point */

FS_PUBLIC void  scl_InitializeTwilightContours(
	fnt_ElementType *   pElement,
	int16               sMaxPoints,
	int16               sMaxContours);

FS_PUBLIC void  scl_ZeroOutlineData(
	fnt_ElementType *   pElement,           /* Element              */
	uint16              usNumberOfPoints,   /* Number of Points     */
	uint16              usNumberOfContours);/* Number of Contours   */

FS_PUBLIC void scl_ZeroOutlineFlags(
	fnt_ElementType * pElement);            /* Element pointer  */

FS_PUBLIC void  scl_IncrementChildElement(
	fnt_ElementType * pChildElement,    /* Child Element pointer    */
	fnt_ElementType * pParentElement);  /* Parent Element pointer   */

FS_PUBLIC void  scl_UpdateParentElement(
	fnt_ElementType * pChildElement,    /* Child Element pointer    */
	fnt_ElementType * pParentElement);  /* Parent Element pointer   */

FS_PUBLIC uint32      scl_GetContourDataSize (
	 fnt_ElementType *  pElement);

FS_PUBLIC void  scl_DumpContourData(
	 fnt_ElementType *  pElement,
	 uint8 **               pbyOutline);

FS_PUBLIC void  scl_RestoreContourData(
	 fnt_ElementType *  pElement,
	 uint8 **               ppbyOutline);

FS_PUBLIC void  scl_ScaleAdvanceWidth (
	void *          pvGlobalGS,         /* GlobalGS             */
	vectorType *    AdvanceWidth,
	uint16          usNonScaledAW,
	 boolean          bPositiveSquare,
	uint16          usEmResolution,
	transMatrix *   trans);

FS_PUBLIC void  scl_ScaleAdvanceHeight (
	void *          pvGlobalGS,         /* GlobalGS             */
	vectorType *    AdvanceHeight,
	uint16          usNonScaledAH,
	 boolean          bPositiveSquare,
	uint16          usEmResolution,
	transMatrix *   trans);

FS_PUBLIC void  scl_ScaleVerticalMetrics (
	void *          pvGlobalGS,
	uint16          usNonScaledAH,
	int16           sNonScaledTSB,
	boolean         bPositiveSquare,
	uint16          usEmResolution,
	transMatrix *   trans,
	vectorType *    pvecAdvanceHeight,
	vectorType *    pvecTopSideBearing);

FS_PUBLIC void  scl_CalcLSBsAndAdvanceWidths(
	fnt_ElementType *   pElement,
	F26Dot6             f26XMin,
	F26Dot6             f26YMax,
	point *             devAdvanceWidth,
	point *             devLeftSideBearing,
	point *             LeftSideBearing,
	point *             devLeftSideBearingLine,
	point *             LeftSideBearingLine);

FS_PUBLIC void  scl_CalcTSBsAndAdvanceHeights(
	fnt_ElementType *   pElement,
	F26Dot6             f26XMin,
	F26Dot6             f26YMax,
	point *             devAdvanceHeight,
	point *             devTopSideBearing,
	point *             TopSideBearing,
	point *             devTopSideBearingLine,
	point *             TopSideBearingLine);

FS_PUBLIC void  scl_CalcDevAdvanceWidth(
	fnt_ElementType *   pElement,
	point *             devAdvanceWidth);

FS_PUBLIC void  scl_CalcDevAdvanceHeight(
	fnt_ElementType *   pElement,
	point *             devAdvanceHeight);

FS_PUBLIC void  scl_QueryPPEM(
	void *      pvGlobalGS,
	uint16 *    pusPPEM);

FS_PUBLIC void  scl_QueryPPEMXY(
	void *      pvGlobalGS,
	uint16 *    pusPPEMX,
	uint16 *    pusPPEMY);

FS_PUBLIC void scl_45DegreePhaseShift (
	fnt_ElementType *   pElement);

FS_PUBLIC void  scl_PostTransformGlyph (
	void *              pvGlobalGS,         /* GlobalGS             */
	fnt_ElementType *   pElement,
	transMatrix *       trans);

FS_PUBLIC void  scl_ApplyTranslation (
	fnt_ElementType *   pElement,
	transMatrix *       trans,
	boolean             bUseHints,
	boolean             bHintAtEmSquare
#ifdef FSCFG_SUBPIXEL
	,boolean             bSubPixel
#endif // FSCFG_SUBPIXEL
    );

FS_PUBLIC void  scl_LocalPostTransformGlyph(fnt_ElementType * pElement, transMatrix *trans);

#ifdef FSCFG_SUBPIXEL
FS_PUBLIC void  scl_ScaleDownFromSubPixelOverscale (
	fnt_ElementType *   pElement);   /* Element  */

FS_PUBLIC void  scl_ScaleToCompatibleWidth (
	fnt_ElementType *   pElement,  /* Element  */
    Fixed   fxCompatibleWidthScale);  

FS_PUBLIC void  scl_AdjustCompatibleMetrics (
	fnt_ElementType *   pElement,  /* Element  */
    F26Dot6   horTranslation,
    F26Dot6   newDevAdvanceWidthX);  

FS_PUBLIC void  scl_CalcDevHorMetrics(
	fnt_ElementType *   pElement,
	F26Dot6 *           pDevAdvanceWidthX,
	F26Dot6 *           pDevLeftSideBearingX,
	F26Dot6 *           pDevRightSideBearingX);

FS_PUBLIC void  scl_CalcDevNatHorMetrics(
	fnt_ElementType *   pElement,
	F26Dot6 *           pDevAdvanceWidthX,
	F26Dot6 *           pDevLeftSideBearingX,
	F26Dot6 *           pDevRightSideBearingX,
	F26Dot6 *           pNatAdvanceWidthX,
	F26Dot6 *           pNatLeftSideBearingX,
	F26Dot6 *           pNatRightSideBearingX);

#endif // FSCFG_SUBPIXEL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\fs\interp.c ===
/*********************************************************************

	  interp.c -- TT Rasterizer Interpreter Module

	  Copyright:  (c) 1987-1990, 1992 by Apple Computer, Inc., all rights reserved.
				  (c) 1989-1999. Microsoft Corporation, all rights reserved.

	   7/10/99  BeatS	 62 Add support for native SP fonts, vertical RGB
	   4/01/99  BeatS	 61 Implement alternative interpretation of TT instructions for SP
	  10/14/97  claudebe 60 ClaudeBe, allowing a trace function to know if in FontProgram
							access to unitialized data
	  04/29/97  claudebe 59 ClaudeBe, catching illegal recursion and infinite loops
	  02/21/97  claudebe 58 ClaudeBe, scaled component in composite glyphs
	   2/05/96  claudebe 57 compfont for itpr_MD, wrong zone pointer
	   2/05/96  claudebe 56 GetInfo return HintForGray information
	   8/12/94  deanb  55   orphan routine CHECK_STATE deleted
	   2/09/94  deanb  54   RASTERIZER_VERSION defined for GETINFO
	  12/17/93  deanb  53   CHECK_POINT zone corrected in MIRP
	  12/08/93  deanb  52   itrp_SCANTYPE enabled for smart dropout control
	   9/15/93  deanb  51   InnerTraceEx double call fixed; iOpCode -> lOpCode
	   7/29/93  deanb  50   ALIGNPTS, SHE fixed; InnerTraceExecute saves first
	   7/12/93  deanb  49   itrp_IllegalInstruction works
	   6/28/93  deanb  48   gbyPushTable made const
	   2/16/93  deanb  47   fxUnRounded set after check single width
	   2/15/93  deanb  46   fall back to MIRPG when using single width
	   2/15/93  deanb  45   vector defaults for FONTPROGRAM, stat back
	   2/12/93  deanb  44   delete stat code
	   2/12/93  deanb  43   cleanup MSIRP & itrp_Execute
	   2/12/93  deanb  42   branch itrp_IP on MovePoint
	   2/11/93  deanb  41   use c8 register calling convetions
	   2/11/93  deanb  40   switch to Microsoft C ver 8
	   2/09/93  deanb  39   skipPushData inline in itrp_IF
	   2/09/93  deanb  38   do fast MIRP's with if statments
	   2/09/93  deanb  37   remove fast MDRPX and MIRPY routines
	   2/09/93  deanb  36   fast MDRPX and MIRPY routines
	   2/08/93  deanb  35   cleanup MIRPs, combine if statments
	   2/08/93  deanb  34   dual rounding with 6 ptr init values
	   2/08/93  deanb  33   IUP inner loop pointer check
	   2/08/93  deanb  32   repair skipPushData for npushw
	   2/05/93  deanb  31   check for fxHintedDelta = 0
	   2/05/93  deanb  30   use roundFuncPtr in fast MIRP's
	   2/05/93  deanb  29   itrp_SWAP done in place
	   2/05/93  deanb  28   fntMirpFunc defined for MIRPG/X/Y
	   2/05/93  deanb  27   iOpCode passed in to all functions
	   2/05/93  deanb  26   use instr ptr for param and return
	   2/04/93  deanb  25   pull oldRange out of itrp_IP loops
	   2/04/93  deanb  24   movePoint check for proj.x/y = 1
	   2/03/93  deanb  23   table driven skipPushData
	   2/03/93  deanb  22   zero based Unary Operand pointers
	   2/01/93  deanb  21   split out SetRoundState
	   2/01/93  deanb  20   eliminate OpCode assignemnt, registers
	   2/01/93  deanb  19   bump Normalize limit up to 0x20000000L
	   1/29/93  deanb  18   add SuperRound MIRPG fallback
	   1/29/93  deanb  17   fast MIRPX and MIRPY routines
	   1/27/93  deanb  16   single rounding routines restored
	   1/27/93  deanb  15   innerExecute tune up
	   1/27/93  deanb  14   rounding routines for engine/no engine
	   1/27/93  deanb  13   repair itrp_Normalize for BIG vectors
	   1/26/93  deanb  12   split out SPVTCA and SFVTCA
	   1/26/93  deanb  11   clean up itrp_IP
	   1/26/93  deanb  10   return IUP to old start/end calc
	   1/25/93  deanb   9   use pointers in IUP loops
	   1/25/93  deanb   8   major rewrite of itrp_IUP
	   1/25/93  deanb   7   rewrite itrp_Normalize
	   1/22/93  deanb   6   split and do Unary Operands in place
	   1/22/93  deanb   5   do Binary Operands in place
	   1/22/93  deanb   4   split out BinaryOperand
	   1/22/93  deanb   3   split out PUSHB1 and PUSHW1
	   1/22/93  deanb   2   split out PushSomeBytes/Words
	   1/22/93  deanb   1   split out SRP0-2, LLOOP, POP
	   1/22/93  deanb   0   STAT card timing added
	   1/22/93  deanb       dead code/comments moved to history.fnt
 
**********************************************************************/

#define FSCFG_INTERNAL

#include "fscdefs.h"
#include "fontmath.h"
#include "sfnt.h"
#include "fnt.h"
#include "interp.h"
#include "fserror.h"

#include "stat.h"                   /* for STAT card timing only */

#include <stdio.h>

#ifdef SEGMENT_LINK
#pragma segment FNT_C
#endif

/* perfect spot size (Fixed) */
#ifndef FIXEDSQRT2
#define FIXEDSQRT2 0x00016A0A
#endif

#ifdef FSCFG_SUBPIXEL
#define RASTERIZER_VERSION  37      /* MS reserved values 33 - 64 */
#else
#define RASTERIZER_VERSION  35      /* MS reserved values 33 - 64 */
#endif // FSCFG_SUBPIXEL
									/* 33 = Rasterizer v1.5 */
									/* 34 = Rasterizer v1.6 */
									/* 35 = Rasterizer v1.7 */
									/* 36 = Rasterizer v1.6+, Windows CE, SubPixel */
									/* 37 = Rasterizer v1.8, Windows 2000, SubPixel */

#ifdef FSCFG_SUBPIXEL
	// the following are 9 switches to avoid all kinds of "hinting techniques" that have adverse effects on SubPixel
	// they should be considered "band-aid" solutions, to avoid us the worst of the worst with existing fonts.
	// in the future, fonts that are optimized for SubPixel should be tagged as such.
	// This will permit to switch these switches off again.
	#define RDTGRoundsDownToGrid		// to avoid not aligning control points when Align translates to MDRP with RDTG preceded by SPVTL
	#define NoVirtRoundInPrep			// to avoid PMingLiU vertically misplacing strokes (vectors not set properly in prep for certain calculations)
	#define RoundOffRespectsCvtCutIn	// to avoid Palatino Italic's fractional grey-scale targetted cvts and unrounded MIRP (little r) which bypasses cvt cut-in
	#define MSIRPRespectsCvtCutIn		// to avoid fonts pre-calculating a distance and subsequently MSIRPing it (neither rounding nor cvt cut-in involved in MSIRP)
	#define InlineDeltasOnly			// to avoid all kinds of bumps, blops, or irregular weight gains
	#define BypassDandIStroke			// to avoid collapsing strokes in (partly) auto-hinted fonts using DStroke and IStroke commands
	#define BypassJellesSpacing			// to avoid bloated characters
	#define BypassVacuformRound			// to avoid diamond shaped characters
	#define AssistTomsDiagonal			// to avoid Georgia italic to become upright

	// values derived from the primary values in fscdefs.h
	#define CVT_CUT_IN_OVERSCALE	VIRTUAL_OVERSCALE	// high value to encourage MIRP to fall back on original distance to avoid stroke weight jumps in size ramp
	#define ENGINE_COMP_OVERSCALE	VISUAL_OVERSCALE	// value not particularly relevant as engine compensation is not currently used
	#define MIN_DIST_OVERSCALE		VISUAL_OVERSCALE	// value not terribly important as it basically affects the minimum stroke weight

	#define Tuned4SubPixel(globalGS) ((uint16)((globalGS)->localParBlock.instructControl & TUNED4SPFLAG))
#else
	#define Tuned4SubPixel(globalGS) (false)
#endif

#define MAX_ELEMENTS 2
#define TWILIGHTZONE 0 /* The point storage */
#define GLYPHELEMENT 1 /* The actual glyph */

/* those constant are used as default to catch illegal fonts */
#define INTERP_MAX_JUMPS			10000
#define INTERP_MAX_RECURSIVE_CALLS	100

#define MAXANGLES       20

#define ROTATEDGLYPH        0x0100
#define STRETCHEDGLYPH      0x0200
/* new Apple 1994 */
#define VARIATIONGLYPH      0x0400
#define VERTICALGLYPH       0x0800
/* new Microsoft 1996 */
#define HINTEDFORGRAYGLYPH  0x1000

#define VERSIONINTERPRETERQUERY          0x0001
#define ROTATEDINTERPRETERQUERY          0x0002
#define STRETCHEDINTERPRETERQUERY        0x0004
/* new Apple 1994 */
#define VARIATIONINTERPRETERQUERY        0x0008
#define VERTICALMETRICSINTERPRETERQUERY  0x0010
/* new Microsoft 1996 */
#define HINTFORGRAYINTERPRETERQUERY      0x0020

/* new Microsoft 1998
   moved out of FSCFG_SUBPIXEL to build debug version for non SP environment */
#define HINTFORSUBPIXELINTERPRETERQUERY						0x0040
#define HINTFORSUBPIXELCOMPATIBLEWIDTHINTERPRETERQUERY		0x0080
#define HINTFORSUBPIXELVERTICALDIRECTIONINTERPRETERQUERY	0x0100
#define HINTFORSUBPIXELBGRORDERINTERPRETERQUERY				0x0200

#ifdef FSCFG_SUBPIXEL
/* new Microsoft 1998 */
#define HINTEDFORSUBPIXELGLYPH								0x02000
#define HINTEDFORSUBPIXELCOMPATIBLEWIDTHGLYPH				0x04000
#define HINTEDFORSUBPIXELVERTICALDIRECTIONGLYPH				0x08000
#define HINTEDFORSUBPIXELBGRORDERGLYPH						0x10000
#endif // FSCFG_SUBPIXEL

// this includes all SP specific flags, since we don't want a SP enabled font to break on a non SP enabled rasterizer
#define SELECTOR_FLAGS (VERSIONINTERPRETERQUERY | ROTATEDINTERPRETERQUERY | STRETCHEDINTERPRETERQUERY |					\
						VARIATIONINTERPRETERQUERY | VERTICALMETRICSINTERPRETERQUERY | HINTFORGRAYINTERPRETERQUERY |		\
						HINTFORSUBPIXELINTERPRETERQUERY | HINTFORSUBPIXELCOMPATIBLEWIDTHINTERPRETERQUERY |			\
						HINTFORSUBPIXELVERTICALDIRECTIONINTERPRETERQUERY | HINTFORSUBPIXELBGRORDERINTERPRETERQUERY)

#define MAXBYTE_INSTRUCTIONS 256

#define ONEVECTOR                       ONESHORTFRAC
#define VECTORMUL(value, component)     ShortFracMul((F26Dot6)(value), (ShortFract)(component))
#define VECTORDOT(a,b)                  ShortFracDot((ShortFract)(a),(ShortFract)(b))
#define VECTORDIV(num,denum)            ShortFracDiv((ShortFract)(num),(ShortFract)(denum))
#define VECTORMULDIV(a,b,c)             ShortFracMulDiv((ShortFract)(a),(ShortFract)(b),(ShortFract)(c))
#define VECTOR2FIX(a)                   ((Fixed) (a) << 2)
#define ONESIXTEENTHVECTOR              ((ONEVECTOR) >> 4)

#ifdef FSCFG_REENTRANT
#define GSP0    fnt_LocalGraphicStateType* pLocalGS
#define GSP     fnt_LocalGraphicStateType* pLocalGS,
#define GSA0    pLocalGS
#define GSA     pLocalGS,
#define LocalGS (*pLocalGS)
#else 
#define GSP0    void
#define GSP
#define GSA0
#define GSA
fnt_LocalGraphicStateType LocalGS
 #ifndef FSCFG_NO_INITIALIZED_DATA
  = {0}
 #endif 
;
#endif 


#define MABS(x)                 ( (x) < 0 ? (-(x)) : (x) )


/* Common Interpreter Function Parameter */

#define IPARAM         GSP uint8 *pbyInst, int32 lOpCode

#define MIRPG          0
#define MIRPX          1
#define MIRPY          2
				  
// color compensation flags in ROUND, MDRP, and MIRP
#define	GREY	0
#define BLACK	1
#define WHITE	2
#define OTHER	3

// flags for UTP, IUP, MovePoint
#define XMOVED 0x01
#define YMOVED 0x02


#define NUM_PHANTOM_PTS   4L

#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA // master switch

	#define NumRelationShips(elem) (elem->ep[elem->nc - 1] + 1 + NUM_PHANTOM_PTS)

	// Make an empty data structure (DAG)
	void InitPhaseControl(fnt_ElementType *elem) {
		long i;
		PhaseControlRelation *rel;

		for (i = 0; i < NumRelationShips(elem); i++) {
			rel = &elem->pcr[i];
			rel->parent0 = rel->parent1 = rel->child = -1;
			rel->flags = 0;
			rel->phaseShift = 0;
		}
		elem->phaseControlExecuted = false;
	} // InitPhaseControl

	//	Function to avert circular dependencies, whose traversal would cause endless recursion in
	//	"PhaseShift" further below.
	//
	//	In the trivial case (self dependency), a child would depend on itself. This scenario is ex-
	//	cluded by respective tests in the callers.
	//
	//	In the simplest non-trivial case (direct dependency), before linking from a parent to a child,
	//	we want to determine whether the child links back to the parent:
	//
	//		IndirectlyDependsOn(..., parent, child, ...) ?
	//
	//	If it does, then "self" (the parent) depends on "whom" (the child), and we'd get a circular
	//	dependency, because the child would depend on the parent as a result of "AddDistance":
	//
	//		rel->parent0 == whom ?
	//
	//	noting that "rel" points to self's phase control relation structure.
	//
	//	In the more general case (indirect dependency, which includes direct dependency via zero
	//	indirections), self's parent may depend on the child (and recursively), hence:
	//
	//		rel->parent0 == whom || IndirectlyDependsOn(..., rel->parent0, whom, ...) ?
	//
	//	In the most general case, there may be two parents involved, hence we have to follow both
	//	lines of ancestry:
	//
	//		rel->parent0 == whom || IndirectlyDependsOn(..., rel->parent0, whom, ...) || 
	//		rel->parent1 == whom || IndirectlyDependsOn(..., rel->parent1, whom, ...) ?
	//
	//	Notice that in the actual code the latter is re-arranged for efficiency.
	//	Notice also that we don't have a simple case of tail recursion, which could be replaced by
	//	an iteration easily.

	boolean IndirectlyDependsOn(fnt_ElementType *elem, long self, long whom, long level) {
		PhaseControlRelation *rel;

		level--;
		if (level < 0) return true; // safeguard against stack overflow, probably redundant

	//	here we assume that we're called only from within AddDistance or AddProportion, hence
	//	"self" and "whom" have been range checked initially. Every recursion changes the actual
	//	value of "self", but only to a value obtained from a "pcr", which only gets range checked
	//	values, hence we don't need to range check "self" again. "whom" is invariant anyhow.
	//	Additionally, we also assume that "self" and "whom" are not the same. Since the algorithm
	//	below terminates if "self"'s parent equals "whom", "self" never becomes "whom".

		rel = &elem->pcr[self];
		if (rel->parent0 == -1) // 0 parents (MDAP, MIAP)
			return false; // no dependencies
		else if (rel->parent1 == -1) // 1 parent (MDRP, MIRP, SHP, ALIGNRP, etc.)
			return rel->parent0 == whom || IndirectlyDependsOn(elem,rel->parent0,whom,level-1);
		else // 2 parents (IP)
			return rel->parent0 == whom || rel->parent1 == whom || IndirectlyDependsOn(elem,rel->parent0,whom,level-1) || IndirectlyDependsOn(elem,rel->parent1,whom,level-1);
		return false; // we shouldn't get down here, but the compiler thinks we do...
	} // IndirectlyDependsOn

	// Called from the TT interpreter whenever a MIRP, MDRP, SHP, ALIGNRP (etc.) is executed
	// Add a distance relationship to the DAG
	void AddDistance(fnt_LocalGraphicStateType *localGS, fnt_ElementType *elem, long from, long to, long color) {
		long parent;

		if (0 <= from && from < NumRelationShips(elem) && 0 <= to && to < NumRelationShips(elem) && from != to) { // prevent endless recursions
			if (IndirectlyDependsOn(elem,from,to,INTERP_MAX_RECURSIVE_CALLS))
				elem->pcr[to].flags |= BADREL;
			else if (elem->pcr[to].parent0 == -1) { // we have no parent for this child
				while ((parent = elem->pcr[from].parent0) != -1 && elem->oox[from] == elem->oox[parent])
					from = parent; // simplify link structure in case of links to "align" vertical edges
				elem->pcr[to].parent0 = (int16)from; // first link wins, bad links may produce suboptimal phase control
				elem->pcr[to].parent1 = -1;
			}
			if (color == BLACK && elem->pcr[from].child == -1 && elem->pcr[to].child != from) { // first black link wins...
				if ((parent = elem->pcr[from].parent0) != -1 && elem->pcr[parent].child == from)
					elem->pcr[to].flags |= BADREL;
				else
					elem->pcr[from].child = (int16)to;
			}
		}
	} // AddDistance
	
	// Called from the TT interpreter when an IP is executed
	// Add a proportion relationship to the DAG
	void AddProportion(fnt_LocalGraphicStateType *localGS, fnt_ElementType *elem, long from0, long to, long from1) {
		if (0 <= from0 && from0 < NumRelationShips(elem) && 0 <= from1 && from1 < NumRelationShips(elem) && 0 <= to && to < NumRelationShips(elem) && from0 != to && from1 != to && from0 != from1) { // prevent endless recursions
			if (IndirectlyDependsOn(elem,from0,to,INTERP_MAX_RECURSIVE_CALLS) || IndirectlyDependsOn(elem,from1,to,INTERP_MAX_RECURSIVE_CALLS))
				elem->pcr[to].flags |= BADREL;
			else if (elem->pcr[to].parent0 == -1 && elem->pcr[to].parent1 == -1) {
				elem->pcr[to].parent0 = (int16)from0; // first interpolate wins, bad interpolates
				elem->pcr[to].parent1 = (int16)from1; // ...may produce suboptimal phase control
			}
		}
	} // AddProportion
	
	// Calculate the phase shift resulting from a child point that depends on two parent points by proportion (interpolation)
	F26Dot6 CalcAvgXPhaseShift(fnt_ElementType *elem, long parent0, long child, long parent1, F26Dot6 phase0, F26Dot6 phase1) {
		F26Dot6 leftX,childX,rightX,leftPhase,rightPhase;
		
		// the phase of child control points that are interpolated between a pair of parent control points depends on the phase
		// applied to both of these parent control points.
		// If both parents have the same phase, then the child point gets that phase
		if (phase0 == phase1) return phase0; // IPs "within" strokes

		// if the phase is different, we try to calculcate a weighted average.
		// In dubious cases, this may fail (divide-by-zero), in which case we fall back on an unweighted (plain) average.
		if (elem->ox[parent0] < elem->ox[parent1]) {
			leftX = elem->ox[parent0]; rightX = elem->ox[parent1];
			leftPhase = phase0; rightPhase = phase1;
		} else {
			leftX = elem->ox[parent1]; rightX = elem->ox[parent0];
			leftPhase = phase1; rightPhase = phase0;
		}
		childX = elem->ox[child];
		
		return leftX != rightX 
			? ((childX - leftX)*rightPhase + (rightX - childX)*leftPhase)/(rightX - leftX) // weighted average
			: (leftPhase + rightPhase) / 2; // unweighted average
	} // CalcAvgXPhaseShift
	
	// This is the part that (recursively) traverses the data structure to apply the above rules.
	// Notice that it works much like the early prototype for the compiler that translates VTT's GUI into TMT
	F26Dot6 PhaseShift(fnt_LocalGraphicStateType *localGS, fnt_ElementType *elem, short anyBadRelation, long child) {
		PhaseControlRelation *rel,*childRel;
		F26Dot6 phase;
		
		if (child == -1) return 0; // nothing, hence no phase shift
		
		rel = &elem->pcr[child];
		
		if (rel->flags & DOING) return 0; // prevent from endless recursion due to circular dependencies; probably redundant
		rel->flags |= DOING;

		if ((rel->flags & DONE) == 0) { // else been there already, know phase
			if (child > elem->ep[elem->nc-1]) { // LSB, RSB
				phase = LongMulDiv(elem->x[child],localGS->globalGS->compatibleWidthStemConcertina - 0x10000,0x10000);
			} else if (rel->parent0 == -1) { // MDAP, MIAP
				if (anyBadRelation) {
					phase = LongMulDiv(elem->x[child],localGS->globalGS->compatibleWidthStemConcertina - 0x10000,0x10000);
				} else {
					phase = 0;
				}
			} else if (rel->parent1 == -1) { // MDRP, MIRP, SHP, ALIGNRP, ...
				phase = PhaseShift(localGS,elem,anyBadRelation,rel->parent0);
			} else { // IP
				phase = CalcAvgXPhaseShift(elem,rel->parent0,child,rel->parent1,PhaseShift(localGS,elem,anyBadRelation,rel->parent0),PhaseShift(localGS,elem,anyBadRelation,rel->parent1));
			}
			
			if ((rel->flags & DONE) == 0) { // still not done, after above recursion
				if (rel->child != -1 && ((childRel = &elem->pcr[rel->child])->flags & DONE) == 0) {
					if (rel->parent0 == -1 || rel->parent1 == -1) { // not IP
						phase = LongMulDiv(elem->x[child] + elem->x[rel->child],localGS->globalGS->compatibleWidthStemConcertina - 0x10000,0x20000);
					}
					
					elem->x[child] += phase;
					elem->x[rel->child] += phase;
					
					childRel->phaseShift = phase;
					childRel->flags |= DONE;
				
				// else if we're linked to, and we're not a leaf, such as in a chain of links through a 'v',
				// do the proportional thing, in order not to twist the 'v'
				// additionally, we may want to make the decision, which "stroke" wins, a bit smarter,
				// by giving preference to the one with the lesser |dy|

				} else {
					if (anyBadRelation && rel->parent1 == -1 && (rel->parent0 == -1 || elem->ox[child] != elem->ox[rel->parent0])) {
					//	bad MDRP, MIRP, SHP, ALIGNRP, MDAP, or MIAP, but not in case aligned along vertical edge
						phase = LongMulDiv(elem->x[child],localGS->globalGS->compatibleWidthStemConcertina - 0x10000,0x10000);
					} // else IP
					if (rel->parent0 != -1) {
						elem->x[child] += phase;
					}
				}
				rel->phaseShift = phase;
				rel->flags |= DONE;
			}
		}

		rel->flags &= ~DOING;
		return rel->phaseShift;
	} // PhaseShift

	// This is a plain old loop
	void ExecutePhaseControl(fnt_LocalGraphicStateType *localGS, fnt_ElementType *elem) {
		long i,numRelationShips;
		short anyBadRelation;
		F26Dot6 phase;

		numRelationShips = NumRelationShips(elem);
		for (i = 0; i < numRelationShips && (elem->pcr[i].flags & BADREL) == 0; i++);
		anyBadRelation = i < numRelationShips;
		for (i = 0; i < numRelationShips; i++) {
			phase = PhaseShift(localGS,elem,anyBadRelation,i);
		}
		elem->phaseControlExecuted = true;
	} // ExecutePhaseControl

	// helper function
	long ContNum(fnt_ElementType *elem, long knot) {
		long i;

		for (i = 0; i < elem->nc && knot > elem->ep[i]; i++);
		return i < elem->nc ? i : -1;
	} // ContNum

	// The "concertina algorithm" uses the color flags in the MDRP and MIRP instructions to "determine" the existence
	// of stems. Most of the time, the color flags are set correctly; in fact, if the TT code is generated by the TMT
	// compiler, they should always be correct. However, there is a small number of cases where the flags are erroneous
	// (a black stroke which is not flagged as black) or misleading (the extent of a cross bar, which is a black link
	// as defined in the TMT compiler, but which for the purpose of this algorithm had rather not be flagged as black).
	// Not surprisingly, most of these cases (avoiding to say, all of them) happen on grotesque fonts, with the MDRP
	// or MIRP between two neighbouring points on the outline (cases in which a compiler generating TT code could ar-
	// gueably be undecided). Therefore we make a last ditch effort in this function to correct the colour flags for
	// this special class of problems.
	long DoubleCheckLinkColor(fnt_ElementType *elem, long from, long to, long color) {
		long fromCont,fromStart,fromEnd,fromSucc,fromPred,toCont,toSucc,toPred;
		boolean fromRightTurn,toRightTurn,properlyOriented;

		// first, determine whether we link between a pair of neighbours on one and the same contour
		// one of the knots is not on any contour (LSB, RSB), hence can't be neighbours
		if ((fromCont = ContNum(elem,from)) < 0 || // error
			(toCont   = ContNum(elem,to))   < 0)
			return GREY; // it's not a black stroke
		
		// if they belong to different contours, we don't attempt to improve color flag
		if (fromCont != toCont) return color;
		
		// if they belong to the same contour, but are not neighbours, we don't attempt to improve color flag, either
		fromStart = elem->sp[fromCont];
		fromEnd   = elem->ep[fromCont];
		fromSucc = from == fromEnd ? fromStart : from+1;
		fromPred = from == fromStart ? fromEnd : from-1;
		if (to != fromSucc && to != fromPred) return color;

		// if they are neighbours, but the link is along the arm of a T-junction, we call it a grey link.
		// we determine this by testing whether the link starts at a point where the outline makes a right
		// turn and ends at a point where the outline makes a left turn, or vice versa.
		toSucc = to == fromEnd ? fromStart : to+1;
		toPred = to == fromStart ? fromEnd : to-1;
		fromRightTurn = (elem->oox[from]-elem->oox[fromPred])*(elem->ooy[fromSucc]-elem->ooy[from]) <
						(elem->ooy[from]-elem->ooy[fromPred])*(elem->oox[fromSucc]-elem->oox[from]);
		toRightTurn   = (elem->oox[to]-elem->oox[toPred])*(elem->ooy[toSucc]-elem->ooy[to]) <
						(elem->ooy[to]-elem->ooy[toPred])*(elem->oox[toSucc]-elem->oox[to]);
		if (fromRightTurn != toRightTurn)
			return GREY;

		// a extraneous case encountered, a link along a diagonal stroke
		if (2*MABS(elem->oox[to]-elem->oox[from]) < MABS(elem->ooy[to]-elem->ooy[from]))
			return GREY;

		properlyOriented = (elem->fc[fromCont] & OUTLINE_MISORIENTED) == 0;

		return properlyOriented == fromRightTurn ? BLACK : WHITE;
	} // DoubleCheckLinkColor

	// Determine whether an interpolation is actually an interpolation, as opposed to an extrapolation.
	// For actual interpolations, child points are moved along proportionally to the parent points. For
	// extrapolations child points are shifted along with the parent point(s). Notice that we implement
	// a behaviour similar to IUP (points between extrema are interpolated, the others are shifted along)
	boolean InterAlign(fnt_ElementType *elem, long parent0, long child, long parent1) {
		long parent0x,childx,parent1x,temp;

		parent0x = elem->oox[parent0];
		parent1x = elem->oox[parent1];
		if (parent0x > parent1x) { temp = parent0x; parent0x = parent1x; parent1x = temp; }
		childx = elem->oox[child];
		return parent0x <= childx && childx <= parent1x;
	} // InterAlign

#endif // SUBPIXEL_BC_AW_STEM_CONCERTINA


/* Private function prototypes */

FS_PRIVATE F26Dot6 itrp_RoundToDoubleGrid(GSP F26Dot6 xin, F26Dot6 engine);
FS_PRIVATE F26Dot6 itrp_RoundDownToGrid(GSP F26Dot6 xin, F26Dot6 engine);
FS_PRIVATE F26Dot6 itrp_RoundUpToGrid(GSP F26Dot6 xin, F26Dot6 engine);
FS_PRIVATE F26Dot6 itrp_RoundToGrid(GSP F26Dot6 xin, F26Dot6 engine);
FS_PRIVATE F26Dot6 itrp_RoundToHalfGrid(GSP F26Dot6 xin, F26Dot6 engine);
FS_PRIVATE F26Dot6 itrp_RoundOff(GSP F26Dot6 xin, F26Dot6 engine);

#ifdef FSCFG_SUBPIXEL
	// a duplicate set of rounding functions, with either the b/w (above) or the sp (below) version being installed
	FS_PRIVATE F26Dot6 itrp_RoundToDoubleGridSP(GSP F26Dot6 xin, F26Dot6 engine);
	FS_PRIVATE F26Dot6 itrp_RoundDownToGridSP(GSP F26Dot6 xin, F26Dot6 engine);
	FS_PRIVATE F26Dot6 itrp_RoundUpToGridSP(GSP F26Dot6 xin, F26Dot6 engine);
	FS_PRIVATE F26Dot6 itrp_RoundToGridSP(GSP F26Dot6 xin, F26Dot6 engine);
	FS_PRIVATE F26Dot6 itrp_RoundToHalfGridSP(GSP F26Dot6 xin, F26Dot6 engine);
	FS_PRIVATE F26Dot6 itrp_RoundOffSP(GSP F26Dot6 xin, F26Dot6 engine);
#endif

FS_PRIVATE F26Dot6 itrp_SuperRound(GSP F26Dot6 xin, F26Dot6 engine);
FS_PRIVATE F26Dot6 itrp_Super45Round(GSP F26Dot6 xin, F26Dot6 engine);

FS_PRIVATE void itrp_MovePoint  (GSP fnt_ElementType *element, int32 point, F26Dot6 delta);
FS_PRIVATE void itrp_XMovePoint (GSP fnt_ElementType *element, int32 point, F26Dot6 delta);
FS_PRIVATE void itrp_YMovePoint (GSP fnt_ElementType *element, int32 point, F26Dot6 delta);
FS_PRIVATE F26Dot6 itrp_Project (GSP F26Dot6 x, F26Dot6 y);
FS_PRIVATE F26Dot6 itrp_OldProject (GSP F26Dot6 x, F26Dot6 y);
FS_PRIVATE F26Dot6 itrp_XProject (GSP F26Dot6 x, F26Dot6 y);
FS_PRIVATE F26Dot6 itrp_YProject (GSP F26Dot6 x, F26Dot6 y);
FS_PRIVATE Fixed itrp_GetCVTScale (GSP0);
FS_PRIVATE F26Dot6 itrp_GetCVTEntryFast (GSP int32 n);
FS_PRIVATE F26Dot6 itrp_GetCVTEntrySlow (GSP int32 n);
FS_PRIVATE F26Dot6 itrp_GetSingleWidthFast (GSP0);
FS_PRIVATE F26Dot6 itrp_GetSingleWidthSlow (GSP0);
FS_PRIVATE void itrp_ChangeCvtFast (GSP fnt_ElementType *element, int32 number, F26Dot6 delta);
FS_PRIVATE void itrp_ChangeCvtSlow (GSP fnt_ElementType *element, int32 number, F26Dot6 delta);

FS_PRIVATE void itrp_InnerTraceExecute (GSP uint8 *ptr, uint8 *eptr);
FS_PRIVATE void itrp_InnerExecute (GSP uint8 *ptr, uint8 *eptr);
FS_PRIVATE void itrp_Check_PF_Proj (GSP0);
FS_PRIVATE void itrp_ComputeAndCheck_PF_Proj (GSP0);
FS_PRIVATE void itrp_SetRoundValues (GSP int32 arg1, int32 normalRound);
FS_PRIVATE F26Dot6 itrp_CheckSingleWidth (GSP F26Dot6 value);
FS_PRIVATE fnt_instrDef*itrp_FindIDef (GSP uint8 opCode);
FS_PRIVATE uint8* itrp_DeltaEngine (GSP uint8 *pbyInst, FntMoveFunc doIt, int16 base, int16 shift);

/* Actual instructions for the jump table */
FS_PRIVATE uint8* itrp_SVTCA_0 (IPARAM);
FS_PRIVATE uint8* itrp_SVTCA_1 (IPARAM);
FS_PRIVATE uint8* itrp_SPVTCA_0 (IPARAM);
FS_PRIVATE uint8* itrp_SPVTCA_1 (IPARAM);
FS_PRIVATE uint8* itrp_SFVTCA_0 (IPARAM);
FS_PRIVATE uint8* itrp_SFVTCA_1 (IPARAM);
FS_PRIVATE uint8* itrp_SPVTL (IPARAM);
FS_PRIVATE uint8* itrp_SDPVTL (IPARAM);
FS_PRIVATE uint8* itrp_SFVTL (IPARAM);
FS_PRIVATE uint8* itrp_WPV (IPARAM);
FS_PRIVATE uint8* itrp_WFV (IPARAM);
FS_PRIVATE uint8* itrp_RPV (IPARAM);
FS_PRIVATE uint8* itrp_RFV (IPARAM);
FS_PRIVATE uint8* itrp_SFVTPV (IPARAM);
FS_PRIVATE uint8* itrp_ISECT (IPARAM);
FS_PRIVATE uint8* itrp_SRP0 (IPARAM);
FS_PRIVATE uint8* itrp_SRP1 (IPARAM);
FS_PRIVATE uint8* itrp_SRP2 (IPARAM);
FS_PRIVATE uint8* itrp_SetElementPtr (IPARAM);
FS_PRIVATE uint8* itrp_LLOOP (IPARAM);
FS_PRIVATE uint8* itrp_RTG (IPARAM);
FS_PRIVATE uint8* itrp_RTHG (IPARAM);
FS_PRIVATE uint8* itrp_RTDG (IPARAM);
FS_PRIVATE uint8* itrp_ROFF (IPARAM);
FS_PRIVATE uint8* itrp_RUTG (IPARAM);
FS_PRIVATE uint8* itrp_RDTG (IPARAM);
FS_PRIVATE uint8* itrp_SROUND (IPARAM);
FS_PRIVATE uint8* itrp_S45ROUND (IPARAM);
FS_PRIVATE uint8* itrp_LMD (IPARAM);
FS_PRIVATE uint8* itrp_RAW (IPARAM);
FS_PRIVATE uint8* itrp_LWTCI (IPARAM);
FS_PRIVATE uint8* itrp_LSWCI (IPARAM);
FS_PRIVATE uint8* itrp_LSW (IPARAM);
FS_PRIVATE uint8* itrp_DUP (IPARAM);
FS_PRIVATE uint8* itrp_POP (IPARAM);
FS_PRIVATE uint8* itrp_CLEAR (IPARAM);
FS_PRIVATE uint8* itrp_SWAP (IPARAM);
FS_PRIVATE uint8* itrp_DEPTH (IPARAM);
FS_PRIVATE uint8* itrp_CINDEX (IPARAM);
FS_PRIVATE uint8* itrp_MINDEX (IPARAM);
FS_PRIVATE uint8* itrp_ROTATE (IPARAM);
FS_PRIVATE uint8* itrp_MDAP (IPARAM);
FS_PRIVATE uint8* itrp_MIAP (IPARAM);
FS_PRIVATE uint8* itrp_IUP (IPARAM);
FS_PRIVATE uint8* itrp_SHP (IPARAM);
FS_PRIVATE uint8* itrp_SHC (IPARAM);
FS_PRIVATE uint8* itrp_SHE (IPARAM);
FS_PRIVATE uint8* itrp_SHPIX (IPARAM);
FS_PRIVATE uint8* itrp_IP (IPARAM);
FS_PRIVATE uint8* itrp_MSIRP (IPARAM);
FS_PRIVATE uint8* itrp_ALIGNRP (IPARAM);
FS_PRIVATE uint8* itrp_ALIGNPTS (IPARAM);
FS_PRIVATE uint8* itrp_SANGW (IPARAM);
FS_PRIVATE uint8* itrp_FLIPPT (IPARAM);
FS_PRIVATE uint8* itrp_FLIPRGON (IPARAM);
FS_PRIVATE uint8* itrp_FLIPRGOFF (IPARAM);
FS_PRIVATE uint8* itrp_SCANCTRL (IPARAM);
FS_PRIVATE uint8* itrp_SCANTYPE (IPARAM);
FS_PRIVATE uint8* itrp_INSTCTRL (IPARAM);
FS_PRIVATE uint8* itrp_AA (IPARAM);
FS_PRIVATE uint8* itrp_NPUSHB (IPARAM);
FS_PRIVATE uint8* itrp_NPUSHW (IPARAM);
FS_PRIVATE uint8* itrp_WS (IPARAM);
FS_PRIVATE uint8* itrp_RS (IPARAM);
FS_PRIVATE uint8* itrp_WCVT (IPARAM);
FS_PRIVATE uint8* itrp_WCVTFOD (IPARAM);
FS_PRIVATE uint8* itrp_RCVT (IPARAM);
FS_PRIVATE uint8* itrp_RC (IPARAM);
FS_PRIVATE uint8* itrp_WC (IPARAM);
FS_PRIVATE uint8* itrp_MD (IPARAM);
FS_PRIVATE uint8* itrp_MPPEM (IPARAM);
FS_PRIVATE uint8* itrp_MPS (IPARAM);
FS_PRIVATE uint8* itrp_GETINFO (IPARAM);
FS_PRIVATE uint8* itrp_FLIPON (IPARAM);
FS_PRIVATE uint8* itrp_FLIPOFF (IPARAM);
FS_PRIVATE uint8* itrp_IF (IPARAM);
FS_PRIVATE uint8* itrp_ELSE (IPARAM);
FS_PRIVATE uint8* itrp_EIF (IPARAM);
FS_PRIVATE uint8* itrp_JMPR (IPARAM);
FS_PRIVATE uint8* itrp_JROT (IPARAM);
FS_PRIVATE uint8* itrp_JROF (IPARAM);
FS_PRIVATE uint8* itrp_ROUND (IPARAM);
FS_PRIVATE uint8* itrp_NROUND (IPARAM);
FS_PRIVATE uint8* itrp_PUSHB (IPARAM);
FS_PRIVATE uint8* itrp_PUSHW (IPARAM);
FS_PRIVATE uint8* itrp_MDRP (IPARAM);
FS_PRIVATE uint8* itrp_MIRP (IPARAM);
FS_PRIVATE uint8* itrp_CALL (IPARAM);
FS_PRIVATE uint8* itrp_FDEF (IPARAM);
FS_PRIVATE uint8* itrp_LOOPCALL (IPARAM);
FS_PRIVATE uint8* itrp_IDefPatch (IPARAM);
FS_PRIVATE uint8* itrp_IDEF (IPARAM);
FS_PRIVATE uint8* itrp_UTP (IPARAM);
FS_PRIVATE uint8* itrp_SDB (IPARAM);
FS_PRIVATE uint8* itrp_SDS (IPARAM);
FS_PRIVATE uint8* itrp_DELTAP1 (IPARAM);
FS_PRIVATE uint8* itrp_DELTAP2 (IPARAM);
FS_PRIVATE uint8* itrp_DELTAP3 (IPARAM);
FS_PRIVATE uint8* itrp_DELTAC1 (IPARAM);
FS_PRIVATE uint8* itrp_DELTAC2 (IPARAM);
FS_PRIVATE uint8* itrp_DELTAC3 (IPARAM);

FS_PRIVATE uint8*  itrp_PUSHB1 (IPARAM);
FS_PRIVATE uint8*  itrp_PUSHW1 (IPARAM);

FS_PRIVATE uint8*  itrp_LT  (IPARAM);
FS_PRIVATE uint8*  itrp_LTEQ (IPARAM);
FS_PRIVATE uint8*  itrp_GT  (IPARAM);
FS_PRIVATE uint8*  itrp_GTEQ (IPARAM);
FS_PRIVATE uint8*  itrp_EQ  (IPARAM);
FS_PRIVATE uint8*  itrp_NEQ (IPARAM);
FS_PRIVATE uint8*  itrp_AND (IPARAM);
FS_PRIVATE uint8*  itrp_OR  (IPARAM);
FS_PRIVATE uint8*  itrp_ADD (IPARAM);
FS_PRIVATE uint8*  itrp_SUB (IPARAM);
FS_PRIVATE uint8*  itrp_DIV (IPARAM);
FS_PRIVATE uint8*  itrp_MUL (IPARAM);
FS_PRIVATE uint8*  itrp_MAX (IPARAM);
FS_PRIVATE uint8*  itrp_MIN (IPARAM);

FS_PRIVATE uint8*  itrp_ODD (IPARAM);
FS_PRIVATE uint8*  itrp_EVEN (IPARAM);
FS_PRIVATE uint8*  itrp_NOT (IPARAM);
FS_PRIVATE uint8*  itrp_ABS (IPARAM);
FS_PRIVATE uint8*  itrp_NEG (IPARAM);
FS_PRIVATE uint8*  itrp_CEILING (IPARAM);
FS_PRIVATE uint8*  itrp_FLOOR (IPARAM);

FS_PRIVATE uint8*  itrp_IllegalInstruction (IPARAM);

FS_PRIVATE fnt_ElementType*itrp_SH_Common (GSP F26Dot6*dx, F26Dot6*dy, int32*point, int32 lOpCode);
FS_PRIVATE uint8* itrp_SHP_Common (GSP uint8 *pbyInst, 
#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
								   int32 refPoint,
#endif
#ifdef FSCFG_SUBPIXEL							// extra parameter to distinguish between coming from SHPIX, in which case we assume
								   uint8 shpix, // the context is a delta fn and hence we most likely skip the delta, and SHP
#endif
								   F26Dot6 dx, F26Dot6 dy);
FS_PRIVATE uint8* itrp_PushSomeBytes (GSP int32, uint8*);
FS_PRIVATE uint8* itrp_PushSomeWords (GSP int32, uint8*);
FS_PRIVATE uint8* itrp_SkipPushData (GSP uint8*);

#ifndef NOT_ON_THE_MAC
#ifdef FSCFG_DEBUG
FS_PRIVATE void itrp_DDT (int8 c, int32 n);
#endif
#endif
FS_PRIVATE uint8* itrp_DEBUG (IPARAM);

#define MAX(a,b)        ((a) > (b) ? (a) : (b))

FS_PRIVATE ErrorCode   itrp_Execute (
	fnt_ElementType *               pTwilightElement,
	fnt_ElementType *               pGlyphElement,
	uint8 *                         ptr,
	uint8 *                         eptr,
	fnt_GlobalGraphicStateType *    globalGS,
	 FntTraceFunc                           TraceFunc);

/* GLOBAL GS INITIALIZATION */

FS_PUBLIC void          itrp_UpdateGlobalGS(
	void *              pvGlobalGS, /* GlobalGS                             */
	void *              pvCVT,      /* Pointer to control value table       */
	void *              pvStore,    /* Pointer to storage                   */
	void *              pvFuncDef,  /* Pointer to function defintions       */
	void *              pvInstrDef, /* Pointer to instruction definitions   */
	void *              pvStack,    /* Pointer to the stack                 */
	LocalMaxProfile *       maxp,
	uint16              cvtCount,
	uint32              ulLengthFontProgram, /* Length of font program      */
	void *              pvFontProgram, /* Pointer to font program           */
	uint32              ulLengthPreProgram, /* Length of pre program        */
	void *              pvPreProgram,  /* Pointer to pre program            */
	ClientIDType        clientID)     /* User ID Number                     */
{
	fnt_GlobalGraphicStateType *    globalGS;
#ifdef FSCFG_SECURE
    uint16      maxStackElements = maxp->maxStackElements;

#ifdef FSCFG_EUDC_EDITOR_BUG
    if (maxStackElements == 0)
    {
      maxStackElements = 1;
    }

#endif // FSCFG_EUDC_EDITOR_BUG
#endif // FSCFG_SECURE

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

	globalGS->controlValueTable =   (F26Dot6 *)pvCVT;
	globalGS->store =               (F26Dot6 *)pvStore;
	globalGS->funcDef =             (fnt_funcDef *)pvFuncDef;
	globalGS->instrDef =            (fnt_instrDef *)pvInstrDef;
	globalGS->stackBase =           (F26Dot6 *)pvStack;
	globalGS->clientID =            clientID;
#ifdef FSCFG_SECURE
	globalGS->stackMax =             globalGS->stackBase + maxStackElements;
    globalGS->maxPointsIncludePhantom = MAX (maxp->maxPoints,maxp->maxCompositePoints) + NUM_PHANTOM_PTS;
#endif // FSCFG_SECURE

	if(ulLengthFontProgram)
	{
		globalGS->pgmList[FONTPROGRAM].Length = ulLengthFontProgram;
		globalGS->pgmList[FONTPROGRAM].Instruction = (unsigned char *)pvFontProgram;
	}
	else
	{
		globalGS->pgmList[FONTPROGRAM].Length = ulLengthFontProgram;
		globalGS->pgmList[FONTPROGRAM].Instruction = NULL;
	}
	if(ulLengthPreProgram)
	{
		globalGS->pgmList[PREPROGRAM].Length = ulLengthPreProgram;
		globalGS->pgmList[PREPROGRAM].Instruction = (unsigned char *)pvPreProgram;
	}
	else
	{
		globalGS->pgmList[PREPROGRAM].Length = ulLengthPreProgram;
		globalGS->pgmList[PREPROGRAM].Instruction = NULL;
	}

	globalGS->maxp = maxp;
	globalGS->cvtCount = cvtCount;
	globalGS->bCompositeGlyph = FALSE;
	globalGS->bSameTransformAsMaster = TRUE;
	globalGS->bOriginalPointIsInvalid = FALSE;

	globalGS->ulMaxJumpCounter = INTERP_MAX_JUMPS;
	globalGS->ulMaxRecursiveCall = INTERP_MAX_RECURSIVE_CALLS;
}

FS_PUBLIC boolean itrp_bApplyHints(
	void *      pvGlobalGS)
{
	fnt_GlobalGraphicStateType *    globalGS;

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;
	return (!(globalGS->localParBlock.instructControl & NOGRIDFITFLAG));
}

FS_PUBLIC void  itrp_QueryScanInfo(
	void *      pvGlobalGS,
	uint16 *    pusScanType,
	uint16 *    pusScanControl)
{
	fnt_GlobalGraphicStateType *    globalGS;

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;
	 *pusScanType =  FS_HIWORD(globalGS->localParBlock.scanControl);
	 *pusScanControl = FS_LOWORD(globalGS->localParBlock.scanControl);
}

FS_PUBLIC void  itrp_SetCompositeFlag(
	void *      pvGlobalGS,
	uint8       bCompositeFlag)
{
	fnt_GlobalGraphicStateType *    globalGS;

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;
	globalGS->bCompositeGlyph = bCompositeFlag;

	globalGS->bOriginalPointIsInvalid = globalGS->bCompositeGlyph || !globalGS->bSameTransformAsMaster;
}

FS_PUBLIC void	itrp_SetSameTransformFlag(
	void *      pvGlobalGS,
	boolean		bSameTransformAsMaster)
{
	fnt_GlobalGraphicStateType *    globalGS;

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;
	globalGS->bSameTransformAsMaster = (uint8)bSameTransformAsMaster;

	globalGS->bOriginalPointIsInvalid = globalGS->bCompositeGlyph || !globalGS->bSameTransformAsMaster;
}

/*
*  function table
*/

FntFunc function [MAXBYTE_INSTRUCTIONS]
#ifndef FSCFG_NO_INITIALIZED_DATA
=
{
  itrp_SVTCA_0, itrp_SVTCA_1, itrp_SPVTCA_0, itrp_SPVTCA_1, itrp_SFVTCA_0, itrp_SFVTCA_1, itrp_SPVTL, itrp_SPVTL,
  itrp_SFVTL, itrp_SFVTL, itrp_WPV, itrp_WFV, itrp_RPV, itrp_RFV, itrp_SFVTPV, itrp_ISECT,
  itrp_SRP0, itrp_SRP1, itrp_SRP2, itrp_SetElementPtr, itrp_SetElementPtr, itrp_SetElementPtr, itrp_SetElementPtr, itrp_LLOOP,
  itrp_RTG, itrp_RTHG, itrp_LMD, itrp_ELSE, itrp_JMPR, itrp_LWTCI, itrp_LSWCI, itrp_LSW,
  itrp_DUP, itrp_POP, itrp_CLEAR, itrp_SWAP, itrp_DEPTH, itrp_CINDEX, itrp_MINDEX, itrp_ALIGNPTS,
  itrp_RAW, itrp_UTP, itrp_LOOPCALL, itrp_CALL, itrp_FDEF, itrp_IllegalInstruction, itrp_MDAP, itrp_MDAP,
  itrp_IUP, itrp_IUP, itrp_SHP, itrp_SHP, itrp_SHC, itrp_SHC, itrp_SHE, itrp_SHE,
  itrp_SHPIX, itrp_IP, itrp_MSIRP, itrp_MSIRP, itrp_ALIGNRP, itrp_RTDG, itrp_MIAP, itrp_MIAP,
  itrp_NPUSHB, itrp_NPUSHW, itrp_WS, itrp_RS, itrp_WCVT, itrp_RCVT, itrp_RC, itrp_RC,
  itrp_WC, itrp_MD, itrp_MD, itrp_MPPEM, itrp_MPS, itrp_FLIPON, itrp_FLIPOFF, itrp_DEBUG,
  itrp_LT, itrp_LTEQ, itrp_GT, itrp_GTEQ, itrp_EQ, itrp_NEQ, itrp_ODD, itrp_EVEN,
  itrp_IF, itrp_EIF, itrp_AND, itrp_OR, itrp_NOT, itrp_DELTAP1, itrp_SDB, itrp_SDS,
  itrp_ADD, itrp_SUB, itrp_DIV, itrp_MUL, itrp_ABS, itrp_NEG, itrp_FLOOR, itrp_CEILING,
  itrp_ROUND, itrp_ROUND, itrp_ROUND, itrp_ROUND, itrp_NROUND, itrp_NROUND, itrp_NROUND, itrp_NROUND,
  itrp_WCVTFOD, itrp_DELTAP2, itrp_DELTAP3, itrp_DELTAC1, itrp_DELTAC2, itrp_DELTAC3, itrp_SROUND, itrp_S45ROUND,
  itrp_JROT, itrp_JROF, itrp_ROFF, itrp_IllegalInstruction, itrp_RUTG, itrp_RDTG, itrp_SANGW, itrp_AA,

  itrp_FLIPPT, itrp_FLIPRGON, itrp_FLIPRGOFF, itrp_IDefPatch, itrp_IDefPatch, itrp_SCANCTRL, itrp_SDPVTL, itrp_SDPVTL,
  itrp_GETINFO, itrp_IDEF, itrp_ROTATE, itrp_MAX, itrp_MIN, itrp_SCANTYPE, itrp_INSTCTRL, itrp_IDefPatch,
  itrp_IDefPatch, itrp_IDefPatch, itrp_IDefPatch, itrp_IDefPatch, itrp_IDefPatch, itrp_IDefPatch, itrp_IDefPatch, itrp_IDefPatch,
  itrp_IDefPatch, itrp_IDefPatch, itrp_IDefPatch, itrp_IDefPatch, itrp_IDefPatch, itrp_IDefPatch, itrp_IDefPatch, itrp_IDefPatch,
  itrp_IDefPatch, itrp_IDefPatch, itrp_IDefPatch, itrp_IDefPatch, itrp_IDefPatch, itrp_IDefPatch, itrp_IDefPatch, itrp_IDefPatch,
  itrp_IDefPatch, itrp_IDefPatch, itrp_IDefPatch, itrp_IDefPatch, itrp_IDefPatch, itrp_IDefPatch, itrp_IDefPatch, itrp_IDefPatch,
  itrp_PUSHB1, itrp_PUSHB, itrp_PUSHB, itrp_PUSHB, itrp_PUSHB, itrp_PUSHB, itrp_PUSHB, itrp_PUSHB,
  itrp_PUSHW1, itrp_PUSHW, itrp_PUSHW, itrp_PUSHW, itrp_PUSHW, itrp_PUSHW, itrp_PUSHW, itrp_PUSHW,
  itrp_MDRP, itrp_MDRP, itrp_MDRP, itrp_MDRP, itrp_MDRP, itrp_MDRP, itrp_MDRP, itrp_MDRP,
  itrp_MDRP, itrp_MDRP, itrp_MDRP, itrp_MDRP, itrp_MDRP, itrp_MDRP, itrp_MDRP, itrp_MDRP,
  itrp_MDRP, itrp_MDRP, itrp_MDRP, itrp_MDRP, itrp_MDRP, itrp_MDRP, itrp_MDRP, itrp_MDRP,
  itrp_MDRP, itrp_MDRP, itrp_MDRP, itrp_MDRP, itrp_MDRP, itrp_MDRP, itrp_MDRP, itrp_MDRP,
  itrp_MIRP, itrp_MIRP, itrp_MIRP, itrp_MIRP, itrp_MIRP, itrp_MIRP, itrp_MIRP, itrp_MIRP,
  itrp_MIRP, itrp_MIRP, itrp_MIRP, itrp_MIRP, itrp_MIRP, itrp_MIRP, itrp_MIRP, itrp_MIRP,
  itrp_MIRP, itrp_MIRP, itrp_MIRP, itrp_MIRP, itrp_MIRP, itrp_MIRP, itrp_MIRP, itrp_MIRP,
  itrp_MIRP, itrp_MIRP, itrp_MIRP, itrp_MIRP, itrp_MIRP, itrp_MIRP, itrp_MIRP, itrp_MIRP
}
#endif /* FSCFG_NO_INITIALIZED_DATA */
;

/* the old itrp_Init function and tables now live in history.fnt - deanb */


#ifdef  GET_STACKSPACE
  int32 MaxStackSize = 0;

  #define PUSH(p, x) \
	{ \
	  if (p - LocalGS.globalGS->stackBase > MaxStackSize) \
		MaxStackSize = p - LocalGS.globalGS->stackBase; \
	  (*(p)++ = (x)); \
	}

#else
  #define PUSH( p, x ) ( *(p)++ = (x) )
#endif
  #define POP( p )     ( *(--p) )

#define BADCOMPILER

#ifdef BADCOMPILER
#define BOOLEANPUSH( p, x ) PUSH( p, ((x) ? 1 : 0) ) /* MPW 3.0 */
#else
#define BOOLEANPUSH( p, x ) PUSH( p, x )
#endif

#ifdef FSCFG_DEBUG
void CHECK_RANGE (int32 n, int32 min, int32 max);
void CHECK_RANGE (int32 n, int32 min, int32 max)
{
  if (n > max || n < min)
	ERR_REPORT (ERR_RANGE, n, min, max, 0);
}


void CHECK_ASSERTION (int32 expression);
void CHECK_ASSERTION (int32 expression)
{
  if (!expression)
	ERR_REPORT (ERR_ASSERTION, expression, 0, 0, 0);
}


void CHECK_CVT (fnt_LocalGraphicStateType* pGS, int32 cvt);
void CHECK_CVT (fnt_LocalGraphicStateType* pGS, int32 cvt)
{
  int32 cvtCount = (int32)(pGS->globalGS->cvtCount - 1L);

  if ((int32)cvt > cvtCount || (int32)cvt < 0L)
	ERR_REPORT (ERR_CVT, cvt, 0, cvtCount, 0);
}


void CHECK_FDEF (fnt_LocalGraphicStateType* pGS, int32 fdef);
void CHECK_FDEF (fnt_LocalGraphicStateType* pGS, int32 fdef)
{
  int32 maxFdef = (int32)(pGS->globalGS->maxp->maxFunctionDefs - 1L);

  if ((int32)fdef > maxFdef || (int32)fdef < 0L)
	ERR_REPORT (ERR_FDEF, fdef, 0, maxFdef, 0);
}

#define CHECK_PROGRAM(a)

void CHECK_ELEMENT (fnt_LocalGraphicStateType* pGS, int32 elem);
void CHECK_ELEMENT (fnt_LocalGraphicStateType* pGS, int32 elem)
{
  int32 maxElem = (int32)(pGS->globalGS->maxp->maxElements - 1L);

/*
  At least 1 maxElements will always be available
*/
  if (!maxElem)
	maxElem++;

  if ((int32)elem > maxElem || (int32)elem < 0L)
	ERR_REPORT (ERR_ELEMENT, elem, 0, maxElem, 0);
}

void CHECK_ELEMENTPTR (fnt_LocalGraphicStateType* pGS, fnt_ElementType*elem);
void CHECK_ELEMENTPTR (fnt_LocalGraphicStateType* pGS, fnt_ElementType*elem)
{
  if (elem == &pGS->elements[1])
  {
	 int32 maxctrs, maxpts;

	maxctrs = MAX (pGS->globalGS->maxp->maxContours,
				   pGS->globalGS->maxp->maxCompositeContours);
	maxpts  = MAX (pGS->globalGS->maxp->maxPoints,
				   pGS->globalGS->maxp->maxCompositePoints);

	if ((int32)elem->nc > (int32)maxctrs || (int32)elem->nc < 1L)
	  ERR_REPORT (ERR_CONTOUR, elem->nc, 1, maxctrs, 0);

	if ((int32)elem->ep[elem->nc-1] > maxpts - 1L ||
		(int32)elem->ep[elem->nc-1] < 0L)
	  ERR_REPORT (ERR_POINT, elem->ep[elem->nc-1], 0, maxpts - 1L, 0);
  }
  else if (elem != &pGS->elements[0])
	ERR_REPORT (ERR_INDEX, elem, &pGS->elements[0], &pGS->elements[1], 0);
}

void CHECK_STORAGE (fnt_LocalGraphicStateType* pGS, int32 index);
void CHECK_STORAGE (fnt_LocalGraphicStateType* pGS, int32 index)
{
  int32 maxIndex = (int32)(pGS->globalGS->maxp->maxStorage - 1L);

  if ((int32)index > maxIndex || (int32)index < 0L)
	ERR_REPORT (ERR_STORAGE, index, 0, maxIndex, 0);
}

void CHECK_STACK (fnt_LocalGraphicStateType* pGS);
void CHECK_STACK (fnt_LocalGraphicStateType* pGS)
{
  int32 base = (int32)(pGS->stackPointer - pGS->globalGS->stackBase);
  int32 max = (int32)(pGS->globalGS->maxp->maxStackElements - 1L);

  if (base > max || base < 0L)
	ERR_REPORT (ERR_STACK, base, 0, max, 0);
}

void CHECK_POINT (fnt_LocalGraphicStateType* pGS, fnt_ElementType*elem, int32 pt);
void CHECK_POINT (fnt_LocalGraphicStateType* pGS, fnt_ElementType*elem, int32 pt)
{
  CHECK_ELEMENTPTR (pGS, elem);
  if (pGS->elements == elem)
  {
	if ((int32)pt > pGS->globalGS->maxp->maxTwilightPoints - 1L ||
		(int32)pt < 0L)
	  ERR_REPORT (ERR_POINT, pt, 0, pGS->globalGS->maxp->maxTwilightPoints - 1L, 0);
  }
  else                                                      /* phantom points */
  {
	if ((int32)pt > elem->ep[elem->nc-1] + 2L || (int32)pt < 0L)
	  ERR_REPORT (ERR_POINT, pt, 0, elem->ep[elem->nc-1] + 2L, 0);
  }
}

void CHECK_CONTOUR (fnt_LocalGraphicStateType* pGS, fnt_ElementType*elem, int32 ctr);
void CHECK_CONTOUR (fnt_LocalGraphicStateType* pGS, fnt_ElementType*elem, int32 ctr)
{
  CHECK_ELEMENTPTR (pGS, elem);
  if ((int32)ctr > elem->nc - 1L || (int32)ctr < 0L)
	ERR_REPORT (ERR_CONTOUR, ctr, 0, elem->nc -1L, 0);
}

void CHECK_VECTOR (VECTORTYPE x, VECTORTYPE y);
void CHECK_VECTOR (VECTORTYPE x, VECTORTYPE y)
{
  if ( x == 0 && y == 0 )
	ERR_REPORT (ERR_VECTOR, x, y, 0, 0);
}

void CHECK_LARGER (int32 min, int32 n);
void CHECK_LARGER (int32 min, int32 n)
{
  if ( n <= min )
	ERR_REPORT (ERR_LARGER, min, n, 0, 0);
}

void CHECK_INT8 (int32 n);
void CHECK_INT8 (int32 n)
{
  if ( n & 0xFFFFFF00 )
	ERR_REPORT (ERR_INT8, n, 0, 0, 0);
}

void CHECK_INT16 (int32 n);
void CHECK_INT16 (int32 n)
{
  if ( n & 0xFFFF0000 )
	ERR_REPORT (ERR_INT16, n, 0, 0, 0);
}

void CHECK_SELECTOR (int32 n);
void CHECK_SELECTOR (int32 n)
{
  if ( n & ~((int32)SELECTOR_FLAGS) )
	ERR_REPORT (ERR_SELECTOR, n, 0, 0, 0);
}

void CHECK_SUBSTACK (fnt_LocalGraphicStateType* pGS, F26Dot6* pt);
void CHECK_SUBSTACK (fnt_LocalGraphicStateType* pGS, F26Dot6* pt)
{
  int32 base = (int32)(pt - pGS->globalGS->stackBase);
  int32 max = (int32)(pGS->globalGS->maxp->maxStackElements - 1L);

  if (base > max || base < 0L)
	ERR_REPORT (ERR_STACK, base, 0, max, 0);
}

void POP_CHECK (F26Dot6*);
void POP_CHECK (F26Dot6* stackPtr)
{
  F26Dot6 * base = LocalGS.globalGS->stackBase;
  F26Dot6 * max;

  max = base + LocalGS.globalGS->maxp->maxStackElements - 1L;
  if ( stackPtr <= base)
	ERR_REPORT (ERR_STACK, (stackPtr - base - 1L), 0, (max - base), 0);
  return;
}

void PUSH_CHECK (F26Dot6*);
void PUSH_CHECK (F26Dot6* stackPtr)
{
  F26Dot6 * base = LocalGS.globalGS->stackBase;
  F26Dot6 * max;

  max = base + LocalGS.globalGS->maxp->maxStackElements - 1L;
  if ( stackPtr > max )
	ERR_REPORT (ERR_STACK, (stackPtr - base), 0, (max - base), 0);
  return;
}

#define CHECK_POP(s)                (POP_CHECK(s),POP(s))
#define CHECK_PUSH(s, v)            (PUSH_CHECK(s),PUSH(s, v))

#else
#define CHECK_RANGE(a,b,c)
#define CHECK_ASSERTION(a)
#define CHECK_CVT(pgs,b)
#define CHECK_POINT(pgs,b,c)
#define CHECK_CONTOUR(pgs,b,c)
#define CHECK_FDEF(pgs,b)
#define CHECK_PROGRAM(a)
#define CHECK_ELEMENT(pgs,b)
#define CHECK_ELEMENTPTR(pgs,b)
#define CHECK_STORAGE(pgs,b)
#define CHECK_STACK(pgs)
#define CHECK_VECTOR(a,b)
#define CHECK_LARGER(a,b)
#define CHECK_INT8(a)
#define CHECK_INT16(a)
#define CHECK_SELECTOR(a)
#define CHECK_SUBSTACK(pgs,a)
#define CHECK_POP(s)                POP(s)
#define CHECK_PUSH(s, v)            PUSH(s, v)
#endif

/*@@*/

/* ClaudeBe 4/15/98 new secure rasterizer testing of critical errors */
/* errors originally detected by the fstrace callback trace function */
/* moved inside the rasterizer for performance reason */

#ifdef FSCFG_SECURE

#define SECURE_CHECK_FOR_POP(stackPtr, lNumItems) \
 \
  if (stackPtr - (int32)(lNumItems) < LocalGS.globalGS->stackBase) \
{ \
	LocalGS.ercReturn = SECURE_STACK_UNDERFLOW;  /* error returned to client */ \
	return LocalGS.pbyEndInst; \
  } 

#define SECURE_CHECK_FOR_PUSH(stackPtr, lNumItems) \
 \
  if (stackPtr + (int32)(lNumItems) > LocalGS.globalGS->stackMax) \
{ \
	LocalGS.ercReturn = SECURE_STACK_OVERFLOW;  /* error returned to client */ \
	return LocalGS.pbyEndInst; \
  } 

#define SECURE_CHECK_SUBSTACK(stackPtr) \
 \
  if ((stackPtr < LocalGS.globalGS->stackBase) || (stackPtr >= LocalGS.globalGS->stackMax)) \
{ \
	LocalGS.ercReturn = SECURE_INVALID_STACK_ACCESS;  /* error returned to client */ \
	return LocalGS.pbyEndInst; \
  } 

#define SECURE_CHECK_POINT(elem, pt) \
{ \
    if (LocalGS.elements == elem) \
    { \
	  if ((int32)pt >= LocalGS.globalGS->maxp->maxTwilightPoints || \
		 (int32)pt < 0L) \
      { \
	    LocalGS.ercReturn = SECURE_POINT_OUT_OF_RANGE;  /* error returned to client */ \
	    return LocalGS.pbyEndInst; \
      } \
    } \
    else \
    { \
	  if ((int32)pt >= LocalGS.globalGS->maxPointsIncludePhantom || (int32)pt < 0L) \
      { \
	    LocalGS.ercReturn = SECURE_POINT_OUT_OF_RANGE;  /* error returned to client */ \
	    return LocalGS.pbyEndInst; \
      } \
    } \
}

#define SECURE_CHECK_FDEF(fdef) \
{ \
    if ((int32)fdef >= (LocalGS.globalGS->maxp->maxFunctionDefs) || (int32)fdef < 0L) \
    { \
	  LocalGS.ercReturn = SECURE_FDEF_OUT_OF_RANGE;  /* error returned to client */ \
	  return LocalGS.pbyEndInst; \
    } \
}

#define SECURE_CHECK_PROGRAM(pgmIndex) \
{ \
    if (pgmIndex >= MAXPREPROGRAMS) \
    { \
	  LocalGS.ercReturn = SECURE_ERR_FUNCTION_NOT_DEFINED;  /* error returned to client */ \
	  return LocalGS.pbyEndInst; \
    } \
}

#define SECURE_CHECK_ZONE(elem) \
{ /* in theory we should compare with maxp->maxElements but the rasterizer always allocate for MAX_ELEMENTS zones */ \
    if ((int32)elem >= MAX_ELEMENTS || (int32)elem < 0L) \
    { \
	  LocalGS.ercReturn = SECURE_INVALID_ZONE;  /* error returned to client */ \
	  return LocalGS.pbyEndInst; \
    } \
}

#define SECURE_CHECK_FOR_UNITIALIZED_ZONE(elem) \
{ \
	if (LocalGS.globalGS->pgmIndex != GLYPHPROGRAM) \
	/* in the glyph program, both zone (glyph and twilight are initialized */ \
	{ \
	    if (LocalGS.globalGS->pgmIndex != PREPROGRAM || LocalGS.elements != elem ) \
		/* in the pre-program, only the twilight zone is initialized, */ \
		/* in any other zone i.e. font program, none of the zones are initialized */ \
		{ \
	       LocalGS.ercReturn = SECURE_UNITIALIZED_ZONE;  /* error returned to client */ \
	       return LocalGS.pbyEndInst; \
		} \
    } \
}


#define SECURE_CHECK_IDEF_OPCODE(idef) \
{ \
    if ( idef & 0xFFFFFF00 ) \
    { \
	  LocalGS.ercReturn = SECURE_INST_OPCODE_TO_LARGE;  /* error returned to client */ \
	  return LocalGS.pbyEndInst; \
    } \
}

#define SECURE_CHECK_IDEF_OVERFLOW() \
{ \
    if (LocalGS.globalGS->instrDefCount >= LocalGS.globalGS->maxp->maxInstructionDefs) \
    { \
	  LocalGS.ercReturn = SECURE_EXCEEDS_INSTR_DEFS_IN_MAXP;  /* error returned to client */ \
	  return LocalGS.pbyEndInst; \
    } \
}

#define SECURE_CHECK_STORAGE(index) \
{ \
    if ((int32)index >= (LocalGS.globalGS->maxp->maxStorage) || (int32)index < 0L) \
    { \
	  LocalGS.ercReturn = SECURE_STORAGE_OUT_OF_RANGE;  /* error returned to client */ \
	  return LocalGS.pbyEndInst; \
    } \
}

#define SECURE_CHECK_CONTOUR(elem, ctr) \
{ /* The reason in SECURE_CHECK_CONTOUR that we are checking against elem->nc instead of maxContours */ \
	/* is that we will access CE2->sp[contour] and we may try to access a point out of bounds */ \
    if ((int32)ctr < 0L || (int32)ctr >= (elem)->nc) \
    { \
	  LocalGS.ercReturn = SECURE_CONTOUR_OUT_OF_RANGE;  /* error returned to client */ \
	  return LocalGS.pbyEndInst; \
    } \
}

#define SECURE_CHECK_CVT(cvt) \
{ \
    if ((int32)cvt >= (LocalGS.globalGS->cvtCount) || (int32)cvt < 0L) \
    { \
	  LocalGS.ercReturn = SECURE_CVT_OUT_OF_RANGE;  /* error returned to client */ \
	  return LocalGS.pbyEndInst; \
    } \
}

#ifdef FSCFG_FONTOGRAPHER_BUG
#define SECURE_CHECK_CVT_READ_SPECIAL(cvt) \
{ \
    if (((int32)cvt >= (LocalGS.globalGS->cvtCount) && cvt > 255) || (int32)cvt < 0L) \
    { \
	  LocalGS.ercReturn = SECURE_CVT_OUT_OF_RANGE;  /* error returned to client */ \
	  return LocalGS.pbyEndInst; \
    } \
}
#endif // FSCFG_FONTOGRAPHER_BUG

#else

#define SECURE_CHECK_FOR_POP(stackPtr, lNumItems) 
#define SECURE_CHECK_FOR_PUSH(stackPtr, lNumItems) 
#define SECURE_CHECK_SUBSTACK(stackPtr) 
#define SECURE_CHECK_POINT(elem, pt) 
#define SECURE_CHECK_FDEF(fdef) 
#define SECURE_CHECK_PROGRAM(pgmIndex)
#define SECURE_CHECK_ZONE(elem)
#define SECURE_CHECK_IDEF_OPCODE(idef) 
#define SECURE_CHECK_IDEF_OVERFLOW() 
#define SECURE_CHECK_STORAGE(index) 
#define SECURE_CHECK_CONTOUR(elem, ctr) 
#define SECURE_CHECK_CVT(cvt) 
#define SECURE_CHECK_FOR_UNITIALIZED_ZONE(elem) 

#ifdef FSCFG_FONTOGRAPHER_BUG
#define SECURE_CHECK_CVT_READ_SPECIAL(cvt) 
#endif // FSCFG_FONTOGRAPHER_BUG

#endif


#define BIT0( t ) ( (t) & 0x01 )
#define BIT1( t ) ( (t) & 0x02 )
#define BIT2( t ) ( (t) & 0x04 )
#define BIT3( t ) ( (t) & 0x08 )
#define BIT4( t ) ( (t) & 0x10 )
#define BIT5( t ) ( (t) & 0x20 )
#define BIT6( t ) ( (t) & 0x40 )
#define BIT7( t ) ( (t) & 0x80 )

/****** Element Codes *********/
#define SCE0_CODE       0x13
#define SCE1_CODE       0x14
#define SCE2_CODE       0x15
#define SCES_CODE       0x16

/****** Control Codes *********/
#define IF_CODE         0x58
#define ELSE_CODE       0x1B
#define EIF_CODE        0x59
#define ENDF_CODE       0x2d
#define MD_CODE         0x49

#ifdef FSCFG_SUBPIXEL
	// For SubPixel, rather than deciding within the rounding function whether we're currently
	// running SubPixel at all, and whether we're in the SubPixel-specific direction, we
	// install the appropriate version of the rounding function into the local ParameterBlock.
	// There are two parameters that determine this installation:
	// - a boolean "inSubPixelDirection" in LocalGS, set whenever the pv changes (eg. in SVTCA[X])
	// - an enum "roundState" in localParBlock, set whenever rounding state changes (eg. in RTG[])
	// It is necessary to have variables for these two parameters, because the states they
	// represent change independently, yet the round function depends on both parameters.
	// Whenever any of these two parameters change, we index the matrix "itrp_RoundFunction"
	// below to install the correct rounding function into the local ParameterBlock. 
	// Exception: itrp_RoundDownToGridSP, the SubPixel version of the RDTG function, inspects
	// the pv and actually rounds down to grid if pv == dpv. (cf. comments in itrp_RoundDownToGridSP)
	
	typedef enum { inRtdg = 0, inRdtg, inRutg, inRtg, inRthg, inRoff, inSRnd, inS45Rnd } RoundFunction;
	#ifndef FSCFG_NO_INITIALIZED_DATA
	const
	#endif
		  FntRoundFunc itrp_RoundFunction[2][8]
	#ifndef FSCFG_NO_INITIALIZED_DATA
												=  {{itrp_RoundToDoubleGrid,   itrp_RoundDownToGrid,   itrp_RoundUpToGrid,   itrp_RoundToGrid,   itrp_RoundToHalfGrid,   itrp_RoundOff,   itrp_SuperRound, itrp_Super45Round},
													{itrp_RoundToDoubleGridSP, itrp_RoundDownToGridSP, itrp_RoundUpToGridSP, itrp_RoundToGridSP, itrp_RoundToHalfGridSP, itrp_RoundOffSP, itrp_SuperRound, itrp_Super45Round}}
	#endif
	;
	// Following are two helper macros to update the aforementioned parameters "inSubPixelDirection"
	// and "roundState", along with installing the updated rounding function. The purpose of these
	// macros is to assert correspondence of the two parameters with the rounding function by system,
	// rather than by industriousness. The first helper macro is used whenever the projection vector
	// changes (eg. in SVTCA[X]) which changes whether or not we're in the SubPixel-specific direction.
	// The second helper macro is used whenever the round state changes (eg. in RTG[]).

	// Two versions of the first helper macro to update
	// - localGS.inSubPixelDirection (flag)
	// - localParBlock.RoundValue (func ptr)
	// as a result of a change of the projection vector.
	// We're using two different macros merely because VC wouldn't let us nest an #ifdef within a #define
	#ifdef NoVirtRoundInPrep
		#define UpdateRoundFunctionByProjectionVector(localGS)											\
			{																							\
				fnt_ParameterBlock *par = &(localGS).globalGS->localParBlock;							\
																										\
				(localGS).inSubPixelDirection = RunningSubPixel((localGS).globalGS) && InSubPixelDirection(localGS);							\
				par->RoundValue = itrp_RoundFunction[(localGS).inSubPixelDirection && (Tuned4SubPixel((localGS).globalGS) || (localGS).globalGS->pgmIndex != PREPROGRAM)][par->roundState];	\
			}
	#else
		#define UpdateRoundFunctionByProjectionVector(localGS)											\
			{																							\
				fnt_ParameterBlock *par = &(localGS).globalGS->localParBlock;							\
																										\
				(localGS).inSubPixelDirection = RunningSubPixel((localGS).globalGS) && InSubPixelDirection(localGS);							\
				par->RoundValue = itrp_RoundFunction[(localGS).inSubPixelDirection][par->roundState];	\
			}
	#endif

	// Second helper macro to update
	// - localParBlock.roundState (enum)
	// - localParBlock.RoundValue (func ptr)
	// as a result of a change of the round state.
	#define UpdateRoundFunctionByRoundState(localGS,state)											\
		{																							\
			fnt_ParameterBlock *par = &(localGS).globalGS->localParBlock;							\
																									\
			par->roundState = (state);																\
			par->RoundValue = itrp_RoundFunction[(localGS).inSubPixelDirection][par->roundState];	\
		}

	// Helper macro to used to determine whether or not to skip a delta instruction or function.
	// In backwardscompatibility mode, deltas are skipped if they are in SubPixel direction or
	// if they are applied to an untouched/unmoved point or if they are postIUP. Additionally,
	// deltas are skipped in composites if they are in SubPixel direction for proper centering
	// and vertical positioning of diacritical marks.
	// See also comments in itrp_SHP_Common.
	#ifdef InlineDeltasOnly
		#define AMovedPointInNonSPDirection(localGS,zonePtr,pointNum)							\
			((uint16)(!VerticalSPDirection((localGS).globalGS) ?								\
					  ProjVectInY((localGS)) && ((localGS).globalGS->bCompositeGlyph || ((localGS).zonePtr->f[(pointNum)] & YMOVED && !((localGS).globalGS->subPixelCompatibilityFlags & SPCF_iupyCalled))) :	\
					  ProjVectInX((localGS)) && ((localGS).globalGS->bCompositeGlyph || ((localGS).zonePtr->f[(pointNum)] & XMOVED && !((localGS).globalGS->subPixelCompatibilityFlags & SPCF_iupxCalled)))))
	#endif

#endif // FSCFG_SUBPIXEL

// Macros for rounding to grid etc. The purpose of these macros is to make the code more readable
// in cases such as MIRP, where rounding is performed inline for optimization reasons.
// - All rounding is applied to non-negative numbers only, negative numbers have their sign changed
//   before and after. 
// - Engine compensation is added to the unrounded number. Notice that substituting (literal) 0 for
//   engine will be optimized by the compiler
// - Rounding, in principle, follows the pattern in RTG:
//   - add half the "resolution" (this corresponds to adding 0.5)
//   - mask with the complement of "resolution"-minus-1 (this corresponds to a truncated division by
//	   "resolution", immediately followed by a multiplication by the same amount)
//	   Notice that masking only works with powers of two for the resolution

// for round-to-double-grid, we simply use half the resolution
#define RTDG(x,engine,resolution)	\
	if (x >= 0) {					\
		x += engine;				\
		x += resolution / 4;		\
		x &= ~(resolution / 2 - 1);	\
	} else {						\
		x = -x;						\
		x += engine;				\
		x += resolution / 4;		\
		x &= ~(resolution / 2 - 1);	\
		x = -x;						\
	}

// for round-down-to-grid, we skip the part that adds 0.5
#define RDTG(x,engine,resolution)	\
	if (x >= 0) {					\
		x += engine;				\
		x &= ~(resolution - 1);		\
	} else {						\
		x = -x;						\
		x += engine;				\
		x &= ~(resolution - 1);		\
		x = -x;						\
	}

// for round-up-to-grid, we add "0.9999" instead of 0.5
#define RUTG(x,engine,resolution)	\
	if (x >= 0) {					\
		x += engine;				\
		x += resolution - 1;		\
		x &= ~(resolution - 1);		\
	} else {						\
		x = -x;						\
		x += engine;				\
		x += resolution - 1;		\
		x &= ~(resolution - 1);		\
		x = -x;						\
	}

#define RTG(x,engine,resolution)	\
	if (x >= 0) {					\
		x += engine;				\
		x += resolution / 2;		\
		x &= ~(resolution - 1);		\
	} else {						\
		x = -x;						\
		x += engine;				\
		x += resolution / 2;		\
		x &= ~(resolution - 1);		\
		x = -x;						\
	}

// for round-to-half-grid, we first round-down-to-grid, then add 0.5
#define RTHG(x,engine,resolution)	\
	if (x >= 0) {					\
		x += engine;				\
		x &= ~(resolution - 1);		\
		x += resolution / 2;		\
	} else {						\
		x = -x;						\
		x += engine;				\
		x &= ~(resolution - 1);		\
		x += resolution / 2;		\
		x = -x;						\
	}

// for round-off, we have to do the engine compensation part only
#define ROFF(x,engine,resolution)	\
	if (x >= 0) {					\
		x += engine;				\
	} else {						\
		x -= engine;				\
	}


// Macro for testing against cvt cut-in. The purpose of this macro is to make the code more readable
// in cases such as MIRP, where this test is performed in various places in accordance with #defines
// and flags. Notice that substituting (literal) 1 for overscale will be optimized by the compiler.
#define CVTCI(parameterBlock,distance,originalDistance,overscale)													\
	{																												\
		F26Dot6 difference = distance - originalDistance;															\
		difference *= overscale;																					\
		if (difference > parameterBlock->wTCI || difference < -parameterBlock->wTCI) /* not within cvt cut-in? */	\
			distance = originalDistance;																			\
	}

/* Set default values for all variables in globalGraphicsState DefaultParameterBlock
 *      Eventually, we should provide for a Default preprogram that could optionally be 
 *      run at this time to provide a different set of default values.
 */
ErrorCode itrp_SetDefaults (
	void *  pvGlobalGS,
	Fixed   fxPixelDiameter)
{
  fnt_ParameterBlock *par;
  fnt_GlobalGraphicStateType *  globalGS;

  globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

  par = &globalGS->defaultParBlock;

#ifdef FSCFG_SUBPIXEL
  par->roundState = inRtg;
  par->RoundValue = itrp_RoundFunction[RunningSubPixel(globalGS)
#ifdef NoVirtRoundInPrep
	// at this point, globalGS->pgmIndex is not defined. However, we may assume that we're called
	// exclusively from fsg_RunPreProgram, hence we assume that we're about to do the pre-program
	&& Tuned4SubPixel(globalGS)
#endif
	][par->roundState]; // at this point, LocalGS.inSubPixelDirection may not be defined
#else
  par->RoundValue = itrp_RoundToGrid;
#endif
  par->minimumDistance = FNT_PIXELSIZE;
  par->wTCI = FNT_PIXELSIZE * 17 / 16;
  par->sWCI = 0;
  par->sW   = 0;
  par->autoFlip = true;
  par->deltaBase = 9;
  par->deltaShift = 3;
  par->angleWeight = 128;
  par->scanControl = 0;
  par->instructControl = 0;

/* Set up the engine compensation array for the interpreter */
/* This will be indexed into by the booleans in some instructions */
  globalGS->engine[0] = globalGS->engine[3] = 0;                     /* Grey and ? distance */
  globalGS->engine[1] = FIXEDTODOT6 (FIXEDSQRT2 - fxPixelDiameter);  /* Black distance */
  globalGS->engine[2] = -globalGS->engine[1];                        /* White distance */

  return NO_ERR;
}

/************************************************************************/

/*
 * Illegal instruction trap
 */
FS_PRIVATE uint8* itrp_IllegalInstruction (IPARAM)
{
	FS_UNUSED_PARAMETER(lOpCode);
	FS_UNUSED_PARAMETER(pbyInst);

	LocalGS.ercReturn = UNDEFINED_INSTRUCTION_ERR;  /* returned to client */
	return LocalGS.pbyEndInst;                      /* stops innerEx loop */
}

/************************************************************************/

/*  Scale vector (x,y) to unit length in 2.14   rewrite - 1/25/93 - deanb */

FS_PUBLIC void itrp_Normalize (F26Dot6 x, F26Dot6 y, VECTOR *pVec)
{
	Fract fLength;
	int32 lSumOfSquares;
	 int32 lShift;

	CHECK_RANGE (x, -32768L << 6, 32767L << 6);
	CHECK_RANGE (y, -32768L << 6, 32767L << 6);


	if ((x == 0L) && (y == 0L))             /* if null vector in */
	{
		pVec->x = ONEVECTOR;                /* default to unit x vector */
		pVec->y = 0;
	}
	else
	{
		if ((x < 32767L) && (x > -32768L) && (y < 32767L) && (y > -32768L))
		{
			lSumOfSquares = (x * x) + (y * y);  
			
				lShift = 8 * sizeof(Fract) - 17; /* to get x and y to 2.30 */
			while (lSumOfSquares < 0x20000000L)
			{
				lSumOfSquares <<= 2;        /* maximize precision */
					 lShift++;
			}
				x <<= lShift;
				y <<= lShift;                         /* keep x and y in step */
		}
		else
		{
			while ((x < 0x20000000L) && (x > -0x20000000L) && (y < 0x20000000L) && (y > -0x20000000L))
			{
				x <<= 1;
				y <<= 1;
			}
			lSumOfSquares = FracMul(x, x) + FracMul(y, y);
		}
		fLength = FracSqrt(lSumOfSquares);
		pVec->x = ROUNDFIXTOINT (FracDiv(x, fLength));
		pVec->y = ROUNDFIXTOINT (FracDiv(y, fLength));
	}
}


/******************** BEGIN Internal Rounding Routines ***************************/

F26Dot6 itrp_RoundToDoubleGrid (GSP F26Dot6 xin, F26Dot6 engine) {
	F26Dot6 x = xin;

	RTDG(x,engine,FNT_PIXELSIZE);
	if (( (int32) (xin ^ x)) < 0 && xin) {
		x = 0; /* The sign flipped, make zero */
	}
	return x;
} // itrp_RoundToDoubleGrid

#ifdef FSCFG_SUBPIXEL
F26Dot6 itrp_RoundToDoubleGridSP (GSP F26Dot6 xin, F26Dot6 engine) {
	F26Dot6 x = xin;

	engine /= ENGINE_COMP_OVERSCALE;
	RTDG(x,engine,VIRTUAL_PIXELSIZE_RTDG);
	if (( (int32) (xin ^ x)) < 0 && xin) {
		x = 0; /* The sign flipped, make zero */
	}
	return x;
} // itrp_RoundToDoubleGridSP
#endif


F26Dot6 itrp_RoundDownToGrid (GSP F26Dot6 xin, F26Dot6 engine) {
	F26Dot6 x = xin;

	RDTG(x,engine,FNT_PIXELSIZE);
	if (( (int32) (xin ^ x)) < 0 && xin) {
		x = 0; /* The sign flipped, make zero */
	}
	return x;
} // itrp_RoundDownToGrid

#ifdef FSCFG_SUBPIXEL
F26Dot6 itrp_RoundDownToGridSP (GSP F26Dot6 xin, F26Dot6 engine) {
#ifdef RDTGRoundsDownToGrid
	// Historically, if a point to be aligned was away by 1.5 degrees or more from the line to which to align, the TypemanTalk
	// Align has translated to SPVTL, followed by RDTG and MDRP. This has a major problem: The MDRP instruction uses the set pv
	// to measure the original distance on the UNINSTRUCTED outline. This gives us an "original" distance which is more or less
	// wrong, depending on how far the reference point has moved already (notice that it is most likely that the reference point
	// has moved somewhat in x and in y before the alignee gets to be aligned). Subsequently, when MDRP gets to move the point,
	// it uses the same pv again, but this time around on the INSTRUCTED outline, in order to determine how far the point has to
	// be moved in the end. Luckily, this is used in connection with RDTG, which is applied to the "original" distance, and
	// thereby often reduces the "original" distance to 0, which often is closer the the correct original distance than the one
	// obtained by using the pv on the uninstructed outline.
	//   In SubPixel, however, these erroneous "original" distances would be rounded down to the nearest 1/16 of a pixel, and
	// with that become highly visible (a distance of just under 1 pixel, which is what gets rounded down to 0 in b/w, is too
	// large a distance to be ignored in SP). Therefore, we have to make an exception here. The recently introduced TypemanTalk
	// DAlign command, in contrast, uses the DUAL projection vector to measure the original distance on the UNINSTRUCTED outline,
	// which gives us the correct original distance. Therefore the exception is to test whether we're using the PV (in which case
	// we fall back onto the b/w rounding) or not (in which case we're using the SP rounding).
	if (Tuned4SubPixel(LocalGS.globalGS) || LocalGS.OldProject != itrp_Project) { // we're using the dual projection vector
#endif
		F26Dot6 x = xin;

		engine /= ENGINE_COMP_OVERSCALE;
		RDTG(x,engine,VIRTUAL_PIXELSIZE_RDTG);
		if (( (int32) (xin ^ x)) < 0 && xin) {
			x = 0; /* The sign flipped, make zero */
		}
		return x;
#ifdef RDTGRoundsDownToGrid
	} else { // we're using the "normal" projection vector
		return itrp_RoundDownToGrid(GSA xin,engine);
	}
#endif
} // itrp_RoundDownToGridSP
#endif


F26Dot6 itrp_RoundUpToGrid (GSP F26Dot6 xin, F26Dot6 engine) {
	F26Dot6 x = xin;

	RUTG(x,engine,FNT_PIXELSIZE);
	if (( (int32) (xin ^ x)) < 0 && xin) {
		x = 0; /* The sign flipped, make zero */
	}
	return x;
} // itrp_RoundUpToGrid

#ifdef FSCFG_SUBPIXEL
F26Dot6 itrp_RoundUpToGridSP (GSP F26Dot6 xin, F26Dot6 engine) {
	F26Dot6 x = xin;

	engine /= ENGINE_COMP_OVERSCALE;
	RUTG(x,engine,VIRTUAL_PIXELSIZE_RUTG);
	if (( (int32) (xin ^ x)) < 0 && xin) {
		x = 0; /* The sign flipped, make zero */
	}
	return x;
} // itrp_RoundUpToGridSP
#endif


F26Dot6 itrp_RoundToGrid (GSP F26Dot6 xin, F26Dot6 engine) {
	F26Dot6 x = xin;

	RTG(x,engine,FNT_PIXELSIZE);
	if (( (int32) (xin ^ x)) < 0 && xin) {
		x = 0; /* The sign flipped, make zero */
	}
	return x;
} // itrp_RoundToGrid

#ifdef FSCFG_SUBPIXEL
F26Dot6 itrp_RoundToGridSP (GSP F26Dot6 xin, F26Dot6 engine) {
	F26Dot6 x = xin;

	engine /= ENGINE_COMP_OVERSCALE;
	RTG(x,engine,VIRTUAL_PIXELSIZE_RTG);
	if (( (int32) (xin ^ x)) < 0 && xin) {
		x = 0; /* The sign flipped, make zero */
	}
	return x;
} // itrp_RoundToGridSP
#endif


F26Dot6 itrp_RoundToHalfGrid (GSP F26Dot6 xin, F26Dot6 engine) {
	F26Dot6 x = xin;

	RTHG(x,engine,FNT_PIXELSIZE);
	if (((xin ^ x)) < 0 && xin) {
		x = xin > 0 ? FNT_PIXELSIZE / 2 : -FNT_PIXELSIZE / 2; /* The sign flipped, make equal to smallest valid value */
	}
	return x;
} // itrp_RoundToHalfGrid

#ifdef FSCFG_SUBPIXEL
F26Dot6 itrp_RoundToHalfGridSP (GSP F26Dot6 xin, F26Dot6 engine) {
	F26Dot6 x = xin;

	engine /= ENGINE_COMP_OVERSCALE;
	RTHG(x,engine,VIRTUAL_PIXELSIZE_RTHG);
	if (((xin ^ x)) < 0 && xin) {
		x = xin > 0 ? VIRTUAL_PIXELSIZE_RTHG / 2 : -VIRTUAL_PIXELSIZE_RTHG / 2; /* The sign flipped, make equal to smallest valid value */
	}
	return x;
} // itrp_RoundToHalfGridSP
#endif


/*
 * Internal rounding routine
 */
F26Dot6 itrp_RoundOff (GSP F26Dot6 xin, F26Dot6 engine) {
	F26Dot6 x = xin;

	ROFF(x,engine,FNT_PIXELSIZE);
	if (( (int32) (xin ^ x)) < 0 && xin) {
		x = 0; /* The sign flipped, make zero */
	}
	return x;
} // itrp_RoundOff

/*
 * Internal rounding routine
 */
#ifdef FSCFG_SUBPIXEL
F26Dot6 itrp_RoundOffSP (GSP F26Dot6 xin, F26Dot6 engine) {
	F26Dot6 x = xin;

	engine /= ENGINE_COMP_OVERSCALE;
	ROFF(x,engine,VIRTUAL_PIXELSIZE_ROFF);
	if (( (int32) (xin ^ x)) < 0 && xin) {
		x = 0; /* The sign flipped, make zero */
	}
	return x;
} // itrp_RoundOffSP
#endif


/************************************************************************/

/*
 * Internal rounding routine
 */
F26Dot6 itrp_SuperRound (GSP  F26Dot6 xin, F26Dot6 engine) { // B.St. to check
  F26Dot6 x = xin;
  fnt_ParameterBlock *pb = &LocalGS.globalGS->localParBlock;

  if (x >= 0) 
  {
	x += engine;
	x += pb->threshold - pb->phase;
	x &= pb->periodMask;
	x += pb->phase;
  } 
  else 
  {
	x = -x;
	x += engine;
	x += pb->threshold - pb->phase;
	x &= pb->periodMask;
	x += pb->phase;
	x = -x;
  }
  if (( (int32) (xin ^ x)) < 0 && xin) 
  {
	x = xin > 0 ? pb->phase : -pb->phase; /* The sign flipped, make equal to smallest phase */
  }
  return x;
}


/*
 * Internal rounding routine
 */
F26Dot6 itrp_Super45Round (GSP  F26Dot6 xin, F26Dot6 engine) { // B.St. to check
  F26Dot6 x = xin;
  fnt_ParameterBlock *pb = &LocalGS.globalGS->localParBlock;

  if (x >= 0) 
  {
	x += engine;
	x += pb->threshold - pb->phase;
	x = (F26Dot6) VECTORDIV (x, pb->period45);
	x  &= ~ (FNT_PIXELSIZE - 1);
	x = (F26Dot6) VECTORMUL (x, pb->period45);
	x += pb->phase;
  } 
  else 
  {
	x = -x;
	x += engine;
	x += pb->threshold - pb->phase;
	x = (F26Dot6) VECTORDIV (x, pb->period45);
	x  &= ~ (FNT_PIXELSIZE - 1);
	x = (F26Dot6) VECTORMUL (x, pb->period45);
	x += pb->phase;
	x = -x;
  }
  if (((xin ^ x)) < 0 && xin)
  {
	x = xin > 0 ? pb->phase : -pb->phase; /* The sign flipped, make equal to smallest phase */
  }
  return x;
}


/******************** END Rounding Routines ***************************/


/* 3-versions ************************************************************************/

/*
 * Moves the point in element by delta (measured against the projection vector)
 * along the freedom vector.
 */

FS_PRIVATE void itrp_MovePoint (GSP fnt_ElementType *element, int32 point, F26Dot6 delta)
{
	VECTORTYPE pfProj;
	VECTORTYPE fx;
	VECTORTYPE fy;
	  
	pfProj = LocalGS.pfProj;
	fx = LocalGS.free.x;
	fy = LocalGS.free.y;

	CHECK_POINT (&LocalGS, element, point);

	if (pfProj != ONEVECTOR)
	{
		if (fx) 
		{
			if (pfProj == fx)                   /* if proj.x = 1 */
			{
				element->x[point] += delta;
			}
			else
			{
				element->x[point] += LongMulDiv (delta, (int32)fx, (int32)pfProj);
			}
			element->f[point] |= XMOVED;
		}
		if (fy) 
		{
			if (pfProj == fy)                   /* if proj.y = 1 */
			{
				element->y[point] += delta;
			}
			else
			{
				element->y[point] += LongMulDiv (delta, (int32)fy, (int32)pfProj);
			}
			element->f[point] |= YMOVED;
		}
	}
	else
	{
		if (fx) 
		{
			element->x[point] += VECTORMUL (delta, fx);
			element->f[point] |= XMOVED;
		}
		if (fy) 
		{
			element->y[point] += VECTORMUL (delta, fy);
			element->f[point] |= YMOVED;
		}
	}
}


/*
 * For use when the projection and freedom vectors coincide along the x-axis.
 */

FS_PRIVATE void itrp_XMovePoint (GSP fnt_ElementType*element, int32 point, F26Dot6 delta)
{
  CHECK_POINT (&LocalGS, element, point);
  element->x[point] += delta;
  element->f[point] |= XMOVED;
}


/*
 * For use when the projection and freedom vectors coincide along the y-axis.
 */
FS_PRIVATE void itrp_YMovePoint (GSP fnt_ElementType *element, int32 point, F26Dot6 delta)
{
  CHECK_POINT (&LocalGS, element, point);
  element->y[point] += delta;
  element->f[point] |= YMOVED;
}

/*
 * projects x and y into the projection vector.
 */
FS_PRIVATE F26Dot6 itrp_Project (GSP F26Dot6 x, F26Dot6 y)
{
  return (F26Dot6) (VECTORMUL (x, LocalGS.proj.x) + VECTORMUL (y, LocalGS.proj.y));
}


/*
 * projects x and y into the old projection vector.
 */
FS_PRIVATE F26Dot6 itrp_OldProject (GSP F26Dot6 x, F26Dot6 y)
{
  return (F26Dot6) (VECTORMUL (x, LocalGS.oldProj.x) + VECTORMUL (y, LocalGS.oldProj.y));
}


/*
 * Projects when the projection vector is along the x-axis
 */
F26Dot6 itrp_XProject (GSP F26Dot6 x, F26Dot6 y)
{
  FS_UNUSED_PARAMETER(y);

  return (x);
}


/*
 * Projects when the projection vector is along the y-axis
 */
F26Dot6 itrp_YProject (GSP F26Dot6 x, F26Dot6 y)
{
  FS_UNUSED_PARAMETER(x);

  return (y);
}


/*************************************************************************/

/*** Compensation for Transformations ***/

/*
* Internal support routine, keep this guy FAST!!!!!!!          <3>
*/
FS_PRIVATE Fixed itrp_GetCVTScale (GSP0)
{
  VECTORTYPE pvx, pvy;
  fnt_GlobalGraphicStateType *globalGS = LocalGS.globalGS;
  Fixed sySq, sxSq, strSq;

/* Do as few Math routines as possible to gain speed */

  pvx = LocalGS.proj.x;
  pvy = LocalGS.proj.y;
  if (pvy) 
  {
	if (pvx)
	{
	  if (LocalGS.cvtDiagonalStretch == 0)    /* cache is now invalid */
	  {
		pvy = VECTORDOT (pvy, pvy);
		pvx = VECTORDOT (pvx, pvx);
		sySq = FixMul (globalGS->cvtStretchY, globalGS->cvtStretchY);
		sxSq = FixMul (globalGS->cvtStretchX, globalGS->cvtStretchX);

		strSq = FixMul (VECTOR2FIX(pvx),sxSq) + FixMul (VECTOR2FIX(pvy),sySq);
		if  (strSq > ONEFIX)      /* Never happens! */
		  return ONEFIX;

		/* Convert 16.16 to 2.30, compute square root, round to 16.16 */
		LocalGS.cvtDiagonalStretch = (FracSqrt (strSq<<14) + (1<<13)) >> 14;
	  }
	  return LocalGS.cvtDiagonalStretch;
	}
	else        /* pvy == +1 or -1 */
	  return globalGS->cvtStretchY;
  }
  else  /* pvx == +1 or -1 */
	return globalGS->cvtStretchX;
}


/*      Functions for function pointer in local graphic state
*/

FS_PRIVATE F26Dot6 itrp_GetCVTEntryFast (GSP int32 n)
{
  CHECK_CVT (&LocalGS, n);
  return LocalGS.globalGS->controlValueTable[ n ];
}


FS_PRIVATE F26Dot6 itrp_GetCVTEntrySlow (GSP int32 n)
{
  Fixed scale;

  CHECK_CVT (&LocalGS, n);
  scale = itrp_GetCVTScale (GSA0);
  return (F26Dot6) (FixMul (LocalGS.globalGS->controlValueTable[ n ], scale));
}


FS_PRIVATE F26Dot6 itrp_GetSingleWidthFast (GSP0)
{
  return LocalGS.globalGS->localParBlock.scaledSW;
}


/*
 *
 */
FS_PRIVATE F26Dot6 itrp_GetSingleWidthSlow (GSP0)
{
  Fixed scale;

  scale = itrp_GetCVTScale (GSA0);
  return (F26Dot6) (FixMul (LocalGS.globalGS->localParBlock.scaledSW, scale));
}


/*************************************************************************/

FS_PRIVATE void itrp_ChangeCvtFast (GSP fnt_ElementType*elem, int32 number, F26Dot6 delta)
{
  FS_UNUSED_PARAMETER(elem);
  CHECK_CVT (&LocalGS, number);
  LocalGS.globalGS->controlValueTable[ number ] += delta;
}



/*************************************************************************/

FS_PRIVATE void itrp_ChangeCvtSlow (GSP fnt_ElementType*elem, int32 number, F26Dot6 delta)
{
  FS_UNUSED_PARAMETER(elem);

  CHECK_CVT (&LocalGS, number);

  delta = FixDiv (delta, itrp_GetCVTScale(GSA0));
  LocalGS.globalGS->controlValueTable[ number ] += delta;
}

/*************************************************************************/

/*
 * This is the tracing interpreter.
 */
FS_PRIVATE void itrp_InnerTraceExecute (GSP uint8 *pbyInst, uint8 *pbyEndInst)
{
	int32 lOpCode;

	LocalGS.pbyEndInst = pbyEndInst;                /* for illegal instruction */
	LocalGS.pbyStartInst = pbyInst;                /* to detect jump before the begining */

	if (pbyInst < pbyEndInst)
	{
		ERR_START ();
		while ((pbyInst < pbyEndInst) && (LocalGS.TraceFunc != NULL))
		{
			LocalGS.insPtr = pbyInst;               /* save for client */
			LocalGS.opCode = *pbyInst;              /* save for client */
			ERR_RECORD (*pbyInst);
			LocalGS.TraceFunc (&LocalGS, pbyEndInst);
			if (LocalGS.TraceFunc == NULL)          /* allow client to break out */
			{
				break;
			}
			lOpCode = (int32)*pbyInst;
			pbyInst++;
			pbyInst = function[ lOpCode ] (GSA pbyInst, lOpCode);
			ERR_BREAK ();
		}
		ERR_END ();
	}
}

/*************************************************************************/

/*
 * This is the fast non-tracing interpreter inner loop.
 */

FS_PRIVATE void itrp_InnerExecute (GSP uint8 *pbyInst, uint8 *pbyEndInst)
{
	int32 lOpCode;

	ERR_START ();
	
	LocalGS.pbyEndInst = pbyEndInst;                /* for illegal instruction */
	LocalGS.pbyStartInst = pbyInst;                /* to detect jump before the begining */
	
	while (pbyInst < pbyEndInst)
	{
		ERR_RECORD (*pbyInst);
			  
		lOpCode = (int32)*pbyInst;  /* opCode no longer saved in LocalGS */
		pbyInst++;

		pbyInst = function[ lOpCode ] (GSA pbyInst, lOpCode);
		ERR_BREAK ();
	}
	ERR_END ();
}

/*************************************************************************/


#ifdef FSCFG_DEBUG
FS_PRIVATE F26Dot6 itrp_GetSingleWidthNil (GSP0);
FS_PRIVATE F26Dot6 itrp_GetCVTEntryNil (GSP int32 n);

FS_PRIVATE F26Dot6 itrp_GetSingleWidthNil (GSP0)
{
  ERR_REPORT (ERR_GETSINGLEWIDTHNIL, 0, 0, 0, 0);
  return 0;
}

FS_PRIVATE F26Dot6 itrp_GetCVTEntryNil (GSP int32 n)
{
  ERR_REPORT (ERR_GETCVTENTRYNIL, 0, 0, 0, 0);
  return 0;
}
#endif

/*************************************************************************/

FS_PUBLIC ErrorCode  itrp_ExecuteFontPgm(
	fnt_ElementType *   pTwilightElement,
	fnt_ElementType *   pGlyphElement,
	void *              pvGlobalGS,
	 FntTraceFunc           TraceFunc)
{
	fnt_GlobalGraphicStateType *    globalGS;

#ifdef FSCFG_SECURE
	int32 i;
#endif // FSCFG_SECURE

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

	globalGS->instrDefCount = 0;        /* none allocated yet, always do this, even if there's no fontProgram */
	globalGS->init          = TRUE;
	globalGS->pgmIndex = FONTPROGRAM;

	/* To avoid accessing unitialized memory when setting LocalGS.MIRPCode */
    globalGS->engine[0] = globalGS->engine[3] = 0;                     /* Grey and ? distance */
    globalGS->engine[1] = 0;  /* Black distance */
    globalGS->engine[2] = 0;                        /* White distance */

#ifdef FSCFG_SUBPIXEL
		// init since we don't do itrp_SetDefaults prior to executing the fpgm
    globalGS->localParBlock.roundState = inRtg;
    globalGS->localParBlock.RoundValue = itrp_RoundToGrid;

    globalGS->subPixelCompatibilityFlags = 0;
    globalGS->numDeltaFunctionsDetected = 0;
#endif

#ifdef FSCFG_SECURE
	/* initialize globalGS->funcDef[...].pgmIndex with MAXPREPROGRAMS to detect calls to undefined functions */
	for (i = 0; i < globalGS->maxp->maxFunctionDefs; i++)
	{
		globalGS->funcDef[i].pgmIndex = MAXPREPROGRAMS;

	}
#endif // FSCFG_SECURE

	if (globalGS->pgmList[FONTPROGRAM].Instruction)
	{
		return itrp_Execute (
			pTwilightElement,
			pGlyphElement,
			globalGS->pgmList[FONTPROGRAM].Instruction,
			globalGS->pgmList[FONTPROGRAM].Instruction +
				globalGS->pgmList[FONTPROGRAM].Length,
			globalGS,
			TraceFunc);
	}
	return NO_ERR;
}

/*************************************************************************/

FS_PUBLIC ErrorCode  itrp_ExecutePrePgm(
	fnt_ElementType *   pTwilightElement,
	fnt_ElementType *   pGlyphElement,
	void *              pvGlobalGS,
	 FntTraceFunc           TraceFunc)
{
	ErrorCode   result;
	fnt_GlobalGraphicStateType *    globalGS;

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

	globalGS->init          = TRUE;
	globalGS->localParBlock = globalGS->defaultParBlock;    /* copy gState parameters */

	globalGS->pgmIndex = PREPROGRAM;

	if (globalGS->pgmList[PREPROGRAM].Instruction)
	{
		result = itrp_Execute (
			pTwilightElement,
			pGlyphElement,
			globalGS->pgmList[PREPROGRAM].Instruction,
			globalGS->pgmList[PREPROGRAM].Instruction + globalGS->pgmList[PREPROGRAM].Length,
			globalGS,
			TraceFunc);
	}
	else
	{
		result = NO_ERR;
	}

	if (! (globalGS->localParBlock.instructControl & DEFAULTFLAG))
		globalGS->defaultParBlock = globalGS->localParBlock;    /* change default parameters */

	return result;
}

/*************************************************************************/

FS_PUBLIC ErrorCode  itrp_ExecuteGlyphPgm(
	fnt_ElementType *   pTwilightElement,
	fnt_ElementType *   pGlyphElement,
	uint8 *             ptr,
	uint8 *    eptr,
	void *              pvGlobalGS,
	 FntTraceFunc           TraceFunc,
	uint16 *            pusScanType,
	uint16 *            pusScanControl,
	boolean *           pbChangeScanControl)
{
	ErrorCode                       result;
	fnt_GlobalGraphicStateType *    globalGS;

	globalGS = (fnt_GlobalGraphicStateType *)pvGlobalGS;

	result = NO_ERR;

	globalGS->init          = FALSE;
	globalGS->pgmIndex		= GLYPHPROGRAM;
	globalGS->localParBlock = globalGS->defaultParBlock;    /* default parameters for glyphs */
	
	if (!(globalGS->localParBlock.instructControl & NOGRIDFITFLAG))
	{
		result = itrp_Execute (
			pTwilightElement,
			pGlyphElement,
			ptr,
			eptr,
			globalGS,
			TraceFunc);
	}
	*pbChangeScanControl = (globalGS->localParBlock.scanControl !=
						   globalGS->defaultParBlock.scanControl);
	 *pusScanControl = FS_LOWORD(globalGS->localParBlock.scanControl);
	 *pusScanType =  FS_HIWORD(globalGS->localParBlock.scanControl);

	return result;
}

/*************************************************************************/

/*
 * Executes the font instructions.
 *
 * Parameter Description
 *
 * elements points to the character elements. Element 0 is always
 * reserved and not used by the actual character.
 *
 * ptr points at the first instruction.
 * eptr points to right after the last instruction
 *
 * globalGS points at the global graphics state
 *
 * TraceFunc is pointer to a callback functioned called with a pointer to the
 *              local graphics state if TraceFunc is not null.
 *
 * Note: The stuff globalGS is pointing at must remain intact
 *       between calls to this function.
 */
FS_PRIVATE ErrorCode itrp_Execute (
	fnt_ElementType *               pTwilightElement,
	fnt_ElementType *               pGlyphElement,
	uint8 *                         ptr,
	uint8 *                         eptr,
	fnt_GlobalGraphicStateType *    globalGS,
	 FntTraceFunc                           TraceFunc)

{
#ifdef FSCFG_REENTRANT
	fnt_LocalGraphicStateType thisLocalGS;
	fnt_LocalGraphicStateType* pLocalGS = &thisLocalGS;
#endif
	fnt_ElementType       aElements[MAX_ELEMENTS];

	MEMCPY((void*)&(aElements[TWILIGHTZONE]), (void*)pTwilightElement, sizeof (fnt_ElementType));
	MEMCPY((void*)&(aElements[GLYPHELEMENT]), (void*)pGlyphElement, sizeof (fnt_ElementType));
	
	STAT_ON_FNTEXEC;                        /* start STAT timer */    
	
	LocalGS.globalGS = globalGS;            /* init Local Graphics State */
	LocalGS.elements = aElements;
	LocalGS.Pt0 = 0; 
	LocalGS.Pt1 = 0; 
	LocalGS.Pt2 = 0;
	LocalGS.CE0 = &aElements[GLYPHELEMENT];
	LocalGS.CE1 = &aElements[GLYPHELEMENT];
	LocalGS.CE2 = &aElements[GLYPHELEMENT];
	LocalGS.free.x = ONEVECTOR;
	LocalGS.proj.x = ONEVECTOR;
	LocalGS.oldProj.x = ONEVECTOR;
	LocalGS.free.y = 0;
	LocalGS.proj.y = 0;
	LocalGS.oldProj.y = 0;
	LocalGS.pfProj = ONEVECTOR;
	LocalGS.MovePoint = itrp_XMovePoint;
	LocalGS.Project = itrp_XProject;
	LocalGS.OldProject = itrp_XProject;
	LocalGS.loop = 0;           /* 1 less than count for faster loops. mrr */

	LocalGS.ulJumpCounter = globalGS->ulMaxJumpCounter;           /* counter used to catch infinite loops */
	LocalGS.ulRecursiveCall = globalGS->ulMaxRecursiveCall;           /* counter used to catch deep recrusion */

	if (globalGS->engine[1] == 0)           /* if engine compenstion turned off */
	{
		LocalGS.MIRPCode = MIRPX;           /* default to fast mirp */
	}
	else
	{
		LocalGS.MIRPCode = MIRPG;           /* fall back to general mirp */
	}

	if (globalGS->pgmIndex == FONTPROGRAM)
	{
#ifdef FSCFG_DEBUG
		LocalGS.GetCVTEntry = itrp_GetCVTEntryNil;
		LocalGS.GetSingleWidth = itrp_GetSingleWidthNil;
#else
		LocalGS.GetCVTEntry = itrp_GetCVTEntryFast;
		LocalGS.GetSingleWidth = itrp_GetSingleWidthFast;
#endif
		LocalGS.ChangeCvt = itrp_ChangeCvtFast;
	}
	else
	{
#ifdef FSCFG_SUBPIXEL
		globalGS->subPixelCompatibilityFlags &= ~(SPCF_iupxCalled | SPCF_iupyCalled | SPCF_inVacuformRound | SPCF_inSkippableDeltaFn);
		// can't do this when doing the font program, would try to access the localParBlock, which is still uninitialized at this point.
		UpdateRoundFunctionByProjectionVector(LocalGS);
#endif
#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
		LocalGS.pt0 = LocalGS.pt1 = -1; // points referred to in MDRP for Align as a result of SPVTL and SDPVTL...
#endif
		if (globalGS->pixelsPerEm <= 1)
			return NO_ERR;
		  
		if (globalGS->bSameStretch)
		{
			LocalGS.GetCVTEntry = itrp_GetCVTEntryFast;
			LocalGS.GetSingleWidth = itrp_GetSingleWidthFast;
			LocalGS.ChangeCvt = itrp_ChangeCvtFast;
		} 
		else 
		{
			LocalGS.GetCVTEntry = itrp_GetCVTEntrySlow;
			LocalGS.GetSingleWidth = itrp_GetSingleWidthSlow;
			LocalGS.ChangeCvt = itrp_ChangeCvtSlow;
			LocalGS.MIRPCode = MIRPG;       /* fall back to general mirp */
		}

		if (globalGS->localParBlock.sW)     /* We need to scale the single width for this size  */
		{
			globalGS->localParBlock.scaledSW = globalGS->ScaleFuncCVT (&globalGS->scaleCVT, (F26Dot6)(globalGS->localParBlock.sW));
			LocalGS.MIRPCode = MIRPG;       /* fall back to general mirp */
		}
	}
	
	LocalGS.stackPointer = globalGS->stackBase;
	LocalGS.TraceFunc = TraceFunc;
	LocalGS.ercReturn = NO_ERR;             /* default return value */

	if (TraceFunc != NULL)
	{
		LocalGS.Interpreter = itrp_InnerTraceExecute;
	}
	else
	{
		LocalGS.Interpreter = itrp_InnerExecute;
	}
#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
		if (globalGS->pgmIndex == GLYPHPROGRAM && RunningSubPixel(globalGS) && CompatibleWidthSP(globalGS))
			InitPhaseControl(LocalGS.CE0);
#endif

	(*LocalGS.Interpreter) (GSA ptr, eptr);

#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	if (LocalGS.globalGS->pgmIndex == GLYPHPROGRAM && RunningSubPixel(LocalGS.globalGS) && CompatibleWidthSP(LocalGS.globalGS) &&
		!LocalGS.CE0->phaseControlExecuted) {
		ExecutePhaseControl(&LocalGS,LocalGS.CE0);
	//	phaseControlExecuted == true by now
	}
#endif
	STAT_OFF_FNTEXEC;                            /* stop STAT timer */
	
	return LocalGS.ercReturn;               /* NO_ERR unless illegal inst */
}


/*************************************************************************/

/*** 2 internal LocalGS.pfProj computation support routines ***/

/*
 * Only does the check of LocalGS.pfProj
 */
  FS_PRIVATE void itrp_Check_PF_Proj (GSP0)
  {
	VECTORTYPE pfProj = LocalGS.pfProj;

	if (pfProj > -ONESIXTEENTHVECTOR && pfProj < ONESIXTEENTHVECTOR) 
	{
	  LocalGS.pfProj = (VECTORTYPE)(pfProj < 0 ? -ONEVECTOR : ONEVECTOR); /* Prevent divide by small number */
	}
  }


/*
 * Computes LocalGS.pfProj and then does the check
 */
  FS_PRIVATE void itrp_ComputeAndCheck_PF_Proj (GSP0)
  {
	VECTORTYPE pfProj;

	pfProj = (VECTORTYPE)(VECTORDOT (LocalGS.proj.x, LocalGS.free.x) + VECTORDOT (LocalGS.proj.y, LocalGS.free.y));
	if (pfProj > -ONESIXTEENTHVECTOR && pfProj < ONESIXTEENTHVECTOR) 
	{
	  pfProj = (VECTORTYPE)(pfProj < 0 ? -ONEVECTOR : ONEVECTOR); /* Prevent divide by small number */
	}
	LocalGS.pfProj = pfProj;

	LocalGS.cvtDiagonalStretch = 0;      /* invalidate cache */ 
  }

/******************************************/
/******** The Actual Instructions *********/
/******************************************/

/*
 * Set Vectors To Coordinate Axis - Y
 */
  FS_PRIVATE uint8* itrp_SVTCA_0 (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);
	LocalGS.free.x = LocalGS.proj.x = 0;
	LocalGS.free.y = LocalGS.proj.y = ONEVECTOR;
	LocalGS.MovePoint = itrp_YMovePoint;
	LocalGS.Project = itrp_YProject;
#ifdef FSCFG_SUBPIXEL
	UpdateRoundFunctionByProjectionVector(LocalGS);
#endif
#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	LocalGS.pt0 = LocalGS.pt1 = -1; // points referred to in MDRP for Align as a result of SPVTL and SDPVTL...
#endif

	LocalGS.OldProject = itrp_YProject;
	LocalGS.pfProj = ONEVECTOR;
	if (LocalGS.MIRPCode != MIRPG)          /* if we haven't fallen back */
	{
		LocalGS.MIRPCode = MIRPY;           /* then use fast mirp */
	}
	return pbyInst;
  }

/*
 * Set Vectors To Coordinate Axis - X
 */
  FS_PRIVATE uint8* itrp_SVTCA_1 (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);
	LocalGS.free.x = LocalGS.proj.x = ONEVECTOR;
	LocalGS.free.y = LocalGS.proj.y = 0;
	LocalGS.MovePoint = itrp_XMovePoint;
	LocalGS.Project = itrp_XProject;
#ifdef FSCFG_SUBPIXEL
	UpdateRoundFunctionByProjectionVector(LocalGS);
#endif
#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	LocalGS.pt0 = LocalGS.pt1 = -1; // points referred to in MDRP for Align as a result of SPVTL and SDPVTL...
#endif

	LocalGS.OldProject = itrp_XProject;
	LocalGS.pfProj = ONEVECTOR;
	if (LocalGS.MIRPCode != MIRPG)          /* if we haven't fallen back */
	{
		LocalGS.MIRPCode = MIRPX;           /* then use fast mirp */
	}
	return pbyInst;
  }

/*
 * Set Projection Vector To Coordinate Axis - Y
 */
  FS_PRIVATE uint8* itrp_SPVTCA_0 (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);
	LocalGS.proj.x = 0;
	LocalGS.proj.y = ONEVECTOR;
	LocalGS.Project = itrp_YProject;
#ifdef FSCFG_SUBPIXEL
	UpdateRoundFunctionByProjectionVector(LocalGS);
#endif
#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	LocalGS.pt0 = LocalGS.pt1 = -1; // points referred to in MDRP for Align as a result of SPVTL and SDPVTL...
#endif

	LocalGS.pfProj = LocalGS.free.y;
	itrp_Check_PF_Proj (GSA0);
	LocalGS.MovePoint = itrp_MovePoint;
	LocalGS.OldProject = LocalGS.Project;
	LocalGS.MIRPCode = MIRPG;               /* fall back to general mirp */
	return pbyInst;
  }

/*
 * Set Projection Vector To Coordinate Axis - X
 */
  FS_PRIVATE uint8* itrp_SPVTCA_1 (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);
	LocalGS.proj.x = ONEVECTOR;
	LocalGS.proj.y = 0;
	LocalGS.Project = itrp_XProject;
#ifdef FSCFG_SUBPIXEL
	UpdateRoundFunctionByProjectionVector(LocalGS);
#endif
#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	LocalGS.pt0 = LocalGS.pt1 = -1; // points referred to in MDRP for Align as a result of SPVTL and SDPVTL...
#endif

	LocalGS.pfProj = LocalGS.free.x;
	itrp_Check_PF_Proj (GSA0);
	LocalGS.MovePoint = itrp_MovePoint;
	LocalGS.OldProject = LocalGS.Project;
	LocalGS.MIRPCode = MIRPG;               /* fall back to general mirp */
	return pbyInst;
  }


/*
 * Set Freedom Vector to Coordinate Axis - Y
 */
  FS_PRIVATE uint8* itrp_SFVTCA_0 (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);
	LocalGS.free.x = 0;
	LocalGS.free.y = ONEVECTOR;
	LocalGS.pfProj = LocalGS.proj.y;
	itrp_Check_PF_Proj (GSA0);
	LocalGS.MovePoint = itrp_MovePoint;
	LocalGS.MIRPCode = MIRPG;               /* fall back to general mirp */
	return pbyInst;
  }

/*
 * Set Freedom Vector to Coordinate Axis - X
 */
  FS_PRIVATE uint8* itrp_SFVTCA_1 (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);
	LocalGS.free.x = ONEVECTOR;
	LocalGS.free.y = 0;
	LocalGS.pfProj = LocalGS.proj.x;
	itrp_Check_PF_Proj (GSA0);
	LocalGS.MovePoint = itrp_MovePoint;
	LocalGS.MIRPCode = MIRPG;               /* fall back to general mirp */
	return pbyInst;
  }


/*
 * Set Projection Vector To Line
 */
  FS_PRIVATE uint8* itrp_SPVTL (IPARAM)
  {
	int32 arg1, arg2;
	
    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);

    arg2 = (int32)CHECK_POP (LocalGS.stackPointer);
	arg1 = (int32)CHECK_POP (LocalGS.stackPointer);

    SECURE_CHECK_POINT (LocalGS.CE2, arg2);
	SECURE_CHECK_POINT (LocalGS.CE1, arg1);

	CHECK_POINT (&LocalGS, LocalGS.CE2, arg2);
	CHECK_POINT (&LocalGS, LocalGS.CE1, arg1);

#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	LocalGS.pt0 = (int16)arg2; LocalGS.pt1 = (int16)arg1; // points referred to in MDRP for Align as a result of SPVTL and SDPVTL...
#endif

	itrp_Normalize (LocalGS.CE1->x[arg1] - LocalGS.CE2->x[arg2], LocalGS.CE1->y[arg1] - LocalGS.CE2->y[arg2], &LocalGS.proj);
	if (BIT0 (lOpCode)) { // rotate 90 degrees, appears to work in non-square aspect ratio as well
	  VECTORTYPE tmp = LocalGS.proj.y;
	  LocalGS.proj.y = LocalGS.proj.x;
	  LocalGS.proj.x = (VECTORTYPE)(-tmp);
	}

	itrp_ComputeAndCheck_PF_Proj (GSA0);
	LocalGS.MovePoint = itrp_MovePoint;
	LocalGS.Project = itrp_Project;
#ifdef FSCFG_SUBPIXEL
	UpdateRoundFunctionByProjectionVector(LocalGS);
#endif
	LocalGS.OldProject = LocalGS.Project;
	LocalGS.MIRPCode = MIRPG;               /* fall back to general mirp */
	return pbyInst;
  }


/*
 * Set Dual Projection Vector To Line
 */
  FS_PRIVATE uint8* itrp_SDPVTL (IPARAM)
  {
	int32 arg1, arg2;

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);

    arg2 = (int32)CHECK_POP (LocalGS.stackPointer);
	arg1 = (int32)CHECK_POP (LocalGS.stackPointer);

    SECURE_CHECK_POINT (LocalGS.CE2, arg2);
	SECURE_CHECK_POINT (LocalGS.CE1, arg1);

    CHECK_POINT (&LocalGS, LocalGS.CE2, arg2);
	CHECK_POINT (&LocalGS, LocalGS.CE1, arg1);

#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	LocalGS.pt0 = (int16)arg2; LocalGS.pt1 = (int16)arg1; // points referred to in MDRP for Align as a result of SPVTL and SDPVTL...
#endif

//	Do the current domain
	itrp_Normalize (LocalGS.CE1->x[arg1] - LocalGS.CE2->x[arg2], LocalGS.CE1->y[arg1] - LocalGS.CE2->y[arg2], &LocalGS.proj);

//	Do the old domain
	itrp_Normalize (LocalGS.CE1->ox[arg1] - LocalGS.CE2->ox[arg2], LocalGS.CE1->oy[arg1] - LocalGS.CE2->oy[arg2], &LocalGS.oldProj);

	if (BIT0 (lOpCode))	{ // rotate 90 degrees, appears to work in non-square aspect ratio as well
	  VECTORTYPE tmp = LocalGS.proj.y;
	  LocalGS.proj.y = LocalGS.proj.x;
	  LocalGS.proj.x = (VECTORTYPE)(-tmp);

	  tmp = LocalGS.oldProj.y;
	  LocalGS.oldProj.y = LocalGS.oldProj.x;
	  LocalGS.oldProj.x = (VECTORTYPE)(-tmp);
	}
	
	itrp_ComputeAndCheck_PF_Proj (GSA0);
	LocalGS.MovePoint = itrp_MovePoint;
	LocalGS.Project = itrp_Project;
#ifdef FSCFG_SUBPIXEL
	UpdateRoundFunctionByProjectionVector(LocalGS);
#endif
	LocalGS.OldProject = itrp_OldProject;
	LocalGS.MIRPCode = MIRPG;               /* fall back to general mirp */
	return pbyInst;
  }

/*
 * Set Freedom Vector To Line
 */
  FS_PRIVATE uint8* itrp_SFVTL (IPARAM)
  {
	int32 arg1, arg2;

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);

    arg2 = (int32)CHECK_POP (LocalGS.stackPointer);
	arg1 = (int32)CHECK_POP (LocalGS.stackPointer);

    SECURE_CHECK_POINT (LocalGS.CE2, arg2);
	SECURE_CHECK_POINT (LocalGS.CE1, arg1);

    CHECK_POINT (&LocalGS, LocalGS.CE2, arg2);
	CHECK_POINT (&LocalGS, LocalGS.CE1, arg1);

	itrp_Normalize (LocalGS.CE1->x[arg1] - LocalGS.CE2->x[arg2], LocalGS.CE1->y[arg1] - LocalGS.CE2->y[arg2], &LocalGS.free);
	if (BIT0 (lOpCode)) { // rotate 90 degrees, appears to work in non-square aspect ratio as well
	  VECTORTYPE tmp     = LocalGS.free.y;
	  LocalGS.free.y     = LocalGS.free.x;
	  LocalGS.free.x     = (VECTORTYPE)(-tmp);
	}
	
	itrp_ComputeAndCheck_PF_Proj (GSA0);
	LocalGS.MovePoint = itrp_MovePoint;
	LocalGS.MIRPCode = MIRPG;               /* fall back to general mirp */
	return pbyInst;
  }


/*
 * Write Projection Vector
 */
  FS_PRIVATE uint8* itrp_WPV (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);

    LocalGS.proj.y = (VECTORTYPE) CHECK_POP (LocalGS.stackPointer);
	LocalGS.proj.x = (VECTORTYPE) CHECK_POP (LocalGS.stackPointer);

#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	LocalGS.pt0 = LocalGS.pt1 = -1; // points referred to in MDRP for Align as a result of SPVTL and SDPVTL...
#endif

	CHECK_VECTOR (LocalGS.proj.x, LocalGS.proj.y);
	itrp_ComputeAndCheck_PF_Proj (GSA0);

	LocalGS.MovePoint = itrp_MovePoint;
	LocalGS.Project = itrp_Project;
#ifdef FSCFG_SUBPIXEL
	UpdateRoundFunctionByProjectionVector(LocalGS);
#endif
	LocalGS.OldProject = LocalGS.Project;
	LocalGS.MIRPCode = MIRPG;               /* fall back to general mirp */
	return pbyInst;
  }

/*
 * Write Freedom vector
 */
  FS_PRIVATE uint8* itrp_WFV (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);

    LocalGS.free.y = (VECTORTYPE) CHECK_POP (LocalGS.stackPointer);
	LocalGS.free.x = (VECTORTYPE) CHECK_POP (LocalGS.stackPointer);

	CHECK_VECTOR (LocalGS.free.x, LocalGS.free.y);
	itrp_ComputeAndCheck_PF_Proj (GSA0);

	LocalGS.MovePoint = itrp_MovePoint;
	LocalGS.MIRPCode = MIRPG;               /* fall back to general mirp */
	return pbyInst;
  }

/*
 * Read Projection Vector
 */
  FS_PRIVATE uint8* itrp_RPV (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);
    SECURE_CHECK_FOR_PUSH (LocalGS.stackPointer, 2);
	CHECK_PUSH (LocalGS.stackPointer, LocalGS.proj.x);
	CHECK_PUSH (LocalGS.stackPointer, LocalGS.proj.y);
	return pbyInst;
  }

/*
 * Read Freedom Vector
 */
  FS_PRIVATE uint8* itrp_RFV (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);
    SECURE_CHECK_FOR_PUSH (LocalGS.stackPointer, 2);
	CHECK_PUSH (LocalGS.stackPointer, LocalGS.free.x);
	CHECK_PUSH (LocalGS.stackPointer, LocalGS.free.y);
	return pbyInst;
  }

/*
 * Set Freedom Vector To Projection Vector
 */
  FS_PRIVATE uint8* itrp_SFVTPV (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);
	LocalGS.free = LocalGS.proj;
	LocalGS.pfProj = ONEVECTOR;
	LocalGS.MovePoint = itrp_MovePoint;
	LocalGS.MIRPCode = MIRPG;               /* fall back to general mirp */
	return pbyInst;
  }

/*
 * itrp_ISECT ()
 *
 * Computes the intersection of two lines without using floating point!!
 *
 * (1) Bx + dBx * t0 = Ax + dAx * t1
 * (2) By + dBy * t0 = Ay + dAy * t1
 *
 *  1  => (t1 = Bx - Ax + dBx * t0) / dAx
 *  +2 =>   By + dBy * t0 = Ay + dAy/dAx * [ Bx - Ax + dBx * t0 ]
 *     => t0 * [dAy/dAx * dBx - dBy] = By - Ay - dAy/dAx* (Bx-Ax)
 *     => t0 (dAy*DBx - dBy*dAx) = dAx (By - Ay) + dAy (Ax-Bx)
 *     => t0 = [dAx (By-Ay) + dAy (Ax-Bx)] / [dAy*dBx - dBy*dAx]
 *     => t0 = [dAx (By-Ay) - dAy (Bx-Ax)] / [dBx*dAy - dBy*dAx]
 *     t0 = N/D
 *     =>
 *          N = (By - Ay) * dAx - (Bx - Ax) * dAy;
 *              D = dBx * dAy - dBy * dAx;
 *      A simple floating point implementation would only need this, and
 *      the check to see if D is zero.
 *              But to gain speed we do some tricks and avoid floating point.
 *
 */
  FS_PRIVATE uint8* itrp_ISECT (IPARAM)
  {
	F26Dot6 N, D;
	int32   arg1, arg2;
	F26Dot6 Bx, By, Ax, Ay;
	F26Dot6 dBx, dBy, dAx, dAy;

#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	int32 arg1p, arg2p;
#endif

	{
	  fnt_ElementType*element = LocalGS.CE0;
	  F26Dot6*stack = LocalGS.stackPointer;

	  FS_UNUSED_PARAMETER(lOpCode);

      SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 5);

	  arg2 = (int32)CHECK_POP (stack); /* get one line */
	  arg1 = (int32)CHECK_POP (stack);
	  SECURE_CHECK_POINT (LocalGS.CE0, arg2);
	  SECURE_CHECK_POINT (LocalGS.CE0, arg1);
	  CHECK_POINT (&LocalGS, LocalGS.CE0, arg2);
	  CHECK_POINT (&LocalGS, LocalGS.CE0, arg1);
	  dAx = element->x[arg2] - (Ax = element->x[arg1]);
	  dAy = element->y[arg2] - (Ay = element->y[arg1]);

#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	  if (LocalGS.globalGS->pgmIndex == GLYPHPROGRAM && CompatibleWidthSP(LocalGS.globalGS)) {
		  arg2p = arg2;
		  arg1p = arg1;
	  }
#endif

	  element = LocalGS.CE1;
	  arg2 = (int32)CHECK_POP (stack); /* get the other line */
	  arg1 = (int32)CHECK_POP (stack);
	  SECURE_CHECK_POINT (LocalGS.CE1, arg2);
	  SECURE_CHECK_POINT (LocalGS.CE1, arg1);
	  CHECK_POINT (&LocalGS, LocalGS.CE1, arg2);
	  CHECK_POINT (&LocalGS, LocalGS.CE1, arg1);
	  dBx = element->x[arg2] - (Bx = element->x[arg1]);
	  dBy = element->y[arg2] - (By = element->y[arg1]);

#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	  if (LocalGS.globalGS->pgmIndex == GLYPHPROGRAM && CompatibleWidthSP(LocalGS.globalGS) && MABS(Mul26Dot6(dBy,dAx)) > MABS(Mul26Dot6(dBx,dAy))) {
		  arg2p = arg2;	// pick the line which is closer to the y-axis
		  arg1p = arg1; // since aligning perpendicular to parent axis
	  }
#endif
	  arg1 = (int32)CHECK_POP (stack); /* get the point number */
	  SECURE_CHECK_POINT (LocalGS.CE2, arg1);
	  CHECK_POINT (&LocalGS, LocalGS.CE2, arg1);
	  LocalGS.stackPointer = stack;

#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	  // for our purposes, handle like a proportion (have intersected point follow proportional to parents)
	  // need no fv, pv set for ISECT, hence we don't test against LocalGS.inSubPixelDirection
	  if (LocalGS.CE2 != &LocalGS.elements[TWILIGHTZONE] && LocalGS.globalGS->pgmIndex == GLYPHPROGRAM && CompatibleWidthSP(LocalGS.globalGS))
		AddProportion(&LocalGS,LocalGS.CE2,arg1p,arg1,arg2p);
#endif
				


	}
	LocalGS.CE2->f[arg1] |= XMOVED | YMOVED;
	{
	  F26Dot6*elementx = LocalGS.CE2->x;
	  F26Dot6*elementy = LocalGS.CE2->y;
	  if (dAy == 0) 
	  {
		if (dBx == 0) 
		{
		  elementx[arg1] = Bx;
		  elementy[arg1] = Ay;
		  return pbyInst;
		}
		N = By - Ay;
		D = -dBy;
	  } 
	  else if (dAx == 0) 
	  {
		if (dBy == 0) 
		{
		  elementx[arg1] = Ax;
		  elementy[arg1] = By;
		  return pbyInst;
		}
		N = Bx - Ax;
		D = -dBx;
	  } 
	  else if (MABS (dAx) >= MABS (dAy))
	  {
/* To prevent out of range problems divide both N and D with the max */
		N = (By - Ay) - MulDiv26Dot6 (Bx - Ax, dAy, dAx);
		D = MulDiv26Dot6 (dBx, dAy, dAx) - dBy;
	  } 
	  else 
	  {
		N = MulDiv26Dot6 (By - Ay, dAx, dAy) - (Bx - Ax);
		D = dBx - MulDiv26Dot6 (dBy, dAx, dAy);
	  }

	  if (D) 
	  {
		elementx[arg1] = Bx + (F26Dot6) MulDiv26Dot6 (dBx, N, D);
		elementy[arg1] = By + (F26Dot6) MulDiv26Dot6 (dBy, N, D);
	  } 
	  else 
	  {
/* degenerate case: parallell lines, put point in the middle */
		elementx[arg1] = (Bx + (dBx >> 1) + Ax + (dAx >> 1)) >> 1;
		elementy[arg1] = (By + (dBy >> 1) + Ay + (dAy >> 1)) >> 1;
	  }
	}
	return pbyInst;
  }

/*
 * Load Minimum Distance
 */
  FS_PRIVATE uint8* itrp_LMD (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);

    LocalGS.globalGS->localParBlock.minimumDistance = CHECK_POP (LocalGS.stackPointer);
	CHECK_LARGER (-1L, LocalGS.globalGS->localParBlock.minimumDistance);
	return pbyInst;
  }

/*
 * Load Control Value Table Cut In
 */
  FS_PRIVATE uint8* itrp_LWTCI (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);

    LocalGS.globalGS->localParBlock.wTCI = CHECK_POP (LocalGS.stackPointer);
	CHECK_LARGER (-1L, LocalGS.globalGS->localParBlock.wTCI);
	return pbyInst;
  }

/*
 * Load Single Width Cut In
 */
  FS_PRIVATE uint8* itrp_LSWCI (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);

    LocalGS.globalGS->localParBlock.sWCI = CHECK_POP (LocalGS.stackPointer);
	LocalGS.MIRPCode = MIRPG;               /* fall back to general mirp */
	CHECK_LARGER (-1L, LocalGS.globalGS->localParBlock.sWCI);
	return pbyInst;
  }

/*
 * Load Single Width , assumes value comes from the original domain, not the cvt or outline
 */
  FS_PRIVATE uint8* itrp_LSW (IPARAM)
  {
	fnt_GlobalGraphicStateType *globalGS = LocalGS.globalGS;
	fnt_ParameterBlock *pb = &globalGS->localParBlock;
	int32 arg;

	FS_UNUSED_PARAMETER(lOpCode);

	LocalGS.MIRPCode = MIRPG;               /* fall back to general mirp */

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);

    arg = CHECK_POP (LocalGS.stackPointer);
	CHECK_INT16 (arg);
	pb->sW = (int16)arg;
	CHECK_LARGER (-1L, pb->sW);

	pb->scaledSW = globalGS->ScaleFuncCVT (&globalGS->scaleCVT, (F26Dot6)pb->sW); /* measurement should not come from the outline */
	return pbyInst;
  }

/* these functions were split out from itrp_SetLocalGraphicState - deanb */
  
  FS_PRIVATE uint8* itrp_SRP0 (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);
    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	LocalGS.Pt0 = (int32)CHECK_POP (LocalGS.stackPointer);
	return pbyInst;
  }

  FS_PRIVATE uint8* itrp_SRP1 (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);
    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	LocalGS.Pt1 = (int32)CHECK_POP (LocalGS.stackPointer);
	return pbyInst;
  }

  FS_PRIVATE uint8* itrp_SRP2 (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);
    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	LocalGS.Pt2 = (int32)CHECK_POP (LocalGS.stackPointer);
	return pbyInst;
  }
  
  FS_PRIVATE uint8* itrp_LLOOP (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);
    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	LocalGS.loop = (int32)(CHECK_POP (LocalGS.stackPointer)) - 1;
	return pbyInst;
  }

  FS_PRIVATE uint8* itrp_POP (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);
    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	CHECK_POP (LocalGS.stackPointer);
	return pbyInst;
  }


  FS_PRIVATE uint8* itrp_SetElementPtr (IPARAM)
  {
	int32             arg;
	fnt_ElementType * element;

	switch (lOpCode)
	{
	  case SCES_CODE: 
		ERR_OPC ("SCES");
		break;
	  case SCE0_CODE: 
		ERR_OPC ("SCE0");
		break;
	  case SCE1_CODE: 
		ERR_OPC ("SCE1");
		break;
	  case SCE2_CODE: 
		ERR_OPC ("SCE2");
		break;
	  default:
		ERR_OPC ("???");
		break;
	}

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	arg = (int32)CHECK_POP (LocalGS.stackPointer);
    SECURE_CHECK_ZONE(arg);
    CHECK_ELEMENT (&LocalGS, arg);
	element = &LocalGS.elements[ arg ];

	switch (lOpCode)
	{
	  case SCES_CODE: 
		LocalGS.CE2 = element;
		LocalGS.CE1 = element;
	  case SCE0_CODE: 
		LocalGS.CE0 = element;
		break;
	  case SCE1_CODE: 
		LocalGS.CE1 = element;
		break;
	  case SCE2_CODE: 
		LocalGS.CE2 = element;
		break;
#ifdef FSCFG_DEBUG
	  default:
		ERR_REPORT (ERR_INVOPC, lOpCode, 0, 0, 0);
		break;
#endif
	}
	LocalGS.MIRPCode = MIRPG;               /* fall back to general mirp */
	return pbyInst;
  }

/*
 * Super Round
 */
  FS_PRIVATE uint8* itrp_SROUND (IPARAM)
  {
	fnt_ParameterBlock *pb = &LocalGS.globalGS->localParBlock;
	int32      arg1;
	int32      arg;

	FS_UNUSED_PARAMETER(lOpCode);
    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	arg = (int32)CHECK_POP (LocalGS.stackPointer);
	CHECK_INT16 (arg);
	arg1 = (int32)arg;
	itrp_SetRoundValues (GSA arg1, true);
#ifdef FSCFG_SUBPIXEL
	UpdateRoundFunctionByRoundState(LocalGS,inSRnd);
#else
	pb->RoundValue = itrp_SuperRound; // B.St. to check
#endif
	LocalGS.MIRPCode = MIRPG;               /* fall back to general mirp */
	return pbyInst;
  }

/*
 * Super Round
 */
  FS_PRIVATE uint8* itrp_S45ROUND (IPARAM)
  {
	fnt_ParameterBlock *pb = &LocalGS.globalGS->localParBlock;
	int32      arg1;
	int32      arg;

	FS_UNUSED_PARAMETER(lOpCode);
    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	arg = (int32)CHECK_POP (LocalGS.stackPointer);
	CHECK_INT16 (arg);
	arg1 = (int32)arg;
	itrp_SetRoundValues (GSA arg1, false);
#ifdef FSCFG_SUBPIXEL
	UpdateRoundFunctionByRoundState(LocalGS,inS45Rnd);
#else
	pb->RoundValue = itrp_Super45Round; // B.St. to check
#endif
	LocalGS.MIRPCode = MIRPG;               /* fall back to general mirp */
	return pbyInst;
  }

/*********************************************************************/

/*  These routines were split out from SetRoundState  */
/*  They set the current rounding state, and all but  */
/*  RoundToGrid cause MIRP to fall back to MIRPG      */


FS_PRIVATE uint8* itrp_RTG (IPARAM)
{
	FS_UNUSED_PARAMETER(lOpCode);
#ifdef FSCFG_SUBPIXEL
	UpdateRoundFunctionByRoundState(LocalGS,inRtg)
#else
	LocalGS.globalGS->localParBlock.RoundValue = itrp_RoundToGrid;
#endif
	return pbyInst;
}

FS_PRIVATE uint8* itrp_RTHG (IPARAM)
{
	FS_UNUSED_PARAMETER(lOpCode);
#ifdef FSCFG_SUBPIXEL
	UpdateRoundFunctionByRoundState(LocalGS,inRthg);
#else
	LocalGS.globalGS->localParBlock.RoundValue = itrp_RoundToHalfGrid;
#endif
	LocalGS.MIRPCode = MIRPG;
	return pbyInst;
}

FS_PRIVATE uint8* itrp_RTDG (IPARAM)
{
	FS_UNUSED_PARAMETER(lOpCode);
#ifdef FSCFG_SUBPIXEL
	UpdateRoundFunctionByRoundState(LocalGS,inRtdg);
#else
	LocalGS.globalGS->localParBlock.RoundValue = itrp_RoundToDoubleGrid;
#endif
	LocalGS.MIRPCode = MIRPG;
	return pbyInst;
}

FS_PRIVATE uint8* itrp_ROFF (IPARAM)
{
	FS_UNUSED_PARAMETER(lOpCode);
#ifdef FSCFG_SUBPIXEL
	UpdateRoundFunctionByRoundState(LocalGS,inRoff);
#else
	LocalGS.globalGS->localParBlock.RoundValue = itrp_RoundOff;
#endif
	LocalGS.MIRPCode = MIRPG;
	return pbyInst;
}

FS_PRIVATE uint8* itrp_RDTG (IPARAM)
{
	FS_UNUSED_PARAMETER(lOpCode);
#ifdef FSCFG_SUBPIXEL
	UpdateRoundFunctionByRoundState(LocalGS,inRdtg);
#else
	LocalGS.globalGS->localParBlock.RoundValue = itrp_RoundDownToGrid;
#endif
	LocalGS.MIRPCode = MIRPG;
	return pbyInst;
}

FS_PRIVATE uint8* itrp_RUTG (IPARAM)
{
	FS_UNUSED_PARAMETER(lOpCode);
#ifdef FSCFG_SUBPIXEL
	UpdateRoundFunctionByRoundState(LocalGS,inRutg);
#else
	LocalGS.globalGS->localParBlock.RoundValue = itrp_RoundUpToGrid;
#endif
	LocalGS.MIRPCode = MIRPG;
	return pbyInst;
}

/*********************************************************************/


#define FRACSQRT2DIV2   11591
/*
 * Internal support routine for the super rounding routines
 */
  FS_PRIVATE void itrp_SetRoundValues (GSP int32 arg1, int32 normalRound)
  {
	 int32       tmp;
	fnt_ParameterBlock *pb = &LocalGS.globalGS->localParBlock;

	tmp = arg1 & 0xC0;

	if (normalRound) 
	{
	  switch (tmp) 
	  {
	  case 0x00:
		pb->period = FNT_PIXELSIZE / 2;
		break;
	  case 0x40:
		pb->period = FNT_PIXELSIZE;
		break;
	  case 0x80:
		pb->period = FNT_PIXELSIZE * 2;
		break;
	  default:
		pb->period = 999; /* Illegal */
	  }
	  pb->periodMask = ~ (pb->period - 1);
	} 
	else 
	{
	  pb->period45 = FRACSQRT2DIV2;
	  switch (tmp) 
	  {
	  case 0x00:
		pb->period45 >>= 1;
		break;
	  case 0x40:
		break;
	  case 0x80:
		pb->period45 <<= 1;
		break;
	  default:
		pb->period45 = 999; /* Illegal */
	  }
	  tmp = (sizeof (pb->period45) * 8 - 2 - FNT_PIXELSHIFT);
	  pb->period = (int16) ((pb->period45 + (1L << (tmp - 1))) >> tmp); /*convert from 2.30 to 26.6 */
	}

	tmp = arg1 & 0x30;
	switch (tmp) 
	{
	case 0x00:
	  pb->phase = 0;
	  break;
	case 0x10:
	  pb->phase = (int16)((pb->period + 2) >> 2);
	  break;
	case 0x20:
	  pb->phase = (int16)((pb->period + 1) >> 1);
	  break;
	case 0x30:
	  pb->phase = (int16)((pb->period + pb->period + pb->period + 2) >> 2);
	  break;
	}
	tmp = arg1 & 0x0f;
	if (tmp == 0) 
	{
	  pb->threshold = (int16)(pb->period - 1);
	} 
	else 
	{
	  pb->threshold = (int16)(((tmp - 4) * pb->period + 4) >> 3);
	}
  }

/*
 * Read Advance Width
 */
  FS_PRIVATE uint8* itrp_RAW (IPARAM)
  {
	F26Dot6* ox;
	int32 index;  

	FS_UNUSED_PARAMETER(lOpCode);

	if (LocalGS.globalGS->pgmIndex != GLYPHPROGRAM)
	{
		LocalGS.ercReturn = RAW_NOT_IN_GLYPHPGM_ERR;  /* returned to client, error RAW not in glyph program */
		return LocalGS.pbyEndInst;
	}

	ox = LocalGS.elements[GLYPHELEMENT].ox;
	index = LocalGS.elements[GLYPHELEMENT].ep[LocalGS.elements[GLYPHELEMENT].nc - 1] + 1;      /* lsb point */

    SECURE_CHECK_FOR_PUSH (LocalGS.stackPointer, 1);
	CHECK_PUSH( LocalGS.stackPointer, ox[index+1] - ox[index] );
	return pbyInst;
  }

/*
 * DUPlicate
 */
  FS_PRIVATE uint8* itrp_DUP (IPARAM)
  {
	F26Dot6 top;

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	top = LocalGS.stackPointer[-1];
	FS_UNUSED_PARAMETER(lOpCode);
    SECURE_CHECK_FOR_PUSH (LocalGS.stackPointer, 1);
	CHECK_PUSH (LocalGS.stackPointer, top);
	return pbyInst;
  }

/*
 * CLEAR stack
 */
  FS_PRIVATE uint8* itrp_CLEAR (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);
	LocalGS.stackPointer = LocalGS.globalGS->stackBase;
	return pbyInst;
  }

/*********************************************************************/

/*
 * SWAP
 */
FS_PRIVATE uint8* itrp_SWAP (IPARAM)
{
	F26Dot6 *pfxStack;
	F26Dot6 fxTemp;
		   
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	pfxStack = LocalGS.stackPointer - 1;
	fxTemp = pfxStack[0];
	pfxStack[0] = pfxStack[-1];
	pfxStack[-1] = fxTemp;
	
	return pbyInst;
}

/*********************************************************************/

/*
 * DEPTH
 */
  FS_PRIVATE uint8* itrp_DEPTH (IPARAM)
  {
	F26Dot6 depth = (F26Dot6)(LocalGS.stackPointer - LocalGS.globalGS->stackBase);
	FS_UNUSED_PARAMETER(lOpCode);
    SECURE_CHECK_FOR_PUSH (LocalGS.stackPointer, 1);
	CHECK_PUSH (LocalGS.stackPointer, depth);
	return pbyInst;
  }

/*
 * Copy INDEXed value
 */
  FS_PRIVATE uint8* itrp_CINDEX (IPARAM)
  {
	int32   arg1;
	F26Dot6 tmp, *p;
	F26Dot6*stack = LocalGS.stackPointer;

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);

	arg1 = (int32)CHECK_POP (stack);

    SECURE_CHECK_FOR_POP (stack, arg1);

	p = stack - arg1;
	CHECK_SUBSTACK (&LocalGS, p);
	SECURE_CHECK_SUBSTACK (p);

	tmp = *p;

	CHECK_PUSH (stack , tmp);
	return pbyInst;
  }

/*
 * Move INDEXed value
 */
  FS_PRIVATE uint8* itrp_MINDEX (IPARAM)
  {
	int32   arg1;
	F26Dot6 tmp, *p;
	F26Dot6*stack = LocalGS.stackPointer;

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);

	arg1 = (int32)CHECK_POP (stack);

    SECURE_CHECK_FOR_POP (stack, arg1);

	p = stack - arg1;
	CHECK_SUBSTACK (&LocalGS, p);
	SECURE_CHECK_SUBSTACK (p);

	tmp = *p;

	if (arg1 > 0) 
	{
	  do 
	  {
		*p = * (p + 1); 
		p++;
	  } while (--arg1);
	  CHECK_POP (stack);
	}
	CHECK_PUSH (stack, tmp);
	LocalGS.stackPointer = stack;
	return pbyInst;
  }

/*
 *      Rotate element 3 to the top of the stack                        <4>
 *      Thanks to Oliver for the obscure code.
 */
  FS_PRIVATE uint8* itrp_ROTATE (IPARAM)
  {
	F26Dot6 *stack = LocalGS.stackPointer;
	F26Dot6 element1;
	F26Dot6 element2;

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 3);
	element1 = *--stack;
	element2 = *--stack;

    *stack = element1;
	element1 = *--stack;
	*stack = element2;
	* (stack + 2) = element1;
	return pbyInst;
  }

/*********************************************************************/

/*
 * Move Direct Absolute Point
 */
FS_PRIVATE uint8* itrp_MDAP (IPARAM) {
	F26Dot6 fxProj;
	fnt_ElementType *pCE0;
	fnt_ParameterBlock *pb;
	int32 iPoint;

	pCE0 = LocalGS.CE0;
	pb = &LocalGS.globalGS->localParBlock;

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	iPoint = (int32)CHECK_POP (LocalGS.stackPointer);
	SECURE_CHECK_POINT (pCE0, iPoint);
	CHECK_POINT (&LocalGS, pCE0, iPoint);
	LocalGS.Pt0 = iPoint; 
	LocalGS.Pt1 = iPoint;

	if (BIT0 (lOpCode)) { // round?
		fxProj = (*LocalGS.Project) (GSA pCE0->x[iPoint], pCE0->y[iPoint]);
		fxProj = pb->RoundValue (GSA fxProj, LocalGS.globalGS->engine[0]) - fxProj;
	} else {
		fxProj = 0;         /* mark the point as touched */
	}

	(*LocalGS.MovePoint) (GSA pCE0, iPoint, fxProj);
	return pbyInst;
} // itrp_MDAP

/*********************************************************************/

/*
 * Move Indirect Absolute Point
 */
FS_PRIVATE uint8* itrp_MIAP (IPARAM) {
	int32   iPoint;
	int32   iCVTIndex;
	F26Dot6 fxNewProj;
	F26Dot6 fxOrigProj;
	F26Dot6 fxProjDif;
	fnt_ElementType *pCE0;
	fnt_ParameterBlock *pb;

	pCE0 = LocalGS.CE0;
	pb = &LocalGS.globalGS->localParBlock;
	
    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	iCVTIndex = (int32)CHECK_POP (LocalGS.stackPointer);
	SECURE_CHECK_CVT (iCVTIndex);
	CHECK_CVT (&LocalGS, iCVTIndex);
	fxNewProj = LocalGS.GetCVTEntry (GSA iCVTIndex);

	iPoint = (int32)CHECK_POP (LocalGS.stackPointer);
	SECURE_CHECK_POINT (pCE0, iPoint);
	CHECK_POINT (&LocalGS, pCE0, iPoint);
	LocalGS.Pt0 = iPoint;
	LocalGS.Pt1 = iPoint;

	if (pCE0 == &LocalGS.elements[TWILIGHTZONE]) {
		pCE0->x[iPoint] = (F26Dot6) VECTORMUL (fxNewProj, LocalGS.proj.x);
		pCE0->ox[iPoint] = pCE0->x[iPoint];
		pCE0->y[iPoint] = (F26Dot6) VECTORMUL (fxNewProj, LocalGS.proj.y);
		pCE0->oy[iPoint] = pCE0->y[iPoint];
	}

	fxOrigProj = (*LocalGS.Project) (GSA pCE0->x[iPoint], pCE0->y[iPoint]);

	if (BIT0 (lOpCode)) { // round?
		fxProjDif = fxNewProj - fxOrigProj;
		if (fxProjDif < 0) {
			fxProjDif = -fxProjDif;
		}
		if (fxProjDif > pb->wTCI) {
			fxNewProj = fxOrigProj;
		}
		fxNewProj = pb->RoundValue (GSA fxNewProj, LocalGS.globalGS->engine[0]);
	}
	// Notice that unlike MIRP, here we don't have a switch that would require the round-off flag MIAP[r] to honour
	// the cvt cut-in. We assume that the context is a stroke placement with coordinates calculated to move a stroke
	// possibly from the origin to the targeted location such as in PMingLiU. See also comments in MSIRP and MIRP.
	
	(*LocalGS.MovePoint) (GSA pCE0, iPoint, fxNewProj - fxOrigProj);
	return pbyInst;
} // itrp_MIAP


/*********************************************************************/

FS_PRIVATE uint8* itrp_IUP (IPARAM)
{
	fnt_ElementType *pCE2;
	
	int32 *alOrig;                          /* original outline array */
	int32 *plOrig;
	int32 *plOrigTouch2;                    /* for loop stop */
	int32 *plOrigEnd;
	int32 lOrig1;                           /* touched point 1 */
	int32 lOrig2;                           /* touched point 2 */
	int32 lOrigMin;                         /* min coord touched point */
	int32 lOrigDelta;
	int32 lOrigCorr;
	
	F26Dot6 *afxScaled;                     /* scaled outline array */
	F26Dot6 *pfxScaled;
	F26Dot6 fxScaledMax;
	F26Dot6 fxScaledMin;
	F26Dot6 fxScaledCoord;
	
	F26Dot6 fxMovedMax;                     /* hint movement of max */
	F26Dot6 fxMovedMin;                     /* hint movement of min */

	F26Dot6 *afxHinted;                     /* hinted outline array */
	F26Dot6 *pfxHinted;
	F26Dot6 fxHintedMax;
	F26Dot6 fxHintedMin;
	F26Dot6 fxHintedDelta;

	uint8 *abyFlags;                        /* point flags array */
	uint8 byMask;
	
	int32 iPt;                         /* current point index */
	int32 iStartPt;                    /* start of contour */
	int32 iEndPt;                      /* end of contour */
	int32 iStopPt;                     /* touched point indicates completion */
	int32 iTouch1;
	int32 iTouch2;
	int32 iMin;
	int32 iMax;
			   
	int32 iContour;

	int32 lTemp;
	Fixed fRatio;

	STAT_ON_IUP;                        /* start STAT timer */    

	pCE2 = LocalGS.CE2;

	SECURE_CHECK_FOR_UNITIALIZED_ZONE(pCE2);

#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	if (LocalGS.globalGS->pgmIndex == GLYPHPROGRAM && RunningSubPixel(LocalGS.globalGS) && CompatibleWidthSP(LocalGS.globalGS) &&
		VerticalSPDirection(LocalGS.globalGS) != (lOpCode & 0x01) && !pCE2->phaseControlExecuted) {
		ExecutePhaseControl(&LocalGS,pCE2);
	//	phaseControlExecuted == true by now
	}
#endif
	
	abyFlags = pCE2->f;

	if (lOpCode & 0x01)              /* use x coordinates */
	{
		afxHinted = pCE2->x;
		afxScaled = pCE2->ox;
		if( LocalGS.globalGS->bOriginalPointIsInvalid)
		{
			alOrig = pCE2->ox;
		}
		else
		{
			alOrig = pCE2->oox;
		}
		byMask = XMOVED;
	} 
	else                                    /* use y coordinates */
	{
		afxHinted = pCE2->y;
		afxScaled = pCE2->oy;
		if( LocalGS.globalGS->bOriginalPointIsInvalid)
		{
			alOrig = pCE2->oy;
		}
		else
		{
			alOrig = pCE2->ooy;
		}
		byMask = YMOVED;
	}

	for (iContour = 0; iContour < pCE2->nc; iContour++)
	{
		iStartPt = pCE2->sp[iContour];
		iEndPt = pCE2->ep[iContour];
		plOrigEnd = &alOrig[iEndPt];        /* for limit check */

		iPt = iStartPt;
		while (!(abyFlags[iPt] & byMask) && (iPt <= iEndPt))
		{
			iPt++;
		}
		if (iPt <= iEndPt)                  /* if any points are touched */
		{
			iStopPt = iPt;                  /* save for done condition */
			
			do                              /* for each contour segment */
			{
				do                          /* find next untouched point */
				{
					iTouch1 = iPt;
					iPt++;
					if (iPt > iEndPt)
					{
						iPt = iStartPt;
					}
				} while ((abyFlags[iPt] & byMask) && iPt != iStopPt);

				if (iPt != iStopPt)
				{
					iTouch2 = iPt;
					do                      /* find next touched point */
					{
						iTouch2++;
						if (iTouch2 > iEndPt)
						{
							iTouch2 = iStartPt;
						}
					} while (!(abyFlags[iTouch2] & byMask));

					lOrig1 = alOrig[iTouch1];
					lOrig2 = alOrig[iTouch2];
					if (lOrig1 < lOrig2)
					{
						lOrigMin = lOrig1;
						lOrigDelta = lOrig2 - lOrig1;
						iMin = iTouch1;
						iMax = iTouch2;
					}
					else
					{
						lOrigMin = lOrig2;
						lOrigDelta = lOrig1 - lOrig2;
						iMin = iTouch2;
						iMax = iTouch1;
					}
					
					fxHintedMin = afxHinted[iMin];
					fxScaledMin = afxScaled[iMin];
					fxMovedMin = fxHintedMin - fxScaledMin;

					if (lOrigDelta != 0L)
					{
						fxScaledMax = afxScaled[iMax];
						fxHintedMax = afxHinted[iMax];
						fxMovedMax = fxHintedMax - fxScaledMax;
						fxHintedDelta = fxHintedMax - fxHintedMin;

						if (lOrigDelta < 32768 && fxHintedDelta < 32768)
						{
							plOrig = &alOrig[iPt];          /* set up pointers */
							pfxScaled = &afxScaled[iPt];
							pfxHinted = &afxHinted[iPt];
							lOrigCorr = lOrigDelta >> 1;
							plOrigTouch2 = &alOrig[iTouch2];    /* set limits */
							
							while (plOrig < plOrigTouch2)   /* if not across start/end */
							{
								fxScaledCoord = *pfxScaled;
								if ((fxScaledCoord > fxScaledMin) && (fxScaledCoord < fxScaledMax))
								{
									lTemp = SHORTMUL (*plOrig - lOrigMin, fxHintedDelta);
									lTemp += lOrigCorr;
									lTemp /= lOrigDelta;
									*pfxHinted = (F26Dot6)lTemp + fxHintedMin;
								}
								else if (fxScaledCoord >= fxScaledMax)
								{
									*pfxHinted = fxScaledCoord + fxMovedMax;
								}
								else
								{
									*pfxHinted = fxScaledCoord + fxMovedMin;
								}
								plOrig++;
								pfxScaled++;
								pfxHinted++;
							}                               /* end of time critical loop */
															
							while (plOrig != plOrigTouch2)  /* if points span start/end */
							{
								fxScaledCoord = *pfxScaled;
								if ((fxScaledCoord > fxScaledMin) && (fxScaledCoord < fxScaledMax))
								{
									lTemp = SHORTMUL (*plOrig - lOrigMin, fxHintedDelta);
									lTemp += lOrigCorr;
									lTemp /= lOrigDelta;
									*pfxHinted = (F26Dot6)lTemp + fxHintedMin;
								}
								else if (fxScaledCoord >= fxScaledMax)
								{
									*pfxHinted = fxScaledCoord + fxMovedMax;
								}
								else
								{
									*pfxHinted = fxScaledCoord + fxMovedMin;
								}
								plOrig++;
								pfxScaled++;
								pfxHinted++;
								
								if (plOrig > plOrigEnd)
								{
									plOrig = &alOrig[iStartPt];
									pfxScaled = &afxScaled[iStartPt];
									pfxHinted = &afxHinted[iStartPt];
								}
							}
							iPt = iTouch2;              /* keep in step */
						}
						else                /* if too big for 32 bit product */
						{
							fRatio = FixDiv (fxHintedDelta, lOrigDelta);
							while (iPt != iTouch2)
							{
								lTemp = afxScaled[iPt];
								if (lTemp <= fxScaledMin)
								{
									lTemp += fxMovedMin;
								}
								else if (lTemp >= fxScaledMax)
								{
									lTemp += fxMovedMax;
								}
								else
								{
									lTemp = alOrig[iPt];
									lTemp -= lOrigMin;
									lTemp = FixMul (lTemp, fRatio);
									lTemp += fxHintedMin;
								}
								afxHinted[iPt] = (F26Dot6)lTemp;
								
								if (iPt < iEndPt)
									iPt++;
								else
									iPt = iStartPt;
							}
						}                   /* endif (lOrigDelta < 32768 && fxHintedDelta < 32768) */
					}
					else                    /* if (lOrigDelta == 0L) */
					{
						while (iPt != iTouch2)
						{
							afxHinted[iPt] += fxMovedMin;
							
							if (iPt < iEndPt)
								iPt++;
							else
								iPt = iStartPt;
						}
					}                       /* endif (lOrigDelta != 0L) */
				}                           /* endif (iPt != iStopPt) */
			} while (iPt != iStopPt);       /* until contour is closed */
		}                                   /* endif (iPt <= iEndPt) */
	 }
								  /* next contour */
	STAT_OFF_IUP;                           /* stop STAT timer */    

#ifdef FSCFG_SUBPIXEL
	LocalGS.globalGS->subPixelCompatibilityFlags |= (lOpCode & 0x01 ? SPCF_iupxCalled : SPCF_iupyCalled);
#endif

	return pbyInst;
} // itrp_IUP

/*********************************************************************/

boolean IsSideBearingPoint(fnt_ElementType *element, int32 point);
boolean IsSideBearingPoint(fnt_ElementType *element, int32 point) {
	int32 numPoints = (int32)element->ep[element->nc - 1] + 1;
	return numPoints + LEFTSIDEBEARING <= point && point <= numPoints + RIGHTSIDEBEARING;
} // IsSideBearingPoint

boolean IsSideBearingLink(fnt_ElementType *element, int32 point0, int32 point1);
boolean IsSideBearingLink(fnt_ElementType *element, int32 point0, int32 point1) {
	int32 numPoints = (int32)element->ep[element->nc - 1] + 1;
	return numPoints + LEFTSIDEBEARING <= point0 && point0 <= numPoints + RIGHTSIDEBEARING || numPoints + LEFTSIDEBEARING <= point1 && point1 <= numPoints + RIGHTSIDEBEARING;
} // IsSideBearingLink


  FS_PRIVATE fnt_ElementType* itrp_SH_Common (GSP F26Dot6*dx, F26Dot6*dy, int32*point, int32 lOpCode)
  {
	F26Dot6 proj;
	int32 pt;
	fnt_ElementType * element;

	if (BIT0 (lOpCode))
	{
	  pt = LocalGS.Pt1;
	  element = LocalGS.CE0;
	} 
	else 
	{
	  pt = LocalGS.Pt2;
	  element = LocalGS.CE1;
	}
	proj = (*LocalGS.Project) (GSA element->x[pt] - element->ox[pt], element->y[pt] - element->oy[pt]);

	*dx = *dy = 0; // silence prefix

	if (LocalGS.pfProj != ONEVECTOR)
	{
	  if (LocalGS.free.x)
		*dx = (F26Dot6) LongMulDiv (proj, (int32)LocalGS.free.x, (int32)LocalGS.pfProj);
	  if (LocalGS.free.y)
		*dy = (F26Dot6) LongMulDiv (proj, (int32)LocalGS.free.y, (int32)LocalGS.pfProj);
	}
	else
	{
	  if (LocalGS.free.x)
		*dx = (F26Dot6) VECTORMUL (proj, LocalGS.free.x);
	  if (LocalGS.free.y)
		*dy = (F26Dot6) VECTORMUL (proj, LocalGS.free.y);
	}
	*point = pt;
	return element;
  }

/*********************************************************************/

FS_PRIVATE uint8* itrp_SHP_Common (GSP uint8 *pbyInst, 
#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
								   int32 refPoint,
#endif
#ifdef FSCFG_SUBPIXEL							// extra parameter to distinguish between coming from SHPIX, in which case we assume
								   uint8 shpix, // the context is a delta fn and hence we most likely skip the delta, and SHP
#endif
								   F26Dot6 dx, F26Dot6 dy)
{
	fnt_ElementType *CE2;
	int32 count;
	int32 point;
	
	CE2 = LocalGS.CE2;
	count = LocalGS.loop + 1;         /* faster for ms c8 */

	while (count != 0)
	{
		point = (int32)CHECK_POP (LocalGS.stackPointer);
		SECURE_CHECK_POINT (LocalGS.CE2, point);
		CHECK_POINT (&LocalGS, LocalGS.CE2, point);

#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
		if (CE2 != &LocalGS.elements[TWILIGHTZONE] && LocalGS.globalGS->pgmIndex == GLYPHPROGRAM && LocalGS.inSubPixelDirection && CompatibleWidthSP(LocalGS.globalGS))
			AddDistance(&LocalGS,CE2,refPoint,point,OTHER);
#endif

#ifdef FSCFG_SUBPIXEL
#ifdef InlineDeltasOnly
		// here we assume that if we're doing a SHPIX instruction, we're in the context of a function that implements delta instructions
		// for a range of ppem sizes. If such a delta occurs on an untouched point, regardless of whether it's in SP direction or not,
		// it creates a dent in the outline. While for b/w this is intended to flip one or more pixels, it distorts the stroke in SP.
		// If such a delta occurs on a touched point, it moves along the entire outline, such as to place strokes differently. If this
		// happens in SP direction, this distorts the natural spacing of the stroke(s). Therefore we keep only deltas on touched points
		// in non SP direction.
		//   Notice that strictly speaking, we should keep inline deltas (in non SP direction) only. However, since we do not have the
		// tree of instructions at this level, we don't know whether there are any dependant points that have been touched already,
		// prior to applying the delta (in which case it's a pre-IUP delta), or not (in which case it's an inline delta). In cases
		// where a pre-IUP delta was used to cleanup several pixels of the b/w bitmap, the SP result won't be optimal, but not nearly
		// as bad as it would be in grey-scaling. This is due to the oversampling, which in grey-scaling is done in both directions,
		// while only in one direction in SP. As a result, even the oversampled pixels (stripes) are typically "in".
		//   Notice also that we cannot use the fact whether IUP has happened already or not (even though this would be easy to track),
		// since some pre-IUP deltas are erroneously applied to untouched points, the result of which is unreliable in the sense that
		// the delta amount applies to the original (untouched) position of the point, which typically differs from its post-IUP
		// position. While this may lead to the desired result in b/w, in SP point positions likely will differ from those in b/w.
		// This has lead to irregularly spaced (and "angled") glyphs in fonts such as Palatino italic.
		//   Notice, finally, that for composites, the touched/untouched rule does not apply the same way. A point that is flagged as
		// untouched may have been previously touched while executing the code for the respective component. Yet a subsequent SHPIX or
		// possibly delta applied to that point will not create a(nother) dent in the outline, but move the entire outline, instead.
		// This is used in b/w e.g. to re-position diacritics to ensure a minimal distance of 1 pixel between the base character and
		// the diacritic. Hence we also keep deltas in composites.

		if (!shpix || (LocalGS.globalGS->subPixelCompatibilityFlags & SPCF_inSkippableDeltaFn) == 0 || AMovedPointInNonSPDirection(LocalGS,CE2,point)) {
#endif // InlineDeltasOnly
#endif // FSCFG_SUBPIXEL
		if (LocalGS.free.x) {
			CE2->x[point] += dx;
			CE2->f[point] |= XMOVED;
		}
		if (LocalGS.free.y) {
			CE2->y[point] += dy;
			CE2->f[point] |= YMOVED;
		}
#ifdef FSCFG_SUBPIXEL
#ifdef InlineDeltasOnly
		}
#endif
#endif
		count--;
	}
	LocalGS.loop = 0;
    return pbyInst;
}

/*********************************************************************/

/*
 * SHift Point
 */
  FS_PRIVATE uint8* itrp_SHP (IPARAM)
  {
	F26Dot6 dx, dy;
	int32 point;

#ifdef FSCFG_SECURE
	if (BIT0 (lOpCode))
	{
	  SECURE_CHECK_POINT (LocalGS.CE0, LocalGS.Pt1);
	} 
	else 
	{
	  SECURE_CHECK_POINT (LocalGS.CE1, LocalGS.Pt2);
	}
#endif 

	itrp_SH_Common (GSA &dx, &dy, &point, lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, LocalGS.loop + 1);

    return itrp_SHP_Common (GSA pbyInst, 
#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
		point,
#endif
#ifdef FSCFG_SUBPIXEL
		false, // we don't come from SHPIX
#endif
		dx, dy);
  }

/*
 * SHift Contour
 */
  FS_PRIVATE uint8* itrp_SHC (IPARAM)
  {
	fnt_ElementType *element;
	F26Dot6 dx, dy;
	int32 contour, point;

	{
	  F26Dot6 x, y;
	  int32 pt;

#ifdef FSCFG_SECURE
	  if (BIT0 (lOpCode))
	  {
	    SECURE_CHECK_POINT (LocalGS.CE0, LocalGS.Pt1);
	  } 
	  else 
	  {
	    SECURE_CHECK_POINT (LocalGS.CE1, LocalGS.Pt2);
	  }
#endif 
	  
	  element = itrp_SH_Common (GSA &x, &y, &pt, lOpCode);
	  point = pt;
	  dx = x;
	  dy = y;
	}
    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	contour = (int32)CHECK_POP (LocalGS.stackPointer);

#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	if (LocalGS.globalGS->pgmIndex == GLYPHPROGRAM && RunningSubPixel(LocalGS.globalGS) && CompatibleWidthSP(LocalGS.globalGS) &&
		!VerticalSPDirection(LocalGS.globalGS) && !element->phaseControlExecuted) {
		ExecutePhaseControl(&LocalGS,element);
	//	phaseControlExecuted == true by now
		dx += element->pcr[point].phaseShift;
	}
#endif
	


	SECURE_CHECK_FOR_UNITIALIZED_ZONE(LocalGS.CE2);
	SECURE_CHECK_CONTOUR (LocalGS.CE2, contour);
	CHECK_CONTOUR (&LocalGS, LocalGS.CE2, contour);

	{
	  VECTORTYPE fvx = LocalGS.free.x;
	  VECTORTYPE fvy = LocalGS.free.y;
	  fnt_ElementType*CE2 = LocalGS.CE2;
	  int32 currPt = CE2->sp[contour];
	  int32 count = CE2->ep[contour] - currPt;
	  SECURE_CHECK_POINT (CE2, currPt + count);
	  CHECK_POINT (&LocalGS, CE2, currPt + count);
	  for (; count >= 0; --count)
	  {
		if (currPt != point || element != CE2)
		{
		  if (fvx) 
		  {
			CE2->x[currPt] += dx;
			CE2->f[currPt] |= XMOVED;
		  }
		  if (fvy) 
		  {
			CE2->y[currPt] += dy;
			CE2->f[currPt] |= YMOVED;
		  }
		}
		currPt++;
	  }
	}
	
	return pbyInst;
  }

/*********************************************************************/

/*
 * SHift Element                     rewritten 7/29/93 deanb
 *
 * Flags are no longer set to show touch in x or y direction
 */

FS_PRIVATE uint8* itrp_SHE (IPARAM)
{
	fnt_ElementType *element;
	F26Dot6 fxDX, fxDY;
	int32 lFirstPt, lRefPt, lLastPt, arg1;
	
	F26Dot6 fxSaveX;                    /* for ref point restoration */
	F26Dot6 fxSaveY;
	
	F26Dot6 *pfxX, *pfxStopX;           /* temporary element pointers */
	F26Dot6 *pfxY, *pfxStopY;
	
#ifdef FSCFG_SECURE
	if (BIT0 (lOpCode))
	{
	  SECURE_CHECK_POINT (LocalGS.CE0, LocalGS.Pt1);
	} 
	else 
	{
	  SECURE_CHECK_POINT (LocalGS.CE1, LocalGS.Pt2);
	}
#endif 

	element = itrp_SH_Common (GSA &fxDX, &fxDY, &lRefPt, lOpCode);
	
    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	arg1 = (int32)CHECK_POP (LocalGS.stackPointer);
    SECURE_CHECK_ZONE(arg1);
	CHECK_ELEMENT (&LocalGS, arg1);
	SECURE_CHECK_FOR_UNITIALIZED_ZONE(&LocalGS.elements[arg1]);

	lLastPt = LocalGS.elements[arg1].ep[LocalGS.elements[arg1].nc - 1];
	SECURE_CHECK_POINT (&LocalGS.elements[arg1], lLastPt);
	CHECK_POINT (&LocalGS, &LocalGS.elements[arg1], lLastPt);
	lFirstPt  = LocalGS.elements[arg1].sp[0];
	SECURE_CHECK_POINT (&LocalGS.elements[arg1], lFirstPt);
	CHECK_POINT (&LocalGS, &LocalGS.elements[arg1], lFirstPt);

	if (element == &LocalGS.elements[arg1])     /* if ref pt is in same zone */     
	{
		fxSaveX = LocalGS.elements[arg1].x[lRefPt];
		fxSaveY = LocalGS.elements[arg1].y[lRefPt];
	}
	
	if (LocalGS.free.x != 0) 
	{
		pfxX = &LocalGS.elements[arg1].x[lFirstPt];
		pfxStopX = &LocalGS.elements[arg1].x[lLastPt];

		while (pfxX <= pfxStopX)
		{
			*pfxX += fxDX;                      /* shift each point in x */
			pfxX++;
		}
	}

	if (LocalGS.free.y != 0) 
	{
		pfxY = &LocalGS.elements[arg1].y[lFirstPt];
		pfxStopY = &LocalGS.elements[arg1].y[lLastPt];

		while (pfxY <= pfxStopY)
		{
			*pfxY += fxDY;                      /* shift each point in y */
			pfxY++;
		}
	}
	
	if (element == &LocalGS.elements[arg1])     /* if ref pt is in same zone */     
	{
		LocalGS.elements[arg1].x[lRefPt] = fxSaveX;
		LocalGS.elements[arg1].y[lRefPt] = fxSaveY;
	}

	return pbyInst;
}

/*********************************************************************/

/*
 * SHift point by PIXel amount
 */
  FS_PRIVATE uint8* itrp_SHPIX (IPARAM)
  {
	F26Dot6 proj, dx, dy;

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, LocalGS.loop + 2);
	proj = CHECK_POP (LocalGS.stackPointer);
	if (LocalGS.free.x)
	  dx = (F26Dot6) VECTORMUL (proj, LocalGS.free.x);
	else
		dx = 0; // silence BC
	if (LocalGS.free.y)
	  dy = (F26Dot6) VECTORMUL (proj, LocalGS.free.y);
	else
		dy = 0; // silence BC

	return itrp_SHP_Common (GSA pbyInst, 
#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
		-1,
#endif
#ifdef FSCFG_SUBPIXEL
		true, // we do come from SHPIX
#endif
		dx, dy);
  }

/*********************************************************************/

/*
 * Interpolate Point
 */

uint8* itrp_IP (IPARAM)
{
	int32 arg1;
	int32 RP1;
	int32 RP2;
	
	int32 cLoop;
	fnt_ElementType *pCE0;
	fnt_ElementType *pCE1;
	fnt_ElementType *pCE2;
	fnt_ElementType *pTwilight;
	
	F26Dot6 x_RP1;
	F26Dot6 ox_RP1;
	F26Dot6 *pCE1_ox;
	F26Dot6 *pCE2_ox;

	F26Dot6 y_RP1;
	F26Dot6 oy_RP1;
	F26Dot6 *pCE1_oy;
	F26Dot6 *pCE2_oy;

	F26Dot6 oldRange;
	F26Dot6 proj;
	F26Dot6 fxDelta;
	
	F26Dot6 *pfxStack;

	FntMoveFunc MovePoint;
	FntProject Project;
	

	FS_UNUSED_PARAMETER(lOpCode);

	cLoop = LocalGS.loop + 1;               /* faster for ms c8 */
	pCE0 = LocalGS.CE0;
	pCE1 = LocalGS.CE1;
	pCE2 = LocalGS.CE2;
	pTwilight = &LocalGS.elements[TWILIGHTZONE];
	RP1 = LocalGS.Pt1;
	RP2 = LocalGS.Pt2;

	SECURE_CHECK_POINT (pCE0, RP1);
	SECURE_CHECK_POINT (pCE1, RP2);

	pfxStack = LocalGS.stackPointer;

	MovePoint = LocalGS.MovePoint;
	Project = LocalGS.Project;

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, cLoop);
    
	if (pCE0 == pTwilight || pCE1 == pTwilight || pCE2 == pTwilight 
		|| LocalGS.globalGS->bOriginalPointIsInvalid)
	{
		ox_RP1 = pCE0->ox[RP1];
		oy_RP1 = pCE0->oy[RP1];
		pCE1_ox = pCE1->ox;
		pCE1_oy = pCE1->oy;
		pCE2_ox = pCE2->ox;
		pCE2_oy = pCE2->oy;
	}
	else
	{
		ox_RP1 = pCE0->oox[RP1];
		oy_RP1 = pCE0->ooy[RP1];
		pCE1_ox = pCE1->oox;
		pCE1_oy = pCE1->ooy;
		pCE2_ox = pCE2->oox;
		pCE2_oy = pCE2->ooy;
	}
	x_RP1 = pCE0->x[RP1];
	y_RP1 = pCE0->y[RP1];
		
	oldRange = LocalGS.OldProject (GSA pCE1_ox[RP2] - ox_RP1, pCE1_oy[RP2] - oy_RP1);
	
	if (oldRange != 0)                      /* this should always happen */
	{
		if (MovePoint == itrp_XMovePoint)   /* so project is also xproject */
		{
			proj = pCE1->x[RP2] - x_RP1;
			while (cLoop != 0)
			{
				arg1 = (int32)CHECK_POP (pfxStack);
				SECURE_CHECK_POINT (pCE2, arg1);
				CHECK_POINT (&LocalGS, pCE2, arg1);

#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
				if (pCE2 != &LocalGS.elements[TWILIGHTZONE] && LocalGS.globalGS->pgmIndex == GLYPHPROGRAM && LocalGS.inSubPixelDirection && CompatibleWidthSP(LocalGS.globalGS))
					AddProportion(&LocalGS,pCE2,RP1,arg1,RP2);
#endif
				
				fxDelta = pCE2_ox[arg1] - ox_RP1;
				fxDelta = (F26Dot6)MulDiv26Dot6 (proj, fxDelta, oldRange);
				
				pCE2->x[arg1] = fxDelta + x_RP1;
				pCE2->f[arg1] |= XMOVED;
				cLoop--;
			}
		}
		else if (MovePoint == itrp_YMovePoint)  /* so project is also yproject */
		{
			proj = pCE1->y[RP2] - y_RP1;
			while (cLoop != 0)
			{
				arg1 = (int32)CHECK_POP (pfxStack);
				SECURE_CHECK_POINT (pCE2, arg1);
				CHECK_POINT (&LocalGS, pCE2, arg1);
				
#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
				if (pCE2 != &LocalGS.elements[TWILIGHTZONE] && LocalGS.globalGS->pgmIndex == GLYPHPROGRAM && LocalGS.inSubPixelDirection && CompatibleWidthSP(LocalGS.globalGS))
					AddProportion(&LocalGS,pCE2,RP1,arg1,RP2);
#endif
				
				fxDelta = pCE2_oy[arg1] - oy_RP1; 
				fxDelta = (F26Dot6) MulDiv26Dot6(proj, fxDelta, oldRange);
				
				pCE2->y[arg1] = fxDelta + y_RP1;
				pCE2->f[arg1] |= YMOVED;
				cLoop--;
			}
		}
		else    /* if (MovePoint == itrp_MovePoint) */
		{
			proj = Project (GSA pCE1->x[RP2] - x_RP1, pCE1->y[RP2] - y_RP1);
			while (cLoop != 0)
			{
				arg1 = (int32)CHECK_POP (pfxStack);
				SECURE_CHECK_POINT (pCE2, arg1);
				CHECK_POINT (&LocalGS, pCE2, arg1);
				
#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
				if (pCE2 != &LocalGS.elements[TWILIGHTZONE] && LocalGS.globalGS->pgmIndex == GLYPHPROGRAM && LocalGS.inSubPixelDirection && CompatibleWidthSP(LocalGS.globalGS))
					AddProportion(&LocalGS,pCE2,RP1,arg1,RP2);
#endif
				
				fxDelta = Project (GSA pCE2_ox[arg1] - ox_RP1, pCE2_oy[arg1] - oy_RP1);
				fxDelta = (F26Dot6) MulDiv26Dot6(proj, fxDelta, oldRange);
				MovePoint (GSA pCE2, arg1, fxDelta - 
					Project (GSA pCE2->x[arg1] - x_RP1, pCE2->y[arg1] - y_RP1) );
				cLoop--;
			}
		}
	}
	else    /* if (oldRange == 0) */  
			/* this should never happen, but for safety's sake... */
	{
		while (cLoop != 0)
		{
			arg1 = (int32)CHECK_POP (pfxStack);
			SECURE_CHECK_POINT (pCE2, arg1);
			CHECK_POINT (&LocalGS, pCE2, arg1);
						
#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
			if (pCE2 != &LocalGS.elements[TWILIGHTZONE] && LocalGS.globalGS->pgmIndex == GLYPHPROGRAM && LocalGS.inSubPixelDirection && CompatibleWidthSP(LocalGS.globalGS))
				AddProportion(&LocalGS,pCE2,RP1,arg1,RP2);
#endif
				
			fxDelta = Project (GSA pCE2_ox[arg1] - ox_RP1, pCE2_oy[arg1] - oy_RP1);
			MovePoint (GSA pCE2, arg1, fxDelta - 
				Project (GSA pCE2->x[arg1] - x_RP1, pCE2->y[arg1] - y_RP1) );
			cLoop--;
		}
	}       /* endif (oldRange != 0) */
	
	LocalGS.stackPointer = pfxStack;
	LocalGS.loop = 0;
	return pbyInst;
}

/*********************************************************************/

/*
 * Move Stack Indirect Relative Point
 */

uint8* itrp_MSIRP (IPARAM) {
	int32 iPt0;
	int32 iPt2;                            // point #
	F26Dot6 fxDist;                        // distance
#ifdef FSCFG_SUBPIXEL
#ifdef MSIRPRespectsCvtCutIn
	F26Dot6 fxOutlineDist;
	fnt_ParameterBlock *pb;
#endif
#endif
#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	long color;
#endif
	F26Dot6 fxPosition;
	fnt_ElementType *pCE0;
	fnt_ElementType *pCE1;

	pCE0 = LocalGS.CE0;
	pCE1 = LocalGS.CE1;
	iPt0 = LocalGS.Pt0;
	
    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);

    fxDist = CHECK_POP (LocalGS.stackPointer);
	iPt2 = (int32)CHECK_POP (LocalGS.stackPointer);
	SECURE_CHECK_POINT (pCE0, iPt0);
	SECURE_CHECK_POINT (pCE1, iPt2);
	CHECK_POINT (&LocalGS, pCE1, iPt2);
		
#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	if (pCE1 != &LocalGS.elements[TWILIGHTZONE] && LocalGS.globalGS->pgmIndex == GLYPHPROGRAM && LocalGS.inSubPixelDirection && CompatibleWidthSP(LocalGS.globalGS)) {
		color = DoubleCheckLinkColor(pCE1,iPt0,iPt2,BLACK); // don't really know any better
		AddDistance(&LocalGS,pCE1,iPt0,iPt2,color);
	}
#endif

	if (pCE1 == &LocalGS.elements[TWILIGHTZONE]) {
		pCE1->ox[iPt2] = pCE0->ox[iPt0] + (F26Dot6) VECTORMUL (fxDist, LocalGS.proj.x);
		pCE1->oy[iPt2] = pCE0->oy[iPt0] + (F26Dot6) VECTORMUL (fxDist, LocalGS.proj.y);
		pCE1->x[iPt2] = pCE1->ox[iPt2];
		pCE1->y[iPt2] = pCE1->oy[iPt2];
	}
	
#ifdef FSCFG_SUBPIXEL
#ifdef MSIRPRespectsCvtCutIn
	if (!Tuned4SubPixel(LocalGS.globalGS) && LocalGS.inSubPixelDirection) {
	// similarly to MIRP, here we honour a cvt cut-in in case there is a non-trivial outline distance between the
	// parent (reference) and the child (target) point involved, in which case we assume the context is a stroke weight,
	// else we assume the context is an accent placement function, in which case we use the actual distance as before
		fxOutlineDist = (*LocalGS.OldProject) (GSA pCE1->ox[iPt2] - pCE0->ox[iPt0], pCE1->oy[iPt2] - pCE0->oy[iPt0]);
		if (fxOutlineDist) { // else assume we're positioning accents with a calculated MSIRP, hence no cvt cut-in
			pb = &LocalGS.globalGS->localParBlock;
			// notice that unlike MIRP, we don't do the autoFlip since MSIRP is used with calculated distances that
			// would have the correct sign to begin with.
			CVTCI(pb,fxDist,fxOutlineDist,CVT_CUT_IN_OVERSCALE);
		}
	}
#endif
#endif

	fxPosition = (*LocalGS.Project) (GSA pCE1->x[iPt2] - pCE0->x[iPt0], pCE1->y[iPt2] - pCE0->y[iPt0]);
	(*LocalGS.MovePoint) (GSA pCE1, iPt2, fxDist - fxPosition);
	
	LocalGS.Pt1 = iPt0;
	LocalGS.Pt2 = iPt2;
	if (BIT0 (lOpCode)) {
		LocalGS.Pt0 = iPt2; // move the reference point
	}
	return pbyInst;
} // itrp_MSIRP

/*********************************************************************/

/*
 * Align Relative Point
 */

FS_PRIVATE uint8* itrp_ALIGNRP (IPARAM)
  {
	fnt_ElementType*ce1 = LocalGS.CE1;
	F26Dot6 pt0x = LocalGS.CE0->x[LocalGS.Pt0];
	F26Dot6 pt0y = LocalGS.CE0->y[LocalGS.Pt0];

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, LocalGS.loop + 1);

	for (; LocalGS.loop >= 0; --LocalGS.loop)
	{
	  int32 ptNum = (int32)CHECK_POP (LocalGS.stackPointer);
	  F26Dot6 proj;

	  SECURE_CHECK_POINT (ce1, ptNum);
	  CHECK_POINT (&LocalGS, ce1, ptNum);
#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
		if (ce1 != &LocalGS.elements[TWILIGHTZONE] && LocalGS.globalGS->pgmIndex == GLYPHPROGRAM && LocalGS.inSubPixelDirection && CompatibleWidthSP(LocalGS.globalGS))
			// if we are aligning to some diagonal (pt0 and pt1 are set after SPVTL etc.), and if the child is between the parents
			// (InterAlign, cf. also comments there), we handle it as a proportion, else as a distance with non specific color.
			if (LocalGS.pt0 != -1 && LocalGS.pt1 != -1 && InterAlign(LocalGS.CE1,LocalGS.pt0,ptNum,LocalGS.pt1))
				AddProportion(&LocalGS,ce1,LocalGS.pt0,ptNum,LocalGS.pt1);
			else
				AddDistance(&LocalGS,ce1,LocalGS.Pt0,ptNum,OTHER);
#endif
	  proj = -(* LocalGS.Project) (GSA ce1->x[ptNum] - pt0x, ce1->y[ptNum] - pt0y);
	  (*LocalGS.MovePoint) (GSA ce1, ptNum, proj);
	}
	LocalGS.loop = 0;
	return pbyInst;
  }


/*
 * Align Two Points (by moving both of them)
 */
  FS_PRIVATE uint8* itrp_ALIGNPTS (IPARAM)
  {
	int32 pt1, pt2;
	F26Dot6 move1, dist;

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	pt2  = (int32)CHECK_POP (LocalGS.stackPointer); /* point # 2   */
	pt1  = (int32)CHECK_POP (LocalGS.stackPointer); /* point # 1   */
	SECURE_CHECK_POINT (LocalGS.CE1, pt2);
	SECURE_CHECK_POINT (LocalGS.CE0, pt1);
	CHECK_POINT (&LocalGS, LocalGS.CE1, pt2);
	CHECK_POINT (&LocalGS, LocalGS.CE0, pt1);
/* We do not have to check if we are in character element zero (the twilight zone)
		   since both points already have to have defined values before we execute this instruction */
	dist = LocalGS.CE1->x[pt2] - LocalGS.CE0->x[pt1];
	move1 = LocalGS.CE1->y[pt2] - LocalGS.CE0->y[pt1];
	if (LocalGS.Project != itrp_XProject)
	{
	  if (LocalGS.Project == itrp_YProject)
		dist = move1;
	  else
		dist = (*LocalGS.Project) (GSA dist, move1);
	}

	move1 = dist >> 1;
	(*LocalGS.MovePoint) (GSA LocalGS.CE0, pt1, move1);
	(*LocalGS.MovePoint) (GSA LocalGS.CE1, pt2, move1 - dist);
	return pbyInst;
  }

/*
 * Set Angle Weight
 */
  FS_PRIVATE uint8* itrp_SANGW (IPARAM)
  {
	int32 arg;

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	arg = CHECK_POP (LocalGS.stackPointer);
	CHECK_INT16 (arg);
	LocalGS.globalGS->localParBlock.angleWeight = (int16)arg;
	return pbyInst;
  }

/*
 * Flip Point
 */
  FS_PRIVATE uint8* itrp_FLIPPT (IPARAM)
  {
	uint8 *onCurve = LocalGS.CE0->onCurve;
	F26Dot6*stack = LocalGS.stackPointer;
	int32 count = LocalGS.loop;

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, count + 1);

    for (; count >= 0; --count)
	{
	  int32 point = (int32)CHECK_POP (stack);
	  SECURE_CHECK_POINT (LocalGS.CE0, point);
	  CHECK_POINT (&LocalGS, LocalGS.CE0, point);
	  onCurve[ point ] ^= ONCURVE;
	}
	LocalGS.loop = 0;

	LocalGS.stackPointer = stack;
	return pbyInst;
  }

/*
 * Flip On a Range
 */
  FS_PRIVATE uint8* itrp_FLIPRGON (IPARAM)
  {
	int32 lo, hi;
	int32 count;
	uint8 *onCurve = LocalGS.CE0->onCurve;
	F26Dot6*stack = LocalGS.stackPointer;

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	hi = (int32)CHECK_POP (stack);
	SECURE_CHECK_POINT (LocalGS.CE0, hi);
	CHECK_POINT (&LocalGS, LocalGS.CE0, hi);
	lo = (int32)CHECK_POP (stack);
	SECURE_CHECK_POINT (LocalGS.CE0, lo);
	CHECK_POINT (&LocalGS, LocalGS.CE0, lo);

	onCurve += lo;
	for (count = (int32) (hi - lo); count >= 0; --count)
	  *onCurve++ |= ONCURVE;
	LocalGS.stackPointer = stack;
	return pbyInst;
  }

/*
 * Flip Off a Range
 */
  FS_PRIVATE uint8* itrp_FLIPRGOFF (IPARAM)
  {
	int32 lo, hi;
	int32 count;
	uint8 *onCurve = LocalGS.CE0->onCurve;

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	hi = (int32)CHECK_POP (LocalGS.stackPointer);
	SECURE_CHECK_POINT (LocalGS.CE0, hi);
	CHECK_POINT (&LocalGS, LocalGS.CE0, hi);
	lo = (int32)CHECK_POP (LocalGS.stackPointer);
	SECURE_CHECK_POINT (LocalGS.CE0, lo);
	CHECK_POINT (&LocalGS, LocalGS.CE0, lo);

	onCurve += lo;
	for (count = (int32) (hi - lo); count >= 0; --count)
	  *onCurve++ &= ~ONCURVE;
	return pbyInst;
  }

/* 4/22/90 rwb - made more general
 * Sets lower 16 flag bits of ScanControl variable.  Sets scanContolIn if we are in one
 * of the preprograms; else sets scanControlOut.
 *
 * stack: value => -;
 *
 */
  FS_PRIVATE uint8* itrp_SCANCTRL (IPARAM)
  {
	fnt_GlobalGraphicStateType *globalGS = LocalGS.globalGS;
	fnt_ParameterBlock *pb = &globalGS->localParBlock;
	int32 arg;

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	arg = CHECK_POP (LocalGS.stackPointer);
	CHECK_INT16 (arg);
	pb->scanControl = (pb->scanControl & 0xFFFF0000) | arg;
	return pbyInst;
  }

/* 5/24/90 rwb
 * Sets upper 16 bits of ScanControl variable. Sets scanContolIn if we are in one
 * of the preprograms; else sets scanControlOut.
 */

  FS_PRIVATE uint8* itrp_SCANTYPE (IPARAM)
  {
	fnt_GlobalGraphicStateType *globalGS;
	fnt_ParameterBlock *pb;
	int32 *scanPtr;
	int32 arg;

	FS_UNUSED_PARAMETER(lOpCode);

	globalGS = LocalGS.globalGS;
	pb = &globalGS->localParBlock;
	scanPtr = (int32*)&(pb->scanControl);
	
    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	arg = CHECK_POP (LocalGS.stackPointer);
	CHECK_INT16 (arg);

/*  how it was:
	CHECK_SCANMODE (arg);
	if (arg == 0)  
	  *scanPtr &= 0xFFFF;
	else if (arg == 1)        
	  *scanPtr = (*scanPtr & 0xFFFF) | STUBCONTROL;
	else if (arg == 2)        
	  *scanPtr = (*scanPtr & 0xFFFF) | NODOCONTROL;
*/

/*  now any 8 bit value may be passed to the scan converter */
	
	*scanPtr = (*scanPtr & 0xFFFF) | (arg << 16);
	return pbyInst;
  }

/* 6/28/90 rwb
 * Sets instructControl flags in global graphic state.  Only legal in pre program.
 * A selector is used to choose the flag to be set.
 * Bit0 - NOGRIDFITFLAG - if set, then truetype instructions are not executed.
 *              A font may want to use the preprogram to check if the glyph is rotated or
 *              transformed in such a way that it is better to not gridfit the glyphs.
 * Bit1 - DEFAULTFLAG - if set, then changes in localParameterBlock variables in the
 *              globalGraphics state made in the CVT preprogram are not copied back into
 *              the defaultParameterBlock.  So, the original default values are the starting
 *              values for each glyph.
 * Bit2 - TUNED4SPFLAG - if set, a font will be rendered in native SP mode (as opposed to
 *              backwards compatible mode)
 *
 * stack: value, selector => -;
 *
 */
  FS_PRIVATE uint8* itrp_INSTCTRL (IPARAM)  /* <13> */
  {
	fnt_GlobalGraphicStateType *globalGS;
	int32 *ic;
	int32 selector;
	int32 value;
	int32 arg;

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	globalGS = LocalGS.globalGS;
	ic = (int32*)&globalGS->localParBlock.instructControl;
	arg = CHECK_POP (LocalGS.stackPointer);
	value = CHECK_POP (LocalGS.stackPointer);
	CHECK_INT16 (arg);
	selector = (int32)arg;
	CHECK_SELECTOR (selector);
	if (globalGS->init)
	{
	  if (selector == 1) 
		*ic &= ~NOGRIDFITFLAG;
	  else if (selector == 2) 
		*ic &= ~DEFAULTFLAG;
	  else if (selector == 3)
		*ic &= ~TUNED4SPFLAG;

	  *ic |= value;
	}
	return pbyInst;
  }

/*
 * AdjustAngle         <4>
 */
  FS_PRIVATE uint8* itrp_AA (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);

	/* This is a NOP now. However, do pop the argument off the stack -amitc- 9/11/91. */
	/* Discard the popped value. -lenox- 11/11/91 */
    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	(void) CHECK_POP (LocalGS.stackPointer);
						 /* old code now lives in history.fnt - deanb */
	return pbyInst;
  }

/*********************************************************************/

/* Called by itrp_PUSHB and itrp_NPUSHB */

/* these functions were split out from itrp_PushSomeStuff - deanb */
  
FS_PRIVATE uint8* itrp_PushSomeBytes (GSP int32 count, uint8* pbyInst)
{
	F26Dot6 *stack;
		
	stack = LocalGS.stackPointer;
    SECURE_CHECK_FOR_PUSH (stack, count);
	while (count != 0)
	{
		CHECK_PUSH (stack, *pbyInst++);
		count--;
	}
	LocalGS.stackPointer = stack;
	return pbyInst;
}

FS_PRIVATE uint8* itrp_PushSomeWords (GSP int32 count, uint8* pbyInst)
{
	F26Dot6 *stack;
	int16 word;
		
	stack = LocalGS.stackPointer;
    SECURE_CHECK_FOR_PUSH (stack, count);
	while (count != 0)
	{
		word = *pbyInst++;
		CHECK_PUSH (stack, (int16) ((word << 8) + *pbyInst++));
		count--;
	}
	LocalGS.stackPointer = stack;
	return pbyInst;
}

/*********************************************************************/

/*
 * PUSH 1 Byte           the most commonly called pushb
 */
FS_PRIVATE uint8* itrp_PUSHB1 (IPARAM)
{
	FS_UNUSED_PARAMETER(lOpCode);
    SECURE_CHECK_FOR_PUSH (LocalGS.stackPointer, 1);
	CHECK_PUSH (LocalGS.stackPointer, *pbyInst++);
	return pbyInst;
}

/*
 * PUSH Bytes
 */
FS_PRIVATE uint8* itrp_PUSHB (IPARAM)
{
	int32 iCount;

	iCount = lOpCode - 0xb0 + 1;
	return itrp_PushSomeBytes (GSA iCount, pbyInst);
}

/*
 * N PUSH Bytes
 */
FS_PRIVATE uint8* itrp_NPUSHB (IPARAM)
{
	int32 iCount;

	FS_UNUSED_PARAMETER(lOpCode);

	iCount = (int32)*pbyInst++;
	return itrp_PushSomeBytes (GSA iCount, pbyInst);
}

/*
 * PUSH 1 Word           the most commonly called pushw
 */
FS_PRIVATE uint8* itrp_PUSHW1 (IPARAM)
{
	int16 word;

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_PUSH (LocalGS.stackPointer, 1);
	word = *pbyInst++;
	CHECK_PUSH (LocalGS.stackPointer, (int16)((word << 8) + *pbyInst++));
	return pbyInst;
}

/*
 * PUSH Words           <3>
 */
FS_PRIVATE uint8* itrp_PUSHW (IPARAM)
{
	int32 iCount;

	iCount = lOpCode - 0xb8 + 1;
	return itrp_PushSomeWords (GSA iCount, pbyInst);
}

/*
 * N PUSH Words
 */
FS_PRIVATE uint8* itrp_NPUSHW (IPARAM)
{
	int32 iCount;

	FS_UNUSED_PARAMETER(lOpCode);

	iCount = (int32)*pbyInst++;
	return itrp_PushSomeWords (GSA iCount, pbyInst);
}

/*********************************************************************/

/*
 * Write Store
 */
  FS_PRIVATE uint8* itrp_WS (IPARAM)
  {
	F26Dot6 storage;
	int32 storeIndex;

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	storage = CHECK_POP (LocalGS.stackPointer);
	storeIndex = (int32)CHECK_POP (LocalGS.stackPointer);

	SECURE_CHECK_STORAGE (storeIndex);
	CHECK_STORAGE (&LocalGS,storeIndex);

	LocalGS.globalGS->store[ storeIndex ] = storage;
	return pbyInst;
  }

/*
 * Read Store
 */
  FS_PRIVATE uint8* itrp_RS (IPARAM) {
	int32 storeIndex;

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	storeIndex = (int32)CHECK_POP (LocalGS.stackPointer);
	SECURE_CHECK_STORAGE (storeIndex);
	CHECK_STORAGE (&LocalGS, storeIndex);
#ifdef FSCFG_SUBPIXEL
#ifdef BypassVacuformRound
	if (storeIndex == 8 && RunningSubPixel(LocalGS.globalGS) && !Tuned4SubPixel(LocalGS.globalGS) && (LocalGS.globalGS->subPixelCompatibilityFlags & SPCF_detectedVacuformRound) > 0) {
		LocalGS.globalGS->subPixelCompatibilityFlags |= SPCF_inVacuformRound;
		CHECK_PUSH (LocalGS.stackPointer, 0); // push 0 indicating we don't do vacuforming
	} else {
#endif
#endif
		CHECK_PUSH (LocalGS.stackPointer, LocalGS.globalGS->store[storeIndex]);
#ifdef FSCFG_SUBPIXEL
#ifdef BypassVacuformRound
	}
#endif
#endif
	return pbyInst;
  }

/*
 * Write Control Value Table from outLine, assumes the value comes form the outline domain
 */
  FS_PRIVATE uint8* itrp_WCVT (IPARAM)
  {
	int32 cvtIndex;
	F26Dot6 cvtValue;

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	cvtValue = CHECK_POP (LocalGS.stackPointer);
	cvtIndex = (int32)CHECK_POP (LocalGS.stackPointer);

	SECURE_CHECK_CVT (cvtIndex);
	CHECK_CVT (&LocalGS, cvtIndex);

	if (cvtValue != 0 && LocalGS.GetCVTEntry != itrp_GetCVTEntryFast)
	  cvtValue = FixDiv (cvtValue, itrp_GetCVTScale (GSA0));
	LocalGS.globalGS->controlValueTable[ cvtIndex ] = cvtValue;
	return pbyInst;
  }

/*
 * Write Control Value Table From Original Domain, assumes the value comes from the original domain, not the cvt or outline
 */
  FS_PRIVATE uint8* itrp_WCVTFOD (IPARAM)
  {
	int32 cvtIndex;
	F26Dot6 cvtValue;
	fnt_GlobalGraphicStateType *globalGS = LocalGS.globalGS;

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	cvtValue = CHECK_POP (LocalGS.stackPointer);
	cvtIndex = (int32)CHECK_POP (LocalGS.stackPointer);
	SECURE_CHECK_CVT (cvtIndex);
	CHECK_CVT (&LocalGS, cvtIndex);
	globalGS->controlValueTable[ cvtIndex ] = globalGS->ScaleFuncCVT (&globalGS->scaleCVT, cvtValue);
	return pbyInst;
  }



/*
 * Read Control Value Table
 */
  FS_PRIVATE uint8* itrp_RCVT (IPARAM)
  {
	int32 cvtIndex;
	
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	cvtIndex = (int32)CHECK_POP (LocalGS.stackPointer);

#ifndef FSCFG_FONTOGRAPHER_BUG
	SECURE_CHECK_CVT (cvtIndex);
#else
	SECURE_CHECK_CVT_READ_SPECIAL (cvtIndex);
#endif // FSCFG_FONTOGRAPHER_BUG

	CHECK_CVT (&LocalGS, cvtIndex);

	LocalGS.GetCVTEntry (GSA cvtIndex);
	CHECK_PUSH (LocalGS.stackPointer, LocalGS.GetCVTEntry (GSA cvtIndex));
	return pbyInst;
  }

/*
 * Read Coordinate
 */
  FS_PRIVATE uint8* itrp_RC (IPARAM)
  {
	int32 pt;
	fnt_ElementType * element;
	F26Dot6 proj;

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	pt = (int32)CHECK_POP (LocalGS.stackPointer);
	element = LocalGS.CE2;
	SECURE_CHECK_POINT (element, pt);
	CHECK_POINT (&LocalGS, element, pt);

	if (BIT0 (lOpCode))
	  proj = (*LocalGS.OldProject) (GSA element->ox[pt], element->oy[pt]);
	else
	  proj = (*LocalGS.Project) (GSA element->x[pt], element->y[pt]);

	CHECK_PUSH (LocalGS.stackPointer, proj);
	return pbyInst;
  }

/*
 * Write Coordinate
 */
  FS_PRIVATE uint8* itrp_WC (IPARAM)
  {
	F26Dot6 proj, coord;
	int32 pt;
	fnt_ElementType *element;

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	coord = CHECK_POP (LocalGS.stackPointer);/* value */
	pt = (int32)CHECK_POP (LocalGS.stackPointer);/* point */
	element = LocalGS.CE2;
	SECURE_CHECK_POINT (element, pt);
	CHECK_POINT (&LocalGS, element, pt);

	proj = (*LocalGS.Project) (GSA element->x[pt],  element->y[pt]);
	proj = coord - proj;

	(*LocalGS.MovePoint) (GSA element, pt, proj);

	if (element == &LocalGS.elements[TWILIGHTZONE])
	{
	  element->ox[pt] = element->x[pt];
	  element->oy[pt] = element->y[pt];
	}
	return pbyInst;
  }


/*
 * Measure Distance
 */
  FS_PRIVATE uint8* itrp_MD (IPARAM)
  {
	int32 pt1, pt2;
	F26Dot6 proj, *stack = LocalGS.stackPointer;
	fnt_GlobalGraphicStateType *globalGS = LocalGS.globalGS;

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	pt2 = (int32)CHECK_POP (stack);
	pt1 = (int32)CHECK_POP (stack);
	SECURE_CHECK_POINT (LocalGS.CE0, pt1);
	SECURE_CHECK_POINT (LocalGS.CE1, pt2);
	CHECK_POINT (&LocalGS, LocalGS.CE0, pt1);
	CHECK_POINT (&LocalGS, LocalGS.CE1, pt2);
	if (BIT0 (lOpCode - MD_CODE)) { // MD[O] in original outline
		if (LocalGS.CE0 == &LocalGS.elements[TWILIGHTZONE] || LocalGS.CE1 == &LocalGS.elements[TWILIGHTZONE] 
			|| LocalGS.globalGS->bOriginalPointIsInvalid)
		{
			proj = (*LocalGS.OldProject) (GSA LocalGS.CE1->ox[pt1] - LocalGS.CE0->ox[pt2], LocalGS.CE1->oy[pt1] - LocalGS.CE0->oy[pt2]);
		}
		else if (globalGS->bSameStretch)
		{
			proj = (*LocalGS.OldProject) (GSA LocalGS.CE1->oox[pt1] - LocalGS.CE0->oox[pt2], LocalGS.CE1->ooy[pt1] - LocalGS.CE0->ooy[pt2] );
			proj = globalGS->ScaleFuncCVT( &globalGS->scaleCVT, proj );
		}
		else
		{
			proj = (*LocalGS.OldProject) (GSA 
				globalGS->ScaleFuncX (&globalGS->scaleX, LocalGS.CE1->oox[pt1] - LocalGS.CE0->oox[pt2]), 
				globalGS->ScaleFuncY (&globalGS->scaleY, LocalGS.CE1->ooy[pt1] - LocalGS.CE0->ooy[pt2]) );
		}
	}

	/* old MS code, give different value than Apple :
	 * proj  = (*LocalGS.OldProject) (GSA LocalGS.CE0->ox[pt1] - LocalGS.CE1->ox[pt2], LocalGS.CE0->oy[pt1] - LocalGS.CE1->oy[pt2]);
	*/
	
	else { // MD[N] in grid-fitted outline
		proj  = (*LocalGS.Project) (GSA LocalGS.CE0->x[pt1] - LocalGS.CE1->x[pt2], LocalGS.CE0->y[pt1] - LocalGS.CE1->y[pt2]);
#ifdef FSCFG_SUBPIXEL
#ifdef BypassVacuformRound
		if ((LocalGS.globalGS->subPixelCompatibilityFlags & (SPCF_iupxCalled | SPCF_iupyCalled | SPCF_inVacuformRound)) == (SPCF_iupxCalled | SPCF_iupyCalled | SPCF_inVacuformRound) && proj == FNT_PIXELSIZE)
			proj++; // increase by smallest possible amount to throw off type 2 vacuforms which are keyed off a distance being exacly 1 pixel
#endif
#endif
	}
	CHECK_PUSH (stack, proj);
	LocalGS.stackPointer = stack;
	return pbyInst;
  }

/*
 * Measure Pixels Per EM
 */
  FS_PRIVATE uint8* itrp_MPPEM (IPARAM)
  {
	uint16 ppem;
	fnt_GlobalGraphicStateType *globalGS = LocalGS.globalGS;

	FS_UNUSED_PARAMETER(lOpCode);

	ppem = globalGS->pixelsPerEm;
	if (!globalGS->bSameStretch)
		ppem = (uint16)FixMul (ppem, itrp_GetCVTScale (GSA0));

    SECURE_CHECK_FOR_PUSH (LocalGS.stackPointer, 1);
	CHECK_PUSH (LocalGS.stackPointer, ppem);
	return pbyInst;
  }

/*
 * Measure Point Size
 */
  FS_PRIVATE uint8* itrp_MPS (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_PUSH (LocalGS.stackPointer, 1);
	CHECK_PUSH (LocalGS.stackPointer, LocalGS.globalGS->pointSize);
	return pbyInst;
  }

/*
 * Get Miscellaneous info: version number, rotated, stretched   <6>
 * Version number is 8 bits.  This is version 0x01 : 5/1/90
 *
 */

  FS_PRIVATE uint8* itrp_GETINFO (IPARAM)
  {
	fnt_GlobalGraphicStateType *globalGS = LocalGS.globalGS;
	int32      info = 0;
	int32      selector;
	int32      arg;

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	arg = CHECK_POP (LocalGS.stackPointer);
	CHECK_INT16 (arg);
	selector = (int32)arg;
	CHECK_SELECTOR (selector);
	if (selector & VERSIONINTERPRETERQUERY)                            /* version */
	  info |= RASTERIZER_VERSION;
	if ((selector & ROTATEDINTERPRETERQUERY) && (globalGS->non90DegreeTransformation & NON90DEGTRANS_ROTATED))
	  info |= ROTATEDGLYPH;
	if ((selector & STRETCHEDINTERPRETERQUERY) && (globalGS->non90DegreeTransformation & NON90DEGTRANS_STRETCH))
	  info |= STRETCHEDGLYPH;
	if ((selector & HINTFORGRAYINTERPRETERQUERY) && (globalGS->bHintForGray))
	  info |= HINTEDFORGRAYGLYPH;
#ifdef FSCFG_SUBPIXEL
	if ((selector & HINTFORSUBPIXELINTERPRETERQUERY) && (globalGS->flHintForSubPixel & FNT_SP_SUB_PIXEL))
	  info |= HINTEDFORSUBPIXELGLYPH;
	if ((selector & HINTFORSUBPIXELCOMPATIBLEWIDTHINTERPRETERQUERY) && (globalGS->flHintForSubPixel & FNT_SP_COMPATIBLE_WIDTH))
	  info |= HINTEDFORSUBPIXELCOMPATIBLEWIDTHGLYPH;
	if ((selector & HINTFORSUBPIXELVERTICALDIRECTIONINTERPRETERQUERY) && (globalGS->flHintForSubPixel & FNT_SP_VERTICAL_DIRECTION))
	  info |= HINTEDFORSUBPIXELVERTICALDIRECTIONGLYPH;
	if ((selector & HINTFORSUBPIXELBGRORDERINTERPRETERQUERY) && (globalGS->flHintForSubPixel & FNT_SP_BGR_ORDER))
	  info |= HINTEDFORSUBPIXELBGRORDERGLYPH;
#endif // FSCFG_SUBPIXEL
	CHECK_PUSH (LocalGS.stackPointer, info);
	return pbyInst;
  } // itrp_GETINFO

/*
 * FLIP ON
 */
  FS_PRIVATE uint8* itrp_FLIPON (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);
	LocalGS.globalGS->localParBlock.autoFlip = true;
	return pbyInst;
  }

/*
 * FLIP OFF
 */
  FS_PRIVATE uint8* itrp_FLIPOFF (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);
	LocalGS.globalGS->localParBlock.autoFlip = false;
	return pbyInst;
  }

#ifndef NOT_ON_THE_MAC
#ifdef FSCFG_DEBUG
/*
 * DEBUG
 */
  FS_PRIVATE uint8* itrp_DEBUG (IPARAM)
  {
	int32 arg;
	int8 buffer[24];

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	arg = CHECK_POP (LocalGS.stackPointer);

	buffer[1] = 'D';
	buffer[2] = 'E';
	buffer[3] = 'B';
	buffer[4] = 'U';
	buffer[5] = 'G';
	buffer[6] = ' ';
	if (arg >= 0) 
	{
	  buffer[7] = '+';
	} 
	else 
	{
	  arg = -arg;
	  buffer[7] = '-';
	}

	buffer[13] = arg % 10 + '0'; 
	arg /= 10;
	buffer[12] = arg % 10 + '0'; 
	arg /= 10;
	buffer[11] = arg % 10 + '0'; 
	arg /= 10;
	buffer[10] = arg % 10 + '0'; 
	arg /= 10;
	buffer[ 9] = arg % 10 + '0'; 
	arg /= 10;
	buffer[ 8] = arg % 10 + '0'; 
	arg /= 10;

	buffer[14] = arg ? '*' : ' ';


	buffer[0] = 14; /* convert to pascal */
	DEBUGSTR (buffer);
	return pbyInst;
  }

#else           /* debug */

  FS_PRIVATE uint8* itrp_DEBUG (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);
    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	CHECK_POP (LocalGS.stackPointer);
	return pbyInst;
  }

#endif          /* debug */
#else

  FS_PRIVATE uint8* itrp_DEBUG (IPARAM)
  {
	FS_UNUSED_PARAMETER(lOpCode);
    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	CHECK_POP (LocalGS.stackPointer);
	return pbyInst;
  }

#endif          /* ! not on the mac */


/* these functions were split out from itrp_BinaryOperand - deanb */

  FS_PRIVATE uint8* itrp_LT (IPARAM)
  {
	F26Dot6 *pfxStack;
	
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	pfxStack = LocalGS.stackPointer - 1;
	LocalGS.stackPointer = pfxStack;
	pfxStack[-1] = (pfxStack[-1] < pfxStack[0]) ? 1 : 0;
	CHECK_STACK (&LocalGS);
	return pbyInst;
  }

  FS_PRIVATE uint8* itrp_LTEQ (IPARAM)
  {
	F26Dot6 *pfxStack;
	
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	pfxStack = LocalGS.stackPointer - 1;
	LocalGS.stackPointer = pfxStack;
	pfxStack[-1] = (pfxStack[-1] <= pfxStack[0]) ? 1 : 0;
	CHECK_STACK (&LocalGS);
	return pbyInst;
  }

  FS_PRIVATE uint8* itrp_GT (IPARAM)
  {
	F26Dot6 *pfxStack;
	
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	pfxStack = LocalGS.stackPointer - 1;
	LocalGS.stackPointer = pfxStack;
	pfxStack[-1] = (pfxStack[-1] > pfxStack[0]) ? 1 : 0;
	CHECK_STACK (&LocalGS);
	return pbyInst;
  }

  FS_PRIVATE uint8* itrp_GTEQ (IPARAM)
  {
	F26Dot6 *pfxStack;
	
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	pfxStack = LocalGS.stackPointer - 1;
	LocalGS.stackPointer = pfxStack;
	pfxStack[-1] = (pfxStack[-1] >= pfxStack[0]) ? 1 : 0;
	CHECK_STACK (&LocalGS);
	return pbyInst;
  }

  FS_PRIVATE uint8* itrp_EQ (IPARAM)
  {
	F26Dot6 *pfxStack;
	
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	pfxStack = LocalGS.stackPointer - 1;
	LocalGS.stackPointer = pfxStack;
	pfxStack[-1] = (pfxStack[-1] == pfxStack[0]) ? 1 : 0;
	CHECK_STACK (&LocalGS);
	return pbyInst;
  }

  FS_PRIVATE uint8* itrp_NEQ (IPARAM)
  {
	F26Dot6 *pfxStack;
	
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	pfxStack = LocalGS.stackPointer - 1;
	LocalGS.stackPointer = pfxStack;
	pfxStack[-1] = (pfxStack[-1] != pfxStack[0]) ? 1 : 0;
	CHECK_STACK (&LocalGS);
	return pbyInst;
  }

  FS_PRIVATE uint8* itrp_AND (IPARAM)
  {
	F26Dot6 *pfxStack;
	
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	pfxStack = LocalGS.stackPointer - 1;
	LocalGS.stackPointer = pfxStack;
	pfxStack[-1] = (pfxStack[-1] && pfxStack[0]) ? 1 : 0;
	CHECK_STACK (&LocalGS);
	return pbyInst;
  }

  FS_PRIVATE uint8* itrp_OR (IPARAM)
  {
	F26Dot6 *pfxStack;
	
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	pfxStack = LocalGS.stackPointer - 1;
	LocalGS.stackPointer = pfxStack;
	pfxStack[-1] = (pfxStack[-1] || pfxStack[0]) ? 1 : 0;
	CHECK_STACK (&LocalGS);
	return pbyInst;
  }

  FS_PRIVATE uint8* itrp_ADD (IPARAM)
  {
	F26Dot6 *pfxStack;
	
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	pfxStack = LocalGS.stackPointer - 1;
	LocalGS.stackPointer = pfxStack;
	pfxStack[-1] += pfxStack[0];
	CHECK_STACK (&LocalGS);
	return pbyInst;
  }

  FS_PRIVATE uint8* itrp_SUB (IPARAM)
  {
	F26Dot6 *pfxStack;
	
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	pfxStack = LocalGS.stackPointer - 1;
	LocalGS.stackPointer = pfxStack;
	pfxStack[-1] -= pfxStack[0];
	CHECK_STACK (&LocalGS);
	return pbyInst;
  }

  FS_PRIVATE uint8* itrp_MUL (IPARAM)
  {
	F26Dot6 *pfxStack;
	
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	pfxStack = LocalGS.stackPointer - 1;
	LocalGS.stackPointer = pfxStack;
	pfxStack[-1] =  Mul26Dot6(pfxStack[-1], pfxStack[0]);
	CHECK_STACK (&LocalGS);
	return pbyInst;
  }

  FS_PRIVATE uint8* itrp_DIV (IPARAM)
  {
	F26Dot6 *pfxStack;
	
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	pfxStack = LocalGS.stackPointer - 1;
	LocalGS.stackPointer = pfxStack;
	if (pfxStack[0] == 0)
	{
		LocalGS.ercReturn = DIV_BY_0_IN_HINTING_ERR;  /* returned to client, error DIV by zero */
		return LocalGS.pbyEndInst;
	} 
	pfxStack[-1] = (int32)(((long)pfxStack[-1] << 6) / pfxStack[0]);
	CHECK_STACK (&LocalGS);
	return pbyInst;
  }

  FS_PRIVATE uint8* itrp_MAX (IPARAM)
  {
	F26Dot6 *pfxStack;
	
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	pfxStack = LocalGS.stackPointer - 1;
	LocalGS.stackPointer = pfxStack;
	if (pfxStack[-1] < pfxStack[0])
	{
		pfxStack[-1] = pfxStack[0];
	}
	CHECK_STACK (&LocalGS);
	return pbyInst;
  }
  
  FS_PRIVATE uint8* itrp_MIN (IPARAM)
  {
	F26Dot6 *pfxStack;
	
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	pfxStack = LocalGS.stackPointer - 1;
	LocalGS.stackPointer = pfxStack;
	if (pfxStack[-1] > pfxStack[0])
	{
		pfxStack[-1] = pfxStack[0];
	}
	CHECK_STACK (&LocalGS);
	return pbyInst;
  }

/**************************************************************************/

/* these functions were split out from itrp_UnaryOperand - deanb */

// for the ODD/EVEN pair, b/w, and no engine compensation case, we could
// essentially look at the two bits before and after the binary point of
// the F26Dot6 number:
//		1.100000 rounds to 2 (even)
//		1.000000 rounds to 1 (odd)
//		0.100000 rounds to 1 (odd)
//		0.000000 rounds to 0 (even)
// If the two bits are equal, then the number is even, else odd
// for engine compensation, we currently call the full itrp_RoundToGrid
// we'll allow tagged SP fonts to inquire about even/odd virtual pixels

  FS_PRIVATE uint8* itrp_ODD (IPARAM) {
	F26Dot6 *pfxStack;
	F26Dot6 fxArg;
	
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	pfxStack = LocalGS.stackPointer - 1;
	fxArg = itrp_RoundToGrid (GSA *pfxStack, 0);
	fxArg >>= FNT_PIXELSHIFT;
	*pfxStack = fxArg & 1L;
	return pbyInst;
  }

  FS_PRIVATE uint8* itrp_EVEN (IPARAM) {
	F26Dot6 *pfxStack;
	F26Dot6 fxArg;
	
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	pfxStack = LocalGS.stackPointer - 1;
	fxArg = itrp_RoundToGrid (GSA *pfxStack, 0);
	fxArg >>= FNT_PIXELSHIFT;
	fxArg++;
	*pfxStack = fxArg & 1L;
	return pbyInst;
  }

  FS_PRIVATE uint8* itrp_NOT (IPARAM)
  {
	F26Dot6 *pfxStack;
	
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	pfxStack = LocalGS.stackPointer - 1;
	*pfxStack = !*pfxStack;
	return pbyInst;
  }
	  
  FS_PRIVATE uint8* itrp_ABS (IPARAM)
  {
	F26Dot6 *pfxStack;
	
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	pfxStack = LocalGS.stackPointer - 1;
	if (*pfxStack < 0L)
	{
		*pfxStack = -*pfxStack;
	}
	return pbyInst;
  }
	  
  FS_PRIVATE uint8* itrp_NEG (IPARAM)
  {
	F26Dot6 *pfxStack;
	
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	pfxStack = LocalGS.stackPointer - 1;
	*pfxStack = -*pfxStack;
	return pbyInst;
  }
	  
  FS_PRIVATE uint8* itrp_CEILING (IPARAM)
  {
	F26Dot6 *pfxStack;
	
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	pfxStack = LocalGS.stackPointer - 1;
	*pfxStack += FNT_PIXELSIZE - 1;		// actually, this is not the pixel size, but the number 1 in 26.6
	*pfxStack &= ~(FNT_PIXELSIZE - 1);	// same here
	return pbyInst;
  }
	  
  FS_PRIVATE uint8* itrp_FLOOR (IPARAM)
  {
	F26Dot6 *pfxStack;
	
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	pfxStack = LocalGS.stackPointer - 1;
	*pfxStack &= ~(FNT_PIXELSIZE - 1);	// actually, this is not the pixel size, but the number 1 in 26.6
	return pbyInst;
  }
	  

/**************************************************************************/

/* This is called by itrp_IF, itrp_ELSE, itrp_FDEF, and itrp_IDEF         */
/* It is used to find the next TrueType instruction in the instruction    */
/* stream by skipping over push data.  It is table driven for speed.      */

static const uint8 gbyPushTable[] = {
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
   21,22, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	1, 2, 3, 4, 5, 6, 7, 8, 2, 4, 6, 8,10,12,14,16,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
};

FS_PRIVATE uint8* itrp_SkipPushData (GSP uint8* pbyInst)
{
	int32 iDataCount;         /* count of data following push instruction */
	
	iDataCount = (int32)gbyPushTable[ pbyInst[-1] ];   /* opcode */
	
	if (iDataCount != 0)                        /* if a push instruction */
	{
		if (iDataCount == 21)                   /* special for npushb */
		{
			iDataCount = (int32)*pbyInst + 1;
		}
		else if (iDataCount == 22)              /* special for npushw */
		{
			iDataCount = ((int32)*pbyInst << 1) + 1;
		}
		pbyInst += iDataCount;

	}
	return pbyInst;
}

/**************************************************************************/

/*
 * IF
 */
FS_PRIVATE uint8* itrp_IF (IPARAM)
{
	int32 iLevel;
	int32 iScanOpCode;
	int32 iDataCount;         /* count of data following push instruction */

	FS_UNUSED_PARAMETER(lOpCode);	
	
    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	if (!CHECK_POP (LocalGS.stackPointer))
	{
		iLevel = 1;
		while ((iLevel != 0) && (pbyInst < LocalGS.pbyEndInst))     /* iLevel = # of IF's minus # of EIF's */
		{
			iScanOpCode = (int32)*pbyInst++;

			if (iScanOpCode == EIF_CODE)
			{
				ERR_IF (-1);
				iLevel--;
			} 
			else if (iScanOpCode == IF_CODE) 
			{
				ERR_IF (1);
				iLevel++;
			} 
			else if (iScanOpCode == ELSE_CODE) 
			{
				if (iLevel == 1) 
					break;
			} 
			else
			{
				iDataCount = (int32)gbyPushTable[iScanOpCode];
				
				if (iDataCount != 0)            /* if a push instruction */
				{
					if (iDataCount == 21)       /* special for npushb */
					{
						iDataCount = (int32)*pbyInst + 1;
					}
					else if (iDataCount == 22)  /* special for npushw */
					{
						iDataCount = ((int32)*pbyInst << 1) + 1;
					}
					pbyInst += iDataCount;
				}
			}
		}

		if ((pbyInst == LocalGS.pbyEndInst) && (iLevel != 0))
		{
			LocalGS.ercReturn = MISSING_EIF_ERR;  /* returned to client, missing EIF */

		}
	}
	return pbyInst;
}

/**************************************************************************/

/*
 *      ELSE for the IF
 */
FS_PRIVATE uint8* itrp_ELSE (IPARAM)
{
	int16 level;
	uint8 opCode;

	FS_UNUSED_PARAMETER(lOpCode);

	level = 1;
	while ((level != 0) && (pbyInst < LocalGS.pbyEndInst))     /* iLevel = # of IF's minus # of EIF's */
	{
		opCode = *pbyInst++;
		
		if (opCode == EIF_CODE)
		{
			ERR_IF (-1);
			level--;
		} 
		else if (opCode == IF_CODE) 
		{
			ERR_IF (1);
			level++;
		} 
		else
		{
			pbyInst = itrp_SkipPushData (GSA pbyInst);
		}
	}

	if (level != 0)
	{
		LocalGS.ercReturn = MISSING_EIF_ERR;  /* returned to client, missing EIF */

	}
	return pbyInst;
}

/**************************************************************************/

/*
 * End IF
 */
FS_PRIVATE uint8* itrp_EIF (IPARAM)
{
	FS_UNUSED_PARAMETER(lOpCode);

	return pbyInst;
}

/**************************************************************************/

/*
 * Jump Relative
 */
FS_PRIVATE uint8* itrp_JMPR (IPARAM)
{
	int32 offset;

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	offset = (int32)CHECK_POP (LocalGS.stackPointer);
	offset--;       /* since the interpreter post-increments the IP */
	pbyInst += offset;
	LocalGS.ulJumpCounter --; /* jump counter used to detect infinite loops */

	if (LocalGS.ulJumpCounter == 0)
	{
		LocalGS.ercReturn = INFINITE_LOOP_ERR;  /* error returned to client */
		return LocalGS.pbyEndInst;
	}
    if (pbyInst < LocalGS.pbyStartInst)
	{
		LocalGS.ercReturn = JUMP_BEFORE_START_ERR;  /* error returned to client */
		return LocalGS.pbyEndInst;
    }
	return pbyInst;
}

/**************************************************************************/

/*
 * Jump Relative On True
 */
FS_PRIVATE uint8* itrp_JROT (IPARAM)
{
	int32 offset;
	boolean bFlag;

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	bFlag = (boolean)CHECK_POP (LocalGS.stackPointer);
	offset = (int32)CHECK_POP (LocalGS.stackPointer);

	if (bFlag)
	{
		pbyInst += offset - 1;    /* interpreter post-increments the IP */
		LocalGS.ulJumpCounter --; /* jump counter used to detect infinite loops */
		if (LocalGS.ulJumpCounter == 0)
		{
			LocalGS.ercReturn = INFINITE_LOOP_ERR;  /* error returned to client */
			return LocalGS.pbyEndInst;
		}
        if (pbyInst < LocalGS.pbyStartInst)
		{
			LocalGS.ercReturn = JUMP_BEFORE_START_ERR;  /* error returned to client */
			return LocalGS.pbyEndInst;
		}
	} 
	return pbyInst;
}

/**************************************************************************/

/*
 * Jump Relative On False
 */
FS_PRIVATE uint8* itrp_JROF (IPARAM)
{
	int32 offset;
	boolean bFlag;

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	bFlag = (boolean)CHECK_POP (LocalGS.stackPointer);
	offset = (int32)CHECK_POP (LocalGS.stackPointer);

	if (!bFlag)
	{
		pbyInst += offset - 1;    /* interpreter post-increments the IP */
		LocalGS.ulJumpCounter --; /* jump counter used to detect infinite loops */
		if (LocalGS.ulJumpCounter == 0)
		{
			LocalGS.ercReturn = INFINITE_LOOP_ERR;  /* error returned to client */
			return LocalGS.pbyEndInst;
		}
        if (pbyInst < LocalGS.pbyStartInst)
	    {
		    LocalGS.ercReturn = JUMP_BEFORE_START_ERR;  /* error returned to client */
		    return LocalGS.pbyEndInst;
        }
	} 
	return pbyInst;
}

/**************************************************************************/

/*
 * ROUND
 */
  FS_PRIVATE uint8* itrp_ROUND (IPARAM)
  {
	F26Dot6 arg1;
	fnt_ParameterBlock *pb = &LocalGS.globalGS->localParBlock;

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	arg1 = CHECK_POP (LocalGS.stackPointer);

	CHECK_RANGE (lOpCode, 0x68, 0x6B);

	arg1 = pb->RoundValue (GSA arg1, LocalGS.globalGS->engine[lOpCode - 0x68]);
	
	CHECK_PUSH (LocalGS.stackPointer , arg1);
	return pbyInst;
  }

/*
 * No ROUND
 */
  FS_PRIVATE uint8* itrp_NROUND (IPARAM)
  {
	F26Dot6 arg1;

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	arg1 = CHECK_POP (LocalGS.stackPointer);

	CHECK_RANGE (lOpCode, 0x6C, 0x6F);

	arg1 = itrp_RoundOff (GSA arg1, LocalGS.globalGS->engine[lOpCode - 0x6c]);
	CHECK_PUSH (LocalGS.stackPointer , arg1);
	return pbyInst;
  }

/**************************************************************************/

/*
 * An internal function used by MIRP an MDRP.
 */
  F26Dot6 itrp_CheckSingleWidth (GSP F26Dot6 fxValue) { // Single Width cut-in? B.St. to check
	F26Dot6 fxDelta;
	F26Dot6 fxScaledSW;
	fnt_ParameterBlock *pb;

	pb = &LocalGS.globalGS->localParBlock;
	fxScaledSW = LocalGS.GetSingleWidth (GSA0);

	if (fxValue >= 0) 
	{
		fxDelta = fxValue - fxScaledSW;
		if (fxDelta < 0)    
			fxDelta = -fxDelta;
		if (fxDelta < pb->sWCI)    
			fxValue = fxScaledSW;
	} 
	else 
	{
		fxValue = -fxValue;
		fxDelta = fxValue - fxScaledSW;
		if (fxDelta < 0)    
			fxDelta = -fxDelta;
		if (fxDelta < pb->sWCI)    
			fxValue = fxScaledSW;
		fxValue = -fxValue;
	}
	return fxValue;
}

/**************************************************************************/

/*
 * Move Direct Relative Point
 */
FS_PRIVATE uint8* itrp_MDRP (IPARAM)
{
	int32 iPt0;
	int32 iPt1;
	fnt_ElementType *pCE0;
	fnt_ElementType *pCE1;
	fnt_GlobalGraphicStateType *globalGS;
	fnt_ParameterBlock *pb;
	F26Dot6 fxMoveDist;
	F26Dot6 fxUnRounded;
	F26Dot6 fxMin;
	
	iPt0 = LocalGS.Pt0;
	pCE0 = LocalGS.CE0;
	pCE1 = LocalGS.CE1;
	globalGS = LocalGS.globalGS;
	pb = &globalGS->localParBlock;

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	iPt1 = (int32)CHECK_POP (LocalGS.stackPointer);

	SECURE_CHECK_POINT (pCE0, iPt0);
	SECURE_CHECK_POINT (pCE1, iPt1);
	CHECK_POINT (&LocalGS, pCE0, iPt0);
	CHECK_POINT (&LocalGS, pCE1, iPt1);

#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	if (LocalGS.globalGS->pgmIndex == GLYPHPROGRAM && LocalGS.inSubPixelDirection && CompatibleWidthSP(globalGS))
		if (pCE1 != &LocalGS.elements[TWILIGHTZONE] && LocalGS.pt0 != -1 && LocalGS.pt1 != -1 && InterAlign(LocalGS.CE1,LocalGS.pt0,iPt1,LocalGS.pt1))
			AddProportion(&LocalGS,pCE1,LocalGS.pt0,iPt1,LocalGS.pt1);
		else 
			AddDistance(&LocalGS,pCE1,iPt0,iPt1,OTHER); // strokes are hardly MDRPed, more likely to get black MDRPs that should be grey
#endif

	if (pCE0 == &LocalGS.elements[TWILIGHTZONE] || pCE1 == &LocalGS.elements[TWILIGHTZONE] || LocalGS.globalGS->bOriginalPointIsInvalid) {
		fxMoveDist = (*LocalGS.OldProject) (GSA pCE1->ox[iPt1] - pCE0->ox[iPt0], pCE1->oy[iPt1] - pCE0->oy[iPt0]);
	} else if (globalGS->bSameStretch) {
		fxMoveDist = (*LocalGS.OldProject) (GSA pCE1->oox[iPt1] - pCE0->oox[iPt0], pCE1->ooy[iPt1] - pCE0->ooy[iPt0]);
		fxMoveDist = globalGS->ScaleFuncCVT( &globalGS->scaleCVT, fxMoveDist );
	} else {
		fxMoveDist = (*LocalGS.OldProject) (GSA 
			globalGS->ScaleFuncX (&globalGS->scaleX, pCE1->oox[iPt1] - pCE0->oox[iPt0]), 
			globalGS->ScaleFuncY (&globalGS->scaleY, pCE1->ooy[iPt1] - pCE0->ooy[iPt0]) );
	}

	if (pb->sWCI) { // Single Width cut-in? B.St. to check
		fxMoveDist = itrp_CheckSingleWidth (GSA fxMoveDist);
	}

	fxUnRounded = fxMoveDist;

	if (BIT2 (lOpCode)) { // Round?
		fxMoveDist = pb->RoundValue (GSA fxMoveDist, globalGS->engine[lOpCode & 0x03]);
	} else {
		fxMoveDist = itrp_RoundOff (GSA fxMoveDist, globalGS->engine[lOpCode & 0x03]);
	}
	
	if (BIT3 (lOpCode)) { // Minimum distance?
		fxMin = pb->minimumDistance;
#ifdef FSCFG_SUBPIXEL
			if (LocalGS.inSubPixelDirection)
				fxMin /= MIN_DIST_OVERSCALE;
#endif
		if (fxUnRounded >= 0) {
			if (fxMoveDist < fxMin)
				fxMoveDist = fxMin;
		} else {
			fxMin = -fxMin;
			if (fxMoveDist > fxMin)
				fxMoveDist = fxMin;
		}
	}

	fxMoveDist -= (*LocalGS.Project) (GSA pCE1->x[iPt1] - pCE0->x[iPt0], pCE1->y[iPt1] - pCE0->y[iPt0]);
	(*LocalGS.MovePoint) (GSA pCE1, iPt1, fxMoveDist);
	
	LocalGS.Pt1 = iPt0;
	LocalGS.Pt2 = iPt1;
	if (BIT4 (lOpCode))
	{
		LocalGS.Pt0 = iPt1;          /* move the reference point */
	}
	return pbyInst;
} // itrp_MDRP


/**************************************************************************/

/*
 * Move Indirect Relative Point     General
 */

/*    
 *  This routine branches to either the general MIRPG, or to the fast MIRPX 
 *  or MIRPY.  The MIRPCode is set to MIRPX at the beginning of each glyph, 
 *  and may be changed to MIRPY or to MIRPX by the SVTCA instructions.  
 *  Any other change in relevant state will cause the function vector to fall 
 *  back to MIRPG.
 *
 *  Conditions for fast MIRPX and MIRPY:
 *      fast cvt (identity transform)
 *      no single width cut in
 *      no twilight zone
 *      round to grid
 *      no engine compensation
 *      LocalGS.MovePoint = itrp_X[or Y]MovePoint;  
 */

FS_PRIVATE uint8* itrp_MIRP (IPARAM)
{
	int32 iPoint;
	int32 iPt0;
	int32 iCVTIndex;
	F26Dot6 fxMoveDist;
	F26Dot6 fxMin;
	F26Dot6 fxOutlineDist;
	F26Dot6 fxPosition;
	F26Dot6 fxEngine;
#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	long color;
#endif
	
	fnt_ParameterBlock *pb;
	fnt_ElementType *pCE0;
	fnt_ElementType *pCE1;
	fnt_GlobalGraphicStateType *globalGS;

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	globalGS = LocalGS.globalGS;                /* common setup */
	pb = &globalGS->localParBlock;      
	pCE0 = LocalGS.CE0;
	pCE1 = LocalGS.CE1;
	iCVTIndex = (int32)CHECK_POP (LocalGS.stackPointer);
	SECURE_CHECK_CVT (iCVTIndex);
	CHECK_CVT (&LocalGS, iCVTIndex);
	
	iPoint = (int32)CHECK_POP (LocalGS.stackPointer);
	SECURE_CHECK_POINT (LocalGS.CE1, iPoint);
	CHECK_POINT (&LocalGS, LocalGS.CE1, iPoint);
	
	iPt0 = LocalGS.Pt0;
	SECURE_CHECK_POINT (LocalGS.CE0, iPt0);
	CHECK_POINT (&LocalGS, LocalGS.CE0, iPt0);
	LocalGS.Pt1 = iPt0;
	LocalGS.Pt2 = iPoint;
	
#ifdef SUBPIXEL_BC_AW_STEM_CONCERTINA
	if (pCE1 != &LocalGS.elements[TWILIGHTZONE] && LocalGS.globalGS->pgmIndex == GLYPHPROGRAM && LocalGS.inSubPixelDirection && CompatibleWidthSP(globalGS)) {
		color = DoubleCheckLinkColor(pCE1,iPt0,iPoint,lOpCode & 0x03);
		AddDistance(&LocalGS,pCE1,iPt0,iPoint,color);
	}
#endif

	if (LocalGS.MIRPCode == MIRPG)              /********* MIRPG *********/
	{
		fxMoveDist = LocalGS.GetCVTEntry (GSA iCVTIndex);

		if (pb->sWCI) { // Single Width cut-in? B.St. to check
			fxMoveDist = itrp_CheckSingleWidth (GSA fxMoveDist);
		}

		if (pCE1 == &LocalGS.elements[TWILIGHTZONE]) {
			pCE1->ox[iPoint] = pCE0->ox[iPt0] + (F26Dot6) VECTORMUL (fxMoveDist, LocalGS.proj.x);
			pCE1->x[iPoint] = pCE1->ox[iPoint];
			pCE1->oy[iPoint] = pCE0->oy[iPt0] + (F26Dot6) VECTORMUL (fxMoveDist, LocalGS.proj.y);
			pCE1->y[iPoint] = pCE1->oy[iPoint];
		}

		if (LocalGS.OldProject == itrp_XProject) {
			fxOutlineDist = pCE1->ox[iPoint] - pCE0->ox[iPt0];
		} else if (LocalGS.OldProject == itrp_YProject) {
			fxOutlineDist = pCE1->oy[iPoint] - pCE0->oy[iPt0];
		} else {
			fxOutlineDist = (*LocalGS.OldProject) (GSA pCE1->ox[iPoint] - pCE0->ox[iPt0], pCE1->oy[iPoint] - pCE0->oy[iPt0]);
		}

		if (((fxOutlineDist ^ fxMoveDist) < 0) && (pb->autoFlip)) {
			fxMoveDist = -fxMoveDist;           /* Do the auto flip */
		}

		fxEngine = globalGS->engine[lOpCode & 0x03];

#ifdef FSCFG_SUBPIXEL
		if (LocalGS.inSubPixelDirection) {
			// here we may honour a cvt cut-in even though the round-off flag would require not to do so. We assume that the
			// context is a stroke weight that has been tweaked for use with grey-scaling, and the only way to force MIRP
			// to use a particular distance is to round the cvt "by hand" and then turn off the rounding flag, which is
			// quite what we don't want to do in SubPixel, ie. to enforce an unnatural weight.
#ifdef RoundOffRespectsCvtCutIn
			if (!Tuned4SubPixel(globalGS)) {
				// round off respects cvt cut-in, non native sp fonts do early cvt cut-in test, ahead of rounding
				CVTCI(pb,fxMoveDist,fxOutlineDist,CVT_CUT_IN_OVERSCALE);
			}
#endif				
			if (BIT2 (lOpCode)) { // Round?
#ifdef RoundOffRespectsCvtCutIn
				if (Tuned4SubPixel(globalGS)) {
					// round off respects cvt cut-in, but native sp fonts do cvt cut-in test in the usual place
					CVTCI(pb,fxMoveDist,fxOutlineDist,CVT_CUT_IN_OVERSCALE);
				}
#else
				// round off doesn't respect cvt cut-in, hence cvt cut-in test in the usual place
				CVTCI(pb,fxMoveDist,fxOutlineDist,CVT_CUT_IN_OVERSCALE);
#endif // RoundOffRespectsCvtCutIn
				fxMoveDist = pb->RoundValue (GSA fxMoveDist, fxEngine);
			} else { // !Round
				fxMoveDist = itrp_RoundOffSP (GSA fxMoveDist, fxEngine);
			}
		} else { // !inSubPixelDirection
#endif // FSCFG_SUBPIXEL
			if (BIT2 (lOpCode)) { // Round?
				CVTCI(pb,fxMoveDist,fxOutlineDist,1);
				fxMoveDist = pb->RoundValue (GSA fxMoveDist, fxEngine);
			} else {
				fxMoveDist = itrp_RoundOff (GSA fxMoveDist, fxEngine);
			}
#ifdef FSCFG_SUBPIXEL
		}
#endif
		if (BIT3 (lOpCode)) { // Minimum distance?
			fxMin = pb->minimumDistance;
#ifdef FSCFG_SUBPIXEL
			if (LocalGS.inSubPixelDirection)
				fxMin /= MIN_DIST_OVERSCALE;
#endif
			if (fxOutlineDist >= 0) {
				if (fxMoveDist < fxMin)
					fxMoveDist = fxMin;
			} else {
				fxMin = -fxMin;
				if (fxMoveDist > fxMin)
					fxMoveDist = fxMin;
			}
		}
		if (LocalGS.Project == itrp_XProject) {
			fxPosition = pCE1->x[iPoint] - pCE0->x[iPt0];
		} else if (LocalGS.Project == itrp_YProject) {
			fxPosition = pCE1->y[iPoint] - pCE0->y[iPt0];
		} else {
			fxPosition = (*LocalGS.Project) (GSA pCE1->x[iPoint] - pCE0->x[iPt0], pCE1->y[iPoint] - pCE0->y[iPt0]);
		}

		(*LocalGS.MovePoint) (GSA pCE1, iPoint, fxMoveDist - fxPosition);
	
	} else if (LocalGS.MIRPCode == MIRPX) {        /********* MIRPX *********/
	
		fxMoveDist = globalGS->controlValueTable[ iCVTIndex ];  /* always fast */

		fxOutlineDist = pCE1->ox[iPoint] - pCE0->ox[iPt0];  /* x direction only */

		if (((fxOutlineDist ^ fxMoveDist) < 0) && (pb->autoFlip)) {
			fxMoveDist = -fxMoveDist;           /* Do the auto flip */
		}

#ifdef FSCFG_SUBPIXEL
		if (LocalGS.inSubPixelDirection) {
			// same situation as in general MIRP case above
#ifdef RoundOffRespectsCvtCutIn
			if (!Tuned4SubPixel(globalGS)) {
				// round off respects cvt cut-in, non native sp fonts do early cvt cut-in test, ahead of rounding
				CVTCI(pb,fxMoveDist,fxOutlineDist,CVT_CUT_IN_OVERSCALE);
			}
#endif				
			if (BIT2 (lOpCode)) { // Round?
#ifdef RoundOffRespectsCvtCutIn
				if (Tuned4SubPixel(globalGS)) {
					// round off respects cvt cut-in, but native sp fonts do cvt cut-in test in the usual place
					CVTCI(pb,fxMoveDist,fxOutlineDist,CVT_CUT_IN_OVERSCALE);
				}
#else			
				// round off doesn't respect cvt cut-in, hence cvt cut-in test in the usual place
				CVTCI(pb,fxMoveDist,fxOutlineDist,CVT_CUT_IN_OVERSCALE);
#endif				
				RTG(fxMoveDist,0,VIRTUAL_PIXELSIZE_RTG);
			} // else no round off since no engine compensation
		} else { // !inSubPixelDirection
#endif // FSCFG_SUBPIXEL

			if (BIT2 (lOpCode)) { // Round?
				CVTCI(pb,fxMoveDist,fxOutlineDist,1);
				RTG(fxMoveDist,0,FNT_PIXELSIZE);
			} // else no round off since no engine compensation

#ifdef FSCFG_SUBPIXEL
		}
#endif

		if (BIT3 (lOpCode)) { // Minimum distance?
			fxMin = pb->minimumDistance;
#ifdef FSCFG_SUBPIXEL
			if (LocalGS.inSubPixelDirection)
				fxMin /= MIN_DIST_OVERSCALE;
#endif
			if (fxOutlineDist >= 0) {
				if (fxMoveDist < fxMin)
					fxMoveDist = fxMin;
			} else {
				fxMin = -fxMin;
				if (fxMoveDist > fxMin)
					fxMoveDist = fxMin;
			}
		}

		pCE1->x[iPoint] = fxMoveDist + pCE0->x[iPt0];  /* move point fast */
		pCE1->f[iPoint] |= XMOVED;
	
	} else { /* if (LocalGS.MIRPCode == MIRPY) */  /********* MIRPY *********/
	
		fxMoveDist = globalGS->controlValueTable[ iCVTIndex ];  /* always fast */

		fxOutlineDist = pCE1->oy[iPoint] - pCE0->oy[iPt0];  /* y direction only */

		if (((fxOutlineDist ^ fxMoveDist) < 0) && (pb->autoFlip)) {
			fxMoveDist = -fxMoveDist;           /* Do the auto flip */
		}

#ifdef FSCFG_SUBPIXEL
		if (LocalGS.inSubPixelDirection) {
			// same situation as in general MIRP case above
#ifdef RoundOffRespectsCvtCutIn
			if (!Tuned4SubPixel(globalGS)) {
				// round off respects cvt cut-in, non native sp fonts do early cvt cut-in test, ahead of rounding
				CVTCI(pb,fxMoveDist,fxOutlineDist,CVT_CUT_IN_OVERSCALE);
			}
#endif				
			if (BIT2 (lOpCode)) { // Round?
#ifdef RoundOffRespectsCvtCutIn
				if (Tuned4SubPixel(globalGS)) {
					// round off respects cvt cut-in, but native sp fonts do cvt cut-in test in the usual place
					CVTCI(pb,fxMoveDist,fxOutlineDist,CVT_CUT_IN_OVERSCALE);
				}
#else			
				// round off doesn't respect cvt cut-in, hence cvt cut-in test in the usual place
				CVTCI(pb,fxMoveDist,fxOutlineDist,CVT_CUT_IN_OVERSCALE);
#endif				
				RTG(fxMoveDist,0,VIRTUAL_PIXELSIZE_RTG);
			} // else no round off since no engine compensation
		} else { // !inSubPixelDirection
#endif // FSCFG_SUBPIXEL

			if (BIT2 (lOpCode)) { // Round?
				CVTCI(pb,fxMoveDist,fxOutlineDist,1);
				RTG(fxMoveDist,0,FNT_PIXELSIZE);
			} // else no round off since no engine compensation

#ifdef FSCFG_SUBPIXEL
		}
#endif

		if (BIT3 (lOpCode)) { // Minimum distance?
			fxMin = pb->minimumDistance;
#ifdef FSCFG_SUBPIXEL
			if (LocalGS.inSubPixelDirection)
				fxMin /= MIN_DIST_OVERSCALE;
#endif
			if (fxOutlineDist >= 0) {
				if (fxMoveDist < fxMin)
					fxMoveDist = fxMin;
			} else {
				fxMin = -fxMin;
				if (fxMoveDist > fxMin)
					fxMoveDist = fxMin;
			}
		}

		pCE1->y[iPoint] = fxMoveDist + pCE0->y[iPt0];  /* move point fast */
		pCE1->f[iPoint] |= YMOVED;
	}
	
	if (BIT4 (lOpCode)) {
		LocalGS.Pt0 = iPoint;                   /* move the reference point */
	}
	return pbyInst;
} // itrp_MIRP

/**************************************************************************/

/*
 * CALL a function
 */
FS_PRIVATE uint8* itrp_CALL (IPARAM)
{
	fnt_funcDef *funcDef;
	uint8 *pbySubroutine;
	fnt_GlobalGraphicStateType *globalGS;
	int32 arg;
	uint8 *pbyEndInst;                      /* saves parent's stop condition */
	uint8 *pbyStartInst;                    /* saves parent's stop condition */
#ifdef FSCFG_SUBPIXEL
#ifdef BypassDandIStroke
	uint8 patchedStore22 = false;
	F26Dot6 store22;
#endif
#ifdef BypassJellesSpacing
	uint8 patchedStore24 = false;
	F26Dot6 store24;
#endif
#ifdef AssistTomsDiagonal
	uint8 assistTomsDiagonal = false;
	F26Dot6 cvtCI = 0;
#endif
#ifdef InlineDeltasOnly
	uint16 i;
	uint8 inSkippableDeltaFn = false;
#endif
#endif

	FS_UNUSED_PARAMETER(lOpCode);

	globalGS = LocalGS.globalGS;
    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	arg = (int32)CHECK_POP (LocalGS.stackPointer);

	CHECK_PROGRAM (funcDef->pgmIndex);
    SECURE_CHECK_FDEF(arg);
	CHECK_FDEF (&LocalGS, arg);
	funcDef = &globalGS->funcDef[ arg ];

 	SECURE_CHECK_PROGRAM (funcDef->pgmIndex);

	pbySubroutine = globalGS->pgmList[ funcDef->pgmIndex ].Instruction;

	CHECK_ASSERTION (globalGS->funcDef != 0);
	CHECK_ASSERTION (pbySubroutine != 0);

	pbySubroutine += funcDef->start;
	pbyEndInst = LocalGS.pbyEndInst;        /* save for parent */
	pbyStartInst = LocalGS.pbyStartInst;        /* save for parent */

#ifdef FSCFG_SUBPIXEL
#ifdef BypassDandIStroke
	// here we're assuming that fns 64 through 66 are support functions for the TMT D/IStroke commands, which may make strokes collapse in SubPixel.
	// To determine whether we've actually run into the context of these fns, we look at the first couple of bytes only, as the exact implementation
	// of these functions may have changed over time, but hopefully, the preamble (to look at storage #22) hasn't. The easiest way to by-pass these
	// fns is to flag storage #22 with 0, indicating not to use D/IStrokes, else we'd have to cleanup the stack.
	// Admittedly a bit of a hack. If anybody can think of a "better bandaid", I'll be happy to consider it.
	//    The reason, by the way, why DStroke doesn't work, is the following. DStroke brings pairs of points to the same y (or x), MIRP[m<rBl] the
	// floating point, and the moves it back to the old y (or x). Now that we re-interpret little r, cvt cut in actually gets to cut in, the original
	// distance gets to apply, just that the original distance is taken prior to bringing points to same y (or x), meaning it's likely to be WAY off.
	// As a result, the diagonal stroke weight (in x) starts to depend heavily on the distance (in y) of the control points involved, which obviously
	// is not what we want. Notice that for non-square aspect ratios, the DStroke is a NOP, therefore was a NOP with 16x SubPixel, and hence we're
	// not doing any major harm by skipping it in SubPixel.
	if (64 <= arg && arg <= 66 && RunningSubPixel(LocalGS.globalGS) && !Tuned4SubPixel(LocalGS.globalGS) && (LocalGS.globalGS->subPixelCompatibilityFlags & SPCF_detectedDandIStroke) > 0) {
		store22 = LocalGS.globalGS->store[22];
		LocalGS.globalGS->store[22] = 0;
		patchedStore22 = true;
	}
#endif
#ifdef BypassJellesSpacing
	// here we're assuming that fns 0, 1, 2, 4, 7, and 8 are support functions for Monotype's Jelle Bosma's spacing functions, which may squish
	// characters or pull them left or right or in both directions at the same time. This has to do amongst other with using the twilight zone.
	// The spacing algorithm is meant to be turned off above a certain size, such as 30 ppem, hence we may argue that with the extra virtual re-
	// solution we should turn it off at a considerably smaller ppem size, or altogether. From there the logic is like bypassing D/IStroke.
	// (1 << arg) & (1 + 2 + 4 + 16 + 128 + 256) != 0
	if ((0 <= arg && arg <= 2 || arg == 4 || 7 <= arg && arg <= 8) && RunningSubPixel(LocalGS.globalGS) && !Tuned4SubPixel(LocalGS.globalGS) && (LocalGS.globalGS->subPixelCompatibilityFlags & SPCF_detectedJellesSpacing) > 0) {
		store24 = LocalGS.globalGS->store[24];
		LocalGS.globalGS->store[24] = 0;
		patchedStore24 = true;
	}
#endif
#ifdef AssistTomsDiagonal
	if (arg == 58 && RunningSubPixel(LocalGS.globalGS) && !Tuned4SubPixel(LocalGS.globalGS) && (LocalGS.globalGS->subPixelCompatibilityFlags & SPCF_detectedTomsDiagonal) > 0) {
		cvtCI = LocalGS.globalGS->localParBlock.wTCI;
		LocalGS.globalGS->localParBlock.wTCI = 0x7fffffff;
		assistTomsDiagonal = true;
	}
#endif
#ifdef InlineDeltasOnly
	for (i = 0; i < LocalGS.globalGS->numDeltaFunctionsDetected && LocalGS.globalGS->deltaFunction[i] != (uint16)arg; i++);
	if (i < LocalGS.globalGS->numDeltaFunctionsDetected && RunningSubPixel(LocalGS.globalGS) && !Tuned4SubPixel(LocalGS.globalGS)) {
		LocalGS.globalGS->subPixelCompatibilityFlags |= SPCF_inSkippableDeltaFn;
		inSkippableDeltaFn = true;
	}
#endif
#endif


	LocalGS.ulRecursiveCall --; /* jump counter used to detect deep recursions */
	if (LocalGS.ulRecursiveCall == 0)
	{
		LocalGS.ercReturn = INFINITE_RECURSION_ERR;  /* error returned to client */
		return LocalGS.pbyEndInst;
	}
	LocalGS.Interpreter (GSA pbySubroutine, pbySubroutine + funcDef->length);   /* recursion */
	LocalGS.ulRecursiveCall ++; /* jump counter used to detect deep recursions */
	

#ifdef FSCFG_SUBPIXEL
#ifdef InlineDeltasOnly
	if (inSkippableDeltaFn) {
		LocalGS.globalGS->subPixelCompatibilityFlags &= ~SPCF_inSkippableDeltaFn;
	}
#endif
#ifdef AssistTomsDiagonal
	if (assistTomsDiagonal) {
		LocalGS.globalGS->localParBlock.wTCI = cvtCI;
	}
#endif
#ifdef BypassJellesSpacing
	if (patchedStore24) {
		LocalGS.globalGS->store[24] = store24;
	}
#endif
#ifdef BypassDandIStroke
	if (patchedStore22) {
		LocalGS.globalGS->store[22] = store22;
	}
#endif
#endif

	LocalGS.pbyEndInst = pbyEndInst;        /* restore for parent */
	LocalGS.pbyStartInst = pbyStartInst;    /* restore for parent */
	if (LocalGS.ercReturn != NO_ERR)        /* if illegal inst has been hit */
	{
		return pbyEndInst;                  /* exit parent's loop */
	}
			
	return pbyInst;
}

/**************************************************************************/

/*
 * Function DEFinition
 */
FS_PRIVATE uint8* itrp_FDEF (IPARAM)
{
	fnt_funcDef *funcDef;
	uint8 * program, *funcStart;
	uint8 funcFragment[8][16] ={{0x01,0x20,0xB0,0x03,0x25},				// SVTCA[X] DUP[] #PUSH 3 CINDEX[] (DiagEndCtrl)
								{0xB0,0x16,0x43,0x58},					// #PUSH 22 RS[] IF[] (D/IStroke)
								{0x01,0xB0,0x18,0x43,0x58},				// SVTCA[X] #PUSH 24 RS[] IF[] (Jelle's Spacing, version #1)
								{0x01,0x18,0xB0,0x18,0x43,0x58},		// SVTCA[X] RTG[] #PUSH 24 RS[] IF[] (Jelle's Spacing, version #2)
								{0x45,0x23,0x46,0x60,0x20,0xB0,0x26},	// RCVT[] SWAP[] GC[N] ADD[] DUP[] #PUSH 38 (VacuFormRound)
								{0x20,0x20,0xB0,0x01,0x60,0x46,0xB0,0x40,0x23,0x42}, // DUP[] DUP[] #PUSH[] 1 ADD[] GC[N] #PUSH[] 64 SWAP[] WS[] (Tom's Diagonal)
								{0x4B,0x53,0x23,0x4B,0x51,0x5A,0x58,0x38,0x1B,0x21,0x21,0x59,0x2D}, // MPPEM[] GTEQ[] SWAP[] MPPEM[] LTEQ[] AND[] IF[] SHPIX[] ELSE[] POP[] POP[] EIF[] ENDF[] (Range of deltas)
								{0x4B,0x54,0x58,0x38,0x1B,0x21,0x21,0x59,0x2D}}; // MPPEM[] EQ[] IF[] SHPIX[] ELSE[] POP[] POP[] EIF[] ENDF[] (Delta)

	// extend here for two variants of delta fn

	fnt_GlobalGraphicStateType * globalGS;
	int32 arg;

	FS_UNUSED_PARAMETER(lOpCode);

	globalGS = LocalGS.globalGS;

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	arg = (int32)CHECK_POP (LocalGS.stackPointer);
    SECURE_CHECK_FDEF(arg);
	CHECK_FDEF (&LocalGS, arg);

	if (LocalGS.globalGS->pgmIndex >= MAXPREPROGRAMS)
	{
		LocalGS.ercReturn = FDEF_IN_GLYPHPGM_ERR;  /* returned to client, error FDEF in glyph program */
		return LocalGS.pbyEndInst;
	}

	funcDef = &globalGS->funcDef[ arg ];
	program = globalGS->pgmList[ funcDef->pgmIndex = LocalGS.globalGS->pgmIndex ].Instruction;

	CHECK_PROGRAM (funcDef->pgmIndex);
	CHECK_ASSERTION (globalGS->funcDef != 0);
	CHECK_ASSERTION (globalGS->pgmList[funcDef->pgmIndex].Instruction != 0);

	funcDef->start = (int32)(pbyInst - program);

	funcStart = pbyInst;

#ifdef FSCFG_SUBPIXEL
#ifdef BypassDandIStroke
	if (64 <= arg && arg <= 66 && memcmp(funcStart,funcFragment[1],4) == 0)
		LocalGS.globalGS->subPixelCompatibilityFlags |= SPCF_detectedDandIStroke;
#endif
#ifdef BypassJellesSpacing // (1 << arg) & (1 + 2 + 4 + 16 + 128 + 256) != 0
	if ((0 <= arg && arg <= 2 || arg == 4 || 7 <= arg && arg <= 8) && (memcmp(funcStart,funcFragment[2],5) == 0 || memcmp(funcStart,funcFragment[3],6) == 0))
		LocalGS.globalGS->subPixelCompatibilityFlags |= SPCF_detectedJellesSpacing;
#endif
#ifdef BypassVacuformRound
	if (arg == 0 && memcmp(funcStart,funcFragment[4],7) == 0)
		LocalGS.globalGS->subPixelCompatibilityFlags |= SPCF_detectedVacuformRound;
#endif
#ifdef AssistTomsDiagonal
	if (arg == 58 && memcmp(funcStart,funcFragment[5],10) == 0) 
		LocalGS.globalGS->subPixelCompatibilityFlags |= SPCF_detectedTomsDiagonal;
#endif
#ifdef InlineDeltasOnly
	if (*funcStart == funcFragment[6][0] && (memcmp(funcStart,funcFragment[7],9) == 0 || memcmp(funcStart,funcFragment[6],13) == 0) && LocalGS.globalGS->numDeltaFunctionsDetected < maxDeltaFunctions)
		LocalGS.globalGS->deltaFunction[LocalGS.globalGS->numDeltaFunctionsDetected++] = (uint16)arg;
	// if we have too many delta fns, we'll end up executing a delta fn; this may not look optimal, but we don't expect to get to this point in the first place.
#endif
#endif
	while ( ((*pbyInst++) != ENDF_CODE)  && (pbyInst < LocalGS.pbyEndInst) )
	{
		pbyInst = itrp_SkipPushData (GSA pbyInst);
	}

	if ((pbyInst == LocalGS.pbyEndInst) &&  (*(pbyInst-1) != ENDF_CODE ))
	{
		LocalGS.ercReturn = MISSING_ENDF_ERR;  /* returned to client, missing ENDF */

	}

	funcDef->length = (uint16)(pbyInst - funcStart - 1); /* don't execute ENDF */
	return pbyInst;
}

/**************************************************************************/

/*
 * LOOP while CALLing a function
 */
FS_PRIVATE uint8* itrp_LOOPCALL (IPARAM)
{
	uint8 *start, *stop;
	InterpreterFunc Interpreter;
	fnt_funcDef *funcDef;
	int32 arg;
	int32 loop;
	uint8 * ins;
	uint8 *pbyEndInst;                      /* saves parent's stop condition */
	uint8 *pbyStartInst;                    /* saves parent's stop condition */
	
	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 2);
	arg = (int32)CHECK_POP (LocalGS.stackPointer);
    SECURE_CHECK_FDEF(arg);
	CHECK_FDEF (&LocalGS, arg);

	funcDef = & (LocalGS.globalGS->funcDef[ arg ]);
	{
		SECURE_CHECK_PROGRAM (funcDef->pgmIndex);
		CHECK_PROGRAM (funcDef->pgmIndex);
		ins = LocalGS.globalGS->pgmList[ funcDef->pgmIndex ].Instruction;

		start = &ins[funcDef->start];
		stop = &ins[funcDef->start + funcDef->length];  /* funcDef->end -> funcDef->length <4> */
	}
	Interpreter = LocalGS.Interpreter;
	arg = (int32)CHECK_POP (LocalGS.stackPointer);
	CHECK_INT16 (arg);
	CHECK_LARGER (-1L, arg);
	loop = (int32)arg;
	
	pbyEndInst = LocalGS.pbyEndInst;        /* save for parent */
	pbyStartInst = LocalGS.pbyStartInst;    /* save for parent */
	LocalGS.ulRecursiveCall --; /* jump counter used to detect deep recursions */
	if (LocalGS.ulRecursiveCall == 0)
	{
		LocalGS.ercReturn = INFINITE_RECURSION_ERR;  /* error returned to client */
		return LocalGS.pbyEndInst;
	}

	for (--loop; ((loop >= 0) && (LocalGS.ercReturn == NO_ERR)); --loop)
	{
		Interpreter (GSA start, stop);
	}
	LocalGS.ulRecursiveCall ++; /* jump counter used to detect deep recursions */
	LocalGS.pbyEndInst = pbyEndInst;        /* restore for parent */
	LocalGS.pbyStartInst = pbyStartInst;    /* restore for parent */
	
	if (LocalGS.ercReturn != NO_ERR)        /* if illegal inst has been hit */
	{
		return pbyEndInst;                  /* exit parent's loop */
	}
	return pbyInst;
}

/**************************************************************************/

/*
 *      This guy returns the index of the given opCode, or 0 if not found <4>
 */
FS_PRIVATE fnt_instrDef *itrp_FindIDef (GSP uint8 opCode)
{
	fnt_GlobalGraphicStateType *globalGS;
	int32 count;
	fnt_instrDef*instrDef;
	
	globalGS = LocalGS.globalGS;
	count = globalGS->instrDefCount;
	instrDef = globalGS->instrDef;
		
	for (--count; count >= 0; instrDef++, --count)
	{
		if (instrDef->opCode == opCode)
		{
			return instrDef;
		}
	}
	return 0;
}

/**************************************************************************/

/*
 *      This guy gets called for opCodes that has been patch by the font's IDEF <4>
 *      or if they have never been defined.  If there is no corresponding IDEF,
 *      flag it as an illegal instruction.
 */
FS_PRIVATE uint8* itrp_IDefPatch (IPARAM)
{
	fnt_instrDef *instrDef;
	uint8 *program;
	uint8 *pbyEndInst;                      /* saves parent's stop condition */
	uint8 *pbyStartInst;                    /* saves parent's stop condition */
	
	pbyEndInst = LocalGS.pbyEndInst;        /* save for parent */
	pbyStartInst = LocalGS.pbyStartInst;    /* save for parent */
	
	instrDef = itrp_FindIDef (GSA (uint8)lOpCode);
	if (instrDef == 0)
	{
		return itrp_IllegalInstruction (GSA pbyInst, lOpCode);
	}
	else
	{
		SECURE_CHECK_PROGRAM (instrDef->pgmIndex);
		CHECK_PROGRAM (instrDef->pgmIndex);
		program = LocalGS.globalGS->pgmList[ instrDef->pgmIndex ].Instruction;
		program += instrDef->start;
		
		LocalGS.ulRecursiveCall --; /* jump counter used to detect deep recursions */
		if (LocalGS.ulRecursiveCall == 0)
		{
			LocalGS.ercReturn = INFINITE_RECURSION_ERR;  /* error returned to client */
			return LocalGS.pbyEndInst;
		}

		LocalGS.Interpreter (GSA program, program + instrDef->length);
	
		LocalGS.ulRecursiveCall ++; /* jump counter used to detect deep recursions */

		LocalGS.pbyEndInst = pbyEndInst;    /* restore for parent */
		LocalGS.pbyStartInst = pbyStartInst;/* restore for parent */
		
		if (LocalGS.ercReturn != NO_ERR)    /* if illegal inst has been hit */
		{
			return pbyEndInst;              /* exit parent's loop */
		}
	}
	return pbyInst;
}

/**************************************************************************/

/*
 * Instruction DEFinition       <4>
 */
FS_PRIVATE uint8* itrp_IDEF (IPARAM)
{
	int32 arg;
	uint8 opCode;
	fnt_instrDef *instrDef;
	int32 pgmIndex;
	uint8 * program;
	uint8 * instrStart;

	FS_UNUSED_PARAMETER(lOpCode);

	pgmIndex = (int32)LocalGS.globalGS->pgmIndex;

	if (pgmIndex >= MAXPREPROGRAMS)
	{
		LocalGS.ercReturn = IDEF_IN_GLYPHPGM_ERR;  /* returned to client, error IDEF in glyph program */
		return LocalGS.pbyEndInst;
	}

	program = LocalGS.globalGS->pgmList[ pgmIndex ].Instruction;
	instrStart = pbyInst;
	
    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	arg = CHECK_POP (LocalGS.stackPointer);
    SECURE_CHECK_IDEF_OPCODE(arg);
    CHECK_INT8 (arg);
	opCode = (uint8)arg;
	CHECK_PROGRAM (pgmIndex);

	instrDef = itrp_FindIDef (GSA opCode);
	if (!instrDef)
	{
        SECURE_CHECK_IDEF_OVERFLOW();
		instrDef = LocalGS.globalGS->instrDef + LocalGS.globalGS->instrDefCount++;
	}

	instrDef->pgmIndex = (uint8) pgmIndex;
	instrDef->opCode = opCode;          /* this may or may not have been set */
	instrDef->start = (int32)(pbyInst - program);

	while (((*pbyInst++) != ENDF_CODE) && (pbyInst < LocalGS.pbyEndInst))
	{
		pbyInst = itrp_SkipPushData (GSA pbyInst);
	}

	if ((pbyInst == LocalGS.pbyEndInst) &&  (*(pbyInst-1) != ENDF_CODE ))
	{
		LocalGS.ercReturn = MISSING_ENDF_ERR;  /* returned to client, missing ENDF */

	}

	instrDef->length = (uint16)(pbyInst - instrStart - 1); /* don't execute ENDF */
	return pbyInst;
}

/**************************************************************************/

/*
 * UnTouch Point
 */
  FS_PRIVATE uint8* itrp_UTP (IPARAM)
  {
	uint8*f = LocalGS.CE0->f;
	int32 point;

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	point = (int32)CHECK_POP (LocalGS.stackPointer);
	SECURE_CHECK_POINT (LocalGS.CE0, point);
	CHECK_POINT (&LocalGS, LocalGS.CE0, point);
	if (LocalGS.free.x)
	{
	  f[point] &= ~XMOVED;
	}
	if (LocalGS.free.y)
	{
	  f[point] &= ~YMOVED;
	}
	return pbyInst;
  }

/*
 * Set Delta Base
 */
  FS_PRIVATE uint8* itrp_SDB (IPARAM)
  {
	int32 arg;

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	arg = CHECK_POP (LocalGS.stackPointer);
	CHECK_INT16 (arg);
	LocalGS.globalGS->localParBlock.deltaBase = (int16)arg;
	return pbyInst;
  }

/*
 * Set Delta Shift
 */
  FS_PRIVATE uint8* itrp_SDS (IPARAM)
  {
	int32 arg;

	FS_UNUSED_PARAMETER(lOpCode);

    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	arg = CHECK_POP (LocalGS.stackPointer);
	CHECK_INT16 (arg);
	LocalGS.globalGS->localParBlock.deltaShift = (int16)arg;
	return pbyInst;
  }

/**************************************************************************/

/*
 * DeltaEngine, internal support routine
 */
FS_PRIVATE uint8*  itrp_DeltaEngine (GSP uint8 *pbyInst, FntMoveFunc doIt, int16 sBase, int16 sShift)
{
	int32 iRange;
	int32 iAim;
	int32 iHigh;
	int32 iFakePPEM;
	int32 iPPEM;
	F26Dot6 fxDelta;

		/* Find the beginning of data pairs for this particular size */
    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, 1);
	iHigh = CHECK_POP (LocalGS.stackPointer) << 1;
    SECURE_CHECK_FOR_POP (LocalGS.stackPointer, iHigh);
	LocalGS.stackPointer -= iHigh;              /* -= number of pops required */
	CHECK_STACK (&LocalGS);

	iRange = LocalGS.globalGS->pixelsPerEm;     /* same as itrp_MPPEM () */
	if (!LocalGS.globalGS->bSameStretch)
		iRange = (int32)FixMul(iRange, itrp_GetCVTScale (GSA0));
	iFakePPEM = iRange - (int32)sBase;

	if ((iFakePPEM >= 16) || (iFakePPEM < 0))
	{
		return pbyInst;                                 /* Not within exception range */
	}
	iFakePPEM = iFakePPEM << 4;

	iAim = 0;
	iRange = iHigh >> 1; 
	iRange &= ~1;
	while (iRange > 2)                          /* binary search for first data */
	{
		iPPEM = LocalGS.stackPointer[ iAim + iRange ]; /* [ iPPEM << 4 | exception ] */
		if ((iPPEM & ~0x0f) < iFakePPEM) 
		{
			iAim += iRange;                     /* approach the starting point */
		}
		iRange >>= 1; 
		iRange &= ~1;                           /* iRange must stay even */
	}

	while (iAim < iHigh) 
	{
		iPPEM = LocalGS.stackPointer[ iAim ];   /* [ iPPEM << 4 | exception ] */
		fxDelta = iPPEM & ~0x0f;
		if (fxDelta == iFakePPEM)
		{                                       /* We found an exception, go ahead and apply it */
			fxDelta = iPPEM & 0xf;              /* 0 ... 15 */
			fxDelta -= fxDelta >= 8 ? 7 : 8;    /* -8 ... -1, 1 ... 8 */
			fxDelta <<= FNT_PIXELSHIFT;        /* convert to pixels */
			fxDelta >>= sShift;                 /* scale to right size */
            
#ifdef FSCFG_SECURE
            if (doIt == LocalGS.MovePoint)
            {
                SECURE_CHECK_POINT(LocalGS.CE0,(int32)LocalGS.stackPointer[iAim+1]);
            } else
			{
				FS_ASSERT( (doIt == LocalGS.ChangeCvt), "itrp_DeltaEngine called with wrong doIt.")
                SECURE_CHECK_CVT((int32)LocalGS.stackPointer[iAim+1]);
			}
#endif
#ifdef FSCFG_SUBPIXEL
#ifdef InlineDeltasOnly
		// similar to itrp_SHP_Common above
		// main difference: we don't distinguish between SHPIX and SHP, but between CVT deltas and ordinary deltas
			if (doIt == LocalGS.ChangeCvt || !RunningSubPixel(LocalGS.globalGS) || Tuned4SubPixel(LocalGS.globalGS) || AMovedPointInNonSPDirection(LocalGS,CE0,(int16)LocalGS.stackPointer[iAim+1]))
#endif
#endif
				doIt (GSA LocalGS.CE0, (int32)LocalGS.stackPointer[iAim+1], (F26Dot6) fxDelta);
		} 
		else if (fxDelta > iFakePPEM)
		{
			break;                              /* we passed the data */
		}
		iAim += 2;
	}
    return pbyInst;
}

/**************************************************************************/

/*
 * DELTAP1
 */
  FS_PRIVATE uint8* itrp_DELTAP1 (IPARAM)
  {
	fnt_ParameterBlock *pb;

	FS_UNUSED_PARAMETER(lOpCode);

	pb = &LocalGS.globalGS->localParBlock;
	return itrp_DeltaEngine (GSA pbyInst, LocalGS.MovePoint, pb->deltaBase, pb->deltaShift);
  }

/*
 * DELTAP2
 */
  FS_PRIVATE uint8* itrp_DELTAP2 (IPARAM)
  {
	fnt_ParameterBlock *pb;
	int16 sBase;

	FS_UNUSED_PARAMETER(lOpCode);

	pb = &LocalGS.globalGS->localParBlock;
	sBase = (int16)(pb->deltaBase + 16);
	return itrp_DeltaEngine (GSA pbyInst, LocalGS.MovePoint, sBase, pb->deltaShift);
  }

/*
 * DELTAP3
 */
  FS_PRIVATE uint8* itrp_DELTAP3 (IPARAM)
  {
	fnt_ParameterBlock *pb;
	int16 sBase;

	FS_UNUSED_PARAMETER(lOpCode);

	pb = &LocalGS.globalGS->localParBlock;
	sBase = (int16)(pb->deltaBase + 32);
	return itrp_DeltaEngine (GSA pbyInst, LocalGS.MovePoint, sBase, pb->deltaShift);
  }

/*
 * DELTAC1
 */
  FS_PRIVATE uint8* itrp_DELTAC1 (IPARAM)
  {
	fnt_ParameterBlock *pb;

	FS_UNUSED_PARAMETER(lOpCode);

	pb = &LocalGS.globalGS->localParBlock;
	return itrp_DeltaEngine (GSA pbyInst, LocalGS.ChangeCvt, pb->deltaBase, pb->deltaShift);
  }

/*
 * DELTAC2
 */
  FS_PRIVATE uint8* itrp_DELTAC2 (IPARAM)
  {
	fnt_ParameterBlock *pb;
	int16 sBase;

	FS_UNUSED_PARAMETER(lOpCode);

	pb = &LocalGS.globalGS->localParBlock;
	sBase = (int16)(pb->deltaBase + 16);
	return itrp_DeltaEngine (GSA pbyInst, LocalGS.ChangeCvt, sBase, pb->deltaShift);
  }

/*
 * DELTAC3
 */
  FS_PRIVATE uint8* itrp_DELTAC3 (IPARAM)
  {
	fnt_ParameterBlock *pb;
	int16 sBase;

	FS_UNUSED_PARAMETER(lOpCode);

	pb = &LocalGS.globalGS->localParBlock;
	sBase = (int16)(pb->deltaBase + 32);
	return itrp_DeltaEngine (GSA pbyInst, LocalGS.ChangeCvt, sBase, pb->deltaShift);
  }


#ifdef FSCFG_NO_INITIALIZED_DATA
	
	void itrp_InitializeData (void)
	{
		int32 i;

		/***** 0x00 - 0x0f *****/
		function[0x00] = itrp_SVTCA_0;
		function[0x01] = itrp_SVTCA_1;
		function[0x02] = itrp_SPVTCA_0;
		function[0x03] = itrp_SPVTCA_1;
		function[0x04] = itrp_SFVTCA_0;
		function[0x05] = itrp_SFVTCA_1;
		function[0x06] = itrp_SPVTL;
		function[0x07] = itrp_SPVTL;
		function[0x08] = itrp_SFVTL;
		function[0x09] = itrp_SFVTL;
		function[0x0A] = itrp_WPV;
		function[0x0B] = itrp_WFV;
		function[0x0C] = itrp_RPV;
		function[0x0D] = itrp_RFV;
		function[0x0E] = itrp_SFVTPV;
		function[0x0F] = itrp_ISECT;

		/***** 0x10 - 0x1f *****/
		function[0x10] = itrp_SRP0;
		function[0x11] = itrp_SRP1;
		function[0x12] = itrp_SRP2;
		function[0x13] = itrp_SetElementPtr;
		function[0x14] = itrp_SetElementPtr;
		function[0x15] = itrp_SetElementPtr;
		function[0x16] = itrp_SetElementPtr;
		function[0x17] = itrp_LLOOP;
		function[0x18] = itrp_RTG;
		function[0x19] = itrp_RTHG;
		function[0x1A] = itrp_LMD;
		function[0x1B] = itrp_ELSE;
		function[0x1C] = itrp_JMPR;
		function[0x1D] = itrp_LWTCI;
		function[0x1E] = itrp_LSWCI;
		function[0x1F] = itrp_LSW;

		/***** 0x20 - 0x2f *****/
		function[0x20] = itrp_DUP;
		function[0x21] = itrp_POP;
		function[0x22] = itrp_CLEAR;
		function[0x23] = itrp_SWAP;
		function[0x24] = itrp_DEPTH;
		function[0x25] = itrp_CINDEX;
		function[0x26] = itrp_MINDEX;
		function[0x27] = itrp_ALIGNPTS;
		function[0x28] = itrp_RAW;
		function[0x29] = itrp_UTP;
		function[0x2A] = itrp_LOOPCALL;
		function[0x2B] = itrp_CALL;
		function[0x2C] = itrp_FDEF;
		function[0x2D] = itrp_IllegalInstruction;
		function[0x2E] = itrp_MDAP;
		function[0x2F] = itrp_MDAP;

		/***** 0x30 - 0x3f *****/
		function[0x30] = itrp_IUP;
		function[0x31] = itrp_IUP;
		function[0x32] = itrp_SHP;
		function[0x33] = itrp_SHP;
		function[0x34] = itrp_SHC;
		function[0x35] = itrp_SHC;
		function[0x36] = itrp_SHE;
		function[0x37] = itrp_SHE;
		function[0x38] = itrp_SHPIX;
		function[0x39] = itrp_IP;
		function[0x3A] = itrp_MSIRP;
		function[0x3B] = itrp_MSIRP;
		function[0x3C] = itrp_ALIGNRP;
		function[0x3D] = itrp_RTDG;
		function[0x3E] = itrp_MIAP;
		function[0x3F] = itrp_MIAP;

		/***** 0x40 - 0x4f *****/
		function[0x40] = itrp_NPUSHB;
		function[0x41] = itrp_NPUSHW;
		function[0x42] = itrp_WS;
		function[0x43] = itrp_RS;
		function[0x44] = itrp_WCVT;
		function[0x45] = itrp_RCVT;
		function[0x46] = itrp_RC;
		function[0x47] = itrp_RC;
		function[0x48] = itrp_WC;
		function[0x49] = itrp_MD;
		function[0x4A] = itrp_MD;
		function[0x4B] = itrp_MPPEM;
		function[0x4C] = itrp_MPS;
		function[0x4D] = itrp_FLIPON;
		function[0x4E] = itrp_FLIPOFF;
		function[0x4F] = itrp_DEBUG;

		/***** 0x50 - 0x5f *****/
		function[0x50] = itrp_LT;
		function[0x51] = itrp_LTEQ;
		function[0x52] = itrp_GT;
		function[0x53] = itrp_GTEQ;
		function[0x54] = itrp_EQ;
		function[0x55] = itrp_NEQ;
		function[0x56] = itrp_ODD;
		function[0x57] = itrp_EVEN;
		function[0x58] = itrp_IF;
		function[0x59] = itrp_EIF;
		function[0x5A] = itrp_AND;
		function[0x5B] = itrp_OR;
		function[0x5C] = itrp_NOT;
		function[0x5D] = itrp_DELTAP1;
		function[0x5E] = itrp_SDB;
		function[0x5F] = itrp_SDS;

		/***** 0x60 - 0x6f *****/
		function[0x60] = itrp_ADD;
		function[0x61] = itrp_SUB;
		function[0x62] = itrp_DIV;
		function[0x63] = itrp_MUL;
		function[0x64] = itrp_ABS;
		function[0x65] = itrp_NEG;
		function[0x66] = itrp_FLOOR;
		function[0x67] = itrp_CEILING;
		function[0x68] = itrp_ROUND;
		function[0x69] = itrp_ROUND;
		function[0x6A] = itrp_ROUND;
		function[0x6B] = itrp_ROUND;
		function[0x6C] = itrp_NROUND;
		function[0x6D] = itrp_NROUND;
		function[0x6E] = itrp_NROUND;
		function[0x6F] = itrp_NROUND;

		/***** 0x70 - 0x7f *****/
		function[0x70] = itrp_WCVTFOD;
		function[0x71] = itrp_DELTAP2;
		function[0x72] = itrp_DELTAP3;
		function[0x73] = itrp_DELTAC1;
		function[0x74] = itrp_DELTAC2;
		function[0x75] = itrp_DELTAC3;
		function[0x76] = itrp_SROUND;
		function[0x77] = itrp_S45ROUND;
		function[0x78] = itrp_JROT;
		function[0x79] = itrp_JROF;
		function[0x7A] = itrp_ROFF;
		function[0x7B] = itrp_IllegalInstruction;
		function[0x7C] = itrp_RUTG;
		function[0x7D] = itrp_RDTG;
		function[0x7E] = itrp_SANGW;
		function[0x7F] = itrp_AA;

		/***** 0x80 - 0x8d *****/
		function[0x80] = itrp_FLIPPT;
		function[0x81] = itrp_FLIPRGON;
		function[0x82] = itrp_FLIPRGOFF;
		function[0x83] = itrp_IDefPatch;
		function[0x84] = itrp_IDefPatch;
		function[0x85] = itrp_SCANCTRL;
		function[0x86] = itrp_SDPVTL;
		function[0x87] = itrp_SDPVTL;
		function[0x88] = itrp_GETINFO;
		function[0x89] = itrp_IDEF;
		function[0x8A] = itrp_ROTATE;
		function[0x8B] = itrp_MAX;
		function[0x8C] = itrp_MIN;
		function[0x8D] = itrp_SCANTYPE;
		function[0x8E] = itrp_INSTCTRL;

		/***** 0x8f - 0xaf *****/
		for ( i = 0x8F; i <= 0xAF;  ++i )
			function[i] = itrp_IDefPatch;

		/***** 0xb0 - 0xb7 *****/
		function[0xB0] = itrp_PUSHB1;
		function[0xB1] = itrp_PUSHB;
		function[0xB2] = itrp_PUSHB;
		function[0xB3] = itrp_PUSHB;
		function[0xB4] = itrp_PUSHB;
		function[0xB5] = itrp_PUSHB;
		function[0xB6] = itrp_PUSHB;
		function[0xB7] = itrp_PUSHB;

		/***** 0xb8 - 0xbf *****/
		function[0xB8] = itrp_PUSHW1;
		function[0xB9] = itrp_PUSHW;
		function[0xBA] = itrp_PUSHW;
		function[0xBB] = itrp_PUSHW;
		function[0xBC] = itrp_PUSHW;
		function[0xBD] = itrp_PUSHW;
		function[0xBE] = itrp_PUSHW;
		function[0xBF] = itrp_PUSHW;

		/***** 0xc0 - 0xdf *****/
		for ( i = 0xC0; i <= 0xDF;  i++ )
			function[i] = itrp_MDRP;

		/***** 0xe0 - 0xff *****/
		for ( i = 0xE0; i <= 0xFF;  i++ )
			function[i] = itrp_MIRP;
		
#ifdef FSCFG_SUBPIXEL
		// initialize round function table for SP
		itrp_RoundFunction[0][0] = itrp_RoundToDoubleGrid;
		itrp_RoundFunction[0][1] = itrp_RoundDownToGrid;
		itrp_RoundFunction[0][2] = itrp_RoundUpToGrid;
		itrp_RoundFunction[0][3] = itrp_RoundToGrid;
		itrp_RoundFunction[0][4] = itrp_RoundToHalfGrid;
		itrp_RoundFunction[0][5] = itrp_RoundOff;
		itrp_RoundFunction[0][6] = itrp_SuperRound;
		itrp_RoundFunction[0][7] = itrp_Super45Round;
		itrp_RoundFunction[1][0] = itrp_RoundToDoubleGridSP;
		itrp_RoundFunction[1][1] = itrp_RoundDownToGridSP;
		itrp_RoundFunction[1][2] = itrp_RoundUpToGridSP;
		itrp_RoundFunction[1][3] = itrp_RoundToGridSP;
		itrp_RoundFunction[1][4] = itrp_RoundToHalfGridSP;
		itrp_RoundFunction[1][5] = itrp_RoundOffSP;
		itrp_RoundFunction[1][6] = itrp_SuperRound;
		itrp_RoundFunction[1][7] = itrp_Super45Round;
#endif
	}

#endif /* FSCFG_NO_INITIALIZED_DATA */

/* END OF interp.c */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\fs\scanlist.c ===
/*********************************************************************

	  scanlist.c -- New Scan Converter ScanList Module

	  (c) Copyright 1992  Microsoft Corp.  All rights reserved.

	   8/23/93  deanb   gray scale pass through functions
	   6/22/93  deanb   all dropouts confined to bounding box
	   6/10/93  deanb   fsc_InitializeScanlist added, stdio & assert gone
	   4/26/93  deanb   fix pointers now works with segmented memory
	   4/19/93  deanb   banding added
	   4/07/93  deanb   sorting is now done on the fly
	   4/01/93  deanb   intersection arrays replace linked lists
	   3/19/93  deanb   size_t replaced with int32
	  12/22/92  deanb   Rectangle -> Rect
	  10/28/92  deanb   memory requirements reworked
	  10/19/92  deanb   smart dropout tiebreak left & down
	  10/14/92  deanb   delete usScanKind from state
	  10/09/92  deanb   reentrant
	  10/08/92  deanb   reworked for split workspace
	  10/02/92  deanb   correct AddVertDropoutScan assertions
	   9/25/92  deanb   separate nodrop/dropout entry points
	   9/22/92  deanb   smart dropout control
	   9/17/92  deanb   stub control
	   9/15/92  deanb   simple dropout control
	   9/11/92  deanb   setupscan handles scankind
	   9/09/92  deanb   dropout / nodropout begun
	   8/17/92  deanb   include struc.h scconst.h
	   8/07/92  deanb   initial dropout control
	   8/06/92  deanb   assertions reinstated
	   7/27/92  deanb   bitmap clear added
	   7/16/92  deanb   gulBytesRemaining -> gulIntersectRemaining
	   6/18/92  deanb   int x coord for HorizScanAdd
	   6/01/92  deanb   incorporate bitmap functions
	   5/08/92  deanb   reordered includes for precompiled headers
	   5/04/92  deanb   Array tags added
	   4/28/92  deanb   list array sentinels added
	   4/21/92  deanb   single HorizScanAdd routine
	   4/15/92  deanb   calls to BitMap
	   4/13/92  deanb   uiY to iY for HorizScanOn/Off
	   4/09/92  deanb   New types
	   4/03/92  deanb   HorizScan On/Off coded
	   3/31/92  deanb   InitScanArray begun
	   3/25/92  deanb   GetWorkSizes and local types
	   3/23/92  deanb   First cut

**********************************************************************/

/*********************************************************************/

/*      Imports                                                      */

/*********************************************************************/

#define FSCFG_INTERNAL

#include    "fscdefs.h"             /* shared data types */
#include    "fserror.h"             /* error codes */

#include    "scglobal.h"            /* structures & constants */
#include    "scgray.h"              /* gray scale param block */
#include    "scbitmap.h"            /* bit blt operations */
#include    "scmemory.h"            /* for allocations */

/*********************************************************************/

/*      Contour reversal list structures                             */

/*********************************************************************/

typedef struct Rev                  /* Reversal list entry */
{
	int16 sScan;                    /* scan line */
	int16 sCross;                   /* direction +1 or -1 */
	struct Rev *prevLink;           /* link to next reversal */
}
Reversal;

struct RevRoots                     /* Reversal list roots */
{
	Reversal *prevYRoot;            /* Y direction contour reversals */
	Reversal *prevXRoot;            /* X direction contour reversals */
	Reversal *prevNext;             /* Next available list item */
	Reversal *prevEnd;              /* End of buffer (for overflow check) */
	struct RevRoots *prrSelf;       /* to check for moved memory */
};

#include    "scanlist.h"            /* for own function prototypes */

/*********************************************************************/

/*      Local Prototypes                                             */

/*********************************************************************/

FS_PRIVATE void AddReversal (Reversal**, Reversal*, F26Dot6, int16);
FS_PRIVATE int32 GetIxEstimate(Reversal*);
FS_PRIVATE void FixPointers(PRevRoot);

FS_PRIVATE void AddHorizSimpleScan(PSTATE int32, int32);
FS_PRIVATE void AddVertSimpleScan(PSTATE int32, int32);
FS_PRIVATE void AddHorizSmartScan(PSTATE int32, int32);
FS_PRIVATE void AddVertSmartScan(PSTATE int32, int32);
FS_PRIVATE void AddHorizSimpleBand(PSTATE int32, int32);
FS_PRIVATE void AddHorizSmartBand(PSTATE int32, int32);

FS_PRIVATE int32 LookForDropouts(PSTATE char*, uint16);
FS_PRIVATE int32 DoHorizDropout(PSTATE int16*, int16*, int32, char*, uint16);
FS_PRIVATE int32 DoVertDropout(PSTATE int16*, int16*, int32, char*, uint16);

FS_PRIVATE int32 HorizCrossings(PSTATE int32, int32);
FS_PRIVATE int32 VertCrossings(PSTATE int32, int32);

FS_PRIVATE uint32 GetBitAbs(PSTATE char*, int32, int32);
FS_PRIVATE int32 SetBitAbs(PSTATE char*, int32, int32);


/*********************************************************************/

/*      Initialization Functions                                     */

/*********************************************************************/

FS_PUBLIC void fsc_InitializeScanlist()
{
	fsc_InitializeBitMasks();
}


/*********************************************************************/

/*      Contour Reversal Functions                                   */

/*********************************************************************/

/* setup the contour reversal list roots structure */

FS_PUBLIC PRevRoot  fsc_SetupRevRoots (
		char* pchRevBuf,
		int32 lRevBufSize )
{
	PRevRoot prrRoots;
	Reversal *prevSentinel;
	
	prrRoots = (PRevRoot) pchRevBuf;                /* workspace begin */
	prevSentinel = (Reversal*) (prrRoots + 1);      /* just past the roots */

	prrRoots->prevYRoot = prevSentinel;             /* point to sentinel */
	prrRoots->prevXRoot = prevSentinel;             /* for both lists */
	prevSentinel->sScan = HUGEINT;                  /* stop value */
	prevSentinel->sCross = 0;
	prevSentinel->prevLink = NULL;
	prrRoots->prevNext = prevSentinel + 1;          /* to next free record */
	
	prrRoots->prevEnd = (Reversal*)(pchRevBuf + lRevBufSize);
	prrRoots->prrSelf = prrRoots;                   /* for address validation */
	
	return prrRoots;
}

/*********************************************************************/

/* insert into y list one countour reversal structure */

FS_PUBLIC void fsc_AddYReversal (
		PRevRoot prrRoots,
		F26Dot6 fxCoord,
		int16 sDir )
{
	AddReversal(&(prrRoots->prevYRoot), prrRoots->prevNext, fxCoord, sDir);

	(prrRoots->prevNext)++;                     /* to next free memory */

	Assert(prrRoots->prevNext <= prrRoots->prevEnd);
}

/*********************************************************************/

/* insert into x list one countour reversal structure */

FS_PUBLIC void fsc_AddXReversal (
		PRevRoot prrRoots,
		F26Dot6 fxCoord,
		int16 sDir )
{
	AddReversal(&(prrRoots->prevXRoot), prrRoots->prevNext, fxCoord, sDir);

	(prrRoots->prevNext)++;                     /* to next free memory */

	Assert(prrRoots->prevNext <= prrRoots->prevEnd);
}

/*********************************************************************/

/* insert into x or y list one countour reversal structure */

FS_PRIVATE void AddReversal (
		Reversal **pprevList,
		Reversal *prevNext,
		F26Dot6 fxCoord,
		int16 sDir )
{
	int16 sScan;

	sScan = (int16)((fxCoord + SUBHALF + (sDir >> 1)) >> SUBSHFT);

	while(sScan > (*pprevList)->sScan)          /* will stop before sentinel */
	{
		pprevList = &((*pprevList)->prevLink);  /* else link to next */
	}
	prevNext->sScan = sScan;                    /* save scanline */
	prevNext->sCross = -sDir;                   /* count up from bottom */
	prevNext->prevLink = *pprevList;            /* link rest of list */

	*pprevList = prevNext;                      /* insert new item */
}

/*********************************************************************/

/* return the total number of reversals in the lists */

FS_PUBLIC int32 fsc_GetReversalCount (PRevRoot prrRoots)
{
	return (int32)(( prrRoots->prevNext - 1 -           /* don't count sentinel */
			 (Reversal*)((char*)prrRoots + sizeof(struct RevRoots))) );
}

/*********************************************************************/

/* calculate anticipated horizontal intersections */

FS_PUBLIC int32 fsc_GetHIxEstimate(PRevRoot prrRoots)
{
	if (prrRoots != prrRoots->prrSelf)          /* if reversals have moved */
	{
		FixPointers(prrRoots);                  /* then patch up the pointers */
	}
	return ( GetIxEstimate( prrRoots->prevYRoot ) );
}

/*********************************************************************/

/* calculate anticipated vertical intersections */

FS_PUBLIC int32 fsc_GetVIxEstimate(PRevRoot prrRoots)
{
	if (prrRoots != prrRoots->prrSelf)          /* if reversals have moved */
	{
		FixPointers(prrRoots);                  /* then patch up the pointers */
	}
	return ( GetIxEstimate( prrRoots->prevXRoot ) );
}

/*********************************************************************/

/* calculate anticipated intersections */

FS_PRIVATE int32 GetIxEstimate(Reversal *prevList)
{
	int32 lTotalIx;
	
	lTotalIx = 0L;
	while (prevList->sScan < HUGEINT)       /* look through list */
	{
		if (prevList->sCross == 1)          /* adding up columns! */
		{
			lTotalIx -= (int32)prevList->sScan;
		}
		else
		{
			lTotalIx += (int32)prevList->sScan;
		}
		prevList = prevList->prevLink;
	}
	return(lTotalIx);
}

/*********************************************************************/

/* calculate horizontal intersections for banding */

FS_PUBLIC int32 fsc_GetHIxBandEst(
		PRevRoot prrRoots,
		Rect* prectBox,
		  int32 lBandWidth
)
{
	Reversal *prevHiList;               /* high band reversal pointer */
	Reversal *prevLoList;               /* low band reversal pointer */
	int16 sHiScan;                      /* current top of band */
	int16 sLoScan;                      /* current bottom of band */
	int16 sHiCross;                     /* top of band's crossings */
	int16 sLoCross;                     /* bottom of band's crossings*/
	int32 lTotalIx;                     /* intersection count for each band */
	int32 lBiggestIx;                   /* largest intersection count */

	if (prrRoots != prrRoots->prrSelf)          /* if reversals have moved */
	{
		FixPointers(prrRoots);                  /* then patch up the pointers */
	}
	lTotalIx = 0;
	prevHiList = prrRoots->prevYRoot;
	sHiScan = prectBox->bottom;
	sHiCross = 0;
	while (lBandWidth > 0)
	{
		while (prevHiList->sScan <= sHiScan)
		{
			sHiCross += prevHiList->sCross;     /* add in this line's crossings */
			prevHiList = prevHiList->prevLink;  /* link to next reversal */
		}
		lTotalIx += (int32)sHiCross;            /* add up first band's crossings */
		sHiScan++;
		lBandWidth--;
	}
	lBiggestIx = lTotalIx;

	prevLoList = prrRoots->prevYRoot;
	sLoScan = prectBox->bottom;
	sLoCross = 0;
	while (sHiScan < prectBox->top)
	{
		while (prevHiList->sScan <= sHiScan)
		{
			sHiCross += prevHiList->sCross;     /* add in high line's crossings */
			prevHiList = prevHiList->prevLink;  /* link to next reversal */
		}
		while (prevLoList->sScan <= sLoScan)
		{
			sLoCross += prevLoList->sCross;     /* add in low line's crossings */
			prevLoList = prevLoList->prevLink;  /* link to next reversal */
		}
		lTotalIx += (int32)(sHiCross - sLoCross);
		if (lTotalIx > lBiggestIx)
		{
			lBiggestIx = lTotalIx;              /* save the largest value */
		}
		sHiScan++;
		sLoScan++;
	}
	return(lBiggestIx);
}

/*********************************************************************/

/*      return number of bytes used by reversal lists                */

FS_PUBLIC int32 fsc_GetRevMemSize(PRevRoot prrRoots)
{
	return (int32)((char*)(prrRoots->prevNext) - (char*)prrRoots);
}

/*********************************************************************/

/*  when reversal list has moved, recalculate the pointers           */

FS_PRIVATE void FixPointers(PRevRoot prrRoots)
{
	char *pchNewBase;
	char *pchOldBase;
	Reversal *prevList;

	pchNewBase = (char*)prrRoots;
	pchOldBase = (char*)prrRoots->prrSelf;          /* pre-move base addr */

	prrRoots->prevYRoot = (Reversal*)(pchNewBase + ((char*)prrRoots->prevYRoot - pchOldBase));
	prrRoots->prevXRoot = (Reversal*)(pchNewBase + ((char*)prrRoots->prevXRoot - pchOldBase));
	prrRoots->prevNext = (Reversal*)(pchNewBase + ((char*)prrRoots->prevNext - pchOldBase));
	prrRoots->prevEnd = (Reversal*)(pchNewBase + ((char*)prrRoots->prevEnd - pchOldBase));
	
	prevList = prrRoots->prevYRoot;
	while(prevList->sScan < HUGEINT)                /* from root to sentinel */
	{
		prevList->prevLink = (Reversal*)(pchNewBase + ((char*)prevList->prevLink - pchOldBase));
		prevList = prevList->prevLink;
	}
	
	prevList = prrRoots->prevXRoot;
	while(prevList->sScan < HUGEINT)                /* from root to sentinel */
	{
		prevList->prevLink = (Reversal*)(pchNewBase + ((char*)prevList->prevLink - pchOldBase));
		prevList = prevList->prevLink;
	}
	
	prrRoots->prrSelf = prrRoots;                   /* for next time */
}

/*********************************************************************/

/*      Workspace Calcluation Functions                              */

/*********************************************************************/

/* calculate horizontal scan workspace memory requirements */

FS_PUBLIC int32 fsc_GetScanHMem(
		uint16 usScanKind,      /* scan type */
		int32 lHScan,           /* number of horiz scanlines */
		int32 lHInter )         /* number of horiz intersections */
{
	ALIGN(voidPtr, lHScan); 
	ALIGN(voidPtr, lHInter ); 
	if (!(usScanKind & SK_SMART))       /* if simple dropout */
	{
		return (lHScan * (4 * sizeof(int16*)) +     /* for on/off begin/end */
				lHInter * (2 * sizeof(int16)));     /* for intersection arrays */
	}
	else                                /* if smart dropout */
	{
		return (lHScan * (4 * sizeof(int16*)) +     /* for on/off begin/end */
				lHInter * (4 * sizeof(int16)));     /* for ix/code arrays */
	}
}


/*********************************************************************/

/* calculate vertical scan workspace memory requirements */

FS_PUBLIC int32 fsc_GetScanVMem(
		uint16 usScanKind,      /* scan type */
		int32 lVScan,           /* number of vert scanlines */
		int32 lVInter,          /* number of vert intersections */
		int32 lElemPts )        /* number of contour element points */
{
	ALIGN(voidPtr, lVScan); 
	ALIGN(voidPtr, lVInter); 
	ALIGN(voidPtr, lElemPts ); 
	if (!(usScanKind & SK_SMART))       /* if simple dropout */
	{
		return (lVScan * (4 * sizeof(int16*)) +     /* for on/off begin/end */
				lVInter * (2 * sizeof(int16)));     /* for intersection arrays */
	}
	else                                /* if smart dropout */
	{
		return (lVScan * (4 * sizeof(int16*)) +     /* for on/off begin/end */
				lVInter * (4 * sizeof(int16)) +     /* for ix/code arrays */
				lElemPts * (2 * sizeof(F26Dot6)));  /* for element (x, y) */
	}
}

/*********************************************************************/

/*      Scan Conversion Preparation Functions                        */

/*********************************************************************/

/*  Line, Spline, and Endpoint register their callbacks here */

FS_PUBLIC void fsc_SetupCallBacks(
		PSTATE                       /* pointer to state variables */
		int16 sCode,                 /* element code (line, spline, endpoint) */
		F26Dot6 (*pfnHoriz)(int32, F26Dot6*, F26Dot6*),   /* horiz callback */
		F26Dot6 (*pfnVert)(int32, F26Dot6*, F26Dot6*)     /* vert callback */
)
{
	STATE.pfnHCallBack[sCode] = pfnHoriz;
	STATE.pfnVCallBack[sCode] = pfnVert;
}


/*********************************************************************/

/*  Allocate scan workspace memory and set up pointer arrays */

FS_PUBLIC int32 fsc_SetupScan(
		PSTATE                      /* pointer to state variables */
		Rect* prectBox,             /* bounding box */
		uint16 usScanKind,          /* dropout control value */
		int32 lHiBand,              /* top scan limit */
		int32 lLoBand,              /* bottom scan limit */
		boolean bSaveRow,           /* save last bitmap row for dropout */
		int32 lRowBytes,            /* for last row alloc */
		int32 lHInterCount,         /* estimate of horiz intersections */
		int32 lVInterCount,         /* estimate of vert intersections */
		int32 lElemCount,           /* estimate of element points */
		PRevRoot prrRoots           /* reversal list roots */
)
{
	int32 lHorizBandCount;          /* number of horizontal scan lines */
	int32 lVertScanCount;           /* number of vertical scan lines */
	int32 lPointerArraySize;        /* bytes per pointer array */

	int16 sScan;                    /* current scan line */
	int16 sCross;                   /* crossings on this line */
	int16 *psScanIx;                /* temp scan intersection array */
	Reversal *prevList;             /* pointer to reversal list */
	
	int16 **ppsHOnBegin;            /* for init speed */
	int16 **ppsHOnEnd;
	int16 **ppsHOffBegin;
	int16 **ppsHOffEnd;
	int16 **ppsVOnBegin;            /* for init speed */
	int16 **ppsVOnEnd;
	int16 **ppsVOffBegin;
	int16 **ppsVOffEnd;


	STATE.lBoxTop = (int32)prectBox->top;   /* copy the bounding box */
	STATE.lBoxBottom = (int32)prectBox->bottom;
	STATE.lBoxLeft = (int32)prectBox->left;
	STATE.lBoxRight = (int32)prectBox->right;
	
	STATE.lHiScanBand = lHiBand;    /* copy scan band limits */
	STATE.lLoScanBand = lLoBand;
	
/*  set STATE according to dropout and banding requirements */

	if ((usScanKind & SK_NODROPOUT) || !(usScanKind & SK_SMART))
	{
		STATE.sIxSize = 1;          /* one int16 per intersection */
		STATE.sIxShift = 0;         /* log2 of size */

		if ((STATE.lHiScanBand == STATE.lBoxTop) && (STATE.lLoScanBand == STATE.lBoxBottom))
		{
			STATE.pfnAddHoriz = AddHorizSimpleScan;
		}
		else    /* if banding */
		{
			STATE.pfnAddHoriz = AddHorizSimpleBand;
		}
		STATE.pfnAddVert = AddVertSimpleScan;
	}
	else        /* if smart dropout */
	{
		STATE.sIxSize = 2;          /* two int16's per intersection */
		STATE.sIxShift = 1;         /* log2 of size */

		if ((STATE.lHiScanBand == STATE.lBoxTop) && (STATE.lLoScanBand == STATE.lBoxBottom))
		{
			STATE.pfnAddHoriz = AddHorizSmartScan;
		}
		else    /* if banding */
		{
			STATE.pfnAddHoriz = AddHorizSmartBand;
		}
		STATE.pfnAddVert = AddVertSmartScan;
	}

/* setup horizontal intersection array for all cases */
	
	lHorizBandCount = STATE.lHiScanBand - STATE.lLoScanBand;
	Assert(lHorizBandCount > 0);
	
	lPointerArraySize = lHorizBandCount * sizeof(int16*);
	STATE.apsHOnBegin = (int16**) fsc_AllocHMem(ASTATE lPointerArraySize);
	STATE.apsHOffBegin = (int16**) fsc_AllocHMem(ASTATE lPointerArraySize);
	STATE.apsHOnEnd = (int16**) fsc_AllocHMem(ASTATE lPointerArraySize);
	STATE.apsHOffEnd = (int16**) fsc_AllocHMem(ASTATE lPointerArraySize);
	
	STATE.lPoint = 0L;                      /* initial element index */
	STATE.lElementPoints = lElemCount;

	psScanIx = (int16*) fsc_AllocHMem(ASTATE lHInterCount << (STATE.sIxShift + 2));
			
	if (prrRoots != prrRoots->prrSelf)      /* if reversals have moved */
	{
		FixPointers(prrRoots);              /* then patch up the pointers */
	}
	prevList = prrRoots->prevYRoot;         /* root of y list reversals */
	sCross = 0;
	
	ppsHOnBegin = STATE.apsHOnBegin;        /* for init speed */
	ppsHOnEnd = STATE.apsHOnEnd;
	ppsHOffBegin = STATE.apsHOffBegin;
	ppsHOffEnd = STATE.apsHOffEnd;

/* initialize horizontal scan arrays */
	
	for (sScan = (int16)STATE.lLoScanBand; sScan < (int16)STATE.lHiScanBand; sScan++)
	{
		while (prevList->sScan <= sScan)
		{
			sCross += (prevList->sCross << STATE.sIxShift); /* add in this line's crossings */
			prevList = prevList->prevLink;                  /* link to next reversal */
		}
		*ppsHOnBegin = psScanIx;
		ppsHOnBegin++;
		*ppsHOnEnd = psScanIx;
		ppsHOnEnd++;
		psScanIx += sCross;
				
		*ppsHOffBegin = psScanIx;
		ppsHOffBegin++;
		*ppsHOffEnd = psScanIx;
		ppsHOffEnd++;
		psScanIx += sCross;
	}
	
/* if doing dropout control, setup X intersection array */

	if (!(usScanKind & SK_NODROPOUT))           /* if any kind of dropout */
	{
		lVertScanCount = (int32)(prectBox->right - prectBox->left);
		Assert(lVertScanCount > 0);

		lPointerArraySize = lVertScanCount * sizeof(int16*);
		STATE.apsVOnBegin = (int16**) fsc_AllocVMem(ASTATE lPointerArraySize);
		STATE.apsVOffBegin = (int16**) fsc_AllocVMem(ASTATE lPointerArraySize);
		STATE.apsVOnEnd = (int16**) fsc_AllocVMem(ASTATE lPointerArraySize);
		STATE.apsVOffEnd = (int16**) fsc_AllocVMem(ASTATE lPointerArraySize);

		if (bSaveRow)                           /* if fast banding & dropout */
		{
			STATE.pulLastRow = (uint32*) fsc_AllocVMem(ASTATE lRowBytes);
			STATE.lLastRowIndex = HUGEFIX;      /* impossible value => uninitialized */
		}
		psScanIx = (int16*) fsc_AllocVMem(ASTATE lVInterCount << (STATE.sIxShift + 2));
				
		prevList = prrRoots->prevXRoot;         /* root of x list reversals */
		sCross = 0;
		sScan = prectBox->left;
	
		ppsVOnBegin = STATE.apsVOnBegin;        /* for init speed */
		ppsVOnEnd = STATE.apsVOnEnd;
		ppsVOffBegin = STATE.apsVOffBegin;
		ppsVOffEnd = STATE.apsVOffEnd;
	
		for (sScan = prectBox->left; sScan < prectBox->right; sScan++)
		{
			while (prevList->sScan <= sScan)
			{
				sCross += (prevList->sCross << STATE.sIxShift); /* add in this line's crossings */
				prevList = prevList->prevLink;                  /* link to next reversal */
			}
			*ppsVOnBegin = psScanIx;
			ppsVOnBegin++;
			*ppsVOnEnd = psScanIx;
			ppsVOnEnd++;
			psScanIx += sCross;
					
			*ppsVOffBegin = psScanIx;
			ppsVOffBegin++;
			*ppsVOffEnd = psScanIx;
			ppsVOffEnd++;
			psScanIx += sCross;
		}
		if (usScanKind & SK_SMART)              /* if smart dropout */
		{
			STATE.afxXPoints = (F26Dot6*) fsc_AllocVMem(ASTATE lElemCount * sizeof(F26Dot6));
			STATE.afxYPoints = (F26Dot6*) fsc_AllocVMem(ASTATE lElemCount * sizeof(F26Dot6));
		}
	}
	return NO_ERR;
}

/*********************************************************************/

/* This function saves the first contour point for smart dropout calcs */

FS_PUBLIC void fsc_BeginContourScan(
		PSTATE                              /* pointer to state variables */
		uint16 usScanKind,                  /* scan type */
		F26Dot6 fxX1,                       /* starting point x coordinate */
		F26Dot6 fxY1                        /* starting point y coordinate */
)
{
	if (!(usScanKind & SK_NODROPOUT) && (usScanKind & SK_SMART)) /* if smart dropout */
	{
		STATE.afxXPoints[STATE.lPoint] = fxX1;
		STATE.afxYPoints[STATE.lPoint] = fxY1;
		STATE.lPoint++;
		Assert (STATE.lPoint <= STATE.lElementPoints);
	}
}

/*********************************************************************/
	
/* This function is called at the beginning of each line, subdivided */
/* spline, or endpoint-on-scanline.  It sets scanline state variables, */
/* save control points (for smart dropout control), and return the */
/* appropriate AddScan function pointers */

FS_PUBLIC void fsc_BeginElement(
	PSTATE                                      /* pointer to state variables */
	uint16 usScanKind,                          /* type of dropout control */
	int32 lQuadrant,                            /* determines scan on/off */
	int32 lElementCode,                         /* element (line, spline, ep) */
	int32 lPts,                                 /* number of points to store */
	F26Dot6 *pfxX,                              /* next x control point(s) */
	F26Dot6 *pfxY,                              /* next y control point(s) */
	void (**ppfnAddHorizScan)(PSTATE int32, int32),  /* horiz add scan return */
	void (**ppfnAddVertScan)(PSTATE int32, int32)    /* vert add scan return */
)
{
	*ppfnAddHorizScan = STATE.pfnAddHoriz;      /* set horiz add scan func */
	*ppfnAddVertScan = STATE.pfnAddVert;        /* set vert add scan func */

	
	if ((lQuadrant == 1) || (lQuadrant == 2))
	{
		STATE.apsHorizBegin = STATE.apsHOnBegin;    /* add 'on' interscections */
		STATE.apsHorizEnd = STATE.apsHOnEnd;
	}
	else
	{
		STATE.apsHorizBegin = STATE.apsHOffBegin;   /* add 'off' interscections */
		STATE.apsHorizEnd = STATE.apsHOffEnd;
	}
	
	if (!(usScanKind & SK_NODROPOUT))               /* if any kind of dropout */
	{
		if ((lQuadrant == 2) || (lQuadrant == 3))
		{
			STATE.apsVertBegin = STATE.apsVOnBegin; /* add 'on' interscections */
			STATE.apsVertEnd = STATE.apsVOnEnd;
		}
		else
		{
			STATE.apsVertBegin = STATE.apsVOffBegin; /* add 'off' interscections */
			STATE.apsVertEnd = STATE.apsVOffEnd;
		}
		
		if (usScanKind & SK_SMART)              /* if smart dropout */
		{
            Assert((STATE.lPoint - 1) <= (0xFFFF >> SC_CODESHFT));
			STATE.usScanTag = (uint16)(((STATE.lPoint - 1) << SC_CODESHFT) | lElementCode);

			while (lPts > 0)                    /* save control points */
			{
				STATE.afxXPoints[STATE.lPoint] = *pfxX;
				pfxX++;
				STATE.afxYPoints[STATE.lPoint] = *pfxY;
				pfxY++;
				STATE.lPoint++;
				lPts--;
				Assert (STATE.lPoint <= STATE.lElementPoints);
			}
		}
	}
}


/*********************************************************************/

/*      Add Scanline Intersection Functions                          */

/*********************************************************************/

/*  Sort a simple intersection into the horizontal scan list array  */

FS_PRIVATE void AddHorizSimpleScan(
		PSTATE                      /* pointer to state variables */
		int32 lX,                   /* x coordinate */
		int32 lY )                  /* scan index */
{
	int16 **ppsEnd;                 /* ptr to end array top */
	int16 *psBegin;                 /* pts to first array element */
	int16 *psEnd;                   /* pts past last element */
	int16 *psLead;                  /* leads psEnd walking backward */
	int16 sX;

/* printf("H(%li, %li)  ", lX, lY); */

	Assert(lX >= STATE.lBoxLeft);   /* trap unreasonable values */
	Assert(lX <= STATE.lBoxRight);
	Assert(lY >= STATE.lBoxBottom);
	Assert(lY < STATE.lBoxTop);

	lY -= STATE.lBoxBottom;         /* normalize */
	psBegin = STATE.apsHorizBegin[lY];
	ppsEnd = &STATE.apsHorizEnd[lY];
	psEnd = *ppsEnd;
	(*ppsEnd)++;                    /* bump ptr for next time */
	
	psLead = psEnd - 1;
	sX = (int16)lX;
	
	while((psLead >= psBegin) && (*psLead > sX))
	{
		*psEnd-- = *psLead--;       /* make room */
	}
	*psEnd = sX;                    /* store new value */
}

/*********************************************************************/

/*  Sort a simple intersection into the vertical scan list array  */

FS_PRIVATE void AddVertSimpleScan(
		PSTATE                      /* pointer to state variables */
		int32 lX,                   /* x coordinate */
		int32 lY )                  /* scan index */
{
	int16 **ppsEnd;                 /* ptr to end array top */
	int16 *psBegin;                 /* pts to first array element */
	int16 *psEnd;                   /* pts past last element */
	int16 *psLead;                  /* leads psEnd walking backward */
	int16 sY;

/* printf("V(%li, %li)  ", lX, lY); */

	Assert(lX >= STATE.lBoxLeft);   /* trap unreasonable values */
	Assert(lX < STATE.lBoxRight);
	Assert(lY >= STATE.lBoxBottom);
	Assert(lY <= STATE.lBoxTop);

	lX -= STATE.lBoxLeft;           /* normalize */
	psBegin = STATE.apsVertBegin[lX];
	ppsEnd = &STATE.apsVertEnd[lX];
	psEnd = *ppsEnd;
	(*ppsEnd)++;                    /* bump ptr for next time */

	psLead = psEnd - 1;
	sY = (int16)lY;
	
	while((psLead >= psBegin) && (*psLead > sY))
	{
		*psEnd-- = *psLead--;       /* make room */
	}
	*psEnd = sY;                    /* store new value */
}

/*********************************************************************/

/*  Sort a smart intersection into the horizontal scan list array  */

FS_PRIVATE void AddHorizSmartScan(
		PSTATE                      /* pointer to state variables */
		int32 lX,                   /* x coordinate */
		int32 lY )                  /* scan index */
{
	int16 **ppsEnd;                 /* ptr to end array top */
	uint32 *pulBegin;                /* pts to first array element */
	uint32 *pulEnd;                  /* pts past last element */
	uint32 *pulLead;                 /* leads pulEnd walking backward */
	int16 *psInsert;                /* new data insertion point */
	int16 sX;

	Assert(lX >= STATE.lBoxLeft);   /* trap unreasonable values */
	Assert(lX <= STATE.lBoxRight);
	Assert(lY >= STATE.lBoxBottom);
	Assert(lY < STATE.lBoxTop);
	
	lY -= STATE.lBoxBottom;         /* normalize */
	pulBegin = (uint32*)STATE.apsHorizBegin[lY];
	ppsEnd = &STATE.apsHorizEnd[lY];
	pulEnd = (uint32*)*ppsEnd;
	(*ppsEnd) += 2;                 /* value & tag */

	pulLead = pulEnd - 1;
	sX = (int16)lX;

	while((pulLead >= pulBegin) && (*((int16*)pulLead) > sX))
	{
		*pulEnd-- = *pulLead--;     /* make room */
	}
	psInsert = (int16*)pulEnd;
	*psInsert = sX;                 /* store new value */
	psInsert++;
	*psInsert = STATE.usScanTag;    /* keep tag too */
}

/*********************************************************************/

/*  Sort a smart intersection into the vertical scan list array  */

FS_PRIVATE void AddVertSmartScan(
		PSTATE                      /* pointer to state variables */
		int32 lX,                   /* x coordinate */
		int32 lY )                  /* scan index */
{
	int16 **ppsEnd;                 /* ptr to end array top */
	uint32 *pulBegin;                /* pts to first array element */
	uint32 *pulEnd;                  /* pts past last element */
	uint32 *pulLead;                 /* leads pulEnd walking backward */
	int16 *psInsert;                /* new data insertion point */
	int16 sY;

	Assert(lX >= STATE.lBoxLeft);   /* trap unreasonable values */
	Assert(lX < STATE.lBoxRight);
	Assert(lY >= STATE.lBoxBottom);
	Assert(lY <= STATE.lBoxTop);
	
	lX -= STATE.lBoxLeft;         /* normalize */
	pulBegin = (uint32*)STATE.apsVertBegin[lX];
	ppsEnd = &STATE.apsVertEnd[lX];
	pulEnd = (uint32*)*ppsEnd;
	(*ppsEnd) += 2;                 /* value & tag */

	pulLead = pulEnd - 1;
	sY = (int16)lY;

	while((pulLead >= pulBegin) && (*((int16*)pulLead) > sY))
	{
		*pulEnd-- = *pulLead--;     /* make room */
	}
	psInsert = (int16*)pulEnd;
	*psInsert = sY;                 /* store new value */
	psInsert++;
	*psInsert = STATE.usScanTag;    /* keep tag too */
}

/*********************************************************************/

/*  Add an intersection with banding                                 */

/*********************************************************************/

/*  Sort a simple intersection into the horizontal band list array  */

FS_PRIVATE void AddHorizSimpleBand(
		PSTATE                      /* pointer to state variables */
		int32 lX,                   /* x coordinate */
		int32 lY )                  /* scan index */
{
	int16 **ppsEnd;                 /* ptr to end array top */
	int16 *psBegin;                 /* pts to first array element */
	int16 *psEnd;                   /* pts past last element */
	int16 *psLead;                  /* leads psEnd walking backward */
	int16 sX;

	Assert(lX >= STATE.lBoxLeft);   /* trap unreasonable values */
	Assert(lX <= STATE.lBoxRight);
	
	if ((lY >= STATE.lLoScanBand) && (lY < STATE.lHiScanBand))
	{
		lY -= STATE.lLoScanBand;    /* normalize */
		psBegin = STATE.apsHorizBegin[lY];
		ppsEnd = &STATE.apsHorizEnd[lY];
		psEnd = *ppsEnd;
		(*ppsEnd)++;                /* bump ptr for next time */
		
		psLead = psEnd - 1;
		sX = (int16)lX;

		while((psLead >= psBegin) && (*psLead > sX))
		{
			*psEnd-- = *psLead--;   /* make room */
		}
		*psEnd = sX;                /* store new value */
	}
}

/*********************************************************************/

/*  Sort a smart intersection into the horizontal band list array  */

FS_PRIVATE void AddHorizSmartBand(
		PSTATE                      /* pointer to state variables */
		int32 lX,                   /* x coordinate */
		int32 lY )                  /* scan index */
{
	int16 **ppsEnd;                 /* ptr to end array top */
	uint32 *pulBegin;               /* pts to first array element */
	uint32 *pulEnd;                 /* pts past last element */
	uint32 *pulLead;                /* leads pulEnd walking backward */
	int16 *psInsert;                /* new data insertion point */
	int16 sX;

	Assert(lX >= STATE.lBoxLeft);   /* trap unreasonable values */
	Assert(lX <= STATE.lBoxRight);
	
	if ((lY >= STATE.lLoScanBand) && (lY < STATE.lHiScanBand))
	{
		lY -= STATE.lLoScanBand;    /* normalize */
		pulBegin = (uint32*)STATE.apsHorizBegin[lY];
		ppsEnd = &STATE.apsHorizEnd[lY];
		pulEnd = (uint32*)*ppsEnd;
		(*ppsEnd) += 2;             /* value & tag */

		pulLead = pulEnd - 1;
		sX = (int16)lX;

		while((pulLead >= pulBegin) && (*((int16*)pulLead) > sX))
		{
			*pulEnd-- = *pulLead--;  /* make room */
		}
		psInsert = (int16*)pulEnd;
		*psInsert = sX;              /* store new value */
		psInsert++;
		*psInsert = STATE.usScanTag; /* keep tag too */
	}
}


/*********************************************************************/

/*  When all contours have been scanned, fill in the bitmap          */

/*********************************************************************/

FS_PUBLIC int32 fsc_FillBitMap(
		PSTATE                          /* pointer to state variables */
		char *pchBitMap,                /* target memory */
		int32 lHiBand,                  /* top bitmap limit */
		int32 lLoBand,                  /* bottom bitmap limit */
		int32 lRowBytes,                /* bitmap bytes per row */
		int32 lOrgLoBand,               /* original low band row */
		uint16 usScanKind )             /* dropout control value */
{
	int32 lHeight;                      /* of scan band in pixels */
	int32 lIndex;                       /* array index */
	int32 lFirstScan;                   /* first scanline index */

	int16 sXOffset;                     /* bitmap box shift */
	int16 sXStart;                      /* on transition */
	int16 sXStop;                       /* off transition */
	
	uint32 *pulRow;                     /* row beginning pointer */
	uint32 ulBMPLongs;                  /* longs per bitmap */
	int32 lRowLongs;                    /* long words per row */
	int32 lErrCode;
	
	int16 **ppsHOnBegin;                /* for init speed */
	int16 **ppsHOnEnd;
	int16 **ppsHOffBegin;
			
	int16 *psHorizOn;
	int16 *psHorizOff;
	int16 *psHorizOnEnd;
	

/*  printf("%li : %li\n", lHiBand, lLoBand); */
	
	STATE.lHiBitBand = lHiBand;                 /* copy bit band limits */
	STATE.lLoBitBand = lLoBand;
	lHeight = STATE.lHiBitBand - STATE.lLoBitBand;
	
	STATE.lRowBytes = lRowBytes;                /* save bytes per row */
	lRowLongs = lRowBytes >> 2;                 /* long words per row */
	
	ulBMPLongs = (uint32)(lRowLongs * (int32)lHeight);
	pulRow = (uint32*)pchBitMap;                /* start at glyph top */
	lErrCode = fsc_ClearBitMap(ulBMPLongs, pulRow);
	if (lErrCode != NO_ERR) return lErrCode;

	sXOffset = (int16)STATE.lBoxLeft;
	
	lFirstScan = STATE.lHiBitBand - STATE.lLoScanBand - 1;
	ppsHOnBegin = &STATE.apsHOnBegin[lFirstScan];
	ppsHOffBegin = &STATE.apsHOffBegin[lFirstScan];
	ppsHOnEnd = &STATE.apsHOnEnd[lFirstScan];
						
/*  now go through the bitmap from top to bottom */

	for (lIndex = 0; lIndex < lHeight; lIndex++)
	{
		psHorizOn = *ppsHOnBegin;
		ppsHOnBegin--;
		psHorizOff = *ppsHOffBegin;
		ppsHOffBegin--;
		psHorizOnEnd = *ppsHOnEnd;
		ppsHOnEnd--;
				
		Assert(psHorizOnEnd <= psHorizOff);
		Assert(psHorizOnEnd - psHorizOn == STATE.apsHOffEnd[lFirstScan - lIndex] - psHorizOff);

		while (psHorizOn < psHorizOnEnd)
		{
			sXStart = *psHorizOn - sXOffset;
			psHorizOn += STATE.sIxSize;
			sXStop = *psHorizOff - sXOffset;
			psHorizOff += STATE.sIxSize;

			if (sXStart < sXStop)                   /* positive run */
			{
				lErrCode = fsc_BLTHoriz(sXStart, sXStop - 1, pulRow);
			}
			else if (sXStart > sXStop)              /* negative run */
			{
				lErrCode = fsc_BLTHoriz(sXStop, sXStart - 1, pulRow);
			}
			if (lErrCode != NO_ERR) return lErrCode;
		}
		pulRow += lRowLongs;                        /* next row */
	}
	
/* if doing dropout control, do it now */

	if (!(usScanKind & SK_NODROPOUT))               /* if any kind of dropout */
	{
		lErrCode = LookForDropouts(ASTATE pchBitMap, usScanKind);
		if (lErrCode != NO_ERR) return lErrCode;
		
		if (lOrgLoBand != STATE.lLoScanBand)        /* if fast banding & dropout */
		{
			pulRow -= lRowLongs;                    /* back to overscan row */
			pulRow -= lRowLongs;                    /* back to low row */
			lErrCode = fsc_BLTCopy (pulRow, STATE.pulLastRow, lRowLongs);
			if (lErrCode != NO_ERR) return lErrCode;

			STATE.lLastRowIndex = STATE.lLoBitBand + 1; /* save row ID */
		}
	}
	return NO_ERR;
}

/*********************************************************************/

/*      Dropout Control Functions                                    */

/*********************************************************************/
	
FS_PRIVATE int32 LookForDropouts(
		PSTATE                      /* pointer to state variables  */
		char *pchBitMap,
		uint16 usScanKind )         /* dropout control value */
{
	int16 **ppsHOnBegin;            /* for init speed */
	int16 **ppsHOnEnd;
	int16 **ppsHOffBegin;
			
	int16 *psHorizOn;
	int16 *psHorizOff;
	int16 *psHorizOnEnd;
	
	int16 **ppsVOnBegin;            /* for init speed */
	int16 **ppsVOnEnd;
	int16 **ppsVOffEnd;
			
	int16 *psVertOn;
	int16 *psVertOff;
	int16 *psVertOnBegin;

	int32 lHeight;
	int32 lWidth;
	int32 lIndex;                   /* array index */
	int32 lFirstScan;               /* first scanline index */
	
	int32 lErrCode;

/*  Check horizontal scan lines for dropouts  */
	
	lHeight = STATE.lHiBitBand - STATE.lLoBitBand;
	lFirstScan = STATE.lHiBitBand - STATE.lLoScanBand - 1;
	ppsHOnBegin = &STATE.apsHOnBegin[lFirstScan];
	ppsHOffBegin = &STATE.apsHOffBegin[lFirstScan];
	ppsHOnEnd = &STATE.apsHOnEnd[lFirstScan];
		
	for (lIndex = 0; lIndex < lHeight; lIndex++)
	{
		psHorizOn = *ppsHOnBegin;
		ppsHOnBegin--;
		psHorizOff = *ppsHOffBegin;
		ppsHOffBegin--;
		psHorizOnEnd = *ppsHOnEnd;
		ppsHOnEnd--;
		
		while (psHorizOn < psHorizOnEnd)
		{
			if (*psHorizOn == *psHorizOff)  /* zero length run */
			{
				lErrCode = DoHorizDropout(ASTATE psHorizOn, psHorizOff,
										 STATE.lHiBitBand - lIndex - 1,
										 pchBitMap,
										 usScanKind);
				if (lErrCode != NO_ERR) return lErrCode;
			}
			psHorizOn += STATE.sIxSize;
			psHorizOff += STATE.sIxSize;
		}
	}
		
/*  Check vertical scan lines for dropouts  */
	
	lWidth = STATE.lBoxRight - STATE.lBoxLeft;
	ppsVOnBegin = STATE.apsVOnBegin;
	ppsVOnEnd = STATE.apsVOnEnd;
	ppsVOffEnd = STATE.apsVOffEnd;
	
	for (lIndex = 0; lIndex < lWidth; lIndex++)
	{
		psVertOnBegin = *ppsVOnBegin;
		ppsVOnBegin++;
		psVertOn = *ppsVOnEnd - STATE.sIxSize;  /* start at end (glyph top) */
		ppsVOnEnd++;
		psVertOff = *ppsVOffEnd - STATE.sIxSize;
		ppsVOffEnd++;
		
		while (psVertOn >= psVertOnBegin)       /* from top to bottom */
		{
			if (*psVertOn == *psVertOff)        /* zero length run */
			{
				lErrCode = DoVertDropout(ASTATE psVertOn, psVertOff,
										 STATE.lBoxLeft + lIndex,
										 pchBitMap, usScanKind);
				if (lErrCode != NO_ERR) return lErrCode;
			}
			psVertOn -= STATE.sIxSize;
			psVertOff -= STATE.sIxSize;
		}
	}
	return NO_ERR;
}


/*********************************************************************/

FS_PRIVATE int32 DoHorizDropout(
		PSTATE                  /* pointer to state variables */
		int16 *psOn,            /* pointer to on intersection */
		int16 *psOff,           /* pointer to off intersection */
		int32 lYDrop,           /* y coord of dropout */
		char *pchBitMap,        /* target memory */
		uint16 usScanKind )     /* dropout control value */
{
	int32 lXDrop;                                   /* x coord of dropout */
	int32 lCross;                                   /* scanline crossings */
	F26Dot6 fxX1, fxX2;                             /* for smart dropout */
	uint16 usOnTag, usOffTag;                       /* element info */
	int16 sOnPt, sOffPt;                            /* element list index */
	F26Dot6 (*pfnOn)(int32, F26Dot6*, F26Dot6*);    /* on callback */
	F26Dot6 (*pfnOff)(int32, F26Dot6*, F26Dot6*);   /* off callback */

	lXDrop = (int32)*psOn;
	
/*  if stub control on, check for stubs  */

	if (usScanKind & SK_STUBS)
	{
		lCross = HorizCrossings(ASTATE lXDrop, lYDrop + 1);
		lCross += VertCrossings(ASTATE lXDrop - 1, lYDrop + 1);
		lCross += VertCrossings(ASTATE lXDrop, lYDrop + 1);
		if (lCross < 2)
		{
			return NO_ERR;                      /* no continuation above */
		}
		
		lCross = HorizCrossings(ASTATE lXDrop, lYDrop - 1);
		lCross += VertCrossings(ASTATE lXDrop - 1, lYDrop);
		lCross += VertCrossings(ASTATE lXDrop, lYDrop);
		if (lCross < 2)
		{
			return NO_ERR;                      /* no continuation below */
		}
	}

/*  passed stub control, now check pixels left and right  */

	if (lXDrop > STATE.lBoxLeft)                /* if pixel to left */
	{
		if (GetBitAbs(ASTATE pchBitMap, lXDrop - 1, lYDrop) != 0L)
		{
			return NO_ERR;                      /* no dropout needed */
		}
	}
	if (lXDrop < STATE.lBoxRight)               /* if pixel to right */
	{
		if (GetBitAbs(ASTATE pchBitMap, lXDrop, lYDrop) != 0L)
		{
			return NO_ERR;                      /* no dropout needed */
		}
	}

/*  no pixels left or right, now determine bit placement  */

	if (usScanKind & SK_SMART)
	{
		usOnTag = (uint16)*(psOn+1);
		sOnPt = (int16)(usOnTag >> SC_CODESHFT);
		pfnOn = STATE.pfnHCallBack[usOnTag & SC_CODEMASK];
		fxX1 = pfnOn(lYDrop, &STATE.afxXPoints[sOnPt], &STATE.afxYPoints[sOnPt]);
		
		usOffTag = (uint16)*(psOff+1);
		sOffPt = (int16)(usOffTag >> SC_CODESHFT);
		pfnOff = STATE.pfnHCallBack[usOffTag & SC_CODEMASK];
		fxX2 = pfnOff(lYDrop, &STATE.afxXPoints[sOffPt], &STATE.afxYPoints[sOffPt]);
		
		lXDrop = (int32)((fxX1 + fxX2 - 1) >> (SUBSHFT + 1));     /* average */
	}
	else                                        /* simple dropout */
	{
		lXDrop--;                               /* always to the left */
	}
	
	if (lXDrop < STATE.lBoxLeft)                /* confine to bounding box */
	{
		lXDrop = STATE.lBoxLeft;
	}
	if (lXDrop >= STATE.lBoxRight)
	{
		lXDrop = STATE.lBoxRight - 1L;
	}

	return SetBitAbs(ASTATE pchBitMap, lXDrop, lYDrop);  /* turn on dropout pix */
}


/*********************************************************************/

FS_PRIVATE int32 DoVertDropout(
		PSTATE                      /* pointer to state variables */
		int16 *psOn,                /* pointer to on intersection */
		int16 *psOff,               /* pointer to off intersection */
		int32 lXDrop,               /* x coord of dropout */
		char *pchBitMap,            /* target memory descriptor */
		uint16 usScanKind )         /* dropout control value */
{
	int32 lYDrop;                                 /* y coord of dropout */
	int32 lCross;                                 /* scanline crossings */
	F26Dot6 fxY1, fxY2;                           /* for smart dropout */
	uint16 usOnTag, usOffTag;                     /* element info */
	int16 sOnPt, sOffPt;                          /* element list index */
	F26Dot6 (*pfnOn)(int32, F26Dot6*, F26Dot6*);  /* on callback */
	F26Dot6 (*pfnOff)(int32, F26Dot6*, F26Dot6*); /* off callback */
	
	lYDrop = (int32)*psOn;

	if ((lYDrop < STATE.lLoBitBand) || (lYDrop > STATE.lHiBitBand))
	{
		return NO_ERR;                          /* quick return for outside band */
	}

/*  if stub control on, check for stubs  */

	if (usScanKind & SK_STUBS)
	{
		lCross = VertCrossings(ASTATE lXDrop - 1, lYDrop);
		lCross += HorizCrossings(ASTATE lXDrop, lYDrop);
		lCross += HorizCrossings(ASTATE lXDrop, lYDrop - 1);
		if (lCross < 2)
		{
			return NO_ERR;                      /* no continuation to left */
		}
		
		lCross = VertCrossings(ASTATE lXDrop + 1, lYDrop);
		lCross += HorizCrossings(ASTATE lXDrop + 1, lYDrop);
		lCross += HorizCrossings(ASTATE lXDrop + 1, lYDrop - 1);
		if (lCross < 2)
		{
			return NO_ERR;                      /* no continuation to right */
		}
	}

/*  passed stub control, now check pixels below and above  */

	if (lYDrop > STATE.lBoxBottom)                  /* if pixel below */
	{
		if (GetBitAbs(ASTATE pchBitMap, lXDrop, lYDrop - 1) != 0L)
		{
			return NO_ERR;                          /* no dropout needed */
		}
	}
	if (lYDrop < STATE.lBoxTop)                     /* if pixel above */
	{
		if (GetBitAbs(ASTATE pchBitMap, lXDrop, lYDrop) != 0L)
		{
			return NO_ERR;                          /* no dropout needed */
		}
	}

/*  no pixels above or below, now determine bit placement  */
	
	if (usScanKind & SK_SMART)
	{
		usOnTag = (uint16)*(psOn+1);
		sOnPt = (int16)(usOnTag >> SC_CODESHFT);
		pfnOn = STATE.pfnVCallBack[usOnTag & SC_CODEMASK];
		fxY1 = pfnOn(lXDrop, &STATE.afxXPoints[sOnPt], &STATE.afxYPoints[sOnPt]);
		
		usOffTag = (uint16)*(psOff+1);
		sOffPt = (int16)(usOffTag >> SC_CODESHFT);
		pfnOff = STATE.pfnVCallBack[usOffTag & SC_CODEMASK];
		fxY2 = pfnOff(lXDrop, &STATE.afxXPoints[sOffPt], &STATE.afxYPoints[sOffPt]);
		
		lYDrop = (int32)((fxY1 + fxY2 - 1) >> (SUBSHFT + 1));     /* average */
	}
	else                                        /* simple dropout */
	{
		lYDrop--;                               /* always below */
	}
	
	if (lYDrop < STATE.lBoxBottom)              /* confine to bounding box */
	{
		lYDrop = STATE.lBoxBottom;
	}
	if (lYDrop >= STATE.lBoxTop)
	{
		lYDrop = STATE.lBoxTop - 1L;
	}
		
	if ((lYDrop >= STATE.lLoBitBand) && (lYDrop < STATE.lHiBitBand))
	{
		return SetBitAbs(ASTATE pchBitMap, lXDrop, lYDrop);  /* turn on dropout pix */
	}
	return NO_ERR;
}


/*********************************************************************/

/*  Count contour crossings of a horizontal scan line segment  */

FS_PRIVATE int32 HorizCrossings(
		PSTATE                          /* pointer to state variables */
		int32 lX,
		int32 lY )
{
	int32 lCrossings;
	int32 lIndex;
	
	int16 *psOn;
	int16 *psOff;
	int16 *psOnEnd;
	int16 sX;
	
	if ((lY < STATE.lLoScanBand) || (lY >= STATE.lHiScanBand))
	{
		return 0;                       /* if outside the scan region */
	}
	
	lCrossings = 0;
	lIndex = lY - STATE.lLoScanBand;
	psOn = STATE.apsHOnBegin[lIndex];
	psOff = STATE.apsHOffBegin[lIndex];
	psOnEnd = STATE.apsHOnEnd[lIndex];
	sX = (int16)lX;
	
	while (psOn < psOnEnd)
	{
		if (*psOn == sX)
		{
			lCrossings++;
		}
		psOn += STATE.sIxSize;
		
		if (*psOff == sX)
		{
			lCrossings++;
		}
		psOff += STATE.sIxSize;
	}
	return lCrossings;
}


/*********************************************************************/

/*  Count contour crossings of a vertical scan line segment  */

FS_PRIVATE int32 VertCrossings(
		PSTATE                          /* pointer to state variables */
		int32 lX,
		int32 lY )
{
	int32 lCrossings;
	int32 lIndex;
	
	int16 *psOn;
	int16 *psOff;
	int16 *psOnEnd;
	int16 sY;
	
	if ((lX < STATE.lBoxLeft) || (lX >= STATE.lBoxRight))
	{
		return 0;                       /* if outside the bitmap */
	}
	
	lCrossings = 0;
	lIndex = lX - STATE.lBoxLeft;
	psOn = STATE.apsVOnBegin[lIndex];
	psOff = STATE.apsVOffBegin[lIndex];
	psOnEnd = STATE.apsVOnEnd[lIndex];
	sY = (int16)lY;
	
	while (psOn < psOnEnd)
	{
		if (*psOn == sY)
		{
			lCrossings++;
		}
		psOn += STATE.sIxSize;
		
		if (*psOff == sY)
		{
			lCrossings++;
		}
		psOff += STATE.sIxSize;
	}
	return lCrossings;
}
		

/****************************************************************************/

/*              Get a pixel using absolute coordinates                      */

/*  When banding with dropout control, this routine uses the last low row   */
/*  of the previous bitmap when possible.                                   */

FS_PRIVATE uint32 GetBitAbs(
		PSTATE                              /* pointer to state variables */
		char *pchBitMap,
		int32 lX,
		int32 lY )
{
	uint32 *pulRow;                         /* bitmap row pointer */

	Assert(lX >= STATE.lBoxLeft);           /* trap unreasonable values */
	Assert(lX < STATE.lBoxRight);
	Assert(lY >= STATE.lBoxBottom);
	Assert(lY < STATE.lBoxTop);

	if ((lY < STATE.lHiBitBand) && (lY >= STATE.lLoBitBand))  /* if within the bitmap */
	{
		pulRow = (uint32*)(pchBitMap + ((STATE.lHiBitBand - 1 - lY) * STATE.lRowBytes));
		return fsc_GetBit(lX - STATE.lBoxLeft, pulRow);       /* read the bitmap */
	}
	if (lY == STATE.lLastRowIndex)          /* if saved from last band */
	{
		return fsc_GetBit(lX - STATE.lBoxLeft, STATE.pulLastRow);
	}
	return(0L);                             /* outside bitmap doesn't matter */
}


/*********************************************************************/

/*  Set a pixel using absolute coordinates  */

FS_PRIVATE int32 SetBitAbs(
		PSTATE                              /* pointer to state variables */
		char *pchBitMap,
		int32 lX,
		int32 lY )
{
	uint32 *pulRow;                         /* bitmap row pointer */
	
	Assert(lX >= STATE.lBoxLeft);           /* trap unreasonable values */
	Assert(lX < STATE.lBoxRight);
	Assert(lY >= STATE.lLoBitBand);
	Assert(lY < STATE.lHiBitBand);
	
	pulRow = (uint32*)(pchBitMap + ((STATE.lHiBitBand - 1 - lY) * STATE.lRowBytes));
	
	return fsc_SetBit(lX - STATE.lBoxLeft, pulRow);
}


/*********************************************************************/

/*      Gray Scale Pass Through Functions                            */

/*********************************************************************/

FS_PUBLIC int32 fsc_ScanClearBitMap (
		uint32 ulCount,                     /* longs per bmp */
		uint32* pulBitMap                   /* bitmap ptr caste long */
)
{
	return fsc_ClearBitMap(ulCount, pulBitMap);
}


/*********************************************************************/

FS_PUBLIC int32 fsc_ScanCalcGrayRow(
		GrayScaleParam* pGSP                /* pointer to param block */
)
{
	return fsc_CalcGrayRow(pGSP);
}

/*********************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\fs\scglobal.h ===
/*********************************************************************

      scglobal.h -- Information shared by all scan converter modules

      (c) Copyright 1992  Microsoft Corp.  All rights reserved.

       7/09/93 deanb    include fsconfig.h removed (fscdefs does it)
       4/19/93 deanb    banding limits added
       4/12/93 deanb    from old scconst.h + scstate.h

**********************************************************************/

#include "fscdefs.h"                /* for type definitions */

/********************************************************************/

/*      Internal Constant Values                                    */

/********************************************************************/

#define HUGEINT         0x7FFF          /* impossibly large int16 value */
#define HUGEFIX         0x7FFFFFFFL     /* impossibly large fx value */

#define SUBPIX          64L             /* sub pixels per pix */
#define SUBHALF         32L             /* one half of SUBPIX */
#define SUBSHFT         6               /* log base two of SUBPIX */
    
#define ONSCANLINE(y)   ((y) & (SUBPIX - 1L)) == SUBHALF
#define SCANABOVE(y)    ((((y) + SUBHALF) & (-SUBPIX)) + SUBHALF)
#define SCANBELOW(y)    ((((y) - SUBHALF - 1L) & (-SUBPIX)) + SUBHALF)

/*      Math macros      */

#define FXABS(x)  ((x) >= 0L ? (x) : -(x))

/*      Module codes for subpix callbacks   */

#define SC_LINECODE     0
#define SC_SPLINECODE   1
#define SC_ENDPTCODE    2

#define SC_MAXCODES     3               /* number of codes above */
#define SC_CODESHFT     2               /* bits needed to store codes */
#define SC_CODEMASK     0x0003          /* to mask off codes */


/**********************************************************************

    The following structure defines all of the state variables for the 
    scan converter.  This structure is allocated statically for a non-
    reentrant implementation, or as an automatic variable to permit 
    reentrancy.  There are three sets of variables: one for the endpoint 
    module, one for scanlist, and one for memory.  Rules of the game are 
    that each module accesses ONLY its own variables for reading AND 
    writing.  It is possible for one module to read another's variables, 
    BUT IT WOULD BE WRONG.

**********************************************************************/

typedef struct statevar
{

/* endpoint state variables */

    F26Dot6 fxX0, fxY0;             /* point from call before last */
    F26Dot6 fxX1, fxY1;             /* point from previous call */
    F26Dot6 fxX2Save, fxY2Save;     /* for closing the contour */
                 
/* scanlist state variables */

    int32 lBoxLeft;                 /* bounding box xmin */
    int32 lBoxRight;                /* bounding box xmax */
    int32 lBoxTop;                  /* bounding box ymax */
    int32 lBoxBottom;               /* bounding box ymin */
    int32 lRowBytes;                /* bitmap bytes per row */
    int32 lHiScanBand;              /* banding upper scan limit */
    int32 lLoScanBand;              /* banding lower scan limit */
    int32 lHiBitBand;               /* banding upper bitmap limit */
    int32 lLoBitBand;               /* banding lower bitmap limit */
    int32 lLastRowIndex;            /* last row scan line index */
    uint32* pulLastRow;             /* for dropout banding */

    int16 **apsHOnBegin;            /* beginning of on pointers array */
    int16 **apsHOffBegin;           /* beginning of off pointers array */
    int16 **apsHOnEnd;              /* end of on pointers array */
    int16 **apsHOffEnd;             /* end of off pointers array */
    int16 **apsHorizBegin;          /* current pointer array */
    int16 **apsHorizEnd;            /* current pointer array */

    int16 **apsVOnBegin;            /* beginning of on pointers array */
    int16 **apsVOffBegin;           /* beginning of off pointers array */
    int16 **apsVOnEnd;              /* end of on pointers array */
    int16 **apsVOffEnd;             /* end of off pointers array */
    int16 **apsVertBegin;           /* current pointer array */
    int16 **apsVertEnd;             /* current pointer array */
              
#ifdef FSCFG_REENTRANT              /* needed to avoid circular PSTATE */
    void (*pfnAddHoriz)(struct statevar*, int32, int32);
    void (*pfnAddVert)(struct statevar*, int32, int32);
#else
    void (*pfnAddHoriz)(int32, int32);
    void (*pfnAddVert)(int32, int32);
#endif

    F26Dot6 (*pfnHCallBack[SC_MAXCODES])(int32, F26Dot6*, F26Dot6*);
    F26Dot6 (*pfnVCallBack[SC_MAXCODES])(int32, F26Dot6*, F26Dot6*);
        
    F26Dot6 *afxXPoints;            /* x element control points */
    F26Dot6 *afxYPoints;            /* y element control points */
    int32 lElementPoints;           /* estimate of element points */
    int32 lPoint;                   /* index to element control points */
    uint16 usScanTag;               /* stores point index, element code */
    int16 sIxSize;                  /* int16's per intersection */
    int16 sIxShift;                 /* log2 of size */

/* memory state variables */

    char *pchHNextAvailable;        /* horizontal memory pointer */
    char *pchVNextAvailable;        /* vertical memory pointer */
    char *pchHWorkSpaceEnd;         /* horizontal memory overflow */
    char *pchVWorkSpaceEnd;         /* vertical memory overflow */
}
StateVars;

/********************************************************************/

/*              Reentrancy parameters                               */

/********************************************************************/

#ifdef FSCFG_REENTRANT

#define PSTATE      StateVars *pState,
#define PSTATE0     StateVars *pState
#define ASTATE      pState,
#define ASTATE0     pState
#define STATE       (*pState)

#else 

#define PSTATE
#define PSTATE0     void
#define ASTATE
#define ASTATE0
#define STATE       State

extern  StateVars   State;              /* statically alloc'd in NewScan */

#endif 

/********************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\fs\scbitmap.c ===
/*********************************************************************

      scbitmap.c -- New Scan Converter BitMap Module

      (c) Copyright 1992  Microsoft Corp.  All rights reserved.

      10/03/93  deanb   use (x) in bitmask shift macros
       8/23/93  deanb   gray scale functions
       6/11/93  deanb   use MEMSET macro, string & stddef removed
       6/10/93  deanb   Start/Stop/Bit mask macros
       6/10/93  deanb   InitializeBitMasks added, stdio & assert removed
       4/29/93  deanb   BLTCopy routine added
       3/19/93  deanb   size_t caste checked
      10/14/92  deanb   memset for fsc_ClearBitMap
       9/15/92  deanb   Set bit coded 
       8/18/92  deanb   include scconst.h 
       6/02/92  deanb   Row pointer, integer limits, no descriptor 
       5/08/92  deanb   reordered includes for precompiled headers 
       5/04/92  deanb   Array tags added 
       4/27/92  deanb   Negative runs handled 
       4/16/92  deanb   Coding 
       3/23/92  deanb   First cut 

**********************************************************************/

#define FSCFG_INTERNAL

/*********************************************************************/

/*      Imports                                                      */

/*********************************************************************/


#include    "fscdefs.h"             /* shared data types */
#include    "scgray.h"              /* gray scale param block */
#include    "fserror.h"             /* error codes */
#include    "scbitmap.h"            /* for own function prototypes */


/*********************************************************************/

/*      Constants                                                    */

/*********************************************************************/

#define     MASKSIZE    32              /* bits per bitmap masks */
#define     MASKSHIFT   5               /* log2 of MASKSIZE */
#define     MASKBITS    0x0000001FL     /* masks pix loc of long word */

#define     ALL_ONES    ((uint32)0xFFFFFFFFL)
#define     HIGH_ONE    ((uint32)0x80000000L)


/*********************************************************************/

/*      Bitmask definitions                                          */

/*********************************************************************/
    
#ifndef FSCFG_USE_MASK_SHIFT    /* if using bitmask tables */

#define START_MASK(x)   aulStartBits[x]
#define STOP_MASK(x)    aulStopBits[x]
#define BIT_MASK(x)     aulBitMask[x]

/*  bitmask tables */

FS_PRIVATE uint32 aulStartBits[MASKSIZE];       /* such as:  0000111 */
FS_PRIVATE uint32 aulStopBits[MASKSIZE];        /* such as:  1110000 */
FS_PRIVATE uint32 aulBitMask[MASKSIZE];         /* such as:  0001000 */


#else                           /* if using bitmask shift */

#define START_MASK(x)   (ALL_ONES >> (x))
#define STOP_MASK(x)    (ALL_ONES << ((MASKSIZE - 1) - (x)))
#define BIT_MASK(x)     (HIGH_ONE >> (x))

#endif


/*********************************************************************/

/*      Export Functions                                             */

/*********************************************************************/

/*      fsc_InitializeBitMasks() loads the arrays of 32-bit masks at 
 *      runtime to create CPU independent bitmap masks.
 *
 *      It is conditionally compiled because the arrays are unused
 *      in a "USE_MASK_SHIFT" (e.g. Apple, HP) configuration. 
 *
 *      We load the arrays by converting the Big-Endian value of
 *      the mask to the "native" representation of that mask.  The
 *      "native" representation can be applied to a "native" byte
 *      array to manipulate more than 8 bits at a time of an output
 *      bitmap.
 */

FS_PUBLIC void fsc_InitializeBitMasks (void)
{
#ifndef FSCFG_USE_MASK_SHIFT

    int32 lIdx;
    uint32 ulStartMask;
    uint32 ulStopMask;
    uint32 ulBitMask;

    ulStartMask = ALL_ONES;
    ulStopMask = ALL_ONES;
    ulBitMask = HIGH_ONE;
    
    for (lIdx = 0; lIdx < MASKSIZE; lIdx++)
    {
        aulStartBits[lIdx] = (uint32) SWAPL(ulStartMask);
        aulStopBits[MASKSIZE - lIdx - 1] = (uint32) SWAPL(ulStopMask);
        aulBitMask[lIdx] = (uint32) SWAPL(ulBitMask);

        ulStartMask >>= 1;
        ulStopMask <<= 1;
        ulBitMask >>= 1;
    }
#endif
}


/*********************************************************************/

FS_PUBLIC int32 fsc_ClearBitMap (
        uint32 ulBMPLongs, 
        uint32 *pulMap )
{
    size_t stBytes;

    stBytes = (size_t)ulBMPLongs << 2;

    Assert((uint32)stBytes == (ulBMPLongs << 2));

    MEMSET((void*)pulMap, 0, stBytes);
    
    return NO_ERR;
}


/*********************************************************************/

FS_PUBLIC int32 fsc_BLTHoriz (
        int32 lXStart, 
        int32 lXStop, 
        uint32 *pulMap )                 
{
    int32 lSkip;

    lSkip = (lXStart >> MASKSHIFT);         /* longwords to first black */
    pulMap += lSkip;
    lXStart -= lSkip << MASKSHIFT;          /* correct start/stop */
    lXStop -= lSkip << MASKSHIFT;
    while (lXStop >= MASKSIZE)
    {
        *pulMap |= START_MASK(lXStart);
        pulMap++;
        lXStart = 0;
        lXStop -= MASKSIZE;
    }
    *pulMap |= START_MASK(lXStart) & STOP_MASK(lXStop);
    return NO_ERR;
}


/*********************************************************************/

FS_PUBLIC int32 fsc_BLTCopy ( 
        uint32 *pulSource,         /* source row pointer */
        uint32 *pulDestination,    /* destination row pointer */
        int32 lCount )             /* long word counter */
{
    while (lCount)
    {
        *pulDestination = *pulSource;
        pulDestination++;
        pulSource++;
        lCount--;
    }
    return NO_ERR;
}


/*********************************************************************/

FS_PUBLIC uint32 fsc_GetBit( 
        int32 lXCoord,              /* x coordinate */
        uint32* pulMap )            /* bit map row pointer */
{
    return(pulMap[lXCoord >> MASKSHIFT] & BIT_MASK(lXCoord & MASKBITS));
}


/*********************************************************************/

FS_PUBLIC int32 fsc_SetBit( 
        int32 lXCoord,              /* x coordinate */
        uint32* pulMap )            /* bit map row pointer */
{
    pulMap[lXCoord >> MASKSHIFT] |= BIT_MASK(lXCoord & MASKBITS);
    
    return NO_ERR;
}


/*********************************************************************/

/*  Gray scale row bitmap calculation                                */
/*  Count one row of over scale pixels into gray scale row           */

/*********************************************************************/
                
FS_PUBLIC int32 fsc_CalcGrayRow(
        GrayScaleParam* pGSP
)
{            
    char        *pchOver;               /* pointer to overscaled bitmap */
    char        *pchGray;               /* pointer to gray scale bitmap */
    uint16      usShiftMask;            /* masks off over scaled bits of interest */
    uint16      usGoodBits;             /* number of valid bits in usOverBits */
    uint16      usOverBits;             /* a byte of overscaled bitmap */
    int16       sGrayColumns;           /* number of gray columns to calc */
    
    static char chCount[256] = {        /* count of one bits */    
        0, 1, 1, 2, 1, 2, 2, 3, 1, 2, 2, 3, 2, 3, 3, 4, 1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5,
        1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
        1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
        2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
        1, 2, 2, 3, 2, 3, 3, 4, 2, 3, 3, 4, 3, 4, 4, 5, 2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6,
        2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
        2, 3, 3, 4, 3, 4, 4, 5, 3, 4, 4, 5, 4, 5, 5, 6, 3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7,
        3, 4, 4, 5, 4, 5, 5, 6, 4, 5, 5, 6, 5, 6, 6, 7, 4, 5, 5, 6, 5, 6, 6, 7, 5, 6, 6, 7, 6, 7, 7, 8
    };


    pchGray = pGSP->pchGray;
    pchOver = pGSP->pchOver;
    sGrayColumns = pGSP->sGrayCol;
    usShiftMask = 0x00FF >> (8 - pGSP->usOverScale);  /* over bits per gray pix */
    usGoodBits = 8 - pGSP->usFirstShift;
    usOverBits = ((uint16)*pchOver) >> pGSP->usFirstShift;
                
    Assert (pchGray >= pGSP->pchGrayLo);
    Assert (pchGray < pGSP->pchGrayHi);
    
    *pchGray += chCount[usOverBits & usShiftMask];
    pchGray--;                              /* move backwards through both bitmaps! */
    sGrayColumns--;

    while (sGrayColumns > 0)                /* for each gray column (after 1st) */
    {
        usGoodBits -= pGSP->usOverScale;
        if (usGoodBits > 0)                 /* if bits remain in over byte */
        {
            usOverBits >>= pGSP->usOverScale;
        }
        else                                /* if we've looked at everything */
        {
            pchOver--;

            Assert (pchOver >= pGSP->pchOverLo);
            Assert (pchOver < pGSP->pchOverHi);

            usOverBits = (uint16)*pchOver;
            usGoodBits = 8;
        }

        Assert (pchGray >= pGSP->pchGrayLo);
        Assert (pchGray < pGSP->pchGrayHi);

        *pchGray += chCount[usOverBits & usShiftMask];  /* accumulate count */
        pchGray--;
        sGrayColumns--;
    }
    return NO_ERR;
}

/*********************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\fs\scline.h ===
/*********************************************************************

	  scline.h -- Line Module Exports

	  (c) Copyright 1992  Microsoft Corp.  All rights reserved.

	   3/19/93 deanb    size_t replaced with int32
	  10/28/92 deanb    reentrant params renamed, mem req redone
	  10/09/92 deanb    PSTP added
	   9/25/92 deanb    include scan control type 
	   9/09/92 deanb    GetLineElemSize returns size_t 
	   8/21/92 deanb    GetLineElemSize added 
	   7/23/92 deanb    Back to x2,y2 again 
	   7/17/92 deanb    Changed from longline to line 
	   4/21/92 deanb    Scan lines and on/off added 
	   4/09/92 deanb    New types 
	   4/01/92 deanb    Back to x2,y2 
	   3/20/92 deanb    Reintroduced 
	   1/14/92 deanb    First cut 

**********************************************************************/

#include "fscdefs.h"                /* for type definitions */


/*********************************************************************/

/*              Export Functions                                     */

/*********************************************************************/

FS_PUBLIC void fsc_SetupLine ( PSTATE0 );

FS_PUBLIC int32 fsc_CalcLine( 
		PSTATE              /* pointer to state variables */
		F26Dot6,            /* point 1  x coordinate */
		F26Dot6,            /* point 1  y coordinate */
		F26Dot6,            /* point 2  y coordinate */
		F26Dot6,            /* point 2  y coordinate */
		uint16              /* scan control type */
);

/*********************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\fs\scendpt.h ===
/*********************************************************************

	  scendpt.h -- EndPoint Module Exports

	  (c) Copyright 1992  Microsoft Corp.  All rights reserved.

	   3/19/93 deanb    size_t replaced with int32
	  10/28/92 deanb    reentrant params renamed, mem req redone
	  10/09/92 deanb    PSTP added
	   9/25/92 deanb    include scan control type 
	   9/09/92 deanb    GetEndpointElemSize returns size_t 
	   9/08/92 deanb    GetEndpointElemSize added 
	   7/24/92 deanb    ContourSave functions deleted 
	   4/09/92 deanb    New types again 
	   3/20/92 deanb    New types, save contour functions 
	   1/14/92 deanb    First cut 

**********************************************************************/

#include "fscdefs.h"                /* for type definitions */


/*********************************************************************/

/*              Export Functions                                     */

/*********************************************************************/

FS_PUBLIC void fsc_SetupEndPt ( PSTATE0 );

FS_PUBLIC void fsc_BeginContourEndpoint( 
		PSTATE              /* pointer to state variables */
		F26Dot6,            /* starting point x coordinate */
		F26Dot6             /* starting point y coordinate */
);

FS_PUBLIC int32 fsc_CheckEndPoint( 
		PSTATE              /* pointer to state variables */
		F26Dot6,            /* x coordinate */
		F26Dot6,            /* y coordinate */
		uint16              /* scan control type */
);

FS_PUBLIC int32 fsc_EndContourEndpoint( 
		PSTATE              /* pointer to state variables */
		uint16              /* scan control type */
);

/*********************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\fs\scmemory.c ===
/*********************************************************************

      scmemory.c -- New Scan Converter Memory Managment Module

      (c) Copyright 1992  Microsoft Corp.  All rights reserved.

       6/10/93  deanb   assert.h and stdio.h removed
      10/28/92  deanb   reentrant params renamed
      10/14/92  deanb   New fsc_SetupMem parameters
      10/09/92  deanb   Reentrant
      10/08/92  deanb   Separate Horiz/Vert memory pools
       9/10/92  deanb   First cut 

**********************************************************************/

/*********************************************************************/

/*      Imports                                                      */

/*********************************************************************/

#define FSCFG_INTERNAL

#include    "fscdefs.h"             /* shared data types */
#include    "scglobal.h"            /* structures & constants */
#include    "scmemory.h"            /* for own function prototypes */


/**********************************************************************

    Workspace memory is divided into two pools, identified here as
    HMem (horizontal memory) and VMem (vertical memory).  HMem is
    always used, and contains horizontal scan array lists.  VMem is 
    used only when dropout control is enabled, and contains the 
    vertical scan array lists and the contour elements used to compute 
    subpixel intersections for smart dropout control.  This division 
    into two pools was done, in part, for backward compatiblity with 
    the Apple rasterizer.  It allows a client to force dropout control
    off by setting the allocated size of VMem to zero.

**********************************************************************/
    
/*********************************************************************/

/*      Export Functions      */

/*********************************************************************/

FS_PUBLIC void fsc_SetupMem( 
        PSTATE                           /* pointer to state variables */
        char* pchHBuffer,                /* pointer to horiz workspace */
        int32 lHMemSize,                 /* size of horiz workspace */
        char* pchVBuffer,                /* pointer to vert workspace */
        int32 lVMemSize )                /* size of vert workspace */
{
    STATE.pchHNextAvailable = pchHBuffer;
    STATE.pchHWorkSpaceEnd = pchHBuffer + lHMemSize;
    
    STATE.pchVNextAvailable = pchVBuffer;
    STATE.pchVWorkSpaceEnd = pchVBuffer + lVMemSize;
}


/********************************************************************/

FS_PUBLIC void *fsc_AllocHMem( 
        PSTATE                         /* pointer to state variables  */
        int32 lSize )                  /* requested size in bytes */
{
    void *pvTemp;
    
/* printf("H: %ui   ", lSize); */

    pvTemp = (void*)STATE.pchHNextAvailable;
    ALIGN(voidPtr, lSize); 
    STATE.pchHNextAvailable += lSize;
    
    Assert(STATE.pchHNextAvailable <= STATE.pchHWorkSpaceEnd);
    return pvTemp;
}

/********************************************************************/

FS_PUBLIC void *fsc_AllocVMem( 
        PSTATE                         /* pointer to state variables */
        int32 lSize )                  /* requested size in bytes */
{
    void *pvTemp;

/* printf("V: %ui   ", lSize); */
    
    pvTemp = (void*)STATE.pchVNextAvailable;
    ALIGN(voidPtr, lSize); 
    STATE.pchVNextAvailable += lSize;
    
    Assert(STATE.pchVNextAvailable <= STATE.pchVWorkSpaceEnd);
    return pvTemp;
}

/********************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\fs\scentry.h ===
/*********************************************************************

      scentry.h -- NewScan Module Exports

      (c) Copyright 1992-95  Microsoft Corp.  All rights reserved.

       1/23/95  deanb       added fsc_GetCoords helper function
       9/07/93  deanb       F26Dot6 min/max added to gbmp structure
       8/10/93  deanb       expand interface for gray scale
       6/10/93  deanb       fsc_Initialize added
       4/21/93  deanb       banding params for MeasureGlyph
       3/29/93  deanb       reversal memory added to WorkScan
       3/19/93  deanb       size_t replaced with int32
      12/22/92  deanb       Rectangle -> Rect
      12/21/92  deanb       Interface types aligned with rasterizer
      11/30/92  deanb       WorkSpace renamed WorkScan
      11/05/92  deanb       ulPointCount removed from ContourList
      11/04/92  deanb       RemoveDups function added
      10/14/92  deanb       Exported data structures added
       8/18/92  deanb       Scan type param added 
       8/17/92  deanb       Functions renamed to ..Glyph 
       7/24/92  deanb       Polyline functions deleted 
       4/09/92  deanb       New types 
       3/30/92  deanb       WorkspaceSize renamed MeasureContour 
       3/24/92  deanb       BitMap back to WorkspaceSize 
       3/20/92  deanb       Structs moved to fscdefs.h, params trimmed 
       3/17/92  deanb       Add ulPointCount, rework fcn params 
       3/05/92  deanb       Add data structures 
       3/04/92  deanb       Size reports added 
       2/21/92  deanb       First cut 

*********************************************************************/

#include "fscdefs.h"                /* for type definitions */


/********************************************************************/

/*      Exported Data Structures                                    */

/********************************************************************/

typedef struct
{
    uint16 usContourCount;          /* number of contours */
    int16 *asStartPoint;            /* contour startpoint index array */
    int16 *asEndPoint;              /* contour endpoint index array */
    F26Dot6 *afxXCoord;             /* contour x coordinate array */
    F26Dot6 *afxYCoord;             /* contour y coordinate array */
    uint8 *abyOnCurve;              /* on curve / off curve array */
    uint8 *abyFc;					/* contour flags, one byte for every contour */
}
ContourList;

typedef struct
{
    int16 sRowBytes;                /* bit map width in bytes */
    int16 sHiBand;                  /* upper banding limit */
    int16 sLoBand;                  /* lower banding limit */
    Rect rectBounds;                /* bit map border */
    boolean bZeroDimension;         /* flags zero width or height */
    F26Dot6 fxMinX;                 /* full precision x minimum */
    F26Dot6 fxMaxX;                 /* full precision x maximum */
    F26Dot6 fxMinY;                 /* full precision y minimum */
    F26Dot6 fxMaxY;                 /* full precision y maximum */
    int32 lMMemSize;                /* size of bitmap in bytes */
    char *pchBitMap;                /* pixel bit map */
}
GlyphBitMap;

typedef struct
{
    int32 lRMemSize;                /* workspace bytes for reversal lists */
    int32 lHMemSize;                /* workspace bytes needed for horiz scan */
    int32 lVMemSize;                /* additional workspace for vert scan */
    int32 lHInterCount;             /* estimate of horiz scan intersections */
    int32 lVInterCount;             /* estimate of vert scan intersections */
    int32 lElementCount;            /* estimate of element control points */
    char *pchRBuffer;               /* reversal workspace byte pointer */
    char *pchHBuffer;               /* horiz workspace byte pointer */
    char *pchVBuffer;               /* vert workspace byte pointer */
}
WorkScan;

typedef struct
{
    int16 x;                        /* x pixel value */
    int16 y;                        /* y pixel value */
}
PixCoord;

/*********************************************************************/

/*      Function Exports                                             */

/*********************************************************************

  fsc_Initialize

    This routine calls down to the bitmap module to initialize the
    bitmap masks.  It should be called once, before and scan conversion
    is done.  No harm will be done if it is called more than once.

*/

FS_PUBLIC void fsc_Initialize (
        void
);


/*********************************************************************

  fsc_RemoveDups

    This routine examines a glyph contour by contour and removes any
    duplicated points.  Two subtlties here:  1) following a call to
    this routine, the relation of End[i] + 1 = Start[i + 1] may no
    longer hold (in other words, the contours may not be tightly
    packed);  and 2) two duplicate off curve points will become a
    single ON curve point (this makes sense when you remember that
    between any two offs there must be an on).

  Input Values:

    ContourList -   All values set (pointers to contour arrays)

  Returned Values:
    
    ContourList -   Start, X, Y, and OnCurve arrays may be modified

*/

FS_PUBLIC int32 fsc_RemoveDups( 
        ContourList*        /* glyph outline */
);

/*********************************************************************

  fsc_OverScaleOutline(&Clist, inputPtr->param.gray.usOverScale);

    This routine scales up an outline for gray scale scan conversion

  Input Values:

    ContourList -   All values set (pointers to contour arrays)
    
    uint16      -   usOverScale     Multiplier

  Returned Values:
    
    ContourList -   X and Y arrays will be multiplied by usOverScale

*/

FS_PUBLIC int32 fsc_OverScaleOutline( 
        ContourList*,       /* glyph outline */
        uint16              /* over scale factor */
);

/*********************************************************************

  fsc_MeasureGlyph

    This routine examines a glyph contour by contour and calculates 
    its size and the amount of workspace needed to scan convert it.

  Input Values:

    ContourList -   All values set (pointers to contour arrays)

    WorkScan    -   pchRBuffer      Points to MeasureGlyph workspace used to
                                    store contour reversals.
                    lRMemSize       Size of RBuffer in bytes.  This should be
                                    2 * sizeof(Reversal) * NumberOfPoints to
                                    handle the worst case.
    
    uint16      -   usScanKind      Dropout control code

    uint16      -   usRoundXMin     Allows alignment of XMin for gray scale
                                    XMin modulo usRoundXMin will be zero

  Returned Values:

    WorkScan    -   pchRBuffer      Unchanged
                    lRMemSize       Amount of RBuffer actually used.  This will
                                    typically be much less than the worst case.
                    lHMemSize       Amount of horizontal workspace memory required.
                                    (Memory base 6, always used)
                    lVMemSize       Amount of vertical workspace memory required.
                                    (Memory base 7, used for dropout only)
                    lHInterCount    Estimate of horiz scan intersections
                    lVInterCount    Estimate of vert scan intersections
                    lElementCount   Estimate of element control points

    GlyphBitMap -   sRowBytes       Bytes per row in bitmap (padded to 0 mod 4).
                    rectBounds      Worst case black bounding box.
                    lMMemSize       Size of bitmap in bytes
*/

FS_PUBLIC int32 fsc_MeasureGlyph( 
		ContourList* pclContour,        /* glyph outline */
		GlyphBitMap* pbmpBitMap,        /* to return bounds */
		WorkScan* pwsWork,              /* to return values */
		uint16 usScanKind,              /* dropout control value */
		uint16 usRoundXMin,              /* for gray scale alignment */
		int16 sBitmapEmboldeningHorExtra,
		int16 sBitmapEmboldeningVertExtra );
    
/*********************************************************************

  fsc_MeasureBand

    This routine calculates the amount of workspace needed to scan 
    convert a glyph using banding.

  Input Values:

    WorkScan    -   pchRBuffer      Same value as passed into fsc_MeasureGlyph
                    lHMemSize       Size of horizontal memory from MeasureGlyph
                    lVMemSize       Size of vertical memory from MeasureGlyph
                    lHInterCount    Same value as returned from fsc_MeasureGlyph
                    lVInterCount    Same value as returned from fsc_MeasureGlyph
                    lElementCount   Same value as returned from fsc_MeasureGlyph
    
    uint16      -   usBandType      FS_BANDINGSMALL or FS_BANDINGFAST
    
    uint16      -   usBandWidth     Number of scan lines of maximum band

    uint16      -   usScanKind      Dropout control code

  Returned Values:

    WorkScan    -   pchRBuffer      Unchanged
                    lRMemSize       Unchanged
                    lHMemSize       Amount of horizontal workspace memory required.
                                    (Memory base 6, always used)
                    lVMemSize       Amount of vertical workspace memory required.
                                    (Memory base 7, used for dropout only)
                    lHInterCount    Estimate of horiz band intersections
                    lVInterCount    Unchanged
                    lElementCount   Unchanged

    GlyphBitMap -   sRowBytes       Unchanged
                    rectBounds      Unchanged
                    lMMemSize       Size of bitmap in bytes

*/

FS_PUBLIC int32 fsc_MeasureBand( 
        GlyphBitMap*,        /* computed by MeasureGlyph */
        WorkScan*,           /* to return new values */
        uint16,              /* usBandType = small or fast */
        uint16,              /* usBandWidth = scanline count */
        uint16               /* usScanKind = dropout control value */
);


/*********************************************************************

  fsc_FillGlyph

    This routine is responsible for the actual creation of a bitmap
    from the outline.
    
  Input Values:

    ContourList -   All values set (pointers to contour arrays)

    WorkScan    -   pchRBuffer      Same value as passed into fsc_MeasureGlyph
                    pchHBuffer      Pointer to horizontal workspace memory
                    pchVBuffer      Pointer to vertical workspace memory
                    lHMemSize       Size of horizontal memory (for assertion checks)
                    lVMemSize       Size of vertical memory (for assertion checks)
                    lHInterCount    Same value as returned from fsc_MeasureGlyph
                    lVInterCount    Same value as returned from fsc_MeasureGlyph
                    lElementCount   Same value as returned from fsc_MeasureGlyph

    GlyphBitMap -   pchBitMap       Pointer to bit map output buffer
                    sRowBytes       Same value as returned from fsc_MeasureGlyph
                    rectBounds      Same value as returned from fsc_MeasureGlyph
  
    uint16      -   usBandType      Old, Small, or Fast banding code
    
    uint16      -   usScanKind      Dropout control code

  Returned Values:

    GlyphBitMap -   Bit map output buffer filled in.

*/

FS_PUBLIC int32 fsc_FillGlyph( 
        ContourList*,       /* glyph outline */
        GlyphBitMap*,       /* target */
        WorkScan*,          /* for scan array */
        uint16,             /* banding type */
        uint16              /* scan type */
);

/*********************************************************************

  fsc_CalcGrayMap

    This routine calculates a gray scale bitmap from an overscaled bitmap
    
  Input Values:

    GlyphBitMap1 -  pchBitMap       Pointer to over scaled bit map
                    sRowBytes       Same value as returned from fsc_MeasureGlyph
                    rectBounds      Same value as returned from fsc_MeasureGlyph
    
    GlyphBitMap2 -  pchBitMap       Pointer to gray scale bit map output buffer
                    sRowBytes       1 byte per pixel
                    rectBounds      Same value as returned from fsc_MeasureExtrema
    
    uint16       -  usOverScale     Gray scale contour multiplier
  
  Returned Values:

    GlyphBitMap2 -  Gray scale bit map output buffer filled in.

*/

FS_PUBLIC int32 fsc_CalcGrayMap( 
        GlyphBitMap*,       /* over scaled source */
        GlyphBitMap*,       /* gray scale target */
        uint16              /* over scale factor */
);


/*********************************************************************

  fsc_GetCoords

    This routine returns an array of coordinates for outline points
    
  Input Values:

    ContourList -   All values set (pointers to contour arrays)
    
    uint16      -   usPointCount    Number of points to look up

    uint16*     -   pusPointIndex   Array of point indices
  
  Returned Values:

    pxyCoords   -   Array of (x,y) integer (pixel) coordinates

*/

FS_PUBLIC int32 fsc_GetCoords(
        ContourList*,       /* glyph outline */
        uint16,             /* point count */
        uint16*,            /* point indices */
        PixCoord*           /* point coordinates */
);

 /*********************************************************************/

#ifdef FSCFG_SUBPIXEL

/*********************************************************************

  fsc_OverscaleToSubPixel

    This routine is the heart of the RGB striping algorithm
    
  Input Values:

    OverscaledBitmap
  
  Returned Values:

    SubPixelBitMap

*/

FS_PUBLIC void fsc_OverscaleToSubPixel (
    GlyphBitMap * OverscaledBitmap, 
	boolean bgrOrder, 
    GlyphBitMap * SubPixelBitMap
);

 /*********************************************************************/

#endif // FSCFG_SUBPIXEL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\fs\scspline.h ===
/*********************************************************************

	  scspline.h -- Spline Module Exports

	  (c) Copyright 1992  Microsoft Corp.  All rights reserved.

	   3/19/93 deanb    size_t replaced with int32
	  10/28/92 deanb    reentrant params renamed, mem req redone
	  10/09/92 deanb    PSTATE added
	   9/25/92 deanb    include scan control type 
	   9/09/92 deanb    GetSplineElemSize returns size_t 
	   9/08/92 deanb    MAXSPLINELENGTH added 
	   8/17/92 deanb    PowerOf2 moved to math 
	   7/23/92 deanb    EvaluateSpline replaced with CalcSpline + PowerOf2 
	   4/09/92 deanb    New types again 
	   3/16/92 deanb    New types 
	   1/14/92 deanb    First cut 

*********************************************************************/

#include "fscdefs.h"                /* for type definitions */


/*********************************************************************/

/*              Export Functions                                     */

/*********************************************************************/

FS_PUBLIC void fsc_SetupSpline ( PSTATE0 );

FS_PUBLIC int32 fsc_CalcSpline( 
		PSTATE          /* pointer to state varables */
		F26Dot6,        /* start point x coordinate */
		F26Dot6,        /* start point y coordinate */
		F26Dot6,        /* control point x coordinate */
		F26Dot6,        /* control point y coordinate */
		F26Dot6,        /* ending x coordinate */
		F26Dot6,        /* ending y coordinate */
		uint16          /* scan control type */
);

/********************************************************************/

/*              Export Definitions                                  */

/********************************************************************/

#define MAXSPLINELENGTH     3200        /* calculation overflow limit */

/********************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\fs\scendpt.c ===
/*********************************************************************

	  scendpt.c -- New Scan Converter EndPoint Module

	  (c) Copyright 1992  Microsoft Corp.  All rights reserved.

	   6/10/93  deanb   assert.h and stdio.h removed
	   3/19/93  deanb   size_t replaced with int32
	  10/28/92  deanb   reentrant params renamed
	  10/09/92  deanb   reentrant
	   9/25/92  deanb   branch on scan kind 
	   9/14/92  deanb   check vert topology written 
	   9/10/92  deanb   first dropout code 
	   8/18/92  deanb   include struc.h, scconst.h 
	   6/18/92  deanb   int x coord for HorizScanAdd 
	   5/08/92  deanb   reordered includes for precompiled headers 
	   4/21/92  deanb   Single HorizScanAdd 
	   4/09/92  deanb   New types 
	   4/06/92  deanb   Check Topology corrected 
	   4/02/92  deanb   Coded 
	   3/23/92  deanb   First cut 

**********************************************************************/

/*********************************************************************/

/*      Imports                                                      */

/*********************************************************************/

#define FSCFG_INTERNAL

#include    "fscdefs.h"             /* shared data types */
#include    "fserror.h"             /* error codes */

#include    "scglobal.h"            /* structures & constants */
#include    "scanlist.h"            /* saves scan line intersections */
#include    "scendpt.h"             /* for own function prototypes */

/*********************************************************************/

/*      Local Prototypes                                             */

/*********************************************************************/

FS_PRIVATE void CheckHorizTopology( PSTATE F26Dot6, F26Dot6, uint16 );
FS_PRIVATE void CheckVertTopology( PSTATE F26Dot6, F26Dot6, uint16 );

FS_PRIVATE void AddHorizOn( PSTATE uint16 );
FS_PRIVATE void AddHorizOff( PSTATE uint16 );
FS_PRIVATE void AddVertOn( PSTATE uint16 );
FS_PRIVATE void AddVertOff( PSTATE uint16 );

FS_PRIVATE F26Dot6 CalcHorizEpSubpix( int32, F26Dot6*, F26Dot6* );
FS_PRIVATE F26Dot6 CalcVertEpSubpix( int32, F26Dot6*, F26Dot6* );


/*********************************************************************/

/*      Export Functions                                             */

/*********************************************************************/

/*  pass callback routine pointers to scanlist for smart dropout control */

FS_PUBLIC void fsc_SetupEndPt (PSTATE0) 
{
	fsc_SetupCallBacks(ASTATE SC_ENDPTCODE, CalcHorizEpSubpix, CalcVertEpSubpix);
}

/*********************************************************************/

FS_PUBLIC void fsc_BeginContourEndpoint( 
		PSTATE               /* pointer to state variables */
		F26Dot6 fxX,         /* starting point x coordinate */
		F26Dot6 fxY )        /* starting point y coordinate */
{
	STATE.fxX1 = fxX;                   /* last = contour start point */
	STATE.fxY1 = fxY;
	STATE.fxX0 = HUGEFIX;               /* contour begin alert */
}


/*********************************************************************/

FS_PUBLIC int32 fsc_CheckEndPoint( 
		PSTATE               /* pointer to state variables */
		F26Dot6 fxX2,        /* x coordinate */
		F26Dot6 fxY2,        /* y coordinate */
		uint16 usScanKind )  /* dropout control type */
{
	if (ONSCANLINE(STATE.fxY1))             /* if y1 is on scan line */
	{
		if ((STATE.fxX1 == fxX2) && (STATE.fxY1 == fxY2)) /* catch dup'd points */
		{
			return NO_ERR;                  /*   and just ignore them   */
		}
				
		if (STATE.fxX0 == HUGEFIX)          /* if contour begin */
		{
			STATE.fxX2Save = fxX2;          /*   keep for contour end   */
			STATE.fxY2Save = fxY2;          
		}
		else                                /* if mid contour */
		{
			CheckHorizTopology(ASTATE fxX2, fxY2, usScanKind);
		}               
	}
	
	if (!(usScanKind & SK_NODROPOUT))       /* if dropout control on */
	{
		if (ONSCANLINE(STATE.fxX1))         /* if x1 is on scan line */
		{
			if ((STATE.fxX1 == fxX2) && (STATE.fxY1 == fxY2)) /* catch dup'd points */
			{
				return NO_ERR;              /*   and just ignore them   */
			}
				
			if (STATE.fxX0 == HUGEFIX)      /* if contour begin */
			{
				STATE.fxX2Save = fxX2;      /*   keep for contour end   */
				STATE.fxY2Save = fxY2;
			}
			else                            /* if mid contour */
			{
				CheckVertTopology(ASTATE fxX2, fxY2, usScanKind);
			}               
		}
	}

	STATE.fxX0 = STATE.fxX1;                /* old = last */
	STATE.fxY0 = STATE.fxY1;
	STATE.fxX1 = fxX2;                      /* last = current */
	STATE.fxY1 = fxY2;
	
	return NO_ERR;
}


/*********************************************************************/

FS_PUBLIC int32 fsc_EndContourEndpoint( 
		PSTATE                          /* pointer to state variables */
		uint16 usScanKind )             /* dropout control type */
{
	if (ONSCANLINE(STATE.fxY1))             /* if y1 is on scan line */
	{
		CheckHorizTopology(ASTATE STATE.fxX2Save, STATE.fxY2Save, usScanKind);
	}
	
	if (!(usScanKind & SK_NODROPOUT))       /* if dropout control on */
	{
		if (ONSCANLINE(STATE.fxX1))         /* if x1 is on scan line */
		{
			CheckVertTopology(ASTATE STATE.fxX2Save, STATE.fxY2Save, usScanKind);
		}
	}
	return NO_ERR;
}

/*********************************************************************/

/*      Private Functions      */

/*********************************************************************/

/*      Implement the endpoint-on-horiz-scanline case table    */

FS_PRIVATE void CheckHorizTopology(PSTATE F26Dot6 fxX2, F26Dot6 fxY2, uint16 usScanKind)
{

/* printf("(%li, %li)", fxX2, fxY2); */

	if (fxY2 > STATE.fxY1)
	{
		if (STATE.fxY1 > STATE.fxY0)
		{
			AddHorizOn(ASTATE usScanKind);
		}
		else if (STATE.fxY1 < STATE.fxY0)
		{
			AddHorizOn(ASTATE usScanKind);
			AddHorizOff(ASTATE usScanKind);
		}
		else                    /* (STATE.fxY1 == STATE.fxY0) */
		{
			if (STATE.fxX1 < STATE.fxX0)
			{
				AddHorizOn(ASTATE usScanKind);
			}
		}
	}
	else if (fxY2 < STATE.fxY1)
	{
		if (STATE.fxY1 > STATE.fxY0)
		{
			AddHorizOn(ASTATE usScanKind);
			AddHorizOff(ASTATE usScanKind);
		}
		else if (STATE.fxY1 < STATE.fxY0)
		{
			AddHorizOff(ASTATE usScanKind);
		}
		else                    /* (STATE.fxY1 == STATE.fxY0) */
		{
			if (STATE.fxX1 > STATE.fxX0)
			{
				AddHorizOff(ASTATE usScanKind);
			}
		}
	}
	else                        /* (fxY2 == STATE.fxY1) */
	{
		if (STATE.fxY1 > STATE.fxY0)
		{
			if (fxX2 > STATE.fxX1)
			{
				AddHorizOn(ASTATE usScanKind);
			}
		}
		else if (STATE.fxY1 < STATE.fxY0)
		{
			if (fxX2 < STATE.fxX1)
			{
				AddHorizOff(ASTATE usScanKind);
			}
		}
		else                    /* (STATE.fxY1 == STATE.fxY0) */
		{
			if ((STATE.fxX1 > STATE.fxX0) && (fxX2 < STATE.fxX1))
			{
				AddHorizOff(ASTATE usScanKind);
			}
			else if ((STATE.fxX1 < STATE.fxX0) && (fxX2 > STATE.fxX1))
			{
				AddHorizOn(ASTATE usScanKind);
			}
		}
	}
}


/*********************************************************************/

/*      Implement the endpoint-on-vert-scanline case table      */

FS_PRIVATE void CheckVertTopology(PSTATE F26Dot6 fxX2, F26Dot6 fxY2, uint16 usScanKind)
{
	if (fxX2 < STATE.fxX1)
	{
		if (STATE.fxX1 < STATE.fxX0)
		{
			AddVertOn(ASTATE usScanKind);
		}
		else if (STATE.fxX1 > STATE.fxX0)
		{
			AddVertOn(ASTATE usScanKind);
			AddVertOff(ASTATE usScanKind);
		}
		else                    /* (STATE.fxX1 == STATE.fxX0) */
		{
			if (STATE.fxY1 < STATE.fxY0)
			{
				AddVertOn(ASTATE usScanKind);
			}
		}
	}
	else if (fxX2 > STATE.fxX1)
	{
		if (STATE.fxX1 < STATE.fxX0)
		{
			AddVertOn(ASTATE usScanKind);
			AddVertOff(ASTATE usScanKind);
		}
		else if (STATE.fxX1 > STATE.fxX0)
		{
			AddVertOff(ASTATE usScanKind);
		}
		else                    /* (STATE.fxX1 == STATE.fxX0) */
		{
			if (STATE.fxY1 > STATE.fxY0)
			{
				AddVertOff(ASTATE usScanKind);
			}
		}
	}
	else                        /* (fxX2 == STATE.fxX1) */
	{
		if (STATE.fxX1 < STATE.fxX0)
		{
			if (fxY2 > STATE.fxY1)
			{
				AddVertOn(ASTATE usScanKind);
			}
		}
		else if (STATE.fxX1 > STATE.fxX0)
		{
			if (fxY2 < STATE.fxY1)
			{
				AddVertOff(ASTATE usScanKind);
			}
		}
		else                    /* (STATE.fxX1 == STATE.fxX0) */
		{
			if ((STATE.fxY1 > STATE.fxY0) && (fxY2 < STATE.fxY1))
			{
				AddVertOff(ASTATE usScanKind);
			}
			else if ((STATE.fxY1 < STATE.fxY0) && (fxY2 > STATE.fxY1))
			{
				AddVertOn(ASTATE usScanKind);
			}
		}
	}
}


/*********************************************************************/
	
FS_PRIVATE void AddHorizOn( PSTATE uint16 usScanKind )
{
	int32 lXScan, lYScan;
	void (*pfnAddHorizScan)(PSTATE int32, int32);
	void (*pfnAddVertScan)(PSTATE int32, int32);
	
	fsc_BeginElement( ASTATE usScanKind, 1, SC_ENDPTCODE,   /* quadrant and what */
					  0, NULL, NULL,                        /* number of pts */
					  &pfnAddHorizScan, &pfnAddVertScan );  /* what to call */
	
	lXScan = (int32)((STATE.fxX1 + SUBHALF - 1) >> SUBSHFT);
	lYScan = (int32)(STATE.fxY1 >> SUBSHFT);
	
	pfnAddHorizScan(ASTATE lXScan, lYScan);
}


/*********************************************************************/
	
FS_PRIVATE void AddHorizOff( PSTATE uint16 usScanKind )
{
	int32 lXScan, lYScan;
	void (*pfnAddHorizScan)(PSTATE int32, int32);
	void (*pfnAddVertScan)(PSTATE int32, int32);
	
	fsc_BeginElement( ASTATE usScanKind, 4, SC_ENDPTCODE,   /* quadrant and what */
					  0, NULL, NULL,                        /* number of pts */
					  &pfnAddHorizScan, &pfnAddVertScan );  /* what to call */

	lXScan = (int32)((STATE.fxX1 + SUBHALF) >> SUBSHFT);
	lYScan = (int32)(STATE.fxY1 >> SUBSHFT);
	
	pfnAddHorizScan(ASTATE lXScan, lYScan);
}


/*********************************************************************/
	
FS_PRIVATE void AddVertOn( PSTATE uint16 usScanKind )
{
	int32 lXScan, lYScan;
	void (*pfnAddHorizScan)(PSTATE int32, int32);
	void (*pfnAddVertScan)(PSTATE int32, int32);
	
	fsc_BeginElement( ASTATE usScanKind, 2, SC_ENDPTCODE,   /* quadrant and what */
					  0, NULL, NULL,                        /* number of pts */
					  &pfnAddHorizScan, &pfnAddVertScan );  /* what to call */

	lYScan = (int32)((STATE.fxY1 + SUBHALF - 1) >> SUBSHFT);
	lXScan = (int32)(STATE.fxX1 >> SUBSHFT);
	
	pfnAddVertScan(ASTATE lXScan, lYScan);
}


/*********************************************************************/
	
FS_PRIVATE void AddVertOff( PSTATE uint16 usScanKind )
{
	int32 lXScan, lYScan;
	void (*pfnAddHorizScan)(PSTATE int32, int32);
	void (*pfnAddVertScan)(PSTATE int32, int32);
	
	fsc_BeginElement( ASTATE usScanKind, 1, SC_ENDPTCODE,   /* quadrant and what */
					  0, NULL, NULL,                        /* number of pts */
					  &pfnAddHorizScan, &pfnAddVertScan );  /* what to call */

	lYScan = (int32)((STATE.fxY1 + SUBHALF) >> SUBSHFT);
	lXScan = (int32)(STATE.fxX1 >> SUBSHFT);
	
	pfnAddVertScan(ASTATE lXScan, lYScan);
}


/*********************************************************************/

/*      Private Callback Functions                                   */

/*********************************************************************/

FS_PRIVATE F26Dot6 CalcHorizEpSubpix(int32 lYScan, 
									 F26Dot6 *pfxX, 
									 F26Dot6 *pfxY )
{
	FS_UNUSED_PARAMETER(lYScan);
	FS_UNUSED_PARAMETER(pfxY);

/* printf("HorizEndpt(%li %li)\n", *pfxX, *pfxY); */

	return *pfxX;                           /* exact intersection */
}


/*********************************************************************/

FS_PRIVATE F26Dot6 CalcVertEpSubpix(int32 lXScan, 
									F26Dot6 *pfxX, 
									F26Dot6 *pfxY )
{
	FS_UNUSED_PARAMETER(lXScan);
	FS_UNUSED_PARAMETER(pfxX);

/* printf("VertEndpt (%li %li)\n", *pfxX, *pfxY); */

	return *pfxY;                           /* exact intersection */
}


/*********************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\fs\scentry.c ===
/*********************************************************************

	  scentry.c -- New Scan Converter NewScan Module

	  (c) Copyright 1992-1997  Microsoft Corp.  All rights reserved.

	  10/14/97  claudebe    accessing unitialized memory
	   1/31/95  deanb       added fsc_GetCoords function
	   8/04/94  deanb       State initialized to more it out of bss
	   8/24/93  deanb       flatcount fix to reversal detection
	   8/10/93  deanb       gray scale support routines added
	   6/22/93  deanb       all black bounding box, (0,0) for null glyph
	   6/11/93  gregh       Removed ONCURVE definition
	   6/11/93  deanb       if HiBand <= LoBand do entire bitmap
	   6/10/93  deanb       fsc_Initialize added, stdio & assert gone
	   4/06/92  deanb       CheckContour removed
	   3/19/92  deanb       ScanArrays rather than lists
	  12/22/92  deanb       MultDivide -> LongMulDiv; Rectangle -> Rect
	  12/21/92  deanb       interface types aligned with rasterizer
	  12/11/92  deanb       fserror.h imported, new error codes
	  11/30/92  deanb       WorkSpace renamed WorkScan
	  11/04/92  deanb       remove duplicate points function added
	  10/28/92  deanb       memory requirement calculation reworked
	  10/19/92  deanb       bad contours ignored rather than error'd
	  10/16/92  deanb       first contour point off curve fix
	  10/13/92  deanb       rect.bounds correction
	  10/12/92  deanb       reentrant State implemented
	  10/08/92  deanb       reworked for split workspace
	  10/05/92  deanb       global ListMemory replace with stListSize 
	   9/25/92  deanb       scankind included in line/spline/endpoint calls 
	   9/10/92  deanb       dropout coding begun 
	   9/08/92  deanb       MAXSPLINELENGTH now imported from scspline.h 
	   8/18/92  deanb       New i/f for dropout control, contour elems 
	   7/28/92  deanb       Recursive calls for up/down & left/right 
	   7/23/92  deanb       EvaluateSpline included 
	   7/17/92  deanb       Included EvaluateLine 
	   7/13/92  deanb       Start/End point made SHORT 
	   6/01/92  deanb       fsc_FillBitMap debug switch added 
	   5/08/92  deanb       reordered includes for precompiled headers 
	   4/27/92  deanb       Splines coded 
	   4/09/92  deanb       New types 
	   4/06/92  deanb       rectBounds calc corrected 
	   3/30/92  deanb       MinMax calc added to MeasureContour 
	   3/24/92  deanb       GetWorkspaceSize coded 
	   3/23/92  deanb       First cut 
 
**********************************************************************/

/*********************************************************************/

/*        Imports                                                    */

/*********************************************************************/

#define FSCFG_INTERNAL

#include    "fscdefs.h"             /* shared data types  */
#include    "fserror.h"             /* error codes */
#include    "fontmath.h"            /* for LongMulDiv */

#include    "scglobal.h"            /* structures & constants */
#include    "scgray.h"              /* gray scale param block */
#include    "scspline.h"            /* spline evaluation */
#include    "scline.h"              /* line evaluation */
#include    "scendpt.h"             /* for init and contour list */
#include    "scanlist.h"            /* for init and bitmap */
#include    "scmemory.h"            /* for setup mem */
#include    "scentry.h"             /* for own function prototypes */

/*********************************************************************/
											 
/*      Global state structure                                       */

/*********************************************************************/

#ifndef FSCFG_REENTRANT
	
FS_PUBLIC StateVars   State = {0};  /* global static:  available to all */

#endif

/*********************************************************************/
											 
/*      Local Prototypes                                             */

/*********************************************************************/

FS_PRIVATE int32 FindExtrema(ContourList*, GlyphBitMap*);

FS_PRIVATE int32 EvaluateSpline(PSTATE F26Dot6, F26Dot6, F26Dot6, F26Dot6, F26Dot6, F26Dot6, uint16 );


/*********************************************************************/
											 
/*      Function Exports                                             */

/*********************************************************************/

/*      Initialization Functions                                     */

/*********************************************************************/

FS_PUBLIC void fsc_Initialize()
{
	fsc_InitializeScanlist();               /* scanlist calls to bitmap */
}


/*********************************************************************/

/*  Remove duplicated points from contour data                       */

/*  This was previously done in sc_FindExtrema of sc.c,              */
/*  but was pulled out to avoid having fsc_MeasureGlyph              */
/*  make changes to the contour list data structure.                 */

/*********************************************************************/

FS_PUBLIC int32 fsc_RemoveDups( 
		ContourList* pclContour )           /* glyph outline */
{
	uint16 usContour;                       /* contour limit */
	int16 sStartPt, sEndPt;                 /* coutour index limits */
	int16 sPt;                              /* point index */
	int16 s;                                /* index for list collapse */
	F26Dot6 *pfxX1, *pfxY1;                 /* leading point */
	F26Dot6 fxX2, fxY2;                     /* trailing point */

	for (usContour = 0; usContour < pclContour->usContourCount; usContour++)
	{
		sStartPt = pclContour->asStartPoint[usContour];
		sEndPt = pclContour->asEndPoint[usContour];
		
		pfxX1 = &(pclContour->afxXCoord[sStartPt]); 
		pfxY1 = &(pclContour->afxYCoord[sStartPt]); 
					
		for (sPt = sStartPt; sPt < sEndPt; ++sPt)
		{
			fxX2 = *pfxX1;                          /* check next pair */
			pfxX1++;
			fxY2 = *pfxY1;
			pfxY1++;
			
			if ((*pfxX1 == fxX2) && (*pfxY1 == fxY2))   /* if duplicate */
			{
				for(s = sPt; s > sStartPt; s--)     /* s = index of point to be removed */
				{
					pclContour->afxXCoord[s] = pclContour->afxXCoord[s - 1];
					pclContour->afxYCoord[s] = pclContour->afxYCoord[s - 1];
					pclContour->abyOnCurve[s] = pclContour->abyOnCurve[s - 1];
				}
				sStartPt++;                         /* advance start past dup */
				pclContour->asStartPoint[usContour] = sStartPt;
				pclContour->abyOnCurve[sPt + 1] |= ONCURVE; /* dup'd pt must be on curve */
			}
		}
		
		/* now pfxX1 and pfxY1 point to end point coordinates */

		if (sStartPt != sEndPt)                     /* finished if single point */
		{
			fxX2 = pclContour->afxXCoord[sStartPt];
			fxY2 = pclContour->afxYCoord[sStartPt];
								
			if ((*pfxX1 == fxX2) && (*pfxY1 == fxY2))   /* if start = end */
			{
				pclContour->asStartPoint[usContour]++;
				pclContour->abyOnCurve[sEndPt] |= ONCURVE;  /* dup'd pt must be on curve */
			}
		}
	}
	return NO_ERR;
}


/*********************************************************************/

/*  Calculate the amount of workspace needed to scan convert         */
/*  a given glyph into a given bitmap.  Get per intersection and     */
/*  per scanline size info from ScanList module.                     */

/*********************************************************************/

FS_PUBLIC int32 fsc_MeasureGlyph( 
		ContourList* pclContour,        /* glyph outline */
		GlyphBitMap* pbmpBitMap,        /* to return bounds */
		WorkScan* pwsWork,              /* to return values */
		uint16 usScanKind,              /* dropout control value */
		uint16 usRoundXMin,              /* for gray scale alignment */
		int16 sBitmapEmboldeningHorExtra,
		int16 sBitmapEmboldeningVertExtra )
{
	uint16 usCont;                      /* contour index */
	int16 sPt;                          /* point index */
	int16 sStart, sEnd;                 /* start and end point of contours */
	int16 sOrgDir;                      /* original contour direction */
	int16 sDir;                         /* current contour direction */
	int16 sFlatCount;                   /* for contours starting flat */
	int32 lVScanCount;                  /* total vertical scan lines */
	int32 lHScanCount;                  /* total horizontal scan lines */
	int32 lTotalHIx;
	int32 lTotalVIx;
	int32 lElementCount;                /* total element point estimate */
	int32 lDivide;                      /* spline element point counter */
	int32 lErrCode;    
	
	F26Dot6 fxX1, fxX2;                 /* x coord endpoints */
	F26Dot6 fxY1, fxY2;                 /* y coord endpoints */
	F26Dot6 *pfxXCoord, *pfxYCoord;     /* for fast point array access */
	F26Dot6 fxAbsDelta;                 /* for element count check */
	uint8 byF1, byF2;                   /* oncurve flag values */
	uint8 *pbyFlags;                    /* for element count check */

	PRevRoot prrRoots;                  /* reversal list roots structure */

	
	lErrCode = FindExtrema(pclContour, pbmpBitMap); /* calc bounding box */
	if (lErrCode != NO_ERR) return lErrCode;

	pbmpBitMap->rectBounds.left &= -((int32)usRoundXMin);   /* mask off low n bits */

	/* bitmap emboldening by 2% + 1 pixel horizontally, 2% vertically */
	if ((pbmpBitMap->rectBounds.top != pbmpBitMap->rectBounds.bottom) && (pbmpBitMap->rectBounds.left != pbmpBitMap->rectBounds.right))
	{
 		// we don't want to increase the size of the bitmap on a empty glyph
		if (sBitmapEmboldeningHorExtra > 0)
		{
			pbmpBitMap->rectBounds.right += sBitmapEmboldeningHorExtra;
		}
		else
		{
			pbmpBitMap->rectBounds.left += sBitmapEmboldeningHorExtra;
		}
		if (sBitmapEmboldeningVertExtra > 0)
		{
			pbmpBitMap->rectBounds.bottom -= (sBitmapEmboldeningVertExtra);
		}
		else
		{
			pbmpBitMap->rectBounds.top -= (sBitmapEmboldeningVertExtra);
		}
	}

	prrRoots = fsc_SetupRevRoots(pwsWork->pchRBuffer, pwsWork->lRMemSize);
	lElementCount = 0;                  /* smart point counter */
	
	for (usCont = 0; usCont < pclContour->usContourCount; usCont++)
	{
		sStart = pclContour->asStartPoint[usCont];
		sEnd = pclContour->asEndPoint[usCont];
		if (sStart == sEnd)
		{
			continue;                               /* for anchor points */
		}

/* check contour Y values for direction reversals */

		fxY1 = pclContour->afxYCoord[sEnd];         /* start by closing */
		pfxYCoord = &pclContour->afxYCoord[sStart];

		sPt = sStart;
		sDir = 0;                                   /* starting dir unknown */
		sFlatCount = 0;
		while ((sDir == 0) && (sPt <= sEnd))
		{
			fxY2 = *pfxYCoord++;
			if (fxY2 > fxY1)                        /* find first up or down */
			{
				sDir = 1;
			}
			else if (fxY2 < fxY1)
			{
				sDir = -1;
			}
			else
			{
				sFlatCount++;                       /* countour starts flat */
			}
			fxY1 = fxY2;
			sPt++;
		}
		sOrgDir = sDir;                             /* save original ep check */

		while (sPt <= sEnd)
		{
			fxY2 = *pfxYCoord++;
			if (sDir == 1)
			{
				if (fxY2 <= fxY1)                   /* = is for endpoint cases */
				{
					fsc_AddYReversal (prrRoots, fxY1, 1);
					sDir = -1;
				}
			}
			else    /* if sDir == -1 */
			{
				if (fxY2 >= fxY1)                   /* = is for endpoint cases */
				{
					fsc_AddYReversal (prrRoots, fxY1, -1);
					sDir = 1;
				}
			}
			fxY1 = fxY2;                            /* next segment */
			sPt++;
		}
								
		while (sFlatCount > 0)                      /* if contour started flat */
		{
			if (sDir == 0)                          /* if completely flat */
			{
				sDir = 1;                           /* then pick a direction */
				sOrgDir = 1;
			}
			fsc_AddYReversal (prrRoots, fxY1, sDir); /* add one per point */
			sDir = -sDir;
			sFlatCount--;
		}
		if (sOrgDir != sDir)                        /* if endpoint reverses */
		{
			fsc_AddYReversal (prrRoots, fxY1, sDir); /* then balance up/down */
		}

/* if doing dropout control, check contour X values for direction reversals */

		if (!(usScanKind & SK_NODROPOUT))           /* if any kind of dropout */
		{
			fxX1 = pclContour->afxXCoord[sEnd];     /* start by closing */
			pfxXCoord = &pclContour->afxXCoord[sStart];

			sPt = sStart;
			sDir = 0;                               /* starting dir unknown */
			sFlatCount = 0;
			while ((sDir == 0) && (sPt <= sEnd))
			{
				fxX2 = *pfxXCoord++;
				if (fxX2 > fxX1)                    /* find first up or down */
				{
					sDir = 1;
				}
				else if (fxX2 < fxX1)
				{
					sDir = -1;
				}
				else
				{
					sFlatCount++;                   /* countour starts flat */
				}
				fxX1 = fxX2;
				sPt++;
			}
			sOrgDir = sDir;                         /* save original ep check */

			while (sPt <= sEnd)
			{
				fxX2 = *pfxXCoord++;
				if (sDir == 1)
				{
					if (fxX2 <= fxX1)               /* = is for endpoint cases */
					{
						fsc_AddXReversal (prrRoots, fxX1, 1);
						sDir = -1;
					}
				}
				else    /* if sDir == -1 */
				{
					if (fxX2 >= fxX1)               /* = is for endpoint cases */
					{
						fsc_AddXReversal (prrRoots, fxX1, -1);
						sDir = 1;
					}
				}
				fxX1 = fxX2;                        /* next segment */
				sPt++;
			}
									
			while (sFlatCount > 0)                  /* if contour started flat */
			{
				if (sDir == 0)                      /* if completely flat */
				{
					sDir = 1;                       /* then pick a direction */
					sOrgDir = 1;
				}
				fsc_AddXReversal (prrRoots, fxX1, sDir); /* add one per point */
				sDir = -sDir;
				sFlatCount--;
			}
			if (sOrgDir != sDir)                    /* if endpoint reverses */
			{
				fsc_AddXReversal (prrRoots, fxX1, sDir); /* then balance up/down */
			}

			if (usScanKind & SK_SMART)              /* if smart dropout control */
			{                                       /* estimate the elem point count */
				fxX1 = pclContour->afxXCoord[sEnd];
				fxY1 = pclContour->afxYCoord[sEnd];
				byF1 = pclContour->abyOnCurve[sEnd];
				pfxXCoord = &pclContour->afxXCoord[sStart];
				pfxYCoord = &pclContour->afxYCoord[sStart];
				pbyFlags = &pclContour->abyOnCurve[sStart];

				lElementCount += (uint32)(sEnd - sStart) + 2L;  /* 1/pt + 1/contour */

				for (sPt = sStart; sPt <= sEnd; sPt++)
				{
					fxX2 = *pfxXCoord++;
					fxY2 = *pfxYCoord++;
					byF2 = *pbyFlags++;

					if (((byF1 & byF2) & ONCURVE) == 0) /* if this is a spline */
					{
						if (((byF1 | byF2) & ONCURVE) == 0)
						{
							lElementCount++;            /* +1 for midpoint */
						}
								
						if (FXABS(fxX2 - fxX1) > FXABS(fxY2 - fxY1))
						{
							fxAbsDelta = FXABS(fxX2 - fxX1);
						}
						else
						{
							fxAbsDelta = FXABS(fxY2 - fxY1);
						}
						lDivide = 0;
						while (fxAbsDelta > (MAXSPLINELENGTH / 2))
						{
							lDivide++;
							lDivide <<= 1;
							fxAbsDelta >>= 1;
						}
						lElementCount += lDivide;   /* for subdivision */
					}
					fxX1 = fxX2;
					fxY1 = fxY2;
					byF1 = byF2;
				}
			}
		}
	}
	if (!(usScanKind & SK_NODROPOUT) && (usScanKind & SK_SMART))  /* if smart dropout */
	{
		lElementCount += fsc_GetReversalCount(prrRoots) << 1;  /* add in 2 * reversals */
		if (lElementCount > (0xFFFF >> SC_CODESHFT))
		{
			return SMART_DROP_OVERFLOW_ERR;
		}
	}

		
/*  set horiz workspace return values */

	lHScanCount = (int32)(pbmpBitMap->rectBounds.top - pbmpBitMap->rectBounds.bottom);
	lVScanCount = (int32)(pbmpBitMap->rectBounds.right - pbmpBitMap->rectBounds.left);
	
	pbmpBitMap->sRowBytes = (int16)ROWBYTESLONG(lVScanCount);
	pbmpBitMap->lMMemSize = (lHScanCount * (int32)pbmpBitMap->sRowBytes);
	
	lTotalHIx = fsc_GetHIxEstimate(prrRoots);   /* intersection count */
	pwsWork->lHMemSize = fsc_GetScanHMem(usScanKind, lHScanCount, lTotalHIx);

/*  set vertical workspace return values */
	
	if (usScanKind & SK_NODROPOUT)                  /* if no dropout */
	{
		pwsWork->lVMemSize = 0L;
		lTotalVIx = 0;
	}
	else
	{
		lTotalVIx = fsc_GetVIxEstimate(prrRoots);   /* estimate intersection count */
		pwsWork->lVMemSize = fsc_GetScanVMem(usScanKind, lVScanCount, lTotalVIx, lElementCount);
	}
	
	pwsWork->lHInterCount = lTotalHIx;              /* save for SetupScan */
	pwsWork->lVInterCount = lTotalVIx;
	pwsWork->lElementCount = lElementCount;
	pwsWork->lRMemSize = fsc_GetRevMemSize(prrRoots);

#ifdef FSCFG_REENTRANT
	
	pwsWork->lHMemSize += sizeof(StateVars);        /* reentrant state space */

#endif

	return NO_ERR;
} 


/*********************************************************************/

/*  Calculate the amount of workspace needed to scan convert         */
/*  a given band into a given bitmap.  Get per intersection and      */
/*  per scanline size info from ScanList module.                     */

/*********************************************************************/

FS_PUBLIC int32 fsc_MeasureBand( 
		GlyphBitMap* pbmpBitMap,        /* computed by MeasureGlyph */
		WorkScan* pwsWork,              /* to return new values */
		uint16 usBandType,              /* small or fast */
		uint16 usBandWidth,             /* scanline count */
		uint16 usScanKind )             /* dropout control value */
{
	int32 lBandWidth;                   /* max scanline count */
	int32 lTotalHIx;                    /* est of horiz intersections in band */
	int32 lVScanCount;                  /* total vertical scan lines */
	int32 lHScanCount;                  /* total horizontal scan lines */

	lBandWidth = (int32)usBandWidth;
	pbmpBitMap->lMMemSize = (lBandWidth * (int32)pbmpBitMap->sRowBytes);
	
	if (usBandType == FS_BANDINGSMALL) 
	{
		lTotalHIx = fsc_GetHIxBandEst((PRevRoot)pwsWork->pchRBuffer, &pbmpBitMap->rectBounds, lBandWidth);
		pwsWork->lHInterCount = lTotalHIx;  /* save for SetupScan */
		pwsWork->lHMemSize = fsc_GetScanHMem(usScanKind, lBandWidth, lTotalHIx);
		pwsWork->lVMemSize = 0L;            /* force dropout control off */
	}
	else if (usBandType == FS_BANDINGFAST) 
	{
		lTotalHIx = fsc_GetHIxEstimate((PRevRoot)pwsWork->pchRBuffer);  /* intersection count */
		pwsWork->lHInterCount = lTotalHIx;  /* save for SetupScan */
		
		lHScanCount = (int32)(pbmpBitMap->rectBounds.top - pbmpBitMap->rectBounds.bottom);
		pwsWork->lHMemSize = fsc_GetScanHMem(usScanKind, lHScanCount, lTotalHIx);

		if (usScanKind & SK_NODROPOUT)      /* if no dropout */
		{
			pwsWork->lVMemSize = 0L;
		}
		else                                /* if any kind of dropout */
		{
			pbmpBitMap->lMMemSize += (int32)pbmpBitMap->sRowBytes;  /* to save below row */
			
			lVScanCount = (int32)(pbmpBitMap->rectBounds.right - pbmpBitMap->rectBounds.left);
			pwsWork->lVMemSize = fsc_GetScanVMem(usScanKind, lVScanCount, pwsWork->lVInterCount, pwsWork->lElementCount);
			pwsWork->lVMemSize += (int32)pbmpBitMap->sRowBytes;     /* to save above row */
			ALIGN(voidPtr, pwsWork->lVMemSize ); 
		}
	}
	
#ifdef FSCFG_REENTRANT
	
	pwsWork->lHMemSize += sizeof(StateVars);        /* reentrant state space */

#endif
	
	return NO_ERR;
}


/*********************************************************************/

/*  Scan Conversion Routine                                          */
/*  Trace the contour, passing out lines and splines,                */
/*  then call ScanList to fill the bitmap                            */

/*********************************************************************/

FS_PUBLIC int32 fsc_FillGlyph( 
		ContourList* pclContour,        /* glyph outline */
		GlyphBitMap* pgbBitMap,         /* target */
		WorkScan* pwsWork,              /* for scan array */
		uint16 usBandType,              /* old, small, fast or faster */
		uint16 usScanKind )             /* dropout control value */
{
	uint16 usCont;                      /* contour index */
	int16 sStart, sEnd;                 /* start and end point of contours */
	int32 lStateSpace;                  /* HMem used by state structure */
	int32 lErrCode;                     /* function return code */
	F26Dot6 *pfxXCoord;                 /* next x coord ptr */
	F26Dot6 *pfxYCoord;                 /* next y coord ptr */
	uint8 *pbyOnCurve;                  /* next flag ptr */
	F26Dot6 *pfxXStop;                  /* contour trace end condition */
	F26Dot6 fxX1, fxX2, fxX3;           /* x coord endpoints */
	F26Dot6 fxY1, fxY2, fxY3;           /* y coord endpoints */
	uint8 byOnCurve;                    /* point 2 flag variable */
	int32 lHiScanBand;                  /* top scan limit */ 
	int32 lLoScanBand;                  /* bottom scan limit */
	int32 lHiBitBand;                   /* top bitmap limit */
	int32 lLoBitBand;                   /* bottom bitmap limit */
	int32 lOrgLoBand;                   /* save for overscan fill check */
	F26Dot6 fxYHiBand, fxYLoBand;       /* limits in f26.6 */
	boolean bSaveRow;                   /* for dropout over scanning */
	boolean bBandCheck;                 /* eliminate out of band elements */

#ifdef FSCFG_REENTRANT
	
	StateVars *pState;                  /* reentrant State is accessed via pointer */

	pState = (StateVars*)pwsWork->pchHBuffer;  /* and lives in HMem (memoryBase[6]) */ 
	lStateSpace = sizeof(StateVars);

#else
	
	lStateSpace = 0L;                   /* no HMem needed if not reentrant */

#endif
	
	if (pgbBitMap->rectBounds.top <= pgbBitMap->rectBounds.bottom)
	{
		return NO_ERR;                              /* quick out for null glyph */
	}

	if (pgbBitMap->bZeroDimension)                  /* if no height or width */
	{
		usScanKind &= (~SK_STUBS);                  /* force no-stub dropout */
	}

	lHiBitBand = (int32)pgbBitMap->sHiBand, 
	lLoBitBand = (int32)pgbBitMap->sLoBand;
	lOrgLoBand = lLoBitBand;                        /* save for fill call */    
	
	Assert (lHiBitBand > lLoBitBand);               /* should be handled above */
	
	if (!(usScanKind & SK_NODROPOUT))               /* if any kind of dropout */
	{
		lLoBitBand--;                               /* leave room below line */
	}
	if (lHiBitBand > pgbBitMap->rectBounds.top)
	{
		lHiBitBand = pgbBitMap->rectBounds.top;     /* clip to top */
	}
	if (lLoBitBand < pgbBitMap->rectBounds.bottom)
	{
		lLoBitBand = pgbBitMap->rectBounds.bottom;  /* clip to bottom */
	}
	if (usBandType == FS_BANDINGFAST)               /* if fast banding */
	{
		lHiScanBand = pgbBitMap->rectBounds.top;    /* render everything */
		lLoScanBand = pgbBitMap->rectBounds.bottom;
		bSaveRow = TRUE;                            /* keep last row for dropout */
	}
	else                                            /* if old or small banding */
	{
		lHiScanBand = lHiBitBand;                   /* just take the band */
		lLoScanBand = lLoBitBand;
		bSaveRow = FALSE;                           /* last row not needed */
	}
	
/*  if fast banding has already renderend elements, skip to FillBitMap */

	if (usBandType != FS_BANDINGFASTER)             /* if rendering required */
	{
		fsc_SetupMem(ASTATE                         /* init workspace */
				pwsWork->pchHBuffer + lStateSpace, 
				pwsWork->lHMemSize - lStateSpace,
				pwsWork->pchVBuffer, 
				pwsWork->lVMemSize);
		
		fsc_SetupLine(ASTATE0);             /* passes line callback to scanlist */
		fsc_SetupSpline(ASTATE0);           /* passes spline callback to scanlist */
		fsc_SetupEndPt(ASTATE0);            /* passes endpoint callback to scanlist */

/*  Eliminate out of band lines and splines, unless fast banding */

		bBandCheck = ((lHiScanBand < pgbBitMap->rectBounds.top) || (lLoScanBand > pgbBitMap->rectBounds.bottom));

		fxYHiBand = (F26Dot6)((lHiScanBand << SUBSHFT) - SUBHALF);  /* may be too wide */
		fxYLoBand = (F26Dot6)((lLoScanBand << SUBSHFT) + SUBHALF);

		lErrCode = fsc_SetupScan(ASTATE &(pgbBitMap->rectBounds), usScanKind, 
							 lHiScanBand, lLoScanBand, bSaveRow, (int32)pgbBitMap->sRowBytes,
							 pwsWork->lHInterCount, pwsWork->lVInterCount,
							 pwsWork->lElementCount, (PRevRoot)pwsWork->pchRBuffer );

		if (lErrCode != NO_ERR) return lErrCode;
		
		for (usCont = 0; usCont < pclContour->usContourCount; usCont++)
		{
			sStart = pclContour->asStartPoint[usCont];
			sEnd = pclContour->asEndPoint[usCont];

			if (sStart == sEnd)
			{
				continue;                               /* for compatibilty */
			}
/*
	For efficiency in tracing the contour, we start by assigning (x1,y1)
	to the last oncurve point.  This is found by starting with the End
	point and backing up if necessary.  The pfxCoord pointers can then
	be used to trace the entire contour without being reset across the
	Start/End gap. 
*/
			pfxXCoord = &pclContour->afxXCoord[sStart];
			pfxYCoord = &pclContour->afxYCoord[sStart];
			pbyOnCurve = &pclContour->abyOnCurve[sStart];
			pfxXStop = &pclContour->afxXCoord[sEnd];

			if (pclContour->abyOnCurve[sEnd] & ONCURVE) /* if endpoint oncurve */
			{
				fxX1 = pclContour->afxXCoord[sEnd];
				fxY1 = pclContour->afxYCoord[sEnd];
				fxX2 = *pfxXCoord;
				fxY2 = *pfxYCoord;
				byOnCurve = *pbyOnCurve;                /* 1st pt might be off */
				pfxXStop++;                             /* stops at endpoint */
			}
			else                                        /* if endpoint offcurve */
			{
				fxX1 = pclContour->afxXCoord[sEnd - 1];
				fxY1 = pclContour->afxYCoord[sEnd - 1];
				fxX2 = pclContour->afxXCoord[sEnd];
				fxY2 = pclContour->afxYCoord[sEnd];
				if ((pclContour->abyOnCurve[sEnd - 1] & ONCURVE) == 0)
				{
					fxX1 = (fxX1 + fxX2 + 1) >> 1;      /* offcurve midpoint */
					fxY1 = (fxY1 + fxY2 + 1) >> 1;
				}
				byOnCurve = 0;
				pfxXCoord--;                            /* pre decrement */
				pfxYCoord--;
				pbyOnCurve--;
			}
			fsc_BeginContourEndpoint(ASTATE fxX1, fxY1);          /* 1st oncurve pt -> ep module */
			fsc_BeginContourScan(ASTATE usScanKind, fxX1, fxY1);  /* to scanlist module too */
/*
	At this point, (x1,y1) is the last oncurve point; (x2,y2) is the next
	point (on or off); and the pointers are ready to be incremented to the
	point following (x2,y2).  
		
	Throughout this loop (x1,y1) is always an oncurve point (it may be the 
	midpoint between two offcurve points).  If (x2,y2) is oncurve, then we 
	have a line; if offcurve, we have a spline, and (x3,y3) will be the 
	next oncurve point.
*/
			if (!bBandCheck)
			{
				while (pfxXCoord < pfxXStop)
				{
					if (byOnCurve & ONCURVE)                /* if next point oncurve */
					{
						lErrCode = fsc_CheckEndPoint(ASTATE fxX2, fxY2, usScanKind);
						if (lErrCode != NO_ERR) return lErrCode;

						lErrCode = fsc_CalcLine(ASTATE fxX1, fxY1, fxX2, fxY2, usScanKind);
						if (lErrCode != NO_ERR) return lErrCode;

						fxX1 = fxX2;                        /* next oncurve point */
						fxY1 = fxY2;
								
						pfxXCoord++;
						pfxYCoord++;
						pbyOnCurve++;
					}
					else
					{
						pfxXCoord++;                        /* check next point */
						fxX3 = *pfxXCoord;
						pfxYCoord++;
						fxY3 = *pfxYCoord;
						pbyOnCurve++;
								
						if (*pbyOnCurve & ONCURVE)          /* if it's on, use it */
						{
							pfxXCoord++;
							pfxYCoord++;
							pbyOnCurve++;
						}
						else                                /* if not, calc next on */
						{
							fxX3 = (fxX2 + fxX3 + 1) >> 1;  /* offcurve midpoint */
							fxY3 = (fxY2 + fxY3 + 1) >> 1;
						}
						lErrCode = EvaluateSpline(ASTATE fxX1, fxY1, fxX2, fxY2, fxX3, fxY3, usScanKind);
						if (lErrCode != NO_ERR) return lErrCode;

						fxX1 = fxX3;                        /* next oncurve point */
						fxY1 = fxY3;
					}

					/* test to avoid reading past the end of memory on the last line */
					if (pfxXCoord != pfxXStop)
					{
						fxX2 = *pfxXCoord;                      /* next contour point */
						fxY2 = *pfxYCoord;
						byOnCurve = *pbyOnCurve;
					}
				}
			}
			else    /* if band checking */
			{
				while (pfxXCoord < pfxXStop)
				{
					if (byOnCurve & ONCURVE)                /* if next point oncurve */
					{
						lErrCode = fsc_CheckEndPoint(ASTATE fxX2, fxY2, usScanKind);
						if (lErrCode != NO_ERR) return lErrCode;

						if (!(((fxY1 > fxYHiBand) && (fxY2 > fxYHiBand)) ||
							  ((fxY1 < fxYLoBand) && (fxY2 < fxYLoBand))))
						{
							lErrCode = fsc_CalcLine(ASTATE fxX1, fxY1, fxX2, fxY2, usScanKind);
							if (lErrCode != NO_ERR) return lErrCode;
						}

						fxX1 = fxX2;                        /* next oncurve point */
						fxY1 = fxY2;
								
						pfxXCoord++;
						pfxYCoord++;
						pbyOnCurve++;
					}
					else
					{
						pfxXCoord++;                        /* check next point */
						fxX3 = *pfxXCoord;
						pfxYCoord++;
						fxY3 = *pfxYCoord;
						pbyOnCurve++;
								
						if (*pbyOnCurve & ONCURVE)          /* if it's on, use it */
						{
							pfxXCoord++;
							pfxYCoord++;
							pbyOnCurve++;
						}
						else                                /* if not, calc next on */
						{
							fxX3 = (fxX2 + fxX3 + 1) >> 1;  /* offcurve midpoint */
							fxY3 = (fxY2 + fxY3 + 1) >> 1;
						}

						if (!(((fxY1 > fxYHiBand) && (fxY2 > fxYHiBand) && (fxY3 > fxYHiBand)) ||
							  ((fxY1 < fxYLoBand) && (fxY2 < fxYLoBand) && (fxY3 < fxYLoBand))))
						{
							lErrCode = EvaluateSpline(ASTATE fxX1, fxY1, fxX2, fxY2, fxX3, fxY3, usScanKind);
							if (lErrCode != NO_ERR) return lErrCode;
						}
						else    /* if entirely outside of the band */
						{
							lErrCode = fsc_CheckEndPoint(ASTATE fxX3, fxY3, usScanKind);
							if (lErrCode != NO_ERR) return lErrCode;
						}

						fxX1 = fxX3;                        /* next oncurve point */
						fxY1 = fxY3;
					}

					/* test to avoid reading past the end of memory on the last line */
					if (pfxXCoord != pfxXStop)
					{
						fxX2 = *pfxXCoord;                      /* next contour point */
						fxY2 = *pfxYCoord;
						byOnCurve = *pbyOnCurve;
					}
				}
			}
			lErrCode = fsc_EndContourEndpoint(ASTATE usScanKind);
			if (lErrCode != NO_ERR) return lErrCode;
		}
	}
	
	lErrCode = fsc_FillBitMap(
			ASTATE 
			pgbBitMap->pchBitMap, 
			lHiBitBand, 
			lLoBitBand,
			(int32)pgbBitMap->sRowBytes, 
			lOrgLoBand,
			usScanKind
	);

	if (lErrCode != NO_ERR) return lErrCode;
	
	return NO_ERR;
}


#ifndef FSCFG_DISABLE_GRAYSCALE

/*********************************************************************/

/*  This routine scales up an outline for gray scale scan conversion */

/*********************************************************************/

FS_PUBLIC int32 fsc_OverScaleOutline( 
		ContourList* pclContour,        /* glyph outline */
		uint16 usOverScale              /* over scale factor */
)
{
	uint16 usCont;                      /* contour index */
	int16 sPt;                          /* point index */
	int16 sStart, sEnd;                 /* start and end point of contours */
	int16 sShift;                       /* for power of two multiply */
	F26Dot6 *pfxXCoord, *pfxYCoord;     /* for fast point array access */
	
	
	switch (usOverScale)                /* look for power of two */
	{
	case 1:
		sShift = 0;
		break;
	case 2:
		sShift = 1;
		break;
	case 4:
		sShift = 2;
		break;
	case 8:
		sShift = 3;
		break;
	default:
		sShift = -1;
		break;
	}

	for (usCont = 0; usCont < pclContour->usContourCount; usCont++)
	{
		sStart = pclContour->asStartPoint[usCont];
		sEnd = pclContour->asEndPoint[usCont];
				
		pfxXCoord = &pclContour->afxXCoord[sStart];
		pfxYCoord = &pclContour->afxYCoord[sStart];
			
		if (sShift >= 0)                    /* if power of two */
		{
			for (sPt = sStart; sPt <= sEnd; sPt++)
			{
				*pfxXCoord <<= sShift;
				pfxXCoord++;
				*pfxYCoord <<= sShift;
				pfxYCoord++;
			}
		}
		else                                /* if not a power of two */
		{
			for (sPt = sStart; sPt <= sEnd; sPt++)
			{
				*pfxXCoord *= (int32)usOverScale;
				pfxXCoord++;
				*pfxYCoord *= (int32)usOverScale;
				pfxYCoord++;
			}
		}
	}
	return NO_ERR;
}


/*********************************************************************/

/*  Gray scale bitmap calculation                                    */
/*  Count over scale pixels into gray scale byte array               */
/*  Be sure that Hi/LoBand are set correctly for both Over & Gray!   */

/*********************************************************************/

FS_PUBLIC int32 fsc_CalcGrayMap( 
		GlyphBitMap* pOverGBMap,        /* over scaled source */
		GlyphBitMap* pGrayGBMap,        /* gray scale target */
		uint16 usOverScale              /* over scale factor */
)
{
	char        *pchOverRow;            /* over scaled bitmap row pointer */
	char        *pchGrayRow;            /* gray scale bitmap row pointer */

	int16       sVOffset;               /* over scaled rows to skip */
	int16       sRightPix;              /* right edge of used over pix's */
		
	int16       sGrayRow;               /* gray scale row loop counter */
	uint16      usOverRowCount;         /* over scaled row loop counter */
	int16       sTotalRowCount;         /* over scaled whole band counter */
	
	uint32      ulBytes;                /* gray scale count for clear */
	int32       lErrCode;               /* function return code */
	
	GrayScaleParam  GSP;                /* param block for CalcGrayRow */


	Assert ((usOverScale == 1) || (usOverScale == 2) || (usOverScale == 4) || (usOverScale == 8));

	ulBytes = (uint32)pGrayGBMap->sRowBytes * (uint32)(pGrayGBMap->sHiBand - pGrayGBMap->sLoBand);
	Assert(((ulBytes >> 2) << 2) == ulBytes);
	fsc_ScanClearBitMap (ulBytes >> 2, (uint32*)pGrayGBMap->pchBitMap);
	
	GSP.usOverScale = usOverScale;
	GSP.pchOverLo = pOverGBMap->pchBitMap;      /* set pointer limits */
	GSP.pchOverHi = pOverGBMap->pchBitMap + pOverGBMap->lMMemSize;
	GSP.pchGrayLo = pGrayGBMap->pchBitMap;      /* set pointer limits */
	GSP.pchGrayHi = pGrayGBMap->pchBitMap + pGrayGBMap->lMMemSize;

	pchOverRow = pOverGBMap->pchBitMap;
	usOverRowCount = usOverScale;
	sTotalRowCount = pOverGBMap->sHiBand - pOverGBMap->sLoBand;
	sVOffset = pOverGBMap->sHiBand - usOverScale * pGrayGBMap->sHiBand;
	if (sVOffset < 0)                                   /* if mapped above over's bitmap */
	{
		usOverRowCount -= (uint16)(-sVOffset);          /* correct first band count */
	}
	else
	{
		pchOverRow += sVOffset * pOverGBMap->sRowBytes; /* point into bitmap */
		sTotalRowCount -= sVOffset;                     /* adjust for skipped rows */
	}
	
	sRightPix = pGrayGBMap->rectBounds.right * (int16)usOverScale - pOverGBMap->rectBounds.left;
	pchOverRow += (sRightPix - 1) >> 3;
	GSP.usFirstShift = (uint16)(7 - ((sRightPix-1) & 0x0007));

	GSP.sGrayCol = pGrayGBMap->rectBounds.right - pGrayGBMap->rectBounds.left;
	pchGrayRow = pGrayGBMap->pchBitMap + (GSP.sGrayCol - 1);

	for (sGrayRow = pGrayGBMap->sHiBand - 1; sGrayRow >= pGrayGBMap->sLoBand; sGrayRow--)
	{
		GSP.pchGray = pchGrayRow;
		while ((usOverRowCount > 0) && (sTotalRowCount > 0))
		{
			GSP.pchOver = pchOverRow;
			lErrCode = fsc_ScanCalcGrayRow( &GSP );
			if (lErrCode != NO_ERR) return lErrCode;
			
			pchOverRow += pOverGBMap->sRowBytes;
			usOverRowCount--;
			sTotalRowCount--;
		}                               
		pchGrayRow += pGrayGBMap->sRowBytes;
		usOverRowCount = usOverScale;
	}
	return NO_ERR;
}

#else                                   /* if grayscale is disabled */

FS_PUBLIC int32 fsc_OverScaleOutline( 
		ContourList* pclContour,        /* glyph outline */
		uint16 usOverScale              /* over scale factor */
)
{
	FS_UNUSED_PARAMETER(pclContour);
	FS_UNUSED_PARAMETER(usOverScale);
	
	return BAD_GRAY_LEVEL_ERR;
}


FS_PUBLIC int32 fsc_CalcGrayMap( 
		GlyphBitMap* pOverGBMap,        /* over scaled source */
		GlyphBitMap* pGrayGBMap,        /* gray scale target */
		uint16 usOverScale              /* over scale factor */
)
{
	FS_UNUSED_PARAMETER(pOverGBMap);
	FS_UNUSED_PARAMETER(pGrayGBMap);
	FS_UNUSED_PARAMETER(usOverScale);
	
	return BAD_GRAY_LEVEL_ERR;
}

#endif

/*********************************************************************/
											 
/*      Local Functions                                              */

/*********************************************************************/

/*********************************************************************/

/*  This routine examines a glyph contour by contour and calculates  */
/*  its bounding box.                                                */

/*********************************************************************/

FS_PRIVATE int32 FindExtrema( 
		ContourList* pclContour,        /* glyph outline */
		GlyphBitMap* pbmpBitMap         /* to return bounds */
)
{
	uint16 usCont;                      /* contour index */
	int16 sPt;                          /* point index */
	int16 sStart, sEnd;                 /* start and end point of contours */
	int32 lMaxX, lMinX;                 /* for bounding box left, right */
	int32 lMaxY, lMinY;                 /* for bounding box top, bottom */
	
	F26Dot6 *pfxXCoord, *pfxYCoord;     /* for fast point array access */
	F26Dot6 fxMaxX, fxMinX;             /* for bounding box left, right */
	F26Dot6 fxMaxY, fxMinY;             /* for bounding box top, bottom */
	boolean bFirstContour;              /* set false after min/max set */


	fxMaxX = 0L;                        /* default bounds limits */
	fxMinX = 0L;
	fxMaxY = 0L;
	fxMinY = 0L;
	bFirstContour = TRUE;               /* first time only */
	
	for (usCont = 0; usCont < pclContour->usContourCount; usCont++)
	{
		sStart = pclContour->asStartPoint[usCont];
		sEnd = pclContour->asEndPoint[usCont];
		if (sStart == sEnd)
		{
			continue;                               /* for anchor points */
		}
		
		pfxXCoord = &pclContour->afxXCoord[sStart];
		pfxYCoord = &pclContour->afxYCoord[sStart];
				
		if (bFirstContour)            
		{
			fxMaxX = *pfxXCoord;                    /* init bounds limits */
			fxMinX = *pfxXCoord;
			fxMaxY = *pfxYCoord;
			fxMinY = *pfxYCoord;
			bFirstContour = FALSE;                  /* just once */
		}

		for (sPt = sStart; sPt <= sEnd; sPt++)      /* find the min & max */
		{
			if (*pfxXCoord > fxMaxX)
				fxMaxX = *pfxXCoord;
			if (*pfxXCoord < fxMinX)
				fxMinX = *pfxXCoord;
					
			if (*pfxYCoord > fxMaxY)
				fxMaxY = *pfxYCoord;
			if (*pfxYCoord < fxMinY)
				fxMinY = *pfxYCoord;

			pfxXCoord++;
			pfxYCoord++;
		}
	}
	
	pbmpBitMap->fxMinX = fxMinX;                    /* save full precision bounds */
	pbmpBitMap->fxMinY = fxMinY;
	pbmpBitMap->fxMaxX = fxMaxX;                    /* save full precision bounds */
	pbmpBitMap->fxMaxY = fxMaxY;

	lMinX = (fxMinX + SUBHALF - 1) >> SUBSHFT;      /* pixel black box */
	lMinY = (fxMinY + SUBHALF - 1) >> SUBSHFT;
	lMaxX = (fxMaxX + SUBHALF) >> SUBSHFT;
	lMaxY = (fxMaxY + SUBHALF) >> SUBSHFT;
			
	if ((F26Dot6)(int16)lMinX != lMinX ||           /* check overflow */
		(F26Dot6)(int16)lMinY != lMinY ||
		(F26Dot6)(int16)lMaxX != lMaxX ||
		(F26Dot6)(int16)lMaxY != lMaxY )
	{
		return POINT_MIGRATION_ERR;
	}

	pbmpBitMap->bZeroDimension = FALSE;             /* assume some size */
	
	if (bFirstContour == FALSE)                     /* if contours present */
	{                                               /* then force a non-zero bitmap */
		if (lMinX == lMaxX)
		{
			lMaxX++;                                /* force 1 pixel wide */
			pbmpBitMap->bZeroDimension = TRUE;      /* flag for filling */
		}
		if (lMinY == lMaxY)
		{
			lMaxY++;                                /* force 1 pixel high */
			pbmpBitMap->bZeroDimension = TRUE;      /* flag for filling */
		}
	}
	
/*  set bitmap structure return values */

	pbmpBitMap->rectBounds.left   = (int16)lMinX;
	pbmpBitMap->rectBounds.right  = (int16)lMaxX;
	pbmpBitMap->rectBounds.bottom = (int16)lMinY;
	pbmpBitMap->rectBounds.top    = (int16)lMaxY;

	return NO_ERR;
}

/*********************************************************************/

/* This recursive routine subdivides splines that are non-monotonic or   */
/* too big into splines that fsc_CalcSpline can handle.  It also         */
/* filters out degenerate (linear) splines, passing off to fsc_CalcLine. */


FS_PRIVATE int32 EvaluateSpline( 
		PSTATE                      /* pointer to state vars */
		F26Dot6 fxX1,               /* start point x coordinate */
		F26Dot6 fxY1,               /* start point y coordinate */
		F26Dot6 fxX2,               /* control point x coordinate */
		F26Dot6 fxY2,               /* control point y coordinate */
		F26Dot6 fxX3,               /* ending x coordinate */
		F26Dot6 fxY3,               /* ending y coordinate */
		uint16 usScanKind           /* scan control type */
)
{
	F26Dot6 fxDX21, fxDX32, fxDX31;     /* delta x's */
	F26Dot6 fxDY21, fxDY32, fxDY31;     /* delta y's */
	
	F26Dot6 fxDenom;                    /* ratio denominator  */
	F26Dot6 fxX4, fxY4;                 /* first mid point */
	F26Dot6 fxX5, fxY5;                 /* mid mid point */
	F26Dot6 fxX6, fxY6;                 /* second mid point */
	F26Dot6 fxX456, fxY456;             /* for monotonic subdivision */
	F26Dot6 fxAbsDX, fxAbsDY;           /* abs of DX31, DY31 */
	
	int32 lErrCode;


	fxDX21 = fxX2 - fxX1;                       /* get all four deltas */
	fxDX32 = fxX3 - fxX2;
	fxDY21 = fxY2 - fxY1;
	fxDY32 = fxY3 - fxY2;
  
/*  If spline goes up and down, then subdivide it  */

	if (((fxDY21 > 0L) && (fxDY32 < 0L)) || ((fxDY21 < 0L) && (fxDY32 > 0L)))
	{
		fxDenom = fxDY21 - fxDY32;              /* total y span */
		fxX4 = fxX1 + LongMulDiv(fxDX21, fxDY21, fxDenom);
		fxX6 = fxX2 + LongMulDiv(fxDX32, fxDY21, fxDenom);
		fxX5 = fxX4 + LongMulDiv(fxX6 - fxX4, fxDY21, fxDenom);
		fxY456 = fxY1 + LongMulDiv(fxDY21, fxDY21, fxDenom);
		
		lErrCode = EvaluateSpline(ASTATE fxX1, fxY1, fxX4, fxY456, fxX5, fxY456, usScanKind);
		if (lErrCode != NO_ERR)  return lErrCode;

		return EvaluateSpline(ASTATE fxX5, fxY456, fxX6, fxY456, fxX3, fxY3, usScanKind);
	}
	
/*  If spline goes left and right, then subdivide it  */
	
	if (((fxDX21 > 0L) && (fxDX32 < 0L)) || ((fxDX21 < 0L) && (fxDX32 > 0L)))
	{
		fxDenom = fxDX21 - fxDX32;              /* total x span */
		fxY4 = fxY1 + LongMulDiv(fxDY21, fxDX21, fxDenom);
		fxY6 = fxY2 + LongMulDiv(fxDY32, fxDX21, fxDenom);
		fxY5 = fxY4 + LongMulDiv(fxY6 - fxY4, fxDX21, fxDenom);
		fxX456 = fxX1 + LongMulDiv(fxDX21, fxDX21, fxDenom);

		lErrCode = EvaluateSpline(ASTATE fxX1, fxY1, fxX456, fxY4, fxX456, fxY5, usScanKind);
		if (lErrCode != NO_ERR)  return lErrCode;

		return EvaluateSpline(ASTATE fxX456, fxY5, fxX456, fxY6, fxX3, fxY3, usScanKind);
	}

/*  By now the spline must be monotonic  */

	fxDX31 = fxX3 - fxX1;                       /* check overall size */
	fxDY31 = fxY3 - fxY1;
	fxAbsDX = FXABS(fxDX31);
	fxAbsDY = FXABS(fxDY31);

/*  If spline is too big to calculate, then subdivide it  */

	if ((fxAbsDX > MAXSPLINELENGTH) || (fxAbsDY > MAXSPLINELENGTH))
	{
		fxX4 = (fxX1 + fxX2) >> 1;              /* first segment mid point */
		fxY4 = (fxY1 + fxY2) >> 1;
		fxX6 = (fxX2 + fxX3) >> 1;              /* second segment mid point */
		fxY6 = (fxY2 + fxY3) >> 1;
		fxX5 = (fxX4 + fxX6) >> 1;              /* mid segment mid point */
		fxY5 = (fxY4 + fxY6) >> 1;

		lErrCode = EvaluateSpline(ASTATE fxX1, fxY1, fxX4, fxY4, fxX5, fxY5, usScanKind);
		if (lErrCode != NO_ERR)  return lErrCode;

		return EvaluateSpline(ASTATE fxX5, fxY5, fxX6, fxY6, fxX3, fxY3, usScanKind);
	}

/*  The spline is now montonic and small enough  */

	lErrCode = fsc_CheckEndPoint(ASTATE fxX3, fxY3, usScanKind);  /* first check endpoint */
	if (lErrCode != NO_ERR)  return lErrCode;

	if (fxDX21 * fxDY32 == fxDY21 * fxDX32)     /* if spline is degenerate (linear) */
	{                                           /* treat as a line */
		return fsc_CalcLine(ASTATE fxX1, fxY1, fxX3, fxY3, usScanKind);
	}
	else        
	{
		return fsc_CalcSpline(ASTATE fxX1, fxY1, fxX2, fxY2, fxX3, fxY3, usScanKind);
	}
}


/*********************************************************************/

/*  Return an array of coordinates for outline points */

FS_PUBLIC int32 fsc_GetCoords(
		ContourList* pclContour,        /* glyph outline */
        uint16 usPointCount,            /* point count */
        uint16* pusPointIndex,          /* point indices */
        PixCoord* ppcCoordinate         /* point coordinates */
)
{
    uint16  usMaxIndex;                 /* last defined point */
    int32  lX;                          /* integer x coord */
    int32  lY;                          /* integer y coord */

    if (pclContour->usContourCount == 0)
    {
        return BAD_POINT_INDEX_ERR;     /* can't have a point without a contour */
    }
     
    usMaxIndex = pclContour->asEndPoint[pclContour->usContourCount - 1] + 2;    /* allow 2 phantoms */

    while (usPointCount > 0)
    {
        if (*pusPointIndex > usMaxIndex)
        {
            return BAD_POINT_INDEX_ERR;     /* beyond the last contour */
        }

        lX = (pclContour->afxXCoord[*pusPointIndex] + SUBHALF) >> SUBSHFT;
        lY = (pclContour->afxYCoord[*pusPointIndex] + SUBHALF) >> SUBSHFT;

        if ( ((int32)(int16)lX != lX) || ((int32)(int16)lY != lY) )
    	{
    		return POINT_MIGRATION_ERR;    /* catch overflow */
    	}

        ppcCoordinate->x = (int16)lX;
        ppcCoordinate->y = (int16)lY;

        pusPointIndex++;
        ppcCoordinate++;
        usPointCount--;                     /* loop through all points */
    }
	return NO_ERR;
}

/*********************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\fs\scline.c ===
/*********************************************************************

	  scline.c -- New Scan Converter Line Module

	  (c) Copyright 1992  Microsoft Corp.  All rights reserved.

	   6/10/93  deanb   assert.h and stdio.h removed
	   3/19/93  deanb   size_t replaced with int32
	  12/22/92  deanb   MultDivide replaced with LongMulDiv
	  10/28/92  deanb   mem requirement reworked
	  10/13/92  deanb   horiz / vert line rework
	  10/09/92  deanb   reentrant
	   9/25/92  deanb   branch on scan kind 
	   9/21/92  deanb   rework horiz & vert lines 
	   9/14/92  deanb   reflection correction with iX/YOffset 
	   9/10/92  deanb   first dropout code 
	   9/08/92  deanb   quickstep deleted 
	   8/18/92  deanb   include struc.h, scconst.h 
	   7/23/92  deanb   Back to x1,y1,x2,y2 input params 
	   7/17/92  deanb   Changed from longline to line 
	   6/18/92  deanb   Cross product line rendering  
	   3/23/92  deanb   First cut 

**********************************************************************/

/*********************************************************************/

/*      Imports                                                      */

/*********************************************************************/

#define FSCFG_INTERNAL

#include    "fscdefs.h"             /* shared data types */
#include    "fserror.h"             /* error codes */
#include    "fontmath.h"            /* for subpix calc */

#include    "scglobal.h"            /* structures & constants */
#include    "scanlist.h"            /* saves scan line intersections */
#include    "scline.h"              /* for own function prototypes */

/*********************************************************************/

/*      Local Prototypes                                             */

/*********************************************************************/

FS_PRIVATE F26Dot6 CalcHorizLineSubpix(int32, F26Dot6*, F26Dot6*);
FS_PRIVATE F26Dot6 CalcVertLineSubpix(int32, F26Dot6*, F26Dot6*);


/*********************************************************************/

/*      Export Functions                                             */

/*********************************************************************/
	
/*  pass callback routine pointers to scanlist for smart dropout control */

FS_PUBLIC void fsc_SetupLine (PSTATE0) 
{
	fsc_SetupCallBacks(ASTATE SC_LINECODE, CalcHorizLineSubpix, CalcVertLineSubpix);
}


/*********************************************************************/

FS_PUBLIC int32 fsc_CalcLine( 
		PSTATE                /* pointer to state variables */
		F26Dot6 fxX1,         /* point 1  x coordinate */
		F26Dot6 fxY1,         /* point 1  y coordinate */
		F26Dot6 fxX2,         /* point 2  x coordinate */
		F26Dot6 fxY2,         /* point 2  y coordinate */
		uint16 usScanKind     /* dropout control type */
)
{
	int32 lXScan;                           /* current x pixel index */
	int32 lXSteps;                          /* vert scanline index count */
	int32 lXIncr;                           /* x pixel increment */
	int32 lXOffset;                         /* reflection correction */
	
	int32 lYScan;                           /* current scanline index */
	int32 lYSteps;                          /* horiz scanline index count */
	int32 lYIncr;                           /* y pixel increment */
	int32 lYOffset;                         /* reflection correction */

	F26Dot6 fxXInit, fxYInit;               /* sub steps to first pixel */
	F26Dot6 fxXScan, fxYScan;               /* x,y pixel center coords */
	F26Dot6 fxXX2, fxYY2;                   /* absolute value of DX, DY */
	F26Dot6 fxXTemp, fxYTemp;               /* for horiz/vert line calc */
	
	void (*pfnAddHorizScan)(PSTATE int32, int32);
	void (*pfnAddVertScan)(PSTATE int32, int32);
	
	int32 lQuadrant;                        /* 1, 2, 3, or 4 */
	int32 lQ;                               /* cross product */
	int32 lDQy, lDQx;                       /* cross product increments */
	int32 i;                                /* loop counter */


/* printf("(%li, %li) - (%li, %li)\n", fxX1, fxY1, fxX2, fxY2); */
	
/*  check y coordinates  */

	if (fxY2 >= fxY1)                           /* if going up or flat */
	{
		lQuadrant = 1;
		lQ = 0L;
		
		fxYScan = SCANABOVE(fxY1);              /* first scanline to cross */
		fxYInit = fxYScan - fxY1;               /* first y step */
		lYScan = (int32)(fxYScan >> SUBSHFT);
		lYSteps = (int32)((SCANBELOW(fxY2)) >> SUBSHFT) - lYScan + 1;
		lYIncr = 1;        
		lYOffset = 0;                           /* no reflection */
		fxYY2 = fxY2 - fxY1;                    /* translate */
	}
	else                                        /* if going down */
	{
		lQuadrant = 4;
		lQ = 1L;                                /* to include pixel centers */
		
		fxYScan = SCANBELOW(fxY1);              /* first scanline to cross */
		fxYInit = fxY1 - fxYScan;               /* first y step */
		lYScan = (int32)(fxYScan >> SUBSHFT);
		lYSteps = lYScan - (int32)((SCANABOVE(fxY2)) >> SUBSHFT) + 1;
		lYIncr = -1;        
		lYOffset = 1;                           /* reflection correction */
		fxYY2 = fxY1 - fxY2;                    /* translate and reflect */
	}
	
	if (fxY2 == fxY1)                           /* if horizontal line */
	{
		if (usScanKind & SK_NODROPOUT)          /* if no dropout control */
		{
			return NO_ERR;                      /* if only horiz scan, done */
		}
		if (fxX2 < fxX1)                        /* if going left  */
		{
			fxYTemp = fxY1 - 1;                 /* to include pix centers */
		}
		else                                    /* if going right */
		{
			fxYTemp = fxY1;          
		}
		lYScan = (int32)(SCANABOVE(fxYTemp) >> SUBSHFT);
		lYSteps = 0;
	}

/*  check x coordinates  */
	
	if (fxX2 >= fxX1)                           /* if going right or vertical */
	{
		fxXScan = SCANABOVE(fxX1);              /* first scanline to cross */
		fxXInit = fxXScan - fxX1;               /* first x step */
		lXScan = (int32)(fxXScan >> SUBSHFT);
		lXSteps = (int32)((SCANBELOW(fxX2)) >> SUBSHFT) - lXScan + 1;
		lXIncr = 1;        
		lXOffset = 0;                           /* no reflection */
		fxXX2 = fxX2 - fxX1;                    /* translate */
	}
	else                                        /* if going left */
	{
		lQ = 1L - lQ;                           /* reverse it */
		lQuadrant = (lQuadrant == 1) ? 2 : 3;   /* negative x choices */

		fxXScan = SCANBELOW(fxX1);              /* first scanline to cross */
		fxXInit = fxX1 - fxXScan;               /* first x step */
		lXScan = (int32)(fxXScan >> SUBSHFT);
		lXSteps = lXScan - (int32)((SCANABOVE(fxX2)) >> SUBSHFT) + 1;
		lXIncr = -1;        
		lXOffset = 1;                           /* reflection correction */
		fxXX2 = fxX1 - fxX2;                    /* translate and reflect */
	}
	
	if (fxX2 == fxX1)                           /* if vertical line       */
	{
		if (fxY2 > fxY1)                        /* if going up  */
		{
			fxXTemp = fxX1 - 1;                 /* to include pix centers */
		}
		else                                    /* if going down */
		{
			fxXTemp = fxX1;          
		}
		lXScan = (int32)(SCANABOVE(fxXTemp) >> SUBSHFT);
		lXSteps = 0;
	}

/*-------------------------------------------------------------------*/
	
	fsc_BeginElement( ASTATE usScanKind, lQuadrant, SC_LINECODE, /* where and what */
					  1, &fxX2, &fxY2,                           /* number of pts */
					  &pfnAddHorizScan, &pfnAddVertScan );       /* what to call */

/*-------------------------------------------------------------------*/

	if (usScanKind & SK_NODROPOUT)              /* if no dropout control */
	{
		if (fxX1 == fxX2)                       /* if vertical line */
		{
			for (i = 0; i < lYSteps; i++)       /*   then blast a column   */
			{
				pfnAddHorizScan(ASTATE lXScan, lYScan);
				lYScan += lYIncr;               /* advance y scan + or - */
			}
			return NO_ERR;
		}
		
/*  handle general case:  line is neither horizontal nor vertical  */

		lQ += (fxXX2 * fxYInit) - (fxYY2 * fxXInit);  /* cross product init */
		lDQy = fxXX2 << SUBSHFT;
		lDQx = -fxYY2 << SUBSHFT;
																	
		lXScan += lXOffset;

		for (i = 0; i < (lXSteps + lYSteps); i++)
		{
			if (lQ > 0L)                        /* if left of line */
			{
				lXScan += lXIncr;               /* advance x scan + or - */
				lQ += lDQx;           
			}
			else                                /* if right of line */
			{
				pfnAddHorizScan(ASTATE lXScan, lYScan);
				lYScan += lYIncr;               /* advance y scan + or - */
				lQ += lDQy;
			}
		}
	}
/*-------------------------------------------------------------------*/
	
	else  /* if dropout control */
	{                                           /* handle special case lines  */
		if (fxY1 == fxY2)                       /* if horizontal line */
		{
			for (i = 0; i < lXSteps; i++)       /*   then blast a row   */
			{
				pfnAddVertScan(ASTATE lXScan, lYScan);
				lXScan += lXIncr;               /* advance x scan + or - */
			}
			return NO_ERR;
		}

		if (fxX1 == fxX2)                       /* if vertical line */
		{
			for (i = 0; i < lYSteps; i++)       /*   then blast a column   */
			{
				pfnAddHorizScan(ASTATE lXScan, lYScan);
				lYScan += lYIncr;               /* advance y scan + or - */
			}
			return NO_ERR;
		}
		
/*  handle general case:  line is neither horizontal nor vertical  */

		lQ += (fxXX2 * fxYInit) - (fxYY2 * fxXInit);  /* cross product init */
		lDQy = fxXX2 << SUBSHFT;
		lDQx = -fxYY2 << SUBSHFT;
																	
		for (i = 0; i < (lXSteps + lYSteps); i++)
		{
			if (lQ > 0L)                        /* if left of line */
			{
				pfnAddVertScan(ASTATE lXScan, lYScan + lYOffset);
				lXScan += lXIncr;               /* advance x scan + or - */
				lQ += lDQx;           
			}
			else                                /* if right of line */
			{
				pfnAddHorizScan(ASTATE lXScan + lXOffset, lYScan);
				lYScan += lYIncr;               /* advance y scan + or - */
				lQ += lDQy;
			}
		}
	}
	return NO_ERR;
}


/*********************************************************************/

/*      Private Callback Functions                                   */

/*********************************************************************/

FS_PRIVATE F26Dot6 CalcHorizLineSubpix(int32 lYScan, 
									   F26Dot6 *pfxX, 
									   F26Dot6 *pfxY )
{
	F26Dot6 fxXDrop, fxYDrop;

/* printf("Line (%li, %li) - (%li, %li)", *pfxX, *pfxY, *(pfxX+1), *(pfxY+1)); */

	fxYDrop = ((F26Dot6)lYScan << SUBSHFT) + SUBHALF;
	
	Assert(((fxYDrop > *pfxY) && (fxYDrop < *(pfxY+1))) ||
		   ((fxYDrop < *pfxY) && (fxYDrop > *(pfxY+1))));

	fxXDrop = *pfxX + LongMulDiv(*(pfxX+1) - *pfxX, fxYDrop - *pfxY, *(pfxY+1) - *pfxY);

/* printf("  (%li, %li)\n", fxXDrop, fxYDrop); */

	return fxXDrop;
}


/*********************************************************************/

FS_PRIVATE F26Dot6 CalcVertLineSubpix(int32 lXScan, 
									  F26Dot6 *pfxX, 
									  F26Dot6 *pfxY )
{
	F26Dot6 fxXDrop, fxYDrop;

/* printf("Line (%li, %li) - (%li, %li)", *pfxX, *pfxY, *(pfxX+1), *(pfxY+1)); */

	fxXDrop = ((F26Dot6)lXScan << SUBSHFT) + SUBHALF;
	
	Assert(((fxXDrop > *pfxX) && (fxXDrop < *(pfxX+1))) ||
		   ((fxXDrop < *pfxX) && (fxXDrop > *(pfxX+1))));

	fxYDrop = *pfxY + LongMulDiv(*(pfxY+1) - *pfxY, fxXDrop - *pfxX, *(pfxX+1) - *pfxX);

/* printf("  (%li, %li)\n", fxXDrop, fxYDrop); */

	return fxYDrop;
}


/*********************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\fs\scmemory.h ===
/*********************************************************************

      scmemory.h -- Memory Module Exports

      (c) Copyright 1992  Microsoft Corp.  All rights reserved.

       3/19/93 deanb    size_t replaced with int32
      10/14/92 deanb    New SetupMem parameters
      10/09/92 deanb    PSTP added
      10/08/92 deanb    Horiz/Vert memory alloc's
       9/09/92 deanb    Alloc param int32  
       9/08/92 deanb    Setup with WorkSpace pointer 
       8/21/92 deanb    First cut 

**********************************************************************/

#include "fscdefs.h"                /* for type definitions */


/*********************************************************************/

/*              Export Functions                                     */

/*********************************************************************/

FS_PUBLIC void fsc_SetupMem( 
        PSTATE              /* pointer to state variables */
        char*,              /* pointer to horiz workspace */
        int32 ,             /* size of horiz workspace */
        char*,              /* pointer to vert workspace */
        int32               /* size of vert workspace */
);

FS_PUBLIC void *fsc_AllocHMem( 
        PSTATE              /* pointer to state variables */
        int32               /* allocate from horiz memory pool */
);

FS_PUBLIC void *fsc_AllocVMem( 
        PSTATE              /* pointer to state variables */
        int32               /* allocate from vert memory pool */
);

/*********************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\fs\scspline.c ===
/*********************************************************************

      scspline.c -- New Scan Converter Spline Module

      (c) Copyright 1992  Microsoft Corp.  All rights reserved.

       6/10/93  deanb   assert.h and stdio.h removed
       3/19/93  deanb   size_t replaced with int32
      10/28/92  deanb   memory requirements reworked
      10/09/92  deanb   reentrant
       9/28/92  deanb   quick out for nearly vert/horiz splines 
       9/25/92  deanb   branch on scan kind 
       9/22/92  deanb   subpix calculation using subdivision 
       9/14/92  deanb   reflection correction with iX/YOffset 
       9/10/92  deanb   first dropout code 
       9/02/92  deanb   Precision reduction by shifting control points 
       7/24/92  deanb   Initial Q set for perfect symmetry 
       7/23/92  deanb   EvaluateSpline split out and moved to NewScan 
       7/20/92  deanb   removed unreachable case 
       7/16/92  deanb   faster power of 2 
       7/06/92  deanb   Cleanups 
       7/01/92  deanb   Reinstate a single spline routine 
       6/30/92  deanb   Implicit spline rendering 
       3/23/92  deanb   First cut 

**********************************************************************/

/*********************************************************************/

/*      Imports                                                      */

/*********************************************************************/

#define FSCFG_INTERNAL

#include    "fscdefs.h"             /* shared data types */
#include    "fserror.h"             /* error codes */
#include    "fontmath.h"            /* for power of 2 calc */

#include    "scglobal.h"            /* structures & constants */
#include    "scanlist.h"            /* for direct horizscan add call */
#include    "scspline.h"            /* for own function prototypes */
                
/*********************************************************************/

/*      Constants                                                    */

/*********************************************************************/

#define     QMAXSHIFT      7            /* shift limit q precision */

/*********************************************************************/

/*      Local Prototypes                                             */

/*********************************************************************/
 
FS_PRIVATE F26Dot6 CalcHorizSpSubpix(int32, F26Dot6*, F26Dot6*);
FS_PRIVATE F26Dot6 CalcVertSpSubpix(int32, F26Dot6*, F26Dot6*);


/*********************************************************************/

/*      Export Functions                                             */

/*********************************************************************/
    
/*  pass callback routine pointers to scanlist for smart dropout control */

FS_PUBLIC void fsc_SetupSpline (PSTATE0) 
{
    fsc_SetupCallBacks(ASTATE SC_SPLINECODE, CalcHorizSpSubpix, CalcVertSpSubpix);
}


/*********************************************************************/

FS_PUBLIC int32 fsc_CalcSpline( 
        PSTATE                  /* pointer to state variables */
        F26Dot6 fxX1,           /* start point x coordinate */
        F26Dot6 fxY1,           /* start point y coordinate */
        F26Dot6 fxX2,           /* control point x coordinate */
        F26Dot6 fxY2,           /* control point y coordinate */
        F26Dot6 fxX3,           /* ending x coordinate */
        F26Dot6 fxY3,           /* ending y coordinate */
        uint16 usScanKind )     /* dropout control type */
{
    F26Dot6 fxXInit, fxYInit;           /* initial step values */
    F26Dot6 fxXScan, fxYScan;           /* set to first crossings */
    F26Dot6 fxXX2, fxYY2;               /* translated reflected control point */
    F26Dot6 fxXX3, fxYY3;               /* translated reflected end point */
    
    F26Dot6 afxXControl[2];             /* params for BeginElement call */
    F26Dot6 afxYControl[2];

    void (*pfnAddHorizScan)(PSTATE int32, int32);
    void (*pfnAddVertScan)(PSTATE int32, int32);
    
    int32 lABits;                       /* 1+int(log2(alpha)) */
    int32 lXYBits;                      /* 1+int(log2(max(x3,y3))) */
    int32 lZBits;                       /* 6, 5, 4 log2(subpixels per pix) */
    int32 lZShift;                      /* 0, 1, 2 shift to minipixel */
    F26Dot6 fxZRound;                   /* rounding factor for minipix shift */
    F26Dot6 fxZSubpix;                  /* 64, 32, 16 subpixels per pix */
    int32 lQuadrant;                    /* 1, 2, 3, or 4 */

    F26Dot6 fxAx, fxAy;                 /* parametric 2nd order terms */
    F26Dot6 lAlpha;                     /* cross product measures curvature */

    int32 lR, lT;                       /* quadratic coefficients for xx, yy */
    int32 lS2, lU2, lV2;                /* half coefficients for xy, x, y */
    int32 lRz, lSz, lTz;                /* coeff's times subpix size */
        
    int32 lQ;                           /* cross product value */
    int32 lDQx, lDQy;                   /* first order derivative */
    int32 lDDQx, lDDQy;                 /* second order derivative */

    int32 lYScan;                       /* scan line counter */
    int32 lYStop;                       /* scan line end */
    int32 lYIncr;                       /* scan line direction */
    int32 lYOffset;                     /* reflection correction */
    int32 lXScan;                       /* horiz pix position */
    int32 lXStop;                       /* pix end */
    int32 lXIncr;                       /* pix increment direction */
    int32 lXOffset;                     /* reflection correction */

    static const int32 lZShiftTable[] = { /* for precision adjustment */
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   /*  0 -  9  */
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   /* 10 - 19 */
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,   /* 20 - 29 */
        1, 1, 1, 2, 2, 2, 3, 3          /* 30 - 34 */
    };


/* printf("(%li, %li) - (%li, %li) -(%li, %li)\n", fxX1, fxY1, fxX2, fxY2, fxX3, fxY3 ); */


/*  Translate spline point 1 to (0,0) and reflect into the first quadrant  */
    
    if (fxY3 > fxY1)                            /* if going up */
    {
        lQ = 0L;
        lQuadrant = 1;

        fxYScan = SCANABOVE(fxY1);              /* first scanline to cross */
        fxYInit = fxYScan - fxY1;               /* first y step */
        lYScan = (int32)(fxYScan >> SUBSHFT);
        lYStop = (int32)((SCANBELOW(fxY3)) >> SUBSHFT) + 1;
        lYIncr = 1;        
        lYOffset = 0;                           /* no reflection */
        fxYY2 = fxY2 - fxY1;                    /* translate */
        fxYY3 = fxY3 - fxY1;
    }
    else                                        /* if going down */
    {
        lQ = 1L;                                /* to include pixel centers */
        lQuadrant = 4;
        
        fxYScan = SCANBELOW(fxY1);              /* first scanline to cross */
        fxYInit = fxY1 - fxYScan;               /* first y step */
        lYScan = (int32)(fxYScan >> SUBSHFT);
        lYStop = (int32)((SCANABOVE(fxY3)) >> SUBSHFT) - 1;
        lYIncr = -1;        
        lYOffset = 1;                           /* reflection correction */
        fxYY2 = fxY1 - fxY2;                    /* translate and reflect */
        fxYY3 = fxY1 - fxY3;
    }
    
    if (fxX3 > fxX1)                            /* if going right */
    {
        fxXScan = SCANABOVE(fxX1);              /* first scanline to cross */
        fxXInit = fxXScan - fxX1;               /* first x step */
        lXScan = (int32)(fxXScan >> SUBSHFT);
        lXStop = (int32)((SCANBELOW(fxX3)) >> SUBSHFT) + 1;
        lXIncr = 1;        
        lXOffset = 0;                           /* no reflection */
        fxXX2 = fxX2 - fxX1;                    /* translate */
        fxXX3 = fxX3 - fxX1;
    }
    else                                        /* if going left or straight */
    {
        lQ = 1L - lQ;                           /* to include pixel centers */
        lQuadrant = (lQuadrant == 1) ? 2 : 3;   /* negative x choices */

        fxXScan = SCANBELOW(fxX1);              /* first scanline to cross */
        fxXInit = fxX1 - fxXScan;               /* first x step */
        lXScan = (int32)(fxXScan >> SUBSHFT);
        lXStop = (int32)((SCANABOVE(fxX3)) >> SUBSHFT) - 1;
        lXIncr = -1;        
        lXOffset = 1;                           /* reflection correction */
        fxXX2 = fxX1 - fxX2;                    /* translate and reflect */
        fxXX3 = fxX1 - fxX3;
    }

/*-------------------------------------------------------------------*/
    
    afxXControl[0] = fxX2;
    afxYControl[0] = fxY2;
    afxXControl[1] = fxX3;
    afxYControl[1] = fxY3;

    fsc_BeginElement( ASTATE usScanKind, lQuadrant, SC_SPLINECODE,  /* where and what */
                      2, afxXControl, afxYControl,                  /* number of pts */
                      &pfnAddHorizScan, &pfnAddVertScan );          /* what to call */

/*-------------------------------------------------------------------*/

    if (usScanKind & SK_NODROPOUT)              /* if no dropout control */
    {
        if (lYScan == lYStop)                   /* and if no scan crossings */
        {
            return NO_ERR;                      /* then quick exit */
        }
        
        if (lXScan == lXStop)                   /* if nearly vertical */
        {    
            lXScan += lXOffset;
            while (lYScan != lYStop)
            {
                pfnAddHorizScan(ASTATE lXScan, lYScan);
                lYScan += lYIncr;               /* advance y scan + or - */
            }
            return NO_ERR;                      /* quick out */
        }
    }
        
/*-------------------------------------------------------------------*/

    else                                        /* if smart dropout control on */
    {
        if (lXScan == lXStop)                   /* if nearly vertical */
        {    
            lXScan += lXOffset;
            while (lYScan != lYStop)
            {
                pfnAddHorizScan(ASTATE lXScan, lYScan);
                lYScan += lYIncr;               /* advance y scan + or - */
            }
            return NO_ERR;                      /* quick out */
        }

        if (lYScan == lYStop)                   /* if nearly horizontal */
        {
            lYScan += lYOffset;
            while (lXScan != lXStop)
            {
                pfnAddVertScan(ASTATE lXScan, lYScan);
                lXScan += lXIncr;               /* advance x scan + or - */
            }        
            return NO_ERR;                      /* quick out */
        }
    }

/*-------------------------------------------------------------------*/

/*  Now calculate parametric term precision      */

    Assert(fxXX3 <= MAXSPLINELENGTH);
    Assert(fxYY3 <= MAXSPLINELENGTH);

    lAlpha = (fxXX2 * fxYY3 - fxYY2 * fxXX3) << 1;      /* curvature term */
    
    lABits = PowerOf2(lAlpha);
    lXYBits = fxXX3 > fxYY3 ? PowerOf2((int32)fxXX3) : PowerOf2((int32)fxYY3);
    
    Assert(lXYBits <= 12);                      /* max allowed spline bits */
    Assert(lABits <= 25);

    lZShift = lZShiftTable[lABits + lXYBits];   /* look up precision fix */
    lZBits = SUBSHFT - lZShift;

    if (lZShift > 0)                            /* if precision fix is needed */
    {
        fxZRound = 1L << (lZShift - 1);
        
        fxXX2 = (fxXX2 + fxZRound) >> lZShift;  /* shift to 32 or 16 subpix grid */
        fxXX3 = (fxXX3 + fxZRound) >> lZShift;
        fxYY2 = (fxYY2 + fxZRound) >> lZShift;
        fxYY3 = (fxYY3 + fxZRound) >> lZShift;
        
        fxXInit = (fxXInit + fxZRound) >> lZShift;
        fxYInit = (fxYInit + fxZRound) >> lZShift;

        lAlpha = (fxXX2 * fxYY3 - fxYY2 * fxXX3) << 1;  /* recompute curvature */
    }

    Assert (FXABS(lAlpha * fxXX3) < (1L << 29) + (3L << 24));
    Assert (FXABS(lAlpha * fxYY3) < (1L << 29) + (3L << 24));

/*  Calculate terms for Q = Rxx + Sxy + Tyy + Ux + Vy  */

    fxAx = fxXX3 - (fxXX2 << 1);
    fxAy = fxYY3 - (fxYY2 << 1);

    lR = fxAy * fxAy;
    lS2 = -fxAx * fxAy;
    lT = fxAx * fxAx;
    lU2 = fxYY2 * lAlpha;
    lV2 = -fxXX2 * lAlpha;

/*  
    Calculate starting forward difference terms:

    lQ = Q(x,y) = Rxx + Sxy + Tyy + Ux + Vy
    lDQx = Q(x+z, y) - Q(x, y) = R(2xz + zz) + Syz + Uz
    lDQy = Q(x, y+z) - Q(x, y) = T(2yz + zz) + Sxz + Vz 

*/
    fxZSubpix = 1L << lZBits;                   /* adjusted subpix per pix */

    if (lXYBits <= QMAXSHIFT)                   /* if small enough use full Q */
    {
        lQ += (lR * fxXInit + (lS2 << 1) * fxYInit + (lU2 << 1)) * fxXInit + 
              (lT * fxYInit + (lV2 << 1)) * fxYInit;
        lDQx = (lR * ((fxXInit << 1) + fxZSubpix) + (lS2 << 1) * fxYInit + (lU2 << 1)) << lZBits;
        lDQy = (lT * ((fxYInit << 1) + fxZSubpix) + (lS2 << 1) * fxXInit + (lV2 << 1)) << lZBits;
        
        lRz = lR << (lZBits << 1);              /* needed in the loop */
        lSz = (lS2 << 1) << (lZBits << 1);
        lTz = lT << (lZBits << 1);
    }
    else                                        /* if too big take out a 2 * Z */
    {
        lQ += (((lR >> 1) * fxXInit + lS2 * fxYInit + lU2) >> lZBits) * fxXInit + 
              (((lT >> 1) * fxYInit + lV2) >> lZBits) * fxYInit;
        
        lDQx = lR * (fxXInit + (fxZSubpix >> 1)) + lS2 * fxYInit + lU2;
        lDQy = lT * (fxYInit + (fxZSubpix >> 1)) + lS2 * fxXInit + lV2;
        
        lRz = lR << (lZBits - 1);               /* needed in the loop */
        lSz = lS2 << lZBits;
        lTz = lT << (lZBits - 1);
    }
    lDDQx = lRz << 1;                           /* 2nd derivative terms */
    lDDQy = lTz << 1;
                
/*-------------------------------------------------------------------*/

    if (usScanKind & SK_NODROPOUT)              /* if no dropout control */
    {
        lXScan += lXOffset;                     /* pre increment */
        lXStop += lXOffset;                     /* limit too */

/*  Branch to appropriate inner loop  */

        if (lAlpha > 0L)                        /* if curvature up */
        {
            while ((lXScan != lXStop) && (lYScan != lYStop))
            {
                if ((lQ < 0L) || (lDQy > lTz))  /* check against dy */
                {
                    lXScan += lXIncr;           /* advance x scan + or - */
                    lQ += lDQx;                 /* adjust cross product */
                    lDQx += lDDQx;              /* adjust derivative */
                    lDQy += lSz;                /* adjust cross term */
                }                               
                else
                {
                    pfnAddHorizScan(ASTATE lXScan, lYScan);
                    lYScan += lYIncr;           /* advance y scan + or - */
                    lQ += lDQy;                 /* adjust cross product */
                    lDQy += lDDQy;              /* adjust derivative */
                    lDQx += lSz;                /* adjust cross term */
                }
            }
        }
        else                                    /* if curvature down */
        {
            while ((lXScan != lXStop) && (lYScan != lYStop))
            {
                if ((lQ < 0L) || (lDQx > lRz))  /* check against dx */
                {
                    pfnAddHorizScan(ASTATE lXScan, lYScan);
                    lYScan += lYIncr;           /* advance y scan + or - */
                    lQ += lDQy;                 /* adjust cross product */
                    lDQy += lDDQy;              /* adjust derivative */
                    lDQx += lSz;                /* adjust cross term */
                }
                else
                {
                    lXScan += lXIncr;           /* advance x scan + or - */
                    lQ += lDQx;                 /* adjust cross product */
                    lDQx += lDDQx;              /* adjust derivative */
                    lDQy += lSz;                /* adjust cross term */
                }
            }
        }

/* if past bounding box, finish up */

        while (lYScan != lYStop)
        {
            pfnAddHorizScan(ASTATE lXScan, lYScan);
            lYScan += lYIncr;                   /* advance y scan + or - */
        }
    }        

/*-------------------------------------------------------------------*/

    else                                        /* if dropout control on */
    {
        if (lAlpha > 0L)                        /* if curvature up */
        {
            while ((lXScan != lXStop) && (lYScan != lYStop))
            {
                if ((lQ < 0L) || (lDQy > lTz))  /* check against dy */
                {
                    pfnAddVertScan(ASTATE lXScan, lYScan + lYOffset);
                    lXScan += lXIncr;           /* advance x scan + or - */
                    lQ += lDQx;                 /* adjust cross product */
                    lDQx += lDDQx;              /* adjust derivative */
                    lDQy += lSz;                /* adjust cross term */
                }                               
                else
                {
                    pfnAddHorizScan(ASTATE lXScan + lXOffset, lYScan);
                    lYScan += lYIncr;           /* advance y scan + or - */
                    lQ += lDQy;                 /* adjust cross product */
                    lDQy += lDDQy;              /* adjust derivative */
                    lDQx += lSz;                /* adjust cross term */
                }
            }
        }
        else                                    /* if curvature down */
        {
            while ((lXScan != lXStop) && (lYScan != lYStop))
            {
                if ((lQ < 0L) || (lDQx > lRz))  /* check against dx */
                {
                    pfnAddHorizScan(ASTATE lXScan + lXOffset, lYScan);
                    lYScan += lYIncr;           /* advance y scan + or - */
                    lQ += lDQy;                 /* adjust cross product */
                    lDQy += lDDQy;              /* adjust derivative */
                    lDQx += lSz;                /* adjust cross term */
                }
                else
                {
                    pfnAddVertScan(ASTATE lXScan, lYScan + lYOffset);
                    lXScan += lXIncr;           /* advance x scan + or - */
                    lQ += lDQx;                 /* adjust cross product */
                    lDQx += lDDQx;              /* adjust derivative */
                    lDQy += lSz;                /* adjust cross term */
                }
            }
        }

/* if outside the bounding box, finish up */

        while (lXScan != lXStop)
        {
            pfnAddVertScan(ASTATE lXScan, lYScan + lYOffset);
            lXScan += lXIncr;                   /* advance x scan + or - */
        }        
        
        while (lYScan != lYStop)
        {
            pfnAddHorizScan(ASTATE lXScan + lXOffset, lYScan);
            lYScan += lYIncr;                   /* advance y scan + or - */
        }
    }

/*-------------------------------------------------------------------*/

    return NO_ERR;
}


/*********************************************************************/

/*      Private Callback Functions      */

/*********************************************************************/

FS_PRIVATE F26Dot6 CalcHorizSpSubpix(
    int32 lYScan, 
    F26Dot6 *pfxX, 
    F26Dot6 *pfxY )
{
    F26Dot6 fxYDrop;                            /* dropout scan line */
    F26Dot6 fxX1, fxY1;                         /* local control points */
    F26Dot6 fxX2, fxY2;
    F26Dot6 fxX3, fxY3;
    F26Dot6 fxXMid, fxYMid;                     /* spline center point */

/* printf("Spline (%li, %li) - (%li, %li) - (%li, %li)", *pfxX, *pfxY,
        *(pfxX+1), *(pfxY+1), *(pfxX+2), *(pfxY+2));
*/

    fxYDrop = ((F26Dot6)lYScan << SUBSHFT) + SUBHALF;
    
    Assert(((fxYDrop > *pfxY) && (fxYDrop < *(pfxY+2))) ||
           ((fxYDrop < *pfxY) && (fxYDrop > *(pfxY+2))));

    fxX2 = *(pfxX+1);
    fxY2 = *(pfxY+1);
    
    if (*pfxY < *(pfxY+2))                      /* if spline goes up */
    {
        fxX1 = *pfxX;                           /* just copy it */
        fxY1 = *pfxY;
        fxX3 = *(pfxX+2);
        fxY3 = *(pfxY+2);
    }
    else                                        /* if spline goes down */
    {
        fxX1 = *(pfxX+2);                       /* flip it upside down */
        fxY1 = *(pfxY+2);
        fxX3 = *pfxX;
        fxY3 = *pfxY;
    }

    do                                          /* midpoint subdivision */
    {
        fxXMid = (fxX1 + fxX2 + fxX2 + fxX3 + 1) >> 2;
        fxYMid = (fxY1 + fxY2 + fxY2 + fxY3 + 1) >> 2;
        
        if (fxYMid > fxYDrop)
        {
            fxX2 = (fxX1 + fxX2) >> 1;          /* subdivide down */
            fxY2 = (fxY1 + fxY2) >> 1;
            fxX3 = fxXMid;
            fxY3 = fxYMid;
        }
        else if (fxYMid < fxYDrop)
        {
            fxX2 = (fxX2 + fxX3) >> 1;          /* subdivide up */
            fxY2 = (fxY2 + fxY3) >> 1;
            fxX1 = fxXMid;
            fxY1 = fxYMid;
        }
    } 
    while (fxYMid != fxYDrop);

/* printf("  (%li, %li)\n", fxXMid, fxYMid); */

    return fxXMid;
}


/*********************************************************************/

FS_PRIVATE F26Dot6 CalcVertSpSubpix(
    int32 lXScan, 
    F26Dot6 *pfxX, 
    F26Dot6 *pfxY )
{
    F26Dot6 fxXDrop;                            /* dropout scan line */
    F26Dot6 fxX1, fxY1;                         /* local control points */
    F26Dot6 fxX2, fxY2;
    F26Dot6 fxX3, fxY3;
    F26Dot6 fxXMid, fxYMid;                     /* spline center point */

/* printf("Spline (%li, %li) - (%li, %li) - (%li, %li)", *pfxX, *pfxY,
        *(pfxX+1), *(pfxY+1), *(pfxX+2), *(pfxY+2));
*/
    
    fxXDrop = ((F26Dot6)lXScan << SUBSHFT) + SUBHALF;
    
    Assert(((fxXDrop > *pfxX) && (fxXDrop < *(pfxX+2))) ||
           ((fxXDrop < *pfxX) && (fxXDrop > *(pfxX+2))));
    
    fxX2 = *(pfxX+1);
    fxY2 = *(pfxY+1);

    if (*pfxX < *(pfxX+2))                      /* if spline goes right */
    {                                                                  
        fxX1 = *pfxX;                           /* just copy it */
        fxY1 = *pfxY;
        fxX3 = *(pfxX+2);
        fxY3 = *(pfxY+2);
    }
    else                                        /* if spline goes left */
    {                                                                  
        fxX1 = *(pfxX+2);                       /* flip it around */
        fxY1 = *(pfxY+2);
        fxX3 = *pfxX;
        fxY3 = *pfxY;
    }

    do
    {
        fxXMid = (fxX1 + fxX2 + fxX2 + fxX3 + 1) >> 2;
        fxYMid = (fxY1 + fxY2 + fxY2 + fxY3 + 1) >> 2;
        
        if (fxXMid > fxXDrop)
        {
            fxX2 = (fxX1 + fxX2) >> 1;          /* subdivide left */
            fxY2 = (fxY1 + fxY2) >> 1;
            fxX3 = fxXMid;
            fxY3 = fxYMid;
        }
        else if (fxXMid < fxXDrop)
        {
            fxX2 = (fxX2 + fxX3) >> 1;          /* subdivide right */
            fxY2 = (fxY2 + fxY3) >> 1;
            fxX1 = fxXMid;
            fxY1 = fxYMid;
        }
    } 
    while (fxXMid != fxXDrop);

/* printf("  (%li, %li)\n", fxXMid, fxYMid); */
    
    return fxYMid;
}


/*********************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\fs\scgray.h ===
/*********************************************************************

	  scgray.h -- Gray Scale Parameter Block Definition

	  (c) Copyright 1993  Microsoft Corp.  All rights reserved.

	   8/23/93 deanb    First cut 

**********************************************************************/

#ifndef FSCGRAY_DEFINED
#define FSCGRAY_DEFINED


#include "fscdefs.h"                /* for type definitions */

/*********************************************************************/

/*      Gray scale calculation parameters                            */

/*********************************************************************/

typedef struct
{
	char* pchOver;                  /* pointer to overscaled bitmap */
	char* pchGray;                  /* pointer to gray scale bitmap */
	int16 sGrayCol;                 /* number of gray columns to calc */
	uint16 usOverScale;             /* outline magnification factor */
	uint16 usFirstShift;            /* first byte's shift */
	char* pchOverLo;                /* low limit of overscaled bitmap */
	char* pchOverHi;                /* high limit of overscaled bitmap */
	char* pchGrayLo;                /* low limit of gray scale bitmap */
	char* pchGrayHi;                /* high limit of gray scale bitmap */
}
GrayScaleParam;


/*********************************************************************/

#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\fs\stat.h ===
/*********************************************************************/
/*                                                                   */
/*    stat.h -- stat.asm exports                                     */
/*                                                                   */
/*    (c) Copyright 1992  Microsoft Corp.  All rights reserved.      */
/*                                                                   */
/*     4/9/96  claudebe adding profiling with IceCAP                 */
/*     2/26/93 deanb    macros come back                             */
/*     2/22/93 deanb    timing switch moved to fsconfig.h macros     */
/*     2/11/93 deanb    __cdecl's for ms C8                          */
/*    12/22/92 deanb    Apple types                                  */
/*    11/20/92 deanb    Timing switches revised                      */
/*    11/17/92 deanb    First cut                                    */
/*                                                                   */
/*********************************************************************/

/* STAT Card Timing Switches */

#ifdef FSCFG_USESTATCARD         /* compile option for profiling */
  #define STAT_ON               gbTimer = TRUE; StartSample();
  #define STAT_OFF              StopSample(); gbTimer = FALSE;
  #define STAT_ON_CALLBACK      if (gbTimer) StartSample();
  #define STAT_OFF_CALLBACK     if (gbTimer) StopSample();
#elif FSCFG_USEICECAP          /* compile option for profiling with IceCAP */
//#include <ICAPExp.h>
  #define STAT_ON               gbTimer = TRUE; StartCAP();
  #define STAT_OFF              StopCAP(); gbTimer = FALSE;
  #define STAT_ON_CALLBACK      if (gbTimer) ResumeCAP();
  #define STAT_OFF_CALLBACK     if (gbTimer) SuspendCAP();
#else
  #define STAT_ON
  #define STAT_OFF
  #define STAT_ON_CALLBACK
  #define STAT_OFF_CALLBACK
#endif

#if 1

#define STAT_ON_NEWSFNT         STAT_ON
#define STAT_OFF_NEWSFNT        STAT_OFF
#define STAT_ON_NEWTRAN         STAT_ON
#define STAT_OFF_NEWTRAN        STAT_OFF
#define STAT_ON_NEWGLYPH        STAT_ON
#define STAT_OFF_NEWGLYPH       STAT_OFF
#define STAT_ON_GRIDFIT         STAT_ON
#define STAT_OFF_GRIDFIT        STAT_OFF
#define STAT_ON_FINDBMS         STAT_ON
#define STAT_OFF_FINDBMS        STAT_OFF
#define STAT_ON_SCAN            STAT_ON
#define STAT_OFF_SCAN           STAT_OFF
#define STAT_ON_FNTEXEC         
#define STAT_OFF_FNTEXEC        
#define STAT_ON_IUP
#define STAT_OFF_IUP
#define STAT_ON_CALCORIG
#define STAT_OFF_CALCORIG

#else

#define STAT_ON_NEWSFNT
#define STAT_OFF_NEWSFNT
#define STAT_ON_NEWTRAN
#define STAT_OFF_NEWTRAN
#define STAT_ON_NEWGLYPH
#define STAT_OFF_NEWGLYPH
#define STAT_ON_GRIDFIT         STAT_ON         
#define STAT_OFF_GRIDFIT        STAT_OFF         
#define STAT_ON_FINDBMS   
#define STAT_OFF_FINDBMS  
#define STAT_ON_SCAN            
#define STAT_OFF_SCAN           
#define STAT_ON_FNTEXEC
#define STAT_OFF_FNTEXEC
#define STAT_ON_IUP
#define STAT_OFF_IUP
#define STAT_ON_CALCORIG
#define STAT_OFF_CALCORIG

#endif

/*********************************************************************/

/*              Global timing variable                               */

/*********************************************************************/

extern boolean gbTimer;                /* set true when timer running */

/*********************************************************************/

/*              Export Functions                                     */

/*********************************************************************/


#ifdef FSCFG_USESTATCARD         /* compile option for profiling */

uint16 __cdecl  InitStat( void );

uint16 __cdecl  ConfigElapsed( void );

uint16 __cdecl  ConfigSample( void );

uint16 __cdecl  StartElapsed( void );

uint16 __cdecl  StartSample( void );

uint32 __cdecl  ReadElapsed( void );

uint32 __cdecl  ReadSample( void );

uint16 __cdecl  ReadSample_Count( void );

uint16 __cdecl  StopElapsed( void );

uint16 __cdecl  StopSample( void );

uint16 __cdecl  ResetElapsed( void );

uint16 __cdecl  ResetSample( void );

#endif  /* FSCFG_USESTATCARD */

/*********************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\fs\sfntaccs.h ===
/*
	File:       private sfnt.h

	Contains:   xxx put contents here xxx

	Written by: xxx put writers here xxx

	Copyright:  (c) 1987-1990, 1992 by Apple Computer, Inc., all rights reserved.
				(c) 1989-1997. Microsoft Corporation, all rights reserved.

	Change History (most recent first):

		<>       02/21/97   CB      ClaudeBe, scaled component in composite glyphs
		<>       12/14/95   CB      add advance height to sfac_ReadGlyphMetrics
		<3+>     7/17/90    MR      Change return types to in for computemapping and readsfnt
		 <3>     7/14/90    MR      changed SQRT to conditional FIXEDSQRT2
		 <2>     7/13/90    MR      Change parameters to ReadSFNT and ComputeMapping
		<1+>     4/18/90    CL      
		 <1>     3/21/90    EMT     First checked in with Mike Reed's blessing.

	To Do:
*/

#include    "sfnt.h"

/* EXPORTED DATA TYPES */

typedef struct {
  uint32    ulOffset;
  uint32    ulLength;
} sfac_OffsetLength;

typedef struct sfac_ClientRec *sfac_ClientRecPtr;

typedef uint16 (*MappingFunc) (const uint8 *, uint16 , sfac_ClientRecPtr);

typedef struct sfac_ClientRec {
	ClientIDType        lClientID;          /* User ID Number                           */
	GetSFNTFunc         GetSfntFragmentPtr; /* User function to eat sfnt                */
	ReleaseSFNTFunc     ReleaseSfntFrag;    /* User function to relase sfnt             */
	int16               sIndexToLocFormat;  /* Format of loca table                     */
	uint32              ulMapOffset;        /* Offset to platform mapping data          */
	sfac_OffsetLength   TableDirectory[sfnt_NUMTABLEINDEX]; /* Table offsets/lengths    */
	uint16              usNumberOf_LongHorMetrics; /* Number of entries in hmtx table   */
	uint16              usNumLongVertMetrics;      /* number of entries with AH         */
	boolean				bValidNumLongVertMetrics; /* true if 'vhea' table exist         */
    uint16              usMappingFormat;    /* format code (0,2,4,6) for mapping func   */
	MappingFunc			GlyphMappingF;		/* mapping function char to glyph			*/
	uint16              usGlyphIndex;       /* Current glyph index                      */
	uint16				usFormat4SearchRange; /* Format 4 cached SearchRange			*/
	uint16				usFormat4EntrySelector; /* Format 4 cached EntrySelector		*/
	uint16				usFormat4RangeShift;/* Format 4 cached Range Shift				*/
	/* value for sDefaultAscender and sDefaultDescender comes from TypoAscender and     */
	/* TypoDescender from 'OS/2', if the 'OS/2' is missing, alternate values comes from */
	/* the horizontal header Ascender and Descender                                     */
	int16				sDefaultAscender;
	int16				sDefaultDescender;
	int16				sWinDescender;
} sfac_ClientRec;


/* It would be great if we could make this an opaque data type
// But in this case, the ownership of the memory for the data is the
// responsibility of the owner module. (i.e. sfntaccs.c) This adds
// complications to our model (read: it is much easier to allocate the
// data off the stack of the caller) so we won't implement this for now.
*/

/*  Glyph Handle -- Used for access to glyph data in 'glyf' table   */

typedef struct {
	 const void *     pvGlyphBaseAddress; /* Base address of glyph, needed for Release */
	 const void *     pvGlyphNextAddress; /* Current position in glyph                    */
	 const void *     pvGlyphEndAddress; /* End address of glyph, used to catch glyph corruption */
} sfac_GHandle;

/*  ComponentTypes -- Method used for positioning component in composite    */

typedef enum {
	AnchorPoints,
	OffsetPoints,
	Undefined
} sfac_ComponentTypes;

/* MACROS */

#define SFAC_LENGTH(ClientInfo,Table)  ClientInfo->TableDirectory[(int)Table].ulLength

/* PUBLIC PROTOTYPE CALLS */

/*
 * Creates mapping for finding offset table
 */

FS_PUBLIC ErrorCode sfac_DoOffsetTableMap (
	sfac_ClientRec *    ClientInfo);    /* Sfnt Client information  */

FS_PUBLIC ErrorCode sfac_ComputeMapping (
	sfac_ClientRec *    ClientInfo,     /* Sfnt Client information      */
	uint16              usPlatformID,   /* Platform Id used for mapping */
	uint16              usSpecificID);  /* Specific Id used for mapping */

FS_PUBLIC ErrorCode sfac_GetGlyphIndex(
	sfac_ClientRec *    ClientInfo,         /* Sfnt Client information      */
	uint16              usCharacterCode);   /* Character code to be mapped  */

FS_PUBLIC ErrorCode sfac_GetMultiGlyphIDs (
	sfac_ClientRec *    ClientInfo,         /* Sfnt Client information      */
	uint16	            usCharCount,        /* Number of chars to convert   */
	uint16	            usFirstChar,        /* First char code              */
	uint16 *	        pusCharCode,        /* or Pointer to char code list */
	uint16 *	        pusGlyphID);        /* Output glyph ID array        */

FS_PUBLIC ErrorCode sfac_GetWin95GlyphIDs (
	uint8 *             pbyCmapSubTable,    /* Pointer to cmap sub table    */
	uint16	            usCharCount,        /* Number of chars to convert   */
	uint16	            usFirstChar,        /* First char code              */
	uint16 *	        pusCharCode,        /* or Pointer to char code list */
	uint16 *	        pusGlyphID);        /* Output glyph ID array        */

FS_PUBLIC ErrorCode sfac_GetWinNTGlyphIDs (
	sfac_ClientRec *    ClientInfo,         /* Sfnt Client information      */
	uint16	            usCharCount,        /* Number of chars to convert   */
	uint16	            usFirstChar,        /* First char code              */
	uint32	            ulCharCodeOffset,   /* Offset to be added to *pulCharCode
											   before converting            */
	uint32 *	        pulCharCode,        /* Pointer to char code list    */
	uint32 *	        pulGlyphID);        /* Output glyph ID array        */

FS_PUBLIC ErrorCode sfac_LoadCriticalSfntMetrics(
	 sfac_ClientRec *   ClientInfo,      /* Sfnt Client information     */
	 uint16 *               pusEmResolution,/* Sfnt Em Resolution               */
	 boolean *              pbIntegerScaling,/* Sfnt flag for int scaling   */
	 LocalMaxProfile *  pMaxProfile);    /* Sfnt Max Profile table      */

FS_PUBLIC ErrorCode sfac_ReadGlyphMetrics (
	sfac_ClientRec *    ClientInfo,     /* Sfnt Client information          */
	register uint16     glyphIndex,     /* Glyph number for metrics         */
	uint16 *            pusNonScaledAW, /* Return: Non Scaled Advance Width */
	uint16 *            pusNonScaledAH, /* Return: Non Scaled Advance Height */
	int16 *             psNonScaledLSB,
	int16 *             psNonScaledTSB);

FS_PUBLIC ErrorCode sfac_ReadGlyphHorMetrics (
	sfac_ClientRec *    ClientInfo,     /* Sfnt Client information          */
	register uint16     glyphIndex,     /* Glyph number for metrics         */
	uint16 *            pusNonScaledAW, /* Return: Non Scaled Advance Width */
	int16 *             psNonScaledLSB);

FS_PUBLIC ErrorCode sfac_ReadGlyphVertMetrics (
	sfac_ClientRec *    ClientInfo,     /* Sfnt Client information          */
	register uint16     glyphIndex,     /* Glyph number for metrics         */
	uint16 *            pusNonScaledAH, /* Return: Non Scaled Advance Height */
	int16 *             psNonScaledTSB);

FS_PUBLIC ErrorCode sfac_ReadNumLongVertMetrics (
	sfac_ClientRec *    ClientInfo,     /* Sfnt Client information           */
	uint16 *            pusNumLongVertMetrics, /* Entries for which AH exists */
	boolean *           pbValidNumLongVertMetrics ); /* true if 'vhea' table exist  */

FS_PUBLIC ErrorCode sfac_CopyFontAndPrePrograms(
	sfac_ClientRec *    ClientInfo,     /* Sfnt Client Information  */
	char *              pFontProgram,   /* pointer to Font Program  */
	char *              pPreProgram);   /* pointer to Pre Program   */

FS_PUBLIC ErrorCode sfac_CopyCVT(
	sfac_ClientRec *    ClientInfo,     /* Client Information       */
	F26Dot6 *           pCVT);          /* pointer to CVT           */

FS_PUBLIC ErrorCode sfac_CopyHdmxEntry(
	sfac_ClientRec *    ClientInfo,     /* Client Information   */
	uint16              usPixelsPerEm,  /* Current Pixels per Em    */
	boolean *           bFound,         /* Flag indicating if entry found */
	uint16              usFirstGlyph,   /* First Glyph to copy */
	uint16              usLastGlyph,    /* Last Glyph to copy */
	int16 *             psBuffer);      /* Buffer to save glyph sizes */

FS_PUBLIC ErrorCode sfac_GetLTSHEntries(
	sfac_ClientRec *    ClientInfo,     /* Client Information   */
	uint16              usPixelsPerEm,  /* Current Pixels per Em    */
	uint16              usFirstGlyph,   /* First Glyph to copy */
	uint16              usLastGlyph,    /* Last Glyph to copy */
	int16 *             psBuffer);      /* Buffer to save glyph sizes */

FS_PUBLIC ErrorCode sfac_ReadGlyphHeader(
	sfac_ClientRec *    ClientInfo,         /* Client Information           */
	uint16              usGlyphIndex,       /* Glyph index to read          */
	sfac_GHandle *      hGlyph,             /* Return glyph handle          */
	boolean *           pbCompositeGlyph,   /* Is glyph a composite?        */
	boolean *           pbHasOutline,       /* Does glyph have outlines?    */
	int16 *             psNumberOfContours, /* Number of contours in glyph  */
	BBOX *              pbbox);             /* Glyph Bounding box           */

FS_PUBLIC ErrorCode sfac_ReadOutlineData(
	 uint8 *                abyOnCurve,           /* Array of on curve indicators per point  */
	 F26Dot6 *              afxOoy,               /* Array of ooy points for every point         */
	 F26Dot6 *              afxOox,               /* Array of oox points for every point         */
	 sfac_GHandle *     hGlyph,
	 LocalMaxProfile *  maxProfile,       /* MaxProfile Table                                */
	 boolean                bHasOutline,          /* Does glyph have outlines?                   */
	 int16                  sNumberOfContours,  /* Number of contours in glyph               */
	 int16 *                asStartPoints,    /* Array of start points for every contour  */
	 int16 *                asEndPoints,          /* Array of end points for every contour   */
	 uint16 *               pusSizeOfInstructions, /* Size of instructions in bytes          */
	 uint8 **               pbyInstructions,   /* Pointer to start of glyph instructions    */
     uint32*                pCompositePoints,   /* total number of point for composites, to check for overflow */
     uint32*                pCompositeContours);    /* total number of contours for composites, to check for overflow */

FS_PUBLIC ErrorCode sfac_ReadComponentData(
	sfac_GHandle *          hGlyph,
	sfac_ComponentTypes *   pMultiplexingIndicator, /* Indicator for Anchor vs offsets    */
	boolean *               pbRoundXYToGrid,    /* Round composite offsets to grid              */
	boolean *               pbUseMyMetrics,     /* Use component metrics                        */
	boolean *               pbScaleCompositeOffset,   /* Do we scale the composite offset, Apple/MS   */
	boolean *               pbWeHaveInstructions, /* Composite has instructions                 */
	uint16 *                pusComponentGlyphIndex, /* Glyph index of component                 */
	int16 *                 psXOffset,          /* X Offset of component (if app)               */
	int16 *                 psYOffset,          /* Y Offset of component (if app)               */
	uint16 *                pusAnchorPoint1,    /* Anchor point 1 of component (if app)         */
	uint16 *                pusAnchorPoint2,    /* Anchor point 2 of component (if app)         */
	transMatrix             *pMulT,             /* Transformation matrix for component          */
	boolean *				pbWeHaveAScale,     /* We have a scaling in pMulT					*/
	boolean *               pbLastComponent);   /* Is this the last component?                  */

/*  sfac_ReadCompositeInstructions

	Returns pointer to TrueType instructions for composites.

 */

FS_PUBLIC ErrorCode sfac_ReadCompositeInstructions(
	sfac_GHandle *  hGlyph,
	uint8 **        pbyInstructions,    /* Pointer to start of glyph instructions   */
	uint16 *        pusSizeOfInstructions); /* Size of instructions in bytes        */


/*  sfac_ReleaseGlyph

	Called when access to glyph in 'glyf' table is finished.

 */

FS_PUBLIC ErrorCode sfac_ReleaseGlyph(
	sfac_ClientRec *    ClientInfo, /* Sfnt Client Information  */
	sfac_GHandle *      hGlyph);    /* Glyph Handle Information */


/**********************************************************************/

/*      Embedded Bitmap (sbit) Access Routines      */

/**********************************************************************/

#ifndef FSCFG_DISABLE_GRAYSCALE
#define SBIT_BITDEPTH_MASK	0x0116	 /* support sbit with bitDepth of 1, 2, 4 and 8 */
/* SBIT_BITDEPTH_MASK must have the same value as FS_SBIT_BITDEPTH_MASK in fscaler.h */ 
#else

#define SBIT_BITDEPTH_MASK	0x0002	 /* support only sbit with bitDepth of 1 */
/* SBIT_BITDEPTH_MASK must have the same value as FS_SBIT_BITDEPTH_MASK in fscaler.h */ 
#endif


/*      SFNTACCS Export Prototypes for SBIT      */

FS_PUBLIC ErrorCode sfac_SearchForStrike (
	sfac_ClientRec *pClientInfo,
	uint16 usPpemX, 
	uint16 usPpemY, 
	uint16 usOverScale,            /* outline magnification requested */
	uint16 *pusBitDepth,			/* 1 for B/W bitmap, 2, 4 or 8 for gray sbit */
	uint16 *pusTableState,
	uint16 *pusSubPpemX,
	uint16 *pusSubPpemY,
	uint32 *pulStrikeOffset 
);

FS_PUBLIC ErrorCode sfac_SearchForBitmap (
	sfac_ClientRec *pClientInfo,
	uint16 usGlyphCode,
	uint32 ulStrikeOffset,
	boolean *pbGlyphFound,
	uint16 *pusMetricsType,
	uint16 *pusMetricsTable,
	uint32 *pulMetricsOffset,
	uint16 *pusBitmapFormat,
	uint32 *pulBitmapOffset,
	uint32 *pulBitmapLength
);

FS_PUBLIC ErrorCode sfac_GetSbitMetrics (
	sfac_ClientRec *pClientInfo,
	uint16 usMetricsType,
	uint16 usMetricsTable,
	uint32 ulMetricsOffset,
	uint16 *pusHeight,
	uint16 *pusWidth,
	int16 *psLSBearingX,
	int16 *psLSBearingY,
	int16 *psTopSBearingX, /* NEW */
	int16 *psTopSBearingY, /* NEW */
	uint16 *pusAdvanceWidth,
	uint16 *pusAdvanceHeight,  /* NEW */
   	boolean *pbHorMetricsFound, /* NEW */
   	boolean *pbVertMetricsFound /* NEW */
);

FS_PUBLIC ErrorCode sfac_ShaveSbitMetrics (
	sfac_ClientRec *pClientInfo,
	uint16 usBitmapFormat,
	uint32 ulBitmapOffset,
    uint32 ulBitmapLength,
	uint16 usBitDepth,
	uint16 *pusHeight,
	uint16 *pusWidth,
    uint16 *pusShaveLeft,
    uint16 *pusShaveRight,
    uint16 *pusShaveTop,  /* NEW */
    uint16 *pusShaveBottom,  /* NEW */
	int16 *psLSBearingX,
	int16 *psLSBearingY, /* NEW */
	int16 *psTopSBearingX, /* NEW */
	int16 *psTopSBearingY /* NEW */
);

FS_PUBLIC ErrorCode sfac_GetSbitBitmap (
	sfac_ClientRec *pClientInfo,
	uint16 usBitmapFormat,
	uint32 ulBitmapOffset,
	uint32 ulBitmapLength,
	uint16 usHeight,
	uint16 usWidth,
    uint16 usShaveLeft,
    uint16 usShaveRight,
    uint16 usShaveTop, /* NEW */
    uint16 usShaveBottom,  /* NEW */
	uint16 usXOffset,
	uint16 usYOffset,
	uint16 usRowBytes,
	uint16 usBitDepth,
	uint8 *pbyBitMap, 
	uint16 *pusCompCount
);

FS_PUBLIC ErrorCode sfac_GetSbitComponentInfo (
	sfac_ClientRec *pClientInfo,
	uint16 usComponent,
	uint32 ulBitmapOffset,
	uint32 ulBitmapLength,
	uint16 *pusCompGlyphCode,
	uint16 *pusCompXOffset,
	uint16 *pusCompYOffset
);


/**********************************************************************/

/*  Results of search for strike's bitmapSizeSubtable   */

#define     SBIT_UN_SEARCHED    0
#define     SBIT_NOT_FOUND      1
#define     SBIT_BLOC_FOUND     2
#define     SBIT_BSCA_FOUND     3

/**********************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\fs\sfntaccs.c ===
/*
	File:       sfnt.c

	Contains:   xxx put contents here (or delete the whole line) xxx

	Written by: xxx put name of writer here (or delete the whole line) xxx

   Copyright:  (c) 1987-1990, 1992 by Apple Computer, Inc., all rights reserved.
			   (c) 1989-1997. Microsoft Corporation, all rights reserved.

	Change History (most recent first):

		<>       02/21/97   CB      ClaudeBe, scaled component in composite glyphs
		<>       12/14/95   CB      add advance height to sfac_ReadGlyphMetrics
	   <17+>     10/9/90    MR,rb   Remove classification of unused tables in sfnt_Classify
		<17>     8/10/90    MR      Pass nil for textLength parameter to MapString2, checked in
									other files to their precious little system will BUILD.  Talk
									about touchy!
		<16>     8/10/90    gbm     rolling out Mike's textLength change, because he hasn't checked
									in all the relevant files, and the build is BROKEN!
		<15>     8/10/90    MR      Add textLength arg to MapString2
		<14>     7/26/90    MR      don't include toolutil.h
		<13>     7/23/90    MR      Change computeindex routines to call functins in MapString.c
		<12>     7/18/90    MR      Add SWAPW macro for INTEL
		<11>     7/13/90    MR      Lots of Ansi-C stuff, change behavior of ComputeMapping to take
									platform and script
		 <9>     6/27/90    MR      Changes for modified format 4: range is now times two, loose pad
									word between first two arrays.  Eric Mader
		 <8>     6/21/90    MR      Add calls to ReleaseSfntFrag
		 <7>      6/5/90    MR      remove vector mapping functions
		 <6>      6/4/90    MR      Remove MVT
		 <5>      5/3/90    RB      simplified decryption.
		 <4>     4/10/90    CL      Fixed mapping table routines for double byte codes.
		 <3>     3/20/90    CL      Joe found bug in mappingtable format 6 Added vector mapping
									functions use pointer-loops in sfnt_UnfoldCurve, changed z from
									int32 to int16
		 <2>     2/27/90    CL      New error code for missing but needed table. (0x1409)  New
									CharToIndexMap Table format.
									Assume subtablenumber zero for old sfnt format.  Fixed
									transformed component bug.
	   <3.2>    11/14/89    CEL     Left Side Bearing should work right for any transformation. The
									phantom points are in, even for components in a composite glyph.
									They should also work for transformations. Device metric are
									passed out in the output data structure. This should also work
									with transformations. Another leftsidebearing along the advance
									width vector is also passed out. whatever the metrics are for
									the component at it's level. Instructions are legal in
									components. Instructions are legal in components. Glyph-length 0
									bug in sfnt.c is fixed. Now it is legal to pass in zero as the
									address of memory when a piece of the sfnt is requested by the
									scaler. If this happens the scaler will simply exit with an
									error code ! Fixed bug with instructions in components.
	   <3.1>     9/27/89    CEL     Removed phantom points.
	   <3.0>     8/28/89    sjk     Cleanup and one transformation bugfix
	   <2.2>     8/14/89    sjk     1 point contours now OK
	   <2.1>      8/8/89    sjk     Improved encryption handling
	   <2.0>      8/2/89    sjk     Just fixed EASE comment
	   <1.5>      8/1/89    sjk     Added composites and encryption. Plus some enhancements.
	   <1.4>     6/13/89    SJK     Comment
	   <1.3>      6/2/89    CEL     16.16 scaling of metrics, minimum recommended ppem, point size 0
									bug, correct transformed integralized ppem behavior, pretty much
									so
	   <1.2>     5/26/89    CEL     EASE messed up on "c" comments
	  <y1.1>  5/26/89    CEL     Integrated the new Font Scaler 1.0 into Spline Fonts
	   <1.0>     5/25/89    CEL     Integrated 1.0 Font scaler into Bass code for the first time.

	To Do:
		<3+>     3/20/90    mrr     Fixed mapping table routines for double byte codes.
									Added support for font program.
									Changed count from uint16 to int16 in vector char2index routines.
*/

#define FSCFG_INTERNAL

/** FontScaler's Includes **/

#include "fserror.h"
#include "fscdefs.h"
#include "sfntaccs.h"
#include "sfntoff.h"
/*#include "MapString.h" */

#include "stat.h"                   /* STAT timing card prototypes */

/*  CONSTANTS   */

#define MISSING_GLYPH_INDEX     0
#define MAX_FORMAT0_CHAR_INDEX  256
#define MAX_LINEAR_X2           16
static  const   transMatrix   IdentTransform =
   {{{ONEFIX,      0,      0},
	 {     0, ONEFIX,      0},
	 {     0,      0, ONEFIX}}};

/*  MACROS  */
#define MAX(a, b)   (((a) > (b)) ? (a) : (b))

#define GETSFNTFRAG(ClientInfo,lOffset,lLength) (ClientInfo)->GetSfntFragmentPtr(ClientInfo->lClientID, lOffset, lLength)
#define RELEASESFNTFRAG(ClientInfo,data)        (ClientInfo)->ReleaseSfntFrag((voidPtr)data)

#define SFAC_BINARYITERATION \
	  newP = (uint16 *) ((char *)tableP + (usSearchRange >>= 1)); \
		if (charCode > (uint16) SWAPW (*newP)) tableP = newP;

#define SFAC_GETUNSIGNEDBYTEINC( p ) ((uint8)(*p++))

/* PRIVATE PROTOTYES */

FS_PRIVATE void sfac_Classify (
	 sfac_OffsetLength * TableDirectory,
	 uint8 *                    dir);

FS_PRIVATE uint16 sfac_ComputeUnkownIndex (const uint8 * mapping, uint16 charCode, sfac_ClientRec * ClientInfo);
FS_PRIVATE uint16 sfac_ComputeIndex0 (const uint8 * mapping, uint16 charCode, sfac_ClientRec * ClientInfo);
FS_PRIVATE uint16 sfac_ComputeIndex2 (const uint8 * mapping, uint16 charCode, sfac_ClientRec * ClientInfo);
FS_PRIVATE uint16 sfac_ComputeIndex4 (const uint8 * mapping, uint16 charCode, sfac_ClientRec * ClientInfo);
FS_PRIVATE uint16 sfac_ComputeIndex6 (const uint8 * mapping, uint16 charCode, sfac_ClientRec * ClientInfo);

FS_PRIVATE ErrorCode sfac_GetGlyphLocation (
	sfac_ClientRec *    ClientInfo,
	uint16              gIndex,
	uint32 *            ulOffset,
	uint32 *            ulLength,
	sfnt_tableIndex*  pGlyphTableIndex);

FS_PRIVATE ErrorCode    sfac_GetDataPtr (
	sfac_ClientRec *    ClientInfo,
	uint32              ulOffset,
	uint32              ulLength,
	sfnt_tableIndex     TableRef,
	boolean             bMustHaveTable,
    const void * *     ppvTablePtr);

FS_PRIVATE ErrorCode sfac_GetGlyphIDs (
   	MappingFunc			pfnGlyphMapping,		/* mapping func char to glyph	*/
    const uint8 *       mapOffsetPtr,       /* cmap subtable past header    */
	sfac_ClientRec *    ClientInfo,         /* Sfnt Client information      */
	uint16	            usCharCount,        /* Number of chars to convert   */
	uint16	            usCharCode,         /* First char code              */
	uint16 *	        pusCharCode,        /* or Pointer to char code list */
	uint16 *	        pusGlyphID);        /* Output glyph ID array        */

FS_PRIVATE ErrorCode sfac_GetLongGlyphIDs (
   	MappingFunc			pfnGlyphMapping,	/* mapping func char to glyph	*/
    const uint8 *       mapOffsetPtr,       /* cmap subtable past header    */
	sfac_ClientRec *    ClientInfo,         /* May be NULL!                 */
	uint16	            usCharCount,        /* Number of chars to convert   */
	uint16	            usCharCode,         /* First char code              */
	uint32	            ulCharCodeOffset,   /* Offset to be added to *pulCharCode
											   before converting            */
	uint32 *	        pulCharCode,        /* Pointer to char code list    */
	uint32 *	        pulGlyphID);         /* Output glyph ID array        */

FS_PRIVATE void	sfac_ComputeBinarySearchParams(
	uint16		usSegCount, 		/* INPUT */
	uint16 *	pusSearchRange,		/* OUTPUT */
	uint16 *	pusEntrySelector,	/* OUTPUT */
	uint16 *	pusRangeShift);		/* OUTPUT */

FS_PRIVATE ErrorCode sfac_ReadGlyphBbox(
	sfac_ClientRec *    ClientInfo,         /* Client Information           */
	uint16              usGlyphIndex,       /* Glyph index to read          */
	BBOX *              pbbox);             /* Glyph Bounding box           */

/*
 * Internal routine (make this an array and do a look up?)
 */
FS_PRIVATE void sfac_Classify (
	 sfac_OffsetLength * TableDirectory,
	 uint8 *                    dir)
{
	int32 Index;

	switch ((uint32)SWAPL(*((sfnt_TableTag *)&dir[SFNT_DIRECTORYENTRY_TAG])))
	{
		case tag_FontHeader:
			Index = (int32)sfnt_fontHeader;
			break;
		case tag_HoriHeader:
			Index = (int32)sfnt_horiHeader;
			break;
		case tag_IndexToLoc:
			Index = (int32)sfnt_indexToLoc;
			break;
		case tag_MaxProfile:
			Index = (int32)sfnt_maxProfile;
			break;
		case tag_ControlValue:
			Index = (int32)sfnt_controlValue;
			break;
		case tag_PreProgram:
			Index = (int32)sfnt_preProgram;
			break;
		case tag_GlyphData:
			Index = (int32)sfnt_glyphData;
			break;
		case tag_HorizontalMetrics:
			Index = (int32)sfnt_horizontalMetrics;
			break;
		case tag_CharToIndexMap:
			Index = (int32)sfnt_charToIndexMap;
			break;
		case tag_FontProgram:
			Index = (int32)sfnt_fontProgram;   /* <4> */
			break;
		case tag_GlyphDirectory:         /* Used for GlyphDirectory Download */
			Index = (int32)sfnt_GlyphDirectory;
			break;
		case tag_HoriDeviceMetrics:
			Index = (int32)sfnt_HoriDeviceMetrics;
			break;
		case tag_LinearThreshold:
			Index = (int32)sfnt_LinearThreshold;
			break;
		case tag_BitmapData:
			Index = (int32)sfnt_BitmapData;
			break;
		case tag_BitmapLocation:
			Index = (int32)sfnt_BitmapLocation;
			break;
		case tag_BitmapScale:
			Index = (int32)sfnt_BitmapScale;
			break;
		case tag_VertHeader:
			Index = (int32)sfnt_vertHeader;
			break;
		case tag_VerticalMetrics:
			Index = (int32)sfnt_verticalMetrics;
			break;
		case tag_OS_2:
			Index = (int32)sfnt_OS_2;
			break;
		default:
			Index = -1;
			break;
	}
	if (Index >= 0)
	{
		  TableDirectory[Index].ulOffset = (uint32) SWAPL (*((uint32 *)&dir[SFNT_DIRECTORYENTRY_TABLEOFFSET]));
		  TableDirectory[Index].ulLength = (uint32) SWAPL (*((uint32 *)&dir[SFNT_DIRECTORYENTRY_TABLELENGTH]));
	}
}


/*
 * Creates mapping for finding offset table     <4>
 */

FS_PUBLIC ErrorCode sfac_DoOffsetTableMap (
	sfac_ClientRec *  ClientInfo)    /* Sfnt Client information */

{
	int32        i;
	uint8 *      sfntDirectory;
	int32        cTables;
	uint8 *      dir;

	STAT_OFF_CALLBACK;                  /* pause STAT timer */

	sfntDirectory = (uint8 *) GETSFNTFRAG (ClientInfo, 0L, (int32)SIZEOF_SFNT_OFFSETTABLE);

	STAT_ON_CALLBACK;                /* restart STAT timer */

	if (sfntDirectory != NULL)
	{
		cTables = (int32) SWAPW (*((uint16 *)&sfntDirectory[SFNT_OFFSETTABLE_NUMOFFSETS]));
		RELEASESFNTFRAG(ClientInfo, sfntDirectory);

		STAT_OFF_CALLBACK;               /* pause STAT timer */

		sfntDirectory = (uint8 *) GETSFNTFRAG (
			ClientInfo,
			0L,
			((int32)SIZEOF_SFNT_OFFSETTABLE + (int32)SIZEOF_SFNT_DIRECTORYENTRY * (int32)(cTables)));

		STAT_ON_CALLBACK;             /* restart STAT timer */


		if (sfntDirectory == NULL)
		{
			return(CLIENT_RETURNED_NULL);
		}
	}
	else
	{
		return(NULL_SFNT_DIR_ERR);
	}

	/* Initialize */

	MEMSET (ClientInfo->TableDirectory, 0, sizeof (ClientInfo->TableDirectory));

	dir = &sfntDirectory[SFNT_OFFSETTABLE_TABLE];

	for (i = 0; i < cTables; i++)
	{
		sfac_Classify (ClientInfo->TableDirectory, dir);
		dir += SIZEOF_SFNT_DIRECTORYENTRY;
	}

	/* Used when glyphs are accessed from the base of memory */

	ClientInfo->TableDirectory[(int32)sfnt_BeginningOfFont].ulOffset = 0U;
	ClientInfo->TableDirectory[(int32)sfnt_BeginningOfFont].ulLength = ~0U;

	RELEASESFNTFRAG(ClientInfo, sfntDirectory);

	return NO_ERR;
}

/*
 * Use this function when only part of the table is needed.
 *
 * n is the table number.
 * offset is within table.
 * length is length of data needed.
 * To get an entire table, pass length = ULONG_MAX     <4>
 */

FS_PRIVATE ErrorCode sfac_GetDataPtr (
	sfac_ClientRec *    ClientInfo,
	uint32              ulOffset,
	uint32              ulLength,
	sfnt_tableIndex     TableRef,
	boolean             bMustHaveTable,
	const void **       ppvTablePtr)
{
	uint32      ulTableLength;

	ulTableLength = SFAC_LENGTH(ClientInfo, TableRef);

	if (ulTableLength > 0)
	{
		if(ulLength == ULONG_MAX)
		{
			ulLength = ulTableLength;
		}

		STAT_OFF_CALLBACK;               /* pause STAT timer */

		*ppvTablePtr = (void *)GETSFNTFRAG (
			ClientInfo,
			(int32)(ulOffset + ClientInfo->TableDirectory[(int32)TableRef].ulOffset),
			(int32)ulLength);

		STAT_ON_CALLBACK;             /* restart STAT timer */

		if (*ppvTablePtr == NULL)
		{
			return CLIENT_RETURNED_NULL; /* Do a gracefull recovery   */
		}
	}
	else
	{
		*ppvTablePtr = (void *)NULL;

		if (bMustHaveTable)
		{
			return MISSING_SFNT_TABLE; /* Do a gracefull recovery  */
		}
	}

	return NO_ERR;
}


/*
 * This, is when we don't know what is going on
 */

FS_PRIVATE uint16 sfac_ComputeUnkownIndex (const uint8 * mapping, uint16 charCode, sfac_ClientRec * ClientInfo)
{
	FS_UNUSED_PARAMETER(mapping);
	FS_UNUSED_PARAMETER(charCode);
	FS_UNUSED_PARAMETER(ClientInfo);
	return MISSING_GLYPH_INDEX;
}


/*
 * Byte Table Mapping 256->256          <4>
 */
FS_PRIVATE uint16 sfac_ComputeIndex0 (const uint8 * mapping, uint16 charCode, sfac_ClientRec * ClientInfo)
{
	FS_UNUSED_PARAMETER(ClientInfo);
	if (charCode < MAX_FORMAT0_CHAR_INDEX)
	{
		return (uint16)mapping[charCode];
	}
	else
	{
		return MISSING_GLYPH_INDEX;
	}
}

/*
 * High byte mapping through table
 *
 * Useful for the national standards for Japanese, Chinese, and Korean characters.
 *
 * Dedicated in spirit and logic to Mark Davis and the International group.
 *
 *  Algorithm: (I think)
 *      First byte indexes into KeyOffset table.  If the offset is 0, keep going, else use second byte.
 *      That offset is from beginning of data into subHeader, which has 4 words per entry.
 *          entry, extent, delta, range
 *
 */

FS_PRIVATE uint16 sfac_ComputeIndex2 (const uint8 * mapping, uint16 charCode, sfac_ClientRec * ClientInfo)
{
	uint16          usIndex;
	uint16          usMapMe;
	uint16          usHighByte;
	uint16          usGlyph;
	const uint8 *   Table2;
	const uint8 *   subHeader;

	FS_UNUSED_PARAMETER(ClientInfo);
	Table2 = (const uint8 *) mapping;

	usHighByte = (uint16)(charCode >> 8);

	if (((uint16 *)&Table2[SFNT_MAPPINGTABLE2_SUBHEADERSKEYS]) [usHighByte])
	{
		usMapMe = (uint16)(charCode & 0xFF); /* We also need the low byte. */
	}
	else
	{
#ifdef  FSCFG_MICROSOFT_KK
		if(usHighByte != 0)
		{
			usMapMe = usHighByte;
		}
		else
		{
				usMapMe = (uint16)(charCode & 0xFF);
		}
#else
		usMapMe = usHighByte;
#endif
	}

	subHeader = (const uint8 *) ((char *)&Table2[SFNT_MAPPINGTABLE2_SUBHEADERS] +
		(uint16)SWAPW (((uint16 *)&Table2[SFNT_MAPPINGTABLE2_SUBHEADERSKEYS]) [usHighByte]));

	usMapMe -= (uint16)SWAPW (*((uint16 *)&subHeader[SFNT_SUBHEADER2_FIRSTCODE]));    /* Subtract first code. */

	if (usMapMe < (uint16)SWAPW (*((uint16 *)&subHeader[SFNT_SUBHEADER2_ENTRYCOUNT])))
	{  /* See if within range. */

		usGlyph = (uint16)(* ((uint16 *) ((char *) &subHeader[SFNT_SUBHEADER2_IDRANGEOFFSET] +
			(uint16)SWAPW (*((uint16 *)&subHeader[SFNT_SUBHEADER2_IDRANGEOFFSET]))) + usMapMe));

		if (usGlyph != 0) /* Note: usGlyph has not been swapped yet */
		{
			usIndex = (uint16)((int32)(uint32)(uint16)SWAPW(usGlyph) + (int32)SWAPW (*((int16 *)&subHeader[SFNT_SUBHEADER2_IDDELTA])));
		}
		else
		{
			usIndex = MISSING_GLYPH_INDEX;
		}
	}
	else
	{
		usIndex = MISSING_GLYPH_INDEX;
	}

	return usIndex;
}

/*
 * Segment mapping to delta values, Yack.. !
 *
 * In memory of Peter Edberg. Initial code taken from code example supplied by Peter.
 */
FS_PRIVATE uint16 sfac_ComputeIndex4 (const uint8 * mapping, uint16 charCode, sfac_ClientRec * ClientInfo)
{
	const uint16 *  tableP;
	const uint8 *   Table4;
	uint16          usIdDelta;
	uint16          usOffset;
	uint16          usIndex;
	uint16          usSegCountX2;
	uint16			usSearchRange;
	uint16			usEntrySelector;
	uint16			usRangeShift;
	const uint16 *  newP;    /* temporary pointer for binary iteration   */
	uint16          usStartCount;

	Table4 = (const uint8 *)mapping;

	usSegCountX2 = (uint16) SWAPW(*((uint16 *)&Table4[SFNT_MAPPINGTABLE4_SEGCOUNTX2]));
	tableP = (const uint16 *)&Table4[SFNT_MAPPINGTABLE4_ENDCOUNT];

	/* If there are just a few segments, skip straight to the linear search */

	if (usSegCountX2 >= MAX_LINEAR_X2 && charCode > 0xFF)
	{
		/* start with unrolled binary search */

		/* tableP points at endCount[] */
		if( ClientInfo == NULL )
		{
			sfac_ComputeBinarySearchParams(
				(uint16)(usSegCountX2 / 2),
				&usSearchRange,
				&usEntrySelector,
				&usRangeShift);
		}
		else
		{
			usSearchRange = ClientInfo->usFormat4SearchRange;

			/* Assert(SWAPW(*((uint16 *)&Table4[SFNT_MAPPINGTABLE4_RANGESHIFT])) == ClientInfo->usFormat4RangeShift); */
			usRangeShift = ClientInfo->usFormat4RangeShift;

			/* Assert((uint16)SWAPW(*((uint16 *)&Table4[SFNT_MAPPINGTABLE4_ENTRYSELECTOR])) == ClientInfo->usFormat4EntrySelector); */
			usEntrySelector = ClientInfo->usFormat4EntrySelector;
		}

		if (charCode >= (uint16) SWAPW (* ((uint16 *) ((char *)tableP + usSearchRange))))
		{
			tableP = (uint16 *) ((char *)tableP + usRangeShift); /* range to low shift it up */
		}


		switch( usEntrySelector )
		{
		case 15:
			SFAC_BINARYITERATION;
			/* fall through */
		case 14:
			SFAC_BINARYITERATION;
			/* fall through */
		case 13:
			SFAC_BINARYITERATION;
			/* fall through */
		case 12:
			SFAC_BINARYITERATION;
			/* fall through */
		case 11:
			SFAC_BINARYITERATION;
			/* fall through */
		case 10:
			SFAC_BINARYITERATION;
			/* fall through */
		case 9:
			SFAC_BINARYITERATION;
			/* fall through */
		case 8:
			SFAC_BINARYITERATION;
			/* fall through */
		case 7:
			SFAC_BINARYITERATION;
			/* fall through */
		case 6:
			SFAC_BINARYITERATION;
			/* fall through */
		case 5:
			SFAC_BINARYITERATION;
			/* fall through */
		case 4:
			SFAC_BINARYITERATION;
			/* fall through */
		case 3:
		case 2:   /* drop through */
		case 1:
		case 0:
			break;
		default:
			Assert(FALSE);
			break;
		}
	}

	/*  Now do linear search */

	while(charCode > (uint16) SWAPW(*tableP))
	{
		tableP++;
	}

	tableP++;                  /*  Skip Past reservedPad word    */

	/* End of search, now do mapping */

	tableP = (uint16 *) ((char *)tableP + usSegCountX2); /* point at startCount[] */
	usStartCount = (uint16) SWAPW (*tableP);

	if (charCode >= usStartCount)
	{
		  usOffset = (uint16)(charCode - (uint16) SWAPW (*tableP));
		tableP = (uint16 *) ((char *)tableP + usSegCountX2); /* point to idDelta[] */
		usIdDelta = (uint16) SWAPW (*tableP);
		tableP = (uint16 *) ((char *)tableP + usSegCountX2); /* point to idRangeOffset[] */

		if ((uint16) SWAPW (*tableP) == 0)
		{
				usIndex   = (uint16)(charCode + usIdDelta);
		}
		else
		{
			/* Use glyphIdArray to access index */

			usOffset += usOffset; /* make word offset */
			tableP   = (uint16 *) ((char *)tableP + (uint16) SWAPW (*tableP) + usOffset); /* point to glyphIndexArray[] */

			if((uint16)SWAPW (*tableP) != MISSING_GLYPH_INDEX)
			{
					 usIndex    = (uint16)((uint16) SWAPW (*tableP) + usIdDelta);
			}
			else
			{
				usIndex = MISSING_GLYPH_INDEX;
			}
		}
	}
	else
	{
		usIndex = MISSING_GLYPH_INDEX;
	}

	return usIndex;
}


/*
 * Trimmed Table Mapping
 */

FS_PRIVATE uint16 sfac_ComputeIndex6 (const uint8 * mapping, uint16 charCode, sfac_ClientRec * ClientInfo)
{
	const uint8 *Table6;

	FS_UNUSED_PARAMETER(ClientInfo);

	Table6 = (const uint8 *) mapping;

	charCode  -= (uint16)SWAPW (*((uint16 *)&Table6[SFNT_MAPPINGTABLE6_FIRSTCODE]));

	if (charCode < (uint16) SWAPW (*((uint16 *)&Table6[SFNT_MAPPINGTABLE6_ENTRYCOUNT])))
	{
		return ((uint16) SWAPW (((uint16 *)&Table6[SFNT_MAPPINGTABLE6_GLYPHIDARRAY]) [charCode]));
	}
	else
	{
		return   MISSING_GLYPH_INDEX;
	}
}


/*
 * Sets up our mapping function pointer.
 */

FS_PUBLIC ErrorCode sfac_ComputeMapping (
	sfac_ClientRec *  ClientInfo,
	uint16            usPlatformID,
	uint16            usSpecificID)

{
	const uint8 *   table;
	const uint8 *   MappingTable;
	const uint8 *   Table4;
	boolean         bFound;
	ErrorCode       Ret;
	const uint8 *	plat;
	uint16			usSegCountX2;

	bFound = FALSE;

	/* the following code allow a client that is only interested by glyph indices to
               call fs_NewSfnt with -1 for PlatformID and SpecificID */
	if(usPlatformID == 0xFFFF)
	{
		ClientInfo->GlyphMappingF = sfac_ComputeUnkownIndex;
		return NO_ERR;
	}


	Ret = sfac_GetDataPtr (ClientInfo, 0L, ULONG_MAX, sfnt_charToIndexMap, FALSE, (const void **)&table);

	if(Ret != NO_ERR)
	{
		return Ret;
	}


	if (table == NULL)
	{
		/* If no "cmap" is present, permits access to characters by glyph index */

		ClientInfo->GlyphMappingF = sfac_ComputeUnkownIndex;
		return NO_ERR;
	}

	/* APPLE Code
	if(*((uint16 *)&table[SFNT_CHAR2INDEXDIRECTORY_VERSION]) != 0)
	{
		ClientInfo->GlyphMappingF = sfac_ComputeUnkownIndex;
		RELEASESFNTFRAG(ClientInfo, table);
		return OUT_OF_RANGE_SUBTABLE;
	}
	*/

	/* mapping */

	plat = (uint8 *) &table[SFNT_CHAR2INDEXDIRECTORY_PLATFORM]; /* <4> */

	while(plat < (uint8 *)&table[SFNT_CHAR2INDEXDIRECTORY_PLATFORM + ((uint16)SWAPW(*((uint16 *)&table[SFNT_CHAR2INDEXDIRECTORY_NUMTABLES])) *
		  SIZEOF_SFNT_PLATFORMENTRY)] && !bFound)
	{
		if (((uint16)SWAPW(*((uint16 *)&plat[SFNT_PLATFORMENTRY_PLATFORMID])) == usPlatformID) &&
			((uint16)SWAPW(*((uint16 *)&plat[SFNT_PLATFORMENTRY_SPECIFICID])) == usSpecificID))
		{
			bFound = TRUE;
			ClientInfo->ulMapOffset = (uint32) SWAPL (*((uint32 *)&plat[SFNT_PLATFORMENTRY_PLATFORMOFFSET]));   /* skip header */
		}
		plat += SIZEOF_SFNT_PLATFORMENTRY;
	}


	if (!bFound)
	{
		ClientInfo->ulMapOffset = 0;
		ClientInfo->GlyphMappingF = sfac_ComputeUnkownIndex;
		RELEASESFNTFRAG(ClientInfo, table);
		return OUT_OF_RANGE_SUBTABLE;
	}
	else
	{
		Assert(Ret == NO_ERR);
		MappingTable = (uint8 *)((uint8 *)table + ClientInfo->ulMapOffset);  /* back up for header */
		ClientInfo->ulMapOffset += (uint32)SIZEOF_SFNT_MAPPINGTABLE;
	}

    ClientInfo->usMappingFormat = (uint16)SWAPW (*((uint16 *)&MappingTable[SFNT_MAPPINGTABLE_FORMAT]));

	switch (ClientInfo->usMappingFormat)
	{
	case 0:
		ClientInfo->GlyphMappingF = sfac_ComputeIndex0;
		break;
	case 2:
		ClientInfo->GlyphMappingF = sfac_ComputeIndex2;
		break;
	case 4:
		ClientInfo->GlyphMappingF = sfac_ComputeIndex4;

		/* Pre-compute several values used for Index 4 lookups */
		/* This becomes necessary because of several font vendors who */
		/* have placed incorrect values in the TrueType font file. */

		Table4 = (uint8 *)((uint8 *)table + ClientInfo->ulMapOffset);
		usSegCountX2 = (uint16) SWAPW(*((uint16 *)&Table4[SFNT_MAPPINGTABLE4_SEGCOUNTX2]));

		sfac_ComputeBinarySearchParams(
			(uint16)(usSegCountX2 / 2),
			&ClientInfo->usFormat4SearchRange,
			&ClientInfo->usFormat4EntrySelector,
			&ClientInfo->usFormat4RangeShift);

		break;
	case 6:
		ClientInfo->GlyphMappingF = sfac_ComputeIndex6;
		break;
	default:
		ClientInfo->GlyphMappingF = sfac_ComputeUnkownIndex;
		Ret = UNKNOWN_CMAP_FORMAT;
		break;
	}
	RELEASESFNTFRAG(ClientInfo, table);

	return Ret;
}

FS_PRIVATE void	sfac_ComputeBinarySearchParams(
	uint16		usSegCount, 		/* INPUT */
	uint16 *	pusSearchRange,		/* OUTPUT */
	uint16 *	pusEntrySelector,	/* OUTPUT */
	uint16 *	pusRangeShift)		/* OUTPUT */
{
	uint16			usLog;
	uint16			usPowerOf2;

	usLog = 0;
	usPowerOf2 = 1;

	while((2 * usPowerOf2) <= usSegCount )
	{
		usPowerOf2 *= 2;
		usLog++;
	}

	*pusSearchRange = 2 * usPowerOf2;
	*pusEntrySelector = usLog;
	*pusRangeShift = (2 * usSegCount) - (2 * usPowerOf2);
}

FS_PUBLIC ErrorCode sfac_GetGlyphIndex(
	sfac_ClientRec *  ClientInfo,
	uint16            usCharacterCode)
{
	 const uint8 *   mappingPtr;
	ErrorCode   error;

	 error = sfac_GetDataPtr (ClientInfo, 0L, ULONG_MAX, sfnt_charToIndexMap, TRUE, (const void **)&mappingPtr);

	if(error != NO_ERR)
	{
		return error;
	}

	ClientInfo->usGlyphIndex = ClientInfo->GlyphMappingF (mappingPtr + ClientInfo->ulMapOffset, usCharacterCode, ClientInfo);

	RELEASESFNTFRAG(ClientInfo, mappingPtr);

	return NO_ERR;
}

/*  return glyph ID's for a range or for an array of character codes */

FS_PUBLIC ErrorCode sfac_GetMultiGlyphIDs (
	sfac_ClientRec *    ClientInfo,         /* Sfnt Client information      */
	uint16	            usCharCount,        /* Number of chars to convert   */
	uint16	            usFirstChar,        /* First char code              */
	uint16 *	        pusCharCode,        /* or Pointer to char code list */
	uint16 *	        pusGlyphID)         /* Output glyph ID array        */
{
	const uint8 *       mappingPtr;
    const uint8 *       mapOffsetPtr;
	ErrorCode           errCode;

    if ((ClientInfo->usMappingFormat != 0) &&
        (ClientInfo->usMappingFormat != 2) &&
        (ClientInfo->usMappingFormat != 4) &&
        (ClientInfo->usMappingFormat != 6))
    {
        return UNKNOWN_CMAP_FORMAT;
    }

	errCode = sfac_GetDataPtr (ClientInfo, 0L, ULONG_MAX, sfnt_charToIndexMap, TRUE, (const void **)&mappingPtr);
    if(errCode != NO_ERR)
	{
		return errCode;
	}
    mapOffsetPtr = mappingPtr + ClientInfo->ulMapOffset;

    errCode = sfac_GetGlyphIDs (
   	    ClientInfo->GlyphMappingF,
        mapOffsetPtr,
        ClientInfo,
        usCharCount,
	    usFirstChar,
	    pusCharCode,
	    pusGlyphID);

	RELEASESFNTFRAG(ClientInfo, mappingPtr);

	return errCode;
}

/*  special version for Win95 doesn't require a font context */

FS_PUBLIC ErrorCode sfac_GetWin95GlyphIDs (
	uint8 *             pbyCmapSubTable,       /* Pointer to cmap sub table    */
	uint16	            usCharCount,        /* Number of chars to convert   */
	uint16	            usFirstChar,        /* First char code              */
	uint16 *	        pusCharCode,        /* or Pointer to char code list */
	uint16 *	        pusGlyphID)         /* Output glyph ID array        */
{
   	uint16              usMappingFormat;    /* cmap subtable format code    */
   	MappingFunc			pfnGlyphMapping;	/* mapping func char to glyph   */
    const uint8 *       pbyCmapData;        /* past subtable header         */
 	ErrorCode           errCode;

    usMappingFormat = (uint16)SWAPW (*((uint16 *)&pbyCmapSubTable[SFNT_MAPPINGTABLE_FORMAT]));
	switch (usMappingFormat)
	{
	case 0:
		pfnGlyphMapping = sfac_ComputeIndex0;
		break;
	case 2:
		pfnGlyphMapping = sfac_ComputeIndex2;
        break;
	case 4:
		pfnGlyphMapping = sfac_ComputeIndex4;
        break;
	case 6:
		pfnGlyphMapping = sfac_ComputeIndex6;
		break;
    default:
        return UNKNOWN_CMAP_FORMAT;
    }
    pbyCmapData = pbyCmapSubTable + SIZEOF_SFNT_MAPPINGTABLE;


    errCode = sfac_GetGlyphIDs (
   	    pfnGlyphMapping,
        pbyCmapData,
        NULL,                               /* ClientInfo */
        usCharCount,
	    usFirstChar,
	    pusCharCode,
	    pusGlyphID );

	return errCode;
}

/* special helper function for NT
   - an offset usCharCodeOffset is added to the character codes from pulCharCode 
     before converting the value to glyph index
   - pulCharCode and pulGlyphID are both uint32 *
   - pulCharCode and pulGlyphID can point to the same address        
*/

FS_PUBLIC ErrorCode sfac_GetWinNTGlyphIDs (
	sfac_ClientRec *    ClientInfo,         /* Sfnt Client information      */
	uint16	            usCharCount,        /* Number of chars to convert   */
	uint16	            usFirstChar,        /* First char code              */
	uint32	            ulCharCodeOffset,   /* Offset to be added to *pulCharCode
											   before converting            */
	uint32 *	        pulCharCode,        /* Pointer to char code list    */
	uint32 *	        pulGlyphID)        /* Output glyph ID array        */
{
	const uint8 *       mappingPtr;
    const uint8 *       mapOffsetPtr;
	ErrorCode           errCode;

    if ((ClientInfo->usMappingFormat != 0) &&
        (ClientInfo->usMappingFormat != 2) &&
        (ClientInfo->usMappingFormat != 4) &&
        (ClientInfo->usMappingFormat != 6))
    {
        return UNKNOWN_CMAP_FORMAT;
    }

	errCode = sfac_GetDataPtr (ClientInfo, 0L, ULONG_MAX, sfnt_charToIndexMap, TRUE, (const void **)&mappingPtr);
    if(errCode != NO_ERR)
	{
		return errCode;
	}
    mapOffsetPtr = mappingPtr + ClientInfo->ulMapOffset;

    errCode = sfac_GetLongGlyphIDs (
   	    ClientInfo->GlyphMappingF,
        mapOffsetPtr,
        ClientInfo,
        usCharCount,
	    usFirstChar,
		ulCharCodeOffset,
	    pulCharCode,
	    pulGlyphID);

	RELEASESFNTFRAG(ClientInfo, mappingPtr);

	return errCode;
}

/*      common code for the two get glyph ID helper routines */

FS_PRIVATE ErrorCode sfac_GetGlyphIDs (
   	MappingFunc			pfnGlyphMapping,	/* mapping func char to glyph	*/
    const uint8 *       mapOffsetPtr,       /* cmap subtable past header    */
	sfac_ClientRec *    ClientInfo,         /* May be NULL!                 */
	uint16	            usCharCount,        /* Number of chars to convert   */
	uint16	            usCharCode,         /* First char code              */
	uint16 *	        pusCharCode,        /* or Pointer to char code list */
	uint16 *	        pusGlyphID)         /* Output glyph ID array        */
{
	if (pusCharCode == NULL)                /* Null pointer implies character code range */
    {
        if (((uint32)usCharCode + (uint32)usCharCount) > 0x0000FFFFL)
        {
            return INVALID_CHARCODE_ERR;    /* trap an illegal range */
        }

        while (usCharCount > 0)
        {
        	*pusGlyphID = pfnGlyphMapping (mapOffsetPtr, usCharCode, ClientInfo);
            pusGlyphID++;
            usCharCode++;                   /* next character in range */
            usCharCount--;
        }
    }
    else                                    /* Valid pointer implies character code array */
    {
        while (usCharCount > 0)
        {
            if (*pusCharCode == 0xFFFF)     /* trap illegal char code */
            {
                return INVALID_CHARCODE_ERR;
            }
        	*pusGlyphID = pfnGlyphMapping (mapOffsetPtr, *pusCharCode, ClientInfo);
            pusGlyphID++;
            pusCharCode++;                  /* next character in array */
            usCharCount--;
        }
    }
	return NO_ERR;
}

/*      special for NT */

FS_PRIVATE ErrorCode sfac_GetLongGlyphIDs (
   	MappingFunc			pfnGlyphMapping,	/* mapping func char to glyph	*/
    const uint8 *       mapOffsetPtr,       /* cmap subtable past header    */
	sfac_ClientRec *    ClientInfo,         /* May be NULL!                 */
	uint16	            usCharCount,        /* Number of chars to convert   */
	uint16	            usCharCode,         /* First char code              */
	uint32	            ulCharCodeOffset,   /* Offset to be added to *pulCharCode
											   before converting            */
	uint32 *	        pulCharCode,        /* Pointer to char code list    */
	uint32 *	        pulGlyphID)         /* Output glyph ID array        */
{
	if (pulCharCode == NULL)                /* Null pointer implies character code range */
    {
        if (((uint32)usCharCode + (uint32)usCharCount) > 0x0000FFFFL)
        {
            return INVALID_CHARCODE_ERR;    /* trap an illegal range */
        }

        while (usCharCount > 0)
        {
        	*pulGlyphID = (uint32)pfnGlyphMapping (mapOffsetPtr, usCharCode, ClientInfo);
            pulGlyphID++;
            usCharCode++;                   /* next character in range */
            usCharCount--;
        }
    }
    else                                    /* Valid pointer implies character code array */
    {
        while (usCharCount > 0)
        {
			if ((*pulCharCode + ulCharCodeOffset) > 0x0000FFFFL)
            {
                return INVALID_CHARCODE_ERR;   /* trap an illegal range */
            }
			usCharCode = (uint16) (*pulCharCode + ulCharCodeOffset);
        	*pulGlyphID = (uint32)pfnGlyphMapping (mapOffsetPtr, usCharCode, ClientInfo);
            pulGlyphID++;
            pulCharCode++;                  /* next character in array */
            usCharCount--;
        }
    }
	return NO_ERR;
}

/*********************************************************************/

FS_PUBLIC ErrorCode sfac_LoadCriticalSfntMetrics(
	sfac_ClientRec *        ClientInfo,
	uint16 *                pusEmResolution,
	boolean *               pbIntegerScaling,
	LocalMaxProfile *       pMaxProfile)
{
	ErrorCode       error;
	const uint8 *   fontHead;
	const uint8 *   horiHead;
	const uint8 *   pTempMaxProfile;
	const uint8 *   pTempOS_2;

	error = sfac_GetDataPtr (ClientInfo, 0L, ULONG_MAX, sfnt_fontHeader, TRUE, (const void **)&fontHead);

	if(error != NO_ERR)
	{
		return error;
	}

	error = sfac_GetDataPtr (ClientInfo, 0L, ULONG_MAX, sfnt_horiHeader, TRUE, (const void **)&horiHead);

	if(error != NO_ERR)
	{
		return error;
	}

	if ((uint32)SWAPL (*((uint32 *)&fontHead[SFNT_FONTHEADER_MAGICNUMBER])) != SFNT_MAGIC)
	{
		return BAD_MAGIC_ERR;
	}

	*pusEmResolution     = (uint16)SWAPW (*((uint16 *)&fontHead[SFNT_FONTHEADER_UNITSPEREM]));
	if(*pusEmResolution < 16 || *pusEmResolution > 16384)
		return BAD_UNITSPEREM_ERR;
		
	*pbIntegerScaling    = (((uint16)SWAPW (*((uint16 *)&fontHead[SFNT_FONTHEADER_FLAGS]))& USE_INTEGER_SCALING) ==
									 USE_INTEGER_SCALING);

	ClientInfo->usNumberOf_LongHorMetrics = (uint16)SWAPW (*((uint16 *)&horiHead[SFNT_HORIZONTALHEADER_NUMBEROF_LONGHORMETRICS]));
	ClientInfo->sIndexToLocFormat       = SWAPW (*((int16 *)&fontHead[SFNT_FONTHEADER_INDEXTOLOCFORMAT]));

	error = sfac_GetDataPtr (ClientInfo, 0L, ULONG_MAX, sfnt_OS_2, FALSE, (const void **)&pTempOS_2); /* not a mandatory table */

	if(error != NO_ERR)
	{
		return error;
	}

	if(pTempOS_2 != NULL)
	{
		/* get TypoAscender and TypoDescender from the OS/2 table */
		ClientInfo->sDefaultAscender = (int16)SWAPW (*((uint16 *)&pTempOS_2[SFNT_OS2_STYPOASCENDER]));
		ClientInfo->sDefaultDescender = (int16)SWAPW (*((uint16 *)&pTempOS_2[SFNT_OS2_STYPODESCENDER]));
		RELEASESFNTFRAG(ClientInfo, pTempOS_2);
	} else {
		/* if OS/2 is not there get the values from horizontal header */
		ClientInfo->sDefaultAscender = (int16)SWAPW (*((uint16 *)&horiHead[SFNT_HORIZONTALHEADER_YASCENDER]));
		ClientInfo->sDefaultDescender = (int16)SWAPW (*((uint16 *)&horiHead[SFNT_HORIZONTALHEADER_YDESCENDER]));
	}
	ClientInfo->sWinDescender = (int16)SWAPW (*((uint16 *)&horiHead[SFNT_HORIZONTALHEADER_YDESCENDER]));

	RELEASESFNTFRAG(ClientInfo, horiHead);
	RELEASESFNTFRAG(ClientInfo, fontHead);

	error = sfac_GetDataPtr (ClientInfo, 0L, ULONG_MAX, sfnt_maxProfile, TRUE, (const void **)&pTempMaxProfile);

	if(error != NO_ERR)
	{
		return error;
	}

	pMaxProfile->version =              (Fixed)SWAPL(*((Fixed *)&pTempMaxProfile[SFNT_MAXPROFILETABLE_VERSION]));
	pMaxProfile->numGlyphs =            (uint16)SWAPW(*((uint16 *)&pTempMaxProfile[SFNT_MAXPROFILETABLE_NUMGLYPHS]));
	pMaxProfile->maxPoints =            (uint16)SWAPW(*((uint16 *)&pTempMaxProfile[SFNT_MAXPROFILETABLE_MAXPOINTS]));
	pMaxProfile->maxContours =          (uint16)SWAPW(*((uint16 *)&pTempMaxProfile[SFNT_MAXPROFILETABLE_MAXCONTOURS]));
	pMaxProfile->maxCompositePoints =   (uint16)SWAPW(*((uint16 *)&pTempMaxProfile[SFNT_MAXPROFILETABLE_MAXCOMPOSITEPOINTS]));
	pMaxProfile->maxCompositeContours = (uint16)SWAPW(*((uint16 *)&pTempMaxProfile[SFNT_MAXPROFILETABLE_MAXCOMPOSITECONTOURS]));
	pMaxProfile->maxElements =          (uint16)SWAPW(*((uint16 *)&pTempMaxProfile[SFNT_MAXPROFILETABLE_MAXELEMENTS]));
	pMaxProfile->maxTwilightPoints =    (uint16)SWAPW(*((uint16 *)&pTempMaxProfile[SFNT_MAXPROFILETABLE_MAXTWILIGHTPOINTS]));
	pMaxProfile->maxStorage =           (uint16)SWAPW(*((uint16 *)&pTempMaxProfile[SFNT_MAXPROFILETABLE_MAXSTORAGE]));
	pMaxProfile->maxFunctionDefs =      (uint16)SWAPW(*((uint16 *)&pTempMaxProfile[SFNT_MAXPROFILETABLE_MAXFUNCTIONDEFS]));
	pMaxProfile->maxInstructionDefs =   (uint16)SWAPW(*((uint16 *)&pTempMaxProfile[SFNT_MAXPROFILETABLE_MAXINSTRUCTIONDEFS]));
	pMaxProfile->maxStackElements =     (uint16)SWAPW(*((uint16 *)&pTempMaxProfile[SFNT_MAXPROFILETABLE_MAXSTACKELEMENTS]));
	pMaxProfile->maxSizeOfInstructions =(uint16)SWAPW(*((uint16 *)&pTempMaxProfile[SFNT_MAXPROFILETABLE_MAXSIZEOFINSTRUCTIONS]));
	pMaxProfile->maxComponentElements = (uint16)SWAPW(*((uint16 *)&pTempMaxProfile[SFNT_MAXPROFILETABLE_MAXCOMPONENTELEMENTS]));
	pMaxProfile->maxComponentDepth =    (uint16)SWAPW(*((uint16 *)&pTempMaxProfile[SFNT_MAXPROFILETABLE_MAXCOMPONENTDEPTH]));

	RELEASESFNTFRAG(ClientInfo, pTempMaxProfile);

	error = sfac_ReadNumLongVertMetrics(ClientInfo, &ClientInfo->usNumLongVertMetrics,&ClientInfo->bValidNumLongVertMetrics);

	return error;
}



/*
 *
 */

FS_PUBLIC ErrorCode sfac_ReadGlyphHorMetrics (
	sfac_ClientRec *    ClientInfo,
	uint16              glyphIndex,
	uint16 *            pusNonScaledAW,
	int16 *             psNonScaledLSB)
{
	const uint8 *   horizMetricPtr;
	uint16          numberOf_LongHorMetrics;
	ErrorCode       error;
	int16 *         lsb;

	numberOf_LongHorMetrics = ClientInfo->usNumberOf_LongHorMetrics;
	error = sfac_GetDataPtr (ClientInfo, 0L, ULONG_MAX, sfnt_horizontalMetrics, TRUE, (const void **)&horizMetricPtr);

	if(error != NO_ERR)
	{
		return error;
	}

	if (glyphIndex < numberOf_LongHorMetrics)
	{
		*pusNonScaledAW     = (uint16)SWAPW (*((uint16 *)&horizMetricPtr[(glyphIndex * SIZEOF_SFNT_HORIZONTALMETRICS) + SFNT_HORIZONTALMETRICS_ADVANCEWIDTH]));
		*psNonScaledLSB     = SWAPW (*((int16 *)&horizMetricPtr[(glyphIndex * SIZEOF_SFNT_HORIZONTALMETRICS) + SFNT_HORIZONTALMETRICS_LEFTSIDEBEARING]));
	}
	else
	{
		lsb = (int16 *) (char *)& horizMetricPtr[numberOf_LongHorMetrics * SIZEOF_SFNT_HORIZONTALMETRICS]; /* first entry after[AW,LSB] array */

		*pusNonScaledAW       = (uint16)SWAPW (*((uint16 *)&horizMetricPtr[((numberOf_LongHorMetrics-1) * SIZEOF_SFNT_HORIZONTALMETRICS) + SFNT_HORIZONTALMETRICS_ADVANCEWIDTH]));
		*psNonScaledLSB      = SWAPW (lsb[glyphIndex - numberOf_LongHorMetrics]);
	}

	RELEASESFNTFRAG(ClientInfo, horizMetricPtr);

	return NO_ERR;
}

FS_PUBLIC ErrorCode sfac_ReadGlyphVertMetrics (
	sfac_ClientRec *    ClientInfo,
	uint16              glyphIndex,
	uint16 *            pusNonScaledAH,
	int16 *             psNonScaledTSB)
{
	const uint8 *   vertMetricPtr;
	uint16          usNumLongVertMetrics;       /* number of entries with AH */
	ErrorCode       error;
	int16 *         psTSB;
	BBOX            bbox;           


	usNumLongVertMetrics = ClientInfo->usNumLongVertMetrics;
	if(ClientInfo->bValidNumLongVertMetrics)
	{

		error = sfac_GetDataPtr (ClientInfo, 0L, ULONG_MAX, sfnt_verticalMetrics, FALSE, (const void **)&vertMetricPtr);  /* not a mandatory table */

		if(error != NO_ERR)
		{
			return error;
		}
	}

	if (ClientInfo->bValidNumLongVertMetrics && (vertMetricPtr != NULL) )
	{
		if (glyphIndex < usNumLongVertMetrics)
		{
			*pusNonScaledAH     = (uint16)SWAPW (*((uint16 *)&vertMetricPtr[(glyphIndex * SIZEOF_SFNT_VERTICALMETRICS) + SFNT_VERTICALMETRICS_ADVANCEHEIGHT]));
			*psNonScaledTSB     = SWAPW (*((int16 *)&vertMetricPtr[(glyphIndex * SIZEOF_SFNT_VERTICALMETRICS) + SFNT_VERTICALMETRICS_TOPSIDEBEARING]));
		}
		else
		{
			psTSB = (int16 *) (char *)& vertMetricPtr[usNumLongVertMetrics * SIZEOF_SFNT_VERTICALMETRICS]; /* first entry after[AW,TSB] array */

			*pusNonScaledAH       = (uint16)SWAPW (*((uint16 *)&vertMetricPtr[((usNumLongVertMetrics-1) * SIZEOF_SFNT_VERTICALMETRICS) + SFNT_VERTICALMETRICS_ADVANCEHEIGHT]));
			*psNonScaledTSB      = SWAPW (psTSB[glyphIndex - usNumLongVertMetrics]);
		}

		RELEASESFNTFRAG(ClientInfo, vertMetricPtr);
	} else {

		/* We don't have vertical metrics, let's set to default values */

		/* to get the glyph bbox for the defalut value of the vertical metrics */
		error = sfac_ReadGlyphBbox(ClientInfo,ClientInfo->usGlyphIndex, &bbox);

		if(error != NO_ERR)
		{
			return error;
		}		

		/* default if no vertical metrics found */
		*pusNonScaledAH = ClientInfo->sDefaultAscender - ClientInfo->sDefaultDescender;   
		*psNonScaledTSB = ClientInfo->sDefaultAscender - bbox.yMax;
	}

	return NO_ERR;
}

FS_PUBLIC ErrorCode sfac_ReadGlyphMetrics (
	sfac_ClientRec *    ClientInfo,
	uint16              glyphIndex,
	uint16 *            pusNonScaledAW,
	uint16 *            pusNonScaledAH,
	int16 *             psNonScaledLSB,
	int16 *             psNonScaledTSB)
{
	ErrorCode       error;

	error = sfac_ReadGlyphHorMetrics (ClientInfo, glyphIndex, pusNonScaledAW, psNonScaledLSB);

	if(error != NO_ERR)
	{
		return error;
	}

	error = sfac_ReadGlyphVertMetrics (ClientInfo, glyphIndex, pusNonScaledAH, psNonScaledTSB);
	return error;
}

/*
 *  Read Number of Long Vertical Metrics from vhea table
 */

FS_PUBLIC ErrorCode sfac_ReadNumLongVertMetrics(
	sfac_ClientRec *        ClientInfo,
	uint16 *                pusNumLongVertMetrics,
	boolean *               pbValidNumLongVertMetrics )
{
	ErrorCode       error;
	const uint8 *   vertHead;

	*pbValidNumLongVertMetrics = FALSE;
	error = sfac_GetDataPtr (ClientInfo, 0L, ULONG_MAX, sfnt_vertHeader, FALSE, (const void **)&vertHead);

	if(error != NO_ERR)
	{
		return error;
	}		
	
	if(vertHead != NULL)
	{
		*pusNumLongVertMetrics = (uint16)SWAPW (*((uint16 *)&vertHead[SFNT_VERTICALHEADER_NUMBEROF_LONGVERTMETRICS]));
		*pbValidNumLongVertMetrics = TRUE;

		RELEASESFNTFRAG(ClientInfo, vertHead);
	}

	return NO_ERR;
}


FS_PRIVATE ErrorCode sfac_GetGlyphLocation (
	sfac_ClientRec *    ClientInfo,
	uint16              gIndex,
	uint32 *            ulOffset,
	uint32 *            ulLength,
	sfnt_tableIndex*    pGlyphTableIndex)

{
	const void *    indexPtr;
	ErrorCode       error;
	uint16 *        shortIndexToLoc;
	uint32 *        longIndexToLoc;
	uint32 *        offsetPtr;
	uint16 *        lengthPtr;

	error = sfac_GetDataPtr (ClientInfo, 0L, ULONG_MAX, sfnt_GlyphDirectory, FALSE, (const void **)&indexPtr);

	if(error != NO_ERR)
	{
		return error;
	}

	/* If there is a glyph directory, first check for the glyph there.  */

	if (indexPtr != NULL)
	{
		offsetPtr = (uint32 *)((char *)indexPtr+((int32)gIndex*(int32)(sizeof(int32)+sizeof(uint16))));
		lengthPtr = (uint16 *)(char *)(offsetPtr+1);

		*ulOffset = (uint32)SWAPL(*offsetPtr);

		if(*ulOffset == 0L)
		{
			*ulLength =  0L;
		}
		else
		{
			*ulLength =  (uint32) (uint16)SWAPW(*lengthPtr);
		}

		/* sfnt_BeginningOfFont references the beginning of memory  */

		*pGlyphTableIndex = sfnt_BeginningOfFont;

		RELEASESFNTFRAG(ClientInfo, indexPtr);
		return NO_ERR;
	}

	error = sfac_GetDataPtr (ClientInfo, 0L, ULONG_MAX, sfnt_indexToLoc, TRUE, (const void **)&indexPtr);
	if(error != NO_ERR)
	{
		return error;
	}

	if (ClientInfo->sIndexToLocFormat == SHORT_INDEX_TO_LOC_FORMAT)
	{
		shortIndexToLoc = (uint16 *)indexPtr + gIndex;
		*ulOffset = (uint32) (uint16) (SWAPW (*shortIndexToLoc)) << 1;
		shortIndexToLoc++;
		*ulLength =  (((uint32) (uint16) (SWAPW (*shortIndexToLoc)) << 1) - *ulOffset);
	}
	else
	{
		longIndexToLoc = (uint32 *)indexPtr + gIndex;
		*ulOffset = (uint32) SWAPL (*longIndexToLoc);
		longIndexToLoc++;
		*ulLength = ((uint32)SWAPL (*longIndexToLoc) - *ulOffset);
	}

	*pGlyphTableIndex = sfnt_glyphData;

	RELEASESFNTFRAG(ClientInfo, indexPtr);

	return NO_ERR;
}

FS_PUBLIC ErrorCode sfac_CopyFontAndPrePrograms(
	sfac_ClientRec *    ClientInfo,    /* Client Information         */
	char *              pFontProgram,  /* pointer to Font Program    */
	char *              pPreProgram)   /* pointer to Pre Program     */
{
	uint32              ulLength;
	const char *        pFragment;
	ErrorCode           error;

	error = sfac_GetDataPtr (ClientInfo, 0L, ULONG_MAX, sfnt_fontProgram, FALSE, (const void **)&pFragment);
	if(error)
	{
		return error;
	}
	ulLength = SFAC_LENGTH (ClientInfo, sfnt_fontProgram);
	if (ulLength)
	{
		MEMCPY (pFontProgram, pFragment, ulLength);
		RELEASESFNTFRAG(ClientInfo, pFragment);
	}

	error = sfac_GetDataPtr (ClientInfo, 0L, ULONG_MAX, sfnt_preProgram, FALSE, (const void **)&pFragment);
	if(error)
	{
		return error;
	}
	ulLength = SFAC_LENGTH (ClientInfo, sfnt_preProgram);
	if (ulLength)
	{
		MEMCPY (pPreProgram, pFragment, ulLength);
		RELEASESFNTFRAG(ClientInfo, pFragment);
	}

	return NO_ERR;
}

FS_PUBLIC ErrorCode sfac_CopyCVT(
	sfac_ClientRec *    ClientInfo,    /* Client Information   */
	F26Dot6 *           pCVT)       /* pointer to CVT    */
{
	uint32              ulLength;
	const int16 *       pFragment;
	int32               lNumCVT;
	int32               lCVTCount;
	const int16 *       psSrcCVT;
	F26Dot6 *           pfxDstCVT;
	ErrorCode           error;

	error = sfac_GetDataPtr (ClientInfo, 0L, ULONG_MAX, sfnt_controlValue, FALSE, (const void **)&pFragment);

	if(error)
	{
		return error;
	}

	ulLength = SFAC_LENGTH (ClientInfo, sfnt_controlValue);

	if (ulLength)
	{
		psSrcCVT = pFragment;
		pfxDstCVT = pCVT;

		lNumCVT = ((int32)ulLength / (int32)sizeof( sfnt_ControlValue));

		for(lCVTCount = 0L; lCVTCount < lNumCVT; lCVTCount++)
		{
			pfxDstCVT[lCVTCount] = (F26Dot6)SWAPW(psSrcCVT[lCVTCount]);
		}

		RELEASESFNTFRAG(ClientInfo, pFragment);
	}

	return NO_ERR;
}

FS_PUBLIC ErrorCode sfac_CopyHdmxEntry(
	sfac_ClientRec *    ClientInfo,     /* Client Information   */
	uint16              usPixelsPerEm,  /* Current Pixels per Em    */
	boolean *           pbFound,        /* Flag indicating if entry found */
	uint16              usFirstGlyph,   /* First Glyph to copy */
	uint16              usLastGlyph,    /* Last Glyph to copy */
	int16 *             psBuffer)       /* Buffer to save glyph sizes */
{
	const uint8 *       pHdmx;
	const uint8 *       pCurrentHdmxRecord;
	uint32              ulHdmxRecordSize;
	uint16              usRecordIndex;
	uint16              usGlyphIndex;
	ErrorCode           error;

	Assert( usFirstGlyph <= usLastGlyph );
	Assert( psBuffer != NULL );

	*pbFound = FALSE;

	error = sfac_GetDataPtr (ClientInfo, 0L, ULONG_MAX, sfnt_HoriDeviceMetrics, FALSE, (const void **)&pHdmx);

	if(error)
	{
		return error;
	}

	/* If no 'hdmx' return success and not found    */

	if( pHdmx == NULL )
	{
		return NO_ERR;
	}

	if((uint16)pHdmx[SFNT_HDMX_VERSION] == 0)   /*  NOTE: No SWAP for zero check    */
	{
		ulHdmxRecordSize = (uint32)SWAPL(*((uint32 *)&pHdmx[SFNT_HDMX_LSIZERECORD]));

		usRecordIndex = 0;
		pCurrentHdmxRecord = &pHdmx[SFNT_HDMX_HDMXTABLE];
		while (  (usRecordIndex < (uint16)SWAPW(*((uint16 *)&pHdmx[SFNT_HDMX_SNUMRECORDS]))) && !*pbFound )
		{
			if( usPixelsPerEm == (uint16)pCurrentHdmxRecord[SFNT_HDMXRECORD_BEMY] )
			{
				*pbFound = TRUE;
			}
			else
			{
				pCurrentHdmxRecord += ulHdmxRecordSize;
			}
			usRecordIndex++;
		}

		if ( *pbFound )
		{
			for( usGlyphIndex = usFirstGlyph; usGlyphIndex <= usLastGlyph; usGlyphIndex++)
			{
				*psBuffer = (int16)pCurrentHdmxRecord[SFNT_HDMXRECORD_BWIDTHS + usGlyphIndex];
				psBuffer++;
			}
		}
	}

	RELEASESFNTFRAG(ClientInfo, pHdmx);

	return NO_ERR;
}

FS_PUBLIC ErrorCode sfac_GetLTSHEntries(
	sfac_ClientRec *    ClientInfo,     /* Client Information   */
	uint16              usPixelsPerEm,  /* Current Pixels per Em    */
	uint16              usFirstGlyph,   /* First Glyph to copy */
	uint16              usLastGlyph,    /* Last Glyph to copy */
	int16 *             psBuffer)       /* Buffer to save glyph sizes */
{
	const uint8 *       pLTSH;
	uint16              usGlyphIndex;
	ErrorCode           error;

	MEMSET(psBuffer, FALSE, ((usLastGlyph - usFirstGlyph) + 1) * sizeof(int16));

	error = sfac_GetDataPtr (ClientInfo, 0L, ULONG_MAX, sfnt_LinearThreshold, FALSE, (const void **)&pLTSH);

	if(error)
	{
		return error;
	}
	
	if( pLTSH == NULL )
	{
		return NO_ERR;
	}

	if((uint16)pLTSH[SFNT_LTSH_VERSION] == 0)   /*  NOTE: No SWAP for zero check    */
	{
		for( usGlyphIndex = usFirstGlyph; usGlyphIndex <= usLastGlyph; usGlyphIndex++ )
		{
			if( usPixelsPerEm >= (uint16)pLTSH[SFNT_LTSH_UBYPELSHEIGHT + usGlyphIndex] )
			{
				*psBuffer = TRUE;
			}
			else
			{
				*psBuffer = FALSE;
			}
			psBuffer++;
		}
	}

	RELEASESFNTFRAG(ClientInfo, pLTSH);

	return NO_ERR;
}



/***************************** Public  Function ****************************\
* sfac_ReadGlyphHeader
*
* This routine sets up the glyph handle to a glyph, and returns the header
* information in the glyph.
*
* Effects:
*
* Error Returns:
*
* UNKNOWN_COMPOSITE_VERSION
*
* History:
* Wed 26-Aug-1992 09:55:19 -by-  Greg Hitchcock [gregh]
*      Added CodeReview fixes
* Tue 09-Jun-1992 18:42:51 -by-  Greg Hitchcock [gregh]
*      Initial version.
\***************************************************************************/

FS_PUBLIC ErrorCode sfac_ReadGlyphHeader(
	sfac_ClientRec *    ClientInfo,       /* Client Information         */
	uint16              usGlyphIndex,     /* Glyph index to read        */
	sfac_GHandle *      hGlyph,           /* Return glyph handle        */
	boolean *           pbCompositeGlyph, /* Is glyph a composite?      */
	boolean *           pbHasOutline,     /* Does glyph have outlines?  */
	int16 *             psNumberOfContours, /* Number of contours in glyph */
	BBOX *              pbbox)            /* Glyph Bounding box         */
{
	uint32              ulLength;
	uint32              ulOffset;
	sfnt_tableIndex     glyphTableIndex;
	ErrorCode           error;
	const uint8 *       GlyphHeader;

	hGlyph->pvGlyphBaseAddress = NULL;
	hGlyph->pvGlyphNextAddress = NULL;

	/* Locate the glyph in the font file   */

	error = sfac_GetGlyphLocation(
		ClientInfo,
		usGlyphIndex,
		&ulOffset,
		&ulLength,
		&glyphTableIndex);

	if(error)
	{
		return error;
	}

	if( ulLength == 0 )
	{
		*psNumberOfContours = 1;
		MEMSET(pbbox, 0, sizeof(BBOX));
		*pbHasOutline = FALSE;
		*pbCompositeGlyph = FALSE;
	}
	else
	{
		if (ulLength < SFNT_PACKEDSPLINEFORMAT_ENDPOINTS)
		{
			return GLYF_TABLE_CORRUPTION_ERR;
		}

		error = sfac_GetDataPtr(ClientInfo, ulOffset, ulLength,
				glyphTableIndex, TRUE, (const void **)&hGlyph->pvGlyphBaseAddress);

		if(error)
		{
			return error;
		}

		hGlyph->pvGlyphEndAddress = (uint8 *)hGlyph->pvGlyphBaseAddress + ulLength;

		GlyphHeader = (uint8 *)hGlyph->pvGlyphBaseAddress;
		*psNumberOfContours = SWAPW(*((int16 *)&GlyphHeader[SFNT_PACKEDSPLINEFORMAT_NUMBEROFCONTOURS]));

		if( *psNumberOfContours < COMPONENTCTRCOUNT )
		{
			return UNKNOWN_COMPOSITE_VERSION;
		}

		if( *psNumberOfContours == COMPONENTCTRCOUNT )
		{
			*pbCompositeGlyph = TRUE;
			*psNumberOfContours = 0;
			*pbHasOutline = FALSE;
		}
		else
		{
			*pbCompositeGlyph = FALSE;
			*pbHasOutline = TRUE;
		}

		pbbox->xMin = SWAPW(*((int16 *)&GlyphHeader[SFNT_PACKEDSPLINEFORMAT_BBOX+BBOX_XMIN]));
		pbbox->yMin = SWAPW(*((int16 *)&GlyphHeader[SFNT_PACKEDSPLINEFORMAT_BBOX+BBOX_YMIN]));
		pbbox->xMax = SWAPW(*((int16 *)&GlyphHeader[SFNT_PACKEDSPLINEFORMAT_BBOX+BBOX_XMAX]));
		pbbox->yMax = SWAPW(*((int16 *)&GlyphHeader[SFNT_PACKEDSPLINEFORMAT_BBOX+BBOX_YMAX]));

		if((pbbox->xMin > pbbox->xMax) || (pbbox->yMin > pbbox->yMax))
		{
			return SFNT_DATA_ERR;
		}

		if(pbHasOutline)
		{
			hGlyph->pvGlyphNextAddress = (voidPtr)&GlyphHeader[SFNT_PACKEDSPLINEFORMAT_ENDPOINTS];
		}
	}

	return NO_ERR;
}

/***************************** Public  Function ****************************\
* sfac_ReadGlyphBbox
*
*
* Effects:
*         This function release the glyph memory immediately
*
* Error Returns:
*
* SFNT_DATA_ERR
*
* History:
* Wed 20-Dec-1996 18:42:51 -by-  Claude Betrisey [claudebe]
*      Initial version.
\***************************************************************************/

FS_PUBLIC ErrorCode sfac_ReadGlyphBbox(
	sfac_ClientRec *    ClientInfo,       /* Client Information         */
	uint16              usGlyphIndex,     /* Glyph index to read        */
	BBOX *              pbbox)            /* Glyph Bounding box         */
{
	uint32              ulLength;
	uint32              ulOffset;
	sfnt_tableIndex     glyphTableIndex;
	ErrorCode           error;
	const uint8 *       GlyphHeader;


	/* Locate the glyph in the font file   */

	error = sfac_GetGlyphLocation(
		ClientInfo,
		usGlyphIndex,
		&ulOffset,
		&ulLength,
		&glyphTableIndex);

	if(error)
	{
		return error;
	}

	if( ulLength == 0 )
	{
		MEMSET(pbbox, 0, sizeof(BBOX));
	}
	else
	{
		error = sfac_GetDataPtr(ClientInfo, ulOffset, ulLength,
				glyphTableIndex, TRUE, (const void **)&GlyphHeader);

		if(error)
		{
			return error;
		}

		pbbox->xMin = SWAPW(*((int16 *)&GlyphHeader[SFNT_PACKEDSPLINEFORMAT_BBOX+BBOX_XMIN]));
		pbbox->yMin = SWAPW(*((int16 *)&GlyphHeader[SFNT_PACKEDSPLINEFORMAT_BBOX+BBOX_YMIN]));
		pbbox->xMax = SWAPW(*((int16 *)&GlyphHeader[SFNT_PACKEDSPLINEFORMAT_BBOX+BBOX_XMAX]));
		pbbox->yMax = SWAPW(*((int16 *)&GlyphHeader[SFNT_PACKEDSPLINEFORMAT_BBOX+BBOX_YMAX]));

		RELEASESFNTFRAG(ClientInfo, GlyphHeader );

		if((pbbox->xMin > pbbox->xMax) || (pbbox->yMin > pbbox->yMax))
		{
			return SFNT_DATA_ERR;
		}


	}

	return NO_ERR;
}

/***************************** Public  Function ****************************\
* sfac_ReadOutlineData
*
*   This routine reads the outline data from the font file. This information
*   includes x and y coordinates, and on-curve indicators as well as start/end
*   points, flags, and instruction data.
*
* Effects:
*   hGlyph
*
* Error Returns:
*   CONTOUR_DATA_ERR
*
* History:
* Wed 26-Aug-1992 09:55:49 -by-  Greg Hitchcock [gregh]
*      Added Code Review fixes
* Tue 09-Jun-1992 18:42:51 -by-  Greg Hitchcock [gregh]
*      Initial version.
\***************************************************************************/


FS_PUBLIC ErrorCode sfac_ReadOutlineData(
	uint8 *             abyOnCurve,             /* Array of on curve indicators per point */
	F26Dot6 *           afxOoy,                 /* Array of ooy points for every point    */
	F26Dot6 *           afxOox,                 /* Array of oox points for every point    */
	sfac_GHandle *      hGlyph,
	LocalMaxProfile *   pMaxProfile,            /* copy of profile                        */
	boolean             bHasOutline,            /* Does glyph have outlines?              */
	int16               sNumberOfContours,      /* Number of contours in glyph            */
	int16 *             asStartPoints,          /* Array of start points for every contour   */
	int16 *             asEndPoints,            /* Array of end points for every contour    */
	uint16 *            pusSizeOfInstructions,  /* Size of instructions in bytes        */
	 uint8 **               pbyInstructions,    /* Pointer to start of glyph instructions    */
     uint32*                pCompositePoints,   /* total number of point for composites, to check for overflow */
     uint32*                pCompositeContours) /* total number of contours for composites, to check for overflow */

{

	uint8 *     pbyCurrentSfntLocation;
	int16 *     psCurrentLocation;
	int16 *     asSfntEndPoints;
	uint8 *     pbySfntFlags;
	uint8       byRepeatFlag;

	int32       lNumPoints;
	int32       lContourIndex;
	int32       lPointCount;
	int32       lPointIndex;
	uint16      usRepeatCount;
	int16       sXValue;
	int16       sYValue;
	uint8 *     pbyFlags;
	F26Dot6 *   pf26OrigX;
	F26Dot6 *   pf26OrigY;

	/* Initialize Fields */

	asStartPoints[0] = 0;
	asEndPoints[0] = 0;

	abyOnCurve[0] = ONCURVE;
	afxOox[0] = 0;
	afxOoy[0] = 0;

	*pbyInstructions = NULL;
	*pusSizeOfInstructions = 0;

	/* If we don't have an outline, exit here   */

	if (!bHasOutline)
	{
		return NO_ERR;
	}

	if (sNumberOfContours <= 0 || sNumberOfContours > (int16)pMaxProfile->maxContours)
	{
		return CONTOUR_DATA_ERR;
	}

    /* Handle the case of outlines   */

	psCurrentLocation = (int16 *)hGlyph->pvGlyphNextAddress;

	asSfntEndPoints = psCurrentLocation;
	psCurrentLocation += sNumberOfContours;

	if ((voidPtr)psCurrentLocation > hGlyph->pvGlyphEndAddress)
	{
		return GLYF_TABLE_CORRUPTION_ERR;
	}

	*pusSizeOfInstructions = (uint16)SWAPWINC (psCurrentLocation);
	*pbyInstructions = (uint8 *)psCurrentLocation;
	pbySfntFlags = (uint8 *)((char *)psCurrentLocation + *pusSizeOfInstructions);

	if ((voidPtr)pbySfntFlags > hGlyph->pvGlyphEndAddress)
	{
		return GLYF_TABLE_CORRUPTION_ERR;
	}


    *pCompositeContours += sNumberOfContours;
	if (*pCompositeContours > (uint32)MAX (pMaxProfile->maxContours, pMaxProfile->maxCompositeContours))
	{
		return CONTOUR_DATA_ERR;
	}

	lContourIndex = 0;

	asStartPoints[lContourIndex] = 0;
	asEndPoints[lContourIndex] = SWAPW (asSfntEndPoints[lContourIndex]);
	lNumPoints = (int32)asEndPoints[lContourIndex] + 1;

	for(lContourIndex = 1; lContourIndex < (int32)sNumberOfContours; lContourIndex++)
	{
		asStartPoints[lContourIndex] = (int16)(asEndPoints[lContourIndex - 1] + 1);
		asEndPoints[lContourIndex] = SWAPW (asSfntEndPoints[lContourIndex]);
		if ((lNumPoints > asEndPoints[lContourIndex]) || (lNumPoints > (int32)pMaxProfile->maxPoints))
		{
			/* array of end points is not in ascending order, or too many points */
			return POINTS_DATA_ERR;
		}
		lNumPoints = (int32)asEndPoints[lContourIndex] + 1;
	}

    *pCompositePoints += lNumPoints;
	if (*pCompositePoints > (uint32)MAX (pMaxProfile->maxPoints, pMaxProfile->maxCompositePoints) )
	{
		return POINTS_DATA_ERR;
	}

	/* Do flags */

	usRepeatCount = 0;

	lPointCount = lNumPoints;
	pbyFlags = abyOnCurve;

	while(lPointCount > 0)
	{
		if(usRepeatCount == 0)
		{
			*pbyFlags = *pbySfntFlags;

			if(*pbyFlags & REPEAT_FLAGS)
			{
				pbySfntFlags++;
				usRepeatCount = (uint16)*pbySfntFlags;
			}
			pbySfntFlags++;
			pbyFlags++;
			lPointCount--;
		}
		else
		{
			byRepeatFlag = pbyFlags[-1];
			lPointCount -= (int32)usRepeatCount;

			if (lPointCount < 0)
			{
				return GLYF_TABLE_CORRUPTION_ERR;
			}

			while(usRepeatCount > 0)
			{
				*pbyFlags = byRepeatFlag;
				pbyFlags++;
				usRepeatCount--;
			}
		}
	}

	pbyCurrentSfntLocation = pbySfntFlags;

	if(usRepeatCount > 0)
	{
		return POINTS_DATA_ERR;
	}

	if ((voidPtr)pbyCurrentSfntLocation > hGlyph->pvGlyphEndAddress)
	{
		return GLYF_TABLE_CORRUPTION_ERR;
	}
	/* Do X first */

	sXValue = 0;
	pf26OrigX = afxOox;
	pbyFlags = abyOnCurve;

	for(lPointIndex = 0; lPointIndex < lNumPoints; lPointIndex++)
	{
		if(*pbyFlags & XSHORT)
		{
			if(*pbyFlags & SHORT_X_IS_POS)
			{
				sXValue += (int16)SFAC_GETUNSIGNEDBYTEINC (pbyCurrentSfntLocation);
			}
			else
			{
				sXValue -= (int16)SFAC_GETUNSIGNEDBYTEINC (pbyCurrentSfntLocation);
			}
		}
		else if (! (*pbyFlags & NEXT_X_IS_ZERO))
		{
			/* This means we have a two byte quantity */

			sXValue += SWAPW(*((int16 *)pbyCurrentSfntLocation));
			pbyCurrentSfntLocation += sizeof(int16);
		}
		*pf26OrigX = (F26Dot6)sXValue;
		pf26OrigX++;
		pbyFlags++;
	}

	if ((voidPtr)pbyCurrentSfntLocation > hGlyph->pvGlyphEndAddress)
	{
		return GLYF_TABLE_CORRUPTION_ERR;
	}
	/* Now Do Y */

	sYValue = 0;
	pf26OrigY = afxOoy;
	pbyFlags = abyOnCurve;

	for(lPointIndex = 0; lPointIndex < lNumPoints; lPointIndex++)
	{
		if(*pbyFlags & YSHORT)
		{
			if(*pbyFlags & SHORT_Y_IS_POS)
			{
				sYValue += (int16)SFAC_GETUNSIGNEDBYTEINC (pbyCurrentSfntLocation);
			}
			else
			{
				sYValue -= (int16)SFAC_GETUNSIGNEDBYTEINC (pbyCurrentSfntLocation);
			}
		}
		else if (! (*pbyFlags & NEXT_Y_IS_ZERO))
		{
			/* This means we have a two byte quantity */

			sYValue += SWAPW(*((int16 *)pbyCurrentSfntLocation));
			pbyCurrentSfntLocation += sizeof(int16);
		}
		*pf26OrigY = (F26Dot6)sYValue;
		pf26OrigY++;

		/* Clear out extraneous bits in OnCurve */

		*pbyFlags &= ONCURVE;
		pbyFlags++;
	}

	if ((voidPtr)pbyCurrentSfntLocation > hGlyph->pvGlyphEndAddress)
	{
		return GLYF_TABLE_CORRUPTION_ERR;
	}

	hGlyph->pvGlyphNextAddress = (voidPtr)pbyCurrentSfntLocation;

	return NO_ERR;
}

/***************************** Public  Function ****************************\
*
* sfac_ReadComponentData
*
*   This routine reads information from the font file for positioning and
*   scaling a glyph component.
*
* Effects:
*
* Error Returns:
*   none
*
* History:
* Wed 26-Aug-1992 09:56:29 -by-  Greg Hitchcock [gregh]
*      Added Code Review Fixes
* Tue 09-Jun-1992 18:42:51 -by-  Greg Hitchcock [gregh]
*      Initial version.
\***************************************************************************/

FS_PUBLIC ErrorCode sfac_ReadComponentData(
	sfac_GHandle *          hGlyph,
	sfac_ComponentTypes *   pMultiplexingIndicator, /* Indicator for Anchor vs offsets  */
	boolean *               pbRoundXYToGrid,  /* Round composite offsets to grid     */
	boolean *               pbUseMyMetrics,   /* Use component metrics            */
	boolean *               pbScaleCompositeOffset,   /* Do we scale the composite offset, Apple/MS   */
	boolean *               pbWeHaveInstructions, /* Composite has instructions         */
	uint16 *                pusComponentGlyphIndex, /* Glyph index of component         */
	int16 *                 psXOffset,        /* X Offset of component (if app)      */
	int16 *                 psYOffset,        /* Y Offset of component (if app)      */
	uint16 *                pusAnchorPoint1,  /* Anchor point 1 of component (if app) */
	uint16 *                pusAnchorPoint2,  /* Anchor point 2 of component (if app) */
	transMatrix             *pMulT,           /* Transformation matrix for component */
	boolean *				pbWeHaveAScale,     /* We have a scaling in pMulT					*/
	boolean *               pbLastComponent)   /* Is this the last component?                  */

{
	int16 *     psCurrentLocation;
	uint16      usComponentFlags;
	char *      byteP;

	Fixed       fMultiplier;


	psCurrentLocation = (int16 *)hGlyph->pvGlyphNextAddress;

	/* Initialize values */

	/* Initialize transformation matrix to identity */

	*pMulT = IdentTransform;

	*psXOffset = 0;
	*psYOffset = 0;
	*pusAnchorPoint1 = 0;
	*pusAnchorPoint2 = 0;
	*pbWeHaveAScale = FALSE;

	usComponentFlags = (uint16)SWAPWINC(psCurrentLocation);

	*pbWeHaveInstructions = ((usComponentFlags & WE_HAVE_INSTRUCTIONS) == WE_HAVE_INSTRUCTIONS);
	*pbUseMyMetrics =    ((usComponentFlags & USE_MY_METRICS) == USE_MY_METRICS);
	*pbRoundXYToGrid =      ((usComponentFlags & ROUND_XY_TO_GRID) == ROUND_XY_TO_GRID);

	/* new flags that indicate if the glyph was designed to have the component offset scaled or not
	   Apple does scale the component offset, MS doesn't, those flags are supposed to be clear on old fonts
	   on new fonts, only one of these flags must be set,
	   default is set to false, MS behavior */
	if ((usComponentFlags & SCALED_COMPONENT_OFFSET) == SCALED_COMPONENT_OFFSET)
	{
		*pbScaleCompositeOffset = TRUE;
	}
	if ((usComponentFlags & UNSCALED_COMPONENT_OFFSET) == UNSCALED_COMPONENT_OFFSET)
	{
		*pbScaleCompositeOffset = FALSE;
	}

	*pusComponentGlyphIndex = (uint16)SWAPWINC(psCurrentLocation);

	if (usComponentFlags & ARGS_ARE_XY_VALUES)
	{
		*pMultiplexingIndicator = OffsetPoints;
	}
	else
	{
		*pMultiplexingIndicator = AnchorPoints;
	}


	/*
		!!!APPLEBUG The rasterizer did not handle Word Anchor Points. This
		!!!APPLEBUG has been corrected in our version of the rasterizer, but
		!!!APPLEBUG we need to verify with the Apple source code.  --GregH
	 */

	if (usComponentFlags & ARG_1_AND_2_ARE_WORDS)
	{
		if (usComponentFlags & ARGS_ARE_XY_VALUES)
		{
			*psXOffset    = SWAPWINC (psCurrentLocation);
			*psYOffset    = SWAPWINC (psCurrentLocation);
		}
		else
		{
			*pusAnchorPoint1 = (uint16) SWAPWINC (psCurrentLocation);
			*pusAnchorPoint2 = (uint16) SWAPWINC (psCurrentLocation);
		}
	}
	else
	{
		byteP = (char *)psCurrentLocation;
		if (usComponentFlags & ARGS_ARE_XY_VALUES)
		{
		/* offsets are signed */
			*psXOffset = (int16)(int8)*byteP++;
			*psYOffset = (int16)(int8)*byteP;
		}
		else
		{
		/* anchor points are unsigned */
			*pusAnchorPoint1 = (uint16)(uint8) * byteP++;
			*pusAnchorPoint2 = (uint16)(uint8) * byteP;
		}
		++psCurrentLocation;
	}


	if (usComponentFlags & (WE_HAVE_A_SCALE | WE_HAVE_AN_X_AND_Y_SCALE | WE_HAVE_A_TWO_BY_TWO))
	{

		*pbWeHaveAScale = TRUE;

		if (usComponentFlags & WE_HAVE_A_TWO_BY_TWO)
		{
			fMultiplier  = (Fixed)SWAPWINC (psCurrentLocation); /* read 2.14 */
			pMulT->transform[0][0] = (fMultiplier << 2); /* turn into 16.16 */

			fMultiplier  = (Fixed)SWAPWINC (psCurrentLocation); /* read 2.14 */
			pMulT->transform[0][1] = (fMultiplier << 2); /* turn into 16.16 */

			fMultiplier  = (Fixed)SWAPWINC (psCurrentLocation); /* read 2.14 */
			pMulT->transform[1][0] = (fMultiplier << 2); /* turn into 16.16 */

			fMultiplier  = (Fixed)SWAPWINC (psCurrentLocation); /* read 2.14 */
			pMulT->transform[1][1] = (fMultiplier << 2); /* turn into 16.16 */

		}
		else
		{
			/* If we have a scale factor, build it into the transformation matrix   */

			pMulT->transform[0][1] = 0;
			pMulT->transform[1][0] = 0;

			fMultiplier  = (Fixed)SWAPWINC (psCurrentLocation); /* read 2.14 */
			pMulT->transform[0][0] = (fMultiplier <<= 2); /* turn into 16.16 */

			if (usComponentFlags & WE_HAVE_AN_X_AND_Y_SCALE)
			{
				fMultiplier  = (Fixed)SWAPWINC (psCurrentLocation); /* read 2.14 */
				pMulT->transform[1][1] = (fMultiplier <<= 2); /* turn into 16.16 */
			}
			else
			{
				pMulT->transform[1][1] = pMulT->transform[0][0];
			}
		}
	}
	*pbLastComponent = !((usComponentFlags & MORE_COMPONENTS) == MORE_COMPONENTS);

	hGlyph->pvGlyphNextAddress = (voidPtr)psCurrentLocation;

	if (hGlyph->pvGlyphNextAddress > hGlyph->pvGlyphEndAddress)
	{
		return GLYF_TABLE_CORRUPTION_ERR;
	}
	return NO_ERR;
}

/***************************** Public  Function ****************************\
*
* sfac_ReadCompositeInstructions
*
*   This routine returns the instructions for the composite
*
* Effects:
*   none
*
* Error Returns:
*   none
*
* History:
* Tue 09-Jun-1992 18:42:51 -by-  Greg Hitchcock [gregh]
*      Initial version.
\***************************************************************************/

FS_PUBLIC ErrorCode sfac_ReadCompositeInstructions(
	sfac_GHandle * hGlyph,
	uint8 **    pbyInstructions,     /* Pointer to start of glyph instructions */
	uint16 *    pusSizeOfInstructions) /* Size of instructions in bytes           */
{
	int16 *    psCurrentLocation;

	psCurrentLocation = (int16 *)hGlyph->pvGlyphNextAddress;

	*pusSizeOfInstructions = (uint16)SWAPWINC (psCurrentLocation);
	*pbyInstructions = (uint8 *)psCurrentLocation;
	hGlyph->pvGlyphNextAddress = (voidPtr)(*pbyInstructions + *pusSizeOfInstructions);

	if (hGlyph->pvGlyphNextAddress > hGlyph->pvGlyphEndAddress)
	{
		return GLYF_TABLE_CORRUPTION_ERR;
	}

	return NO_ERR;
}

/***************************** Public  Function ****************************\
*
* sfac_ReleaseGlyph
*
*   This routine releases the glyph handle for the font file
*
* Effects:
*   none
*
* Error Returns:
*   none
*
* History:
* Tue 09-Jun-1992 18:42:51 -by-  Greg Hitchcock [gregh]
*      Initial version.
\***************************************************************************/

FS_PUBLIC ErrorCode sfac_ReleaseGlyph(
	sfac_ClientRec *  ClientInfo,
	sfac_GHandle *    hGlyph)
{
	if(hGlyph->pvGlyphNextAddress)
	{
		RELEASESFNTFRAG(ClientInfo,(voidPtr)hGlyph->pvGlyphBaseAddress);

		hGlyph->pvGlyphNextAddress = NULL;
		hGlyph->pvGlyphBaseAddress = NULL;

	}

	return NO_ERR;
}

/***************************************************************************/

/*      Embedded Bitmap (sbit) Access Routines      */

/**********************************************************************/

/*  Local constants  */

#define     SBIT_BLOC_TABLE         1       /* which table are metrics in */
#define     SBIT_BDAT_TABLE         2

#define     SBIT_HORIZ_METRICS      1       /* which kind of metrics */
#define     SBIT_VERT_METRICS       2
#define     SBIT_BIG_METRICS        3

typedef enum {                              /* metrics type */
	flgHorizontal = 0x01,
	flgVertical = 0x02
} bitmapFlags;

FS_PRIVATE boolean FindBlocStrike (         /* helper function prototype */
	const uint8 *pbyBloc,
	uint16 usPpemX, 
	uint16 usPpemY, 
	uint16 usOverScale,            /* outline magnification requested */
	uint16 *pusBitDepth,			/* 1 for B/W bitmap, 2, 4 or 8 for gray sbit */
	uint32 *pulStrikeOffset );

FS_PRIVATE boolean FindBscaStrike (         /* helper function prototype */
	const uint8 *pbyBsca,
	uint16 usPpemX, 
	uint16 usPpemY, 
	uint32 *pulStrikeOffset );

/*  byte size bitmap range masks */

static uint8    achStartMask[] = { 0xFF, 0x7F, 0x3F, 0x1F, 0x0F, 0x07, 0x03, 0x01 };
static uint8    achStopMask[] =  { 0x00, 0x80, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC, 0xFE, 0xFF };
					
/**********************************************************************/

FS_PUBLIC ErrorCode sfac_SearchForStrike (
	sfac_ClientRec *pClientInfo,
	uint16 usPpemX, 
	uint16 usPpemY, 
	uint16 usOverScale,            /* outline magnification requested */
	uint16 *pusBitDepth,			/* 1 for B/W bitmap, 2, 4 or 8 for gray sbit */
	uint16 *pusTableState,
	uint16 *pusSubPpemX,
	uint16 *pusSubPpemY,
	uint32 *pulStrikeOffset )
{
	const uint8 *   pbyBloc;
	const uint8 *   pbyBsca;
	ErrorCode       ReturnCode;
	
	*pusTableState = SBIT_NOT_FOUND;                /* defaults */
	*pulStrikeOffset = 0L;
	*pusSubPpemX = 0;
	*pusSubPpemY = 0;

	ReturnCode = sfac_GetDataPtr (
		pClientInfo,                                /* callback etc. */
		0L,                                         /* table start */
		ULONG_MAX,                                  /* read whole table */
		sfnt_BitmapLocation,                        /* registered tag */
		FALSE,                                      /* doesn't have to be there */
		(const void**)&pbyBloc );                   /* data pointer */
	
	if (ReturnCode != NO_ERR) return ReturnCode;
	
	if (pbyBloc != NULL)                            /* if bloc exists */
	{
		if (FindBlocStrike (pbyBloc, usPpemX, usPpemY, usOverScale, pusBitDepth, pulStrikeOffset))
		{
			*pusTableState = SBIT_BLOC_FOUND;       /* exact match */
		}
		else                                        /* if bloc and NO match */
		{
			ReturnCode = sfac_GetDataPtr (
				pClientInfo,                        /* callback etc. */
				0L,                                 /* table start */
				ULONG_MAX,                          /* read whole table */
				sfnt_BitmapScale,                   /* registered tag */
				FALSE,                              /* doesn't have to be there */
				(const void**)&pbyBsca );           /* data pointer */
			
			if (ReturnCode != NO_ERR) return ReturnCode;
			
			if (pbyBsca != NULL)                    /* if bsca exists */
			{
				if (FindBscaStrike (pbyBsca, usPpemX, usPpemY, pulStrikeOffset))
				{
					*pusSubPpemX = (uint16)pbyBsca[*pulStrikeOffset + SFNT_BSCA_SUBPPEMX];
					*pusSubPpemY = (uint16)pbyBsca[*pulStrikeOffset + SFNT_BSCA_SUBPPEMY];
					
					if (FindBlocStrike (pbyBloc, *pusSubPpemX, *pusSubPpemY, usOverScale, pusBitDepth, pulStrikeOffset))
					{
						*pusTableState = SBIT_BSCA_FOUND;
					}
				}
				RELEASESFNTFRAG(pClientInfo, pbyBsca );
			}
		}
		RELEASESFNTFRAG(pClientInfo, pbyBloc);
	}
	return NO_ERR;
}

/**********************************************************************/

/*  Find a strike that matches ppemX & Y in the bloc table */

FS_PRIVATE boolean FindBlocStrike (
	const uint8 *pbyBloc,
	uint16 usPpemX, 
	uint16 usPpemY, 
	uint16 usOverScale,            /* outline magnification requested */
	uint16 *pusBitDepth,			/* 1 for B/W bitmap, 2, 4 or 8 for gray sbit */
	uint32 *pulStrikeOffset )
{
	uint32          ulNumStrikes;
	uint32          ulStrikeOffset;
	uint32          ulColorRefOffset;
	uint16			usPreferedBitDepth, usBestBitDepth, usCurrentBitDepth;
	uint16			usSbitBitDepthMask;
	
	ulNumStrikes = (uint32)SWAPL(*((uint32*)&pbyBloc[SFNT_BLOC_NUMSIZES]));
	ulStrikeOffset = SFNT_BLOC_FIRSTSTRIKE;

	usBestBitDepth = 0;
	
	if (usOverScale == 0)
	{
		usPreferedBitDepth = 1;
		usSbitBitDepthMask = SBIT_BITDEPTH_MASK & 0x0002; /* accept only black/white bitmap */
	} else 
	{
		if (usOverScale == 2)
		{
			usPreferedBitDepth = 2;
		} else if (usOverScale == 4) 
		{
			usPreferedBitDepth = 4;
		} else
		{
			usPreferedBitDepth = 8;
		}
		usSbitBitDepthMask = SBIT_BITDEPTH_MASK & ~0x0002; /* accept only grayscale bitmap */
	} 

	while (ulNumStrikes > 0)
	{
		if ((usPpemX == (uint16)pbyBloc[ulStrikeOffset + SFNT_BLOC_PPEMX]) &&
			(usPpemY == (uint16)pbyBloc[ulStrikeOffset + SFNT_BLOC_PPEMY]))
		{
			ulColorRefOffset = (uint32)SWAPL(*((uint32*)&pbyBloc[ulStrikeOffset + SFNT_BLOC_COLORREF]));
			usCurrentBitDepth = pbyBloc[ulStrikeOffset + SFNT_BLOC_BITDEPTH];

			if (((0x01 << usCurrentBitDepth) & usSbitBitDepthMask) && (ulColorRefOffset == 0L))
			{
				if (usCurrentBitDepth == usPreferedBitDepth)
				{
					/* perfect match */
					*pulStrikeOffset = ulStrikeOffset;
					*pusBitDepth = usPreferedBitDepth;
					return TRUE;      
				} else if (usCurrentBitDepth > usPreferedBitDepth)
				{
					/* above is better than below */
					if ((usCurrentBitDepth < usBestBitDepth) || (usBestBitDepth < usPreferedBitDepth))
					{
						/* above and closer */
						*pulStrikeOffset = ulStrikeOffset;
						usBestBitDepth = usCurrentBitDepth;
					}
				} else /* if (usCurrentBitDepth < usPreferedBitDepth) */
				{
					/* we look below the prefered only if we don't have found anything above */
					if ((usBestBitDepth < usPreferedBitDepth) && (usCurrentBitDepth > usBestBitDepth))
					{
						/* below and closer */
						*pulStrikeOffset = ulStrikeOffset;
						usBestBitDepth = usCurrentBitDepth;
					}
				}
			}
		}
		ulNumStrikes--;
		ulStrikeOffset += SIZEOF_BLOC_SIZESUBTABLE;
	}

	if (usBestBitDepth != 0)
	{
		*pusBitDepth = usBestBitDepth;
		return TRUE;                                   /* best match found */
	} 

	return FALSE;                                   /* match not found */
}

/**********************************************************************/

/*  Find a strike that matches ppemX & Y in the bsca table */

FS_PRIVATE boolean FindBscaStrike (
	const uint8 *pbyBsca,
	uint16 usPpemX, 
	uint16 usPpemY, 
	uint32 *pulStrikeOffset )
{
	uint32          ulNumStrikes;
	uint32          ulStrikeOffset;
	
	ulNumStrikes = (uint32)SWAPL(*((uint32*)&pbyBsca[SFNT_BSCA_NUMSIZES]));
	ulStrikeOffset = SFNT_BSCA_FIRSTSTRIKE;
								
	while (ulNumStrikes > 0)
	{
		if ((usPpemX == (uint16)pbyBsca[ulStrikeOffset + SFNT_BSCA_PPEMX]) &&
			(usPpemY == (uint16)pbyBsca[ulStrikeOffset + SFNT_BSCA_PPEMY]))
		{
			*pulStrikeOffset = ulStrikeOffset;
			return TRUE;                            /* match found */
		}
		ulNumStrikes--;
		ulStrikeOffset += SIZEOF_BSCA_SIZESUBTABLE;
	}
	return FALSE;                                   /* match not found */
}

/**********************************************************************/

/*  Look for a glyph in a given strike */        

FS_PUBLIC ErrorCode sfac_SearchForBitmap (
	sfac_ClientRec *pClientInfo,
	uint16 usGlyphCode,
	uint32 ulStrikeOffset,
	boolean *pbGlyphFound,                   /* return values */
	uint16 *pusMetricsType,
	uint16 *pusMetricsTable,
	uint32 *pulMetricsOffset,
	uint16 *pusBitmapFormat,
	uint32 *pulBitmapOffset,
	uint32 *pulBitmapLength )
{
	const uint8 *   pbyBloc;
	ErrorCode       ReturnCode;

	uint32      ulNumIndexTables;
	uint32      ulIndexArrayTop;
	uint32      ulIndexArrayOffset;
	uint32      ulSubTableOffset;
	uint32      ulGlyphOffset;
	uint32      ulNextGlyphOffset;
	uint32      ulBitmapLength;
	uint32      ulImageDataOffset;
	uint32      ulNumGlyphs;
	uint32      ulTop;                      /* binary search ranges */
	uint32      ulBottom;
	uint32      ulHit;
	uint32      ulHitOffset;

	uint16      usStartGlyph;               /* for whole strike */
	uint16      usEndGlyph;
	uint16      usFirstGlyph;               /* for one sub table */
	uint16      usLastGlyph;
	uint16      usIndexFormat;
	uint16      usImageFormat;
	uint16      usHitCode;
	
	bitmapFlags bmfDirection;               /* horiz or vert */

	
	*pbGlyphFound = FALSE;                              /* default */

	ReturnCode = sfac_GetDataPtr (
		pClientInfo,                                    /* callback etc. */
		0L,                                             /* table start */
		ULONG_MAX,                                      /* read whole table */
		sfnt_BitmapLocation,                            /* registered tag */
		TRUE,                                           /* better be there now */
		(const void**)&pbyBloc );                       /* data pointer */
	
	if (ReturnCode != NO_ERR) return ReturnCode;
		
	usStartGlyph = (uint16)SWAPW(*((uint16*)&pbyBloc[ulStrikeOffset + SFNT_BLOC_STARTGLYPH]));
	usEndGlyph = (uint16)SWAPW(*((uint16*)&pbyBloc[ulStrikeOffset + SFNT_BLOC_ENDGLYPH]));

	if ((usStartGlyph > usGlyphCode) || (usEndGlyph < usGlyphCode))
	{
		RELEASESFNTFRAG(pClientInfo, pbyBloc);
		return NO_ERR;                                  /* glyph out of range */
	}

	ulNumIndexTables = (uint32)SWAPL(*((uint32*)&pbyBloc[ulStrikeOffset + SFNT_BLOC_NUMINDEXTABLES]));
	ulIndexArrayTop = (uint32)SWAPL(*((uint32*)&pbyBloc[ulStrikeOffset + SFNT_BLOC_INDEXARRAYOFFSET]));
	ulIndexArrayOffset = ulIndexArrayTop;

	while ((ulNumIndexTables > 0) && (*pbGlyphFound == FALSE))
	{
		usFirstGlyph = (uint16)SWAPW(*((uint16*)&pbyBloc[ulIndexArrayOffset + SFNT_BLOC_FIRSTGLYPH]));
		usLastGlyph = (uint16)SWAPW(*((uint16*)&pbyBloc[ulIndexArrayOffset + SFNT_BLOC_LASTGLYPH]));
	
		if ((usFirstGlyph <= usGlyphCode) && (usLastGlyph >= usGlyphCode))
		{
			ulSubTableOffset = ulIndexArrayTop +
				(uint32)SWAPL(*((uint32*)&pbyBloc[ulIndexArrayOffset + SFNT_BLOC_ADDITIONALOFFSET]));
			
			usIndexFormat = (uint16)SWAPW(*((uint16*)&pbyBloc[ulSubTableOffset + SFNT_BLOC_INDEXFORMAT]));
			usImageFormat = (uint16)SWAPW(*((uint16*)&pbyBloc[ulSubTableOffset + SFNT_BLOC_IMAGEFORMAT]));
			ulImageDataOffset = (uint32)SWAPL(*((uint32*)&pbyBloc[ulSubTableOffset + SFNT_BLOC_IMAGEOFFSET]));

/* decode the individual index subtable formats */            

			switch(usIndexFormat)                       /* different search req's */
			{
			case 1:
				ulSubTableOffset += SFNT_BLOC_OFFSETARRAY + sizeof(uint32) * (uint32)(usGlyphCode - usFirstGlyph);
				ulGlyphOffset = (uint32)SWAPL(*((uint32*)&pbyBloc[ulSubTableOffset]));
				
				ulSubTableOffset += sizeof(uint32);
				ulNextGlyphOffset = (uint32)SWAPL(*((uint32*)&pbyBloc[ulSubTableOffset]));
				ulBitmapLength = ulNextGlyphOffset - ulGlyphOffset;

				if (ulBitmapLength == 0)
				{
					RELEASESFNTFRAG(pClientInfo, pbyBloc);
					return NO_ERR;                      /* no bitmap data stored */
				}
				ulImageDataOffset += ulGlyphOffset;
				*pulMetricsOffset = ulImageDataOffset;
				*pusMetricsTable = SBIT_BDAT_TABLE;
				break;
			
			case 2:
				ulBitmapLength = (uint32)SWAPL(*((uint32*)&pbyBloc[ulSubTableOffset + SFNT_BLOC_IDX2IMAGESIZE]));
				ulImageDataOffset += ulBitmapLength * (usGlyphCode - usFirstGlyph);
				*pulBitmapOffset = ulImageDataOffset;
				
				*pulMetricsOffset = ulSubTableOffset + SFNT_BLOC_IDX2METRICS;
				*pusMetricsTable = SBIT_BLOC_TABLE;
				*pusMetricsType = SBIT_BIG_METRICS;
				break;
			
			case 3:
				ulSubTableOffset += SFNT_BLOC_OFFSETARRAY + sizeof(uint16) * (uint32)(usGlyphCode - usFirstGlyph);
				ulGlyphOffset = (uint32)(uint16)SWAPW(*((uint16*)&pbyBloc[ulSubTableOffset]));
				
				ulSubTableOffset += sizeof(uint16);
				ulNextGlyphOffset = (uint32)(uint16)SWAPW(*((uint16*)&pbyBloc[ulSubTableOffset]));
				ulBitmapLength = ulNextGlyphOffset - ulGlyphOffset;

				if (ulBitmapLength == 0)
				{
					RELEASESFNTFRAG(pClientInfo, pbyBloc);
					return NO_ERR;                      /* no bitmap data stored */
				}
				ulImageDataOffset += ulGlyphOffset;
				*pulMetricsOffset = ulImageDataOffset;
				*pusMetricsTable = SBIT_BDAT_TABLE;
				break;
			
			case 4:
				ulNumGlyphs = (uint32)SWAPL(*((uint32*)&pbyBloc[ulSubTableOffset + SFNT_BLOC_IDX4NUMGLYPHS]));
				ulTop = 0L;
				ulBottom = ulNumGlyphs - 1L;
				ulSubTableOffset += SFNT_BLOC_IDX4OFFSETARRAY;  /* array base */

				ulHit = ulTop;
				ulHitOffset = ulSubTableOffset;
				usHitCode = (uint16)SWAPW(*((uint16*)&pbyBloc[ulHitOffset + SFNT_BLOC_IDX4CODE]));
				if (usHitCode != usGlyphCode)
				{
					ulHit = ulBottom;
					ulHitOffset = ulSubTableOffset + (ulHit * SIZEOF_CODEOFFSETPAIR);
					usHitCode = (uint16)SWAPW(*((uint16*)&pbyBloc[ulHitOffset + SFNT_BLOC_IDX4CODE]));
					while (usHitCode != usGlyphCode)
					{
						if (usHitCode < usGlyphCode)    /* binary search for glyph code */
						{
							ulTop = ulHit;
						}
						else
						{
							ulBottom = ulHit;
						}
						
						if ((ulBottom - ulTop) < 2L)
						{
							RELEASESFNTFRAG(pClientInfo, pbyBloc);
							return NO_ERR;              /* glyph not found */
						}
						
						ulHit = (ulTop + ulBottom) >> 1L;
						ulHitOffset = ulSubTableOffset + (ulHit * SIZEOF_CODEOFFSETPAIR);
						usHitCode = (uint16)SWAPW(*((uint16*)&pbyBloc[ulHitOffset + SFNT_BLOC_IDX4CODE]));
					}
				}
				ulGlyphOffset = (uint32)(uint16)SWAPW(*((uint16*)&pbyBloc[ulHitOffset + SFNT_BLOC_IDX4OFFSET]));
				ulNextGlyphOffset = (uint32)(uint16)SWAPW(*((uint16*)&pbyBloc[ulHitOffset + SIZEOF_CODEOFFSETPAIR + SFNT_BLOC_IDX4OFFSET]));
				ulBitmapLength = ulNextGlyphOffset - ulGlyphOffset;
				
				ulImageDataOffset += ulGlyphOffset;
				*pulMetricsOffset = ulImageDataOffset;
				*pusMetricsTable = SBIT_BDAT_TABLE;
				break;
			
			case 5:
				ulBitmapLength = (uint32)SWAPL(*((uint32*)&pbyBloc[ulSubTableOffset + SFNT_BLOC_IDX5IMAGESIZE]));
				
				*pulMetricsOffset = ulSubTableOffset + SFNT_BLOC_IDX5METRICS;
				*pusMetricsTable = SBIT_BLOC_TABLE;
				*pusMetricsType = SBIT_BIG_METRICS;
				
				ulNumGlyphs = (uint32)SWAPL(*((uint32*)&pbyBloc[ulSubTableOffset + SFNT_BLOC_IDX5NUMGLYPHS]));
				ulTop = 0L;
				ulBottom = ulNumGlyphs - 1L;
				ulSubTableOffset += SFNT_BLOC_IDX5CODEARRAY;  /* array base */

				ulHit = ulTop;
				ulHitOffset = ulSubTableOffset;
				usHitCode = (uint16)SWAPW(*((uint16*)&pbyBloc[ulHitOffset]));
				if (usHitCode != usGlyphCode)
				{
					ulHit = ulBottom;
					ulHitOffset = ulSubTableOffset + (ulHit * sizeof(uint16));
					usHitCode = (uint16)SWAPW(*((uint16*)&pbyBloc[ulHitOffset + SFNT_BLOC_IDX4CODE]));
					while (usHitCode != usGlyphCode)
					{
						if (usHitCode < usGlyphCode)    /* binary search for glyph code */
						{
							ulTop = ulHit;
						}
						else
						{
							ulBottom = ulHit;
						}
						
						if ((ulBottom - ulTop) < 2L)
						{
							RELEASESFNTFRAG(pClientInfo, pbyBloc);
							return NO_ERR;              /* glyph not found */
						}
						
						ulHit = (ulTop + ulBottom) >> 1L;
						ulHitOffset = ulSubTableOffset + (ulHit * sizeof(uint16));
						usHitCode = (uint16)SWAPW(*((uint16*)&pbyBloc[ulHitOffset]));
					}
				}
				ulImageDataOffset += ulBitmapLength * ulHit;
				*pulBitmapOffset = ulImageDataOffset;
				break;
			
			
			default:
				
				RELEASESFNTFRAG(pClientInfo, pbyBloc);
				return NO_ERR;                          /* unknown format */
			}

/* use the glyph formats to calculate metrics type & data offsets */
				
			*pulBitmapLength = ulBitmapLength;
			*pusBitmapFormat = usImageFormat;           /* save for bitmap decoding */
			bmfDirection = (bitmapFlags)pbyBloc[ulStrikeOffset + SFNT_BLOC_FLAGS];

			switch(usImageFormat)                       /* different metrics sizes */
			{
			case 1:                                     /* small glyph metrics */
			case 2:
				if (bmfDirection == flgHorizontal)
				{
					*pusMetricsType = SBIT_HORIZ_METRICS;
				}
				else
				{
					Assert(bmfDirection == flgVertical);

					*pusMetricsType = SBIT_VERT_METRICS;
				}
				*pulBitmapOffset = ulImageDataOffset + SIZEOF_SBIT_SMALLMETRICS;
				*pbGlyphFound = TRUE;
				break;
			
			case 3:
				break;
			
			case 4:
				break;
			
			case 5:             /* bitmap offset and metrics type set above */
				*pbGlyphFound = TRUE;
				break;
			
			case 6:
			case 7:
			case 9:
				*pusMetricsType = SBIT_BIG_METRICS;
				*pulBitmapOffset = ulImageDataOffset + SIZEOF_SBIT_BIGMETRICS;
				*pbGlyphFound = TRUE;
				break;
			
			case 8:
				if (bmfDirection == flgHorizontal)
				{
					*pusMetricsType = SBIT_HORIZ_METRICS;
				}
				else
				{
					Assert(bmfDirection == flgVertical);

					*pusMetricsType = SBIT_VERT_METRICS;
				}
				*pulBitmapOffset = ulImageDataOffset + SIZEOF_SBIT_SMALLMETRICS + SIZEOF_SBIT_GLYPH8PAD;
				*pbGlyphFound = TRUE;
				break;

			default:
				break;
			}
		}
		ulNumIndexTables--;    
		ulIndexArrayOffset += SIZEOF_BLOC_INDEXARRAY;
	}
	
	RELEASESFNTFRAG(pClientInfo, pbyBloc);
	return NO_ERR;
}


/**********************************************************************/

/* fetch the horizontal metrics */

FS_PUBLIC ErrorCode sfac_GetSbitMetrics (
	sfac_ClientRec *pClientInfo,
	uint16 usMetricsType,
	uint16 usMetricsTable,
	uint32 ulMetricsOffset,
	uint16 *pusHeight,
	uint16 *pusWidth,
	int16 *psLSBearingX,
	int16 *psLSBearingY,
	int16 *psTopSBearingX, /* NEW */
	int16 *psTopSBearingY, /* NEW */
	uint16 *pusAdvanceWidth,
	uint16 *pusAdvanceHeight,  /* NEW */
   	boolean *pbHorMetricsFound, /* NEW */
   	boolean *pbVertMetricsFound ) /* NEW */
{
	const uint8     *pbyTable;
	uint32          ulTableLength;
	sfnt_tableIndex TableIndex;
	ErrorCode       ReturnCode;

	*pbHorMetricsFound = FALSE;                        /* default */
	*pbVertMetricsFound = FALSE;                        /* default */

	if (usMetricsTable == SBIT_BDAT_TABLE)          /* if metrics in bdat */
	{
		TableIndex = sfnt_BitmapData;
	}
	else                                            /* if metrics in bloc */
	{
		TableIndex = sfnt_BitmapLocation;
	}
	if (usMetricsType == SBIT_BIG_METRICS)          /* if both h & v metrics */
	{
		ulTableLength = SIZEOF_SBIT_BIGMETRICS;
	}
	else                                            /* if only h or v metrics */
	{
		ulTableLength = SIZEOF_SBIT_SMALLMETRICS;
	}

	ReturnCode = sfac_GetDataPtr (
		pClientInfo,                                /* callback etc. */
		ulMetricsOffset,                            /* metrics start */
		ulTableLength,                              /* read just metrics */
		TableIndex,                                 /* registered tag */
		TRUE,                                       /* should be there */
		(const void**)&pbyTable );                  /* data pointer */
	
	if (ReturnCode != NO_ERR) return ReturnCode;

/*  for horizontal metrics, offsets could be different for big & small */

	*pusHeight = (uint16)pbyTable[SFNT_SBIT_HEIGHT];
	*pusWidth = (uint16)pbyTable[SFNT_SBIT_WIDTH];

	if (usMetricsType == SBIT_BIG_METRICS)          /* if both h & v metrics */
	{
    	*psLSBearingX = (int16)(*((int8*)&pbyTable[SFNT_SBIT_BEARINGX]));
    	*psLSBearingY = (int16)(*((int8*)&pbyTable[SFNT_SBIT_BEARINGY]));
    	*pusAdvanceWidth = (uint16)pbyTable[SFNT_SBIT_ADVANCE];
    	*psTopSBearingX = (int16)(*((int8*)&pbyTable[SFNT_SBIT_VERTBEARINGX]));
    	*psTopSBearingY = (int16)(*((int8*)&pbyTable[SFNT_SBIT_VERTBEARINGY]));
    	*pusAdvanceHeight = (uint16)pbyTable[SFNT_SBIT_VERTADVANCE];
		*pbHorMetricsFound = TRUE;                        
		*pbVertMetricsFound = TRUE;                     
	}
	else if (usMetricsType == SBIT_HORIZ_METRICS)   
	{
    	*psLSBearingX = (int16)(*((int8*)&pbyTable[SFNT_SBIT_BEARINGX]));
    	*psLSBearingY = (int16)(*((int8*)&pbyTable[SFNT_SBIT_BEARINGY]));
    	*pusAdvanceWidth = (uint16)pbyTable[SFNT_SBIT_ADVANCE];
		*pbHorMetricsFound = TRUE;                        
	}
	else /* if (usMetricsType == SBIT_VERT_METRICS) */  
	{
    	*psTopSBearingX = (int16)(*((int8*)&pbyTable[SFNT_SBIT_BEARINGX]));
    	*psTopSBearingY = (int16)(*((int8*)&pbyTable[SFNT_SBIT_BEARINGY]));
    	*pusAdvanceHeight = (uint16)pbyTable[SFNT_SBIT_ADVANCE];
		*pbVertMetricsFound = TRUE;                     
	}

	RELEASESFNTFRAG(pClientInfo, pbyTable);

	return NO_ERR;
}

/**********************************************************************/

/* shave the white space from horizontal metrics for bitmap format 5 */

#define     ROWSIZE     16                      /* 16 bytes = 128 bits max */

FS_PUBLIC ErrorCode sfac_ShaveSbitMetrics (
	sfac_ClientRec *pClientInfo,
	uint16 usBitmapFormat,
	uint32 ulBitmapOffset,
    uint32 ulBitmapLength,
	uint16 usBitDepth,
	uint16 *pusHeight,
	uint16 *pusWidth,
    uint16 *pusShaveLeft,
    uint16 *pusShaveRight,
    uint16 *pusShaveTop,  /* NEW */
    uint16 *pusShaveBottom,  /* NEW */
	int16 *psLSBearingX,
	int16 *psLSBearingY, /* NEW */
	int16 *psTopSBearingX, /* NEW */
	int16 *psTopSBearingY) /* NEW */
{
    uint8           abyBitRow[ROWSIZE];         /* or bitmap into one row */
	const uint8     *pbyTable;
	const uint8     *pbyBdat;
    uint8           *pbyBitMap;
    uint8           byMask;
    uint8           byUpMask;
    uint8           byLowMask;
	uint16          usBitData;
	uint16          usFreshBits;
	uint16       	usOutBits;
	uint16       	usRow;
	uint16       	usStopBit;
    uint16          usShaveLeft;
    uint16          usShaveRight;
    uint16          usShaveTop;
    uint16          usShaveBottom;
	uint16          usStart;
	ErrorCode       ReturnCode;
	boolean			bWeGotBlackPixels;				/* used in vertical shaving */
	uint8			byBlackPixelsInCurrentRaw;		/* used in vertical shaving */
	uint8			byTempBuffer;		/* temporary buffer used to detect the first/last row containing black pixels */

    *pusShaveLeft = 0;                          /* defaults */
    *pusShaveRight = 0;
    *pusShaveTop = 0;                          /* defaults */
    *pusShaveBottom = 0;

    if (usBitmapFormat != 5)                    /* if not constant metrics data */
    {
        return NO_ERR;
    }

    if ((*pusWidth * usBitDepth) > (ROWSIZE << 3))
    {
    	return NO_ERR;                          /* punt huge bitmaps */
    }
    
    MEMSET(abyBitRow, 0, ROWSIZE);              /* clear to zeros */

/*      read the bitmap data    */

	ReturnCode = sfac_GetDataPtr (
		pClientInfo,                            /* callback etc. */
		ulBitmapOffset,                         /* metrics start */
		ulBitmapLength,                         /* read bitmap data */
		sfnt_BitmapData,                        /* registered tag */
		TRUE,                                   /* should be there */
		(const void**)&pbyTable );              /* data pointer */

	if (ReturnCode != NO_ERR) return ReturnCode;

	pbyBdat = pbyTable;
	usBitData = 0;                              /* up to 16 bits of bdat */
	usFreshBits = 0;                            /* read & unwritten */

	bWeGotBlackPixels = FALSE;					/* used for vertical shaving */
	usShaveTop = 0;
	usShaveBottom = 0;


/*      'or' the bitmap data into a single row    */    
	usRow = *pusHeight;

    while (usRow > 0)
	{
		pbyBitMap = abyBitRow;
		usOutBits = *pusWidth * usBitDepth;
		usStopBit = 8;
		byBlackPixelsInCurrentRaw = 0;

		while (usOutBits > 0)                   /* if more to do */
		{
			if (usFreshBits < 8)                /* if room for fresh data */
			{
				usBitData <<= 8;
                if (ulBitmapLength > 0)         /* prevent read past data end */
                {
                    usBitData |= (uint16)*pbyBdat++;
                    ulBitmapLength--;
                }
				usFreshBits += 8;
			}
			
			if (usStopBit > usOutBits)
			{
				usStopBit = usOutBits;
			}
			byMask = achStopMask[usStopBit];
			
			byTempBuffer = (uint8)((usBitData >> (usFreshBits - 8)) & byMask);

			byBlackPixelsInCurrentRaw |= byTempBuffer;

			*pbyBitMap++ |= byTempBuffer;

			usFreshBits -= usStopBit;
			usOutBits -= usStopBit;
		}
		if (byBlackPixelsInCurrentRaw != 0)
		{
			bWeGotBlackPixels = TRUE;
			usShaveBottom = usRow-1;
		}
		if (!bWeGotBlackPixels) usShaveTop ++;
        usRow--;
	}

	if (usShaveTop == *pusHeight)
	{
		/* the bitmap is completely white */
		usShaveTop = 0;
		usShaveBottom = 0;
	}

	RELEASESFNTFRAG(pClientInfo, pbyTable);

/*      calculate white space on the left    */
    
    pbyBitMap = abyBitRow;
	if (usBitDepth == 1)
	{
		byUpMask = 0x80;
		byLowMask = 0x01;
	} else if (usBitDepth == 2)
	{
		byUpMask = 0xC0;
		byLowMask = 0x03;
	} else if (usBitDepth == 4)
	{
		byUpMask = 0xF0;
		byLowMask = 0x0F;
	} else /* usBitDepth == 8 */
	{
		byUpMask = 0xFF;
		byLowMask = 0xFF;
	}
	byMask = byUpMask;
    usShaveLeft = 0;

    while ((*pbyBitMap & byMask) == 0)
    {
        usShaveLeft++;
        if (usShaveLeft == *pusWidth)
        {
            return NO_ERR;          /* no black found, don't shave */
        }
        byMask >>= usBitDepth;
        if (byMask == 0)
        {
            byMask = byUpMask;
            pbyBitMap++;
        }
    }

/*      calculate white space on the right    */
    
    usStart = (*pusWidth - 1) * usBitDepth;
    pbyBitMap = &abyBitRow[usStart >> 3];
    byMask = byUpMask >> (usStart & 0x0007);
    usShaveRight = 0;
    
    while ((*pbyBitMap & byMask) == 0)
    {
        usShaveRight++;
        if (byMask == byUpMask)
        {
            byMask = byLowMask;
            pbyBitMap--;
        }
        else
        {
            byMask <<= usBitDepth;
        }
    }

/*      correct the width and sidebearing    */

    *pusShaveLeft = usShaveLeft;
    *pusShaveRight = usShaveRight;
    *pusWidth -= usShaveLeft + usShaveRight;
    *psLSBearingX += (int16)usShaveLeft;
    *psTopSBearingX += (int16)usShaveLeft;

	*pusShaveTop = usShaveTop;
    *pusShaveBottom = usShaveBottom;
    *pusHeight -= usShaveTop + usShaveBottom;
    *psLSBearingY -= (int16)usShaveTop;
    *psTopSBearingY -= (int16)usShaveTop;

	return NO_ERR;
}


/**********************************************************************/


/* fetch the bitmap */

/*  Currently supporting the following bdat formats:
	
	1 - Small metrics;  Byte aligned data
	2 - Small metrics;  Bit aligned data
	5 - Const metrics;  Bit aligned data
	6 - Big metrics;    Byte aligned data
	7 - Big metrics;    Bit aligned data
	8 - Small metrics;  Composite data
	9 - Big metrics;    Composite data
*/

FS_PUBLIC ErrorCode sfac_GetSbitBitmap (
	sfac_ClientRec *pClientInfo,
	uint16 usBitmapFormat,
	uint32 ulBitmapOffset,
	uint32 ulBitmapLength,
	uint16 usHeight,
	uint16 usWidth,
    uint16 usShaveLeft,                             /* for white space in fmt 5 */
    uint16 usShaveRight,
    uint16 usShaveTop, /* NEW */
    uint16 usShaveBottom,  /* NEW */
	uint16 usXOffset,
	uint16 usYOffset,
	uint16 usDstRowBytes,
	uint16 usBitDepth,
	uint8 *pbyBitMap, 
	uint16 *pusCompCount )
{
	const uint8     *pbyTable;
	const uint8     *pbyBdat;
	uint8           *pbyBitRow;                     /* start of bitmap row */

	uint16          usSrcRowBytes;                  /* bytes per row in bdat */
	ErrorCode       ReturnCode;

	uint16          usBitData;                      /* bdat data read into 16 bits */
	uint16          usOutBits;                      /* num of bits to put to bitmap */
	uint16          usCount;
	uint16          usXOffBytes;
	uint16          usXOffBits;
	uint16          usStartBit;
	uint16          usStopBit;
	int16           sFreshBits;                     /* num of bits read not written */
	uint8           byMask;                         /* for partial bytes */
	
	ReturnCode = sfac_GetDataPtr (
		pClientInfo,                                /* callback etc. */
		ulBitmapOffset,                             /* metrics start */
		ulBitmapLength,                             /* read bitmap data */
		sfnt_BitmapData,                            /* registered tag */
		TRUE,                                       /* should be there */
		(const void**)&pbyTable );                  /* data pointer */
	
	if (ReturnCode != NO_ERR) return ReturnCode;

	pbyBdat = pbyTable;
	*pusCompCount = 0;                              /* usual case */
	
	pbyBitRow = pbyBitMap + (usDstRowBytes * usYOffset);
	usXOffBytes = (usXOffset * usBitDepth) >> 3;
	usXOffBits = (usXOffset * usBitDepth) & 0x07;

	switch(usBitmapFormat)
	{
	case 1:                                         /* byte aligned */
	case 6:
		
		usSrcRowBytes = ((usWidth * usBitDepth) + 7) / 8;

		if (usXOffBits == 0)                         /* if byte aligned */
		{
			while (usHeight > 0)
			{
				pbyBitMap = pbyBitRow + usXOffBytes;    /* adjust left */

				for (usCount = 0; usCount < usSrcRowBytes; usCount++)
				{
					*pbyBitMap++ |= *pbyBdat++;
				}
				pbyBitRow += usDstRowBytes;
				usHeight--;
			}
		}
		else                                        /* if offset in x */
		{
			while (usHeight > 0)
			{
				pbyBitMap = pbyBitRow + usXOffBytes;    /* adjust left */
				usBitData = 0;

				for (usCount = 0; usCount < usSrcRowBytes; usCount++)
				{
					usBitData |= (uint16)*pbyBdat++;
					*pbyBitMap++ |= (usBitData >> usXOffBits) & 0x00FF;
					usBitData <<= 8;
				}
				*pbyBitMap |= (usBitData >> usXOffBits) & 0x00FF;
							 
				pbyBitRow += usDstRowBytes;
				usHeight--;
			}
		}
		break;
	
	case 2:                                         /* bit aligned data */
	case 5:
	case 7:
		
		usBitData = 0;                              /* up to 16 bits of bdat */
		sFreshBits = 0;                             /* read & unwritten */
	
		usHeight += usShaveTop;

		while (usHeight > 0)                        /* for each row */
		{
			pbyBitMap = pbyBitRow + usXOffBytes;    /* adjust left */
			usOutBits = usWidth * usBitDepth;
			usStartBit = usXOffBits;
			usStopBit = 8;
			sFreshBits -= (int16)usShaveLeft * usBitDepth;       /* skip the left white bits */

			while (usOutBits > 0)                   /* if more to do */
			{
				while (sFreshBits < 8)              /* if room for fresh data */
				{
					usBitData <<= 8;
					if (ulBitmapLength > 0)         /* prevent read past data end */
					{
						usBitData |= (uint16)*pbyBdat++;
						ulBitmapLength--;
					}
					sFreshBits += 8;
				}
				
				if (usStopBit > usOutBits + usStartBit)
				{
					usStopBit = usStartBit + usOutBits;
				}
				byMask = achStartMask[usStartBit] & achStopMask[usStopBit];
				
				*pbyBitMap++ |= (uint8)((usBitData >> (sFreshBits + (int16)usStartBit - 8)) & byMask);

				sFreshBits -= (int16)(usStopBit - usStartBit);
				usOutBits -= usStopBit - usStartBit;
				usStartBit = 0;
			}
			sFreshBits -= (int16)usShaveRight*usBitDepth;      /* skip the right white bits */

			if (usShaveTop == 0)
			{
				pbyBitRow += usDstRowBytes;             /* next row */
			} else {
				usShaveTop --;
			}
			usHeight--;
		}
		break;
	
	case 3:                                         /* various */
	case 4:
		break;
	
	case 8:                                         /* composites */
	case 9:                                         /* just return count */
		
		*pusCompCount = (uint16)SWAPW(*((uint16*)&pbyBdat[SFNT_BDAT_COMPCOUNT]));
		break;
	
	default:
		Assert(FALSE);
		break;
	}

	RELEASESFNTFRAG(pClientInfo, pbyTable);
	return NO_ERR;
}

/**********************************************************************/

FS_PUBLIC ErrorCode sfac_GetSbitComponentInfo (
	sfac_ClientRec *pClientInfo,
	uint16 usComponent,
	uint32 ulBitmapOffset,
	uint32 ulBitmapLength,
	uint16 *pusCompGlyphCode,
	uint16 *pusCompXOffset,
	uint16 *pusCompYOffset
)
{
	const uint8 *   pbyBdat;
	ErrorCode       ReturnCode;

	
	ReturnCode = sfac_GetDataPtr (
		pClientInfo,                                /* callback etc. */
		ulBitmapOffset,                             /* metrics start */
		ulBitmapLength,                             /* read bitmap data */
		sfnt_BitmapData,                            /* registered tag */
		TRUE,                                       /* should be there */
		(const void**)&pbyBdat );                   /* data pointer */
	
	if (ReturnCode != NO_ERR) return ReturnCode;

	pbyBdat += SFNT_BDAT_FIRSTCOMP + (SIZEOF_SBIT_BDATCOMPONENT * usComponent);
		
	*pusCompGlyphCode = (uint16)SWAPW(*((uint16*)&pbyBdat[SFNT_BDAT_COMPGLYPH]));
	*pusCompXOffset = (uint16)pbyBdat[SFNT_BDAT_COMPXOFF];
	*pusCompYOffset = (uint16)pbyBdat[SFNT_BDAT_COMPYOFF];

	RELEASESFNTFRAG(pClientInfo, pbyBdat);

	return NO_ERR;
}

/**********************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\fs\sfnt.h ===
/*
	File:       sfnt.h

	Contains:   xxx put contents here (or delete the whole line) xxx

	Written by: xxx put name of writer here (or delete the whole line) xxx

	Copyright:  c 1988-1990 by Apple Computer, Inc., all rights reserved.
	            (c) 1989-1999 by Microsoft Corporation.

	Change History (most recent first):

				 7/10/99  BeatS		Add support for native SP fonts, vertical RGB
		 <3>    02/21/97    CB      ClaudeBe, add flags for scaled composite offset compatibility
		 <3>    10/31/90    MR      Add bit-field option for integer or fractional scaling [rb]
		 <2>    10/20/90    MR      Remove unneeded tables from sfnt_tableIndex. [rb]
		<12>     7/18/90    MR      platform and specific should always be unsigned
		<11>     7/14/90    MR      removed duplicate definitions of int[8,16,32] etc.
		<10>     7/13/90    MR      Minor type changes, for Ansi-C
		 <9>     6/29/90    RB      revise postscriptinfo struct
		 <7>      6/4/90    MR      Remove MVT
		 <6>      6/1/90    MR      pad postscriptinfo to long word aligned
		 <5>     5/15/90    MR      Add definition of PostScript table
		 <4>      5/3/90    RB      mrr     Added tag for font program 'fpgm'
		 <3>     3/20/90    CL      chucked old change comments from EASE
		 <2>     2/27/90    CL      getting bbs headers
	   <3.1>    11/14/89    CEL     Instructions are legal in components.
	   <3.0>     8/28/89    sjk     Cleanup and one transformation bugfix
	   <2.2>     8/14/89    sjk     1 point contours now OK
	   <2.1>      8/8/89    sjk     Improved encryption handling
	   <2.0>      8/2/89    sjk     Just fixed EASE comment
	   <1.7>      8/1/89    sjk     Added composites and encryption. Plus some enhancements.
	   <1.6>     6/13/89    SJK     Comment
	   <1.5>      6/2/89    CEL     16.16 scaling of metrics, minimum recommended ppem, point size 0
									bug, correct transformed integralized ppem behavior, pretty much
									so
	   <1.4>     5/26/89    CEL     EASE messed up on "c" comments
	  <,1.3>  5/26/89    CEL     Integrated the new Font Scaler 1.0 into Spline Fonts

	To Do:
		<3+>     3/20/90    mrr     Added tag for font program 'fpgm'
*/

#pragma pack(1)

#ifndef SFNT_DEFINED
#define SFNT_DEFINED

#include "fscdefs.h" // DO NOT REMOVE
#include "sfnt_en.h"

typedef struct {
	uint32 bc;
	uint32 ad;
} BigDate;

typedef struct {
	sfnt_TableTag   tag;
	uint32          checkSum;
	uint32          offset;
	uint32          length;
} sfnt_DirectoryEntry;

/*
 *  The search fields limits numOffsets to 4096.
 */
typedef struct {
	int32 version;                  /* 0x10000 (1.0) */
	uint16 numOffsets;              /* number of tables */
	uint16 searchRange;             /* (max2 <= numOffsets)*16 */
	uint16 entrySelector;           /* log2 (max2 <= numOffsets) */
	uint16 rangeShift;              /* numOffsets*16-searchRange*/
	sfnt_DirectoryEntry table[1];   /* table[numOffsets] */
} sfnt_OffsetTable;
#define OFFSETTABLESIZE     12  /* not including any entries */

/*
 *  for the flags field
 */
#define Y_POS_SPECS_BASELINE            0x0001
#define X_POS_SPECS_LSB                 0x0002
#define HINTS_USE_POINTSIZE             0x0004
#define USE_INTEGER_SCALING             0x0008
#define INSTRUCTED_ADVANCE_WIDTH        0x0010

/* flags 5-10 defined by Apple */
#define APPLE_VERTICAL_LAYOUT           0x0020
#define APPLE_RESERVED                  0x0040
#define APPLE_LINGUISTIC_LAYOUT         0x0080
#define APPLE_GX_METAMORPHOSIS          0x0100
#define APPLE_STRONG_RIGHT_TO_LEFT      0x0200
#define APPLE_INDIC_EFFECT              0x0400

#define FONT_COMPRESSED                 0x0800
#define FONT_CONVERTED                  0x1000

#define OUTLINE_CORRECT_ORIENTATION     0x4000
#define SFNT_MAGIC 0x5F0F3CF5

#define SHORT_INDEX_TO_LOC_FORMAT       0
#define LONG_INDEX_TO_LOC_FORMAT        1
#define GLYPH_DATA_FORMAT               0

typedef struct {
	Fixed       version;            /* for this table, set to 1.0 */
	Fixed       fontRevision;       /* For Font Manufacturer */
	uint32      checkSumAdjustment;
	uint32      magicNumber;        /* signature, should always be 0x5F0F3CF5  == MAGIC */
	uint16      flags;
	uint16      unitsPerEm;         /* Specifies how many in Font Units we have per EM */

	BigDate     created;
	BigDate     modified;

	/** This is the font wide bounding box in ideal space
 (baselines and metrics are NOT worked into these numbers) **/
	FUnit       xMin;
	FUnit       yMin;
	FUnit       xMax;
	FUnit       yMax;

	uint16      macStyle;               /* macintosh style word */
	uint16      lowestRecPPEM;          /* lowest recommended pixels per Em */

	/* 0: fully mixed directional glyphs, 1: only strongly L->R or T->B glyphs, 
	   -1: only strongly R->L or B->T glyphs, 2: like 1 but also contains neutrals,
	   -2: like -1 but also contains neutrals */
	int16       fontDirectionHint;

	int16       indexToLocFormat;
	int16       glyphDataFormat;
} sfnt_FontHeader;

typedef struct {
	Fixed       version;                /* for this table, set to 1.0 */

	FUnit       yAscender;
	FUnit       yDescender;
	FUnit       yLineGap;       /* Recommended linespacing = ascender - descender + linegap */
	uFUnit      advanceWidthMax;
	FUnit       minLeftSideBearing;
	FUnit       minRightSideBearing;
	FUnit       xMaxExtent; /* Max of (LSBi + (XMAXi - XMINi)), i loops through all glyphs */

	int16       horizontalCaretSlopeNumerator;
	int16       horizontalCaretSlopeDenominator;

	uint16      reserved0;
	uint16      reserved1;
	uint16      reserved2;
	uint16      reserved3;
	uint16      reserved4;

	int16       metricDataFormat;           /* set to 0 for current format */
	uint16      numberOf_LongHorMetrics;    /* if format == 0 */
} sfnt_HorizontalHeader;

typedef struct {
	uint16      advanceWidth;
	int16       leftSideBearing;
} sfnt_HorizontalMetrics;

typedef struct {
	uint16      advanceHeight;
	int16       topSideBearing;
} sfnt_VerticalMetrics;

/*
 *  CVT is just a bunch of int16s
 */
typedef int16 sfnt_ControlValue;

/*
 *  Char2Index structures, including platform IDs
 */
typedef struct {
	uint16  format;
	uint16  length;
	uint16  version;
} sfnt_mappingTable;

typedef struct {
	uint16  platformID;
	uint16  specificID;
	uint32  offset;
} sfnt_platformEntry;

typedef struct {
	uint16  version;
	uint16  numTables;
	sfnt_platformEntry platform[1]; /* platform[numTables] */
} sfnt_char2IndexDirectory;
#define SIZEOFCHAR2INDEXDIR     4

typedef struct {
  uint16  firstCode;
  uint16  entryCount;
  int16   idDelta;
  uint16  idRangeOffset;
} sfnt_subHeader2;

typedef struct {
  uint16            subHeadersKeys [256];
  sfnt_subHeader2   subHeaders [1];
} sfnt_mappingTable2;

typedef struct {
  uint16  segCountX2;
  uint16  searchRange;
  uint16  entrySelector;
  uint16  rangeShift;
  uint16  endCount[1];
} sfnt_mappingTable4;

typedef struct {
  uint16  firstCode;
  uint16  entryCount;
  uint16  glyphIdArray [1];
} sfnt_mappingTable6;

typedef struct {
	uint16 platformID;
	uint16 specificID;
	uint16 languageID;
	uint16 nameID;
	uint16 length;
	uint16 offset;
} sfnt_NameRecord;

typedef struct {
	uint16 format;
	uint16 count;
	uint16 stringOffset;
/*  sfnt_NameRecord[count]  */
} sfnt_NamingTable;

typedef struct {
	Fixed       version;                /* for this table, set to 1.0 */
	uint16      numGlyphs;
	uint16      maxPoints;              /* in an individual glyph */
	uint16      maxContours;            /* in an individual glyph */
	uint16      maxCompositePoints;     /* in an composite glyph */
	uint16      maxCompositeContours;   /* in an composite glyph */
	uint16      maxElements;            /* set to 2, or 1 if no twilightzone points */
	uint16      maxTwilightPoints;      /* max points in element zero */
	uint16      maxStorage;             /* max number of storage locations */
	uint16      maxFunctionDefs;        /* max number of FDEFs in any preprogram */
	uint16      maxInstructionDefs;     /* max number of IDEFs in any preprogram */
	uint16      maxStackElements;       /* max number of stack elements for any individual glyph */
	uint16      maxSizeOfInstructions;  /* max size in bytes for any individual glyph */
	uint16      maxComponentElements;   /* number of glyphs referenced at top level */
	uint16      maxComponentDepth;      /* levels of recursion, 1 for simple components */
} sfnt_maxProfileTable;

typedef struct {
  int16       numberOfContours;
  BBOX        bbox;
  int16       endPoints[1];
} sfnt_PackedSplineFormat;

#define DEVEXTRA    2   /* size + max */
/*
 *  Each record is n+2 bytes, padded to long word alignment.
 *  First byte is ppem, second is maxWidth, rest are widths for each glyph
 */
typedef struct {
	int16               version;
	int16               numRecords;
	int32               recordSize;
	/* Byte widths[numGlyphs+2] * numRecords */
} sfnt_DeviceMetrics;

#ifdef UNNAMED_UNION        /* Anonymous unions are supported */
#define postScriptNameIndices   /* by some C implementations,  */
#endif              /* but they are not portable. */

typedef struct {
	Fixed   version;                /* 1.0 */
	Fixed   italicAngle;
	FUnit   underlinePosition;
	FUnit   underlineThickness;
	uint32  isFixedPitch;
	uint32  minMemType42;
	uint32  maxMemType42;
	uint32  minMemType1;
	uint32  maxMemType1;

	uint16  numberGlyphs;
	union
	{
	  uint16  glyphNameIndex[1];   /* version == 2.0 */
	  int8    glyphNameIndex25[1]; /* version == 2.5 */
	} postScriptNameIndices;
} sfnt_PostScriptInfo;

#ifdef postScriptNameIndices
#undef postScriptNameIndices
#endif 

typedef struct {
	uint16  Version;
	int16   xAvgCharWidth;
	uint16  usWeightClass;
	uint16  usWidthClass;
	int16   fsType;
	int16   ySubscriptXSize;
	int16   ySubscriptYSize;
	int16   ySubscriptXOffset;
	int16   ySubscriptYOffset;
	int16   ySuperScriptXSize;
	int16   ySuperScriptYSize;
	int16   ySuperScriptXOffset;
	int16   ySuperScriptYOffset;
	int16   yStrikeOutSize;
	int16   yStrikeOutPosition;
	int16   sFamilyClass;
	uint8   Panose [10];
	uint32  ulCharRange [4];
	char    achVendID [4];
	uint16  usSelection;
	uint16  usFirstChar;
	uint16  usLastChar;
	int16   sTypoAscender;
	 int16  sTypoDescender;
	int16   sTypoLineGap;
	int16   sWinAscent;
	int16   sWinDescent;
	uint32  ulCodePageRange[2];
} sfnt_OS2;

typedef struct
{
	uint8   bEmY;
	uint8   bEmX;
	uint8   abInc[1];
} sfnt_hdmxRecord;

typedef struct
{
	uint16          Version;
	int16           sNumRecords;
	int32           lSizeRecord;
	sfnt_hdmxRecord HdmxTable;
} sfnt_hdmx;

typedef struct
{
	uint16    Version;
	uint16    usNumGlyphs;
	uint8     ubyPelsHeight;
} sfnt_LTSH;

typedef struct
{
	uint16          rangeMaxPPEM;
	uint16          rangeGaspBehavior;
} sfnt_gaspRange;

typedef struct
{
	uint16          version;
	uint16          numRanges;
	sfnt_gaspRange  gaspRange[1];
} sfnt_gasp;

/* various typedef to access to the sfnt data */

typedef sfnt_OffsetTable          *sfnt_OffsetTablePtr;
typedef sfnt_FontHeader           *sfnt_FontHeaderPtr;
typedef sfnt_HorizontalHeader     *sfnt_HorizontalHeaderPtr;
typedef sfnt_maxProfileTable      *sfnt_maxProfileTablePtr;
typedef sfnt_ControlValue         *sfnt_ControlValuePtr;
typedef sfnt_char2IndexDirectory  *sfnt_char2IndexDirectoryPtr;
typedef sfnt_HorizontalMetrics    *sfnt_HorizontalMetricsPtr;
typedef sfnt_VerticalMetrics      *sfnt_VerticalMetricsPtr;
typedef sfnt_platformEntry        *sfnt_platformEntryPtr;
typedef sfnt_NamingTable          *sfnt_NamingTablePtr;
typedef sfnt_OS2                  *sfnt_OS2Ptr;
typedef sfnt_DirectoryEntry       *sfnt_DirectoryEntryPtr;
typedef sfnt_PostScriptInfo       *sfnt_PostScriptInfoPtr;
typedef sfnt_gasp                 *sfnt_gaspPtr;

/*
 * 'gasp' Table Constants
*/

#define GASP_GRIDFIT    0x0001
#define GASP_DOGRAY     0x0002


/*
 * UNPACKING Constants
*/
/*define ONCURVE                 0x01   defined in FSCDEFS.H    */
#define XSHORT              0x02
#define YSHORT              0x04
#define REPEAT_FLAGS        0x08 /* repeat flag n times */
/* IF XSHORT */
#define SHORT_X_IS_POS      0x10 /* the short vector is positive */
/* ELSE */
#define NEXT_X_IS_ZERO      0x10 /* the relative x coordinate is zero */
/* ENDIF */
/* IF YSHORT */
#define SHORT_Y_IS_POS      0x20 /* the short vector is positive */
/* ELSE */
#define NEXT_Y_IS_ZERO      0x20 /* the relative y coordinate is zero */
/* ENDIF */
/* 0x40 & 0x80              RESERVED
** Set to Zero
**
*/

/*
 * Composite glyph constants
 */
#define COMPONENTCTRCOUNT           -1      /* ctrCount == -1 for composite */
#define ARG_1_AND_2_ARE_WORDS       0x0001  /* if set args are words otherwise they are bytes */
#define ARGS_ARE_XY_VALUES          0x0002  /* if set args are xy values, otherwise they are points */
#define ROUND_XY_TO_GRID            0x0004  /* for the xy values if above is true */
#define WE_HAVE_A_SCALE             0x0008  /* Sx = Sy, otherwise scale == 1.0 */
#define NON_OVERLAPPING             0x0010  /* set to same value for all components */
#define MORE_COMPONENTS             0x0020  /* indicates at least one more glyph after this one */
#define WE_HAVE_AN_X_AND_Y_SCALE    0x0040  /* Sx, Sy */
#define WE_HAVE_A_TWO_BY_TWO        0x0080  /* t00, t01, t10, t11 */
#define WE_HAVE_INSTRUCTIONS        0x0100  /* instructions follow */
#define USE_MY_METRICS              0x0200  /* apply these metrics to parent glyph */
#define OVERLAP_COMPOUND			0x0400  /* used by Apple in GX fonts */
#define SCALED_COMPONENT_OFFSET     0x0800  /* composite designed to have the component offset scaled (designed for Apple) */
#define UNSCALED_COMPONENT_OFFSET   0x1000  /* composite designed not to have the component offset scaled (designed for MS) */

/*
 *  Private enums for tables used by the scaler.  See sfnt_Classify
 */
typedef enum {
	sfnt_fontHeader,
	sfnt_horiHeader,
	sfnt_indexToLoc,
	sfnt_maxProfile,
	sfnt_controlValue,
	sfnt_preProgram,
	sfnt_glyphData,
	sfnt_horizontalMetrics,
	sfnt_charToIndexMap,
	sfnt_fontProgram,
	sfnt_Postscript,
	sfnt_HoriDeviceMetrics,
	sfnt_LinearThreshold,
	sfnt_Names,
	sfnt_OS_2,
	sfnt_GlyphDirectory,
	sfnt_BitmapData,
	sfnt_BitmapLocation,
	sfnt_BitmapScale,
	sfnt_vertHeader,
	sfnt_verticalMetrics,
	sfnt_BeginningOfFont,       /* References the beginning of memory   */
	sfnt_NUMTABLEINDEX
} sfnt_tableIndex;

#endif
#pragma pack()
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\fs\sfnt_en.h ===
/*
	File:       sfnt_en.h

	Written by: Mike Reed

	Copyright:  c 1989-1990 by Apple Computer, Inc., all rights reserved.

	Change History (most recent first):

		<8+>     7/16/90    MR      Fixed INTEL version of tag_GlyphData
		 <8>     7/16/90    MR      Conditionalize redefinition of script codes
		 <7>     7/13/90    MR      Conditionalize enums to allow for byte-reversal on INTEL chips
		 <6>     6/30/90    MR      Remove tag reference to 'mvt ' and 'cryp'
		 <4>     6/26/90    MR      Add all script codes, with SM naming conventions
		 <3>     6/20/90    MR      Change tag enums to #defines to be ansi-correct
		 <2>      6/1/90    MR      Add postscript name to sfnt_NameIndex and 'post' to tags.
	To Do:
*/

#ifndef SFNT_ENUMS

#define SFNT_ENUMS

typedef enum {
	plat_Unicode,
	plat_Macintosh,
	plat_ISO,
	plat_MS
} sfnt_PlatformEnum;

#ifndef __SCRIPT__
typedef enum {
	smRoman,
	smJapanese,
	smTradChinese,
	smChinese = smTradChinese,
	smKorean,
	smArabic,
	smHebrew,
	smGreek,
	smCyrillic,
	smRussian = smCyrillic,
	smRSymbol,
	smDevanagari,
	smGurmukhi,
	smGujarati,
	smOriya,
	smBengali,
	smTamil,
	smTelugu,
	smKannada,
	smMalayalam,
	smSinhalese,
	smBurmese,
	smKhmer,
	smThai,
	smLaotian,
	smGeorgian,
	smArmenian,
	smSimpChinese,
	smTibetan,
	smMongolian,
	smGeez,
	smEthiopic = smGeez,
	smAmharic = smGeez,
	smSlavic,
	smEastEurRoman = smSlavic,
	smVietnamese,
	smExtArabic,
	smSindhi = smExtArabic,
	smUninterp
} sfnt_ScriptEnum;
#endif

typedef enum {
	lang_English,
	lang_French,
	lang_German,
	lang_Italian,
	lang_Dutch,
	lang_Swedish,
	lang_Spanish,
	lang_Danish,
	lang_Portuguese,
	lang_Norwegian,
	lang_Hebrew,
	lang_Japanese,
	lang_Arabic,
	lang_Finnish,
	lang_Greek,
	lang_Icelandic,
	lang_Maltese,
	lang_Turkish,
	lang_Yugoslavian,
	lang_Chinese,
	lang_Urdu,
	lang_Hindi,
	lang_Thai
} sfnt_LanguageEnum;

typedef enum {
	name_Copyright,
	name_Family,
	name_Subfamily,
	name_UniqueName,
	name_FullName,
	name_Version,
	name_Postscript
} sfnt_NameIndex;

typedef uint32 sfnt_TableTag;

#define tag_CharToIndexMap      0x636d6170        /* 'cmap' */
#define tag_ControlValue        0x63767420        /* 'cvt ' */
#define tag_BitmapData          0x45424454        /* 'EBDT' */
#define tag_BitmapLocation      0x45424c43        /* 'EBLC' */
#define tag_BitmapScale         0x45425343        /* 'EBSC' */
#define tag_Editor0             0x65647430        /* 'edt0' */
#define tag_Editor1             0x65647431        /* 'edt1' */
#define tag_Encryption          0x63727970        /* 'cryp' */
#define tag_FontHeader          0x68656164        /* 'head' */
#define tag_FontProgram         0x6670676d        /* 'fpgm' */
#define tag_GridfitAndScanProc	0x67617370		  /* 'gasp' */
#define tag_GlyphDirectory      0x67646972        /* 'gdir' */
#define tag_GlyphData           0x676c7966        /* 'glyf' */
#define tag_HoriDeviceMetrics   0x68646d78        /* 'hdmx' */
#define tag_HoriHeader          0x68686561        /* 'hhea' */
#define tag_HorizontalMetrics   0x686d7478        /* 'hmtx' */
#define tag_IndexToLoc          0x6c6f6361        /* 'loca' */
#define tag_Kerning             0x6b65726e        /* 'kern' */
#define tag_LinearThreshold     0x4c545348        /* 'LTSH' */
#define tag_MaxProfile          0x6d617870        /* 'maxp' */
#define tag_NamingTable         0x6e616d65        /* 'name' */
#define tag_OS_2                0x4f532f32        /* 'OS/2' */
#define tag_Postscript          0x706f7374        /* 'post' */
#define tag_PreProgram          0x70726570        /* 'prep' */
#define tag_VertDeviceMetrics	0x56444d58		  /* 'VDMX' */
#define tag_VertHeader	        0x76686561		  /* 'vhea' */
#define tag_VerticalMetrics     0x766d7478		  /* 'vmtx' */

#define tag_TTO_GSUB     		0x47535542		  /* 'GSUB' */
#define tag_TTO_GPOS     		0x47504F53		  /* 'GPOS' */
#define tag_TTO_GDEF     		0x47444546		  /* 'GDEF' */
#define tag_TTO_BASE     		0x42415345		  /* 'BASE' */
#define tag_TTO_JSTF     		0x4A535446		  /* 'JSTF' */

#endif      /* not sfnt_enums */
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\fs\sfntoff.h ===
#define BIGDATE_BC      0
#define BIGDATE_AD      4
#define SIZEOF_BIGDATE  8

#define BBOX_XMIN   0
#define BBOX_YMIN   2
#define BBOX_XMAX   4
#define BBOX_YMAX   6
#define SIZEOF_BBOX 8

#define SFNT_DIRECTORYENTRY_TAG         0
#define SFNT_DIRECTORYENTRY_CHECKSUM    4
#define SFNT_DIRECTORYENTRY_TABLEOFFSET 8
#define SFNT_DIRECTORYENTRY_TABLELENGTH 12
#define SIZEOF_SFNT_DIRECTORYENTRY      16

#define SFNT_OFFSETTABLE_VERSION        0
#define SFNT_OFFSETTABLE_NUMOFFSETS     4
#define SFNT_OFFSETTABLE_SEARCHRANGE    6
#define SFNT_OFFSETTABLE_ENTRYSELECTOR  8
#define SFNT_OFFSETTABLE_RANGESHIFT     10
#define SFNT_OFFSETTABLE_TABLE          12
#define SIZEOF_SFNT_OFFSETTABLE         12

#define SFNT_FONTHEADER_VERSION             0
#define SFNT_FONTHEADER_FONTREVISION        4
#define SFNT_FONTHEADER_CHECKSUMADJUSTMENT  8
#define SFNT_FONTHEADER_MAGICNUMBER         12
#define SFNT_FONTHEADER_FLAGS               16
#define SFNT_FONTHEADER_UNITSPEREM          18
#define SFNT_FONTHEADER_CREATED             20
#define SFNT_FONTHEADER_MODIFIED            28
#define SFNT_FONTHEADER_XMIN                36
#define SFNT_FONTHEADER_YMIN                38
#define SFNT_FONTHEADER_XMAX                40
#define SFNT_FONTHEADER_YMAX                42
#define SFNT_FONTHEADER_MACSTYLE            44
#define SFNT_FONTHEADER_LOWESTRECPPEM       46
#define SFNT_FONTHEADER_FONTDIRECTIONHINT   48
#define SFNT_FONTHEADER_INDEXTOLOCFORMAT    50
#define SFNT_FONTHEADER_GLYPHDATAFORMAT     52
#define SIZEOF_SFNT_FONTHEADER              54

#define SFNT_HORIZONTALHEADER_VERSION                           0
#define SFNT_HORIZONTALHEADER_YASCENDER                         4
#define SFNT_HORIZONTALHEADER_YDESCENDER                        6
#define SFNT_HORIZONTALHEADER_YLINEGAP                          8
#define SFNT_HORIZONTALHEADER_ADVANCEWIDTHMAX                   10
#define SFNT_HORIZONTALHEADER_MINLEFTSIDEBEARING                12
#define SFNT_HORIZONTALHEADER_MINRIGHTSIDEBEARING               14
#define SFNT_HORIZONTALHEADER_XMAXEXTENT                        16
#define SFNT_HORIZONTALHEADER_HORIZONTALCARETSLOPENUMERATOR     18
#define SFNT_HORIZONTALHEADER_HORIZONTALCARETSLOPEDENOMINATOR   20
#define SFNT_HORIZONTALHEADER_RESERVED0                         22
#define SFNT_HORIZONTALHEADER_RESERVED1                         24
#define SFNT_HORIZONTALHEADER_RESERVED2                         26
#define SFNT_HORIZONTALHEADER_RESERVED3                         28
#define SFNT_HORIZONTALHEADER_RESERVED4                         30
#define SFNT_HORIZONTALHEADER_METRICDATAFORMAT                  32
#define SFNT_HORIZONTALHEADER_NUMBEROF_LONGHORMETRICS           34
#define SIZEOF_SFNT_HORIZONTALHEADER                            36

#define SFNT_HORIZONTALMETRICS_ADVANCEWIDTH     0
#define SFNT_HORIZONTALMETRICS_LEFTSIDEBEARING  2
#define SIZEOF_SFNT_HORIZONTALMETRICS           4

#define SFNT_VERTICALHEADER_NUMBEROF_LONGVERTMETRICS            34

#define SFNT_VERTICALMETRICS_ADVANCEHEIGHT      0
#define SFNT_VERTICALMETRICS_TOPSIDEBEARING     2
#define SIZEOF_SFNT_VERTICALMETRICS             4



#define SFNT_CONTROLVALUE 2

#define SFNT_MAPPINGTABLE_FORMAT            0
#define SFNT_MAPPINGTABLE_MAPTABLELENGTH    2
#define SFNT_MAPPINGTABLE_VERSION           4
#define SIZEOF_SFNT_MAPPINGTABLE            6

#define SFNT_PLATFORMENTRY_PLATFORMID       0
#define SFNT_PLATFORMENTRY_SPECIFICID       2
#define SFNT_PLATFORMENTRY_PLATFORMOFFSET   4
#define SIZEOF_SFNT_PLATFORMENTRY           8

#define SFNT_CHAR2INDEXDIRECTORY_VERSION    0
#define SFNT_CHAR2INDEXDIRECTORY_NUMTABLES  2
#define SFNT_CHAR2INDEXDIRECTORY_PLATFORM   4
#define SIZEOF_SFNT_CHAR2INDEXDIRECTORY     4

#define SFNT_SUBHEADER2_FIRSTCODE       0
#define SFNT_SUBHEADER2_ENTRYCOUNT      2
#define SFNT_SUBHEADER2_IDDELTA         4
#define SFNT_SUBHEADER2_IDRANGEOFFSET   6
#define SIZEOF_SFNT_SUBHEADER2          8

#define SFNT_MAPPINGTABLE2_SUBHEADERSKEYS   0
#define SFNT_MAPPINGTABLE2_SUBHEADERS       512
#define SIZEOF_SFNT_MAPPINGTABLE2           512

#define SFNT_MAPPINGTABLE4_SEGCOUNTX2       0
#define SFNT_MAPPINGTABLE4_SEARCHRANGE      2
#define SFNT_MAPPINGTABLE4_ENTRYSELECTOR    4
#define SFNT_MAPPINGTABLE4_RANGESHIFT       6
#define SFNT_MAPPINGTABLE4_ENDCOUNT         8
#define SIZEOF_SFNT_MAPPINGTABLE4           8

#define SFNT_MAPPINGTABLE6_FIRSTCODE    0
#define SFNT_MAPPINGTABLE6_ENTRYCOUNT   2
#define SFNT_MAPPINGTABLE6_GLYPHIDARRAY 4
#define SIZEOF_SFNT_MAPPINGTABLE6       4

#define SFNT_NAMERECORD_PLATFORMID  0
#define SFNT_NAMERECORD_SPECIFICID  2
#define SFNT_NAMERECORD_LANGUAGEID  4
#define SFNT_NAMERECORD_NAMEID      6
#define SFNT_NAMERECORD_NAMELENGTH  8
#define SFNT_NAMERECORD_NAMEOFFSET  10
#define SIZEOF_SFNT_NAMERECORD      12

#define SFNT_NAMINGTABLE_FORMAT         0
#define SFNT_NAMINGTABLE_COUNT          2
#define SFNT_NAMINGTABLE_STRINGOFFSET   4
/*  SFNT_NAMERECORD[COUNT]  */
#define SIZEOF_SFNT_NAMINGTABLE         6

#define SFNT_PACKEDSPLINEFORMAT_NUMBEROFCONTOURS    0
#define SFNT_PACKEDSPLINEFORMAT_BBOX                2
#define SFNT_PACKEDSPLINEFORMAT_ENDPOINTS           10
#define SIZEOF_SFNT_PACKEDSPLINEFORMAT              10

#define SFNT_DEVICEMETRICS_VERSION      0
#define SFNT_DEVICEMETRICS_NUMRECORDS   2
#define SFNT_DEVICEMETRICS_RECORDSIZE   4
/* BYTE WIDTHS[NUMGLYPHS+2] * NUMRECORDS */
#define SIZEOF_SFNT_DEVICEMETRICS       8

#define POSTSCRIPTNAMEINDICES_VERSION               0
#define POSTSCRIPTNAMEINDICES_ITALICANGLE           4
#define POSTSCRIPTNAMEINDICES_UNDERLINEPOSITION     8
#define POSTSCRIPTNAMEINDICES_UNDERLINETHICKNESS    10
#define POSTSCRIPTNAMEINDICES_ISFIXEDPITCH          12
#define POSTSCRIPTNAMEINDICES_PAD                   14
#define POSTSCRIPTNAMEINDICES_MINMEMTYPE42          16
#define POSTSCRIPTNAMEINDICES_MAXMEMTYPE42          20
#define POSTSCRIPTNAMEINDICES_MINMEMTYPE1           24
#define POSTSCRIPTNAMEINDICES_MAXMEMTYPE1           28
#define POSTSCRIPTNAMEINDICES_NUMBERGLYPHS          32
#define GLYPHNAMEINDEX                              34
#define GLYPHNAMEINDEX25                            34
#define SIZEOF_SFNT_POSTSCRIPTINFO                  36

#define SFNT_OS2_VERSION                0
#define SFNT_OS2_XAVGCHARWIDTH          2
#define SFNT_OS2_USWEIGHTCLASS          4
#define SFNT_OS2_USWIDTHCLASS           6
#define SFNT_OS2_FSTYPE                 8
#define SFNT_OS2_YSUBSCRIPTXSIZE        10
#define SFNT_OS2_YSUBSCRIPTYSIZE        12
#define SFNT_OS2_YSUBSCRIPTXOFFSET      14
#define SFNT_OS2_YSUBSCRIPTYOFFSET      16
#define SFNT_OS2_YSUPERSCRIPTXSIZE      18
#define SFNT_OS2_YSUPERSCRIPTYSIZE      20
#define SFNT_OS2_YSUPERSCRIPTXOFFSET    22
#define SFNT_OS2_YSUPERSCRIPTYOFFSET    24
#define SFNT_OS2_YSTRIKEOUTSIZE         26
#define SFNT_OS2_YSTRIKEOUTPOSITION     28
#define SFNT_OS2_SFAMILYCLASS           30
#define SFNT_OS2_PANOSE                 32
#define SFNT_OS2_ULCHARRANGE            42
#define SFNT_OS2_ACHVENDID              58
#define SFNT_OS2_USSELECTION            62
#define SFNT_OS2_USFIRSTCHAR            64
#define SFNT_OS2_USLASTCHAR             66
#define SFNT_OS2_STYPOASCENDER          68
#define SFNT_OS2_STYPODESCENDER         70
#define SFNT_OS2_STYPOLINEGAP           72
#define SFNT_OS2_SWINASCENT             74
#define SFNT_OS2_SWINDESCENT            76
#define SIZEOF_SFNT_OS2                 78

#define SFNT_HDMX_VERSION               0
#define SFNT_HDMX_SNUMRECORDS           2
#define SFNT_HDMX_LSIZERECORD           4
#define SFNT_HDMX_HDMXTABLE             8
#define SIZEOF_SFNT_HDMX                8

#define SFNT_HDMXRECORD_BEMY            0
#define SFNT_HDMXRECORD_BEMX            1
#define SFNT_HDMXRECORD_BWIDTHS         2
#define SIZEOF_SFNT_HDMXRECORD          2

#define SFNT_LTSH_VERSION               0
#define SFNT_LTSH_NUMGLYPHS             2
#define SFNT_LTSH_UBYPELSHEIGHT         4
#define SIZEOF_SFNT_LTSH                4

#define SFNT_MAXPROFILETABLE_VERSION                0
#define SFNT_MAXPROFILETABLE_NUMGLYPHS              4
#define SFNT_MAXPROFILETABLE_MAXPOINTS              6
#define SFNT_MAXPROFILETABLE_MAXCONTOURS            8
#define SFNT_MAXPROFILETABLE_MAXCOMPOSITEPOINTS     10
#define SFNT_MAXPROFILETABLE_MAXCOMPOSITECONTOURS   12
#define SFNT_MAXPROFILETABLE_MAXELEMENTS            14
#define SFNT_MAXPROFILETABLE_MAXTWILIGHTPOINTS      16
#define SFNT_MAXPROFILETABLE_MAXSTORAGE             18
#define SFNT_MAXPROFILETABLE_MAXFUNCTIONDEFS        20
#define SFNT_MAXPROFILETABLE_MAXINSTRUCTIONDEFS     22
#define SFNT_MAXPROFILETABLE_MAXSTACKELEMENTS       24
#define SFNT_MAXPROFILETABLE_MAXSIZEOFINSTRUCTIONS  26
#define SFNT_MAXPROFILETABLE_MAXCOMPONENTELEMENTS   28
#define SFNT_MAXPROFILETABLE_MAXCOMPONENTDEPTH      30
#define SIZEOF_SFNT_MAXPROFILETABLE 				32

#define SFNT_GASPRANGE_RANGEMAXPPEM 		0
#define SFNT_GASPRANGE_RANGEGASPBEHAVIOR	2
#define SIZEOF_SFNT_GASPRANGE				4

#define SFNT_GASP_VERSION					0
#define SFNT_GASP_NUMRANGES 				2
#define SFNT_GASP_GASPRANGE 				4
#define SIZEOF_SFNT_GASP					4

/**********************************************************************/

/*      Embedded Bitmap (sbit) Table Offsets      */

/**********************************************************************/

/*  Bloc, Bdat and Bsca file constants    */

/*  This first bloc is common to both bloc and bsca tables */

#define     SFNT_BLOC_NUMSIZES               4
#define     SFNT_BLOC_FIRSTSTRIKE            8

#define     SFNT_BLOC_INDEXARRAYOFFSET       0
#define     SFNT_BLOC_NUMINDEXTABLES         8
#define     SFNT_BLOC_COLORREF              12
#define     SFNT_BLOC_STARTGLYPH            40
#define     SFNT_BLOC_ENDGLYPH              42
#define     SFNT_BLOC_PPEMX                 44
#define     SFNT_BLOC_PPEMY                 45
#define     SFNT_BLOC_BITDEPTH              46
#define     SFNT_BLOC_FLAGS                 47
#define     SIZEOF_BLOC_SIZESUBTABLE        48

#define     SFNT_BLOC_FIRSTGLYPH             0
#define     SFNT_BLOC_LASTGLYPH              2
#define     SFNT_BLOC_ADDITIONALOFFSET       4
#define     SIZEOF_BLOC_INDEXARRAY           8

#define     SFNT_BLOC_INDEXFORMAT            0
#define     SFNT_BLOC_IMAGEFORMAT            2
#define     SFNT_BLOC_IMAGEOFFSET            4
#define     SFNT_BLOC_OFFSETARRAY            8

#define     SFNT_BLOC_IDX2IMAGESIZE          8
#define     SFNT_BLOC_IDX2METRICS           12

#define     SFNT_BLOC_IDX4NUMGLYPHS          8
#define     SFNT_BLOC_IDX4OFFSETARRAY       12

#define     SFNT_BLOC_IDX4CODE               0
#define     SFNT_BLOC_IDX4OFFSET             2
#define     SIZEOF_CODEOFFSETPAIR            4
                
#define     SFNT_BLOC_IDX5IMAGESIZE          8
#define     SFNT_BLOC_IDX5METRICS           12
#define     SFNT_BLOC_IDX5NUMGLYPHS         20
#define     SFNT_BLOC_IDX5CODEARRAY         24

#define     SFNT_SBIT_HEIGHT                 0
#define     SFNT_SBIT_WIDTH                  1
#define     SFNT_SBIT_BEARINGX               2
#define     SFNT_SBIT_BEARINGY               3
#define     SFNT_SBIT_ADVANCE                4
#define     SFNT_SBIT_VERTBEARINGX           5
#define     SFNT_SBIT_VERTBEARINGY           6
#define     SFNT_SBIT_VERTADVANCE            7
#define     SIZEOF_SBIT_SMALLMETRICS         5
#define     SIZEOF_SBIT_BIGMETRICS           8

#define     SFNT_BDAT_COMPCOUNT              0
#define     SIZEOF_SBIT_GLYPH8PAD            1
#define     SFNT_BDAT_FIRSTCOMP              2

#define     SFNT_BDAT_COMPGLYPH              0
#define     SFNT_BDAT_COMPXOFF               2
#define     SFNT_BDAT_COMPYOFF               3
#define     SIZEOF_SBIT_BDATCOMPONENT        4

#define     SFNT_BSCA_NUMSIZES               4
#define     SFNT_BSCA_FIRSTSTRIKE            8

#define     SFNT_BSCA_PPEMX                 24
#define     SFNT_BSCA_PPEMY                 25
#define     SFNT_BSCA_SUBPPEMX              26
#define     SFNT_BSCA_SUBPPEMY              27
#define     SIZEOF_BSCA_SIZESUBTABLE        28

/**********************************************************************/
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\fs\subpixel.c ===
/*********************************************************************

	  subpixel.c -- sub pixel rendering

	  (c) Copyright 1999-2000  Microsoft Corp.  All rights reserved.

 
**********************************************************************/

/*********************************************************************/

/*        Imports                                                    */

/*********************************************************************/

#define FSCFG_INTERNAL

#include    "fscdefs.h"             /* shared data types  */
#include    "scentry.h"             /* for own function prototypes */

#ifdef FSCFG_SUBPIXEL

#ifdef FSCFG_SUBPIXEL_STANDALONE

// this should be considered a temporary solution. currently, the rasterizer is plumbed for 8 bpp output in SubPixel,
// and appears to have John Platt's filter hard-wired in. In the future, we would rather have the overscaled b/w bitmap
// as output, such that we can do any color filtering and gamma correction outside and independent of the rasterizer

// Index values for wRGBColors and awColorIndexTable

#define RED_INDEX	0
#define GREEN_INDEX	1
#define	BLUE_INDEX	2

// The abColorIndexTable datastructure contains one entry for each virtual subpixel.
// We index into this table to determine which color is assigned to that subpixel.
// To create the table, we set the first number of subpixels assigned to red to the red index,
// and likewise for green and blue.

static const uint8 abColorIndexTable[2][RGB_OVERSCALE] = // 2 Tables to indicate color for each subpixel, 0 = RGB striping order, 1 = BGR striping order
	{{RED_INDEX,  RED_INDEX,  RED_INDEX,  RED_INDEX,  RED_INDEX,														// R_Subpixels, hard-wired
	  GREEN_INDEX,GREEN_INDEX,GREEN_INDEX,GREEN_INDEX,GREEN_INDEX,GREEN_INDEX,GREEN_INDEX,GREEN_INDEX,GREEN_INDEX,	// G_Subpixels, hard-wired
	  BLUE_INDEX, BLUE_INDEX},																						// B_Subpixels, hard-wired
	 {BLUE_INDEX, BLUE_INDEX,
	  GREEN_INDEX,GREEN_INDEX,GREEN_INDEX,GREEN_INDEX,GREEN_INDEX,GREEN_INDEX,GREEN_INDEX,GREEN_INDEX,GREEN_INDEX,
	  RED_INDEX,  RED_INDEX,  RED_INDEX,  RED_INDEX,  RED_INDEX}};

#define PIXEL_ON	1
#define PIXEL_OFF	0
#define CHAR_BIT	8         /* number of bits in a char */

char GetInputPixel( char *pbyInputRowData, uint32 ulWidthIndex )
{
	uint32	ulRowIndex;
	char	byPixelMask;
	
	ulRowIndex = ulWidthIndex / CHAR_BIT;			// Determines which byte to check out
	byPixelMask = 0x80 >> ulWidthIndex % CHAR_BIT; // Determine offset within byte
	return ( (pbyInputRowData[ ulRowIndex ] & byPixelMask)?PIXEL_ON:PIXEL_OFF );
}


FS_PUBLIC void fsc_OverscaleToSubPixel (GlyphBitMap * OverscaledBitmap, boolean bgrOrder, GlyphBitMap * SubPixelBitMap)
{
	char * pbyInputRowData, *pbyOutputRowData;			// Pointer to one scanline of data
	uint32 ulOverscaledBitmapWidth; // Fscaled bitmap widths
	uint32 ulHeightIndex, ulWidthIndex, ulMaxWidthIndex;	// Scanline index and byte pixel index
	char byPixel;						// Contents of one pixel from the rasterizer
	uint16 usRGBColors[ 3 ];				// Contains sum of each color based on number of subpixels
    int16 sBitmapSubPixelStart;     
    uint16 usColorIndex;
    uint32 ulBytes;
	
	// Start processing the bitmap
	// This is the heart of the RGB striping algorithm
	sBitmapSubPixelStart = OverscaledBitmap->rectBounds.left % RGB_OVERSCALE;
    if (sBitmapSubPixelStart < 0)
    {
        sBitmapSubPixelStart += RGB_OVERSCALE;
    }

    ulOverscaledBitmapWidth = OverscaledBitmap->rectBounds.right - OverscaledBitmap->rectBounds.left;
    ulMaxWidthIndex = ulOverscaledBitmapWidth + sBitmapSubPixelStart;

    /* clear the resulting bitmap */
	ulBytes = (uint32)SubPixelBitMap->sRowBytes * (uint32)(SubPixelBitMap->sHiBand - SubPixelBitMap->sLoBand);
	Assert(((ulBytes >> 2) << 2) == ulBytes);

	for ( ulHeightIndex = 0; ulHeightIndex < (uint32)(SubPixelBitMap->sHiBand - SubPixelBitMap->sLoBand); ulHeightIndex++ )
	{
		// Initialize Input to start of current row

		pbyInputRowData = OverscaledBitmap->pchBitMap + (OverscaledBitmap->sRowBytes * ulHeightIndex);
		pbyOutputRowData = SubPixelBitMap->pchBitMap + (SubPixelBitMap->sRowBytes * ulHeightIndex);
				
		// Initialize RGBColors

		usRGBColors[RED_INDEX] = 0;
		usRGBColors[GREEN_INDEX] = 0;
		usRGBColors[BLUE_INDEX] = 0;

		// Walk the scanline from the first subpixel, calculating R,G, & B values

		for( ulWidthIndex = sBitmapSubPixelStart; ulWidthIndex < ulMaxWidthIndex; ulWidthIndex++)
		{
            byPixel = GetInputPixel( pbyInputRowData, ulWidthIndex - sBitmapSubPixelStart );
			FS_ASSERT((byPixel <= 1),"Input Pixel greater than one");
			usRGBColors[abColorIndexTable[bgrOrder][ulWidthIndex % RGB_OVERSCALE]] += byPixel;

			// If we've finished one pixel or the scanline, write out pixel 

			if((( ulWidthIndex % RGB_OVERSCALE ) == (uint32)(RGB_OVERSCALE - 1)) || // Finish one pixel
				ulWidthIndex == ( ulOverscaledBitmapWidth + sBitmapSubPixelStart - 1) ) // Finish row
			{
                /* write out current pixel, 8 bits in range 0 through 179 = (R_Subpixels + 1) * (G_Subpixels + 1) * (B_Subpixels + 1) */

                usColorIndex = usRGBColors[RED_INDEX]   * (G_Subpixels + 1) * (B_Subpixels + 1) +
                               usRGBColors[GREEN_INDEX] * (B_Subpixels + 1) +
                               usRGBColors[BLUE_INDEX];

                        FS_ASSERT((usColorIndex < 256),"Resulting pixel doesn't fit in a byte");

                *pbyOutputRowData = (char) usColorIndex;
                pbyOutputRowData++;
				usRGBColors[RED_INDEX] = 0;
				usRGBColors[GREEN_INDEX] = 0;
				usRGBColors[BLUE_INDEX] = 0;
            }
		}
	}
}

#else // !FSCFG_SUBPIXEL_STANDALONE


#define CHAR_BIT      8         /* number of bits in a char */

unsigned char ajRGBToWeight222[64] = {
    0,1,1,2,4,5,5,6,4,5,5,6,8,9,9,10,
    16,17,17,18,20,21,21,22,20,21,21,22,24,25,25,26,
    16,17,17,18,20,21,21,22,20,21,21,22,24,25,25,26,
    32,33,33,34,36,37,37,38,36,37,37,38,40,41,41,42};

    unsigned char ajRGBToWeightMask[CHAR_BIT] = { 
        0xFC, 0x7E, 0x3F, 0x1F, 0x0F, 0x07, 0x03, 0x01};

FS_PUBLIC void fsc_OverscaleToSubPixel (GlyphBitMap * OverscaledBitmap, boolean bgrOrder, GlyphBitMap * SubPixelBitMap)
{
	char * pbyInputRowData, *pbyOutputRowData;			// Pointer to one scanline of data
	uint32 ulOverscaledBitmapWidth; // Fscaled bitmap widths
	uint32 ulHeightIndex, ulWidthIndex, ulMaxWidthIndex;	// Scanline index and byte pixel index
    int16 sBitmapSubPixelStart;     
    uint16 usColorIndex;

    uint16 usSubPixelIndex;
    int16 uSubPixelRightShift, uSubPixelLeftShift;
    char * pbyInputEndRowData;


	// Start processing the bitmap
	// This is the heart of the RGB striping algorithm
	sBitmapSubPixelStart = OverscaledBitmap->rectBounds.left % RGB_OVERSCALE;
    if (sBitmapSubPixelStart < 0)
    {
        sBitmapSubPixelStart += RGB_OVERSCALE;
    }

    ulOverscaledBitmapWidth = OverscaledBitmap->rectBounds.right - OverscaledBitmap->rectBounds.left;
    ulMaxWidthIndex = (uint32)(SubPixelBitMap->rectBounds.right - SubPixelBitMap->rectBounds.left);

	for ( ulHeightIndex = 0; ulHeightIndex < (uint32)(SubPixelBitMap->sHiBand - SubPixelBitMap->sLoBand); ulHeightIndex++ )
	{
		// Initialize Input to start of current row

		pbyInputRowData = OverscaledBitmap->pchBitMap + (OverscaledBitmap->sRowBytes * ulHeightIndex);
        pbyInputEndRowData = pbyInputRowData + OverscaledBitmap->sRowBytes;
		pbyOutputRowData = SubPixelBitMap->pchBitMap + (SubPixelBitMap->sRowBytes * ulHeightIndex);
				

        /* do the first partial byte : */

        usColorIndex = (unsigned char)(*pbyInputRowData) >> (sBitmapSubPixelStart + (8 - RGB_OVERSCALE));
        usColorIndex = ajRGBToWeight222[usColorIndex];

        *pbyOutputRowData = (char) usColorIndex;

        pbyOutputRowData++;

        usSubPixelIndex = (CHAR_BIT + RGB_OVERSCALE - sBitmapSubPixelStart) % CHAR_BIT;

		// Walk the scanline from the first subpixel, calculating R,G, & B values

		for( ulWidthIndex = 1; ulWidthIndex < ulMaxWidthIndex; ulWidthIndex++)
		{
            uSubPixelLeftShift = 0;
            uSubPixelRightShift = CHAR_BIT - RGB_OVERSCALE - usSubPixelIndex;
            if (uSubPixelRightShift < 0) 
            {
                uSubPixelLeftShift = - uSubPixelRightShift;
                uSubPixelRightShift = 0;
            }

            usColorIndex = ((unsigned char)(*pbyInputRowData) & ajRGBToWeightMask[usSubPixelIndex]) >> uSubPixelRightShift << uSubPixelLeftShift;

            if (pbyInputRowData+1 < pbyInputEndRowData)
            {
                /* avoid reading too far for the partial pixel at the end */
                uSubPixelRightShift = CHAR_BIT + CHAR_BIT - RGB_OVERSCALE - usSubPixelIndex;

                usColorIndex += (unsigned char)(*(pbyInputRowData+1)) >> uSubPixelRightShift;
            }
            usColorIndex = ajRGBToWeight222[usColorIndex];

            *pbyOutputRowData = (char) usColorIndex;

            pbyOutputRowData++;

            usSubPixelIndex = (usSubPixelIndex + RGB_OVERSCALE);
            if (usSubPixelIndex >= CHAR_BIT)
            {
                usSubPixelIndex = usSubPixelIndex % CHAR_BIT;
                pbyInputRowData ++;
            }
		}
	}
}

#endif // FSCFG_SUBPIXEL_STANDALONE

#endif // FSCFG_SUBPIXEL
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\fsverify\fsvconfg.h ===
/***************************************************************************
 * Module: FSVCONFG.H
 *
 * Copyright (c) Microsoft Corp., 1998
 *
 * Author: Paul Linnerud (paulli)
 * Date:   January 1998
 *
 * Mods: 
 *
 * Configurations to fsverify
 *
 **************************************************************************/ 
/* input defines */

/* global settings */
#define PLATFORM_ID			-1
#define ENCODING_ID			-1
#define XRES				72
#define YRES				72

/* test set 1 settings */
#define MAT1_0_0			ONEFIX
#define MAT1_0_1			0
#define MAT1_0_2			0
#define MAT1_1_0			0
#define MAT1_1_1			ONEFIX
#define MAT1_1_2			0
#define MAT1_2_0			0
#define MAT1_2_1			0
#define MAT1_2_2			ONEFIX

#define OVER_SCALE_1		0
#define CHECK_FROM_SIZE_1	1
#define CHECK_TO_SIZE_1		150

/* test set 2 settings */
#define MAT2_0_0			ONEFIX
#define MAT2_0_1			0
#define MAT2_0_2			0
#define MAT2_1_0			0
#define MAT2_1_1			ONEFIX
#define MAT2_1_2			0
#define MAT2_2_0			0
#define MAT2_2_1			0
#define MAT2_2_2			ONEFIX

#define OVER_SCALE_2		4
#define CHECK_FROM_SIZE_2	12
#define CHECK_TO_SIZE_2		11

/* test set 3 settings */
// 45 degree rotation with X2 Y & X stretch
#define MAT3_0_0			92680
#define MAT3_0_1			92680
#define MAT3_0_2			0
#define MAT3_1_0			-92680
#define MAT3_1_1			92680
#define MAT3_1_2			0
#define MAT3_2_0			0
#define MAT3_2_1			0
#define MAT3_2_2			ONEFIX

#define OVER_SCALE_3		0
#define CHECK_FROM_SIZE_3	12
#define CHECK_TO_SIZE_3		11
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\fsverify\fstrace.c ===
/***********************************************************************************

Module: FSTrace.c

Author: Paul Linnerud (PaulLi)

Date: 8/4/95

Purpose: Provides a trace function that can be called by the rasterizer using the rasterizer's 
trace feature. The purpose of the trace function is to check and verify parameters and other data
associated with	TrueType instructions. Module also contains functions to support the operation
of the trace function.

History:
8/4/95  Wrote it.  PaulLi
2/5/96	Added check for New Apple Instructions. PaulLi
2/6/96  Added optional chaining of trace functions. PaulLi
10/8/97 cleanup for NT 5.0. ClaudeBe

************************************************************************************/

#define FSCFG_INTERNAL
#include <stdlib.h> // for malloc, free, realloc 
#include "fscaler.h"
#include "fserror.h"
#include "fontmath.h"

#include "FSTrace.h"

#ifdef FST_DEBUG
//#include "fstasrt.h"
#else
#define FSTAssert(X,Y)
#endif

#ifndef FST_CRIT_ONLY
#include <stdio.h>  // for sprintf
#endif


#ifdef FSCFG_REENTRANT 
#define GSA     pLocalGS,
#else 
#define GSA
#endif 

/* with 3 levels, we will cover the 99.9999% of the fonts and keep the use of realloc an exception */
#define FST_PREALLOCATED_NEST_LEVELS	3

#define IF_CODE         0x58
#define ELSE_CODE       0x1B
#define EIF_CODE        0x59
#define ENDF_CODE       0x2d
#define MD_CODE         0x49
#define FDEF_CODE		0x2c
#define IDEF_CODE       0x89
#define MAX_CLIENTS       10
#define POP( p )     ( *(--p) )
#define MAX(a,b)        ((a) > (b) ? (a) : (b))

#ifndef UNREFERENCED_PARAMETER
#define UNREFERENCED_PARAMETER(P)  \
    \
{ \
   (P) = (P); \
} \

#endif


#define BIT0( t ) ( (t) & 0x01 )
#define BIT1( t ) ( (t) & 0x02 )
#define BIT2( t ) ( (t) & 0x04 )
#define BIT3( t ) ( (t) & 0x08 )
#define BIT4( t ) ( (t) & 0x10 )
#define BIT5( t ) ( (t) & 0x20 )
#define BIT6( t ) ( (t) & 0x40 )
#define BIT7( t ) ( (t) & 0x80 )

#define CURRENTLEVEL    1
#define PREVIOUSLEVEL   2

#define GLYPH_ZONE      1
#define TWILIGHT_ZONE   0

#define SMALL_TEMP_STRING_SIZE  50
#define LARGE_TEMP_STRING_SIZE  256
#define NUM_REF_PTS             3

/* flags for UTP, IUP, MovePoint */
#define XMOVED 0x01
#define YMOVED 0x02

/* Type definitions	*/ 

#ifndef FST_CRIT_ONLY
/* Call stack cell definition*/
typedef struct
{
  /* Points to first instruction in code block (function,program).
     Set when first instruction in block is executed. */
  unsigned char* pCallNestBeginInst;

  /* Points to last instruction in code block. Set when first instruction in block
     is executed.	*/
  unsigned char* pCallNestLevelEndInst;
  
  /* If nesting level. */
  long lIfNestLevel;
  
  /* The function we are currently in. If not in function, is set to NO_FUNCTION. */
  unsigned short usFunc; 

  /* The user defined instruction we are currently in. If not in a user defined instruction, is set to
     NO_INSTRUCTION.  */
  unsigned short usUserDefinedInst;
  
  /* Current instruction pointer. Is only set when calling a function or user defined instruction.
     Used to provide instruction pointer of CALL, LOOPCALL or call to user defined instruction. Any other
     time a instruction pointer is used, it is taken from localGS. 	*/
  unsigned char* insPtr;
  
  /* Used to indicate if this instruction is the last one we will see in this block of code.
     In the general case, this is set in the call stack updating code. In some cases as with the IF 
     instruction, determining if an instruction is the last one executed must be done in code dealing
     specifically with the function. In those cases, the determination is made in the respective instruction
     handling code.	   */
  BOOL bLastInst;
  
  /* Specifies which if any function was called at this level.	 */
  unsigned short usFunctionCalled;
  
  /* Specifies how many times functions has yet to execute. In the case of a CALL, this is set to 1 
     at the time of the call. In the case of a LOOPCALL, this is set to the number of times the 
     LOOPCALL is to call the function. 	 */
  unsigned short usCurrentCallCount;
  
  /* Specifies which if any user defined instruction was called at this level. */
  unsigned short usUserDefinedInstCalled;
  
  /* Specifies if the current instruction is user defined. */
  BOOL bCurrentInstUserDefined;
}CallStackCell;
#endif // FST_CRIT_ONLY

/* Client specific data structure  */
typedef struct
{  
  /* Call nest level. A value of 0 means we are at a initial condition causing FsTrace to initialize
     the first call stack cell. A value of 1 means we are at the base level of the call stack. */
  long lCallNestLevel;

  long lAllocatedNestlevels;
  
  /* To keep track of what the loop variable was set to. Set when SLOOP is called. Cleared when 
     instruction uses loop.	  */
  long lLoopSet;
  
  /* Current value of the loop variable. Set and cleared in instructions that use the loop variable. */
  long lCurrentLoop;
  
  /* Variable to indicate if a break was requested by client.	 */
  BOOL bBreakOccured;
  
  BOOL bGrayscaleInfoRequested;

  BOOL bFirstCallToTraceFunction;

  /* most commonly accessed maxp values are cached here to avoid dereferencing localGS too often to get them */
	int32      maxPointsIncludePhantomMinus1;  /* in an individual glyph, including maxCompositePoints  */
	int32      maxContours;                    /* in an individual glyph, including maxCompositeContours */
	int32      maxElementsMinus1;              /* set to 2, or 1 if no twilightzone points */
	int32      maxStorageMinus1;                     /* max number of storage locations */
	int32      maxFunctionDefsMinus1;          /* max number of FDEFs in any preprogram */
	int32      maxStackElements;               /* max number of stack elements for any individual glyph */
	int32      maxTwilightPointsMinus1;        /* max points in element zero */
    int32      cvtCountMinus1;                 /* Number of cvt */

#ifndef FST_CRIT_ONLY
  /* Array of bytes each byte represents a storage location. If storage locaton is written to,
     byte is set to 1 otherwise it is 0. Memory is allocated during first call to WS. Size of
     array dependant on maxp value for maxStorage.		*/
  unsigned char* pStoreBits;
  
  /* Array of bytes each byte represents a twilight zone point. If a twilight zone point has been
     set with an instructon like MDAP, the value is 1 otherwise it is 0. Memory is allocated when first
     twilight zone point is set. Size of array dependant on maxp value of maxTwilightPoints.   */
  unsigned char* pTwilightZonePtsSet;

  /* Pointer to call stack.	   */
  CallStackCell* pArrayCallStack;

  /* Static array of 3 bytes to indicate if a reference point is set. If byte is 1, reference point
     is set otherwise, it is not.	  */
  unsigned char RefPtsUsed[NUM_REF_PTS];
#endif

}ClientSpecificData;

typedef ClientSpecificData* pClientSpecificData;

/* Global Variables */

/* Array to indicate if instruction is used by rasterizer. */
static const int8 gFunctonUsed [UCHAR_MAX + 1]
=
{
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1
};

/* Array to indicate if instruction uses the loop graphic state variable.  */
static const int8 gInstUsesLoop [UCHAR_MAX + 1]
=
{
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
};
	   	   
/* pointer to current Client specific data	 */
static pClientSpecificData pCurrentSpecificData = NULL;


/* Function to call when FsTrace finds a problem.	*/
#ifndef FST_CRIT_ONLY
static NotifyFunc gpNotifyFunction;
#endif // FST_CRIT_ONLY

/* Pointers to trace functions to call after CallBackFSTraceFunction is called. We store one for
   the pre-program and one for the glyph programs. */
#ifdef FST_CHAIN_TRACE
static FntTraceFunc gpPrePgmTraceNext = NULL;
static FntTraceFunc gpGlyfPgmTraceNext = NULL;
#endif //  FST_CHAIN_TRACE

/* Local Helper Functions prototypes */

#ifndef FST_CRIT_ONLY
static BOOL OutputErrorToClient(fnt_LocalGraphicStateType *, unsigned short usErrorType,
                                unsigned short usErrorCode, char* szErrorString);
#else
#define OutputErrorToClient(A,B,C,D) pCurrentSpecificData->bBreakOccured = TRUE
#endif

#ifndef FST_CRIT_ONLY
static BOOL UpdateCallStack(pClientSpecificData pCSD, fnt_LocalGraphicStateType * pLocalGS, uint8 * pbyEndInst);
static BOOL ProcessPostInst(pClientSpecificData pCSD, fnt_LocalGraphicStateType * pLocalGS, uint8 * pbyEndInst);
#endif // FST_CRIT_ONLY

static void ClearRefPtFlags(pClientSpecificData pCSD);
static void SetTwilightZonePt(pClientSpecificData pCSD, fnt_LocalGraphicStateType* pGS, fnt_ElementType*elem, int32 pt);
static void ClearTwilightZonePts(pClientSpecificData pCSD);

#ifndef FST_CRIT_ONLY
static uint8* FST_SkipPushData (uint8* pbyInst); 
#endif // FST_CRIT_ONLY

static fnt_instrDef *FST_FindIDef (fnt_LocalGraphicStateType * pLocalGS);
static void FST_CompMul(int32 src1, int32 src2, int32 dst[2]); 

#define Check_For_PUSH(stackPtr, stackMax, pLocalGS, lNumItems) if ( stackPtr + (long)(lNumItems - 1) > stackMax ) OutputErrorToClient(pLocalGS,ET_CRITICAL_ERROR,ERR_STACK_OVERFLOW,NULL);

static BOOL Check_For_POP(F26Dot6* stackPtr, F26Dot6 * stackBase, fnt_LocalGraphicStateType * pLocalGS, long lNumItems);

#ifndef FST_CRIT_ONLY
static void Check_jump(fnt_LocalGraphicStateType * pLocalGS, uint8 * pbyEndInst, int32 offset);
#endif // FST_CRIT_ONLY

static BOOL Check_Storage (fnt_LocalGraphicStateType* pGS, int32 index, int32 maxIndex);
static void Check_CVT (fnt_LocalGraphicStateType* pGS, int32 cvt, int32 cvtCount);
static void Check_Zone(fnt_LocalGraphicStateType* pGS, int32 elem, int32 maxElem);
static void Check_ZonePtr(fnt_LocalGraphicStateType* pGS, fnt_ElementType*elem, int32 maxElem, int32 maxctrs, int32 maxpts, int32 maxTwiPts);
static void Check_ForUnitializedZone (fnt_LocalGraphicStateType* pGS, fnt_ElementType*elem);
static void Check_Point(fnt_LocalGraphicStateType* pGS, fnt_ElementType*elem, int32 pt,int32 maxPts, int32 maxTwiPts);
static void Check_Contour(fnt_LocalGraphicStateType* pGS, fnt_ElementType*elem, int32 ctr, int32 maxCtrs);
static BOOL Check_FDEF (fnt_LocalGraphicStateType* pGS, int32 fdef, int32 maxFdef);
static void Check_INT16 (fnt_LocalGraphicStateType* pGS, int32 n);
static void Check_INT8 (fnt_LocalGraphicStateType* pGS, int32 n);
static void Check_Larger (fnt_LocalGraphicStateType* pGS, int32 min, int32 n);
static void Check_SubStack (fnt_LocalGraphicStateType* pGS, F26Dot6* pt, F26Dot6 * stackBase, F26Dot6 * stackMax);
static void Check_Selector (fnt_LocalGraphicStateType* pGS, int32 n);
static void Check_INSTCTRL_Selector (fnt_LocalGraphicStateType* pGS, int32 n);
static void Check_FUCoord (fnt_LocalGraphicStateType* pGS, F26Dot6 coord);
static void Check_RefPtUsed(fnt_LocalGraphicStateType* pGS, int32 pt);
static void Check_Range (fnt_LocalGraphicStateType* pGS, int32 n, int32 min, int32 max);
static void Check_PF_Vectors (fnt_LocalGraphicStateType* pLocalGS);

#ifdef FSCFG_FONTOGRAPHER_BUG
static void Check_CVTReadSpecial (fnt_LocalGraphicStateType* pGS, int32 cvt);
#endif // FSCFG_FONTOGRAPHER_BUG

static Fixed fst_GetCVTScale (fnt_LocalGraphicStateType * pLocalGS);
static Fract fst_FracSqrt (Fract xf);

/* Public Functions */

/* CallbackFSTraceFunction is called by the rasterizer prior to every TrueType instruction. This
   is where all the checking takes place. The function must be provided to the rasterizer via 
   fs_NewTransformation for the pre-program and via fs_ContourGridFit for the respective glyph program.*/
extern void FST_CALLBACK fst_CallBackFSTraceFunction(fnt_LocalGraphicStateType * pLocalGS, uint8 * pbyEndInst)
{
 pClientSpecificData pCSD; 
  F26Dot6 * stackBase;
  F26Dot6 * stackMax;

 /* Local pointer to current client data  */
 pCSD = pCurrentSpecificData;

 FSTAssert((pCSD != NULL),"Current specific data not set or allocated");
 if (pCSD == NULL) return;

#ifdef FST_CRIT_ONLY
 pCSD->bBreakOccured = FALSE;
#endif

 if (pCSD->bFirstCallToTraceFunction)
 {
     LocalMaxProfile *pmaxp = pLocalGS->globalGS->maxp;

     /* first time the trace function is called, we need to setup a couple of cached values */
    pCSD->maxPointsIncludePhantomMinus1 = MAX (pmaxp->maxPoints,pmaxp->maxCompositePoints) - 1 + NUM_PHANTOM_PTS;
    pCSD->maxContours = MAX (pmaxp->maxContours,pmaxp->maxCompositeContours);
    pCSD->maxElementsMinus1 = pmaxp->maxElements -1;
    pCSD->maxStorageMinus1 = pmaxp->maxStorage -1;
    pCSD->maxFunctionDefsMinus1 = pmaxp->maxFunctionDefs -1;
    pCSD->maxStackElements = pmaxp->maxStackElements;
    pCSD->maxTwilightPointsMinus1 = pmaxp->maxTwilightPoints -1;
    pCSD->cvtCountMinus1 = pLocalGS->globalGS->cvtCount -1;
    
#ifdef FSCFG_EUDC_EDITOR_BUG
    if (pCSD->maxStackElements == 0)
    {
      pCSD->maxStackElements = 1;
    }
#endif // FSCFG_EUDC_EDITOR_BUG
    pCSD->bFirstCallToTraceFunction = FALSE;
 }

  /* TrueType stack boundaries, used by Check_For_POP and Check_For_PUSH : */
  stackBase = pLocalGS->globalGS->stackBase;
  stackMax = stackBase + pCSD->maxStackElements - 1L;

#ifndef FST_CRIT_ONLY
 if (!UpdateCallStack(pCSD,pLocalGS,pbyEndInst)) return; /* could fail on a memory reallocation */
#endif // FST_CRIT_ONLY
 
 switch(pLocalGS->opCode)
 {
   /* NPUSHB[]	*/
   case 0x40:
   { 
     int32 iCount;
	
	 if(pLocalGS->insPtr + 1 > pbyEndInst - 1)
	   OutputErrorToClient(pLocalGS,ET_CRITICAL_ERROR,ERR_OVERFLOW_INST_PTR,NULL);

	 iCount = (int32)*(pLocalGS->insPtr + 1);
   	 
	 if(pLocalGS->insPtr + 1 + iCount > pbyEndInst - 1)
	   OutputErrorToClient(pLocalGS,ET_CRITICAL_ERROR,ERR_OVERFLOW_INST_PTR,NULL);
	 
	 Check_For_PUSH(pLocalGS->stackPointer, stackMax, pLocalGS,iCount);
	 
#ifndef FST_CRIT_ONLY
	 if(pLocalGS->insPtr + 1 + iCount >= pbyEndInst - 1) 
	   pCSD->pArrayCallStack[pCSD->lCallNestLevel - 1].bLastInst = TRUE;
#endif // FST_CRIT_ONLY

   	 break;
   }
   
   /* NPUSHW[]	*/
   case 0x41:
   {     
     int32 iCount;
	
	 if(pLocalGS->insPtr + 1 > pbyEndInst - 1)
	   OutputErrorToClient(pLocalGS,ET_CRITICAL_ERROR,ERR_OVERFLOW_INST_PTR,NULL);

	 iCount = (int32)*(pLocalGS->insPtr + 1);
   	 
	 if(pLocalGS->insPtr + 1 + 2*iCount > pbyEndInst - 1)
	   OutputErrorToClient(pLocalGS,ET_CRITICAL_ERROR,ERR_OVERFLOW_INST_PTR,NULL);
	 
	 Check_For_PUSH(pLocalGS->stackPointer,stackMax, pLocalGS,iCount);
	 
#ifndef FST_CRIT_ONLY
	 if(pLocalGS->insPtr + 1 + 2*iCount >= pbyEndInst - 1) 
	   pCSD->pArrayCallStack[pCSD->lCallNestLevel - 1].bLastInst = TRUE;
#endif // FST_CRIT_ONLY

   	 break;
   }
   	   
   /* PUSHB[abc] */
   case 0xB0:
   case 0xB1:
   case 0xB2:
   case 0xB3:
   case 0xB4:
   case 0xB5:
   case 0xB6:
   case 0xB7:
   {
     int32 iCount;

	 iCount = pLocalGS->opCode - 0xb0 + 1;

	 if(pLocalGS->insPtr + iCount > pbyEndInst - 1)
	   OutputErrorToClient(pLocalGS,ET_CRITICAL_ERROR,ERR_OVERFLOW_INST_PTR,NULL);
	 
	 Check_For_PUSH(pLocalGS->stackPointer,stackMax, pLocalGS,iCount);

#ifndef FST_CRIT_ONLY
	 if(pLocalGS->insPtr + iCount >= pbyEndInst - 1) 
	   pCSD->pArrayCallStack[pCSD->lCallNestLevel - 1].bLastInst = TRUE;
#endif // FST_CRIT_ONLY

     break;
   }
   
   /* PUSHW[abc]  */
   case 0xB8:
   case 0xB9:
   case 0xBA:
   case 0xBB:
   case 0xBC:
   case 0xBD:
   case 0xBE:
   case 0xBF:
   {
     int32 iCount;

	 iCount = pLocalGS->opCode - 0xb8 + 1;

	 if(pLocalGS->insPtr + 2*iCount > pbyEndInst - 1)
	   OutputErrorToClient(pLocalGS,ET_CRITICAL_ERROR,ERR_OVERFLOW_INST_PTR,NULL);
	 
	 Check_For_PUSH(pLocalGS->stackPointer,stackMax, pLocalGS,iCount);

#ifndef FST_CRIT_ONLY
	 if(pLocalGS->insPtr + 2*iCount >= pbyEndInst - 1) 
	   pCSD->pArrayCallStack[pCSD->lCallNestLevel - 1].bLastInst = TRUE;
#endif // FST_CRIT_ONLY

     break;
   }

   /* RS[]	 */
   case 0x43:
   {
     int32 location;
     F26Dot6 * tmpstackPtr = pLocalGS->stackPointer;

     if (Check_For_POP(pLocalGS->stackPointer,stackBase, pLocalGS,1))
	 {
		location = POP(tmpstackPtr);

		if(Check_Storage(pLocalGS,location,pCSD->maxStorageMinus1))
		{
#ifndef FST_CRIT_ONLY
			if((pCSD->pStoreBits == NULL) || (pCSD->pStoreBits[location] != 1))
			{
				char szDetails[SMALL_TEMP_STRING_SIZE];
				sprintf(szDetails,"Index: %ld ",location);
				OutputErrorToClient(pLocalGS,ET_ERROR,ERR_STORE_INDEX_NOT_WRITTEN_TO,szDetails);
			}
		#endif
		}
	 }

     break;
   }

   /* WS[]	  */
   case 0x42:
   {
     int32 value, location;
     F26Dot6 * tmpstackPtr = pLocalGS->stackPointer;

     if (Check_For_POP(pLocalGS->stackPointer,stackBase, pLocalGS,2))
	 {
		value = POP(tmpstackPtr);
		location = POP(tmpstackPtr);

		if(Check_Storage(pLocalGS,location,pCSD->maxStorageMinus1))
		{
	   #ifndef FST_CRIT_ONLY
		/* If first time we write to a store location, alloc array for set state. */
		if(pCSD->pStoreBits == NULL)
		{
			uint16 index;

			pCSD->pStoreBits = (unsigned char *)FST_MALLOC(pLocalGS->globalGS->maxp->maxStorage * sizeof(unsigned char));
			FSTAssert((pCSD->pStoreBits != NULL),"ClientData memory allocation error");
			if (pCSD->pStoreBits == NULL)
			{
				/* stop executing instructions. */
				pLocalGS->TraceFunc = NULL;	
				pLocalGS->ercReturn = TRACE_FAILURE_ERR;  /* returned an error to the rasterizer client */
				/* Set flag to indicate break occured so call stack can be updated properly. */
				pCSD->bBreakOccured = TRUE;
			}
			for(index = 0; index < pLocalGS->globalGS->maxp->maxStorage; index++)
				pCSD->pStoreBits[index] = 0;
		}

		/* Set the set state for the location. */
		pCSD->pStoreBits[location] = 1;
	   #endif
		}
	 }

     break;
   }

   /* WCVTP[] */
   case 0x44:
   {
     int32 cvtIndex, cvtValue;
	 F26Dot6 * tmpstackPtr = pLocalGS->stackPointer;
	 
	 if (Check_For_POP(pLocalGS->stackPointer,stackBase, pLocalGS,2))
	 {
		cvtValue = POP(tmpstackPtr);
		cvtIndex = POP(tmpstackPtr);
		Check_CVT(pLocalGS,cvtIndex, pCSD->cvtCountMinus1);
	 }
     break;
   }

   /* WCVTF[]  */
   case 0x70:
   {      
     int32 cvtIndex, cvtValue;
	 F26Dot6 * tmpstackPtr = pLocalGS->stackPointer;

     if (Check_For_POP(pLocalGS->stackPointer,stackBase, pLocalGS,2))
	 {
		cvtValue = POP(tmpstackPtr);
		cvtIndex = POP(tmpstackPtr);

		Check_CVT(pLocalGS,cvtIndex, pCSD->cvtCountMinus1);
		#ifndef FST_CRIT_ONLY
		Check_FUCoord(pLocalGS,cvtValue);
		#endif
	 }

     break;
   }

   /* RCVT[]  */
   case 0x45:
   {
     int32 cvtIndex;
	 F26Dot6 * tmpstackPtr = pLocalGS->stackPointer;

     if (Check_For_POP(pLocalGS->stackPointer,stackBase, pLocalGS,1))
	 {
		cvtIndex = POP(tmpstackPtr);

#ifndef FSCFG_FONTOGRAPHER_BUG
		Check_CVT(pLocalGS,cvtIndex, pCSD->cvtCountMinus1);
#else
		Check_CVTReadSpecial(pLocalGS,cvtIndex);
#endif // FSCFG_FONTOGRAPHER_BUG
	 }

     break;
   }

   /* SVTCA[a] */
   case 0x00:
   case 0x01:
     break;

   /* SPVTCA[a]	*/
   case 0x02:
   case 0x03:
     break;

   /* SFVTCA[a]	*/
   case 0x04:
   case 0x05:
     break;
   
   /* SPVTL[a] */
   case 0x06:
   case 0x07:
   /* SFVTL[a] */
   case 0x08:
   case 0x09:
   /* SDPVTL[a]	*/
   case 0x86:
   case 0x87:
   {
     F26Dot6 * tmpstackPtr = pLocalGS->stackPointer;
	 int32 point1, point2;

     if (Check_For_POP(pLocalGS->stackPointer,stackBase, pLocalGS,2))
	 {
		point1 = POP(tmpstackPtr);
		point2 = POP(tmpstackPtr);

		Check_ZonePtr(pLocalGS,pLocalGS->CE2,pCSD->maxElementsMinus1, pCSD->maxContours, pCSD->maxPointsIncludePhantomMinus1, pCSD->maxTwilightPointsMinus1);
		Check_Point(pLocalGS,pLocalGS->CE2,point1, pCSD->maxPointsIncludePhantomMinus1, pCSD->maxTwilightPointsMinus1);
		Check_ZonePtr(pLocalGS,pLocalGS->CE1,pCSD->maxElementsMinus1, pCSD->maxContours, pCSD->maxPointsIncludePhantomMinus1, pCSD->maxTwilightPointsMinus1);
		Check_Point(pLocalGS,pLocalGS->CE1,point2, pCSD->maxPointsIncludePhantomMinus1, pCSD->maxTwilightPointsMinus1);
	 }
         
     break;
   }
     
   /* SFVTPV[] */
   case 0x0E:
     break;
   
   /* SPVFS[] */
   case 0x0A:
   /* SFVFS[] */
   case 0x0B:
   {
     F26Dot6 * tmpstackPtr = pLocalGS->stackPointer;
	 #ifndef FST_CRIT_ONLY
	 int32 x,y;
	 VECTORTYPE vx, vy;
	 #endif

     if (Check_For_POP(pLocalGS->stackPointer,stackBase, pLocalGS,2))
	 {
	 #ifndef FST_CRIT_ONLY
		y = (int32)POP(tmpstackPtr);
		x = (int32)POP(tmpstackPtr);

		Check_INT16(pLocalGS,y);
		Check_INT16(pLocalGS,x);

		vy = (VECTORTYPE)y;
		vx = (VECTORTYPE)x;

		/* Check vector components to make sure that they are not zero. */
		if(vy == 0 && vx == 0)
		OutputErrorToClient(pLocalGS,ET_ERROR,ERR_VECTOR_XY_ZERO,NULL);
	 
		/* Check vector components to make sure that x^2 + y^2 ~= 0x4000^2. */
		if(vx*vx + vy*vy != 0x10000000)
		{
			if(((vx-1)*(vx-1) + (vy-1)*(vy-1) >= 0x10000000) &&
				((vx+1)*(vx+1) + (vy+1)*(vy+1) <= 0x10000000))
			{
				OutputErrorToClient(pLocalGS,ET_ERROR,ERR_VECTOR_XY_INVALID,NULL);
			}
		}
	 #endif
	 }    
     break;
   }
      
   /* GPV[], GFV[] */
   case 0x0C:
   case 0x0D:
     Check_For_PUSH(pLocalGS->stackPointer,stackMax, pLocalGS,2);
     break;   

   /* SRP0[],SRP1[],SRP2[] */
   case 0x10:
   case 0x11:
   case 0x12:
     if (Check_For_POP(pLocalGS->stackPointer,stackBase, pLocalGS,1))
	 {
		#ifndef FST_CRIT_ONLY
		pCSD->RefPtsUsed[pLocalGS->opCode - 0x10] = 1;
		#endif 
	 }
     break;
  
   /* SZP0[], SZP1[], SZP2[], SZPS[] */
   case 0x13:
   case 0x14:
   case 0x15:
   case 0x16:
   {
     int32 zone;
     F26Dot6 * tmpstackPtr = pLocalGS->stackPointer;

     if (Check_For_POP(pLocalGS->stackPointer,stackBase, pLocalGS,1))
	 {
		zone = POP(tmpstackPtr);
		Check_Zone(pLocalGS,zone,pCSD->maxElementsMinus1);
	 }
         
     break;
   }   

   /* RTHG[] */
   case 0x19:
     break;

   /* RTG[] */
   case 0x18:
     break;

   /* RTDG[] */
   case 0x3D:
     break;

   /* RDTG[] */
   case 0x7D:
     break;
   
   /* Unknown */
   case 0x7B:
	 #ifndef FST_CRIT_ONLY 
     OutputErrorToClient(pLocalGS,ET_ERROR,ERR_INVALID_INSTRUCTION,NULL);
	 pCSD->pArrayCallStack[pCSD->lCallNestLevel - 1].bLastInst = TRUE;	 
#endif // FST_CRIT_ONLY
     break;
   
   /* RUTG[] */
   case 0x7C:
     break;
      
   /* ROFF[] */
   case 0x7A:
     break;

   /* SROUND[] */
   case 0x76:
   /* S45ROUND[] */
   case 0x77:
   { 
     #define period_mask     0x000000C0
	 #define reserved_period 0x000000C0

     F26Dot6 * tmpstackPtr = pLocalGS->stackPointer;
	 #ifndef FST_CRIT_ONLY
	 int32 arg;
	 #endif

     if (Check_For_POP(pLocalGS->stackPointer,stackBase, pLocalGS,1))
	 {
		#ifndef FST_CRIT_ONLY
		arg = (int32)POP(tmpstackPtr);
     
		Check_INT8(pLocalGS,arg);

		if((arg & period_mask) == reserved_period)
			OutputErrorToClient(pLocalGS,ET_ERROR,ERR_3_USED_FOR_PERIOD,NULL);
		#endif
	 }    
     break;
   }
 
   /* SLOOP[] */
   case 0x17:
   {
     F26Dot6 * tmpstackPtr = pLocalGS->stackPointer;
	 int32 arg;

     if (Check_For_POP(pLocalGS->stackPointer,stackBase, pLocalGS,1))
	 {
		arg = (int32)POP(tmpstackPtr);

		#ifndef FST_CRIT_ONLY	 
		Check_Larger(pLocalGS,-1L,arg);
		#endif

		pCSD->lLoopSet = arg - 1;
	 }

     break;
   }

   /* SMD[] */
   case 0x1A:
   {
     F26Dot6 * tmpstackPtr = pLocalGS->stackPointer;
	 #ifndef FST_CRIT_ONLY
	 int32 arg;
	 #endif

     if (Check_For_POP(pLocalGS->stackPointer,stackBase, pLocalGS,1))
	 {
		#ifndef FST_CRIT_ONLY
		arg = (int32)POP(tmpstackPtr);
     
		Check_Larger(pLocalGS,-1L,arg);
		#endif
	 }
         
     break;
   }

   /* INSTCTRL[] */
   case 0x8E:
   {
	 F26Dot6 * tmpstackPtr = pLocalGS->stackPointer;
	 #ifndef FST_CRIT_ONLY
	 int32 value, selector;
	 #endif
	      
     if (Check_For_POP(pLocalGS->stackPointer,stackBase, pLocalGS,2))
	 {
		#ifndef FST_CRIT_ONLY
		selector = (int32)POP(tmpstackPtr);
		value = (int32)POP(tmpstackPtr);
     
		Check_INSTCTRL_Selector(pLocalGS,selector);

		if(selector == 1)
		{
			if((value != 0) && (value != 1))
			{
				char szBuffer[SMALL_TEMP_STRING_SIZE];
				sprintf(szBuffer,"Value: %ld",value);
				OutputErrorToClient(pLocalGS,ET_ERROR,ERR_VALUE_INVALID_0_OR_1,szBuffer); 
			}
	   
		}else if(selector == 2)
		{
			if((value != 0) && (value != 2))
			{
				char szBuffer[SMALL_TEMP_STRING_SIZE];
				sprintf(szBuffer,"Value: %ld",value);
				OutputErrorToClient(pLocalGS,ET_ERROR,ERR_VALUE_INVALID_0_OR_2,szBuffer);
			} 
		}

		if(!pLocalGS->globalGS->init)
			OutputErrorToClient(pLocalGS,ET_ERROR,ERR_NOT_CALLED_FROM_PREPROGRAM,NULL);
		#endif
	 }
         
     break;
   }

   /* SCANCTRL[] */
   case 0x85:
   {
     #define reserved_bits 0x0000C000
	 #define mutual_ex_ppm 0x00000900
	 #define mutual_ex_rot 0x00001200
	 #define mutual_ex_str 0x00002400

	 F26Dot6 * tmpstackPtr = pLocalGS->stackPointer;
	 #ifndef FST_CRIT_ONLY
	 int32 arg;
	 #endif

     if (Check_For_POP(pLocalGS->stackPointer,stackBase, pLocalGS,1))
	 {
		#ifndef FST_CRIT_ONLY 
		arg = (int32)POP(tmpstackPtr);
     
		Check_INT16(pLocalGS,arg);

		if(arg & reserved_bits)
			OutputErrorToClient(pLocalGS,ET_ERROR,ERR_RESERVED_BIT_SET,NULL);

		if((arg & mutual_ex_ppm) == mutual_ex_ppm)
		  OutputErrorToClient(pLocalGS,ET_ERROR,ERR_BITS_8_AND_11_SET,NULL);

		if((arg & mutual_ex_rot) == mutual_ex_rot)
		  OutputErrorToClient(pLocalGS,ET_ERROR,ERR_BITS_9_AND_12_SET,NULL);
	   
		if((arg & mutual_ex_str) == mutual_ex_str)
		  OutputErrorToClient(pLocalGS,ET_ERROR,ERR_BITS_10_AND_13_SET,NULL); 
		#endif
	 }
         
     break;
   }

   /* SCANTYPE[] */
   case 0x8D:
   {
     F26Dot6 * tmpstackPtr = pLocalGS->stackPointer;
	 #ifndef FST_CRIT_ONLY
	 int32 arg;
	 #endif

     if (Check_For_POP(pLocalGS->stackPointer,stackBase, pLocalGS,1))
	 {
		#ifndef FST_CRIT_ONLY 
		arg = (int32)POP(tmpstackPtr);
	 
		Check_INT16(pLocalGS,arg);
		Check_Selector(pLocalGS,arg);
		#endif
	 }
         
     break;
   }

   /* SCVTCI[] */
   case 0x1D:
   {
     F26Dot6 * tmpstackPtr = pLocalGS->stackPointer;
	 #ifndef FST_CRIT_ONLY
	 int32 arg;
	 #endif

     if (Check_For_POP(pLocalGS->stackPointer,stackBase, pLocalGS,1))
	 {
		#ifndef FST_CRIT_ONLY
		arg = (int32)POP(tmpstackPtr);

		Check_Larger(pLocalGS,-1L, arg);
		#endif
	 }
         
     break;
   }

   /* SSWCI[] */
   case 0x1E:
   {
     F26Dot6 * tmpstackPtr = pLocalGS->stackPointer;
	 #ifndef FST_CRIT_ONLY
	 int32 arg;
	 #endif

     if (Check_For_POP(pLocalGS->stackPointer,stackBase, pLocalGS,1))
	 {
		#ifndef FST_CRIT_ONLY 
		arg = (int32)POP(tmpstackPtr);

		Check_Larger(pLocalGS,-1L, arg);
		#endif
	 }
	     
     break;
   }

   /* SSW[] */
   case 0x1F:
   {
     F26Dot6 * tmpstackPtr = pLocalGS->stackPointer;
	 #ifndef FST_CRIT_ONLY
	 int32 arg;
	 #endif

     if (Check_For_POP(pLocalGS->stackPointer,stackBase, pLocalGS,1))
	 {
		#ifndef FST_CRIT_ONLY
		arg = (int32)POP(tmpstackPtr);

		Check_INT16(pLocalGS,arg);
		Check_Larger(pLocalGS,-1L,arg);
		#endif
	 }

     break;
   }

   /* FLIPON[] */
   case 0x4D:
     break;

   /* FLIPOFF[] */
   case 0x4E:
     break;

   /* SANGW[] */
   case 0x7E:
   { 
     F26Dot6 * tmpstackPtr = pLocalGS->stackPointer;
	 #ifndef FST_CRIT_ONLY
	 int32 arg;
	 #endif

     if (Check_For_POP(pLocalGS->stackPointer,stackBase, pLocalGS,1))
	 {
		#ifndef FST_CRIT_ONLY 
		arg = (int32)POP(tmpstackPtr);
     
		Check_INT16(pLocalGS,arg);

		OutputErrorToClient(pLocalGS,ET_WARNING,WAR_SANGW_OBSELETE,NULL); 
		#endif
	 }
         
     break;
   }

   /* SDB[] */
   case 0x5E:
   {
     F26Dot6 * tmpstackPtr = pLocalGS->stackPointer;
	 #ifndef FST_CRIT_ONLY
	 int32 arg;
	 #endif

     if (Check_For_POP(pLocalGS->stackPointer,stackBase, pLocalGS,1))
	 {
		#ifndef FST_CRIT_ONLY
		arg = (int32)POP(tmpstackPtr);
     
		Check_INT16(pLocalGS,arg);
		#endif
	 }
      
     break;
   }

   /* SDS[] */
   case 0x5F:
   {
     F26Dot6 * tmpstackPtr = pLocalGS->stackPointer;
	 #ifndef FST_CRIT_ONLY
	 int32 arg;
	 #endif

     if (Check_For_POP(pLocalGS->stackPointer,stackBase, pLocalGS,1))
	 {
		#ifndef FST_CRIT_ONLY
		arg = (int32)POP(tmpstackPtr);

		Check_INT16(pLocalGS,arg);
		/* Percision is 1/(2^delta shift). Since 1/64 is highest percision any value 
		   greater than 6 is too high. */
		Check_Range(pLocalGS,arg,0L,6L);
		#endif
	 }

     break;
   }

   /* GC[a] */
   case 0x46:
   case 0x47:
   {
     F26Dot6 * tmpstackPtr = pLocalGS->stackPointer;
	 int32 point;

     if (Check_For_POP(pLocalGS->stackPointer,stackBase, pLocalGS,1))
	 {
		point = POP(tmpstackPtr);

		Check_ZonePtr(pLocalGS,pLocalGS->CE2,pCSD->maxElementsMinus1, pCSD->maxContours, pCSD->maxPointsIncludePhantomMinus1, pCSD->maxTwilightPointsMinus1);
		Check_Point(pLocalGS,pLocalGS->CE2,point, pCSD->maxPointsIncludePhantomMinus1, pCSD->maxTwilightPointsMinus1);
	 }

     break;
   }
   
   /* SCFS[] */
   case 0x48:
   { 
     F26Dot6 * tmpstackPtr = pLocalGS->stackPointer; 
     F26Dot6 value;
	 int32 point;
     
     if (Check_For_POP(pLocalGS->stackPointer,stackBase, pLocalGS,2))
	 {
		value = POP(tmpstackPtr);
		point = POP(tmpstackPtr);

		Check_ZonePtr(pLocalGS,pLocalGS->CE2,pCSD->maxElementsMinus1, pCSD->maxContours, pCSD->maxPointsIncludePhantomMinus1, pCSD->maxTwilightPointsMinus1);
		#ifndef FST_CRIT_ONLY
		SetTwilightZonePt(pCSD,pLocalGS,pLocalGS->CE2,point);
		#endif
		Check_Point(pLocalGS,pLocalGS->CE2,point, pCSD->maxPointsIncludePhantomMinus1, pCSD->maxTwilightPointsMinus1);

		#ifndef FST_CRIT_ONLY
		Check_PF_Vectors(pLocalGS);
		#endif
	 }

     break;
   }

   /* MD[a] */
   case 0x49:
   case 0x4A:
   {
     F26Dot6 * tmpstackPtr = pLocalGS->stackPointer;
	 int32 point1, point2;

     if (Check_For_POP(pLocalGS->stackPointer,stackBase, pLocalGS,2))
	 {
		point1 = POP(tmpstackPtr);
		point2 = POP(tmpstackPtr);

		Check_ZonePtr(pLocalGS,pLocalGS->CE1,pCSD->maxElementsMinus1, pCSD->maxContours, pCSD->maxPointsIncludePhantomMinus1, pCSD->maxTwilightPointsMinus1);
		Check_Point(pLocalGS,pLocalGS->CE1,point1, pCSD->maxPointsIncludePhantomMinus1, pCSD->maxTwilightPointsMinus1);
		Check_ZonePtr(pLocalGS,pLocalGS->CE0,pCSD->maxElementsMinus1, pCSD->maxContours, pCSD->maxPointsIncludePhantomMinus1, pCSD->maxTwilightPointsMinus1);
		Check_Point(pLocalGS,pLocalGS->CE0,point2, pCSD->maxPointsIncludePhantomMinus1, pCSD->maxTwilightPointsMinus1);
	 }
     break;
   }

   /* MPPEM[] */
   case 0x4B:
     Check_For_PUSH(pLocalGS->stackPointer,stackMax, pLocalGS,1);
     break;

   /* MPS[] */
   case 0x4C:
     Check_For_PUSH(pLocalGS->stackPointer,stackMax, pLocalGS,1);
	 #ifndef FST_CRIT_ONLY
	 OutputErrorToClient(pLocalGS,ET_WARNING,WAR_MPS_ALWAYS_12_ON_WINDOWS,NULL);
     #endif
     break;

   /* FLIPPT[] */
   case 0x80:
   {
     F26Dot6 * tmpstackPtr = pLocalGS->stackPointer;
	 pCSD->lCurrentLoop = pLocalGS->loop;
     
	 if (Check_For_POP(tmpstackPtr,stackBase,pLocalGS, pCSD->lCurrentLoop + 1))
	 {
	 
		Check_ZonePtr(pLocalGS,pLocalGS->CE0,pCSD->maxElementsMinus1, pCSD->maxContours, pCSD->maxPointsIncludePhantomMinus1, pCSD->maxTwilightPointsMinus1);
		while (pCSD->lCurrentLoop >= 0)
		{
		  int32 point = (int32)POP(tmpstackPtr);
		  Check_Point(pLocalGS,pLocalGS->CE0,point, pCSD->maxPointsIncludePhantomMinus1, pCSD->maxTwilightPointsMinus1);
		  pCSD->lCurrentLoop--;
		}
		pCSD->lCurrentLoop = 0;
		pCSD->lLoopSet = 0; 
	 }

     break;
   }

   /* FLIPRGON[] */
   case 0x81:
   /* FLIPRGOFF[] */
   case 0x82:
   {
     int32 lo, hi;
	 F26Dot6 * tmpstackPtr = pLocalGS->stackPointer;

	 if (Check_For_POP(pLocalGS->stackPointer,stackBase, pLocalGS,2))
	 {
		hi = (int32)POP(tmpstackPtr);
		lo = (int32)POP(tmpstackPtr);

		Check_ZonePtr(pLocalGS,pLocalGS->CE0,pCSD->maxElementsMinus1, pCSD->maxContours, pCSD->maxPointsIncludePhantomMinus1, pCSD->maxTwilightPointsMinus1);
		Check_Point(pLocalGS,pLocalGS->CE0,hi, pCSD->maxPointsIncludePhantomMinus1, pCSD->maxTwilightPointsMinus1);
		Check_Point(pLocalGS,pLocalGS->CE0,lo, pCSD->maxPointsIncludePhantomMinus1, pCSD->maxTwilightPointsMinus1);
	 
		#ifndef FST_CRIT_ONLY
		/* If high point is < low point, instruction will do nothing so warn user. */
		if(hi < lo)
		  OutputErrorToClient(pLocalGS,ET_WARNING,WAR_HI_PT_LESS_THAN_LOW_PT,NULL);
		#endif
	 }
	      
     break;
   }    
     
   /* SHP[a] */
   case 0x32:
   case 0x33:
   {
     F26Dot6 * tmpstackPtr = pLocalGS->stackPointer;
     int32 rpt;
	 fnt_ElementType * relement;
	 int32 point;

	 pCSD->lCurrentLoop = pLocalGS->loop;

     if (BIT0 (pLocalGS->opCode))
	 {
	   #ifndef FST_CRIT_ONLY
	   Check_RefPtUsed(pLocalGS,1);
	   #endif
	   rpt = pLocalGS->Pt1;
	   relement = pLocalGS->CE0;
	 } 
 	 else 
	 {
	   #ifndef FST_CRIT_ONLY
	   Check_RefPtUsed(pLocalGS,2);
	   #endif
	   rpt = pLocalGS->Pt2;
	   relement = pLocalGS->CE1;
	 }

	 Check_ZonePtr(pLocalGS,relement,pCSD->maxElementsMinus1, pCSD->maxContours, pCSD->maxPointsIncludePhantomMinus1, pCSD->maxTwilightPointsMinus1);
	 Check_Point(pLocalGS,relement,rpt, pCSD->maxPointsIncludePhantomMinus1, pCSD->maxTwilightPointsMinus1);
	
	 if (Check_For_POP(tmpstackPtr,stackBase, pLocalGS,pCSD->lCurrentLoop + 1))
	 {
	 
		Check_ZonePtr(pLocalGS,pLocalGS->CE2,pCSD->maxElementsMinus1, pCSD->maxContours, pCSD->maxPointsIncludePhantomMinus1, pCSD->maxTwilightPointsMinus1);
		while (pCSD->lCurrentLoop >= 0)
		{
		  point = (int32)POP(tmpstackPtr);
		  #ifndef FST_CRIT_ONLY
		   SetTwilightZonePt(pCSD,pLocalGS,pLocalGS->CE2,point);
		   #endif
		   Check_Point(pLocalGS,pLocalGS->CE2,point, pCSD->maxPointsIncludePhantomMinus1, pCSD->maxTwilightPointsMinus1);
		   pCSD->lCurrentLoop--;
		}	 
		pCSD->lCurrentLoop = 0;
		pCSD->lLoopSet = 0;

		#ifndef FST_CRIT_ONLY
		Check_PF_Vectors(pLocalGS); 
		#endif
	 }
	 	   
     break;
   }

   /* SHC[a] */
   case 0x34:
   case 0x35:
   {
	 F26Dot6 * tmpstackPtr = pLocalGS->stackPointer;
     int32 rpt;
	 fnt_ElementType * relement;
	 int32 contour;
	 
	 if (BIT0 (pLocalGS->opCode))
	 {
	   #ifndef FST_CRIT_ONLY
	   Check_RefPtUsed(pLocalGS,1);
	   #endif
	   rpt = pLocalGS->Pt1;
	   relement = pLocalGS->CE0;
	 } 
 	 else 
	 {
	   #ifndef FST_CRIT_ONLY
	   Check_RefPtUsed(pLocalGS,2);
	   #endif
	   rpt = pLocalGS->Pt2;
	   relement = pLocalGS->CE1;
	 }

	 Check_ForUnitializedZone (pLocalGS, pLocalGS->CE2);
	 Check_ZonePtr(pLocalGS,relement,pCSD->maxElementsMinus1, pCSD->maxContours, pCSD->maxPointsIncludePhantomMinus1, pCSD->maxTwilightPointsMinus1);
	 Check_Point(pLocalGS,relement,rpt, pCSD->maxPointsIncludePhantomMinus1, pCSD->maxTwilightPointsMinus1);

     if (Check_For_POP(pLocalGS->stackPointer,stackBase, pLocalGS,1))
	 {
		contour = (int32)POP(tmpstackPtr);
	 
		Check_ZonePtr(pLocalGS,pLocalGS->CE2,pCSD->maxElementsMinus1, pCSD->maxContours, pCSD->maxPointsIncludePhantomMinus1, pCSD->maxTwilightPointsMinus1);
		Check_Contour(pLocalGS,pLocalGS->CE2,contour, pCSD->maxContours);

		#ifndef FST_CRIT_ONLY
		Check_PF_Vectors(pLocalGS); 
		#endif
	 }

     break;
   }

   /* SHZ[a] */
   case 0x36:
   case 0x37:
   {
     F26Dot6 * tmpstackPtr = pLocalGS->stackPointer;
     int32 rpt;
	 fnt_ElementType * relement;
	 int32 zone;

	 if (BIT0 (pLocalGS->opCode))
	 {
	   #ifndef FST_CRIT_ONLY
	   Check_RefPtUsed(pLocalGS,1);
	   #endif
	   rpt = pLocalGS->Pt1;
	   relement = pLocalGS->CE0;
	 } 
 	 else 
	 {
	   #ifndef FST_CRIT_ONLY
	   Check_RefPtUsed(pLocalGS,2);
	   #endif
	   rpt = pLocalGS->Pt2;
	   relement = pLocalGS->CE1;
	 }

	 Check_ZonePtr(pLocalGS,relement,pCSD->maxElementsMinus1, pCSD->maxContours, pCSD->maxPointsIncludePhantomMinus1, pCSD->maxTwilightPointsMinus1);
	 Check_Point(pLocalGS,relement,rpt, pCSD->maxPointsIncludePhantomMinus1, pCSD->maxTwilightPointsMinus1);

     if (Check_For_POP(pLocalGS->stackPointer,stackBase, pLocalGS,1))
	 {
		zone = (int32)POP(tmpstackPtr);

		Check_Zone(pLocalGS,zone, pCSD->maxElementsMinus1);
		Check_ForUnitializedZone (pLocalGS, &pLocalGS->elements[zone]);

		#ifndef FST_CRIT_ONLY
		Check_PF_Vectors(pLocalGS); 
		#endif
	 }
     
     break;
   }

   /* SHPIX[] */
   case 0x38:
   {
	 F26Dot6 * tmpstackPtr = pLocalGS->stackPointer;
	 int32 point;
	 F26Dot6 proj;

	 pCSD->lCurrentLoop = pLocalGS->loop;

     if (Check_For_POP(pLocalGS->stackPointer,stackBase, pLocalGS,1))
	 {
		proj = POP(tmpstackPtr);

		Check_For_POP(tmpstackPtr,stackBase,pLocalGS, pCSD->lCurrentLoop + 1);

		Check_ZonePtr(pLocalGS,pLocalGS->CE2,pCSD->maxElementsMinus1, pCSD->maxContours, pCSD->maxPointsIncludePhantomMinus1, pCSD->maxTwilightPointsMinus1);
		while (pCSD->lCurrentLoop >= 0)
		{
		  point = (int32)POP(tmpstackPtr);
		  #ifndef FST_CRIT_ONLY
		  SetTwilightZonePt(pCSD,pLocalGS,pLocalGS->CE2,point);
		  #endif
		  Check_Point(pLocalGS,pLocalGS->CE2,point, pCSD->maxPointsIncludePhantomMinus1, pCSD->maxTwilightPointsMinus1);
		  pCSD->lCurrentLoop--;
		}
		pCSD->lCurrentLoop = 0;
		pCSD->lLoopSet = 0; 
	 }
	 
	 break;
   }

   /* MSIRP[a] */
   case 0x3A:
   case 0x3B:
   {
     F26Dot6 * tmpstackPtr = pLocalGS->stackPointer;
	 int32 iPt2;                           
	 F26Dot6 fxDist;                            
	 
     if (Check_For_POP(pLocalGS->stackPointer,stackBase, pLocalGS,2))
	 {
		fxDist = POP(tmpstackPtr);
		iPt2 = (int32)POP(tmpstackPtr);

		Check_ZonePtr(pLocalGS,pLocalGS->CE1,pCSD->maxElementsMinus1, pCSD->maxContours, pCSD->maxPointsIncludePhantomMinus1, pCSD->maxTwilightPointsMinus1);
		#ifndef FST_CRIT_ONLY
		SetTwilightZonePt(pCSD,pLocalGS,pLocalGS->CE1,iPt2);
		#endif
		Check_Point(pLocalGS,pLocalGS->CE1,iPt2, pCSD->maxPointsIncludePhantomMinus1, pCSD->maxTwilightPointsMinus1);

		#ifndef FST_CRIT_ONLY
		Check_RefPtUsed(pLocalGS,0);
		#endif
		Check_ZonePtr(pLocalGS,pLocalGS->CE0,pCSD->maxElementsMinus1, pCSD->maxContours, pCSD->maxPointsIncludePhantomMinus1, pCSD->maxTwilightPointsMinus1);
		Check_Point(pLocalGS,pLocalGS->CE0,pLocalGS->Pt0, pCSD->maxPointsIncludePhantomMinus1, pCSD->maxTwilightPointsMinus1);

		#ifndef FST_CRIT_ONLY
		Check_PF_Vectors(pLocalGS); 

		/* Update reference point set state. */
		if (BIT0 (pLocalGS->opCode))
		{
		  	pCSD->RefPtsUsed[0] = 1;
		}	 
		pCSD->RefPtsUsed[1] = 1;
		pCSD->RefPtsUsed[2] = 1;
		#endif
	 }

     break;
   }

   /* MDAP[a] */
   case 0x2E:
   case 0x2F:
   { 
     F26Dot6 * tmpstackPtr = pLocalGS->stackPointer;
	 int32 iPt;

     if (Check_For_POP(pLocalGS->stackPointer,stackBase, pLocalGS,1))
	 {
		iPt = (int32)POP(tmpstackPtr);

		Check_ZonePtr(pLocalGS,pLocalGS->CE0,pCSD->maxElementsMinus1, pCSD->maxContours, pCSD->maxPointsIncludePhantomMinus1, pCSD->maxTwilightPointsMinus1);
		#ifndef FST_CRIT_ONLY
		SetTwilightZonePt(pCSD,pLocalGS,pLocalGS->CE0,iPt);
		#endif
		Check_Point(pLocalGS,pLocalGS->CE0,iPt, pCSD->maxPointsIncludePhantomMinus1, pCSD->maxTwilightPointsMinus1);

		#ifndef FST_CRIT_ONLY
		Check_PF_Vectors(pLocalGS); 

		/* Reference points 0 and 1 set. */
		pCSD->RefPtsUsed[0] = 1;
		pCSD->RefPtsUsed[1] = 1;
		#endif
	 }

     break;
   }

   /* MIAP[a] */
   case 0x3E:
   case 0x3F:
   { 
     F26Dot6 * tmpstackPtr = pLocalGS->stackPointer;
	 int32   iPoint;
	 int32   iCVTIndex;

     if (Check_For_POP(pLocalGS->stackPointer,stackBase, pLocalGS,2))
	 {
		iCVTIndex = POP(tmpstackPtr);
		iPoint = POP(tmpstackPtr);

		Check_CVT(pLocalGS,iCVTIndex, pCSD->cvtCountMinus1);

		Check_ZonePtr(pLocalGS,pLocalGS->CE0,pCSD->maxElementsMinus1, pCSD->maxContours, pCSD->maxPointsIncludePhantomMinus1, pCSD->maxTwilightPointsMinus1);
		#ifndef FST_CRIT_ONLY
		SetTwilightZonePt(pCSD,pLocalGS,pLocalGS->CE0,iPoint);
		#endif
		Check_Point(pLocalGS,pLocalGS->CE0,iPoint, pCSD->maxPointsIncludePhantomMinus1, pCSD->maxTwilightPointsMinus1);

		#ifndef FST_CRIT_ONLY
		Check_PF_Vectors(pLocalGS); 

		/* Reference points 0 and 1 set. */
		pCSD->RefPtsUsed[0] = 1;
		pCSD->RefPtsUsed[1] = 1;
		#endif
	 }

     break;
   }

   /* MDRP[abcde] */
   case 0xC0:
   case 0xC1:
   case 0xC2:
   case 0xC3:
   case 0xC4:
   case 0xC5:
   case 0xC6:
   case 0xC7:
   case 0xC8:
   case 0xC9:
   case 0xCA:
   case 0xCB:
   case 0xCC:
   case 0xCD:
   case 0xCE:
   case 0xCF:
   case 0xD0:
   case 0xD1:
   case 0xD2:
   case 0xD3:
   case 0xD4:
   case 0xD5:
   case 0xD6:
   case 0xD7:
   case 0xD8:
   case 0xD9:
   case 0xDA:
   case 0xDB:
   case 0xDC:
   case 0xDD:
   case 0xDE:
   case 0xDF:
   {
     F26Dot6 * tmpstackPtr = pLocalGS->stackPointer;
	 int32   iPt1;

     if (Check_For_POP(pLocalGS->stackPointer,stackBase, pLocalGS,1))
	 {
		iPt1 = (int32)POP(tmpstackPtr);

		/* Check to see if distance type for engine characteristic compensation is 3 which is reserved. */
		#ifndef FST_CRIT_ONLY
		if (BIT0(pLocalGS->opCode) && BIT1(pLocalGS->opCode))
		  OutputErrorToClient(pLocalGS,ET_ERROR,ERR_INVALID_FLAG,NULL);
		#endif
	 
		Check_ZonePtr(pLocalGS,pLocalGS->CE1,pCSD->maxElementsMinus1, pCSD->maxContours, pCSD->maxPointsIncludePhantomMinus1, pCSD->maxTwilightPointsMinus1);
		#ifndef FST_CRIT_ONLY
		SetTwilightZonePt(pCSD,pLocalGS,pLocalGS->CE1,iPt1);
		#endif
		Check_Point(pLocalGS,pLocalGS->CE1,iPt1, pCSD->maxPointsIncludePhantomMinus1, pCSD->maxTwilightPointsMinus1);

		#ifndef FST_CRIT_ONLY
		Check_RefPtUsed(pLocalGS,0);
		#endif
		Check_ZonePtr(pLocalGS,pLocalGS->CE0,pCSD->maxElementsMinus1, pCSD->maxContours, pCSD->maxPointsIncludePhantomMinus1, pCSD->maxTwilightPointsMinus1);
		Check_Point(pLocalGS,pLocalGS->CE0,pLocalGS->Pt0, pCSD->maxPointsIncludePhantomMinus1, pCSD->maxTwilightPointsMinus1);

		#ifndef FST_CRIT_ONLY
		Check_PF_Vectors(pLocalGS); 

		/* Update reference point set state. */
		if (BIT4 (pLocalGS->opCode))
		{
		  	pCSD->RefPtsUsed[0] = 1;
		}	 
		pCSD->RefPtsUsed[1] = 1;
		pCSD->RefPtsUsed[2] = 1;
		#endif
	 }

     break;
   }

   /* MIRP[abcde] */
   case 0xE0:
   case 0xE1:
   case 0xE2:
   case 0xE3:
   case 0xE4:
   case 0xE5:
   case 0xE6:
   case 0xE7:
   case 0xE8:
   case 0xE9:
   case 0xEA:
   case 0xEB:
   case 0xEC:
   case 0xED:
   case 0xEE:
   case 0xEF:
   case 0xF0:
   case 0xF1:
   case 0xF2:
   case 0xF3:
   case 0xF4:
   case 0xF5:
   case 0xF6:
   case 0xF7:
   case 0xF8:
   case 0xF9:
   case 0xFA:
   case 0xFB:
   case 0xFC:
   case 0xFD:
   case 0xFE:
   case 0xFF:
   {
     F26Dot6 * tmpstackPtr = pLocalGS->stackPointer;
	 int32   iPt;
	 int32   iCVTIndex;

     if (Check_For_POP(pLocalGS->stackPointer,stackBase, pLocalGS,2))
	 {
		iCVTIndex = (int32)POP(tmpstackPtr);
		iPt = (int32)POP(tmpstackPtr);
	 
		/* Check to see if distance type for engine characteristic compensation is 3 which is reserved. */
		#ifndef FST_CRIT_ONLY
		if (BIT0(pLocalGS->opCode) && BIT1(pLocalGS->opCode))
		  OutputErrorToClient(pLocalGS,ET_ERROR,ERR_INVALID_FLAG,NULL);
		#endif

		Check_CVT(pLocalGS,iCVTIndex, pCSD->cvtCountMinus1);
	 
		Check_ZonePtr(pLocalGS,pLocalGS->CE1,pCSD->maxElementsMinus1, pCSD->maxContours, pCSD->maxPointsIncludePhantomMinus1, pCSD->maxTwilightPointsMinus1);
		#ifndef FST_CRIT_ONLY
		SetTwilightZonePt(pCSD,pLocalGS,pLocalGS->CE1,iPt);
		#endif
		Check_Point(pLocalGS,pLocalGS->CE1,iPt, pCSD->maxPointsIncludePhantomMinus1, pCSD->maxTwilightPointsMinus1);
	 
		#ifndef FST_CRIT_ONLY
		Check_RefPtUsed(pLocalGS,0);
		#endif
		Check_ZonePtr(pLocalGS,pLocalGS->CE0,pCSD->maxElementsMinus1, pCSD->maxContours, pCSD->maxPointsIncludePhantomMinus1, pCSD->maxTwilightPointsMinus1);
		Check_Point(pLocalGS,pLocalGS->CE0,pLocalGS->Pt0, pCSD->maxPointsIncludePhantomMinus1, pCSD->maxTwilightPointsMinus1);

		#ifndef FST_CRIT_ONLY
		Check_PF_Vectors(pLocalGS); 

		/* Update reference point set state. */
		if (BIT4 (pLocalGS->opCode))
		{
		  	pCSD->RefPtsUsed[0] = 1;
		}	 
		pCSD->RefPtsUsed[1] = 1;
		pCSD->RefPtsUsed[2] = 1;
		#endif
	 }
     
     break;
   }

   /* ALIGNRP[] */
   case 0x3C:
   {
     F26Dot6 * tmpstackPtr = pLocalGS->stackPointer;

	 pCSD->lCurrentLoop = pLocalGS->loop;

	 #ifndef FST_CRIT_ONLY
	 Check_RefPtUsed(pLocalGS,0);
	 #endif
	 Check_ZonePtr(pLocalGS,pLocalGS->CE0,pCSD->maxElementsMinus1, pCSD->maxContours, pCSD->maxPointsIncludePhantomMinus1, pCSD->maxTwilightPointsMinus1);
	 Check_Point(pLocalGS,pLocalGS->CE0,pLocalGS->Pt0, pCSD->maxPointsIncludePhantomMinus1, pCSD->maxTwilightPointsMinus1);

	 if (Check_For_POP(tmpstackPtr,stackBase, pLocalGS, pCSD->lCurrentLoop + 1))
	 {
	 
		Check_ZonePtr(pLocalGS,pLocalGS->CE1,pCSD->maxElementsMinus1, pCSD->maxContours, pCSD->maxPointsIncludePhantomMinus1, pCSD->maxTwilightPointsMinus1);
		while (pCSD->lCurrentLoop >= 0)
		{
		  int32 point = (int32)POP(tmpstackPtr);
		  #ifndef FST_CRIT_ONLY
		  SetTwilightZonePt(pCSD,pLocalGS,pLocalGS->CE1,point);
		  #endif
		  Check_Point(pLocalGS,pLocalGS->CE1,point, pCSD->maxPointsIncludePhantomMinus1, pCSD->maxTwilightPointsMinus1);
		  pCSD->lCurrentLoop--;
		}	 
		pLocalGS,pCSD->lCurrentLoop = 0;
		pCSD->lLoopSet = 0; 

		#ifndef FST_CRIT_ONLY
		Check_PF_Vectors(pLocalGS); 
		#endif
	 }
	
     break;
   }

   /* AA[] */
   case 0x7F:
     #ifndef FST_CRIT_ONLY
     OutputErrorToClient(pLocalGS,ET_ERROR,ERR_INVALID_INSTRUCTION,NULL);
	 #endif
	 break;

   /* ISECT[] */
   case 0x0F:
   { 
     F26Dot6 * tmpstackPtr = pLocalGS->stackPointer;
     int32   arg1, arg2;

     if (Check_For_POP(pLocalGS->stackPointer,stackBase, pLocalGS,5))
	 {
     
		arg2 = (int32)POP(tmpstackPtr);
		arg1 = (int32)POP(tmpstackPtr);
	 
		Check_ZonePtr(pLocalGS,pLocalGS->CE0,pCSD->maxElementsMinus1, pCSD->maxContours, pCSD->maxPointsIncludePhantomMinus1, pCSD->maxTwilightPointsMinus1);
		Check_Point(pLocalGS,pLocalGS->CE0,arg2, pCSD->maxPointsIncludePhantomMinus1, pCSD->maxTwilightPointsMinus1);
		Check_Point(pLocalGS,pLocalGS->CE0,arg1, pCSD->maxPointsIncludePhantomMinus1, pCSD->maxTwilightPointsMinus1);

		arg2 = (int32)POP(tmpstackPtr);
		arg1 = (int32)POP(tmpstackPtr);
	 
		Check_ZonePtr(pLocalGS,pLocalGS->CE1,pCSD->maxElementsMinus1, pCSD->maxContours, pCSD->maxPointsIncludePhantomMinus1, pCSD->maxTwilightPointsMinus1);
		Check_Point(pLocalGS,pLocalGS->CE1,arg2, pCSD->maxPointsIncludePhantomMinus1, pCSD->maxTwilightPointsMinus1);
		Check_Point(pLocalGS,pLocalGS->CE1,arg1, pCSD->maxPointsIncludePhantomMinus1, pCSD->maxTwilightPointsMinus1);

		arg1 = (int32)POP(tmpstackPtr);
	 
		Check_ZonePtr(pLocalGS,pLocalGS->CE2,pCSD->maxElementsMinus1, pCSD->maxContours, pCSD->maxPointsIncludePhantomMinus1, pCSD->maxTwilightPointsMinus1);
		#ifndef FST_CRIT_ONLY
		SetTwilightZonePt(pCSD,pLocalGS,pLocalGS->CE2,arg1);
		#endif
		Check_Point(pLocalGS,pLocalGS->CE2,arg1, pCSD->maxPointsIncludePhantomMinus1, pCSD->maxTwilightPointsMinus1);
	 }
	 
     break;
   }

   /* ALIGNPTS[] */
   case 0x27:
   {
     F26Dot6 * tmpstackPtr = pLocalGS->stackPointer;
     int32   pt1, pt2;

     if (Check_For_POP(pLocalGS->stackPointer,stackBase, pLocalGS,2))
	 {
		pt1 = (int32)POP(tmpstackPtr);
		pt2 = (int32)POP(tmpstackPtr);

		Check_ZonePtr(pLocalGS,pLocalGS->CE1,pCSD->maxElementsMinus1, pCSD->maxContours, pCSD->maxPointsIncludePhantomMinus1, pCSD->maxTwilightPointsMinus1);
		#ifndef FST_CRIT_ONLY
		SetTwilightZonePt(pCSD,pLocalGS,pLocalGS->CE1,pt1);
		#endif
		Check_Point(pLocalGS,pLocalGS->CE1,pt1, pCSD->maxPointsIncludePhantomMinus1, pCSD->maxTwilightPointsMinus1);

		Check_ZonePtr(pLocalGS,pLocalGS->CE0,pCSD->maxElementsMinus1, pCSD->maxContours, pCSD->maxPointsIncludePhantomMinus1, pCSD->maxTwilightPointsMinus1);
		#ifndef FST_CRIT_ONLY
		SetTwilightZonePt(pCSD,pLocalGS,pLocalGS->CE0,pt2);
		#endif
		Check_Point(pLocalGS,pLocalGS->CE0,pt2, pCSD->maxPointsIncludePhantomMinus1, pCSD->maxTwilightPointsMinus1);

		#ifndef FST_CRIT_ONLY
		Check_PF_Vectors(pLocalGS);
		#endif
	 }
 

     break;
   }

   /* IP[] */
   case 0x39:
   {
	 F26Dot6 * tmpstackPtr = pLocalGS->stackPointer;
	 int32 point;
	 #ifndef FST_CRIT_ONLY
	 F26Dot6 Pt1Proj, Pt2Proj;
	 F26Dot6 oox_RP1, ooy_RP1, oox_RP2, ooy_RP2;
	 #endif

	 pCSD->lCurrentLoop = pLocalGS->loop;

	 #ifndef FST_CRIT_ONLY
	 Check_RefPtUsed(pLocalGS,1);
	 #endif
	 Check_ZonePtr(pLocalGS,pLocalGS->CE0,pCSD->maxElementsMinus1, pCSD->maxContours, pCSD->maxPointsIncludePhantomMinus1, pCSD->maxTwilightPointsMinus1);
	 Check_Point(pLocalGS,pLocalGS->CE0,pLocalGS->Pt1, pCSD->maxPointsIncludePhantomMinus1, pCSD->maxTwilightPointsMinus1);

	 #ifndef FST_CRIT_ONLY
	 Check_RefPtUsed(pLocalGS,2);
	 #endif
	 Check_ZonePtr(pLocalGS,pLocalGS->CE1,pCSD->maxElementsMinus1, pCSD->maxContours, pCSD->maxPointsIncludePhantomMinus1, pCSD->maxTwilightPointsMinus1);
	 Check_Point(pLocalGS,pLocalGS->CE1,pLocalGS->Pt2, pCSD->maxPointsIncludePhantomMinus1, pCSD->maxTwilightPointsMinus1);

	 #ifndef FST_CRIT_ONLY
	 if(pLocalGS->CE0 == pLocalGS->elements || pLocalGS->CE1 == pLocalGS->elements || pLocalGS->globalGS->bCompositeGlyph)
	 {
		oox_RP1 = pLocalGS->CE0->ox[pLocalGS->Pt1];
		ooy_RP1 = pLocalGS->CE0->oy[pLocalGS->Pt1];

		oox_RP2 = pLocalGS->CE1->ox[pLocalGS->Pt2];
		ooy_RP2	= pLocalGS->CE1->oy[pLocalGS->Pt2];

	 }else
	 {
	    oox_RP1 = pLocalGS->CE0->oox[pLocalGS->Pt1];
		ooy_RP1 = pLocalGS->CE0->ooy[pLocalGS->Pt1];

		oox_RP2 = pLocalGS->CE1->oox[pLocalGS->Pt2];
		ooy_RP2	= pLocalGS->CE1->ooy[pLocalGS->Pt2];
	 }

	 /* Call the Project function to get the position on the projection vector for both points.
	    If both points have the same position, issue an error. */
	 Pt1Proj = (pLocalGS->OldProject)(GSA oox_RP1,ooy_RP1);
	 Pt2Proj = (pLocalGS->OldProject)(GSA oox_RP2,ooy_RP2);

	 if(Pt1Proj == Pt2Proj)
	 {
	   char szDetails[SMALL_TEMP_STRING_SIZE];

	   sprintf(szDetails,"RP1 = %ld, RP2 = %ld ",pLocalGS->Pt1,pLocalGS->Pt2);
	   OutputErrorToClient(pLocalGS,ET_ERROR,ERR_RP1_RP2_SAME_POS_ON_PROJ,szDetails);
	 }
	 #endif

	 if (Check_For_POP(tmpstackPtr,stackBase, pLocalGS,pCSD->lCurrentLoop + 1))
	 {

		Check_ZonePtr(pLocalGS,pLocalGS->CE2,pCSD->maxElementsMinus1, pCSD->maxContours, pCSD->maxPointsIncludePhantomMinus1, pCSD->maxTwilightPointsMinus1);
		while (pCSD->lCurrentLoop >= 0)
		{
		  point = (int32)POP(tmpstackPtr);
		  #ifndef FST_CRIT_ONLY
		  SetTwilightZonePt(pCSD,pLocalGS,pLocalGS->CE2,point);
		   #endif
		  Check_Point(pLocalGS,pLocalGS->CE2,point, pCSD->maxPointsIncludePhantomMinus1, pCSD->maxTwilightPointsMinus1);
		   pCSD->lCurrentLoop--;
		  }
		pCSD->lCurrentLoop = 0;
		pCSD->lLoopSet = 0; 

		#ifndef FST_CRIT_ONLY
		Check_PF_Vectors(pLocalGS);
		#endif
	 }
	  	 
     break;
   }

   /* UTP[] */
   case 0x29:
   {
     F26Dot6 * tmpstackPtr = pLocalGS->stackPointer;
	 int32 point;
	 uint8 * f = pLocalGS->CE0->f;

	 if (Check_For_POP(pLocalGS->stackPointer,stackBase, pLocalGS,1))
	 {
		point = (int32)POP(tmpstackPtr);

		Check_ZonePtr(pLocalGS,pLocalGS->CE0,pCSD->maxElementsMinus1, pCSD->maxContours, pCSD->maxPointsIncludePhantomMinus1, pCSD->maxTwilightPointsMinus1);
		Check_Point(pLocalGS,pLocalGS->CE0,point, pCSD->maxPointsIncludePhantomMinus1, pCSD->maxTwilightPointsMinus1);

		#ifndef FST_CRIT_ONLY
		if(pLocalGS->free.x && pLocalGS->free.y)
		{
		  if(!(f[point] & XMOVED) && !(f[point] & YMOVED))
		    OutputErrorToClient(pLocalGS,ET_WARNING,WAR_PT_NOT_TOUCHED,NULL);
	     
		}else if (pLocalGS->free.x)
		{
		  if(!(f[point] & XMOVED))
		    OutputErrorToClient(pLocalGS,ET_WARNING,WAR_PT_NOT_TOUCHED,NULL);
		}else if (pLocalGS->free.y)
		{
		  if(!(f[point] & YMOVED))
		    OutputErrorToClient(pLocalGS,ET_WARNING,WAR_PT_NOT_TOUCHED,NULL);
		}
		#endif 
	 }
	 
     break;
   }

   /* IUP[a] */
   case 0x30:
   case 0x31:
   {
     Check_ForUnitializedZone (pLocalGS,pLocalGS->CE2);

     #ifndef FST_CRIT_ONLY
     /* Make sure zone pointer 2 points to zone 1 */
	 if(pLocalGS->CE2 != &pLocalGS->elements[1])
	   OutputErrorToClient(pLocalGS,ET_ERROR,ERR_INVALID_ZONE_IN_IUP,NULL);
	 #endif

	 Check_ZonePtr(pLocalGS,pLocalGS->CE2,pCSD->maxElementsMinus1, pCSD->maxContours, pCSD->maxPointsIncludePhantomMinus1, pCSD->maxTwilightPointsMinus1);

	 #ifndef FST_CRIT_ONLY
	 Check_PF_Vectors(pLocalGS);
	 #endif 

     break;
   }

   /* DELTAP1[] */
   case 0x5D:
   /* DELTAP2[] */
   case 0x71:
   /* DELTAP3[] */
   case 0x72:
   {
     F26Dot6 * tmpstackPtr = pLocalGS->stackPointer;
	 int32 count, point, arg, numPOPs;

#ifdef FST_DELTA_SPECIFIC_PPEM
     int16 sBase; /* used for delta */
	 int32 iFakePPEM, iFakeArgPPEM, iRange;

     iRange = pLocalGS->globalGS->pixelsPerEm;

	 if (!pLocalGS->globalGS->bSameStretch)
     {
		iRange = (int32)FixMul(iRange, fst_GetCVTScale (pLocalGS));
     }

     sBase = (int16)(pLocalGS->globalGS->localParBlock.deltaBase);

	 if (pLocalGS->opCode == 0x71) sBase += 16; /* DELTAP2[] */
	 if (pLocalGS->opCode == 0x72) sBase += 32; /* DELTAP3[] */
	iFakePPEM = iRange - (int32)sBase;

	/* are we in the ppem range we are interested in */
	if ((iFakePPEM < 16) && (iFakePPEM >= 0))
	{
	 iFakePPEM = iFakePPEM << 4;
#endif // FST_DELTA_SPECIFIC_PPEM

     if (Check_For_POP(pLocalGS->stackPointer,stackBase, pLocalGS,1))
	 {
		 count = (int32)POP(tmpstackPtr);
	 
		 numPOPs = count << 1; 
		 if (Check_For_POP(tmpstackPtr,stackBase, pLocalGS,numPOPs))
		 {
	 
			Check_ZonePtr(pLocalGS,pLocalGS->CE0,pCSD->maxElementsMinus1, pCSD->maxContours, pCSD->maxPointsIncludePhantomMinus1, pCSD->maxTwilightPointsMinus1);
			for(; count > 0; count--)
			{
			  point = (int32)POP(tmpstackPtr);
			  arg = (int32)POP(tmpstackPtr);

#ifdef FST_DELTA_SPECIFIC_PPEM
			 	iFakeArgPPEM = arg & ~0x0f;
				if (iFakeArgPPEM == iFakePPEM)
				{
#endif // FST_DELTA_SPECIFIC_PPEM

	   
			     #ifndef FST_CRIT_ONLY
			    SetTwilightZonePt(pCSD,pLocalGS,pLocalGS->CE0,point);
			    Check_INT8(pLocalGS,arg);
			    #endif
			   Check_Point(pLocalGS,pLocalGS->CE0,point, pCSD->maxPointsIncludePhantomMinus1, pCSD->maxTwilightPointsMinus1);
#ifdef FST_DELTA_SPECIFIC_PPEM
				}
#endif // FST_DELTA_SPECIFIC_PPEM

			} 
		 }
	 }
#ifdef FST_DELTA_SPECIFIC_PPEM
	}
#endif // FST_DELTA_SPECIFIC_PPEM
	 	 
     break;
   }
      
   /* DELTAC1[] */
   case 0x73:
   /* DELTAC2[] */
   case 0x74:
   /* DELTAC3[] */
   case 0x75:
   {
     F26Dot6 * tmpstackPtr = pLocalGS->stackPointer;
	 int32 count, cvt, arg, numPOPs;

#ifdef FST_DELTA_SPECIFIC_PPEM
     int16 sBase; /* used for delta */
	 int32 iFakePPEM, iFakeArgPPEM, iRange;

     iRange = pLocalGS->globalGS->pixelsPerEm;

	 if (!pLocalGS->globalGS->bSameStretch)
     {
		iRange = (int32)FixMul(iRange, fst_GetCVTScale (pLocalGS));
     }

	 sBase = (int16)(pLocalGS->globalGS->localParBlock.deltaBase);

	 if (pLocalGS->opCode == 0x74) sBase += 16; /* DELTAC2[] */
	 if (pLocalGS->opCode == 0x75) sBase += 32; /* DELTAC3[] */
	iFakePPEM = iRange - (int32)sBase;

	/* are we in the ppem range we are interested in */
	if ((iFakePPEM < 16) && (iFakePPEM >= 0))
	{
	 iFakePPEM = iFakePPEM << 4;
#endif // FST_DELTA_SPECIFIC_PPEM
     if (Check_For_POP(pLocalGS->stackPointer,stackBase, pLocalGS,1))
	 {
		 count = (int32)POP(tmpstackPtr);
	 
		 numPOPs = count << 1; 
		 if (Check_For_POP(tmpstackPtr,stackBase, pLocalGS,numPOPs))
		 {

			for(; count > 0; count--)
			{
			  cvt = (int32)POP(tmpstackPtr);
			  arg = (int32)POP(tmpstackPtr);

#ifdef FST_DELTA_SPECIFIC_PPEM
			 	iFakeArgPPEM = arg & ~0x0f;
				if (iFakeArgPPEM == iFakePPEM)
				{
#endif // FST_DELTA_SPECIFIC_PPEM
			  Check_CVT(pLocalGS,cvt, pCSD->cvtCountMinus1);
			 #ifndef FST_CRIT_ONLY
			   Check_INT8(pLocalGS,arg);
			 #endif
#ifdef FST_DELTA_SPECIFIC_PPEM
				}
#endif // FST_DELTA_SPECIFIC_PPEM
			} 
		 }
	 }

#ifdef FST_DELTA_SPECIFIC_PPEM
	}
#endif // FST_DELTA_SPECIFIC_PPEM

	 #ifndef FST_CRIT_ONLY
	 /* If executed in a glyph program warn user that repeated executions can have
	    unexpected results. */
	 if(!(pLocalGS->globalGS->init))
	   OutputErrorToClient(pLocalGS,ET_WARNING,WAR_DELTAC_IN_GLYPH_PGM,NULL);
	 #endif

     break;
   }	     
   
   /* DUP[] */
   case 0x20:
     Check_For_POP(pLocalGS->stackPointer,stackBase, pLocalGS,1);
	 Check_For_PUSH(pLocalGS->stackPointer,stackMax, pLocalGS,1);
     break;

   /* POP[] */
   case 0x21:
     Check_For_POP(pLocalGS->stackPointer,stackBase, pLocalGS,1);
     break;

   /* CLEAR[] */
   case 0x22:
     break;
 
   /* SWAP[] */
   case 0x23:
     Check_For_POP(pLocalGS->stackPointer,stackBase, pLocalGS,2);
     break;

   /* DEPTH[] */
   case 0x24:
	 Check_For_PUSH(pLocalGS->stackPointer,stackMax, pLocalGS,1);
     break;
   
   /* CINDEX[] */
   case 0x25:
   /* MINDEX[] */
   case 0x26:
   {
     F26Dot6 * tmpstackPtr = pLocalGS->stackPointer;
	 int32 arg;

     if (Check_For_POP(pLocalGS->stackPointer,stackBase, pLocalGS,1))
	 {
		arg = (int32)POP(tmpstackPtr);
	 
		if(arg <= 0)
		  OutputErrorToClient(pLocalGS,ET_CRITICAL_ERROR,ERR_INVALID_STACK_ACCESS,NULL);

		Check_SubStack(pLocalGS,tmpstackPtr - arg, stackBase, stackMax);
	 }

     break;
   }
      
   /* ROLL[] */
   case 0x8A:
     Check_For_POP(pLocalGS->stackPointer,stackBase, pLocalGS,3);
     break;

   /* IF[] */
   case 0x58:
   {
	#ifndef FST_CRIT_ONLY
     int32 iLevel = 0;
	 int32 OpCode;
	 int32 arg;
     F26Dot6 * tmpstackPtr = pLocalGS->stackPointer;
	 uint8* tmpinstPtr = pLocalGS->insPtr;
	 BOOL bFoundELSE = FALSE;
	 BOOL bKeepSearching = TRUE;
	#endif // FST_CRIT_ONLY

	 /* IF Rules: 
	    If you take IF, you get an ELSE or EIF(if no ELSE).
	    If you do not take IF and there is an assocated ELSE, you get EIF.
	    If you do not take IF and there is no ELSE the next instruction is the one after EIF (if any).
	 */

	 if (Check_For_POP(pLocalGS->stackPointer,stackBase, pLocalGS,1))
	 {
	#ifndef FST_CRIT_ONLY
         /* the rasterizer 1.7 now detect MISSING_EIF_ERR, we can then downgrade this error
            from critical in fstrace to avoid duplicate work and imporve performance */

		arg = POP(tmpstackPtr);

		/* Make sure there is an EIF somewhere down stream. Also, see if IF is last instruction 
		   executed in block. */

		while((tmpinstPtr < pbyEndInst) && bKeepSearching)
		{
		    OpCode = (int32)*tmpinstPtr++;

			/* On the first IF, we will get the IF therefore iLevel which starts at 0 will go to 1. */
			if (OpCode == IF_CODE)
			{
				iLevel++;
			}   
			else if (OpCode == EIF_CODE)
		    {
			    iLevel--;
			
				/* For an IF that failed, find coresponding EIF. If found ELSE on the way that means
				   we will see the else later. If no ELSE and endf is endptr - 1, IF was the last 
				   instruction executed in block. */
			   
				if(iLevel == 0)
				  bKeepSearching = FALSE;
								 
				if(iLevel == 0 && !bFoundELSE && !arg)
				{
				  if(tmpinstPtr >= pbyEndInst)
				    pCSD->pArrayCallStack[pCSD->lCallNestLevel - 1].bLastInst = TRUE; 
				}
			
			}		
			else if (OpCode == ELSE_CODE && iLevel == 1)
			{
				bFoundELSE = TRUE;
			} 
			else
			{
				tmpinstPtr = FST_SkipPushData (tmpinstPtr);
			}
		 }

		 if(iLevel > 0)
		   OutputErrorToClient(pLocalGS,ET_CRITICAL_ERROR,ERR_IF_WITHOUT_EIF,NULL);
	 	 
		 /* Increment IF nest level. Only increment it if it will be decremented later in an EIF or ELSE. 
		   You only get an EIF or ELSE if you take the IF indicated by a positive arg or if you have found an
		    ELSE if you do not take the IF. Put another way, you do not get an EIF if you do not take IF and
		    there is no ELSE. 
		 */
	 
		 if(bFoundELSE || arg)
		   pCSD->pArrayCallStack[pCSD->lCallNestLevel - 1].lIfNestLevel++;

	#endif // FST_CRIT_ONLY
	 }
	 
     break;
   }

   /* ELSE[] */
   case 0x1B:
   {
	#ifndef FST_CRIT_ONLY
         /* the rasterizer 1.7 now detect MISSING_EIF_ERR, we can then downgrade this error
            from critical in fstrace to avoid duplicate work and imporve performance */
	 int32 iLevel = 1;
	 int32 OpCode;
	 uint8* tmpinstPtr = pLocalGS->insPtr;
	 BOOL bKeepSearching = TRUE;

	 /*
	 	ELSE Rules:
		You get an ELSE if you take IF and there is an ELSE.
	 */
	 /* If we get an ELSE, look ahead to see if EIF is endptr - 1. If so, then ELSE is last
	    instruction executed in block.
	 */
	 while((tmpinstPtr < pbyEndInst) && bKeepSearching)
	 {
	    OpCode = (int32)*tmpinstPtr++;

	    if (OpCode == EIF_CODE)
	    {
		    iLevel--;
			if(iLevel == 0)
			{
			  bKeepSearching = FALSE;

			  /* Really checking if tmpinstPtr >= pbyEndInst - 1 since tmpinstPtr is already incremented. */
			  if(tmpinstPtr >= pbyEndInst)
			    pCSD->pArrayCallStack[pCSD->lCallNestLevel - 1].bLastInst = TRUE; 
			  
			}
		} 
		else if (OpCode == IF_CODE) 
		{
			iLevel++;
		}
		else
		{
			tmpinstPtr = FST_SkipPushData (tmpinstPtr);
		}
	 }
	 
	 /* Check to make sure that the ELSE properly terminated with EIF. If this gets hit the next
	    error here will probably also get hit but that is ok cuz this protects from a situation
	    where we could jump over a EIF and lose track of if nest level. 	 */
	 if(iLevel > 0)
	   OutputErrorToClient(pLocalGS,ET_CRITICAL_ERROR,ERR_ELSE_WITHOUT_EIF,NULL);

	 /* Make sure we are in an IF. If not issue error. If so, decrement IF nest level.  */
	 if(pCSD->pArrayCallStack[pCSD->lCallNestLevel - 1].lIfNestLevel < 1)
	   OutputErrorToClient(pLocalGS,ET_CRITICAL_ERROR,ERR_ELSE_WITHOUT_IF,NULL);
	 else
	   pCSD->pArrayCallStack[pCSD->lCallNestLevel - 1].lIfNestLevel--;
    
	#endif // FST_CRIT_ONLY
     break;
   }

   /* EIF[] */
   case 0x59:
   {
     #ifndef FST_CRIT_ONLY
     /* Make sure we are in an IF. If not issue error. If so, decrement IF nest level. 
	 */
     if(pCSD->pArrayCallStack[pCSD->lCallNestLevel - 1].lIfNestLevel < 1)
	 {
	   OutputErrorToClient(pLocalGS,ET_ERROR,ERR_EIF_WITHOUT_IF,NULL);
	 }
	 else
	 {
       pCSD->pArrayCallStack[pCSD->lCallNestLevel - 1].lIfNestLevel--;
	 }
     #endif // FST_CRIT_ONLY
	
     break;
   }

   /* JROT[] */
   case 0x78:
   {
#ifndef FST_CRIT_ONLY
     int32 bTakeJump, offset;
#endif // FST_CRIT_ONLY
     F26Dot6 * tmpstackPtr = pLocalGS->stackPointer;

	 if (Check_For_POP(pLocalGS->stackPointer,stackBase, pLocalGS,2))
	 {

#ifndef FST_CRIT_ONLY
		bTakeJump = POP(tmpstackPtr);
		offset = POP(tmpstackPtr);
	 
		/* If we are going to take jump, call Check_jump which checks the offset and updates whether
		   or not this jump is the last instruction.	 */
		if(bTakeJump)
		  Check_jump(pLocalGS,pbyEndInst,offset); 
#endif // FST_CRIT_ONLY
     
	 }
     break;
   }

   /* JMPR[] */
   case 0x1C:
   {
#ifndef FST_CRIT_ONLY
     int32 offset;
#endif // FST_CRIT_ONLY
	 F26Dot6 * tmpstackPtr = pLocalGS->stackPointer;

     if (Check_For_POP(pLocalGS->stackPointer,stackBase, pLocalGS,1))
	 {
	 
#ifndef FST_CRIT_ONLY
		offset = POP(tmpstackPtr);

		/* Call Check_jump which checks the offset and updates whether or not this jump is the last
		   instruction. */
		Check_jump(pLocalGS,pbyEndInst,offset); 
#endif // FST_CRIT_ONLY
	 }

     break;
   }

   /* JROF[] */
   case 0x79:
   {
#ifndef FST_CRIT_ONLY
     int32 bTakeJump, offset;
#endif // FST_CRIT_ONLY
     F26Dot6 * tmpstackPtr = pLocalGS->stackPointer;

     if (Check_For_POP(pLocalGS->stackPointer,stackBase, pLocalGS,2))
	 {

#ifndef FST_CRIT_ONLY
		 bTakeJump = !(POP(tmpstackPtr));
		 offset = POP(tmpstackPtr);
	 
		 /* If we are going to take jump, call Check_jump which checks the offset and updates whether
		    or not this jump is the last instruction.	*/
		 if(bTakeJump)
		   Check_jump(pLocalGS,pbyEndInst,offset); 
#endif // FST_CRIT_ONLY

	 }
     break;
   }

   /* LT[] */
   case 0x50:
     Check_For_POP(pLocalGS->stackPointer,stackBase, pLocalGS,2);
     break;

   /* LTEQ[] */
   case 0x51:
     Check_For_POP(pLocalGS->stackPointer,stackBase, pLocalGS,2);
     break;

   /* GT[] */
   case 0x52:
     Check_For_POP(pLocalGS->stackPointer,stackBase, pLocalGS,2);
     break;

   /* GTEQ[] */
   case 0x53:
     Check_For_POP(pLocalGS->stackPointer,stackBase, pLocalGS,2);
     break;

   /* EQ[] */
   case 0x54:
     Check_For_POP(pLocalGS->stackPointer,stackBase, pLocalGS,2);
     break;

   /* NEQ[] */
   case 0x55:
     Check_For_POP(pLocalGS->stackPointer,stackBase, pLocalGS,2);
     break;

   /* ODD[] */
   case 0x56:
     Check_For_POP(pLocalGS->stackPointer,stackBase, pLocalGS,1);
     break;

   /* EVEN[] */
   case 0x57:
     Check_For_POP(pLocalGS->stackPointer,stackBase, pLocalGS,1);
     break;

   /* AND[] */
   case 0x5A:
     Check_For_POP(pLocalGS->stackPointer,stackBase, pLocalGS,2);
     break;

   /* OR[] */
   case 0x5B:
     Check_For_POP(pLocalGS->stackPointer,stackBase, pLocalGS,2);
     break;

   /* NOT[] */
   case 0x5C:
     Check_For_POP(pLocalGS->stackPointer,stackBase, pLocalGS,1);
     break;

   /* ADD[] */
   case 0x60:
   {
     F26Dot6 * tmpstackPtr = pLocalGS->stackPointer;
	 #ifndef FST_CRIT_ONLY
	 F26Dot6 arg1, arg2, sum;
	 #endif

     if (Check_For_POP(pLocalGS->stackPointer,stackBase, pLocalGS,2))
	 {
		#ifndef FST_CRIT_ONLY
		 arg1 = POP(tmpstackPtr);
		 arg2 = POP(tmpstackPtr);

		 sum = arg1 + arg2;

		 if(((arg1 >= 0) && (arg2 >= 0) && (sum <  0)) ||
		    ((arg1 <  0) && (arg2 <  0) && (sum >= 0))) 
		   OutputErrorToClient(pLocalGS,ET_ERROR,ERR_MATH_OVERFLOW,NULL);
		 #endif

	 }
     break;
   }

   /* SUB[] */
   case 0x61:
   {
     F26Dot6 * tmpstackPtr = pLocalGS->stackPointer;
	 #ifndef FST_CRIT_ONLY
	 F26Dot6 arg1, arg2, diff;
	 #endif

     if (Check_For_POP(pLocalGS->stackPointer,stackBase, pLocalGS,2))
	 {
		#ifndef FST_CRIT_ONLY
		arg1 = POP(tmpstackPtr);
		arg2 = POP(tmpstackPtr);

		diff = arg2 - arg1;

		if(((arg2 <  0) && (arg1 >= 0) && (diff >= 0)) ||
		   ((arg2 >= 0) && (arg1 <  0)	&& (diff <  0)))
		  OutputErrorToClient(pLocalGS,ET_ERROR,ERR_MATH_OVERFLOW,NULL);
		 #endif

	 }
     break;
   }

   /* DIV[] */
   case 0x62:
   {
     #define HI7 0xFE000000 

     F26Dot6 * tmpstackPtr = pLocalGS->stackPointer;
	 F26Dot6 divisor, dividend;
	 #ifndef FST_CRIT_ONLY
	 F26Dot6 result;
	 #endif

     if (Check_For_POP(pLocalGS->stackPointer,stackBase, pLocalGS,2))
	 {
		divisor = POP(tmpstackPtr);
		dividend = POP(tmpstackPtr);
	 
		if(divisor == 0)
		  OutputErrorToClient(pLocalGS,ET_CRITICAL_ERROR,ERR_DIVIDE_BY_ZERO,NULL);

		#ifndef FST_CRIT_ONLY
		result = dividend / divisor;

		result &= HI7;

		if((result != 0) && (result != HI7))
		  OutputErrorToClient(pLocalGS,ET_ERROR,ERR_MATH_OVERFLOW,NULL);
		#endif
	 }

     break;
   }

   /* MUL[] */
   case 0x63:
   {
     #define LOW6  0x0000003F
	 #define LOW26 0x03FFFFFF
	 #define HI1   0x80000000
	 #define HI27  0xFFFFFFE0

     F26Dot6 * tmpstackPtr = pLocalGS->stackPointer;
	 #ifndef FST_CRIT_ONLY
	 int32 arg1, arg2,hi27;
	 int32 dst[2];
	 #endif

     if (Check_For_POP(pLocalGS->stackPointer,stackBase, pLocalGS,2))
	 {
		#ifndef FST_CRIT_ONLY
		arg1 = POP(tmpstackPtr);
		arg2 = POP(tmpstackPtr);

		FST_CompMul(arg1,arg2,dst);

		hi27 = dst[0] & HI27;

		if((hi27 != 0) && (hi27 != HI27))
		  OutputErrorToClient(pLocalGS,ET_ERROR,ERR_MATH_OVERFLOW,NULL);
		#endif

	 }
     break;
   }

   /* ABS[] */
   case 0x64:
     Check_For_POP(pLocalGS->stackPointer,stackBase, pLocalGS,1);
     break;

   /* NEG[] */
   case 0x65:
     Check_For_POP(pLocalGS->stackPointer,stackBase, pLocalGS,1);
     break;

   /* FLOOR[] */
   case 0x66:
     Check_For_POP(pLocalGS->stackPointer,stackBase, pLocalGS,1);
     break;

   /* CEILING[] */
   case 0x67:
     Check_For_POP(pLocalGS->stackPointer,stackBase, pLocalGS,1);
     break;

   /* MAX[] */
   case 0x8B:
     Check_For_POP(pLocalGS->stackPointer,stackBase, pLocalGS,2);
     break;

   /* MIN[] */
   case 0x8C:
     Check_For_POP(pLocalGS->stackPointer,stackBase, pLocalGS,2);
     break;

   /* ROUND[ab] */
   case 0x68:
   case 0x69:
   case 0x6A:
   case 0x6B:
     Check_For_POP(pLocalGS->stackPointer,stackBase, pLocalGS,1);
     	
	 /* Check to see if distance type for engine characteristic compensation is 3 which is reserved. */
	 #ifndef FST_CRIT_ONLY
	 if (BIT0(pLocalGS->opCode) && BIT1(pLocalGS->opCode))
	   OutputErrorToClient(pLocalGS,ET_ERROR,ERR_INVALID_FLAG,NULL);
	 #endif
     break;

   /* NROUND[ab] */
   case 0x6C:
   case 0x6D:
   case 0x6E:
   case 0x6F:
     Check_For_POP(pLocalGS->stackPointer,stackBase, pLocalGS,1);

	 /* Check to see if distance type for engine characteristic compensation is 3 which is reserved. */
	 #ifndef FST_CRIT_ONLY
	 if (BIT0(pLocalGS->opCode) && BIT1(pLocalGS->opCode))
	   OutputErrorToClient(pLocalGS,ET_ERROR,ERR_INVALID_FLAG,NULL);
	 #endif
     break;

   /* RAW[] */
   case 0x28:
	 if (pLocalGS->globalGS->pgmIndex != GLYPHPROGRAM)
	   OutputErrorToClient(pLocalGS,ET_CRITICAL_ERROR,ERR_RAW_NOT_FROM_GLYPHPGM,NULL);
     Check_For_PUSH(pLocalGS->stackPointer,stackMax, pLocalGS,1);
     break;

   /* FDEF[] */
   case 0x2C:
   {
     #ifndef FST_CRIT_ONLY
	 uint8* tmpInstPtr = pLocalGS->insPtr;
	 int32 OpCode;
	 BOOL bFoundENDF = FALSE;
     #endif // FST_CRIT_ONLY

	 F26Dot6 * tmpstackPtr = pLocalGS->stackPointer;
	 int32 arg;

	 if(!pLocalGS->globalGS->init)
		   OutputErrorToClient(pLocalGS,ET_CRITICAL_ERROR,ERR_NOT_CALLED_FROM_PREPROGRAM,NULL);

	 if (Check_For_POP(pLocalGS->stackPointer,stackBase, pLocalGS,1))
	 {
		 arg = POP(tmpstackPtr);

	 
		 Check_FDEF(pLocalGS, arg, pCSD->maxFunctionDefsMinus1);
	 
		 #ifndef FST_CRIT_ONLY
         /* the rasterizer 1.7 now detect MISSING_ENDF_ERR, we can then downgrade this error
            from critical in fstrace to avoid duplicate work and imporve performance */

         /* Check to make sure that there is an ENDF for this FDEF. ENDF needs to be within 64K of FDEF.
		    Also check to see if this FDEF is the last instruction executed in program. */
		 while((tmpInstPtr < pbyEndInst) && !bFoundENDF)
		 {
		    OpCode = (int32)*tmpInstPtr++;

			if((OpCode == FDEF_CODE) && ((tmpInstPtr - 1) != pLocalGS->insPtr))
			{
			  OutputErrorToClient(pLocalGS,ET_ERROR,ERR_FDEF_FOUND_IN_FDEF,NULL);
			}
			else if(OpCode == IDEF_CODE)
			{ 
			  OutputErrorToClient(pLocalGS,ET_ERROR,ERR_IDEF_FOUND_IN_FDEF,NULL);
			}
			else if(OpCode != ENDF_CODE)
			{
			  tmpInstPtr = FST_SkipPushData (tmpInstPtr);
			}
			else
			{
			  bFoundENDF = TRUE;
			}
		 }

		 if(!bFoundENDF)
		   OutputErrorToClient(pLocalGS,ET_CRITICAL_ERROR,ERR_FDEF_WITHOUT_ENDF,NULL);

		 if(bFoundENDF)
		 { 	   
		   if((ptrdiff_t)(tmpInstPtr - pLocalGS->insPtr + 1) > 65535)
		     OutputErrorToClient(pLocalGS,ET_ERROR,ERR_ENDF_BEYOND_64K_OF_FDEF,NULL);
		 }

		 if(tmpInstPtr >= pbyEndInst)
		   pCSD->pArrayCallStack[pCSD->lCallNestLevel - 1].bLastInst = TRUE; 
		 #endif // FST_CRIT_ONLY

	 }
     break;
   }

   /* ENDF[] */
   case 0x2D:
     #ifndef FST_CRIT_ONLY
     OutputErrorToClient(pLocalGS,ET_ERROR,ERR_ENDF_EXECUTED,NULL);
	 pCSD->pArrayCallStack[pCSD->lCallNestLevel - 1].bLastInst = TRUE;
#endif // FST_CRIT_ONLY

     break;

   /* CALL[] */
   case 0x2B:
   {
     F26Dot6 * tmpstackPtr = pLocalGS->stackPointer;
	 int32 arg;
	 fnt_funcDef *funcDef;
#ifndef FST_CRIT_ONLY
	 pCSD->pArrayCallStack[pCSD->lCallNestLevel - 1].insPtr = pLocalGS->insPtr;
#endif // FST_CRIT_ONLY

	 if (Check_For_POP(pLocalGS->stackPointer,stackBase, pLocalGS,1))
	 {
		 arg = POP(tmpstackPtr);

		 if(!Check_FDEF(pLocalGS, arg, pCSD->maxFunctionDefsMinus1))
	      break;

		 funcDef = &pLocalGS->globalGS->funcDef[ arg ];

		 /* this line will catch undefined functions that have funcDef->pgmIndex == FNT_UNDEFINEDINDEX */
		 if (funcDef->pgmIndex >= MAXPREPROGRAMS) 
		 {
#ifndef FST_CRIT_ONLY
		   char szDetails[SMALL_TEMP_STRING_SIZE];
		   sprintf(szDetails,"Function = %ld ",arg);
	 
		   OutputErrorToClient(pLocalGS,ET_CRITICAL_ERROR,ERR_FUNCTION_NOT_DEFINED,szDetails);
#else
		   OutputErrorToClient(pLocalGS,ET_CRITICAL_ERROR,ERR_FUNCTION_NOT_DEFINED,NULL);
#endif // FST_CRIT_ONLY
		 }
		 else
		 {
		   #ifndef FST_CRIT_ONLY
		   /* Issue warning if function has a length of zero which means function is only 
		      an FDEF followed immediately by an ENDF. */
		   if(funcDef->start == 0)
		   {      	     
			 char szBuffer[SMALL_TEMP_STRING_SIZE];
			 sprintf(szBuffer,"Function: %ld",arg);
		     OutputErrorToClient(pLocalGS,ET_WARNING,ERR_FUNCTION_NOT_DEFINED,szBuffer);
		   } else
		   {
				if(funcDef->length == 0)
				{      	     
					char szBuffer[SMALL_TEMP_STRING_SIZE];
					sprintf(szBuffer,"Function: %ld",arg);
					OutputErrorToClient(pLocalGS,ET_WARNING,WAR_CALL_ZERO_LEN_FUNC,szBuffer);
				}
		   }
		   #endif
	 
		   /* Ignore calls to zero length functions since we will not get called in them.  */
#ifndef FST_CRIT_ONLY
	    if(funcDef->length != 0)
		   {
	         pCSD->pArrayCallStack[pCSD->lCallNestLevel - 1].usCurrentCallCount = 1;
		     pCSD->pArrayCallStack[pCSD->lCallNestLevel - 1].usFunctionCalled = (unsigned short)arg;
		   }
#endif
		 }
	 }
     break;
   }

   /* LOOPCALL[] */
   case 0x2A:
   {
     F26Dot6 * tmpstackPtr = pLocalGS->stackPointer;
	 int32 arg,count;
	 fnt_funcDef *funcDef;

#ifndef FST_CRIT_ONLY
	 pCSD->pArrayCallStack[pCSD->lCallNestLevel - 1].insPtr = pLocalGS->insPtr;
#endif // FST_CRIT_ONLY

	 if (Check_For_POP(pLocalGS->stackPointer,stackBase, pLocalGS,2))
	 {
		 arg = POP(tmpstackPtr);
		 count = POP(tmpstackPtr);
	 
		 if(!Check_FDEF(pLocalGS, arg, pCSD->maxFunctionDefsMinus1))
	     break;
	 
		 funcDef = &pLocalGS->globalGS->funcDef[ arg ];
	 	 
		 #ifndef FST_CRIT_ONLY
		 Check_INT16(pLocalGS,count);
		 if(count < 1)
		   OutputErrorToClient(pLocalGS,ET_WARNING,WAR_LOOPCALL_COUNT_LESS_THAN_ONE,NULL);
		 #endif

		 /* this line will catch undefined functions that have funcDef->pgmIndex == FNT_UNDEFINEDINDEX */
		 if (funcDef->pgmIndex >= MAXPREPROGRAMS) 
		 {
#ifndef FST_CRIT_ONLY
		   char szDetails[SMALL_TEMP_STRING_SIZE];
		   sprintf(szDetails,"Function = %ld ",arg); 
		   OutputErrorToClient(pLocalGS,ET_CRITICAL_ERROR,ERR_FUNCTION_NOT_DEFINED,szDetails);
#else
		   OutputErrorToClient(pLocalGS,ET_CRITICAL_ERROR,ERR_FUNCTION_NOT_DEFINED,NULL);
#endif // FST_CRIT_ONLY
		 }
		 else
		 {
		   #ifndef FST_CRIT_ONLY
		   /* Issue warning if function has a length of zero which means function is only 
		      an FDEF followed immediately by an ENDF. */
		   if(funcDef->start == 0)
		   {      	     
			 char szBuffer[SMALL_TEMP_STRING_SIZE];
			 sprintf(szBuffer,"Function: %ld",arg);
		     OutputErrorToClient(pLocalGS,ET_WARNING,ERR_FUNCTION_NOT_DEFINED,szBuffer);
		   } else
		   {
				if(funcDef->length == 0)
				{      	     
					char szBuffer[SMALL_TEMP_STRING_SIZE];
					sprintf(szBuffer,"Function: %ld",arg);
					OutputErrorToClient(pLocalGS,ET_WARNING,WAR_CALL_ZERO_LEN_FUNC,szBuffer);
				}
		   }
		   #endif

		   /* Ignore calls to zero length functions and functions that are not
		      called because count less than 1. We will not get called in them. */
#ifndef FST_CRIT_ONLY
	    if((funcDef->length != 0) && (count >= 1))
		   {
	         pCSD->pArrayCallStack[pCSD->lCallNestLevel - 1].usCurrentCallCount = (unsigned short)count;
		     pCSD->pArrayCallStack[pCSD->lCallNestLevel - 1].usFunctionCalled = (unsigned short)arg;
		   }
#endif
	   
		}
	 }
     break;
   }

   /* IDEF[] */
   case 0x89:
   {
     #ifndef FST_CRIT_ONLY
	 uint8* tmpInstPtr = pLocalGS->insPtr;
	 int32 OpCode;
	 BOOL bFoundEIF = FALSE;
     #endif // FST_CRIT_ONLY

     F26Dot6 * tmpstackPtr = pLocalGS->stackPointer;
	 int32 arg;

	 if (Check_For_POP(pLocalGS->stackPointer,stackBase, pLocalGS,1))
	 {
		 arg = POP(tmpstackPtr);

		 if(arg > UCHAR_MAX)
		 {
#ifndef FST_CRIT_ONLY
		   char szDetails[SMALL_TEMP_STRING_SIZE];
		   sprintf(szDetails,"Instruction: %ld ",arg);
		   OutputErrorToClient(pLocalGS,ET_CRITICAL_ERROR,ERR_INST_OPCODE_TO_LARGE,szDetails);
#else
		   OutputErrorToClient(pLocalGS,ET_CRITICAL_ERROR,ERR_INST_OPCODE_TO_LARGE,NULL);
#endif // FST_CRIT_ONLY
		   break;
		 }

		 if(!pLocalGS->globalGS->init)
		   OutputErrorToClient(pLocalGS,ET_CRITICAL_ERROR,ERR_NOT_CALLED_FROM_PREPROGRAM,NULL);
	 
		 #ifndef FST_CRIT_ONLY
		 /* Check to see if function is already defined by rasterizer.
		    If function is already defined by another IDEF, that is OK, we can redefine it. */
		 if(gFunctonUsed[arg])
		 {
		   char szDetails[SMALL_TEMP_STRING_SIZE];
		   sprintf(szDetails,"Instruction: %ld ",arg);
		   OutputErrorToClient(pLocalGS,ET_ERROR,ERR_INSTR_DEFD_BY_FS,szDetails);
		 }
		 #endif

		 /* Check to see if we will overflow maxp value for maxInstructionDefs if we define
		    this instruction. */
		 if(pLocalGS->globalGS->instrDefCount >= pLocalGS->globalGS->maxp->maxInstructionDefs)
		 {
#ifndef FST_CRIT_ONLY
		   char szDetails[SMALL_TEMP_STRING_SIZE];
		   sprintf(szDetails,"Maximum Instruction Defs: %ld ",pLocalGS->globalGS->maxp->maxInstructionDefs);
		   OutputErrorToClient(pLocalGS,ET_CRITICAL_ERROR,ERR_EXCEEDS_INSTR_DEFS_IN_MAXP,szDetails);
#else
		   OutputErrorToClient(pLocalGS,ET_CRITICAL_ERROR,ERR_EXCEEDS_INSTR_DEFS_IN_MAXP,NULL);
#endif // FST_CRIT_ONLY
		 }
	 
		 #ifndef FST_CRIT_ONLY
         /* the rasterizer 1.7 now detect MISSING_ENDF_ERR, we can then downgrade this error
            from critical in fstrace to avoid duplicate work and imporve performance */

         /* Check to make sure that there is an ENDF for this IDEF. ENDF needs to be within 64K of IDEFF.
		    Also check to see if this IDEF is the last instruction executed in program. */
		 while((tmpInstPtr < pbyEndInst) && !bFoundEIF)
		 {
		    OpCode = (int32)*tmpInstPtr++;

			if((OpCode == IDEF_CODE) && ((tmpInstPtr - 1) != pLocalGS->insPtr))
			{
			  OutputErrorToClient(pLocalGS,ET_ERROR,ERR_IDEF_FOUND_IN_IDEF,NULL);
			}
			else if(OpCode == FDEF_CODE)
			{
			  OutputErrorToClient(pLocalGS,ET_ERROR,ERR_FDEF_FOUND_IN_IDEF,NULL);
			} 
			else if(OpCode != ENDF_CODE)
			{
			  tmpInstPtr = FST_SkipPushData (tmpInstPtr);
			}
			else
			{
			  bFoundEIF = TRUE;
			}
		 }

		 if(!bFoundEIF)
		   OutputErrorToClient(pLocalGS,ET_CRITICAL_ERROR,ERR_IDEF_WITHOUT_ENDF,NULL);

		 if(bFoundEIF)
		 {
		   if((ptrdiff_t)(tmpInstPtr - pLocalGS->insPtr + 1) > 65535)
		     OutputErrorToClient(pLocalGS,ET_ERROR,ERR_ENDF_BEYOND_64K_OF_IDEF,NULL);
		 }

		 if(tmpInstPtr >= pbyEndInst)
		   pCSD->pArrayCallStack[pCSD->lCallNestLevel - 1].bLastInst = TRUE; 
	
		 #endif // FST_CRIT_ONLY
	 }
     break;
   }

   /* DEBUG[] */
   case 0x4F:
     Check_For_POP(pLocalGS->stackPointer,stackBase, pLocalGS,1); 
	 #ifndef FST_CRIT_ONLY
     OutputErrorToClient(pLocalGS,ET_WARNING,WAR_DEBUG_FOUND,NULL); 
     #endif  
     break;

   /* GETINFO[] */
   case 0x88:
   {
#define HINTFORGRAYINTERPRETERQUERY      0x0020

     F26Dot6 * tmpstackPtr = pLocalGS->stackPointer;
	 int32 selector;

     if (Check_For_POP(pLocalGS->stackPointer,stackBase, pLocalGS,1))
	 {
		selector = (int32)POP(tmpstackPtr);

	    if (selector & HINTFORGRAYINTERPRETERQUERY)
        {
            pCSD->bGrayscaleInfoRequested = TRUE;
        }

		#ifndef FST_CRIT_ONLY

		Check_INT16(pLocalGS,selector);
		Check_Selector(pLocalGS,selector);
		#endif
	 }
     
     break;
   }

   /* Apple Only Instructions */
   /* fnt_ADJUST */
   case 0x8f:
   /* fnt_ADJUST */
   case 0x90:
   /* fnt_GETVARIATION */
   case 0x91:
   /* fnt_INSTCTRL */
   case 0x92:
   {
	 #ifndef FST_CRIT_ONLY
	 char szDetails[SMALL_TEMP_STRING_SIZE];
	 sprintf(szDetails,"OpCode: %ld ",pLocalGS->opCode);
	 OutputErrorToClient(pLocalGS,ET_WARNING,WAR_APPLE_ONLY_INSTR,szDetails); 
     #endif  	 
	 break;
   }

   default:
   {
     fnt_instrDef *instrDef;
	 
	 instrDef = FST_FindIDef(pLocalGS);
	 if(instrDef == 0)
	 {
	   OutputErrorToClient(pLocalGS,ET_ERROR,ERR_INVALID_INSTRUCTION,NULL);
#ifndef FST_CRIT_ONLY
	   pCSD->pArrayCallStack[pCSD->lCallNestLevel - 1].bLastInst = TRUE; 
#endif // FST_CRIT_ONLY
	 }
#ifndef FST_CRIT_ONLY
     else
	 {
	   pCSD->pArrayCallStack[pCSD->lCallNestLevel - 1].insPtr = pLocalGS->insPtr;
	   /* Issue warning if instruction has a length of zero which means function is only 
	      an FDEF followed immediately by an ENDF. */
	   if(instrDef->length == 0)
	     OutputErrorToClient(pLocalGS,ET_WARNING,WAR_CALL_ZERO_LEN_UD_INSTR,NULL);

	   /* Ignore calls to zero length functions since we will not get called in them.  */
       if(instrDef->length != 0)
	   {
         pCSD->pArrayCallStack[pCSD->lCallNestLevel - 1].bCurrentInstUserDefined = TRUE;
	     pCSD->pArrayCallStack[pCSD->lCallNestLevel - 1].usUserDefinedInstCalled = (unsigned short)pLocalGS->opCode;
	   }
	 }
#endif 
	 	 
     break;
   }

   
 }

#ifdef FST_CRIT_ONLY
   if (pCSD->bBreakOccured)
   {
       /* If client returns false, stop executing instructions. */
    pLocalGS->TraceFunc = NULL;

	pLocalGS->ercReturn = INSTRUCTION_ERR;  /* returned an error to the rasterizer client */
	/* Set flag to indicate break occured so call stack can be updated properly. */
   }
#else
 ProcessPostInst(pCSD,pLocalGS,pbyEndInst);
 #endif
 
 #ifdef FST_CHAIN_TRACE 
 /* Optional Trace function chaining code. */
 if(pLocalGS->globalGS->init)
 {
   if(gpPrePgmTraceNext != NULL)
   {
     gpPrePgmTraceNext(pLocalGS,pbyEndInst);
     if(pLocalGS->TraceFunc == NULL)
     {
	   /* Set flag to indicate break occured so call stack can be updated properly. */
	   pCSD->bBreakOccured = TRUE;    
     }
   } 
 }else
 {
   if(gpGlyfPgmTraceNext != NULL)
   {
     gpGlyfPgmTraceNext(pLocalGS,pbyEndInst);
     if(pLocalGS->TraceFunc == NULL)
     {
	   /* Set flag to indicate break occured so call stack can be updated properly. */
	   pCSD->bBreakOccured = TRUE; 
     }
   }
 }
 #endif

}

void fst_SetCurrentSpecificDataPointer(void * pFSTSpecificData)
{
  pCurrentSpecificData = (ClientSpecificData *)pFSTSpecificData;
}


BOOL fst_InitSpecificDataPointer(void ** hFSTSpecificData)
{ 
  pClientSpecificData pCSD;
  
  pCSD = (ClientSpecificData *)FST_MALLOC(sizeof(ClientSpecificData));
  if(pCSD == NULL)
    return FALSE;

  /* Set current pointer  */
  pCurrentSpecificData = pCSD;
  * hFSTSpecificData = (void *)pCSD;

  /* Initialize values */
  #ifndef FST_CRIT_ONLY
  pCSD->pStoreBits = NULL;
  pCSD->pTwilightZonePtsSet = NULL;
  ClearRefPtFlags(pCSD);
  #endif
  pCSD->lCallNestLevel = 0;
  pCSD->lAllocatedNestlevels = FST_PREALLOCATED_NEST_LEVELS;
  pCSD->lLoopSet = 0;
  pCSD->lCurrentLoop = 0;
  pCSD->bBreakOccured = FALSE;
#ifndef FST_CRIT_ONLY
  pCSD->pArrayCallStack = (CallStackCell *)FST_MALLOC( pCSD->lAllocatedNestlevels * sizeof(CallStackCell));
  if(pCSD->pArrayCallStack == NULL)
  {
    FST_FREE(pCSD);
	pCurrentSpecificData = NULL;
    return FALSE;
  }
#endif // FST_CRIT_ONLY

  pCSD->bGrayscaleInfoRequested = FALSE;

  pCSD->bFirstCallToTraceFunction = TRUE;

  pCSD->maxPointsIncludePhantomMinus1 = 0;
  pCSD->maxContours = 0;
  pCSD->maxElementsMinus1 = 0;
  pCSD->maxStorageMinus1 = 0;
  pCSD->maxFunctionDefsMinus1 = 0;
  pCSD->maxStackElements = 0;
  pCSD->maxTwilightPointsMinus1 = 0;
  pCSD->cvtCountMinus1 = 0;
  return TRUE;
}

BOOL fst_DeAllocClientData(void * pFSTSpecificData)
{
  pClientSpecificData pCSD;

  /* free memory associated with client */
  pCSD = (ClientSpecificData *)pFSTSpecificData;
  if(pCSD == NULL)
    return FALSE;

  #ifndef FST_CRIT_ONLY
  if(pCSD->pStoreBits != NULL)
    FST_FREE(pCSD->pStoreBits);

  if(pCSD->pTwilightZonePtsSet != NULL)
    FST_FREE(pCSD->pTwilightZonePtsSet);

  if(pCSD->pArrayCallStack != NULL)
    FST_FREE(pCSD->pArrayCallStack);
#endif // FST_CRIT_ONLY

  FST_FREE(pCSD);

  pCurrentSpecificData = NULL;

  return TRUE;
}

/* get the info if the grayscale flag was requested */
BOOL fst_GetGrayscaleInfoRequested (void *pFSTSpecificData)
{
  pClientSpecificData pCSD = (ClientSpecificData *)pFSTSpecificData;

  if (pCSD == NULL) return TRUE;

  return pCSD->bGrayscaleInfoRequested;
}

#ifndef FST_CRIT_ONLY
BOOL fst_SetNotificationFunction(NotifyFunc pFunc)
{
	if(pFunc == NULL)
    return FALSE;

  gpNotifyFunction =  pFunc;

  return TRUE;
}
#endif // FST_CRIT_ONLY

#ifdef FST_CHAIN_TRACE
/* This is an optional function which sets a pointer to a function which is called at the end of
   CallBackFSTraceFunction if we are in the pre-program. The previous function pointer is returned.*/
FntTraceFunc fst_SetPrePgmTraceChainFunction(FntTraceFunc pPrePgmFunc)
{
  FntTraceFunc pInitialSetting = gpPrePgmTraceNext;
  gpPrePgmTraceNext = pPrePgmFunc;
  return pInitialSetting;
}

/* This is an optional function which sets a pointer to a function which is called at the end of
   CallBackFSTraceFunction if we are in a glyph program. The previous function pointer is returned.*/
FntTraceFunc fst_SetGlyfPgmTraceChainFunction(FntTraceFunc pGlyfPgmFunc)
{
  FntTraceFunc pInitialSetting = gpGlyfPgmTraceNext;
  gpGlyfPgmTraceNext = pGlyfPgmFunc;
  return pInitialSetting;
}
#endif // FST_CHAIN_TRACE


#ifndef FST_CRIT_ONLY
/* Strings for disassembling TrueType used by GetErrorText()   */
static const char  *giStr[256] =
{
	/***** 0x00 - 0x0f *****/
	"SVTCA[y-axis]",
	"SVTCA[x-axis]",
	"SPVTCA[y-axis]",
	"SPVTCA[x-axis]",
	"SFVTCA[y-axis]",
	"SFVTCA[x-axis]",
	"SPVTL[=p1,p2]",
	"SPVTL[.p1,p2]",
	"SFVTL[=p1,p2]",
	"SFVTL[.p1,p2]",
	"SPVFS",
	"SFVFS",
	"GPV",
	"GFV",
	"SFVTPV",
	"ISECT",

	/***** 0x10 - 0x1f *****/
	"SRP0",
	"SRP1",
	"SRP2",
	"SZP0",
	"SZP1",
	"SZP2",
	"SZPS",
	"SLOOP",
	"RTG",
	"RTHG",
	"SMD",
	"ELSE",
	"JMPR",
	"SCVTCI",
	"SSWCI",
	"SSW",

	/***** 0x20 - 0x2f *****/
	"DUP",
	"POP",
	"CLEAR",
	"SWAP",
	"DEPTH",
	"CINDEX",
	"MINDEX",
	"ALIGNPTS",
	"Inst 0x28",
	"UTP",
	"LOOPCALL",
	"CALL",
	"FDEF",
	"ENDF",
	"MDAP[nrd]",
	"MDAP[rd]",


	/***** 0x30 - 0x3f *****/
	"IUP[y]",
	"IUP[x]",
	"SHP[rp2,zp1]",
	"SHP[rp1,zp0]",
	"SHC[rp2,zp1]",
	"SHC[rp1,zp0]",
	"SHZ[rp2,zp1]",
	"SHZ[rp1,zp0]",
	"SHPIX",
	"IP",
	"MSIRP[nrp]",
	"MSIRP[srp]",
	"ALIGNRP",
	"RTDG",
	"MIAP[nrd+nci]",
	"MIAP[rd+ci]",

	/***** 0x40 - 0x4f *****/
	"NPUSHB",
	"NPUSHW",
	"WS",
	"RS",
	"WCVTP",
	"RCVT",
	"GC[cur p]",
	"GC[org p]",
	"SCFS",
	"MD[cur]",
	"MD[org]",
	"MPPEM",
	"MPS",
	"FLIPON",
	"FLIPOFF",
	"DEBUG",

	/***** 0x50 - 0x5f *****/
	"LT",
	"LTEQ",
	"GT",
	"GTEQ",
	"EQ",
	"NEQ",
	"ODD",
	"EVEN",
	"IF",
	"EIF",
	"AND",
	"OR",
	"NOT",
	"DELTAP1",
	"SDB",
	"SDS",

	/***** 0x60 - 0x6f *****/
	"ADD",
	"SUB",
	"DIV",
	"MUL",
	"ABS",
	"NEG",
	"FLOOR",
	"CEILING",
	"ROUND[Gray]",
	"ROUND[Black]",
	"ROUND[White]",
	"ROUND[Reserved]",
	"NROUND[Gray]",
	"NROUND[Black]",
	"NROUND[White]",
	"NROUND[Reserved]",

	/***** 0x70 - 0x7f *****/
	"WCVTF",
	"DELTAP2",
	"DELTAP3",
	"DELTAC1",
	"DELTAC2",
	"DELTAC3",
	"SROUND",
	"S45ROUND",
	"JROT",
	"JROF",
	"ROFF",
	"0x7b-Reserved",
	"RUTG",
	"RDTG",
	"SANGW",
	"AA",

	/***** 0x80 - 0x8d *****/
	"FLIPPT",
	"FLIPRGON",
	"FLIPRGOFF",
	"User 83",
	"User 84",
	"SCANCTRL",
	"SDPVTL[0]",
	"SDPVTL[1]",
	"GETINFO",
	"IDEF",
	"ROLL",
	"MAX",
	"MIN",
	"SCANTYPE",
	"INSTCTRL",

	/***** 0x8f - 0xaf *****/
	"ADJUST",
	"ADJUST",
	"GETVARIATION",
	"GETDATA",
	"User 93",
	"User 94",
	"User 95",
	"User 96",
	"User 97",
	"User 98",
	"User 99",
	"User 9a",
	"User 9b",
	"User 9c",
	"User 9d",
	"User 9e",
	"User 9f",
	"User a0",
	"User a1",
	"User a2",
	"User a3",
	"User a4",
	"User a5",
	"User a6",
	"User a7",
	"User a8",
	"User a9",
	"User aa",
	"User ab",
	"User ac",
	"User ad",
	"User ae",
	"User af",

	/***** 0xb0 - 0xb7 *****/
	"PUSHB[1]",
	"PUSHB[2]",
	"PUSHB[3]",
	"PUSHB[4]",
	"PUSHB[5]",
	"PUSHB[6]",
	"PUSHB[7]",
	"PUSHB[8]",

	/***** 0xb8 - 0xbf *****/
	"PUSHW[1]",
	"PUSHW[2]",
	"PUSHW[3]",
	"PUSHW[4]",
	"PUSHW[5]",
	"PUSHW[6]",
	"PUSHW[7]",
	"PUSHW[8]",

	/***** 0xc0 - 0xdf *****/
	"MDRP[nrp0,nmd,nrd,Gray]",
	"MDRP[nrp0,nmd,nrd,Black]",
	"MDRP[nrp0,nmd,nrd,White]",
	"MDRP[nrp0,nmd,nrd,Reserved]",
	"MDRP[nrp0,nmd,rd,Gray]",
	"MDRP[nrp0,nmd,rd,Black]",
	"MDRP[nrp0,nmd,rd,White]",
	"MDRP[nrp0,nmd,rd,Reserved]",
	"MDRP[nrp0,md,nrd,Gray]",
	"MDRP[nrp0,md,nrd,Black]",
	"MDRP[nrp0,md,nrd,White]",
	"MDRP[nrp0,md,nrd,Reserved]",
	"MDRP[nrp0,md,rd,Gray]",
	"MDRP[nrp0,md,rd,Black]",
	"MDRP[nrp0,md,rd,White]",
	"MDRP[nrp0,md,rd,Reserved]",
	"MDRP[srp0,nmd,nrd,Gray]",
	"MDRP[srp0,nmd,nrd,Black]",
	"MDRP[srp0,nmd,nrd,White]",
	"MDRP[srp0,nmd,nrd,Reserved]",
	"MDRP[srp0,nmd,rd,Gray]",
	"MDRP[srp0,nmd,rd,Black]",
	"MDRP[srp0,nmd,rd,White]",
	"MDRP[srp0,nmd,rd,Reserved]",
	"MDRP[srp0,md,nrd,Gray]",
	"MDRP[srp0,md,nrd,Black]",
	"MDRP[srp0,md,nrd,White]",
	"MDRP[srp0,md,nrd,Reserved]",
	"MDRP[srp0,md,rd,Gray]",
	"MDRP[srp0,md,rd,Black]",
	"MDRP[srp0,md,rd,White]",
	"MDRP[srp0,md,rd,Reserved]",

	/***** 0xe0 - 0xff *****/
	"MIRP[nrp0,nmd,nrd,Gray]",
	"MIRP[nrp0,nmd,nrd,Black]",
	"MIRP[nrp0,nmd,nrd,White]",
	"MIRP[nrp0,nmd,nrd,Reserved]",
	"MIRP[nrp0,nmd,rd,Gray]",
	"MIRP[nrp0,nmd,rd,Black]",
	"MIRP[nrp0,nmd,rd,White]",
	"MIRP[nrp0,nmd,rd,Reserved]",
	"MIRP[nrp0,md,nrd,Gray]",
	"MIRP[nrp0,md,nrd,Black]",
	"MIRP[nrp0,md,nrd,White]",
	"MIRP[nrp0,md,nrd,Reserved]",
	"MIRP[nrp0,md,rd,Gray]",
	"MIRP[nrp0,md,rd,Black]",
	"MIRP[nrp0,md,rd,White]",
	"MIRP[nrp0,md,rd,Reserved]",
	"MIRP[srp0,nmd,nrd,Gray]",
	"MIRP[srp0,nmd,nrd,Black]",
	"MIRP[srp0,nmd,nrd,White]",
	"MIRP[srp0,nmd,nrd,Reserved]",
	"MIRP[srp0,nmd,rd,Gray]",
	"MIRP[srp0,nmd,rd,Black]",
	"MIRP[srp0,nmd,rd,White]",
	"MIRP[srp0,nmd,rd,Reserved]",
	"MIRP[srp0,md,nrd,Gray]",
	"MIRP[srp0,md,nrd,Black]",
	"MIRP[srp0,md,nrd,White]",
	"MIRP[srp0,md,nrd,Reserved]",
	"MIRP[srp0,md,rd,Gray]",
	"MIRP[srp0,md,rd,Black]",
	"MIRP[srp0,md,rd,White]",
	"MIRP[srp0,md,rd,Reserved]" };

BOOL fst_GetErrorTypeText(unsigned short usErrorType, char* szTypeString, unsigned short usStringSize)
{
  char szBuffer[SMALL_TEMP_STRING_SIZE];

  if(szTypeString == NULL)
    return FALSE;

  switch(usErrorType)
  {
    case ET_CRITICAL_ERROR:
	  strcpy(szBuffer,"Critical Error");
	  break;

	case ET_ERROR:
	  strcpy(szBuffer,"Error");
	  break;

	case ET_WARNING:
	  strcpy(szBuffer,"Warning");
	  break;
	
	default:
	  strcpy(szBuffer,"Unknown Error Type");
	  break;
  }

  if(strlen(szBuffer) + 1 > usStringSize)
    return FALSE;

  strcpy(szTypeString,szBuffer);
  return TRUE;
}

BOOL fst_GetOpCodeText(unsigned char opCode, char* szOpCodeString, unsigned short usStringSize)
{
  char szBuffer[SMALL_TEMP_STRING_SIZE];

  if(szOpCodeString == NULL)
    return FALSE;

  strcpy(szBuffer,giStr[opCode]);

  if(strlen(szBuffer) + 1 > usStringSize)
    return FALSE;

  strcpy(szOpCodeString,szBuffer);
  return TRUE;
}


BOOL fst_GetErrorText(unsigned short usErrorCode,char* szErrorString, unsigned short usStringSize)
{
  char szBuffer[LARGE_TEMP_STRING_SIZE];

  if(szErrorString == NULL)
    return FALSE;
  
  switch(usErrorCode)
  {
    case ERR_OVERFLOW_INST_PTR:
	  strcpy(szBuffer,"Overflow Instruction Stream. ");
	  break;

	case ERR_STACK_OVERFLOW:
	  strcpy(szBuffer,"Stack Overflow. ");
	  break;

	case ERR_STACK_UNDERFLOW:
	  strcpy(szBuffer,"Stack Underflow. ");
	  break;

	case ERR_IF_WITHOUT_EIF:
	  strcpy(szBuffer,"IF found without corresponding EIF. ");
	  break;

	case ERR_ELSE_WITHOUT_IF:
	  strcpy(szBuffer,"ELSE found without IF. ");
	  break;

	case ERR_EIF_WITHOUT_IF:
	  strcpy(szBuffer,"EIF found without IF. ");
	  break;

	case ERR_FDEF_WITHOUT_ENDF:
	  strcpy(szBuffer,"FDEF found without ENDF. ");
	  break;

	case ERR_IDEF_WITHOUT_ENDF:
	  strcpy(szBuffer,"IDEF found without ENDF. ");
	  break;

	case ERR_ENDF_EXECUTED:
	  strcpy(szBuffer,"ENDF found without FDEF or IDEF. ");
	  break;

	case WAR_CALL_ZERO_LEN_FUNC:
	  strcpy(szBuffer,"CALL to zero length function. ");
	  break;									   

	case WAR_JMP_OFFSET_ZERO:
	  strcpy(szBuffer,"Jump offset zero. ");
	  break;
	
	case ERR_JMP_BEFORE_BEGINNING:
	  strcpy(szBuffer,"Jump before beginning of program or function. ");
	  break;

	case ERR_JMP_BEYOND_2MORE_THAN_END:
	  strcpy(szBuffer,"Jump beyond 2 bytes past end of function or program. ");
	  break;

	case ERR_INVALID_INSTRUCTION:
	  strcpy(szBuffer,"Invalid Instruction. ");
	  break;

	case ERR_STORAGE_OUT_OF_RANGE:
	  strcpy(szBuffer,"Storage index out of range. ");
	  break;

	case ERR_CVT_OUT_OF_RANGE:
	  strcpy(szBuffer,"CVT Out of range. ");
	  break;

	case ERR_INVALID_ZONE:
	  strcpy(szBuffer,"Invalid zone. ");
	  break;
	
	case ERR_INVALID_ZONE_NO_TWI:
	  strcpy(szBuffer,"No twilight zone defined. Invalid zone. "); 
	  break;

	case ERR_INVALID_MAXZONES_IN_MAXP:
	  strcpy(szBuffer,"Invalid maxZones in maxp table. ");
	  break;

	case ERR_CONTOUR_OUT_OF_RANGE:
	  strcpy(szBuffer,"Contour out of range. ");
	  break;

	case ERR_POINT_OUT_OF_RANGE:
	  strcpy(szBuffer,"Point out of range. ");
	  break;

	case ERR_ZONE_NOT_0_NOR_1:
	  strcpy(szBuffer,"Zone not 0 nor 1. ");
	  break;

	case ERR_PREPROGAM_ZONE_NOT_TWI:
	  strcpy(szBuffer,"Zone referenced in pre-program is not the twilight zone. ");
	  break;

	case WAR_MPS_ALWAYS_12_ON_WINDOWS:
	  strcpy(szBuffer,"Window 95 and Windows 3.1 always return 12. ");
	  break;

	case WAR_HI_PT_LESS_THAN_LOW_PT:
	  strcpy(szBuffer,"High point is less than low point. ");
	  break;

	case ERR_FDEF_OUT_OF_RANGE:
	  strcpy(szBuffer,"FDEF out of range. ");
	  break;

	case ERR_FDEF_SPACE_NOT_DEFINED:
	  strcpy(szBuffer,"Function definition space not defined. ");
	  break;

	case ERR_VALUE_TO_LARGE_FOR_INT16:
	  strcpy(szBuffer,"Value exceeds capacity of 2 byte number. ");
	  break;

	case ERR_VALUE_TO_LARGE_FOR_INT8:
	  strcpy(szBuffer,"Value exceeds capacity of 1 byte number. ");
	  break;

	case ERR_VALUE_TO_SMALL:
	  strcpy(szBuffer,"Value too small. ");
	  break;

	case ERR_ENDF_BEYOND_64K_OF_FDEF:
	  strcpy(szBuffer,"ENDF beyond 64K of FDEF. ");
	  break;

	case ERR_ENDF_BEYOND_64K_OF_IDEF:
	  strcpy(szBuffer,"ENDF beyond 64K of IDEF. ");
	  break;

	case ERR_INVALID_ZONE_IN_IUP:
	  strcpy(szBuffer,"ZP2 in IUP does not point to zone 1. ");
	  break;

	case ERR_INVALID_STACK_ACCESS:
	  strcpy(szBuffer,"Attempt to access stack element out of range. ");
	  break;

	case WAR_PT_NOT_TOUCHED:
	  strcpy(szBuffer,"Point not touched. ");
	  break;

	case ERR_MATH_OVERFLOW:
	  strcpy(szBuffer,"Math overflow. ");
	  break;

	case ERR_DIVIDE_BY_ZERO:
	  strcpy(szBuffer,"Divide by zero. ");
	  break;

	case ERR_FUNCTION_NOT_DEFINED:
	  strcpy(szBuffer,"Function not defined. ");
	  break;

	case ERR_INSTR_DEFD_BY_FS:
	  strcpy(szBuffer,"Instruction already defined by rasterizer. ");
	  break;

	case ERR_EXCEEDS_INSTR_DEFS_IN_MAXP:
	  strcpy(szBuffer,"IDEF exceeds max instruction defs in maxp. ");
	  break;

	case WAR_DEBUG_FOUND:
	  strcpy(szBuffer,"DEBUG found which should not be found in production code. ");
	  break;

	case ERR_SELECTOR_INVALID:
	  strcpy(szBuffer,"Selector invalid. ");
	  break;

	case ERR_STORE_INDEX_NOT_WRITTEN_TO:
	  strcpy(szBuffer,"Storage location not written to. ");
	  break; 

	case ERR_FUCOORDINATE_OUT_OF_RANGE:
	  strcpy(szBuffer,"Funit coordinate out of range must be -16384 .. 16383. ");
	  break;

	case ERR_REFPOINT_USED_BUT_NOT_SET:
	  strcpy(szBuffer,"Reference point used but not set. ");
	  break;

	case ERR_3_USED_FOR_PERIOD:
	  strcpy(szBuffer,"Reserved value of 3 used for period. ");
	  break;

	case ERR_NOT_CALLED_FROM_PREPROGRAM:
	  strcpy(szBuffer,"Not called from pre-program. ");
	  break;

	case ERR_RESERVED_BIT_SET:
	  strcpy(szBuffer,"At least one reserved bit is set. ");
	  break;

	case ERR_VALUE_INVALID_0_OR_1:
	  strcpy(szBuffer,"Value invalid should be 0 or 1. ");
	  break;

	case ERR_VALUE_INVALID_0_OR_2:
	  strcpy(szBuffer,"Value invalid should be 0 or 2. ");
	  break;

	case ERR_BITS_8_AND_11_SET:
	  strcpy(szBuffer,"Bits 8 and 11 are set, they are mutually exclusive. ");
	  break;

	case ERR_BITS_9_AND_12_SET:
	  strcpy(szBuffer,"Bits 9 and 12 are set, they are mutually exclusive. ");
	  break;

	case ERR_BITS_10_AND_13_SET:
	  strcpy(szBuffer,"Bits 10 and 13 are set, they are mutually exclusive. ");
	  break;

	case WAR_SANGW_OBSELETE:
	  strcpy(szBuffer,"Function no longer needed because of dropped support of AA. ");
	  break;

	case ERR_VALUE_OUT_OF_RANGE:
	  strcpy(szBuffer,"Value out of range. ");
	  break;

	case WAR_DELTAC_IN_GLYPH_PGM:
	  strcpy(szBuffer,"Repeated executions in glyph programs can have unexpected results. ");
	  break;

	case ERR_VECTOR_XY_ZERO:
	  strcpy(szBuffer,"X and Y components of vector are 0. ");
	  break;

	case ERR_VECTOR_XY_INVALID:
	  strcpy(szBuffer,"X and Y components of vector are invalid. X^2 + Y^2 != 0x4000^2. ");
	  break;

	case ERR_RP1_RP2_SAME_POS_ON_PROJ:
	  strcpy(szBuffer,"RP1 and RP2 have the same position on the projection vector. ");
	  break;

	case WAR_PF_VECTORS_AT_OR_NEAR_PERP:
	  strcpy(szBuffer,"Projection and freedom vectors at or near perpendicular. ");
	  break;

	case WAR_CALL_ZERO_LEN_UD_INSTR:
	  strcpy(szBuffer,"Call to zero length user defined instruction. ");
	  break;

	case ERR_TWILIGHT_ZONE_PT_NOT_SET:
	  strcpy(szBuffer,"Twilight zone point not set. ");
	  break;
	    
	case WAR_LOOP_NOT_1_AT_END_OF_PGM:
	  strcpy(szBuffer,"Loop variable not 1 at end of program. This means it was set but not used. ");
	  break;

	case ERR_ELSE_WITHOUT_EIF:
	  strcpy(szBuffer,"ELSE found without EIF. ");
	  break;

	case ERR_INVALID_FLAG:
	  strcpy(szBuffer,"Invalid Instruction flag. ");
	  break;

	case ERR_FDEF_FOUND_IN_FDEF:
	  strcpy(szBuffer,"FDEF found within FDEF - ENDF pair. ");
	  break;

	case ERR_IDEF_FOUND_IN_FDEF:
	  strcpy(szBuffer,"IDEF found within FDEF - ENDF pair. ");
	  break;

	case ERR_IDEF_FOUND_IN_IDEF:
	  strcpy(szBuffer,"IDEF found within IDEF - ENDF pair. ");
	  break;

	case ERR_FDEF_FOUND_IN_IDEF:
	  strcpy(szBuffer,"FDEF found within IDEF - ENDF pair. ");
	  break;

	case WAR_LOOPCALL_COUNT_LESS_THAN_ONE:
	  strcpy(szBuffer,"Value for count is less than 1. Function will not be called. ");
	  break;

	case ERR_INST_OPCODE_TO_LARGE:
	  strcpy(szBuffer,"Instruction OpCode is to large. Must be between 0 and 255. ");
	  break;

	case WAR_APPLE_ONLY_INSTR:
	  strcpy(szBuffer,"Instruction is only valid on the Apple platform. ");
	  break;
	
	case ERR_RAW_NOT_FROM_GLYPHPGM:
	  strcpy(szBuffer,"RAW[], not called from glyph program. ");
	  break;

	case ERR_UNITIALIZED_ZONE:
	  strcpy(szBuffer,"Font/pre program, access to unitialized zone ");
	  break;

	default:
	  sprintf(szBuffer,"Unknown Error %u ",usErrorCode);
	  break;
}

  if(strlen(szBuffer) + 1 > usStringSize)
    return FALSE;

  strcpy(szErrorString,szBuffer);
  
  return TRUE;

}

/* Local Functions */ 
static BOOL OutputErrorToClient(fnt_LocalGraphicStateType * pLocalGS, unsigned short usErrorType,
                                unsigned short usErrorCode, char* szErrorString)
{
  /* This function takes the information in the call stack and creates a TraceArray memory object
     that is passed to the client's notify function along with details about the error message. */


  TraceArray* pTA = NULL;
  pClientSpecificData pCSD;
  unsigned short usIndex;

  /* Local pointer to current client data */
  pCSD = pCurrentSpecificData;
    
  FSTAssert((pCSD->lCallNestLevel > 0),"CallNestLevel is not > 0");

  pTA = (TraceArray *)FST_MALLOC(sizeof(TraceArray) + (pCSD->lCallNestLevel - 1) * sizeof(TraceCell));
  if(pTA == NULL)
    return FALSE;

  pTA->bCompositeGlyph = pLocalGS->globalGS->bCompositeGlyph;

  pTA->pgmIndex = pLocalGS->globalGS->pgmIndex;

  pTA->lNumCells = pCSD->lCallNestLevel;

  /* For all levels other than most current, set values.  */
  for(usIndex = 0; usIndex < pTA->lNumCells - 1; usIndex++)
  {
	pTA->arrayTraceCell[usIndex].usFunc = pCSD->pArrayCallStack[usIndex].usFunc;
	pTA->arrayTraceCell[usIndex].usUserDefinedInst = pCSD->pArrayCallStack[usIndex].usUserDefinedInst;
	/* Set ByteOffset using call stack's value for insPtr which in only set prior to going up a level. */
	pTA->arrayTraceCell[usIndex].lByteOffset = (ptrdiff_t)(pCSD->pArrayCallStack[usIndex].insPtr - 
	                                           pCSD->pArrayCallStack[usIndex].pCallNestBeginInst);
  }

  /* Set most current or highest level values. */
  pTA->arrayTraceCell[pTA->lNumCells - 1].usFunc = pCSD->pArrayCallStack[pTA->lNumCells - 1].usFunc;
  pTA->arrayTraceCell[pTA->lNumCells - 1].usUserDefinedInst = pCSD->pArrayCallStack[pTA->lNumCells - 1].usUserDefinedInst;
  /* Set ByteOffset using localGS value for insPtr. */
  pTA->arrayTraceCell[pTA->lNumCells - 1].lByteOffset = (ptrdiff_t)(pLocalGS->insPtr - 
	                                           pCSD->pArrayCallStack[pTA->lNumCells - 1].pCallNestBeginInst);

  /* If this instruction uses the loop graphic state, give the loop iteration (1 based).
     If not, set the iteration to 0 indicating to client that function does not use loop. */
  if(gInstUsesLoop[pLocalGS->opCode])
  {
    /* Loop internally zero based but documented as 1 based so add one to output number. */
    pTA->lLoopIteration = (pCSD->lLoopSet -	pCSD->lCurrentLoop) + 1;
  }else
  {
    pTA->lLoopIteration = 0;
  }
    
  /* Call client's notify function */
  if(!gpNotifyFunction(pLocalGS->opCode,usErrorType,usErrorCode,szErrorString,pTA))
  {
    /* If client returns false, stop executing instructions. */
    pLocalGS->TraceFunc = NULL;
	/* Set flag to indicate break occured so call stack can be updated properly. */
	pCSD->bBreakOccured = TRUE;
  }

  FST_FREE(pTA);  
  return TRUE;
}

static BOOL UpdateCallStack(pClientSpecificData pCSD, fnt_LocalGraphicStateType * pLocalGS, uint8 * pbyEndInst)
{     
  CallStackCell *pCallStackCell;
  
  FSTAssert(pCSD->pArrayCallStack,"CallStack pointer NULL");  
  
  if(pCSD->lCallNestLevel > 0)
    pCallStackCell = &(pCSD->pArrayCallStack[pCSD->lCallNestLevel - CURRENTLEVEL]);
  else
	pCallStackCell = NULL;
     
  if(pCSD->lCallNestLevel <= 0 || pCSD->bBreakOccured)
  {
     /* First time we are called for a font or after a break set data to initial values. */
	 pCSD->lCallNestLevel = 1;

	 /* If the client ordered a break, start fresh. */
	 if(pCSD->bBreakOccured)
	 {

	   if (pCSD->lCallNestLevel > pCSD->lAllocatedNestlevels)
	   {
		   pCSD->pArrayCallStack = (CallStackCell *)FST_REALLOC(pCSD->pArrayCallStack,pCSD->lCallNestLevel*sizeof(CallStackCell),pCSD->lAllocatedNestlevels*sizeof(CallStackCell));
		   FSTAssert((pCSD->pArrayCallStack != NULL),"CallStack memory allocation error");
			if (pCSD->pArrayCallStack == NULL)
			{
				/* stop executing instructions. */
				pLocalGS->TraceFunc = NULL;	
				pLocalGS->ercReturn = TRACE_FAILURE_ERR;  /* returned an error to the rasterizer client */
				/* Set flag to indicate break occured so call stack can be updated properly. */
				pCSD->bBreakOccured = TRUE;
				return FALSE;
			}
		   pCSD->lAllocatedNestlevels = pCSD->lCallNestLevel;
	   }

	   pCSD->lLoopSet = 0;

	   ClearRefPtFlags(pCSD);
	   ClearTwilightZonePts(pCSD);

	   pCSD->bBreakOccured = FALSE;
	 }

	 pCSD->pArrayCallStack[0].pCallNestBeginInst = pLocalGS->insPtr;
	 pCSD->pArrayCallStack[0].pCallNestLevelEndInst = pbyEndInst;
	 pCSD->pArrayCallStack[0].lIfNestLevel = 0;

	 pCSD->pArrayCallStack[0].usFunc = NO_FUNCTION;
	 pCSD->pArrayCallStack[0].usUserDefinedInst = NO_INSTRUCTION;
	 pCSD->pArrayCallStack[0].usFunctionCalled = NO_FUNCTION;
	 pCSD->pArrayCallStack[0].usUserDefinedInstCalled = NO_INSTRUCTION;
	 pCSD->pArrayCallStack[0].bLastInst = FALSE;
	 pCSD->pArrayCallStack[0].usCurrentCallCount = 0;
	 pCSD->pArrayCallStack[0].bCurrentInstUserDefined = FALSE;
  
  }else if (pCallStackCell->usCurrentCallCount || pCallStackCell->bCurrentInstUserDefined)
  {
     /* If usCurrentCallCount is non-zero or bCurrentInstUserDefined is TRUE, the last function was
        either a CALL, LOOPCALL or call to a user defined (IDEFed) instruction which means
	    we are going up a level in our call stack and need to allocate an additional
	    call stack cell.	*/
	 CallStackCell *pCurrentCallStackCell;
	 CallStackCell *pPrevCallStackCell;  

	 pCSD->lCallNestLevel += 1;

	 if (pCSD->lCallNestLevel > pCSD->lAllocatedNestlevels)
	 {
		 pCSD->pArrayCallStack = (CallStackCell *)FST_REALLOC(pCSD->pArrayCallStack,pCSD->lCallNestLevel*sizeof(CallStackCell),pCSD->lAllocatedNestlevels*sizeof(CallStackCell));
		 FSTAssert((pCSD->pArrayCallStack != NULL),"CallStack memory allocation error");
			if (pCSD->pArrayCallStack == NULL)
			{
				/* stop executing instructions. */
				pLocalGS->TraceFunc = NULL;	
				pLocalGS->ercReturn = TRACE_FAILURE_ERR;  /* returned an error to the rasterizer client */
				/* Set flag to indicate break occured so call stack can be updated properly. */
				pCSD->bBreakOccured = TRUE;
				return FALSE;
			}
		 pCSD->lAllocatedNestlevels = pCSD->lCallNestLevel;
	 }

	 pCurrentCallStackCell = &(pCSD->pArrayCallStack[pCSD->lCallNestLevel - CURRENTLEVEL]);
	 pPrevCallStackCell = &(pCSD->pArrayCallStack[pCSD->lCallNestLevel - PREVIOUSLEVEL]);
     
	 /* Decrement usCurrentCallCount by one. For a CALL, this will set it to zero. For LOOPCALL,
	    the value remaining will be the number of iterations we will call the function again after 
	    this iteration. */
	 if(pPrevCallStackCell->usCurrentCallCount)
	 {
	   pCurrentCallStackCell->usFunc = pPrevCallStackCell->usFunctionCalled;
	   pCurrentCallStackCell->usUserDefinedInst = NO_INSTRUCTION;

       pPrevCallStackCell->usCurrentCallCount = (unsigned short)MAX(0,pPrevCallStackCell->usCurrentCallCount - 1);
	 }

	 if(pPrevCallStackCell->bCurrentInstUserDefined)
	 {
	   pCurrentCallStackCell->usUserDefinedInst = pPrevCallStackCell->usUserDefinedInstCalled;
	   pCurrentCallStackCell->usFunc = NO_FUNCTION;

	   pPrevCallStackCell->bCurrentInstUserDefined = FALSE;
	 }
	 
	 pCurrentCallStackCell->pCallNestBeginInst = pLocalGS->insPtr;
	 pCurrentCallStackCell->pCallNestLevelEndInst = pbyEndInst;
	 pCurrentCallStackCell->lIfNestLevel = 0;
	 pCurrentCallStackCell->bLastInst = FALSE;
	 pCurrentCallStackCell->usFunctionCalled = NO_FUNCTION;
	 pCurrentCallStackCell->usCurrentCallCount = 0;
	 pCurrentCallStackCell->usUserDefinedInstCalled = NO_INSTRUCTION;
	 pCurrentCallStackCell->bCurrentInstUserDefined = FALSE;

  }else if(pCallStackCell->bLastInst)
  {
    /* If the last instruction executed was the last instruction in a function block, we are going 
	   down a level in the call stack. An exception to this is if we got to this function with
	   a LOOPCALL and the function is going to be executed again, our level remains the same.

	   If the last instruction executed was the last instruction at level 1 that is at the base
	   level not in a function, we are in a new program. */
    long lIndex;
	long lHowManyLevels = 0;
	BOOL bFoundMatch = FALSE;

	CallStackCell *pCurrentCallStackCell;
	CallStackCell *pPrevCallStackCell = NULL; 

	pCurrentCallStackCell = &(pCSD->pArrayCallStack[pCSD->lCallNestLevel - CURRENTLEVEL]);	

	if(pCSD->lCallNestLevel > CURRENTLEVEL)
	{
	  pPrevCallStackCell = &(pCSD->pArrayCallStack[pCSD->lCallNestLevel - PREVIOUSLEVEL]); 
	}
	/* If lCallNestlevel > 1 then the last instruction was in a function and if usCurrentCallCount 
	   is non zero, we are still in the function. It was called by a LOOPCALL.   */
	if((pCSD->lCallNestLevel > CURRENTLEVEL) && (pPrevCallStackCell != NULL) && (pPrevCallStackCell->usCurrentCallCount))
	{
	  /* Decrement number of times LOOPCALL will call this function by one. */
	  pPrevCallStackCell->usCurrentCallCount = (unsigned short)(pPrevCallStackCell->usCurrentCallCount - 1);
	}else
	{
	  /* Look in the call stack to see if the current end instruction pointer is in there.
	     If so, then decrement down to that level. If not, we are in a different program so 
	     set level to 1 and reinitialize call stack cell for new base. */
	  for(lIndex = pCSD->lCallNestLevel - PREVIOUSLEVEL; (lIndex >= 0 && !bFoundMatch); lIndex--)
	  {
	    lHowManyLevels++;

	    if(pbyEndInst == pCSD->pArrayCallStack[lIndex].pCallNestLevelEndInst)
	      bFoundMatch = TRUE;
	  }

	  if(!bFoundMatch)
	  {
	    pCSD->lCallNestLevel = 1;
	  }else
	  {
	    pCSD->lCallNestLevel -= lHowManyLevels;
	  }

	  FSTAssert((pCSD->lCallNestLevel > 0),"Call Nest level below 1");

	  if (pCSD->lCallNestLevel > pCSD->lAllocatedNestlevels)
	  {
		  pCSD->pArrayCallStack = (CallStackCell *)FST_REALLOC(pCSD->pArrayCallStack,pCSD->lCallNestLevel*sizeof(CallStackCell),pCSD->lAllocatedNestlevels*sizeof(CallStackCell));
		  FSTAssert((pCSD->pArrayCallStack != NULL),"CallStack memory allocation error");
			if (pCSD->pArrayCallStack == NULL)
			{
				/* stop executing instructions. */
				pLocalGS->TraceFunc = NULL;	
				pLocalGS->ercReturn = TRACE_FAILURE_ERR;  /* returned an error to the rasterizer client */
				/* Set flag to indicate break occured so call stack can be updated properly. */
				pCSD->bBreakOccured = TRUE;
				return FALSE;
			}
		  pCSD->lAllocatedNestlevels = pCSD->lCallNestLevel;
	  }

	  pCurrentCallStackCell = &(pCSD->pArrayCallStack[pCSD->lCallNestLevel - CURRENTLEVEL]);

	  if (pCSD->lCallNestLevel > 1)
	  {
	    pPrevCallStackCell = &(pCSD->pArrayCallStack[pCSD->lCallNestLevel - PREVIOUSLEVEL]); 
	  }
	  /* The following if is needed because if we fall back into the beginning of a function called by a 
	     LOOPCALL from a higher level, we need to decrement number of times LOOPCALL will call this function
	     by one. If lCallNestlevel > 1 then the last instruction was in a function and if usCurrentCallCount 
	     is non zero and our instruction pointer is pointing to the first instruction, we have fallen back
	     into function called by a LOOPCALL.  */
	  if((pCSD->lCallNestLevel > 1) && (pPrevCallStackCell->usCurrentCallCount) &&
	     (pCurrentCallStackCell->pCallNestBeginInst == pLocalGS->insPtr))
	  {
	    /* Decrement number of times LOOPCALL will call this function by one. */
	    pPrevCallStackCell->usCurrentCallCount = (unsigned short)(pPrevCallStackCell->usCurrentCallCount - 1);
	  }

	  if(!bFoundMatch)
	  {
	    pCurrentCallStackCell->pCallNestBeginInst = pLocalGS->insPtr;
	    pCurrentCallStackCell->pCallNestLevelEndInst = pbyEndInst;
	    pCurrentCallStackCell->usFunc = NO_FUNCTION;
	    pCurrentCallStackCell->lIfNestLevel = 0;
	    pCurrentCallStackCell->bLastInst = FALSE;

		pCSD->lLoopSet = 0;
	   
	    #ifndef FST_CRIT_ONLY
	    ClearRefPtFlags(pCSD);
		ClearTwilightZonePts(pCSD);
		#endif 
	  }
    }

	pCurrentCallStackCell->bLastInst = FALSE;
  }
    
  FSTAssert((pCSD->pArrayCallStack[0].usFunc == NO_FUNCTION),"Base of stack not NO_FUNCTION");
  
  /* Determine if this will be last instruction executed in this block. For certin instructions
     such as IF, ELSE and FDEF, this method of determining if it is the last instruction will not
     work so the determination will be made in the check routines for the respective functions.  */
  if(pLocalGS->insPtr >= pbyEndInst - 1)
    pCSD->pArrayCallStack[pCSD->lCallNestLevel - CURRENTLEVEL].bLastInst = TRUE;

  return TRUE;
}

static BOOL ProcessPostInst(pClientSpecificData pCSD, fnt_LocalGraphicStateType * pLocalGS, uint8 * pbyEndInst)
{   
  /* Check for lLoopSet at this level is for speed only to possibly avoid loop. */
  if((pCSD->pArrayCallStack[pCSD->lCallNestLevel - CURRENTLEVEL].bLastInst) && (pCSD->lLoopSet))
  {
    long lIndex;
	BOOL bLastInstruction = TRUE;

	for(lIndex = pCSD->lCallNestLevel - 1; (lIndex >= 0 && bLastInstruction); lIndex--)
	{
	  /* Make sure last instruction bit is set for previous levels in call stack. */
	  if(!(pCSD->pArrayCallStack[lIndex].bLastInst))
	    bLastInstruction = FALSE;

	  /* Check to see if any outstanding LoopCalls in previous levels in call stack. */
	  if(pCSD->pArrayCallStack[lIndex].usCurrentCallCount)
	    bLastInstruction = FALSE;
	}
	
	if(bLastInstruction && (pCSD->lLoopSet))
	{
	  OutputErrorToClient(pLocalGS,ET_WARNING,WAR_LOOP_NOT_1_AT_END_OF_PGM,NULL);
	}
  }
  
  /* Prevent unreferenced formal parameter warning */
  UNREFERENCED_PARAMETER(pbyEndInst);  
   
  return TRUE;
}

static void ClearRefPtFlags(pClientSpecificData pCSD)
{ 
  int iIndex;

  FSTAssert((pCSD != NULL),"pCSD NULL in ClearRefPtFlags");

  for(iIndex = 0; iIndex < NUM_REF_PTS; iIndex++)
    pCSD->RefPtsUsed[iIndex] = 0;
}

static void SetTwilightZonePt(pClientSpecificData pCSD, fnt_LocalGraphicStateType* pGS, fnt_ElementType*elem, 
                              int32 pt)
{   
  if (pGS->elements == elem)
  {
	if(pCSD->pTwilightZonePtsSet == NULL)
	{
	  pCSD->pTwilightZonePtsSet = (unsigned char *)FST_MALLOC(sizeof(unsigned char) * pGS->globalGS->maxp->maxTwilightPoints);
	  FSTAssert((pCSD->pTwilightZonePtsSet != NULL),"ClientData memory allocation error");
	  if(pCSD->pTwilightZonePtsSet != NULL)
	  {
	    int index;
		for(index = 0; index < pGS->globalGS->maxp->maxTwilightPoints; index++)
		  pCSD->pTwilightZonePtsSet[index] = 0; 
	  }
	}
	 
	if((pt < pGS->globalGS->maxp->maxTwilightPoints) && (pt >= 0))
	  pCSD->pTwilightZonePtsSet[pt] = 1; 
  }
}

static void ClearTwilightZonePts(pClientSpecificData pCSD)
{ 
  if(pCSD->pTwilightZonePtsSet != NULL)
  {
    FST_FREE(pCSD->pTwilightZonePtsSet);
    pCSD->pTwilightZonePtsSet = NULL;
  }
}

/**************************************************************************/

/* This is called by itrp_IF, itrp_ELSE, itrp_FDEF, and itrp_IDEF         */
/* It is used to find the next TrueType instruction in the instruction    */
/* stream by skipping over push data.  It is table driven for speed.      */

#define NPUSHB_CASE	21
#define NPUSHW_CASE 22

static const uint8 gbyPushTable[] = {
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    NPUSHB_CASE,NPUSHW_CASE, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	1, 2, 3, 4, 5, 6, 7, 8, 2, 4, 6, 8,10,12,14,16,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
	0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
};

static uint8* FST_SkipPushData (uint8* pbyInst)
{
	int32 iDataCount;         /* count of data following push instruction */
	
	iDataCount = (int32)gbyPushTable[ pbyInst[-1] ];   /* opcode */
	
	if (iDataCount != 0)                        /* if a push instruction */
	{
		if (iDataCount == NPUSHB_CASE)          /* special for npushb */
		{
			iDataCount = (int32)*pbyInst + 1;
		}
		else if (iDataCount == NPUSHW_CASE)     /* special for npushw */
		{
			iDataCount = ((int32)*pbyInst << 1) + 1;
		}
		pbyInst += iDataCount;
	}
	return pbyInst;
}
#endif // FST_CRIT_ONLY

/*
 *      This guy returns the index of the given opCode, or 0 if not found 
 */
static fnt_instrDef *FST_FindIDef (fnt_LocalGraphicStateType * pLocalGS)
{
	fnt_GlobalGraphicStateType *globalGS;
	int32 count;
	fnt_instrDef*instrDef;
	
	globalGS = pLocalGS->globalGS;
	count = globalGS->instrDefCount;
	instrDef = globalGS->instrDef;
		
	for (--count; count >= 0; instrDef++, --count)
	{
		if (instrDef->opCode == pLocalGS->opCode)
		{
			return instrDef;
		}
	}
	return 0;
}

#ifndef FST_CRIT_ONLY
static void FST_CompMul(int32 lSrc1, int32 lSrc2, int32 alDst[2])
{
	boolean     bNegative;
	uint32      ulDstLo;
	uint32      ulDstHi;
	uint16      usSrc1lo;
	uint16      usSrc1hi;
	uint16      usSrc2lo;
	uint16      usSrc2hi;
	uint32      ulTemp;

	bNegative = (lSrc1 ^ lSrc2) < 0;

	if (lSrc1 < 0)
	{
		lSrc1 = -lSrc1;
	}
	if (lSrc2 < 0)
	{
		lSrc2 = -lSrc2;
	}

	usSrc1hi = (uint16)(lSrc1 >> 16);
	usSrc1lo = (uint16)lSrc1;
	usSrc2hi = (uint16)(lSrc2 >> 16);
	usSrc2lo = (uint16)lSrc2;
	ulTemp   = (uint32)usSrc1hi * (uint32)usSrc2lo + (uint32)usSrc1lo * (uint32)usSrc2hi;
	ulDstHi  = (uint32)usSrc1hi * (uint32)usSrc2hi + (ulTemp >> 16);
	ulDstLo  = (uint32)usSrc1lo * (uint32)usSrc2lo;
	ulTemp <<= 16;
	ulDstLo += ulTemp;
	ulDstHi += (uint32)(ulDstLo < ulTemp);

	if (bNegative)
	{
		ulDstLo = (uint32)-((int32)ulDstLo);

		if (ulDstLo != 0L)
		{
			ulDstHi = ~ulDstHi;
		}
		else
		{
			ulDstHi = (uint32)-((int32)ulDstHi);
		}
	}

	alDst[0] = (int32)ulDstHi;
	alDst[1] = (int32)ulDstLo;
}
#endif
 

static BOOL Check_For_POP(F26Dot6* stackPtr, F26Dot6* stackBase, fnt_LocalGraphicStateType * pLocalGS, long lNumItems)
{
  if (stackPtr - (long)(lNumItems - 1) <= stackBase)
  {
	OutputErrorToClient(pLocalGS,ET_CRITICAL_ERROR,ERR_STACK_UNDERFLOW,NULL);
	return FALSE;
  }
  return TRUE;
}

#ifndef FST_CRIT_ONLY
static void Check_jump(fnt_LocalGraphicStateType * pLocalGS, uint8 * pbyEndInst, int32 offset)
{
  pClientSpecificData pCSD;

  /* Local pointer to current client data */
  pCSD = pCurrentSpecificData;

  /* Check offset of jump. If jump causes us to change level on	call stack, set last
     instruction flag approporiately. */ 
  
  /* Warn if jumping to offset zero. */
  if(offset == 0)
  {
    OutputErrorToClient(pLocalGS,ET_WARNING,WAR_JMP_OFFSET_ZERO,NULL);
  }  
  /* If offset is less than zero, we are going back in instruction stream. */
  else if(offset < 0)
  { 
    /* Check to see if we are going to jump to before beginning of function or program. */
    if(pLocalGS->insPtr + offset < pCSD->pArrayCallStack[pCSD->lCallNestLevel - 1].pCallNestBeginInst)
      OutputErrorToClient(pLocalGS,ET_CRITICAL_ERROR,ERR_JMP_BEFORE_BEGINNING,NULL);

	/* If the jump was our last instruction and we are jumping to a negative offset, 
	   the instruction is not really the last instruction.  */
	if(pCSD->pArrayCallStack[pCSD->lCallNestLevel - 1].bLastInst == TRUE)
	  pCSD->pArrayCallStack[pCSD->lCallNestLevel -1].bLastInst = FALSE;
  }
  /* If offset is greater than zero, we are going forward in instruction stream. */
  else if(offset > 0)
  {
    /* Check to see if we are jumping beyond 2 bytes past last instruction.
       Technically it is OK to jump beyond end of program of function because
       it constitutes a break. This check just makes sure that we are not jumping
       to far beyond end. */
    if(pLocalGS->insPtr + offset > pbyEndInst + 2)
	  OutputErrorToClient(pLocalGS,ET_ERROR,ERR_JMP_BEYOND_2MORE_THAN_END,NULL);

	/* If jump beyond last executed instruction, then this will be last instruction. */
	if(pLocalGS->insPtr + offset > pbyEndInst - 1)
	  pCSD->pArrayCallStack[pCSD->lCallNestLevel - 1].bLastInst = TRUE;
  }
}
#endif // FST_CRIT_ONLY

static BOOL Check_Storage(fnt_LocalGraphicStateType* pGS, int32 index, int32 maxStorage)
{
  if ((int32)index > maxStorage || (int32)index < 0L)
  {
#ifndef FST_CRIT_ONLY
    char szIndex[SMALL_TEMP_STRING_SIZE];
	sprintf (szIndex, "Index = %ld, Range = %ld .. %ld", index, 0, maxStorage); 
    OutputErrorToClient(pGS, ET_CRITICAL_ERROR, ERR_STORAGE_OUT_OF_RANGE, szIndex);
#else
    OutputErrorToClient(pGS, ET_CRITICAL_ERROR, ERR_STORAGE_OUT_OF_RANGE, NULL);
#endif // FST_CRIT_ONLY
	return FALSE;
  }
  return TRUE;
}

static void Check_CVT(fnt_LocalGraphicStateType* pGS, int32 cvt, int32 cvtCount)
{
  if ((int32)cvt > cvtCount || (int32)cvt < 0L)
  {
#ifndef FST_CRIT_ONLY
    char szCVT[SMALL_TEMP_STRING_SIZE];
	sprintf(szCVT,"CVT = %ld, Range = %ld .. %ld",cvt,0,cvtCount);
	OutputErrorToClient(pGS, ET_CRITICAL_ERROR, ERR_CVT_OUT_OF_RANGE, szCVT);
#else
	OutputErrorToClient(pGS, ET_CRITICAL_ERROR, ERR_CVT_OUT_OF_RANGE, NULL);
#endif // FST_CRIT_ONLY
  }
}

#ifdef FSCFG_FONTOGRAPHER_BUG
static void Check_CVTReadSpecial(fnt_LocalGraphicStateType* pGS, int32 cvt)
{
  int32 cvtCount = (int32)(pGS->globalGS->cvtCount - 1L);

  if (((int32)cvt > cvtCount && cvt > 255) || (int32)cvt < 0L)
  {
#ifndef FST_CRIT_ONLY
    char szCVT[SMALL_TEMP_STRING_SIZE];
	sprintf(szCVT,"CVT = %ld, Range = %ld .. %ld",cvt,0,cvtCount);
	OutputErrorToClient(pGS, ET_CRITICAL_ERROR, ERR_CVT_OUT_OF_RANGE, szCVT);
#else
	OutputErrorToClient(pGS, ET_CRITICAL_ERROR, ERR_CVT_OUT_OF_RANGE, NULL);
#endif // FST_CRIT_ONLY
  }
}
#endif // FSCFG_FONTOGRAPHER_BUG

static void Check_Zone(fnt_LocalGraphicStateType* pGS, int32 elem, int32 maxElem)
{
  if(maxElem == 1)
  {
    /* We have both zones.  */
	if (elem > maxElem || elem < 0L)
	{
#ifndef FST_CRIT_ONLY
	  char szZone[SMALL_TEMP_STRING_SIZE];
	  sprintf(szZone,"%i",elem);
	  OutputErrorToClient(pGS,ET_CRITICAL_ERROR,ERR_INVALID_ZONE,szZone);
#else
	  OutputErrorToClient(pGS,ET_CRITICAL_ERROR,ERR_INVALID_ZONE,NULL);
#endif // FST_CRIT_ONLY
	}
	
  }else if(maxElem == 0)
  {
	/* We have no twilight zone. */
	if (elem != 1L)
	{
#ifndef FST_CRIT_ONLY
	  char szZone[SMALL_TEMP_STRING_SIZE];
	  sprintf(szZone,"%i",elem);
	  OutputErrorToClient(pGS,ET_CRITICAL_ERROR,ERR_INVALID_ZONE_NO_TWI,szZone);
#else
	  OutputErrorToClient(pGS,ET_CRITICAL_ERROR,ERR_INVALID_ZONE_NO_TWI,NULL);
#endif // FST_CRIT_ONLY
	}

  }else
  {
    #ifndef FST_CRIT_ONLY
	/* As long as we are here, generate error if maxElem is not 0 or 1. */
	OutputErrorToClient(pGS,ET_ERROR,ERR_INVALID_MAXZONES_IN_MAXP,NULL);
	#endif
  }
     
}

static void Check_ZonePtr (fnt_LocalGraphicStateType* pGS, fnt_ElementType*elem, int32 maxElem, int32 maxctrs, int32 maxpts, int32 maxTwiPts)
{
#ifndef FST_CRIT_ONLY
	if (pGS->globalGS->pgmIndex != GLYPHPROGRAM) 
	/* in the glyph program, both zone (glyph and twilight are initialized */ 
	{ 
	    if (pGS->globalGS->pgmIndex != PREPROGRAM || pGS->elements != elem ) 
		/* in the pre-program, only the twilight zone is initialized, */ 
		/* in any other zone i.e. font program, none of the zones are initialized */ 
		{ 
			OutputErrorToClient(pGS,ET_ERROR,ERR_UNITIALIZED_ZONE,NULL);
		} 
    } 
#endif // FST_CRIT_ONLY

  if (elem == &pGS->elements[GLYPH_ZONE])
  {
#ifndef FST_CRIT_ONLY
	if ((int32)elem->nc > (int32)maxctrs || (int32)elem->nc < 1L)
	{
	  char szDetails[SMALL_TEMP_STRING_SIZE];
	  sprintf (szDetails,"CONTOUR = %ld, Range = %ld .. %ld ",elem->nc,1,maxctrs); 
	  OutputErrorToClient(pGS,ET_ERROR,ERR_CONTOUR_OUT_OF_RANGE,szDetails);
	  return;
	}

	if ((int32)elem->ep[elem->nc-1] > maxpts ||
		(int32)elem->ep[elem->nc-1] < 0L) 
	{
	  char szDetails[SMALL_TEMP_STRING_SIZE];
	  sprintf (szDetails,"POINT = %ld, Range = %ld .. %ld ",elem->ep[elem->nc-1],1,maxpts);
	  OutputErrorToClient(pGS,ET_ERROR,ERR_POINT_OUT_OF_RANGE,szDetails);
	}
#endif // FST_CRIT_ONLY
  }
  else if (elem == &pGS->elements[TWILIGHT_ZONE])
  {
#ifndef FST_CRIT_ONLY
	if ((int32)elem->ep[elem->nc-1] > maxTwiPts  ||
		(int32)elem->ep[elem->nc-1] < 0L)
	{
	  char szDetails[SMALL_TEMP_STRING_SIZE];
	  sprintf(szDetails,"POINT = %ld, Range = %ld .. %ld ",elem->ep[elem->nc-1],0,maxTwiPts);
	  OutputErrorToClient(pGS,ET_ERROR,ERR_POINT_OUT_OF_RANGE,szDetails);
    }

    /* If we use twilight zone and maxElements in MAXP is 1, we do not have a twilight zone. */
	if(maxElem == 0)
	{
	  OutputErrorToClient(pGS,ET_ERROR,ERR_INVALID_ZONE_NO_TWI,"0");
	}
#endif // FST_CRIT_ONLY
  }
  else 
  {
    OutputErrorToClient(pGS,ET_CRITICAL_ERROR,ERR_ZONE_NOT_0_NOR_1,NULL);
  }
  	
}


static void Check_ForUnitializedZone (fnt_LocalGraphicStateType* pGS, fnt_ElementType*elem)
{
	if (pGS->globalGS->pgmIndex != GLYPHPROGRAM) 
	/* in the glyph program, both zone (glyph and twilight are initialized */ 
	{ 
	    if (pGS->globalGS->pgmIndex != PREPROGRAM || pGS->elements != elem ) 
		/* in the pre-program, only the twilight zone is initialized, */ 
		/* in any other zone i.e. font program, none of the zones are initialized */ 
		{ 
			OutputErrorToClient(pGS,ET_CRITICAL_ERROR,ERR_UNITIALIZED_ZONE,NULL);
		} 
    } 
}

static void Check_Point(fnt_LocalGraphicStateType* pGS, fnt_ElementType*elem, int32 pt, int32 maxPts, int32 maxTwiPts)
{
  pClientSpecificData pCSD;

  /* Local pointer to current client data */
  pCSD = pCurrentSpecificData;

  if (pGS->elements == elem)
  {
	if ((int32)pt > maxTwiPts  ||
		(int32)pt < 0L)
	{
#ifndef FST_CRIT_ONLY
	  char szDetails[SMALL_TEMP_STRING_SIZE];
	  sprintf(szDetails,"POINT = %ld, Range = %ld .. %ld ",pt,0,maxTwiPts);
	  OutputErrorToClient(pGS,ET_CRITICAL_ERROR,ERR_POINT_OUT_OF_RANGE,szDetails);
#else
	  OutputErrorToClient(pGS,ET_CRITICAL_ERROR,ERR_POINT_OUT_OF_RANGE,NULL);
#endif // FST_CRIT_ONLY
	}
	#ifndef FST_CRIT_ONLY
	else if((pCSD->pTwilightZonePtsSet == NULL) || (pCSD->pTwilightZonePtsSet[pt] == 0))
	{
	  char szDetails[SMALL_TEMP_STRING_SIZE];
	  sprintf(szDetails,"POINT = %ld ",pt);
	  OutputErrorToClient(pGS,ET_ERROR,ERR_TWILIGHT_ZONE_PT_NOT_SET,szDetails);
	}
	#endif
  }
  else                                                     
  {
	if ((int32)pt > maxPts || (int32)pt < 0L)
	{
#ifndef FST_CRIT_ONLY
	  char szDetails[SMALL_TEMP_STRING_SIZE];
	  sprintf (szDetails,"POINT = %ld, Range = %ld .. %ld ",pt,0,elem->ep[elem->nc-1] + NUM_PHANTOM_PTS);
	  OutputErrorToClient(pGS,ET_CRITICAL_ERROR,ERR_POINT_OUT_OF_RANGE,szDetails);
#else
	  OutputErrorToClient(pGS,ET_CRITICAL_ERROR,ERR_POINT_OUT_OF_RANGE,NULL);
#endif // FST_CRIT_ONLY
	}
	#ifndef FST_CRIT_ONLY
	else if ((int32)pt > elem->ep[elem->nc-1] + NUM_PHANTOM_PTS)
	{
	  char szDetails[SMALL_TEMP_STRING_SIZE];
	  sprintf (szDetails,"POINT = %ld, Range = %ld .. %ld ",pt,0,elem->ep[elem->nc-1] + NUM_PHANTOM_PTS);
	  OutputErrorToClient(pGS,ET_ERROR,ERR_POINT_OUT_OF_RANGE,szDetails);
	}
	#endif
  }
}

static void Check_Contour(fnt_LocalGraphicStateType* pGS, fnt_ElementType*elem, int32 ctr, int32 maxCtrs)
{ 
  if ((int32)ctr > (maxCtrs -1L) || (int32)ctr < 0L || (int32)ctr > elem->nc - 1L)
  {
#ifndef FST_CRIT_ONLY
    char szDetails[SMALL_TEMP_STRING_SIZE];
	sprintf (szDetails,"CONTOUR = %ld, Range = %ld .. %ld ",ctr,0,elem->nc - 1L); 
	OutputErrorToClient(pGS,ET_CRITICAL_ERROR,ERR_CONTOUR_OUT_OF_RANGE,szDetails);
#else
	OutputErrorToClient(pGS,ET_CRITICAL_ERROR,ERR_CONTOUR_OUT_OF_RANGE,NULL);
#endif // FST_CRIT_ONLY
  }
}

static BOOL Check_FDEF (fnt_LocalGraphicStateType* pGS, int32 fdef, int32 maxFdef)
{
  if ((int32)fdef > maxFdef || (int32)fdef < 0L)
  {
#ifndef FST_CRIT_ONLY
    char szDetails[SMALL_TEMP_STRING_SIZE];
	sprintf(szDetails,"FDEF = %ld, Range = %ld .. %ld ",fdef,0,maxFdef);
	OutputErrorToClient(pGS,ET_CRITICAL_ERROR,ERR_FDEF_OUT_OF_RANGE,szDetails);
#else
	OutputErrorToClient(pGS,ET_CRITICAL_ERROR,ERR_FDEF_OUT_OF_RANGE,NULL);
#endif // FST_CRIT_ONLY
	return FALSE;
  }

  return TRUE;
}

#ifndef FST_CRIT_ONLY
static void Check_INT16 (fnt_LocalGraphicStateType* pGS, int32 n)
{ 
  /* Make sure that there is nothing in high 16 the result of sign extended 
     negative values is ok.     */
  if (((n & 0xFFFF0000) != 0) && ((n & 0xFFFF0000) != 0xFFFF0000))
  {
    char szDetails[SMALL_TEMP_STRING_SIZE];
	sprintf(szDetails,"%ld ",n);
	OutputErrorToClient(pGS,ET_ERROR,ERR_VALUE_TO_LARGE_FOR_INT16,szDetails);
  }
}

static void Check_INT8 (fnt_LocalGraphicStateType* pGS, int32 n)
{
  if (((n & 0xFFFFFF00) != 0) && ((n & 0xFFFFFF00) != 0xFFFFFF00))
  {
    char szDetails[SMALL_TEMP_STRING_SIZE];
	sprintf(szDetails,"%ld ",n);
	OutputErrorToClient(pGS,ET_ERROR,ERR_VALUE_TO_LARGE_FOR_INT8,szDetails);
  }
}

static void Check_Larger (fnt_LocalGraphicStateType* pGS, int32 min, int32 n)
{
  if ( n <= min )
  {
    char szDetails[SMALL_TEMP_STRING_SIZE];
	sprintf(szDetails,"%ld is not larger than %ld",n,min);
	OutputErrorToClient(pGS,ET_ERROR,ERR_VALUE_TO_SMALL,szDetails);
  }
}
#endif

static void Check_SubStack (fnt_LocalGraphicStateType* pGS, F26Dot6* pt, F26Dot6 * stackBase, F26Dot6 * stackMax)
{   
  if (pt > stackMax || pt < stackBase)
    OutputErrorToClient(pGS,ET_CRITICAL_ERROR,ERR_INVALID_STACK_ACCESS,NULL);
}

#ifndef FST_CRIT_ONLY
static void Check_Selector (fnt_LocalGraphicStateType* pGS, int32 n)
{
  if ( n & 0xFFC0)
  {
    char szDetails[SMALL_TEMP_STRING_SIZE];
	sprintf(szDetails,"Selector: %ld ",n);
    OutputErrorToClient(pGS,ET_ERROR,ERR_SELECTOR_INVALID,szDetails);
  }
}

static void Check_INSTCTRL_Selector (fnt_LocalGraphicStateType* pGS, int32 n)
{
  if ((n != 1) && (n != 2))
  {
    char szDetails[SMALL_TEMP_STRING_SIZE];
	sprintf(szDetails,"Selector: %ld ",n);
	OutputErrorToClient(pGS,ET_ERROR,ERR_SELECTOR_INVALID,szDetails);
  }
}

static void Check_FUCoord (fnt_LocalGraphicStateType* pGS, F26Dot6 coord)
{
  #define MAXCOORD (16383L << 6)
  #define MINCOORD (-16384L << 6)

  if ((coord > MAXCOORD) || (coord < MINCOORD))
    OutputErrorToClient(pGS,ET_ERROR,ERR_FUCOORDINATE_OUT_OF_RANGE,NULL);
}

static void Check_RefPtUsed (fnt_LocalGraphicStateType* pGS, int32 pt)
{
  pClientSpecificData pCSD;

  /* Local pointer to current client data */
  pCSD = pCurrentSpecificData;

  /* Commenting out because still deciding on whether this is a valid warning/error.
  if (pCSD->RefPtsUsed[pt] == 0)
  {
    char szDetails[20];
	sprintf(szDetails,"RP%ld ",pt);
	OutputErrorToClient(pGS,ET_WARNING,ERR_REFPOINT_USED_BUT_NOT_SET,szDetails);
  }	 */

  /* Prevent unreferenced formal parameter warning. If above code reactivated, remove.*/
  UNREFERENCED_PARAMETER(pt);
  UNREFERENCED_PARAMETER(pGS);
}

static void Check_Range (fnt_LocalGraphicStateType* pGS, int32 n, int32 min, int32 max)
{
  if (n > max || n < min)
  {
    char szDetails[SMALL_TEMP_STRING_SIZE];
	sprintf(szDetails,"Value = %ld, Range = %ld .. %ld",n,min,max);
	OutputErrorToClient(pGS,ET_ERROR,ERR_VALUE_OUT_OF_RANGE,szDetails);
  }
}

#define VECTORDOT(a,b)                  ShortFracDot((ShortFract)(a),(ShortFract)(b))
#define ONEVECTOR                       ONESHORTFRAC
#define ONESIXTEENTHVECTOR              ((ONEVECTOR) >> 4)

static void Check_PF_Vectors (fnt_LocalGraphicStateType* pLocalGS)
{
  VECTORTYPE pfProj;

  pfProj = (VECTORTYPE)pLocalGS->OldProject(GSA pLocalGS->free.x,pLocalGS->free.y);

  if (pfProj > -ONESIXTEENTHVECTOR && pfProj < ONESIXTEENTHVECTOR) 
  {
    OutputErrorToClient(pLocalGS,ET_WARNING,WAR_PF_VECTORS_AT_OR_NEAR_PERP,NULL);
  }
} 
#endif

/*** Compensation for Transformations ***/

/*
* same as itrp_GetCVTScale
*/

#define VECTORDOT(a,b)                  ShortFracDot((ShortFract)(a),(ShortFract)(b))
#define VECTOR2FIX(a)                   ((Fixed) (a) << 2)
#define NEGINFINITY               0x80000000UL


static Fixed fst_GetCVTScale (fnt_LocalGraphicStateType * pLocalGS)
{
  VECTORTYPE pvx, pvy;
  fnt_GlobalGraphicStateType *globalGS = pLocalGS->globalGS;
  Fixed sySq, sxSq, strSq;

/* Do as few Math routines as possible to gain speed */

  pvx = pLocalGS->proj.x;
  pvy = pLocalGS->proj.y;
  if (pvy) 
  {
	if (pvx)
	{
	  if (pLocalGS->cvtDiagonalStretch == 0)    /* cache is now invalid */
	  {
		pvy = VECTORDOT (pvy, pvy);
		pvx = VECTORDOT (pvx, pvx);
		sySq = FixMul (globalGS->cvtStretchY, globalGS->cvtStretchY);
		sxSq = FixMul (globalGS->cvtStretchX, globalGS->cvtStretchX);

		strSq = FixMul (VECTOR2FIX(pvx),sxSq) + FixMul (VECTOR2FIX(pvy),sySq);
		if  (strSq > ONEFIX)      /* Never happens! */
		  return ONEFIX;

		/* Convert 16.16 to 2.30, compute square root, round to 16.16 */
		pLocalGS->cvtDiagonalStretch = (fst_FracSqrt (strSq<<14) + (1<<13)) >> 14;
	  }
	  return pLocalGS->cvtDiagonalStretch;
	}
	else        /* pvy == +1 or -1 */
	  return globalGS->cvtStretchY;
  }
  else  /* pvx == +1 or -1 */
	return globalGS->cvtStretchX;
}

/* 
   Fract FracSqrt (Fract xf)
   Input:  xf           2.30 fixed point value
   Return: sqrt(xf)     2.30 fixed point value
*/

static Fract fst_FracSqrt (Fract xf)
{
	Fract b = 0L;
	uint32 c, d, x = xf;
	
	if (xf < 0) return (NEGINFINITY);

	/*
	The algorithm extracts one bit at a time, starting from the
	left, and accumulates the square root in b.  The algorithm 
	takes advantage of the fact that non-negative input values
	range from zero to just under two, and corresponding output
	ranges from zero to just under sqrt(2).  Input is assigned
	to temporary value x (unsigned) so we can use the sign bit
	for more precision.
	*/
	
	if (x >= 0x40000000)
	{
		x -= 0x40000000; 
		b  = 0x40000000; 
	}

	/*
	This is the main loop.  If we had more precision, we could 
	do everything here, but the lines above perform the first
	iteration (to align the 2.30 radix properly in b, and to 
	preserve full precision in x without overflow), and afterward 
	we do two more iterations.
	*/
	
	for (c = 0x10000000; c; c >>= 1)
	{
		d = b + c;
		if (x >= d)
		{
			x -= d; 
			b += (c<<1); 
		}
		x <<= 1;
	}

	/*
	Iteration to get last significant bit.
	
	This code has been reduced beyond recognition, but basically,
	at this point c == 1L>>1 (phantom bit on right).  We would
	like to shift x and d left 1 bit when we enter this iteration,
	instead of at the end.  That way we could get phantom bit in
	d back into the word.  Unfortunately, that may cause overflow
	in x.  The solution is to break d into b+c, subtract b from x,
	then shift x left, then subtract c<<1 (1L).
	*/
	
	if (x > (uint32)b) /* if (x == b) then (x < d).  We want to test (x >= d). */
	{
		x -= b;
		x <<= 1;
		x -= 1L;
		b += 1L; /* b += (c<<1) */
	}
	else
	{
		x <<= 1;
	}

	/* 
	Final iteration is simple, since we don't have to maintain x.
	We just need to calculate the bit to the right of the least
	significant bit in b, and use the result to round our final answer.
	*/
	
	return ( b + (Fract)(x>(uint32)b) );
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\fsverify\fsverify.h ===
/***************************************************************************
 * Module: FSVERIFY.H
 *
 * Copyright (c) Microsoft Corp., 1998
 *
 * Author: Paul Linnerud (paulli)
 * Date:   January 1998
 *
 * Mods: 
 *
 * Functions to verify that TrueType hint data do not contain critical errors
 * which are capable of making the system unstable. Tests are run over a set 
 * of sizes and transforms. 
 *
 **************************************************************************/ 
/* error codes */
#define FSV_E_NONE							0
#define FSV_E_INVALID_TTC_INDEX				1
#define FSV_E_INVALID_FONT_FILE				2
#define FSV_E_FS_ERROR						4
#define FSV_E_FS_EXCEPTION					5
#define FSV_E_NO_MEMORY						6
#define	FSV_E_FSTRACE_INIT_FAIL				7
#define FSV_E_FS_BAD_INSTRUCTION			8

#define FSV_USE_DEFAULT_SIZE_SETTINGS	0x00000001

/* typedefs */
typedef struct
{	
	// Version control
	long lStructSize;
	// Test 1 is no gray scale no transformation.
	unsigned long ulTest1Flags;
	long lTest1From;
	long lTest1To;

	// Test 2 is gray scale no transformation.
	unsigned long ulTest2Flags;
	long lTest2From;
	long lTest2To;

	// Test 3 is no gray scale with non trivial transformation.
	unsigned long ulTest3Flags;
	long lTest3From;
	long lTest3To;
}FSVTESTPARAM, *PFSVTESTPARAM;

typedef unsigned long fsverror;

/* interface */
fsverror fsv_VerifyImage(unsigned char* pucImage, unsigned long ulImageSize, unsigned long ulTTCIndex, 
						 PFSVTESTPARAM pfsvTestParam);
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\fsverify\fstrace.h ===
/***********************************************************************************

Module: FSTrace.h

Author: Paul Linnerud (PaulLi)

Date: 8/4/95

Purpose: Header file exposing interfaces to FSTrace.c.

History:
8/4/95  Wrote it.  PaulLi
10/9/97  Compilation flags moved to the .h file, fst_ prefix to the functions, ClaudeBe

************************************************************************************/

/* memory allocation function used by fstrace.c : */

#ifndef FST_MALLOC
#define FST_MALLOC malloc
#endif
#ifndef FST_FREE
#define FST_FREE free
#endif
#ifndef FST_REALLOC
#define FST_REALLOC(Ptr,NewSize,OldSize) realloc(Ptr,NewSize)
#endif

#ifndef FST_CALLBACK
#ifdef _MAC
#define FST_CALLBACK 
#else
#define FST_CALLBACK __cdecl
#endif
#endif
/* compilation flags : */

/* To chain trace functions, define FST_CHAIN_TRACE. */
/* #define FST_CHAIN_TRACE */

// In NT kernel, we do not use it. 
/* To enable FSTAssert, define FST_DEBUG. */

/* #define FST_DEBUG */ 

/* To Set Critical Error Notification Only Mode, define FST_CRIT_ONLY. 
   in this mode, only critical error that not already detected by the rasterizer 1.7 will be checked, 
   in this mode, the error notification call-back function will not be called */
#define FST_CRIT_ONLY


/* this definition should be moved in fscdefs.h when we upgrade to rasterizer v 1.7
		FSCFG_FONTOGRAPHER_BUG

		Fontographer 3.5 has a bug. This is causing numerous symbol fonts to
		have the critical error : Inst: RCVT CVT Out of range. CVT = 255
		This flag is meant to be set under Windows. If will cause additional
		memory to be allocated for the CVT if necessary in order to be sure
		that this illegal read will access memory within the legal range.
		Under a secure rasterizer, this flag will cause RCVT with CVT <= 255
		and CVT > NumCvt to be classified as error instead of critical error */
/* #define FSCFG_FONTOGRAPHER_BUG */

/* FST_DELTA_SPECIFIC_PPEM :To be set when fstrace is used in a secure rasterizer, this will cause errors in delta commands
   to be activated only at the ppem size at which they occur,
   this will allow glyphs to be rasterized at most sizes when there is an error in a delta command */
/* #define FST_DELTA_SPECIFIC_PPEM */

/************************************************************************************/

#ifndef BOOL
typedef int BOOL;
#endif

#ifndef TRUE
#define TRUE 1
#define FALSE 0
#endif

#define NUM_PHANTOM_PTS   4L

#define NO_FUNCTION      0xffff
#define NO_INSTRUCTION   0xffff

/* Error type defines */
#define ET_CRITICAL_ERROR        0x1000
#define ET_ERROR                 0x2000
#define ET_WARNING               0x3000

/* Error defines */
#define ERR_OVERFLOW_INST_PTR            0x0001
#define ERR_STACK_OVERFLOW               0x0002
#define ERR_STACK_UNDERFLOW              0x0003
#define ERR_IF_WITHOUT_EIF               0x0004
#define ERR_ELSE_WITHOUT_IF              0x0005
#define ERR_EIF_WITHOUT_IF               0x0006
#define ERR_FDEF_WITHOUT_ENDF            0x0007
#define ERR_IDEF_WITHOUT_ENDF            0x0008
#define ERR_ENDF_EXECUTED                0x0009
#define WAR_CALL_ZERO_LEN_FUNC           0x000A
#define WAR_JMP_OFFSET_ZERO		         0x000B
#define ERR_JMP_BEFORE_BEGINNING         0x000C
#define ERR_JMP_BEYOND_2MORE_THAN_END    0x000D
#define ERR_INVALID_INSTRUCTION          0x000E
#define ERR_STORAGE_OUT_OF_RANGE         0x000F
#define ERR_CVT_OUT_OF_RANGE             0x0010
#define ERR_INVALID_ZONE                 0x0011
#define ERR_INVALID_ZONE_NO_TWI		     0x0012
#define ERR_INVALID_MAXZONES_IN_MAXP	 0x0013
#define ERR_CONTOUR_OUT_OF_RANGE		 0x0014
#define ERR_POINT_OUT_OF_RANGE           0x0015
#define ERR_ZONE_NOT_0_NOR_1             0x0016
#define ERR_PREPROGAM_ZONE_NOT_TWI       0x0017
#define WAR_MPS_ALWAYS_12_ON_WINDOWS	 0x0018
#define WAR_HI_PT_LESS_THAN_LOW_PT		 0x0019
#define ERR_FDEF_OUT_OF_RANGE			 0x001A
#define ERR_FDEF_SPACE_NOT_DEFINED		 0x001B
#define ERR_VALUE_TO_LARGE_FOR_INT16	 0x001C
#define ERR_VALUE_TO_SMALL               0x001D
#define ERR_ENDF_BEYOND_64K_OF_FDEF      0x001E
#define ERR_INVALID_ZONE_IN_IUP          0x001F
#define ERR_INVALID_STACK_ACCESS		 0x0020
#define WAR_PT_NOT_TOUCHED				 0x0022
#define ERR_MATH_OVERFLOW                0x0023
#define ERR_DIVIDE_BY_ZERO               0x0024
#define ERR_FUNCTION_NOT_DEFINED         0x0025
#define ERR_VALUE_TO_LARGE_FOR_INT8      0x0026
#define ERR_INSTR_DEFD_BY_FS             0x0027
#define ERR_EXCEEDS_INSTR_DEFS_IN_MAXP	 0x0028
#define ERR_ENDF_BEYOND_64K_OF_IDEF      0x0029
#define WAR_DEBUG_FOUND                  0x002A
#define ERR_SELECTOR_INVALID			 0x002B
#define ERR_STORE_INDEX_NOT_WRITTEN_TO	 0x002C
#define ERR_FUCOORDINATE_OUT_OF_RANGE    0x002D
#define ERR_REFPOINT_USED_BUT_NOT_SET    0x002F
#define ERR_3_USED_FOR_PERIOD            0x0030
#define ERR_NOT_CALLED_FROM_PREPROGRAM   0x0031
#define ERR_RESERVED_BIT_SET             0x0032
#define ERR_VALUE_INVALID_0_OR_1         0x0033
#define ERR_VALUE_INVALID_0_OR_2         0x0034
#define ERR_BITS_8_AND_11_SET            0x0035
#define ERR_BITS_9_AND_12_SET   		 0x0036
#define ERR_BITS_10_AND_13_SET      	 0x0037
#define WAR_SANGW_OBSELETE               0x0038
#define ERR_VALUE_OUT_OF_RANGE           0x0039
#define WAR_PF_VECTORS_AT_OR_NEAR_PERP	 0x003A
#define WAR_DELTAC_IN_GLYPH_PGM          0x003B
#define ERR_VECTOR_XY_ZERO               0x003C
#define ERR_VECTOR_XY_INVALID            0x003D
#define ERR_RP1_RP2_SAME_POS_ON_PROJ     0x003F
#define WAR_CALL_ZERO_LEN_UD_INSTR  	 0x0040
#define ERR_TWILIGHT_ZONE_PT_NOT_SET     0x0041
#define WAR_LOOP_NOT_1_AT_END_OF_PGM     0x0042
#define ERR_ELSE_WITHOUT_EIF			 0x0043
#define ERR_INVALID_FLAG    	         0x0044
#define ERR_FDEF_FOUND_IN_FDEF           0x0045
#define ERR_IDEF_FOUND_IN_FDEF			 0x0046
#define ERR_IDEF_FOUND_IN_IDEF           0x0047
#define ERR_FDEF_FOUND_IN_IDEF           0x0048
#define WAR_LOOPCALL_COUNT_LESS_THAN_ONE 0x0049
#define ERR_INST_OPCODE_TO_LARGE         0x004A
#define WAR_APPLE_ONLY_INSTR			 0x004B
#define ERR_RAW_NOT_FROM_GLYPHPGM		 0x004C
#define ERR_UNITIALIZED_ZONE		     0x004D
#ifdef __cplusplus
extern "C" {
#endif

#ifndef FST_CRIT_ONLY
/* TraceCell structure */
typedef struct
{
  /* User defined instruction we are currently in. If not in a user defined instruction, is set to
     NO_INSTRUCTION */
  unsigned short usUserDefinedInst;
  /* Function we are currently in. If not in a function, is set to NO_FUNCTION.*/
  unsigned short usFunc;
  /* Zero based offset within program or function, where problem occured. */
  long lByteOffset;
}TraceCell;

/* TraceArray structure. Provides information including complete call stack on where
   a problem occured. */
typedef struct
{
  /* Number of trace cells */
  long lNumCells;
  /* Set to TRUE if this error is generated from a composite glyph. */
  BOOL bCompositeGlyph;
  /* Set to TRUE if error is from pre-program. */
  uint16 pgmIndex;
  /* Provides 1 based loop iteration. If value is 0, instructon does not use loop variable. */
  long lLoopIteration;
  /* Call stack / Trace array. */
  TraceCell arrayTraceCell[1];
}TraceArray;

typedef TraceArray* pTraceArray;

/* Prototype for client notify function. Function is provided by client and is called by 
   FsTrace when it notices a problem. */
typedef BOOL (FST_CALLBACK *NotifyFunc)(unsigned char OpCode, unsigned short usErrorType, 
                                   unsigned short usErrorCode, char* szErrorString, pTraceArray pTA);
#endif // FST_CRIT_ONLY


/* Allocate client specific memory for a particular font. In the most likely case,this function should
   be called after fs_NewSfnt but before fs_NewTransformation. If multiple transformations are used, it does
   not need to be called for each transformation. This memory will need to be deallocated using fst_DeAllocClientData*/
BOOL fst_InitSpecificDataPointer(void ** hFSTSpecificData);

/* fst_SetCurrentSpecificDataPointer allow FSClient to access the correct specific data when the rasterizer 
   is called concurretly with different fonts. */
void fst_SetCurrentSpecificDataPointer(void * pFSTSpecificData);

/* DeAllocate client specific memory. */
BOOL fst_DeAllocClientData(void * pFSTSpecificData);


/* get the info if the grayscale flag was requested */
BOOL fst_GetGrayscaleInfoRequested (void *pFSTSpecificData);

/* The Trace function in FSTrace is called by the rasterizer prior to every TrueType instruction. This
   is where all the checking takes place. The function must be provided to the rasterizer via 
   fs_NewTransformation for the pre-program and via fs_ContourGridFit for the respective glyph program.*/
extern void FST_CALLBACK fst_CallBackFSTraceFunction(fnt_LocalGraphicStateType *, uint8 *); 

/* This function sets the client notification function. This function is provided by the client and
   is called by FsTrace when it noticed a problem. The prototype of the function is shown above.*/
#ifndef FST_CRIT_ONLY
BOOL fst_SetNotificationFunction(NotifyFunc pFunc);
#endif // FST_CRIT_ONLY

/* This is an optional function which sets a pointer to a function which is called at the end of
   CallBackFSTraceFunction if we are in the pre-program. The previous function pointer is returned.*/
#ifdef FST_CHAIN_TRACE
FntTraceFunc fst_SetPrePgmTraceChainFunction(FntTraceFunc pPrePgmFunc);

/* This is an optional function which sets a pointer to a function which is called at the end of
   CallBackFSTraceFunction if we are in a glyph program. The previous function pointer is returned.*/
FntTraceFunc fst_SetGlyfPgmTraceChainFunction(FntTraceFunc pGlyfPgmFunc);
#endif // FST_CHAIN_TRACE

#ifndef FST_CRIT_ONLY
/* A helper function that takes as input the error type code and an empty string and fills the string with
   the text that corresponds to the error type. */
BOOL fst_GetErrorTypeText(unsigned short usErrorType, char* szErrorString, unsigned short usStringSize);

/* A helper function that takes as input the OpCode and an empty string and fills the string with the text
   that corresponds to the OpCode. */
BOOL fst_GetOpCodeText(unsigned char opCode, char* szOpCodeString, unsigned short usStringSize);

/* A helper function that takes as input the error code and an empty string and fills the string with the
   text that corresponds to the error.  */
BOOL fst_GetErrorText(unsigned short usErrorCode,char* szErrorString, unsigned short usStringSize);
#endif // FST_CRIT_ONLY

#ifdef __cplusplus
}
#endif
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\fsverify\fsverify.c ===
/***************************************************************************
 * Module: FSVERIFY.C
 *
 * Copyright (c) Microsoft Corp., 1998
 *
 * Author: Paul Linnerud (paulli)
 * Date:   January 1998
 *
 * Mods: 
 *
 * Functions to verify that TrueType hint data do not contain critical errors
 * which are capable of making the system unstable. Tests are run over a set 
 * of sizes and transforms. 
 *
 **************************************************************************/ 
#include <windows.h>
#include "fsverify.h"

// rasterizer includes
#include "fscdefs.h"
#include "sfnt.h"
#include "fscaler.h"
#include "sfntoff.h"
#include "fserror.h"

// fstrace include
#include "fstrace.h"

/* defines */
#define SIGN(a)         ((a)<0 ? -1 : 1)
#define ABS(a)          ((a) < 0 ? -(a) : (a))
#define ROUND_FIXPT(fx) ( (short) ( SIGN(fx) * (ONEFIX/2+ABS(fx)) / ONEFIX ) )
#define LONG_TO_FIXED(l)((Fixed)(l) << 16)
#define FIXED_TO_LONG(f)((long)(f) >> 16)

#define PRIVATE		static
#define TTC_TAG		0x74746366
#define VER_ONE		0x00010000
#define VER_TWO		0x00020000
#define VER_TRUE	0x74727565
#define OTTO_TAG	0x4f54544f	

// fsverify configuration
#include "fsvconfg.h"

typedef struct                          /* Client Data for a single job */
{
	fs_GlyphInputType in;               /* Client interface input */
	fs_GlyphInfoType out;               /* Client interface output */
	transMatrix mat;                    /* Client Matrix Transform */
	LPBYTE lpbTTFFile;
	DWORD dwFileSize;
	long lPointSize;
	USHORT usNumGlyphs;
	BOOL bTTC;
	ULONG ulTTCIndex;
	ULONG ulTableDirSize;
	long lLastError;
} CLIENTDATA, *PCLIENTDATA;

/* Private functions declarations */

PRIVATE fsverror SetTTCValues(PCLIENTDATA pCli, unsigned long ulTTCIndex);
PRIVATE fsverror Execute_Transformation(PCLIENTDATA pCli);
PRIVATE unsigned short GetNumGlyphs(PCLIENTDATA pCli);
PRIVATE ULONG GetOffsetToTable(PCLIENTDATA pCli,ULONG ulWantedTable);
BOOL GetTableData(PCLIENTDATA pCli, ULONG ulOffsetToTable, long lDataOffset, long lSize, BOOL bSwap, void* pvData);
void* FS_CALLBACK_PROTO CallbackGetSfntFragment (ClientIDType, long, long);
void FS_CALLBACK_PROTO CallbackReleaseSfntFragment (void*);
PRIVATE BOOL NewClientData (CLIENTDATA *pCli,size_t, size_t);	
PRIVATE void FreeClientData(CLIENTDATA *pCli,size_t iLo, size_t iHi);
PRIVATE void* fsvMalloc (size_t cb);
PRIVATE void fsvFree (void* pv);	 

/* Public functions implementations */

fsverror fsv_VerifyImage(unsigned char* pucImage, unsigned long ulImageSize, unsigned long ulTTCIndex, 
						 PFSVTESTPARAM pfsvTestParam)
{
	CLIENTDATA cdCli;
	fsverror errOut = FSV_E_NONE;
	int32 lCode;
	long lSize, lSizeFrom, lSizeTo;
	void *pFsTraceSpecificData;
	FSVTESTPARAM fsvDefaultParam;
	PFSVTESTPARAM pfsvInternalParam;

	if(pfsvTestParam == NULL)
	{
		fsvDefaultParam.ulTest1Flags = FSV_USE_DEFAULT_SIZE_SETTINGS;
		fsvDefaultParam.ulTest2Flags = FSV_USE_DEFAULT_SIZE_SETTINGS;
		fsvDefaultParam.ulTest3Flags = FSV_USE_DEFAULT_SIZE_SETTINGS;
		pfsvInternalParam = &fsvDefaultParam;	
	}else
	{
		pfsvInternalParam = pfsvTestParam;
	}

	memset(&cdCli,0,sizeof(cdCli));

	cdCli.lpbTTFFile = pucImage;
	cdCli.dwFileSize = ulImageSize;

	errOut = SetTTCValues(&cdCli,ulTTCIndex);
	if(errOut != FSV_E_NONE)
		return errOut;

	cdCli.usNumGlyphs = GetNumGlyphs(&cdCli);	

	__try
	{
		lCode = fs_OpenFonts(&cdCli.in,&cdCli.out);
		if(lCode != 0)
			errOut = FSV_E_FS_ERROR;		
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{     
		errOut = FSV_E_FS_EXCEPTION;
	} 

	if(errOut != FSV_E_NONE)
		return errOut;
	  
	if(!NewClientData(&cdCli,0,2))
	{
		errOut = FSV_E_NO_MEMORY;
		fs_CloseFonts(&cdCli.in,&cdCli.out);
		return errOut;
	}

	__try
	{
		lCode = fs_Initialize(&cdCli.in,&cdCli.out);
		if(lCode != 0)
			errOut = FSV_E_FS_ERROR;		
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{     
		errOut = FSV_E_FS_EXCEPTION;
	} 

	if(errOut != FSV_E_NONE)
	{ 		
		fs_CloseFonts(&cdCli.in,&cdCli.out);
		FreeClientData(&cdCli,0,2);
		return errOut;
	}
  
	cdCli.in.clientID = (ClientIDType)(&cdCli); 
	cdCli.in.param.newsfnt.platformID = PLATFORM_ID;
	cdCli.in.param.newsfnt.specificID = ENCODING_ID;
	cdCli.in.GetSfntFragmentPtr = CallbackGetSfntFragment;
	cdCli.in.ReleaseSfntFrag = CallbackReleaseSfntFragment;
	cdCli.in.sfntDirectory = NULL;

	 /* Need exception handler because fs_NewSfnt may fault if the TTF file
		 is corrupt */									
	__try
	{ 
  		lCode = fs_NewSfnt (&cdCli.in,&cdCli.out);
		if(lCode != 0)
			errOut = FSV_E_FS_ERROR;		
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{     
		errOut = FSV_E_FS_EXCEPTION;
	} 

	if(errOut != FSV_E_NONE)
	{ 		
		fs_CloseFonts(&cdCli.in,&cdCli.out);
		FreeClientData(&cdCli,0,2);
		return errOut;
	}

	if(!NewClientData (&cdCli,3,4))
	{
		errOut = FSV_E_NO_MEMORY;		
		fs_CloseFonts(&cdCli.in,&cdCli.out);
		FreeClientData(&cdCli,0,2);
		return errOut;
	}

	if(!fst_InitSpecificDataPointer(&pFsTraceSpecificData))
	{
		errOut = FSV_E_FSTRACE_INIT_FAIL;		
		fs_CloseFonts(&cdCli.in,&cdCli.out);
		FreeClientData(&cdCli,0,4);
		return errOut;
	}

	/* test set 1 */     	
	if(pfsvInternalParam->ulTest1Flags & FSV_USE_DEFAULT_SIZE_SETTINGS)
	{
		lSizeFrom = CHECK_FROM_SIZE_1;
		lSizeTo = CHECK_TO_SIZE_1;
	}
	else
	{
		lSizeFrom = pfsvInternalParam->lTest1From;
		lSizeTo = pfsvInternalParam->lTest1To;
	}

	for(lSize = lSizeFrom; lSize <= lSizeTo; lSize++)
	{
		cdCli.mat.transform[0][0] = MAT1_0_0;	
		cdCli.mat.transform[0][1] = MAT1_0_1;	
		cdCli.mat.transform[0][2] = MAT1_0_2;	
		cdCli.mat.transform[1][0] = MAT1_1_0;	
		cdCli.mat.transform[1][1] = MAT1_1_1;	
		cdCli.mat.transform[1][2] = MAT1_1_2;	
		cdCli.mat.transform[2][0] = MAT1_2_0;	
		cdCli.mat.transform[2][1] = MAT1_2_1;	
		cdCli.mat.transform[2][2] = MAT1_2_2;
		
		cdCli.in.param.newtrans.pointSize = LONG_TO_FIXED(lSize);
		cdCli.in.param.newtrans.usOverScale = OVER_SCALE_1;
		cdCli.in.param.newtrans.xResolution = XRES;             
		cdCli.in.param.newtrans.yResolution = YRES;
		cdCli.in.param.newtrans.pixelDiameter = FIXEDSQRT2;
		cdCli.in.param.newtrans.transformMatrix = &cdCli.mat;   
		cdCli.in.param.newtrans.traceFunc = fst_CallBackFSTraceFunction; 

		errOut = Execute_Transformation(&cdCli);
		if(errOut != FSV_E_NONE)
		{			
			fs_CloseFonts(&cdCli.in,&cdCli.out);
			FreeClientData(&cdCli,0,4);
			return errOut;
		}
	}
	
	/* test set 2 */
	if(fst_GetGrayscaleInfoRequested(pFsTraceSpecificData))
	{
		if(pfsvInternalParam->ulTest2Flags & FSV_USE_DEFAULT_SIZE_SETTINGS)
		{
			lSizeFrom = CHECK_FROM_SIZE_2;
			lSizeTo = CHECK_TO_SIZE_2;
		}
		else
		{
			lSizeFrom = pfsvInternalParam->lTest2From;
			lSizeTo = pfsvInternalParam->lTest2To;
		}

	    for(lSize = lSizeFrom; lSize <= lSizeTo; lSize++)
	    {
			cdCli.mat.transform[0][0] = MAT2_0_0;	
			cdCli.mat.transform[0][1] = MAT2_0_1;	
			cdCli.mat.transform[0][2] = MAT2_0_2;	
			cdCli.mat.transform[1][0] = MAT2_1_0;	
			cdCli.mat.transform[1][1] = MAT2_1_1;	
			cdCli.mat.transform[1][2] = MAT2_1_2;	
			cdCli.mat.transform[2][0] = MAT2_2_0;	
			cdCli.mat.transform[2][1] = MAT2_2_1;	
			cdCli.mat.transform[2][2] = MAT2_2_2;
			
		    cdCli.in.param.newtrans.pointSize = LONG_TO_FIXED(lSize);
			cdCli.in.param.newtrans.usOverScale = OVER_SCALE_2;
			cdCli.in.param.newtrans.xResolution = XRES;             
			cdCli.in.param.newtrans.yResolution = YRES;
			cdCli.in.param.newtrans.pixelDiameter = FIXEDSQRT2;
			cdCli.in.param.newtrans.transformMatrix = &cdCli.mat;   
			cdCli.in.param.newtrans.traceFunc = fst_CallBackFSTraceFunction; 

		    errOut = Execute_Transformation(&cdCli);
		    if(errOut != FSV_E_NONE)
		    {
			    fs_CloseFonts(&cdCli.in,&cdCli.out);
			    FreeClientData(&cdCli,0,4);
			    return errOut;
		    }
	    }
    }
	
	/* test set 3 */
	if(pfsvInternalParam->ulTest3Flags & FSV_USE_DEFAULT_SIZE_SETTINGS)
	{
		lSizeFrom = CHECK_FROM_SIZE_3;
		lSizeTo = CHECK_TO_SIZE_3;
	}
	else
	{
		lSizeFrom = pfsvInternalParam->lTest3From;
		lSizeTo = pfsvInternalParam->lTest3To;
	}

	for(lSize = lSizeFrom; lSize <= lSizeTo; lSize++)
	{
		cdCli.mat.transform[0][0] = MAT3_0_0;	
		cdCli.mat.transform[0][1] = MAT3_0_1;	
		cdCli.mat.transform[0][2] = MAT3_0_2;	
		cdCli.mat.transform[1][0] = MAT3_1_0;	
		cdCli.mat.transform[1][1] = MAT3_1_1;	
		cdCli.mat.transform[1][2] = MAT3_1_2;	
		cdCli.mat.transform[2][0] = MAT3_2_0;	
		cdCli.mat.transform[2][1] = MAT3_2_1;	
		cdCli.mat.transform[2][2] = MAT3_2_2;	

		cdCli.in.param.newtrans.pointSize = LONG_TO_FIXED(lSize);
		cdCli.in.param.newtrans.usOverScale = OVER_SCALE_3;
		cdCli.in.param.newtrans.xResolution = XRES;             
		cdCli.in.param.newtrans.yResolution = YRES;
		cdCli.in.param.newtrans.pixelDiameter = FIXEDSQRT2;
		cdCli.in.param.newtrans.transformMatrix = &cdCli.mat;   
		cdCli.in.param.newtrans.traceFunc = fst_CallBackFSTraceFunction;
		
		errOut = Execute_Transformation(&cdCli);
		if(errOut != FSV_E_NONE)
		{
			fs_CloseFonts(&cdCli.in,&cdCli.out);
			FreeClientData(&cdCli,0,4);
			return errOut;
		}
	}	

	fst_DeAllocClientData(pFsTraceSpecificData);

	fs_CloseFonts(&cdCli.in,&cdCli.out);
	FreeClientData(&cdCli,0,4);

	return errOut;
}

/* Private functions implementations*/

PRIVATE fsverror SetTTCValues(PCLIENTDATA pCli, unsigned long ulTTCIndex)
{
	ULONG ulTag;
	fsverror errOut = FSV_E_NONE;

	ulTag = SWAPL(*(pCli->lpbTTFFile));
  
	if(ulTag == TTC_TAG)
	{		
		ULONG ulOffsetToDirTable;
		USHORT usNumTables;
		ULONG ulDirCount = SWAPL(*(pCli->lpbTTFFile + 8));
		
		pCli->bTTC = TRUE;  
		pCli->ulTTCIndex = ulTTCIndex;	 
	
		if(pCli->ulTTCIndex > ulDirCount - 1)
		{
			errOut = FSV_E_INVALID_TTC_INDEX;
		}else
		{
			ulOffsetToDirTable = SWAPL(*(pCli->lpbTTFFile + 12 + pCli->ulTTCIndex * 4));
			usNumTables = SWAPW(*(pCli->lpbTTFFile + ulOffsetToDirTable + 4));
			pCli->ulTableDirSize = usNumTables * SIZEOF_SFNT_DIRECTORYENTRY + SIZEOF_SFNT_OFFSETTABLE;
		}
	}else 
	{
		pCli->bTTC = FALSE;	
	}

	return errOut;
}

PRIVATE fsverror Execute_Transformation(PCLIENTDATA pCli)
{
	fsverror errOut = FSV_E_NONE;
	unsigned short usCurIdx;
	int32 lCode;	

	__try
	{
		lCode = fs_NewTransformation (&pCli->in,&pCli->out);
		if(lCode != 0)
		{			
			if(lCode == UNDEFINED_INSTRUCTION_ERR)
				errOut = FSV_E_FS_BAD_INSTRUCTION;
			else
				errOut = FSV_E_FS_ERROR;
		}
	}
	__except(EXCEPTION_EXECUTE_HANDLER)
	{     
		errOut = FSV_E_FS_EXCEPTION;
	} 

	if(errOut != FSV_E_NONE)
		return errOut;
		
	for(usCurIdx = 0; usCurIdx < pCli->usNumGlyphs; usCurIdx++)
	{     
		pCli->in.param.newglyph.characterCode = 0xFFFF;
		pCli->in.param.newglyph.glyphIndex = usCurIdx;
		pCli->in.param.newglyph.bMatchBBox = FALSE;   
		pCli->in.param.newglyph.bNoEmbeddedBitmap = TRUE;   

		__try
		{
			lCode = fs_NewGlyph (&pCli->in,&pCli->out);
			if(lCode != 0)
				errOut = FSV_E_FS_ERROR;			
		}
		__except(EXCEPTION_EXECUTE_HANDLER)
		{     
			errOut = FSV_E_FS_EXCEPTION;
		} 

		if(errOut != FSV_E_NONE)
			return errOut;		
		
		pCli->in.param.gridfit.styleFunc = NULL;
		pCli->in.param.gridfit.traceFunc = fst_CallBackFSTraceFunction;	
		pCli->in.param.gridfit.bSkipIfBitmap = FALSE;   
      	   
		__try
		{
			lCode = fs_ContourGridFit(&pCli->in,&pCli->out);
			if(lCode != 0)
			{
				if(lCode == UNDEFINED_INSTRUCTION_ERR)
					errOut = FSV_E_FS_BAD_INSTRUCTION;
				else
					errOut = FSV_E_FS_ERROR;
			}
		}
		__except(EXCEPTION_EXECUTE_HANDLER)
		{     
			errOut = FSV_E_FS_EXCEPTION;
		} 

		if(errOut != FSV_E_NONE)
			return errOut;		
	}

	return errOut;
}

PRIVATE unsigned short GetNumGlyphs(PCLIENTDATA pCli)
{  /*
   Function to get number of glyphs in the font. It accomplishes this by going in the maxp
   table and getting value of the numGlyphs field.
   */
   ULONG ulOffsetTomaxp;   
   USHORT usNumGlyphs;

   if(pCli == NULL)
     return 0;

   ulOffsetTomaxp = GetOffsetToTable(pCli,tag_MaxProfile);
   if(ulOffsetTomaxp == 0)
     return 0;
   
   if(!GetTableData(pCli,ulOffsetTomaxp,4,2,TRUE,&usNumGlyphs))
	 return 0;
	 
   return usNumGlyphs; 
}

PRIVATE ULONG GetOffsetToTable(PCLIENTDATA pCli,ULONG ulWantedTable)
{  /*
   Function returns the offset in a font file to the specified table.

   Function assumes the CallbackGetSfntFragment is implemented using memory we do need need to free; 
   Hence, CallbackReleaseSfntFragment is not called. 
   */   
   ULONG ulIndex = 4;
   USHORT usNumTables; 
   ULONG ulOffsetToTable;
   void* pvCallbackResult;
   USHORT usTablesLookedAt = 0;
   	
   if(pCli == NULL)
     return 0;   
   
   pvCallbackResult = CallbackGetSfntFragment((ClientIDType)pCli,ulIndex,2);
   if (pvCallbackResult == NULL)
     return 0;
  
   usNumTables = SWAPW(*(USHORT*)pvCallbackResult);
   
   ulIndex += 8;
   do
   { 
	 if(usTablesLookedAt >= usNumTables)
	   return 0;

	 usTablesLookedAt = usTablesLookedAt + 1;

	 pvCallbackResult = CallbackGetSfntFragment((ClientIDType)pCli,ulIndex,4); 
	 if (pvCallbackResult == NULL)
       return 0;
       	 
	 ulIndex = ulIndex + 16;
	 
   }while(SWAPL(*(ULONG*)pvCallbackResult) != (int32)ulWantedTable ); 

   ulIndex = ulIndex - 16; 
   ulIndex = ulIndex + 8; 

   pvCallbackResult = CallbackGetSfntFragment((ClientIDType)pCli,ulIndex,4); 
   if (pvCallbackResult == NULL)
     return 0;
   
   ulOffsetToTable = SWAPL(*(ULONG*)pvCallbackResult);

   return ulOffsetToTable; 
}

BOOL GetTableData(PCLIENTDATA pCli, ULONG ulOffsetToTable, long lDataOffset, long lSize, BOOL bSwap,
                    void* pvData)
{  /* Function gets font file data in a table given the offset to the table and the offset
      to the data in the table. If the data is 2 or 4 bytes, function can also swap the byte 
	  ordering	  
   */   
   void* pvCallbackResult;
   
   if(pCli == NULL)
     return FALSE;   

   pvCallbackResult = CallbackGetSfntFragment((ClientIDType)pCli,ulOffsetToTable + lDataOffset,lSize);
   if (pvCallbackResult == NULL)
     return FALSE;

   switch(lSize)
   {
	 case 1:
	 { 		    
	   *(BYTE*)pvData = *(BYTE*)pvCallbackResult;
	   break;
	 }

	 case 2:
	 {
	   if(bSwap)
	     *(USHORT*)pvData = SWAPW(*(USHORT*)pvCallbackResult);
	   else
	     *(USHORT*)pvData = *(USHORT*)pvCallbackResult;
	   break;
	 }

	 case 4:
	 {
	   if(bSwap)
	     *(ULONG*)pvData = SWAPL(*(ULONG*)pvCallbackResult);
	   else
	     *(ULONG*)pvData = *(ULONG*)pvCallbackResult;
	   break;
	 }

	 default:
	 {
	   memcpy(pvData,pvCallbackResult,lSize);
	   break;
	 }
   }  

   return TRUE;
}

/* low level font data access callbacks */

void* FS_CALLBACK_PROTO CallbackGetSfntFragment (ClientIDType lClient, long lOff, long lSize)
{
	CLIENTDATA *pCli = (CLIENTDATA*) lClient;

	if((long)(size_t)lSize != lSize)
	  return NULL;

	if(pCli->bTTC)
	{
	  unsigned long ulOffsetToDirTable;
	 
	  if(lOff < (long)pCli->ulTableDirSize)
	  {	 
	    ulOffsetToDirTable = SWAPL(*(pCli->lpbTTFFile + 12 + pCli->ulTTCIndex * 4));
	    lOff += ulOffsetToDirTable;
	  }	  
	}

	if((DWORD)(lOff + lSize) > pCli->dwFileSize)
	  return NULL;

	return (PVOID)(pCli->lpbTTFFile + lOff);
}

void FS_CALLBACK_PROTO CallbackReleaseSfntFragment (void* pv)
{
    //We do not need anything here since our image if from client.	
}

/* memory functions */

PRIVATE BOOL NewClientData (CLIENTDATA *pCli, size_t iLo, size_t iHi)
{
	size_t i, cbBuf;

	for (i=iLo;  i<=iHi;  i++)
	{
		if  (pCli->out.memorySizes[i] == 0)
		{
			pCli->in.memoryBases[i] = NULL;
		}
		else
		{
			cbBuf = (size_t) pCli->out.memorySizes[i];			

			pCli->in.memoryBases[i] = fsvMalloc(cbBuf);
			if(pCli->in.memoryBases[i] == NULL)
				return FALSE;			
		}
	}

	return TRUE;
}

PRIVATE void FreeClientData(CLIENTDATA *pCli, size_t iLo, size_t iHi)
{
   size_t i;

   for (i=iLo; i<=iHi; i++)
   {
	 if(pCli->in.memoryBases[i] != NULL)
	   fsvFree(pCli->in.memoryBases[i]);
   }

}

PRIVATE void* fsvMalloc (size_t cb)
{
	if  (cb == 0)
		return NULL;

	return HeapAlloc(GetProcessHeap(),HEAP_ZERO_MEMORY,cb);
}

PRIVATE void fsvFree (void* pv)
{
    HeapFree(GetProcessHeap(),0,pv);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\fsverify\fsvtst.c ===
#include <windows.h>
#include <stdio.h>
#include "fsverify.h"

void main( int argc, char *argv[] )
{
	char szFile[MAX_PATH];
	HANDLE hTTFFile;
	HANDLE hTTFFileMap;
	LPBYTE lpbTTFFile;
	DWORD dwFileSize;
	fsverror err;

	if(argc != 2)
	{
		printf("Need some input \n\r");
		return;
	}

	lstrcpy(szFile,argv[1]);

	hTTFFile = CreateFile (szFile,
		                   GENERIC_READ,
						   FILE_SHARE_READ,
						   (LPSECURITY_ATTRIBUTES)NULL,
						   OPEN_EXISTING,
						   FILE_ATTRIBUTE_NORMAL,
						   (HANDLE)NULL);  
	if(hTTFFile ==  INVALID_HANDLE_VALUE)
	{
		printf("Can't open file \n\r");
		return; 
	}

	/* Get TTF file size. */
	dwFileSize = GetFileSize(hTTFFile,0);

	hTTFFileMap = CreateFileMapping(hTTFFile,NULL,PAGE_READONLY,0,dwFileSize,NULL);  
	if(hTTFFileMap == NULL)
	{
		printf("Can't map file \n\r");
		CloseHandle(hTTFFile);		 
		return;
	}

	lpbTTFFile = MapViewOfFile(hTTFFileMap,FILE_MAP_READ,0,0,0);	 
	if(lpbTTFFile == NULL)
	{
		printf("Can't map view of file \n\r");
		CloseHandle(hTTFFileMap);
		CloseHandle(hTTFFile); 		 
		return;
	}

	err = fsv_VerifyImage(lpbTTFFile, dwFileSize, 0, NULL);
	if(err != FSV_E_NONE)
		printf("BAAAAAD FONT!!! \n\r");

	UnmapViewOfFile(lpbTTFFile);
	CloseHandle(hTTFFileMap);
	CloseHandle(hTTFFile);
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\sign\cryptutil.cpp ===
//
// cryptutil.cpp
//
// (c) 1997-1998. Microsoft Corporation.
// Author: Donald Chinn
//
// Utilities related to cryptographic operations.
//
// Functions in this file:
//   GetHashValueSize
//   GetAlgHashValueSize
//

#include "cryptutil.h"
#include "signerr.h"

//
// Given a hash value, return the number of bytes of
// of the hash value in pcbHashValue.  
// (Typically, this will be either 16 or 20 bytes.)
// For MD5, the hash value length is 16 bytes.
//
HRESULT GetHashValueSize (HCRYPTHASH hHash, USHORT *pcbHashValue)
{
    DWORD cbDigest = 0;

	// Get the hash value size.
    if (!CryptGetHashParam(hHash, HP_HASHVAL, NULL, &cbDigest, 0)) {
#if MSSIPOTF_ERROR
		    SignError ("Cannot continue: Error during CryptGetHashParam (hash size).", NULL, TRUE);
#endif
		    return MSSIPOTF_E_CRYPT;
	} else {
#if MSSIPOTF_DBG
            DbgPrintf ("hash value size = %d.\n", cbDigest);
#endif
		    *pcbHashValue = (USHORT) cbDigest;
		    return S_OK;
	}
}


//
// Given a hash algorithm, return the size of its hash value.
//
HRESULT GetAlgHashValueSize (ALG_ID usHashAlg, USHORT *pcbHashValue)
{
	HCRYPTPROV hProv;
	HCRYPTHASH hHash;
	BOOL fReturn;


	// Set hProv to point to a cryptographic context of the default CSP.
	if (!CryptAcquireContext (&hProv, NULL, MS_DEF_PROV, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
#if MSSIPOTF_ERROR
		SignError ("Cannot continue: Error during CryptAcquireContext.", NULL, TRUE);
#endif
		fReturn = MSSIPOTF_E_CRYPT;
		goto done;
	}

	// Create a hash object
	if (!CryptCreateHash (hProv, usHashAlg, 0, 0, &hHash)) {
#if MSSIPOTF_ERROR
		SignError ("Cannot continue: Error during CryptCreateHash.",
            "GetAlghashValueSize", TRUE);
#endif
		fReturn = MSSIPOTF_E_CRYPT;
		goto done;
	}

	// Pass the hash object to GetHashValueSize
	if ((fReturn = GetHashValueSize (hHash, pcbHashValue)) != NO_ERROR) {
#if MSSIPOTF_DBG
		DbgPrintf ("Error during GetHashValueSize.\n");
#endif
		goto done;
	}

	fReturn = S_OK;

done:
	// Free resources
	if (hProv)
		CryptReleaseContext(hProv, 0);

	if (hHash)
		CryptDestroyHash (hHash);

	return fReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\sign\cryptutil.h ===
//
// cryptutil.h
//
// (c) 1997-1998. Microsoft Corporation.
// Author: Donald Chinn
//
// Functions exported:
//   GetHashValueSize
//   GetAlgHashValueSize
//

#ifndef _CRYPTUTIL_H
#define _CRYPTUTIL_H


#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x400
#endif

#include <windows.h>
#include <wincrypt.h>

#include "signglobal.h"


// hash algorithm used throughout the signing and verification process
// BUGBUG: THIS IS A TREMENDOUS HACK -- the client will always provide
// the hash algorithm.  This is only used for testing!
#define DSIG_HASH_ALG CALG_MD5

HRESULT GetHashValueSize (HCRYPTHASH hHash, USHORT *pcbHashValue);

HRESULT GetAlgHashValueSize (ALG_ID usHashAlg, USHORT *pcbHashValue);

#endif // _CRYPTUTIL_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\sign\dsigtable.h ===
//
// dsigTable.h
//
// (c) 1997-1998. Microsoft Corporation.
// Author: Donald Chinn
//
// Classes defined:
//   CDsigInfo
//   CDsigSig
//   CDsigSigF1
//   CDsigSigF2
//   CDsigSignature
//   CDsigTable
//



#ifndef _DSIGTABLE_H
#define _DSIGTABLE_H


#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x400
#endif

#include <windows.h>
#include <wincrypt.h>

#include "signglobal.h"

#include "subset.h"


// DSIG table tag for the offset table
#define DSIG_TAG "DSIG"
#define DSIG_LONG_TAG 0x44534947

// version number for the DSIG table
#define DSIG_TABLE_VERSION1 1
#define DSIG_TABLE_CURRENT_VERSION DSIG_TABLE_VERSION1

// default flag field in the DSIG table
// FLAG_RADIX should be number of values in a USHORT
#define FS_TRACE_FLAG          0x02
#define FLAG_RADIX             256
#define DSIG_DEFAULT_FLAG_HIGH 0
#define DSIG_DEFAULT_FLAG_LOW  1

// Size of the DsigSignatureHeader
#define SIZEOF_DSIGSIGNATUREHEADER 12

// Format numbers in DsigSignatureHeader
#define DSIGSIG_ANY_FORMAT 0
#define DSIGSIG_FORMAT1 1
#define DSIGSIG_FORMAT2 2

// Default format for OTFs
#define DSIGSIG_DEF_FORMAT  DSIGSIG_FORMAT1

// Default format for TTCs
#define DSIGSIG_TTC_DEF_FORMAT  DSIGSIG_FORMAT1

// version number for the dsigInfo structure in DSIGSIG Format 2
#define DSIGINFO_VERSION1 1
#define DSIGINFO_CURRENT_VERSION DSIGINFO_VERSION1

// offsets for DsigSig
#define DSIGSIGF2_DSIGINFOOFFSET 8

// index of a non-existent signature; to be used as an
// argument to a function that requires a signature index
// number, but you want to refer to a non-existent signature
#define NO_SIGNATURE 0xFFFF


class CDsigInfo {
public:
	int Alloc();
	CDsigInfo ();
    CDsigInfo (ALG_ID ulHashAlg);
	~CDsigInfo ();
	CDsigInfo (const CDsigInfo& in);
	CDsigInfo& operator= (const CDsigInfo& in);

	HRESULT Read (TTFACC_FILEBUFFERINFO *pFileBufferInfo, ULONG *pulOffset);
	HRESULT Write (TTFACC_FILEBUFFERINFO *pOutputFileBufferInfo, ULONG *pulOffset);
	void Print ();
	HRESULT GetSize (ULONG *pulDsigInfoSize);

	// access functions
	ULONG GetVersion ();
	void SetVersion (ULONG ulVersion);
    ALG_ID GetHashAlgorithm ();
    void SetHashAlgorithm (ALG_ID usHashAlgorithm);
	ULONG GetNumMissingGlyphs ();
	void SetNumMissingGlyphs (ULONG ulNumMissingGlyphs);
	BYTE *GetMissingGlyphs ();
	void SetMissingGlyphs (BYTE *pbMissingGlyphs);


private:
	ULONG ulVersion;           // version of the DsigInfo
    ALG_ID usHashAlgorithm;    // hash algorithm used in the tree of hashes
    USHORT usHashValueLength;  // length (in bytes) of the hash value
	ULONG ulNumMissingGlyphs;  // number of missing hash values for the glyph tree of hashes
	BYTE *pbMissingGlyphs;
	ULONG ulNumMissingEBLC;    // either 0 or 1.  Is 1 iff the entire EBLC disappears
                               // after subsetting.
	BYTE *pbMissingEBLC;
	ULONG ulNumMissingNames;   // number of missing hash values for the name table
	BYTE *pbMissingNames;
	ULONG ulNumMissingPost;    // number of missing hash values for the post table
	BYTE *pbMissingPost;
	USHORT usNumMissingVDMX;    // number of missing hash values for the VDMX table
	USHORT usMissingVDMXFlags;  // indicates which VDMX tables are missing
	BYTE *pbMissingVDMX;
};

// CDsigSig: an abstract class used to define DsigSig's of the
// various formats.
class CDsigSig {
public:
	virtual HRESULT Read (TTFACC_FILEBUFFERINFO *pFileBufferInfo,
                          ULONG *pulOffset,
                          ULONG cbDsigSig) = 0;
	virtual HRESULT Write (TTFACC_FILEBUFFERINFO *pOutputFileBufferInfo,
		    			   ULONG *pulOffset) = 0;
	virtual void Print () = 0;
	virtual HRESULT GetSize (ULONG *pulDsigSigSize) = 0;
	virtual HRESULT GetNonSignatureSize(ULONG *pulSize) = 0;
	virtual HRESULT HashTTFfile (TTFACC_FILEBUFFERINFO *pFileBufferInfo,
                                 BYTE **ppbHashTopLevel,
                                 DWORD *pcbHashTopLevel,
                                 HCRYPTPROV hProv,
                                 ALG_ID alg_id,
                                 ULONG cbDsig,
                                 BYTE *pbDsig) = 0;

    virtual HRESULT HashTTCfile (TTFACC_FILEBUFFERINFO *pFileBufferInfo,
                                 BYTE **ppbHashTopLevel,
                                 DWORD *pcbHashTopLevel,
                                 HCRYPTPROV hProv,
                                 ALG_ID alg_id,
                                 ULONG cbDsig,
                                 BYTE *pbDsig) = 0;

    // access functions
	virtual ULONG GetSignatureSize () {return cbSignature;};
	virtual BYTE *GetSignature () {return pbSignature;};
	virtual void SetSignature (BYTE *pbSignature, ULONG cbSignature) {
		this->pbSignature = pbSignature;
		this->cbSignature = cbSignature;
		};

protected:
	ULONG cbSignature;
	BYTE *pbSignature;
};


class CDsigSigF1 : public CDsigSig {
public:
	CDsigSigF1 ();
	~CDsigSigF1 ();

	virtual HRESULT Read (TTFACC_FILEBUFFERINFO *pFileBufferInfo,
                          ULONG *pulOffset,
                          ULONG cbDsigSig);
	virtual HRESULT Write (TTFACC_FILEBUFFERINFO *pOutputFileBufferInfo,
                           ULONG *pulOffset);
	virtual void Print ();
	virtual HRESULT GetSize (ULONG *pulDsigSigSize);
	virtual HRESULT GetNonSignatureSize(ULONG *pulSize);
	virtual HRESULT HashTTFfile (TTFACC_FILEBUFFERINFO *pFileBufferInfo,
                                 BYTE **ppbHashTopLevel,
                                 DWORD *pcbHashTopLevel,
                                 HCRYPTPROV hProv,
                                 ALG_ID alg_id,
                                 ULONG cbDsig,
                                 BYTE *pbDsig);

    virtual HRESULT HashTTCfile (TTFACC_FILEBUFFERINFO *pFileBufferInfo,
                                 BYTE **ppbHashTopLevel,
                                 DWORD *pcbHashTopLevel,
                                 HCRYPTPROV hProv,
                                 ALG_ID alg_id,
                                 ULONG cbDsig,
                                 BYTE *pbDsig);

private:
	USHORT usReserved1;
	USHORT usReserved2;
};


class CDsigSigF2 : public CDsigSig {
public:
	CDsigSigF2 ();
    CDsigSigF2 (ALG_ID ulHashAlg);
	~CDsigSigF2 ();

	virtual HRESULT Read (TTFACC_FILEBUFFERINFO *pFileBufferInfo,
                          ULONG *pulOffset,
                          ULONG cbDsigSig);
	virtual HRESULT Write (TTFACC_FILEBUFFERINFO *pOutputFileBufferInfo,
                           ULONG *pulOffset);
	virtual void Print ();
	virtual HRESULT GetSize (ULONG *pulDsigSigSize);
	virtual HRESULT GetNonSignatureSize(ULONG *pulSize);
	virtual HRESULT HashTTFfile (TTFACC_FILEBUFFERINFO *pFileBufferInfo,
		    					 BYTE **ppbHashTopLevel,
                                 DWORD *pcbHashTopLevel,
                                 HCRYPTPROV hProv,
                                 ALG_ID alg_id,
                                 ULONG cbDsig,
                                 BYTE *pbDsig);

    virtual HRESULT HashTTCfile (TTFACC_FILEBUFFERINFO *pFileBufferInfo,
                                 BYTE **ppbHashTopLevel,
                                 DWORD *pcbHashTopLevel,
                                 HCRYPTPROV hProv,
                                 ALG_ID alg_id,
                                 ULONG cbDsig,
                                 BYTE *pbDsig);

    ALG_ID GetHashAlgorithm ();

	// access functions
	ULONG GetSignatureOffset ();
	void SetSignatureOffset (ULONG ulSignatureOffset);
	CDsigInfo *GetDsigInfo ();
	void SetDsigInfo (CDsigInfo *pDsigInfo);

private:
	ULONG ulDsigInfoOffset;
	ULONG ulSignatureOffset;
    // if cbDsigInfo == 0, then the CDsigInfo object is invalid,
    // even if pDsigInfo points to an actual CDSigInfo object.
    ULONG cbDsigInfo;
	CDsigInfo *pDsigInfo;
};

// CDsigSignature: consists of a header and a DsigSig.  The DsigSig
// can be one of many types.  Currently, we have Format 1 and Format 2
// (DsigSigF1 and DsigSigF2, respectively).
class CDsigSignature {
public:
    CDsigSignature ();
    CDsigSignature (ULONG ulDsigSigFormat);
    ~CDsigSignature ();

    HRESULT ReadHeader (TTFACC_FILEBUFFERINFO *pFileBufferInfo, ULONG *pulOffset);
    HRESULT WriteHeader (TTFACC_FILEBUFFERINFO *pOutputFileBufferInfo, ULONG *pulOffset);
    HRESULT ReadDsigSig (TTFACC_FILEBUFFERINFO *pFileBufferInfo,
                         ULONG *pulOffset,
                         ULONG cbDsigSignature);
    HRESULT WriteDsigSig (TTFACC_FILEBUFFERINFO *pOutputFileBufferInfo,
                          ULONG *pulOffset);
    void Print ();
    HRESULT GetSize (ULONG *pulDsigSignatureSize);
    HRESULT GetSignatureSize (ULONG *pulSignatureSize);

	// access functions
	ULONG GetFormat ();
	void SetFormat (ULONG ulFormat);
	ULONG GetLength ();
	void SetLength (ULONG ulLength);
	ULONG GetOffset ();
	void SetOffset (ULONG ulOffset);
	CDsigSig *GetDsigSig ();

private:
	ULONG ulFormat;
	ULONG ulLength;
	ULONG ulOffset;
	CDsigSig *pDsigSig;
};

// CDsigTable: representation of the DSIG table
class CDsigTable {
public:
	CDsigTable ();
	~CDsigTable ();

	HRESULT Read (TTFACC_FILEBUFFERINFO *pFileBufferInfo, ULONG *pulOffset, ULONG ulLength);
	HRESULT Write (TTFACC_FILEBUFFERINFO *pOutputFileBufferInfo, ULONG *pulOffset);
	HRESULT WriteDirEntry (TTFACC_FILEBUFFERINFO *pOutputFileBufferInfo, ULONG ulOffset);
	void Print ();
	HRESULT GetSize (ULONG *pulDsigTableSize);
	HRESULT GetAbsoluteIndex (ULONG ulDsigSigFormat, USHORT *pusDsigSignatureIndex);
	HRESULT InsertDsigSignature (CDsigSignature *pDsigSignature,
		    					 USHORT *pusIndex);
	HRESULT AppendDsigSignature (CDsigSignature *pDsigSignature,
                                 USHORT *pusIndex);
	HRESULT RemoveDsigSignature (USHORT usIndex);
	HRESULT ReplaceDsigInfo (USHORT usDsigSignatureIndex, CDsigInfo *pDsigInfoNew);
	HRESULT ReplaceSignature (USHORT usDsigSignatureIndex,
                              BYTE *pbSignature,
                              ULONG cbSignature);

	// access functions
	USHORT GetNumSigs ();
    USHORT GetFlag ();
    void SetFlag (USHORT usFlag);
	CDsigSignature *GetDsigSignature (USHORT usIndex);

private:
	ULONG ulVersion;
	USHORT usNumSigs;
	USHORT usFlag;      // this flag indicates whether the font file may
                        // be resigned (default is 1 == cannot be resigned)
	CDsigSignature **ppSigs;
};

#endif // _DSIGTABLE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\sign\fileobj.cpp ===
//
// fileobj.cpp
//
// (c) 1997-1998. Microsoft Corporation.
// Author: Donald Chinn
//

#include "fileobj.h"
#include "utilsign.h"
#include "signerr.h"

// Constructor: Map the file
CFileHandle::CFileHandle (HANDLE hFile, BOOL fCleanup)
{
    this->hFile = hFile;
    this->fCleanup = fCleanup;
    hMapFile = NULL;
    pbMemPtr = NULL;
    cbMemPtr = 0;
}


// Destructor: Unmap the file
CFileHandle::~CFileHandle ()
{
    UnmapFile ();

}


// Map a file.  If hMapFile is not NULL (the file is presumed
// to already be mapped), then do nothing.
//
// If cbFile == 0, then the size of the file is used
// in the calls to map the file and its file size is
// returned in *pcbFile.
HRESULT CFileHandle::MapFile (ULONG cbFile,
                              DWORD dwProtect,
                              DWORD dwAccess)
{
	HRESULT fReturn = E_FAIL;

#if MSSIPOTF_DBG
//    DbgPrintf ("Calling CFileHandle::MapFile.\n");
#endif

	if (hMapFile == NULL) {
		if ((hMapFile =
				CreateFileMapping (hFile,
								   NULL,
								   dwProtect,
								   0,
								   cbFile,
								   NULL)) == NULL) {
#if MSSIPOTF_ERROR
			SignError ("Cannot continue: Error in CreateFileMapping.", NULL, TRUE);
#endif
			fReturn = MSSIPOTF_E_FILE;
			goto done;
		}
		if ((pbMemPtr = (BYTE *) MapViewOfFile (hMapFile,
												dwAccess,
												0,
												0,
												cbFile)) == NULL) {
#if MSSIPOTF_ERROR
			SignError ("Cannot continue: Error in MapViewOfFile.", NULL, TRUE);
#endif
			fReturn = MSSIPOTF_E_FILE;
			goto done;
		}

		if ((cbMemPtr = GetFileSize (hFile, NULL)) == 0xFFFFFFFF) {
#if MSSIPOTF_ERROR
			SignError ("Cannot continue: Error in GetFileSize.", NULL, TRUE);
#endif
			fReturn = MSSIPOTF_E_FILE;
			goto done;
		}
	}

    fReturn = S_OK;
done:
#if MSSIPOTF_DBG
//    DbgPrintf ("Exiting CFileHandle::MapFile.\n");
#endif

    return fReturn;
}


HRESULT CFileHandle::UnmapFile ()
{
#if MSSIPOTF_DBG
//    DbgPrintf ("Called CFileHandle::UnmapFile.\n");
#endif
    if (hMapFile) {
		CloseHandle (hMapFile);
        hMapFile = NULL;
    }

    if (pbMemPtr) {
		UnmapViewOfFile (pbMemPtr);
        pbMemPtr = NULL;
        cbMemPtr = 0;
    }
#if MSSIPOTF_DBG
//    DbgPrintf ("Exiting CFileHandle::UnmapFile.\n");
#endif


	return S_OK;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\sign\glyphexist.h ===
//
// glyphExist.h
//
// (c) 1997-1998. Microsoft Corporation.
// Author: Donald Chinn
//
// Functions exported:
//   GetPresentGlyphList
//   GetSubsetPresentGlyphList
//

#ifndef _GLYPHEXIST_H
#define _GLYPHEXIST_H

#include "hashGlyph.h"
#include "subset.h"

HRESULT GetPresentGlyphList (TTFACC_FILEBUFFERINFO *pFileBufferInfo,
                             UCHAR *puchPresentGlyphList,
                             USHORT usNumGlyphs);

HRESULT GetSubsetPresentGlyphList (TTFACC_FILEBUFFERINFO *pFileBufferInfo,
                                   USHORT *pusKeepCharCodeList,
                                   USHORT usCharListCount,
                                   UCHAR *puchPresentGlyphList,
                                   USHORT usNumGlyphs);

#endif // _GLYPHEXIST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\sign\fileobj.h ===
//
// fileobj.h
//
// (c) 1997-1998. Microsoft Corporation.
// Author: Donald Chinn
//

#ifndef _FILEOBJ_H
#define _FILEOBJ_H


#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x400
#endif

#include <windows.h>
#include "signglobal.h"


class CFileObj {
public:
    void GetMemPtr (BYTE **ppbMemPtr, ULONG *pcbMemPtr) {
        *ppbMemPtr = this->pbMemPtr;
        *pcbMemPtr = this->cbMemPtr;
    };
    virtual HRESULT MapFile (ULONG cbFile,
                             DWORD dwProtect,
                             DWORD dwAccess) = 0;
    virtual HRESULT UnmapFile () = 0;
    virtual HRESULT CloseFileHandle () = 0;
    virtual void SetEndOfFileObj (ULONG cbFile) = 0;
    BYTE *GetFileObjPtr () {
        return pbMemPtr;
    };
    ULONG GetFileObjSize () {
        return cbMemPtr;
    };
protected:
    BYTE *pbMemPtr;
    ULONG cbMemPtr;
};


class CFileHandle : public CFileObj {
public:
    CFileHandle (HANDLE hFile, BOOL fCleanup);
    ~CFileHandle ();
    void SetEndOfFileObj (ULONG cbFile) {
        SetFilePointer (hFile, cbFile, NULL, FILE_BEGIN);
        SetEndOfFile (hFile);
    } ;
    virtual HRESULT MapFile (ULONG cbFile,
                             DWORD dwProtect,
                             DWORD dwAccess);
    virtual HRESULT UnmapFile ();
    virtual HRESULT CloseFileHandle () {
        if (fCleanup && hFile) {
#if MSSIPOTF_DBG
            DbgPrintf ("Closing file handle.\n");  // DBGEXTRA
#endif
            CloseHandle (hFile);
            hFile = NULL;
        }
        return S_OK;
    } ;
private:
    HANDLE hFile;
    BOOL fCleanup;    // If fCleanup is TRUE, then we close
                      // the handle hFile in the destructor
    HANDLE hMapFile;
};


class CFileMemPtr : public CFileObj {
public:
    CFileMemPtr (BYTE *pbMemPtr, ULONG cbMemPtr) {
        this->pbMemPtr = pbMemPtr;
        this->cbMemPtr = cbMemPtr;
    } ;
    void SetEndOfFileObj (ULONG cbFile) {
        ;
    } ;
    virtual HRESULT MapFile (ULONG cbFile,
                             DWORD dwProtect,
                             DWORD dwAccess) {
        return S_OK;
    } ;
    virtual HRESULT UnmapFile () {
        return S_OK;
    } ;
    virtual HRESULT CloseFileHandle () {
        return S_OK;
    }

};


#endif // _FILEOBJ_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\sign\dsigtable.cpp ===
//
// dsigTable.cpp
//
// (c) 1997-1998. Microsoft Corporation.
// Author: Donald Chinn
//
// Routines dealing with objects related to the DSIG table.
//
// Some methodological notes:
//
// Since constructors cannot have a return value and error
// values are passed via return values, we follow the
// convention that constructors do not allocate any memory
// to any of its member variables (which might be pointers
// to other objects).
//
// In addition to the constructor for each class, there is an
// associated function called Alloc.  Alloc allocates and
// initializes any member variables that are objects.  Typically,
// this involves calling the constructor and Alloc function of
// the member variable's class type.  Also, Alloc checks for any
// other kinds of possible errors.  If any errors occur, the error
// code is returned.  In general, if an initialization action could
// cause an error, it belongs in the Alloc function.  (NOTE: this
// methodology is not implemented in all classes in this file.)
//
// A typical way to create an object and report errors is to
// write the following code:
//
// if (((pObject = new CObject) == NULL) ||
//     (pObject->Alloc() != NO_ERROR)) {
//   SignError (<error message>);
//   fReturn = <error code>;
//   goto done;
// }
//
// Memory allocation:
// All memory for data structures are allocated using the new operator.
// For functions that adds object(s) to a CDsigTable via an argument,
// there are two acceptable ways for the caller to proceed:
// 1. The caller creates a disposable object (i.e., an object whose
//    memory could be deleted at any time) using new and passes its
//    pointer in.
// 2. The caller creates an object (using new or malloc), but then
//    creates a copy of it with new and passes the latter pointer in.
//    (In other words, the copy is a disposable object.)
// In either case, the object passed in is dispoable, and it is NOT
// the caller's responsibility to delete the memory for that object.
//
// Order of classes in this file:
//   CDsigInfo
//   CDsigSig
//   CDsigSigF1
//   CDsigSigF2
//   CDsigSignature
//   CDsigTable
//


#include "dsigTable.h"
#include "utilsign.h"
#include "cryptutil.h"
#include "signerr.h"


////
//// CDsigInfo member functions
////

//
// Alloc function
//
int CDsigInfo::Alloc ()
{
	int fReturn;


	fReturn = NO_ERROR;
// done:
	return fReturn;
}


// Default constructor
//
// Create a default DsigInfo structure for Format 2 DSIG signatures
//
CDsigInfo::CDsigInfo ()
{
	ulVersion = DSIGINFO_CURRENT_VERSION;
    usHashAlgorithm = DSIG_HASH_ALG;

	ulNumMissingGlyphs = 0;
	pbMissingGlyphs = NULL;

	ulNumMissingEBLC = 0;
	pbMissingEBLC = NULL;

	ulNumMissingNames = 0;
	pbMissingNames = 0;

	ulNumMissingPost = 0;
	pbMissingPost = NULL;

	usNumMissingVDMX = 0;
	usMissingVDMXFlags = 0;
	pbMissingVDMX = NULL;

}


// Constructor with a hash algorithm as an argument
CDsigInfo::CDsigInfo (ALG_ID ulHashAlg)
{
	ulVersion = DSIGINFO_CURRENT_VERSION;
	usHashAlgorithm = ulHashAlg;

	ulNumMissingGlyphs = 0;
	pbMissingGlyphs = NULL;

	ulNumMissingEBLC = 0;
	pbMissingEBLC = NULL;

	ulNumMissingNames = 0;
	pbMissingNames = 0;

	ulNumMissingPost = 0;
	pbMissingPost = NULL;

	usNumMissingVDMX = 0;
	usMissingVDMXFlags = 0;
	pbMissingVDMX = NULL;
}


// Default destructor
CDsigInfo::~CDsigInfo ()
{
	if (pbMissingGlyphs)
		delete [] pbMissingGlyphs;

	if (pbMissingEBLC)
		delete [] pbMissingEBLC;

	if (pbMissingNames)
		delete [] pbMissingNames;
	
	if (pbMissingPost)
		delete [] pbMissingPost;

	if (pbMissingVDMX)
		delete [] pbMissingVDMX;
}


// Copy constructor
CDsigInfo::CDsigInfo (const CDsigInfo& in)
{
    USHORT usHashValueLength = 0;

	ulVersion = in.ulVersion;
    usHashAlgorithm = in.usHashAlgorithm;

    // BUGBUG: we will eventually make this simply:
    // usHashValueLength = in.usHashValueLength;
    if (GetAlgHashValueSize (usHashAlgorithm, &usHashValueLength) != NO_ERROR) {
#if MSSIPOTF_DBG
        DbgPrintf ("Error in GetAlgHashValueLength.\n");
#endif
    }

	ulNumMissingGlyphs = in.ulNumMissingGlyphs;
	if ((pbMissingGlyphs =
			new BYTE [ulNumMissingGlyphs * usHashValueLength]) == NULL) {
#if MSSIPOTF_ERROR
		SignError ("Cannot continue: Error in new BYTE.", NULL, FALSE);
#endif
	}

	ulNumMissingEBLC = in.ulNumMissingEBLC;
	if ((pbMissingEBLC =
			new BYTE [ulNumMissingEBLC * usHashValueLength]) == NULL) {
#if MSSIPOTF_ERROR
		SignError ("Cannot continue: Error in new BYTE.", NULL, FALSE);
#endif
	}

	ulNumMissingNames = in.ulNumMissingNames;
	if ((pbMissingNames =
			new BYTE [ulNumMissingNames * usHashValueLength]) == NULL) {
#if MSSIPOTF_ERROR
		SignError ("Cannot continue: Error in new BYTE.", NULL, FALSE);
#endif
	}

	ulNumMissingPost = in.ulNumMissingPost;
	if ((pbMissingPost =
			new BYTE [ulNumMissingPost * usHashValueLength]) == NULL) {
#if MSSIPOTF_ERROR
		SignError ("Cannot continue: Error in new BYTE.", NULL, FALSE);
#endif
	}

	usNumMissingVDMX = in.usNumMissingVDMX;
	usMissingVDMXFlags = in.usMissingVDMXFlags;
	if ((pbMissingGlyphs =
			new BYTE [ulNumMissingGlyphs * usHashValueLength]) == NULL) {
#if MSSIPOTF_ERROR
		SignError ("Cannot continue: Error in new BYTE.", NULL, FALSE);
#endif
	}
}


// Assignment operator
CDsigInfo& CDsigInfo::operator= (const CDsigInfo& in)
{
    USHORT cbHashValueLength = 0;

	ulVersion = in.ulVersion;
    usHashAlgorithm = in.usHashAlgorithm;
    usHashValueLength = in.usHashValueLength;
    
    ulNumMissingGlyphs = in.ulNumMissingGlyphs;
	if (pbMissingGlyphs)
		delete [] pbMissingGlyphs;
	if ((pbMissingGlyphs =
			new BYTE [ulNumMissingGlyphs * usHashValueLength]) == NULL) {
#if MSSIPOTF_ERROR
		SignError ("Cannot continue: Error in new BYTE.", NULL, FALSE);
#endif
	}
    memcpy (pbMissingGlyphs, in.pbMissingGlyphs,
        ulNumMissingGlyphs * usHashValueLength);

	ulNumMissingEBLC = in.ulNumMissingEBLC;
	if (pbMissingEBLC)
		delete [] pbMissingEBLC;
	if ((pbMissingEBLC =
			new BYTE [ulNumMissingEBLC * usHashValueLength]) == NULL) {
#if MSSIPOTF_ERROR
		SignError ("Cannot continue: Error in new BYTE.", NULL, FALSE);
#endif
	}
    memcpy (pbMissingEBLC, in.pbMissingEBLC,
        ulNumMissingEBLC * usHashValueLength);

	ulNumMissingNames = in.ulNumMissingNames;
	if (pbMissingNames)
		delete [] pbMissingNames;
	if ((pbMissingNames =
			new BYTE [ulNumMissingNames * usHashValueLength]) == NULL) {
#if MSSIPOTF_ERROR
		SignError ("Cannot continue: Error in new BYTE.", NULL, FALSE);
#endif
	}
    memcpy (pbMissingNames, in.pbMissingNames,
        ulNumMissingNames * usHashValueLength);

	ulNumMissingPost = in.ulNumMissingPost;
	if (pbMissingPost)
		delete [] pbMissingPost;
	if ((pbMissingPost =
			new BYTE [ulNumMissingPost * usHashValueLength]) == NULL) {
#if MSSIPOTF_ERROR
		SignError ("Cannot continue: Error in new BYTE.", NULL, FALSE);
#endif
	}
    memcpy (pbMissingPost, in.pbMissingPost,
        ulNumMissingPost * usHashValueLength);

	usNumMissingVDMX = in.usNumMissingVDMX;
	usMissingVDMXFlags = in.usMissingVDMXFlags;
	if (pbMissingVDMX)
		delete [] pbMissingVDMX;
	if ((pbMissingVDMX =
			new BYTE [usNumMissingVDMX * usHashValueLength]) == NULL) {
#if MSSIPOTF_ERROR
		SignError ("Cannot continue: Error in new BYTE.", NULL, FALSE);
#endif
	}
    memcpy (pbMissingVDMX, in.pbMissingVDMX,
        usNumMissingVDMX * usHashValueLength);

	return *this;
}


//
// Read the DsigInfo part of a DSIG signature from a file starting
// at the given offset.
// Return in pulOffset the offset just after the last byte read.
//
HRESULT CDsigInfo::Read (TTFACC_FILEBUFFERINFO *pFileBufferInfo,
                         ULONG *pulOffset)
{
	HRESULT fReturn;

	USHORT hashValueLength = 0;
	ULONG sizeof_long = sizeof(ULONG);
	ULONG sizeof_short = sizeof(USHORT);

	// version, hashAlgorithm
	ReadLong(pFileBufferInfo, &ulVersion, *pulOffset);
	*pulOffset += sizeof_long;

    if (ulVersion < DSIGINFO_VERSION1) {
#if MSSIPOTF_ERROR
        SignError ("Bad DsigInfo version number.", NULL, FALSE);
#endif
        fReturn = MSSIPOTF_E_BADVERSION;
        goto done;
    }

	ReadLong(pFileBufferInfo, (ULONG *) &usHashAlgorithm, *pulOffset);
	*pulOffset += sizeof_long;

    // BUGBUG: We eventually want to crack the PKCS #7 packet to determine the
    // hash algorithm, and then compute the hash value length after that.
	// Compute hash value length
	if ((fReturn = GetAlgHashValueSize (usHashAlgorithm, &hashValueLength))
					!= S_OK) {
#if MSSIPOTF_DBG
		DbgPrintf ("Error in GetAlgHashValueSize.\n");
#endif
		return fReturn;
	}

	// glyphs
	ReadLong(pFileBufferInfo, &ulNumMissingGlyphs, *pulOffset);
	*pulOffset += sizeof_long;
	if (ulNumMissingGlyphs > 0) {

		// hash values
		if ((pbMissingGlyphs =
				new BYTE [ulNumMissingGlyphs * hashValueLength]) == NULL) {
#if MSSIPOTF_ERROR
			SignError ("Cannot continue: Error in new BYTE.", NULL, FALSE);
#endif
			fReturn = E_OUTOFMEMORY;
			goto done;
		}
		ReadBytes (pFileBufferInfo,
			pbMissingGlyphs,
			*pulOffset,
			ulNumMissingGlyphs * hashValueLength);
		*pulOffset += ulNumMissingGlyphs * hashValueLength;
	} else {
		pbMissingGlyphs = NULL;
	}

	// EBLC table
	ReadLong(pFileBufferInfo, &ulNumMissingEBLC, *pulOffset);
	*pulOffset += sizeof_long;
	if (ulNumMissingEBLC > 0) {
		if ((pbMissingEBLC =
				new BYTE [ulNumMissingEBLC * hashValueLength]) == NULL) {
#if MSSIPOTF_ERROR
			SignError ("Cannot continue: Error in new BYTE.", NULL, FALSE);
#endif
			fReturn = E_OUTOFMEMORY;
			goto done;
		}
		ReadBytes (pFileBufferInfo,
			pbMissingEBLC,
			*pulOffset,
			ulNumMissingEBLC * hashValueLength);
		*pulOffset += ulNumMissingEBLC * hashValueLength;
	} else {
		pbMissingEBLC = NULL;
	}

	// names
	ReadLong(pFileBufferInfo, &ulNumMissingNames, *pulOffset);
	*pulOffset += sizeof_long;
	if (ulNumMissingNames > 0) {
		if ((pbMissingNames =
				new BYTE [ulNumMissingNames * hashValueLength]) == NULL) {
#if MSSIPOTF_ERROR
			SignError ("Cannot continue: Error in new BYTE.", NULL, FALSE);
#endif
			fReturn = E_OUTOFMEMORY;
			goto done;
		}
		ReadBytes (pFileBufferInfo,
			pbMissingNames,
			*pulOffset,
			ulNumMissingNames * hashValueLength);
		*pulOffset += ulNumMissingNames * hashValueLength;
	} else {
		pbMissingNames = NULL;
	}

	// post table
	ReadLong(pFileBufferInfo, &ulNumMissingPost, *pulOffset);
	*pulOffset += sizeof_long;
	if (ulNumMissingPost > 0) {
		if ((pbMissingPost =
				new BYTE [ulNumMissingPost * hashValueLength]) == NULL) {
#if MSSIPOTF_ERROR
			SignError ("Cannot continue: Error in new BYTE.", NULL, FALSE);
#endif
			fReturn = E_OUTOFMEMORY;
			goto done;
		}
		ReadBytes (pFileBufferInfo,
			pbMissingPost,
			*pulOffset,
			ulNumMissingPost * hashValueLength);
		*pulOffset += ulNumMissingPost * hashValueLength;
	} else {
		pbMissingPost = NULL;
	}

	// VDMX table
	ReadWord(pFileBufferInfo, &usNumMissingVDMX, *pulOffset);
	*pulOffset += sizeof_short;
	ReadWord(pFileBufferInfo, &usMissingVDMXFlags, *pulOffset);
	*pulOffset += sizeof_short;
	if (usNumMissingVDMX > 0) {
		if ((pbMissingVDMX =
				new BYTE [usNumMissingVDMX * hashValueLength]) == NULL) {
#if MSSIPOTF_ERROR
			SignError ("Cannot continue: Error in new BYTE.", NULL, FALSE);
#endif
			fReturn = E_OUTOFMEMORY;
			goto done;
		}
		ReadBytes (pFileBufferInfo,
			pbMissingVDMX,
			*pulOffset,
			usNumMissingVDMX * hashValueLength);
		*pulOffset += usNumMissingVDMX * hashValueLength;
	} else {
		pbMissingVDMX = NULL;
	}

	fReturn = S_OK;

done:
	return fReturn;
}


//
// Write the DsigInfo part of a DSIG signature to a file starting
// at the given offset.
// Return in pulOffset the offset just after the last byte written.
//
HRESULT CDsigInfo::Write (TTFACC_FILEBUFFERINFO *pOutputFileBufferInfo,
					      ULONG *pulOffset)
{
	int fReturn;

    USHORT cbHashValueLength = 0;

	ULONG sizeof_long = sizeof(LONG);
	ULONG sizeof_word = sizeof(SHORT);

	// version, length, hash algorithm, reserved
	WriteLong(pOutputFileBufferInfo, ulVersion, *pulOffset);
	*pulOffset += sizeof_long;
	WriteLong(pOutputFileBufferInfo, usHashAlgorithm, *pulOffset);
	*pulOffset += sizeof_long;

    // BUGBUG: We will eventually will need to delete this if block, because
    // we will be guaranteed that cbHashValueLength is correct.
	// Compute hash value length
	if ((fReturn = GetAlgHashValueSize (usHashAlgorithm, &cbHashValueLength))
					!= S_OK) {
#if MSSIPOTF_DBG
        DbgPrintf ("Error in GetAlgHashValueSize.\n");
#endif
		return fReturn;
	}

	// missing glyphs
	WriteLong(pOutputFileBufferInfo, ulNumMissingGlyphs, *pulOffset);
	*pulOffset += sizeof_long;
	WriteBytes (pOutputFileBufferInfo,
				pbMissingGlyphs,
				*pulOffset,
				ulNumMissingGlyphs * cbHashValueLength);
	*pulOffset += ulNumMissingGlyphs * cbHashValueLength;

	// EBLC
	WriteLong(pOutputFileBufferInfo, ulNumMissingEBLC, *pulOffset);
	*pulOffset += sizeof_long;
	WriteBytes (pOutputFileBufferInfo,
				pbMissingEBLC,
				*pulOffset,
				ulNumMissingEBLC * cbHashValueLength);
	*pulOffset += ulNumMissingEBLC * cbHashValueLength;

	// names
	WriteLong(pOutputFileBufferInfo, ulNumMissingNames, *pulOffset);
	*pulOffset += sizeof_long;
	WriteBytes (pOutputFileBufferInfo,
				pbMissingNames,
				*pulOffset,
				ulNumMissingNames * cbHashValueLength);
	*pulOffset += ulNumMissingNames * cbHashValueLength;

	// post
	WriteLong (pOutputFileBufferInfo, ulNumMissingPost, *pulOffset);
	*pulOffset += sizeof_long;
	WriteBytes (pOutputFileBufferInfo,
				pbMissingPost,
				*pulOffset,
				ulNumMissingPost * cbHashValueLength);
	*pulOffset += ulNumMissingPost * cbHashValueLength;

	// vdmx
	WriteWord (pOutputFileBufferInfo, usNumMissingVDMX, *pulOffset);
	*pulOffset += sizeof_word;
	WriteWord (pOutputFileBufferInfo, usMissingVDMXFlags, *pulOffset);
	*pulOffset += sizeof_word;
	WriteBytes (pOutputFileBufferInfo,
				pbMissingVDMX,
				*pulOffset,
				usNumMissingVDMX * cbHashValueLength);
	*pulOffset += usNumMissingVDMX * cbHashValueLength;

	fReturn = S_OK;

    // For future implementations: we might need to long word align
    // (i.e., write zeros if necessary).  For this version, we know
    // the number of bytes written is long word aligned.  Note: this
    // padding may actually belong at the DsigSigF2::Write level.

// done:
	return fReturn;
}


//
// Print out parts of the DsigInfo
//
void CDsigInfo::Print ()
{
#if MSSIPOTF_DBG
	DbgPrintf ("  dsigInfo version: %d\n", ulVersion);
	DbgPrintf ("  Hash alg: %d\n", usHashAlgorithm);

	DbgPrintf ("  Num missing glyphs: %d\n", ulNumMissingGlyphs);
	DbgPrintf ("  Num missing EBLC  : %d\n", ulNumMissingEBLC);
	DbgPrintf ("  Num missing names : %d\n", ulNumMissingNames);
	DbgPrintf ("  Num missing post  : %d\n", ulNumMissingPost);
	DbgPrintf ("  Num missing VDMX  : %d\n", usNumMissingVDMX);

	DbgPrintf ("\n");
#endif
}


//
// Compute the length in bytes of a DsigInfo structure
// if it were to be written to a file.
//
HRESULT CDsigInfo::GetSize (ULONG *pulDsigInfoSize)
{
	int fReturn;

	ULONG sizeof_long = sizeof(ULONG);		// size of a ULONG
	ULONG sizeof_short = sizeof(USHORT);	// size of a USHORT
	USHORT sizeof_hash;						// size of a hash value

    // BUGBUG: Can we just assume that usHashValueSize is correct?
	// Compute sizeof_hash
	if ((fReturn = GetAlgHashValueSize (usHashAlgorithm, &sizeof_hash))
					!= S_OK) {
#if MSSIPOTF_DBG
        DbgPrintf ("Error in GetAlgHashValueSize.\n");
#endif
		return fReturn;
	}
//	cout << "sizeof_hash = " << dec << sizeof_hash << endl;

	// version, hashAlgorithm
	*pulDsigInfoSize = 2 * sizeof_long;
	// missingGlyphs
	*pulDsigInfoSize += sizeof_long + ulNumMissingGlyphs * sizeof_hash;
	// EBLC
	*pulDsigInfoSize += sizeof_long + ulNumMissingEBLC * sizeof_hash;
	// Names
	*pulDsigInfoSize += sizeof_long + ulNumMissingNames * sizeof_hash;
	// Post
	*pulDsigInfoSize += sizeof_long + ulNumMissingPost * sizeof_hash;
	// VDMX
	*pulDsigInfoSize += 2 * sizeof_short + usNumMissingVDMX * sizeof_hash;

#if MSSIPOTF_DBG
    DbgPrintf ("DsigInfo size = %d.\n", *pulDsigInfoSize);
#endif

	fReturn = S_OK;

// done:
	return fReturn;
}


// access functions for CDsigInfo

ULONG CDsigInfo::GetVersion ()
{
	return(ulVersion);
}


void CDsigInfo::SetVersion (ULONG ulVersion)
{
	this->ulVersion = ulVersion;
}


ALG_ID CDsigInfo::GetHashAlgorithm ()
{
	return(usHashAlgorithm);
}


void CDsigInfo::SetHashAlgorithm (ALG_ID usHashAlgorithm)
{
	this->usHashAlgorithm = usHashAlgorithm;
}


ULONG CDsigInfo::GetNumMissingGlyphs ()
{
	return ulNumMissingGlyphs;
}


void CDsigInfo::SetNumMissingGlyphs (ULONG ulNumMissingGlyphs)
{
	this->ulNumMissingGlyphs = ulNumMissingGlyphs;
}


BYTE *CDsigInfo::GetMissingGlyphs ()
{
	return pbMissingGlyphs;
}


void CDsigInfo::SetMissingGlyphs (BYTE *pbMissingGlyphs)
{
	this->pbMissingGlyphs = pbMissingGlyphs;
}



////
//// CDsigSigF1 member functions
////

// default constructor
CDsigSigF1::CDsigSigF1 ()
{
	usReserved1 = 0;
	usReserved2 = 0;
	cbSignature = 0;
	pbSignature = NULL;
}


// default destructor
CDsigSigF1::~CDsigSigF1 ()
{
	delete [] pbSignature;
}


//
// Read a DsigSigF1 from a file starting at the given offset.
// cbDsigSig is how many bytes the DsigSig is.
// Check that the following properties of the DsigSig hold:
//   The reserved fields are 0.
//   The DsigSig is not too small.
//   The signature is the correct size.
//   
// Return in pulOffset the offset just after the last byte read.
//
HRESULT CDsigSigF1::Read (TTFACC_FILEBUFFERINFO *pFileBufferInfo,
	    				  ULONG *pulOffset,
		    			  ULONG cbDsigSig)
{
	HRESULT fReturn = E_FAIL;
	ULONG cbNonSignature = 0;
    ULONG cbSignatureFile = 0;

	ULONG sizeof_short = sizeof(USHORT);
	ULONG sizeof_long = sizeof(ULONG);

	//// Reserved fields
	ReadWord(pFileBufferInfo, &(usReserved1), *pulOffset);
	*pulOffset += sizeof_short;
	ReadWord(pFileBufferInfo, &(usReserved2), *pulOffset);
	*pulOffset += sizeof_short;

/*  //// shouldn't check for this, so that the code is forward-compatible

    // check that the reserved fields are 0
    if ((usReserved1 != 0) || (usReserved2 != 0)) {
#if MSSIPOTF_ERROR
        SignError ("Reserved fields of the DSIG table not set to 0.", NULL, FALSE);
#endif
        fReturn = MSSIPOTF_E_DSIG_RESERVED;
        goto done;
    }
*/

	//// signature
	// we have now read enough of the DsigSig to determine how long the
	// signature is.
    // PAST NOTE TO SELF: Is there a better way to do this (i.e., without
    // having to make a call to GetNonSignatureSize)?  I think this is
    // OK because we check that cbDsigSig - cbNonSignature equals
    // the cbSignature field of the signature in the file.
    // BUGBUG: is this good for backwards compatibility?
	GetNonSignatureSize(&cbNonSignature);
	if (cbDsigSig >= cbNonSignature) {
		// set the cbSignature field of the DsigSig
		cbSignature = cbDsigSig - cbNonSignature;
	} else {
#if MSSIPOTF_ERROR
		SignError ("Size of DsigSig in DSIG table too small.", NULL, FALSE);
#endif
		fReturn = MSSIPOTF_E_DSIG_STRUCTURE;
		goto done;
	}
	if ((pbSignature = new BYTE [cbSignature]) == NULL) {
#if MSSIPOTF_ERROR
		SignError ("Cannot continue: Error in new BYTE.", NULL, FALSE);
#endif
		fReturn = E_OUTOFMEMORY;
		goto done;
	}
    // read in the length of the signature from file
	ReadLong(pFileBufferInfo, &(cbSignatureFile), *pulOffset);
	*pulOffset += sizeof_long;
    if (cbSignatureFile != cbSignature) {
#if MSSIPOTF_ERROR
       SignError ("Size of signature is incorrect.", NULL, FALSE);
#endif
        fReturn = MSSIPOTF_E_DSIG_STRUCTURE;
        goto done;
    }

	// read it in
	if (ReadBytes (pFileBufferInfo,
                   pbSignature,
                   *pulOffset,
                   cbSignature) != NO_ERROR) {
#if MSSIPOTF_ERROR
		SignError ("Cannot continue: Error in ReadBytes.", NULL, FALSE);
#endif
        fReturn = MSSIPOTF_E_CANTGETOBJECT;
		goto done;
	}

	*pulOffset += cbSignature;

	fReturn = S_OK;

done:
	return fReturn;
}


//
// Write a DsigSigF1 to a file starting at the given offset.
// Return in pulOffset the offset just after the last byte written.
//
HRESULT CDsigSigF1::Write (TTFACC_FILEBUFFERINFO *pOutputFileBufferInfo,
					       ULONG *pulOffset)
{
	HRESULT fReturn = E_FAIL;
	ULONG sizeof_short = sizeof(USHORT);
	ULONG sizeof_long = sizeof(ULONG);

	assert (((*pulOffset) % sizeof(ULONG)) == 0);

	//// Reserved fields
	WriteWord(pOutputFileBufferInfo, usReserved1, *pulOffset);
	*pulOffset += sizeof_short;
	WriteWord(pOutputFileBufferInfo, usReserved2, *pulOffset);
	*pulOffset += sizeof_short;
	WriteLong(pOutputFileBufferInfo, cbSignature, *pulOffset);
	*pulOffset += sizeof_long;
	
	// the signature
	if (WriteBytes (pOutputFileBufferInfo,
					pbSignature,
					*pulOffset,
					cbSignature) != NO_ERROR) {
#if MSSIPOTF_ERROR
		SignError ("Cannot continue: Error in WriteBytes.", NULL, FALSE);
#endif
        fReturn = MSSIPOTF_E_FILE;
		goto done;
	}
	*pulOffset += cbSignature;

	fReturn = S_OK;

done:
	return fReturn;
}


//
// Print the DsigSigF1 structure.
//
void CDsigSigF1::Print ()
{
#if MSSIPOTF_DBG
	DbgPrintf ("  usReserved1: %d\n", usReserved1);
	DbgPrintf ("  usReserved2: %d\n", usReserved2);

	DbgPrintf ("  The signature (%d bytes):\n", cbSignature);

    PrintAbbrevBytes (pbSignature, cbSignature);

	DbgPrintf ("\n");
#endif
}


//
// Compute the size  in bytes of the DsigSigF1 if
// it were written to a file.
//
HRESULT CDsigSigF1::GetSize (ULONG *pulDsigSigSize)
{
	int fReturn;

	*pulDsigSigSize = 2 * sizeof(USHORT) + sizeof(ULONG);
	*pulDsigSigSize += cbSignature;

	fReturn = S_OK;
// done:
	return fReturn;
}


// Compute the size in bytes of all non-signature elements
// in a DsigSigF1 if it were written to a file.
HRESULT CDsigSigF1::GetNonSignatureSize (ULONG *pulSize)
{
	HRESULT fReturn = E_FAIL;

	*pulSize = 2 * sizeof (USHORT) + sizeof (ULONG);

	fReturn = S_OK;
// done:
	return fReturn;
}


////
//// CDsigSigF2 member functions
////

// default constructor
CDsigSigF2::CDsigSigF2 ()
{
	ulDsigInfoOffset = DSIGSIGF2_DSIGINFOOFFSET;
	if (((pDsigInfo = new CDsigInfo) == NULL) ||
			(pDsigInfo->Alloc() != NO_ERROR)) {
#if MSSIPOTF_ERROR
		SignError ("Cannot continue: Error in new CDsigInfo.", NULL, FALSE);
#endif
	}

    // pDsigInfo->GetSize(&cbDsigInfo);
    cbDsigInfo = 0;     // indicates that the DsigInfo is not valid
#if MSSIPOTF_DBG
    DbgPrintf ("cbDsigInfo = %d.\n", cbDsigInfo);
#endif
	ulSignatureOffset = RoundToLongWord(cbDsigInfo) + 3 * sizeof(ULONG);

	cbSignature = 0;
	pbSignature = NULL;
}


// Constructor with a hash algorithm as an argument
CDsigSigF2::CDsigSigF2 (ALG_ID ulHashAlg)
{
	ulDsigInfoOffset = DSIGSIGF2_DSIGINFOOFFSET;
	if (((pDsigInfo = new CDsigInfo (ulHashAlg)) == NULL) ||
			(pDsigInfo->Alloc() != NO_ERROR)) {
#if MSSIPOTF_ERROR
		SignError ("Cannot continue: Error in new CDsigInfo.", NULL, FALSE);
#endif
	}

    // pDsigInfo->GetSize(&cbDsigInfo);
    cbDsigInfo = 0;     // indicates that the DsigInfo is not valid
#if MSSIPOTF_DBG
    DbgPrintf ("cbDsigInfo = %d.\n", cbDsigInfo);
#endif
	ulSignatureOffset = RoundToLongWord(cbDsigInfo) + 3 * sizeof(ULONG);
	cbSignature = 0;
	pbSignature = NULL;
}


// default destructor
CDsigSigF2::~CDsigSigF2 ()
{
	delete pDsigInfo;

	delete [] pbSignature;
}


//
// Read a DsigSigF2 from a file starting at the given offset.
// cbDsigSig is how many bytes the DsigSig is.
// Return in pulOffset the offset just after the last byte read.
//
HRESULT CDsigSigF2::Read (TTFACC_FILEBUFFERINFO *pFileBufferInfo,
		    			  ULONG *pulOffset,
			    		  ULONG cbDsigSig)
{
	HRESULT fReturn = E_FAIL;

	ULONG sizeof_long = sizeof(ULONG);

	//// ulDsigInfoOffset, ulSignatureOffset
	ReadLong(pFileBufferInfo, &(ulDsigInfoOffset), *pulOffset);
	*pulOffset += sizeof_long;
	ReadLong(pFileBufferInfo, &(ulSignatureOffset), *pulOffset);
	*pulOffset += sizeof_long;

	//// DsigInfo
	// ulDsigInfoOffset should equal DSIGINFOF2_OFFSET if there is a
	// DsigInfo in the DSIG signature.
	if (ulDsigInfoOffset == DSIGSIGF2_DSIGINFOOFFSET) {

        ULONG ulOffsetOriginal = 0;

		// DsigInfo
	    ReadLong(pFileBufferInfo, &cbDsigInfo, *pulOffset);
	    *pulOffset += sizeof_long;
        ulOffsetOriginal = *pulOffset;

		if (pDsigInfo->Read (pFileBufferInfo, pulOffset) != NO_ERROR) {
#if MSSIPOTF_DBG
			DbgPrintf ("Error in CDsigInfo::Read.\n");
#endif
            fReturn = MSSIPOTF_E_CANTGETOBJECT;
			goto done;
		}
        // Check that the current offset is the original offset
        // plus the length.
#if MSSIPOTF_DBG
        DbgPrintf ("*pulOffset = %d, ulOffsetOriginal = %d, cbDsigInfo = %d.\n",
            *pulOffset, ulOffsetOriginal, cbDsigInfo);
#endif
        if ((*pulOffset < ulOffsetOriginal) ||
            (*pulOffset != (ulOffsetOriginal + cbDsigInfo))) {
#if MSSIPOTF_ERROR
            SignError ("Incorrect length of DsigInfo.", NULL, FALSE);
#endif
            fReturn = MSSIPOTF_E_DSIG_STRUCTURE;
            goto done;
        }

        // Verify that the extra pad bytes have value 0.
        BYTE zero = 0x00;
        ULONG i;
        for (i = *pulOffset; i < RoundToLongWord (*pulOffset); i++) {
            if (memcmp (pFileBufferInfo->puchBuffer + i, &zero, 1)) {
#if MSSIPOTF_ERROR
                SignError ("Bad gap bytes in DSIG table.", NULL, FALSE);
#endif
                fReturn = MSSIPOTF_E_DSIG_STRUCTURE;
                goto done;
            }
        }

		*pulOffset = RoundToLongWord (*pulOffset);
    } else {
#if MSSIPOTF_ERROR
        SignError ("DsigInfoOffset is incorrect.", NULL, FALSE);
#endif
        fReturn = MSSIPOTF_E_DSIG_STRUCTURE;
        goto done;
    }

	//// signature
	ReadLong(pFileBufferInfo, &cbSignature, *pulOffset);
	*pulOffset += sizeof_long;

    if ((pbSignature = new BYTE [cbSignature]) == NULL) {
#if MSSIPOTF_ERROR
		SignError ("Cannot continue: Error in new BYTE.", NULL, FALSE);
#endif
		fReturn = E_OUTOFMEMORY;
		goto done;
	}
	// read it in
	if (ReadBytes (pFileBufferInfo,
                   pbSignature,
                   *pulOffset,
                   cbSignature) != NO_ERROR) {
#if MSSIPOTF_ERROR
		SignError ("Error in ReadBytes.", NULL, FALSE);
#endif
        fReturn = MSSIPOTF_E_CANTGETOBJECT;
		goto done;
	}
	*pulOffset += cbSignature;

	fReturn = S_OK;

done:
	return fReturn;
}


//
// Write a DsigSigF2 to a file starting at the given offset.
// Return in pulOffset the offset just after the last byte written.
//
HRESULT CDsigSigF2::Write (TTFACC_FILEBUFFERINFO *pOutputFileBufferInfo,
	    				   ULONG *pulOffset)
{
	HRESULT fReturn = E_FAIL;
	ULONG sizeof_long = sizeof(ULONG);
    ULONG cbDsigInfoTemp = 0;

	assert (((*pulOffset) % sizeof_long) == 0);

	// ulDsigInfoOffset and ulDsigSignatureOffset
	WriteLong(pOutputFileBufferInfo, ulDsigInfoOffset, *pulOffset);
	*pulOffset += sizeof_long;
	WriteLong(pOutputFileBufferInfo, ulSignatureOffset, *pulOffset);
	*pulOffset += sizeof_long;
	
	// the dsigInfo.  If pDsigInfo is NULL, then there is no DsigInfo
	// in this DSIG signature.
#if MSSIPOTF_DBG
    DbgPrintf ("Write: cbDsigInfo = %d.\n", cbDsigInfo);
#endif

    if (cbDsigInfo == 0) {
        // Even if the DsigInfo is not a valid object, we write as
        // though it were.
        pDsigInfo->GetSize (&cbDsigInfoTemp);
    } else {
        cbDsigInfoTemp = cbDsigInfo;
    }
	WriteLong(pOutputFileBufferInfo, cbDsigInfoTemp, *pulOffset);
	*pulOffset += sizeof_long;

	if (pDsigInfo != NULL) {
		assert (ulDsigInfoOffset == DSIGSIGF2_DSIGINFOOFFSET);

		if (pDsigInfo->Write (pOutputFileBufferInfo,
                              pulOffset) != NO_ERROR) {
#if MSSIPOTF_DBG
            DbgPrintf ("Error in CDsigInfo::Write.\n");
#endif
            fReturn = MSSIPOTF_E_FILE;
			goto done;
		}
        // Write zeros for the pad bytes
        ZeroLongWordAlign (pOutputFileBufferInfo, *pulOffset);
		*pulOffset = RoundToLongWord(*pulOffset);
	}

	// the signature
	WriteLong(pOutputFileBufferInfo, cbSignature, *pulOffset);
	*pulOffset += sizeof_long;
	if (WriteBytes (pOutputFileBufferInfo,
                    pbSignature,
                    *pulOffset,
                    cbSignature) != NO_ERROR) {
#if MSSIPOTF_ERROR
		SignError ("Error in WriteBytes.", NULL, FALSE);
#endif
        fReturn = MSSIPOTF_E_FILE;
		goto done;
	}
	*pulOffset += cbSignature;

	fReturn = S_OK;

done:
	return fReturn;
}


//
// Print the DsigSigF2 structure.
// cbSignature is the length of the signature part of the DsigSigF2.
//
void CDsigSigF2::Print ()
{
#if MSSIPOTF_DBG
	DbgPrintf ("  DsigInfoOffset : %d\n", ulDsigInfoOffset);
	DbgPrintf ("  SignatureOffset: %d\n", ulSignatureOffset);

	DbgPrintf ("  DsigInfo Length: %d\n", cbDsigInfo);
	if (pDsigInfo != NULL) {
		pDsigInfo->Print ();
	}

	DbgPrintf ("  The signature (%d bytes):\n", cbSignature);

    PrintAbbrevBytes (pbSignature, cbSignature);

    DbgPrintf ("\n");
#endif
}


//
// Compute the size in bytes of the DsigSigF2 if it were
// written to a file.
//
HRESULT CDsigSigF2::GetSize (ULONG *pulDsigSigSize)
{
	HRESULT fReturn;
    ULONG cbDsigInfo = 0;

    // ulDsigInfoOffset, ulSignatureOffset, cbDsigInfo, cbSignature
	*pulDsigSigSize = 4 * sizeof(ULONG);

    if (pDsigInfo != NULL) {
        pDsigInfo->GetSize(&cbDsigInfo);
    }
    *pulDsigSigSize += RoundToLongWord(cbDsigInfo);
	*pulDsigSigSize += cbSignature;

	fReturn = S_OK;
// done:
	return fReturn;
}


//
// Compute the size in bytes of all non-signature elements
// in a DsigSigF2 if it were written to a file.
HRESULT CDsigSigF2::GetNonSignatureSize (ULONG *pulSize)
{
	HRESULT fReturn;
    ULONG cbDsigInfo = 0;

    pDsigInfo->GetSize(&cbDsigInfo);
	*pulSize = RoundToLongWord(cbDsigInfo);
	*pulSize += 4 * sizeof (ULONG);

	fReturn = S_OK;
// done:
	return fReturn;
}


// access functions for CDsigSigF2

ULONG CDsigSigF2::GetSignatureOffset ()
{
	return ulSignatureOffset;
}


void CDsigSigF2::SetSignatureOffset (ULONG ulSignatureOffset)
{
	this->ulSignatureOffset = ulSignatureOffset;
}


CDsigInfo *CDsigSigF2::GetDsigInfo ()
{
	return pDsigInfo;
}


void CDsigSigF2::SetDsigInfo (CDsigInfo *pDsigInfo)
{
	this->pDsigInfo = pDsigInfo;
    pDsigInfo->GetSize(&cbDsigInfo);
}


// Return the hash algorithm associated with this DsigSig
ALG_ID CDsigSigF2::GetHashAlgorithm ()
{
	CDsigInfo *pDsigInfo = NULL;
	
	if ((pDsigInfo = GetDsigInfo()) == NULL) {
#if MSSIPOTF_ERROR
		SignError ("No valid DsigInfo.", NULL, FALSE);
#endif
		return 0;
	}

	return (pDsigInfo->GetHashAlgorithm());
}


////
//// DsigSignature
////

// default constructor
CDsigSignature::CDsigSignature ()
{
	ulFormat = 0;
	ulLength = 0;
	ulOffset = 0;
	pDsigSig = NULL;
}


// constructor for CDsigSignature
CDsigSignature::CDsigSignature (ULONG ulDsigSigFormat)
{
	ULONG ulSize;

	ulFormat = ulDsigSigFormat;
	ulOffset = 0;
	switch (ulDsigSigFormat) {
		case DSIGSIG_FORMAT1: 
            if ((pDsigSig = new CDsigSigF1 ()) == NULL) {
#if MSSIPOTF_ERROR
                SignError ("Error in new CDsigSigF1.", NULL, FALSE);
#endif
                goto done;
            }
			((CDsigSigF1 *) pDsigSig)->GetSize(&ulSize);
			ulLength = ulSize;
			break;

#if ENABLE_FORMAT2
		case DSIGSIG_FORMAT2:
            if ((pDsigSig = new CDsigSigF2 ()) == NULL) {
#if MSSIPOTF_ERROR
                SignError ("Error in new CDsigSigF2.", NULL, FALSE);
#endif
                goto done;
            }
			((CDsigSigF2 *) pDsigSig)->GetSize(&ulSize);
			ulLength = ulSize;
			break;
#endif

		default:
#if MSSIPOTF_DBG
			DbgPrintf ("CDsigSignature constructor: Bad DsigSig format.\n");
#endif
			// exit (SIGN_BAD_FORMAT);
			break;
	}
done:
    ;
}


// default destructor
CDsigSignature::~CDsigSignature ()
{
	switch (ulFormat) {
		case DSIGSIG_FORMAT1:
			delete (CDsigSigF1 *) pDsigSig;
			break;

#if ENABLE_FORMAT2
		case DSIGSIG_FORMAT2:
			delete (CDsigSigF2 *) pDsigSig;
			break;
#endif

		default:
#if MSSIPOTF_DBG
			DbgPrintf ("CDsigSignature destructor: Bad DsigSig format.\n");
#endif
			// exit (SIGN_BAD_FORMAT);
			break;
	}
}


// Read a DsigSignature header 
HRESULT CDsigSignature::ReadHeader (TTFACC_FILEBUFFERINFO *pFileBufferInfo,
	    							ULONG *pulOffset)
{
	ULONG sizeof_long = sizeof(ULONG);

	ReadLong(pFileBufferInfo, &(ulFormat), *pulOffset);
	*pulOffset += sizeof_long;
	ReadLong(pFileBufferInfo, &(ulLength), *pulOffset);
	*pulOffset += sizeof_long;
	ReadLong(pFileBufferInfo, &(ulOffset), *pulOffset);
	*pulOffset += sizeof_long;

	return S_OK;
}


// Write a DsigSignature header
HRESULT CDsigSignature::WriteHeader (TTFACC_FILEBUFFERINFO *pOutputFileBufferInfo,
	    							 ULONG *pulOffset)
{
	ULONG sizeof_long = sizeof(ULONG);

	WriteLong(pOutputFileBufferInfo, ulFormat, *pulOffset);
	*pulOffset += sizeof_long;
	WriteLong(pOutputFileBufferInfo, ulLength, *pulOffset);
	*pulOffset += sizeof_long;
	WriteLong(pOutputFileBufferInfo, ulOffset, *pulOffset);
	*pulOffset += sizeof_long;

	return S_OK;
}


// Read the DsigSig part of the DsigSignature
HRESULT CDsigSignature::ReadDsigSig (TTFACC_FILEBUFFERINFO *pFileBufferInfo,
	    							 ULONG *pulOffset,
		    						 ULONG cbDsigSignature)
{
	HRESULT fReturn = NO_ERROR;

	switch (ulFormat) {
		case DSIGSIG_FORMAT1:
			if ((pDsigSig = new CDsigSigF1 ()) == NULL) {
#if MSSIPOTF_ERROR
				SignError ("Error in new CDsigSigF1.", NULL, FALSE);
#endif
				fReturn = E_OUTOFMEMORY;
				goto done;
			}
			break;

#if ENABLE_FORMAT2
		case DSIGSIG_FORMAT2:
			if ((pDsigSig = new CDsigSigF2 ()) == NULL) {
#if MSSIPOTF_ERROR
				SignError ("Error in new CDsigSigF2.", NULL, FALSE);
#endif
				fReturn = E_OUTOFMEMORY;
				goto done;
			}
			break;
#endif

		default:
#if MSSIPOTF_ERROR
			SignError ("Cannot continue: Signature has bad format number.",
                NULL, FALSE);
#endif
			fReturn = MSSIPOTF_E_DSIG_STRUCTURE;
            goto done;
			break;
	}

	if (pDsigSig->Read (pFileBufferInfo,
                        pulOffset,
                        cbDsigSignature) != NO_ERROR) {
#if MSSIPOTF_DBG
		DbgPrintf ("Error in CDsigSig::Read.\n");
#endif
        fReturn = MSSIPOTF_E_CANTGETOBJECT;
        goto done;
	}

	fReturn = S_OK;
done:
	return fReturn;
}


// Write the DsigSig part of the DsigSignature
HRESULT CDsigSignature::WriteDsigSig (TTFACC_FILEBUFFERINFO *pOutputFileBufferInfo,
                                      ULONG *pulOffset)
{
	HRESULT fReturn = S_OK;

	if (pDsigSig->Write (pOutputFileBufferInfo,
                         pulOffset) != NO_ERROR) {
#if MSSIPOTF_DBG
		DbgPrintf ("Error in CDsigSig::Write.\n");
#endif
        fReturn = MSSIPOTF_E_FILE;
	}

	return fReturn;
}


// Print a DsigSignature
void CDsigSignature::Print ()
{
#if MSSIPOTF_DBG
	DbgPrintf ("  Format: %d\n", ulFormat);
	DbgPrintf ("  Length: %d\n", ulLength);
	DbgPrintf ("  Offset: %d\n", ulOffset);
	pDsigSig->Print();
#endif
}


// Return in pulDsigSignatureSize the size of the DsigSig
// associated with this DsigSignature.
HRESULT CDsigSignature::GetSize (ULONG *pulDsigSignatureSize)
{
	HRESULT fReturn;

	pDsigSig->GetSize(pulDsigSignatureSize);

	fReturn = S_OK;
// done:
	return fReturn;
}


// Return in pulSignatureSize the size of the signature
//   part of the DsigSignature.
HRESULT CDsigSignature::GetSignatureSize (ULONG *pulSignatureSize)
{
	HRESULT fReturn;

	if (pDsigSig == NULL) {
#if MSSIPOTF_ERROR
		SignError ("No signature.", NULL, FALSE);
#endif
		fReturn = MSSIPOTF_E_DSIG_STRUCTURE;
		goto done;
	}

	*pulSignatureSize = pDsigSig->GetSignatureSize();

	fReturn = S_OK;
done:
	return fReturn;
}


//// access functions for CDsigSignature

ULONG CDsigSignature::GetFormat ()
{
	return ulFormat;
}


void CDsigSignature::SetFormat (ULONG ulFormat)
{
	this->ulFormat = ulFormat;
}


ULONG CDsigSignature::GetLength ()
{
	return ulLength;
}


void CDsigSignature::SetLength (ULONG ulLength)
{
	this->ulLength = ulLength;
}


ULONG CDsigSignature::GetOffset ()
{
	return ulOffset;
}


void CDsigSignature::SetOffset (ULONG ulOffset)
{
	this->ulOffset = ulOffset;
}


CDsigSig *CDsigSignature::GetDsigSig ()
{
	return pDsigSig;
}



////
//// CDsigTable
////

// default constructor
CDsigTable::CDsigTable ()
{
	ulVersion = DSIG_TABLE_CURRENT_VERSION;
	usNumSigs = 0;
	usFlag = DSIG_DEFAULT_FLAG_HIGH * FLAG_RADIX + DSIG_DEFAULT_FLAG_LOW;
	ppSigs = NULL;
}


// default destructor
CDsigTable::~CDsigTable ()
{
	ULONG i;

	if (ppSigs) {
		for (i = 0; i < usNumSigs; i++) {
			delete (ppSigs[i]);
		}

		delete ppSigs;
	}
}



// Read a DsigTable from a file starting at the given offset.
// Return in pulOffset the offset just after the last byte read.
// Returns SIGN_DSIG_ABSENT if there is no DSIG table.
HRESULT CDsigTable::Read (TTFACC_FILEBUFFERINFO *pFileBufferInfo,
					  ULONG *pulOffset,
                      ULONG ulLength)
{
	HRESULT fReturn = E_FAIL;

	ULONG sizeof_long = sizeof(ULONG);
	ULONG sizeof_short = sizeof(USHORT);

	ULONG ulDsigOffset;
	ULONG i;


    // Remember where the DSIG table begins
    ulDsigOffset = *pulOffset;

	// version
	ReadLong(pFileBufferInfo, &(ulVersion), *pulOffset);
	*pulOffset += sizeof_long;
    // Jamboree version of this code had the following
    // version check, but it should be forward-compatible
    if (ulVersion < DSIG_TABLE_VERSION1) {
#if MSSIPOTF_ERROR
        SignError ("Bad DSIG Table version number.", NULL, FALSE);
#endif
        fReturn = MSSIPOTF_E_BADVERSION;
        goto done;
    }

    // numSigs
	ReadWord(pFileBufferInfo, &(usNumSigs), *pulOffset);
	*pulOffset += sizeof_short;
	ReadWord(pFileBufferInfo, &(usFlag), *pulOffset);
	*pulOffset += sizeof_short;

	// allocate memory for the DsigSignatures
    if ((ppSigs = new (CDsigSignature * [usNumSigs])) == NULL) {
#if MSSIPOTF_ERROR
		SignError ("Cannot continue: Error in new CDsigSignature *.", NULL, FALSE);
#endif
		fReturn = E_OUTOFMEMORY;
		goto done;
	}
					
	for (i = 0; i < usNumSigs; i++) {
		if ((ppSigs[i] = new CDsigSignature) == NULL) {
#if MSSIPOTF_ERROR
			SignError ("Cannot continue: Error in new CDsigSignature.", NULL, FALSE);
#endif
			fReturn = E_OUTOFMEMORY;
			goto done;
		}
	}

	// headers
	for (i = 0; i < usNumSigs; i++) {
		ppSigs[i]->ReadHeader (pFileBufferInfo, pulOffset);
	}

    // ASSERT: *pulOffset is on a long word boundary.
    assert (*pulOffset == RoundToLongWord (*pulOffset));

	// DsigSignatures
	for (i = 0; i < usNumSigs; i++) {

		if (ppSigs[i]->GetOffset() != (*pulOffset - ulDsigOffset)) {
#if MSSIPOTF_ERROR
			SignError ("DSIG signatures not arranged properly.", NULL, FALSE);
#endif
			fReturn = MSSIPOTF_E_DSIG_STRUCTURE;
			goto done;
		}
		if ((fReturn =
				ppSigs[i]->ReadDsigSig (pFileBufferInfo,
									pulOffset,
									ppSigs[i]->GetLength())) != S_OK) {
#if MSSIPOTF_DBG
			DbgPrintf ("Error in CDsigSignature::ReadDsigSig.\n");
#endif
			goto done;
		}

        // Verify that the pad bytes between DsigSigs are set to 0
        BYTE zero = 0x00;
        ULONG j;
        for (j = *pulOffset; j < RoundToLongWord (*pulOffset); j++) {
            if (memcmp (pFileBufferInfo->puchBuffer + j, &zero, 1)) {
#if MSSIPOTF_ERROR
                SignError ("Bad gap bytes in DSIG table.", NULL, FALSE);
#endif
                fReturn = MSSIPOTF_E_DSIG_STRUCTURE;
                goto done;
            }
        }
		*pulOffset = RoundToLongWord (*pulOffset);

	}

    // Check that the last byte read was at byte (offset + length)
    // of the DSIG table.
    if (*pulOffset != (ulDsigOffset + ulLength)) {
#if MSSIPOTF_ERROR
        SignError ("DSIG table read is not the advertised length.",
            NULL, FALSE);
#endif
        fReturn = MSSIPOTF_E_DSIG_STRUCTURE;
        goto done;
    }
	
	fReturn = S_OK;

done:

	return fReturn;
}


// Write a DsigTable to a file starting at the given offset.
// Also, update its directory entry.
// Return in pulOffset the offset just after the last byte written.
HRESULT CDsigTable::Write (TTFACC_FILEBUFFERINFO *pOutputFileBufferInfo,
                           ULONG *pulOffset)
{
	HRESULT fReturn = E_FAIL;

	ULONG sizeof_long = sizeof(ULONG);
	ULONG sizeof_short = sizeof(USHORT);
	ULONG i;


	assert ((*pulOffset % sizeof_long) == 0);  // check that we are word-aligned

	//// Write the DSIG table to the new file.

	// version, numSigs, and dsigInfoOffset
	WriteLong (pOutputFileBufferInfo, ulVersion, *pulOffset);
	*pulOffset += sizeof_long;
	WriteWord (pOutputFileBufferInfo, usNumSigs, *pulOffset);
	*pulOffset += sizeof_short;
	WriteWord (pOutputFileBufferInfo, usFlag, *pulOffset);
	*pulOffset += sizeof_short;

	// the headers
	for (i = 0; i < usNumSigs; i++) {
		ppSigs[i]->WriteHeader (pOutputFileBufferInfo, pulOffset);
	}

    // ASSERT: *pulOffset is long word aligned
    assert (*pulOffset == RoundToLongWord (*pulOffset));

	// the DsigSignatures
	for (i = 0; i < usNumSigs; i++) {
		if ((fReturn =
				ppSigs[i]->WriteDsigSig (pOutputFileBufferInfo,
										pulOffset)) != NO_ERROR) {
#if MSSIPOTF_DBG
			DbgPrintf ("Error in CDsigSignature::WriteDsigSig.\n");
#endif
			goto done;
		}

        // Write zeros for the pad bytes
        ZeroLongWordAlign (pOutputFileBufferInfo, *pulOffset);
		*pulOffset = RoundToLongWord (*pulOffset);
	}


	fReturn = S_OK;

done:
	return fReturn;
}


// Update a TTF file's directory entry for the DSIG table based
// on the DsigTable object and an offset.  If ulOffset = 0, then
// the offset field is not touched.
HRESULT CDsigTable::WriteDirEntry (TTFACC_FILEBUFFERINFO *pOutputFileBufferInfo,
                                   ULONG ulOffset)
{
	HRESULT fReturn = E_FAIL;

	DIRECTORY dirDsig;
	ULONG dsigDirOffset;


	// Find the DSIG directory entry in the new file
    // BUGBUG
	// dsigDirOffset = TTDirectoryEntryOffset (pOutputFileBufferInfo, DSIG_TAG);
	// ReadDirectoryEntry (pOutputFileBufferInfo, dsigDirOffset, &dirDsig);
    GetTTDirectory (pOutputFileBufferInfo, DSIG_TAG, &dirDsig);
    dsigDirOffset = dirDsig.offset;

	//// Compute the checksum value for the DSIG table and set the correct
	//// values for the directory entry for the DSIG table (pDirDsig).
	
	if (ulOffset != 0) {
		dirDsig.offset = ulOffset;
	}
	GetSize (&(dirDsig.length));
	dirDsig.checkSum = 0;  // needs to be calculated later
	WriteDirectoryEntry (&dirDsig, pOutputFileBufferInfo, dsigDirOffset);

	//// The directory entry of the DSIG table in the new file is now correct,
	//// except for its checksum field.

	//// Calculate and write the checksum field of the DSIG table's
	//// directory entry.
	if (UpdateDirEntry (pOutputFileBufferInfo, DSIG_TAG, dirDsig.length)
			!= NO_ERROR) {
#if MSSIPOTF_ERROR
		SignError ("Cannot continue: Error in UpdateDirEntry.", NULL, FALSE);
#endif
        fReturn = MSSIPOTF_E_FILE;
		goto done;
	}

	fReturn = S_OK;
done:
	return fReturn;
}


// Print a DsigTable
void CDsigTable::Print ()
{
#if MSSIPOTF_DBG
	ULONG i;

	DbgPrintf ("---- DSIG Table ----\n");
	DbgPrintf ("Version : %d\n", ulVersion);
	DbgPrintf ("Num Sigs: %d\n", usNumSigs);
	DbgPrintf ("Flag    : %d\n", usFlag);
	for (i = 0; i < usNumSigs; i++) {
		DbgPrintf ("DSIG signature %d:\n", i);
		ppSigs[i]->Print ();
	}
	DbgPrintf ("\n");
#endif
}


// Return in pulDsigSignatureSize the size of the DsigTable.
HRESULT CDsigTable::GetSize (ULONG *pulDsigTableSize)
{
	HRESULT fReturn;

	ULONG ulDsigSignatureSize;
	USHORT i;

	*pulDsigTableSize = sizeof(ULONG) + 2 * sizeof(USHORT);
	for (i = 0; i < usNumSigs; i++) {
		ppSigs[i]->GetSize(&ulDsigSignatureSize);
		*pulDsigTableSize += SIZEOF_DSIGSIGNATUREHEADER +
			RoundToLongWord(ulDsigSignatureSize);
	}

	fReturn = S_OK;
// done:
	return fReturn;
}


// Given a format and an index, return the absolute index of the
// index-th DsigSignature of the given format.
HRESULT CDsigTable::GetAbsoluteIndex (ULONG ulDsigSigFormat, USHORT *pusDsigSigIndex)
{
	HRESULT fReturn;

	USHORT i = 0;
	USHORT numFound = 0;

	if (ulDsigSigFormat == DSIGSIG_ANY_FORMAT) {

		if (*pusDsigSigIndex >= usNumSigs) {
#if MSSIPOTF_DBG
			DbgPrintf ("Not enough signatures.\n");
#endif
			fReturn = MSSIPOTF_E_DSIG_STRUCTURE;
			goto done;
		}

	} else {

		while (i < usNumSigs) {
			if (ppSigs[i]->GetFormat() ==
				ulDsigSigFormat) {
				numFound++;
			}
			if (numFound == (*pusDsigSigIndex + 1))
				break;
			i++;
		}

		if (i < usNumSigs) {
			*pusDsigSigIndex = i;
		} else {
#if MSSIPOTF_DBG
			DbgPrintf ("Not enough signatures.\n");
#endif
			fReturn = MSSIPOTF_E_DSIG_STRUCTURE;
			goto done;
		}
	}

	fReturn = S_OK;

done:
	return fReturn;
}


// Insert the given DsigSignature at the given index.  If
// *pusIndex is beyond the index of the last signature, then
// we append the signature and return the actual index in
// *pusIndex.
HRESULT CDsigTable::InsertDsigSignature (CDsigSignature *pDsigSignature,
                                         USHORT *pusIndex)
{
	HRESULT fReturn = E_FAIL;
	ULONG sizeof_long = sizeof(ULONG);
	ULONG sizeof_short = sizeof(USHORT);
    CDsigSignature **ppSigsTemp = NULL;

    USHORT usNumSigsOld = 0;
	USHORT i;

	// note that the DsigSignature array is zero-indexed, but numSigs is not.
    if ((ppSigsTemp = new (CDsigSignature * [usNumSigs])) == NULL) {
#if MSSIPOTF_ERROR
		SignError ("Cannot continue: Error in new (CDSigSignature *).", NULL, FALSE);
#endif
		fReturn = E_OUTOFMEMORY;
		goto done;
    }

    usNumSigsOld = usNumSigs;
    // copy pointers to temp array
    for (i = 0; i < usNumSigsOld; i++) {
        ppSigsTemp[i] = ppSigs[i];
    }

	usNumSigs++;
    delete [] ppSigs;

    // reallocate new ppSigs array with new (bigger) size
    if ((ppSigs = new (CDsigSignature * [usNumSigs])) == NULL) {
#if MSSIPOTF_ERROR
		SignError ("Cannot continue: Error in new (CDSigSignature *).", NULL, FALSE);
#endif
		fReturn = E_OUTOFMEMORY;
		goto done;
    }

    // copy pointers to new array
    for (i = 0; i < usNumSigsOld; i++) {
        ppSigs[i] = ppSigsTemp[i];
    }
    ppSigs[usNumSigsOld] = NULL;  // set the last pointer in the array to NULL

    delete [] ppSigsTemp;

/*
	// reallocate array of pointers
	if ((ppSigs = (CDsigSignature * *)
			realloc (ppSigs, usNumSigs * sizeof (CDsigSignature *))) == NULL) {
		SignError ("Error in realloc.", NULL, FALSE);
		fReturn = SIGN_MALLOC;
		goto done;
	}
*/

	//// ppSigs now points to the reallocated array of pointers

	// if the requested index is too large, make it the last index
	if (usNumSigs <= *pusIndex) {
		*pusIndex = usNumSigs - 1;
	}

	//// shift all DsigSignatures after the new DsigSignature down one
	for (i = usNumSigs - 1; i > *pusIndex; i--) {
		ppSigs[i] = ppSigs[i-1];
	}

	//// add the pointer to the new DsigSignature
	ppSigs[*pusIndex] = pDsigSignature;

	// adjust the header offsets of all the original DsigSignatures
	for (i = 0; i < usNumSigs; i++) {
		ppSigs[i]->SetOffset (ppSigs[i]->GetOffset() +
			SIZEOF_DSIGSIGNATUREHEADER);
	}
	// Compute the offset for the new DsigSignature
	if (*pusIndex == 0) {
		ppSigs[*pusIndex]->SetOffset (sizeof_long +
			2 * sizeof_short + usNumSigs * SIZEOF_DSIGSIGNATUREHEADER);
	} else {
		ppSigs[*pusIndex]->SetOffset (ppSigs[*pusIndex - 1]->GetOffset() +
			RoundToLongWord(ppSigs[*pusIndex - 1]->GetLength()) );
	}

	// Compute the offsets for DsigSignatures that come after the new one
	for (i = *pusIndex + 1; i < usNumSigs; i++) {
		ppSigs[i]->SetOffset (ppSigs[i - 1]->GetOffset() +
			RoundToLongWord(ppSigs[i - 1]->GetLength()) );
	}

	fReturn = S_OK;

done:
	return fReturn;
}


// Append the given DsigSignature to the DsigTable.  Return in
//   pusIndex the index where it was inserted.
HRESULT CDsigTable::AppendDsigSignature (CDsigSignature *pDsigSignature,
                                         USHORT *pusIndex)
{
	HRESULT fReturn = E_FAIL;
	ULONG sizeof_long = sizeof(ULONG);
	ULONG sizeof_short = sizeof(USHORT);
        CDsigSignature **ppSigsTemp = NULL;

	USHORT i;

	// pDsigSigIndex is zero-indexed, but usNumSigs is not.
	*pusIndex = usNumSigs;
	usNumSigs++;

	// reallocate array of pointers
	if ((ppSigsTemp = (CDsigSignature * *)
			realloc (ppSigs, usNumSigs * sizeof (CDsigSignature *))) == NULL) {
#if MSSIPOTF_ERROR
		SignError ("Cannot continue: Error in realloc.", NULL, FALSE);
#endif
		fReturn = E_OUTOFMEMORY;
		goto done;
	} else {
                ppSigs = ppSigsTemp;
        }


	//// ppSigs now points to the reallocated array of pointers

	ppSigs[*pusIndex] = pDsigSignature;

	// adjust the header offsets of all the original DsigSignatures
	for (i = 0; i < *pusIndex; i++) {
		ppSigs[i]->SetOffset (ppSigs[i]->GetOffset() +
			SIZEOF_DSIGSIGNATUREHEADER);
	}
	// Compute the offset for the new DsigSignature
	if (*pusIndex == 0) {
		// there is only one DsigSignature after appending
		ppSigs[*pusIndex]->SetOffset (sizeof_long +
			2 * sizeof_short + SIZEOF_DSIGSIGNATUREHEADER);
	} else {
		ppSigs[*pusIndex]->SetOffset (ppSigs[*pusIndex - 1]->GetOffset() +
			RoundToLongWord(ppSigs[*pusIndex - 1]->GetLength()) );
	}


	fReturn = S_OK;

done:
	return fReturn;
}


// Remove the DsigSignature of the given index.
HRESULT CDsigTable::RemoveDsigSignature (USHORT usIndex)
{
	HRESULT fReturn;

	CDsigSignature *pDsigSignature;
	ULONG dsigSigLength;
	ULONG sizeof_DsigSigHeader = SIZEOF_DSIGSIGNATUREHEADER;
	ULONG i;


	// Check for index out of bounds
	if (usIndex >= usNumSigs) {
#if MSSIPOTF_DBG
		DbgPrintf ("RemoveDsigSignature: Not enough signatures.\n");
#endif
		fReturn = MSSIPOTF_E_DSIG_STRUCTURE;
		goto done;
	}

	// Get the usIndex-th DsigSignature
	pDsigSignature = ppSigs[usIndex];
	dsigSigLength = RoundToLongWord(pDsigSignature->GetLength());

	// Subtract the length of a DsigSignatureHeader from the offsets of all sigs
	for (i = 0; i < usNumSigs; i++) {
		ppSigs[i]->SetOffset (ppSigs[i]->GetOffset() - sizeof_DsigSigHeader);
	}

	// Subtract the length of the current sig from the offsets of all
	// sigs after the current one.
	for (i = usIndex; i < usNumSigs; i++) {
		ppSigs[i]->SetOffset (ppSigs[i]->GetOffset() - dsigSigLength);
	}

	// Free the memory pointed to by pDsigSignature.
	delete pDsigSignature;

	// Compress the array of DsigSigHeader and DsigSigs
	if (usNumSigs > 0) {
        USHORT usNumSigsNew = usNumSigs - 1;
		for (i = usIndex; i < usNumSigsNew; i++) {
			ppSigs[i] = ppSigs[i+1];
		}
	}

	// Adjust the number of signatures
	usNumSigs--;


	fReturn = S_OK;

done:
	return fReturn;
}


//// access functions

USHORT CDsigTable::GetNumSigs ()
{
	return usNumSigs;
}


USHORT CDsigTable::GetFlag ()
{
    return usFlag;
}


void CDsigTable::SetFlag (USHORT usFlag)
{
    this->usFlag = usFlag;
}

// Return the DsigSignature of the given index.
// Return NULL if the index is too high.
CDsigSignature *CDsigTable::GetDsigSignature (USHORT usIndex)
{
	if (usIndex < usNumSigs) {
		return ppSigs[usIndex];
	} else {
		return NULL;
	}
}


// Replace the DsigInfo of the usDsigSignatureIndex-th DsigSignature
// in the DsigTable.
HRESULT CDsigTable::ReplaceDsigInfo (USHORT usDsigSignatureIndex,
                                     CDsigInfo *pDsigInfoNew)
{
	HRESULT fReturn = E_FAIL;
	USHORT i;

	CDsigSignature *pDsigSignature = NULL;
	ULONG cbDsigInfoOld, cbDsigInfoNew;

	// Check for index out of bounds
	if (usDsigSignatureIndex >= usNumSigs) {
#if MSSIPOTF_DBG
		DbgPrintf ("Not enough signatures.\n");
#endif
		fReturn = MSSIPOTF_E_DSIG_STRUCTURE;
		goto done;
	}

	pDsigSignature = GetDsigSignature (usDsigSignatureIndex);

	// Check to make sure the DsigSig is Format 2
	if (pDsigSignature->GetFormat() != DSIGSIG_FORMAT2) {
#if MSSIPOTF_ERROR
		SignError ("Bad format for the signature.", NULL, FALSE);
#endif
		fReturn = MSSIPOTF_E_DSIG_STRUCTURE;
		goto done;
	}

	//// Delete the old DsigInfo and insert the new one
	// Calculate the sizes of the old DsigInfo and the new DsigInfo
	((CDsigSigF2 *) pDsigSignature->GetDsigSig())->GetDsigInfo()->GetSize (&cbDsigInfoOld);
	pDsigInfoNew->GetSize (&cbDsigInfoNew);
	
	// Delete the old DsigInfo and insert the new dsigInfo
	delete ((CDsigSigF2 *) pDsigSignature->GetDsigSig())->GetDsigInfo();
	((CDsigSigF2 *) pDsigSignature->GetDsigSig())->SetDsigInfo (pDsigInfoNew);

	// Adjust the offsets and lengths of the given DsigSignature
	cbDsigInfoOld = RoundToLongWord (cbDsigInfoOld);
	cbDsigInfoNew = RoundToLongWord (cbDsigInfoNew);
	((CDsigSigF2 *) pDsigSignature->GetDsigSig())->SetSignatureOffset
		(2 * sizeof(ULONG) + cbDsigInfoNew);
	pDsigSignature->SetLength(pDsigSignature->GetLength() -
		cbDsigInfoOld + cbDsigInfoNew);
	
	// Adjust the offsets in all the headers after the current dsigSig
	for (i = usDsigSignatureIndex + 1; i < GetNumSigs(); i++) {
		GetDsigSignature(i)->SetOffset(
			GetDsigSignature(i)->GetOffset() +
			RoundToLongWord (GetDsigSignature(i)->GetLength()));
	}

	fReturn = S_OK;
done:
	return fReturn;
}


// Replace the signature of the usDsigSignatureIndex-th DsigSignature
// in the DsigTable.
HRESULT CDsigTable::ReplaceSignature (USHORT usDsigSignatureIndex,
                                      BYTE *pbSignature,
                                      ULONG cbSignature)
{
	HRESULT fReturn = E_FAIL;
	USHORT i;
	CDsigSignature *pDsigSignature = NULL;
	ULONG cbSignatureOld;

	// Check for index out of bounds
	if (usDsigSignatureIndex >= usNumSigs) {
#if MSSIPOTF_DBG
		DbgPrintf ("Not enough signatures.\n");
#endif
		fReturn = MSSIPOTF_E_DSIG_STRUCTURE;
		goto done;
	}

	pDsigSignature = GetDsigSignature (usDsigSignatureIndex);

	// Erase the old signature
	pDsigSignature->GetSignatureSize (&cbSignatureOld);
	GetDsigSignature(usDsigSignatureIndex)->SetLength(
		GetDsigSignature(usDsigSignatureIndex)->GetLength() -
		RoundToLongWord(cbSignatureOld));
	if (pDsigSignature->GetDsigSig()->GetSignature()) {
		delete GetDsigSignature(usDsigSignatureIndex)->GetDsigSig()->GetSignature();
		GetDsigSignature(usDsigSignatureIndex)->GetDsigSig()->SetSignature (NULL, 0);
	}

	// set the new signature
	pDsigSignature->GetDsigSig()->SetSignature (pbSignature, cbSignature);
	GetDsigSignature(usDsigSignatureIndex)->SetLength(
		GetDsigSignature(usDsigSignatureIndex)->GetLength() +
		cbSignature);

	// adjust the offsets in all the headers after the current dsigSig
	for (i = usDsigSignatureIndex + 1; i < GetNumSigs(); i++) {
		GetDsigSignature(i)->SetOffset(
			GetDsigSignature(i-1)->GetOffset() +
			RoundToLongWord (GetDsigSignature(i-1)->GetLength()));
	}


	fReturn = S_OK;
done:
	return fReturn;

}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\sign\hashglyph.cpp ===
//
// hashGlyph.cpp
//
// (c) 1997-1998. Microsoft Corporation.
// Author: Donald Chinn
//
// Compute the hash value for an
// individual glyph.
//
// Functions in this file:
//   FreeGlyphInfo
//   PrintGlyphInfo
//   HashGlyph
//   HashGlyphNull
//

#include "hashGlyph.h"
#include "hTblGlyf.h"
#include "utilsign.h"
#include "cryptutil.h"
#include "signerr.h"

#include "subset.h"


//
// Free the memory associated with a GlyphInfo array.
//
void FreeGlyphInfo (GlyphInfo *pGlyphInfo, USHORT numGlyphs)
{
	USHORT i;

	if (pGlyphInfo) {
		for (i = 0; i < numGlyphs; i++) {
			if (pGlyphInfo[i].pusCmap)
				delete [] pGlyphInfo[i].pusCmap;
			if (pGlyphInfo[i].pKern)
			    delete [] pGlyphInfo[i].pKern;
		}
		delete [] pGlyphInfo;
    }
}


//
// Print a GlyphInfo array
//
void PrintGlyphInfo (GlyphInfo *pGlyphInfo, USHORT numGlyphs)
{
#if MSSIPOTF_DBG
	USHORT i;

	for (i = 0; i < numGlyphs; i++) {
		DbgPrintf ("%d: %d %d %d %d %d %d %d %d\n",
			pGlyphInfo[i].usNumMapped,
			pGlyphInfo[i].ulGlyf,
			pGlyphInfo[i].ulLength,
			pGlyphInfo[i].usAdvanceWidth,
			pGlyphInfo[i].sLeftSideBearing,
			pGlyphInfo[i].usNumKern,
			pGlyphInfo[i].usAdvanceHeight,
			pGlyphInfo[i].sTopSideBearing);
	}
#endif
}


//
// Compute the hash of a glyph.
// Each piece of information that is used to
// compute the hash is accompanied in parentheses
// by what table that information can be found.
// 
HRESULT CHashTableGlyfContext::HashGlyph (USHORT i,
                                          BYTE *pbHash)
{
	HRESULT fReturn = E_FAIL;
	HCRYPTHASH hHash;


	// Set hHash to be the hash object.
	if (!CryptCreateHash(hProv, hashAlg, 0, 0, &hHash)) {
#if MSSIPOTF_ERROR
		SignError ("Error during CryptCreateHash.",
            "MergeSubtreeHashes", TRUE);
#endif
		fReturn = MSSIPOTF_E_CRYPT;
		goto done;
	}

	//// characters that map to this glyph (cmap)

	//// image data or component data (EBLC, EBDT)

	//// glyph data (glyf)
	if (!CryptHashData (hHash,
						pFileBufferInfo->puchBuffer + pGlyphInfo[i].ulGlyf,
						pGlyphInfo[i].ulLength,
						0)) {
#if MSSIPOTF_ERROR
		SignError ("Error during CryptHashData.", NULL, TRUE);
#endif
		fReturn = MSSIPOTF_E_CRYPT;
		goto done;
	}


	//// advance width, left side bearing (hmtx)

	//// kerning pairs (kern)

	//// ypel (LTSH)

	//// advance height, top side bearing (vmtx)


	if (!CryptGetHashParam(hHash, HP_HASHVAL, pbHash, &cbHash, 0)) {
#if MSSIPOTF_ERROR
		SignError ("Error during CryptGetHashParam (hash value).", NULL, TRUE);
#endif
		fReturn = MSSIPOTF_E_CRYPT;
		goto done;
	}

	// pbHash now contains the hash value.

	ulNodesTouched++;
	ulHashComputations++;

	fReturn = S_OK;

done:
	return fReturn;
}


// Compute the hash value of a glyph that
// is defined to be missing.  (See glyphExist.cpp
// for a definition of "missing".)
HRESULT CHashTableGlyfContext::HashGlyphNull (BYTE *pbHash)
{
	HRESULT fReturn = E_FAIL;
	HCRYPTHASH hHash;

	// Feed zero bytes into CryptHashData
	if (!CryptCreateHash(hProv, hashAlg, 0, 0, &hHash)) {
#if MSSIPOTF_ERROR
		SignError ("Error during CryptCreateHash.",
            "HashGlyphNull", TRUE);
#endif
		fReturn = MSSIPOTF_E_CRYPT;
		goto done;
	}

	if (!CryptGetHashParam(hHash, HP_HASHVAL, pbHash, &cbHash, 0)) {
#if MSSIPOTF_ERROR
		SignError ("Error during CryptGetHashParam (hash value).", NULL, TRUE);
#endif
		fReturn = MSSIPOTF_E_CRYPT;
		goto done;
	}

    fReturn = S_OK;

done:
	// Free resources
	if (hHash)
		CryptDestroyHash (hHash);

	return fReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\sign\glyphexist.cpp ===
//
// glyphExist.cpp
//
// (c) 1997-1998. Microsoft Corporation.
// Author: Donald Chinn
//
// Functions in this file:
//   ReadAllocCmapFormat4Offset
//   MakeKeepGlyphListOffset
//   CharArrayToList
//   GetCmapFormat0Glyphs
//   GetCmapFormat4Glyphs
//   GetCmapFormat6Glyphs
//   GetPresentGlyphList
//   GetSubsetPresentGlyphList
//


#include "glyphExist.h"
#include "utilsign.h"
#include "signerr.h"

#include "subsetCmap.h"

#define DEBUG_CMAP 1

////
//// DEFINITION: A glyph *exists* in a font file if and only if:
////   it is found in some cmap subtable OR
////   glyph data exists for that glyph, meaning that glyph i
////     has glyph data if the (i+1)-st offset in the loca table is
////     greater than the i-th offset in the loca table OR
////   it is the component of a composite glyph that exists.
////
//// A glyph is *present* if and only if it exists.
//// A glyph is *missing* if and only if it is not present.
////


// This function is similar in function to ReadAllocCmapFormat6,
// except that here the input is an offset (rather than a
// PlatformID/EncodingID pair).
int16 ReadAllocCmapFormat6Offset( TTFACC_FILEBUFFERINFO * pInputBufferInfo, 
                                  uint32 ulOffset,
					              uint16 *pusFoundEncoding,
					              CMAP_FORMAT6 * pCmap,
                                  uint16 **  glyphIndexArray)
{
uint16 usBytesRead;
uint32 ulBytesRead;
int16 errCode;

/*
   // locate the cmap subtable
   
	ulOffset = FindCmapSubtable( pInputBufferInfo, usPlatform, usEncoding, pusFoundEncoding  );
	if ( ulOffset == 0 )
		return( ERR_FORMAT );
*/

   /* Read cmap table */

	if ((errCode = ReadGeneric( pInputBufferInfo, (uint8 *) pCmap, SIZEOF_CMAP_FORMAT6, CMAP_FORMAT6_CONTROL, ulOffset, &usBytesRead)) != NO_ERROR)
		return (errCode);

   	if (pCmap->format != FORMAT6_CMAP_FORMAT)
      	return( ERR_FORMAT );

	*glyphIndexArray = (uint16 *) Mem_Alloc( pCmap->entryCount * sizeof( uint16 ));
	if ( *glyphIndexArray == NULL )
		return( ERR_MEM );

	if ((errCode = ReadGenericRepeat( pInputBufferInfo, (uint8 *) *glyphIndexArray, WORD_CONTROL, ulOffset + usBytesRead, &ulBytesRead, pCmap->entryCount, sizeof(uint16))) != NO_ERROR)
		return(errCode); 
	return( NO_ERROR );
}



// This function is similar in function to ReadCmapFormat0,
// except that here the input is an offset (rather than a
// PlatformID/EncodingID pair).
int16 ReadCmapFormat0Offset( TTFACC_FILEBUFFERINFO * pInputBufferInfo,
                             uint32 ulOffset,
                             uint16 *pusFoundEncoding,
			                 CMAP_FORMAT0 *pCmap)
{
uint16 usBytesRead;
uint32 ulBytesRead;
int16 errCode;

/*
   // locate the cmap subtable
   
	ulOffset = FindCmapSubtable( pInputBufferInfo, usPlatform, usEncoding, pusFoundEncoding  );
	if ( ulOffset == 0L )
		return( ERR_FORMAT );
*/

   /* Read cmap table */

	if ((errCode = ReadGeneric( pInputBufferInfo, (uint8 *) pCmap, SIZEOF_CMAP_FORMAT0, CMAP_FORMAT0_CONTROL, ulOffset, &usBytesRead)) != NO_ERROR)
		return (errCode);

   	if (pCmap->format != FORMAT0_CMAP_FORMAT)
      	return( ERR_FORMAT );

	if ((errCode = ReadGenericRepeat( pInputBufferInfo, (uint8 *) &(pCmap->glyphIndexArray), BYTE_CONTROL, ulOffset + usBytesRead, &ulBytesRead, CMAP_FORMAT0_ARRAYCOUNT, sizeof(uint8))) != NO_ERROR)
		return(errCode); 
	return( NO_ERROR );

}


// Given an offset pointing to a Format 4 encoding table,
// return the Format 4 segments.
//
// This function is similar in function to ReadAllocCmapFormat4,
// except that here the input is an offset (rather than a
// PlatformID/EncodingID pair).
int16 ReadAllocCmapFormat4Offset( TTFACC_FILEBUFFERINFO * pInputBufferInfo,
                                  uint32 ulOffset,
					              uint16 *pusFoundEncoding,
					              CMAP_FORMAT4 * pCmapFormat4,
                                  FORMAT4_SEGMENTS **  ppFormat4Segments,
                                  GLYPH_ID ** ppGlyphId )
{
uint16 usSegCount;
uint16 usnGlyphIds;
uint16 usBytesRead;
uint32 ulBytesRead;
int16 errCode;
CMAP_SUBHEADER CmapSubHeader;

// The commented part just below is code that is in ReadAllocCmapFormat4.
/*
   // find Format4 part of 'cmap' table

   	*ppFormat4Segments = NULL;	// in case of error
	*ppGlyphId = NULL;
	ulOffset = FindCmapSubtable( pInputBufferInfo, usPlatform, usEncoding, pusFoundEncoding );
   	if ( ulOffset == 0 )          
      	return( ERR_FORMAT );
*/

    /* read fixed length part of the table */
	/* test the waters with this little read */
   	if ((errCode = ReadGeneric( pInputBufferInfo, (uint8 *) &CmapSubHeader, SIZEOF_CMAP_SUBHEADER, CMAP_SUBHEADER_CONTROL, ulOffset, &usBytesRead )) != NO_ERROR)
		return(errCode);

   	if (CmapSubHeader.format != FORMAT4_CMAP_FORMAT)
      	return( ERR_FORMAT );

	/* OK, it really is format 4, read the whole thing */
	if ((errCode = ReadGeneric( pInputBufferInfo, (uint8 *) pCmapFormat4, SIZEOF_CMAP_FORMAT4, CMAP_FORMAT4_CONTROL, ulOffset, &usBytesRead )) != NO_ERROR)
		return(errCode);

   	usSegCount = pCmapFormat4->segCountX2 / 2;

   /* read variable length part */
   	ulOffset += usBytesRead;

	if ((errCode = ReadAllocCmapFormat4Segs( pInputBufferInfo, usSegCount, ppFormat4Segments, ulOffset, &ulBytesRead )) != NO_ERROR)
		return(errCode);
	if ( ulBytesRead == 0)	/* 0 could mean okey dokey */
      	return( NO_ERROR );                
   
    ulOffset += ulBytesRead;
  	if ((errCode = ReadAllocCmapFormat4Ids( pInputBufferInfo, usSegCount, *ppFormat4Segments, ppGlyphId, &usnGlyphIds, ulOffset, &ulBytesRead )) != NO_ERROR)
	{
		FreeCmapFormat4( *ppFormat4Segments, *ppGlyphId );
		*ppFormat4Segments = NULL;
		*ppGlyphId = NULL;
		return( errCode );
	}

   return( NO_ERROR );

}


// Given an offset pointing to a Format 4 encoding table,
// return all glyphs that exist in that table.
//
// This function is similar in function to MakeKeepGlyphList,
// except that here the input is an offset (rather than a
// PlatformID/EncodingID pair).
int16 MakeKeepGlyphListOffset(
TTFACC_FILEBUFFERINFO * pInputBufferInfo, /* ttfacc info */
CONST uint16 usListType, /* 0 = character list, 1 = glyph list */
uint32 ulOffset,
CONST uint16 usPlatform, /* cmap platform of the table */
CONST uint16 usEncoding, /* cmap encoding of the table */
CONST uint16 *pusKeepCharCodeList, /* list of chars to keep - from client */
CONST uint16 usCharListCount,	   /* count of list of chars to keep */
uint8 *puchKeepGlyphList, /* pointer to an array of chars representing glyphs 0-usGlyphListCount. */
CONST uint16 usGlyphListCount, /* count of puchKeepGlyphList array */
uint16 *pusMaxGlyphIndexUsed,
uint16 *pusGlyphKeepCount
)
{
uint16 i,j;
uint16 usGlyphIdx;
FORMAT4_SEGMENTS * Format4Segments=NULL;	/* pointer to Format4Segments array */
GLYPH_ID * GlyphId=NULL;	/* pointer to GlyphID array - for Format4 subtable */
CMAP_FORMAT6 CmapFormat6;	  /* cmap subtable headers */
CMAP_FORMAT4 CmapFormat4;
CMAP_FORMAT0 CmapFormat0;
MAXP Maxp;	/* local copy */
HEAD Head;	/* local copy */
uint16 usnComponents;
uint16 usnMaxComponents;
uint16 *pausComponents = NULL;
uint16 usnComponentDepth = 0;	
uint16 usIdxToLocFmt;
uint32 ulLocaOffset;
uint32 ulGlyfOffset;
uint16 *glyphIndexArray; /* for format 6 cmap subtables */
int16 errCode=NO_ERROR;
uint16 usFoundEncoding;
int16 KeepBullet = FALSE;
int16 FoundBullet = FALSE;
uint16 fKeepFlag; 
uint16 usGlyphKeepCount;
uint16 usMaxGlyphIndexUsed;

	if ( ! GetHead( pInputBufferInfo, &Head ))
		return( ERR_MISSING_HEAD );
	usIdxToLocFmt = Head.indexToLocFormat;

	if ( ! GetMaxp(pInputBufferInfo, &Maxp))
		return( ERR_MISSING_MAXP );
	
	if ((ulLocaOffset = TTTableOffset( pInputBufferInfo, LOCA_TAG )) == DIRECTORY_ERROR)
		return (ERR_MISSING_LOCA);

	if ((ulGlyfOffset = TTTableOffset( pInputBufferInfo, GLYF_TAG )) == DIRECTORY_ERROR)
		return (ERR_MISSING_GLYF);

	usnMaxComponents = Maxp.maxComponentElements * Maxp.maxComponentDepth; /* maximum total possible */
	pausComponents = (uint16 *) Mem_Alloc(usnMaxComponents * sizeof(uint16));
	if (pausComponents == NULL)
		return(ERR_MEM);

	/* fill in array of glyphs to keep.  Glyph 0 is the missing chr glyph,
	glyph 1 is the NULL glyph. */
	puchKeepGlyphList[ 0 ] = 1;
	puchKeepGlyphList[ 1 ] = 1;
	puchKeepGlyphList[ 2 ] = 1;

	if (usListType == TTFDELTA_GLYPHLIST)
	{
		for ( i = 0; i < usCharListCount; i++ )
			if (pusKeepCharCodeList[ i ] < usGlyphListCount)  /* don't violate array ! */
				puchKeepGlyphList[ pusKeepCharCodeList[ i ] ] = 1;
	}
	else
	{
// The following commented out line is from MakeKeepGlyphList
//		if ((errCode = ReadAllocCmapFormat4( pInputBufferInfo, usPlatform, usEncoding, &usFoundEncoding, &CmapFormat4, &Format4Segments, &GlyphId )) == NO_ERROR)	 /* found a Format4 Cmap */
	    if ((errCode = ReadAllocCmapFormat4Offset( pInputBufferInfo, ulOffset, &usFoundEncoding, &CmapFormat4, &Format4Segments, &GlyphId )) == NO_ERROR)	 /* found a Format4 Cmap */
		{

			for ( i = 0; i < usCharListCount; i++ )
			{
				usGlyphIdx = GetGlyphIdx( pusKeepCharCodeList[ i ], Format4Segments, (uint16)(CmapFormat4.segCountX2 / 2), GlyphId );
				if (usGlyphIdx != 0 && usGlyphIdx != INVALID_GLYPH_INDEX && usGlyphIdx < usGlyphListCount)
				{
					/* If the chr code exists, keep the glyph and its components.  Also
					account for this in the MinMax chr code global. */
					puchKeepGlyphList[ usGlyphIdx ] = 1;
					if (pusKeepCharCodeList[ i ] == WIN_ANSI_MIDDLEDOT) /* ~Backward Compatibility~! See comment at top of file */
						KeepBullet = TRUE;
					if (pusKeepCharCodeList[ i ] == WIN_ANSI_BULLET) /* ~Backward Compatibility~! See comment at top of file */
						FoundBullet = TRUE;
				}
			}
			/* ~Backward Compatibility~! See comment at top of file */
			if ((usPlatform == TTFSUB_MS_PLATFORMID && usEncoding == TTFSUB_UNICODE_CHAR_SET &&
				KeepBullet && !FoundBullet))  /* need to add that bullet into the list of CharCodes to keep, and glyphs to keep */
			{
				usGlyphIdx = GetGlyphIdx( WIN_ANSI_BULLET, Format4Segments, (uint16)(CmapFormat4.segCountX2 / 2), GlyphId );
				if (usGlyphIdx != 0 && usGlyphIdx != INVALID_GLYPH_INDEX && usGlyphIdx < usGlyphListCount)
				{
					puchKeepGlyphList[ usGlyphIdx ] = 1;  /* we are keeping 0xB7, so we must make sure to keep 0x2219 */
				}
			}
			FreeCmapFormat4( Format4Segments, GlyphId );
        }
//		else if ( (errCode = ReadCmapFormat0( pInputBufferInfo, usPlatform, usEncoding, &usFoundEncoding, &CmapFormat0)) == NO_ERROR)	 // found a Format0 Cmap
		else if ( (errCode = ReadCmapFormat0Offset( pInputBufferInfo, ulOffset, &usFoundEncoding, &CmapFormat0)) == NO_ERROR)	 // found a Format0 Cmap
 		{
	 		for (i = 0; i < usCharListCount; ++i)
			{
				if (pusKeepCharCodeList[ i ] < CMAP_FORMAT0_ARRAYCOUNT)
				{
			 		usGlyphIdx = CmapFormat0.glyphIndexArray[pusKeepCharCodeList[ i ]];
					if (usGlyphIdx < usGlyphListCount)
						puchKeepGlyphList[ usGlyphIdx ] = 1;	
				}
			}
		}
//      else if ( (errCode = ReadAllocCmapFormat6( pInputBufferInfo, usPlatform, usEncoding, &usFoundEncoding, &CmapFormat6, &glyphIndexArray)) == NO_ERROR)	 // found a Format6 Cmap
        else if ( (errCode = ReadAllocCmapFormat6Offset( pInputBufferInfo, ulOffset, &usFoundEncoding, &CmapFormat6, &glyphIndexArray)) == NO_ERROR)	 // found a Format6 Cmap
 		{
		uint16 firstCode = CmapFormat6.firstCode;

	 		for (i = 0; i < usCharListCount; ++i)
			{
				if 	((pusKeepCharCodeList[ i ] >= firstCode) && 
					 (pusKeepCharCodeList[ i ] < firstCode + CmapFormat6.entryCount))
				{
			 		usGlyphIdx = glyphIndexArray[pusKeepCharCodeList[ i ] - firstCode];
					if (usGlyphIdx < usGlyphListCount)
						puchKeepGlyphList[ usGlyphIdx ] = 1;	
				}
			}
			FreeCmapFormat6(glyphIndexArray);
		}

    }
	*pusGlyphKeepCount = 0;
	*pusMaxGlyphIndexUsed = 0;
	for (fKeepFlag = 1; errCode == NO_ERROR ; ++fKeepFlag)
	{
		usGlyphKeepCount = 0;
		usMaxGlyphIndexUsed = 0;
		/* Now gather up any components referenced by the list of glyphs to keep and TTO glyphs */
		for (usGlyphIdx = 0; usGlyphIdx < usGlyphListCount; ++usGlyphIdx) /* gather up any components */
		{
			if (puchKeepGlyphList[ usGlyphIdx ] == fKeepFlag)
			{
				usMaxGlyphIndexUsed = usGlyphIdx;
				++ (usGlyphKeepCount);

				GetComponentGlyphList( pInputBufferInfo, usGlyphIdx, &usnComponents, pausComponents, usnMaxComponents, &usnComponentDepth, 0, usIdxToLocFmt, ulLocaOffset, ulGlyfOffset);
				for ( j = 0; j < usnComponents; j++ )	/* check component value before assignment */
				{
					if ((pausComponents[ j ] < usGlyphListCount) && ((puchKeepGlyphList)[ pausComponents[ j ] ] == 0))
						(puchKeepGlyphList)[ pausComponents[ j ] ] = fKeepFlag + 1;  /* so it will be grabbed next time around */
				}
			}
		}
		*pusGlyphKeepCount += usGlyphKeepCount;
		*pusMaxGlyphIndexUsed = max(usMaxGlyphIndexUsed, *pusMaxGlyphIndexUsed);
		if (!usGlyphKeepCount) /* we didn't find any more */
			break;

		/* Now gather up any glyphs referenced by GSUB, GPOS, JSTF or BASE tables */
        // Add to the list of KeepGlyphs based on data from GSUB, BASE and JSTF table
		if ((errCode = TTOAutoMap(pInputBufferInfo, puchKeepGlyphList, usGlyphListCount, fKeepFlag)) != NO_ERROR)
			break;

        // Add to the list of KeepGlyphs based on data from Mort table
		if ((errCode = MortAutoMap(pInputBufferInfo, puchKeepGlyphList, usGlyphListCount, fKeepFlag)) != NO_ERROR)
			break;

	}
	Mem_Free(pausComponents);
	
	return errCode;
}




// Given an array of booleans (a characteristic array), output a
// list of USHORTs such that each element is set to TRUE in the
// characteristic array.
//
// This function assumes that pusList has been allocated at least
// usNumElements * sizeof(USHORT) bytes.
HRESULT CharArrayToList (UCHAR *puchArray,
                         USHORT usNumElements,
                         USHORT *pusList,
                         USHORT *pusListCount)
{
    USHORT i;

    *pusListCount = 0;
    for (i = 0; i < usNumElements; i++) {
        if (puchArray[i]) {
            pusList [*pusListCount] = i;
            (*pusListCount)++;
        }
    }

    return S_OK;
}


// Given an offset to a cmap format 0 encoding table, return the
// glyphs directly mapped to in the table.
HRESULT GetCmapFormat0Glyphs (TTFACC_FILEBUFFERINFO *pFileBufferInfo,
                              ULONG ulOffset,
                              UCHAR *puchGlyphs,
                              USHORT usNumGlyphs)
{
    HRESULT fReturn = E_FAIL;

    CMAP_FORMAT0 Cmap;
    USHORT usBytesRead; // never used -- needed as an argument
    ULONG ulBytesRead;  // never used -- needed as an argument

    USHORT i;

    // initialize puchGlyphs
    for (i = 0; i < usNumGlyphs; i++) {
        puchGlyphs[i] = FALSE;
    }

    // read the header part of the cmap encoding table
	if (ReadGeneric( pFileBufferInfo,
            (uint8 *) &Cmap,
            SIZEOF_CMAP_FORMAT0,
            CMAP_FORMAT0_CONTROL,
            ulOffset,
            &usBytesRead) != NO_ERROR) {
#if MSSIPOTF_ERROR
		SignError ("Error reading format 0 cmap encoding table.", NULL, FALSE);
#endif
        fReturn = MSSIPOTF_E_CANTGETOBJECT;
        goto done;
    }

/*
    // check the version number of the encoding table
    // BUGBUG: should have the version number in a .h file somewhere
    if (Cmap.revision != 0) {
        SignError ("Bad cmap encoding table version number.", NULL, FALSE);
        fReturn = SIGN_STRUCTURE;
        goto done;
    }
*/

    // check that the length of the encoding table is correct
    if (Cmap.length != ((3 * sizeof(USHORT)) + CMAP_FORMAT0_ARRAYCOUNT)) {
#if MSSIPOTF_ERROR
        SignError ("Incorrect length of format 0 cmap encoding table.", NULL, FALSE);
#endif
        fReturn = MSSIPOTF_E_CANTGETOBJECT;
        goto done;
    }

    // read in the glyphIdArray
	if (ReadGenericRepeat( pFileBufferInfo,
            (uint8 *) &(Cmap.glyphIndexArray),
            BYTE_CONTROL,
            ulOffset + usBytesRead,
            &ulBytesRead,
            CMAP_FORMAT0_ARRAYCOUNT,
            sizeof(uint8)) != NO_ERROR) {
#if MSSIPOTF_ERROR
		SignError ("Error reading format 0 cmap encoding table.", NULL, FALSE);
#endif
        fReturn = MSSIPOTF_E_CANTGETOBJECT;
        goto done;
    }

    // set puchGlyphs
    for (i = 0; i < CMAP_FORMAT0_ARRAYCOUNT; i++) {
        if (Cmap.glyphIndexArray[i] < usNumGlyphs) {
            puchGlyphs [ Cmap.glyphIndexArray[i] ] = TRUE;
        }
    }

    fReturn = S_OK;
done:
    return fReturn;
}


// Given an offset to a cmap format 4 encoding table, return the
// glyphs directly mapped to in the table.
HRESULT GetCmapFormat4Glyphs (TTFACC_FILEBUFFERINFO *pFileBufferInfo,
                              ULONG ulOffset,
                              uint16 usPlatform,
                              uint16 usEncoding,
                              UCHAR *puchGlyphs,
                              USHORT usNumGlyphs)
{
    HRESULT fReturn = E_FAIL;

	uint16 usFoundEncoding;
	CMAP_FORMAT4 CmapFormat4;
	FORMAT4_SEGMENTS *Format4Segments = NULL;
	GLYPH_ID * GlyphId = NULL;

	USHORT usSegCount;
	USHORT usCharListCount = 0;
	uint16 *pusCharPresentList = NULL;
	USHORT usCharListIndex;

	USHORT charsInSeg;

	uint16 usMaxGlyphIndexUsed = 0;
	uint16 usGlyphKeepCount = 0;

	USHORT i;
	USHORT j;


	//// Get the list of characters from the cmap table
	if (ReadAllocCmapFormat4Offset(
						pFileBufferInfo,
                        ulOffset,
						&usFoundEncoding,
						&CmapFormat4,
						&Format4Segments,
						&GlyphId ) != NO_ERROR) {
#if MSSIPOTF_ERROR
		SignError ("Error reading the cmap table.", NULL, FALSE);
#endif
        fReturn = MSSIPOTF_E_CANTGETOBJECT;
		goto done;
	}

	// Compute how many characters are represented in the cmap table
	usSegCount = CmapFormat4.segCountX2 / 2;
	for (i = 0; i < usSegCount; i++) {
		usCharListCount +=
			Format4Segments[i].endCount - Format4Segments[i].startCount + 1;
	}
	// allocate memory for puchCharPresentList
	if ((pusCharPresentList =
		    new uint16 [usCharListCount]) == NULL) {
#if MSSIPOTF_ERROR
		SignError ("Cannot continue: Error in new uint16.", NULL, FALSE);
#endif
		fReturn = E_OUTOFMEMORY;
		goto done;
	}
	// Run through the segments and set the pusCharPresentList array
	usCharListIndex = 0;
	for (i = 0; i < usSegCount; i++) {
		charsInSeg = Format4Segments[i].endCount - Format4Segments[i].startCount + 1;
		for (j = 0; j < charsInSeg; j++) {
			pusCharPresentList[usCharListIndex] = Format4Segments[i].startCount + j;
			usCharListIndex++;
		}
	}

#if DEBUG_CMAP
#if MSSIPOTF_DBG
	// print out the list of characters
	DbgPrintf ("Character list:\n");
	DbgPrintf ("0:\t");
	for (i = 0; i < usCharListCount; i++) {
		DbgPrintf ("%d\t", pusCharPresentList[i]);
		if (((i + 1) % 8) == 0) {
			DbgPrintf ("\n");
			DbgPrintf ("%d:\t", i + 1);
		}
	}
	DbgPrintf ("\n");
#endif
#endif

    // initialize puchGlyphs (it is assumed that the
    // memory has been allocated by the caller)
    for (i = 0; i < usNumGlyphs; i++) {
        puchGlyphs[i] = FALSE;
    }

	//// Call MakeKeepGlyphList to get the list of referenced
	//// glyphs from the characters in the cmap table in the TTF file.
	if (MakeKeepGlyphListOffset(pFileBufferInfo, // ttfacc info
						0, // 0 = character list, 1 = glyph list
                        ulOffset,
                        usPlatform,
                        usEncoding,
                        pusCharPresentList, // list of chars to keep - from client
						usCharListCount,	// count of list of chars to keep
						puchGlyphs,	// an array of chars representing
													// glyphs 0-usGlyphListCount. */
						usNumGlyphs,	// count of puchKeepGlyphList array
						&usMaxGlyphIndexUsed,
						&usGlyphKeepCount) != NO_ERROR) {
#if MSSIPOTF_ERROR
		SignError ("Error in MakeKeepGlyphList.", NULL, FALSE);
#endif
        fReturn = MSSIPOTF_E_CANTGETOBJECT;
		goto done;
	}

#if DEBUG_CMAP
#if MSSIPOTF_DBG
	// print out the list of glyphs
	DbgPrintf ("Glyph list:\n");
	DbgPrintf ("0:\t");
	for (i = 0; i < usNumGlyphs; i++) {
		if (puchGlyphs[i]) {
			DbgPrintf ("1\t");
		} else {
			DbgPrintf ("0\t");
		}
		if (((i + 1) % 8) == 0) {
			DbgPrintf ("\n");
			DbgPrintf ("%d:\t", i + 1);
		}
	}
	DbgPrintf ("\n");
#endif
#endif

	fReturn =  S_OK;

done:
	if (Format4Segments)
		free (Format4Segments);

	if (GlyphId)
		free (GlyphId);

	delete [] pusCharPresentList;
    return fReturn;
}


// Given an offset to a cmap format 6 encoding table, return the
// glyphs directly mapped to in the table.
HRESULT GetCmapFormat6Glyphs (TTFACC_FILEBUFFERINFO *pFileBufferInfo,
                              ULONG ulOffset,
                              UCHAR *puchGlyphs,
                              USHORT usNumGlyphs)
{
    HRESULT fReturn = E_FAIL;

    CMAP_FORMAT6 Cmap;
    USHORT *pGlyphIndexArray = NULL;
    USHORT usBytesRead; // never used
    ULONG ulBytesRead;  // never used

    USHORT i;

    // initialize puchGlyphs
    for (i = 0; i < usNumGlyphs; i++) {
        puchGlyphs[i] = FALSE;
    }

    // read the header part of the cmap encoding table
	if (ReadGeneric( pFileBufferInfo,
            (uint8 *) &Cmap,
            SIZEOF_CMAP_FORMAT6,
            CMAP_FORMAT6_CONTROL,
            ulOffset,
            &usBytesRead) != NO_ERROR) {
#if MSSIPOTF_ERROR
		SignError ("Error reading format 6 cmap encoding table.", NULL, FALSE);
#endif
        fReturn = MSSIPOTF_E_CANTGETOBJECT;
        goto done;
    }

    // check the version number of the encoding table
    // BUGBUG: should have the version number in a .h file somewhere
    if (Cmap.revision != 0) {
#if MSSIPOTF_ERROR
        SignError ("Bad cmap encoding table version number.", NULL, FALSE);
#endif
        fReturn = MSSIPOTF_E_BADVERSION;
        goto done;
    }

    // check that the length of the encoding table is correct
    if (Cmap.length != ((5 + Cmap.entryCount) * sizeof(USHORT))) {
#if MSSIPOTF_ERROR
        SignError ("Incorrect length of format 6 cmap encoding table.", NULL, FALSE);
#endif
        fReturn = MSSIPOTF_E_CANTGETOBJECT;
        goto done;
    }

    if ((pGlyphIndexArray =
            new USHORT [Cmap.entryCount * sizeof(uint16)] ) == NULL) {
#if MSSIPOTF_ERROR
        SignError ("Cannot continue: Error in new USHORT.", NULL, FALSE);
#endif
        fReturn = E_OUTOFMEMORY;
        goto done;
    }

    // read in the pGlyphIndexArray
	if (ReadGenericRepeat( pFileBufferInfo,
                    (uint8 *) *pGlyphIndexArray,
                    WORD_CONTROL,
                    ulOffset + usBytesRead,
                    &ulBytesRead,
                    Cmap.entryCount,
                    sizeof(uint16)) != NO_ERROR) {
#if MSSIPOTF_ERROR
        SignError ("Error reading format 6 cmap encoding table.", NULL, FALSE);
#endif
        fReturn = MSSIPOTF_E_CANTGETOBJECT;
		goto done;
    }

    // set puchGlyphs
    for (i = 0; i < Cmap.entryCount; i++) {
        puchGlyphs [ pGlyphIndexArray[i] ] = TRUE;
    }

    fReturn = S_OK;
done:
    delete [] pGlyphIndexArray;

    return fReturn;
}



// 
//
// Given a file buffer info and a GlyphInfo structure, return
// in pPresentGlyphList a char array telling which glyphs are
// present in the TTF file.
//
// This function assumes that the memory for pPresentGlyphList
// has already been allocated.
//
HRESULT GetPresentGlyphList (TTFACC_FILEBUFFERINFO *pFileBufferInfo,
                             UCHAR *puchPresentGlyphList,
                             USHORT usNumGlyphs)
{
    HRESULT fReturn = E_FAIL;
    USHORT i;

    ULONG *pulLoca = NULL;

    ULONG ulEncodingTable;
    ULONG ulCmapOffset;
    CMAP_HEADER CmapHeader;
    CMAP_TABLELOC CmapTableLoc;
    USHORT nCmapTables;
    USHORT usBytesRead;
    ULONG ulOffset;
    USHORT usTableFormat;

    USHORT *pusKeepCharCodeList = NULL;

    UCHAR *puchPresentGlyphListTemp = NULL;

    // pulLoca contains the offsets (as ULONGs) of the loca table,
    // regardless of whether they are long or shorts in the file.
    if ((pulLoca = new ULONG [usNumGlyphs + 1]) == NULL) {
#if MSSIPOTF_ERROR
        SignError ("Cannot continue: Error in new ULONG.", NULL, FALSE);
#endif
        fReturn = E_OUTOFMEMORY;
    }

    if (GetLoca (pFileBufferInfo, pulLoca, usNumGlyphs + 1) == 0L) {
#if MSSIPOTF_ERROR
        SignError ("Error reading loca table.", NULL, FALSE);
#endif
        fReturn = MSSIPOTF_E_CANTGETOBJECT;
        goto done;
    }

    // pusKeepCharCodeList is a list of USHORTs of glyph IDs
    if ((pusKeepCharCodeList = new USHORT [usNumGlyphs]) == NULL) {
#if MSSIPOTF_ERROR
        SignError ("Cannot continue: Error in new USHORT.", NULL, FALSE);
#endif
        fReturn = E_OUTOFMEMORY;
        goto done;
    }
   

    //// From the loca table, determine which glyphs that have glyph data.
    // (No need to initialize puchPresentGlyphList[i] to FALSE, since this
    // loop will set all entries.)
    for (i = 0; i < usNumGlyphs; i++) {
        puchPresentGlyphList[i] = (pulLoca[i] < pulLoca[i+1]);
    }

#if MSSIPOTF_DBG
    DbgPrintf ("puchPresentGlyphList (post loca) =\n");
    PrintBytes (puchPresentGlyphList, usNumGlyphs);
#endif


    // Read header of the 'cmap' table
    if (!(ulCmapOffset = TTTableOffset( pFileBufferInfo, CMAP_TAG ))) {
#if MSSIPOTF_ERROR
		SignError ("Error reading cmap table offset.", NULL, FALSE);
#endif
        fReturn = MSSIPOTF_E_CANTGETOBJECT;
        goto done;
    }
	if (ReadGeneric( pFileBufferInfo, (uint8 *) &CmapHeader,
            SIZEOF_CMAP_HEADER, CMAP_HEADER_CONTROL,
            ulCmapOffset, &usBytesRead) != NO_ERROR) {
#if MSSIPOTF_ERROR
		SignError ("Error reading cmap table header.", NULL, FALSE);
#endif
        fReturn = MSSIPOTF_E_CANTGETOBJECT;
        goto done;
    }

/*
    // Check for the version number of the cmap table
    // BUGBUG: should have default version numbers in a .h file somewhere
    if (CmapHeader.versionNumber != 0) {
        SignError ("Bad cmap version number.", NULL, FALSE);
        fReturn = SIGN_STRUCTURE;
        goto done;
    }
*/

    // pPresentGlyphListTemp is used to indicate which glyphs
    // are present in the current cmap encoding table (and is
    // unioned with the pPresentGlyphList at the end of each
    // iteration of the for loop).
    if ((puchPresentGlyphListTemp = new UCHAR [usNumGlyphs]) == NULL) {
#if MSSIPOTF_ERROR
        SignError ("Cannot continue: Error in new UCHAR.", NULL, FALSE);
#endif
        fReturn = E_OUTOFMEMORY;
        goto done;
    }

    // prepare to read the locations of each encoding table
	ulOffset = ulCmapOffset + usBytesRead;
	nCmapTables = CmapHeader.numTables;

    //// Iterate over all cmap subtables.
    //// Find any glyphs mentioned there.
    for (ulEncodingTable = 0;
        ulEncodingTable < nCmapTables;
        ulEncodingTable++, ulOffset += usBytesRead) {

		if (ReadGeneric( pFileBufferInfo, (uint8 *) &CmapTableLoc,
               SIZEOF_CMAP_TABLELOC, CMAP_TABLELOC_CONTROL,
               ulOffset, &usBytesRead) != NO_ERROR) {
#if MSSIPOTF_ERROR
			SignError ("Error reading cmap encoding table.", NULL, FALSE);
#endif
            fReturn = MSSIPOTF_E_CANTGETOBJECT;
            goto done;
        }

        // reset pPresentGlyphListTemp
        for (i = 0; i < usNumGlyphs; i++) {
            puchPresentGlyphListTemp[i] = FALSE;
        }

        // Find out which glyphs are referred directly in the encoding table.
        if (ReadWord (pFileBufferInfo,
                      &usTableFormat,
                      ulCmapOffset + CmapTableLoc.offset) != NO_ERROR) {
#if MSSIPOTF_ERROR
            SignError ("Error reading cmap encoding table format.", NULL, FALSE);
#endif
            fReturn = MSSIPOTF_E_CANTGETOBJECT;
            goto done;
        }
#if MSSIPOTF_DBG
        DbgPrintf ("++ Dealing with cmap table with format %d.\n", usTableFormat);
#endif
        switch (usTableFormat) {
            case FORMAT0_CMAP_FORMAT:
                if ((fReturn = GetCmapFormat0Glyphs (pFileBufferInfo,
                                    ulCmapOffset + CmapTableLoc.offset,
                                    puchPresentGlyphListTemp,
                                    usNumGlyphs)) != S_OK) {
                    goto done;
                }
                break;

            case FORMAT4_CMAP_FORMAT:
                if ((fReturn = GetCmapFormat4Glyphs (pFileBufferInfo,
                                    ulCmapOffset + CmapTableLoc.offset,
                                    CmapTableLoc.platformID,
                                    CmapTableLoc.encodingID,
                                    puchPresentGlyphListTemp,
                                    usNumGlyphs)) != S_OK) {
                    goto done;
                }
                break;

            case FORMAT6_CMAP_FORMAT:
                if ((fReturn = GetCmapFormat6Glyphs (pFileBufferInfo,
                                    ulCmapOffset + CmapTableLoc.offset,
                                    puchPresentGlyphListTemp,
                                    usNumGlyphs)) != S_OK) {
                    goto done;
                }
                break;

            default:
#if MSSIPOTF_DBG
                DbgPrintf ("Ignoring cmap encoding table %d.\n, ulEncodingTable");
#endif
                break;
        }

#if MSSIPOTF_DBG
        DbgPrintf ("puchPresentGlyphListTemp (post GetCmapFormatX) =\n");
        PrintBytes (puchPresentGlyphListTemp, usNumGlyphs);
#endif

        // Compute the union of puchPresentGlyphList and puchPresentGlyphListTemp.
        // Place the result in puchPresentGlyphList.
        for (i = 0; i < usNumGlyphs; i++) {
            puchPresentGlyphList[i] =
                (puchPresentGlyphList[i] || puchPresentGlyphListTemp[i]);
        }
    }


#if MSSIPOTF_DBG
    DbgPrintf ("puchPresentGlyphList =\n");
    PrintBytes (puchPresentGlyphList, usNumGlyphs);
#endif

    fReturn = S_OK;
done:
    delete [] pulLoca;

    delete [] puchPresentGlyphListTemp;

    delete [] pusKeepCharCodeList;

    return fReturn;
}


//
// Given a file buffer info and a list of glyph IDs that represents
// a subset, return in pPresentGlyphList the list of glyphs related
// to the input glyph list, where "related" means "can be traced in
// zero or more steps via the 'is a component of' relation."
//
HRESULT GetSubsetPresentGlyphList (TTFACC_FILEBUFFERINFO *pFileBufferInfo,
                                   USHORT *pusKeepCharCodeList,
                                   USHORT usCharListCount,
                                   UCHAR *puchPresentGlyphList,
                                   USHORT usNumGlyphs)
{
    HRESULT fReturn = E_FAIL;
    USHORT i;

    ULONG ulEncodingTable;
    ULONG ulCmapOffset;
    CMAP_HEADER CmapHeader;
    CMAP_TABLELOC CmapTableLoc;
    USHORT nCmapTables;
    USHORT usBytesRead;
    ULONG ulOffset;
    USHORT usTableFormat;

    USHORT usMaxGlyphIndexUsed; // never used
    USHORT usGlyphKeepCount;    // never used

    USHORT *pusKeepCharCodeListActual = NULL;
    UCHAR *puchPresentGlyphListTemp = NULL;
    UCHAR *pAllPresentGlyphList = NULL; // glyphs present in the font

    // allocate memory for the actual keep char code list (which might
    // be different from the one given as input to this function)
    if ((pusKeepCharCodeListActual = new USHORT [usNumGlyphs]) == NULL) {
#if MSSIPOTF_ERROR
        SignError ("Cannot continue: Error in new USHORT.", NULL, FALSE);
#endif
        fReturn = E_OUTOFMEMORY;
        goto done;
    }

    // allocate memory for an array that represents all present glyphs
    if ((pAllPresentGlyphList = new UCHAR [usNumGlyphs]) == NULL) {
#if MSSIPOTF_ERROR
        SignError ("Cannot continue: Error in new UCHAR.", NULL, FALSE);
#endif
        fReturn = E_OUTOFMEMORY;
        goto done;
    }

    //// Intersect the input subset with the set of present glyphs
    // Get the set of present glyphs in the file
    if ((fReturn = GetPresentGlyphList (pFileBufferInfo,
                                        pAllPresentGlyphList,
                                        usNumGlyphs)) != S_OK) {
#if MSSIPOTF_ERROR
        SignError ("Error in GetPresentGlyphList.", NULL, FALSE);
#endif
        goto done;
    }
    // ASSERT: pAllPresentGlyphList is a char-array of glyph ID's that
    // now says what glyphs are present.

    // Intersect the present glyphs with those we want to keep.
    for (i = 0; i < usNumGlyphs; i++) {
        puchPresentGlyphList [i] = FALSE;
    }
    for (i = 0; i < usCharListCount; i++) {
        if (pAllPresentGlyphList [ pusKeepCharCodeList [i] ]) {
            puchPresentGlyphList [ pusKeepCharCodeList [i] ] = TRUE;
        }
    }

    // convert puchPresentGlyphListTemp into a list of glyphs for MakeKeepGlyphList
    if ((fReturn = CharArrayToList (puchPresentGlyphList, usNumGlyphs,
                       pusKeepCharCodeListActual, &usCharListCount)) != S_OK) {
        goto done;
    }

    // ASSERT: puchPresentGlyphList [j] is TRUE iff it is in the input
    // list AND it is present in the font file.

    // Reinitialize the pAllPresentGlyphList array.
    for (i = 0; i < usNumGlyphs; i++) {
        pAllPresentGlyphList [i] = FALSE;
    }

    //// For each subtable in the cmap table, add to the list of
    //// present glyphs with respect to the input subset (by calling
    //// MakeKeepGlyphList).

    // Read header of the 'cmap' table
    if (!(ulCmapOffset = TTTableOffset( pFileBufferInfo, CMAP_TAG ))) {
#if MSSIPOTF_ERROR
		SignError ("Error reading cmap table offset.", NULL, FALSE);
#endif
        fReturn = MSSIPOTF_E_CANTGETOBJECT;
        goto done;
    }
	if (ReadGeneric( pFileBufferInfo, (uint8 *) &CmapHeader,
            SIZEOF_CMAP_HEADER, CMAP_HEADER_CONTROL,
            ulCmapOffset, &usBytesRead) != NO_ERROR) {
#if MSSIPOTF_ERROR
		SignError ("Error reading cmap table header.", NULL, FALSE);
#endif
        fReturn = MSSIPOTF_E_CANTGETOBJECT;
        goto done;
    }

/*
    // Check for the version number of the cmap table
    // BUGBUG: should have default version numbers in a .h file somewhere
    if (CmapHeader.versionNumber != 0) {
        SignError ("Bad cmap version number.", NULL, FALSE);
        fReturn = SIGN_STRUCTURE;
        goto done;
    }
*/
    
    // puchPresentGlyphListTemp is used to indicate which glyphs
    // are present in the current cmap encoding table (and is
    // unioned with the puchPresentGlyphList at the end of each
    // iteration of the for loop).
    if ((puchPresentGlyphListTemp = new UCHAR [usNumGlyphs]) == NULL) {
#if MSSIPOTF_ERROR
        SignError ("Cannot continue: Error in new UCHAR.", NULL, FALSE);
#endif
        fReturn = E_OUTOFMEMORY;
        goto done;
    }

    // prepare to read the locations of each encoding table
	ulOffset = ulCmapOffset + usBytesRead;
	nCmapTables = CmapHeader.numTables;

    //// Iterate over all cmap subtables.
    //// Find any glyphs mentioned there.
    for (ulEncodingTable = 0;
        ulEncodingTable < nCmapTables;
        ulEncodingTable++, ulOffset += usBytesRead) {

		if (ReadGeneric( pFileBufferInfo, (uint8 *) &CmapTableLoc,
               SIZEOF_CMAP_TABLELOC, CMAP_TABLELOC_CONTROL,
               ulOffset, &usBytesRead) != NO_ERROR) {
#if MSSIPOTF_ERROR
			SignError ("Error reading cmap encoding table.", NULL, FALSE);
#endif
            fReturn = MSSIPOTF_E_CANTGETOBJECT;
            goto done;
        }

        // reset pPresentGlyphListTemp
        for (i = 0; i < usNumGlyphs; i++) {
            puchPresentGlyphListTemp[i] = FALSE;
        }

        // Find out which glyphs are referred directly in the encoding table.
        if (ReadWord (pFileBufferInfo,
                      &usTableFormat,
                      ulCmapOffset + CmapTableLoc.offset) != NO_ERROR) {
#if MSSIPOTF_ERROR
            SignError ("Error reading cmap encoding table format.", NULL, FALSE);
#endif
            fReturn = MSSIPOTF_E_CANTGETOBJECT;
            goto done;
        }
#if MSSIPOTF_DBG
        DbgPrintf ("++ Dealing with cmap table with format %d.\n", usTableFormat);
#endif

        // Then find out which glyphs are components of the glyphs that
        // we know exist so far (by calling MakeKeepGlyphList).
        if ((fReturn = MakeKeepGlyphListOffset (pFileBufferInfo,
                            1, // 1 = glyph list
                            CmapTableLoc.offset,
                            CmapTableLoc.platformID,
                            CmapTableLoc.encodingID,
                            pusKeepCharCodeListActual,
                            usCharListCount,
                            puchPresentGlyphListTemp,
                            usNumGlyphs,
                            &usMaxGlyphIndexUsed,
                            &usGlyphKeepCount)) != S_OK) {
#if MSSIPOTF_ERROR
            SignError ("Error in MakeKeepGlyphList.", NULL, FALSE);
#endif
            goto done;
        }

#if MSSIPOTF_DBG
        DbgPrintf ("puchPresentGlyphListTemp (post MakeKeepGlyphList) =\n");
        PrintBytes (puchPresentGlyphListTemp, usNumGlyphs);
#endif


        // Compute the union of puchPresentGlyphList and puchPresentGlyphListTemp.
        // Place the result in puchPresentGlyphList.
        for (i = 0; i < usNumGlyphs; i++) {
            puchPresentGlyphList[i] =
                (puchPresentGlyphList[i] || puchPresentGlyphListTemp[i]);
        }

        // ASSERT: After each iteration, pAllPresentGlyphList indicates
        // the present glyphs, with respect to the input subset, over all
        // the cmap subtables examined so far.
    }
        

    fReturn = S_OK;
done:

    delete [] pusKeepCharCodeListActual;

    delete [] pAllPresentGlyphList;

    delete [] puchPresentGlyphListTemp;

    return fReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\sign\hashglyph.h ===
//
// hashGlyph.h
//
// (c) 1997-1998. Microsoft Corporation.
// Author: Donald Chinn
//
// Functions exported:
//   FreeGlyphInfo
//   PrintGlyphInfo
//   HashGlyph
//   hashGlyphNull
//

#ifndef _HASHGLYPH_H
#define _HASHGLYPH_H



#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x400
#endif

#include <windows.h>
#include <wincrypt.h>

#include "signglobal.h"

#include "ttfinfo.h"


// structure representing a kern pair and its value
typedef struct {
	USHORT left;
	USHORT right;
	USHORT value;
} Kern;

// To preventing having to access the tables associated
// with a glyph repeatedly, this data structure holds all
// of the information associated with all glyphs used for
// computing a hash value for glyphs.
typedef struct {
	USHORT *pusCmap;	// list of characters that map to the glyph
	USHORT usNumMapped;
	ULONG ulGlyf;		// offset from beginning of file to glyf table data block
	ULONG ulLength;		// length of glyf table data block
	USHORT usAdvanceWidth;	// advance width
	SHORT sLeftSideBearing;	// left side bearing
	Kern *pKern;		// list of kerning pair values involving the glyph
	USHORT usNumKern;
	BYTE bYpel;			// ypel
	USHORT usAdvanceHeight;	// advance height
	SHORT sTopSideBearing;	// top side bearing
} GlyphInfo;


void FreeGlyphInfo (GlyphInfo *pGlyphInfo, USHORT numGlyphs);

void PrintGlyphInfo (GlyphInfo *pGlyphInfo, USHORT numGlyphs);

/*
HRESULT HashGlyph (USHORT i,
                   BYTE *pbHash);

HRESULT HashGlyphNull (BYTE *phashValue);
*/

#endif  // _HASHGLYPH_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\sign\htblconst.h ===
//
// hTblConst.h
//
// (c) 1997-1998. Microsoft Corporation.
// Author: Donald Chinn
//
// Functions exported:
//   HashTableConst
//

#ifndef _HTBLCONST_H
#define _HTBLCONST_H



#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x400
#endif

#include <windows.h>
#include <wincrypt.h>

#include "signglobal.h"

#include "ttfinfo.h"


extern HRESULT HashTableConst (TTFACC_FILEBUFFERINFO *pFileBufferInfo,
                               CHAR *table_tag,
                               BYTE *pbHash,
                               DWORD cbHash,
                               HCRYPTPROV hProv,
                               ALG_ID alg_id);

#endif  // _HTBLCONST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\sign\htblglyf.cpp ===
//
// hTblGlyf.cpp
//
// (c) 1997-1998. Microsoft Corporation.
// Author: Donald Chinn
//
// Compute the hash value for the glyf table,
// which includes getting values from other
// tables.
//
// Functions in this file:
//   print_tabs
//   CreateNode
//   AppendNode
//   FreeList
//   ConcatList
//   GetCmapInfo
//   GetGlyphInfo
//   FirstPresentGlyph
//   NextPresentGlyph
//   FirstKeepGlyph
//   NextKeepGlyph
//   HashValueMissingGlyphs
//   MergeSubtreeHashes
//   HashValueGlyphRange
//   HashTable_glyf
//

// DEBUG_HTBLGLYF
// 2: print out the characters in the cmap file and
//    the glyphs generated by MakeKeepGlyphList.
// 1: print out the hash value generated along
//    with stats about how many nodes were touched, etc.
#define DEBUG_HTBLGLYF 2

// For printing out the recursion
#define TREETRACE 0

#define APPENDTRACE 1

#include "hTblGlyf.h"
#include "glyphExist.h"
#include "utilsign.h"
#include "cryptutil.h"
#include "signerr.h"

#include "subset.h"


// constructor for CHashTableGlyfContext
//
// The flag fDsigInfo indicates whether the given DsigInfo is valid.
CHashTableGlyfContext::CHashTableGlyfContext
					(TTFACC_FILEBUFFERINFO *pFileBufferInfo,
                     BOOL fDsigInfo,
					 CDsigInfo *pDsigInfo,
					 UCHAR *puchKeepList,
					 DWORD cbHash,
					 HCRYPTPROV hProv,
                     ALG_ID alg_id)
{
	HRESULT fReturn E_FAIL;

	this->pFileBufferInfo = pFileBufferInfo;
    this->fDsigInfo = fDsigInfo;
	this->pDsigInfo = pDsigInfo;
	ulNumMissing = pDsigInfo->GetNumMissingGlyphs();
	ulOffsetMissing = 0;
	pbOldMissingHashValues = pDsigInfo->GetMissingGlyphs();
	pHashListNodeHead = NULL;
	pHashListNodeTail = NULL;
	this->hProv = hProv;
	hashAlg = alg_id;
	this->cbHash = cbHash;
	usNumGlyphs = GetNumGlyphs (pFileBufferInfo);
	this->puchKeepList = puchKeepList;

	ulMissingHashValues = 0;
	ulNodesTouched = 0;
	ulHashComputations = 0;

    
    // allocate memory for puchPresentList
    if ((puchPresentList = new UCHAR [usNumGlyphs]) == NULL) {
#if MSSIPOTF_ERROR
        SignError ("Cannot continue: Error in new UCHAR.", NULL, FALSE);
#endif
        fReturn = E_OUTOFMEMORY;
        goto done;
    }

	// set the present list
	if ((fReturn = GetPresentGlyphList (this->pFileBufferInfo,
                                        puchPresentList,
                                        usNumGlyphs)) != S_OK) {
#if MSSIPOTF_DBG
		DbgPrintf ("Error in GetPresentGlyphList.\n");
#endif
		goto done;
	}

	// allocate memory for pGlyphInfo
	if ((pGlyphInfo = new GlyphInfo [usNumGlyphs]) == NULL) {
#if MSSIPOTF_ERROR
		SignError ("Cannot continue: Error in new GlyphInfo.", NULL, FALSE);
#endif
		fReturn = E_OUTOFMEMORY;
		goto done;
	}

	// set the GlyphInfo structure
	if ((fReturn = GetGlyphInfo (pGlyphInfo)) != S_OK) {
#if MSSIPOTF_DBG
		DbgPrintf ("Error in GetGlyphInfo.\n");
#endif
		goto done;
	}

    // NOTE: There is a small inefficiency in the calls to GetPresentGlyphList
    // and GetGlyphInfo above.  Each of the two functions needs to read the cmap
    // table.  A function that did both of these tasks could read through
    // the cmap table once, but it wouldn't be as modular.

	fReturn = S_OK;
done:
    if (fReturn != S_OK) {
        exit (fReturn);
    }
}


// destructor for CHashTableGlyfContext
CHashTableGlyfContext::~CHashTableGlyfContext ()
{
	// Free resources
	if (pGlyphInfo) {
//		PrintGlyphInfo (pGlyphInfo, usNumGlyphs);
		FreeGlyphInfo (pGlyphInfo, usNumGlyphs);
	}

	delete [] puchPresentList;
	puchPresentList = NULL;

	delete [] puchKeepList;
	puchKeepList = NULL;
}


void print_tabs (int i)
{
#if MSSIPOTF_DBG
	for (; i > 0; i--) {
		DbgPrintf ("  ");
	}
#endif
}


////--------
//// Routines to manipulate a linked list
//// of hash values.

// Create node
// Given the range of missing hash value and
// a pointer to cb bytes, return
// in ppNew a new node.
HRESULT CreateNode (USHORT low, USHORT high, BYTE *pb, ULONG cb, ListNode **ppNew)
{
	HRESULT fReturn = E_FAIL;

	if ((*ppNew = new ListNode) == NULL) {
#if MSSIPOTF_ERROR
		SignError ("Cannot continue: Error in new ListNode.",
            NULL, FALSE);
#endif
		fReturn = E_OUTOFMEMORY;
		goto done;
	}
	(*ppNew)->low = low;
	(*ppNew)->high = high;

	if (((*ppNew)->pb = new BYTE [cb]) == NULL) {
#if MSSIPOTF_ERROR
		SignError ("Cannot continue: Error in new BYTE.", NULL, FALSE);
#endif

        delete *ppNew;
		fReturn = E_OUTOFMEMORY;
		goto done;
	}
	ByteCopy ((*ppNew)->pb, pb, cb);
	(*ppNew)->cb = cb;
	(*ppNew)->next = NULL;

	fReturn = S_OK;

done:
	return fReturn;
}


// Append
// Given a pointer to the head and tail nodes,
// add the given node to the list at the tail.
HRESULT AppendNode (ListNode *pNew, ListNode **ppHead, ListNode **ppTail)
{
	if (*ppHead == NULL) {
		assert (*ppTail == NULL);
		pNew->next = NULL;
		*ppTail = pNew;
		*ppHead = pNew;
	} else {
		assert ((*ppTail)->next == NULL);
		(*ppTail)->next = pNew;
		pNew->next = NULL;
		*ppTail = pNew;
	}

	return S_OK;
}


// Free an entire list
HRESULT FreeList (ListNode *pHead)
{
	ListNode *pCurrent = pHead;
	ListNode *pNext;

	while (pCurrent != NULL) {
		pNext = pCurrent->next;
		delete [] pCurrent->pb;
		delete pCurrent;
		pCurrent = pNext;
	}

	return S_OK;
}


// Given the head of a list, concatenate all of the
// hash values in the list (from head to tail) as a
// single stream of bytes and return it in ppNew.
// Also, return in pNumElem the number of elements in the list
HRESULT ConcatList (ListNode *pHead, USHORT *pNumElem, BYTE **ppNew, ULONG *cb)
{
	HRESULT fReturn = E_FAIL;

	ListNode *pTempOld;	// for walking down the linked list
	BYTE *pTempNew;			// for walking down the ppNew memory

	// Compute how many elements and
	// compute how many bytes in the entire list
	*pNumElem = 0;
	*cb = 0;
	pTempOld = pHead;
	while (pTempOld != NULL) {
		(*pNumElem)++;
		(*cb) += pTempOld->cb;
		pTempOld = pTempOld->next;
	}

	// Allocate space for the new byte stream
	if ((*ppNew = new BYTE [*cb]) == NULL) {
#if MSSIPOTF_ERROR
		SignError ("Cannot continue: Error in new BYTE.", NULL, FALSE);
#endif
		fReturn = E_OUTOFMEMORY;
		goto done;
	}

	// Walk down the list, copying each range and hash value
	// into the new space.
	pTempOld = pHead;
	pTempNew = *ppNew;
	while (pTempOld != NULL) {
		ByteCopy (pTempNew, pTempOld->pb, pTempOld->cb);
		pTempNew += pTempOld->cb;
		pTempOld = pTempOld->next;
	}

	fReturn = S_OK;
done:
	return fReturn;
}


////--------

//
// Set the cmap part of the GlyphInfo structure.
// Return a list of present glyphs, as defined
// by the cmap table and a call to automap.
//
// Note that there are two passes over the cmap
// table.  One pass is to construct a list of
// characters in the cmap table.  The second
// pass is in MakeKeepGlyphList when the characters
// are mapped to glyphs.
//
HRESULT CHashTableGlyfContext::GetCmapInfo (GlyphInfo *pGlyphInfo,
                                            UCHAR **ppuchPresentGlyphsList)
{
	HRESULT fReturn = E_FAIL;

    uint16 usFoundEncoding;
	CMAP_FORMAT4 CmapFormat4;
	FORMAT4_SEGMENTS *Format4Segments = NULL;
	GLYPH_ID * GlyphId = NULL;

	USHORT usSegCount;
	USHORT usCharListCount = 0;
	uint16 *pusCharPresentList = NULL;
	USHORT usCharListIndex;

	USHORT charsInSeg;

	uint16 usMaxGlyphIndexUsed = 0;
	uint16 usGlyphKeepCount = 0;

	USHORT i;
	USHORT j;


	// Allocate memory for *ppuchPresentGlyphsList
	assert (*ppuchPresentGlyphsList == NULL);
	if ((*ppuchPresentGlyphsList =
			new BYTE [usNumGlyphs]) == NULL) {
#if MSSIPOTF_ERROR
		SignError ("Cannot continue: Error in new BYTE.", NULL, FALSE);
#endif
		fReturn = E_OUTOFMEMORY;
		goto done;
	}

	//// Get the list of characters from the cmap table
	if (ReadAllocCmapFormat4(pFileBufferInfo,
                    3,	// platform. BUGBUG: need to make this more general
                    1,	// encoding. BUGBUG: need to make this more general
                    &usFoundEncoding,
                    &CmapFormat4,
                    &Format4Segments,
                    &GlyphId ) != NO_ERROR) {
#if MSSIPOTF_ERROR
		SignError ("Error reading the cmap table.", NULL, FALSE);
#endif
        fReturn = MSSIPOTF_E_CANTGETOBJECT;
		goto done;
	}

	// Compute how many characters are represented in the cmap table
	usSegCount = CmapFormat4.segCountX2 / 2;
	for (i = 0; i < usSegCount; i++) {
		usCharListCount +=
			Format4Segments[i].endCount - Format4Segments[i].startCount + 1;
	}
	// allocate memory for puchCharPresentList
	if ((pusCharPresentList =
		    new uint16 [usCharListCount]) == NULL) {
#if MSSIPOTF_ERROR
		SignError ("Cannot continue: Error in new uint16.", NULL, FALSE);
#endif
		fReturn = E_OUTOFMEMORY;
		goto done;
	}
	// Run through the segments and set the pusCharPresentList array
	usCharListIndex = 0;
	for (i = 0; i < usSegCount; i++) {
		charsInSeg = Format4Segments[i].endCount - Format4Segments[i].startCount + 1;
		for (j = 0; j < charsInSeg; j++) {
			pusCharPresentList[usCharListIndex] = Format4Segments[i].startCount + j;
			usCharListIndex++;
		}
	}

#if (DEBUG_HTBLGLYF == 2)
#if MSSIPOTF_DBG
	// print out the list of characters
	DbgPrintf ("Character list:\n");
	DbgPrintf ("0:\t");
	for (i = 0; i < usCharListCount; i++) {
		DbgPrintf ("%d\t", pusCharPresentList[i]);
		if (((i + 1) % 8) == 0) {
			DbgPrintf ("\n");
			DbgPrintf ("%d:\t", i + 1);
		}
	}
	DbgPrintf ("\n");
#endif
#endif

	// initialize the present glyphs array
	for (i = 0; i < usNumGlyphs; i++) {
		(*ppuchPresentGlyphsList)[i] = FALSE;
	}

	//// Call MakeKeepGlyphList to get the list of referenced
	//// glyphs from the characters in the cmap table in the TTF file.
	if (MakeKeepGlyphList(pFileBufferInfo, // ttfacc info
                        0, // 0 = character list, 1 = glyph list
                        3, // cmap platform to look for
                        1, // cmap encoding to look for
                        pusCharPresentList, // list of chars to keep - from client
                        usCharListCount,	// count of list of chars to keep
                        *ppuchPresentGlyphsList,	// an array of chars representing
                                                    // glyphs 0-usGlyphListCount.
                        usNumGlyphs,        // count of puchKeepGlyphList array
                        &usMaxGlyphIndexUsed,
                        &usGlyphKeepCount) != NO_ERROR) {
#if MSSIPOTF_ERROR
		SignError ("Cannot continue: Error in MakeKeepGlyphList.", NULL, FALSE);
#endif
        fReturn = MSSIPOTF_E_CANTGETOBJECT;
		goto done;
	}

#if (DEBUG_HTBLGLYF == 2)
#if MSSIPOTF_DBG
	// print out the list of glyphs
	DbgPrintf ("Glyph list:\n");
	DbgPrintf ("0:\t");
	for (i = 0; i < usNumGlyphs; i++) {
		if ((*ppuchPresentGlyphsList)[i]) {
			DbgPrintf ("1\t");
		} else {
			DbgPrintf ("0\t");
		}
		if (((i + 1) % 8) == 0) {
			DbgPrintf ("\n");
			DbgPrintf ("%d:\t", i + 1);
		}
	}
	DbgPrintf ("\n");
#endif
#endif

	fReturn =  S_OK;

done:
	if (Format4Segments)
		free (Format4Segments);

	if (GlyphId)
		free (GlyphId);

	delete [] pusCharPresentList;

	return fReturn;
}


//
// Return an array of GlyphInfo structures that
// contains all of the information needed to compute
// a hash value for glyphs 0 through usNumGlyphs.
//
HRESULT CHashTableGlyfContext::GetGlyphInfo (GlyphInfo *pGlyphInfo)
{
	HRESULT fReturn = E_FAIL;
	USHORT i;

	ULONG ulGlyfOffset;
	ULONG *pulLoca = NULL;

	// characters that map to glyphs
	for (i = 0; i < usNumGlyphs; i++) {
		pGlyphInfo[i].pusCmap = NULL;
		pGlyphInfo[i].usNumMapped = 0;	
	}

	// glyf table data
	ulGlyfOffset = TTTableOffset (pFileBufferInfo, GLYF_TAG);
	if ((pulLoca = new ULONG [usNumGlyphs + 1]) == NULL) {
#if MSSIPOTF_ERROR
		SignError ("Cannot continue: Error in new ULONG.", NULL, FALSE);
#endif
		fReturn = E_OUTOFMEMORY;
		goto done;
	}
	if (GetLoca(pFileBufferInfo, pulLoca, usNumGlyphs + 1) == 0L) {
#if MSSIPOTF_ERROR
		SignError ("Cannot continue: Error in GetLoca.", NULL, FALSE);
#endif
        fReturn = MSSIPOTF_E_CANTGETOBJECT;
		goto done;
	}
	for (i = 0; i < usNumGlyphs; i++) {
		pGlyphInfo[i].ulGlyf = ulGlyfOffset + pulLoca[i];
		pGlyphInfo[i].ulLength =  pulLoca[i+1] - pulLoca[i];
	}


	// advance width and left side bearing

	// kerning pairs
	for (i = 0; i < usNumGlyphs; i++) {
		pGlyphInfo[i].pKern = NULL;
		pGlyphInfo[i].usNumKern = 0;	
	}

	// ypel value

	// advance height and top side bearing

	fReturn = S_OK;

done:
	// Free resources
	if (pulLoca)
		delete [] pulLoca;

	return fReturn;
}


// Return the first present glyph in puchPresentList.
void CHashTableGlyfContext::FirstPresentGlyph (LONG *present)
{
	*present = 0;
	for ( ; (*present <= usNumGlyphs) && (puchPresentList[*present] == FALSE);
		(*present)++) {
	}
	if (*present > usNumGlyphs) {
		*present = NONEXT;
	}
}


// Given the current present glyph, return in *present
// the next present glyph.  If there is no next present
// glyph, return NONEXT.
void CHashTableGlyfContext::NextPresentGlyph (LONG *present)
{
	// if *present = NONEXT, then we leave *present = NONEXT
	if (*present != NONEXT) {
		(*present)++;
		for ( ; (*present <= usNumGlyphs) && (puchPresentList[*present] == FALSE);
			(*present)++) {
		}
		if (*present > usNumGlyphs) {
			*present = NONEXT;
		}
	}
}


// Return the first keep glyph in puchKeepList.
void CHashTableGlyfContext::FirstKeepGlyph (LONG *keep)
{
	*keep = 0;
	for ( ; (*keep <= usNumGlyphs) && (puchKeepList[*keep] == FALSE);
		(*keep)++) {
	}
	if (*keep > usNumGlyphs) {
		*keep = NONEXT;
	}
}


// Given the current keep glyph, return in *keep
// the next keep glyph in puchKeepList.
// If there is no next keep glyph, return NONEXT.
void CHashTableGlyfContext::NextKeepGlyph (LONG *keep)
{
	// if *keep = NONEXT, then we leave *keep = NONEXT
	if (*keep != NONEXT) {
		(*keep)++;
		for ( ; (*keep <= usNumGlyphs) && (puchKeepList[*keep] == FALSE);
			(*keep)++) {
		}
		if (*keep > usNumGlyphs) {
			*keep = NONEXT;
		}
	}
}


// Return in pbHash the next hash value in the static
// variable pbMissingHashValues.  The static variable
// ulOffsetMissing points to the hash value to be returned.
// The funtion then updates the static variable
// ulOffsetMissing to point to the next missing hash value.
//
// This function assumes that pbOldMissingHashValues points
// to a number of bytes that is a multiple of cbHash.
HRESULT CHashTableGlyfContext::HashValueMissingGlyphs (BYTE *pbHash)
{
	HRESULT fReturn = E_FAIL;

	// check if there are too few missing hash values
	if ((ulOffsetMissing / cbHash) >= ulNumMissing) {
#if MSSIPOTF_ERROR
		SignError ("Not enough missing hash values.", NULL, FALSE);
#endif
		fReturn = MSSIPOTF_E_CANTGETOBJECT;
		goto done;
	}
	// Get the bytes
	ByteCopy (pbHash, pbOldMissingHashValues + ulOffsetMissing, cbHash);
	ulOffsetMissing += cbHash;

	ulMissingHashValues++;
	ulNodesTouched++;

	fReturn = S_OK;

done:
	return fReturn;
}



// Perform a hash on the concatentation of the low and high hash values
// and place the result in hashValue.
HRESULT CHashTableGlyfContext::MergeSubtreeHashes (BYTE *pbHashLow,
                                                   BYTE *pbHashHigh,
                                                   BYTE *pbHash)
{
    HRESULT fReturn = E_FAIL;
    HCRYPTHASH hHash;

    //// Create a hash object, feed the two hash values into
    //// CryptHashData, and return the resulting hash value.

    // Set hHash to be the hash object.
    if (!CryptCreateHash(hProv, hashAlg, 0, 0, &hHash)) {
#if MSSIPOTF_ERROR
        SignError ("Error during CryptCreateHash.",
                "MergeSubtreeHashes", TRUE);
#endif
        fReturn = MSSIPOTF_E_CRYPT;
        goto done;
	}

	// Feed pbHashLow and pbHashHigh into CryptHashData
	if (!CryptHashData(hHash, pbHashLow, cbHash, 0)) {
#if MSSIPOTF_ERROR
		SignError ("Error during CryptHashData.", NULL, TRUE);
#endif
		fReturn = MSSIPOTF_E_CRYPT;
		goto done;
	}

	if (!CryptHashData(hHash, pbHashHigh, cbHash, 0)) {
#if MSSIPOTF_ERROR
		SignError ("Error during CryptHashData.", NULL, TRUE);
#endif
		fReturn = MSSIPOTF_E_CRYPT;
		goto done;
	}

	if (!CryptGetHashParam(hHash, HP_HASHVAL, pbHash, &cbHash, 0)) {
#if MSSIPOTF_ERROR
		SignError ("Error during CryptGetHashParam (hash value).", NULL, TRUE);
#endif
		fReturn = MSSIPOTF_E_CRYPT;
		goto done;
	}

	// pbHash now contains the hash value.

	ulNodesTouched += 3;
	ulHashComputations++;

	fReturn = S_OK;

done:
	// Free resources
	if (hHash)
		CryptDestroyHash (hHash);

	return fReturn;
}



#define LEFT_SUBTREE 0
#define RIGHT_SUBTREE 1
#define OUTSIDE_TREE 2

// Return the hash value of a range of glyph numbers.
HRESULT CHashTableGlyfContext::HashValueGlyphRange
					(USHORT i, USHORT j,
                     LONG *next_present, LONG *next_keep,
                     int fSuppressAppend,
                     BYTE *pbHash,
                     int level)
{
	HRESULT fReturn = E_FAIL;
    
    USHORT numNodes;	// number of nodes in the (sub)tree,
					// which equals j - i + 1
	USHORT near2NumNodes;	// closest power of 2 to numNodes
							// (== near_2 (numNodes)).

	USHORT numLeft;	// number of nodes in the left subtree
	int where_next_keep_preleft;	// which subtree (or possibly outside the tree) the
									// next keep glyph is before left subtree traversal
	int where_next_keep_postleft;	// which subtree (or possibly outside the tree) the
									// next keep glyph is just after left subtree traversal
	int fSuppressLeftSubtree, fSuppressRightSubtree;
	BYTE *pbHashLow = NULL;		// hash value for left subtree
	BYTE *pbHashHigh = NULL;	// hash value for right subtree
	ListNode *pMissingHashNode;

	

#if TREETRACE
#if MSSIPOTF_DBG
	print_tabs (level);
	DbgPrintf ("Dealing with [%d, %d].\n", i, j);
#endif
#endif

	assert((*next_keep == NONEXT) || (*next_keep >= *next_present));

    if ((*next_present < i) && (*next_present != NONEXT)) {

        // we should have already dealt with the next present
        // glyph and advanced it beyond i
#if MSSIPOTF_DBG
		DbgPrintf ("Error: *next_present < i.\n");
#endif
		fReturn = MSSIPOTF_E_CANTGETOBJECT;
		goto done;

	} else if (i == j) {
		if (*next_present == i) {
			NextPresentGlyph (next_present);  // advance to next glyph
            if (*next_present == NONEXT) {
                *next_keep = NONEXT;
            }
			while ((*next_keep != NONEXT) && (*next_keep < *next_present)) {
				NextKeepGlyph (next_keep);
			}
            // generate the hash value for the glyph
			fReturn = HashGlyph (i, pbHash);

//			cout << "Hash value of glyph " << dec << i << ":" << endl;
//			PrintBytes (pbHash, cbHash);

		} else if (this->fDsigInfo) {
            // Glyph i is not present and the DsigInfo is valid, so
            // we must retrieve its hash value from the DsigInfo
		    if ((fReturn = HashValueMissingGlyphs (pbHash)) != NO_ERROR) {
#if MSSIPOTF_DBG
			    DbgPrintf ("Error in HashValueMissingGlyphs.\n");
#endif
			    goto done;
		    }

#if APPENDTRACE
#if MSSIPOTF_DBG
		print_tabs (level + 1);
		DbgPrintf ("Retrieved missing hash value for [%d, %d].\n", i, j);
		PrintBytes (pbHash, cbHash);
#endif
#endif

        } else {
			// Glyph i is not present and the DsigInfo is not valid, so
            // we must generate a hash value for the missing (null) glyph.
			fReturn = HashGlyphNull (pbHash);
		}

	} else if ( ((*next_present > j) || (*next_present == NONEXT)) &&
                (this->fDsigInfo) ) {

        // the next present glyph is outside the range of i and j and
        // the DsigInfo is valid, so we retrieve its hash value from DsigInfo
		if ((fReturn = HashValueMissingGlyphs (pbHash)) != NO_ERROR) {
#if MSSIPOTF_DBG
			DbgPrintf ("Error in HashValueMissingGlyphs.\n");
#endif
			goto done;
		}

#if APPENDTRACE
#if MSSIPOTF_DBG
		print_tabs (level + 1);
		DbgPrintf ("Retrieved missing hash value for [%d, %d].\n", i, j);
		PrintBytes (pbHash, cbHash);
#endif
#endif

	} else {

        // Either there is a present glyph in the range [i,j] (inclusive) or
        // the DsigInfo is invalid (which means we need to generate the hash
        // value of this node of the tree by recursively generating the hash
        // values of the subtrees).

		numNodes = j - i + 1;
		assert (numNodes >= 2);

		near2NumNodes = near_2 (numNodes);

		// At this point, if (numNodes == near2NumNodes), then 
		// numNodes is a power of 2, and both subtrees are full
		// binary trees.  So, the number of nodes in each subtree
		// is near2NumNodes / 2.  Otherwise,
		// (near2NumNodes / 2) + min(near2NumNodes / 2, (numNodes - // near2NumNodes))
		// is the number of nodes in the left subtree, and
		// numNodes - (# in left subtree) is the number of nodes in
		// the right subtree.
		if (numNodes == near2NumNodes) {
			numLeft = near2NumNodes / 2;
			// numRight = near2NumNodes / 2;
		} else {
			numLeft = (near2NumNodes / 2) + 
					__min(near2NumNodes / 2, (numNodes - near2NumNodes));
		}


		//// Here is a chart that describes what flag to pass down and
		//// whether to append a hash value.
		//
		// Value of where_next_keep_preleft
		// before left subtree traversal:  Action:
		//   LEFT_SUBTREE                  inherit fSuppressAppend
		//   RIGHT_SUBTREE                 suppress left subtree, append left subtree hash
		//   OUTSIDE_TREE                  suppress both subtrees, append combined hash
		//
		// If where_next_keep_preleft equals LEFT_SUBTREE before the left subtree traversal,
		//   then we check *next_keep again after the left subtree traversal.  Then:
		// If *next_keep is in the right subtree, then the call to the right subtree
		//   inherits fSuppressAppend.
		// If *next_keep is outside the tree, then we suppress the right subtree and
		//   append the right subtree hash.
		//
		// If where_next_keep_preleft does not equal LEFT_SUBTREE before the left subtree
		//   traversal, then *next_keep should not have changed values after
		//   traversing the left subtree (and so where_next_keep_preleft should
		//   equal where_next_keep_postleft).
		////
		////

		// which subtree is the next keep glyph in
		if ((i <= *next_keep) && (*next_keep <= i + numLeft - 1)) {
			where_next_keep_preleft = LEFT_SUBTREE;
		} else if ((i + numLeft <= *next_keep) && (*next_keep <= j)) {
			where_next_keep_preleft = RIGHT_SUBTREE;
		} else {
			where_next_keep_preleft = OUTSIDE_TREE;
		}

		fSuppressLeftSubtree =
			(fSuppressAppend || (where_next_keep_preleft != LEFT_SUBTREE)) ?
			TRUE: FALSE;

		// Allocate memory for pbHashLow
		if ((pbHashLow = new BYTE [cbHash]) == NULL) {
#if MSSIPOTF_ERROR
			SignError ("Cannot continue: Error in new BYTE.", NULL, FALSE);
#endif
			fReturn = E_OUTOFMEMORY;
			goto done;
		}

		//// Traverse the left subtree
		if ((fReturn = HashValueGlyphRange (i, i + numLeft - 1,
								next_present, next_keep,
								fSuppressLeftSubtree,
								pbHashLow,
								level + 1)) != S_OK) {
#if MSSIPOTF_DBG
			DbgPrintf ("Error in HashValueGlyphRange [%d, %d].\n",
				i, i + numLeft - 1);
#endif
			goto done;
		}
		if ((!fSuppressAppend) && (where_next_keep_preleft == RIGHT_SUBTREE)) {
			// Append a node to the linked list of hashes
			if ((fReturn = CreateNode (i, i + numLeft - 1,
								pbHashLow, cbHash, &pMissingHashNode)) != NO_ERROR) {
#if MSSIPOTF_DBG
				DbgPrintf ("Error in CreateNode.\n");
#endif
				goto done;
			}
			AppendNode (pMissingHashNode, &pHashListNodeHead, &pHashListNodeTail);
#if APPENDTRACE
#if MSSIPOTF_DBG
			print_tabs (level + 1);
			DbgPrintf ("Appending hash value for [%d, %d].\n",
				i, i + numLeft - 1);
			PrintBytes (pbHashLow, cbHash);
#endif
#endif

		}

		// which subtree is the next keep glyph in
		if ((i <= *next_keep) && (*next_keep <= i + numLeft - 1)) {
			// this branch should not be taken
			where_next_keep_postleft = LEFT_SUBTREE;
			assert (0);
		} else if ((i + numLeft <= *next_keep) && (*next_keep <= j)) {
			where_next_keep_postleft = RIGHT_SUBTREE;
		} else {
			where_next_keep_postleft = OUTSIDE_TREE;
		}

		if (where_next_keep_preleft == LEFT_SUBTREE) {
			if (where_next_keep_postleft == RIGHT_SUBTREE) {
				fSuppressRightSubtree = fSuppressAppend;
			} else {
				assert (where_next_keep_postleft == OUTSIDE_TREE);
				fSuppressRightSubtree = TRUE;
			}
		} else {
			assert (where_next_keep_preleft == where_next_keep_postleft);
			fSuppressRightSubtree =
				(fSuppressAppend || (where_next_keep_preleft == OUTSIDE_TREE)) ?
				TRUE : FALSE;
		}

		// Allocate memory for pbHashHigh
		if ((pbHashHigh = new BYTE [cbHash]) == NULL) {
#if MSSIPOTF_ERROR
			SignError ("Cannot continue: Error in new BYTE.", NULL, FALSE);
#endif
			fReturn = E_OUTOFMEMORY;
			goto done;
		}

		//// Traverse the right subtree
		if ((fReturn = HashValueGlyphRange (i + numLeft, j,
								next_present, next_keep,
								fSuppressRightSubtree,
								pbHashHigh,
                                level + 1)) != S_OK) {
#if MSSIPOTF_DBG
			DbgPrintf ("Error in HashValueGlyphRange [%d, %d].\n",
				i + numLeft, j);
#endif
			goto done;
		}

		if ((!fSuppressAppend) &&
			(where_next_keep_preleft == LEFT_SUBTREE) &&
			(where_next_keep_postleft == OUTSIDE_TREE)) {
			// Append a node to the linked list of hashes
			if ((fReturn = CreateNode (i + numLeft, j,
							pbHashHigh, cbHash, &pMissingHashNode)) != NO_ERROR) {
#if MSSIPOTF_DBG
				DbgPrintf ("Error in CreateNode.\n");
#endif
				goto done;
			}
			AppendNode (pMissingHashNode, &pHashListNodeHead, &pHashListNodeTail);
#if APPENDTRACE
#if MSSIPOTF_DBG
			print_tabs (level + 1);
			DbgPrintf ("Appending hash value for [%d, %d].\n",
				i + numLeft, j);
			PrintBytes (pbHashHigh, cbHash);
#endif
#endif
		}

		//// Combine the hash values of the two subtrees
		if ((fReturn =
			MergeSubtreeHashes (pbHashLow, pbHashHigh, pbHash)) != NO_ERROR) {
#if MSSIPOTF_DBG
			DbgPrintf ("Error in MergeSubtreeHashes.\n");
#endif
			goto done;
		}

		if ((!fSuppressAppend) && (where_next_keep_preleft == OUTSIDE_TREE)) {
			// Append a node to the linked list of hashes
			if ((fReturn = CreateNode (i + numLeft, j,
							pbHash, cbHash, &pMissingHashNode)) != NO_ERROR) {
#if MSSIPOTF_DBG
				DbgPrintf ("Error in CreateNode.\n");
#endif
				goto done;
			}
			AppendNode (pMissingHashNode, &pHashListNodeHead, &pHashListNodeTail);
#if APPENDTRACE
#if MSSIPOTF_DBG
			print_tabs (level + 1);
			DbgPrintf ("Appending hash value for [%d, %d].\n", i, j);
			PrintBytes (pbHash, cbHash);
#endif
#endif
		}

		assert (fReturn == NO_ERROR);

	}

#if TREETRACE
#if MSSIPOTF_DBG
	print_tabs (level);
	DbgPrintf ("Done with [%d, %d].\n", i, j);
#endif
#endif

done:
	// Free resources
    delete [] pbHashLow;

    delete [] pbHashHigh;

#if MSSIPOTF_DBG
	if (fReturn != S_OK)
		DbgPrintf ("Error in [%d, %d].\n", i, j);
#endif

	return fReturn;
}




//
// HashTable_glyf
//
// Compute the hash value for the glyf table of the given
// TTF file.  The number of bytes of the hash value is given
// in cbHash by the caller.  Place the hash value in pbHash.
// In pbMissingHashValues and cMissingHashValues, place the
// missing hash values corresponding to the file that would
// result if it were subsetted according to puchKeepList.
// If puchKeepList is NULL, then no (further) subsetting of
// the file is performed.
//
// Computing the hash value of the glyf table involves
// computing hash values for the individual glyphs.  These
// hash values are organized in a tree of hash values.
// The hash value at the root of this tree is the hash value
// of the glyf table.
//
// Computing the hash value of an individual glyph involves
// not only using the bytes associated with that glyph in the
// glyf table, but also values in other tables (e.g., character
// numbers that map to the glyph (cmap), advance width and
// left side bearing (hmtx), etc.).  Refer to the function
// HashGlyph for a more complete description of how the hash
// value is computed.
//
// If fSupressAppend is FALSE, then this function will return
// in pbNewMissingHashValues, cNewMissingHashValues, and
// cbNewMissingHashValues a set
// of missing hash values corresponding to the keep list.
//
// When using this function to get only a hash value for the
// glyphs, fSuppressAppend should be set to TRUE and the keep
// list should be the all 1's array.
//
// When using this function to further subset a font, fSuppressAppend
// should be se to FALSE, with the appropriate subset specified
// in puchKeepList.
//
// This function assumes that pbHash points to a block
// of memory needed for the given hash algorithm
// and that cbHash is set to the hash value size.
//
HRESULT CHashTableGlyfContext::HashTable_glyf
                (int fSuppressAppend,
                 BYTE *pbHash,
                 BYTE **ppbNewMissingHashValues,
                 USHORT *pcNewMissingHashValues,
                 ULONG *pcbNewMissingHashValues)
{
	HRESULT fReturn = E_FAIL;

	LONG present = 0;
	LONG keep = 0;


	FirstPresentGlyph (&present);
	FirstKeepGlyph (&keep);
	while ((keep != NONEXT) && (keep < present)) {
		NextKeepGlyph (&keep);
	}
#if (DEBUG_HTBLGLYF == 1)
#if MSSIPOTF_DBG
	DbgPrintf ("present = %d\n", present);
	DbgPrintf ("keep    = %d\n", keep);
#endif
#endif

	if ((fReturn = HashValueGlyphRange (0, usNumGlyphs - 1,
                                    &present, &keep,
                                    fSuppressAppend,
                                    pbHash,
                                    0)) != S_OK) {
#if MSSIPOTF_DBG
		DbgPrintf ("Error in HashValueGlyphRange.\n");
#endif
		goto done;
	}

	// Verify that there aren't any extra missing hash values
	if ((ulOffsetMissing / cbHash) != ulNumMissing) {
#if MSSIPOTF_ERROR
		SignError ("Too many missing hash values.", NULL, FALSE);
#endif
		fReturn = MSSIPOTF_E_CANTGETOBJECT;
		goto done;
	}

	// Gather all the missing hash values and their ranges
	if (!fSuppressAppend) {
		ConcatList (pHashListNodeHead,
				pcNewMissingHashValues,
				ppbNewMissingHashValues,
				pcbNewMissingHashValues);
		FreeList (pHashListNodeHead);
	}

#if (DEBUG_HTBLGLYF == 1)
#if MSSIPOTF_DBG
	// post mortem
	DbgPrintf ("\n---- Post Mortem:\n");
	DbgPrintf ("The hash value of the glyf table is:\n");
	PrintBytes (pbHash, cbHash);
	DbgPrintf ("Number of missing hash values retrieved: %d.\n",
		ulMissingHashValues);
	DbgPrintf ("Number of hash computations performed  : %d.\n",
		ulHashComputations);
	DbgPrintf ("Number of nodes touched                : %d.\n",
		ulNodesTouched);
	DbgPrintf ("\n");
#endif
#endif

	fReturn = S_OK;
done:

	return fReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\sign\htblconst.cpp ===
//
// hTblConst.cpp
//
// (c) 1997-1998. Microsoft Corporation.
// Author: Donald Chinn
//
// Compute the hash value for tables that do
// not change at all during subsetting.
//
// Functions in this file:
//   HashTableConst
//


#include "hTblConst.h"
#include "utilsign.h"
#include "cryptutil.h"
#include "signerr.h"

#include "subset.h"

//
// Compute the hash value for the given table of the given
// TTF file.  The number of bytes of the hash value is given
// in cbHash by the caller.  Place the hash value in pbHash.
//
// The table is assumed not to have changed during subsetting,
// which means that table_tag must refer to one of the
// following tables:
//   cvt, EBSC, fpgm, gasp, PCLT, prep
//
// This function assumes that pbHash points to a block
// of memory needed for the given hash algorithm
// and that cbHash is set to the hash value size.
//
// The bytes of the table are fed into the hash function
// as one stream of bytes (regardless of how those bytes
// are interpreted as TTF file values).
//
HRESULT HashTableConst (TTFACC_FILEBUFFERINFO *pFileBufferInfo,
                        CHAR *table_tag,
                        BYTE *pbHash,
                        DWORD cbHash,
                        HCRYPTPROV hProv,
                        ALG_ID alg_id)
{
    HRESULT fReturn = E_FAIL;
	DIRECTORY dir;

    HCRYPTHASH hHash = NULL;

	DWORD cbHashVal = cbHash;  // should equal cbHash after retrieving the hash value


	//// Set up the hash object for this table.

	// Set hHash to be the hash object.
	if (!CryptCreateHash(hProv, alg_id, 0, 0, &hHash)) {
#if MSSIPOTF_ERROR
		SignError ("Error during CryptCreateHash.",
            "HashTableConst", TRUE);
#endif
		fReturn = MSSIPOTF_E_CRYPT;
		goto done;
	}

	//// Find the beginning of the table in the file.
	if (GetTTDirectory (pFileBufferInfo, table_tag, &dir) == DIRECTORY_ERROR) {
#if MSSIPOTF_ERROR
		SignError ("Error finding table ", table_tag, FALSE);
#endif
		fReturn = MSSIPOTF_E_CANTGETOBJECT;
		goto done;
	}

	//// Pump data into the hash function
	if (!CryptHashData (hHash,
						pFileBufferInfo->puchBuffer + dir.offset,
						dir.length,
						0)) {
#if MSSIPOTF_ERROR
		SignError ("Error during CryptHashData.", NULL, TRUE);
#endif
		fReturn = MSSIPOTF_E_CRYPT;
		goto done;
	}

	//// Compute the table's hash value, and place the resulting hash 
	//// value into pbHash.
	if (!CryptGetHashParam(hHash, HP_HASHVAL, pbHash, &cbHashVal, 0)) {
#if MSSIPOTF_ERROR
		SignError ("Error during CryptGetHashParam (hash value).", NULL, TRUE);
#endif
		fReturn = MSSIPOTF_E_CRYPT;
		goto done;
	}
	assert (cbHashVal == cbHash);
	//// pbHash is now set (cbHash was already set)

	fReturn = S_OK;



	//// Clean up resources.
done:
	if (hHash)
		CryptDestroyHash (hHash);

	return fReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\sign\htblglyf.h ===
//
// hTblGlyf.h
//
// (c) 1997-1998. Microsoft Corporation.
// Author: Donald Chinn
//
// Functions exported:
//   HashTable_glyf
//

#ifndef _HTBLGLYF_H
#define _HTBLGLYF_H



#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x400
#endif

#include <windows.h>
#include <wincrypt.h>

#include "signglobal.h"

#include "dsigTable.h"
#include "hashGlyph.h"



// For present and keep indicies, NONEXT signals that
// there is no next glyph in a list.
#define NONEXT -1



// Node of a linked list.  Each node
// contains as data the glyph range of the
// (missing) hash value, and a pointer to bytes.
typedef struct ListNode {
	USHORT low;
	USHORT high;
	BYTE *pb;
	ULONG cb;	// how many bytes the pointer points to
	struct ListNode *next;
} ListNode;


// CHashTableGlyfContext
// An object of this class is what is needed when
// we generate a hash value for a glyf table.

// Global variables.  Defining variables with file
// scope prevents the need to pass them as arguments
// to the recursive functions.  These variables need
// to be initialized (in HashTable_glyf) before using
// the recursive functions.
class CHashTableGlyfContext {
private:
	TTFACC_FILEBUFFERINFO *pFileBufferInfo;
    ULONG fDsigInfo;       // tells whether the DsigInfo is valid or not
	CDsigInfo *pDsigInfo;
	ULONG ulNumMissing;
	ULONG ulOffsetMissing;	// offset to next missing hash value
	BYTE *pbOldMissingHashValues;
	ListNode *pHashListNodeHead;
	ListNode *pHashListNodeTail;
	HCRYPTPROV hProv;
	ALG_ID hashAlg;
	DWORD cbHash;
	USHORT usNumGlyphs;
	UCHAR *puchPresentList;
	UCHAR *puchKeepList;
	GlyphInfo *pGlyphInfo;  // for computing the hash value of glyphs

	// Member variables dealing with the number of nodes touched
	// during the tree traversal.
	ULONG ulMissingHashValues;
	ULONG ulNodesTouched;
	ULONG ulHashComputations;
public:
	CHashTableGlyfContext (TTFACC_FILEBUFFERINFO *pFileBufferInfo,
                        BOOL fDsigInfo,
						CDsigInfo *pDsigInfo,
						UCHAR *puchKeepList,
						DWORD cbHash,
						HCRYPTPROV hProv,
                        ALG_ID alg_id);

	~CHashTableGlyfContext ();

	HRESULT HashTable_glyf (int fSuppressAppend,
                            BYTE *pbHash,
                            BYTE **ppbNewMissingHashValues,
                            USHORT *pcNewMissingHashValues,
                            ULONG *pcbNewMissingHashValues);

	HRESULT HashValueGlyphRange (USHORT i, USHORT j,
							     LONG *next_present, LONG *next_keep,
                                 int fSuppressAppend,
                                 BYTE *pbHash,
                                 int level);

	HRESULT MergeSubtreeHashes (BYTE *pbHashLow,
                                BYTE *pbHashHigh,
                                BYTE *pbHash);

	HRESULT HashValueMissingGlyphs (BYTE *pbHash);

	void NextKeepGlyph (LONG *keep);
	void FirstKeepGlyph (LONG *keep);
	void NextPresentGlyph (LONG *present);
	void FirstPresentGlyph (LONG *present);

	HRESULT GetGlyphInfo (GlyphInfo *pGlyphInfo);
	HRESULT GetCmapInfo (GlyphInfo *pGlyphInfo,
                         UCHAR **ppuchPresentGlyphsList);

	HRESULT CHashTableGlyfContext::HashGlyph (USHORT i,
                                              BYTE *pbHash);
	HRESULT HashGlyphNull (BYTE *pbHash);
};


#endif  // _HTBLGLYF_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\sign\htblpconst.h ===
//
// hTblPConst.h
//
// (c) 1997-1998. Microsoft Corporation.
// Author: Donald Chinn
//
// Functions exported:
//   HashTableHead
//

#ifndef _HTBLPCONST_H
#define _HTBLPCONST_H



#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x400
#endif

#include <windows.h>
#include <wincrypt.h>

#include "signglobal.h"

#include "ttfinfo.h"


// External function declarations

extern HRESULT HashTableHead (TTFACC_FILEBUFFERINFO *pFileBufferInfo,
                              BYTE *pbHash,
                              DWORD cbHash,
                              HCRYPTPROV hProv,
                              ALG_ID alg_id);

extern HRESULT HashTableHhea (TTFACC_FILEBUFFERINFO *pFileBufferInfo,
                              BYTE *pbHash,
                              DWORD cbHash,
                              HCRYPTPROV hProv,
                              ALG_ID alg_id);

extern HRESULT HashTableMaxp (TTFACC_FILEBUFFERINFO *pFileBufferInfo,
                              BYTE *pbHash,
                              DWORD cbHash,
                              HCRYPTPROV hProv,
                              ALG_ID alg_id);

extern HRESULT HashTableOS2  (TTFACC_FILEBUFFERINFO *pFileBufferInfo,
                              BYTE *pbHash,
                              DWORD cbHash,
                              HCRYPTPROV hProv,
                              ALG_ID alg_id);

extern HRESULT HashTableVhea (TTFACC_FILEBUFFERINFO *pFileBufferInfo,
                              BYTE *pbHash,
                              DWORD cbHash,
                              HCRYPTPROV hProv,
                              ALG_ID alg_id);


#endif  // _HTBLPCONST_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\sign\httcfile.cpp ===
//
// hTTCfile.cpp
//
// (c) 1997-1998. Microsoft Corporation.
// Author: Donald Chinn
//
//
// Create a hash value for a True Type Collection file.
//
// The hash value for the entire font file is called
// the top-level hash value.  
//
// Throughout the following description, we assume that the
// TTC file has a version 1 or greater header with DSIG fields.
// If it does not have the DSIG fields, then it needs to be
// converted into one that does, which means a recomputation
// of all of the table offsets in the Table Directories of the
// TTFs in the TTC.
//
// For Format 1 DSIG signatures (CDsigSigF1), the hash
// value is computed by first removing the DSIG table
// from the file (if it exists) and zeroing out the DsigLength
// and DsigOffset fields of the (Version 1 or greater with DSIG fields)
// TTC header.  The resulting stream of bytes should be exactly the
// original file.
//
// Then, the entire file is the input to the hash
// function as a sequence of bytes.  Then the bytes
// associated with the DSIG table (the permissions)
// are hashed in.  The resulting hash value is the
// hash value of the file.
//
// Currently, there is no definition for a Format 2 signature
// for a TTC file.
//
// Once the hash values for all the tables are computed,
// they are pumped into the hash function for the top-level
// hash function.
//
// Functions in this file:
//   HashTTCfile
//

// DEBUG_HASHTTCFILE
// 1: print out the DSIG info of the file being hashed.
//    print out the hash values produced by each table
#define DEBUG_HASHTTCFILE 1


#include "hTTCfile.h"
#include "hTblConst.h"
#include "hTblPConst.h"
#include "hTblGlyf.h"
#include "utilsign.h"
#include "cryptutil.h"
#include "signerr.h"


//
// Compute the hash value of the input TTC file based on
// given DsigSig.  The hash function used is based on hProv.
// The result is returned in ppbHashToplevel and pcbHashTopLevel.
//
// The hash value of a TTC file is the hash value obtained
// by first converting the TTC file into an equivalent one
// with a Version 1 header with no DSIG fields.  Then, delete the DSIG
// table (if it is there) at the end of the file.  Then, zero out the
// DsigTag, DsigLength, and DsigOffset fields of the TTC header.
// The resulting stream of bytes (which might not be a long word aligned
// because of the last table in the file, but nevertheless is made
// to be long word aligned via padding) is hashed, along with the
// bytes associated with the DSIG table (currently defaulted to
// 0x0001 as a USHORT).
//
HRESULT CDsigSigF1::HashTTCfile (TTFACC_FILEBUFFERINFO *pFileBufferInfo,
                                 BYTE **ppbHashTopLevel,
                                 DWORD *pcbHashTopLevel,
                                 HCRYPTPROV hProv,
                                 ALG_ID alg_id,
                                 ULONG cbDsig,
                                 BYTE *pbDsig)
{
	HRESULT fReturn = E_FAIL;

	HCRYPTHASH hHashTopLevel = NULL;	// The top-level hash value

	BYTE *pbHashTopLevel = NULL;
	DWORD cbHash;					// count of bytes for all hash values
	USHORT cbHashShort;

	// variables for the old buffer
	TTCInfo *pTTCInfoOld = NULL;
	CDsigTable *pDsigTable = NULL;
    ULONG cbDirOffsets = 0;
    ULONG ulNumBlocks;

    // variables used if the TTC file has a version 1 header without DSIG fields
    ULONG cbNewTTCBuffer = 0;
    BYTE *pbNewTTCBuffer = NULL;
    BOOL fVersion1NoDsig = FALSE;

    TTFACC_FILEBUFFERINFO *pFileBufferInfoNew = NULL;
    TTC_HEADER_TABLE TTCHeaderTableNew;
    OFFSET_TABLE offTab;
    DIRECTORY dir;
    ULONG ulOffset;

    ULONG i, j;

    // initialize so that when we delete [], we don't have an
    // incorrect pointer
    TTCHeaderTableNew.pulDirOffsets = NULL;

    // SIZEOF_ZERO should be the difference between
    // SIZEOF_TTC_HEADER_TABLE_1_0_DSIG and SIZEOF_TTC_HEADER_TABLE_1_0
#define SIZEOF_ZERO 12
    BYTE pbZero[SIZEOF_ZERO] = {0x00, 0x00, 0x00, 0x00,
                                0x00, 0x00, 0x00, 0x00,
                                0x00, 0x00, 0x00, 0x00};


	//// Create a version of the font file that does not contain
	//// a DSIG table.

	//// Initialize the TTCInfo and DsigTable structures
	if ((fReturn = InitTTCStructures (pFileBufferInfo->puchBuffer,
								pFileBufferInfo->ulBufferSize,
								&pTTCInfoOld, &pDsigTable)) != NO_ERROR) {
#if MSSIPOTF_DBG
		DbgPrintf ("Error in InitTTCStructures.\n");
#endif
        fReturn = MSSIPOTF_E_CANTGETOBJECT;
		goto done;
	}

    // the number of bytes in the TTC header for Table Directory offsets
    cbDirOffsets = pTTCInfoOld->pHeader->ulDirCount * sizeof (ULONG);

    if ((pTTCInfoOld->pHeader->ulVersion == TTC_VERSION_1_0) &&
        (pTTCInfoOld->pHeader->ulDsigTag != DSIG_LONG_TAG)) {
        //// We need to construct a new TTC, where the TTC header
        //// is version 1 with DSIG fields and the offsets for all the
        //// tables are recomputed.

        cbNewTTCBuffer =
            RoundToLongWord(pTTCInfoOld->pFileBufferInfo->ulBufferSize) +
            (SIZEOF_TTC_HEADER_TABLE_1_0_DSIG - SIZEOF_TTC_HEADER_TABLE_1_0);

        if ((pbNewTTCBuffer = new BYTE [cbNewTTCBuffer]) == NULL) {
#if MSSIPOTF_ERROR
            SignError ("Cannot continue: Error in new BYTE [].", NULL, FALSE);
#endif
            fReturn = E_OUTOFMEMORY;
            goto done;
        }

        //// copy over the old buffer into the new, adding in the
        //// bytes for the DsigLength and DsigOffset fields
        //// Also, zero out the dsig fields and pad out the old file.

        // Version 1 (no DSIG fields) TTC header bytes
        memcpy (pbNewTTCBuffer,
                pTTCInfoOld->pFileBufferInfo->puchBuffer,
                SIZEOF_TTC_HEADER_TABLE_1_0 + cbDirOffsets);
        // rest of TTC file
        memcpy (pbNewTTCBuffer + SIZEOF_TTC_HEADER_TABLE_1_0_DSIG + cbDirOffsets,
                pTTCInfoOld->pFileBufferInfo->puchBuffer +
                    (SIZEOF_TTC_HEADER_TABLE_1_0 + cbDirOffsets),
                pTTCInfoOld->pFileBufferInfo->ulBufferSize -
                    (SIZEOF_TTC_HEADER_TABLE_1_0 + cbDirOffsets));
        // DsigLength and DsigOffset fields
        memcpy (pbNewTTCBuffer + SIZEOF_TTC_HEADER_TABLE_1_0 + cbDirOffsets,
                pbZero,
                SIZEOF_TTC_HEADER_TABLE_1_0_DSIG - SIZEOF_TTC_HEADER_TABLE_1_0);


        // Recompute the offsets to the TTF table directories
        // in the TTC header.  We just need to add
        // (SIZEOF_TTC_HEADER_TABLE_1_0_DSIG - SIZEOF_TTC_HEADER_TABLE_1_0)
        // to each offset.

        // first, initialize a new fileBufferInfo
		if ((pFileBufferInfoNew =
			(TTFACC_FILEBUFFERINFO *) malloc (sizeof (TTFACC_FILEBUFFERINFO))) == NULL) {
#if MSSIPOTF_ERROR
			SignError ("Cannot continue: Error in malloc.", NULL, FALSE);
#endif
			fReturn = E_OUTOFMEMORY;
			goto done;
		}
        pFileBufferInfoNew->puchBuffer = pbNewTTCBuffer;
        pFileBufferInfoNew->ulBufferSize = cbNewTTCBuffer;
        pFileBufferInfoNew->ulOffsetTableOffset = 0;
        pFileBufferInfoNew->lpfnReAllocate = NULL;

        // pad out the file to a long word boundary
        ZeroLongWordAlign (pFileBufferInfoNew,
            pTTCInfoOld->pFileBufferInfo->ulBufferSize +
            (SIZEOF_TTC_HEADER_TABLE_1_0_DSIG - SIZEOF_TTC_HEADER_TABLE_1_0));

        // Recompute the offsets to table directories.
        if ((fReturn =
                ReadTTCHeaderTable (pFileBufferInfoNew, &TTCHeaderTableNew))
                != S_OK) {
#if MSSIPOTF_DBG
		    DbgPrintf ("Error in ReadTTCHeaderTable.\n");
#endif
		    goto done;
	    }

        TTCHeaderTableNew.ulVersion = TTC_VERSION_1_0;
        for (i = 0; i < TTCHeaderTableNew.ulDirCount; i++) {
            TTCHeaderTableNew.pulDirOffsets[i] +=
                (SIZEOF_TTC_HEADER_TABLE_1_0_DSIG - SIZEOF_TTC_HEADER_TABLE_1_0);
        }

        // update the TTC header of the new file buffer
        if ((fReturn = WriteTTCHeaderTable (pFileBufferInfoNew, &TTCHeaderTableNew))
                != S_OK) {
#if MSSIPOTF_DBG
		    DbgPrintf ("Error in WriteTTCHeaderTable.\n");
#endif
            goto done;
	    }

        // ASSERT: the Table Directory offsets of the new TTC buffer
        // are correct.

        // Now recompute the table offsets in the table directories
        // of all TTFs in the TTC.  We just need to add
        // (SIZEOF_TTC_HEADER_TABLE_1_0_DSIG - SIZEOF_TTC_HEADER_TABLE_1_0)
        // to each offset.
        for (i = 0; i < TTCHeaderTableNew.ulDirCount; i++) {

            ulOffset = TTCHeaderTableNew.pulDirOffsets[i];
            // ASSERT: ulOffset points to the Offset Table of the i-th
            // TTF file in the TTC
            ReadOffsetTableOffset (pFileBufferInfoNew, ulOffset, &offTab);
            ulOffset += sizeof(OFFSET_TABLE);
            // ASSERT: ulOffset now points to the first directory
            // entry of the i-th TTF file in the TTC

            // check to make sure there is enough memory in the buffer
            // to read all of the tables in the TTF
            if ((ulOffset + offTab.numTables * sizeof(DIRECTORY)) >
                 pFileBufferInfoNew->ulBufferSize) {
#if MSSIPOTF_ERROR
                SignError ("Too many TTF directory entries.", NULL, FALSE);
#endif
                fReturn = MSSIPOTF_E_FILETOOSMALL;
                goto done;
            }
            // update the directory entries for the i-th TTF file
            for (j = 0; j < offTab.numTables; j++) {
                ReadDirectoryEntry (pFileBufferInfoNew, ulOffset, &dir);
                dir.offset +=
                    (SIZEOF_TTC_HEADER_TABLE_1_0_DSIG - SIZEOF_TTC_HEADER_TABLE_1_0);
                WriteDirectoryEntry (&dir, pFileBufferInfoNew, ulOffset);
                ulOffset += sizeof(DIRECTORY);
            }
        }

        fVersion1NoDsig = TRUE;

    } else if ((pTTCInfoOld->pHeader->ulVersion >= TTC_VERSION_1_0) &&
        (pTTCInfoOld->pHeader->ulDsigTag == DSIG_LONG_TAG)) {
              
        // just set pbNewTTCBuffer to the file buffer, and let the
        // hashing part of this function deal with the three parts
        // of the file that need to be treated separately
        pbNewTTCBuffer = pTTCInfoOld->pFileBufferInfo->puchBuffer;

        // we know the last block is the DSIG table.  So, we
        // just need to find the second to last block's offset
        // and length
        assert (pTTCInfoOld->ulNumBlocks > 1);

        ulNumBlocks = pTTCInfoOld->ulNumBlocks;
        cbNewTTCBuffer =
            pTTCInfoOld->ppBlockSorted[ulNumBlocks - 2]->ulOffset +
            pTTCInfoOld->ppBlockSorted[ulNumBlocks - 2]->ulLength;
        // ASSERT: cbNewTTCBuffer is now the number of bytes in the
        //   TTC file, excluding the DSIG table and any pad bytes
        //   that exist immediately before the DSIG table.

        cbNewTTCBuffer = RoundToLongWord (cbNewTTCBuffer);

        assert (cbNewTTCBuffer == pTTCInfoOld->pHeader->ulDsigOffset);

        fVersion1NoDsig = FALSE;

    } else {
        // error (should be caught in InitTTCStructures)
#if MSSIPOTF_ERROR
        SignError ("Bad TTC header version.", NULL, FALSE);
#endif
        fReturn = MSSIPOTF_E_BADVERSION;
        goto done;
    }

	//// At this point, pbNewTTCBuffer is pointing to the correct buffer
	//// cbNewTTCBuffer is the size of the buffer.
    ////
    //// However, if the TTC file has a version 1 or greater header with DSIG
    //// fields, then the DsigTag, DsigLength, and DsigOffset fields of the
    //// header will be set to something nonzero.  So, we have to hash the bytes
    //// before those 8 bytes, hash 8 bytes of 0x00, hash the rest of
    //// the file (excluding the DSIG table at the end of the TTC file),
    //// and finally hash the bytes associated with the DSIG table.
    ////

    // ASSERT: the file has a version 1 header with no DSIG fields
    // if and only if fVersion1NoDsig is TRUE.

#if MSSIPOTF_DBG
    DbgPrintf ("HashTTCfile alg_id = %d\n", alg_id);
#endif
	// Set hHashTopLevel to be the hash object.
	if (!CryptCreateHash(hProv, alg_id, 0, 0, &hHashTopLevel)) {
#if MSSIPOTF_ERROR
		SignError ("Error during CryptCreateHash.",
            "HashTTCfile", TRUE);
#endif
		fReturn = MSSIPOTF_E_CRYPT;
		goto done;
	}

	// Get the hash value size.
	if ((fReturn = GetHashValueSize (hHashTopLevel, &cbHashShort)) != NO_ERROR) {
#if MSSIPOTF_DBG
		DbgPrintf ("Error during GetHashValueSize.\n");
#endif
		goto done;
    } else {
        cbHash = (DWORD) cbHashShort;
    }

	// Allocate memory for the hash value.
	if ((pbHashTopLevel = new BYTE [cbHash]) == NULL) {
#if MSSIPOTF_ERROR
		SignError ("Cannot continue: Error in new BYTE.", NULL, FALSE);
#endif
		fReturn = E_OUTOFMEMORY;
		goto done;
	}

    // ASSERT: (pbNewTTCBuffer + cbNewTTCBuffer) points to the bytes just
    // after the last byte of the unsigned TTC file pointed to by pbNewTTCBuffer.
    //
    // ASSERT: the file has a version 1 header with no DSIG fields
    // if and only if fVersion1NoDsig is TRUE.
    //
    if (fVersion1NoDsig) {
        // Version 1 TTC header with no DSIG fields passed in --
        // buffer is exactly as is needed to hash

	    //// Pump the bytes of the new file into the hash function
	    if (!CryptHashData (hHashTopLevel,
                    pbNewTTCBuffer,
                    cbNewTTCBuffer,
                    0)) {
#if MSSIPOTF_ERROR
		    SignError ("Error during CryptHashData.", NULL, TRUE);
#endif
		    fReturn = MSSIPOTF_E_CRYPT;
		    goto done;
	    }
    } else {
        //// Version 1 or greater TTC header with DSIG fields passed in --
        //// need to break up the file into three parts

	    // Hash the bytes of the header (excluding the DsigTag,
        // DsigLength, and DsigOffset fields)
	    if (!CryptHashData (hHashTopLevel,
                    pbNewTTCBuffer,
                    SIZEOF_TTC_HEADER_TABLE_1_0 + cbDirOffsets,
                    0)) {
#if MSSIPOTF_ERROR
		    SignError ("Error during CryptHashData.", NULL, TRUE);
#endif
		    fReturn = MSSIPOTF_E_CRYPT;
		    goto done;
	    }

        // Hash in zeroes for the DsigTag, DsigLength, and DsigOffset
        // fields a Version 1 TTC header with DSIG fields.
        if (!CryptHashData (hHashTopLevel,
                    pbZero,
                    SIZEOF_ZERO,
                    0)) {
#if MSSIPOTF_ERROR
		    SignError ("Error during CryptHashData.", NULL, TRUE);
#endif
		    fReturn = MSSIPOTF_E_CRYPT;
		    goto done;
	    }

        // Hash the rest of the file (excluding the DSIG table)
        if (!CryptHashData (hHashTopLevel,
                    pbNewTTCBuffer +
                      (SIZEOF_TTC_HEADER_TABLE_1_0_DSIG + cbDirOffsets),
                    cbNewTTCBuffer -
                      (SIZEOF_TTC_HEADER_TABLE_1_0_DSIG + cbDirOffsets),
                    0)) {
#if MSSIPOTF_ERROR
		    SignError ("Error during CryptHashData.", NULL, TRUE);
#endif
		    fReturn = MSSIPOTF_E_CRYPT;
		    goto done;
	    }
    }

    //// Pump the extra bytes associated with the DSIG table into
    //// the hash function.
	if (!CryptHashData (hHashTopLevel, pbDsig, cbDsig, 0)) {
#if MSSIPOTF_ERROR
		SignError ("Error during CryptHashData.", NULL, TRUE);
#endif
		fReturn = MSSIPOTF_E_CRYPT;
		goto done;
	}
		
	//// Compute the top-level hash value, and place the resulting
	//// hash value into pbHashTopLevel.
	if (!CryptGetHashParam(hHashTopLevel, HP_HASHVAL, pbHashTopLevel, &cbHash, 0)) {
#if MSSIPOTF_ERROR
		SignError ("Error during CryptGetHashParam (hash value)", NULL, TRUE);
#endif
		fReturn = MSSIPOTF_E_CRYPT;
		goto done;
	}

	//// Set the return values.
	// Set the top level hash value
	*ppbHashTopLevel = pbHashTopLevel;
	*pcbHashTopLevel = cbHash;

	fReturn = S_OK;

done:
	// free resources
    if (pTTCInfoOld) {
        // free the memory for the FileBufferInfo, but don't
        // free the memory for the actual file.
        if (pTTCInfoOld->pFileBufferInfo) {
            free (pTTCInfoOld->pFileBufferInfo);
        }

        delete [] pTTCInfoOld->pHeader->pulDirOffsets;
        delete pTTCInfoOld->pHeader;
        pTTCInfoOld->pHeader = NULL;

        delete [] pTTCInfoOld->pulOffsetTables;
		pTTCInfoOld->pulOffsetTables = NULL;

        delete [] pTTCInfoOld->pBlocks;
		pTTCInfoOld->pBlocks = NULL;

        delete [] pTTCInfoOld->ppBlockSorted;
		pTTCInfoOld->ppBlockSorted = NULL;

        delete pTTCInfoOld;
    }

	delete pDsigTable;

	if (pFileBufferInfoNew) {
        // pFileBufferInfoNew was allocated if and only if
        // the TTC header was version 1 with no DSIG fields

		delete [] pFileBufferInfoNew->puchBuffer;

		free (pFileBufferInfoNew);
	}

    if (TTCHeaderTableNew.pulDirOffsets) {
        delete [] TTCHeaderTableNew.pulDirOffsets;
    }

	return fReturn;
}


HRESULT CDsigSigF2::HashTTCfile (TTFACC_FILEBUFFERINFO *pFileBufferInfo,
                                 BYTE **ppbHashTopLevel,
                                 DWORD *pcbHashTopLevel,
                                 HCRYPTPROV hProv,
                                 ALG_ID alg_id,
                                 ULONG cbDsig,
                                 BYTE *pbDsig)
{
#if MSSIPOTF_ERROR
    SignError ("Cannot sign a TTC file with a Format 2 signature!", NULL, FALSE);
#endif
    return MSSIPOTF_E_CRYPT;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\sign\htblpconst.cpp ===
//
// hTblPConst.cpp
//
// (c) 1997-1998. Microsoft Corporation.
// Author: Donald Chinn
//
// Compute the hash value for tables for which
// some (but not all) of their values change
// during subsetting.
//
// Functions in this file:
//   HashTablePartConstGeneric
//   HashTableHead
//   HashTableHhea
//   HashTableMaxp
//   HashTableOS2
//   HashTableVhea
//


#include "hTblPConst.h"
#include "utilsign.h"
#include "cryptutil.h"
#include "signerr.h"

#include "subset.h"

//
// Control arrays
//
// The following arrays tell which bytes in the table to hash.
// The bytes are specified by an offset and length pair.
// For example, if the array is {0, 12, 36, 4}, that means
// that the 12 bytes starting at offset 0 and the 4 bytes
// starting at offset 36 are to be pumped into the hash function.
// Offsets are relative to the beginning of the table.
//

/*
// Use the following definition if xMin, yMin, xMax, and yMax 
// ARE NOT used as part of the hash.
#define ulHeadHashControlLength 8
static ULONG pulHeadHashControl [ulHeadHashControlLength] =
        {0, 8,
         12, 24,
         44, 6,
         52, 2};
*/

// Use the following definition if xMin, yMin, xMax, and yMax
// ARE used as part of the hash.
#define ulHeadHashControlLength 6
static ULONG pulHeadHashControl [ulHeadHashControlLength] =
        {0, 8,
         12, 38,
         52, 2};

// Use the following definition if advanceWidthMax, minLeftSideBearing,
// minRightSideBearing, and xMaxExtent ARE used as part of the hash.
#define ulHheaHashControlLength 2
static ULONG pulHheaHashControl [ulHheaHashControlLength] =
        {0, 34};

#define ulMaxpHashControlLength 4
static ULONG pulMaxpHashControl [ulMaxpHashControlLength] =
        {0, 6,
        14, 12};

#define ulOS2HashControlLength 4
static ULONG pulOS2HashControl [ulOS2HashControlLength] =
        {0, 64,
         68, 18};

#define ulVheaHashControlLength 2
static ULONG pulVheaHashControl [ulVheaHashControlLength] =
        {0, 34};



//
// Given a file buffer, an hProv, an alg_id, a table tag,
// a table control length, and a table control, return the
// hash value associated with that table.  This function
// provides a generic way to generate a hash value for
// tables that are partially constant (with respect to
// subsetting).
//
HRESULT HashTablePartConstGeneric (TTFACC_FILEBUFFERINFO *pFileBufferInfo,
                                   BYTE *pbHash,
                                   DWORD cbHash,
                                   HCRYPTPROV hProv,
                                   ALG_ID alg_id,
                                   char *pszTag,
                                   ULONG ulTableHashControlLength,
                                   ULONG *pulTableHashControl)
{
    HRESULT fReturn = E_FAIL;

    ULONG ulOffsetTable;

    HCRYPTHASH hHash = NULL;
	DWORD cbHashVal = cbHash;  // should equal cbHash after retrieving the hash value
    ULONG i;


    //// Find the beginning of the head table
    if ((ulOffsetTable = TTTableOffset (pFileBufferInfo, HEAD_TAG)) ==
        DIRECTORY_ERROR) {

#if MSSIPOTF_ERROR
        SignError ("Error in TTTableOffset.", NULL, FALSE);
#endif
        fReturn = MSSIPOTF_E_CANTGETOBJECT;
        goto done;
    }

	//// Set up the hash object for this table.

	// Set hHash to be the hash object.
	if (!CryptCreateHash(hProv, alg_id, 0, 0, &hHash)) {
#if MSSIPOTF_ERROR
		SignError ("Error during CryptCreateHash.",
            "HashTableConst", TRUE);
#endif
		fReturn = MSSIPOTF_E_CRYPT;
		goto done;
	}

	//// Pump data into the hash function
    for (i = 0; i < ulTableHashControlLength; i += 2) {

	    if (!CryptHashData (hHash,
						    pFileBufferInfo->puchBuffer +
                            ulOffsetTable +
                            pulTableHashControl[i],
						    pulTableHashControl[i+1],
						    0)) {
#if MSSIPOTF_ERROR
		    SignError ("Error during CryptHashData.", NULL, TRUE);
#endif
		    fReturn = MSSIPOTF_E_CRYPT;
		    goto done;
	    }
    }

	//// Compute the table's hash value, and place the resulting hash 
	//// value into pbHash.
	if (!CryptGetHashParam(hHash, HP_HASHVAL, pbHash, &cbHashVal, 0)) {
#if MSSIPOTF_ERROR
		SignError ("Error during CryptGetHashParam (hash value).", NULL, TRUE);
#endif
		fReturn = MSSIPOTF_E_CRYPT;
		goto done;
	}
	assert (cbHashVal == cbHash);
	//// pbHash is now set (cbHash was already set)

    fReturn = S_OK;

done:
    return fReturn;
}


// Generate the hash value for the head table.
// Also, check that the values in the head table that
// are not included in the hash value are valid values.
HRESULT HashTableHead (TTFACC_FILEBUFFERINFO *pFileBufferInfo,
                       BYTE *pbHash,
                       DWORD cbHash,
                       HCRYPTPROV hProv,
                       ALG_ID alg_id)
{
    HRESULT fReturn = E_FAIL;

    if ((fReturn =
            HashTablePartConstGeneric (pFileBufferInfo,
                                       pbHash,
                                       cbHash,
                                       hProv,
                                       alg_id,
                                       HEAD_TAG,
                                       ulHeadHashControlLength,
                                       pulHeadHashControl)) != S_OK) {
#if MSSIPOTF_DBG
        DbgPrintf ("Error in HashTablePartConstGeneric (head).\n");
#endif
        goto done;
    }

    //// Now check the other vaues in the head table.

    // checkSumAdjustment has already been checked by CheckTTF

    // NOTE: The claim is that xMin, yMin, xMax, yMax don't actually
    // change (and so therefore should be included as part of the hash).
    // Check the definition of pulHeadHashControl to see what actually
    // gets hashed here.

    // indexToLocFormat does not need to be explicitly checked because it
    // is used to reference other data

	fReturn = S_OK;

done:
    return fReturn;
}


// Generate the hash value for the hhea table.
// Also, check that the values in the head table that
// are not included in the hash value are valid values.
HRESULT HashTableHhea (TTFACC_FILEBUFFERINFO *pFileBufferInfo,
                       BYTE *pbHash,
                       DWORD cbHash,
                       HCRYPTPROV hProv,
                       ALG_ID alg_id)
{
    HRESULT fReturn = E_FAIL;

    if ((fReturn =
            HashTablePartConstGeneric (pFileBufferInfo,
                                       pbHash,
                                       cbHash,
                                       hProv,
                                       alg_id,
                                       HHEA_TAG,
                                       ulHeadHashControlLength,
                                       pulHeadHashControl)) != S_OK) {
#if MSSIPOTF_DBG
        DbgPrintf ("Error in HashTablePartConstGeneric (hhea).\n");
#endif
        goto done;
    }

    //// Now check the other values in the hhea table.
    // NOTE: The claim is that advanceWidthMax, minLeftSideBearing,
    // minRightSidebearing, and xMaxExtent don't actually
    // change (and so therefore should be included as part of the hash).
    // Check the definition of pulHheaHashControl to see what actually
    // gets hashed here.

    // numberOfHMetrics does not need to be explicity checked because it
    // is used to reference other data.

	fReturn = S_OK;

done:
    return fReturn;
}


// Generate the hash value for the maxp table.
// Also, check that the values in the head table that
// are not included in the hash value are valid values.
HRESULT HashTableMaxp (TTFACC_FILEBUFFERINFO *pFileBufferInfo,
                       BYTE *pbHash,
                       DWORD cbHash,
                       HCRYPTPROV hProv,
                       ALG_ID alg_id)
{
    HRESULT fReturn = E_FAIL;

    ULONG ulOffset = 0;
    MAXP maxp;
    MAXP maxpComputed;

    USHORT usnMaxComponents = 0;
    USHORT *pausComponents = NULL;

    if ((fReturn =
            HashTablePartConstGeneric (pFileBufferInfo,
                                       pbHash,
                                       cbHash,
                                       hProv,
                                       alg_id,
                                       MAXP_TAG,
                                       ulHeadHashControlLength,
                                       pulHeadHashControl)) != S_OK) {
#if MSSIPOTF_DBG
        DbgPrintf ("Error in HashTablePartConstGeneric (maxp).\n");
#endif
        goto done;
    }

    //// Now check the other values in the maxp table.

    if ((ulOffset = GetMaxp( pFileBufferInfo, &maxp)) == 0L) {
#if MSSIPOTF_ERROR
        SignError ("No maxp table.", NULL, FALSE);
#endif
        fReturn = MSSIPOTF_E_CANTGETOBJECT;
        goto done;
    }

    // Compute maxp info
    
    // BUGBUG: Is this right?  What if maxComponentElements is a large number?
    //   What if maxComponentElements is not large enough?
    // Calculate a conservative maximum total possible. 3x3 at minimum
	usnMaxComponents = max(3, maxp.maxComponentElements) * max(3, maxp.maxComponentDepth);
    if ((pausComponents = (uint16 *) malloc(usnMaxComponents * sizeof(uint16))) == NULL) {
 		return E_OUTOFMEMORY;
    }

	if (ComputeMaxPStats(pFileBufferInfo,
            &(maxpComputed.maxContours),
            &(maxpComputed.maxPoints),
            &(maxpComputed.maxCompositeContours),
            &(maxpComputed.maxCompositePoints),
            &(maxpComputed.maxSizeOfInstructions),
            &(maxpComputed.maxComponentElements),
            &(maxpComputed.maxComponentDepth),
            pausComponents,
            usnMaxComponents) != NO_ERROR) {
#if MSSIPOTF_ERROR
        SignError ("Error in ComputeMaxPStats.", NULL, FALSE);
#endif
        fReturn = MSSIPOTF_E_CANTGETOBJECT;
        goto done;
    }

    if ((maxp.maxPoints != maxpComputed.maxPoints) ||
        (maxp.maxContours != maxpComputed.maxContours) ||
        (maxp.maxCompositePoints != maxpComputed.maxCompositePoints) ||
        (maxp.maxCompositeContours != maxpComputed.maxCompositeContours) ||
        (maxp.maxSizeOfInstructions != maxpComputed.maxSizeOfInstructions) ||
        (maxp.maxComponentElements != maxpComputed.maxComponentElements) ||
        (maxp.maxComponentDepth != maxpComputed.maxComponentDepth)) {

#if MSSIPOTF_ERROR
        SignError ("Failed check in maxp.", NULL, FALSE);
#endif
        fReturn = MSSIPOTF_E_PCONST_CHECK;
        goto done;
    }

	fReturn = S_OK;

done:
    if (pausComponents)
        free (pausComponents);

    return fReturn;
}


// Generate the hash value for the OS/2 table.
// Also, check that the values in the head table that
// are not included in the hash value are valid values.
HRESULT HashTableOS2  (TTFACC_FILEBUFFERINFO *pFileBufferInfo,
                       BYTE *pbHash,
                       DWORD cbHash,
                       HCRYPTPROV hProv,
                       ALG_ID alg_id)
{
    HRESULT fReturn = E_FAIL;

    if ((fReturn =
            HashTablePartConstGeneric (pFileBufferInfo,
                                       pbHash,
                                       cbHash,
                                       hProv,
                                       alg_id,
                                       OS2_TAG,
                                       ulHeadHashControlLength,
                                       pulHeadHashControl)) != S_OK) {
#if MSSIPOTF_DBG
        DbgPrintf ("Error in HashTablePartConstGeneric (OS/2).\n");
#endif
        goto done;
    }

    //// Now check the other values in the OS/2 table.

    // BUGBUG: need to check usFirstCharIndex and usLastCharIndex somewhere.
    //   However, it's too expensive to call ModCmap from here.  Need to
    //   check it in a place where the cmap table has already been loaded
    //   and can be processed easily.

	fReturn = S_OK;

done:
    return fReturn;
}


// Generate the hash value for the vhea table.
// Also, check that the values in the head table that
// are not included in the hash value are valid values.
HRESULT HashTableVhea (TTFACC_FILEBUFFERINFO *pFileBufferInfo,
                       BYTE *pbHash,
                       DWORD cbHash,
                       HCRYPTPROV hProv,
                       ALG_ID alg_id)
{
    HRESULT fReturn = E_FAIL;

    if ((fReturn =
            HashTablePartConstGeneric (pFileBufferInfo,
                                       pbHash,
                                       cbHash,
                                       hProv,
                                       alg_id,
                                       VHEA_TAG,
                                       ulHeadHashControlLength,
                                       pulHeadHashControl)) != S_OK) {
#if MSSIPOTF_DBG
        DbgPrintf ("Error in HashTablePartConstGeneric (vhea).\n");
#endif
        goto done;
    }

    //// Now check the other values in the vhea table.
    // NOTE: The claim is that advanceHeightMax, minTopSideBearing,
    // minTopSideBearing, minBottomSideBearing, yMaxExtent don't actually
    // change (and so therefore should be included as part of the hash).
    // Check the definition of pulVheaHashControl to see what actually
    // gets hashed here.

    // numOfLongVerMetrics does not need to be explicity checked because it
    // is used to reference other data.


	fReturn = S_OK;

done:
    return fReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\sign\httcfile.h ===
//
// hTTCfile.h
//
// (c) 1997-1998. Microsoft Corporation.
// Author: Donald Chinn
//
// Functions exported:
//   HashTTCfile
//


#ifndef _HTTCFILE_H
#define _HTTCFILE_H



#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x400
#endif

#include <windows.h>
#include <wincrypt.h>

#include "signglobal.h"

#include "ttcinfo.h"
#include "dsigTable.h"



#endif  // _HTTCFILE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\sign\signature.cpp ===
//
// signature.cpp
//
// (c) 1997-1998. Microsoft Corporation.
// Author: Donald Chinn
//
// Routines dealing with the signature and the
//   hash value.
//
// Functions in this file:
//   GetHashFromSignature
//   CreateSignatureFromHash
//

#include "signature.h"
#include "utilsign.h"

#include "signerr.h"


//
// Extract the hash value from the signature.
//
// For now, the hash value *is* the signature, so
// we just return the signature as the hash value.
//
HRESULT GetHashFromSignature (BYTE *pbSignature, DWORD cbSignature,
                              BYTE **ppbHash, DWORD *pcbHash)
{
    HRESULT hr = E_FAIL;

    delete [] *ppbHash;
	if ((*ppbHash = new BYTE [cbSignature]) == NULL) {
#if MSSIPOTF_ERROR
		SignError ("Cannot continue: Error in new BYTE.", NULL, FALSE);
#endif
        hr = E_OUTOFMEMORY;
        goto done;
	}
	ByteCopy (*ppbHash, pbSignature, cbSignature);
	*pcbHash = cbSignature;

    hr = S_OK;
done:

    return hr;
}


//
// Create a signature from the file's hash value.
//
// For now, the hash value *is* the signature, so
// we just return the hash value as the signature.
// 
HRESULT CreateSignatureFromHash (BYTE *pbHash, DWORD cbHash,
                                 BYTE **ppbSignature, DWORD *pcbSignature)
{
    HRESULT hr = E_FAIL;

    delete [] *ppbSignature;
	if ((*ppbSignature = new BYTE [cbHash]) == NULL) {
#if MSSIPOTF_ERROR
		SignError ("Cannot continue: Error in new BYTE.", NULL, FALSE);
#endif
        hr = E_OUTOFMEMORY;
        goto done;
	}
	ByteCopy (*ppbSignature, pbHash, cbHash);
	*pcbSignature = cbHash;

done:
    return hr;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\sign\isfont.h ===
//
// isfont.h
//
// (c) 1997-1998. Microsoft Corporation.
// Author: Donald Chinn
//
// This file contains functions that test properties of a
// font file (either TTF or TTC files).
//
// Functions exported:
//   IsFontFile
//   IsFontFile_handle
//   IsFontFile_memptr
//   ExistsGlyfTable
//

#ifndef _ISFONT_H
#define _ISFONT_H


#include <windows.h>

#include "signglobal.h"

#include "fileobj.h"


// These #define are used only for the return
// values of the IsFontFile* functions.
#define FAIL_TAG 0
#define OTF_TAG  1
#define TTC_TAG  2


int IsFontFile (CFileObj *pFileObj);
int IsFontFile_handle (IN HANDLE hFile);
int IsFontFile_memptr (BYTE *pbFile, ULONG cbFile);
BOOL ExistsGlyfTable (CFileObj *pFileObj,
                      int iFileType,
                      ULONG ulTTCIndex);

#endif // _ISFONT_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\sign\httffile.h ===
//
// hTTFfile.h
//
// (c) 1997-1998. Microsoft Corporation.
// Author: Donald Chinn
//
// Functions exported:
//   HashTTFfile
//


#ifndef _HTTFFILE_H
#define _HTTFFILE_H



#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x400
#endif

#include <windows.h>
#include <wincrypt.h>

#include "signglobal.h"

#include "ttfinfo.h"
#include "dsigTable.h"



#endif  // _HTTFFILE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\sign\sign.h ===
//
// sign.h
//
// (c) 1997-1998. Microsoft Corporation.
// Author: Donald Chinn
//
//
// Functions exported:
//   FontVerify
//   FontSign
//   GetSubsetDsigInfo
//   FontSignSubset
//   FontShowSignatures
//   FontRemoveSignature
//

#ifndef _SIGN_H
#define _SIGN_H


#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x400
#endif

#include <windows.h>
#include <wincrypt.h>

#include "signglobal.h"

#include "dsigTable.h"

#include "subset.h"


int FontVerify (BYTE *pbOldFile, ULONG cbOldFile,
				ULONG dsigSigFormat, USHORT dsigSigIndex);

int FontSign (BYTE *pbOldFile, ULONG cbOldFile, HANDLE hNewFile,
			  ULONG dsigSigFormat, USHORT dsigSigIndex);

int GetSubsetDsigInfo (TTFACC_FILEBUFFERINFO *pFileBufferInfo,
					   UCHAR *puchKeepGlyphList,
					   USHORT usKeepGlyphCount,
					   CDsigInfo *pDsigInfoIn,
                       ULONG *pcbDsigInfoOut,
					   CDsigInfo **ppDsigInfoOut,
                       HCRYPTPROV hProv);

int FontSignSubset (BYTE *pbOldFile, ULONG cbOldFile, HANDLE hNewFile,
					USHORT *pusKeepGlyphList, USHORT numKeepGlyphs,
					ULONG dsigSigFormat, USHORT dsigSigIndex);

int FontShowSignatures (BYTE *pbFile, ULONG cbFile);

int FontRemoveSignature (BYTE *pbOldFile,
						 ULONG cbOldFile,
						 HANDLE hNewFile,
						 ULONG ulFormat,
						 USHORT ulDsigSigIndex);

int HackCode (BYTE *pbOldFile, ULONG cbOldFile, HANDLE hNewFile);

#endif // _SIGN_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\sign\isfont.cpp ===
//
// isfont.cpp
//
// (c) 1997-1998. Microsoft Corporation.
// Author: Donald Chinn
//
// Routines for high-level TTF file operations.
//
// Functions in this file:
//   IsFontFile
//   IsFontFile_handle
//   IsFontFile_memptr
//   ExistsGlyfTable
//


#include "isfont.h"
#include "ttfinfo.h"
#include "ttcinfo.h"
#include "subset.h"

#include "signerr.h"

// Arrays of bytes that correspond to the first four bytes
// of an OTF file and a TTC file.
BYTE OTFTagV1[4] = {0x00, 0x01, 0x00, 0x00};
BYTE OTFTagOTTO[4] = {0x4F, 0x54, 0x54, 0x4F};  // "OTTO"
BYTE OTFTagV2[4] = {0x00, 0x02, 0x00, 0x00};
BYTE OTFTagTRUE[4] = {0x74, 0x72, 0x75, 0x65};  // "true"
BYTE TTCTag[4]   = {0x74, 0x74, 0x63, 0x66};    // "ttcf"


// Return TRUE if and only if the file has a format that
// allows for the reading of the head table and that the
// magic number of the head table is correct.
int IsFontFile (CFileObj *pFileObj)
{
    int rv = FAIL_TAG;

    TTFACC_FILEBUFFERINFO fileBufferInfo;
	HEAD head;

    TTC_HEADER_TABLE TTCHeader;

#if MSSIPOTF_DBG
    DbgPrintf ("Called IsFontFile.\n");
#endif

    // Initialize pointer in TTCHeader
    TTCHeader.pulDirOffsets = NULL;

    // Here's the algorithm:
	// 1. See if the file is has a TTC format by first matching the
    //      first four bytes of the file to 'ttcf'.
    // 2a. If the first four bytes match, then try to find the
    //       first head table of the file, assuming it has a TTC format.
	// 2b. If there is a head table, get the magic number field
    //      from the head table.
	// 2c. Compare its value to the magic number.
	// 3a. If the first four bytes do not match, assume the file is a
    //      TTF file and try to get the magic number field
    //      from the head table.
	// 3b. Compare its value to the magic number.

	fileBufferInfo.puchBuffer = pFileObj->GetFileObjPtr();
	fileBufferInfo.ulBufferSize = pFileObj->GetFileObjSize();
	fileBufferInfo.ulOffsetTableOffset = 0;
	fileBufferInfo.lpfnReAllocate = NULL;

    if (pFileObj->GetFileObjSize() < sizeof (ULONG)) {
        // the file is too short
        goto done;

    } else if ( !memcmp (pFileObj->GetFileObjPtr(), TTCTag, sizeof(ULONG))) {
        //// Step 2a
        // See if the file looks like a TTC

        if (ReadTTCHeaderTable(&fileBufferInfo, &TTCHeader) != NO_ERROR) {
            goto done;
        } else {
            if (TTCHeader.ulDirCount >= 1) {
                // Set the offset table offset to be the offset of the first TTF
                // file in the TTC.
    	        fileBufferInfo.ulOffsetTableOffset = TTCHeader.pulDirOffsets[0];
            } else {
                // a head table can't possibly exist
                goto done;
            }
        }

        // ASSERT: the Offset Table offset of fileBufferInfo is pointing
        // to the first TTF file in the TTC.

        // Get the head table of the first TTF of the TTC.
        if (GetHead (&fileBufferInfo, &head) == 0) {
		    goto done;
        } else if (head.magicNumber != MAGIC_NUMBER) {
            // steps 2b and 2c
		    goto done;
        } else {
            // the file "looks" like an TTC file
            rv = TTC_TAG;
        }

    } else {
        //// See if the file looks like an OTF file
        if (GetHead (&fileBufferInfo, &head) == 0) {
#if MSSIPOTF_DBG
            DbgPrintf ("Not an OTF: Couldn't read head table.\n");
#endif
		    goto done;
        } else if (head.magicNumber != MAGIC_NUMBER) {
            // steps 3a and 3b
#if MSSIPOTF_DBG
            DbgPrintf ("Not an OTF: Bad magic number.\n");
#endif
		    goto done;
        } else {
            // the file "looks" like an OTF file
            rv = OTF_TAG;
        }
	}

#if MSSIPOTF_DBG
    DbgPrintf ("Exiting IsFontFile.  rv = %d\n", rv);
#endif


done:

    delete [] TTCHeader.pulDirOffsets;

    return rv;
}


// Return OTFtag if and only if the first four bytes of the
// file are consistent with what an OTF file should have.
// Return TTCtag if and only if the first four bytes of the
// file are consistent with what an TTC file should have.
// Return FailTag otherwise.
int IsFontFile_handle (IN HANDLE hFile)
{
    int rv = FAIL_TAG;
	CFileObj *pFileObj = NULL;

    if ((pFileObj =
            (CFileObj *) new CFileHandle (hFile, FALSE)) == NULL) {
#if MSSIPOTF_ERROR
		SignError ("Cannot continue: Error in new CFileHandle.", NULL, FALSE);
#endif
        goto done;
    }

	if (pFileObj->MapFile (0, PAGE_READONLY, FILE_MAP_READ) != NO_ERROR) {
#if MSSIPOTF_ERROR
		SignError ("Cannot continue: Cannot map the file.", NULL, FALSE);
#endif
		goto done;
	}

	rv = IsFontFile (pFileObj);

done:
    if (pFileObj) {
	    pFileObj->UnmapFile();
    }

    delete pFileObj;

    return rv;
}


// Return TRUE if and only if the first four bytes of the
// file are consistent with what an OTF or TTC file should have
// in the first four bytes.
int IsFontFile_memptr (BYTE *pbFile, ULONG cbFile)
{
    int rv = FAIL_TAG;
	CFileObj *pFileObj = NULL;

    if ((pFileObj =
            (CFileObj *) new CFileMemPtr (pbFile, cbFile)) == NULL) {
#if MSSIPOTF_ERROR
		SignError ("Cannot continue: Error in new CFileMemPtr.", NULL, FALSE);
#endif
        goto done;
    }

	rv = IsFontFile (pFileObj);

done:
	delete pFileObj;

	return rv;
}


//
// Given a file, if the file is a TTF file (OTF_TAG), then
//   return TRUE if and only if there is a glyf table in the file.
// If the file is a TTC file (TTC_TAG), then return TRUE
//   if and only if the TTF file with index ulTTCIndex has a
//   glyf table.
//
// The caller should only pass OTF_TAG or TTC_TAG as the
// file type (iFileType).
//
BOOL ExistsGlyfTable (CFileObj *pFileObj,
                      int iFileType,
                      ULONG ulTTCIndex)
{
    BOOL rv = FALSE;
    TTFACC_FILEBUFFERINFO fileBufferInfo;
    uint32 ulGlyfOffset = 0;
    TTC_HEADER_TABLE ttcHeader;


    ttcHeader.pulDirOffsets = NULL;

    fileBufferInfo.puchBuffer = pFileObj->GetFileObjPtr();
    fileBufferInfo.ulBufferSize = pFileObj->GetFileObjSize();
    fileBufferInfo.ulOffsetTableOffset = 0;
    fileBufferInfo.lpfnReAllocate = NULL;

    switch (iFileType) {
        case OTF_TAG:

            ulGlyfOffset =
                TTDirectoryEntryOffset(&fileBufferInfo, "glyf");
            if ((ulGlyfOffset != DIRECTORY_ENTRY_OFFSET_ERR) &&
                (ulGlyfOffset != DIRECTORY_ERROR)) {
                rv = TRUE;
            }
            break;

        case TTC_TAG:

            if (ReadTTCHeaderTable (&fileBufferInfo, &ttcHeader)
                    != NO_ERROR) {
                goto done;
            }

            // set up the right offset table offset
            fileBufferInfo.ulOffsetTableOffset =
                ttcHeader.pulDirOffsets[ulTTCIndex];

            ulGlyfOffset =
                TTDirectoryEntryOffset(&fileBufferInfo, "glyf");
            if ((ulGlyfOffset != DIRECTORY_ENTRY_OFFSET_ERR) &&
                (ulGlyfOffset != DIRECTORY_ERROR)) {
                rv = TRUE;
            }
            break;

        default:
            // this branch should never be taken
            assert (FALSE);
            goto done;
            break;
    }
    
done:

    delete [] ttcHeader.pulDirOffsets;

    return rv;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\sign\sign.cpp ===
//
// sign.cpp
//
// (c) 1997-1998. Microsoft Corporation.
// Author: Donald Chinn
//
// Functions in this file:
//   FontVerify
//   FontSign
//   GetSubsetDsigInfo
//   FontSignSubset
//   FontShowSignatures
//   FontRemoveSignature
//


#include "sign.h"
#include "utilsign.h"
#include "cryptutil.h"
#include "ttfinfo.h"
#include "hTTFfile.h"
#include "hTblGlyf.h"
#include "glyphExist.h"
#include "signature.h"
#include "signerr.h"


//// IMPORTANT NOTE: the dsigSig's in the DSIG table are numbered
////   starting with 0.  Thus, to verify the zero-th dsigSig in Format 2,
////   you would call  FontVerify (file, DSIGSIG_FORMAT2, 0);


//
// FontVerify
//
// Verify dsigSigIndex-th dsigSig of format dsigSigFormat in
//   given font file.
// Produces an error if there are not at least dsigSigIndex + 1 number
//   of dsigSig's of the given format in the file.
// Returns NO_ERROR if the verification is successful.
//
int FontVerify (BYTE *pbOldFile, ULONG cbOldFile,
				ULONG dsigSigFormat, USHORT dsigSigIndex)
{
	int fReturn;

	TTFInfo *pTTFInfoOld;
	CDsigTable *pDsigTable = NULL;	// DsigTable of the old TTF file
	CDsigSignature *pDsigSignature = NULL;

	HCRYPTPROV hProv = NULL;
	BYTE *pbHash = NULL;
	DWORD cbHash;

    USHORT usFlag;
    BYTE *pbDsig = NULL;
    ULONG cbDsig;

	BYTE *pbSignature = NULL;
	DWORD cbSignature;
	BYTE *pbFileHash = NULL;
	DWORD cbFileHash;


	//// Initialize the TTFInfo and DsigInfo structures
	if ((fReturn = InitTTFStructures (pbOldFile, cbOldFile,
								&pTTFInfoOld, &pDsigTable)) != NO_ERROR) {
#if MSSIPOTF_DBG
		DbgPrintf ("Error in InitTTFStructures.\n");
#endif
		goto done;
	}

	// find the absolute index of the DsigSignature we're looking for
	if ((fReturn =
			pDsigTable->GetAbsoluteIndex (dsigSigFormat, &dsigSigIndex)) != NO_ERROR) {
#if MSSIPOTF_DBG
		DbgPrintf ("Error in CDsigTable::GetAbsoluteIndex.\n");
#endif
		goto done;
	}

	// Set the dsigSig and header pointers to the correct places in pDsigTable
	pDsigSignature = pDsigTable->GetDsigSignature(dsigSigIndex);

	// Set hProv to point to a cryptographic context of the default CSP.
	if (!CryptAcquireContext (&hProv, NULL, MS_DEF_PROV, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
#if MSSIPOTF_ERROR
		SignError ("Error during CryptAcquireContext.", NULL, TRUE);
#endif
		fReturn = MSSIPOTF_E_CRYPT;
		goto done;
	}

    // Retrieve the flag field from the DSIG table.
    // These bytes will be used as part of the hash.
    usFlag = pDsigTable->GetFlag();

    // Deal with DSIG table flag bytes
    cbDsig = sizeof(USHORT);
    if ((pbDsig = new BYTE [cbDsig]) == NULL) {
#if MSSIPOTF_ERROR
        SignError ("Cannot continue: Error in new BYTE.", NULL, FALSE);
#endif
        goto done;
    }

    pbDsig [0] = (BYTE) usFlag / FLAG_RADIX;  // high byte
    pbDsig [1] = (BYTE) usFlag % FLAG_RADIX;  // low byte
#if MSSIPOTF_DBG
    DbgPrintf ("pbDsig bytes:\n");
    PrintBytes (pbDsig, 2);
#endif
    
    // Produce a hash value for the TrueType font file
	if ((fReturn =
		pDsigSignature->GetDsigSig()->HashTTFfile (pTTFInfoOld->pFileBufferInfo,
										&pbHash,
										&cbHash,
										hProv,
										DSIG_HASH_ALG,  // BUGBUG: DSIG_HASH_ALG
                                        cbDsig,
                                        pbDsig))
				!= NO_ERROR) {
#if MSSIPOTF_DBG
		DbgPrintf ("Error producing the hash value of the file.\n");
#endif
		goto done;
	}

#if MSSIPOTF_DBG
	DbgPrintf ("The hash value computed for the file is:\n");
	PrintBytes (pbHash, cbHash);
#endif

	// Set pbSignature and cbSignature
	pbSignature = pDsigSignature->GetDsigSig()->GetSignature();
	pDsigSignature->GetSignatureSize (&cbSignature);

	//// Compare the computed hash value to the hash value
	//// from the signature.
	GetHashFromSignature (pbSignature, cbSignature, &pbFileHash, &cbFileHash);

#if MSSIPOTF_DBG
	DbgPrintf ("The hash value in the file is:\n");
	PrintBytes (pbFileHash, cbFileHash);
#endif

	if ((cbFileHash != cbHash) || (ByteCmp (pbFileHash, pbHash, cbHash))) {
#if MSSIPOTF_DBG
		DbgPrintf ("Hash values did not match.  Verification FAILED.\n");
#endif
		fReturn = E_FAIL;
		goto done;
	} else {
#if MSSIPOTF_DBG
		DbgPrintf ("Hash values matched.  Verification successful.\n");
#endif
		fReturn = NO_ERROR;
		goto done;
	}
	fReturn = NO_ERROR;

done:
	// Free resources
	if (hProv)
		CryptReleaseContext (hProv, 0);

	delete pDsigTable;

	FreeTTFInfo (pTTFInfoOld);
	
	delete [] pbHash;

	delete [] pbFileHash;

	return fReturn;
}


//
// FontSign
//
// Add a signature to the dsigSigIndex-th dsigSig of format dsigSigFormat in
//   the given font file.  If dsigSigIndex + 1 is greater than the number of
//   dsigSig's of the specified format, then a new dsigSig of that format
//   is created and appended to the DSIG table.
// Returns NO_ERROR if the signing is successful.
//
int FontSign (BYTE *pbOldFile, ULONG cbOldFile, HANDLE hNewFile,
			  ULONG dsigSigFormat, USHORT dsigSigIndex)
{
	int fReturn;

	TTFInfo *pTTFInfoOld;
	CDsigTable *pDsigTable = NULL;	// DsigTable of the old TTF file
	CDsigSignature *pDsigSignature = NULL;

	HCRYPTPROV hProv = NULL;
	BYTE *pbHash = NULL;
	DWORD cbHash;

    BYTE *pbDsig = NULL;
    ULONG cbDsig;

    BYTE *pbSignature = NULL;
	DWORD cbSignature;


	//// Initialize the TTFInfo and DsigTable structures
	if ((fReturn = InitTTFStructures (pbOldFile, cbOldFile,
								&pTTFInfoOld, &pDsigTable)) != NO_ERROR) {
#if MSSIPOTF_DBG
		DbgPrintf ("Error in InitTTFStructures.\n");
#endif
		goto done;
	}

	// find DsigSignature we're looking for
	if ((fReturn =
			pDsigTable->GetAbsoluteIndex (dsigSigFormat, &dsigSigIndex)) != NO_ERROR) {

		if (fReturn == MSSIPOTF_E_DSIG_STRUCTURE) {
			// Fewer signatures in the DSIG table than expected.
			// Create a new dsigSig.
#if MSSIPOTF_DBG
			DbgPrintf ("Creating a default signature.\n");
#endif
			if ((pDsigSignature = new CDsigSignature (dsigSigFormat)) == NULL) {
#if MSSIPOTF_ERROR
				SignError ("Cannot continue: Error in new CDsigSignature.", NULL, FALSE);
#endif
				fReturn = E_OUTOFMEMORY;
				goto done;
			}
			if ((fReturn =
				pDsigTable->InsertDsigSignature (pDsigSignature, &dsigSigIndex))
					!= NO_ERROR) {
#if MSSIPOTF_DBG
				DbgPrintf ("Error in CDsigTable::InsertDsigSignature.\n");
#endif
				goto done;
			}
		} else {
#if MSSIPOTF_DBG
			DbgPrintf ("Error in CDsigTable::GetAbsoluteIndex.\n");
#endif
			goto done;
		}
	} else {
		pDsigSignature = pDsigTable->GetDsigSignature(dsigSigIndex);
	}

	//// ASSERT: dsigSigIndex is now the index of the dsigSig in the
	//// dsigTable structure.  pDsigSignature points to the corresponding
	//// DsigSignature.


	// Set hProv to point to a cryptographic context of the default CSP.
	if (!CryptAcquireContext (&hProv, NULL, MS_DEF_PROV, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
#if MSSIPOTF_ERROR
		SignError ("Error during CryptAcquireContext.", NULL, TRUE);
#endif
		fReturn = MSSIPOTF_E_CRYPT;
		goto done;
	}

    // Deal with DSIG table flag bytes
    cbDsig = sizeof(USHORT);
    if ((pbDsig = new BYTE [cbDsig]) == NULL) {
#if MSSIPOTF_ERROR
        SignError ("Cannot continue: Error in new BYTE.", NULL, FALSE);
#endif
        goto done;
    }

    pbDsig [0] = (BYTE) DSIG_DEFAULT_FLAG_HIGH;  // high byte
    pbDsig [1] = (BYTE) DSIG_DEFAULT_FLAG_LOW;   // low byte
#if MSSIPOTF_DBG
    DbgPrintf ("pbDsig bytes:\n");
    PrintBytes (pbDsig, 2);
#endif
    
	// Produce a hash value for the TrueType font file
	if ((fReturn =
		pDsigSignature->GetDsigSig()->HashTTFfile (pTTFInfoOld->pFileBufferInfo,
										&pbHash,
										&cbHash,
										hProv,
										DSIG_HASH_ALG,  // BUGBUG: DSIG_HASH_ALG
                                        cbDsig,
                                        pbDsig))
				!= NO_ERROR) {
#if MSSIPOTF_DBG
		DbgPrintf ("Error producing the hash value of the file.\n");
#endif
		goto done;
	}

#if MSSIPOTF_DBG
	DbgPrintf ("The hash value computed for the file is:\n");
	PrintBytes (pbHash, cbHash);
#endif

	CreateSignatureFromHash (pbHash, cbHash, &pbSignature, &cbSignature);

	// Replace the old signature with the new one.
	if ((fReturn =
			pDsigTable->ReplaceSignature (dsigSigIndex, pbSignature, cbSignature))
			!= NO_ERROR) {
#if MSSIPOTF_DBG
		DbgPrintf ("Error in ReplaceSignature.\n");
#endif
		goto done;
	}

	// The dsigTable is correct.  Now write out the file.
#if MSSIPOTF_DBG
	DbgPrintf ("Writing to the file ...\n");
#endif
	if ((fReturn = WriteNewFile (pTTFInfoOld, pDsigTable, hNewFile)) != NO_ERROR) {
#if MSSIPOTF_DBG
		DbgPrintf ("Error in WriteNewFile.\n");
#endif
		goto done;
	}

	fReturn = NO_ERROR;

done:

	// Free resources
	if (hProv)
		CryptReleaseContext (hProv, 0);

	delete pDsigTable;

	FreeTTFInfo (pTTFInfoOld);
	
	delete [] pbHash;

	return fReturn;
}


//
// GetSubsetDsigInfo
//
// Given a TTF file and a subset (defined by pusKeepGlyphList
//   and usKeepGlyphCount), return the dsigInfo structure
//   corresponding to the TTF file if it had been subsetted
//   according to puchKeepGlyphList.
//
int GetSubsetDsigInfo (TTFACC_FILEBUFFERINFO *pFileBufferInfo,
					   UCHAR *puchKeepGlyphList,
					   USHORT usKeepGlyphCount,
					   CDsigInfo *pDsigInfoIn,
                       ULONG *pcbDsigInfoOut,
					   CDsigInfo **ppDsigInfoOut,
                       HCRYPTPROV hProv)
{
	int fReturn;

	CHashTableGlyfContext *pHashTableGlyfContext = NULL;
	BYTE *pbNewMissingHashValues;
	USHORT cNewMissingHashValues;
	ULONG cbNewMissingHashValues;
	BYTE *pbHash;
	USHORT usHash;
	DWORD cbHash;
	ULONG ulDsigInfoSize;

    // BUGBUG: Will need to crack the PKCS #7 packet to get the
    // hash algorithm (and then calculate the hash value size).
	if ((fReturn =
			GetAlgHashValueSize (pDsigInfoIn->GetHashAlgorithm(), &usHash)) != NO_ERROR) {
#if MSSIPOTF_DBG
		DbgPrintf ("Error in GetAlgHashValueSize.\n");
#endif
		goto done;
	}
	cbHash = usHash;
	if ((pbHash = new BYTE [cbHash]) == NULL) {
#if MSSIPOTF_ERROR
		SignError ("Cannot continue: Error in new BYTE.", NULL, FALSE);
#endif
		fReturn = E_OUTOFMEMORY;
		goto done;
	}

    //// Compute the missing hash values

    // Missing Glyphs
	// get the missing hash values for the glyf table
	pHashTableGlyfContext =
		new CHashTableGlyfContext (pFileBufferInfo,
                                   FALSE,
								   pDsigInfoIn,
								   puchKeepGlyphList,
								   cbHash,
								   hProv,
                                   DSIG_HASH_ALG);  // BUGBUG: DSIG_HASH_ALG

	if ((fReturn = pHashTableGlyfContext->HashTable_glyf
							(FALSE,	// don't suppress appending missing hash values
							 pbHash,
							 &pbNewMissingHashValues,	// new hash values
							 &cNewMissingHashValues,
							 &cbNewMissingHashValues)) != NO_ERROR) {
#if MSSIPOTF_DBG
		DbgPrintf ("Error in first call to HashTable_glyf.\n");
#endif
		goto done;
	}

    // Missing EBLC

    // Missing Names

    // Missing Post

    // Missing VDMX

	// create the output dsigInfo structure
	if (((*ppDsigInfoOut = new CDsigInfo) == NULL) ||
			((*ppDsigInfoOut)->Alloc() != NO_ERROR)) {
#if MSSIPOTF_ERROR
		SignError ("Cannot continue: Error in new CDsigInfo.", NULL, FALSE);
#endif
		fReturn = E_OUTOFMEMORY;
		goto done;
	}
	(*ppDsigInfoOut)->SetVersion (pDsigInfoIn->GetVersion());
	(*ppDsigInfoOut)->SetHashAlgorithm (pDsigInfoIn->GetHashAlgorithm());
	(*ppDsigInfoOut)->SetNumMissingGlyphs (cNewMissingHashValues);
	(*ppDsigInfoOut)->SetMissingGlyphs (pbNewMissingHashValues);

	(*ppDsigInfoOut)->GetSize (&ulDsigInfoSize);
	*pcbDsigInfoOut = ulDsigInfoSize;

#if MSSIPOTF_DBG
    DbgPrintf ("**** DsigInfo created:\n");
    (*ppDsigInfoOut)->Print();
#endif


	fReturn = NO_ERROR;

done:

	delete [] pbHash;

	delete pHashTableGlyfContext;

	return fReturn;
}


//
// FontSignSubset
//
// Modify the dsigInfo (or other appropriate structure) of the dsigSigIndex-th
//   dsigSig of format dsigSigFormat in the given font file so that the resulting
//   structure is consistent with the given set of glyphs.
// The input arguments pusKeepCharCodeList and usCharList are expected to
//   define a list of glyph id's (not character codes), which will be passed
//   to GetSubsetPresentGlyphList.
//
// Produces an error if there are not at least dsigSigIndex + 1 number
//   of dsigSig's of the given format in the file.
// Returns NO_ERROR if the operation is successful.
//
int FontSignSubset (BYTE *pbOldFile,
                    ULONG cbOldFile,
                    HANDLE hNewFile,
					USHORT *pusKeepCharCodeList,
                    USHORT usCharListCount,
					ULONG dsigSigFormat,
                    USHORT dsigSigIndex)
{
	int fReturn;

	TTFInfo *pTTFInfoOld;
	CDsigTable *pDsigTable;	// DsigTable of the old TTF file
	CDsigSignature *pDsigSignature;

	HCRYPTPROV hProv = NULL;

	// begin SUBSET stuff
	USHORT i;

	UCHAR *puchKeepGlyphList = NULL;
	USHORT usGlyphListCount;
	USHORT usGlyphKeepCount = 0;

    ULONG cbDsigInfoNew = 0;
	CDsigInfo *pDsigInfoNew;
	// end SUBSET stuff


	//// If dsigSigFormat is not a format that allows subsetting,
	//// then fail.
	if (dsigSigFormat != DSIGSIG_FORMAT2) {
#if MSSIPOTF_ERROR
		SignError ("Signature has bad format number.", NULL, FALSE);
#endif
		fReturn = MSSIPOTF_E_DSIG_STRUCTURE;
		goto done;
	}

	//// Initialize the TTFInfo and DsigInfo structures
	if ((fReturn = InitTTFStructures (pbOldFile, cbOldFile,
								&pTTFInfoOld, &pDsigTable)) != NO_ERROR) {
#if MSSIPOTF_DBG
		DbgPrintf ("Error in InitTTFStructures.\n");
#endif
		goto done;
	}

	
	// find DsigSignature we're looking for
	if ((fReturn =
			pDsigTable->GetAbsoluteIndex (dsigSigFormat, &dsigSigIndex)) != NO_ERROR) {

		if (fReturn == MSSIPOTF_E_DSIG_STRUCTURE) {
			// Fewer signatures in the DSIG table than expected.
			// Create a new dsigSig.
#if MSSIPOTF_DBG
			DbgPrintf ("Creating a default signature.\n");
#endif
			if ((pDsigSignature = new CDsigSignature (dsigSigFormat)) == NULL) {
#if MSSIPOTF_ERROR
				SignError ("Cannot continue: Error in new CDsigSignature.", NULL, FALSE);
#endif
				fReturn = E_OUTOFMEMORY;
				goto done;
			}
			if ((fReturn =
				pDsigTable->AppendDsigSignature (pDsigSignature, &dsigSigIndex))
					!= NO_ERROR) {
#if MSSIPOTF_DBG
				DbgPrintf ("Error in CDsigTable::AppendDsigSignature.\n");
#endif
				goto done;
			}
		} else {
#if MSSIPOTF_DBG
            DbgPrintf ("Error in CDsigTable::GetAbsoluteIndex.\n");
#endif
			goto done;
		}
	} else {
		pDsigSignature = pDsigTable->GetDsigSignature(dsigSigIndex);
	}

	//// ASSERT: dsigSigIndex is now the index of the dsigSig in the
	//// dsigTable structure.  pDsigSignature points to the corresponding
	//// DsigSignature.


	//// begin SUBSET stuff
	usGlyphListCount = GetNumGlyphs (pTTFInfoOld->pFileBufferInfo);

	if ((puchKeepGlyphList = new BYTE [usGlyphListCount]) == NULL) {
#if MSSIPOTF_ERROR
		SignError ("Cannot continue: Error in new BYTE.", NULL, FALSE);
#endif
		fReturn = E_OUTOFMEMORY;
		goto done;
	}

	for (i = 0; i < usGlyphListCount; i++) {
		puchKeepGlyphList[i] = FALSE;
	}

	//// Call GetSubsetPresentGlyphList to get all of glyphs involved
    if ((fReturn = GetSubsetPresentGlyphList (pTTFInfoOld->pFileBufferInfo,
                pusKeepCharCodeList,
                usCharListCount,
                puchKeepGlyphList,
                usGlyphListCount)) != NO_ERROR) {
#if MSSIPOTF_DBG
		DbgPrintf ("Error in GetSubsetKeepGlyphList.\n");
#endif
		goto done;
	}

    // ASSERT: puchKeepGlyphList is a char-array that tells which glyphs
    // we actually want to keep.

#if MSSIPOTF_DBG
	PrintBytes (puchKeepGlyphList, usGlyphListCount);
#endif

/*
	cout << "puchKeepGlyphList:" <<  endl;
	cout << "0:\t";
	for (i = 0; i < usGlyphListCount; i++) {
		if (puchKeepGlyphList[i]) {
			cout << 1 << "\t";
		} else {
			cout << 0 << "\t";
		}
		if (((i + 1) % 8) == 0) {
			cout << endl;
			cout << dec << i + 1 << ":\t";
		}
	}
	cout << endl;
*/

    // BUGBUG: shouldn't have to acquire a context!
	// Set hProv to point to a cryptographic context of the default CSP.
	if (!CryptAcquireContext (&hProv, NULL, MS_DEF_PROV, PROV_RSA_FULL, CRYPT_VERIFYCONTEXT)) {
#if MSSIPOTF_ERROR
		SignError ("Error during CryptAcquireContext.", NULL, TRUE);
#endif
		fReturn = MSSIPOTF_E_CRYPT;
		goto done;
	}

    if ((fReturn = GetSubsetDsigInfo (pTTFInfoOld->pFileBufferInfo,
									puchKeepGlyphList,
									usGlyphListCount,
									((CDsigSigF2 *) pDsigSignature->GetDsigSig())->GetDsigInfo(),
                                    &cbDsigInfoNew,
									&pDsigInfoNew,
                                    hProv)) != NO_ERROR) {
#if MSSIPOTF_DBG
		DbgPrintf ("Error in GetSubsetDsigInfo.\n");
#endif
		goto done;
	}

	//// end SUBSET stuff

	//// Replace the DsigInfo
	if ((fReturn = pDsigTable->ReplaceDsigInfo (dsigSigIndex, pDsigInfoNew))
			!= NO_ERROR) {
#if MSSIPOTF_DBG
		DbgPrintf ("Error in ReplaceDsigInfo.\n");
#endif
		goto done;
	}

	// The dsigTable is correct.  Now write out the file.
#if MSSIPOTF_DBG
	DbgPrintf ("Writing to the file ...\n");
#endif
	if ((fReturn = WriteNewFile (pTTFInfoOld, pDsigTable, hNewFile)) != NO_ERROR) {
#if MSSIPOTF_DBG
		DbgPrintf ("Error in WriteNewFile.\n");
#endif
		goto done;
	}


	fReturn = NO_ERROR;

done:
	if (hProv)
		CryptReleaseContext (hProv, 0);

	delete pDsigTable;

	FreeTTFInfo (pTTFInfoOld);
	
	return fReturn;
}


//
// FontShowSignatures
//
// Print out the DsigTable structure of the given TTF file.
//
int FontShowSignatures (BYTE *pbFile, ULONG cbFile)
{
	int fReturn;

	TTFInfo *pTTFInfo;
	CDsigTable *pDsigTable;	// DsigTable of the old TTF file

	//// Initialize the TTFInfo and DsigInfo structures
	if ((fReturn = InitTTFStructures (pbFile, cbFile,
								&pTTFInfo, &pDsigTable)) != NO_ERROR) {
#if MSSIPOTF_DBG
		DbgPrintf ("Error in InitTTFStructures.\n");
#endif
		goto done;
	}

	pDsigTable->Print ();


	fReturn = NO_ERROR;

done:
	return fReturn;
}


//
// FontRemoveSignature
//
// Given a TTF file and a format and index that specifies
//   a signature in the DSIG table, remove the signature
//   from the DSIG table and write the resulting new file.
//
int FontRemoveSignature (BYTE *pbOldFile,
						 ULONG cbOldFile,
						 HANDLE hNewFile,
						 ULONG ulFormat,
						 USHORT ulDsigSigIndex)
{
	int fReturn;

	TTFInfo *pTTFInfoOld;
	CDsigTable *pDsigTable;	// DsigTable of the old TTF file

	//// Initialize the TTFInfo and DsigInfo structures
	if ((fReturn = InitTTFStructures (pbOldFile, cbOldFile,
								&pTTFInfoOld, &pDsigTable)) != NO_ERROR) {
#if MSSIPOTF_DBG
		DbgPrintf ("Error in InitTTFStructures.\n");
#endif
		goto done;
	}

	// Delete the dsig signature from the dsigTable
	if ((fReturn = pDsigTable->RemoveDsigSignature (ulDsigSigIndex))
			!= NO_ERROR) {
#if MSSIPOTF_DBG
		DbgPrintf ("Error in CDSigTable::RemoveDsigSiganture.\n");
#endif
		goto done;
	}

#if MSSIPOTF_DBG
	DbgPrintf ("Writing to the file ...\n");
#endif
	if ((fReturn = WriteNewFile (pTTFInfoOld, pDsigTable, hNewFile)) != NO_ERROR) {
#if MSSIPOTF_DBG
		DbgPrintf ("Error in WriteNewFile.\n");
#endif
		goto done;
	}


	fReturn = NO_ERROR;

done:
	return fReturn;
}


//
// HackCode
//
// Code to do special testing.
//
int HackCode (BYTE *pbOldFile, ULONG cbOldFile, HANDLE hNewFile)
{
	int fReturn;

	TTFInfo *pTTFInfoOld;
	CDsigTable *pDsigTable = NULL;	// DsigTable of the old TTF file
	BYTE *temp;
	USHORT i;

	//// Initialize the TTFInfo and DsigInfo structures
	if ((fReturn = InitTTFStructures (pbOldFile, cbOldFile,
								&pTTFInfoOld, &pDsigTable)) != NO_ERROR) {
#if MSSIPOTF_DBG
		DbgPrintf ("Error in InitTTFStructures.\n");
#endif
		goto done;
	}

	if ((temp =	new BYTE [16]) == NULL) {
#if MSSIPOTF_ERROR
		SignError ("Cannot continue: Error in new BYTE.", NULL, FALSE);
#endif
		fReturn = E_OUTOFMEMORY;
		goto done;
	}
	for (i = 0; i < 16; i++) {
		temp[i] = 0xFF;
	}
	/*
	pDsigTable->GetDsigSignature(0)->GetDsigSig()->GetDsigInfo()->SetMissingGlyphs(temp);
	pDsigTable->GetDsigSignature(0)->GetDsigSig()->GetDsigInfo()->SetNumMissingGlyphs (1);
	pDsigTable->GetDsigSignature(0)->GetDsigSig()->GetDsigInfo()->SetLength (
		pDsigTable->GetDsigSignature(0)->GetDsigSig()->GetDsigInfo()->GetLength () + 16);
	pDsigTable->GetDsigSignature(0)->GetDsigSig()->SetSignatureOffset (
		pDsigTable->GetDsigSignature(0)->GetDsigSig()->GetSignatureOffset () + 16);
	pDsigTable->GetDsigSignature(0)->SetLength (
		pDsigTable->GetDsigSignature(0)->GetLength() + 16);
	pDsigTable->GetDsigSignature(1)->SetOffset (
		pDsigTable->GetDsigSignature(1)->GetOffset() + 16);
*/

#if MSSIPOTF_DBG
	DbgPrintf ("Writing to the file ...\n");
#endif
	if ((fReturn = WriteNewFile (pTTFInfoOld, pDsigTable, hNewFile)) != NO_ERROR) {
#if MSSIPOTF_DBG
		DbgPrintf ("Error in WriteNewFile.", NULL, FALSE);
#endif
		goto done;
	}

	fReturn = NO_ERROR;

done:
	return fReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\sign\signature.h ===
//
// signature.h
//
// (c) 1997-1998. Microsoft Corporation.
// Author: Donald Chinn
//
// Functions exported:
//   GetHashFromSignature
//   CreateSignatureFromHash
//

#ifndef _SIGNATURE_H
#define _SIGNATURE_H


#ifndef _WIN32_WINNT
#define _WIN32_WINNT 0x400
#endif

#include <windows.h>
#include <wincrypt.h>

#include "signglobal.h"


HRESULT GetHashFromSignature (BYTE *pbSignature, DWORD cbSignature,
                              BYTE **ppbHash, DWORD *pcbHash);

HRESULT CreateSignatureFromHash (BYTE *pbHash, DWORD cbHash,
                                 BYTE **ppbSignature, DWORD *pcbSignature);

#endif  // _SIGNATURE_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\sign\httffile.cpp ===
//
// hTTFfile.cpp
//
// (c) 1997-1998. Microsoft Corporation.
// Author: Donald Chinn
//
//
// Create a hash value for a True Type Font file.
//
// The hash value for the entire font file is called
// the top-level hash value.  
//
// For Format 1 DSIG signatures (CDsigSigF1), the hash
// value is computed by first removing the DSIG table
// from the file (if it exists) and then recomputing
// the table offsets and file checksum.  The resulting
// stream of bytes should be exactly the original file.
// Then, the entire file is the input to the hash
// function as a sequence of bytes.  The resulting hash
// value is the hash value of the file.
//
// For Format 2 DSIG signatures (CDsigSigF2), the hash
// value is computed by first computing a hash value
// for each of the tables in the font file.
// (How each table's hash value is computed is
// explained in each table's hash routine.)
//
// Once the hash values for all the tables are computed,
// they are pumped into the hash function for the top-level
// hash function.
//
// Functions in this file:
//   HashTTFfile
//

// DEBUG_HASHTTFFILE
// 1: print out the DSIG info of the file being hashed.
//    print out the hash values produced by each table
#define DEBUG_HASHTTFFILE 1


#include "hTTFfile.h"
#include "hTblConst.h"
#include "hTblPConst.h"
#include "hTblGlyf.h"
#include "utilsign.h"
#include "cryptutil.h"
#include "signerr.h"


//
// Compute the hash value of the input TTF file based on
// given DsigSig.  The hash function used is based on hProv.
// The result is returned in ppbHashToplevel and pcbHashTopLevel.
//
// This function reconstructs the font file to what it was
// before signing, but it does so without copying the entire
// font file.  Instead, it pumps bytes into CryptHashData each
// part of the font file (as it would have been before signing)
// in one pass.
//
HRESULT CDsigSigF1::HashTTFfile (TTFACC_FILEBUFFERINFO *pFileBufferInfo,
                                 BYTE **ppbHashTopLevel,
                                 DWORD *pcbHashTopLevel,
                                 HCRYPTPROV hProv,
                                 ALG_ID alg_id,
                                 ULONG cbDsig,
                                 BYTE *pbDsig)
{
	HRESULT fReturn = E_FAIL;

	HCRYPTHASH hHashTopLevel = NULL;	// The top-level hash value

	BYTE *pbHashTopLevel = NULL;
	DWORD cbHash;					// count of bytes for all hash values
	USHORT cbHashShort;

	// variables for the old buffer
	TTFInfo *pTTFInfoOld = NULL;
	CDsigTable *pDsigTable = NULL;
	USHORT fDsig;		// is there a DSIG table in the old TTF file?

	// variables in case we need to delete the DSIG table
	OFFSET_TABLE offTableNew;
	USHORT numTablesNew;
	TTFACC_FILEBUFFERINFO *pFileBufferInfo_OffsetTable = NULL;
    TTFACC_FILEBUFFERINFO *pFileBufferInfo_DirEntries = NULL;
    TTFACC_FILEBUFFERINFO *pFileBufferInfo_Head = NULL;
    HEAD head;
	ULONG ulOffset = 0;
	ULONG ulNewFileSize = 0;
    ULONG ulOffset_Dsig = 0;
    DIRECTORY dirDsig;
    DIRECTORY dir;
    ULONG ulFileChecksum = 0;  // checksum of the file before signing
    ULONG ulTempChecksum = 0;

	DIRECTORY *pDir;
	USHORT i, j;
    USHORT usBytesMoved;
    BYTE zero [1] = {0x00};

//    char tagtemp[4];

	// variables passed to CryptHashData
	UCHAR *tempBuffer;
	ULONG ulTempBufferSize;


	//// Create a version of the font file that does not contain
	//// a DSIG table.

	//// Initialize the TTFInfo and DsigTable structures
	if ((fReturn = InitTTFStructures (pFileBufferInfo->puchBuffer,
								pFileBufferInfo->ulBufferSize,
								&pTTFInfoOld, &pDsigTable)) != S_OK) {
#if MSSIPOTF_DBG
		DbgPrintf ("Error in InitTTFStructures.\n");
#endif
		goto done;
	}

    //// Set up the hash value
#if MSSIPOTF_DBG
    DbgPrintf ("HashTTFfile alg_id = %d\n", alg_id);
#endif
	// Set hHashTopLevel to be the hash object.
	if (!CryptCreateHash(hProv, alg_id, 0, 0, &hHashTopLevel)) {
#if MSSIPOTF_ERROR
		SignError ("Error during CryptCreateHash.",
            "HashTTFfile", TRUE);
#endif
		fReturn = MSSIPOTF_E_CRYPT;
		goto done;
	}

	// Get the hash value size.
	if ((fReturn = GetHashValueSize (hHashTopLevel, &cbHashShort)) != S_OK) {
#if MSSIPOTF_DBG
		DbgPrintf ("Error during GetHashValueSize.\n");
#endif
		goto done;
    } else {
        cbHash = (DWORD) cbHashShort;
    }

	// Allocate memory for the hash value.
	if ((pbHashTopLevel = new BYTE [cbHash]) == NULL) {
#if MSSIPOTF_ERROR
		SignError ("Cannot continue: Error in new BYTE.", NULL, FALSE);
#endif
		fReturn = E_OUTOFMEMORY;
		goto done;
	}

	//// Compute the number of tables in the new file.
	// Determine if there is a DSIG table in the old file.
	// We assume that TTDirectoryEntryOffset will not return
	//   DIRECTORY_ENTRY_OFFSET_ERROR.  That is, we assume
	//   the function was called previously and the offset
	//   table was okay.  If it returns DIRECTORY_ERROR, then
	//   there was no DSIG table in the old file.
	fDsig =
		((ulOffset_Dsig =
        TTDirectoryEntryOffset (pFileBufferInfo, DSIG_TAG)) ==
		DIRECTORY_ERROR) ? 0 : 1;
	numTablesNew = pTTFInfoOld->pOffset->numTables - fDsig;

	if (!fDsig) {
		// There was not a DSIG table.  So, we can just use the
		// original buffer to compute the hash value.
		tempBuffer = pFileBufferInfo->puchBuffer;
		ulTempBufferSize = pFileBufferInfo->ulBufferSize;

	    //// At this point, tempBuffer is pointing to the correct buffer
	    //// (either the original one or the one with the DSIG table removed).
	    //// ulTempBufferSize is the size of the buffer.

        //// Pump the bytes of the new file into the hash function
	    if (!CryptHashData (hHashTopLevel, tempBuffer, ulTempBufferSize, 0)) {
#if MSSIPOTF_ERROR
		    SignError ("Error during CryptHashData.", NULL, TRUE);
#endif
		    fReturn = MSSIPOTF_E_CRYPT;
		    goto done;
	    }

	} else {
		// There was a DSIG table.  We need to create a temporary
		// buffer to copy all non-DSIG tables to.  Then, we can
		// compute the hash value.

		//// Handle the Offset Table part of the file
		offTableNew.version = pTTFInfoOld->pOffset->version;
		offTableNew.numTables = numTablesNew;
		
		// ASSERT: numTablesNew is now the number of tables in the file
        // after deleting the DSIG table (if it existed).

        // Compute the offset table values
        CalcOffsetTable (&offTableNew);

		// Allocate memory for the file buffer info structure
		if ((pFileBufferInfo_OffsetTable =
			(TTFACC_FILEBUFFERINFO *) malloc (sizeof (TTFACC_FILEBUFFERINFO))) == NULL) {
#if MSSIPOTF_ERROR
			SignError ("Cannot continue: Error in malloc.", NULL, FALSE);
#endif
			fReturn = E_OUTOFMEMORY;
			goto done;
		}

		// Set the fields of the TTFACC_FILEBUFFERINFO structure.
		if ((pFileBufferInfo_OffsetTable->puchBuffer =
			    new BYTE [SIZEOF_OFFSET_TABLE]) == NULL) {
#if MSSIPOTF_ERROR
			SignError ("Cannot continue: Error in new BYTE.", NULL, FALSE);
#endif
			fReturn = E_OUTOFMEMORY;
			goto done;
		}

		pFileBufferInfo_OffsetTable->ulBufferSize = SIZEOF_OFFSET_TABLE;
		pFileBufferInfo_OffsetTable->ulOffsetTableOffset = 0;
		pFileBufferInfo_OffsetTable->lpfnReAllocate = &NullRealloc;

		// Write the new offset table to the new file.
		WriteOffsetTable (&offTableNew, pFileBufferInfo_OffsetTable);

        // Pump the bytes of the Offset Table into CryptHashData
	    if (!CryptHashData (hHashTopLevel,
                pFileBufferInfo_OffsetTable->puchBuffer,
                pFileBufferInfo_OffsetTable->ulBufferSize,
                0)) {
#if MSSIPOTF_ERROR
		    SignError ("Error during CryptHashData.", NULL, TRUE);
#endif
		    fReturn = MSSIPOTF_E_CRYPT;
		    goto done;
	    }

// printf ("Pumping offset table bytes:\n");
// PrintBytes (pFileBufferInfo_OffsetTable->puchBuffer, pFileBufferInfo_OffsetTable->ulBufferSize);

        CalcChecksum (pFileBufferInfo_OffsetTable,
            0,
            pFileBufferInfo_OffsetTable->ulBufferSize,
            &ulTempChecksum);
        ulFileChecksum += ulTempChecksum;


        //// Handle the Directory Entries part of the file

        if ((fReturn = ReadDirectoryEntry (pFileBufferInfo,
                        ulOffset_Dsig,
                        &dirDsig))
                != S_OK) {
#if MSSIPOTF_ERROR
            SignError ("Can't read DSIG table.", NULL, FALSE);
#endif
            goto done;
        }

        // Allocate memory for the file buffer info structure
		if ((pFileBufferInfo_DirEntries =
			(TTFACC_FILEBUFFERINFO *) malloc (sizeof (TTFACC_FILEBUFFERINFO))) == NULL) {
#if MSSIPOTF_ERROR
			SignError ("Cannot continue: Error in malloc.", NULL, FALSE);
#endif
			fReturn = E_OUTOFMEMORY;
			goto done;
		}

		// Set the fields of the TTFACC_FILEBUFFERINFO structure.
		if ((pFileBufferInfo_DirEntries->puchBuffer =
			    new BYTE [SIZEOF_DIRECTORY * numTablesNew]) == NULL) {
#if MSSIPOTF_ERROR
			SignError ("Cannot continue: Error in new BYTE.", NULL, FALSE);
#endif
			fReturn = E_OUTOFMEMORY;
			goto done;
		}

		pFileBufferInfo_DirEntries->ulBufferSize = SIZEOF_DIRECTORY * numTablesNew;
		pFileBufferInfo_DirEntries->ulOffsetTableOffset = 0;
		pFileBufferInfo_DirEntries->lpfnReAllocate = &NullRealloc;

        // Read and write all non-DSIG tables, adjusting the offset
        // by SIZEOF_DIRECTORY and (if necessary) dirDsig.length.
        pDir = pTTFInfoOld->pDirectory;
        ulOffset = 0;  // offset in pFileBufferInfo_DirEntries->puchBuffer
        for (i = 0; i < pTTFInfoOld->pOffset->numTables; i++, pDir++) {
            if (pDir->tag != DSIG_LONG_TAG) {
                dir.tag = pDir->tag;
                dir.checkSum = pDir->checkSum;
                dir.length = pDir->length;

                dir.offset = pDir->offset;
                if (pDir->offset > dirDsig.offset ) {
                    dir.offset -= RoundToLongWord(dirDsig.length);
                }
                dir.offset -= SIZEOF_DIRECTORY;
                WriteDirectoryEntry (&dir,
                    pFileBufferInfo_DirEntries,
                    ulOffset);
                ulOffset += SIZEOF_DIRECTORY;

                ulFileChecksum += dir.checkSum;
            }
        }
        assert (ulOffset == (SIZEOF_DIRECTORY * numTablesNew));

        // Pump the bytes of the directory entries into CryptHashData
	    if (!CryptHashData (hHashTopLevel,
                pFileBufferInfo_DirEntries->puchBuffer,
                pFileBufferInfo_DirEntries->ulBufferSize,
                0)) {
#if MSSIPOTF_ERROR
		    SignError ("Error during CryptHashData.", NULL, TRUE);
#endif
		    fReturn = MSSIPOTF_E_CRYPT;
		    goto done;
	    }

// printf ("Pumping dir entries bytes:\n");
// PrintBytes (pFileBufferInfo_DirEntries->puchBuffer, pFileBufferInfo_DirEntries->ulBufferSize);

        CalcChecksum (pFileBufferInfo_DirEntries,
            0,
            pFileBufferInfo_DirEntries->ulBufferSize,
            &ulTempChecksum);
        ulFileChecksum += ulTempChecksum;

        //// ASSERT: ulFileChecksum is the file checksum of the
        //// file before signing.

        //// Handle the tables of the font file
        for (i = 0; i < pTTFInfoOld->pOffset->numTables; i++) {
            pDir = pTTFInfoOld->ppDirSorted[i];
// ConvertLongTagToString (pDir->tag, tagtemp);
// printf ("Dealing with table %s.\n", tagtemp);
            if (pDir->tag == HEAD_LONG_TAG) {

                // head table

                // set up the file buffer info structure

                // Allocate memory for the file buffer info structure
		        if ((pFileBufferInfo_Head =
			        (TTFACC_FILEBUFFERINFO *) malloc (sizeof (TTFACC_FILEBUFFERINFO))) == NULL) {
#if MSSIPOTF_ERROR
			        SignError ("Cannot continue: Error in malloc.", NULL, FALSE);
#endif
			        fReturn = E_OUTOFMEMORY;
			        goto done;
		        }

		        // Set the fields of the TTFACC_FILEBUFFERINFO structure.
		        if ((pFileBufferInfo_Head->puchBuffer =
			            new BYTE [SIZEOF_HEAD]) == NULL) {
#if MSSIPOTF_ERROR
			        SignError ("Cannot continue: Error in new BYTE.", NULL, FALSE);
#endif
			        fReturn = E_OUTOFMEMORY;
			        goto done;
		        }

		        pFileBufferInfo_Head->ulBufferSize = SIZEOF_HEAD;
		        pFileBufferInfo_Head->ulOffsetTableOffset = 0;
		        pFileBufferInfo_Head->lpfnReAllocate = &NullRealloc;

                // read in the head table from the original file
                if (ReadGeneric (pTTFInfoOld->pFileBufferInfo, (uint8 *) &head,
                    SIZEOF_HEAD, HEAD_CONTROL, pDir->offset, &usBytesMoved) != NO_ERROR) {

#if MSSIPOTF_ERROR
                    SignError ("Error reading head table.", NULL, FALSE);
#endif
                    fReturn = MSSIPOTF_E_CANTGETOBJECT;
		            goto done;
                }
                assert (usBytesMoved == SIZEOF_HEAD);

                head.checkSumAdjustment = 0xb1b0afba - ulFileChecksum;

                // write the head table to the file buffer info structure
                if (WriteGeneric(pFileBufferInfo_Head, (uint8 *) &head,
                        SIZEOF_HEAD, HEAD_CONTROL, 0, &usBytesMoved) != NO_ERROR) {
                    DbgPrintf ("Error writing head table.\n");
		            fReturn = MSSIPOTF_E_FILE;
                    goto done;
                }
                assert (usBytesMoved == SIZEOF_HEAD);

                // Pump the bytes of the head table into CryptHashData
	            if (!CryptHashData (hHashTopLevel,
                        pFileBufferInfo_Head->puchBuffer,
                        pFileBufferInfo_Head->ulBufferSize,
                        0)) {
#if MSSIPOTF_ERROR
		            SignError ("Error during CryptHashData.", NULL, TRUE);
#endif
		            fReturn = MSSIPOTF_E_CRYPT;
		            goto done;
	            }

// printf ("Pumping head table bytes:\n");
// PrintBytes (pFileBufferInfo_Head->puchBuffer, pFileBufferInfo_Head->ulBufferSize);
                // we now need to pump some pad bytes into CryptHashData
                for (j = 0; j < RoundToLongWord(SIZEOF_HEAD) - SIZEOF_HEAD; j++) {
// PrintBytes (zero, 1);
	                if (!CryptHashData (hHashTopLevel,
                            zero,
                            1,
                            0)) {
#if MSSIPOTF_ERROR
		                SignError ("Error during CryptHashData.", NULL, TRUE);
#endif
		                fReturn = MSSIPOTF_E_CRYPT;
		                goto done;
	                }
                }

            } else if (pDir->tag != DSIG_LONG_TAG) {

                // non-DSIG and non-head tables
                if ((pDir->offset + RoundToLongWord(pDir->length)) <=
                    pFileBufferInfo->ulBufferSize) {

                    // not the last table
	                if (!CryptHashData (hHashTopLevel,
                            pFileBufferInfo->puchBuffer + pDir->offset,
                            RoundToLongWord(pDir->length),
                            0)) {
#if MSSIPOTF_ERROR
		                SignError ("Error during CryptHashData.", NULL, TRUE);
#endif
		                fReturn = MSSIPOTF_E_CRYPT;
		                goto done;
	                }

// ConvertLongTagToString (pDir->tag, tagtemp);
// printf ("Pumping %s table bytes.\n", tagtemp);
                } else {

                    // the last table
	                if (!CryptHashData (hHashTopLevel,
                            pFileBufferInfo->puchBuffer + pDir->offset,
                            pDir->length,
                            0)) {
#if MSSIPOTF_ERROR
		                SignError ("Error during CryptHashData.", NULL, TRUE);
#endif
		                fReturn = MSSIPOTF_E_CRYPT;
		                goto done;
	                }
                    // we now need to pump some possibly missing
                    // pad bytes into CryptHashData
                    for (i = 0; i < RoundToLongWord(pDir->length) - pDir->length; i++) {
	                    if (!CryptHashData (hHashTopLevel,
                                zero,
                                1,
                                0)) {
#if MSSIPOTF_ERROR
		                    SignError ("Error during CryptHashData.", NULL, TRUE);
#endif
		                    fReturn = MSSIPOTF_E_CRYPT;
		                    goto done;
	                    }
                    }
// ConvertLongTagToString (pDir->tag, tagtemp);
// printf ("Pumping %s table bytes.\n", tagtemp);
                }
            }
            // Note: we ignore the DSIG table.

        }
    }

    
    //// Pump the extra bytes associated with the DSIG table into
    //// the hash function.
	if (!CryptHashData (hHashTopLevel, pbDsig, cbDsig, 0)) {
#if MSSIPOTF_ERROR
		SignError ("Error during CryptHashData.", NULL, TRUE);
#endif
		fReturn = MSSIPOTF_E_CRYPT;
		goto done;
	}
// printf ("Pumping DSIG bytes:\n");
// PrintBytes (pbDsig, cbDsig);
		
	//// Compute the top-level hash value, and place the resulting
	//// hash value into pbHashTopLevel.
	if (!CryptGetHashParam(hHashTopLevel, HP_HASHVAL, pbHashTopLevel, &cbHash, 0)) {
#if MSSIPOTF_ERROR
		SignError ("Error during CryptGetHashParam (hash value)", NULL, TRUE);
#endif
		fReturn = MSSIPOTF_E_CRYPT;
		goto done;
	}

	//// Set the return values.
	// Set the top level hash value
	*ppbHashTopLevel = pbHashTopLevel;
	*pcbHashTopLevel = cbHash;

	fReturn = S_OK;

done:
	// free resources
    if (pTTFInfoOld) {
        // free the memory for the FileBufferInfo, but don't
        // free the memory for the actual file.
        if (pTTFInfoOld->pFileBufferInfo) {
            free (pTTFInfoOld->pFileBufferInfo);
        }

        delete pTTFInfoOld->pOffset;
		pTTFInfoOld->pOffset = NULL;

        delete [] pTTFInfoOld->pDirectory;
		pTTFInfoOld->pDirectory = NULL;

        delete [] pTTFInfoOld->ppDirSorted;
		pTTFInfoOld->ppDirSorted = NULL;

        delete pTTFInfoOld;
    }

	delete pDsigTable;

	if (pFileBufferInfo_OffsetTable) {
		delete [] pFileBufferInfo_OffsetTable->puchBuffer;

		free (pFileBufferInfo_OffsetTable);
	}

	if (pFileBufferInfo_DirEntries) {
		delete [] pFileBufferInfo_DirEntries->puchBuffer;

		free (pFileBufferInfo_DirEntries);
	}

	if (pFileBufferInfo_Head) {
		delete [] pFileBufferInfo_Head->puchBuffer;

		free (pFileBufferInfo_Head);
	}

    return fReturn;
}


//
// Compute the hash value of the input TTF file based on
// given DsigSignature.
//
// If the DsigInfo in the DsigSigF2 object is not valid (i.e., cbDsigInfo == 0),
// then we compute the hash value assuming we are signing for the first time.
// If the DsigInfo is valid (i.e., cbDsigInfo != 0), then we compute the
// hash value assuming we are verifying the hash value of the file (given
// the DsigInfo).
//
// The hash function used is based on hProv.
// The result is returned in ppbHashToplevel and pcbHashTopLevel.
//
HRESULT CDsigSigF2::HashTTFfile (TTFACC_FILEBUFFERINFO *pFileBufferInfo,
                                 BYTE **ppbHashTopLevel,
                                 DWORD *pcbHashTopLevel,
                                 HCRYPTPROV hProv,
                                 ALG_ID alg_id,
                                 ULONG cbDsig,
                                 BYTE *pbDsig)
{
	HRESULT fReturn = E_FAIL;

	USHORT usNumGlyphs = 0;
	UCHAR *puchKeepList = NULL;
	CHashTableGlyfContext *pHashTableGlyfContext = NULL;

	HCRYPTHASH hHashTopLevel = NULL;	// The top-level hash value

	BYTE *pbHashTopLevel = NULL;
	DWORD cbHash;					// count of bytes for all hash values
	USHORT cbHashShort;

    HCRYPTHASH hHash = NULL;        // intermediate hash object
	BYTE *pbHash = NULL;			// pointer to intermediate hash values

    OFFSET_TABLE OffsetTable;
    USHORT usNumTables = 0;
    DIRECTORY Directory;
    CHAR pszTag [5];
    BOOL fPumpBytes = FALSE;        // BUGBUG: eventually will need to get rid
                                    // of this variable
	BYTE *pbNewMissingHashValues;
	USHORT cNewMissingHashValues;
	ULONG cbNewMissingHashValues;

    USHORT i, j;



#if (DEBUG_HASHTTFINFO == 1)
	PrintDsigInfo (pDsigInfo);
#endif

	//// Set up the top-level hash value.

	// Set hHashTopLevel to be the hash object.
	if (!CryptCreateHash(hProv, alg_id, 0, 0, &hHashTopLevel)) {
#if MSSIPOTF_ERROR
		SignError ("Error during CryptCreateHash.",
            "HashTTFfile", TRUE);
#endif
		fReturn = MSSIPOTF_E_CRYPT;
		goto done;
	}

	// Get the hash value size.  This size is the size of both
	// the top-level hash and the hash values for individual tables.
	if ((fReturn = GetHashValueSize (hHashTopLevel, &cbHashShort)) != NO_ERROR) {
#if MSSIPOTF_ERROR
		SignError ("Error during GetHashValueSize.", NULL, FALSE);
#endif
		goto done;
	} else {
		cbHash = (DWORD) cbHashShort;
	}

	// Allocate memory for the hash value.
	if ((pbHashTopLevel = new BYTE [cbHash]) == NULL) {
#if MSSIPOTF_ERROR
		SignError ("Cannot continue: Error in new BYTE.", NULL, FALSE);
#endif
		fReturn = E_OUTOFMEMORY;
		goto done;
	}


	//// Compute the hash values for each of the tables.  As each table's
	//// hash value is computed, pump the table's hash value to the top-level
	//// hash function.

    // This block of memory is recycled for each table's hash value.
	if ((pbHash = new BYTE [cbHash]) == NULL) {
#if MSSIPOTF_ERROR
		SignError ("Cannot continue: Error in new BYTE.", NULL, FALSE);
#endif
		fReturn = E_OUTOFMEMORY;
		goto done;
	}


    // For each table in the directory, produce a hash value for it
    // and add it to the top-level hash value.
    if ((fReturn = ReadOffsetTable (pFileBufferInfo, &OffsetTable))
            != S_OK) {
#if MSSIPOTF_DBG
        DbgPrintf ("Error in ReadOffsetTable.\n");
#endif
        goto done;
    }
    usNumTables = OffsetTable.numTables;

    for (i = 0; i < usNumTables; i++) {
        fPumpBytes = FALSE;     // gets set to TRUE if any new bytes need
                                // to be pumped into the top-level hash value
        // Read in the directory entry
        if ((fReturn = ReadDirectoryEntry (pFileBufferInfo,
            SIZEOF_OFFSET_TABLE + (i * SIZEOF_DIRECTORY),
            &Directory)) != NO_ERROR) {

#if MSSIPOTF_DBG
            DbgPrintf ("Error in ReadDirectoryEntry.\n");
#endif
            goto done;
        }
        ConvertLongTagToString (Directory.tag, pszTag);

        switch (Directory.tag) {

            // BUGBUG: Need to deal with the possibility that the EBLC table
            // existed in the original file, but because of subsetting is
            // not in the file now.

        //// The DSIG table.
        case DSIG_LONG_TAG:
            break;

        //// Tables that, for the most part, do not need explicit checks
        case CMAP_LONG_TAG:
            break;

        case EBDT_LONG_TAG:
            break;

        case HDMX_LONG_TAG:
            break;

        case HMTX_LONG_TAG:
            break;

        case KERN_LONG_TAG:
            break;

        case LOCA_LONG_TAG:
            break;

        case LTSH_LONG_TAG:
            break;

        case VMTX_LONG_TAG:
            break;


        //// Tables that are partially hashed and partially checked
        case HEAD_LONG_TAG:
            if ((fReturn = HashTableHead (pFileBufferInfo,
                            pbHash, cbHash, hProv, alg_id)) != NO_ERROR) {
#if MSSIPOTF_DBG
                DbgPrintf ("Error in HashTableHead.\n");
#endif
                goto done;
            }
            fPumpBytes = TRUE;
            break;

        case HHEA_LONG_TAG:
            if ((fReturn = HashTableHhea (pFileBufferInfo,
                            pbHash, cbHash, hProv, alg_id)) != NO_ERROR) {
#if MSSIPOTF_DBG
                DbgPrintf ("Error in HashTableHhea.\n");
#endif
                goto done;
            }
            fPumpBytes = TRUE;
            break;

        case MAXP_LONG_TAG:
            if ((fReturn = HashTableMaxp (pFileBufferInfo,
                            pbHash, cbHash, hProv, alg_id)) != NO_ERROR) {
#if MSSIPOTF_DBG
                DbgPrintf ("Error in HashTableMaxp.\n");
#endif
                goto done;
            }
            fPumpBytes = TRUE;
            break;

        case OS2_LONG_TAG:
            if ((fReturn = HashTableOS2 (pFileBufferInfo,
                            pbHash, cbHash, hProv, alg_id)) != NO_ERROR) {
#if MSSIPOTF_DBG
                DbgPrintf ("Error in HashTableOS2.\n");
#endif
                goto done;
            }
            fPumpBytes = TRUE;
            break;

        case VHEA_LONG_TAG:
            if ((fReturn = HashTableVhea (pFileBufferInfo,
                            pbHash, cbHash, hProv, alg_id)) != NO_ERROR) {
#if MSSIPOTF_DBG
                DbgPrintf ("Error in HashTableVhea.\n");
#endif
                goto done;
            }
            fPumpBytes = TRUE;
            break;


        //// The more complicated tables
        // The glyf table
        case GLYF_LONG_TAG:
	        usNumGlyphs = GetNumGlyphs (pFileBufferInfo);
	        if ((puchKeepList = new BYTE [usNumGlyphs]) == NULL) {
#if MSSIPOTF_ERROR
		        SignError ("Cannot continue: Error in new BYTE.", NULL, FALSE);
#endif
		        fReturn = E_OUTOFMEMORY;
		        goto done;
	        }
	        for (j = 0; j < usNumGlyphs; j++) {
		        puchKeepList[j] = TRUE;
	        }

	        pHashTableGlyfContext =
		        new CHashTableGlyfContext (pFileBufferInfo,
                                           (cbDsigInfo ? TRUE : FALSE),
								           pDsigInfo,
								           puchKeepList,
								           cbHash,
								           hProv,
                                           alg_id);

            // If cbDsigInfo is 0, then we are signing for the first time --
            // we might need to add missing hash values to the DsigInfo.
            // If cbDsigInfo is not 0, then we are verifying.
            if (cbDsigInfo != 0) {
	            if ((fReturn = pHashTableGlyfContext->HashTable_glyf
							            (TRUE,	// suppress appending missing hash values
							             pbHash,
							             NULL,	// no new hash values
							             NULL,
							             NULL)) != NO_ERROR) {
#if MSSIPOTF_DBG
		            DbgPrintf ("Error in HashTable_glyf.\n");
#endif
		            goto done;
	            }
            } else {
 	            if ((fReturn = pHashTableGlyfContext->HashTable_glyf
							            (FALSE,	// possibly append missing hash values
							             pbHash,
							             &pbNewMissingHashValues,	// new hash values
							             &cNewMissingHashValues,
							             &cbNewMissingHashValues)) != NO_ERROR) {
#if MSSIPOTF_DBG
		            DbgPrintf ("Error in HashTable_glyf.\n");
#endif
		            goto done;
	            }
               
                // update the DsigInfo and its size to make it valid
	            pDsigInfo->SetNumMissingGlyphs (cNewMissingHashValues);
	            pDsigInfo->SetMissingGlyphs (pbNewMissingHashValues);
                pDsigInfo->GetSize(&cbDsigInfo);
            }

            fPumpBytes = TRUE;
            break;

        case EBLC_LONG_TAG:
            break;

        case NAME_LONG_TAG:
            break;

        case POST_LONG_TAG:
            break;

        case VDMX_LONG_TAG:
            break;


        //// Simple tables (treated as constant tables).  Note that tables
        //// with unknown tags are treated as simple tables.
        case CVT_LONG_TAG:
        case EBSC_LONG_TAG:
        case FPGM_LONG_TAG:
        case GASP_LONG_TAG:
        case PCLT_LONG_TAG:
        case PREP_LONG_TAG:
        default:
            if ((fReturn = HashTableConst (pFileBufferInfo, pszTag,
                            pbHash, cbHash, hProv, alg_id)) != NO_ERROR) {
#if MSSIPOTF_DBG
		        DbgPrintf ("Error in HashTableConst.\n");
#endif
		        goto done;
	        }
            fPumpBytes = TRUE;
            break;

        }

        if (fPumpBytes) {
            // Pump the hash value created for the table just
            // processed into the top-level hash
#if (DEBUG_HASHTTFFILE == 1)
#if MSSIPOTF_DBG
	        DbgPrintf ("Data pumped into top-level hash function from %s:\n",
                pszTag);
	        PrintBytes (pbHash, cbHash);
#endif
#endif

            if (!CryptHashData (hHashTopLevel, pbHash, cbHash, 0)) {
#if MSSIPOTF_DBG
                DbgPrintf ("Table: 0x%x: ", Directory.tag);
#endif
#if MSSIPOTF_ERROR
                SignError ("Error during CryptHashData.", NULL, TRUE);
#endif
		        fReturn = MSSIPOTF_E_CRYPT;
		        goto done;
            }
        }

    }

	
	//// Compute the top-level hash value, and place the resulting
	//// hash value into pbHash.
	if (!CryptGetHashParam(hHashTopLevel, HP_HASHVAL, pbHashTopLevel, &cbHash, 0)) {
#if MSSIPOTF_ERROR
		SignError ("Error during CryptGetHashParam (hash value).", NULL, TRUE);
#endif
		fReturn = MSSIPOTF_E_CRYPT;
		goto done;
	}

	//// Set the return values.
	// Set the top level hash value
	*ppbHashTopLevel = pbHashTopLevel;
	*pcbHashTopLevel = cbHash;

	fReturn = S_OK;


	//// Clean up resources.
done:
	if (hHashTopLevel)
		CryptDestroyHash (hHashTopLevel);

	delete [] pbHash;

	delete pHashTableGlyfContext;

	return fReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\sign\signglobal.h ===
//
// signglobal.h
//
// (c) 1997-1998. Microsoft Corporation.
// Author: Donald Chinn
//


#include <stdio.h>
#include <assert.h>
#include <stdlib.h>
#include <malloc.h>

// if PERF == 1, then we print out performance numbers
#define PERF 0

#define MSSIPOTF_DBG 0
#define MSSIPOTF_ERROR 0

// Define DbgPrintf to be just the runtime C printf
#define DbgPrintf printf

// if NO_FSTRACE is 1, then we behave as though the font
// file passed the fstrace checks.
#define NO_FSTRACE 0

#define ENABLE_FORMAT2 0
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\sign\subset.h ===
//
// subset.h
//
// (c) 1997-1998. Microsoft Corporation.
// Author: Donald Chinn
//
// Include files from the subsetting code.
// Since the subsetting code is written in
// C, we need to specify extern "C".
//

#ifndef _SUBSET_H
#define _SUBSET_H

#ifdef __cplusplus
extern "C" {
#endif

#include "typedefs.h"
#include "ttff.h"
#include "ttfacc.h"
#include "ttftable.h"
#include "ttftabl1.h"
#include "ttfcntrl.h"
#include "makeglst.h"

#include "mtxcalc.h"

#ifdef __cplusplus
}
#endif

#endif // _SUBSET_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\sign\subsetcmap.h ===
//
// subsetCmap.h
//
// (c) 1997-1998. Microsoft Corporation.
// Author: Donald Chinn
//
// Include files from the subset code needed
// for ReadAllocCmapFormat4Offset and
// for MakeKeepGlyphListOffset.
//

#ifndef _SUBSETCMAP_H
#define _SUBSETCMAP_H

#ifdef __cplusplus
extern "C" {
#endif

#include "ttferror.h"
#include "ttmem.h"
#include "ttfdelta.h"

// from makeglst.c
#define WIN_ANSI_MIDDLEDOT 0xB7
#define WIN_ANSI_BULLET 0x2219

#include "automap.h"


#ifdef __cplusplus
}
#endif

#endif // _SUBSETCMAP_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\sign\signerr.h ===
//
// signerr.h
//
// (c) 1997-1998. Microsoft Corporation.
// Author: Donald Chinn
//
// Functions exported:
//   SignError
//

#ifndef _SIGNERR_H
#define _SIGNERR_H

#include "signglobal.h"

#ifndef NO_ERROR
#define NO_ERROR 0
#endif


/*
//
// BUGBUG:
// Error codes to be added to winerror.h and winerror.w
//

#ifdef RC_INVOKED
#define _HRESULT_TYPEDEF_(_sc) _sc
#else // RC_INVOKED
#define _HRESULT_TYPEDEF_(_sc) ((HRESULT)_sc)
#endif // RC_INVOKED

//
// MessageId: MSSIPOTF_E_OUTOFMEMRANGE
//
// MessageText:
//
//   Tried to reference a part of the file outside the proper range.
//
#define MSSIPOTF_E_OUTOFMEMRANGE   _HRESULT_TYPEDEF_(0x80110001L)

//
// MessageId: MSSIPOTF_E_CANTGETOBJECT
//
// MessageText:
//
//   Could not retrieve an object from the file.
//
#define MSSIPOTF_E_CANTGETOBJECT  _HRESULT_TYPEDEF_(0x80110002L)

//
// MessageId: MSSIPOTF_E_NOHEADTABLE
//
// MessageText:
//
//   Could not find the head table in the file.
//
#define MSSIPOTF_E_NOHEADTABLE     _HRESULT_TYPEDEF_(0x80110003L)

//
// MessageId: MSSIPOTF_E_BAD_MAGICNUMBER
//
// MessageText:
//
//   The magic number in the head table is incorrect.
//
#define MSSIPOTF_E_BAD_MAGICNUMBER  _HRESULT_TYPEDEF_(0x80110004L)

//
// MessageId: MSSIPOTF_E_BAD_OFFSET_TABLE
//
// MessageText:
//
//   The offset table has incorrect values.
//
#define MSSIPOTF_E_BAD_OFFSET_TABLE  _HRESULT_TYPEDEF_(0x80110005L)

//
// MessageId: MSSIPOTF_E_TABLE_TAGORDER
//
// MessageText:
//
//   Duplicate table tags or tags out of alphabetical order.
//
#define MSSIPOTF_E_TABLE_TAGORDER   _HRESULT_TYPEDEF_(0x80110006L)

//
// MessageId: MSSIPOTF_E_TABLE_LONGWORD
//
// MessageText:
//
//   A table does not start on a long word boundary.
//
#define MSSIPOTF_E_TABLE_LONGWORD   _HRESULT_TYPEDEF_(0x80110007L)

//
// MessageId: MSSIPOTF_E_BAD_FIRST_TABLE_PLACEMENT
//
// MessageText:
//
//   First table does not appear after header information.
//
#define MSSIPOTF_E_BAD_FIRST_TABLE_PLACEMENT  _HRESULT_TYPEDEF_(0x80110008L)

//
// MessageId: MSSIPOTF_E_TABLES_OVERLAP
//
// MessageText:
//
//   Two or more tables overlap.
//
#define MSSIPOTF_E_TABLES_OVERLAP   _HRESULT_TYPEDEF_(0x80110009L)

//
// MessageId: MSSIPOTF_E_TABLE_PADBYTES
//
// MessageText:
//
//   Too many pad bytes between tables or pad bytes are not 0.
//
#define MSSIPOTF_E_TABLE_PADBYTES   _HRESULT_TYPEDEF_(0x8011000AL)

//
// MessageId: MSSIPOTF_E_FILETOOSMALL
//
// MessageText:
//
//   File is too small to contain the last table.
//
#define MSSIPOTF_E_FILETOOSMALL   _HRESULT_TYPEDEF_(0x8011000BL)

//
// MessageId: MSSIPOTF_E_TABLE_CHECKSUM
//
// MessageText:
//
//   A table checksum is incorrect.
//
#define MSSIPOTF_E_TABLE_CHECKSUM   _HRESULT_TYPEDEF_(0x8011000CL)

//
// MessageId: MSSIPOTF_E_FILE_CHECKSUM
//
// MessageText:
//
//   The file checksum is incorrect.
//
#define MSSIPOTF_E_FILE_CHECKSUM   _HRESULT_TYPEDEF_(0x8011000DL)

//
// MessageId: MSSIPOTF_E_FAILED_POLICY
//
// MessageText:
//
//   The signature does not have the correct attributes for the policy.
//
#define MSSIPOTF_E_FAILED_POLICY   _HRESULT_TYPEDEF_(0x80110010L)

//
// MessageId: MSSIPOTF_E_FAILED_HINTS_CHECK
//
// MessageText:
//
//   The file did not pass the hints check.
//
#define MSSIPOTF_E_FAILED_HINTS_CHECK   _HRESULT_TYPEDEF_(0x80110011L)

//
// MessageId: MSSIPOTF_E_NOT_OPENTYPE
//
// MessageText:
//
//   The file is not an OpenType file.
//
#define MSSIPOTF_E_NOT_OPENTYPE   _HRESULT_TYPEDEF_(0x80110012L)

//
// MessageId: MSSIPOTF_E_FILE
//
// MessageText:
//
//   Failed on a file operation (open, map, read, write).
//
#define MSSIPOTF_E_FILE   _HRESULT_TYPEDEF_(0x80110013L)

//
// MessageId: MSSIPOTF_E_CRYPT
//
// MessageText:
//
//   A call to a CryptoAPI function failed.
//
#define MSSIPOTF_E_CRYPT   _HRESULT_TYPEDEF_(0x80110014L)

//
// MessageId: MSSIPOTF_E_BADVERSION
//
// MessageText:
//
//   There is a bad version number in the file.
//
#define MSSIPOTF_E_BADVERSION   _HRESULT_TYPEDEF_(0x80110015L)

//
// MessageId: MSSIPOTF_E_DSIG_STRUCTURE
//
// MessageText:
//
//   The structure of the DSIG table is incorrect.
//
#define MSSIPOTF_E_DSIG_STRUCTURE   _HRESULT_TYPEDEF_(0x80110016L)

//
// MessageId: MSSIPOTF_E_PCONST_CHECK
//
// MessageText:
//
//   A check failed in a partially constant table.
//
#define MSSIPOTF_E_PCONST_CHECK   _HRESULT_TYPEDEF_(0x80110017L)

//
// MessageId: MSSIPOTF_E_STRUCTURE
//
// MessageText:
//
//   Some other kind of structural error.
//
#define MSSIPOTF_E_STRUCTURE   _HRESULT_TYPEDEF_(0x80110018L)

*/


void SignError (CHAR *s1, CHAR *s2, BOOL fGetLastError);


#endif  // _SIGNERR_H
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\sign\signerr.cpp ===
//
// signerr.cpp
//
// (c) 1997-1998. Microsoft Corporation.
// Author: Donald Chinn
//
// Functions in this file:
//   SignError
//

#include <windows.h>

#include "signerr.h"


// s1 must point to a valid string.  s2 may be NULL.
void SignError (CHAR *s1, CHAR *s2, BOOL fGetLastError)
{
	DbgPrintf ("%s", s1);
	if (s2)
		DbgPrintf ("%s", s2);
	if (fGetLastError)
		DbgPrintf ("  Error %x.", GetLastError());
	DbgPrintf ("\n");
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\sign\ttfinfo.cpp ===
//
// ttfinfo.cpp
//
// (c) 1997-1998. Microsoft Corporation.
// Author: Donald Chinn
//
// Routines for high-level TTF file operations.
//
// Functions in this file:
//   IsTTFFile_handle
//   IsTTFFile_memptr
//   IsTTFFile
//   NullRealloc
//   FreeFileBufferInfo
//   FreeTTFInfo
//   OffsetCmp
//   SortTablesByOffset
//   GetTTFInfo
//   CheckTTF
//   InitTTFStructures
//   ExistsGlyfTable
//   WriteNewFile
//   WriteNonDsigTables
//   GetNewTTFFileSize
//


// DEBUG_TTFINFO
// 1: print out the offset table and directory of the new file.
#define DEBUG_TTFINFO 1


#include <stdlib.h>
#include <search.h>

#include "ttfinfo.h"
#include "utilsign.h"
#include "cryptutil.h"
#include "signerr.h"


// IsTTTFFile_handle returns TRUE iff the given file handle
// has the structure of a TrueType font file.
BOOL IsTTFFile_handle (HANDLE hFile,
                       BOOL fTableChecksum,
                       HRESULT *phrError)
{
	BOOL rv = FALSE;
	CFileObj *pFileObj = NULL;

    if ((pFileObj =
            (CFileObj *) new CFileHandle (hFile, FALSE)) == NULL) {
#if MSSIPOTF_ERROR
		SignError ("Cannot continue: Error in new CFileHandle.", NULL, FALSE);
#endif
        goto done;
    }

	if (pFileObj->MapFile (0, PAGE_READONLY, FILE_MAP_READ) != NO_ERROR) {
#if MSSIPOTF_DBG
		DbgPrintf ("Error in MapFile.\n");
#endif
		goto done;
	}

	rv = IsTTFFile (pFileObj, fTableChecksum, phrError);

done:
    if (pFileObj) {
        pFileObj->UnmapFile();
    }

    delete pFileObj;

	return rv;
}


// IsTTFFile_memptr returns TRUE iff the given memory pointer
// points to a block of memory that has the structure of a
// TrueType font file.
BOOL IsTTFFile_memptr (BYTE *pbMemPtr,
                       ULONG cbMemPtr,
                       BOOL fTableChecksum,
                       HRESULT *phrError)
{
	BOOL rv = FALSE;
	CFileObj *pFileObj = NULL;

    if ((pFileObj =
            (CFileObj *) new CFileMemPtr (pbMemPtr, cbMemPtr)) == NULL) {
#if MSSIPOTF_ERROR
		SignError ("Cannot continue: Error in new CFileMemPtr.", NULL, FALSE);
#endif
        goto done;
    }

	rv = IsTTFFile (pFileObj, fTableChecksum, phrError);

done:
	delete pFileObj;

	return rv;
}


//
// IsTTFFile provides a quick way of determining whether
// the file has the structure of a TrueType font file.
// The input is a CFileObj that is assumed to already
// be mapped.
//
// This function makes a variety of checks on the file.
//
// It then calls CheckTTF, which does more extensive
// checking for structural properties of the font file.
// (See that function's comments for more details.)
//
// The table checksums of the file are checked if and
// only if fTableChecksum is TRUE.
//
BOOL IsTTFFile (CFileObj *pFileObj,
                BOOL fTableChecksum,
                HRESULT *phrError)
{
	BOOL rv = FALSE;  // return value

	TTFACC_FILEBUFFERINFO fileBufferInfo;
	HEAD head;

    TTFInfo *pTTFInfo = NULL;

	// Here's the algorithm:
	// 1. Read the head table.
	// 2. Get the magic number field from the head table.
	// 3. Compare its value to the magic number.
    // 4. Make sure it passes structural checks.

	fileBufferInfo.puchBuffer = pFileObj->GetFileObjPtr();
	fileBufferInfo.ulBufferSize = pFileObj->GetFileObjSize();
	fileBufferInfo.ulOffsetTableOffset = 0;
	fileBufferInfo.lpfnReAllocate = NULL;

	// step 1
	if (GetHead (&fileBufferInfo, &head) == 0) {
#if MSSIPOTF_ERROR
		DbgPrintf ("Not an OTF: Couldn't read head table.\n");
#endif
        *phrError = MSSIPOTF_E_NOHEADTABLE;
		goto done;
	}

	// step 2
	if (head.magicNumber != MAGIC_NUMBER) {
#if MSSIPOTF_ERROR
		DbgPrintf ("Not an OTF: Bad magic number.\n");
#endif
        *phrError = MSSIPOTF_E_BAD_MAGICNUMBER;
		goto done;
	}

    // step 3
	// Set the TTFInfo structure of the old file
	// Allocate memory for the TTFInfo structure
	if ((pTTFInfo = new TTFInfo) == NULL) {
#if MSSIPOTF_ERROR
		SignError ("Cannot continue: Error in new TTFInfo.", NULL, FALSE);
#endif
        *phrError = E_OUTOFMEMORY;
		goto done;
	}

    // Initialize TTFInfo pointers to NULL
    pTTFInfo->pFileBufferInfo = NULL;
    pTTFInfo->pOffset = NULL;
    pTTFInfo->pDirectory = NULL;
    pTTFInfo->ppDirSorted = NULL;

    if ((*phrError = GetTTFInfo (pFileObj->GetFileObjPtr(),
                                 pFileObj->GetFileObjSize(),
                                 pTTFInfo)) != S_OK) {
#if MSSIPOTF_DBG
		DbgPrintf ("Error in GetTTFInfo.\n");
#endif
		goto done;
	}

    // Step 4
	// Check that the TTF file has a legal directory and table structure
	if ((*phrError = CheckTTF (pTTFInfo, fTableChecksum)) != S_OK) {
		goto done;
	}

	rv = TRUE;

done:

    FreeTTFInfo (pTTFInfo);

	return rv;
}


//
// This function is used for any TTFACC_FILEBUFFERINFO
// that never needs to actually realloc.  For example,
// if the file buffer is actually a memory-mapped file,
// then the buffer's size needs to already be known by
// its creator.  Thus, any reallocation of that space would
// require us to unmap the file and remap it to the new size.
// But this isn't possible because the handle to the original
// file is not contained in the TTFACC_FILEBUFFERINFO
// structure.
void * NullRealloc (void * pb, size_t n)
{
	return pb;
}


//
// Free the space of the TTFACC_FILEBUFFERINFO structure.
// Note: whoever allocated the space for the puchBuffer must
// free that space themselves.
//
void FreeFileBufferInfo (TTFACC_FILEBUFFERINFO *pFileBufferInfo)
{
	if (pFileBufferInfo) {
        /*
        if (pFileBufferInfo->puchBuffer) {
            UnmapViewOfFile (pFileBufferInfo->puchBuffer);
            pFileBufferInfo->puchBuffer = NULL;
        }
        */
		free (pFileBufferInfo);
	}
}


//
// Free the allocated resources in a TTFInfo structure
//
void FreeTTFInfo (TTFInfo *pTTFInfo)
{
	if (pTTFInfo) {
		if (pTTFInfo->pFileBufferInfo) {
			FreeFileBufferInfo (pTTFInfo->pFileBufferInfo);
			pTTFInfo->pFileBufferInfo = NULL;
		}
        delete pTTFInfo->pOffset;
		pTTFInfo->pOffset = NULL;

        delete [] pTTFInfo->pDirectory;
		pTTFInfo->pDirectory = NULL;

        delete [] pTTFInfo->ppDirSorted;
		pTTFInfo->ppDirSorted = NULL;

		delete pTTFInfo;
	}
}


//
// Comparison function for sorting using the offset as the key.
// If the offsets are the same, then the offset with the greater
// length is greater.
//
// elem1 and elem2 are pointers to a pointer to a DIRECTORY
//
int __cdecl OffsetCmp (const void *elem1, const void *elem2)
{
	if ((* (DIRECTORY * *) elem1)->offset < (* (DIRECTORY * *) elem2)->offset) {
		return -1;
	} else if ((* (DIRECTORY * *) elem1)->offset > (* (DIRECTORY * *) elem2)->offset) {
		return 1;
	} else {
        // the offsets are equal; the length now determines which is greater
        if ((* (DIRECTORY * *) elem1)->length <
            (* (DIRECTORY * *) elem2)->length) {
            return -1;
        } else if ((* (DIRECTORY * *) elem1)->length >
            (* (DIRECTORY * *) elem2)->length) {
            return 1;
        } else {
		    return 0;
        }
	}
}


//
// Given a ttf info struct, set the ppDirSorted field to
// be an array of pointers to the directory entries,
// sorted by ascending offset.
//
// This function assumes that the TTF file is large enough
// to contain an offset table and a number of directories
// specified in the offset table.
//
void SortTablesByOffset (TTFInfo *pttfInfo)
{
	qsort ((void *) pttfInfo->ppDirSorted,
		(size_t) pttfInfo->pOffset->numTables,
		sizeof(DIRECTORY *),
		OffsetCmp);
}


//
// Create a TTFInfo structure for the TTF file and
// set all of its fields.
//
// GetTTFInfo allocates memory for subfields, but not for
// the TTFInfo structure itself.
//
HRESULT GetTTFInfo (UCHAR *pFile, ULONG cbFile, TTFInfo *pttfInfo)
{
	HRESULT fReturn = E_FAIL;

	USHORT i;
	USHORT numTables;
	DIRECTORY *pDir;
	ULONG ulOffset;


	// Allocate space for the file buffer info
	if ((pttfInfo->pFileBufferInfo =
		(TTFACC_FILEBUFFERINFO *) malloc (sizeof (TTFACC_FILEBUFFERINFO))) == NULL) {
#if MSSIPOTF_ERROR
		SignError ("Cannot continue: Error in malloc.", NULL, FALSE);
#endif
		fReturn = E_OUTOFMEMORY;
		goto done;
	}

	//// Set the fields of the TTFACC_FILEBUFFERINFO structure
	pttfInfo->pFileBufferInfo->puchBuffer = pFile;
	pttfInfo->pFileBufferInfo->ulBufferSize = cbFile;
	pttfInfo->pFileBufferInfo->ulOffsetTableOffset = 0;
	pttfInfo->pFileBufferInfo->lpfnReAllocate = &NullRealloc;

	//// Check that the file is at least SIZEOF_OFFSET_TABLE long.
	//// (If the file is too small, then we might try to read beyond
	//// the end of the file when we try to read the offset table to
	//// retrieve the number of tables.)
	if (pttfInfo->pFileBufferInfo->ulBufferSize < SIZEOF_OFFSET_TABLE) {
#if MSSIPOTF_ERROR
		SignError ("File too small (not big enough for Offset table).", NULL, FALSE);
#endif
		fReturn = MSSIPOTF_E_FILETOOSMALL;
		goto done;
	}

	if ((pttfInfo->pOffset = new OFFSET_TABLE) == NULL) {
#if MSSIPOTF_ERROR
		SignError ("Cannot continue: Error in new OFFSET_TABLE.", NULL, FALSE);
#endif
		fReturn = E_OUTOFMEMORY;
		goto done;
	}

	//// Read the offset table from the file
	if ((fReturn = ReadOffsetTable (pttfInfo->pFileBufferInfo,
									pttfInfo->pOffset)) != S_OK) {
#if MSSIPOTF_DBG
		DbgPrintf ("Error in ReadOffsetTable.\n");
#endif
		goto done;
	}

	//// Check that the file is at least
	//// SIZEOF_OFFSET_TABLE + (numTables * SIZEOF_DIRECTORY) long
	//// (If the file is too small, then we might try to read beyond
	//// the end of the file when we try to sort the directory entries
	//// by their offsets.)
	if (pttfInfo->pFileBufferInfo->ulBufferSize <
		SIZEOF_OFFSET_TABLE + (ULONG) (pttfInfo->pOffset->numTables * SIZEOF_DIRECTORY)) {
#if MSSIPOTF_ERROR
		SignError ("File too small (not big enough for all the directory entries).", NULL, FALSE);
#endif
		fReturn = MSSIPOTF_E_FILETOOSMALL;
		goto done;
	}

	if ((pttfInfo->pDirectory =
		    new DIRECTORY [pttfInfo->pOffset->numTables]) == NULL) {
#if MSSIPOTF_ERROR
		SignError ("Cannot continue: Error in new DIRECTORY.", NULL, FALSE);
#endif
		fReturn = E_OUTOFMEMORY;
		goto done;
	}

	// Allocate space for the array of sorted pointers
	if ((pttfInfo->ppDirSorted =
        new (DIRECTORY * [pttfInfo->pOffset->numTables])) == NULL) {
#if MSSIPOTF_ERROR
		SignError ("Cannot continue: Error in new DIRECTORY *.", NULL, FALSE);
#endif
		fReturn = E_OUTOFMEMORY;
		goto done;
	}

	//// Read the directory entries.  Set the pointers in ppDirSorted
	//// to be in the (incorrect) order the directories are read.
	numTables = pttfInfo->pOffset->numTables;
	ulOffset = SIZEOF_OFFSET_TABLE;
	pDir = pttfInfo->pDirectory;
	for (i = 0; i < numTables; i++, pDir++, ulOffset += SIZEOF_DIRECTORY) {
		ReadDirectoryEntry (pttfInfo->pFileBufferInfo,
							ulOffset,
							pDir);
		pttfInfo->ppDirSorted[i] = pDir;
	}

	//// Sort the ppDirSorted field of pttfInfo
	SortTablesByOffset (pttfInfo);

	fReturn = S_OK;
done:
	return fReturn;
}


//
// Given a ttf info struct, check that the following hold:
//
// The Offset Table values are correct.
// The tables in the directory are ordered by tag alphabetically.
// The offsets and lengths of the tables form a proper stream
//   of bytes, which means that the tables don't overlap and they
//   are padded with the minimal number of bytes such that the
//   beginning of each table word-aligned.
// The file is long enough to contain all of the tables.
// If the last table ends at byte X, then the file is at most
//   RoundToLongWord(X) bytes long.
// The table checksums are correct.
// The file checksum in the head table is correct.
//
//
// This function assumes that the TTF file is large enough
// to contain an offset table and a number of directories
// specified in the offset table.
//
// This function assumes that pttfInfo->pFileBufferInfo->puchBuffer
// is not necessarily writeable memory (for example, it could be a
// memory-mapped file that has READONLY access).  As a result, to check
// the head table checksum, this function writes the head table
// out to a separate file buffer with the checkSumAdjustment field
// set to zero and then computes the checksum from that buffer.
// For the file checksum, this function computes the checksum without
// setting the checkSumAdjustment field to zero, and then corrects for
// that fact.
//
// Return S_OK if all tests are passed.  Return an error otherwise.
//
HRESULT CheckTTF (TTFInfo *pttfInfo, BOOL fTableChecksum)
{
	HRESULT fReturn = E_FAIL;

	USHORT i;

    OFFSET_TABLE offsetTableCheck;  // used for comparison to the offset table
                                    // in the file
    BYTE zero = 0x00;
    ULONG pad_start;
    ULONG j;

    ULONG ulChecksum;
    CHAR pszTag [5];

    TTFACC_FILEBUFFERINFO *pFileBufferInfoHead = NULL;
    ULONG ulHeadOffset;
    USHORT usBytesMoved;
    HEAD Head;
    DIRECTORY dir;
    ULONG ulHeadChecksumFile;   // head table checksum in the file
    ULONG ulHeadChecksum;       // calculated head table checksum

    ULONG ulHeadcheckSumAdjustment; // the file checksum field in the head table
    ULONG ulFileChecksum;       // calculated file checksum

    if (pttfInfo->pOffset->numTables == 0) {
        // no tables to check
        fReturn = S_OK;
        goto done;
    }

    //// Check that the entries in the offset table
    //// (that is, the sfnt table) are correct, given the
    //// assumption that numTables is correct.
    offsetTableCheck.numTables = pttfInfo->pOffset->numTables;
    CalcOffsetTable (&offsetTableCheck);
// DbgPrintf ("search range: %d %d\n", offsetTableCheck.searchRange, pttfInfo->pOffset->searchRange);
// DbgPrintf ("entry selector: %d %d\n", offsetTableCheck.entrySelector, pttfInfo->pOffset->entrySelector);
// DbgPrintf ("rangeShift: %d %d\n", offsetTableCheck.rangeShift, pttfInfo->pOffset->rangeShift);
    if ((offsetTableCheck.searchRange != pttfInfo->pOffset->searchRange) ||
        (offsetTableCheck.entrySelector != pttfInfo->pOffset->entrySelector) ||
        (offsetTableCheck.rangeShift != pttfInfo->pOffset->rangeShift) ) {

#if MSSIPOTF_ERROR
        DbgPrintf ("Not an OTF: Offset table values incorrect.\n");
#endif
        fReturn = MSSIPOTF_E_BAD_OFFSET_TABLE;
        goto done;
    }

	//// Check that the tags are ordered alphabetically
	for (i = 0; i < pttfInfo->pOffset->numTables - 1; i++) {
		if (pttfInfo->pDirectory[i].tag >= pttfInfo->pDirectory[i+1].tag) {
#if MSSIPOTF_ERROR
			DbgPrintf ("Not an OTF: Tag of table %d out of alphabetical order or duplicate tag.\n", i);
#endif
			fReturn = MSSIPOTF_E_TABLE_TAGORDER;
			goto done;
		}
	}

	//// Check that tables begin on a long-word boundary.
	for (i = 0; i < pttfInfo->pOffset->numTables; i++) {
		if ( (pttfInfo->pDirectory[i].offset % sizeof(LONG)) != 0) {
#if MSSIPOTF_ERROR
			DbgPrintf ("Not an OTF: Table %d offset not long word-aligned.\n", i);
#endif
			fReturn = MSSIPOTF_E_TABLE_LONGWORD;
            goto done;
		}
	}

    //// Check that the first table begins just after the directory
    if (pttfInfo->ppDirSorted[0]->offset != 
            (ULONG) (SIZEOF_OFFSET_TABLE +
            (pttfInfo->pOffset->numTables * SIZEOF_DIRECTORY))) {
#if MSSIPOTF_ERROR
			DbgPrintf ("Not an OTF: First table in the wrong place.\n");
#endif
			fReturn = MSSIPOTF_E_BAD_FIRST_TABLE_PLACEMENT;
			goto done;
    }

	//// If the tables are sorted by offset, then for table i,
	//// Offset[i] + Length[i] <= Offset[i+1] and
	//// Offset[i] + Length[i] >= Offset[i+1] - sizeof(LONG) + 1.
    //// Also, check that the pad bytes are 0x00.
	for (i = 0; i < pttfInfo->pOffset->numTables - 1; i++) {
		if ( (pttfInfo->ppDirSorted[i]->offset + pttfInfo->ppDirSorted[i]->length) >
			pttfInfo->ppDirSorted[i+1]->offset) {
#if MSSIPOTF_ERROR
			DbgPrintf ("Not an OTF: Tables %d and %d overlap.\n", i , i+1);
#endif
			fReturn = MSSIPOTF_E_TABLES_OVERLAP;
			goto done;
		}
		if ( (pttfInfo->ppDirSorted[i]->offset + pttfInfo->ppDirSorted[i]->length) <
			(pttfInfo->ppDirSorted[i+1]->offset - sizeof(LONG) + 1) ) {
#if MSSIPOTF_ERROR
			DbgPrintf ("Not an OTF: Too much padding at the end of table %d.\n", i);
#endif
			fReturn = MSSIPOTF_E_TABLE_PADBYTES;
			goto done;
		}

        pad_start = pttfInfo->ppDirSorted[i]->offset + pttfInfo->ppDirSorted[i]->length;
        j = pad_start;
        // make sure we don't try to read beyond the end of the buffer
        if (RoundToLongWord(pad_start) > pttfInfo->pFileBufferInfo->ulBufferSize) {
#if MSSIPOTF_ERROR
            DbgPrintf ("Not an OTF: File not large enough to contain all tables.\n", i);
#endif
            fReturn = MSSIPOTF_E_FILETOOSMALL;
            goto done;
        }
        for ( ; j < RoundToLongWord (pad_start); j++) {
            if (memcmp (pttfInfo->pFileBufferInfo->puchBuffer + j, &zero, 1)) {
#if MSSIPOTF_ERROR
                DbgPrintf ("Not an OTF: Bad gap bytes at the end of table %d.\n", i);
#endif
                fReturn = MSSIPOTF_E_TABLE_PADBYTES;
                goto done;
            }
        }
	}

	// ASSERT: i now equals numTables - 1
	//// Check that the file is large enough to contain the last table.
	if ( (pttfInfo->ppDirSorted[i]->offset + pttfInfo->ppDirSorted[i]->length) >
		    pttfInfo->pFileBufferInfo->ulBufferSize) {
#if MSSIPOTF_ERROR
		DbgPrintf ("Not an OTF: File not large enough to contain all tables.\n");
#endif
		fReturn = MSSIPOTF_E_FILETOOSMALL;
		goto done;
	}

	if ( RoundToLongWord(pttfInfo->ppDirSorted[i]->offset +
                         pttfInfo->ppDirSorted[i]->length) <
            pttfInfo->pFileBufferInfo->ulBufferSize) {
#if MSSIPOTF_ERROR
		DbgPrintf ("Not an OTF: Too much padding at the end of table %d.\n", i);
#endif
		fReturn = MSSIPOTF_E_TABLE_PADBYTES;
		goto done;
	}

    // Check the pad bytes of the last table.
    // Note that the pad bytes after the last table might not
    // end on a long word boundary (whereas in all previous
    // tables, the pad bytes pad to a long word boundary).
    pad_start = pttfInfo->ppDirSorted[i]->offset + pttfInfo->ppDirSorted[i]->length;
    j = pad_start;
    for ( ; (j < RoundToLongWord (pad_start)) &&
            (j < pttfInfo->pFileBufferInfo->ulBufferSize); j++) {
        if (memcmp (pttfInfo->pFileBufferInfo->puchBuffer + j, &zero, 1)) {
#if MSSIPOTF_ERROR
            DbgPrintf ("Not an OTF: Bad gap bytes at the end of table %d.\n", i);
#endif
            fReturn = MSSIPOTF_E_TABLE_PADBYTES;
            goto done;
        }
    }

    ////
    //// Check that the checksums for all of the tables are correct.
    ////

    if (fTableChecksum) {
        //// Check the non-head table checksums.
	    for (i = 0; i < pttfInfo->pOffset->numTables; i++) {
            ConvertLongTagToString (pttfInfo->pDirectory[i].tag, pszTag);
		    TTTableChecksum (pttfInfo->pFileBufferInfo,
                            pszTag,
                            &ulChecksum);
            if ((ulChecksum != pttfInfo->pDirectory[i].checkSum) &&
                (pttfInfo->pDirectory[i].tag != HEAD_LONG_TAG)) {
#if MSSIPOTF_ERROR
			    DbgPrintf ("Not an OTF: Checksum of table %d does not match.\n", i);
#endif
#if MSSIPOTF_DBG
                DbgPrintf ("Table no. %d, calc cs = %x, file cs = %x.\n",
                    i, ulChecksum, pttfInfo->pDirectory[i].checkSum);
#endif
			    fReturn = MSSIPOTF_E_TABLE_CHECKSUM;
			    goto done;
		    }
	    }
    }

    //// Get the file checksum field in the head table.
    //// If we need to, check the head table checksum.

    // Create and initialize a new buffer that contains the head table only.
    if ((pFileBufferInfoHead = new TTFACC_FILEBUFFERINFO) == NULL) {
#if MSSIPOTF_ERROR
        SignError ("Cannot continue: Error in new TTFACC_FILEBUFFERINFO.", NULL, FALSE);
#endif
        fReturn = E_OUTOFMEMORY;
        goto done;
    }

    if ((pFileBufferInfoHead->puchBuffer =
            new BYTE [RoundToLongWord(SIZEOF_HEAD)]) == NULL) {
#if MSSIPOTF_ERROR
        SignError ("Cannot continue: Error in new BYTE.", NULL, FALSE);
#endif
        fReturn = E_OUTOFMEMORY;
        goto done;
    }
    memset (pFileBufferInfoHead->puchBuffer, 0x00, RoundToLongWord(SIZEOF_HEAD));
    pFileBufferInfoHead->ulBufferSize = RoundToLongWord(SIZEOF_HEAD);
    pFileBufferInfoHead->ulOffsetTableOffset = 0;   // not used in this function
    pFileBufferInfoHead->lpfnReAllocate = NULL;

	ulHeadOffset =  TTTableOffset (pttfInfo->pFileBufferInfo, HEAD_TAG );
    if ( ulHeadOffset == 0L ) {
#if MSSIPOTF_ERROR
        DbgPrintf ("Not an OTF: No head table.\n");
#endif
		fReturn = MSSIPOTF_E_NOHEADTABLE;
        goto done;
    }
	if (ReadGeneric (pttfInfo->pFileBufferInfo, (uint8 *) &Head,
            SIZEOF_HEAD, HEAD_CONTROL, ulHeadOffset, &usBytesMoved) != NO_ERROR) {
#if MSSIPOTF_DBG
        DbgPrintf ("Error reading head table.\n");
#endif
        fReturn = MSSIPOTF_E_NOHEADTABLE;
		goto done;
    }

    // we need this value when we check the file checksum
    ulHeadcheckSumAdjustment = Head.checkSumAdjustment;

    if (fTableChecksum) {
	    Head.checkSumAdjustment = 0L;
        if (WriteGeneric(pFileBufferInfoHead, (uint8 *) &Head,
                SIZEOF_HEAD, HEAD_CONTROL, 0, &usBytesMoved) != NO_ERROR) {
#if MSSIPOTF_DBG
            DbgPrintf ("Error writing head table.\n");
#endif
		    fReturn = MSSIPOTF_E_FILE;
            goto done;
        }
        assert (usBytesMoved == SIZEOF_HEAD);

        // ASSERT: pFileBufferInfoHead now contains the head table with
        // the file checksum (checkSumAdjustment) field zeroed out.

        // Calculate the checksum of the head table (from the new buffer).
        CalcChecksum (pFileBufferInfoHead, 0,
            RoundToLongWord (SIZEOF_HEAD), &ulHeadChecksum);

        // Get the checksum that is in the head table's directory entry
        ConvertLongTagToString (HEAD_LONG_TAG, pszTag);
        GetTTDirectory (pttfInfo->pFileBufferInfo, pszTag, &dir);
        ulHeadChecksumFile = dir.checkSum;

        // Compare the head table's calculated checksum with the checksum in the file
        if (ulHeadChecksum != ulHeadChecksumFile) {
#if MSSIPOTF_ERROR
            DbgPrintf ("Not an OTF: head table checksum does not match.\n");
#endif
//		DbgPrintf ("calc = 0x%x ; file = 0x%x.\n", ulHeadChecksum, ulHeadChecksumFile);
            fReturn = MSSIPOTF_E_TABLE_CHECKSUM;
            goto done;
        }
    }

    //// Check that the file checksum is correct.

    // We assume here that the table checksums are correct, and
    // so the file checksum = checksum(Offset Table) +
    // checksum(DirEntries) + sum of checksum(table.checksum).

    // Offset Table and Directory Entries
    if (CalcChecksum (pttfInfo->pFileBufferInfo, 0,
            SIZEOF_OFFSET_TABLE + (SIZEOF_DIRECTORY * pttfInfo->pOffset->numTables),
            &ulFileChecksum) != NO_ERROR) {
#if MSSIPOTF_ERROR
        SignError ("Error calculating checksum.", NULL, FALSE);
#endif
        fReturn = MSSIPOTF_E_FILE;
        goto done;
    }

    // table checksums from the Directory Entries
	for (i = 0; i < pttfInfo->pOffset->numTables; i++) {
        ulFileChecksum += pttfInfo->ppDirSorted[i]->checkSum;
    }

/*
    // Calculate the file's checksum.  Note that CalcFileChecksum
    // does NOT zero out the checkSumAdjustment field in the head
    // table, which means that if the checkSumAdjustment field is
    // correct, then CalcFileChecksum will return 0xB1B0AFBA.
    ulFileChecksum = CalcFileChecksum (pttfInfo->pFileBufferInfo,
                                       pttfInfo->pFileBufferInfo->ulBufferSize);

  // Verify the correctness of the checksum.
    if (ulFileChecksum != 0xB1B0AFBA) {
        DbgPrintf ("Not an OTF: File checksum is not correct.\n");
        fReturn = SIGN_STRUCTURE;
        goto done;
    }
*/

    // Verify the correctness of the checksum.
    if ((ulHeadcheckSumAdjustment + ulFileChecksum) != 0xB1B0AFBA) {
#if MSSIPOTF_ERROR
        DbgPrintf ("Not an OTF: File checksum is not correct.\n");
#endif
        fReturn = MSSIPOTF_E_FILE_CHECKSUM;
        goto done;
    }

    //// BUGBUG: Check that the cmap does not contain a character that is
	//// mapped to more than one glyph.  (To be implemented.)

	// passed all tests
	fReturn = S_OK;
done:

    // Free the temporary buffer that contained the modified head table.
    if (pFileBufferInfoHead) {
        delete [] pFileBufferInfoHead->puchBuffer;
    }
    delete pFileBufferInfoHead;

	return fReturn;
}


//
// InitTTFStructures
//
// Given a TTF file, return a TTFInfo structure and DsigTable
//   structure for that file.  This function allocates the memory
//   for these structures.
// This functions assumes that the file has passed the IsTTFFile test.
// BUGBUG: Is this last assumption really necessary?  If not, then
// the GetSignedDataMsg does not need to do the full structural checks.
// CLAIM: we don't need the assumption.
//
HRESULT InitTTFStructures (BYTE *pbFile,
					   ULONG cbFile,
					   TTFInfo **ppTTFInfo,
					   CDsigTable **ppDsigTable)
{
	HRESULT fReturn = E_FAIL;

    DIRECTORY dir;
	ULONG ulOffset;  // needed for the call to CDsigTable::Read
    ULONG ulLength;  // needed for the call to CDsigTable::Read

	// Allocate memory for the TTFInfo structure
	if ((*ppTTFInfo = new TTFInfo) == NULL) {
#if MSSIPOTF_ERROR
		SignError ("Cannot continue: Error in new TTFInfo.", NULL, FALSE);
#endif
		fReturn = E_OUTOFMEMORY;
		goto done;
	}

    // Initialize TTFInfo pointers to NULL
    (*ppTTFInfo)->pFileBufferInfo = NULL;
    (*ppTTFInfo)->pOffset = NULL;
    (*ppTTFInfo)->pDirectory = NULL;
    (*ppTTFInfo)->ppDirSorted = NULL;

	// Set the TTFInfo structure of the old file
	if ((fReturn = GetTTFInfo (pbFile, cbFile, *ppTTFInfo)) != NO_ERROR) {
#if MSSIPOTF_ERROR
		SignError ("Cannot continue: Error in GetTTFInfo.", NULL, FALSE);
#endif
		goto done;
	}

	// allocate memory for a dsigTable
	if ((*ppDsigTable = new CDsigTable) == NULL) {
#if MSSIPOTF_ERROR
		SignError ("Cannot continue: Error in new CDsigTable.", NULL, FALSE);
#endif
		fReturn = E_OUTOFMEMORY;
		goto done;
	}

    // Find the offset of the DSIG table in the TTF file
    if (GetTTDirectory ((*ppTTFInfo)->pFileBufferInfo,
                        DSIG_TAG,
                        &dir) == DIRECTORY_ERROR) {
#if MSSIPOTF_DBG
		DbgPrintf ("No DSIG table to read.  Creating default DsigTable.\n");
#endif
        fReturn = S_OK;
        goto done;
    }
    ulOffset = dir.offset;
    ulLength = dir.length;

	// Extract the DSIG table from the old file
    if ((fReturn = (*ppDsigTable)->Read ((*ppTTFInfo)->pFileBufferInfo,
										 &ulOffset, ulLength)) != NO_ERROR) {
#if MSSIPOTF_DBG
		DbgPrintf ("Error in DsigTable::Read.\n");
#endif
		goto done;
    }

	fReturn = S_OK;

done:
	return fReturn;
}


//
// Given an old file and all the information necessary to construct
// the DSIG table, write the resulting TTF file to a new file.
//
HRESULT WriteNewFile (TTFInfo *pttfInfoOld,
                      CDsigTable *pDsigTable,
                      HANDLE hNewFile)
{
	HRESULT fReturn = E_FAIL;

	OFFSET_TABLE offTableNew;
	DIRECTORY *pDirNew = NULL;
	TTFACC_FILEBUFFERINFO *pOutputFileBufferInfo;
	HANDLE hMapNewFile = NULL;
	BYTE *pNewFile = NULL;

	// These variables are strictly for the debug output
#if MSSIPOTF_DBG
	OFFSET_TABLE offTableTest;
	ULONG ulOffsetTest;
	DIRECTORY dirTest;
	USHORT i;
#endif

	int fDsig;	// fDsig == 1 if the old file does have a DSIG table
				// fDsig == 0 if the old file does NOT have a DSIG table
	USHORT numTablesNew;

	ULONG ulNewFileSize;
	ULONG ulOffset;
	ULONG ulDsigOffset;

	//// Compute the number of tables in the new file.
	// Determine if there is a DSIG table in the old file.
	// We assume that TTDirectoryEntryOffset will not return
	//   DIRECTORY_ENTRY_OFFSET_ERROR.  That is, we assume
	//   the function was called previously and the offset
	//   table was okay.  If it returns DIRECTORY_ERROR, then
	//   there was no DSIG table in the old file.
	fDsig =
		(TTDirectoryEntryOffset (pttfInfoOld->pFileBufferInfo, DSIG_TAG) ==
		DIRECTORY_ERROR) ? 0 : 1;
	numTablesNew = pttfInfoOld->pOffset->numTables + (1 - fDsig);

	//// Set up the offset table of the new file
	offTableNew.version = pttfInfoOld->pOffset->version;
	offTableNew.numTables = numTablesNew;

    // Compute the offset table values
    CalcOffsetTable (&offTableNew);
	
	//// We now have all of the information needed to calculate
	//// exactly how long the new file will be, which allows
	//// us to allocate exactly the right amount of memory when
	//// we map the new file to memory.

	// Map the new file to memory.
	if ((fReturn = GetNewTTFFileSize (pttfInfoOld,
							offTableNew.numTables,
							pDsigTable,
							&ulNewFileSize)) != NO_ERROR) {
#if MSSIPOTF_ERROR
		SignError ("Cannot continue: Error in GetNewTTFFileSize.", NULL, FALSE);
#endif
		goto done;
	}

	if (MapFile (hNewFile, &hMapNewFile, &pNewFile, &ulNewFileSize,
			PAGE_READWRITE, FILE_MAP_WRITE) != NO_ERROR) {
#if MSSIPOTF_DBG
		DbgPrintf ("Error in MapFile.\n");
#endif
        fReturn = MSSIPOTF_E_FILE;
		goto done;
	}

	// Allocate memory for the file buffer info structure
	if ((pOutputFileBufferInfo =
		(TTFACC_FILEBUFFERINFO *) malloc (sizeof (TTFACC_FILEBUFFERINFO))) == NULL) {
#if MSSIPOTF_ERROR
		SignError ("Cannot continue: Error in malloc.", NULL, FALSE);
#endif
		fReturn = E_OUTOFMEMORY;
		goto done;
	}

	// Set the fields of the TTFACC_FILEBUFFERINFO structure.
	pOutputFileBufferInfo->puchBuffer = pNewFile;
	pOutputFileBufferInfo->ulBufferSize = ulNewFileSize;
	pOutputFileBufferInfo->ulOffsetTableOffset = 0;
	pOutputFileBufferInfo->lpfnReAllocate = &NullRealloc;

	//// Write the new offset table to the new file.
	WriteOffsetTable (&offTableNew, pOutputFileBufferInfo);

	//// We are now ready to copy the non-DSIG tables from the
	//// old file to the new file.

	//// Copy all non-DSIG tables (with the correct directory entries)
	//// to the new file.
	WriteNonDsigTables (pttfInfoOld, numTablesNew, ADD_DSIG_TABLE, pOutputFileBufferInfo, &ulOffset);

	//// At this point, here is the status:
	//// The offset table: correctly written to the new file
	//// The directory entries: space written to the new file and all
	////   directory entries are correct, except for the data in the DSIG entry.
	//// All non-DSIG tables: correctly written to the new file, except the
	////   file checksum (in head table).
	////
	//// We now need to write the DSIG table and correct
	//// the data in its directory entry.
	ulDsigOffset = ulOffset;  // we need this for when we call WriteDirEntry
	if ((fReturn = pDsigTable->Write (pOutputFileBufferInfo, &ulOffset)) != NO_ERROR) {
#if MSSIPOTF_DBG
		DbgPrintf ("Error in CDsigTable::Write.\n");
#endif
		goto done;
	}
	assert (ulNewFileSize == ulOffset);

	//// Correct the data in the DSIG table's directory entry (including
	//// the checksum field).
	if ((fReturn = pDsigTable->WriteDirEntry (pOutputFileBufferInfo, ulDsigOffset)) != NO_ERROR) {
#if MSSIPOTF_DBG
		DbgPrintf ("Error in CDsigTable::WriteDirEntry.\n");
#endif
		goto done;
	}

	//// All that is left now to do is the checksum for the entire file.
	// Note: The modify date should NOT be changed.  The modify date
    // refers to the date the "design" of the font changed (not the
    // the binary image has changed).

	//// Recompute the head table checksum for the entire file
	//// (ulOffset was returned by WriteDsigTable and is the length of the file)
    SetFileChecksum (pOutputFileBufferInfo, ulOffset);

#if (DEBUG_TTFINFO == 1)
#if MSSIPOTF_DBG
	// for diagnostic purposes only ...
	ReadOffsetTable (pOutputFileBufferInfo, &offTableTest);
	PrintOffsetTable (&offTableTest);
	ulOffsetTest = SIZEOF_OFFSET_TABLE;
	PrintDirectoryHeading ();
	for (i = 0; i < offTableTest.numTables; i++, ulOffsetTest += SIZEOF_DIRECTORY) {
		ReadDirectoryEntry (pOutputFileBufferInfo, ulOffsetTest, &dirTest);
		DbgPrintf ("%d:\t", i);
		PrintDirectoryEntry(&dirTest);
	}
#endif
#endif

	fReturn = S_OK;

done:
	// Free resources
    if (pOutputFileBufferInfo)
		FreeFileBufferInfo (pOutputFileBufferInfo);

    UnmapFile (hMapNewFile, pNewFile);

    return fReturn;
}


//
// Copy all non-DSIG tables to the new file in order of
// their offsets in the old file.
// Return in ulOffset the position of the end of the new file
// (so that the DSIG table can be written starting at that offset).
//
// fAddDsig indicates whether the new buffer contains a DSIG table.
// If fAddDsig == ADD_DSIG_TABLE, then a DSIG table is expected to
//   be added if doesn't already exist.
// If fAddDsig == KEEP_DSIG_TABLE, then a DSIG table will be in the
//   new buffer exactly if the old one had a DSIG table.
// If fAddDsig == DELETE_DSIG_TABLE, then no DSIG table will be in
//   the new buffer.
//
// Upon return, all of the directory entries in the table of
// directories of the new file are correct, except for the non-tag
// fields of the DSIG directory entry.  All table contents are
// correct, except for the file checksum in the head table.
//
HRESULT WriteNonDsigTables (TTFInfo *pttfInfoOld,
                            USHORT numTablesNew,
                            SHORT fAddDsig,
                            TTFACC_FILEBUFFERINFO *pOutputFileBufferInfo,
                            ULONG *pulOffset)
{
	USHORT i;
	USHORT iNew;
	CHAR pszTag[5];	// used for a directory entry tag

	USHORT numTablesOld;
	DIRECTORY **ppDirSortedOld;

	ULONG ulDirOffset;		// offset pointing to where the next directory entry should go
	ULONG ulTableOffset;	// offset pointing to where the next table should go
	DIRECTORY dirNew;

	BOOL fDsig = FALSE;		// is there a DSIG table in the old file?

	ulDirOffset = SIZEOF_OFFSET_TABLE;


	fDsig =
		(TTDirectoryEntryOffset (pttfInfoOld->pFileBufferInfo, DSIG_TAG) ==
		DIRECTORY_ERROR) ? FALSE : TRUE;

	//// Zero out the directory entry area of the new file.
	dirNew.tag = 0;
	dirNew.checkSum = 0;
	dirNew.offset = 0;
	dirNew.length = 0;
	for (i = 0; i < numTablesNew; i++, ulDirOffset += SIZEOF_DIRECTORY) {
		WriteDirectoryEntry (&dirNew, pOutputFileBufferInfo, ulDirOffset);
	}

	//// For each table in the directory of the old TTF file
	//// other than the DSIG table, copy the table's contents
	//// (not the directory entry) to the new TTF file in the
	//// order they appear in the old file.

	ppDirSortedOld = pttfInfoOld->ppDirSorted;
    // Copy all non-DSIG tables (in order of their offsets in
	// the old file) from the old file to the new file.
	// Also, update these new directory entries.
	numTablesOld = pttfInfoOld->pOffset->numTables;
	ulTableOffset = SIZEOF_OFFSET_TABLE + numTablesNew * SIZEOF_DIRECTORY;
	assert ((ulTableOffset % 4) == 0);  // check that we are word-aligned

	for (i = 0; i < numTablesOld; i++) {

		if (ppDirSortedOld[i]->tag != DSIG_LONG_TAG) {

			dirNew.tag = ppDirSortedOld[i]->tag;
			dirNew.checkSum = ppDirSortedOld[i]->checkSum;	// the checksum should be correct
			dirNew.offset = ulTableOffset;
			dirNew.length = ppDirSortedOld[i]->length;

			// Write the new directory entry to the new file
			// NOTE: "unusual" (not usual for dchinn) pointer arithmetic
			iNew = (USHORT)((ULONG_PTR) (ppDirSortedOld[i] - pttfInfoOld->pDirectory));
			// Adjust iNew if the DSIG table existed in the old file
			if (fDsig &&
					(fAddDsig == DELETE_DSIG_TABLE) &&
					(dirNew.tag > DSIG_LONG_TAG)) {
				iNew--;
			}
			ulDirOffset = SIZEOF_OFFSET_TABLE + iNew * SIZEOF_DIRECTORY;

			WriteDirectoryEntry (&dirNew, pOutputFileBufferInfo, ulDirOffset);

			// copy the table from the old file to the new file
			ConvertLongTagToString(ppDirSortedOld[i]->tag, pszTag);
			if (CopyTableOver (pOutputFileBufferInfo,
							   (CONST_TTFACC_FILEBUFFERINFO *) pttfInfoOld->pFileBufferInfo,
							   pszTag,
							   &ulTableOffset) == ERR_FORMAT) {
#if MSSIPOTF_DBG
				DbgPrintf ("Error in CopyTableOver.", NULL, FALSE);
#endif
				return MSSIPOTF_E_FILE;
			} else {
				ulTableOffset += ZeroLongWordAlign (pOutputFileBufferInfo, ulTableOffset);
			}
//          DbgPrintf ("Copied table 0x%x\n", ppDirSortedOld[i]->tag);
//          DbgPrintf ("new offset = 0x%x\n", ulTableOffset);

			assert ((ulTableOffset % sizeof(LONG)) == 0);  // check that we are word-aligned
		} else {

			// Enter the DSIG table entry in the directory if the table
			// is not being deleted
			if (fAddDsig != DELETE_DSIG_TABLE) {
				iNew = (USHORT) ((ULONG_PTR)(ppDirSortedOld[i] - pttfInfoOld->pDirectory));
				ulDirOffset = SIZEOF_OFFSET_TABLE + iNew * SIZEOF_DIRECTORY;

				dirNew.tag = ppDirSortedOld[i]->tag;
				dirNew.checkSum = 0;	// the checksum should be correct
				dirNew.offset = 0;
				dirNew.length = 0;
				WriteDirectoryEntry (&dirNew, pOutputFileBufferInfo, ulDirOffset);
			}
		}
	}

	//// At this point, the new directory has all of the old entries.
	//// If there was no DSIG table in the old file, then there is
	//// an empty entry at the end of the directory.
	//// If this is the case, shift the entries in the directory so that
	//// they are all in alphabetical order by tag.
	if ((fAddDsig == ADD_DSIG_TABLE) && !fDsig) {
		if (numTablesNew >= 2) {
			ShiftDirectory (pOutputFileBufferInfo, numTablesNew, DSIG_LONG_TAG);
		}
	} 
	
	*pulOffset = ulTableOffset;
	return S_OK;
}


//
// Compute the size of a new TTF file, given:
//   the number of tables in the new file,
//   the old TTF file (to get the sizes of all
//     of the non-DSIG tables)
//   a dsigInfo structure, and
//   the size of the signature.
//
HRESULT GetNewTTFFileSize (TTFInfo *pttfInfoOld,
                           USHORT numTablesNew,
                           CDsigTable *pDsigTable,
                           ULONG *pulFileSize)
{
    HRESULT fReturn = E_FAIL;

	DIRECTORY *pDir;
	USHORT numTablesOld;
	USHORT i;

	ULONG ulDsigTableSize;


	// Add in the size of the offset table and
	// the size of the directory entries.
	*pulFileSize = SIZEOF_OFFSET_TABLE + numTablesNew * SIZEOF_DIRECTORY;

	// Run through each non-DSIG table in the old file and
	// add the size of each table.
	numTablesOld = pttfInfoOld->pOffset->numTables;
	pDir = pttfInfoOld->pDirectory;
	for (i = 0; i < numTablesOld; pDir++, i++) {
		if (pDir->tag != DSIG_LONG_TAG) {
			*pulFileSize += RoundToLongWord(pDir->length);
		}
	}
//	cout << "Beginning of new DSIG table = " << dec << *pulFileSize << endl;

	if ((fReturn = pDsigTable->GetSize (&ulDsigTableSize))
			!= NO_ERROR) {
#if MSSIPOTF_DBG
		DbgPrintf ("Error in GetDsigTableSize.\n");
#endif
		goto done;
	}
	*pulFileSize += ulDsigTableSize;

//	cout << "New file size = " << dec << *pulFileSize << endl;

	fReturn = S_OK;

done:
	return fReturn;
}
=== C:/Users/treeman/Desktop/windows nt source code\Source\XPSP1\NT\windows\core\ntgdi\fondrv\tt\mssipotf\sign\ttcinfo.cpp ===
//
// ttcinfo.cpp
//
// (c) 1997-1998. Microsoft Corporation.
// Author: Donald Chinn
//
// Routines for high-level TTC file operations.
//
// Functions in this file:
//
//   IsTTCFile_handle
//   IsTTCFile_memptr
//   IsTTCFile
//   GetTTCInfo
//   PrintTTCHeader
//   PrintTTCBlocks
//   FreeTTCInfo
//   InitTTCStructures
//   BlockOffsetCmp
//   SortTTCBlocksByOffset
//   BlockEqual
//   CompressTTCBlocks
//   ReadTTCHeaderTable
//   WriteTTCHeaderTable
//


#include <stdlib.h>
#include <search.h>

#include "ttcinfo.h"
#include "ttfinfo.h"
#include "utilsign.h"
#include "cryptutil.h"
#include "signerr.h"


// IsTTCFile_handle returns TRUE if and only if the given file handle
// has the structure of a TrueType font file.
BOOL IsTTCFile_handle (HANDLE hFile,
                       BOOL fTableChecksum,
                       HRESULT *phrError)
{
	BOOL rv = FALSE;
	CFileObj *pFileObj = NULL;


    *phrError = E_FAIL;

    if ((pFileObj =
            (CFileObj *) new CFileHandle (hFile, FALSE)) == NULL) {
#if MSSIPOTF_ERROR
		SignError ("Cannot continue: Error in new CFileHandle.", NULL, FALSE);
#endif
        *phrError = E_OUTOFMEMORY;
        goto done;
    }

	if ((*phrError = pFileObj->MapFile (0, PAGE_READONLY, FILE_MAP_READ))
            != S_OK) {
#if MSSIPOTF_DBG
		DbgPrintf ("Error in MapFile.\n");
#endif
		goto done;
	}

	rv = IsTTCFile (pFileObj, fTableChecksum, phrError);

done:
	delete pFileObj;

    if (pFileObj) {
        pFileObj->UnmapFile();
    }

	return rv;
}


// IsTTCFile_memptr returns TRUE if and only if the given memory pointer
// points to a block of memory that has the structure of a
// TrueType Collection font file.
BOOL IsTTCFile_memptr (BYTE *pbMemPtr,
                       ULONG cbMemPtr,
                       BOOL fTableChecksum,
                       HRESULT *phrError)
{
	BOOL rv = FALSE;
	CFileObj *pFileObj = NULL;

    *phrError = E_FAIL;

    if ((pFileObj =
            (CFileObj *) new CFileMemPtr (pbMemPtr, cbMemPtr)) == NULL) {
#if MSSIPOTF_ERROR
		SignError ("Cannot continue: Error in new CFileMemPtr.", NULL, FALSE);
#endif
        *phrError = E_OUTOFMEMORY;
        goto done;
    }

	rv = IsTTCFile (pFileObj, fTableChecksum, phrError);

done:
	delete pFileObj;

	return rv;
}


// Return TRUE if and only if the given file is a TTC file.
// A file is a TTC file if it has the following properties:
//   1. The first block begins just after the TTC header.
//   2. All of the tables in all of the blocks are on long word boundaries
//        and packed (no more than 3 pad bytes).  Also, check that the
//        pad bytes are 0x00.
//   3. The checksums of all tables are correct.
//   4. The file is large enough to contain the last block.
//   5. The last block's gap bytes are OK.
//
//  The table checksums are checked if and only if fTableChecksum is TRUE.
//
BOOL IsTTCFile (CFileObj *pFileObj,
                BOOL fTableChecksum,
                HRESULT *phrError)
{
    BOOL rv = FALSE;
    TTCInfo *pTTCInfo = NULL;
    ULONG i, j;
    BYTE zero = 0x00;

    ULONG ulChecksum;
    ULONG pad_start;

    TTFACC_FILEBUFFERINFO *pFileBufferInfoHead = NULL;
    HEAD Head;

    *phrError = E_FAIL;

    if ((pTTCInfo = new TTCInfo) == NULL) {
#if MSSIPOTF_DBG
		DbgPrintf ("Error in new TTCInfo.\n");
#endif
        *phrError = E_OUTOFMEMORY;
		goto done;
	}

    // Initialize TTCInfo pointers to NULL
    pTTCInfo->pFileBufferInfo = NULL;
    pTTCInfo->pHeader = NULL;
    pTTCInfo->pulOffsetTables = NULL;
    pTTCInfo->ppBlockSorted = NULL;
    pTTCInfo->pBlocks = NULL;

    //// Create and initialize a new buffer that contains the head table only.
    //// These data structures are used when we check the checksum of any
    //// head tables we encounter (Check #3).
    if ((pFileBufferInfoHead = new TTFACC_FILEBUFFERINFO) == NULL) {
#if MSSIPOTF_ERROR
        SignError ("Cannot continue: Error in new TTFACC_FILEBUFFERINFO.", NULL, FALSE);
#endif
        *phrError = E_OUTOFMEMORY;
        goto done;
    }

    if ((pFileBufferInfoHead->puchBuffer =
            new BYTE [RoundToLongWord(SIZEOF_HEAD)]) == NULL) {
#if MSSIPOTF_ERROR
        SignError ("Cannot continue: Error in new BYTE.", NULL, FALSE);
#endif
        *phrError = E_OUTOFMEMORY;
        goto done;
    }


    if ((*phrError = GetTTCInfo (pFileObj->GetFileObjPtr(),
                                 pFileObj->GetFileObjSize(),
                                 pTTCInfo)) != S_OK) {
#if MSSIPOTF_DBG
		DbgPrintf ("Error in GetTTCInfo.\n");
#endif
		goto done;
	}

    // ASSERT: at this point, pTTCInfo->ulNumBlocks is the
    // number of blocks in the TTC.  They are distinct blocks
    // and are sorted by offset.

#if MSSIPOTF_DBG
    PrintTTCHeader (pTTCInfo->pHeader);
//    PrintTTCBlocks (pTTCInfo);
#endif

    // Check #1
    if (pTTCInfo->ulNumBlocks > 0) {
        if ((pTTCInfo->pHeader->ulVersion == TTC_VERSION_1_0) &&
            (pTTCInfo->pHeader->ulDsigTag != DSIG_LONG_TAG)) {

            if (pTTCInfo->ppBlockSorted[0]->ulOffset !=
                (SIZEOF_TTC_HEADER_TABLE_1_0 +
                pTTCInfo->pHeader->ul